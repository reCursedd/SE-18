Is that the right way to do it?
(2 (2 (2 (2 Is) (2 that)) (3 (2 (2 the) (3 (3 right) (2 way))) (2 (2 to) (2 (2 do) (2 it))))) (2 ?))
It would be good to know, so that we don't use something that will be disallowed in the future.
(1 (2 It) (2 (2 (2 would) (3 (3 (3 (2 be) (3 (3 good) (2 (2 to) (2 know)))) (2 ,)) (2 (2 so) (2 (2 that) (2 (2 we) (1 (2 (2 do) (2 n't)) (2 (2 use) (3 (2 something) (2 (2 that) (2 (2 will) (2 (2 be) (2 (2 disallowed) (2 (2 in) (2 (2 the) (2 future))))))))))))))) (2 .)))
Conversely, this compile fine but *should* be an error:.
(1 (2 Conversely) (1 (2 ,) (1 (3 (3 (2 this) (3 (2 compile) (3 fine))) (2 (2 but) (2 *))) (1 (1 (1 (2 (2 should) (2 *)) (1 (2 be) (1 (2 an) (1 error)))) (2 :)) (2 .)))))
I couldn’t but it doesn’t.
(1 (1 (2 (2 (2 I) (1 (2 could) (2 n't))) (2 but)) (2 (2 it) (1 (2 does) (2 n't)))) (2 .))
And the compiler should know that.
(1 (2 And) (2 (2 (2 the) (2 compiler)) (2 (2 (2 should) (2 (2 know) (2 that))) (2 .))))
It’s all in the same crate, a re-export can not be added without recompiling that crate.
(1 (2 (2 It) (2 (2 's) (2 (2 all) (2 (2 in) (2 (2 the) (2 (2 same) (2 crate))))))) (1 (2 ,) (1 (2 (2 a) (2 re-export)) (1 (1 (2 (2 can) (1 not)) (2 (2 be) (3 (2 added) (2 (2 without) (2 (2 recompiling) (2 (2 that) (2 crate))))))) (2 .)))))
Nah, the compiler still tracks reachability through reexports for other purposes.
(1 (2 Nah) (1 (2 ,) (1 (2 (2 the) (2 compiler)) (1 (2 still) (1 (2 (2 (2 tracks) (2 reachability)) (2 (2 through) (2 (2 reexports) (2 (2 for) (2 (2 other) (2 purposes)))))) (2 .))))))
@petrochenkov So you're saying it isn't even an improvement at all and we're just breaking the world to satisfy some RFC that has been sitting around for over a year?
(1 (2 (2 @petrochenkov) (2 So)) (1 (2 you) (1 (1 (2 're) (1 (2 saying) (1 (1 (1 (2 it) (1 (2 (1 (2 is) (2 n't)) (2 even)) (2 (3 (2 an) (3 improvement)) (2 (2 at) (2 all))))) (2 and)) (1 (2 we) (1 (2 (2 're) (2 just)) (1 (2 breaking) (1 (2 the) (2 (2 world) (1 (2 to) (1 (3 satisfy) (1 (2 (2 some) (2 RFC)) (1 (2 that) (2 (2 has) (1 (2 been) (2 (2 (2 sitting) (2 around)) (2 (2 for) (2 (2 over) (2 (2 a) (2 year))))))))))))))))))) (2 ?))))
see #22261 for the discussion, the point is that the privacy checks don't need to reason about the entire crate, but just about the module.
(1 (2 (2 see) (2 (2 (2 #) (2 22261)) (2 (2 for) (2 (2 the) (2 discussion))))) (1 (2 ,) (1 (2 (2 the) (2 point)) (1 (1 (2 is) (2 (2 that) (2 (2 (2 the) (2 (2 privacy) (2 checks))) (2 (2 (2 do) (2 n't)) (2 (2 need) (2 (2 (2 (2 (2 (2 to) (2 (2 reason) (2 (2 about) (2 (2 the) (2 (2 entire) (2 crate)))))) (2 ,)) (2 but)) (2 just)) (2 (2 about) (2 (2 the) (2 module))))))))) (2 .)))))
@retep998 I'd actually be interested to see the specific cases that are failing for you.
(1 (2 (2 @retep998) (2 I)) (1 (2 (2 (2 'd) (2 actually)) (2 (2 be) (2 (3 interested) (1 (2 to) (1 (2 see) (1 (2 (2 the) (2 (2 specific) (2 cases))) (1 (2 that) (1 (2 are) (1 (1 failing) (2 (2 for) (2 you))))))))))) (2 .)))
In particular, I'd like to know if they fall into the category of type aliases that appear in public interfaces, or something else?
(1 (2 (2 In) (2 particular)) (2 (2 ,) (2 (2 I) (1 (2 (2 'd) (2 (2 like) (2 (2 to) (2 (2 know) (2 (2 (2 (2 (2 if) (2 (2 they) (2 (2 fall) (2 (2 into) (2 (2 (2 (2 the) (2 category)) (2 (2 of) (2 (2 type) (2 aliases)))) (2 (2 that) (2 (2 appear) (2 (2 in) (2 (2 public) (2 interfaces)))))))))) (2 ,)) (2 or)) (2 (2 something) (2 else))))))) (2 ?)))))
.
(2 .)
@SimonSapin 
More complex analysis (reachability by reexports, "nameability") was done before and the example with inline-code was an error (based on URL but the rules were changed by the newer edition of RFC 136 to be local, module-level and based exclusively on inline-code annotations and not reachability (it wasn't thoroughly implemented though until recently).
(1 (1 (1 (1 (1 (2 (2 @SimonSapin) (2 (2 (2 More) (3 complex)) (2 analysis))) (2 (2 -LRB-) (2 (2 (2 reachability) (2 (2 by) (2 (2 (2 (2 (2 reexports) (2 ,)) (2 ``)) (2 nameability)) (2 '')))) (2 -RRB-)))) (2 (2 was) (2 (2 done) (2 before)))) (2 and)) (1 (2 (2 (2 the) (2 example)) (2 (2 with) (2 inline-code))) (1 (2 was) (1 (1 (2 an) (1 error)) (2 (2 -LRB-) (2 (1 (2 based) (1 (2 on) (1 (2 URL) (1 (2 but) (1 (2 (2 the) (2 rules)) (1 (2 were) (1 (1 (1 (2 (2 (2 (2 changed) (2 (2 by) (2 (2 (2 the) (2 (2 newer) (2 edition))) (2 (2 of) (2 (2 RFC) (2 136)))))) (2 (2 to) (2 (2 be) (3 local)))) (2 ,)) (2 module-level)) (2 and)) (1 (2 (2 based) (2 exclusively)) (1 (2 (2 on) (2 (2 inline-code) (2 annotations))) (2 (2 and) (1 (1 not) (1 (2 reachability) (1 (2 -LRB-) (1 (2 it) (1 (2 (2 (2 was) (2 n't)) (2 thoroughly)) (2 (2 (2 implemented) (2 though)) (2 (2 until) (2 recently)))))))))))))))))) (2 -RRB-))))))) (2 .))
Edit: some reasons are outlined by @nikomatsakis in URL.
(2 (2 Edit) (2 (2 :) (2 (2 (2 (2 some) (2 reasons)) (2 (2 are) (2 (2 outlined) (2 (2 by) (2 (2 @nikomatsakis) (2 (2 in) (2 URL))))))) (2 .))))
The changes are still only warnings for me so far, although the warnings claim they will become errors, so thankfully it isn't the end of the world yet.
(1 (1 (1 (1 (1 (2 (2 The) (2 changes)) (1 (1 (1 (1 (1 (2 (2 are) (2 still)) (1 (2 only) (3 warnings))) (2 (2 for) (3 me))) (2 (2 so) (2 far))) (2 ,)) (2 (2 although) (1 (3 (2 the) (3 warnings)) (2 (2 claim) (2 (2 they) (2 (2 will) (2 (2 become) (1 errors))))))))) (2 ,)) (2 so)) (1 (2 thankfully) (1 (2 it) (1 (1 (2 is) (2 n't)) (2 (2 (2 the) (2 end)) (2 (2 of) (2 (2 (2 the) (2 world)) (2 yet)))))))) (2 .))
@bluss 
Yes, the current rules have the "universal workaround":.
(2 (2 (2 @bluss) (2 Yes)) (2 (2 ,) (2 (2 (2 the) (2 (2 current) (2 rules))) (2 (2 (2 (2 have) (2 (2 the) (3 (2 ``) (2 (2 universal) (2 (2 workaround) (2 '')))))) (2 :)) (2 .)))))
=>
It is even mentioned in the detailed error message.
(1 (2 (2 =) (2 >)) (1 (2 It) (1 (1 (2 (2 is) (2 even)) (2 (2 mentioned) (2 (2 in) (2 (2 the) (2 (3 detailed) (1 (1 error) (2 message))))))) (2 .))))
This sounds like a regression.
(2 (2 This) (2 (2 (2 sounds) (2 (2 like) (2 (2 a) (2 regression)))) (2 .)))
Some git archaeology points to URL I’ll read up on motivations.
(2 (2 (2 Some) (2 git)) (3 (2 archaeology) (3 (3 (2 points) (2 (2 to) (2 (2 URL) (2 (2 I) (2 (2 'll) (2 (2 (2 read) (2 up)) (2 (2 on) (2 motivations)))))))) (2 .))))
I understand that fixing this bug may require doing a more complex analysis than is currently done, but i maintain that it's a bug.
(2 (2 (1 (1 (1 (2 I) (1 (2 understand) (1 (2 that) (1 (2 (2 fixing) (2 (2 this) (2 bug))) (2 (2 may) (2 (2 require) (2 (2 (2 doing) (2 (2 a) (2 (2 (2 more) (3 complex)) (2 analysis)))) (2 (2 than) (2 (2 (2 is) (2 currently)) (2 done)))))))))) (2 ,)) (2 but)) (2 (2 i) (2 (2 maintain) (2 (2 that) (2 (2 it) (2 (2 's) (2 (2 a) (2 bug)))))))) (2 .))
URL says the same.
(2 (2 URL) (2 (2 (2 says) (2 (2 the) (2 same))) (2 .)))
I don't see how this can't be considered a bug:.
(1 (2 I) (1 (1 (1 (2 (2 do) (2 n't)) (3 (2 see) (2 (2 how) (2 (2 this) (2 (2 (2 ca) (2 n't)) (2 (2 be) (2 (2 considered) (2 (2 a) (2 bug))))))))) (2 :)) (2 .)))
It's trivial to see that this code doesn't actually export any private types.
(1 (2 It) (1 (1 (2 's) (2 (2 trivial) (1 (2 to) (1 (2 see) (1 (2 that) (1 (2 (2 this) (2 code)) (1 (1 (1 (2 does) (2 n't)) (2 actually)) (2 (2 export) (2 (2 any) (2 (2 private) (2 types))))))))))) (2 .)))
I strongly disagree with this being the intended behavior: it just seems wrong.
(1 (1 (2 (1 (2 I) (1 (3 strongly) (1 (3 disagree) (2 (2 with) (2 (2 this) (2 (2 being) (2 (2 the) (2 (2 intended) (2 behavior))))))))) (2 :)) (1 (2 it) (1 (2 just) (1 (2 seems) (1 wrong))))) (2 .))
Reduced test case:.
(2 (2 Reduced) (2 (2 (2 (2 test) (2 case)) (2 :)) (2 .)))
Output with rustc 1.7.0-nightly (1447ce78f 2016-01-13)
This is incorrect: the inline-code function is not visible anywhere inline-code isn’t since the inline-code module is not public.
(1 (1 (1 (1 (1 (2 Output) (1 (2 with) (1 (2 (2 rustc) (2 1.7.0-nightly)) (2 (2 -LRB-) (2 (2 (2 1447ce78f) (2 2016-01-13)) (2 -RRB-)))))) (2 (2 This) (2 (2 is) (2 incorrect)))) (2 :)) (1 (2 (2 the) (2 (2 inline-code) (2 function))) (1 (1 (2 is) (1 not)) (2 (2 visible) (1 (2 (2 anywhere) (2 inline-code)) (2 (1 (2 is) (2 n't)) (2 (2 since) (1 (2 (2 the) (2 (2 inline-code) (2 module))) (2 (1 (2 is) (1 not)) (2 public)))))))))) (2 .))
In my non-reduced crate I get a warning rather than an error but I haven’t managed to reproduce that in the reduced case.
(1 (1 (1 (1 (2 (2 In) (2 (2 my) (2 (2 non-reduced) (2 crate)))) (1 (2 I) (1 (2 get) (1 (2 (2 (2 a) (2 warning)) (2 (2 rather) (2 than))) (1 (2 an) (1 error)))))) (2 but)) (1 (2 I) (1 (2 (2 have) (2 n't)) (2 (2 managed) (2 (2 to) (2 (2 reproduce) (2 (2 that) (2 (2 in) (2 (2 the) (2 (2 reduced) (2 case))))))))))) (2 .))
(Regardless, that warning is also incorrect.)
(1 (2 -LRB-) (1 (2 Regardless) (2 (2 ,) (2 (2 (2 that) (2 warning)) (2 (2 (2 (2 (2 is) (2 also)) (2 incorrect)) (2 .)) (2 -RRB-))))))
Oh, that’s a nice trick, thanks @seanmonstar 
(Through it’s still unfortunate that we have to do this to work around the lint’s incorrect algorithm.)
(1 (3 (2 Oh) (3 (2 ,) (3 (2 that) (3 (2 's) (3 (2 a) (3 (3 nice) (2 trick))))))) (1 (2 ,) (1 (3 thanks) (1 (1 (1 (2 @seanmonstar) (1 (2 -LRB-) (1 (3 (2 Through) (2 it)) (1 (2 (2 (2 's) (2 still)) (2 unfortunate)) (2 (2 that) (2 (2 we) (2 (2 have) (2 (2 to) (2 (2 do) (2 (2 this) (2 (2 to) (2 (2 work) (2 (2 around) (2 (2 (2 the) (2 (2 lint) (2 's))) (2 (2 incorrect) (2 algorithm)))))))))))))))) (2 .)) (2 -RRB-)))))
@retep998 
The recent changes are an improvement because the implementation was a hardly predictable mix of the new rules (mostly), old rules (to less extent) and outright missing cases.
(1 (2 (2 @retep998) (2 (2 The) (2 (2 recent) (2 changes)))) (1 (1 (2 are) (1 (3 (2 an) (3 improvement)) (1 (2 because) (1 (2 (2 the) (2 implementation)) (1 (2 was) (1 (1 (2 a) (1 (1 (2 hardly) (2 predictable)) (2 mix))) (1 (2 of) (1 (2 (2 (2 the) (2 (3 new) (1 (2 (2 rules) (2 (2 -LRB-) (2 (2 mostly) (2 -RRB-)))) (2 (2 ,) (2 (2 (2 old) (2 rules)) (2 (2 -LRB-) (2 (2 (2 to) (2 (2 less) (2 extent))) (2 -RRB-)))))))) (2 and)) (2 (2 outright) (2 (2 missing) (2 cases))))))))))) (2 .)))
Now it's at least consistent.
(3 (2 Now) (3 (2 it) (2 (2 (2 's) (2 (2 (2 at) (1 least)) (3 consistent))) (2 .))))
@nikomatsakis They're all basically a private struct, and then a public typedef to a raw pointer to it.
(2 (2 @nikomatsakis) (3 (2 They) (3 (3 (2 (2 (2 're) (2 all)) (2 basically)) (3 (2 (2 (2 (2 (2 a) (2 (2 private) (2 struct))) (2 ,)) (2 and)) (2 then)) (3 (2 (2 a) (2 (2 public) (2 typedef))) (2 (2 to) (3 (3 (2 a) (2 (2 raw) (2 pointer))) (2 (2 to) (2 it))))))) (2 .))))
The biggest example is URL .
(3 (2 (2 The) (2 (3 biggest) (2 example))) (2 (2 (2 is) (2 URL)) (2 .)))
It's easy enough for me to just make the internal opaque type public, I just don't like knowing that all existing versions of winapi will break in the future, forcing people to cargo update.
(1 (3 (2 It) (3 (2 's) (3 (2 (2 easy) (2 enough)) (2 (2 for) (2 (3 me) (2 (2 to) (2 (2 just) (2 (2 make) (2 (2 the) (2 (2 internal) (2 (2 opaque) (2 (2 type) (2 public))))))))))))) (1 (2 ,) (1 (2 I) (1 (2 just) (1 (1 (2 (2 do) (2 n't)) (1 (2 like) (2 (2 knowing) (1 (2 that) (1 (2 (2 (2 all) (2 (2 existing) (2 versions))) (2 (2 of) (2 winapi))) (1 (2 will) (1 (2 (2 (2 break) (2 (2 in) (2 (2 the) (2 future)))) (2 ,)) (1 (2 (1 forcing) (2 people)) (2 (2 to) (2 (2 cargo) (2 update))))))))))) (2 .))))))
This is expected, because the outer module could re-export that function.
(1 (2 This) (1 (1 (2 is) (1 (2 (1 expected) (2 ,)) (2 (2 because) (2 (2 (2 the) (2 (2 outer) (2 module))) (2 (2 could) (2 (2 re-export) (2 (2 that) (2 function)))))))) (2 .)))
The new rules are not an improvement in any way except to make the code in rustc simpler.
(1 (2 (2 The) (2 (3 new) (2 rules))) (1 (1 (1 (2 (2 are) (1 not)) (3 (3 (2 an) (3 improvement)) (2 (2 in) (2 (2 any) (2 way))))) (2 (2 except) (2 (2 to) (2 (2 make) (2 (2 (2 the) (2 code)) (2 (2 in) (2 (2 rustc) (2 simpler)))))))) (2 .)))
There's still a lot of false negatives, still a lot of false positives as well, and it will cause breaking changes to a huge amount of existing Rust code.
(0 (0 (0 (0 (1 (2 There) (0 (1 (1 (1 (2 (2 's) (2 still)) (1 (2 (2 a) (2 lot)) (1 (2 of) (1 (1 false) (1 negatives))))) (2 ,)) (2 still)) (1 (2 (2 a) (2 lot)) (1 (2 of) (1 (1 (1 false) (3 positives)) (2 (2 as) (3 well))))))) (2 ,)) (2 and)) (3 (2 it) (3 (2 will) (2 (2 (2 cause) (2 (2 breaking) (2 changes))) (2 (2 to) (3 (2 (2 a) (2 (2 huge) (2 amount))) (2 (2 of) (2 (2 existing) (2 (2 Rust) (2 code)))))))))) (2 .))
If there's going to be breaking changes, the new system should at least have significant improvements to make the breakage worth it.
(1 (2 (2 If) (2 (2 there) (2 (2 's) (2 (2 going) (2 (2 to) (2 (2 be) (2 (2 breaking) (2 changes)))))))) (3 (2 ,) (3 (2 (2 the) (2 (3 new) (2 system))) (3 (3 (2 (2 should) (2 (2 at) (1 least))) (3 (2 have) (3 (2 (2 significant) (2 improvements)) (3 (2 to) (3 (2 (2 make) (2 (2 the) (2 breakage))) (3 (2 worth) (2 it))))))) (2 .)))))
This bit me as well.
(3 (2 This) (3 (3 (2 (2 bit) (3 me)) (2 (2 as) (3 well))) (2 .)))
I defined an internal struct, and that sub modules would accept that struct as an argument to their methods.
(1 (1 (1 (1 (1 (2 I) (1 (3 defined) (2 (2 an) (2 (2 internal) (2 struct))))) (2 ,)) (2 and)) (2 (2 (2 that) (2 (1 sub) (2 modules))) (2 (2 would) (2 (2 (2 accept) (2 (2 (2 that) (2 struct)) (2 (2 as) (2 (2 an) (2 argument))))) (2 (2 to) (2 (2 their) (2 methods))))))) (2 .))
The "solution" was to trick the privacy visitor, by putting the struct into its own submodule, make the struct inline-code there, and then import from the sub module.
(1 (2 (2 The) (2 (2 ``) (2 (3 solution) (2 '')))) (1 (1 (2 was) (1 (2 to) (1 (1 (1 (1 (1 (1 (2 (2 (2 trick) (2 (2 the) (2 (2 privacy) (2 visitor)))) (2 ,)) (2 (2 by) (2 (2 (2 putting) (2 (2 the) (2 struct))) (2 (2 into) (2 (2 its) (2 (2 own) (2 submodule))))))) (2 ,)) (2 (2 (2 make) (2 (2 the) (2 (2 struct) (2 inline-code)))) (2 there))) (2 ,)) (2 and)) (2 (2 then) (2 (2 import) (2 (2 from) (2 (2 the) (2 (1 sub) (2 module))))))))) (2 .)))
playpen
@retep998 OK.
(2 (2 (2 playpen) (2 (2 @retep998) (2 OK))) (2 .))
That particular case would not be addressed by any of the mitigating measures we considered, I think.
(1 (1 (2 (2 That) (2 (2 particular) (2 case))) (2 (2 (2 would) (1 not)) (2 (2 be) (2 (2 addressed) (2 (2 by) (2 (2 any) (2 (2 of) (2 (2 (2 the) (2 (2 mitigating) (2 measures))) (2 (2 we) (2 considered)))))))))) (2 (2 ,) (2 (2 I) (2 (2 think) (2 .)))))
(It's sort of the motivating example that the rules were trying to prevent, from what I understand, in that one ought to be able to assume, because it is declared priv, that the private inner struct is not accessible from outside the module.)
(1 (2 -LRB-) (1 (2 It) (2 (1 (1 (2 (2 's) (2 (2 sort) (2 (2 of) (2 (2 the) (2 (2 motivating) (2 example)))))) (1 (2 that) (1 (2 (2 the) (2 rules)) (1 (2 were) (1 (2 (2 (2 trying) (2 (2 to) (2 prevent))) (2 ,)) (1 (2 from) (1 (2 what) (1 (2 I) (1 (2 (2 understand) (2 (2 ,) (2 (2 (2 (2 in) (2 that)) (2 (2 one) (2 (2 ought) (2 (2 to) (2 (2 be) (2 (3 able) (2 (2 to) (2 assume)))))))) (2 ,)))) (1 (2 because) (1 (2 it) (1 (2 is) (1 (2 (2 (2 declared) (2 priv)) (2 ,)) (1 (2 that) (1 (2 (2 the) (2 (2 private) (2 (2 inner) (2 struct)))) (1 (1 (2 is) (1 not)) (2 (3 accessible) (2 (2 from) (2 (2 outside) (2 (2 the) (2 module))))))))))))))))))))) (2 .)) (2 -RRB-))))
@retep998 Let me just say that I'm sorry your code stopped compiling -- I know that's always a pain, whatever the cause.
(1 (1 (1 (1 (2 @retep998) (1 (2 Let) (1 (3 me) (1 (2 just) (1 (2 say) (1 (2 that) (1 (2 I) (1 (2 'm) (1 (2 sorry) (2 (2 (2 your) (2 code)) (2 (2 stopped) (2 compiling)))))))))))) (2 --)) (1 (2 I) (2 (2 (2 (2 know) (2 (2 that) (2 (2 (2 's) (2 always)) (2 (2 a) (2 pain))))) (2 ,)) (2 (1 whatever) (2 (2 the) (2 cause)))))) (2 .))
In this case, as @petrochenkov said, there really aren't any new rules: it's just that rustc was (very) buggy and failed to enforce the rules consistently.
(0 (0 (1 (1 (2 (2 In) (2 (2 this) (2 case))) (1 (2 ,) (1 (2 (2 as) (2 (2 @petrochenkov) (2 said))) (1 (2 ,) (1 (2 there) (1 (2 really) (2 (1 (2 are) (2 n't)) (2 (2 any) (2 (3 new) (2 rules)))))))))) (2 :)) (1 (2 it) (1 (2 's) (1 (2 just) (1 (2 that) (1 (2 rustc) (1 (1 (1 (2 was) (1 (2 (2 -LRB-) (2 (2 very) (2 -RRB-))) (2 buggy))) (2 and)) (1 (1 failed) (2 (2 to) (3 (2 (2 enforce) (2 (2 the) (2 rules))) (2 consistently))))))))))) (2 .))
But I know that doesn't make it any less annoying when you have to update your code.
(1 (2 But) (1 (2 I) (1 (1 (2 know) (1 (2 that) (1 (1 (2 does) (2 n't)) (2 (2 make) (2 (2 it) (2 (2 (2 any) (2 (2 less) (0 annoying))) (2 (2 when) (2 (2 you) (2 (2 have) (2 (2 to) (2 (2 update) (2 (2 your) (2 code))))))))))))) (2 .))))
Closing as a dupe of #13793, but thanks for the report!
(1 (2 (2 Closing) (2 (2 as) (2 (2 (2 a) (1 dupe)) (2 (2 of) (2 (2 #) (2 13793)))))) (3 (2 ,) (3 (2 (2 but) (3 (3 thanks) (2 (2 for) (2 (2 the) (2 report))))) (2 !))))
Compiling an empty file with inline-code fails.
(0 (1 (1 (2 Compiling) (1 (2 an) (1 (1 empty) (2 file)))) (2 (2 with) (2 inline-code))) (0 (0 fails) (2 .)))
I'm using rust-nightly on windows 8.
(1 (2 I) (2 (2 (2 'm) (2 (2 (2 using) (2 rust-nightly)) (2 (2 on) (2 (2 windows) (2 8))))) (2 .)))
Closing as a dupe of URL.
(1 (1 (2 (2 Closing) (2 (2 as) (2 (2 a) (1 dupe)))) (2 (2 of) (2 URL))) (2 .))
Now that macros can be exported across crates, it'd be nice if Rustdoc would pick up inline-code-style macros that are exported.
(1 (2 (2 Now) (2 (2 that) (2 (2 macros) (2 (2 can) (2 (2 be) (2 (2 exported) (2 (2 across) (2 crates)))))))) (2 (2 ,) (1 (2 it) (2 (2 (2 'd) (1 (2 (2 be) (3 nice)) (2 (2 if) (1 (2 Rustdoc) (1 (2 would) (2 (2 (2 pick) (2 up)) (2 (2 (2 inline-code-style) (2 macros)) (2 (2 that) (2 (2 are) (2 exported)))))))))) (2 .)))))
E.g.
Bonus points for being able to document each pattern.
(3 (2 (2 E.g.) (2 Bonus)) (3 (3 (2 points) (2 (2 for) (2 (2 being) (2 (3 able) (2 (2 to) (2 (3 document) (2 (2 each) (2 pattern)))))))) (2 .)))
#17325 means this will become a very niche function.
(2 (2 (2 #) (2 17325)) (2 (2 (2 means) (2 (2 this) (2 (2 will) (2 (2 become) (2 (2 a) (2 (2 very) (2 (2 niche) (2 function)))))))) (2 .)))
It will almost never be the right tool to reach for.
(2 (2 It) (3 (3 (2 (2 will) (2 (2 almost) (2 never))) (2 (2 be) (2 (2 the) (3 (3 right) (2 (2 tool) (2 (2 to) (2 (2 reach) (2 for)))))))) (2 .)))
Is this still relevant?
(2 (2 (2 (2 Is) (2 this)) (2 (2 still) (2 relevant))) (2 ?))
Tasks have changed a lot recently, I am unsure what the current state is.
(1 (2 (2 Tasks) (2 (2 have) (2 (2 (2 changed) (2 (2 a) (2 lot))) (2 recently)))) (1 (2 ,) (1 (2 I) (1 (1 (2 am) (1 (2 unsure) (2 (2 what) (2 (2 (2 the) (2 (2 current) (2 state))) (2 is))))) (2 .)))))
Since tasks are cooperatively scheduled, yielding is pretty important when using tasks with long running threads.
(1 (2 (2 Since) (2 (2 tasks) (2 (2 (2 are) (2 cooperatively)) (2 scheduled)))) (2 (2 ,) (3 (2 yielding) (3 (2 (3 (2 is) (3 (4 pretty) (2 important))) (2 (2 when) (2 (2 (2 using) (2 tasks)) (2 (2 with) (2 (2 (2 long) (2 running)) (2 threads)))))) (2 .)))))
It'd be good if the task and communication tutorial covered std::task::yield a bit, or at least mentioned it, to warn the gung-ho.
(1 (1 (2 (2 (3 (2 It) (2 (2 'd) (3 (3 (2 be) (3 good)) (2 (2 if) (2 (2 (2 (2 the) (2 (2 task) (2 (2 and) (2 (2 communication) (2 tutorial))))) (2 covered)) (2 (2 (2 (2 std) (2 :)) (2 :)) (2 task))))))) (2 :)) (2 :)) (1 (2 (2 yield) (2 (2 (2 (2 (2 a) (2 bit)) (2 ,)) (2 or)) (2 (2 at) (1 least)))) (2 (2 (2 (2 mentioned) (2 it)) (2 ,)) (2 (2 to) (2 (1 warn) (2 (2 the) (2 gung-ho))))))) (2 .))
Triage.
(2 (2 Triage) (2 .))
In #8560, inline-code was reserved as a keyword and inline-code was renamed to inline-code.
(1 (2 (2 In) (2 (2 #) (2 8560))) (1 (2 ,) (1 (2 inline-code) (1 (1 (2 was) (2 (2 reserved) (1 (2 as) (1 (2 (2 a) (2 (2 (2 keyword) (2 and)) (2 inline-code))) (2 (2 was) (2 (2 renamed) (2 (2 to) (2 inline-code)))))))) (2 .)))))
part of #11755 .
(2 (2 (2 part) (2 (2 of) (2 (2 #) (2 11755)))) (2 .))
Seems good, I will consider this issue to be 'revamp the task tutorial' then.
(1 (3 (2 Seems) (3 good)) (1 (2 ,) (1 (2 I) (1 (2 (2 will) (1 (2 consider) (2 (2 this) (2 (2 issue) (2 (2 to) (2 (2 (2 be) (2 `)) (2 (2 (2 revamp) (2 (2 the) (2 (2 task) (2 (2 tutorial) (2 '))))) (2 then)))))))) (2 .)))))
In general the entire tasks tutorial needs a revamp most likely, it hasn't been scrutinized in a long time (I think).
(1 (2 (2 (2 In) (2 general)) (2 (2 (2 the) (2 (2 entire) (2 (2 tasks) (2 tutorial)))) (2 (2 needs) (2 (2 (2 a) (2 revamp)) (2 (2 most) (2 likely)))))) (1 (2 ,) (1 (2 it) (1 (2 (2 (2 has) (2 n't)) (1 (2 been) (2 (2 scrutinized) (2 (2 in) (2 (2 (2 a) (2 (2 long) (2 time))) (2 (2 -LRB-) (2 (2 (2 I) (2 think)) (2 -RRB-)))))))) (2 .)))))
fix issue #22535.
(2 (2 (2 (2 fix) (2 issue)) (2 (2 #) (2 22535))) (2 .))
@bors r+ c2a2b10 rollup.
(1 (2 (2 @bors) (2 r)) (2 (2 (2 +) (2 (2 c2a2b10) (2 rollup))) (2 .)))
r?
(2 (2 r) (2 ?))
@pcwalton
(rust_highfive has picked a reviewer for you, use r?
(1 (2 (2 @pcwalton) (2 (2 -LRB-) (2 (2 rust_highfive) (2 (2 has) (2 (2 picked) (2 (2 (2 a) (2 reviewer)) (2 (2 for) (2 you)))))))) (2 (2 ,) (2 (2 (2 use) (2 r)) (2 ?))))
to override)
fix issue #22535.
(1 (1 (2 to) (1 (1 (2 (2 override) (2 -RRB-)) (2 fix)) (2 (2 issue) (2 (2 #) (2 22535))))) (2 .))
Serialize is out of tree, and it seems as though you've figured out your error, so I'm giving this a close.
(1 (1 (1 (1 (1 (1 (1 (1 (2 Serialize) (1 (2 (2 is) (1 out)) (2 (2 of) (2 tree)))) (2 ,)) (2 and)) (2 (2 it) (2 (2 seems) (2 (2 as) (2 (2 though) (2 (2 you) (2 (2 've) (2 (2 figured) (2 (1 out) (1 (2 your) (1 error))))))))))) (2 ,)) (2 so)) (2 (2 I) (2 (2 'm) (2 (2 (2 giving) (2 this)) (2 (2 a) (2 close)))))) (2 .))
Eh, never mind, it's my fault, looks like the inline-code param of inline-code needs to be nonzero for inline-code.
(1 (2 (1 (2 (1 Eh) (2 ,)) (2 never)) (2 mind)) (1 (1 (2 ,) (1 (1 (2 it) (2 (2 's) (1 (2 my) (2 fault)))) (2 ,))) (1 (1 (1 (2 looks) (2 (2 like) (2 (2 (2 the) (2 (2 inline-code) (2 param))) (2 (2 of) (2 (2 inline-code) (2 needs)))))) (2 (2 to) (2 (2 be) (2 (2 nonzero) (2 (2 for) (2 inline-code)))))) (2 .))))
Still, though, it would be nice if the emits behaved the same way for both encoders.
(2 (2 Still) (2 (2 ,) (2 (2 though) (2 (2 ,) (1 (2 it) (2 (2 (2 would) (2 (2 (2 be) (3 nice)) (2 (2 if) (2 (2 (2 the) (2 emits)) (2 (2 (2 behaved) (2 (2 the) (2 (2 same) (2 way)))) (2 (2 for) (2 (2 both) (2 encoders)))))))) (2 .)))))))
To be honest, I don't quite see why inline-code needs inline-code and inline-code in the first place...
Hi,
  I ran into a problem with inline-code, it won't encode values with inline-code whereas the regular inline-code works just fine using exactly the same code.
(1 (1 (1 (1 (2 (2 To) (3 (2 be) (4 honest))) (1 (2 ,) (1 (2 I) (1 (2 (2 (2 do) (2 n't)) (2 quite)) (1 (2 see) (1 (2 why) (1 (2 inline-code) (2 (2 (2 needs) (2 (2 (2 inline-code) (2 and)) (2 inline-code))) (2 (2 in) (2 (2 the) (2 (2 first) (2 place)))))))))))) (2 ...)) (1 (2 Hi) (1 (2 (2 ,) (2 (2 (2 I) (2 (2 (2 ran) (2 (2 into) (2 (2 a) (1 problem)))) (2 (2 with) (2 inline-code)))) (2 ,))) (1 (2 it) (1 (2 (2 wo) (2 n't)) (3 (2 (2 (2 encode) (2 values)) (2 (2 with) (2 inline-code))) (3 (2 whereas) (3 (2 (2 the) (2 (2 regular) (2 inline-code))) (3 (3 (2 works) (3 (2 just) (3 fine))) (2 (2 using) (2 (2 exactly) (2 (2 the) (2 (2 same) (2 code)))))))))))))) (2 .))
This is the code to reproduce:.
(2 (2 This) (2 (2 (2 (2 is) (2 (2 the) (2 (2 code) (2 (2 to) (2 reproduce))))) (2 :)) (2 .)))
@bors: r+ rollup.
(1 (2 (2 (2 @bors) (2 :)) (2 (2 r) (2 (2 +) (2 rollup)))) (2 .))
r?
(2 (2 r) (2 ?))
@nikomatsakis
(rust_highfive has picked a reviewer for you, use r?
(1 (2 (2 @nikomatsakis) (2 (2 -LRB-) (2 (2 rust_highfive) (2 (2 has) (2 (2 picked) (2 (2 (2 a) (2 reviewer)) (2 (2 for) (2 you)))))))) (2 (2 ,) (2 (2 (2 use) (2 r)) (2 ?))))
to override)
:pushpin: Commit a8680de has been approved by inline-code
<!-- @bors r=steveklabnik a8680deb7f950f48b5807a887944fa73af723507 -->
seems fine to me but I'd like a second opinion -- cc @steveklabnik .
(1 (1 (2 to) (1 (1 (2 (2 override) (2 -RRB-)) (1 (2 (1 (1 (2 (2 :) (2 (2 (2 pushpin) (2 :)) (2 Commit))) (1 (2 a8680de) (2 (2 has) (2 (2 been) (2 (2 approved) (2 (2 by) (2 (2 inline-code) (2 <!-- @bors r=steveklabnik a8680deb7f950f48b5807a887944fa73af723507 -->)))))))) (3 (2 seems) (3 (3 fine) (2 (2 to) (3 me))))) (2 but)) (2 (2 I) (2 (2 'd) (2 (2 like) (2 (2 a) (2 (2 second) (2 opinion)))))))) (2 --))) (2 (2 cc) (2 (2 @steveklabnik) (2 .))))
Closing due to inactivity, but feel free to resubmit with Windows handled as well!
(3 (2 Closing) (3 (3 (2 due) (2 (2 to) (3 (2 (2 (2 inactivity) (2 ,)) (2 but)) (3 (2 feel) (3 (3 free) (3 (2 to) (3 (2 resubmit) (3 (2 with) (3 (2 Windows) (3 (2 handled) (2 (2 as) (3 well)))))))))))) (2 !)))
This may also be expressible as:.
(2 (2 This) (2 (2 (2 (2 (2 may) (2 also)) (2 (2 be) (2 (2 expressible) (2 as)))) (2 :)) (2 .)))
It's ok to not really optimize this much but we probably want to also handle windows as well?
(1 (1 (2 (1 (2 It) (2 (2 's) (2 (2 ok) (2 (2 to) (2 (2 (1 not) (2 really)) (2 (2 optimize) (2 (2 this) (2 much)))))))) (2 but)) (1 (2 we) (1 (2 probably) (3 (2 want) (3 (2 to) (3 (2 also) (2 (2 (2 handle) (2 windows)) (2 (2 as) (3 well))))))))) (2 ?))
Hm spawning processes here may be a bit expensive here so it may be best to just rely on file detection.
(1 (2 (2 Hm) (2 (2 spawning) (2 processes))) (1 (2 here) (1 (1 (2 may) (1 (2 (2 (2 be) (2 (2 (2 a) (2 bit)) (2 expensive))) (2 here)) (3 (2 so) (3 (2 it) (3 (2 may) (3 (3 (2 be) (4 best)) (2 (2 to) (2 (2 just) (2 (2 rely) (2 (2 on) (2 (2 file) (2 detection)))))))))))) (2 .))))
r?
(2 (2 r) (2 ?))
@alexcrichton
(rust_highfive has picked a reviewer for you, use r?
(1 (2 (2 @alexcrichton) (2 (2 -LRB-) (2 (2 rust_highfive) (2 (2 has) (2 (2 picked) (2 (2 (2 a) (2 reviewer)) (2 (2 for) (2 you)))))))) (2 (2 ,) (2 (2 (2 use) (2 r)) (2 ?))))
to override)
Rather than hardcoding the binary name for running asmjs tests, attempt
to detect the name that should be used; either inline-code or inline-code.
(1 (1 (2 to) (1 (1 (2 (2 override) (2 -RRB-)) (2 Rather)) (2 (2 than) (1 (2 (2 hardcoding) (2 (2 the) (2 (2 binary) (2 name)))) (2 (2 for) (2 (2 running) (2 (2 asmjs) (2 tests)))))))) (1 (2 ,) (1 (1 (2 attempt) (1 (2 to) (1 (2 (2 (2 detect) (2 (2 (2 the) (2 name)) (2 (2 that) (2 (2 should) (2 (2 be) (2 used)))))) (2 ;)) (2 (2 either) (2 (2 (2 inline-code) (2 or)) (2 inline-code)))))) (2 .))))
Also
add a command-line argument to manually specify what should be used,
suppressing probing.
(1 (2 Also) (1 (1 (2 (2 (2 (3 add) (2 (2 a) (2 (2 command-line) (2 argument)))) (2 (2 to) (2 (2 manually) (2 (2 specify) (2 (2 what) (2 (2 should) (2 (2 be) (2 used)))))))) (2 ,)) (2 (2 suppressing) (2 probing))) (2 .)))
Fixes #34188.
(2 (2 (2 Fixes) (2 (2 #) (2 34188))) (2 .))
Yeah, I forgot about Windows so at least the .
(1 (2 Yeah) (2 (2 ,) (2 (2 I) (2 (2 (2 (3 forgot) (2 (2 about) (2 Windows))) (2 (2 so) (2 (2 (2 at) (1 least)) (2 the)))) (2 .)))))
exe variants should be added.
(1 (2 (2 exe) (2 variants)) (2 (2 (2 should) (2 (2 be) (2 added))) (2 .)))
I also considered trying to run each instead of scanning PATH, which would free us from needing to know about a platform's executable suffix so I think that's a better solution.
(1 (2 I) (1 (2 also) (1 (1 (2 considered) (1 (2 (2 (2 trying) (2 (2 to) (2 (2 run) (2 each)))) (2 (2 instead) (2 of))) (1 (2 scanning) (1 (2 (2 PATH) (2 ,)) (1 (2 which) (1 (2 would) (1 (2 (3 free) (3 us)) (1 (2 from) (1 (2 needing) (2 (2 to) (2 (2 (2 know) (2 (2 about) (2 (2 (2 a) (2 (2 platform) (2 's))) (2 (2 executable) (2 suffix))))) (2 (2 so) (2 (2 I) (2 (2 think) (2 (2 that) (2 (2 's) (2 (2 a) (2 (4 better) (3 solution))))))))))))))))))) (2 .))))
Rather than hardcoding the binary name for running asmjs tests, attempt
to detect the name that should be used; either inline-code or inline-code.
(1 (1 (2 Rather) (2 (2 than) (2 (2 (2 hardcoding) (2 (2 the) (2 (2 binary) (2 name)))) (2 (2 for) (2 running))))) (1 (1 (2 asmjs) (1 (2 (2 tests) (2 ,)) (1 (2 (2 (2 attempt) (2 (2 to) (2 (2 detect) (2 (2 (2 the) (2 name)) (2 (2 that) (2 (2 should) (2 (2 be) (2 used)))))))) (2 ;)) (2 (2 (2 (2 either) (2 inline-code)) (2 or)) (2 inline-code))))) (2 .)))
Also
add a command-line argument to manually specify what should be used,
suppressing probing.
(1 (2 Also) (1 (1 (2 (2 (2 (3 add) (2 (2 a) (2 (2 command-line) (2 argument)))) (2 (2 to) (2 (2 manually) (2 (2 specify) (2 (2 what) (2 (2 should) (2 (2 be) (2 used)))))))) (2 ,)) (2 (2 suppressing) (2 probing))) (2 .)))
Fixes #34188.
(2 (2 (2 Fixes) (2 (2 #) (2 34188))) (2 .))
cc @Seldaek: this is actually really important.
(3 (2 (2 cc) (2 @Seldaek)) (3 (2 :) (3 (3 (2 this) (3 (2 (2 is) (2 actually)) (3 (2 really) (2 important)))) (2 .))))
When I add anchors I'll make sure there is a "copy link here thingy" near the anchors themselves so you can easily copy the link to send someone directly somewhere.
(1 (2 (2 When) (2 (2 I) (2 (3 add) (2 anchors)))) (1 (2 I) (1 (1 (2 'll) (1 (2 (2 make) (1 (2 sure) (2 (2 there) (2 (2 (2 (2 (2 (2 is) (2 (2 a) (2 (2 ``) (2 (2 copy) (2 link))))) (2 here)) (2 thingy)) (2 '')) (2 (2 near) (2 (2 (2 the) (2 anchors)) (2 themselves))))))) (3 (2 so) (3 (2 you) (3 (2 (2 can) (3 easily)) (2 (2 copy) (2 (2 the) (2 (2 link) (2 (2 to) (2 (2 (2 send) (2 someone)) (2 (2 directly) (2 somewhere)))))))))))) (2 .))))
As noted on rust-dev, right now it's painful to link to the HTML docs for a specific method inside a trait or impl because one has to view source to get an anchor link to the right place.
(1 (2 (2 As) (2 (2 (2 (2 noted) (2 (2 on) (2 rust-dev))) (2 ,)) (2 (3 right) (2 now)))) (1 (2 it) (1 (1 (2 's) (1 (1 painful) (2 (2 to) (3 (2 (3 (2 (2 link) (2 (2 to) (2 (2 the) (2 (2 HTML) (2 docs))))) (2 (2 for) (2 (2 (2 a) (2 (2 specific) (2 method))) (2 (2 inside) (2 (2 a) (2 trait)))))) (2 or)) (3 (2 impl) (3 (2 because) (3 (2 one) (3 (2 (2 has) (2 (2 to) (2 (2 view) (2 source)))) (2 (2 to) (3 (2 (2 get) (3 (2 an) (2 (2 anchor) (2 link)))) (3 (2 to) (3 (2 the) (3 (3 right) (2 place)))))))))))))) (2 .))))
(The anchor links are, in fact, already being generated, just not used.)
(1 (2 -LRB-) (1 (2 (2 The) (2 (2 anchor) (2 links))) (2 (1 (1 (2 (2 (2 (2 are) (2 ,)) (2 (2 in) (2 fact))) (2 ,)) (2 (2 already) (1 (2 being) (1 (1 (2 (2 generated) (2 ,)) (2 (2 just) (1 not))) (2 used))))) (2 .)) (2 -RRB-))))
Triage visit; I guess it's a WONTFIX for the old rustdoc, and is (hopefully) handled by rustdoc_ng (cc @cmr, @Seldaek).
(0 (1 (2 (2 (2 Triage) (2 visit)) (2 ;)) (1 (2 I) (1 (2 guess) (1 (2 it) (1 (1 (2 (2 (2 (2 's) (2 (2 (2 a) (2 WONTFIX)) (2 (2 for) (2 (2 the) (2 (2 old) (2 rustdoc)))))) (2 ,)) (2 and)) (3 (2 is) (2 (2 (2 -LRB-) (2 (2 hopefully) (2 -RRB-))) (2 handled)))) (1 (2 by) (1 (2 rustdoc_ng) (1 (2 -LRB-) (2 (2 (2 (2 (2 cc) (2 @cmr)) (2 ,)) (2 @Seldaek)) (2 -RRB-)))))))))) (2 .))
#8125 .
(2 (2 (2 #) (2 8125)) (2 .))
This is done with rustdoc_ng, now in-tree and generating docs.
(1 (2 This) (1 (1 (2 is) (2 (2 done) (2 (2 with) (2 (3 (2 (2 (2 rustdoc_ng) (2 ,)) (2 (2 now) (2 in-tree))) (2 and)) (2 (2 generating) (2 docs)))))) (2 .)))
@bors: r+ 847fba0
Thanks!
(1 (1 (2 (2 @bors) (2 :)) (2 (2 (2 r) (2 +)) (2 (2 847fba0) (2 Thanks)))) (2 !))
:hourglass: Testing commit 847fba0 with merge 57f4665...
:broken_heart: Test failed - auto-mac-64-opt.
(1 (2 :) (1 (1 (2 (1 (2 (2 hourglass) (2 :)) (2 (2 Testing) (2 (2 commit) (2 (2 847fba0) (2 (2 (2 with) (2 (2 merge) (2 57f4665))) (2 ...)))))) (2 :)) (1 (1 (1 (2 (2 broken_heart) (2 :)) (1 (2 Test) (1 failed))) (2 -)) (2 auto-mac-64-opt))) (2 .)))
@bors: rollup.
(2 (2 (2 (2 @bors) (2 :)) (2 rollup)) (2 .))
@bors: retry
On Sun, Jul 26, 2015 at 5:12 AM, Tamir Duberstein <notifications@github.com>
wrote:.
(1 (2 @bors) (1 (2 :) (1 (1 (2 retry) (1 (1 (1 (2 (2 On) (2 Sun)) (2 (2 ,) (2 (2 (2 (2 (2 Jul) (2 26)) (2 ,)) (2 2015)) (2 (2 at) (2 (2 5:12) (2 AM)))))) (2 ,)) (2 (2 (2 Tamir) (2 Duberstein)) (2 <notifications@github.com>)))) (2 (2 (2 wrote) (2 :)) (2 .)))))
>
>
:sunny: Test successful - auto-linux-32-nopt-t, auto-linux-32-opt, auto-linux-64-nopt-t, auto-linux-64-opt, auto-linux-64-x-android-t, auto-mac-32-opt, auto-mac-64-nopt-t, auto-mac-64-opt, auto-win-gnu-32-nopt-t, auto-win-gnu-32-opt, auto-win-gnu-64-nopt-t, auto-win-gnu-64-opt, auto-win-msvc-32-opt, auto-win-msvc-64-opt.
(1 (1 (2 (2 (2 >) (2 >)) (2 :)) (1 (3 (2 sunny) (3 (2 :) (3 (3 (2 Test) (4 successful)) (2 -)))) (1 (2 auto-linux-32-nopt-t) (1 (2 ,) (1 (2 auto-linux-32-opt) (1 (2 ,) (1 (2 auto-linux-64-nopt-t) (1 (2 ,) (1 (2 auto-linux-64-opt) (1 (2 ,) (1 (2 auto-linux-64-x-android-t) (1 (2 ,) (1 (2 auto-mac-32-opt) (1 (2 ,) (1 (2 auto-mac-64-nopt-t) (1 (2 ,) (1 (2 auto-mac-64-opt) (1 (2 ,) (1 (2 auto-win-gnu-32-nopt-t) (1 (2 ,) (1 (2 auto-win-gnu-32-opt) (1 (2 ,) (1 (2 auto-win-gnu-64-nopt-t) (2 (2 ,) (1 (2 auto-win-gnu-64-opt) (2 (2 ,) (2 (2 auto-win-msvc-32-opt) (2 (2 ,) (2 auto-win-msvc-64-opt))))))))))))))))))))))))))))) (2 .))
r?
(2 (2 r) (2 ?))
@brson
(rust_highfive has picked a reviewer for you, use r?
(1 (2 (2 @brson) (2 (2 -LRB-) (2 (2 rust_highfive) (2 (2 has) (2 (2 picked) (2 (2 (2 a) (2 reviewer)) (2 (2 for) (2 you)))))))) (2 (2 ,) (2 (2 (2 use) (2 r)) (2 ?))))
to override)
Fixes #27263.
(2 (2 to) (2 (2 override) (2 (2 -RRB-) (2 (2 (2 Fixes) (2 (2 #) (2 27263))) (2 .)))))
Failed on git, needs a retry.
(1 (2 (2 Failed) (2 (2 on) (2 git))) (2 (2 ,) (2 (2 (2 needs) (2 (2 a) (2 retry))) (2 .))))
:hourglass: Testing commit 847fba0 with merge 6d36798...
Fixes #27263.
(1 (2 :) (1 (1 (1 (1 (2 (2 (2 hourglass) (2 :)) (2 Testing)) (2 (2 (2 commit) (2 847fba0)) (2 (2 with) (2 (2 merge) (2 6d36798))))) (2 ...)) (2 (2 Fixes) (2 (2 #) (2 27263)))) (2 .)))
:sunny: Test successful - auto-linux-32-nopt-t, auto-linux-32-opt, auto-linux-64-debug-opt, auto-linux-64-nopt-t, auto-linux-64-opt, auto-linux-64-x-android-t, auto-linux-cross-opt, auto-linux-musl-64-opt, auto-mac-32-opt, auto-mac-64-nopt-t, auto-mac-64-opt, auto-mac-ios-opt, auto-win-gnu-32-nopt-t, auto-win-gnu-32-opt, auto-win-gnu-64-nopt-t, auto-win-gnu-64-opt, auto-win-msvc-32-opt, auto-win-msvc-64-opt.
(2 (2 :) (2 (1 (3 (2 sunny) (3 (2 :) (3 (3 (2 Test) (4 successful)) (2 -)))) (1 (2 auto-linux-32-nopt-t) (1 (2 ,) (1 (2 auto-linux-32-opt) (1 (2 ,) (1 (2 auto-linux-64-debug-opt) (1 (2 ,) (1 (2 auto-linux-64-nopt-t) (1 (2 ,) (1 (2 auto-linux-64-opt) (1 (2 ,) (1 (2 auto-linux-64-x-android-t) (1 (2 ,) (1 (2 auto-linux-cross-opt) (1 (2 ,) (1 (2 auto-linux-musl-64-opt) (1 (2 ,) (1 (2 auto-mac-32-opt) (1 (2 ,) (1 (2 auto-mac-64-nopt-t) (1 (2 ,) (1 (2 auto-mac-64-opt) (1 (2 ,) (1 (2 auto-mac-ios-opt) (1 (2 ,) (1 (2 auto-win-gnu-32-nopt-t) (1 (2 ,) (1 (2 auto-win-gnu-32-opt) (1 (2 ,) (1 (2 auto-win-gnu-64-nopt-t) (2 (2 ,) (1 (2 auto-win-gnu-64-opt) (2 (2 ,) (2 (2 auto-win-msvc-32-opt) (2 (2 ,) (2 auto-win-msvc-64-opt)))))))))))))))))))))))))))))))))))) (2 .)))
Fixes #32004 
r?
(2 (2 (2 Fixes) (2 (2 #) (2 (2 32004) (2 r)))) (2 ?))
@eddyb.
(2 (2 @eddyb) (2 .))
Could you expand the expected message to also include “variant” here?
(1 (1 (2 (2 Could) (2 you)) (2 (2 (2 expand) (2 (2 (2 the) (2 (1 expected) (2 message))) (2 (2 to) (2 (2 also) (2 (2 (2 (2 include) (2 ``)) (2 variant)) (2 '')))))) (2 here))) (2 ?))
@bors r+ f40d12f
Looks good to me.
(3 (1 (2 @bors) (1 (2 r) (2 (2 +) (2 (2 f40d12f) (3 Looks))))) (3 (3 (3 good) (2 (2 to) (3 me))) (2 .)))
Fixes #32004 
r?
(2 (2 (2 Fixes) (2 (2 #) (2 (2 32004) (2 r)))) (2 ?))
@eddyb.
(2 (2 @eddyb) (2 .))
And “struct” here?
(2 (2 And) (2 (2 (2 ``) (2 (2 (2 struct) (2 '')) (2 here))) (2 ?)))
:hourglass: Testing commit f40d12f with merge d31d8a9...
fixed.
(1 (2 :) (1 (1 (1 (1 (2 (2 (2 hourglass) (2 :)) (2 Testing)) (2 (2 (2 commit) (2 f40d12f)) (2 (2 with) (2 (2 merge) (2 d31d8a9))))) (2 ...)) (2 fixed)) (2 .)))
I nominate this for beta since this fixes a regression from stable to nightly (now beta) and we recently had a release.
(1 (1 (1 (1 (2 I) (1 (2 (2 nominate) (2 (2 this) (2 (2 for) (2 beta)))) (2 (2 since) (1 (2 this) (1 (2 (2 (2 fixes) (2 (2 a) (2 regression))) (2 (2 from) (2 stable))) (2 (2 to) (2 (2 nightly) (2 (2 -LRB-) (2 (2 (2 now) (2 beta)) (2 -RRB-)))))))))) (2 and)) (2 (2 we) (2 (2 recently) (2 (2 had) (2 (2 a) (2 release)))))) (2 .))
Implements vtable support for generic Deref impls with trait bounds.
(1 (2 Implements) (1 (1 (1 (2 (2 vtable) (2 support)) (1 (2 for) (1 (1 generic) (2 (2 Deref) (2 impls))))) (2 (2 with) (2 (2 trait) (2 bounds)))) (2 .)))
Also fixes cross-crate inlining when using autoderef.
(1 (2 Also) (1 (2 fixes) (2 (2 (2 cross-crate) (2 (2 inlining) (2 (2 when) (2 (2 using) (2 autoderef))))) (2 .))))
Implements vtable support for generic Deref impls with trait bounds.
(1 (2 Implements) (1 (1 (1 (2 (2 vtable) (2 support)) (1 (2 for) (1 (1 generic) (2 (2 Deref) (2 impls))))) (2 (2 with) (2 (2 trait) (2 bounds)))) (2 .)))
Also fixes cross-crate inlining when using autoderef.
(1 (2 Also) (1 (2 fixes) (2 (2 (2 cross-crate) (2 (2 inlining) (2 (2 when) (2 (2 using) (2 autoderef))))) (2 .))))
rustpkg is gone.
(1 (2 rustpkg) (2 (2 (2 is) (2 gone)) (2 .)))
Example:.
(2 (2 Example) (2 (2 :) (2 .)))
gives
inline-code.
(2 (2 (2 gives) (2 inline-code)) (2 .))
Updated.
(2 (2 Updated) (2 .))
Sure.
(2 (2 Sure) (2 .))
r?
(2 (2 r) (2 ?))
@brson 
cc @steveklabnik 
cc @jonathandturner .
(1 (2 (2 @brson) (2 cc)) (2 (2 (2 @steveklabnik) (2 (2 cc) (2 @jonathandturner))) (2 .)))
:pushpin: Commit 58955de has been approved by inline-code
<!-- @bors r=brson 58955dee66a09a81db2dda83f49adf4436bfd6d4 -->
r?
(1 (2 :) (1 (2 (2 (2 pushpin) (2 :)) (2 (2 Commit) (2 58955de))) (1 (1 (2 has) (1 (2 been) (2 (2 approved) (2 (2 by) (2 (2 inline-code) (2 (2 <!-- @bors r=brson 58955dee66a09a81db2dda83f49adf4436bfd6d4 -->) (2 r))))))) (2 ?))))
@brson 
cc @steveklabnik 
cc @jonathandturner .
(1 (2 (2 @brson) (2 cc)) (2 (2 (2 @steveklabnik) (2 (2 cc) (2 @jonathandturner))) (2 .)))
@bors r+
Perhaps this can be clearer about what it means to be unused.
(1 (2 (2 (2 @bors) (2 (2 r) (2 +))) (2 (2 Perhaps) (2 this))) (2 (2 (2 can) (2 (2 be) (2 (2 clearer) (2 (2 about) (2 (2 what) (2 (2 it) (2 (2 means) (2 (2 to) (2 (2 be) (2 unused)))))))))) (2 .)))
As a warning this sounds like the user has done something wrong.
(1 (2 (2 As) (2 (2 a) (2 warning))) (1 (2 this) (1 (1 (2 sounds) (1 (2 like) (1 (2 (2 the) (2 user)) (1 (2 has) (1 (2 done) (1 (2 something) (1 wrong))))))) (2 .))))
What about something like 'Note: this error code is no longer emitted by the compiler.'
(1 (2 (2 What) (2 (2 about) (2 (2 something) (2 (2 (2 like) (2 `)) (2 Note))))) (1 (2 :) (1 (2 (2 this) (2 (1 error) (2 code))) (1 (1 (1 (2 (2 is) (2 (1 no) (2 longer))) (2 (2 emitted) (2 (2 by) (2 (2 the) (2 compiler))))) (2 .)) (2 ')))))
?
(2 ?)
In order to land #13967 I'm ignoring the test in src/test/compile-fail/issue-9725.
(1 (2 (2 (2 In) (2 order)) (2 (2 to) (2 (2 land) (2 (2 #) (2 13967))))) (1 (2 I) (1 (1 (2 'm) (1 (2 ignoring) (2 (2 (2 the) (2 test)) (2 (2 in) (2 (2 src/test/compile-fail) (2 (2 /) (2 issue-9725))))))) (2 .))))
rs which currently explodes rustc.
(2 (2 (2 rs) (2 (2 which) (2 (2 currently) (2 (2 explodes) (2 rustc))))) (2 .))
r?
(2 (2 r) (2 ?))
@steveklabnik .
(2 (2 @steveklabnik) (2 .))
r?
(2 (2 r) (2 ?))
@steveklabnik .
(2 (2 @steveklabnik) (2 .))
:pushpin: Commit ace39cb has been approved by inline-code
<!-- @bors r=steveklabnik ace39cbc15488eb949ef4dc13a10137b170709b1 -->
@bors: r+ rollup
thank you!
(1 (2 :) (1 (1 (1 (1 (2 (2 pushpin) (2 :)) (1 (2 (2 Commit) (2 ace39cb)) (1 (2 has) (1 (2 been) (2 (2 approved) (2 (2 by) (2 (2 inline-code) (2 (2 <!-- @bors r=steveklabnik ace39cbc15488eb949ef4dc13a10137b170709b1 -->) (2 @bors))))))))) (2 :)) (3 (2 r) (3 (2 (2 +) (2 rollup)) (2 (3 thank) (2 you))))) (2 !)))
I'm not sure if/how to test this.
(1 (2 I) (1 (1 (2 (2 (2 'm) (1 not)) (2 sure)) (2 (2 if/how) (2 (2 to) (2 (2 test) (2 this))))) (2 .)))
Passes make check.
(2 (2 Passes) (2 (2 (2 make) (3 check)) (2 .)))
Before
After
Ah, what I meant to say is that behavior is undefined if you unwind in code built with inline-code.
(1 (2 (2 Before) (2 (2 (2 After) (2 Ah)) (2 (2 ,) (2 (2 what) (2 (2 I) (2 (2 meant) (2 (2 to) (2 say)))))))) (1 (1 (2 is) (1 (2 that) (2 (2 behavior) (2 (2 (2 is) (2 undefined)) (2 (2 if) (2 (2 you) (2 (2 unwind) (2 (2 in) (2 (2 code) (2 (2 built) (2 (2 with) (2 inline-code)))))))))))) (2 .)))
Upon rebasing LLVM it sounds like they're removing the inline-code option entirely.
(1 (2 (2 Upon) (2 (2 rebasing) (2 LLVM))) (2 (2 it) (2 (2 (2 sounds) (2 (2 like) (2 (2 they) (2 (2 're) (2 (2 (2 removing) (2 (2 the) (2 (2 inline-code) (2 option)))) (2 entirely)))))) (2 .))))
I think they turned it on by default for relevant platforms and I suppose they handle it somehow for others.
(2 (2 (2 (2 (2 I) (2 (2 think) (2 (2 they) (2 (2 (2 (2 turned) (2 it)) (2 (2 on) (2 (2 by) (2 default)))) (2 (2 for) (2 (2 relevant) (2 platforms))))))) (2 and)) (2 (2 I) (2 (2 suppose) (2 (2 they) (2 (2 (2 (2 handle) (2 it)) (2 somehow)) (2 (2 for) (2 others))))))) (2 .))
See URL.
(3 (3 (2 See) (2 URL)) (2 .))
I'm just waiting for LLVM's mingw bots to go green before we rebase and take an LLVM upgrade, but it could be a long time before that happens if they start requiring c++11 to build llvm (which they're definitely doing soon).
(1 (1 (1 (1 (1 (2 I) (1 (2 (2 'm) (2 just)) (1 (2 (2 waiting) (2 (2 for) (2 (2 (2 LLVM) (2 's)) (2 (2 mingw) (2 bots))))) (2 (2 to) (2 (2 (2 go) (2 green)) (2 (2 before) (2 (2 we) (2 (2 (2 (2 rebase) (2 and)) (2 take)) (2 (2 an) (2 (2 LLVM) (2 upgrade))))))))))) (2 ,)) (2 but)) (2 (2 it) (1 (2 could) (2 (2 (2 be) (2 (2 (2 a) (2 (2 long) (2 time))) (2 (2 before) (2 (2 that) (2 (2 happens) (2 (2 if) (2 (2 they) (2 (2 start) (2 (2 requiring) (2 (2 (2 c++) (2 11)) (2 (2 to) (2 (2 build) (2 llvm))))))))))))) (2 (2 -LRB-) (2 (2 (2 which) (2 (2 they) (2 (2 (2 're) (3 definitely)) (2 (2 doing) (2 soon))))) (2 -RRB-))))))) (2 .))
I think it generally makes sense that the behavior is undefined if you run with inline-code.
(2 (2 I) (2 (2 (2 think) (2 (2 it) (2 (2 generally) (2 (2 (2 makes) (2 sense)) (2 (2 that) (2 (2 (2 the) (2 behavior)) (2 (2 (2 is) (2 undefined)) (2 (2 if) (2 (2 you) (2 (2 run) (2 (2 with) (2 inline-code)))))))))))) (2 .)))
Feel free to inline-code the test.
(2 (2 Feel) (2 (2 (3 free) (2 (2 to) (2 (2 inline-code) (2 (2 the) (2 test))))) (2 .)))
We call a "landing pad" a segment of code which is run whenever an unwinding happens.
(1 (2 We) (1 (2 (2 call) (1 (2 (2 (2 a) (2 (2 ``) (2 (2 landing) (2 (2 pad) (2 ''))))) (2 (2 a) (2 segment))) (2 (2 of) (2 (2 code) (1 (2 which) (1 (2 is) (2 (2 run) (2 (2 whenever) (2 (2 (2 an) (2 unwinding)) (2 happens)))))))))) (2 .)))
This means that after some function was called, something down in the call stack ended up calling inline-code triggering an unwinding of the stack.
(1 (2 This) (1 (2 (2 means) (1 (2 that) (1 (2 (2 after) (2 (2 (2 some) (2 function)) (2 (2 was) (2 called)))) (1 (2 ,) (1 (2 something) (1 (2 (2 down) (2 (2 in) (2 (2 the) (2 (2 call) (2 stack))))) (1 (2 (2 ended) (2 up)) (1 (2 (2 calling) (2 inline-code)) (2 (2 triggering) (2 (2 (2 an) (2 unwinding)) (2 (2 of) (2 (2 the) (2 stack))))))))))))) (2 .)))
Each call instruction in a function may trigger unwinding, and is then associated with a landing pad.
(1 (2 (2 (2 Each) (2 (2 call) (2 instruction))) (2 (2 in) (2 (2 a) (2 function)))) (1 (1 (1 (2 (2 (2 may) (2 (2 trigger) (2 unwinding))) (2 ,)) (2 and)) (2 (2 (2 is) (2 then)) (2 (2 associated) (2 (2 with) (2 (2 a) (2 (2 landing) (2 pad))))))) (2 .)))
These landing pads are what run destructors when the stack unwinds.
(1 (2 (2 These) (2 (2 landing) (2 pads))) (2 (2 (2 are) (2 (2 what) (2 (2 (2 run) (2 destructors)) (2 (2 when) (2 (2 (2 the) (2 stack)) (2 unwinds)))))) (2 .)))
With the inline-code switch, none of these landing pads are generated.
(1 (2 (2 With) (2 (2 the) (2 (2 inline-code) (2 switch)))) (1 (2 ,) (1 (1 (2 none) (2 (2 of) (2 (2 these) (2 (2 landing) (2 pads))))) (2 (2 (2 are) (2 generated)) (2 .)))))
They end up calling special functions in the inline-code library which may not be present on all platforms.
(1 (2 They) (1 (1 (2 (2 end) (2 up)) (1 (2 (2 calling) (2 (3 special) (2 functions))) (2 (2 in) (1 (2 (2 the) (2 (2 inline-code) (2 library))) (1 (2 which) (1 (1 (2 may) (1 not)) (2 (2 be) (2 (2 present) (2 (2 on) (2 (2 all) (2 platforms))))))))))) (2 .)))
On ARM, it looks like the codegen is so different that if the code isn't built to have exceptions thrown that there's no way for libunwind to unwind the stack when an exception is thrown.
(1 (2 (2 On) (2 ARM)) (1 (2 ,) (1 (2 it) (1 (1 (2 looks) (1 (2 like) (1 (2 (2 the) (2 codegen)) (1 (2 (2 is) (2 (2 so) (2 different))) (1 (2 (2 that) (2 if)) (1 (2 (2 the) (2 code)) (2 (1 (2 is) (2 n't)) (1 (2 built) (1 (2 to) (1 (2 have) (1 (2 exceptions) (1 (2 thrown) (1 (2 that) (1 (2 there) (1 (2 's) (2 (1 no) (2 (2 way) (2 (2 for) (2 (2 libunwind) (2 (2 to) (2 (2 (2 unwind) (2 (2 the) (2 stack))) (2 (2 when) (2 (2 (2 an) (2 exception)) (2 (2 is) (2 thrown))))))))))))))))))))))))) (2 .)))))
I suppose it doesn't affect x86 and x86_64 codegen that much.
(1 (2 I) (1 (2 (2 suppose) (1 (2 it) (1 (1 (2 does) (2 n't)) (2 (2 (2 affect) (2 (2 x86) (2 (2 and) (2 (2 x86_64) (2 codegen))))) (2 (2 that) (2 much)))))) (2 .)))
I was basically trying to think of a way to test that inline-code actually works (it was broken recently), so that's what this test is doing.
(1 (1 (1 (1 (1 (2 I) (1 (2 (2 was) (2 basically)) (1 (2 trying) (2 (2 to) (2 (2 think) (1 (2 of) (1 (2 a) (1 (2 way) (1 (2 to) (1 (2 test) (2 (2 that) (3 (2 inline-code) (3 (2 actually) (2 (2 works) (2 (2 -LRB-) (2 (2 (2 it) (2 (2 was) (2 (2 broken) (2 recently)))) (2 -RRB-))))))))))))))))) (2 ,)) (2 so)) (2 (2 that) (2 (2 's) (2 (2 what) (2 (2 (2 this) (2 test)) (2 (2 is) (2 doing))))))) (2 .))
The behavior is ARM-specific (from what I believe), so I think it's ok to just ignore it on android.
(1 (1 (1 (1 (1 (2 (2 The) (2 behavior)) (2 (2 is) (2 (2 ARM-specific) (2 (2 -LRB-) (2 (2 (2 from) (2 (2 what) (2 (2 I) (2 believe)))) (2 -RRB-)))))) (2 ,)) (2 so)) (1 (2 I) (1 (2 think) (1 (2 it) (1 (2 's) (1 (2 ok) (2 (2 to) (1 (2 just) (2 (2 (1 ignore) (2 it)) (2 (2 on) (2 android))))))))))) (2 .))
Ahh, got you.
(3 (2 (2 Ahh) (2 ,)) (3 (2 (2 got) (2 you)) (2 .)))
Your test is making sure that it is behaving incorrectly, as opposed to correctly behaving unsafely.
(1 (2 (2 Your) (2 test)) (1 (1 (2 is) (1 (2 (2 making) (2 sure)) (1 (2 that) (1 (2 it) (1 (2 is) (1 (2 (2 (2 behaving) (2 incorrectly)) (2 ,)) (1 (2 as) (3 (2 opposed) (2 (2 to) (3 (3 correctly) (2 (2 behaving) (2 unsafely)))))))))))) (2 .)))
Well, if "undefined" is sufficient I'll xfail the test for android (just wish it failed more concretely than with an illegal instruction).
(1 (2 Well) (1 (2 ,) (1 (2 (2 if) (3 (2 ``) (3 (2 undefined) (3 (2 '') (2 (2 is) (3 sufficient)))))) (1 (2 I) (1 (1 (2 'll) (1 (2 xfail) (1 (2 (2 the) (2 test)) (1 (2 for) (1 (2 android) (1 (2 -LRB-) (1 (1 (2 just) (1 (2 wish) (1 (2 it) (1 (1 (1 failed) (2 (2 more) (2 concretely))) (2 (2 than) (2 (2 with) (2 (2 an) (2 (2 illegal) (2 instruction))))))))) (2 -RRB-)))))))) (2 .))))))
I'm not sure if/how to test this.
(1 (2 I) (1 (1 (2 (2 (2 'm) (1 not)) (2 sure)) (2 (2 if/how) (2 (2 to) (2 (2 test) (2 this))))) (2 .)))
Passes make check.
(2 (2 Passes) (2 (2 (2 make) (3 check)) (2 .)))
Before
After
Saw this mentioned in #10942.
(1 (2 (2 Before) (2 (2 After) (2 Saw))) (2 (2 this) (2 (2 (2 mentioned) (2 (2 in) (2 (2 #) (2 10942)))) (2 .))))
Yeah, but I didn't think it should be even trying to unwind.
(1 (2 (2 Yeah) (2 (2 ,) (2 (2 but) (2 (2 I) (2 (2 (2 did) (2 n't)) (2 think)))))) (1 (2 it) (1 (2 (2 should) (2 (2 be) (2 (2 even) (2 (2 trying) (2 (2 to) (2 unwind)))))) (2 .))))
I'll admit to not being sure of the intent behind the block-code.
(2 (2 I) (2 (2 (2 'll) (2 (2 admit) (2 (2 to) (2 (1 not) (2 (2 (2 being) (2 sure)) (2 (2 of) (2 (2 (2 the) (2 intent)) (2 (2 behind) (2 (2 the) (2 block-code)))))))))) (2 .)))
.
(2 .)
Is saying that exceptions with block-code.
(2 (2 (2 Is) (2 (2 (2 saying) (2 (2 that) (2 exceptions))) (2 (2 with) (2 block-code)))) (2 .))
gives undefined behaviour all right?
(2 (3 (2 (2 gives) (2 (2 undefined) (2 behaviour))) (2 (2 all) (3 right))) (2 ?))
It looks like the X86 code just doesn't call destructors (I'm not sure if that is better or worse than trying to execute arbitrary code).
(1 (2 It) (1 (1 (1 (2 looks) (1 (2 like) (1 (2 (2 the) (2 (2 X86) (2 code))) (1 (2 just) (1 (1 (2 does) (2 n't)) (2 (2 call) (2 destructors))))))) (1 (2 -LRB-) (2 (1 (2 I) (1 (2 (2 (2 'm) (1 not)) (2 sure)) (1 (2 if) (1 (2 that) (1 (2 is) (1 (1 (2 (4 better) (2 or)) (1 worse)) (2 (2 than) (2 (2 trying) (2 (2 to) (2 (2 execute) (2 (2 arbitrary) (2 code)))))))))))) (2 -RRB-)))) (2 .)))
Closing in favor of #12207 (llvm removed these options).
(1 (2 (2 Closing) (2 (2 in) (2 (2 (2 favor) (2 (2 of) (2 (2 #) (2 12207)))) (2 (2 -LRB-) (2 (2 (2 llvm) (2 (2 removed) (2 (2 these) (2 options)))) (2 -RRB-)))))) (2 .))
Should be fixed for real now.
(2 (2 (2 Should) (2 (2 be) (2 (2 (2 fixed) (2 (2 for) (3 real))) (2 now)))) (2 .))
Actually the fix was wrong.
(1 (2 Actually) (1 (2 (2 the) (2 fix)) (1 (1 (2 was) (1 wrong)) (2 .))))
I have a pending more correct fix.
(1 (2 I) (1 (1 (2 have) (1 (2 a) (2 (2 pending) (2 (2 (2 more) (2 correct)) (2 fix))))) (2 .)))
The following code compiles and outputs inline-code.
(1 (2 (2 The) (2 (2 following) (2 code))) (2 (2 (2 (2 (2 compiles) (2 and)) (2 outputs)) (2 inline-code)) (2 .)))
It also fails if you use inline-code, which uses reference modes instead of region pointers.
(0 (2 It) (0 (2 also) (0 (0 (0 fails) (1 (2 if) (1 (2 you) (1 (2 use) (1 (2 (2 inline-code) (2 ,)) (1 (2 which) (1 (2 uses) (1 (2 (2 reference) (2 modes)) (2 (2 instead) (2 (2 of) (2 (2 region) (2 pointers)))))))))))) (2 .))))
It should be rejected.
(1 (2 It) (1 (1 (2 should) (2 (2 be) (1 rejected))) (2 .)))
:broken_heart: Test failed - auto-mac-32-opt.
(1 (2 :) (1 (1 (1 (2 (2 broken_heart) (2 :)) (1 (2 Test) (1 failed))) (2 -)) (2 (2 auto-mac-32-opt) (2 .))))
On Wed, Apr 08, 2015 at 04:26:16AM -0700, bluss wrote:.
(1 (2 (2 On) (2 Wed)) (1 (2 ,) (1 (1 (2 (2 (2 (2 Apr) (2 08)) (2 ,)) (2 2015)) (2 (2 at) (1 (2 (2 (2 04:26:16) (2 (2 AM) (2 -0700))) (2 ,)) (2 bluss)))) (2 (2 (2 wrote) (2 :)) (2 .)))))
Indeed, my bad.
(1 (1 (2 (2 Indeed) (2 ,)) (1 (2 my) (0 bad))) (2 .))
Ah, I only make inline-code.
(2 (2 Ah) (1 (2 ,) (1 (2 I) (1 (2 only) (2 (2 (2 make) (2 inline-code)) (2 .))))))
D'oh!
(2 (2 D'oh) (2 !))
This should have been marked inline-code, right?
(2 (2 This) (1 (3 (2 should) (3 (2 have) (3 (2 been) (3 (3 (2 (2 marked) (2 inline-code)) (2 ,)) (3 right))))) (2 ?)))
Just reminding, so that we get this right next time.
(3 (2 (2 Just) (2 reminding)) (3 (2 ,) (3 (3 (2 so) (3 (2 that) (3 (2 we) (3 (2 get) (3 (2 this) (3 (3 right) (2 (2 next) (2 time)))))))) (2 .))))
@bors r=huon rollup 49f2a56.
(1 (2 (2 @bors) (2 r)) (2 (2 (2 =) (2 (2 huon) (2 (2 rollup) (2 49f2a56)))) (2 .)))
:hourglass: Testing commit 48a023c with merge 4ca7d49...
@bors: r+ .
(1 (2 :) (1 (1 (1 (1 (1 (1 (2 (2 hourglass) (2 :)) (1 (2 (2 Testing) (2 (2 commit) (2 48a023c))) (2 (2 with) (2 (2 merge) (2 4ca7d49))))) (2 ...)) (2 @bors)) (2 :)) (2 (2 r) (2 +))) (2 .)))
Nope.
(2 (2 Nope) (2 .))
:pushpin: Commit 48a023c has been approved by inline-code
<!-- @bors r=Manishearth 48a023c2e946f6df4217c62be71313484e673c40 -->
Will tests need updating?
(1 (2 :) (1 (1 (2 (2 pushpin) (2 :)) (1 (2 (2 Commit) (2 48a023c)) (2 (2 has) (2 (2 been) (2 (2 approved) (2 (2 by) (2 (2 inline-code) (2 (2 <!-- @bors r=Manishearth 48a023c2e946f6df4217c62be71313484e673c40 -->) (2 (2 Will) (2 tests)))))))))) (2 (2 (2 need) (2 updating)) (2 ?))))
:pushpin: Commit 49f2a56 has been approved by inline-code
<!-- @bors r=huon 49f2a566663b125334245563f4dbe51778296feb -->
Grr.
(1 (2 :) (1 (2 (2 (2 pushpin) (2 :)) (2 (2 Commit) (2 49f2a56))) (1 (1 (2 has) (1 (2 been) (2 (2 approved) (2 (2 by) (2 (2 inline-code) (2 (2 <!-- @bors r=huon 49f2a566663b125334245563f4dbe51778296feb -->) (2 Grr))))))) (2 .))))
I though inline-code passed locally...must be I got confused.
(1 (2 I) (1 (1 (2 though) (1 (2 (2 inline-code) (2 (2 passed) (2 locally))) (2 (2 ...) (2 (2 must) (2 (2 be) (2 I)))))) (1 (1 (2 got) (1 confused)) (2 .))))
r?
(2 (2 r) (2 ?))
@huonw
(rust_highfive has picked a reviewer for you, use r?
(1 (2 (2 @huonw) (2 (2 -LRB-) (2 (2 rust_highfive) (2 (2 has) (2 (2 picked) (2 (2 (2 a) (2 reviewer)) (2 (2 for) (2 you)))))))) (2 (2 ,) (2 (2 (2 use) (2 r)) (2 ?))))
to override)
So this gets jemalloc cross-compiling, on linux at least.
(1 (1 (2 to) (1 (1 (1 (2 (2 override) (2 -RRB-)) (1 (2 So) (2 (2 this) (2 (2 gets) (2 (2 jemalloc) (2 cross-compiling)))))) (2 ,)) (2 (2 on) (2 (2 linux) (2 (2 at) (1 least)))))) (2 .))
Hopefully this gets us one step closer to a green incoming again.
(3 (2 Hopefully) (3 (2 this) (3 (3 (2 gets) (3 (3 us) (3 (2 (2 (2 (2 one) (2 step)) (2 closer)) (2 (2 to) (2 (2 a) (2 (2 green) (2 incoming))))) (2 again)))) (2 .))))
jemalloc produces segv on android.
(2 (2 jemalloc) (2 (2 (2 produces) (2 (2 segv) (2 (2 on) (2 android)))) (2 .)))
So this gets jemalloc cross-compiling, on linux at least.
(1 (2 So) (1 (2 this) (2 (2 (2 gets) (2 (1 (2 (2 (2 jemalloc) (2 cross-compiling)) (2 ,)) (2 (2 on) (2 linux))) (2 (2 at) (1 least)))) (2 .))))
Hopefully this gets us one step closer to a green incoming again.
(3 (2 Hopefully) (3 (2 this) (3 (3 (2 gets) (3 (3 us) (3 (2 (2 (2 (2 one) (2 step)) (2 closer)) (2 (2 to) (2 (2 a) (2 (2 green) (2 incoming))))) (2 again)))) (2 .))))
You mean the "expected"-related ones?
(2 (2 You) (2 (2 (1 mean) (2 (2 the) (2 (2 ``) (2 (1 expected) (2 (2 '') (2 (2 -) (2 (2 related) (2 ones)))))))) (2 ?)))
I will remove them.
(2 (2 I) (2 (2 (2 will) (2 (2 remove) (2 them))) (2 .)))
Please add a comment saying what the test is testing.
(2 (2 Please) (2 (2 (3 add) (2 (2 (2 a) (2 comment)) (2 (2 saying) (2 (2 what) (2 (2 (2 the) (2 test)) (2 (2 is) (2 testing))))))) (2 .)))
Currently inline-code is generated in the desugaring process, and is inline-code.
(1 (2 Currently) (1 (2 inline-code) (3 (2 (2 (2 (2 (2 is) (2 (2 generated) (2 (2 in) (2 (2 the) (2 (2 desugaring) (2 process)))))) (2 ,)) (2 and)) (2 (2 is) (2 inline-code))) (2 .))))
So it is a zero-sized tuple.
(1 (2 So) (2 (2 it) (2 (2 (2 is) (2 (2 a) (2 (2 zero-sized) (2 tuple)))) (2 .))))
Fixes #19991.
(2 (2 (2 Fixes) (2 (2 #) (2 19991))) (2 .))
r?
(2 (2 r) (2 ?))
@nick29581
(rust_highfive has picked a reviewer for you, use r?
(1 (2 (2 @nick29581) (2 (2 -LRB-) (2 (2 rust_highfive) (2 (2 has) (2 (2 picked) (2 (2 (2 a) (2 reviewer)) (2 (2 for) (2 you)))))))) (2 (2 ,) (2 (2 (2 use) (2 r)) (2 ?))))
to override)
What are you trying to detect by checking spans?
(1 (1 (2 to) (1 (2 (2 override) (2 -RRB-)) (2 (2 What) (1 (2 are) (2 (2 you) (2 (2 trying) (2 (2 to) (2 (2 detect) (2 (2 by) (3 (2 checking) (2 spans))))))))))) (2 ?))
This seems like a bad idea, since I don't see why the span for the whole expression and for the body should ever be the same (if they are at the moment, that might be a mistake).
(0 (2 This) (0 (0 (1 (1 (2 seems) (1 (2 like) (1 (2 a) (1 (0 bad) (2 idea))))) (2 ,)) (2 (2 since) (1 (2 I) (1 (2 (2 do) (2 n't)) (1 (2 see) (1 (2 why) (2 (2 (2 (2 the) (2 span)) (2 (2 (2 (2 for) (2 (2 the) (2 (2 whole) (2 expression)))) (2 and)) (2 (2 for) (2 (2 the) (2 body))))) (2 (2 (2 should) (2 ever)) (2 (2 be) (2 (2 (2 the) (2 same)) (2 (2 -LRB-) (2 (2 (2 if) (2 (2 they) (2 (2 are) (2 (2 at) (2 (2 (2 (2 the) (3 moment)) (2 ,)) (1 (2 that) (2 (2 might) (2 (2 be) (2 (2 a) (2 mistake)))))))))) (2 -RRB-))))))))))))) (2 .)))
It is definitely an ugly hack.
(1 (2 It) (1 (1 (2 (2 is) (3 definitely)) (1 (2 an) (1 (1 ugly) (1 hack)))) (2 .)))
When an inline-code construct without an inline-code block is desugared into a inline-code expression, inline-code is generated by the compiler, which has the same span as the whole expression.
(1 (2 (2 When) (1 (2 (2 (2 an) (2 (2 inline-code) (2 construct))) (2 (2 without) (2 (2 an) (2 (2 inline-code) (2 block))))) (2 (2 is) (2 (2 desugared) (2 (2 into) (2 (2 a) (2 (2 inline-code) (2 expression)))))))) (1 (2 ,) (1 (2 inline-code) (1 (1 (2 is) (1 (2 generated) (1 (2 by) (1 (2 (2 (2 the) (2 compiler)) (2 ,)) (2 (2 which) (2 (2 has) (2 (2 (2 the) (2 (2 same) (2 span))) (2 (2 as) (2 (2 the) (2 (2 whole) (2 expression))))))))))) (2 .)))))
I believe that's because it isn't an actual code.
(1 (2 I) (1 (2 (2 believe) (2 (2 that) (2 (2 's) (2 (2 because) (1 (2 it) (1 (1 (2 is) (2 n't)) (2 (2 an) (2 (2 actual) (2 code))))))))) (2 .)))
I could not guess a better span to be used to modify the desugaring process, nor find a reliable method to detect a construct without an inline-code block.
(1 (2 I) (1 (1 (1 (1 (1 (2 (2 could) (1 not)) (1 (2 (2 guess) (2 (2 a) (2 (4 better) (2 span)))) (2 (2 to) (2 (2 be) (2 (2 used) (2 (2 to) (2 (2 modify) (2 (2 the) (2 (2 desugaring) (2 process)))))))))) (2 ,)) (2 nor)) (2 (3 (2 find) (3 (2 a) (3 (3 reliable) (2 method)))) (2 (2 to) (2 (2 (2 detect) (2 (2 a) (2 construct))) (2 (2 without) (2 (2 an) (2 (2 inline-code) (2 block)))))))) (2 .)))
Could you suggest an alternative?
(2 (2 (2 (2 Could) (2 you)) (2 (2 suggest) (2 (2 an) (2 alternative)))) (2 ?))
I don't think you need this comment any more.
(1 (2 I) (1 (2 (2 (2 do) (2 n't)) (2 (2 think) (2 (2 you) (2 (2 (2 need) (2 (2 this) (2 comment))) (2 (2 any) (2 more)))))) (2 .)))
Can you add a compile-fail test for the new error message?
(2 (2 (2 (2 Can) (2 you)) (2 (3 add) (1 (2 (2 a) (2 (2 compile-fail) (2 test))) (2 (2 for) (1 (2 the) (1 (3 new) (1 (1 error) (2 message)))))))) (2 ?))
I'd prefer to just use ty_nil (or whatever it has changed to now, I think it is just a 0-element tuple), if that is what you want here.
(1 (2 I) (2 (2 (2 'd) (2 (2 (2 (2 prefer) (2 (2 (2 (2 to) (2 just)) (2 (2 use) (2 ty_nil))) (2 (2 -LRB-) (2 (2 or) (2 (2 (1 whatever) (1 (2 (2 (2 it) (2 (2 has) (2 (2 changed) (2 (2 to) (2 now))))) (2 ,)) (2 (2 I) (2 (2 think) (2 (2 it) (2 (2 (2 is) (2 just)) (2 (2 a) (2 (2 0-element) (2 tuple))))))))) (2 -RRB-)))))) (2 ,)) (2 (2 if) (2 (2 that) (2 (2 is) (2 (2 what) (2 (2 you) (2 (2 want) (2 here))))))))) (2 .)))
It's not clear to me that bty must be nil, even if it is now.
(1 (2 It) (1 (1 (1 (2 (2 's) (1 not)) (2 (2 clear) (2 (2 to) (3 me)))) (2 (2 that) (2 (2 bty) (2 (2 must) (2 (2 (2 (2 be) (2 nil)) (2 ,)) (2 (2 even) (2 (2 if) (2 (2 it) (2 (2 is) (2 now)))))))))) (2 .)))
I think a better solution would be to extend inline-code to capture that information when desugaring.
(1 (2 I) (2 (2 (2 think) (2 (2 (2 a) (2 (4 better) (3 solution))) (2 (2 would) (2 (2 be) (2 (2 to) (3 (2 extend) (2 (2 inline-code) (2 (2 to) (2 (2 (2 capture) (2 (2 that) (2 information))) (2 (2 when) (2 desugaring))))))))))) (2 .)))
inline-code, perhaps.
(2 (2 inline-code) (2 (2 ,) (2 (2 perhaps) (2 .))))
We may want to drop the Match prefix from the variants while we're at it.
(1 (2 We) (1 (1 (2 may) (1 (2 want) (2 (2 to) (2 (2 (2 (2 drop) (2 (2 the) (2 (2 Match) (2 prefix)))) (2 (2 from) (2 (2 the) (2 variants)))) (2 (2 while) (2 (2 we) (2 (2 're) (2 (2 at) (2 it))))))))) (2 .)))
Thanks for the fixes!
(3 (2 (2 Thanks) (2 (2 for) (2 (2 the) (2 fixes)))) (2 !))
Looks good, r=me with an extra comment in the test.
(1 (3 (3 Looks) (3 good)) (1 (2 ,) (1 (2 r) (1 (2 (3 (2 (2 =) (3 me)) (3 (2 with) (3 (2 an) (2 (2 extra) (2 comment))))) (2 (2 in) (2 (2 the) (2 test)))) (2 .)))))
Fixes #19991.
(2 (2 (2 Fixes) (2 (2 #) (2 19991))) (2 .))
@jakub- Wonderful!
(3 (3 (2 (2 @jakub) (2 -)) (3 Wonderful)) (2 !))
I should have thought of that.
(2 (2 I) (2 (2 (2 should) (2 (2 have) (2 (2 thought) (2 (2 of) (2 that))))) (2 .)))
I will adopt your suggestion.
(2 (2 I) (2 (2 (2 will) (2 (2 adopt) (2 (2 your) (2 suggestion)))) (2 .)))
This catches uses of unstable traits in
and
Builds on an @alexcrichton PR.
(1 (2 This) (1 (1 (3 (2 (3 (2 catches) (2 (2 uses) (2 (2 of) (2 (1 unstable) (2 traits))))) (2 in)) (2 and)) (2 (2 Builds) (2 (2 on) (2 (2 an) (2 (2 @alexcrichton) (2 PR)))))) (2 .)))
r?
(2 (2 r) (2 ?))
@aturon.
(2 (2 @aturon) (2 .))
This catches uses of unstable traits in
and
Builds on an @alexcrichton PR.
(1 (2 This) (1 (1 (3 (2 (3 (2 catches) (2 (2 uses) (2 (2 of) (2 (1 unstable) (2 traits))))) (2 in)) (2 and)) (2 (2 Builds) (2 (2 on) (2 (2 an) (2 (2 @alexcrichton) (2 PR)))))) (2 .)))
r?
(2 (2 r) (2 ?))
@aturon.
(2 (2 @aturon) (2 .))
The LLVM bug was just one blocker for getting this compiler bootstrapped, there are likely to be a good number of other bugs (perhaps more LLVM ones) to overcome before we get to a full compiler.
(1 (1 (2 (2 The) (2 (2 LLVM) (2 bug))) (1 (2 was) (1 (2 (2 just) (2 (2 one) (2 blocker))) (2 (2 for) (2 (2 getting) (2 (2 this) (2 (2 compiler) (2 bootstrapped)))))))) (1 (2 ,) (1 (2 there) (1 (2 (2 are) (2 (2 likely) (2 (2 to) (3 (2 (3 (2 be) (3 (3 (2 a) (3 (3 good) (2 number))) (2 (2 of) (2 (2 other) (2 bugs))))) (2 (2 -LRB-) (2 (2 (2 (2 perhaps) (2 more)) (2 (2 LLVM) (2 ones))) (2 -RRB-)))) (2 (2 to) (2 (2 overcome) (2 (2 before) (2 (2 we) (2 (2 get) (2 (2 to) (3 (2 a) (2 (3 full) (2 compiler))))))))))))) (2 .)))))
Hopefully soon though!
(1 (2 (2 Hopefully) (2 (2 soon) (2 though))) (2 !))
Once URL lands and new snapshots are prepared I believe that we're ready to start bootstrapping in the same manner 64-bit is doing so today.
(1 (2 (2 Once) (1 (3 (2 (2 (2 URL) (2 lands)) (2 and)) (2 (3 new) (2 snapshots))) (1 (2 are) (1 (2 prepared) (1 (2 I) (2 (2 believe) (2 (2 that) (2 (2 we) (2 (2 're) (1 (2 ready) (2 (2 to) (2 (2 start) (2 (2 bootstrapping) (2 (2 in) (2 (2 the) (2 (2 same) (2 (2 manner) (2 64-bit)))))))))))))))))) (2 (2 (2 is) (2 (2 (2 doing) (2 so)) (2 today))) (2 .)))
We should provide nightlies for a i686-pc-windows-msvc host compiler (much in the same way we have a x86_64-pc-windows-msvc host compiler).
(1 (2 We) (1 (1 (2 should) (1 (2 (2 (2 provide) (2 nightlies)) (2 (2 for) (3 (2 a) (2 (2 i686-pc-windows-msvc) (2 (2 host) (2 compiler)))))) (2 (2 -LRB-) (2 (2 (2 much) (2 (2 in) (2 (2 (2 the) (2 (2 same) (2 way))) (2 (2 we) (2 (2 have) (3 (2 a) (2 (2 x86_64-pc-windows-msvc) (2 (2 host) (2 compiler))))))))) (2 -RRB-))))) (2 .)))
Unfortunately there is currently a bug in LLVM preventing us from doing so, so the bootstrap aborts at libsyntax because of this bug: URL.
(1 (1 (1 (1 (1 (1 Unfortunately) (2 (2 there) (2 (2 (2 is) (2 currently)) (2 (2 (2 a) (2 bug)) (2 (2 in) (2 (2 LLVM) (2 (2 (2 preventing) (3 us)) (2 (2 from) (2 (2 doing) (2 so)))))))))) (2 ,)) (2 so)) (2 (2 (2 the) (2 bootstrap)) (2 (2 (2 (2 aborts) (2 (2 at) (2 (2 libsyntax) (2 (2 because) (2 (2 of) (2 (2 this) (2 bug))))))) (2 :)) (2 URL)))) (2 .))
Build system support is being added in URL but it's largely untested because a compiler could never be produced!
(1 (1 (2 (1 (2 (2 Build) (2 (2 system) (2 support))) (1 (2 is) (2 (2 being) (3 (2 added) (2 (2 in) (2 URL)))))) (2 but)) (1 (2 it) (1 (2 (2 's) (2 (2 largely) (2 untested))) (2 (2 because) (2 (2 (2 a) (2 compiler)) (2 (2 (2 could) (2 never)) (2 (2 be) (2 produced)))))))) (2 !))
Now that the llvm bug is closed, what in what rough timeline can we expect an i686-pc-windows-msvc triple?
(2 (2 (2 Now) (2 (2 that) (2 (2 (2 the) (2 (2 llvm) (2 bug))) (2 (2 is) (2 closed))))) (2 (2 ,) (2 (2 (2 what) (2 (2 in) (2 (2 what) (2 (1 rough) (2 timeline))))) (2 (2 (2 (2 can) (2 we)) (2 (2 expect) (2 (2 an) (2 (2 i686-pc-windows-msvc) (2 triple))))) (2 ?)))))
I don't want to be pushy, I'm just wondering whether we need to wait for an llvm release (not sure how often that happens) or what other roadblocks there might be...
Thanks in advance & keep up the great work!
(4 (3 (1 (1 (2 I) (1 (2 (2 do) (2 n't)) (1 (2 want) (1 (2 to) (1 (2 (2 (2 be) (2 pushy)) (2 ,)) (1 (1 (1 (2 I) (1 (2 (2 'm) (2 just)) (1 (2 wondering) (2 (2 whether) (2 (2 we) (1 (2 need) (1 (2 to) (1 (1 (2 wait) (2 (2 for) (2 (2 an) (2 (2 llvm) (2 release))))) (2 (2 -LRB-) (2 (2 (2 (1 not) (2 sure)) (2 (2 (2 how) (2 often)) (2 (2 that) (2 happens)))) (2 -RRB-))))))))))) (2 or)) (2 (2 what) (2 (2 (2 other) (2 roadblocks)) (2 (2 there) (2 (2 might) (2 be))))))))))) (2 ...)) (3 (2 (2 Thanks) (2 (2 in) (2 advance))) (3 (2 &) (3 (2 (2 keep) (2 up)) (3 (2 the) (3 (4 great) (2 work))))))) (2 !))
:)
Dupe of #14916.
(2 (2 (2 (2 :-RRB-) (2 Dupe)) (2 (2 of) (2 (2 #) (2 14916)))) (2 .))
It would be incredibly useful to be able to download a bundle of all the documentation provided at:.
(1 (2 It) (1 (1 (1 (2 would) (1 (2 be) (1 (3 incredibly) (1 (2 useful) (2 (2 to) (2 (2 be) (2 (3 able) (2 (2 to) (2 (2 download) (2 (2 (2 a) (2 bundle)) (2 (2 of) (2 (2 (2 all) (2 (2 the) (2 documentation))) (2 (2 provided) (2 at)))))))))))))) (2 :)) (2 .)))
URL.
(2 (2 URL) (2 .))
This content is presumably built as part of the nightly build process anyway, so it would suffice to zip it up (or create a inline-code) and add a download link.
(1 (2 (2 This) (3 content)) (1 (1 (2 (2 is) (2 presumably)) (1 (2 built) (1 (2 as) (1 (2 (2 part) (2 (2 of) (2 (2 the) (2 nightly)))) (1 (2 (2 (2 (2 build) (2 process)) (2 anyway)) (2 ,)) (1 (2 so) (1 (2 it) (1 (2 would) (1 (2 suffice) (2 (2 to) (2 (2 (2 (2 (2 (2 zip) (2 it)) (2 up)) (2 (2 -LRB-) (2 (2 or) (2 (3 (3 create) (2 (2 a) (2 inline-code))) (2 -RRB-))))) (2 and)) (2 (3 add) (2 (2 a) (2 (2 download) (2 link))))))))))))))) (2 .)))
Since inline-code seems to be the recommended way to install nightly builds, perhaps there could be a flag such as inline-code to also download the corresponding doc bundle.
(1 (2 (2 Since) (2 (2 inline-code) (2 (2 seems) (2 (2 to) (2 (2 be) (2 (2 the) (2 (4 recommended) (2 (2 way) (2 (2 to) (2 (2 install) (2 (2 nightly) (2 builds)))))))))))) (2 (2 ,) (2 (2 perhaps) (1 (2 there) (1 (1 (2 could) (1 (2 be) (1 (2 (2 a) (2 flag)) (1 (2 such) (2 (2 as) (2 (2 inline-code) (2 (2 to) (2 (2 also) (2 (2 download) (2 (2 the) (2 (2 corresponding) (2 (2 doc) (2 bundle))))))))))))) (2 .))))))
As someone who frequently works offline, having access to the docs (especially the library references!)
(2 (2 As) (1 (1 (2 someone) (3 (2 who) (3 (2 frequently) (3 (3 (3 (2 works) (2 offline)) (2 ,)) (2 (2 (2 having) (2 access)) (2 (2 to) (2 (2 the) (2 docs)))))))) (2 (2 -LRB-) (2 (2 especially) (2 (2 (2 (2 (2 the) (2 library)) (2 references)) (2 !)) (2 -RRB-))))))
without having to rebuild everything would be a great help.
(1 (2 (2 without) (2 (2 having) (2 (2 to) (2 rebuild)))) (2 (2 everything) (3 (3 (2 would) (3 (2 be) (3 (2 a) (3 (4 great) (2 help))))) (2 .))))
Thanks!
(3 (2 Thanks) (2 !))
I'm not the first one to see this one (#33733, #33015 -promise I'm not drunk tho heh) while building a brand new project with a single dependency:.
(1 (2 I) (1 (1 (1 (2 (2 'm) (1 not)) (2 (2 the) (2 (2 first) (2 (2 one) (2 (2 to) (2 (2 (2 see) (2 (2 (2 this) (2 one)) (2 (2 -LRB-) (2 (2 (2 (2 (2 (2 (2 #) (2 33733)) (2 ,)) (2 (2 #) (2 33015))) (2 -)) (2 (3 (3 promise) (2 I)) (1 (2 (2 'm) (1 not)) (2 (2 drunk) (2 (2 tho) (2 heh)))))) (2 -RRB-))))) (2 (2 while) (2 (2 (2 building) (2 (2 a) (2 brand))) (2 (2 (3 new) (2 project)) (2 (2 with) (2 (2 a) (2 (2 single) (2 dependency))))))))))))) (2 :)) (2 .)))
The full trace;
## Meta
and 
Interestingly, @filmor seems to have encountered the same issue with the same crate.
(1 (1 (3 (2 (2 The) (2 (3 full) (2 trace))) (2 ;)) (1 (2 (2 ##) (2 (2 (2 Meta) (2 and)) (2 Interestingly))) (2 (2 ,) (2 (2 @filmor) (1 (2 seems) (2 (2 to) (2 (2 have) (2 (2 (2 encountered) (2 (2 the) (2 (2 same) (2 issue)))) (2 (2 with) (2 (2 the) (2 (2 same) (2 crate)))))))))))) (2 .))
While he did make sure it was a completely fresh build, could you do the same?
(2 (3 (2 While) (3 (2 he) (3 (2 did) (3 (3 (2 make) (3 (2 sure) (3 (2 it) (3 (2 was) (3 (2 a) (3 (2 completely) (4 fresh))))))) (2 build))))) (2 (2 ,) (2 (2 (2 (2 could) (2 you)) (2 (2 do) (2 (2 the) (2 same)))) (2 ?))))
This ICE normally comes from having old crates around.
(1 (2 (2 This) (2 ICE)) (1 (2 normally) (2 (2 (3 comes) (2 (2 from) (2 (2 (2 having) (2 (2 old) (2 crates))) (2 around)))) (2 .))))
dupe of #34027.
(1 (1 (1 dupe) (2 (2 of) (2 (2 #) (2 34027)))) (2 .))
.
(2 .)
@nodakai it's the same issue here as in inline-code.
(2 (2 @nodakai) (2 (2 it) (2 (2 (2 (2 's) (2 (2 the) (2 (2 same) (2 issue)))) (2 (2 here) (2 (2 as) (2 (2 in) (2 inline-code))))) (2 .))))
It says "the default type for enum discriminants is inline-code", which is *kinda* true, but it suggests that the enum discriminants will be **represented** using inline-code by default, which *isn't* true.
(1 (1 (1 (1 (2 (2 It) (2 (2 (2 (2 says) (2 ``)) (2 (2 (2 (2 the) (2 (2 default) (2 type))) (2 (2 for) (2 (2 enum) (2 discriminants)))) (2 (2 is) (2 inline-code)))) (2 ''))) (2 (2 ,) (2 (2 (2 which) (2 (2 is) (2 (2 *) (2 (2 (2 kinda) (2 *)) (3 true))))) (2 ,)))) (2 but)) (1 (2 it) (1 (2 suggests) (1 (2 that) (1 (2 (2 the) (2 (2 enum) (2 discriminants))) (1 (2 will) (1 (2 be) (1 (2 **) (1 (2 (2 represented) (2 **)) (1 (2 (2 using) (2 inline-code)) (1 (2 by) (1 (2 (2 default) (2 ,)) (2 (2 which) (1 (2 *) (1 (1 (2 is) (2 n't)) (2 (2 *) (3 true))))))))))))))))) (2 .))
Given that both this patch and inline-code are talking about inline-code in the same place, it actually makes the semantics *less* clear.
(1 (2 (2 Given) (2 (2 that) (2 (2 (2 both) (2 (2 (2 (2 this) (2 patch)) (2 and)) (2 inline-code))) (2 (2 are) (2 (2 (2 talking) (2 (2 about) (2 inline-code))) (2 (2 in) (2 (2 the) (2 (2 same) (2 place))))))))) (2 (2 ,) (1 (2 it) (2 (2 actually) (2 (2 (2 makes) (2 (2 (2 the) (2 semantics)) (2 (2 (2 *) (2 (2 less) (2 *))) (2 clear)))) (2 .))))))
cf. URL.
(2 (2 cf.) (2 (2 URL) (2 .)))
It would be great if anyone could check my English.
(1 (2 It) (2 (2 (2 would) (2 (3 (2 be) (4 great)) (2 (2 if) (2 (2 anyone) (2 (2 could) (3 (3 check) (2 (2 my) (2 English)))))))) (2 .)))
I would agree with "specify"
r=me after.
(2 (2 I) (2 (2 (2 would) (2 (2 (2 agree) (2 (2 with) (2 (3 (2 ``) (2 (2 specify) (2 (2 '') (2 r)))) (2 (2 =) (3 me))))) (2 after))) (2 .)))
Extended the scope of the patch to include inline-code
Avoided the word "assign" in referring to enum declarations because "assign" often implies an update of a mutable state.
(1 (1 (2 Extended) (1 (2 (2 the) (2 scope)) (1 (2 of) (1 (2 the) (1 (2 patch) (2 (2 to) (1 (2 (2 (2 (2 (2 include) (2 (2 inline-code) (2 (2 Avoided) (2 (2 the) (2 word))))) (2 ``)) (2 assign)) (2 '')) (2 (2 in) (1 (2 referring) (2 (2 to) (2 (2 (2 enum) (2 declarations)) (2 (2 because) (2 (2 (2 ``) (2 (2 (2 assign) (2 '')) (2 often))) (2 (2 implies) (2 (2 (2 an) (2 update)) (2 (2 of) (2 (2 a) (2 (2 mutable) (2 state))))))))))))))))))) (2 .))
@Aatch Are you suggesting to fix inline-code?
(2 (2 @Aatch) (2 (2 (2 Are) (2 (2 you) (2 (2 suggesting) (2 (2 to) (2 (2 fix) (2 inline-code)))))) (2 ?)))
Could you elaborate on what you meant by "replicate" ?
(2 (2 (2 (2 Could) (2 you)) (3 (2 elaborate) (2 (2 on) (2 (2 what) (2 (2 you) (2 (2 meant) (2 (2 (2 (2 by) (2 ``)) (2 replicate)) (2 '')))))))) (2 ?))
I believe my patch isn't making the situation worse in terms of an ambiguity on what defaults to inline-code in enum definition.
(1 (2 I) (1 (1 (2 believe) (1 (2 (2 my) (2 patch)) (2 (1 (2 is) (2 n't)) (1 (1 (2 making) (1 (1 (2 (2 the) (2 situation)) (1 worse)) (2 (2 in) (2 (2 terms) (2 (2 of) (2 (2 an) (2 ambiguity))))))) (2 (2 on) (2 (2 what) (2 (2 defaults) (2 (2 to) (2 (2 inline-code) (2 (2 in) (2 (2 enum) (2 definition)))))))))))) (2 .)))
@nodakai I think I may have been misremembering your wording earlier, confusing it with the inline-code wording, so apologies for that.
(1 (2 @nodakai) (1 (2 I) (1 (1 (2 think) (1 (2 I) (1 (2 may) (1 (2 have) (1 (2 been) (1 (2 (2 (2 (2 misremembering) (2 (2 your) (2 wording))) (2 earlier)) (2 ,)) (1 (1 (1 (1 confusing) (2 it)) (2 (2 with) (2 (2 (2 (2 (2 the) (2 (2 inline-code) (2 wording))) (2 ,)) (2 so)) (2 apologies)))) (2 (2 for) (2 that))))))))) (2 .))))
Your wording is actually fine in this respect.
(3 (2 (2 Your) (2 wording)) (3 (3 (2 (2 is) (2 actually)) (3 (3 fine) (3 (2 in) (3 (2 this) (3 respect))))) (2 .)))
If you want to update the error index at the same time, go for it.
(1 (2 (2 If) (1 (2 you) (1 (2 want) (1 (2 to) (1 (1 (2 update) (1 (2 the) (1 (1 error) (2 index)))) (2 (2 at) (2 (2 the) (2 (2 same) (2 time))))))))) (2 (2 ,) (2 (2 (2 go) (2 (2 for) (2 it))) (2 .))))
The error explanation is somewhat misleading, we actually use the smallest valid integer type (with a preference for unsigned integers) when no inline-code is supplied.
(1 (1 (1 (2 The) (1 (1 error) (2 explanation))) (1 (2 is) (2 (2 somewhat) (1 misleading)))) (1 (2 ,) (1 (2 we) (1 (2 actually) (1 (1 (2 use) (1 (2 (2 (2 the) (2 (2 smallest) (2 (2 valid) (2 (2 integer) (2 type))))) (2 (2 -LRB-) (2 (2 (2 with) (2 (2 (2 a) (3 preference)) (2 (2 for) (2 (2 unsigned) (2 integers))))) (2 -RRB-)))) (2 (2 when) (1 (2 (1 no) (2 inline-code)) (2 (2 is) (3 supplied)))))) (2 .))))))
While typechecking treats the RHS as an inline-code for, well, checking, to say it "defaults" to it implies that it will be represented as such.
(2 (2 (2 While) (1 (2 typechecking) (1 (1 (2 (2 (2 treats) (2 (2 the) (2 RHS))) (2 (2 as) (2 (2 (2 an) (2 inline-code)) (2 (3 (2 for) (2 (2 ,) (3 (3 well) (2 ,)))) (2 checking))))) (2 ,)) (2 (2 to) (2 (2 say) (2 it)))))) (3 (2 (2 (2 ``) (2 (2 defaults) (2 ''))) (2 (2 to) (2 it))) (3 (2 (2 implies) (2 (2 that) (2 (2 it) (2 (2 will) (2 (2 be) (2 (2 represented) (2 (2 as) (2 such)))))))) (2 .))))
Especially given the context.
(2 (2 (2 Especially) (2 (2 given) (2 (2 the) (2 context)))) (2 .))
We probably shouldn't replicate that.
(1 (2 We) (1 (2 probably) (1 (2 (2 (2 should) (2 n't)) (2 (2 replicate) (2 that))) (2 .))))
r?
(2 (2 r) (2 ?))
@steveklabnik
(rust_highfive has picked a reviewer for you, use r?
(1 (2 (2 @steveklabnik) (2 (2 -LRB-) (2 (2 rust_highfive) (2 (2 has) (2 (2 picked) (2 (2 (2 a) (2 reviewer)) (2 (2 for) (2 you)))))))) (2 (2 ,) (2 (2 (2 use) (2 r)) (2 ?))))
to override)
cf. URL.
(2 (2 (2 to) (2 (2 (2 (2 override) (2 -RRB-)) (2 cf.)) (2 URL))) (2 .))
It would be great if anyone could check my English.
(1 (2 It) (2 (2 (2 would) (2 (3 (2 be) (4 great)) (2 (2 if) (2 (2 anyone) (2 (2 could) (3 (3 check) (2 (2 my) (2 English)))))))) (2 .)))
@apasel422 works for me .
(3 (2 @apasel422) (3 (2 (2 works) (2 (2 for) (3 me))) (2 .)))
@bors: r+ rollup
Thanks!
(1 (2 (2 (2 @bors) (2 :)) (2 (2 (2 r) (2 (2 +) (2 rollup))) (2 Thanks))) (2 !))
:pushpin: Commit 969d027 has been approved by inline-code
<!-- @bors r=steveklabnik 969d027e3597a0e4a6d06e4c2637b84b8a15d01c -->
@pnkfelix "specify"?
(1 (2 :) (1 (2 (2 (2 pushpin) (2 :)) (2 (2 Commit) (2 969d027))) (1 (1 (2 has) (1 (2 been) (2 (2 approved) (2 (2 by) (2 (2 inline-code) (2 (2 <!-- @bors r=steveklabnik 969d027e3597a0e4a6d06e4c2637b84b8a15d01c -->) (2 (2 @pnkfelix) (2 (2 ``) (2 (2 specify) (2 '')))))))))) (2 ?))))
@Aatch So, _what_ should I do?
(1 (1 (2 (2 (2 @Aatch) (2 So)) (2 ,)) (2 (2 _) (2 (2 what) (2 (2 _) (2 (2 should) (2 (2 I) (2 do))))))) (2 ?))
Are you suggesting me to fix inline-code at the same time?
(1 (2 (2 (2 Are) (2 you)) (2 (2 suggesting) (2 (3 me) (2 (2 to) (2 (2 (2 fix) (2 inline-code)) (2 (2 at) (2 (2 the) (2 (2 same) (2 time))))))))) (2 ?))
Could you also mark this method as inline-code?
(2 (2 (2 (2 (2 Could) (2 you)) (2 also)) (2 (2 (2 mark) (2 (2 this) (2 method))) (2 (2 as) (2 inline-code)))) (2 ?))
This module has been previously stabilized and new items are generally considered experimental for at least awhile.
(1 (1 (2 (2 (2 (2 This) (2 module)) (2 (2 has) (2 (2 been) (2 (2 previously) (2 stabilized))))) (2 and)) (3 (2 (3 new) (2 items)) (3 (2 (2 are) (2 generally)) (2 (2 (2 considered) (2 (2 experimental) (2 (2 for) (2 (2 at) (1 least))))) (1 awhile))))) (2 .))
inline-code!
(2 (2 inline-code) (2 !))
Yeah, I was considering inline-code too.
(1 (2 Yeah) (2 (2 ,) (2 (2 I) (2 (2 (2 was) (2 (2 considering) (2 (2 inline-code) (2 too)))) (2 .)))))
(I want someone else to make the decision...)
Currently there are no instances of inline-code or inline-code in the standard library, inline-code is used for mutably reversing a vector, and inline-code is used for reversing a forward iterator.
(1 (1 (1 (1 (1 (2 (2 -LRB-) (2 (2 (2 I) (2 (2 want) (2 (2 someone) (2 (2 (2 else) (2 (2 to) (2 (2 make) (2 (2 the) (2 decision))))) (2 ...))))) (2 -RRB-))) (1 (1 (2 Currently) (1 (2 there) (1 (2 are) (1 (1 (1 (1 no) (2 instances)) (2 (2 of) (2 (2 (2 inline-code) (2 or)) (2 inline-code)))) (2 (2 in) (2 (2 the) (2 (1 standard) (2 library)))))))) (2 (2 ,) (1 (2 inline-code) (1 (2 is) (2 (2 used) (2 (2 for) (2 (2 mutably) (2 (2 reversing) (2 (2 a) (2 vector))))))))))) (2 ,)) (2 and)) (2 (2 inline-code) (2 (2 is) (2 (2 used) (2 (2 for) (2 (2 reversing) (2 (2 a) (2 (2 forward) (2 iterator))))))))) (2 .))
(not much precedent to draw from).
(2 (2 -LRB-) (2 (2 (1 not) (2 much)) (3 (2 (2 (2 precedent) (2 (2 to) (2 (2 draw) (2 from)))) (2 -RRB-)) (2 .))))
So long as it's inline-code it doesn't matter a whole lot.
(1 (1 (2 So) (2 (2 long) (2 (2 as) (2 (2 it) (2 (2 's) (2 inline-code)))))) (1 (2 it) (1 (1 (1 (2 does) (2 n't)) (2 (2 matter) (3 (2 a) (2 (2 whole) (2 lot))))) (2 .))))
While I agree that this does become one instruction, is it worth the inline-code code?
(3 (2 (2 While) (2 (2 I) (2 (2 agree) (2 (2 that) (2 (2 this) (2 (2 does) (2 (2 become) (2 (2 one) (2 instruction))))))))) (2 (2 ,) (3 (3 (2 (2 is) (2 it)) (3 (2 worth) (2 (2 the) (2 (2 inline-code) (2 code))))) (2 ?))))
With optimizations is a branch still emitted?
(2 (2 (2 With) (2 (2 optimizations) (2 (2 is) (2 (2 (2 a) (2 branch)) (2 (2 still) (2 emitted)))))) (2 ?))
r?
(2 (2 r) (2 ?))
This flips the comparison and is designed to be used when sorting etc.
(1 (2 This) (1 (1 (2 (2 (2 flips) (2 (2 the) (2 comparison))) (2 and)) (1 (2 is) (2 (2 designed) (2 (2 to) (2 (2 be) (2 (2 used) (2 (2 when) (2 (2 sorting) (2 etc.))))))))) (2 .)))
Interesting!
(3 (3 Interesting) (2 !))
This flips the comparison and is designed to be used when sorting etc.
(1 (2 This) (1 (1 (2 (2 (2 flips) (2 (2 the) (2 comparison))) (2 and)) (1 (2 is) (2 (2 designed) (2 (2 to) (2 (2 be) (2 (2 used) (2 (2 when) (2 (2 sorting) (2 etc.))))))))) (2 .)))
Yay.
(2 (2 Yay) (2 .))
I was just lamenting the lack of such a method earlier today.
(1 (2 I) (1 (1 (2 (2 was) (2 just)) (2 (1 (2 lamenting) (1 (2 (2 the) (2 lack)) (2 (2 of) (2 (2 (2 such) (2 (2 a) (2 method))) (2 earlier))))) (2 today))) (2 .)))
Yes, the branch stays.
(3 (2 Yes) (2 (2 ,) (3 (2 (2 the) (2 branch)) (3 (2 stays) (2 .)))))
with inline-code or inline-code:.
(2 (2 (2 (2 with) (2 (2 (2 inline-code) (2 or)) (2 inline-code))) (2 :)) (2 .))
Yep, I already noticed & fixed, but I didn't want to wreck the diff comments just yet.
(1 (1 (2 (2 (2 (2 Yep) (2 (2 ,) (2 (2 I) (2 (2 already) (2 (2 noticed) (2 (2 &) (2 fixed))))))) (2 ,)) (2 but)) (1 (2 I) (1 (2 (2 did) (2 n't)) (1 (2 want) (1 (2 to) (1 (1 (1 (1 wreck) (2 (2 the) (2 (2 diff) (2 comments)))) (2 just)) (2 yet))))))) (2 .))
inline-code is another option (yay bikeshedding).
(1 (2 inline-code) (1 (1 (2 is) (2 (2 (2 another) (2 option)) (2 (2 -LRB-) (2 (2 (2 yay) (2 bikeshedding)) (2 -RRB-))))) (2 .)))
The reversal iterator on iterators is called inline-code (as a data point).
(1 (2 (2 (2 The) (2 (2 reversal) (2 iterator))) (2 (2 on) (2 iterators))) (1 (1 (2 is) (2 (2 (2 called) (2 inline-code)) (2 (2 -LRB-) (2 (2 (2 as) (2 (2 a) (2 (2 data) (2 point)))) (2 -RRB-))))) (2 .)))
I don't think we have conventions around this or anything, however.
(1 (2 I) (1 (2 (2 (2 do) (2 n't)) (2 (2 think) (2 (2 we) (2 (2 (2 (2 (2 have) (2 conventions)) (2 (2 around) (2 (2 (2 this) (2 or)) (2 anything)))) (2 ,)) (2 however))))) (2 .)))
Raw strings with quotes have to be bounded with inline-code, like inline-code.
(1 (2 (2 (2 Raw) (2 strings)) (2 (2 with) (2 quotes))) (1 (1 (2 have) (2 (2 to) (2 (2 be) (1 (2 bounded) (2 (2 with) (2 (2 inline-code) (2 (2 ,) (2 (2 like) (2 inline-code))))))))) (2 .)))
This isn't immediately obvious, especially for someone coming from, say,
Python.
(1 (2 This) (1 (1 (1 (2 (1 (2 is) (2 n't)) (2 (2 immediately) (1 obvious))) (2 ,)) (2 (2 especially) (2 (2 for) (2 (2 someone) (2 (2 coming) (2 (2 (2 from) (2 (2 ,) (2 (2 say) (2 ,)))) (3 Python))))))) (2 .)))
An example showing this usage explicitly or a link to raw string
documentation would be nice.
(1 (2 (2 (3 (2 (2 An) (2 example)) (2 (2 (2 showing) (2 (2 this) (2 usage))) (2 explicitly))) (2 or)) (3 (2 (2 a) (2 link)) (2 (2 to) (3 (2 raw) (2 (3 string) (2 documentation)))))) (2 (2 (2 would) (2 (2 be) (3 nice))) (2 .)))
On Monday, September 8, 2014, Steve Klabnik <notifications@github.com>
wrote:.
(1 (1 (2 On) (1 (2 Monday) (1 (2 ,) (1 (1 (2 (2 (2 September) (2 8)) (2 ,)) (2 2014)) (2 ,))))) (2 (2 (2 Steve) (2 (2 Klabnik) (2 <notifications@github.com>))) (2 (2 (2 wrote) (2 :)) (2 .))))
>
>
>
>
Anyone on this one ?
(1 (2 (2 >) (2 >)) (1 (3 (2 (2 >) (3 (2 >) (2 Anyone))) (2 (2 on) (2 (2 this) (2 one)))) (2 ?)))
If not I'm on it ;)
It's a bit tougher than expected ...
Not on it for now ;)
Raw strings aren't the heaviest advertised feature of Rust, and users of raw strings in some other languages might be surprised at how inline-code characters need to be handled.
(1 (1 (1 (1 (1 (2 (2 If) (1 (1 not) (1 (2 I) (1 (2 'm) (2 (2 on) (1 (2 it) (1 (2 ;-RRB-) (2 (2 It) (2 (2 's) (2 (2 (2 (2 a) (2 bit)) (2 tougher)) (2 (2 than) (1 expected)))))))))))) (1 (2 ...) (1 (2 (2 Not) (2 (2 on) (2 (2 it) (2 (2 for) (2 now))))) (1 (2 (2 ;-RRB-) (2 (2 Raw) (2 strings))) (1 (1 (2 are) (2 n't)) (2 (2 (2 the) (2 (2 heaviest) (2 (2 advertised) (2 feature)))) (2 (2 of) (2 Rust)))))))) (2 ,)) (2 and)) (1 (2 (2 users) (2 (2 of) (2 (2 (2 raw) (2 strings)) (2 (2 in) (2 (2 some) (2 (2 other) (2 languages))))))) (2 (2 might) (2 (2 be) (2 (3 surprised) (2 (2 at) (2 (2 how) (1 (2 (2 inline-code) (2 characters)) (2 (2 need) (2 (2 to) (2 (2 be) (2 handled)))))))))))) (2 .))
In the first section, it has this paragraph:.
(1 (2 (2 In) (2 (2 the) (2 (2 first) (2 section)))) (2 (2 ,) (2 (2 it) (2 (2 (2 (2 has) (2 (2 this) (2 paragraph))) (2 :)) (2 .)))))
Is this not enough?
(2 (2 (2 (2 Is) (2 this)) (2 (1 not) (2 enough))) (2 ?))
What do you suggest?
(2 (2 What) (2 (2 (2 (2 do) (2 you)) (2 suggest)) (2 ?)))
For the following code:.
(2 (2 (2 (2 For) (2 (2 the) (2 (2 following) (2 code)))) (2 :)) (2 .))
We get the following output:.
(1 (2 We) (2 (2 (2 (2 get) (2 (2 the) (2 (2 following) (2 output)))) (2 :)) (2 .)))
This is redundant, only one of the two would be enough.
(1 (1 (2 This) (1 (2 is) (1 redundant))) (2 (2 ,) (1 (2 (2 (2 only) (2 one)) (2 (2 of) (2 (2 the) (2 two)))) (2 (2 (2 would) (2 (2 be) (2 enough))) (2 .)))))
cc @jonathandturner .
(2 (2 cc) (2 (2 @jonathandturner) (2 .)))
<pre>
sully@anansi:~/src/rust/build [master]$ s1 .
(1 (2 <pre>) (3 (3 (3 (2 sully@anansi:~/src/rust/build) (3 (2 -LSB-) (2 master))) (2 (2 -RSB-) (2 (2 $) (2 s1)))) (2 .)))
/stage1/rustc .
(2 (2 /) (2 (2 stage1/rustc) (2 .)))
/test.rs 
gcc: .
(2 (2 (2 /) (2 test.rs)) (2 (2 (2 gcc) (2 :)) (2 .)))
o: No such file or directory
<input>:0:0:0:0: error: linking with gcc failed with code 256
<input>:0:0:0:0: note: gcc arguments: -L./stage1/lib -Lrt -lrustrt .
(0 (1 (2 (2 o) (2 :)) (0 (1 (1 (2 (1 (2 (1 No) (2 (2 such) (2 (2 (2 file) (2 or)) (2 directory)))) (2 (2 <input>) (2 :0:0:0:0))) (2 :)) (1 error)) (2 :)) (1 (2 linking) (1 (2 with) (1 (2 gcc) (1 (1 (1 (1 failed) (2 (2 with) (2 (2 (2 (2 (2 (2 code) (2 256)) (2 (2 <input>) (2 :0:0:0:0))) (2 :)) (2 (2 (2 note) (2 :)) (2 (2 gcc) (2 arguments)))) (2 :)))) (2 -)) (2 (2 L.) (2 (2 /) (2 (2 (2 (2 stage1/lib) (2 -)) (2 Lrt)) (2 (2 -) (2 lrustrt))))))))))) (2 .))
/stage1/lib/glue.
(2 (2 /) (2 (2 stage1/lib/glue) (2 .)))
o -m32 -o  .
(2 (2 (2 (2 o) (2 -)) (2 (2 (2 m32) (2 -)) (2 o))) (2 .))
o -lm .
(2 (2 (2 (2 o) (2 -)) (2 lm)) (2 .))
/stage1/lib/main.
(2 (2 /) (2 (2 stage1/lib/main) (2 .)))
o
<input>:0:0:0:0: error: aborting due to previous errors
</pre>
(s1 is my shell function that sets up the environment).
(1 (2 o) (1 (1 (1 (1 (2 <input>) (1 (1 (2 (2 :0:0:0:0) (2 :)) (1 error)) (2 :))) (2 (2 aborting) (2 (2 (2 due) (2 (2 to) (2 (2 previous) (1 errors)))) (2 </pre>)))) (2 (2 -LRB-) (2 (2 (2 s1) (2 (2 is) (2 (2 (2 my) (2 (2 shell) (2 function))) (2 (2 that) (2 (2 (2 sets) (2 up)) (2 (2 the) (2 environment))))))) (2 -RRB-)))) (2 .)))
Doing ".
(2 (2 (2 Doing) (2 '')) (2 .))
.
(2 .)
/build/test.
(2 (2 /) (2 (2 build/test) (2 .)))
rs" also fails.
(0 (2 (2 (2 rs) (2 '')) (2 also)) (0 (0 fails) (2 .)))
Doing "test.rs" works.
(3 (2 (2 Doing) (2 (2 ``) (2 (2 test.rs) (2 '')))) (3 (2 works) (2 .)))
If I have a file in another directory, "foo/test.
(1 (2 (2 If) (2 (2 I) (2 (2 have) (2 (2 (2 a) (2 file)) (2 (2 in) (2 (2 another) (2 directory))))))) (2 (2 ,) (3 (2 ``) (2 (2 foo/test) (2 .)))))
rs" works but ".
(2 (2 (2 (2 (2 rs) (2 '')) (2 works)) (2 (2 but) (2 ''))) (2 .))
/foo/test.
(2 (2 /) (2 (2 foo/test) (2 .)))
rs" doesn't work.
(1 (2 (2 rs) (2 '')) (1 (1 (1 (2 does) (2 n't)) (2 work)) (2 .)))
In fact, it fails if a .
(1 (2 (2 In) (2 fact)) (1 (2 ,) (1 (2 it) (1 (1 (0 fails) (2 (2 if) (2 a))) (2 .)))))
appears anywhere in the path.
(2 (2 (2 (2 appears) (2 anywhere)) (2 (2 in) (2 (2 the) (2 path)))) (2 .))
Playground
Private struct inline-code is known to implement inline-code for all types it supports.
(1 (2 (2 Playground) (2 (2 Private) (2 struct))) (2 (2 inline-code) (2 (2 (2 is) (2 (2 known) (2 (2 to) (2 (2 (2 implement) (2 inline-code)) (2 (2 for) (2 (2 (2 all) (2 types)) (2 (2 it) (2 supports)))))))) (2 .))))
However, inline-code for public struct inline-code (which simply wraps inline-code) gives the following error:.
(2 (1 However) (1 (2 ,) (1 (2 inline-code) (1 (2 (2 for) (2 (2 public) (2 (2 struct) (2 inline-code)))) (1 (2 (2 -LRB-) (2 (2 (2 which) (2 (2 simply) (2 (2 wraps) (2 inline-code)))) (2 -RRB-))) (1 (1 (1 (2 gives) (1 (2 the) (1 (2 following) (1 error)))) (2 :)) (2 .)))))))
One workaround is to make inline-code public and explicitly add inline-code to the inline-code clause of inline-code (and all its inline-codes).
(1 (2 (2 One) (2 workaround)) (1 (1 (2 is) (2 (2 to) (2 (2 (2 (2 (2 make) (2 (2 inline-code) (2 public))) (2 and)) (2 explicitly)) (2 (3 add) (1 (2 inline-code) (2 (2 to) (1 (2 (2 the) (2 (2 inline-code) (2 clause))) (2 (2 of) (2 (2 inline-code) (2 (2 -LRB-) (2 (2 and) (2 (2 (2 all) (2 (2 its) (2 inline-codes))) (2 -RRB-))))))))))))) (2 .)))
Ah, right, that's because the same limitation affects inline-code, it's requiring that inline-code be inline-code too.
(2 (2 Ah) (2 (2 ,) (2 (3 right) (1 (2 ,) (1 (2 (2 that) (2 (2 's) (2 (2 because) (2 (2 (2 the) (2 (2 same) (2 limitation))) (2 (2 affects) (2 inline-code)))))) (1 (2 ,) (1 (2 it) (2 (2 (2 's) (2 (2 requiring) (2 (2 that) (2 (2 inline-code) (2 (2 be) (2 (2 inline-code) (2 too))))))) (2 .)))))))))
This is a limitation of derive, you can just do inline-code (with the appropriate type params added) instead.
(1 (2 (2 This) (2 (2 is) (2 (2 (2 a) (2 limitation)) (2 (2 of) (2 derive))))) (1 (2 ,) (1 (2 you) (1 (1 (3 (2 (2 (2 can) (2 just)) (2 (2 do) (2 inline-code))) (2 (2 -LRB-) (2 (2 (2 with) (2 (2 (2 the) (2 (3 appropriate) (2 (2 type) (2 params)))) (2 added))) (2 -RRB-)))) (2 instead)) (2 .)))))
I just tried that:.
(2 (2 I) (2 (2 just) (2 (2 (2 (2 tried) (2 that)) (2 :)) (2 .))))
but I received the same error on this impl line.
(1 (2 but) (1 (2 I) (1 (1 (1 (2 received) (1 (2 the) (1 (2 same) (1 error)))) (2 (2 on) (2 (2 this) (2 (2 impl) (2 line))))) (2 .))))
Duplicate of URL thanks for filing!
(3 (2 (2 (2 Duplicate) (2 (2 of) (2 (2 URL) (3 thanks)))) (2 (2 for) (2 filing))) (2 !))
It's strange that inline-code requires inline-code to be copy as inline-code it only contains a shared reference.
(1 (2 It) (1 (1 (2 (2 's) (1 strange)) (1 (2 that) (1 (2 inline-code) (1 (2 requires) (2 (2 inline-code) (2 (2 to) (1 (2 be) (2 (2 copy) (2 (2 as) (2 (2 inline-code) (2 (2 it) (2 (2 only) (2 (2 contains) (2 (2 a) (2 (2 shared) (2 reference)))))))))))))))) (2 .)))
But sure enough, as it says URL.
(1 (2 But) (1 (2 (2 sure) (2 enough)) (2 (2 ,) (2 (2 (2 as) (2 it)) (2 (2 (2 says) (2 URL)) (2 .))))))
Thanks for the clarification.
(2 (2 (2 Thanks) (2 (2 for) (2 (2 the) (2 clarification)))) (2 .))
@huonw My last message is related to the bug you marked this as a dupe of.
(1 (2 (2 @huonw) (2 (2 My) (2 (2 last) (2 message)))) (1 (1 (2 is) (2 (2 related) (2 (2 to) (2 (2 (2 the) (2 bug)) (2 (2 you) (2 (2 (2 (2 marked) (2 this)) (2 (2 as) (2 (2 a) (1 dupe)))) (2 of))))))) (2 .)))
But isn't the original bug reported here different?
(1 (2 But) (1 (1 (1 (1 (2 is) (2 n't)) (2 (2 the) (2 (3 original) (2 bug)))) (2 (2 (2 reported) (2 here)) (2 different))) (2 ?)))
The error says
But it is implement right above it in my example up top.
(3 (3 (1 (1 (1 (2 The) (1 error)) (2 says)) (2 But)) (3 (2 it) (3 (2 is) (3 (3 (3 (2 implement) (3 (3 right) (3 (2 above) (2 it)))) (2 (2 in) (2 (2 my) (2 example)))) (2 (2 up) (2 top)))))) (2 .))
So some information is not being propagated correctly.
(1 (2 So) (1 (2 (2 some) (2 information)) (1 (1 (1 (2 is) (1 not)) (2 (2 being) (3 (2 propagated) (3 correctly)))) (2 .))))
And both Copy and Clone need manual implementations here.
(1 (2 And) (2 (2 (2 both) (2 (2 (2 Copy) (2 and)) (2 Clone))) (2 (2 (2 (2 need) (2 (2 manual) (2 implementations))) (2 here)) (2 .))))
(Clone can reuse Copy though).
(1 (2 -LRB-) (1 (2 Clone) (1 (2 (2 (2 can) (2 (2 (2 reuse) (2 Copy)) (2 though))) (2 -RRB-)) (2 .))))
@marcianx, oh, sorry, you are correct that this seems different!
(1 (1 (2 @marcianx) (1 (2 (2 ,) (2 (2 oh) (2 ,))) (2 sorry))) (2 (2 ,) (2 (2 you) (2 (2 (2 are) (2 (2 correct) (2 (2 that) (2 (2 this) (2 (2 seems) (2 different)))))) (2 !)))))
@ollie27 Not that I can think of, since the reason inline-code exists is to provide a better error message.
(1 (1 (2 (2 @ollie27) (2 Not)) (2 (2 that) (2 (2 I) (2 (2 can) (2 (2 (2 (2 think) (2 of)) (2 ,)) (2 (2 since) (2 (2 (2 the) (2 (2 reason) (2 inline-code))) (2 exists)))))))) (1 (1 (2 is) (1 (2 to) (1 (2 provide) (1 (2 a) (1 (4 better) (1 (1 error) (2 message))))))) (2 .)))
Nice!
(3 (2 Nice) (2 !))
Squash your commits please.
(3 (2 (2 Squash) (2 (2 your) (2 (2 commits) (2 please)))) (2 .))
to clarify, +1 to the PR itself - while I understand the argument that assert_eq should do its own thing for the error message, I don't see that as the point of the macro - aiui, assert_eq just saves you writing inline-code (and is implicitly self-documenting), so it makes sense to have an optional message in the same way assert has.
(1 (2 (2 to) (2 clarify)) (1 (2 ,) (1 (1 (2 (1 (2 (2 +1) (2 (2 to) (2 (2 the) (2 PR)))) (2 itself)) (2 -)) (1 (1 (1 (1 (1 (2 while) (1 (2 I) (1 (2 (2 understand) (2 (2 the) (2 argument))) (1 (2 that) (1 (2 assert_eq) (1 (2 should) (1 (2 (2 do) (2 (2 its) (2 (2 own) (2 thing)))) (1 (2 for) (1 (2 the) (1 (1 error) (2 message))))))))))) (1 (2 ,) (1 (2 I) (1 (2 (2 do) (2 n't)) (1 (2 see) (1 (2 that) (1 (2 (2 as) (2 (2 (2 the) (2 point)) (2 (2 of) (2 (2 (2 (2 the) (2 macro)) (2 -)) (2 aiui))))) (1 (2 ,) (1 (2 assert_eq) (1 (2 just) (2 (2 (2 (3 saves) (2 you)) (2 (2 writing) (2 inline-code))) (2 (2 -LRB-) (2 (2 and) (2 (2 (2 (2 is) (2 implicitly)) (2 self-documenting)) (2 -RRB-))))))))))))))) (2 ,)) (2 so)) (2 (2 it) (2 (2 (2 makes) (2 sense)) (2 (2 to) (2 (2 have) (2 (2 (2 (2 an) (2 (2 optional) (2 message))) (2 (2 in) (2 (2 the) (2 (2 same) (2 way))))) (2 (2 assert) (2 has))))))))) (2 .))))
I must admit, I've never really been a fan of assert_eq at all - perhaps this mental model is why I don't see the benefit.
(1 (1 (1 (1 (2 (2 I) (2 (2 must) (2 admit))) (1 (2 ,) (1 (2 I) (1 (2 (2 (2 've) (2 never)) (2 really)) (2 (2 (2 been) (2 (3 (2 a) (3 fan)) (2 (2 of) (2 assert_eq)))) (2 (2 at) (2 all))))))) (2 -)) (1 (2 (2 perhaps) (2 (2 this) (2 (2 mental) (3 model)))) (1 (2 is) (1 (2 why) (2 (2 I) (2 (2 (2 do) (2 n't)) (3 (2 see) (2 (2 the) (3 benefit))))))))) (2 .))
Is there any reason to use:.
(2 (2 (2 (2 (2 Is) (2 there)) (2 (2 any) (2 (2 reason) (2 (2 to) (2 use))))) (2 :)) (2 .))
rather than:.
(2 (2 (2 rather) (2 (2 than) (2 :))) (2 .))
?
(2 ?)
It's good for me but I'd prefer to let someone from @rust-lang/core team to review it as well.
(3 (3 (2 (3 (2 It) (3 (2 's) (3 (3 good) (2 (2 for) (3 me))))) (2 but)) (2 (2 I) (2 (2 'd) (2 (2 prefer) (2 (2 to) (2 (2 (2 let) (2 someone)) (2 (2 from) (3 (2 (2 @rust) (2 -)) (3 (2 lang/core) (3 (3 team) (3 (2 to) (3 (2 (2 review) (2 it)) (2 (2 as) (3 well)))))))))))))) (2 .))
Yes, @rust-lang/lang and @rust-lang/libs should probably sign off on something like this.
(1 (2 Yes) (1 (2 ,) (1 (2 (2 @rust) (2 (2 (2 -) (2 (2 (2 (2 lang/lang) (2 and)) (2 @rust)) (2 -))) (2 lang/libs))) (1 (1 (2 (2 should) (2 probably)) (3 (3 (3 sign) (1 off)) (2 (2 on) (2 (2 something) (2 (2 like) (2 this)))))) (2 .)))))
Maybe this was trying to match inline-code which can also be given a single argument which implements inline-code and use that.
(2 (2 Maybe) (1 (2 this) (1 (1 (2 was) (1 (2 trying) (2 (2 to) (2 (2 match) (2 (2 inline-code) (2 (2 which) (2 (2 (2 can) (2 also)) (2 (2 (2 (2 be) (2 (2 given) (2 (2 (2 a) (2 (2 single) (2 argument))) (2 (2 which) (2 (2 implements) (2 inline-code)))))) (2 and)) (2 (2 use) (2 that)))))))))) (2 .))))
If we don't want that behaviour and only accept valid format strings I think we can use a single extra rule like:.
(2 (2 (2 (2 If) (2 (2 we) (1 (2 (2 do) (2 n't)) (1 (2 (2 (2 want) (2 (2 that) (2 behaviour))) (2 and)) (1 (2 only) (2 (2 accept) (2 (2 (2 valid) (2 (2 format) (2 strings))) (2 (2 I) (2 (2 think) (2 (2 we) (2 (2 can) (3 (2 (2 use) (2 (2 a) (2 (2 single) (2 (2 extra) (2 rule))))) (2 like))))))))))))) (2 :)) (2 .))
This will also accept things like inline-code which I think we do want to accept.
(2 (2 This) (2 (2 (2 (2 will) (2 also)) (2 (2 (2 accept) (2 things)) (2 (2 like) (2 (2 inline-code) (2 (2 which) (2 (2 I) (2 (2 think) (2 (2 we) (2 (2 do) (2 (2 want) (2 (2 to) (2 accept)))))))))))) (2 .)))
(also we definitely don't want to use inline-code as we'll just run into #30143 again)
@alexcrichton Thanks!
(2 (2 -LRB-) (2 (2 (2 also) (2 we)) (2 (3 definitely) (1 (1 (2 (2 do) (2 n't)) (2 (2 (2 want) (2 (2 to) (2 (2 (2 (2 use) (2 inline-code)) (2 (2 as) (2 (2 we) (2 (2 (2 'll) (2 just)) (2 (2 (2 run) (2 (2 into) (2 (2 #) (2 30143)))) (2 again)))))) (2 -RRB-)))) (2 (2 @alexcrichton) (2 Thanks)))) (2 !)))))
I agree with @brson, it's simplest to just use inline-code for a custom message, since inline-code basically exists just to give a better default message.
(1 (2 (2 I) (2 (2 agree) (2 (2 with) (2 @brson)))) (1 (2 ,) (1 (2 it) (1 (1 (1 (1 (2 's) (1 (2 simplest) (2 (2 to) (1 (2 just) (2 (2 use) (2 (2 inline-code) (2 (2 for) (2 (2 a) (2 (2 custom) (2 message)))))))))) (2 ,)) (2 (2 since) (2 (2 inline-code) (2 (2 basically) (2 (2 (2 exists) (2 just)) (2 (2 to) (2 (3 give) (2 (2 a) (2 (4 better) (2 (2 default) (2 message))))))))))) (2 .)))))
inline-code macro accepts a custom message parameter and it's sometimes useful.
(1 (1 (2 (2 (2 (2 inline-code) (2 macro)) (2 (2 accepts) (2 (2 a) (2 (2 custom) (2 (2 message) (2 parameter)))))) (2 and)) (2 (2 it) (2 (2 's) (2 (2 sometimes) (2 useful))))) (2 .))
But inline-code doesn't have it and users need to use inline-code instead of inline-code when they want to output a custom message even if the assertion just compares two values.
(1 (2 But) (1 (1 (1 (1 (2 inline-code) (1 (1 (2 does) (2 n't)) (2 (2 have) (2 it)))) (2 and)) (1 (2 users) (1 (2 need) (1 (2 to) (1 (2 (2 use) (2 (2 inline-code) (2 (2 instead) (2 (2 of) (2 inline-code))))) (1 (2 when) (1 (2 they) (1 (2 want) (2 (2 to) (1 (2 (2 output) (2 (2 a) (2 (2 custom) (2 message)))) (2 (2 even) (2 (2 if) (2 (2 (2 the) (2 assertion)) (2 (2 just) (2 (2 compares) (2 (2 two) (2 values))))))))))))))))) (2 .)))
This pull request will resolve those cases.
(3 (2 (2 This) (2 (2 pull) (2 request))) (3 (2 (2 will) (2 (2 resolve) (2 (2 those) (2 cases)))) (2 .)))
@GuillaumeGomez Thanks.
(2 (2 @GuillaumeGomez) (2 (2 Thanks) (2 .)))
Squashed them.
(2 (2 (2 Squashed) (2 them)) (2 .))
Thanks for the feedbacks.
(2 (2 (2 Thanks) (2 (2 for) (2 (2 the) (2 feedbacks)))) (2 .))
I agree to appending a custom message to the default one.
(1 (2 I) (1 (2 (2 agree) (2 (2 to) (2 (2 (2 appending) (2 (2 a) (2 (2 custom) (2 message)))) (2 (2 to) (2 (2 the) (2 (2 default) (2 one))))))) (2 .)))
I have two ideas to do that.
(2 (2 I) (2 (2 (2 have) (2 (2 (2 two) (2 ideas)) (2 (2 to) (2 (2 do) (2 that))))) (2 .)))
1.
(2 (2 1) (2 .))
2.
(2 (2 2) (2 .))
The first one can format strings by itself, but it's a bit verbose.
(3 (2 (2 (2 (2 (2 (2 The) (2 (2 first) (2 one))) (2 (2 can) (2 (2 (2 format) (2 strings)) (2 (2 by) (2 itself))))) (2 ,)) (2 but)) (2 (2 it) (2 (2 's) (2 (2 (2 a) (2 bit)) (2 verbose))))) (2 .))
The implementation of the second one is simpler, but it doesn't support formatting.
(2 (2 (2 (3 (3 (2 (2 (2 The) (2 implementation)) (2 (2 of) (2 (2 the) (2 (2 second) (2 one))))) (2 (2 is) (2 simpler))) (2 ,)) (2 but)) (1 (2 it) (1 (1 (2 does) (2 n't)) (2 (2 support) (2 formatting))))) (2 .))
I'm wondering which one is better...
@ollie27 
This question sounds to be similar to "Is there any reason to use inline-code rather than inline-code?"
(1 (1 (1 (1 (1 (2 I) (3 (2 'm) (3 (2 wondering) (3 (2 which) (3 (2 one) (3 (2 is) (4 better))))))) (2 ...)) (2 (2 (2 @ollie27) (2 (2 This) (2 question))) (2 (2 sounds) (2 (2 to) (2 (2 be) (2 (2 similar) (2 (2 to) (2 (2 ``) (2 (2 (2 Is) (2 (2 there) (2 (2 any) (2 reason)))) (2 (2 to) (2 (2 use) (2 (2 inline-code) (2 (2 rather) (2 (2 than) (2 inline-code))))))))))))))) (2 ?)) (2 ''))
Just kidding :)
I prefer inline-code to just inline-code since inline-code seems more explicit to me than inline-code when I see test codes.
(1 (2 (2 Just) (2 kidding)) (1 (1 (2 :-RRB-) (1 (2 I) (2 (2 prefer) (1 (2 inline-code) (1 (2 to) (1 (2 just) (1 (2 inline-code) (2 (2 since) (1 (2 inline-code) (1 (1 (2 seems) (2 (2 more) (2 (1 explicit) (2 (2 to) (2 (3 me) (2 (2 than) (2 inline-code))))))) (1 (2 when) (1 (2 I) (1 (2 see) (1 (2 test) (2 codes))))))))))))))) (2 .)))
In major unit test libraries (e.g. JUnit in Java, OUnit in OCaml and Test::Unit in Ruby) in other languages, there are inline-code which support custom message.
(1 (1 (2 In) (1 (1 (2 (2 major) (2 (2 unit) (2 (2 test) (2 libraries)))) (1 (2 -LRB-) (1 (1 (2 (2 e.g.) (2 JUnit)) (1 (2 in) (1 (2 (2 Java) (2 ,)) (1 (2 (2 (2 OUnit) (2 (2 (2 in) (2 (2 (2 OCaml) (2 and)) (2 Test))) (2 :))) (2 :)) (2 (2 Unit) (2 (2 in) (2 Ruby))))))) (2 -RRB-)))) (2 (2 in) (2 (2 other) (2 languages))))) (1 (2 ,) (1 (2 there) (2 (2 (2 are) (2 (2 inline-code) (2 (2 which) (2 (2 support) (2 (2 custom) (2 message)))))) (2 .)))))
So, when I noticed that inline-code doesn't accept custom message while inline-code supports it, I thought it's just lack of feature or something not design decision.
(1 (2 So) (1 (2 ,) (1 (1 (2 when) (1 (2 I) (2 (2 noticed) (1 (2 that) (1 (2 inline-code) (1 (1 (2 does) (2 n't)) (2 (2 (2 accept) (2 (2 custom) (2 message))) (2 (2 while) (2 (2 inline-code) (2 (2 supports) (2 it))))))))))) (1 (2 ,) (1 (2 I) (1 (1 (2 thought) (1 (2 it) (1 (1 (2 (2 's) (2 just)) (1 (2 lack) (2 (2 of) (2 (2 (2 feature) (2 or)) (2 something))))) (2 (1 not) (2 (2 design) (2 decision)))))) (2 .)))))))
That definition looks good to me!
(3 (2 (2 That) (2 definition)) (3 (3 (2 looks) (3 (3 good) (2 (2 to) (3 me)))) (2 !)))
OK, @nikomatsakis makes a convincing case that it's worth adding something here.
(3 (2 OK) (3 (2 ,) (3 (2 @nikomatsakis) (3 (3 (3 (2 makes) (3 (2 a) (3 (3 convincing) (2 case)))) (3 (2 that) (3 (2 it) (3 (2 (2 's) (2 worth)) (3 (3 (3 adding) (2 something)) (2 here)))))) (2 .)))))
@SimonSapin's suggestion makes sense for added value.
(3 (2 (2 (2 @SimonSapin) (2 's)) (2 suggestion)) (3 (3 (2 makes) (3 (2 sense) (2 (2 for) (3 (2 added) (2 value))))) (2 .)))
cc @rust-lang/libs.
(2 (2 (2 (2 (2 cc) (2 @rust)) (2 -)) (2 lang/libs)) (2 .))
:hourglass: Testing commit 45a63d3 with merge 3ee3267...
I think that @brson and @aturon's logic makes sense, but I confess that I have been regularly surprised that inline-code doesn't accept a custom message -- and rewriting to use inline-code never occurred to me.
(1 (2 :) (1 (1 (2 (2 hourglass) (2 :)) (0 (1 (1 (1 (1 (1 (2 Testing) (2 (2 (2 commit) (2 45a63d3)) (2 (2 with) (2 (2 merge) (2 3ee3267))))) (2 ...)) (1 (2 (2 (2 (2 I) (2 (2 think) (2 (2 that) (2 (2 (2 (2 @brson) (2 and)) (2 (2 (2 @aturon) (2 's)) (2 logic))) (2 (2 makes) (2 sense)))))) (2 ,)) (2 but)) (1 (2 I) (1 (2 confess) (1 (2 that) (1 (2 I) (2 (2 have) (1 (2 been) (2 (2 regularly) (2 (3 surprised) (1 (2 that) (1 (2 inline-code) (1 (1 (2 does) (2 n't)) (2 (2 accept) (2 (2 a) (2 (2 custom) (2 message))))))))))))))))) (2 --)) (2 and)) (1 (2 (2 rewriting) (2 (2 to) (2 (2 use) (2 inline-code)))) (1 (2 never) (2 (2 occurred) (2 (2 to) (3 me))))))) (2 .)))
.
(2 .)
@bors: retry force clean
* appears... stuck.
(1 (1 (2 (2 @bors) (2 :)) (1 (2 (2 (2 retry) (2 (2 (2 force) (3 clean)) (2 (2 *) (2 appears)))) (2 ...)) (2 stuck))) (2 .))
@ollie27 Thanks.
(2 (2 @ollie27) (2 (2 Thanks) (2 .)))
That's what I wanted to do.
(2 (2 That) (2 (2 (2 's) (2 (2 what) (2 (2 I) (2 (2 wanted) (2 (2 to) (2 do)))))) (2 .)))
@alexcrichton  Okay.
(2 (2 @alexcrichton) (2 (2 Okay) (2 .)))
Updated the PR.
(1 (2 (2 Updated) (2 (2 the) (2 PR))) (2 .))
@nikomatsakis good point that having the error message reduces the surprise factor.
(1 (1 (3 (2 @nikomatsakis) (3 (3 good) (2 point))) (1 (2 that) (1 (2 having) (1 (2 the) (1 (1 error) (2 message)))))) (1 (1 (2 reduces) (3 (2 the) (2 (2 surprise) (2 factor)))) (2 .)))
:hourglass: Testing commit 45a63d3 with merge a32aaea...
Oops.
(1 (2 :) (1 (1 (2 (2 hourglass) (2 :)) (1 (2 Testing) (1 (2 (2 commit) (2 45a63d3)) (2 (2 with) (2 (2 (2 (2 merge) (2 a32aaea)) (2 ...)) (2 Oops)))))) (2 .)))
I should've checked the issue...
inline-code macro accepts a custom message parameter and it's sometimes useful.
(1 (1 (2 (2 (2 I) (2 (2 should) (2 (2 've) (2 (2 checked) (2 (2 the) (2 issue)))))) (2 ...)) (1 (2 (2 (2 (2 inline-code) (2 macro)) (2 (2 accepts) (2 (2 a) (2 (2 custom) (2 (2 message) (2 parameter)))))) (2 and)) (2 (2 it) (2 (2 's) (2 (2 sometimes) (2 useful)))))) (2 .))
But inline-code doesn't have it and users need to use inline-code instead of inline-code when they want to output a custom message even if the assertion just compares two values.
(1 (2 But) (1 (1 (1 (1 (2 inline-code) (1 (1 (2 does) (2 n't)) (2 (2 have) (2 it)))) (2 and)) (1 (2 users) (1 (2 need) (1 (2 to) (1 (2 (2 use) (2 (2 inline-code) (2 (2 instead) (2 (2 of) (2 inline-code))))) (1 (2 when) (1 (2 they) (1 (2 want) (2 (2 to) (1 (2 (2 output) (2 (2 a) (2 (2 custom) (2 message)))) (2 (2 even) (2 (2 if) (2 (2 (2 the) (2 assertion)) (2 (2 just) (2 (2 compares) (2 (2 two) (2 values))))))))))))))))) (2 .)))
This pull request will resolve those cases.
(3 (2 (2 This) (2 (2 pull) (2 request))) (3 (2 (2 will) (2 (2 resolve) (2 (2 those) (2 cases)))) (2 .)))
:sunny: Test successful - auto-linux-32-nopt-t, auto-linux-32-opt, auto-linux-64-cargotest, auto-linux-64-cross-freebsd, auto-linux-64-debug-opt, auto-linux-64-nopt-t, auto-linux-64-opt, auto-linux-64-opt-mir, auto-linux-64-opt-rustbuild, auto-linux-64-x-android-t, auto-linux-cross-opt, auto-linux-musl-64-opt, auto-mac-32-opt, auto-mac-64-opt, auto-mac-64-opt-rustbuild, auto-mac-cross-ios-opt, auto-win-gnu-32-opt, auto-win-gnu-32-opt-rustbuild, auto-win-gnu-64-opt, auto-win-msvc-32-opt, auto-win-msvc-64-cargotest, auto-win-msvc-64-opt, auto-win-msvc-64-opt-mir, auto-win-msvc-64-opt-rustbuild.
(2 (2 :) (2 (1 (3 (2 sunny) (3 (2 :) (3 (3 (2 Test) (4 successful)) (2 -)))) (1 (2 auto-linux-32-nopt-t) (1 (2 ,) (1 (2 auto-linux-32-opt) (1 (2 ,) (1 (2 auto-linux-64-cargotest) (1 (2 ,) (1 (2 auto-linux-64-cross-freebsd) (1 (2 ,) (1 (2 auto-linux-64-debug-opt) (1 (2 ,) (1 (2 auto-linux-64-nopt-t) (1 (2 ,) (1 (2 auto-linux-64-opt) (1 (2 ,) (1 (2 auto-linux-64-opt-mir) (1 (2 ,) (1 (2 auto-linux-64-opt-rustbuild) (1 (2 ,) (1 (2 auto-linux-64-x-android-t) (1 (2 ,) (1 (2 auto-linux-cross-opt) (1 (2 ,) (1 (2 auto-linux-musl-64-opt) (1 (2 ,) (1 (2 auto-mac-32-opt) (1 (2 ,) (1 (2 auto-mac-64-opt) (1 (2 ,) (1 (2 auto-mac-64-opt-rustbuild) (1 (2 ,) (1 (2 auto-mac-cross-ios-opt) (1 (2 ,) (1 (2 auto-win-gnu-32-opt) (1 (2 ,) (1 (2 auto-win-gnu-32-opt-rustbuild) (1 (2 ,) (1 (2 auto-win-gnu-64-opt) (1 (2 ,) (1 (2 auto-win-msvc-32-opt) (1 (2 ,) (1 (2 auto-win-msvc-64-cargotest) (2 (2 ,) (1 (2 auto-win-msvc-64-opt) (2 (2 ,) (2 (2 auto-win-msvc-64-opt-mir) (2 (2 ,) (2 auto-win-msvc-64-opt-rustbuild)))))))))))))))))))))))))))))))))))))))))))))))) (2 .)))
@bors: r+ 45a63d3ff611b1412f9d811cd328b648bada5ca2
Thanks!
(1 (1 (2 (2 @bors) (2 :)) (2 (2 (2 r) (2 +)) (2 (2 45a63d3ff611b1412f9d811cd328b648bada5ca2) (2 Thanks)))) (2 !))
+1.
(2 (2 +1) (2 .))
It may be worth using inline-code here as well to ensure that a inline-code which looks like inline-code gives an error saying that it expected an argument rather than being accepted.
(1 (2 It) (1 (1 (2 may) (1 (2 (2 be) (2 worth)) (1 (1 (1 (2 (2 (2 using) (2 inline-code)) (2 here)) (1 (2 as) (1 (3 well) (1 (2 to) (1 (2 ensure) (1 (2 that) (1 (2 (2 (2 a) (2 inline-code)) (2 (2 which) (2 (2 looks) (2 (2 like) (2 inline-code))))) (1 (2 gives) (1 (1 (2 an) (1 error)) (2 (2 saying) (2 (2 that) (2 (2 it) (2 (1 expected) (2 (2 an) (2 argument))))))))))))))) (2 (2 rather) (2 than))) (2 (2 being) (2 accepted))))) (2 .)))
Thanks for the pull request, and welcome!
(3 (2 (2 Thanks) (2 (2 for) (2 (2 the) (2 (2 pull) (2 request))))) (3 (2 ,) (3 (2 and) (3 (2 welcome) (2 !)))))
The Rust team is excited to review your changes, and you should hear from @brson (or someone else) soon.
(3 (3 (3 (3 (3 (2 (2 The) (2 (2 Rust) (3 team))) (3 (2 is) (3 (3 excited) (2 (2 to) (2 (2 review) (2 (2 your) (2 changes))))))) (2 ,)) (2 and)) (2 (2 you) (2 (2 should) (2 (2 (2 hear) (2 (2 from) (2 (2 @brson) (2 (2 -LRB-) (2 (2 or) (2 (2 (2 someone) (2 else)) (2 -RRB-))))))) (2 soon))))) (2 .))
If any changes to this PR are deemed necessary, please add them as extra commits.
(3 (2 (2 If) (2 (1 (2 (2 any) (2 changes)) (2 (2 to) (2 (2 this) (2 PR)))) (2 (2 are) (2 (2 deemed) (2 necessary))))) (3 (2 ,) (3 (3 (2 please) (2 (3 add) (2 (2 them) (2 (2 as) (2 extra))))) (2 (2 commits) (2 .)))))
This ensures that the reviewer can see what has changed since they last reviewed the code.
(3 (2 This) (3 (3 (3 ensures) (2 (2 that) (2 (2 (2 the) (2 reviewer)) (2 (2 can) (2 (2 see) (2 (2 what) (2 (2 has) (2 (2 changed) (2 (2 since) (2 (2 they) (2 (2 last) (2 (2 reviewed) (2 (2 the) (2 code)))))))))))))) (2 .)))
Due to the way GitHub handles out-of-date commits, this should also make it reasonably obvious what issues have or haven't been addressed.
(1 (2 (2 Due) (2 (2 to) (2 (2 (2 the) (2 way)) (2 (2 GitHub) (2 (2 handles) (2 (2 out-of-date) (2 commits))))))) (2 (2 ,) (1 (2 this) (2 (2 (2 (2 should) (2 also)) (2 (2 make) (2 (2 it) (2 (2 (2 reasonably) (1 obvious)) (2 (2 what) (1 (2 issues) (2 (2 (2 have) (2 or)) (2 (2 (2 have) (2 n't)) (2 (2 been) (2 addressed)))))))))) (2 .)))))
Large or tricky changes may require several passes of review and changes.
(2 (2 (2 (2 (2 Large) (2 or)) (2 tricky)) (2 changes)) (2 (2 (2 may) (2 (2 require) (2 (2 (2 several) (2 passes)) (2 (2 of) (2 (2 (2 review) (2 and)) (2 changes)))))) (2 .)))
Please see the contribution instructions for more information.
(2 (2 Please) (3 (3 (3 (2 see) (3 (2 the) (3 (2 contribution) (2 instructions)))) (2 (2 for) (2 (2 more) (2 information)))) (2 .)))
@brson @GuillaumeGomez Well, should I close this PR...?
(1 (2 (2 (2 @brson) (2 @GuillaumeGomez)) (2 Well)) (2 (2 ,) (2 (2 (2 (2 should) (2 I)) (2 (2 (2 close) (2 this)) (2 (2 PR) (2 ...)))) (2 ?))))
Ah yeah I'd vote for the first where the message itself can have more arguments and such like inline-code can.
(2 (2 Ah) (1 (1 (3 yeah) (1 (2 I) (2 (2 'd) (1 (2 (2 vote) (2 (2 for) (2 (2 the) (2 first)))) (1 (2 where) (2 (1 (2 the) (1 (2 message) (1 (2 itself) (2 (2 can) (2 (2 have) (2 (2 (2 (2 more) (2 arguments)) (2 and)) (2 (2 such) (2 (2 like) (2 inline-code))))))))) (2 can))))))) (2 .)))
The libs team got a chance to discuss this PR during triage today and the conclusion was to merge.
(1 (1 (1 (1 (2 (2 The) (2 (2 libs) (3 team))) (2 (2 got) (1 (2 a) (2 (2 chance) (2 (2 to) (2 (1 (2 (2 discuss) (2 (2 this) (2 PR))) (2 (2 during) (2 triage))) (2 today))))))) (2 and)) (2 (2 (2 the) (2 conclusion)) (2 (2 was) (2 (2 to) (2 merge))))) (2 .))
@komamitsu if you want to update with @ollie27's suggestion, I'll r+!
(3 (2 (2 @komamitsu) (2 (2 if) (2 (2 you) (2 (2 want) (2 (2 to) (2 (2 update) (2 (2 with) (2 (2 (2 @ollie27) (2 's)) (2 suggestion))))))))) (3 (2 ,) (3 (2 I) (3 (2 (2 'll) (2 (2 r) (2 +))) (2 !)))))
I feel that as-is this may not add too much value as it's shorter even to use inline-code and you'd get the same message, but if we were to append the message to the inline-code then it seems reasonable to me.
(1 (1 (1 (1 (1 (2 I) (1 (2 feel) (1 (2 that) (1 (1 (1 (2 (2 as-is) (2 this)) (2 (1 (2 may) (1 not)) (2 (2 (3 add) (1 (1 (2 too) (2 much)) (2 value))) (2 (2 as) (2 (2 it) (2 (2 (2 's) (2 shorter)) (2 (2 even) (2 (2 to) (2 (2 use) (2 inline-code)))))))))) (2 and)) (2 (2 you) (2 (2 'd) (2 (2 get) (2 (2 the) (2 (2 same) (2 message)))))))))) (2 ,)) (2 but)) (1 (2 (2 if) (2 (2 we) (2 (2 were) (2 (2 to) (2 (2 (2 append) (2 (2 the) (2 message))) (2 (2 to) (2 (2 the) (2 inline-code)))))))) (2 (2 then) (2 (2 it) (2 (2 seems) (2 (3 reasonable) (2 (2 to) (3 me)))))))) (2 .))
Well, maybe another way to put it is that I got in the habit of using inline-code long ago, and so now I just do it out of habit whenever there is an equality comparison involved.
(1 (2 Well) (1 (2 ,) (1 (1 (1 (1 (1 (1 (2 maybe) (1 (2 (2 another) (2 (2 way) (2 (2 to) (2 (2 put) (2 it))))) (3 (2 is) (2 (2 that) (2 (2 I) (2 (2 got) (2 (2 in) (2 (2 (2 the) (2 habit)) (2 (2 of) (2 (2 (2 using) (2 inline-code)) (2 (2 long) (2 ago)))))))))))) (2 ,)) (2 and)) (2 (2 so) (2 now))) (2 (2 I) (2 (2 just) (2 (2 do) (2 (2 it) (2 (2 (1 out) (2 (2 of) (2 habit))) (2 (2 whenever) (2 (2 there) (2 (2 is) (2 (2 (2 an) (2 (2 equality) (2 comparison))) (2 involved))))))))))) (2 .))))
Updated the PR.
(1 (2 (2 Updated) (2 (2 the) (2 PR))) (2 .))
:bomb: Buildbot returned an error: inline-code.
(1 (2 :) (1 (1 (2 (1 bomb) (2 :)) (2 Buildbot)) (1 (1 (2 returned) (1 (2 an) (1 (1 (1 error) (2 :)) (2 inline-code)))) (2 .))))
As I wrote in URL I think the panic message given to inline-code should be *in addition* (concatenated) to the default one.
(1 (2 (2 As) (2 (2 I) (2 (2 wrote) (2 (2 in) (2 URL))))) (1 (2 I) (1 (1 (2 think) (1 (2 (2 (2 the) (2 (2 panic) (2 message))) (2 (2 given) (2 (2 to) (2 inline-code)))) (1 (2 should) (1 (1 (2 be) (1 (2 (2 (2 *) (2 (2 in) (2 addition))) (2 *)) (2 (2 -LRB-) (2 (2 concatenated) (2 -RRB-))))) (2 (2 to) (2 (2 the) (2 (2 default) (2 one)))))))) (2 .))))
If the default one is replaced entirely instead, that’s the same as inline-code.
(1 (2 (2 If) (2 (2 (2 the) (2 (2 default) (2 one))) (2 (2 is) (2 (2 (2 replaced) (2 entirely)) (2 instead))))) (2 (2 ,) (2 (2 that) (2 (2 (2 's) (2 (2 (2 the) (2 same)) (2 (2 as) (2 inline-code)))) (2 .)))))
IMO the point of inline-code over inline-code is that it prints the two values for you, so you don’t have to.
(1 (1 (1 (1 (1 (1 (2 (2 IMO) (2 (2 the) (2 point))) (2 (2 of) (2 (2 inline-code) (2 (2 over) (2 inline-code))))) (2 (2 is) (2 (2 that) (2 (2 it) (2 (2 prints) (2 (2 (2 the) (2 (2 two) (2 values))) (2 (2 for) (2 you)))))))) (2 ,)) (2 so)) (2 (2 you) (2 (2 (2 do) (2 n't)) (2 (2 have) (2 to))))) (2 .))
It can be desirable to have that, and also provide more information/context in the panic message.
(1 (2 It) (2 (2 (2 can) (2 (2 be) (2 (3 desirable) (2 (2 to) (2 (2 (2 (2 (2 (2 have) (2 that)) (2 ,)) (2 and)) (2 also)) (2 (2 (2 provide) (2 (2 more) (2 information/context))) (2 (2 in) (2 (2 the) (2 (2 panic) (2 message)))))))))) (2 .)))
Like @komamitsu, I have mostly used inline-code because it seemed more declarative (with a nicer message to boot).
(1 (2 (3 Like) (2 @komamitsu)) (2 (2 ,) (1 (2 I) (2 (2 (2 (2 have) (2 mostly)) (1 (2 (2 used) (2 inline-code)) (2 (2 because) (2 (2 it) (1 (2 seemed) (2 (2 (2 more) (2 declarative)) (2 (2 -LRB-) (2 (2 (2 with) (2 (2 (2 a) (2 (2 nicer) (2 message))) (2 (2 to) (2 boot)))) (2 -RRB-))))))))) (2 .)))))
.
(2 .)
@bors: retry force clean
* bots disappeared?
(1 (2 (2 (2 @bors) (2 :)) (2 (2 retry) (2 (2 force) (2 (3 clean) (2 (2 *) (2 (2 bots) (2 disappeared))))))) (2 ?))
related rfc issue: URL.
(1 (2 (2 (2 (2 related) (2 (2 rfc) (2 issue))) (2 :)) (2 URL)) (2 .))
Compiling the following program yields an internal compiler error:.
(1 (2 (2 Compiling) (2 (2 the) (2 (2 following) (2 program)))) (1 (1 (1 (2 yields) (1 (2 an) (1 (2 internal) (1 (2 compiler) (1 error))))) (2 :)) (2 .)))
To explain what happens, before #34095 the compiler never tried to resolve paths in braced struct patterns, like inline-code, as associated types, it just reported an error immediately.
(0 (1 (2 To) (1 (2 explain) (1 (2 what) (1 (2 (2 (2 happens) (2 ,)) (2 (2 before) (2 (2 #) (2 34095)))) (1 (2 (2 the) (2 compiler)) (1 (2 never) (1 (2 tried) (1 (2 to) (1 (1 (1 (1 (2 (2 (2 resolve) (2 paths)) (2 (2 in) (2 (2 braced) (2 (2 struct) (2 patterns))))) (2 ,)) (2 (2 like) (2 inline-code))) (2 ,)) (2 (2 as) (2 (2 associated) (2 types)))))))))))) (1 (2 ,) (1 (2 it) (1 (2 just) (1 (1 (1 (2 reported) (1 (2 an) (1 error))) (2 immediately)) (2 .))))))
Now these paths are sent to type checker for further resolution, but type checker is not ready to deal with them yet.
(1 (1 (2 (2 (2 (2 Now) (2 (2 (2 these) (2 paths)) (2 (2 are) (2 (2 sent) (2 (2 to) (2 (2 (2 type) (2 checker)) (2 (2 for) (2 (2 further) (2 resolution))))))))) (2 ,)) (2 but)) (1 (2 (2 type) (2 checker)) (1 (1 (2 is) (1 not)) (2 (2 ready) (2 (2 to) (2 (2 (2 deal) (2 (2 with) (2 them))) (2 yet))))))) (2 .))
Ouch, this is a consequence of URL.
(1 (2 Ouch) (1 (2 ,) (1 (2 this) (2 (2 (2 is) (2 (2 (2 a) (2 consequence)) (2 (2 of) (2 URL)))) (2 .)))))
It affects only erroneous programs, but it's still pretty bad.
(1 (1 (2 (2 (2 (2 It) (2 (2 affects) (2 (2 only) (2 (2 erroneous) (2 programs))))) (2 ,)) (2 but)) (1 (2 it) (2 (2 (2 's) (2 still)) (1 (4 pretty) (0 bad))))) (2 .))
I hoped to submit a fix until no one noticed... but, well.
(1 (2 I) (1 (1 (2 hoped) (1 (2 to) (1 (1 (1 (2 (2 submit) (2 (2 a) (2 fix))) (2 (2 until) (2 (2 (1 no) (2 one)) (2 (2 (2 noticed) (2 ...)) (2 but))))) (2 ,)) (3 well)))) (2 .)))
Expect it in a couple of days.
(2 (2 (2 (2 Expect) (2 it)) (2 (2 in) (2 (2 (2 a) (2 couple)) (2 (2 of) (2 days))))) (2 .))
This was fixed by #27006, but not backported to the 1.1 branch.
(1 (2 This) (1 (1 (2 was) (1 (1 (2 (2 (2 fixed) (2 (2 by) (2 (2 #) (2 27006)))) (2 ,)) (2 (2 but) (1 not))) (2 (2 backported) (2 (2 to) (2 (2 the) (2 (2 1.1) (2 branch))))))) (2 .)))
You will have to apply the patch manually.
(2 (2 You) (2 (2 (2 will) (2 (2 have) (2 (2 to) (2 (2 (2 apply) (2 (2 the) (2 patch))) (2 manually))))) (2 .)))
Duplicate of URL.
(2 (2 (2 Duplicate) (2 (2 of) (2 URL))) (2 .))
Note that Rust 1.2.0, which will be released this week, has this patch applied.
(1 (1 (2 Note) (1 (2 that) (1 (1 (1 (2 (2 (2 Rust) (2 1.2.0)) (2 ,)) (2 (2 which) (2 (2 will) (2 (2 be) (2 (2 released) (2 (2 this) (2 week))))))) (2 ,)) (2 (2 has) (2 (2 (2 this) (2 patch)) (2 applied)))))) (2 .))
You may wait a few days and try again!
(1 (2 You) (1 (1 (2 may) (2 (2 (2 (2 wait) (2 (2 a) (2 (2 few) (2 days)))) (2 and)) (2 (2 try) (2 again)))) (2 !)))
the .
(2 (2 the) (2 .))
/configure output is :  
configure: looking for configure programs
configure: found program cmp
configure: found program mkdir
configure: found program printf
configure: found program cut
configure: found program head
configure: found program grep
configure: found program xargs
configure: found program cp
configure: found program find
configure: found program uname
configure: found program date
configure: found program tr
configure: found program sed
configure: found program file
configure: found program make
configure: inspecting environment
configure: recreating config.tmp
configure:.
(1 (2 (2 /) (2 (2 configure) (2 output))) (1 (1 (1 (2 (2 is) (2 :)) (1 (2 (2 configure) (2 :)) (1 (2 (2 (2 (1 (2 looking) (2 (2 for) (1 (2 (2 configure) (2 programs)) (2 (2 (1 (2 (1 (2 (1 (2 (2 (2 (2 (2 (1 (2 (2 (2 (1 (2 (1 (2 (1 (2 (2 (2 (2 (2 (2 (2 (2 (2 (2 configure) (2 :)) (2 (2 found) (2 (2 program) (2 (2 cmp) (2 configure))))) (2 :)) (2 (2 found) (2 (2 program) (2 (2 mkdir) (2 configure))))) (2 :)) (2 (2 found) (2 (2 program) (2 (2 printf) (2 configure))))) (2 :)) (2 (2 found) (2 (2 program) (2 (2 cut) (2 configure))))) (2 :)) (2 (2 found) (2 (2 program) (2 (2 head) (2 configure))))) (2 :)) (2 (2 found) (2 (2 program) (2 (2 grep) (2 configure))))) (2 :)) (2 (2 found) (2 (2 (2 program) (2 xargs)) (2 configure)))) (2 :)) (2 (2 found) (2 (2 program) (2 (2 cp) (2 configure))))) (2 :)) (2 (2 found) (2 (2 program) (2 (2 find) (2 configure))))) (2 :)) (2 (2 found) (2 (2 program) (2 (2 uname) (2 configure))))) (2 :)) (2 (2 found) (2 (2 program) (2 (2 date) (2 configure))))) (2 :)) (2 (2 found) (2 (2 program) (2 (2 tr) (2 configure))))) (2 :)) (2 (2 found) (2 (2 program) (2 (2 sed) (2 configure))))) (2 :)) (2 (2 found) (2 (2 program) (2 (2 file) (2 configure))))) (2 :)) (2 (2 found) (2 (2 program) (2 (2 make) (2 configure)))))))) (2 :)) (2 (2 inspecting) (2 (2 environment) (2 configure)))) (2 :)) (2 (2 recreating) (2 (2 config.tmp) (2 configure)))))) (2 :)) (2 .)))
configure: processing .
(2 (2 (2 (2 configure) (2 :)) (2 processing)) (2 .))
/configure args
configure:.
(1 (2 (2 /) (2 (2 configure) (2 args))) (2 (2 (2 configure) (2 :)) (2 .)))
configure: CFG_LOCALSTATEDIR    := /var/lib
configure: CFG_SYSCONFDIR       := /etc
configure: CFG_DATADIR          := /share
configure: CFG_INFODIR          := /share/info
configure: CFG_LLVM_ROOT        :=
configure: CFG_JEMALLOC_ROOT    :=
configure: CFG_BUILD            := x86_64-apple-darwin
configure: CFG_ANDROID_CROSS_PATH := /opt/ndk_standalone
configure: CFG_RELEASE_CHANNEL  := dev
configure: CFG_MUSL_ROOT        := /usr/local
configure: CFG_BUILD            := x86_64-apple-darwin
configure: CFG_LIBDIR           := /usr/local/lib
configure:.
(1 (2 configure) (1 (2 :) (1 (1 (2 (2 CFG_LOCALSTATEDIR) (2 (2 :) (2 =))) (1 (2 /) (1 (2 (2 (2 var/lib) (2 configure)) (2 (2 :) (2 (2 (2 CFG_SYSCONFDIR) (2 :)) (2 =)))) (1 (2 /) (1 (2 (2 (2 etc) (2 configure)) (2 (2 :) (2 (2 (2 CFG_DATADIR) (2 :)) (2 =)))) (1 (2 /) (1 (3 (3 (3 share) (2 configure)) (2 (2 :) (2 (2 (2 CFG_INFODIR) (2 :)) (2 =)))) (1 (2 /) (1 (1 (2 (2 share/info) (2 configure)) (1 (2 :) (1 (1 (1 (2 (2 CFG_LLVM_ROOT) (2 :)) (1 (2 (2 (2 (2 (2 (2 (2 (2 (2 =) (2 configure)) (2 :)) (2 CFG_JEMALLOC_ROOT)) (2 :)) (2 (2 =) (2 configure))) (2 :)) (2 CFG_BUILD)) (2 :)) (2 (2 =) (2 (2 x86_64-apple-darwin) (2 configure))))) (2 :)) (2 CFG_ANDROID_CROSS_PATH)))) (1 (2 :) (1 (2 =) (1 (2 /) (1 (1 (2 (2 opt/ndk) (2 (2 _) (2 (2 standalone) (2 configure)))) (1 (2 :) (1 (1 (1 (2 (2 CFG_RELEASE_CHANNEL) (2 :)) (1 (1 (1 (1 (1 (2 (2 (2 (2 (2 =) (2 (2 dev) (2 configure))) (2 :)) (2 CFG_MUSL_ROOT)) (2 :)) (2 (2 =) (2 (2 /) (2 (2 usr/local) (2 configure))))) (2 :)) (2 CFG_BUILD)) (2 :)) (2 (2 =) (2 (2 x86_64-apple-darwin) (2 configure))))) (2 :)) (2 CFG_LIBDIR)))) (2 (2 :) (2 (2 =) (2 (2 /) (2 (2 (2 usr/local/lib) (2 configure)) (2 :)))))))))))))))))) (2 .))))
configure: validating .
(2 (2 (2 (2 configure) (2 :)) (2 validating)) (2 .))
/configure args
configure:.
(1 (2 (2 /) (2 (2 configure) (2 args))) (2 (2 (2 configure) (2 :)) (2 .)))
configure: CFG_BOOTSTRAP_KEY    := 21:11:31
configure:.
(1 (2 (2 (2 configure) (2 :)) (2 (2 (2 (2 CFG_BOOTSTRAP_KEY) (2 :)) (2 (2 (2 =) (2 21:11:31)) (2 configure))) (2 :))) (2 .))
configure: looking for build programs
configure:.
(2 (2 configure) (2 (2 :) (2 (2 (2 looking) (2 for)) (2 (2 (2 (2 build) (2 (2 programs) (2 configure))) (2 :)) (2 .)))))
configure: CFG_CURLORWGET       := /usr/bin/curl (7.37.1)
configure: CFG_PYTHON           := /usr/bin/python2.7
configure: CFG_GIT              := /usr/bin/git (2.3.8)
configure: git: no git directory.
(1 (2 configure) (1 (2 :) (1 (1 (1 (1 (2 (2 CFG_CURLORWGET) (2 :)) (1 (2 (2 =) (2 /)) (2 (2 usr/bin/curl) (2 (2 (2 -LRB-) (2 (2 7.37.1) (2 -RRB-))) (2 configure))))) (2 :)) (2 CFG_PYTHON)) (1 (2 :) (1 (2 =) (1 (2 /) (1 (1 (2 (2 (2 usr/bin/python2) (2 (2 .7) (2 configure))) (2 (2 :) (2 (2 (2 CFG_GIT) (2 :)) (2 =)))) (1 (2 /) (1 (2 (2 (2 usr/bin/git) (2 (2 -LRB-) (2 (2 2.3.8) (2 -RRB-)))) (2 configure)) (1 (2 :) (1 (2 (2 git) (2 :)) (1 (1 no) (2 (2 git) (2 directory)))))))) (2 .))))))))
disabling submodules
configure: CFG_MD5              := /sbin/md5
configure: CFG_MD5SUM           :=
configure: CFG_HASH_COMMAND     := /sbin/md5 -q | head -c 8
configure: CFG_CLANG            := /usr/bin/clang++ (7.0.0)
configure: CFG_CCACHE           :=
configure: CFG_GCC              := /usr/bin/gcc (7.0.0)
configure: CFG_LD               := /usr/bin/ld
configure: CFG_VALGRIND         :=
configure: CFG_PERF             :=
configure: CFG_ISCC             :=
configure: CFG_ANTLR4           :=
configure: CFG_GRUN             :=
configure: CFG_FLEX             := /usr/bin/flex (2.5.35)
configure: CFG_BISON            := /usr/bin/bison (2.3)
configure: CFG_PANDOC           :=
configure: CFG_XELATEX          :=
configure: CFG_GDB              :=
configure: CFG_LLDB             := /usr/bin/lldb (340.4.53.3)
configure: CFG_DISABLE_VALGRIND_RPASS := 1
configure: CFG_LLDB_VERSION     := lldb-340.4.53.3
configure: CFG_LLDB_PYTHON_DIR  := /Library/Developer/CommandLineTools ...
configure:.
(1 (2 (2 (2 (2 disabling) (2 submodules)) (2 configure)) (2 (2 :) (2 (2 (2 CFG_MD5) (2 :)) (2 =)))) (1 (2 /) (1 (1 (2 (2 sbin/md5) (2 configure)) (1 (2 :) (1 (1 (1 (2 (2 CFG_MD5SUM) (2 :)) (2 (2 (2 (2 (2 (2 =) (2 configure)) (2 :)) (2 CFG_HASH_COMMAND)) (2 :)) (2 (2 =) (2 (2 /) (2 sbin/md5))))) (2 -)) (2 (2 q) (2 (2 |) (2 head)))))) (1 (2 -) (1 (2 (2 c) (2 (2 8) (2 configure))) (1 (2 :) (1 (2 (2 CFG_CLANG) (2 (2 :) (2 (2 =) (2 (2 /) (2 (1 (1 (1 (1 (2 (1 (1 (1 (1 (1 (1 (1 (2 (2 (2 (1 (2 (1 (1 (1 (1 (1 (1 (1 (1 (1 (1 (1 (1 (1 (1 (1 (2 (2 (2 (1 (2 (2 (2 (1 (2 (2 (2 (1 (2 (2 (2 (1 (2 (1 (1 (1 (1 (1 (1 (1 (1 (1 (1 (1 (1 (1 (1 (1 (1 (1 (1 (1 (2 usr/bin/clang) (1 (2 +) (2 (2 +) (2 (2 (2 -LRB-) (2 (2 7.0.0) (2 -RRB-))) (2 configure))))) (2 :)) (2 CFG_CCACHE)) (2 :)) (2 (2 =) (2 configure))) (2 :)) (2 CFG_GCC)) (2 :)) (1 (2 (2 =) (2 /)) (2 (2 usr/bin/gcc) (2 (2 (2 -LRB-) (2 (2 7.0.0) (2 -RRB-))) (2 configure))))) (2 :)) (2 CFG_LD)) (2 :)) (2 (2 =) (2 (2 /) (2 (2 usr/bin/ld) (2 configure))))) (2 :)) (2 CFG_VALGRIND)) (2 :)) (2 (2 =) (2 configure))) (2 :)) (2 CFG_PERF)) (2 :)) (2 (2 =) (2 configure))) (2 :)) (2 CFG_ISCC)) (2 :)) (2 (2 =) (2 configure))) (2 :)) (2 CFG_ANTLR4)) (2 :)) (2 (2 =) (2 configure))) (2 :)) (2 CFG_GRUN)) (2 :)) (2 (2 =) (2 configure))) (2 :)) (2 CFG_FLEX)) (2 :)) (1 (2 (2 =) (2 /)) (2 (2 usr/bin/flex) (2 (2 (2 -LRB-) (2 (2 2.5.35) (2 -RRB-))) (2 configure))))) (2 :)) (2 CFG_BISON)) (2 :)) (1 (2 (2 =) (2 /)) (2 (2 usr/bin/bison) (2 (2 (2 -LRB-) (2 (2 2.3) (2 -RRB-))) (2 configure))))) (2 :)) (2 CFG_PANDOC)) (2 :)) (2 (2 =) (2 configure))) (2 :)) (2 CFG_XELATEX)) (2 :)) (2 (2 =) (2 configure))) (2 :)) (2 CFG_GDB)) (2 :)) (2 (2 =) (2 configure))) (2 :)) (2 CFG_LLDB)) (2 :)) (1 (2 (2 =) (2 /)) (2 (2 usr/bin/lldb) (2 (2 (2 -LRB-) (2 (2 340.4.53.3) (2 -RRB-))) (2 configure))))) (2 :)) (2 CFG_DISABLE_VALGRIND_RPASS)) (2 :)) (2 (2 =) (2 (2 1) (2 configure)))) (2 :)) (2 CFG_LLDB_VERSION)) (2 :)) (2 (2 =) (2 (2 lldb-340) (2 (2 .4.53.3) (2 configure))))) (2 :)) (2 CFG_LLDB_PYTHON_DIR)) (2 :)) (2 =)))))) (1 (2 /) (1 (2 Library/Developer/CommandLineTools) (2 (2 ...) (2 (2 (2 configure) (2 :)) (2 .))))))))))))
configure: looking for target specific programs
configure:.
(2 (2 configure) (2 (2 :) (2 (2 (2 looking) (2 (2 for) (2 (2 target) (2 (2 specific) (2 programs))))) (2 (2 (2 configure) (2 :)) (2 .)))))
configure: CFG_ADB              :=
configure:.
(2 (2 (2 (2 configure) (2 :)) (2 (2 (2 CFG_ADB) (2 :)) (2 (2 =) (2 (2 configure) (2 :))))) (2 .))
configure: on OS X >=10.9, forcing use of clang
configure:.
(1 (1 (2 (2 configure) (2 :)) (1 (1 (2 on) (1 (2 (2 OS) (2 X)) (1 (2 (2 (2 >) (2 (2 =) (2 10.9))) (2 ,)) (1 (1 forcing) (2 (2 use) (2 (2 of) (2 (2 clang) (2 configure)))))))) (2 :))) (2 .))
configure: CFG_ENABLE_CLANG     := 1
configure: CFG_USING_CLANG      := 1
configure: error: bad CLANG version: 7.0.0, need >=3.0svn.
(0 (1 (1 (1 (1 (2 (1 (2 (2 (2 (2 (2 (2 (2 (2 configure) (2 :)) (2 CFG_ENABLE_CLANG)) (2 :)) (2 (2 =) (2 (2 1) (2 configure)))) (2 :)) (2 CFG_USING_CLANG)) (2 :)) (2 (2 =) (2 (2 1) (2 configure)))) (2 :)) (1 (1 (1 error) (2 :)) (1 (0 bad) (2 (2 CLANG) (2 version))))) (2 :)) (2 7.0.0)) (2 ,)) (2 (2 (2 need) (2 (2 >) (2 (2 =) (2 (2 3.0) (2 svn))))) (2 .)))
Once #8974 lands, we can go ahead with this.
(2 (2 (2 Once) (2 (2 (2 #) (2 8974)) (2 lands))) (2 (2 ,) (2 (2 we) (2 (2 (2 can) (2 (2 (2 go) (2 ahead)) (2 (2 with) (2 this)))) (2 .)))))
This will only work for inline-code.
(2 (2 This) (2 (2 (2 (2 will) (2 only)) (2 (2 work) (2 (2 for) (2 inline-code)))) (2 .)))
The compiler knows the high bits will always be zero for inline-code so it can reuse one of them as the tag, with zero representing a inline-code and non-zero representing inline-code.
(1 (2 (2 The) (2 compiler)) (1 (1 (2 knows) (1 (2 (2 the) (2 (3 high) (2 bits))) (1 (2 (2 will) (2 always)) (0 (1 (2 be) (1 (1 zero) (2 (2 for) (2 inline-code)))) (1 (2 so) (1 (2 it) (1 (2 can) (1 (2 (2 (2 (2 reuse) (2 (2 one) (2 (2 of) (2 them)))) (2 (2 as) (2 (2 the) (2 tag)))) (2 ,)) (1 (2 with) (1 (1 zero) (2 (2 representing) (2 (2 (2 a) (2 (2 (2 inline-code) (2 and)) (2 non-zero))) (2 (2 representing) (2 inline-code)))))))))))))) (2 .)))
It can't actually set any of the bits or references won't work.
(1 (2 It) (1 (1 (2 (2 (2 ca) (2 n't)) (2 actually)) (2 (2 set) (2 (2 (2 any) (2 (2 of) (2 (2 the) (2 (2 (2 bits) (2 or)) (2 references))))) (2 (2 (2 wo) (2 n't)) (2 work))))) (2 .)))
In the same vein as #6791.
(2 (2 (2 In) (2 (2 (2 the) (2 (2 same) (3 vein))) (2 (2 as) (2 (2 #) (2 6791))))) (2 .))
Is a reasonable optimization but probably not critical.
(2 (2 (2 Is) (2 (2 (2 (2 a) (2 (3 reasonable) (2 optimization))) (2 but)) (2 (2 probably) (2 (1 not) (2 critical))))) (2 .))
We do similar optimizations for pointer types, I think.
(1 (2 (2 We) (2 (2 do) (2 (2 (2 similar) (2 optimizations)) (2 (2 for) (2 (2 pointer) (2 types)))))) (2 (2 ,) (2 (2 I) (2 (2 think) (2 .)))))
If someone can mentor me through this bug, I'd be interested in giving it a try.
(1 (2 (2 If) (1 (2 someone) (2 (2 can) (1 (2 (2 mentor) (3 me)) (2 (2 through) (2 (2 this) (2 bug))))))) (2 (2 ,) (2 (2 I) (2 (2 (2 'd) (2 (2 be) (2 (3 interested) (2 (2 in) (2 (2 (2 giving) (2 it)) (2 (2 a) (2 try))))))) (2 .)))))
@Thiez what happens for:.
(2 (2 (2 (2 @Thiez) (2 (2 what) (2 (2 happens) (2 for)))) (2 :)) (2 .))
it'd have to be able to handle sub-word references.
(2 (2 it) (2 (2 (2 'd) (2 (2 have) (2 (2 to) (2 (2 be) (2 (3 able) (2 (2 to) (2 (2 handle) (2 (2 sub-word) (2 references))))))))) (2 .)))
If the compiler knew about possible values a type could take perhaps it could make these optimizations automatically?
(1 (2 (2 If) (2 (2 (2 the) (2 compiler)) (3 (2 (2 knew) (2 (2 about) (2 (2 possible) (2 values)))) (2 (2 (2 a) (2 type)) (2 (2 could) (2 (2 take) (2 perhaps))))))) (2 (2 it) (2 (2 (2 could) (2 (2 (2 make) (2 (2 these) (2 optimizations))) (2 automatically))) (2 ?))))
E.g. an ASCII character can have values in the range 0-127, so inline-code could automatically get optimized to 1 byte.
(1 (1 (3 (3 (2 (2 E.g.) (3 (2 (2 an) (2 (2 ASCII) (2 character))) (2 (2 can) (2 (2 have) (2 (2 values) (2 (2 in) (2 (2 the) (2 (2 range) (2 0-127))))))))) (2 ,)) (2 so)) (1 (2 inline-code) (1 (2 (2 could) (2 automatically)) (2 (2 get) (2 (2 optimized) (2 (2 to) (2 (2 1) (2 byte)))))))) (2 .))
The following could be optimized to a single byte as well.
(1 (2 (2 The) (2 following)) (2 (2 (2 could) (2 (2 be) (3 (2 (2 optimized) (2 (2 to) (2 (2 a) (2 (2 single) (2 byte))))) (2 (2 as) (3 well))))) (2 .)))
Because inline-code has 6 variants it can use 3 tag bits, and T uses 1 bit, so the largest variant uses 5 bits for the data, it all fits in a byte.
(3 (3 (2 Because) (3 (2 inline-code) (3 (2 has) (3 (2 (2 6) (2 variants)) (3 (3 (3 (3 (2 (2 (2 (2 it) (2 (2 can) (2 (2 use) (2 (2 3) (2 (2 tag) (2 bits)))))) (2 ,)) (2 and)) (2 (2 T) (2 (2 uses) (2 (2 1) (2 bit))))) (2 ,)) (2 so)) (2 (2 (2 the) (2 (2 largest) (2 variant))) (2 (2 uses) (2 (2 (2 5) (2 bits)) (2 (2 for) (2 (2 the) (2 data))))))))))) (3 (2 ,) (3 (2 it) (3 (2 all) (3 (3 (3 fits) (2 (2 in) (2 (2 a) (2 byte)))) (2 .))))))
@thestinger: Yes.
(2 (2 (2 (2 @thestinger) (2 :)) (2 Yes)) (2 .))
But if you have:.
(2 (2 But) (2 (2 (2 (2 if) (2 (2 you) (2 have))) (2 :)) (2 .)))
You can freely use up to 11 bits to represent which variant it is, with the restriction that zero is reserved for inline-code.
(1 (2 You) (1 (1 (2 (2 can) (3 freely)) (1 (2 (2 (2 use) (2 up)) (2 (2 to) (2 (2 11) (2 bits)))) (1 (2 to) (1 (2 represent) (1 (2 which) (1 (2 variant) (1 (2 it) (1 (2 (2 (2 is) (2 ,)) (2 (2 with) (2 (2 the) (2 restriction)))) (1 (2 that) (1 (1 zero) (2 (2 is) (2 (2 reserved) (2 (2 for) (2 inline-code)))))))))))))) (2 .)))
I think it would work for any enum with up to 2047 nullary variants and one variant containing a inline-code.
(1 (2 I) (1 (2 (2 think) (1 (2 it) (1 (2 would) (1 (2 (2 work) (2 (2 for) (2 (2 any) (2 enum)))) (1 (2 with) (1 (2 (2 (2 (2 (2 up) (2 to)) (2 2047)) (2 (2 nullary) (2 variants))) (2 and)) (2 (2 (2 one) (2 variant)) (2 (2 containing) (2 (2 a) (2 inline-code)))))))))) (2 .)))
@Yoric one starting point to look would be  src/librustc_trans/trans/adt.
(1 (2 (2 (2 @Yoric) (2 one)) (2 (2 (3 starting) (2 point)) (2 (2 to) (2 look)))) (2 (2 (2 would) (2 (2 be) (2 (2 src/librustc) (2 (2 _) (2 trans/trans/adt))))) (2 .)))
rs ; you might look over how PR #19765 changed that file to expand how we search for potential discriminant representations in an enum.
(1 (1 (2 (2 rs) (2 ;)) (1 (2 you) (2 (2 might) (1 (2 (2 look) (2 over)) (1 (2 (2 how) (2 PR)) (2 (2 (2 #) (2 19765)) (1 (2 changed) (1 (2 that) (1 (2 file) (2 (2 to) (1 (2 expand) (2 (2 how) (2 (2 we) (1 (2 search) (2 (2 for) (2 (2 (3 potential) (2 (2 discriminant) (2 representations))) (2 (2 in) (2 (2 an) (2 enum))))))))))))))))))) (2 .))
A inline-code is a inline-code, but Unicode is standardized to only take up 21bit, so there is more than enough space for that optimization.
(1 (1 (2 (2 (2 (2 (2 A) (2 inline-code)) (2 (2 is) (2 (2 a) (2 inline-code)))) (2 ,)) (2 but)) (1 (2 Unicode) (1 (1 (1 (2 is) (2 (2 standardized) (2 (2 to) (2 (2 only) (2 (2 (2 take) (2 up)) (2 21bit)))))) (2 ,)) (2 (2 so) (2 (2 there) (2 (2 (2 is) (2 (2 more) (2 (2 than) (2 enough)))) (2 (2 space) (2 (2 for) (2 (2 that) (2 optimization)))))))))) (2 .))
Might be useful for specifying code page conversion tables with holes in them.
(2 (2 (2 Might) (1 (2 be) (1 (2 useful) (2 (2 for) (2 (2 (2 specifying) (2 (2 code) (2 (2 page) (3 (2 conversion) (2 tables))))) (2 (2 with) (2 (2 holes) (2 (2 in) (2 them))))))))) (2 .))
We now have range asserts on inline-code, so this is more possible than it was before.
(1 (1 (1 (1 (2 (2 We) (2 (2 now) (2 (2 have) (2 (2 range) (2 (2 asserts) (2 (2 on) (2 inline-code))))))) (2 ,)) (2 so)) (3 (2 this) (3 (3 (2 is) (2 (2 more) (2 possible))) (2 (2 than) (2 (2 it) (2 (2 was) (2 before))))))) (2 .))
Can this case be extended to inline-code as well?
(2 (2 (2 (2 Can) (2 (2 this) (2 case))) (2 (2 be) (2 (2 extended) (2 (2 to) (3 (2 inline-code) (2 (2 as) (3 well))))))) (2 ?))
it has 7 unused bits.
(2 (2 it) (2 (2 (2 has) (2 (2 7) (2 (2 unused) (2 bits)))) (2 .)))
Okay, this would mean representing inline-code as the zero tag and inline-code with the non-zero tag.
(1 (2 Okay) (1 (2 ,) (1 (2 this) (1 (1 (2 would) (1 (1 (2 (1 mean) (1 (2 (2 representing) (2 inline-code)) (1 (2 as) (1 (2 the) (1 (1 zero) (2 tag)))))) (2 and)) (2 (2 inline-code) (2 (2 with) (2 (2 the) (2 (2 non-zero) (2 tag))))))) (2 .)))))
If we fix inline-code to actually always be 21-bit, that would work.
(2 (2 (2 If) (3 (2 we) (3 (2 fix) (3 (2 inline-code) (3 (2 (2 to) (2 actually)) (2 (2 always) (2 (2 be) (2 21-bit)))))))) (2 (2 ,) (2 (2 that) (2 (2 (2 would) (2 work)) (2 .)))))
If you set any of the bits in the inline-code, a reference to the inline-code will be corrupt.
(1 (2 (2 If) (2 (2 you) (2 (2 (2 set) (2 (2 any) (2 (2 of) (2 (2 the) (2 bits))))) (2 (2 in) (2 (2 the) (2 inline-code)))))) (1 (2 ,) (1 (2 (2 (2 a) (2 reference)) (2 (2 to) (2 (2 the) (2 inline-code)))) (2 (2 (2 will) (2 (2 be) (1 corrupt))) (2 .)))))
Similar to URL.
(2 (2 (2 Similar) (2 (2 to) (2 URL))) (2 .))
FYI @pnkfelix I rebased @Yoric's work onto @eddyb's recent PR #35764
I'll wait for that to land, then I'll issue a PR for Yoric's rebased work.
(0 (1 (1 (1 (1 (2 FYI) (1 (2 @pnkfelix) (1 (2 I) (1 (2 (2 (2 rebased) (2 (2 (2 @Yoric) (2 's)) (2 work))) (2 (2 onto) (2 (2 (2 @eddyb) (2 's)) (2 (2 recent) (2 (2 PR) (2 (2 #) (2 35764))))))) (1 (2 I) (2 (2 'll) (2 (2 wait) (2 (2 for) (2 (2 that) (2 (2 to) (2 land))))))))))) (2 ,)) (2 then)) (1 (2 I) (1 (2 'll) (1 (2 issue) (2 (2 (2 a) (2 PR)) (2 (2 for) (2 (2 (2 Yoric) (2 's)) (2 (2 rebased) (2 work))))))))) (2 .))
Tuples implement Debug and Hash if their components do.
(1 (2 Tuples) (2 (2 (2 (2 implement) (2 (2 (2 Debug) (2 and)) (2 Hash))) (2 (2 if) (2 (2 (2 their) (2 components)) (2 do)))) (2 .)))
closes #24826
r?
(2 (2 (2 closes) (2 (2 #) (2 (2 24826) (2 r)))) (2 ?))
@alexcrichton 
cc @steveklabnik .
(1 (2 (2 @alexcrichton) (2 cc)) (2 (2 @steveklabnik) (2 .)))
Tuples implement Debug and Hash if their components do.
(1 (2 Tuples) (2 (2 (2 (2 implement) (2 (2 (2 Debug) (2 and)) (2 Hash))) (2 (2 if) (2 (2 (2 their) (2 components)) (2 do)))) (2 .)))
closes #24826
r?
(2 (2 (2 closes) (2 (2 #) (2 (2 24826) (2 r)))) (2 ?))
@alexcrichton 
cc @steveklabnik .
(1 (2 (2 @alexcrichton) (2 cc)) (2 (2 @steveklabnik) (2 .)))
@bors: r+ rollup.
(1 (2 (2 (2 @bors) (2 :)) (2 (2 r) (2 (2 +) (2 rollup)))) (2 .))
:hourglass: Testing commit 01fa559 with merge 5678a1a...
:pushpin: Commit 01fa559 has been approved by inline-code
<!-- @bors r=bluss 01fa55988a9158f5b590f910fc37b6cf6e69c705 -->
:sunny: Test successful - auto-linux-32-nopt-t, auto-linux-32-opt, auto-linux-64-nopt-t, auto-linux-64-opt, auto-linux-64-x-android-t, auto-mac-32-opt, auto-mac-64-nopt-t, auto-mac-64-opt, auto-win-gnu-32-nopt-t, auto-win-gnu-32-opt, auto-win-gnu-64-nopt-t, auto-win-gnu-64-opt.
(1 (2 :) (0 (1 (1 (1 (2 (2 hourglass) (2 :)) (1 (1 (1 (2 (2 Testing) (2 (2 commit) (2 01fa559))) (2 (2 (2 with) (2 (2 merge) (2 5678a1a))) (2 ...))) (2 :)) (1 (1 (1 (1 (1 (2 (2 pushpin) (2 :)) (1 (2 (2 Commit) (2 01fa559)) (2 (2 has) (2 (2 been) (2 (2 approved) (2 (2 by) (2 (2 inline-code) (2 <!-- @bors r=bluss 01fa55988a9158f5b590f910fc37b6cf6e69c705 -->)))))))) (2 :)) (2 sunny)) (2 :)) (3 (2 Test) (4 successful))))) (2 -)) (1 (2 auto-linux-32-nopt-t) (1 (2 ,) (1 (2 auto-linux-32-opt) (1 (2 ,) (1 (2 auto-linux-64-nopt-t) (1 (2 ,) (1 (2 auto-linux-64-opt) (1 (2 ,) (1 (2 auto-linux-64-x-android-t) (1 (2 ,) (1 (2 auto-mac-32-opt) (1 (2 ,) (1 (2 auto-mac-64-nopt-t) (1 (2 ,) (1 (2 auto-mac-64-opt) (1 (2 ,) (1 (2 auto-win-gnu-32-nopt-t) (2 (2 ,) (1 (2 auto-win-gnu-32-opt) (2 (2 ,) (2 (2 auto-win-gnu-64-nopt-t) (2 (2 ,) (2 auto-win-gnu-64-opt)))))))))))))))))))))))) (2 .)))
Updated with smaller code and more accurate title.
(2 (2 (2 Updated) (2 (2 with) (2 (2 (2 (2 (2 smaller) (2 code)) (2 and)) (2 (2 more) (3 accurate))) (2 title)))) (2 .))
Triage: @pnkfelix is correct that this is part of #11166, so should be closed or #11166 should be converted to a meta-bug.
(1 (1 (2 (2 Triage) (2 :)) (1 (2 (2 (2 @pnkfelix) (2 (2 (2 is) (2 correct)) (2 (2 that) (3 (2 this) (2 (2 (2 (2 is) (2 (2 part) (2 (2 of) (2 (2 #) (2 11166))))) (2 ,)) (2 (2 so) (2 (2 should) (2 (2 be) (2 closed))))))))) (2 or)) (2 (2 (2 #) (2 11166)) (2 (2 should) (2 (2 be) (2 (2 converted) (2 (2 to) (2 (2 a) (2 meta-bug))))))))) (2 .))
I'm just going to close this in favor of that one.
(2 (2 I) (2 (2 (2 (2 'm) (2 just)) (3 (2 going) (2 (2 to) (2 (2 close) (2 (2 this) (2 (2 in) (2 (2 favor) (2 (2 of) (2 (2 that) (2 one)))))))))) (2 .)))
I'm familiar with coherence restrictions on trait impls only from IRC conversations ages ago.
(1 (2 I) (1 (1 (2 (2 'm) (2 (2 familiar) (1 (2 with) (1 (2 (2 coherence) (2 restrictions)) (2 (2 on) (2 (2 trait) (2 impls))))))) (2 (2 only) (2 (2 (2 from) (2 IRC)) (2 (2 (2 conversations) (2 ages)) (2 ago))))) (2 .)))
It came up in IRC again, and I *briefly* skimmed the manual sections on impls and crates to see if this restriction was spelled out.
(1 (1 (3 (2 (2 (2 It) (2 (2 (2 came) (2 (2 up) (2 (2 in) (2 IRC)))) (2 again))) (2 ,)) (2 and)) (1 (2 I) (1 (2 (2 *) (2 (3 briefly) (2 *))) (1 (1 (2 (2 skimmed) (2 (2 the) (2 (2 manual) (2 sections)))) (2 (2 on) (2 (2 (2 impls) (2 and)) (2 crates)))) (2 (2 to) (2 (2 see) (2 (2 if) (2 (2 (2 this) (2 restriction)) (2 (2 was) (2 (2 spelled) (1 out))))))))))) (2 .))
I may have missed it.
(1 (2 I) (1 (1 (2 may) (1 (2 have) (1 (2 missed) (2 it)))) (2 .)))
Even in that case, I feel it would be most useful in the manual section describing impls: 6.1.9 Implementations (v0.8 manual)
pcwalton has a good blog post providing background: Coherence, Modularity, and Extensibility for Typeclasses
There was some confusion on IRC as to whether coherence restrictions are per-module or per-crate.
(1 (2 (2 Even) (2 (2 in) (2 (2 that) (2 case)))) (1 (2 ,) (1 (2 I) (0 (1 (2 feel) (1 (2 it) (1 (2 would) (1 (2 be) (0 (2 most) (1 (2 useful) (1 (2 in) (0 (1 (1 (1 (1 (1 (1 (1 (2 (2 the) (2 (2 manual) (2 section))) (1 (2 describing) (2 impls))) (2 :)) (1 (1 (2 (2 6.1.9) (2 Implementations)) (2 (2 -LRB-) (2 (2 (2 v0) (2 (2 .8) (2 manual))) (2 -RRB-)))) (3 (2 pcwalton) (3 (2 has) (2 (3 (2 a) (3 (3 good) (2 (2 blog) (2 post)))) (2 (2 providing) (2 background))))))) (2 :)) (2 (2 (2 Coherence) (2 ,)) (2 Modularity))) (2 ,)) (2 and)) (1 (2 (2 Extensibility) (2 (2 for) (2 Typeclasses))) (1 (2 There) (1 (2 (2 was) (2 (2 (2 some) (2 confusion)) (2 (2 on) (2 IRC)))) (2 (2 as) (2 (2 to) (2 (2 whether) (1 (2 (2 coherence) (2 restrictions)) (2 (2 are) (2 (2 (2 per-module) (2 or)) (2 per-crate)))))))))))))))))) (2 .)))))
Some questions I'd like to see answered in the manual:.
(1 (2 Some) (2 (2 (1 (2 questions) (2 (2 I) (2 (2 'd) (3 (2 like) (2 (2 to) (3 (2 see) (2 (3 answered) (2 (2 in) (2 (2 the) (2 manual)))))))))) (2 :)) (2 .)))
* Are trait impls "always public" even when buried in non-public modules?
(2 (2 *) (1 (2 (2 Are) (2 (2 (2 trait) (2 (2 impls) (2 (2 ``) (2 (2 (2 always) (2 public)) (2 ''))))) (2 (2 even) (2 (2 when) (2 (2 buried) (2 (2 in) (2 (2 non-public) (2 modules)))))))) (2 ?)))
* Can a crate define a trait in one module, `inline-codeinline-codeinline-code` coherently?
(1 (2 *) (1 (2 (2 (2 Can) (2 (2 a) (2 crate))) (2 (2 define) (2 (2 (2 a) (2 trait)) (2 (2 in) (2 one))))) (1 (2 (2 (2 module) (2 ,)) (2 `)) (2 (2 (2 (2 inline-codeinline-codeinline-code) (2 `)) (2 coherently)) (2 ?)))))
This seems like a sub-bug of #11166 to me...
Triage: coherence is per-crate, since the compiler sees the whole crate at once (and so can reason about that).
(1 (1 (2 (1 (2 This) (1 (2 (2 seems) (2 (2 like) (2 (2 (2 a) (2 sub-bug)) (2 (2 of) (2 (2 #) (2 11166)))))) (2 (2 to) (3 me)))) (2 ...)) (1 (2 (2 (2 Triage) (2 :)) (2 coherence)) (2 (2 (2 (2 is) (2 per-crate)) (2 ,)) (2 (2 since) (2 (2 (2 the) (2 compiler)) (2 (2 (2 sees) (2 (2 (2 the) (2 (2 whole) (2 crate))) (2 (2 at) (2 once)))) (2 (2 -LRB-) (2 (2 and) (2 (2 (2 so) (2 (2 can) (2 (2 reason) (2 (2 about) (2 that))))) (2 -RRB-)))))))))) (2 .))
Answers (if someone wishes to take this on):.
(1 (2 (2 (2 Answers) (2 -LRB-)) (2 (2 if) (2 someone))) (2 (2 (2 (2 (2 (2 wishes) (2 (2 to) (2 (2 take) (2 this)))) (2 on)) (2 -RRB-)) (2 :)) (2 .)))
Yes, inline-codes are scoped with the trait, so if the trait is public, so are all impls no matter where the impls are placed.
(1 (1 (1 (2 (1 (2 Yes) (2 (2 ,) (2 (2 inline-codes) (2 (2 are) (2 (2 scoped) (2 (2 with) (2 (2 the) (2 trait)))))))) (2 ,)) (2 so)) (1 (2 (2 if) (2 (2 (2 the) (2 trait)) (2 (2 is) (2 public)))) (2 (2 ,) (1 (2 so) (2 (2 (2 (2 are) (2 all)) (2 impls)) (2 (1 no) (2 (2 matter) (2 (2 where) (2 (2 (2 the) (2 impls)) (2 (2 are) (2 placed))))))))))) (2 .))
Yes, that's fine, since coherence is per-crate.
(3 (2 Yes) (3 (2 ,) (3 (2 that) (3 (3 (3 (2 (2 's) (3 fine)) (2 ,)) (2 (2 since) (2 (2 coherence) (2 (2 is) (2 per-crate))))) (2 .)))))
@pnkfelix pointed out that I'd accidentally said "coherence is per-module" originally; fixed now.
(1 (1 (1 (1 (2 @pnkfelix) (1 (2 (2 pointed) (1 out)) (1 (2 that) (1 (2 I) (1 (2 (2 'd) (2 accidentally)) (2 (2 (2 (2 (2 said) (2 ``)) (2 (2 coherence) (2 (2 is) (2 per-module)))) (2 '')) (2 originally))))))) (2 ;)) (2 (2 fixed) (2 now))) (2 .))
Yeah, inline-code would fix this.
(1 (2 Yeah) (2 (2 ,) (2 (2 inline-code) (2 (2 (2 would) (2 (2 fix) (2 this))) (2 .)))))
The solution I've been using is to document that certain things have to be imported from the crate when a macro is used.
(3 (3 (2 (2 The) (3 solution)) (2 (2 I) (2 (2 've) (2 (2 been) (2 using))))) (2 (2 (2 is) (2 (2 to) (2 (3 document) (2 (2 that) (2 (2 (3 certain) (2 things)) (2 (2 have) (2 (2 to) (2 (2 be) (2 (2 imported) (2 (2 from) (2 (2 (2 the) (2 crate)) (2 (2 when) (2 (2 (2 a) (2 macro)) (2 (2 is) (2 used))))))))))))))) (2 .)))
A better solution would be nice, but would probably require a lot of infrastructure.
(1 (2 (2 A) (2 (4 better) (3 solution))) (1 (1 (2 (2 (2 (2 would) (2 (2 be) (3 nice))) (2 ,)) (2 but)) (1 (2 (2 would) (2 probably)) (2 (2 require) (2 (2 (2 a) (2 lot)) (2 (2 of) (2 infrastructure)))))) (2 .)))
I guess that works too, but it also requires that those things are imported under some specific name.
(1 (1 (2 (2 (2 (2 I) (2 (2 guess) (3 (2 that) (3 (2 works) (2 too))))) (2 ,)) (2 but)) (1 (2 it) (1 (2 also) (1 (2 requires) (2 (2 that) (2 (2 (2 those) (2 things)) (2 (2 are) (2 (2 imported) (2 (2 under) (2 (2 some) (2 (2 specific) (2 name)))))))))))) (2 .))
This looks pretty fixed now.
(2 (2 This) (2 (2 (2 (2 looks) (2 (4 pretty) (2 fixed))) (2 now)) (2 .)))
cc @kmcallister, #17103.
(2 (2 (2 (2 (2 cc) (2 @kmcallister)) (2 ,)) (2 (2 #) (2 17103))) (2 .))
which means the user has to import it under that name to use the macros.
(2 (2 which) (2 (2 (2 means) (2 (2 (2 the) (2 user)) (2 (2 (2 has) (2 (2 to) (2 (2 (2 import) (2 it)) (2 (2 under) (2 (2 that) (2 name)))))) (2 (2 to) (2 (2 use) (2 (2 the) (2 macros))))))) (2 .)))
Yep, has been fixed for a while.
(1 (2 (2 Yep) (2 ,)) (2 (2 (2 has) (2 (2 been) (2 (2 fixed) (2 (2 for) (2 (2 a) (2 while)))))) (2 .)))
IMO, this is two parts:.
(2 (2 IMO) (2 (2 ,) (2 (2 this) (2 (2 (2 (2 is) (2 (2 two) (2 parts))) (2 :)) (2 .)))))
1.
(2 (2 1) (2 .))
stating that enum constructors *are* functions.
(1 (2 (2 (2 stating) (2 (2 that) (2 (2 enum) (2 constructors)))) (2 *)) (2 (2 (2 are) (2 (2 *) (2 functions))) (2 .)))
2.
(2 (2 2) (2 .))
stating that functions can be used where inline-code traits are.
(1 (2 (2 stating) (2 (2 that) (2 (2 functions) (2 (2 can) (2 (2 be) (2 (2 used) (2 (2 where) (2 (2 (2 inline-code) (2 traits)) (2 are))))))))) (2 .))
I don't know how much you need to go into every permutation of every feature in Rust ^_^
It's maybe obliquely mentioned at best.
(2 (1 (2 I) (1 (2 (2 do) (2 n't)) (2 (2 know) (2 (2 (2 how) (2 much)) (2 (2 you) (2 (2 need) (2 (2 to) (2 (2 go) (2 (2 into) (2 (2 (2 every) (2 permutation)) (2 (2 of) (2 (2 (2 every) (2 feature)) (2 (2 in) (2 (2 Rust) (2 ^_^))))))))))))))) (3 (2 It) (3 (3 (2 (2 's) (2 maybe)) (3 (2 obliquely) (3 (2 mentioned) (2 (2 at) (4 best))))) (2 .))))
Neither the nightly Rust reference nor the book seem to mention the fact that one can use enum constructors in a function like way inside expressions, eg.
(1 (2 (2 Neither) (2 (2 (2 (2 the) (2 (2 nightly) (2 (2 Rust) (2 reference)))) (2 nor)) (2 (2 the) (2 book)))) (1 (1 (2 seem) (1 (2 to) (1 (2 (2 mention) (2 (2 the) (2 fact))) (1 (2 that) (1 (2 one) (1 (2 can) (1 (2 (2 use) (2 (2 enum) (2 constructors))) (2 (2 in) (1 (2 (2 a) (2 function)) (2 (2 like) (2 (2 way) (2 (2 inside) (2 (2 (2 expressions) (2 ,)) (2 eg)))))))))))))) (2 .)))
inline-code.
(2 (2 inline-code) (2 .))
(unless I'm mistaken and it's there somewhere, but I didn't find it)
Turns out LLVM only builds libfoo.a libraries, so we're going to need this logic
to statically link librustc.
(1 (2 -LRB-) (0 (1 (2 unless) (1 (2 I) (1 (2 (2 (2 (2 'm) (2 mistaken)) (2 and)) (2 (1 (2 (2 (2 (2 it) (2 (2 's) (2 (2 there) (2 somewhere)))) (2 ,)) (2 but)) (2 (2 I) (2 (2 (2 did) (2 n't)) (2 (2 find) (2 it))))) (2 -RRB-))) (1 (2 (2 Turns) (1 out)) (1 (2 LLVM) (1 (2 only) (3 (2 builds) (2 (2 libfoo.a) (2 libraries))))))))) (1 (2 ,) (1 (2 so) (1 (2 we) (1 (2 (2 're) (1 (2 going) (1 (2 to) (1 (2 (2 need) (2 (2 this) (2 logic))) (2 (2 to) (2 (2 statically) (2 (2 link) (2 librustc)))))))) (2 .)))))))
Turns out LLVM only builds libfoo.a libraries, so we're going to need this logic
to statically link librustc.
(1 (1 (1 (1 (1 (2 (2 (2 (2 Turns) (1 out)) (2 LLVM)) (2 only)) (3 (2 builds) (2 (2 libfoo.a) (2 libraries)))) (2 ,)) (2 so)) (1 (2 we) (2 (2 're) (1 (2 going) (1 (2 to) (1 (2 (2 need) (2 (2 this) (2 logic))) (2 (2 to) (2 (2 statically) (2 (2 link) (2 librustc)))))))))) (2 .))
@alexcrichton +1 for the name of your branch :)
This will be closed by #10965 .
(1 (2 (2 (2 @alexcrichton) (2 +1)) (2 (2 for) (2 (2 (2 the) (2 name)) (2 (2 of) (2 (2 your) (2 branch)))))) (2 (2 (2 :-RRB-) (2 (2 This) (2 (2 will) (2 (2 be) (2 (2 closed) (2 (2 by) (2 (2 #) (2 10965)))))))) (2 .)))
inline-code is now (mostly) gone.
(1 (2 inline-code) (1 (2 (2 (2 is) (2 now)) (1 (2 (2 -LRB-) (2 (2 mostly) (2 -RRB-))) (2 gone))) (2 .)))
When inline-code sees a task to wake up it calls inline-code to reschedule the work, but inline-code assumes that some other scheduler will come along to steal the work.
(1 (1 (2 (2 (2 (2 (2 When) (2 (2 inline-code) (2 (2 (2 sees) (2 (2 a) (2 task))) (2 (2 to) (2 wake))))) (2 (2 up) (2 (2 it) (2 (2 calls) (2 (2 inline-code) (2 (2 to) (2 (2 reschedule) (2 (2 the) (2 work))))))))) (2 ,)) (2 but)) (1 (2 inline-code) (3 (2 assumes) (3 (2 that) (3 (2 (2 some) (2 (2 other) (2 scheduler))) (3 (2 will) (3 (2 (2 come) (2 along)) (3 (2 to) (3 (3 steal) (2 (2 the) (2 work))))))))))) (2 .))
For tasks spawned with inline-code scheduling though, the scheduler doesn't participate in work stealing, so if the task then goes on to block, the other task will never wake up.
(1 (1 (1 (1 (1 (2 (2 For) (1 (2 tasks) (2 (2 (2 spawned) (2 (2 with) (2 (2 inline-code) (2 scheduling)))) (2 though)))) (2 (2 ,) (1 (2 (2 the) (2 scheduler)) (1 (1 (2 does) (2 n't)) (2 (2 participate) (2 (2 in) (2 (2 work) (3 stealing)))))))) (2 ,)) (2 so)) (2 (2 (2 if) (2 (2 (2 the) (2 task)) (2 (2 then) (2 (2 (2 goes) (2 on)) (2 (2 to) (2 block)))))) (2 (2 ,) (2 (2 (2 the) (2 (2 other) (2 task))) (2 (2 (2 will) (2 never)) (2 (2 wake) (2 up))))))) (2 .))
r?
(2 (2 r) (2 ?))
@huonw
(rust_highfive has picked a reviewer for you, use r?
(1 (2 (2 @huonw) (2 (2 -LRB-) (2 (2 rust_highfive) (2 (2 has) (2 (2 picked) (2 (2 (2 a) (2 reviewer)) (2 (2 for) (2 you)))))))) (2 (2 ,) (2 (2 (2 use) (2 r)) (2 ?))))
to override)
:pushpin: Commit e891f29 has been approved by inline-code
<!-- @bors r=huonw e891f29b95bb45ad3ce642b4387a977fae547939 -->
Fixes #24353.
(1 (2 (2 to) (1 (2 (2 override) (2 -RRB-)) (2 (2 (2 :) (2 (2 (2 pushpin) (2 :)) (2 Commit))) (2 e891f29)))) (1 (2 (2 has) (1 (2 been) (2 (2 approved) (2 (2 by) (2 (2 (2 inline-code) (2 (2 <!-- @bors r=huonw e891f29b95bb45ad3ce642b4387a977fae547939 -->) (2 Fixes))) (2 (2 #) (2 24353))))))) (2 .)))
@bors r+
Fixes #24353.
(1 (2 (2 (2 @bors) (2 (2 r) (2 (2 +) (2 Fixes)))) (2 (2 #) (2 24353))) (2 .))
These are superfluous now that we have fixed rvalue lifetimes and Deref.
(1 (2 These) (1 (1 (2 (2 are) (2 superfluous)) (2 (2 now) (2 (2 that) (2 (2 we) (2 (2 have) (2 (2 fixed) (2 (2 (2 (2 rvalue) (2 lifetimes)) (2 and)) (2 Deref)))))))) (2 .)))
I'd also like to kill off inline-code and inline-code, but that'll be a large change so I want to make sure that we actually want to do that first.
(3 (3 (1 (1 (1 (2 I) (1 (2 (2 'd) (2 also)) (1 (2 like) (1 (2 to) (1 (2 (2 kill) (1 off)) (2 (2 (2 inline-code) (2 and)) (2 inline-code))))))) (2 ,)) (2 but)) (3 (2 that) (3 (2 'll) (3 (2 (2 be) (2 (2 a) (2 (2 large) (2 change)))) (3 (2 so) (3 (2 I) (3 (2 want) (3 (2 to) (3 (2 (2 make) (2 sure)) (2 (2 that) (2 (2 we) (2 (2 actually) (2 (2 want) (2 (2 to) (2 (2 do) (2 (2 that) (2 first))))))))))))))))) (2 .))
@alexcrichton Updated with some marker type cleanup.
(1 (2 @alexcrichton) (2 (2 (2 Updated) (2 (2 with) (2 (2 some) (2 (2 marker) (2 (2 type) (2 cleanup)))))) (2 .)))
These are superfluous now that we have fixed rvalue lifetimes and Deref.
(1 (2 These) (1 (1 (2 (2 are) (2 superfluous)) (2 (2 now) (2 (2 that) (2 (2 we) (2 (2 have) (2 (2 fixed) (2 (2 (2 (2 rvalue) (2 lifetimes)) (2 and)) (2 Deref)))))))) (2 .)))
I'd also like to kill off inline-code and inline-code, but that'll be a large change so I want to make sure that we actually want to do that first.
(3 (3 (1 (1 (1 (2 I) (1 (2 (2 'd) (2 also)) (1 (2 like) (1 (2 to) (1 (2 (2 kill) (1 off)) (2 (2 (2 inline-code) (2 and)) (2 inline-code))))))) (2 ,)) (2 but)) (3 (2 that) (3 (2 'll) (3 (2 (2 be) (2 (2 a) (2 (2 large) (2 change)))) (3 (2 so) (3 (2 I) (3 (2 want) (3 (2 to) (3 (2 (2 make) (2 sure)) (2 (2 that) (2 (2 we) (2 (2 actually) (2 (2 want) (2 (2 to) (2 (2 do) (2 (2 that) (2 first))))))))))))))))) (2 .))
Once #7707 lands.
(2 (2 (2 Once) (2 (2 #) (2 (2 7707) (2 lands)))) (2 .))
Shamelessly adds myself as a contributor.
(2 (1 Shamelessly) (3 (2 (2 (2 adds) (2 myself)) (2 (2 as) (2 (2 a) (2 contributor)))) (2 .)))
Shamelessly adds myself as a contributor.
(2 (1 Shamelessly) (3 (2 (2 (2 adds) (2 myself)) (2 (2 as) (2 (2 a) (2 contributor)))) (2 .)))
:confetti_ball: .
(2 (2 :) (2 (2 (2 confetti_ball) (2 :)) (2 .)))
:sunny: Test successful - auto-linux-32-nopt-t, auto-linux-32-opt, auto-linux-64-debug-opt, auto-linux-64-nopt-t, auto-linux-64-opt, auto-linux-64-x-android-t, auto-linux-cross-opt, auto-linux-musl-64-opt, auto-mac-32-opt, auto-mac-64-nopt-t, auto-mac-64-opt, auto-mac-ios-opt, auto-win-gnu-32-nopt-t, auto-win-gnu-32-opt, auto-win-gnu-64-nopt-t, auto-win-gnu-64-opt, auto-win-msvc-32-opt, auto-win-msvc-64-opt.
(2 (2 :) (2 (1 (3 (2 sunny) (3 (2 :) (3 (3 (2 Test) (4 successful)) (2 -)))) (1 (2 auto-linux-32-nopt-t) (1 (2 ,) (1 (2 auto-linux-32-opt) (1 (2 ,) (1 (2 auto-linux-64-debug-opt) (1 (2 ,) (1 (2 auto-linux-64-nopt-t) (1 (2 ,) (1 (2 auto-linux-64-opt) (1 (2 ,) (1 (2 auto-linux-64-x-android-t) (1 (2 ,) (1 (2 auto-linux-cross-opt) (1 (2 ,) (1 (2 auto-linux-musl-64-opt) (1 (2 ,) (1 (2 auto-mac-32-opt) (1 (2 ,) (1 (2 auto-mac-64-nopt-t) (1 (2 ,) (1 (2 auto-mac-64-opt) (1 (2 ,) (1 (2 auto-mac-ios-opt) (1 (2 ,) (1 (2 auto-win-gnu-32-nopt-t) (1 (2 ,) (1 (2 auto-win-gnu-32-opt) (1 (2 ,) (1 (2 auto-win-gnu-64-nopt-t) (2 (2 ,) (1 (2 auto-win-gnu-64-opt) (2 (2 ,) (2 (2 auto-win-msvc-32-opt) (2 (2 ,) (2 auto-win-msvc-64-opt)))))))))))))))))))))))))))))))))))) (2 .)))
r?
(2 (2 r) (2 ?))
@brson .
(2 (2 @brson) (2 .))
These commits add support to the rustbuild build system to compile non-build-system compilers.
(1 (2 These) (2 (2 (2 commits) (2 (3 add) (2 (2 (2 support) (2 (2 to) (2 (2 the) (2 rustbuild)))) (2 (2 (2 build) (2 system)) (2 (2 to) (2 (2 compile) (2 (2 non-build-system) (2 compilers)))))))) (2 .)))
For example this will allow creating an ARM compiler on a x86 system.
(2 (2 (2 For) (2 example)) (2 (2 this) (2 (2 (2 will) (2 (2 allow) (2 (2 (2 creating) (2 (2 an) (2 (2 ARM) (2 compiler)))) (2 (2 on) (2 (2 a) (2 (2 x86) (2 system))))))) (2 .))))
The high level way this works is:.
(3 (3 (2 (2 The) (2 (3 high) (2 (2 level) (2 way)))) (2 (2 this) (2 works))) (2 (2 (2 is) (2 :)) (2 .)))
* The only compiler ever run is the build target compiler.
(1 (2 (2 *) (2 (2 (2 The) (2 (2 only) (2 compiler))) (2 (2 ever) (2 run)))) (2 (2 (2 is) (2 (2 the) (2 (2 build) (2 (2 target) (2 compiler))))) (2 .)))
No other compiler is assumed to be runnable.
(1 (2 (1 No) (2 (2 other) (2 compiler))) (2 (2 (2 is) (2 (2 assumed) (2 (2 to) (2 (2 be) (2 runnable))))) (2 .)))
* As a result, all output artifacts come from the build compiler.
(1 (2 (2 *) (2 (2 As) (2 (2 a) (2 result)))) (2 (2 ,) (2 (2 (2 all) (2 (2 output) (2 artifacts))) (2 (2 (2 come) (2 (2 from) (2 (2 the) (2 (2 build) (2 compiler))))) (2 .)))))
* The libs for the stageN cross-compiled compiler will be linked into place after the build target builds them.
(1 (2 *) (1 (2 (2 The) (2 (2 (2 libs) (2 (2 for) (2 (2 the) (2 stageN)))) (2 (2 cross-compiled) (2 compiler)))) (2 (2 (2 will) (2 (2 be) (2 (2 (2 linked) (2 (2 into) (2 place))) (2 (2 after) (2 (2 the) (2 (2 build) (2 (2 target) (2 (2 builds) (2 them))))))))) (2 .))))
This will break the assumption that a compiler never links to anything it didn't itself produce, but it retains the assumption that a compiler only ever links to anything built in the same stage.
(1 (1 (1 (1 (1 (2 This) (1 (2 will) (1 (2 (2 break) (2 (2 the) (2 assumption))) (1 (2 that) (1 (2 (2 a) (2 compiler)) (1 (2 never) (2 (2 links) (2 (2 to) (2 (2 anything) (2 (2 it) (2 (2 (2 (2 did) (2 n't)) (2 itself)) (2 produce)))))))))))) (2 ,)) (2 but)) (1 (2 it) (1 (2 (2 retains) (2 (2 the) (2 assumption))) (1 (2 that) (1 (2 (2 a) (2 compiler)) (1 (2 only) (2 (2 ever) (2 (2 links) (2 (2 to) (2 (2 anything) (2 (2 built) (2 (2 in) (2 (2 the) (2 (2 same) (2 stage))))))))))))))) (2 .))
I believe this means that the stage1 cross-compiled compilers will still be usable.
(2 (2 I) (2 (2 (2 believe) (2 (2 this) (2 (2 means) (2 (2 that) (2 (2 (2 the) (2 (2 stage1) (2 (2 cross-compiled) (2 compilers)))) (2 (2 (2 will) (2 still)) (2 (2 be) (2 usable)))))))) (2 .)))
I tested this by creating an inline-code compiler.
(2 (2 I) (2 (2 (2 (2 tested) (2 this)) (2 (2 by) (2 (2 creating) (2 (2 an) (2 (2 inline-code) (2 compiler)))))) (2 .)))
So far the linking ended up all working OK (including LLVM being cross compiled), but I haven't been able to run it yet (in QEMU for a raspberry pi).
(1 (1 (2 (2 (2 (2 (2 So) (2 far)) (2 (2 (2 the) (2 linking)) (2 (2 (2 ended) (2 (2 up) (2 all))) (2 (2 (2 working) (2 OK)) (2 (2 -LRB-) (2 (2 (2 including) (2 (2 LLVM) (2 (2 being) (2 (2 cross) (2 compiled))))) (2 -RRB-))))))) (2 ,)) (2 but)) (2 (2 I) (2 (2 (2 have) (2 n't)) (2 (2 been) (2 (3 able) (2 (2 (2 to) (2 (2 (2 run) (2 it)) (2 yet))) (2 (2 -LRB-) (2 (2 (2 in) (2 (2 QEMU) (2 (2 for) (2 (2 a) (2 (2 raspberry) (2 pi)))))) (2 -RRB-))))))))) (2 .))
I think that's because my system linker is messed up or something like that (some newer option is assumed when it's not actually there).
(1 (2 I) (2 (2 (2 think) (1 (2 (2 (2 that) (2 (2 's) (2 (2 because) (2 (2 (2 my) (2 (2 system) (2 linker))) (2 (2 is) (2 (2 messed) (2 up))))))) (2 or)) (2 (2 (2 something) (2 (2 like) (2 that))) (2 (2 -LRB-) (2 (2 (2 (2 some) (2 (2 newer) (2 option))) (2 (2 is) (2 (2 assumed) (2 (2 when) (2 (2 it) (2 (1 (2 (2 's) (1 not)) (2 actually)) (2 there))))))) (2 -RRB-)))))) (2 .)))
Overall, though, this means that rustbuild can compile an arm-unknown-linux-gnueabihf compiler.
(2 (2 Overall) (2 (2 ,) (2 (2 though) (2 (2 ,) (2 (2 this) (2 (2 (2 means) (2 (2 that) (2 (2 rustbuild) (2 (2 can) (2 (2 compile) (2 (2 an) (2 (2 arm-unknown-linux-gnueabihf) (2 compiler)))))))) (2 .)))))))
Ideally we could even start shipping nightlies based on this at some point!
(2 (2 Ideally) (2 (2 we) (2 (2 (2 (2 could) (2 even)) (2 (2 (2 start) (2 (2 shipping) (2 nightlies))) (2 (2 based) (2 (2 on) (2 (2 this) (2 (2 at) (2 (2 some) (2 point)))))))) (2 !))))
:hourglass: Testing commit 15b4a8c with merge 5a0308a...
I've tested this PR by cross compiling a compiler to arm-unknown-linux-gnueabihf.
(1 (2 :) (1 (1 (2 hourglass) (1 (2 :) (1 (1 (1 (2 Testing) (2 (2 (2 commit) (2 15b4a8c)) (2 (2 with) (2 (2 merge) (2 5a0308a))))) (2 ...)) (1 (2 I) (1 (2 've) (1 (2 (2 (2 tested) (2 (2 this) (2 PR))) (2 (2 by) (2 cross))) (2 (2 (2 compiling) (2 (2 a) (2 compiler))) (2 (2 to) (2 arm-unknown-linux-gnueabihf))))))))) (2 .)))
And, then testing that cross compiled rustc/std on an ARMv7 board by running some smoke tests.
(1 (2 And) (1 (2 ,) (1 (2 (2 then) (2 (2 testing) (2 (2 (2 that) (2 cross)) (2 compiled)))) (1 (1 (2 (2 rustc/std) (2 (2 on) (2 (2 an) (2 (2 ARMv7) (2 board))))) (2 (2 by) (1 (2 running) (2 (2 some) (2 (2 smoke) (2 tests)))))) (2 .)))))
The smoke tests consisted of: building cargo, cargo testing hyper and cargo testing clap and all of them succeeded.
(1 (1 (2 (2 (2 (2 The) (2 (2 smoke) (2 tests))) (2 (2 consisted) (2 of))) (2 :)) (1 (1 (1 (1 (2 building) (1 (2 cargo) (1 (2 ,) (1 (2 cargo) (2 (2 testing) (2 (2 hyper) (2 (2 and) (2 (2 cargo) (2 (2 testing) (2 clap)))))))))) (2 and)) (2 (2 all) (2 (2 of) (2 them)))) (3 succeeded))) (2 .))
(NOTE: I needed cargo on the ARM target, so I used an unofficial cargo binary from RustBuild.
(1 (2 -LRB-) (1 (2 NOTE) (1 (2 :) (1 (2 I) (1 (1 (2 (2 (2 (3 needed) (2 cargo)) (2 (2 on) (2 (2 the) (2 (2 ARM) (2 target))))) (2 ,)) (1 (2 so) (1 (2 I) (1 (2 (2 used) (2 (2 an) (2 (2 unofficial) (2 (2 cargo) (2 binary))))) (2 (2 from) (2 RustBuild)))))) (2 .))))))
The host was an x86_64 machine running Ubuntu 15.10.
(1 (2 (2 The) (2 host)) (1 (1 (2 was) (1 (2 (2 an) (2 (2 x86_64) (2 machine))) (2 (2 running) (2 (2 Ubuntu) (2 15.10))))) (2 .)))
The target was an ARMv7 machine running hard-float Ubuntu 15.10)
I found two (minor) issues.
(1 (2 (2 The) (2 target)) (1 (1 (2 was) (1 (2 (2 an) (2 (2 ARMv7) (2 machine))) (1 (2 running) (2 (2 (2 hard-float) (2 (2 Ubuntu) (2 (2 15.10) (2 -RRB-)))) (2 (2 I) (2 (2 found) (2 (2 (2 two) (2 (2 -LRB-) (2 (2 minor) (2 -RRB-)))) (2 issues)))))))) (2 .)))
@alexcrichton  is already aware of them, but to reiterate:.
(2 (2 (2 (2 (2 (2 (2 @alexcrichton) (2 (2 (2 is) (2 already)) (2 (2 aware) (2 (2 of) (2 them))))) (2 ,)) (2 but)) (2 (2 to) (2 reiterate))) (2 :)) (2 .))
- We use the flags produced by the host inline-code to cross compile rustc_llvm.
(1 (2 -) (1 (2 We) (2 (2 (2 use) (2 (2 (2 the) (2 flags)) (2 (2 (2 produced) (2 (2 by) (2 (2 the) (2 (2 host) (2 inline-code))))) (2 (2 to) (2 (2 cross) (2 (2 compile) (2 rustc_llvm))))))) (2 .))))
Among these flags there is a inline-code flag that's not recognized by the ARM cross g++ compiler.
(1 (2 (2 Among) (2 (2 these) (2 flags))) (1 (2 there) (1 (1 (2 is) (1 (2 (2 a) (2 (2 inline-code) (2 flag))) (1 (2 that) (1 (2 (2 's) (1 not)) (1 (2 recognized) (2 (2 by) (2 (2 the) (2 (2 ARM) (2 (2 cross) (1 (2 g) (2 (2 +) (2 (2 +) (2 compiler))))))))))))) (2 .))))
This flag needs to be filtered out before passing the flags to g++.
(1 (2 (2 This) (2 flag)) (1 (1 (2 needs) (2 (2 to) (2 (2 be) (1 (2 (2 filtered) (1 out)) (2 (2 before) (2 (2 passing) (2 (2 (2 the) (2 flags)) (2 (2 to) (2 (2 g) (2 (2 +) (2 +))))))))))) (2 .)))
- The cross compiled inline-code doesn't get copied to the inline-code directories.
(1 (2 -) (1 (2 (2 (2 The) (2 cross)) (2 (2 compiled) (2 inline-code))) (1 (1 (1 (2 does) (2 n't)) (2 (2 get) (2 (2 copied) (2 (2 to) (2 (2 the) (2 (2 inline-code) (2 directories))))))) (2 .))))
How do you exactly use this feature?
(2 (3 How) (2 (2 (2 (2 (2 do) (2 you)) (2 exactly)) (2 (2 use) (2 (2 this) (2 feature)))) (2 ?)))
Can you give an example on howto build for the ARM target you mentioned?
(2 (2 (2 (2 Can) (2 you)) (2 (3 give) (2 (2 (2 (2 an) (2 example)) (2 (2 on) (2 howto))) (2 (2 build) (2 (2 for) (2 (2 (2 the) (2 (2 ARM) (2 target))) (2 (2 you) (2 mentioned)))))))) (2 ?))
Thanks for testing this out @japaric!
(3 (3 (2 Thanks) (2 (2 for) (2 (2 (2 testing) (2 this)) (2 (1 out) (2 @japaric))))) (2 !))
I've amended the relevant commits and those issues should all be fixed.
(3 (2 (2 (2 (2 I) (2 (2 've) (2 (2 amended) (2 (2 the) (2 (2 relevant) (2 commits)))))) (2 and)) (2 (2 (2 those) (2 issues)) (2 (2 (2 should) (2 all)) (2 (2 be) (2 fixed))))) (2 .))
Pass inline-code and inline-code to the inline-code script before calling inline-code.
(1 (1 (1 (2 (2 Pass) (2 (2 (2 inline-code) (2 and)) (2 inline-code))) (2 (2 to) (2 (2 the) (2 (2 inline-code) (2 script))))) (2 (2 before) (2 (2 calling) (2 inline-code)))) (2 .))
Something like this:.
(3 (2 Something) (2 (2 (2 (2 like) (2 this)) (2 :)) (2 .)))
does this cover the inline-code target?
(2 (2 (2 (2 does) (2 this)) (2 (2 cover) (2 (2 the) (2 (2 inline-code) (2 target))))) (2 ?))
@bors r+
I..
(1 (2 @bors) (2 (2 (2 r) (2 (2 +) (2 I.))) (2 .)))
.
(2 .)
doubt it will!
(2 (2 doubt) (3 (2 it) (2 (2 will) (2 !))))
These commits add support to the rustbuild build system to compile non-build-system compilers.
(1 (2 These) (2 (2 (2 commits) (2 (3 add) (2 (2 (2 support) (2 (2 to) (2 (2 the) (2 rustbuild)))) (2 (2 (2 build) (2 system)) (2 (2 to) (2 (2 compile) (2 (2 non-build-system) (2 compilers)))))))) (2 .)))
For example this will allow creating an ARM compiler on a x86 system.
(2 (2 (2 For) (2 example)) (2 (2 this) (2 (2 (2 will) (2 (2 allow) (2 (2 (2 creating) (2 (2 an) (2 (2 ARM) (2 compiler)))) (2 (2 on) (2 (2 a) (2 (2 x86) (2 system))))))) (2 .))))
The high level way this works is:.
(3 (3 (2 (2 The) (2 (3 high) (2 (2 level) (2 way)))) (2 (2 this) (2 works))) (2 (2 (2 is) (2 :)) (2 .)))
* The only compiler ever run is the build target compiler.
(1 (2 (2 *) (2 (2 (2 The) (2 (2 only) (2 compiler))) (2 (2 ever) (2 run)))) (2 (2 (2 is) (2 (2 the) (2 (2 build) (2 (2 target) (2 compiler))))) (2 .)))
No other compiler is assumed to be runnable.
(1 (2 (1 No) (2 (2 other) (2 compiler))) (2 (2 (2 is) (2 (2 assumed) (2 (2 to) (2 (2 be) (2 runnable))))) (2 .)))
* As a result, all output artifacts come from the build compiler.
(1 (2 (2 *) (2 (2 As) (2 (2 a) (2 result)))) (2 (2 ,) (2 (2 (2 all) (2 (2 output) (2 artifacts))) (2 (2 (2 come) (2 (2 from) (2 (2 the) (2 (2 build) (2 compiler))))) (2 .)))))
* The libs for the stageN cross-compiled compiler will be linked into place after the build target builds them.
(1 (2 *) (1 (2 (2 The) (2 (2 (2 libs) (2 (2 for) (2 (2 the) (2 stageN)))) (2 (2 cross-compiled) (2 compiler)))) (2 (2 (2 will) (2 (2 be) (2 (2 (2 linked) (2 (2 into) (2 place))) (2 (2 after) (2 (2 the) (2 (2 build) (2 (2 target) (2 (2 builds) (2 them))))))))) (2 .))))
This will break the assumption that a compiler never links to anything it didn't itself produce, but it retains the assumption that a compiler only ever links to anything built in the same stage.
(1 (1 (1 (1 (1 (2 This) (1 (2 will) (1 (2 (2 break) (2 (2 the) (2 assumption))) (1 (2 that) (1 (2 (2 a) (2 compiler)) (1 (2 never) (2 (2 links) (2 (2 to) (2 (2 anything) (2 (2 it) (2 (2 (2 (2 did) (2 n't)) (2 itself)) (2 produce)))))))))))) (2 ,)) (2 but)) (1 (2 it) (1 (2 (2 retains) (2 (2 the) (2 assumption))) (1 (2 that) (1 (2 (2 a) (2 compiler)) (1 (2 only) (2 (2 ever) (2 (2 links) (2 (2 to) (2 (2 anything) (2 (2 built) (2 (2 in) (2 (2 the) (2 (2 same) (2 stage))))))))))))))) (2 .))
I believe this means that the stage1 cross-compiled compilers will still be usable.
(2 (2 I) (2 (2 (2 believe) (2 (2 this) (2 (2 means) (2 (2 that) (2 (2 (2 the) (2 (2 stage1) (2 (2 cross-compiled) (2 compilers)))) (2 (2 (2 will) (2 still)) (2 (2 be) (2 usable)))))))) (2 .)))
I tested this by creating an inline-code compiler.
(2 (2 I) (2 (2 (2 (2 tested) (2 this)) (2 (2 by) (2 (2 creating) (2 (2 an) (2 (2 inline-code) (2 compiler)))))) (2 .)))
So far the linking ended up all working OK (including LLVM being cross compiled), but I haven't been able to run it yet (in QEMU for a raspberry pi).
(1 (1 (2 (2 (2 (2 (2 So) (2 far)) (2 (2 (2 the) (2 linking)) (2 (2 (2 ended) (2 (2 up) (2 all))) (2 (2 (2 working) (2 OK)) (2 (2 -LRB-) (2 (2 (2 including) (2 (2 LLVM) (2 (2 being) (2 (2 cross) (2 compiled))))) (2 -RRB-))))))) (2 ,)) (2 but)) (2 (2 I) (2 (2 (2 have) (2 n't)) (2 (2 been) (2 (3 able) (2 (2 (2 to) (2 (2 (2 run) (2 it)) (2 yet))) (2 (2 -LRB-) (2 (2 (2 in) (2 (2 QEMU) (2 (2 for) (2 (2 a) (2 (2 raspberry) (2 pi)))))) (2 -RRB-))))))))) (2 .))
I think that's because my system linker is messed up or something like that (some newer option is assumed when it's not actually there).
(1 (2 I) (2 (2 (2 think) (1 (2 (2 (2 that) (2 (2 's) (2 (2 because) (2 (2 (2 my) (2 (2 system) (2 linker))) (2 (2 is) (2 (2 messed) (2 up))))))) (2 or)) (2 (2 (2 something) (2 (2 like) (2 that))) (2 (2 -LRB-) (2 (2 (2 (2 some) (2 (2 newer) (2 option))) (2 (2 is) (2 (2 assumed) (2 (2 when) (2 (2 it) (2 (1 (2 (2 's) (1 not)) (2 actually)) (2 there))))))) (2 -RRB-)))))) (2 .)))
Overall, though, this means that rustbuild can compile an arm-unknown-linux-gnueabihf compiler.
(2 (2 Overall) (2 (2 ,) (2 (2 though) (2 (2 ,) (2 (2 this) (2 (2 (2 means) (2 (2 that) (2 (2 rustbuild) (2 (2 can) (2 (2 compile) (2 (2 an) (2 (2 arm-unknown-linux-gnueabihf) (2 compiler)))))))) (2 .)))))))
Ideally we could even start shipping nightlies based on this at some point!
(2 (2 Ideally) (2 (2 we) (2 (2 (2 (2 could) (2 even)) (2 (2 (2 start) (2 (2 shipping) (2 nightlies))) (2 (2 based) (2 (2 on) (2 (2 this) (2 (2 at) (2 (2 some) (2 point)))))))) (2 !))))
:pushpin: Commit 15b4a8c has been approved by inline-code
<!-- @bors r=brson 15b4a8c2f32460b4b9b9ba27c17cbcf5144b14bb -->
Oh!
(1 (2 :) (1 (2 (2 (2 pushpin) (2 :)) (2 (2 Commit) (2 15b4a8c))) (1 (1 (2 has) (1 (2 been) (2 (2 approved) (2 (2 by) (2 (2 inline-code) (2 (2 <!-- @bors r=brson 15b4a8c2f32460b4b9b9ba27c17cbcf5144b14bb -->) (2 Oh))))))) (2 !))))
I just realized 'this list can never shrink.'
(1 (2 I) (1 (2 just) (1 (1 (1 (2 (2 realized) (2 `)) (1 (2 (2 this) (1 list)) (2 (2 (2 can) (2 never)) (2 shrink)))) (2 .)) (2 '))))
I've set it to 'removed.'
(2 (2 I) (2 (2 (2 (2 've) (2 (2 set) (2 (2 it) (2 (2 (2 to) (2 `)) (2 removed))))) (2 .)) (2 ')))
Let's see how this builds.
(3 (2 (2 Let) (2 's)) (3 (3 (2 see) (2 (2 how) (2 (2 this) (2 builds)))) (2 .)))
Oh, wait, that still doesn't fix it, because I've removed the gate annotations.
(1 (2 (2 Oh) (2 (2 ,) (2 wait))) (1 (2 ,) (1 (2 that) (1 (2 still) (1 (1 (1 (2 does) (2 n't)) (1 (2 (2 (2 fix) (2 it)) (2 ,)) (1 (2 because) (2 (2 I) (2 (2 've) (2 (2 removed) (2 (2 the) (2 (2 gate) (2 annotations))))))))) (2 .))))))
Still curious what the right method is here.
(3 (2 Still) (2 (3 curious) (3 (2 (2 what) (3 (2 (2 the) (3 (3 right) (2 method))) (2 (2 is) (2 here)))) (2 .))))
I guess it should be "Accepted" not "removed."
(1 (2 I) (1 (1 (1 (2 guess) (2 (2 it) (2 (2 should) (2 (2 be) (2 (2 (2 ``) (2 (2 (2 Accepted) (2 '')) (1 not))) (2 (2 ``) (2 removed))))))) (2 .)) (2 '')))
I am bad at this ;)
@alexcrichton allllrighty.
(1 (2 I) (1 (1 (2 am) (1 (0 bad) (2 (2 at) (2 (2 this) (2 (2 ;-RRB-) (2 (2 @alexcrichton) (2 allllrighty))))))) (2 .)))
I, uh, missed the 'tweak visibility' bit.
(1 (2 I) (1 (2 ,) (1 (2 uh) (1 (2 ,) (1 (1 (2 missed) (2 (2 the) (3 (2 `) (3 (2 tweak) (2 (2 visibility) (2 (2 ') (2 bit))))))) (2 .))))))
I'll just give this a close then, I don't have those skills yet :)
I might prefer to fix the field visibility with struct variants before un-feature-gating them.
(1 (2 (2 I) (2 (2 (2 'll) (2 just)) (2 (2 (2 (3 give) (2 this)) (2 (2 a) (2 close))) (2 then)))) (1 (2 ,) (1 (2 I) (1 (1 (2 (2 do) (2 n't)) (1 (2 (2 (2 have) (2 (2 those) (2 skills))) (2 yet)) (1 (2 :-RRB-) (2 (2 I) (2 (2 might) (2 (2 prefer) (2 (2 to) (1 (2 (2 (2 fix) (2 (2 the) (2 (2 field) (2 visibility)))) (2 (2 with) (2 (2 struct) (2 variants)))) (2 (2 before) (2 (2 un-feature-gating) (2 them))))))))))) (2 .)))))
Once they're un-feature-gated they're 1.0 blockers and I don't think we want to block 1.0 on struct variants.
(1 (1 (2 (1 (2 (2 Once) (2 (2 they) (2 (2 're) (2 un-feature-gated)))) (2 (2 they) (2 (2 're) (2 (2 1.0) (2 blockers))))) (2 and)) (2 (2 I) (2 (2 (2 do) (2 n't)) (2 (2 think) (2 (2 we) (2 (2 want) (2 (2 to) (2 (2 (2 block) (2 1.0)) (2 (2 on) (2 (2 struct) (2 variants))))))))))) (2 .))
I also think that the system of Accepted/Removed/etc for feature gates doesn't make sense in light of how feature gates are now intended to work.
(1 (2 I) (1 (2 also) (1 (2 (2 think) (1 (2 that) (1 (2 (2 (2 the) (2 system)) (2 (2 of) (2 (2 Accepted/Removed/etc) (2 (2 for) (2 (2 feature) (3 gates)))))) (1 (1 (2 does) (2 n't)) (2 (2 (2 make) (2 sense)) (2 (2 in) (2 (2 light) (2 (2 of) (2 (2 how) (2 (2 (2 feature) (3 gates)) (2 (2 (2 are) (2 now)) (2 (2 intended) (2 (2 to) (2 work)))))))))))))) (2 .))))
It was supposed to be a backwards compatible change to accept a feature gate (can't break code mentioning it), but feature gates are never backwards compatible so it's ok to just delete it.
(1 (1 (1 (1 (2 (2 It) (1 (2 was) (1 (2 supposed) (2 (2 to) (1 (2 (2 be) (3 (2 a) (3 (2 (2 backwards) (3 compatible)) (2 (2 change) (2 (2 to) (2 (2 accept) (2 (2 a) (2 (2 feature) (2 gate))))))))) (2 (2 -LRB-) (2 (2 (2 (2 ca) (2 n't)) (2 (2 (2 break) (2 code)) (2 (2 mentioning) (2 it)))) (2 -RRB-)))))))) (2 ,)) (2 but)) (1 (2 (2 feature) (3 gates)) (1 (2 (2 are) (2 (2 never) (2 backwards))) (1 (3 compatible) (1 (2 so) (1 (2 it) (1 (2 's) (1 (2 ok) (1 (2 to) (1 (2 just) (3 (2 delete) (2 it)))))))))))) (2 .))
Not ready for merge yet!
(2 (2 (2 (2 Not) (2 ready)) (2 (2 for) (2 (2 merge) (2 yet)))) (2 !))
While I continue to ponder the ownership guide, I figured I'd do little inline-code hacking.
(1 (2 (2 While) (3 (2 I) (2 (2 continue) (2 (2 to) (2 (2 ponder) (2 (2 the) (2 (2 ownership) (2 guide)))))))) (1 (2 ,) (2 (2 I) (2 (2 (2 figured) (2 (2 I) (2 (2 'd) (2 (2 do) (2 (2 little) (2 (2 inline-code) (2 hacking))))))) (2 .)))))
I currently have this, which I believe removes the feature gate, but, given that the snapshot has the gate turned off, what's the right strategy to fix this?
(1 (2 (2 I) (2 (2 currently) (1 (2 (2 (2 (3 (2 have) (3 (2 (2 this) (2 ,)) (2 (2 which) (3 (2 I) (2 (2 believe) (2 (2 removes) (2 (2 the) (2 (2 feature) (2 gate))))))))) (2 ,)) (2 but)) (2 ,)) (2 (2 given) (2 (2 that) (2 (2 (2 the) (2 snapshot)) (2 (2 has) (2 (2 (2 the) (2 gate)) (2 (2 turned) (1 off)))))))))) (2 (2 ,) (2 (2 what) (2 (3 (2 (2 's) (2 (2 the) (2 (3 right) (2 strategy)))) (2 (2 to) (2 (2 fix) (2 this)))) (2 ?)))))
Maybe turn URL to 'inactive', wait for a snapshot, and then apply this PR afterwards?
(1 (2 Maybe) (1 (1 (2 turn) (1 (2 URL) (1 (2 to) (0 (1 (1 (1 (2 (2 (2 `) (1 (1 inactive) (2 '))) (2 ,)) (2 (2 wait) (2 (2 for) (2 (2 a) (2 snapshot))))) (2 ,)) (2 and)) (1 (2 then) (1 (1 (2 apply) (2 (2 this) (2 PR))) (2 afterwards))))))) (2 ?)))
Not ready for merge yet!
(2 (2 (2 (2 Not) (2 ready)) (2 (2 for) (2 (2 merge) (2 yet)))) (2 !))
While I continue to ponder the ownership guide, I figured I'd do little inline-code hacking.
(1 (2 (2 While) (3 (2 I) (2 (2 continue) (2 (2 to) (2 (2 ponder) (2 (2 the) (2 (2 ownership) (2 guide)))))))) (1 (2 ,) (2 (2 I) (2 (2 (2 figured) (2 (2 I) (2 (2 'd) (2 (2 do) (2 (2 little) (2 (2 inline-code) (2 hacking))))))) (2 .)))))
I currently have this, which I believe removes the feature gate, but, given that the snapshot has the gate turned off, what's the right strategy to fix this?
(1 (2 (2 I) (2 (2 currently) (1 (2 (2 (2 (3 (2 have) (3 (2 (2 this) (2 ,)) (2 (2 which) (3 (2 I) (2 (2 believe) (2 (2 removes) (2 (2 the) (2 (2 feature) (2 gate))))))))) (2 ,)) (2 but)) (2 ,)) (2 (2 given) (2 (2 that) (2 (2 (2 the) (2 snapshot)) (2 (2 has) (2 (2 (2 the) (2 gate)) (2 (2 turned) (1 off)))))))))) (2 (2 ,) (2 (2 what) (2 (3 (2 (2 's) (2 (2 the) (2 (3 right) (2 strategy)))) (2 (2 to) (2 (2 fix) (2 this)))) (2 ?)))))
Maybe turn URL to 'inactive', wait for a snapshot, and then apply this PR afterwards?
(1 (2 Maybe) (1 (1 (2 turn) (1 (2 URL) (1 (2 to) (0 (1 (1 (1 (2 (2 (2 `) (1 (1 inactive) (2 '))) (2 ,)) (2 (2 wait) (2 (2 for) (2 (2 a) (2 snapshot))))) (2 ,)) (2 and)) (1 (2 then) (1 (1 (2 apply) (2 (2 this) (2 PR))) (2 afterwards))))))) (2 ?)))
Oh sorry, I should have read the issue more closely!
(1 (2 Oh) (1 (2 sorry) (2 (2 ,) (2 (2 I) (2 (2 (2 should) (2 (2 have) (2 (2 read) (2 (2 (2 the) (2 issue)) (2 (2 more) (2 closely)))))) (2 !))))))
The inline-code tags need to be added through the triage meeting, not manually, removing for now.
(1 (2 (2 The) (2 (2 inline-code) (2 tags))) (1 (1 (1 (1 (2 need) (1 (2 to) (1 (1 (2 (2 be) (3 (2 added) (2 (2 through) (2 (2 the) (2 (2 triage) (2 meeting)))))) (2 ,)) (2 (1 not) (2 manually))))) (2 ,)) (2 (2 removing) (2 (2 for) (2 now)))) (2 .)))
cc me.
(2 (2 (2 cc) (3 me)) (2 .))
cc me.
(2 (2 (2 cc) (3 me)) (2 .))
cc me.
(2 (2 (2 cc) (3 me)) (2 .))
Annoying issues, but not hard blockers:.
(1 (2 Annoying) (2 (2 (2 (2 (2 (2 (2 issues) (2 ,)) (2 but)) (2 (1 not) (2 hard))) (2 blockers)) (2 :)) (2 .)))
*  ] [split Index into Index, IndexMut and IndexAssign
*  ] [make Vec\<T\> implement the slice methods
* x] [Constructing an iterator from a slice doesn't optimise completely
This is a significant performance improvement for any vectors that are grown, and will reduce heap allocation since zero-length vectors do not allocate and it does not have a header.
(0 (0 (1 (1 (1 (2 *) (1 (2 (2 -RSB-) (2 (2 -LSB-) (2 (2 split) (2 Index)))) (2 (2 into) (1 (2 Index) (2 (2 ,) (2 (2 (2 IndexMut) (2 and)) (2 IndexAssign))))))) (1 (2 *) (1 (2 (2 -RSB-) (2 -LSB-)) (1 (2 make) (1 (2 (2 Vec) (2 (2 \) (2 (2 <) (2 (2 T) (2 (2 \) (2 >)))))) (1 (2 (2 implement) (2 (2 the) (2 (2 slice) (2 methods)))) (0 (1 (2 (2 *) (2 x)) (1 (1 (2 (2 -RSB-) (2 -LSB-)) (2 (2 (2 Constructing) (2 (2 an) (2 iterator))) (2 (2 from) (2 (2 a) (2 slice))))) (1 (1 (2 does) (2 n't)) (3 (2 optimise) (2 completely))))) (1 (2 This) (1 (2 is) (1 (3 (2 a) (3 (2 significant) (2 (2 performance) (3 improvement)))) (1 (2 for) (1 (2 (2 any) (2 vectors)) (1 (2 that) (1 (2 (2 (2 (2 are) (2 grown)) (2 ,)) (2 and)) (1 (2 will) (1 (2 (2 reduce) (2 (2 heap) (2 allocation))) (1 (2 since) (1 (2 (2 zero-length) (2 vectors)) (2 (2 (2 do) (1 not)) (2 allocate)))))))))))))))))))) (2 and)) (1 (2 it) (1 (2 (2 does) (1 not)) (2 (2 have) (2 (2 a) (2 header)))))) (2 .))
I moved the priority tag here from the old issue, as this is the same core issue but without the distractions of past issues and discussions that are no longer relevant.
(1 (2 I) (1 (1 (3 (3 (3 (3 moved) (2 (2 the) (2 (2 priority) (2 tag)))) (2 (2 here) (2 (2 from) (2 (2 the) (2 (2 old) (2 issue)))))) (2 ,)) (1 (2 as) (1 (2 this) (1 (2 is) (1 (1 (2 (2 the) (2 (2 same) (2 (2 core) (2 issue)))) (2 (2 but) (2 (2 without) (2 (2 (2 the) (2 distractions)) (2 (2 of) (2 (2 past) (2 (2 (2 issues) (2 and)) (2 discussions)))))))) (2 (2 that) (2 (2 are) (2 (2 (1 no) (2 longer)) (2 relevant))))))))) (2 .)))
(also nominating)
Keeping this metabug around no longer makes sense, since the blockers didn't actually end up blocking it.
(1 (1 (2 (2 -LRB-) (2 (2 also) (2 (2 nominating) (2 -RRB-)))) (1 (1 (2 Keeping) (1 (2 (2 (2 this) (2 metabug)) (2 around)) (2 (1 no) (2 longer)))) (2 (2 makes) (2 sense)))) (1 (2 ,) (1 (2 (2 since) (2 (2 the) (2 blockers))) (1 (1 (2 (2 (2 did) (2 n't)) (2 actually)) (2 (2 (2 end) (2 up)) (2 (2 blocking) (2 it)))) (2 .)))))
@alexcrichton: The inline-code tag was already on this issue.
(1 (2 @alexcrichton) (1 (2 :) (1 (1 (2 (2 The) (2 (2 inline-code) (2 tag))) (2 (2 (2 was) (2 already)) (2 (2 on) (2 (2 this) (2 issue))))) (2 .))))
I just closed the old one instead of heavily editing it and making the comments there irrelevant.
(1 (2 I) (1 (2 just) (1 (1 (2 (2 closed) (2 (2 the) (2 (2 old) (2 one)))) (1 (2 instead) (2 (2 of) (1 (2 (2 (2 heavily) (2 (2 editing) (2 it))) (2 and)) (2 (2 making) (2 (2 (2 the) (2 comments)) (2 (2 there) (1 irrelevant)))))))) (2 .))))
If it's going to have to go through a meeting again, I'll just close this and edit the old one.
(1 (2 (2 If) (2 (2 it) (2 (2 's) (2 (2 going) (2 (2 to) (2 (2 have) (2 (2 to) (2 (2 (2 go) (2 (2 through) (2 (2 a) (2 meeting)))) (2 again))))))))) (1 (2 ,) (1 (2 I) (1 (1 (2 (2 'll) (2 just)) (1 (2 (2 (2 close) (2 this)) (2 and)) (1 (1 edit) (2 (2 the) (2 (2 old) (2 one)))))) (2 .)))))
(as per a FIXME)
Currently supported in format strings: bool, str, char, int/uint, bits, hex, octal, float, poly.
(1 (2 (2 -LRB-) (2 (2 (2 as) (2 (2 per) (2 (2 a) (2 FIXME)))) (2 -RRB-))) (1 (1 (2 Currently) (1 (2 supported) (1 (2 in) (1 (2 (2 (2 format) (2 strings)) (2 :)) (1 (2 bool) (1 (2 ,) (1 (2 str) (1 (2 ,) (1 (2 char) (1 (2 ,) (1 (2 int/uint) (2 (2 ,) (1 (2 bits) (2 (2 ,) (1 (2 hex) (2 (2 ,) (2 (2 octal) (2 (2 ,) (2 (2 float) (2 (2 ,) (2 poly))))))))))))))))))))) (2 .)))
What else?
(2 (2 (2 What) (2 else)) (2 ?))
Fixed in nightly (since some weeks ago, actually).
(2 (2 (2 (2 Fixed) (2 (2 in) (2 nightly))) (2 (2 -LRB-) (2 (2 (2 since) (2 (2 (2 (2 (2 some) (2 weeks)) (2 ago)) (2 ,)) (2 actually))) (2 -RRB-)))) (2 .))
Closing.
(2 (2 Closing) (2 .))
I believe I fixed this recently when removing inline-code, I'll add a test for this though.
(1 (2 I) (1 (1 (2 believe) (1 (2 I) (1 (2 (2 (2 fixed) (2 this)) (2 recently)) (1 (2 when) (1 (2 (2 removing) (2 inline-code)) (1 (2 ,) (1 (2 I) (2 (2 'll) (2 (2 (3 add) (2 (2 (2 a) (2 test)) (2 (2 for) (2 this)))) (2 though)))))))))) (2 .)))
<code>&#96;&#96;&#96;should_panic</code>, <code>&#96;&#96;&#96;should_fail</code>, and <code>&#96;&#96;&#96;rust,should_fail</code> all work fine.
(0 (0 (0 (1 (1 (1 (1 (1 (1 (2 (2 <code>) (2 &#96;)) (2 (2 &#96;) (2 (2 &#96;) (2 (2 should_panic) (2 </code>))))) (2 ,)) (1 (2 (2 <code>) (2 &#96;)) (2 (2 &#96;) (2 (2 &#96;) (2 (2 should_fail) (2 </code>)))))) (2 ,)) (2 and)) (2 <code>)) (2 (2 (2 &#96;) (2 &#96;)) (2 (2 &#96;) (2 rust)))) (2 ,)) (3 (3 (2 should_fail) (3 (2 </code>) (3 (2 all) (2 (2 work) (3 fine))))) (2 .)))
Test case:  Run rustdoc as inline-code, where test.rs contains
block-code.
(1 (1 (2 (2 (2 Test) (2 case)) (2 :)) (1 (2 Run) (1 (2 rustdoc) (1 (2 as) (1 (2 (2 inline-code) (2 ,)) (2 (2 where) (2 (2 test.rs) (2 (2 contains) (2 block-code))))))))) (2 .))
rust,should_panic</code>.
(1 (2 (2 (2 rust) (2 ,)) (2 (2 should_panic) (2 </code>))) (2 .))
///
/// block-code.
(1 (2 (2 /) (2 /)) (1 (2 /) (1 (2 (2 /) (2 /)) (2 (2 /) (2 (2 block-code) (2 .))))))
///
/// block-code.
(1 (2 (2 /) (2 /)) (1 (2 /) (1 (2 (2 /) (2 /)) (2 (2 /) (2 (2 block-code) (2 .))))))
///
/// block-code.
(1 (2 (2 /) (2 /)) (1 (2 /) (1 (2 (2 /) (2 /)) (2 (2 /) (2 (2 block-code) (2 .))))))
///
/// block-code.
(1 (2 (2 /) (2 /)) (1 (2 /) (1 (2 (2 /) (2 /)) (2 (2 /) (2 (2 block-code) (2 .))))))
fn main() {
}
```
I would be happy to work with anyone who wants to work on this issue.
(3 (3 (1 (2 (2 fn) (2 (2 main) (2 (2 -LRB-) (2 (2 (2 -RRB-) (2 -LCB-)) (2 -RCB-))))) (2 ``)) (3 (2 `) (3 (2 I) (3 (2 would) (3 (2 be) (3 (4 happy) (2 (2 to) (2 (2 work) (2 (2 with) (2 (2 anyone) (2 (2 who) (2 (3 wants) (2 (2 to) (2 (2 work) (2 (2 on) (2 (2 this) (2 issue))))))))))))))))) (2 .))
Hey @adrianbrink !
(2 (2 Hey) (2 (2 @adrianbrink) (2 !)))
Thanks :)
That's the directory for all of the long-form docs.
(1 (2 Thanks) (1 (2 (2 :-RRB-) (2 (2 That) (2 (2 's) (2 (2 (2 the) (2 directory)) (2 (2 for) (2 (2 all) (2 (2 of) (2 (2 the) (2 (2 long-form) (2 docs)))))))))) (2 .)))
The API documentation is in the source.
(2 (2 (2 The) (2 (2 API) (2 documentation))) (2 (2 (2 is) (2 (2 in) (2 (2 the) (2 source)))) (2 .)))
With this specific bit of docs, it's here: URL.
(3 (2 (2 With) (2 (2 (2 this) (2 (2 specific) (2 bit))) (2 (2 of) (2 docs)))) (2 (2 ,) (2 (2 it) (2 (2 (2 (2 (2 's) (2 here)) (2 :)) (2 URL)) (2 .)))))
So modifying these lines is where you need to go!
(1 (2 So) (1 (2 (2 modifying) (2 (2 these) (2 lines))) (2 (2 (2 is) (2 (2 where) (2 (2 you) (2 (2 need) (2 (2 to) (2 go)))))) (2 !))))
Feel free to take a shot at it and just open a PR; we can workshop specific wording if you'd like in the PR itself.
(1 (1 (2 (2 (2 Feel) (2 (3 free) (2 (2 to) (2 (2 (2 (2 (2 take) (2 (2 a) (2 shot))) (2 (2 at) (2 it))) (2 and)) (2 (2 just) (2 (3 open) (2 (2 a) (2 PR)))))))) (2 ;)) (2 (2 we) (2 (2 can) (2 (2 (2 workshop) (2 (2 specific) (2 wording))) (2 (2 if) (2 (2 you) (2 (2 'd) (2 (2 (2 like) (2 (2 in) (2 (2 the) (2 PR)))) (2 itself))))))))) (2 .))
:smile: .
(3 (2 :) (3 (3 (4 smile) (2 :)) (2 .)))
I was basically just attempting with words to describe the trait impls on inline-code, but as @aturon was also confused by the wording I guess it *definitely* didn't get the point across!
(1 (1 (1 (1 (1 (2 I) (1 (2 (2 was) (2 basically)) (1 (2 just) (1 (2 (2 attempting) (2 (2 with) (2 words))) (2 (2 to) (1 (2 (2 describe) (2 (2 the) (2 (2 trait) (2 impls)))) (2 (2 on) (2 inline-code)))))))) (2 ,)) (2 but)) (1 (1 (2 as) (1 (2 @aturon) (1 (2 (2 was) (2 also)) (1 (1 confused) (1 (2 by) (1 (2 (2 the) (2 wording)) (1 (2 I) (1 (2 guess) (2 (2 it) (2 (2 (2 *) (3 definitely)) (2 *))))))))))) (2 (2 (2 did) (2 n't)) (2 (2 (2 get) (2 (2 the) (2 point))) (2 across))))) (2 !))
@steveklabnik I would be glad to help out :-) What's the best way to start on this?
(1 (3 (2 @steveklabnik) (3 (2 I) (3 (2 would) (3 (2 be) (3 (2 glad) (3 (2 to) (3 (2 (2 help) (1 out)) (3 (2 :--RRB-) (3 (2 What) (3 (2 's) (3 (3 (2 the) (3 (4 best) (2 way))) (2 (2 to) (2 (2 start) (2 (2 on) (2 this))))))))))))))) (2 ?))
I am trying to find the source for the docs and I am ending up here, but somehow I think I am wrong.
(1 (1 (1 (1 (1 (2 (2 (2 I) (1 (2 am) (2 (2 trying) (2 (2 to) (2 (2 find) (2 (2 (2 the) (2 source)) (2 (2 for) (2 (2 the) (2 docs))))))))) (2 and)) (2 (2 I) (2 (2 am) (2 (2 (2 ending) (2 up)) (2 here))))) (2 ,)) (2 but)) (1 (2 somehow) (1 (2 I) (1 (2 think) (1 (2 I) (1 (2 am) (1 wrong))))))) (2 .))
This line is not clear:.
(1 (2 (2 This) (2 line)) (2 (2 (1 (1 (2 is) (1 not)) (2 clear)) (2 :)) (2 .)))
I don't know if BuilderHasherDefault implements BuilderHasher and Default for Hasher types, or if it implements BuilderHasher for Hasher types that themselves implement Default.
(1 (2 I) (1 (1 (2 (2 do) (2 n't)) (1 (2 know) (1 (2 (2 (2 (2 if) (2 (2 BuilderHasherDefault) (1 (2 implements) (2 (2 (2 (2 BuilderHasher) (2 and)) (2 Default)) (2 (2 for) (2 (2 Hasher) (2 types))))))) (2 ,)) (2 or)) (1 (2 if) (1 (2 it) (1 (2 (2 implements) (2 (2 BuilderHasher) (2 (2 for) (2 (2 Hasher) (2 types))))) (2 (2 that) (2 (2 themselves) (2 (2 implement) (2 Default)))))))))) (2 .)))
@alexcrichton any thoughts on making the semantics here more clear?
(1 (2 (2 (2 @alexcrichton) (2 (2 any) (2 thoughts))) (2 (2 on) (2 (2 making) (2 (2 (2 the) (2 semantics)) (2 (2 here) (2 (2 more) (2 clear))))))) (2 ?))
I'm not mega familiar with the Hash stuff.
(1 (2 I) (1 (1 (2 (2 'm) (1 not)) (2 (2 (2 mega) (2 familiar)) (2 (2 with) (2 (2 the) (2 (2 Hash) (2 stuff)))))) (2 .)))
This is rarely on purpose:.
(2 (2 This) (2 (2 (2 (2 (2 is) (2 rarely)) (2 (2 on) (3 purpose))) (2 :)) (2 .)))
This already produces an inline-code warning for the first inline-code.
(1 (2 This) (2 (2 already) (1 (1 (2 produces) (1 (2 (2 an) (2 (2 inline-code) (2 warning))) (2 (2 for) (2 (2 the) (2 (2 first) (2 inline-code)))))) (2 .))))
That points out the problem quite directly, doesn't it?
(1 (2 (2 That) (2 (2 (2 points) (2 (1 out) (2 (2 the) (1 problem)))) (2 (2 quite) (2 directly)))) (1 (2 ,) (1 (1 (1 (2 does) (2 n't)) (2 it)) (2 ?))))
Yes.
(2 (2 Yes) (2 .))
This has been sitting here for awhile now, so I'm going to close this in favor of the associated RFC.
(1 (2 This) (1 (1 (2 has) (1 (2 been) (1 (2 sitting) (2 (2 here) (3 (2 for) (3 (2 (2 (1 awhile) (2 now)) (2 ,)) (3 (2 so) (2 (2 I) (2 (2 'm) (2 (2 going) (2 (2 to) (2 (2 close) (2 (2 this) (2 (2 in) (2 (2 favor) (2 (2 of) (2 (2 the) (2 (2 associated) (2 RFC))))))))))))))))))) (2 .)))
The inline-code/inline-code terminology is not obvious to anyone who hasn't
already seen it in another language like Haskell, and we already got rid
of inline-code (the common pair for inline-code).
(1 (1 (1 (1 (1 (2 (2 The) (2 (2 inline-code/inline-code) (2 terminology))) (1 (1 (2 is) (1 not)) (1 (1 obvious) (1 (2 to) (2 (2 anyone) (1 (2 who) (1 (2 (2 (2 has) (2 n't)) (2 already)) (1 (2 (2 seen) (2 it)) (2 (2 in) (1 (2 (2 another) (2 language)) (2 (2 like) (2 Haskell)))))))))))) (2 ,)) (2 and)) (2 (2 we) (2 (2 already) (2 (2 (2 got) (2 rid)) (2 (2 of) (2 (2 inline-code) (2 (2 -LRB-) (2 (2 (2 (2 the) (2 (2 common) (2 pair))) (2 (2 for) (2 inline-code))) (2 -RRB-))))))))) (2 .))
Instead of merely renaming these functions, turn them into separate
functions
as these functions are often used in a context where the first/last
element wants to be inspected and it's a bit more ergonomic this way.
(1 (2 (2 Instead) (2 (2 of) (2 (2 merely) (2 (2 renaming) (2 (2 these) (2 functions)))))) (1 (2 ,) (1 (1 (2 (2 (2 turn) (2 them)) (2 (2 into) (2 (2 (2 separate) (2 functions)) (2 (2 as) (2 (2 (2 these) (2 functions)) (2 (2 (2 are) (2 often)) (2 (2 used) (2 (2 in) (2 (2 a) (2 context)))))))))) (1 (2 where) (1 (2 (2 (2 (2 the) (2 (2 first/last) (2 element))) (2 (3 wants) (2 (2 to) (2 (2 be) (2 inspected))))) (2 and)) (2 (2 it) (2 (2 's) (2 (2 (2 (2 (2 a) (2 bit)) (2 more)) (2 ergonomic)) (2 (2 this) (2 way)))))))) (2 .))))
Fixes #24141.
(2 (2 (2 Fixes) (2 (2 #) (2 24141))) (2 .))
[breaking-change]
I prefer the first/tail naming.
(1 (2 (2 -LSB-) (2 breaking-change)) (3 (2 (2 -RSB-) (2 (2 I) (2 (2 prefer) (2 (2 the) (2 (2 first/tail) (2 naming)))))) (2 .)))
It makes sense from my point of view and I don't really like yours (I speak about functions naming) ^^'.
(1 (1 (2 (2 (2 It) (2 (2 (2 makes) (2 sense)) (2 (2 from) (2 (2 (2 my) (2 point)) (2 (2 of) (2 view)))))) (2 and)) (1 (2 I) (1 (2 (2 (2 (2 (2 do) (2 n't)) (2 really)) (2 (2 like) (2 yours))) (2 (2 -LRB-) (2 (2 (2 I) (2 (2 speak) (2 (2 about) (2 (2 functions) (2 naming))))) (2 -RRB-)))) (2 (2 ^) (2 (2 ^) (2 ')))))) (2 .))
I never developped in Haskell but inline-code doesn't "hurt" my feelings and does what I expect it to do.
(1 (2 I) (1 (2 never) (1 (1 (2 (2 (2 developped) (2 (2 in) (2 Haskell))) (2 but)) (1 (2 inline-code) (1 (1 (1 (1 (2 does) (2 n't)) (2 (2 ``) (2 (2 (1 hurt) (2 '')) (2 (2 my) (2 feelings))))) (2 and)) (2 (2 does) (2 (2 what) (2 (2 I) (2 (2 expect) (2 (2 it) (2 (2 to) (2 do)))))))))) (2 .))))
Why changing it then ?
(1 (2 Why) (2 (2 (2 (2 changing) (2 it)) (2 then)) (2 ?)))
After, I guess it's a personal taste...
Hmm, I have mixed reactions.
(1 (1 (2 (2 After) (2 ,)) (2 (2 I) (2 (2 guess) (3 (2 it) (3 (2 's) (3 (2 (2 (2 a) (2 (3 personal) (2 taste))) (2 ...)) (2 Hmm))))))) (1 (2 ,) (1 (2 I) (2 (2 (2 have) (2 (2 mixed) (2 reactions))) (2 .)))))
I admire your attempt to find something categorically *better* than inline-code/inline-code, and this may be in the right direction.
(3 (3 (1 (1 (1 (2 I) (1 (3 admire) (1 (2 (2 (2 your) (2 attempt)) (2 (2 to) (2 (2 (2 find) (2 something)) (2 categorically)))) (2 (2 *) (2 (4 better) (2 (2 *) (2 (2 than) (2 inline-code/inline-code)))))))) (2 ,)) (2 and)) (3 (2 this) (3 (2 may) (3 (2 be) (3 (2 in) (3 (2 the) (3 (3 right) (2 direction)))))))) (2 .))
*And* I really quite strongly dislike the name inline-code, so I'm inclined to like anything that changes that (inline-code, anybody?)
(1 (2 *) (1 (3 (3 (3 (2 And) (1 (3 (2 *) (3 (2 I) (3 (2 really) (3 (3 (2 quite) (3 strongly)) (2 (2 dislike) (2 (2 the) (2 name))))))) (2 inline-code))) (2 ,)) (2 so)) (1 (2 I) (2 (2 'm) (1 (2 inclined) (2 (2 to) (2 (2 like) (2 (2 anything) (2 (2 that) (2 (2 changes) (2 (2 that) (2 (2 -LRB-) (2 (1 (2 (2 (2 inline-code) (2 ,)) (2 anybody)) (2 ?)) (2 -RRB-))))))))))))))
.
(2 .)
*But* I do have some concerns:.
(1 (2 (1 (2 *) (2 (2 (2 But) (2 (2 (2 *) (2 (2 I) (2 do))) (2 (2 have) (2 some)))) (2 concerns))) (2 :)) (2 .))
1.
(2 (2 1) (2 .))
The names inline-code and inline-code seem misleading in that they do not mutate the underlying data.
(1 (2 (2 (2 The) (2 names)) (2 (2 (2 inline-code) (2 and)) (2 inline-code))) (1 (1 (2 seem) (1 (1 misleading) (2 (2 in) (2 (2 that) (2 (2 they) (2 (2 (2 do) (1 not)) (2 (2 mutate) (2 (2 the) (2 (2 underlying) (2 data)))))))))) (2 .)))
I'd prefer a name like inline-code, though inline-code currently returns two slices.
(1 (2 I) (2 (2 (2 'd) (2 (2 (2 (2 (2 prefer) (2 (2 a) (2 name))) (2 (2 like) (2 inline-code))) (2 ,)) (2 (2 though) (2 (2 inline-code) (2 (2 currently) (3 (2 returns) (2 (2 two) (2 slices)))))))) (2 .)))
Perhaps inline-code or inline-code or something like that.
(2 (2 (2 (2 (2 Perhaps) (2 inline-code)) (2 or)) (2 (2 (2 inline-code) (2 or)) (2 something))) (2 (2 (2 like) (2 that)) (2 .)))
2.
(2 (2 2) (2 .))
The change to return a tuple is nice when it works, but inline-code is quite a mouthful (as compared to inline-code).
(2 (2 (3 (3 (3 (2 (2 The) (1 (2 change) (2 (2 to) (3 (2 return) (2 (2 a) (2 tuple)))))) (3 (3 (2 is) (3 nice)) (2 (2 when) (3 (2 it) (2 works))))) (2 ,)) (2 but)) (1 (2 inline-code) (1 (2 is) (2 (2 (2 quite) (2 (2 a) (2 mouthful))) (2 (2 -LRB-) (2 (2 (2 as) (2 (2 compared) (2 (2 to) (2 inline-code)))) (2 -RRB-))))))) (2 .))
On the other hand, it's probably mostly the inline-code, which is the whole point of this PR.
(1 (2 (2 On) (2 (2 the) (2 (2 other) (2 hand)))) (1 (2 ,) (1 (2 it) (1 (1 (2 (2 's) (2 probably)) (1 (2 (2 (2 mostly) (2 (2 the) (2 inline-code))) (2 ,)) (1 (2 which) (1 (2 is) (1 (2 (2 the) (2 (2 whole) (2 point))) (2 (2 of) (2 (2 this) (2 PR)))))))) (2 .)))))
3.
(2 (2 3) (2 .))
Note that we made a deliberate decision to have many slice methods continue to panic on invalid indices precisely because when we attempted to convert them all to return inline-code, it seemed by and large to just make code messier.
(1 (2 (2 Note) (2 (2 that) (2 (2 we) (1 (2 (2 made) (2 (2 a) (2 (2 deliberate) (2 decision)))) (2 (2 to) (1 (2 have) (1 (2 (2 many) (2 (2 slice) (2 methods))) (1 (2 (2 continue) (2 (2 to) (2 (2 (2 panic) (2 (2 on) (2 (2 invalid) (2 indices)))) (3 precisely)))) (2 (2 because) (2 (2 (2 when) (2 (2 we) (1 (2 attempted) (2 (2 to) (1 (2 convert) (2 (2 them) (2 (2 all) (2 (2 to) (2 (2 return) (2 inline-code)))))))))) (2 (2 ,) (2 (2 it) (2 (2 seemed) (2 (2 (2 (2 by) (2 and)) (2 large)) (2 (2 to) (2 (2 just) (2 (2 make) (2 (2 code) (2 messier))))))))))))))))))) (2 .))
(Also, in collections, we tend to use the names "front" and "back", so maybe we should stick to that, rather than "first/last".
(1 (2 -LRB-) (1 (2 Also) (1 (2 ,) (1 (2 (2 in) (2 collections)) (1 (2 ,) (1 (2 we) (1 (1 (2 (2 (2 (2 (2 tend) (3 (2 to) (3 (2 use) (3 (2 the) (2 (2 names) (2 (2 ``) (2 (2 front) (2 (2 '') (2 (2 and) (2 (2 ``) (2 (2 back) (2 '')))))))))))) (2 ,)) (2 so)) (2 maybe)) (2 (2 we) (2 (2 should) (2 (2 stick) (2 (2 to) (2 (2 (2 (2 that) (2 ,)) (2 (2 rather) (2 than))) (2 (2 ``) (2 (2 first/last) (2 ''))))))))) (2 .))))))))
Or does that seem specific to inline-code?)
(2 (2 Or) (2 (2 (2 does) (2 that)) (2 (2 (2 (2 seem) (2 (2 specific) (2 (2 to) (2 inline-code)))) (2 ?)) (2 -RRB-))))
cc @alexcrichton @aturon .
(1 (2 (2 cc) (2 @alexcrichton)) (2 (2 @aturon) (2 .)))
r?
(2 (2 r) (2 ?))
@Gankro
(rust_highfive has picked a reviewer for you, use r?
(1 (2 (2 @Gankro) (2 (2 -LRB-) (2 (2 rust_highfive) (2 (2 has) (2 (2 picked) (2 (2 (2 a) (2 reviewer)) (2 (2 for) (2 you)))))))) (2 (2 ,) (2 (2 (2 use) (2 r)) (2 ?))))
to override)
Having said that, it seems to me that this is an alternative to #24172.
(1 (2 (2 to) (2 (2 (2 (2 override) (2 -RRB-)) (2 (2 Having) (2 (2 said) (2 that)))) (2 ,))) (1 (2 it) (1 (2 (2 (2 seems) (2 (2 to) (3 me))) (2 (2 that) (2 (2 this) (2 (2 is) (2 (2 (2 an) (2 alternative)) (2 (2 to) (2 (2 #) (2 24172)))))))) (2 .))))
I figure we might decide to take this PR, #24172, or neither.
(1 (2 I) (1 (2 (2 figure) (1 (2 we) (2 (2 might) (1 (2 decide) (1 (2 to) (1 (2 take) (1 (1 (1 (2 (2 (2 (2 this) (2 PR)) (2 ,)) (2 (2 #) (2 24172))) (2 ,)) (2 or)) (2 neither)))))))) (2 .)))
But let's move the conversation to #24141 so it can be consolidated.
(3 (2 But) (3 (2 (2 let) (2 's)) (3 (3 (2 (2 (2 move) (2 (2 the) (2 conversation))) (2 (2 to) (2 (2 #) (2 24141)))) (2 (2 so) (2 (2 it) (2 (2 can) (2 (2 be) (2 consolidated)))))) (2 .))))
The inline-code/inline-code terminology is not obvious to anyone who hasn't
already seen it in another language like Haskell, and we already got rid
of inline-code (the common pair for inline-code).
(1 (1 (1 (1 (1 (2 (2 The) (2 (2 inline-code/inline-code) (2 terminology))) (1 (1 (2 is) (1 not)) (1 (1 obvious) (1 (2 to) (2 (2 anyone) (1 (2 who) (1 (2 (2 (2 has) (2 n't)) (2 already)) (1 (2 (2 seen) (2 it)) (2 (2 in) (1 (2 (2 another) (2 language)) (2 (2 like) (2 Haskell)))))))))))) (2 ,)) (2 and)) (2 (2 we) (2 (2 already) (2 (2 (2 got) (2 rid)) (2 (2 of) (2 (2 inline-code) (2 (2 -LRB-) (2 (2 (2 (2 the) (2 (2 common) (2 pair))) (2 (2 for) (2 inline-code))) (2 -RRB-))))))))) (2 .))
Instead of merely renaming these functions, turn them into separate
functions
as these functions are often used in a context where the first/last
element wants to be inspected and it's a bit more ergonomic this way.
(1 (2 (2 Instead) (2 (2 of) (2 (2 merely) (2 (2 renaming) (2 (2 these) (2 functions)))))) (1 (2 ,) (1 (1 (2 (2 (2 turn) (2 them)) (2 (2 into) (2 (2 (2 separate) (2 functions)) (2 (2 as) (2 (2 (2 these) (2 functions)) (2 (2 (2 are) (2 often)) (2 (2 used) (2 (2 in) (2 (2 a) (2 context)))))))))) (1 (2 where) (1 (2 (2 (2 (2 the) (2 (2 first/last) (2 element))) (2 (3 wants) (2 (2 to) (2 (2 be) (2 inspected))))) (2 and)) (2 (2 it) (2 (2 's) (2 (2 (2 (2 (2 a) (2 bit)) (2 more)) (2 ergonomic)) (2 (2 this) (2 way)))))))) (2 .))))
Fixes #24141.
(2 (2 (2 Fixes) (2 (2 #) (2 24141))) (2 .))
[breaking-change]
:umbrella: The latest upstream changes (presumably #23998) made this pull request unmergeable.
(1 (1 (2 (2 (2 -LSB-) (2 (2 breaking-change) (2 -RSB-))) (2 :)) (1 (2 (2 umbrella) (2 :)) (1 (2 (2 (2 The) (2 (2 latest) (2 (2 upstream) (2 changes)))) (2 (2 -LRB-) (2 (2 presumably) (2 (2 (2 #) (2 23998)) (2 -RRB-))))) (2 (2 made) (2 (2 this) (2 (2 pull) (2 (2 request) (2 unmergeable)))))))) (2 .))
Please resolve the merge conflicts.
(2 (2 Please) (2 (2 (2 resolve) (2 (2 the) (2 (2 merge) (3 conflicts)))) (2 .)))
Taking this!
(2 (2 (2 Taking) (2 this)) (2 !))
From: src/test/compile-fail/E0116.rs
Error E0116 needs a span_label, an updated error text and a note, updating from:.
(1 (2 (2 (1 From) (2 :)) (2 src/test/compile-fail)) (1 (2 /) (1 (1 (2 (2 E0116.rs) (2 (2 Error) (2 E0116))) (1 (1 (2 needs) (1 (1 (1 (2 (2 (2 a) (2 span_label)) (2 ,)) (1 (2 an) (2 (2 updated) (1 (1 error) (2 text))))) (2 and)) (3 (2 (2 (2 a) (2 note)) (2 ,)) (2 (2 updating) (2 from))))) (2 :))) (2 .))))
To:.
(2 (2 (2 To) (2 :)) (2 .))
@bors: r+ 8600fefd9c71bf30ad3e23ffc1ef2b7cabe990b2.
(1 (2 (2 (2 @bors) (2 :)) (2 (2 r) (2 (2 +) (2 8600fefd9c71bf30ad3e23ffc1ef2b7cabe990b2)))) (2 .))
Thanks for the pull request, and welcome!
(3 (2 (2 Thanks) (2 (2 for) (2 (2 the) (2 (2 pull) (2 request))))) (3 (2 ,) (3 (2 and) (3 (2 welcome) (2 !)))))
The Rust team is excited to review your changes, and you should hear from @alexcrichton (or someone else) soon.
(3 (3 (3 (3 (3 (2 (2 The) (2 (2 Rust) (3 team))) (3 (2 is) (3 (3 excited) (2 (2 to) (2 (2 review) (2 (2 your) (2 changes))))))) (2 ,)) (2 and)) (2 (2 you) (2 (2 should) (2 (2 (2 hear) (2 (2 from) (2 (2 @alexcrichton) (2 (2 -LRB-) (2 (2 or) (2 (2 (2 someone) (2 else)) (2 -RRB-))))))) (2 soon))))) (2 .))
If any changes to this PR are deemed necessary, please add them as extra commits.
(3 (2 (2 If) (2 (1 (2 (2 any) (2 changes)) (2 (2 to) (2 (2 this) (2 PR)))) (2 (2 are) (2 (2 deemed) (2 necessary))))) (3 (2 ,) (3 (3 (2 please) (2 (3 add) (2 (2 them) (2 (2 as) (2 extra))))) (2 (2 commits) (2 .)))))
This ensures that the reviewer can see what has changed since they last reviewed the code.
(3 (2 This) (3 (3 (3 ensures) (2 (2 that) (2 (2 (2 the) (2 reviewer)) (2 (2 can) (2 (2 see) (2 (2 what) (2 (2 has) (2 (2 changed) (2 (2 since) (2 (2 they) (2 (2 last) (2 (2 reviewed) (2 (2 the) (2 code)))))))))))))) (2 .)))
The way Github handles out-of-date commits, this should also make it reasonably obvious what issues have or haven't been addressed.
(1 (2 (2 (2 The) (2 (2 way) (2 Github))) (2 (2 handles) (2 (2 out-of-date) (2 commits)))) (2 (2 ,) (1 (2 this) (2 (2 (2 (2 should) (2 also)) (2 (2 make) (2 (2 it) (2 (2 (2 reasonably) (1 obvious)) (2 (2 what) (1 (2 issues) (2 (2 (2 have) (2 or)) (2 (2 (2 have) (2 n't)) (2 (2 been) (2 addressed)))))))))) (2 .)))))
Large or tricky changes may require several passes of review and changes.
(2 (2 (2 (2 (2 Large) (2 or)) (2 tricky)) (2 changes)) (2 (2 (2 may) (2 (2 require) (2 (2 (2 several) (2 passes)) (2 (2 of) (2 (2 (2 review) (2 and)) (2 changes)))))) (2 .)))
Please see the contribution instructions for more information.
(2 (2 Please) (3 (3 (3 (2 see) (3 (2 the) (3 (2 contribution) (2 instructions)))) (2 (2 for) (2 (2 more) (2 information)))) (2 .)))
With this change the build on FreeBSD is almost working again.
(2 (2 (2 With) (2 (2 this) (2 (2 change) (2 (2 the) (2 (2 build) (2 (2 on) (2 FreeBSD))))))) (2 (2 (2 (2 is) (2 almost)) (2 (2 working) (2 again))) (2 .)))
With this change the build on FreeBSD is almost working again.
(2 (2 (2 With) (2 (2 this) (2 (2 change) (2 (2 the) (2 (2 build) (2 (2 on) (2 FreeBSD))))))) (2 (2 (2 (2 is) (2 almost)) (2 (2 working) (2 again))) (2 .)))
I believe this is a dupe of #34423, so already fixed in master just waiting on nightlies...
cc @ollie27 .
(1 (1 (1 (1 (1 (2 I) (2 (2 believe) (1 (2 this) (2 (2 is) (2 (2 (2 a) (1 dupe)) (2 (2 of) (2 (2 #) (2 34423)))))))) (2 ,)) (2 so)) (1 (1 (2 (2 already) (1 (2 fixed) (3 (2 in) (3 (2 master) (2 (2 just) (2 (2 waiting) (2 (2 on) (2 nightlies)))))))) (2 ...)) (2 (2 cc) (2 @ollie27)))) (2 .))
Here's the stack trace on Linux:.
(1 (2 Here) (2 (2 (2 (2 's) (2 (2 (2 the) (2 (2 stack) (2 trace))) (2 (2 on) (2 Linux)))) (2 :)) (2 .)))
Ah excellent, thanks!
(3 (3 (2 Ah) (4 excellent)) (3 (2 ,) (3 (3 thanks) (2 !))))
Possible dup of #34222, but that issue is about invalid code, which I don't think is the case here.
(1 (1 (2 (2 Possible) (2 dup)) (1 (2 (2 of) (2 (2 #) (2 34222))) (1 (2 ,) (1 (2 but) (2 (2 that) (1 (2 issue) (2 (2 (2 (2 is) (2 (2 (2 about) (2 invalid)) (2 code))) (2 ,)) (2 (2 which) (2 (2 I) (2 (2 (2 do) (2 n't)) (2 think))))))))))) (2 (2 (2 (2 is) (2 (2 the) (2 case))) (2 here)) (2 .)))
Everything builds cleanly.
(3 (2 Everything) (3 (2 (2 builds) (2 cleanly)) (2 .)))
Then running cargo doc:.
(2 (2 Then) (2 (2 (2 running) (2 cargo)) (2 (2 (2 doc) (2 :)) (2 .))))
@bors: r+ 8bfb93c.
(1 (2 (2 (2 @bors) (2 :)) (2 (2 r) (2 (2 +) (2 8bfb93c)))) (2 .))
Forgot to add a few directories to inline-code so inline-code can
continue to work.
(3 (2 (2 Forgot) (2 (2 to) (2 (3 add) (2 (2 (2 a) (2 (2 few) (2 directories))) (2 (2 to) (2 (2 inline-code) (2 (2 so) (2 inline-code)))))))) (3 (3 (2 can) (2 (2 continue) (2 (2 to) (2 work)))) (2 .)))
Closes #31801.
(2 (2 (2 Closes) (2 (2 #) (2 31801))) (2 .))
r?
(2 (2 r) (2 ?))
@nikomatsakis
(rust_highfive has picked a reviewer for you, use r?
(1 (2 (2 @nikomatsakis) (2 (2 -LRB-) (2 (2 rust_highfive) (2 (2 has) (2 (2 picked) (2 (2 (2 a) (2 reviewer)) (2 (2 for) (2 you)))))))) (2 (2 ,) (2 (2 (2 use) (2 r)) (2 ?))))
to override)
Forgot to add a few directories to inline-code so inline-code can
continue to work.
(1 (1 (2 to) (1 (2 (2 (2 override) (2 -RRB-)) (2 Forgot)) (2 (2 to) (2 (3 add) (2 (2 (2 a) (2 (2 few) (2 directories))) (2 (2 to) (2 (2 inline-code) (2 (2 so) (2 inline-code))))))))) (3 (3 (2 can) (2 (2 continue) (2 (2 to) (2 work)))) (2 .)))
Closes #31801.
(2 (2 (2 Closes) (2 (2 #) (2 31801))) (2 .))
@bors: retry.
(2 (2 (2 (2 @bors) (2 :)) (2 retry)) (2 .))
:broken_heart: Test failed - auto-win-gnu-64-opt.
(1 (2 :) (1 (1 (1 (2 (2 broken_heart) (2 :)) (1 (2 Test) (1 failed))) (2 -)) (2 (2 auto-win-gnu-64-opt) (2 .))))
:sunny: Test successful - auto-linux-32-nopt-t, auto-linux-32-opt, auto-linux-64-debug-opt, auto-linux-64-nopt-t, auto-linux-64-opt, auto-linux-64-x-android-t, auto-linux-cross-opt, auto-linux-musl-64-opt, auto-mac-32-opt, auto-mac-64-nopt-t, auto-mac-64-opt, auto-mac-ios-opt, auto-win-gnu-32-nopt-t, auto-win-gnu-32-opt, auto-win-gnu-64-nopt-t, auto-win-gnu-64-opt, auto-win-msvc-32-opt, auto-win-msvc-64-opt.
(2 (2 :) (2 (1 (3 (2 sunny) (3 (2 :) (3 (3 (2 Test) (4 successful)) (2 -)))) (1 (2 auto-linux-32-nopt-t) (1 (2 ,) (1 (2 auto-linux-32-opt) (1 (2 ,) (1 (2 auto-linux-64-debug-opt) (1 (2 ,) (1 (2 auto-linux-64-nopt-t) (1 (2 ,) (1 (2 auto-linux-64-opt) (1 (2 ,) (1 (2 auto-linux-64-x-android-t) (1 (2 ,) (1 (2 auto-linux-cross-opt) (1 (2 ,) (1 (2 auto-linux-musl-64-opt) (1 (2 ,) (1 (2 auto-mac-32-opt) (1 (2 ,) (1 (2 auto-mac-64-nopt-t) (1 (2 ,) (1 (2 auto-mac-64-opt) (1 (2 ,) (1 (2 auto-mac-ios-opt) (1 (2 ,) (1 (2 auto-win-gnu-32-nopt-t) (1 (2 ,) (1 (2 auto-win-gnu-32-opt) (1 (2 ,) (1 (2 auto-win-gnu-64-nopt-t) (2 (2 ,) (1 (2 auto-win-gnu-64-opt) (2 (2 ,) (2 (2 auto-win-msvc-32-opt) (2 (2 ,) (2 auto-win-msvc-64-opt)))))))))))))))))))))))))))))))))))) (2 .)))
:hourglass: Testing commit 8bfb93c with merge 3d422a0...
:hourglass: Testing commit 8bfb93c with merge 0f62d21...
See #13476.
(1 (2 :) (1 (1 (1 (1 (1 (1 (2 (2 hourglass) (2 :)) (1 (2 (2 Testing) (2 (2 commit) (2 8bfb93c))) (2 (2 (2 with) (2 (2 merge) (2 3d422a0))) (2 ...)))) (2 :)) (1 (2 (2 hourglass) (2 :)) (1 (2 Testing) (2 (2 (2 commit) (2 8bfb93c)) (2 (2 with) (2 (2 merge) (2 0f62d21))))))) (2 ...)) (3 (2 See) (2 (2 #) (2 13476)))) (2 .)))
See #13476.
(3 (3 (2 See) (2 (2 #) (2 13476))) (2 .))
Applying this patch I receive many many errors when compiling cargo at precisely the locations I would expect to see the errors, thanks @nikomatsakis!
(1 (1 (2 Applying) (1 (2 (2 this) (2 patch)) (2 (2 I) (2 (2 (3 receive) (2 (2 many) (2 (2 many) (1 errors)))) (2 (2 when) (2 (2 (2 compiling) (2 cargo)) (2 (2 at) (3 (2 (3 precisely) (2 (2 the) (2 locations))) (2 (2 I) (2 (2 would) (2 (2 expect) (2 (2 to) (2 (2 see) (2 (2 the) (1 errors))))))))))))))) (3 (2 ,) (3 (3 thanks) (2 (2 @nikomatsakis) (2 !)))))
Teach variance checker about the lifetime bounds that appear in trait object types.
(1 (2 (2 (2 Teach) (2 (2 variance) (2 checker))) (2 (2 about) (2 (2 the) (2 lifetime)))) (2 (2 (2 bounds) (2 (2 that) (2 (2 appear) (2 (2 in) (2 (2 trait) (2 (2 object) (2 types))))))) (2 .)))
[breaking-change] This patch fixes a hole in the type system which resulted in lifetime parameters that were only used in trait objects not being checked.
(1 (1 (2 (2 -LSB-) (2 (2 breaking-change) (2 -RSB-))) (2 (2 This) (2 patch))) (1 (1 (2 fixes) (1 (1 (2 (2 a) (2 hole)) (2 (2 in) (2 (2 (2 the) (2 (2 type) (2 system))) (2 (2 which) (1 (2 resulted) (2 (2 in) (2 (2 (2 lifetime) (2 parameters)) (2 (2 that) (2 (2 (2 were) (2 only)) (2 (2 used) (2 (2 in) (2 (2 trait) (2 objects))))))))))))) (2 (1 not) (2 (2 being) (2 checked))))) (2 .)))
It's hard to characterize precisely the changes that might be needed to fix target code.
(1 (2 It) (1 (1 (2 's) (1 (2 hard) (2 (2 to) (2 (2 (2 characterize) (3 precisely)) (2 (2 (2 the) (2 changes)) (2 (2 that) (2 (2 might) (2 (2 be) (2 (3 needed) (2 (2 to) (2 (2 fix) (2 (2 target) (2 code))))))))))))) (2 .)))
cc #18262 (this fixes the test case by @jakub- but I am not sure if this is the same issue that @alexcrichton was reporting)
r?
(1 (1 (2 (2 cc) (2 (2 #) (2 18262))) (1 (2 -LRB-) (2 (1 (2 this) (1 (2 (2 (2 (2 (2 fixes) (2 (2 the) (2 (2 test) (2 case)))) (2 (2 by) (2 @jakub))) (2 -)) (2 but)) (1 (2 I) (1 (2 (2 (2 am) (1 not)) (2 sure)) (2 (2 if) (1 (2 this) (1 (2 (2 is) (2 (2 the) (2 (2 same) (2 issue)))) (2 (2 that) (2 (2 @alexcrichton) (2 (2 was) (2 reporting))))))))))) (2 -RRB-)))) (2 (2 r) (2 ?)))
@pnkfelix 
Fixes #18205 .
(2 (2 (2 (2 @pnkfelix) (2 Fixes)) (2 (2 #) (2 18205))) (2 .))
Teach variance checker about the lifetime bounds that appear in trait object types.
(1 (2 (2 (2 Teach) (2 (2 variance) (2 checker))) (2 (2 about) (2 (2 the) (2 lifetime)))) (2 (2 (2 bounds) (2 (2 that) (2 (2 appear) (2 (2 in) (2 (2 trait) (2 (2 object) (2 types))))))) (2 .)))
[breaking-change] This patch fixes a hole in the type system which resulted in lifetime parameters that were only used in trait objects not being checked.
(1 (1 (2 (2 -LSB-) (2 (2 breaking-change) (2 -RSB-))) (2 (2 This) (2 patch))) (1 (1 (2 fixes) (1 (1 (2 (2 a) (2 hole)) (2 (2 in) (2 (2 (2 the) (2 (2 type) (2 system))) (2 (2 which) (1 (2 resulted) (2 (2 in) (2 (2 (2 lifetime) (2 parameters)) (2 (2 that) (2 (2 (2 were) (2 only)) (2 (2 used) (2 (2 in) (2 (2 trait) (2 objects))))))))))))) (2 (1 not) (2 (2 being) (2 checked))))) (2 .)))
It's hard to characterize precisely the changes that might be needed to fix target code.
(1 (2 It) (1 (1 (2 's) (1 (2 hard) (2 (2 to) (2 (2 (2 characterize) (3 precisely)) (2 (2 (2 the) (2 changes)) (2 (2 that) (2 (2 might) (2 (2 be) (2 (3 needed) (2 (2 to) (2 (2 fix) (2 (2 target) (2 code))))))))))))) (2 .)))
cc #18262 (this fixes the test case by @jakub- but I am not sure if this is the same issue that @alexcrichton was reporting)
r?
(1 (1 (2 (2 cc) (2 (2 #) (2 18262))) (1 (2 -LRB-) (2 (1 (2 this) (1 (2 (2 (2 (2 (2 fixes) (2 (2 the) (2 (2 test) (2 case)))) (2 (2 by) (2 @jakub))) (2 -)) (2 but)) (1 (2 I) (1 (2 (2 (2 am) (1 not)) (2 sure)) (2 (2 if) (1 (2 this) (1 (2 (2 is) (2 (2 the) (2 (2 same) (2 issue)))) (2 (2 that) (2 (2 @alexcrichton) (2 (2 was) (2 reporting))))))))))) (2 -RRB-)))) (2 (2 r) (2 ?)))
@pnkfelix 
Fixes #18205 .
(2 (2 (2 (2 @pnkfelix) (2 Fixes)) (2 (2 #) (2 18205))) (2 .))
cc #18205 .
(2 (2 (2 cc) (2 (2 #) (2 18205))) (2 .))
Leaving deprecated reexports are still generally considered breaking changes, as I understand it.
(1 (2 (2 Leaving) (2 (2 deprecated) (2 reexports))) (3 (3 (2 (2 are) (2 still)) (3 (2 generally) (3 (2 (2 (2 considered) (2 (2 breaking) (2 changes))) (2 ,)) (2 (2 as) (2 (2 I) (2 (2 understand) (2 it))))))) (2 .)))
However, I don't think any changes to inline-code should be considered breaking changes, so I'm fine with not marking it as such (just disagreeing about why).
(2 (1 However) (1 (2 ,) (1 (1 (1 (1 (1 (2 I) (2 (2 (2 do) (2 n't)) (1 (2 (2 think) (2 (2 any) (2 changes))) (2 (2 to) (2 (2 inline-code) (2 (2 should) (2 (2 be) (2 (2 considered) (2 (2 breaking) (2 changes)))))))))) (2 ,)) (2 so)) (1 (2 I) (1 (2 (2 'm) (3 (3 fine) (2 (2 with) (1 (1 not) (2 (2 marking) (2 (2 it) (2 (2 as) (2 such)))))))) (2 (2 -LRB-) (2 (2 just) (2 (2 (2 disagreeing) (2 (2 about) (2 why))) (2 -RRB-))))))) (2 .))))
This leaves a deprecated reexport in place temporarily.
(1 (2 This) (1 (1 (1 (2 leaves) (2 (2 (2 a) (2 (2 deprecated) (2 reexport))) (2 (2 in) (2 place)))) (2 temporarily)) (2 .)))
Closes #1457.
(2 (2 (2 Closes) (2 (2 #) (2 1457))) (2 .))
I didn't mark this a breaking change because of the deprecated reexport.
(1 (2 I) (1 (1 (2 (2 did) (2 n't)) (2 (2 mark) (2 (2 this) (2 (2 (2 a) (2 (2 breaking) (2 change))) (2 (2 because) (2 (2 of) (2 (2 the) (2 (2 deprecated) (2 reexport))))))))) (2 .)))
This may also make sense in inline-code.
(2 (2 This) (2 (2 (2 (2 may) (2 also)) (2 (2 (2 make) (2 sense)) (2 (2 in) (2 inline-code)))) (2 .)))
This leaves a deprecated reexport in place temporarily.
(1 (2 This) (1 (1 (1 (2 leaves) (2 (2 (2 a) (2 (2 deprecated) (2 reexport))) (2 (2 in) (2 place)))) (2 temporarily)) (2 .)))
Closes #1457.
(2 (2 (2 Closes) (2 (2 #) (2 1457))) (2 .))
I didn't mark this a breaking change because of the deprecated reexport.
(1 (2 I) (1 (1 (2 (2 did) (2 n't)) (2 (2 mark) (2 (2 this) (2 (2 (2 a) (2 (2 breaking) (2 change))) (2 (2 because) (2 (2 of) (2 (2 the) (2 (2 deprecated) (2 reexport))))))))) (2 .)))
This also tags inline-code as experimental.
(3 (2 This) (3 (2 also) (3 (2 (2 tags) (3 (2 inline-code) (2 (2 as) (2 experimental)))) (2 .))))
:umbrella: The latest upstream changes (presumably #30929) made this pull request unmergeable.
(1 (2 :) (1 (1 (2 (2 umbrella) (2 :)) (1 (2 (2 (2 The) (2 (2 latest) (2 (2 upstream) (2 changes)))) (2 (2 -LRB-) (2 (2 presumably) (2 (2 (2 #) (2 30929)) (2 -RRB-))))) (2 (2 made) (2 (2 this) (2 (2 pull) (2 (2 request) (2 unmergeable))))))) (2 .)))
Please resolve the merge conflicts.
(2 (2 Please) (2 (2 (2 resolve) (2 (2 the) (2 (2 merge) (3 conflicts)))) (2 .)))
:hourglass: Testing commit ccb4b35 with merge c42ccb8...
Rebased.
(1 (2 :) (1 (1 (2 (2 hourglass) (2 :)) (1 (2 Testing) (1 (2 commit) (2 (2 (2 (2 ccb4b35) (2 (2 with) (2 (2 merge) (2 c42ccb8)))) (2 ...)) (2 Rebased))))) (2 .)))
Also add tests for use of empty structs in cross-crate scenarios
Some tests are commented out, they depend on fixes from  URL.
(1 (1 (2 Also) (2 (3 add) (1 (1 (2 tests) (1 (2 for) (1 (2 use) (1 (2 of) (1 (1 (1 empty) (2 structs)) (2 (2 in) (2 (2 cross-crate) (2 scenarios)))))))) (2 (2 (2 Some) (2 tests)) (2 (2 are) (2 (2 commented) (1 out))))))) (2 (2 ,) (2 (2 they) (2 (2 (2 depend) (2 (2 on) (2 (2 fixes) (2 (2 from) (2 URL))))) (2 .)))))
@bors: r+ ccb4b35897c0356bb397fe045fa23ddbce9fc134.
(1 (2 (2 (2 @bors) (2 :)) (2 (2 r) (2 (2 +) (2 ccb4b35897c0356bb397fe045fa23ddbce9fc134)))) (2 .))
@bors: r+ 1b602045944c8704b0b14f90531775fc7f492fc6
Nice!
(1 (1 (2 (2 @bors) (2 :)) (2 (2 r) (2 (2 +) (2 (2 1b602045944c8704b0b14f90531775fc7f492fc6) (2 Nice))))) (2 !))
:sunny: Test successful - auto-linux-32-nopt-t, auto-linux-32-opt, auto-linux-64-debug-opt, auto-linux-64-nopt-t, auto-linux-64-opt, auto-linux-64-x-android-t, auto-linux-cross-opt, auto-linux-musl-64-opt, auto-mac-32-opt, auto-mac-64-nopt-t, auto-mac-64-opt, auto-win-gnu-32-nopt-t, auto-win-gnu-32-opt, auto-win-gnu-64-nopt-t, auto-win-gnu-64-opt, auto-win-msvc-32-opt, auto-win-msvc-64-opt.
(2 (2 :) (2 (1 (3 (2 sunny) (3 (2 :) (3 (3 (2 Test) (4 successful)) (2 -)))) (1 (2 auto-linux-32-nopt-t) (1 (2 ,) (1 (2 auto-linux-32-opt) (1 (2 ,) (1 (2 auto-linux-64-debug-opt) (1 (2 ,) (1 (2 auto-linux-64-nopt-t) (1 (2 ,) (1 (2 auto-linux-64-opt) (1 (2 ,) (1 (2 auto-linux-64-x-android-t) (1 (2 ,) (1 (2 auto-linux-cross-opt) (1 (2 ,) (1 (2 auto-linux-musl-64-opt) (1 (2 ,) (1 (2 auto-mac-32-opt) (1 (2 ,) (1 (2 auto-mac-64-nopt-t) (1 (2 ,) (1 (2 auto-mac-64-opt) (1 (2 ,) (1 (2 auto-win-gnu-32-nopt-t) (1 (2 ,) (1 (2 auto-win-gnu-32-opt) (1 (2 ,) (1 (2 auto-win-gnu-64-nopt-t) (2 (2 ,) (1 (2 auto-win-gnu-64-opt) (2 (2 ,) (2 (2 auto-win-msvc-32-opt) (2 (2 ,) (2 auto-win-msvc-64-opt)))))))))))))))))))))))))))))))))) (2 .)))
r?
(2 (2 r) (2 ?))
@Aatch
(rust_highfive has picked a reviewer for you, use r?
(1 (2 (2 @Aatch) (2 (2 -LRB-) (2 (2 rust_highfive) (2 (2 has) (2 (2 picked) (2 (2 (2 a) (2 reviewer)) (2 (2 for) (2 you)))))))) (2 (2 ,) (2 (2 (2 use) (2 r)) (2 ?))))
to override)
Also add tests for use of empty structs in cross-crate scenarios
Some tests are commented out, they depend on fixes from  URL.
(1 (1 (2 to) (1 (2 (2 (2 override) (2 -RRB-)) (2 (2 Also) (2 (3 add) (2 tests)))) (1 (2 for) (1 (2 use) (1 (2 of) (1 (1 (1 empty) (2 structs)) (2 (2 in) (1 (2 (2 cross-crate) (2 scenarios)) (2 (2 (2 Some) (2 tests)) (2 (2 are) (2 (2 commented) (1 out)))))))))))) (2 (2 ,) (2 (2 they) (2 (2 (2 depend) (2 (2 on) (2 (2 fixes) (2 (2 from) (2 URL))))) (2 .)))))
Keeping this file up to date requires hours of work every release,
even with the script.
(1 (1 (1 (2 (2 Keeping) (2 (2 this) (2 (2 (2 file) (2 up)) (2 (2 to) (2 date))))) (1 (2 requires) (2 (2 hours) (2 (2 of) (2 work))))) (2 (2 (2 (2 every) (2 release)) (2 ,)) (2 (2 even) (2 (2 with) (2 (2 the) (2 script)))))) (2 .))
It is a fool's errand and we shall not do it
any longer.
(1 (1 (2 (2 (2 It) (2 (2 is) (2 (2 (2 a) (2 (1 fool) (2 's))) (2 errand)))) (2 and)) (2 (2 we) (2 (2 (2 shall) (1 not)) (2 (2 (2 do) (2 it)) (2 (2 any) (2 longer)))))) (2 .))
:hourglass: Testing commit 402749c with merge e4066f5...
:pushpin: Commit 402749c has been approved by inline-code
<!-- @bors r=steveklabnik 402749c539edcbc2d850ac3a782cace8661c68e6 -->
@bors: r+
Keeping this file up to date requires hours of work every release,
even with the script.
(1 (2 :) (0 (1 (1 (1 (1 (1 (2 (2 hourglass) (2 :)) (1 (2 (2 Testing) (2 (2 commit) (2 402749c))) (2 (2 (2 with) (2 (2 merge) (2 e4066f5))) (2 ...)))) (2 :)) (1 (2 (2 pushpin) (2 :)) (1 (2 (2 Commit) (2 402749c)) (1 (2 has) (1 (2 been) (2 (2 approved) (2 (2 by) (2 (2 inline-code) (2 (2 <!-- @bors r=steveklabnik 402749c539edcbc2d850ac3a782cace8661c68e6 -->) (2 @bors)))))))))) (2 :)) (1 (2 r) (1 (2 +) (1 (2 Keeping) (1 (2 (2 this) (2 file)) (1 (2 (2 up) (2 (2 to) (2 date))) (1 (2 requires) (2 (2 hours) (2 (2 of) (2 (2 (2 (2 (2 work) (2 (2 every) (2 release))) (2 ,)) (2 even)) (2 (2 with) (2 (2 the) (2 script))))))))))))) (2 .)))
It is a fool's errand and we shall not do it
any longer.
(1 (1 (2 (2 (2 It) (2 (2 is) (2 (2 (2 a) (2 (1 fool) (2 's))) (2 errand)))) (2 and)) (2 (2 we) (2 (2 (2 shall) (1 not)) (2 (2 (2 do) (2 it)) (2 (2 any) (2 longer)))))) (2 .))
Should we also get rid of inline-code?
(1 (2 (2 (2 (2 Should) (2 we)) (2 also)) (2 (2 (2 get) (2 rid)) (2 (2 of) (2 inline-code)))) (2 ?))
:sunny: Test successful - auto-linux-32-nopt-t, auto-linux-32-opt, auto-linux-64-debug-opt, auto-linux-64-nopt-t, auto-linux-64-opt, auto-linux-64-x-android-t, auto-linux-cross-opt, auto-linux-musl-64-opt, auto-mac-32-opt, auto-mac-64-nopt-t, auto-mac-64-opt, auto-win-gnu-32-nopt-t, auto-win-gnu-32-opt, auto-win-gnu-64-nopt-t, auto-win-gnu-64-opt, auto-win-msvc-32-opt, auto-win-msvc-64-opt.
(2 (2 :) (2 (1 (3 (2 sunny) (3 (2 :) (3 (3 (2 Test) (4 successful)) (2 -)))) (1 (2 auto-linux-32-nopt-t) (1 (2 ,) (1 (2 auto-linux-32-opt) (1 (2 ,) (1 (2 auto-linux-64-debug-opt) (1 (2 ,) (1 (2 auto-linux-64-nopt-t) (1 (2 ,) (1 (2 auto-linux-64-opt) (1 (2 ,) (1 (2 auto-linux-64-x-android-t) (1 (2 ,) (1 (2 auto-linux-cross-opt) (1 (2 ,) (1 (2 auto-linux-musl-64-opt) (1 (2 ,) (1 (2 auto-mac-32-opt) (1 (2 ,) (1 (2 auto-mac-64-nopt-t) (1 (2 ,) (1 (2 auto-mac-64-opt) (1 (2 ,) (1 (2 auto-win-gnu-32-nopt-t) (1 (2 ,) (1 (2 auto-win-gnu-32-opt) (1 (2 ,) (1 (2 auto-win-gnu-64-nopt-t) (2 (2 ,) (1 (2 auto-win-gnu-64-opt) (2 (2 ,) (2 (2 auto-win-msvc-32-opt) (2 (2 ,) (2 auto-win-msvc-64-opt)))))))))))))))))))))))))))))))))) (2 .)))
r?
(2 (2 r) (2 ?))
@alexcrichton
(rust_highfive has picked a reviewer for you, use r?
(1 (2 (2 @alexcrichton) (2 (2 -LRB-) (2 (2 rust_highfive) (2 (2 has) (2 (2 picked) (2 (2 (2 a) (2 reviewer)) (2 (2 for) (2 you)))))))) (2 (2 ,) (2 (2 (2 use) (2 r)) (2 ?))))
to override)
Maybe inline-code can return inline-code when there is no meaningful substring parent (because the path is relative), and there could be a seperate method inline-code (name bikeshedding very welcome) that returns a inline-code?
(1 (1 (1 (1 (1 (2 (2 to) (2 (2 (2 (2 override) (2 -RRB-)) (2 Maybe)) (2 inline-code))) (1 (2 can) (1 (2 (2 return) (2 inline-code)) (1 (2 when) (1 (2 there) (1 (2 is) (1 (1 (1 no) (3 (3 meaningful) (2 (2 substring) (2 parent)))) (2 (2 -LRB-) (2 (2 (2 because) (2 (2 (2 the) (2 path)) (3 (2 is) (3 relative)))) (2 -RRB-)))))))))) (2 ,)) (2 and)) (3 (2 there) (3 (2 could) (3 (2 be) (3 (3 (2 (2 a) (2 (2 seperate) (2 (2 method) (2 inline-code)))) (3 (2 -LRB-) (3 (3 (2 (2 name) (2 bikeshedding)) (2 (2 very) (2 welcome))) (2 -RRB-)))) (3 (2 that) (3 (2 returns) (2 (2 a) (2 inline-code))))))))) (2 ?))
Python is inconsistent between inline-code and inline-code, so unfortunately "doing what Python does" isn't really an option.
(0 (3 Python) (0 (0 (0 (1 (1 (1 (2 is) (1 (1 inconsistent) (2 (2 between) (2 (2 (2 inline-code) (2 and)) (2 inline-code))))) (2 ,)) (2 so)) (1 unfortunately)) (1 (2 ``) (1 (2 (2 doing) (2 (2 what) (2 (3 Python) (2 does)))) (2 (2 '') (1 (2 (1 (2 is) (2 n't)) (2 really)) (2 (2 an) (2 option))))))) (2 .)))
The main consistent thing between their two implementations, which is notably different from Rust, is that the parent relationship is circular once you get to the bottom of it.
(1 (3 (3 (2 (2 (2 (2 The) (2 (2 main) (2 (3 consistent) (2 thing)))) (2 (2 between) (2 (2 their) (2 (2 two) (2 implementations))))) (2 ,)) (2 (2 which) (2 (2 (2 is) (2 notably)) (2 (2 different) (2 (2 from) (2 Rust)))))) (2 ,)) (1 (1 (2 is) (2 (2 that) (2 (2 (2 the) (2 (2 parent) (2 relationship))) (2 (2 (2 is) (2 circular)) (2 (2 once) (2 (2 you) (2 (2 get) (2 (2 to) (2 (2 (2 the) (1 bottom)) (2 (2 of) (2 it))))))))))) (2 .)))
On the question of "is the empty string the parent of anything?"
(2 (2 On) (2 (2 (2 the) (2 question)) (1 (2 of) (1 (2 ``) (1 (1 (1 (2 is) (1 (1 (2 the) (1 (1 empty) (3 string))) (2 (2 (2 the) (2 parent)) (2 (2 of) (2 anything))))) (2 ?)) (2 ''))))))
they give different answers.
(2 (2 they) (2 (2 (3 give) (2 (2 different) (2 answers))) (2 .)))
Here's some more detail:.
(2 (2 Here) (2 (2 (2 (2 's) (2 (2 some) (2 (2 more) (3 detail)))) (2 :)) (2 .)))
### os.path.dirname
Looking at the implementation in CPython, it seems to be
1.
(1 (2 (2 ###) (2 (2 os.path.dirname) (2 (2 Looking) (2 (2 at) (2 (2 (2 the) (2 implementation)) (2 (2 in) (2 CPython))))))) (2 (2 ,) (2 (2 it) (2 (2 (2 seems) (2 (2 to) (2 (2 be) (2 1)))) (2 .)))))
drop everything to the right of the right-most separator (or just everything, if there are no separators)
2.
(3 (2 (2 (2 drop) (2 everything)) (2 (2 to) (2 (2 the) (2 (2 (3 right) (2 (2 of) (2 (1 (2 (2 (2 (2 the) (2 (2 right-most) (2 separator))) (2 -LRB-)) (2 or)) (1 (2 (2 (2 just) (2 everything)) (2 ,)) (2 (2 if) (1 (2 there) (1 (2 are) (2 (1 no) (2 separators))))))) (2 -RRB-)))) (2 2))))) (2 .))
inline-code any remaining separators off of what's left, _unless_ the remaining string is composed entirely of separators
The "unless" in (2) is how they maintain inline-code, though it also has the weird consequence that inline-code and so on.
(1 (1 (2 (2 inline-code) (2 (2 any) (2 (2 remaining) (2 separators)))) (2 (1 off) (2 (2 of) (2 (2 what) (2 (2 's) (2 left)))))) (1 (2 ,) (1 (1 (1 (2 _) (1 (2 unless) (3 (2 (2 _) (2 (2 the) (2 (2 remaining) (3 string)))) (2 (2 is) (2 (2 (2 composed) (2 entirely)) (2 (2 of) (2 separators))))))) (1 (2 (2 The) (2 (2 ``) (2 (2 unless) (2 '')))) (1 (2 in) (1 (2 -LRB-) (1 (2 (2 2) (2 -RRB-)) (1 (2 is) (1 (2 how) (1 (2 they) (1 (2 (2 (2 maintain) (2 inline-code)) (2 ,)) (1 (2 though) (1 (2 it) (1 (2 also) (1 (2 has) (1 (2 (2 the) (2 (1 weird) (2 consequence))) (2 (2 that) (2 (2 inline-code) (2 (2 and) (2 (2 so) (2 on))))))))))))))))))) (2 .))))
Summary: not very smart about trailing separators or dots, postpones normalizing things until it needs to, willing to give you an empty string, eventually circular if you call it enough times 
### pathlib.Path.parent
Pathlib tries to be smarter.
(0 (1 (1 (1 (1 (2 (2 Summary) (2 :)) (1 (1 (1 not) (3 (2 very) (4 smart))) (2 (2 about) (2 (2 trailing) (2 (2 (2 separators) (2 or)) (2 dots)))))) (2 ,)) (1 (2 postpones) (1 (2 (2 normalizing) (2 things)) (2 (2 until) (1 (2 it) (1 (2 (2 (2 needs) (2 to)) (2 ,)) (1 (2 willing) (1 (2 to) (1 (2 (3 give) (2 you)) (1 (2 an) (1 (1 empty) (3 string)))))))))))) (2 ,)) (1 (2 eventually) (1 (2 (2 circular) (2 (2 if) (1 (2 you) (1 (2 (2 (2 call) (2 it)) (2 (2 enough) (2 times))) (2 (2 ###) (2 (2 (2 pathlib.Path.parent) (2 Pathlib)) (2 (2 tries) (2 (2 to) (2 (2 be) (3 smarter)))))))))) (2 .))))
It drops all duplicated separators, trailing separators, and single dots when paths are constructed.
(1 (2 It) (1 (1 (2 drops) (1 (1 (1 (1 (2 all) (1 (2 (2 (2 duplicated) (2 separators)) (2 ,)) (2 (2 trailing) (2 separators)))) (2 ,)) (2 and)) (2 (2 (2 single) (2 dots)) (2 (2 when) (3 (2 paths) (2 (2 are) (2 constructed))))))) (2 .)))
Unless the path is (or would be) empty, in which case it becomes a single dot.
(1 (2 (2 Unless) (2 (2 (2 the) (2 path)) (2 (2 is) (2 (2 -LRB-) (2 (2 or) (2 (2 (2 would) (2 be)) (2 -RRB-))))))) (1 (1 (1 (1 empty) (2 ,)) (2 (2 (2 in) (2 (2 which) (2 case))) (2 (2 it) (2 (2 becomes) (2 (2 a) (2 (2 single) (2 dot))))))) (2 .)))
Summary: smart about separators and dots, aggressive about normalization, never willing to give you an empty string, also eventually circular.
(3 (3 (3 (3 (3 (2 (2 Summary) (2 :)) (3 (4 smart) (2 (2 about) (2 (2 (2 separators) (2 and)) (2 dots))))) (2 ,)) (2 (2 aggressive) (2 (2 about) (1 (2 normalization) (1 (2 ,) (1 (2 never) (1 (2 willing) (1 (2 to) (1 (2 (3 give) (2 you)) (1 (2 an) (1 (1 empty) (3 string)))))))))))) (2 ,)) (2 (2 also) (2 (2 eventually) (2 (2 circular) (2 .)))))
The latter two cases feel weird to me.
(1 (2 (2 The) (2 (2 latter) (2 (2 two) (2 cases)))) (1 (2 (2 feel) (2 (1 weird) (2 (2 to) (3 me)))) (2 .)))
inline-code by itself is kind of a contradiction, on the one hand saying "yes there _is_ a parent" and on the other hand returning an invalid path that really means "no there isn't actually a parent."
(1 (1 (1 (3 (3 (2 (2 inline-code) (2 (2 by) (2 itself))) (3 (2 (2 (2 is) (2 (3 kind) (2 (2 of) (2 (2 a) (1 contradiction))))) (2 ,)) (2 (2 on) (2 (2 (2 the) (2 (2 one) (2 hand))) (2 (2 (2 (2 saying) (2 ``)) (2 (2 (2 yes) (2 (2 there) (2 (2 _) (2 is)))) (2 (2 _) (2 (2 a) (2 parent))))) (2 '')))))) (2 and)) (1 (2 (2 on) (2 (2 (2 the) (2 (2 other) (2 hand))) (1 (2 returning) (2 (2 (2 an) (2 (2 invalid) (2 path))) (2 (2 that) (2 (2 really) (2 (2 (2 means) (2 ``)) (1 no)))))))) (1 (2 there) (1 (1 (1 (2 is) (2 n't)) (2 actually)) (2 (2 a) (2 parent)))))) (2 .)) (2 ''))
We've also tried to avoid creating empty path components in other cases, like the double-slash case inline-code, which returns inline-code rather than inline-code.
(1 (2 We) (0 (1 (2 (2 've) (2 also)) (0 (1 (1 (2 tried) (1 (2 to) (1 (1 avoid) (1 (1 (2 creating) (1 (1 empty) (2 (2 path) (2 components)))) (2 (2 in) (2 (2 other) (2 cases))))))) (2 ,)) (1 (2 like) (1 (2 (2 (2 the) (2 (2 double-slash) (2 (2 case) (2 inline-code)))) (2 ,)) (1 (2 which) (3 (2 returns) (2 (2 inline-code) (2 (2 rather) (2 (2 than) (2 inline-code)))))))))) (2 .)))
For consistency with inline-code, it probably makes sense to have the parent of inline-code be inline-code.
(1 (2 (2 For) (2 (3 consistency) (2 (2 with) (2 inline-code)))) (1 (2 ,) (1 (2 it) (1 (2 probably) (2 (2 (2 (2 makes) (2 sense)) (2 (2 to) (2 (2 have) (2 (2 (2 (2 the) (2 parent)) (2 (2 of) (2 inline-code))) (2 (2 be) (2 inline-code)))))) (2 .))))))
For inline-code I could imagine going either of two ways, either inline-code or inline-code.
(1 (2 (2 For) (2 inline-code)) (1 (2 I) (1 (1 (2 could) (1 (2 imagine) (2 (2 (2 going) (2 (2 either) (2 (2 of) (2 (2 two) (2 ways))))) (2 (2 ,) (2 (2 either) (2 (2 (2 inline-code) (2 or)) (2 inline-code))))))) (2 .))))
If folks agree that one of those options would be nice in theory, then I guess the second question is whether a behavior change here would break backwards compatibility too much to consider doing it.
(1 (2 (2 If) (2 (2 folks) (3 (2 agree) (3 (2 that) (3 (2 (2 one) (2 (2 of) (2 (2 those) (2 options)))) (2 (2 would) (3 (2 be) (3 (3 nice) (2 (2 in) (2 theory)))))))))) (1 (2 ,) (1 (2 then) (1 (2 I) (1 (1 (2 guess) (1 (2 (2 the) (2 (2 second) (2 question))) (1 (2 is) (1 (2 whether) (1 (2 (2 a) (2 (2 behavior) (2 change))) (1 (2 here) (1 (2 would) (1 (1 (2 break) (1 (2 backwards) (1 (2 compatibility) (1 (2 too) (2 much))))) (2 (2 to) (2 (2 consider) (2 (2 doing) (2 it)))))))))))) (2 .))))))
Would it make sense for me to put together a PR and then ask for a Crater run or something like that?
(1 (2 (2 (2 Would) (2 it)) (1 (2 (2 make) (2 (2 sense) (2 (2 for) (3 me)))) (2 (2 to) (1 (2 (1 (2 (2 (2 put) (2 together)) (2 (2 a) (2 PR))) (2 and)) (2 then)) (2 (2 ask) (2 (2 for) (2 (2 (2 a) (2 (2 Crater) (2 (2 (2 run) (2 or)) (2 something)))) (2 (2 like) (2 that))))))))) (2 ?))
@bluss can you return inline-code which is a parent of inline-code though?
(1 (2 @bluss) (1 (1 (2 can) (1 (2 you) (1 (2 return) (2 (2 inline-code) (2 (2 which) (2 (2 (2 is) (2 (2 (2 a) (2 parent)) (2 (2 of) (2 inline-code)))) (2 though))))))) (2 ?)))
and inline-code afterwards etc.
(2 (2 (2 and) (2 (2 inline-code) (2 (2 afterwards) (2 etc.)))) (2 .))
On the question of returning inline-code vs inline-code, I can imagine a few different invariants we could decide to maintain:.
(1 (2 (2 On) (2 (2 (2 the) (2 question)) (2 (2 of) (2 (2 returning) (2 (2 inline-code) (2 (2 vs) (2 inline-code))))))) (1 (2 ,) (1 (2 I) (2 (2 (2 (2 can) (1 (2 imagine) (2 (2 (2 a) (2 (2 few) (2 (2 different) (2 invariants)))) (2 (2 we) (2 (2 could) (2 (2 decide) (2 (2 to) (2 maintain)))))))) (2 :)) (2 .)))))
- If a path exists on the filesystem, and its parent is inline-code, then its parent exists on the filesystem too.
(1 (2 -) (1 (2 (2 If) (2 (2 (2 (2 (2 (2 a) (2 path)) (2 (2 exists) (2 (2 on) (2 (2 the) (2 filesystem))))) (2 ,)) (2 and)) (2 (2 (2 its) (2 parent)) (2 (2 is) (2 inline-code))))) (2 (2 ,) (2 (2 then) (2 (2 (2 its) (2 parent)) (2 (2 (2 (2 exists) (2 (2 on) (2 (2 the) (2 filesystem)))) (2 too)) (2 .)))))))
Both sides maintain this.
(3 (2 (2 Both) (2 sides)) (2 (2 (2 maintain) (2 this)) (2 .)))
(Though libstd's current behavior violates this.)
(2 (2 -LRB-) (2 (2 (2 (2 Though) (2 (2 libstd) (2 's))) (2 (2 current) (2 behavior))) (2 (2 (2 (2 violates) (2 this)) (2 .)) (2 -RRB-))))
- If a path refers (or could refer) to a _file_, then its parent will always be inline-code.
(1 (2 -) (1 (2 (2 If) (2 (2 (2 a) (2 path)) (2 (2 (2 refers) (2 (2 -LRB-) (2 (2 or) (2 (2 (2 could) (2 refer)) (2 -RRB-))))) (2 (2 to) (2 (2 a) (2 (2 _) (2 (2 file) (2 _)))))))) (2 (2 ,) (2 (2 then) (2 (2 (2 its) (2 parent)) (3 (3 (2 (2 will) (2 always)) (2 (2 be) (2 inline-code))) (2 .)))))))
Only the inline-code approach maintains this.
(2 (2 (2 Only) (2 (2 the) (2 (2 inline-code) (2 approach)))) (2 (2 (2 maintains) (2 this)) (2 .)))
- If a path's parent is inline-code, the parent is a prefix of it.
(1 (2 -) (1 (2 (2 If) (2 (2 (2 (2 a) (2 (2 path) (2 's))) (2 parent)) (2 (2 is) (2 inline-code)))) (2 (2 ,) (2 (2 (2 the) (2 parent)) (3 (2 (2 is) (2 (2 (2 a) (2 prefix)) (2 (2 of) (2 it)))) (2 .))))))
Only the inline-code approach maintains this.
(2 (2 (2 Only) (2 (2 the) (2 (2 inline-code) (2 approach)))) (2 (2 (2 maintains) (2 this)) (2 .)))
That last invariant, the prefix one, is important for non-empty parents in most cases, since we don't want inline-code to have to allocate a inline-code.
(3 (1 (2 (2 (2 (2 That) (2 (2 last) (2 invariant))) (2 ,)) (2 (2 the) (2 (2 prefix) (2 one)))) (2 ,)) (3 (3 (3 (3 (2 is) (3 (2 important) (2 (2 for) (2 (2 (2 non-empty) (2 parents)) (2 (2 in) (2 (2 most) (2 cases))))))) (2 ,)) (2 (2 since) (2 (2 we) (1 (2 (2 do) (2 n't)) (2 (2 want) (2 (2 inline-code) (2 (2 to) (2 (2 have) (2 (2 to) (2 (2 allocate) (2 (2 a) (2 inline-code)))))))))))) (2 .)))
But in this specific case we can return inline-code as a inline-code, so we can get away with breaking it.
(1 (2 But) (1 (2 (2 in) (2 (2 this) (2 (2 specific) (2 case)))) (1 (1 (1 (2 (2 (2 we) (2 (2 can) (2 (2 (2 return) (2 inline-code)) (2 (2 as) (2 (2 a) (2 inline-code)))))) (2 ,)) (2 so)) (2 (2 we) (2 (2 can) (2 (2 (2 get) (2 away)) (2 (2 with) (2 (2 breaking) (2 it))))))) (2 .))))
Would a caller care about getting a prefix back for any other reason?
(2 (2 (2 (2 Would) (2 (2 a) (2 caller))) (2 (3 care) (2 (2 about) (1 (2 (2 (2 getting) (2 (2 a) (2 prefix))) (2 back)) (2 (2 for) (2 (2 any) (2 (2 other) (2 reason)))))))) (2 ?))
One possible issue might be if we ever need to support a weird platform where inline-code is not actually a valid path to inline-code's parent directory.
(1 (2 (2 One) (2 (2 possible) (2 issue))) (1 (2 (2 might) (1 (2 be) (1 (2 if) (2 (2 we) (2 (2 ever) (1 (2 need) (1 (2 to) (1 (2 (2 support) (2 (2 a) (2 (1 weird) (2 platform)))) (1 (2 where) (1 (2 inline-code) (1 (1 (1 (2 is) (1 not)) (2 actually)) (2 (2 (2 a) (2 (2 valid) (2 path))) (2 (2 to) (2 (2 (2 inline-code) (2 's)) (2 (2 parent) (2 directory)))))))))))))))) (2 .)))
Though maybe in that case we would define some new per-platform constant, and tweak the definition of inline-code to say that it might return whatever that thing is?
(1 (1 (2 Though) (1 (2 (2 maybe) (2 (2 in) (2 (2 that) (2 case)))) (1 (2 we) (1 (2 would) (1 (2 (2 (2 (2 define) (2 (2 (2 some) (2 (3 new) (2 per-platform))) (2 constant))) (2 ,)) (2 and)) (3 (3 (2 tweak) (2 (2 (2 the) (2 definition)) (2 (2 of) (2 inline-code)))) (2 (2 to) (2 (2 say) (2 (2 that) (2 (2 it) (2 (2 might) (2 return)))))))))))) (2 (2 (1 whatever) (2 (2 that) (2 thing))) (2 (2 is) (2 ?))))
cc @aturon 
These sorts of subtle details in behavior of path are notoriously difficult and often have surprising results.
(1 (1 (2 cc) (2 (2 (2 @aturon) (2 (2 (2 These) (2 sorts)) (2 (2 of) (3 (3 subtle) (2 details))))) (2 (2 in) (2 (2 behavior) (2 (2 of) (2 path)))))) (1 (2 (2 (2 (2 (2 are) (1 (2 notoriously) (1 difficult))) (2 and)) (2 often)) (3 (2 have) (3 (2 surprising) (2 results)))) (2 .)))
One helpful comparison is to see what a bunch of other path libraries do as well in situations like this.
(1 (2 (2 One) (2 (3 helpful) (2 comparison))) (2 (2 (2 is) (2 (2 to) (2 (2 see) (2 (2 what) (2 (2 (2 (2 a) (2 bunch)) (2 (2 of) (2 (2 other) (2 (2 path) (2 libraries))))) (2 (2 (2 do) (2 (2 as) (3 well))) (2 (2 in) (2 (2 situations) (2 (2 like) (2 this)))))))))) (2 .)))
Technically a parent of inline-code is a inline-code, but we cannot return that due to oversights in the design of the function (returns inline-code, not inline-code/inline-code)?
(1 (1 (1 (1 (2 (2 Technically) (2 (2 (2 (2 a) (2 parent)) (2 (2 of) (2 inline-code))) (2 (2 is) (2 (2 a) (2 inline-code))))) (2 ,)) (2 but)) (1 (2 we) (1 (2 (2 can) (1 not)) (3 (2 return) (2 (2 that) (2 (2 due) (2 (2 to) (2 (2 oversights) (2 (2 in) (2 (2 (2 the) (2 design)) (2 (2 of) (2 (2 (2 the) (2 function)) (2 (2 -LRB-) (2 (3 (3 (3 (2 returns) (2 inline-code)) (2 ,)) (2 (1 not) (2 inline-code/inline-code))) (2 -RRB-))))))))))))))) (2 ?))
Oh gosh, yet another consideration: inline-code is aware of leading dots, and because of that the parent of inline-code is currently inline-code, even though single dots are skipped elsewhere.
(1 (2 Oh) (1 (1 (2 (2 gosh) (2 (2 ,) (2 (2 yet) (2 (2 (2 (2 another) (2 consideration)) (2 :)) (2 inline-code))))) (2 (3 (2 (2 (2 is) (2 (2 aware) (2 (2 of) (2 (2 leading) (2 dots))))) (2 ,)) (2 and)) (2 (2 because) (2 (2 (2 of) (2 that)) (1 (2 (2 (2 the) (2 parent)) (2 (2 of) (2 inline-code))) (1 (2 (2 (2 (2 is) (2 currently)) (2 inline-code)) (2 ,)) (2 (2 even) (2 (2 though) (1 (2 (2 single) (2 dots)) (1 (2 are) (1 (2 skipped) (2 elsewhere)))))))))))) (2 .)))
So we have to choose between "consistency across different forms of the same relative path" and "consistency between the inline-code method and the inline-code list".
(2 (2 So) (2 (2 we) (2 (2 (2 have) (2 (2 to) (2 (2 choose) (2 (2 (2 (2 between) (2 ``)) (2 (3 consistency) (2 (2 across) (2 (2 (2 (2 different) (2 forms)) (2 (2 of) (2 (2 the) (2 (2 same) (3 (3 relative) (2 (2 path) (2 (2 '') (2 (2 and) (2 (2 ``) (3 consistency)))))))))) (2 (2 between) (2 (2 (2 (2 the) (2 (2 inline-code) (2 method))) (2 and)) (2 (2 the) (2 (2 inline-code) (1 list))))))))) (2 ''))))) (2 .))))
@nagisa We can return inline-code in particular, just sticking inline-code into a static(!)
(1 (2 @nagisa) (1 (2 We) (1 (2 can) (1 (3 (3 (2 return) (2 (2 inline-code) (2 (2 in) (2 particular)))) (2 ,)) (2 (2 just) (2 (2 (2 sticking) (2 inline-code)) (2 (2 into) (2 (2 a) (2 (1 static) (2 (2 -LRB-) (2 (2 !) (2 -RRB-))))))))))))
.
(2 .)
:hourglass: Testing commit d7a968e with merge f8bf284...
Closes URL.
(1 (2 :) (1 (1 (1 (2 (2 hourglass) (2 :)) (1 (2 Testing) (2 (2 (2 commit) (2 d7a968e)) (2 (2 with) (2 (2 merge) (2 f8bf284)))))) (2 ...)) (2 (2 (2 Closes) (2 URL)) (2 .))))
r?
(2 (2 r) (2 ?))
@jseyfried .
(2 (2 @jseyfried) (2 .))
:broken_heart: Test failed - auto-win-msvc-64-opt.
(1 (2 :) (1 (1 (1 (2 (2 broken_heart) (2 :)) (1 (2 Test) (1 failed))) (2 -)) (2 (2 auto-win-msvc-64-opt) (2 .))))
:hourglass: Testing commit d7a968e with merge 3121221...
@bors retry.
(1 (2 :) (1 (2 (2 (2 hourglass) (2 :)) (2 Testing)) (1 (1 (2 (2 (2 commit) (2 (2 d7a968e) (2 (2 with) (2 (2 merge) (2 3121221))))) (2 ...)) (2 (2 @bors) (2 retry))) (2 .))))
:pushpin: Commit d7a968e has been approved by inline-code
<!-- @bors r=jseyfried d7a968eb1c8e1d4f84e52a1d1a302e40b1fc4aa9 -->
:broken_heart: Test failed - auto-win-msvc-64-opt.
(1 (2 :) (1 (1 (1 (1 (2 (2 pushpin) (2 :)) (1 (2 (2 Commit) (2 d7a968e)) (2 (2 has) (2 (2 been) (2 (2 approved) (2 (2 by) (2 (2 inline-code) (2 <!-- @bors r=jseyfried d7a968eb1c8e1d4f84e52a1d1a302e40b1fc4aa9 -->)))))))) (2 :)) (1 (1 (1 (2 (2 broken_heart) (2 :)) (1 (2 Test) (1 failed))) (2 -)) (2 auto-win-msvc-64-opt))) (2 .)))
Closes URL.
(2 (2 Closes) (2 (2 URL) (2 .)))
r?
(2 (2 r) (2 ?))
@jseyfried .
(2 (2 @jseyfried) (2 .))
:hourglass: Testing commit d7a968e with merge 85ae467...
@bors: retry
On Mon, Jul 25, 2016 at 3:06 PM, bors <notifications@github.com> wrote:.
(1 (2 :) (0 (1 (0 (1 (1 (1 (1 (2 (2 hourglass) (2 :)) (1 (2 (2 Testing) (2 (2 commit) (2 d7a968e))) (2 (2 with) (2 (2 merge) (2 85ae467))))) (2 ...)) (2 @bors)) (2 :)) (1 (1 (1 (2 (2 (2 retry) (2 (2 On) (2 Mon))) (2 ,)) (1 (1 (2 (2 (2 Jul) (2 25)) (2 ,)) (2 2016)) (2 (2 at) (2 (2 3:06) (2 PM))))) (2 ,)) (2 (2 bors) (2 (2 <notifications@github.com>) (2 wrote))))) (2 :)) (2 .)))
>
>
Spurious failure.
(1 (2 (2 >) (2 >)) (1 (1 (2 Spurious) (0 failure)) (2 .)))
@bors: retry
On Tue, Jul 26, 2016 at 3:31 AM, bors <notifications@github.com> wrote:.
(1 (2 @bors) (1 (2 :) (1 (1 (2 retry) (1 (1 (1 (2 (2 On) (2 Tue)) (2 (2 ,) (2 (2 (2 (2 (2 Jul) (2 26)) (2 ,)) (2 2016)) (2 (2 at) (2 (2 3:31) (2 AM)))))) (2 ,)) (2 (2 bors) (2 <notifications@github.com>)))) (2 (2 (2 wrote) (2 :)) (2 .)))))
>
>
:hourglass: Testing commit d7a968e with merge d7a0706...
:broken_heart: Test failed - auto-win-gnu-32-opt.
(1 (1 (2 (2 (2 >) (2 >)) (2 :)) (1 (1 (1 (1 (1 (2 (1 (2 (2 hourglass) (2 :)) (2 (2 Testing) (2 (2 commit) (2 (2 d7a968e) (2 (2 (2 with) (2 (2 merge) (2 d7a0706))) (2 ...)))))) (2 :)) (2 broken_heart)) (2 :)) (1 (2 Test) (1 failed))) (2 -)) (2 auto-win-gnu-32-opt))) (2 .))
@bors r+
@bors: retry.
(1 (2 (2 (2 (2 @bors) (2 (2 r) (2 (2 +) (2 @bors)))) (2 :)) (2 retry)) (2 .))
@bors: retry
On Sun, Jul 24, 2016 at 10:51 PM, bors <notifications@github.com> wrote:.
(1 (2 @bors) (1 (2 :) (1 (1 (2 retry) (1 (1 (1 (2 (2 On) (2 Sun)) (1 (2 ,) (1 (2 (2 (2 (2 Jul) (2 24)) (2 ,)) (2 2016)) (2 (2 at) (2 (2 10:51) (2 PM)))))) (2 ,)) (2 (2 bors) (2 <notifications@github.com>)))) (2 (2 (2 wrote) (2 :)) (2 .)))))
>
>
:broken_heart: Test failed - auto-win-gnu-32-opt-rustbuild.
(1 (1 (2 (2 (2 >) (2 >)) (2 :)) (1 (1 (1 (2 (2 broken_heart) (2 :)) (1 (2 Test) (1 failed))) (2 -)) (2 auto-win-gnu-32-opt-rustbuild))) (2 .))
1.0, high priority.
(3 (3 (2 (2 1.0) (2 ,)) (2 (3 high) (2 priority))) (2 .))
crashes with a double free, because the glue call in inline-code tries to free the originally allocated memory that was already freed by the assignment in inline-code.
(1 (2 (2 crashes) (2 (2 with) (2 (2 (2 (2 a) (2 (2 double) (3 free))) (2 ,)) (2 (2 because) (2 (2 (2 the) (2 glue)) (2 (2 call) (2 (2 in) (2 inline-code)))))))) (1 (1 (2 tries) (2 (2 to) (2 (3 free) (1 (2 (2 the) (2 (2 (2 originally) (2 allocated)) (2 memory))) (2 (2 that) (1 (2 (2 was) (2 already)) (2 (2 freed) (2 (2 by) (2 (2 (2 the) (2 assignment)) (2 (2 in) (2 inline-code))))))))))) (2 .)))
Maybe related to #9758.
(2 (2 Maybe) (2 (2 (2 related) (2 (2 to) (2 (2 #) (2 9758)))) (2 .)))
Reproduced with 9883a6250b61eb4bb715684f9b25304f4f0d437e.
(2 (2 (2 Reproduced) (2 (2 with) (2 9883a6250b61eb4bb715684f9b25304f4f0d437e))) (2 .))
This seems pretty bad -- nominating for milestone 5, production-ready.
(1 (2 This) (1 (1 (2 seems) (1 (1 (1 (2 (1 (4 pretty) (0 bad)) (2 --)) (2 (2 nominating) (2 (2 for) (2 (2 milestone) (2 5))))) (2 ,)) (2 production-ready))) (2 .)))
cc me.
(2 (2 (2 cc) (3 me)) (2 .))
Actually, this doesn't quite work.
(1 (2 Actually) (1 (2 ,) (1 (2 this) (1 (1 (1 (1 (2 does) (2 n't)) (2 quite)) (2 work)) (2 .)))))
I think there's a bug in getopts that isn't properly parsing inline-code.
(1 (2 I) (1 (2 (2 think) (1 (2 there) (1 (2 's) (1 (2 (2 a) (2 bug)) (1 (2 in) (1 (2 getopts) (1 (2 that) (1 (1 (1 (2 is) (2 n't)) (2 properly)) (2 (2 parsing) (2 inline-code)))))))))) (2 .)))
I'll see if I can track down what's going on.
(1 (2 I) (2 (2 (2 'll) (2 (2 see) (2 (2 if) (2 (2 I) (2 (2 can) (2 (2 (2 track) (2 down)) (2 (2 what) (2 (2 's) (2 (2 going) (2 on)))))))))) (2 .)))
This lets a configure-type script specify things like c library locations and other misc linker related things for extension libraries.
(1 (2 This) (1 (1 (2 lets) (1 (2 (2 a) (2 (2 configure-type) (2 script))) (1 (2 (2 specify) (2 things)) (1 (2 like) (1 (2 (2 c) (2 (2 (2 (2 library) (2 locations)) (2 and)) (2 (2 other) (2 (2 misc) (2 linker))))) (2 (2 (2 related) (2 things)) (2 (2 for) (2 (2 extension) (2 libraries))))))))) (2 .)))
This lets a configure-type script specify things like c library locations and other misc linker related things for extension libraries.
(1 (2 This) (1 (1 (2 lets) (1 (2 (2 a) (2 (2 configure-type) (2 script))) (1 (2 (2 specify) (2 things)) (1 (2 like) (1 (2 (2 c) (2 (2 (2 (2 library) (2 locations)) (2 and)) (2 (2 other) (2 (2 misc) (2 linker))))) (2 (2 (2 related) (2 things)) (2 (2 for) (2 (2 extension) (2 libraries))))))))) (2 .)))
Oops, it went into master instead of incoming.
(1 (2 Oops) (1 (2 ,) (1 (2 it) (1 (1 (2 went) (2 (2 into) (3 (2 master) (2 (2 instead) (2 (2 of) (2 incoming)))))) (2 .)))))
r?
(2 (2 r) (2 ?))
@aturon.
(2 (2 @aturon) (2 .))
Thanks, looks great!
(3 (2 Thanks) (3 (2 ,) (3 (3 (2 looks) (4 great)) (2 !))))
@bors: r+ 3577555 rollup.
(1 (1 (2 (2 @bors) (2 :)) (1 (2 r) (2 (2 (2 +) (2 3577555)) (2 rollup)))) (2 .))
r?
(2 (2 r) (2 ?))
@aturon.
(2 (2 @aturon) (2 .))
Closes URL.
(2 (2 Closes) (2 (2 URL) (2 .)))
Niice :heart_eyes:.
(2 (2 Niice) (2 (2 :) (2 (2 (2 heart_eyes) (2 :)) (2 .))))
In explicit code most likely not but I'd imagine it being used all over the place after monomorphization.
(1 (2 (2 In) (2 (2 (2 (1 explicit) (2 code)) (2 (2 most) (2 likely))) (2 (1 not) (2 but)))) (1 (2 I) (1 (2 (2 'd) (1 (2 imagine) (2 (2 it) (2 (2 being) (2 (2 (2 used) (2 (2 all) (2 (2 over) (2 (2 the) (2 place))))) (2 (2 after) (2 monomorphization))))))) (2 .))))
Is inline-code used for anything now that inline-code is gone?
(1 (2 (2 (2 Is) (2 inline-code)) (1 (2 (2 used) (2 (2 for) (2 anything))) (2 (2 now) (2 (2 that) (2 (2 inline-code) (2 (2 is) (2 gone))))))) (2 ?))
Shouldn't inline-code be removed as well?
(1 (1 (2 (2 (2 Should) (2 n't)) (2 inline-code)) (2 (2 be) (2 (2 removed) (2 (2 as) (3 well))))) (2 ?))
Is this used often enough to have it special-cased in the compiler?
(2 (2 (2 (2 Is) (2 this)) (2 (2 (2 used) (2 (2 often) (2 enough))) (2 (2 to) (2 (2 (2 have) (2 (2 it) (2 special-cased))) (2 (2 in) (2 (2 the) (2 compiler))))))) (2 ?))
So inline-code would parse as inline-code?
(1 (2 So) (1 (2 inline-code) (2 (2 (2 would) (2 (2 parse) (2 (2 as) (2 inline-code)))) (2 ?))))
It's been long enough that we can probably stop parsing this form.
(1 (2 It) (1 (1 (2 's) (1 (2 been) (1 (2 (2 long) (2 enough)) (1 (2 that) (1 (2 we) (1 (2 (2 can) (2 probably)) (2 (2 stop) (2 (2 parsing) (2 (2 this) (2 form)))))))))) (2 .)))
cc @alexcrichton @pcwalton.
(1 (2 (2 cc) (2 @alexcrichton)) (2 (2 @pcwalton) (2 .)))
This ends up being a parse error so it doesn't matter too much what AST node this parses to.
(1 (2 This) (1 (1 (2 (2 ends) (2 up)) (1 (2 being) (1 (1 (2 a) (1 (2 parse) (1 error))) (3 (2 so) (3 (2 it) (2 (1 (2 does) (2 n't)) (1 (2 matter) (1 (1 (2 too) (2 much)) (2 (2 what) (2 (2 AST) (2 (2 (2 node) (2 (2 this) (2 parses))) (2 to)))))))))))) (2 .)))
I imagine we'll want the obsolete syntax knowledge to stick around for quite some time.
(1 (2 I) (1 (1 (2 imagine) (2 (2 we) (2 (2 'll) (1 (2 (2 want) (2 (2 the) (2 (2 obsolete) (2 (2 syntax) (2 knowledge))))) (2 (2 to) (2 (2 (2 stick) (2 around)) (2 (2 for) (2 (2 quite) (2 (2 some) (2 time)))))))))) (2 .)))
There is still a lot of outdated Rust code in Stack Overflow pages that it would be nice to have the compiler be helpful with.
(1 (2 There) (1 (1 (1 (2 (2 is) (2 still)) (1 (2 (2 a) (2 lot)) (1 (2 of) (1 (1 (1 outdated) (2 (2 Rust) (2 code))) (2 (2 in) (2 (2 Stack) (2 (2 Overflow) (2 pages)))))))) (2 (2 that) (2 (2 it) (2 (2 would) (2 (2 be) (3 (3 nice) (2 (2 to) (2 (2 have) (2 (2 (2 the) (2 compiler)) (2 (2 (2 be) (3 helpful)) (2 with))))))))))) (2 .)))
Though I imagine most of those examples don't parse for other reasons anyway...
Where is the empty case handled?
(1 (2 Though) (1 (2 I) (1 (2 imagine) (1 (2 (2 most) (2 (2 of) (2 (2 those) (2 examples)))) (1 (2 (2 do) (2 n't)) (1 (2 (2 (2 (2 parse) (2 (2 for) (2 (2 other) (2 reasons)))) (2 anyway)) (2 ...)) (1 (2 Where) (1 (1 (1 (2 is) (1 (2 the) (1 (1 empty) (2 case)))) (2 handled)) (2 ?)))))))))
Is the guard extraneous?
(2 (2 (2 (2 Is) (2 (2 the) (2 guard))) (2 extraneous)) (2 ?))
TyBot has to stay for now as that's how we represent diverging functions in the AST.
(3 (2 TyBot) (3 (3 (2 has) (2 (2 to) (2 (2 (2 stay) (2 (2 for) (2 now))) (2 (2 as) (2 (2 that) (2 (2 's) (2 (2 how) (2 (2 we) (2 (2 represent) (2 (2 (2 diverging) (2 functions)) (2 (2 in) (2 (2 the) (2 AST))))))))))))) (2 .)))
I removed TyUniq and TyNil.
(1 (2 I) (2 (2 (2 removed) (2 (2 (2 TyUniq) (2 and)) (2 TyNil))) (2 .)))
:+1: Been wanting to do this myself but I was afraid of the performance implications of going through interning for each call to inline-code.
(1 (2 :) (1 (1 (2 (2 +1) (1 (2 :) (2 Been))) (1 (3 (2 wanting) (2 (2 to) (2 (2 (2 do) (2 this)) (2 myself)))) (1 (2 but) (2 (2 I) (2 (2 was) (1 (2 afraid) (1 (2 of) (1 (2 (2 the) (2 (2 performance) (2 implications))) (2 (2 of) (1 (2 going) (2 (2 through) (2 (2 (2 interning) (2 (2 for) (2 (2 each) (2 call)))) (2 (2 to) (2 inline-code)))))))))))))) (2 .)))
Does the hash optimize out, at least?
(2 (3 Does) (2 (2 (2 the) (1 hash)) (2 (2 (2 (2 (2 optimize) (1 out)) (2 ,)) (2 (2 at) (1 least))) (2 ?))))
Last I checked, LLVM could const-eval FNV when applied to strings longer than 16 bytes (I didn't try to push it harder).
(1 (2 (2 (2 Last) (2 I)) (2 checked)) (1 (2 ,) (1 (2 LLVM) (2 (2 (2 could) (2 (2 (2 const-eval) (2 FNV)) (2 (2 when) (2 (2 applied) (2 (2 to) (2 (2 (2 strings) (2 (2 longer) (2 (2 than) (2 (2 16) (2 bytes))))) (2 (2 -LRB-) (2 (2 (2 I) (2 (2 (2 did) (2 n't)) (2 (2 try) (2 (2 to) (2 (2 push) (2 (2 it) (2 harder))))))) (2 -RRB-))))))))) (2 .)))))
This special case can probably be removed as well, but that might require reworking the loop below a bit.
(1 (2 (2 (3 (3 (2 (2 This) (2 (3 special) (2 case))) (3 (2 (2 can) (2 probably)) (2 (2 be) (2 (2 removed) (2 (2 as) (3 well)))))) (2 ,)) (2 but)) (2 (2 that) (2 (2 might) (2 (2 require) (1 (2 (2 reworking) (2 (2 the) (2 loop))) (2 (1 below) (2 (2 a) (2 bit)))))))) (2 .))
inline-code should go as well.
(3 (2 inline-code) (3 (3 (2 should) (2 (2 go) (2 (2 as) (3 well)))) (2 .)))
This special case can be removed now.
(2 (2 (2 This) (2 (3 special) (2 case))) (2 (2 (2 can) (2 (2 be) (2 (2 removed) (2 now)))) (2 .)))
Shouldn't the above 3 variants be removed?
(1 (1 (1 (2 (2 Should) (2 n't)) (2 (2 the) (2 (2 above) (2 (2 3) (2 variants))))) (2 (2 be) (2 removed))) (2 ?))
I'm surprised inline-code is still around.
(3 (2 I) (2 (2 (2 'm) (3 (3 surprised) (2 (2 inline-code) (2 (2 (2 is) (2 still)) (2 around))))) (2 .)))
@pcwalton Agreed, the manual still refers to inline-code the way you described.
(1 (2 (2 (2 (2 @pcwalton) (2 Agreed)) (2 ,)) (2 (2 the) (2 manual))) (2 (2 still) (2 (2 (2 refers) (2 (2 to) (2 (2 inline-code) (2 (2 (2 the) (2 way)) (2 (2 you) (2 described)))))) (2 .))))
But I made it truthful about inline-code not being a literal any more.
(1 (2 But) (1 (2 I) (1 (2 (1 (2 made) (2 (2 it) (2 (2 (2 truthful) (2 (2 about) (2 (2 inline-code) (1 not)))) (2 (2 being) (3 (2 a) (3 literal)))))) (2 (2 any) (2 more))) (2 .))))
It still might be nice for pedagogical reasons to refer to unit as a kind of separate type in the documentation, since it's so common.
(3 (2 It) (3 (2 still) (3 (3 (2 might) (3 (3 (3 (3 (2 (2 be) (3 nice)) (2 (2 for) (2 (2 pedagogical) (2 reasons)))) (2 (2 to) (3 (2 (2 refer) (2 (2 to) (2 unit))) (2 (2 as) (2 (2 (2 a) (3 kind)) (2 (2 of) (2 (2 (2 separate) (2 type)) (2 (2 in) (2 (2 the) (2 documentation)))))))))) (2 ,)) (2 (2 since) (2 (2 it) (2 (2 's) (2 (2 so) (2 common))))))) (2 .))))
(Internally though this is a great refactoring.)
(3 (2 -LRB-) (3 (3 (3 (2 Internally) (3 (2 though) (3 (2 this) (3 (2 is) (3 (2 a) (3 (4 great) (2 refactoring))))))) (2 .)) (2 -RRB-)))
Oh wow, it previously required an allocation!
(4 (2 Oh) (3 (3 (3 (3 wow) (2 ,)) (2 (2 it) (2 (2 previously) (2 (2 required) (2 (2 an) (2 allocation)))))) (2 !)))
:dancer: .
(2 (2 :) (2 (2 (2 dancer) (2 :)) (2 .)))
I kept it so that witnesses in non-exhaustive patterns would be more descriptive (i.e. () rather than _) but we can probably achieve that differently.
(1 (2 (1 (1 (1 (2 I) (1 (2 (2 kept) (2 it)) (1 (2 so) (2 (2 that) (1 (2 (2 witnesses) (2 (2 in) (2 (2 non-exhaustive) (2 patterns)))) (2 (2 would) (2 (2 be) (2 (2 more) (2 descriptive))))))))) (1 (2 -LRB-) (2 (1 (2 (2 (2 (2 i.e.) (2 -LRB-)) (2 -RRB-)) (2 rather)) (2 (2 than) (2 _))) (2 -RRB-)))) (2 but)) (2 (2 we) (2 (2 (2 can) (2 probably)) (2 (2 (3 achieve) (2 that)) (2 differently))))) (2 .))
Closes URL.
(2 (2 Closes) (2 (2 URL) (2 .)))
Thanks for the report!
(2 (2 (2 Thanks) (2 (2 for) (2 (2 the) (2 report)))) (2 !))
I think that this issue may be more appropriately placed in a different location, however.
(1 (2 I) (2 (2 (2 think) (1 (2 that) (1 (2 (2 this) (2 issue)) (2 (2 may) (2 (2 (2 (2 be) (2 (2 (2 more) (2 appropriately)) (2 (2 placed) (2 (2 in) (2 (2 a) (2 (2 different) (2 location))))))) (2 ,)) (2 however)))))) (2 .)))
Modifications to the prelude would require an RFC (or an issue in the RFC repo) and other general discussion about the verbosity and possible other solutions would be a good candidate for URL.
(1 (1 (1 (1 (2 (2 Modifications) (2 (2 to) (2 (2 the) (2 prelude)))) (2 (2 would) (2 (2 require) (2 (2 (2 (2 (2 an) (2 RFC)) (2 (2 -LRB-) (2 (2 or) (2 (2 (2 (2 an) (2 issue)) (2 (2 in) (2 (2 the) (2 (2 RFC) (2 repo))))) (2 -RRB-))))) (2 and)) (2 (2 (2 other) (2 (2 general) (2 discussion))) (2 (2 about) (2 (2 the) (2 verbosity)))))))) (2 and)) (3 (2 (2 possible) (2 (2 other) (3 solutions))) (2 (2 would) (3 (2 be) (3 (3 (2 a) (3 (3 good) (2 candidate))) (2 (2 for) (2 URL))))))) (2 .))
It has been proposed (informally) that one should be able to import a static trait method as a function.
(1 (2 It) (1 (1 (2 has) (1 (2 been) (1 (2 (2 proposed) (2 (2 -LRB-) (2 (2 informally) (2 -RRB-)))) (2 (2 that) (2 (2 one) (2 (2 should) (2 (2 be) (2 (3 able) (2 (2 to) (2 (2 (2 import) (2 (2 a) (2 (1 static) (2 (2 trait) (2 method))))) (2 (2 as) (2 (2 a) (2 function))))))))))))) (2 .)))
that is:.
(2 (2 that) (2 (2 (2 is) (2 :)) (2 .)))
inline-code  
would Just Work.
(2 (2 inline-code) (2 (2 (2 (2 would) (2 Just)) (2 Work)) (2 .)))
See also: URL.
(3 (3 (3 (3 (2 See) (2 also)) (2 :)) (2 URL)) (2 .))
inline-code (or inline-code) is long, prone to off-by-one-default mistakes, and looks silly.
(1 (2 (2 inline-code) (2 (2 -LRB-) (2 (2 or) (2 (2 inline-code) (2 -RRB-))))) (1 (1 (2 is) (1 (2 long) (2 (2 ,) (2 (2 (2 prone) (2 (2 to) (2 (2 off-by-one-default) (2 mistakes)))) (2 (2 ,) (2 (2 and) (2 (2 looks) (3 silly)))))))) (2 .)))
I wanted to use default values to save myself typing of all the struct fields, but importing and using Default doesn't save me much typing :)
Could the path be shortened?
(1 (1 (2 (2 (2 (2 I) (2 (2 wanted) (2 (2 to) (2 (2 (2 use) (2 (2 default) (2 values))) (2 (2 to) (2 (2 save) (2 (2 myself) (2 (2 typing) (2 (2 of) (2 (2 all) (2 (2 the) (2 (2 struct) (2 fields))))))))))))) (2 ,)) (2 but)) (1 (2 (2 (2 (2 importing) (2 and)) (2 using)) (2 Default)) (2 (1 (2 does) (2 n't)) (1 (2 save) (1 (3 me) (2 (2 much) (2 (2 typing) (2 (2 (2 :-RRB-) (2 Could)) (2 (2 (2 the) (2 path)) (2 (2 be) (2 shortened))))))))))) (2 ?))
e.g. by making a function inline-code or adding inline-code to prelude?
(1 (2 e.g.) (1 (2 (2 by) (2 (2 (2 (2 making) (2 (2 a) (2 (2 function) (2 inline-code)))) (2 or)) (3 (3 adding) (2 (2 inline-code) (2 (2 to) (2 prelude)))))) (2 ?)))
Ah, it's leaking the argument slots to the slot the tail-call is originating from.
(2 (2 Ah) (1 (2 ,) (1 (2 it) (1 (2 (2 's) (1 (2 (2 (2 leaking) (2 (2 the) (2 (2 argument) (2 slots)))) (2 (2 to) (2 (2 the) (2 slot)))) (2 (2 (2 the) (2 tail-call)) (2 (2 is) (2 (2 originating) (2 from)))))) (2 .)))))
Nice minimal case, thanks!
(3 (2 (2 (2 (2 Nice) (2 (2 minimal) (2 case))) (2 ,)) (3 thanks)) (2 !))
Found the problem, adding further-reduced test plus fix shortly.
(1 (1 (1 (2 (2 Found) (2 (2 the) (1 problem))) (2 ,)) (1 (2 (3 adding) (2 (2 further-reduced) (2 test))) (2 (2 (3 plus) (2 fix)) (2 shortly)))) (2 .))
Fix leaking arg slots on tail calls.
(2 (2 (2 Fix) (2 (2 (2 leaking) (2 (2 arg) (2 slots))) (2 (2 on) (2 (2 tail) (2 calls))))) (2 .))
Closed by bc646d01c501f2566fd78057e23c283cfedc0eb0.
(2 (2 (2 Closed) (2 (2 by) (2 bc646d01c501f2566fd78057e23c283cfedc0eb0))) (2 .))
Er, the function the tail-call is originating from.
(1 (2 (2 (2 Er) (2 ,)) (2 (2 (2 the) (2 function)) (2 (2 the) (2 tail-call)))) (2 (2 (2 is) (2 (2 originating) (2 from))) (2 .)))
Sigh, mondays.
(3 (2 (2 (2 Sigh) (2 ,)) (2 mondays)) (2 .))
The following code
gives
Without the 'dummy' vector it is OK, i.e.
e.g. the following fails to parse (inline-code is inline-code at runtime: a parse error).
(1 (2 (2 The) (2 (2 following) (2 code))) (1 (1 (2 gives) (1 (2 (2 Without) (2 (2 the) (2 (2 `) (2 (2 dummy) (2 (2 ') (2 vector)))))) (1 (2 it) (1 (1 (2 is) (1 (2 OK) (1 (2 ,) (1 (2 i.e.) (1 (2 e.g.) (1 (2 (2 the) (2 following)) (1 (0 fails) (2 (2 to) (2 parse))))))))) (1 (2 -LRB-) (2 (1 (2 inline-code) (1 (2 is) (1 (2 inline-code) (1 (2 at) (1 (2 (2 runtime) (2 :)) (1 (2 a) (1 (2 parse) (1 error)))))))) (2 -RRB-))))))) (2 .)))
(looks like there are tidy errors on travis)
Sorry!
(1 (2 -LRB-) (1 (2 looks) (2 (2 (1 (2 like) (2 (1 (2 there) (2 (2 are) (2 (2 (2 tidy) (1 errors)) (2 (2 on) (2 travis))))) (2 -RRB-))) (2 Sorry)) (2 !))))
I always forget the trailing spaces...
Make struct variant syntax more consistent with struct syntax and fix an
assert in middle::typeck.
(2 (2 I) (2 (2 always) (2 (2 (1 forget) (1 (2 the) (1 (1 (1 (2 (2 (2 trailing) (3 spaces)) (2 ...)) (1 (2 (2 (2 Make) (1 (2 (2 struct) (2 (2 variant) (2 syntax))) (3 (2 more) (2 (3 consistent) (2 (2 with) (2 (2 struct) (2 syntax))))))) (2 and)) (2 (2 fix) (2 (2 (2 an) (2 assert)) (2 (2 (2 in) (2 middle)) (2 :)))))) (2 :)) (2 typeck)))) (2 .))))
Fix #19003.
(2 (2 (2 Fix) (2 (2 #) (2 19003))) (2 .))
Make struct variant syntax more consistent with struct syntax and fix an
assert in middle::typeck.
(1 (1 (2 (2 (2 Make) (1 (2 (2 struct) (2 (2 variant) (2 syntax))) (3 (2 more) (2 (3 consistent) (2 (2 with) (2 (2 struct) (2 syntax))))))) (2 and)) (2 (2 fix) (2 (2 (2 (2 (2 an) (2 assert)) (2 (2 (2 in) (2 middle)) (2 :))) (2 :)) (2 typeck)))) (2 .))
Fix #19003.
(2 (2 (2 Fix) (2 (2 #) (2 19003))) (2 .))
Triage: still ICEs.
(2 (2 Triage) (2 (2 :) (2 (2 (2 still) (2 ICEs)) (2 .))))
Compiler version (running on OS X 10.10.1):.
(1 (2 (1 (2 (2 Compiler) (2 version)) (2 (2 -LRB-) (2 (2 (2 (2 running) (2 (2 on) (2 OS))) (2 (2 X) (2 10.10.1))) (2 -RRB-)))) (2 :)) (2 .))
To reproduce the ICE:.
(2 (2 To) (2 (2 (2 (2 reproduce) (2 (2 the) (2 ICE))) (2 :)) (2 .)))
Triage: Still ICEs.
(3 (3 (2 (2 Triage) (2 :)) (2 (2 Still) (2 ICEs))) (2 .))
Given information on what should happen here, I'd be willing to look into fixing this, [this] function seems to be the likely location of the fix.
(1 (1 (2 (2 Given) (2 (2 information) (2 (2 on) (2 (2 what) (2 (2 should) (2 (2 happen) (2 here))))))) (2 (2 ,) (2 (2 I) (2 (2 'd) (2 (2 be) (2 (2 willing) (2 (2 to) (2 (2 look) (2 (2 into) (2 (2 fixing) (2 this))))))))))) (1 (2 ,) (1 (2 (2 -LSB-) (2 (2 this) (2 (2 -RSB-) (2 function)))) (1 (2 (2 seems) (2 (2 to) (2 (2 be) (2 (2 (2 the) (2 (2 likely) (2 location))) (2 (2 of) (2 (2 the) (2 fix))))))) (2 .)))))
From IRC:.
(2 (2 (2 (1 From) (2 IRC)) (2 :)) (2 .))
It's just that i'm not used to the pull request system, and each time i do inline-code, git merge all the commits from the rust master on the top on my branch and add all the commits to the pull request.
(0 (0 (1 (1 (1 (2 It) (1 (2 's) (1 (2 just) (1 (2 that) (1 (2 i) (1 (2 (2 'm) (1 not)) (2 (2 used) (2 (2 to) (2 (2 the) (2 (2 pull) (2 (2 request) (2 system)))))))))))) (2 ,)) (2 and)) (1 (2 (2 each) (2 (2 time) (2 i))) (1 (2 (2 (2 do) (2 inline-code)) (2 ,)) (1 (2 git) (2 (2 (2 (2 (2 merge) (2 (2 all) (2 (2 the) (2 commits)))) (3 (2 from) (3 (3 (2 the) (3 (2 rust) (2 master))) (2 (2 on) (3 (2 (2 the) (2 top)) (2 (2 on) (2 (2 my) (2 branch)))))))) (2 and)) (2 (2 (3 add) (2 (2 all) (2 (2 the) (2 commits)))) (2 (2 to) (2 (2 the) (2 (2 pull) (2 request)))))))))) (2 .))
I've probably missed something.
(1 (2 I) (1 (1 (2 (2 've) (2 probably)) (2 (2 missed) (2 something))) (2 .)))
So i try again tomorrow.
(2 (2 So) (2 (2 i) (2 (2 (2 (2 try) (2 again)) (2 tomorrow)) (2 .))))
Feel free to force-push an existing PR, github'll track it all and update this one for you.
(1 (2 (2 Feel) (2 (3 free) (2 (2 to) (2 (2 force-push) (2 (2 an) (2 (2 existing) (2 PR))))))) (2 (2 ,) (2 (2 github) (2 (2 (2 'll) (2 (2 (2 (2 track) (2 (2 it) (2 all))) (2 and)) (2 (2 update) (2 (2 (2 this) (2 one)) (2 (2 for) (2 you)))))) (2 .)))))
Re-submit the previous pull request.
(3 (2 (2 Re-submit) (2 (2 the) (2 (2 previous) (2 pull)))) (2 (2 request) (2 .)))
Clean the accidental merge, update to rust master and change libconcurrency to libsync.
(1 (3 (2 Clean) (2 (2 (2 the) (2 accidental)) (2 merge))) (1 (2 ,) (1 (1 (2 (3 (2 update) (3 (2 to) (3 (2 rust) (2 master)))) (2 and)) (2 (2 (2 change) (2 libconcurrency)) (2 (2 to) (2 libsync)))) (2 .))))
Okay thank you !
(3 (2 Okay) (3 (2 (3 thank) (2 you)) (2 !)))
I try inline-code tomorrow!
(2 (2 I) (2 (2 (2 try) (2 (2 inline-code) (2 tomorrow))) (2 !)))
Re-submit the previous pull request.
(3 (2 (2 Re-submit) (2 (2 the) (2 (2 previous) (2 pull)))) (2 (2 request) (2 .)))
Clean the accidental merge, update to rust master and change libconcurrency to libsync.
(1 (3 (2 Clean) (2 (2 (2 the) (2 accidental)) (2 merge))) (1 (2 ,) (1 (1 (2 (3 (2 update) (3 (2 to) (3 (2 rust) (2 master)))) (2 and)) (2 (2 (2 change) (2 libconcurrency)) (2 (2 to) (2 libsync)))) (2 .))))
Maybe this would be better phrased as "The inline-code library for concurrency-enabled mechanisms and primitives"?
(2 (2 Maybe) (2 (2 this) (1 (2 (2 would) (2 (2 be) (2 (4 better) (2 (2 phrased) (2 (2 (2 (2 as) (2 ``)) (1 (2 (2 The) (2 (2 inline-code) (2 library))) (2 (2 for) (2 (2 concurrency-enabled) (2 (2 (2 mechanisms) (2 and)) (2 primitives)))))) (2 '')))))) (2 ?))))
(I know it goes against the other ones, but the middle phase is rather long for libsync.)
(1 (2 -LRB-) (2 (1 (1 (2 (2 (2 (2 I) (2 (2 know) (2 (2 it) (2 (2 goes) (2 (2 against) (2 (2 the) (2 (2 other) (2 ones)))))))) (2 ,)) (2 but)) (2 (2 (2 the) (2 (2 middle) (2 phase))) (2 (2 is) (2 (2 rather) (2 (2 long) (2 (2 for) (2 libsync))))))) (2 .)) (2 -RRB-)))
(This needs a rebase, btw.)
(1 (2 -LRB-) (1 (2 This) (1 (1 (1 (2 needs) (2 (2 (2 (2 a) (2 rebase)) (2 ,)) (2 btw))) (2 .)) (2 -RRB-))))
No problem!
(2 (1 No) (2 (1 problem) (2 !)))
I'm not entirely sure what inline-code does, but I find that inline-code works pretty well for me.
(3 (3 (1 (1 (1 (2 I) (1 (2 (2 'm) (1 not)) (2 (2 entirely) (2 (2 sure) (2 (2 what) (2 (2 inline-code) (2 does))))))) (2 ,)) (2 but)) (3 (2 I) (3 (2 find) (3 (2 that) (3 (2 inline-code) (3 (3 (2 works) (3 (4 pretty) (3 well))) (2 (2 for) (3 me)))))))) (2 .))
Port of URL.
(2 (2 (2 Port) (2 (2 of) (2 URL))) (2 .))
r?
(2 (2 r) (2 ?))
@nikomatsakis .
(2 (2 @nikomatsakis) (2 .))
<img src="URL alt="warning" height=20> **Warning** <img src="URL alt="warning" height=20>
* Pull requests are usually filed against the master branch for this repo, but this one is against beta.
(1 (1 (1 (1 (1 (2 (2 <) (2 (2 img) (2 src))) (1 (2 =) (1 (2 ``) (1 (1 (1 (2 URL) (2 (2 alt) (2 (2 (2 =) (2 (2 ``) (2 (2 warning) (2 (2 '') (2 height))))) (2 (2 =) (2 (2 20) (2 >)))))) (1 (2 (2 **) (2 Warning)) (1 (2 **) (1 (2 (2 <) (2 (2 img) (2 src))) (2 (2 =) (2 (2 (2 ``) (2 (2 URL) (2 (2 alt) (2 (2 =) (2 (2 ``) (2 (2 warning) (2 (2 '') (2 height)))))))) (2 (2 =) (2 (2 20) (2 >))))))))) (1 (2 *) (1 (2 (2 Pull) (2 requests)) (2 (2 (2 are) (2 usually)) (3 (2 filed) (2 (2 against) (3 (3 (2 the) (3 (2 master) (2 branch))) (2 (2 for) (2 (2 this) (2 repo))))))))))))) (2 ,)) (2 but)) (2 (2 (2 this) (2 one)) (2 (2 is) (2 (2 against) (2 beta))))) (2 .))
Please double check that you specified the right target!
(2 (2 Please) (3 (2 (2 (2 double) (3 check)) (2 (2 that) (2 (2 you) (2 (2 specified) (2 (2 the) (2 (3 right) (2 target))))))) (2 !)))
r+
Port of URL.
(1 (2 r) (1 (2 (2 (2 +) (2 Port)) (2 (2 of) (2 URL))) (2 .)))
r?
(2 (2 r) (2 ?))
@nikomatsakis .
(2 (2 @nikomatsakis) (2 .))
@mdinger corrected :) (damn you spaces before punctuation, you are the exact opposite in French...)
Wonderful, thank you so much!
(3 (2 (2 @mdinger) (2 (2 corrected) (2 :-RRB-))) (4 (3 (2 -LRB-) (3 (3 (3 (3 (3 (1 damn) (2 (2 you) (2 (3 spaces) (2 (2 before) (2 punctuation))))) (2 ,)) (2 (2 you) (2 (2 are) (2 (2 (2 the) (2 (2 exact) (2 opposite))) (2 (2 in) (2 French)))))) (2 ...)) (2 -RRB-))) (3 (3 (3 (3 Wonderful) (2 ,)) (2 (3 thank) (2 (2 you) (2 (2 so) (2 much))))) (2 !))))
inline-code.
(2 (2 inline-code) (2 .))
Updated :)
What do you think @steveklabnik ?
(1 (2 (2 (2 Updated) (2 :-RRB-)) (2 (2 What) (2 (2 do) (2 (2 you) (2 think))))) (2 (2 @steveklabnik) (2 ?)))
Lacks closing backticks.
(1 (1 (1 Lacks) (2 closing)) (2 (2 backticks) (2 .)))
This should mostly fix your grammar if you want it:.
(2 (2 This) (2 (2 (2 (2 (2 should) (2 mostly)) (2 (2 (2 fix) (2 (2 your) (2 grammar))) (2 (2 if) (2 (2 you) (2 (2 want) (2 it)))))) (2 :)) (2 .)))
I think inline-code sounds weird and vague in this context and would probably change it to something more specific.
(1 (2 I) (1 (1 (2 (2 (2 (2 think) (2 (2 (2 inline-code) (2 sounds)) (1 (2 (1 weird) (2 and)) (2 vague)))) (2 (2 in) (2 (2 this) (2 context)))) (2 and)) (2 (2 (2 would) (2 probably)) (2 (2 (2 change) (2 it)) (2 (2 to) (2 (2 something) (2 (2 more) (2 specific))))))) (2 .)))
Maybe inline-code...but I'm sorta guessing as I'm not really sure what you're trying to say.
(1 (2 (2 Maybe) (2 inline-code)) (1 (2 ...) (1 (1 (2 but) (1 (2 I) (1 (2 'm) (1 (2 sorta) (1 (2 guessing) (1 (2 as) (1 (2 I) (1 (2 (2 'm) (1 not)) (2 (2 really) (2 (2 sure) (2 (2 what) (2 (2 you) (2 (2 're) (2 (2 trying) (2 (2 to) (2 say)))))))))))))))) (2 .))))
inline-code was mentioned above in this diff but not explained.
(1 (2 inline-code) (2 (2 (2 was) (2 (2 (3 (2 mentioned) (3 (2 above) (2 (2 in) (2 (2 this) (2 diff))))) (2 but)) (2 (1 not) (2 explained)))) (2 .)))
However, you don't get much out of mentioning it for those who don't understand inline-code.
(2 (1 However) (1 (2 ,) (1 (2 you) (1 (1 (2 (2 do) (2 n't)) (1 (2 (2 get) (2 (2 much) (1 out))) (2 (2 of) (2 (2 (2 mentioning) (2 it)) (2 (2 for) (2 (2 those) (2 (2 who) (1 (2 (2 do) (2 n't)) (2 (2 understand) (2 inline-code)))))))))) (2 .)))))
For everyone who doesn't, something like:.
(3 (2 (2 For) (2 (2 everyone) (2 (2 who) (1 (2 does) (2 n't))))) (2 (2 ,) (2 (2 something) (2 (2 (2 like) (2 :)) (2 .)))))
would be more enlightening.
(2 (2 (2 would) (2 (2 be) (2 (2 more) (3 enlightening)))) (2 .))
If inline-code are to be mentioned, these should be changed to:.
(1 (2 (2 If) (2 (2 inline-code) (2 (2 are) (2 (2 to) (2 (2 be) (2 mentioned)))))) (2 (2 ,) (2 (2 these) (2 (2 (2 (2 should) (2 (2 be) (2 (2 changed) (2 to)))) (2 :)) (2 .)))))
inline-code
inline-code.
(2 (2 inline-code) (2 (2 inline-code) (2 .)))
inline-code... is followed by?
(1 (2 inline-code) (2 (2 ...) (2 (2 (2 is) (2 (2 followed) (2 by))) (2 ?))))
@gamazeps I'm not a native speaker either, so maybe someone else wants to way in.
(1 (1 (1 (1 (1 (2 @gamazeps) (2 (2 I) (2 (2 (2 (2 'm) (1 not)) (2 (2 a) (2 (2 native) (2 speaker)))) (2 either)))) (2 ,)) (2 so)) (2 (2 maybe) (2 (2 (2 someone) (2 else)) (2 (2 (3 wants) (2 (2 to) (2 way))) (2 in))))) (2 .))
I was actually close to suggesting "(Movie)Extra", or "Bystander" as an alternative, but my gut feeling is that it would just be better to avoid "Who cares about $person's name" altogether.
(1 (1 (2 (2 (2 (2 I) (2 (2 (2 was) (2 actually)) (2 (2 (2 (2 (2 close) (2 (2 to) (2 (2 (2 (2 suggesting) (2 '')) (2 (2 (2 -LRB-) (2 (2 Movie) (2 -RRB-))) (2 Extra))) (2 '')))) (2 ,)) (2 or)) (2 (2 ``) (2 (2 (2 Bystander) (2 '')) (2 (2 as) (2 (2 an) (2 alternative)))))))) (2 ,)) (2 but)) (1 (2 (2 my) (3 (2 gut) (2 feeling))) (1 (2 is) (1 (2 that) (1 (2 it) (1 (2 (2 would) (2 just)) (2 (3 (2 be) (4 better)) (2 (2 to) (2 (1 avoid) (2 (2 ``) (2 (2 Who) (2 (3 cares) (2 (2 (2 about) (2 (2 $) (2 person))) (2 (2 (2 's) (2 (2 name) (2 ''))) (2 altogether))))))))))))))) (2 .))
(The Peon wording in particular invokes "We are the mighty rulers, we don't care about those simple people" imagery in my head)
Last part to edit and I'll update the PR :)
All the types should be in backticks.
(1 (2 -LRB-) (1 (2 (2 The) (2 (2 Peon) (2 wording))) (1 (2 (2 in) (2 particular)) (0 (1 (2 invokes) (1 (2 ``) (1 (1 (1 (2 (2 (2 We) (2 (2 are) (2 (2 the) (2 (2 mighty) (2 rulers))))) (2 ,)) (2 (2 we) (1 (2 (2 do) (2 n't)) (2 (2 (3 care) (2 (2 about) (2 (2 those) (3 (2 simple) (2 (2 people) (2 (2 '') (2 imagery))))))) (2 (2 in) (2 (2 (2 my) (2 (2 head) (2 (2 -RRB-) (2 (2 Last) (2 part))))) (2 (2 to) (1 edit)))))))) (2 and)) (1 (2 I) (1 (2 'll) (1 (2 update) (1 (2 (2 the) (2 (2 PR) (2 :-RRB-))) (2 (2 (2 All) (2 (2 the) (2 types))) (2 (2 should) (2 (2 be) (2 (2 in) (2 backticks)))))))))))) (2 .)))))
And there isn't a 'name field' here, so that characterization is wrong.
(1 (2 And) (1 (2 there) (0 (0 (1 (1 (1 (1 (2 is) (2 n't)) (2 (2 a) (2 (2 `) (2 (2 name) (2 (2 field) (2 ')))))) (2 here)) (2 ,)) (1 (2 so) (1 (2 that) (1 (2 characterization) (1 (2 is) (1 wrong)))))) (2 .))))
@steveklabnik edited :)
I like this idea, but naming it inline-code introduces shadowing.
(1 (1 (1 (1 (1 (2 @steveklabnik) (3 (2 edited) (2 (2 (2 :-RRB-) (2 I)) (2 (2 like) (2 (2 this) (2 idea)))))) (2 ,)) (2 but)) (2 (2 (2 naming) (2 (2 it) (2 inline-code))) (2 (3 introduces) (2 shadowing)))) (2 .))
This is why I made the previous one inline-code.
(1 (2 This) (2 (2 (2 is) (2 (2 why) (2 (2 I) (2 (2 made) (2 (2 the) (2 (2 previous) (2 (2 one) (2 inline-code)))))))) (2 .)))
Can we maybe do something similar here?
(2 (2 (2 (2 (2 Can) (2 we)) (2 maybe)) (2 (2 (2 do) (2 (2 something) (2 similar))) (2 here))) (2 ?))
Also the 'as you can guess' makes this flow a little awkward to me.
(1 (2 (2 (2 (2 (2 Also) (2 the)) (2 `)) (2 (2 (2 as) (2 you)) (2 (2 can) (2 guess)))) (2 ')) (1 (1 (2 makes) (2 (2 this) (1 (2 (2 flow) (1 (2 a) (1 (2 little) (1 awkward)))) (2 (2 to) (3 me))))) (2 .)))
I do think this is a significnatly better example, thank you :)
Having this kind of derogatory language in a guide doesn't really sit well with me.
(1 (2 I) (2 (2 (2 do) (2 (2 think) (3 (2 this) (3 (3 (3 (2 is) (3 (2 a) (2 (2 (2 significnatly) (4 better)) (2 example)))) (2 ,)) (1 (3 thank) (1 (2 you) (1 (2 :-RRB-) (1 (2 Having) (1 (2 (2 (2 this) (3 kind)) (2 (2 of) (2 (2 (2 derogatory) (2 language)) (2 (2 in) (2 (2 a) (2 guide)))))) (1 (1 (1 (2 does) (2 n't)) (2 really)) (3 (3 (2 sit) (3 well)) (2 (2 with) (3 me))))))))))))) (2 .)))
I'm sure there is an example to be found not questioning the human dignity of certain classes (as historical as the example may be).
(1 (2 I) (1 (2 (2 'm) (2 (2 sure) (2 (2 there) (2 (2 is) (2 (2 an) (2 (2 example) (2 (2 to) (2 (2 be) (2 (2 found) (2 (1 not) (2 (2 questioning) (2 (2 (2 the) (2 (2 human) (2 dignity))) (2 (2 of) (2 (2 (3 certain) (2 classes)) (2 (2 -LRB-) (2 (2 (2 as) (2 (2 (2 historical) (2 (2 as) (2 (2 the) (2 example)))) (2 (2 may) (2 be)))) (2 -RRB-))))))))))))))))) (2 .)))
Let's replace 'it' with "match expressions"
These two would be inline-code not inline-code.
(1 (1 (2 Let) (2 (2 's) (2 (2 (2 (2 (2 replace) (2 `)) (2 it)) (2 ')) (2 (2 with) (2 (2 ``) (1 (2 (2 (2 match) (2 expressions)) (2 '')) (1 (2 (2 These) (2 two)) (2 (2 would) (2 (2 (2 be) (2 inline-code)) (2 (1 not) (2 inline-code))))))))))) (2 .))
I like adding the reference to sum types here, but I would add a parenthetical saying something like "the type theory term for enums) and remove the other parenthetical.
(1 (1 (1 (1 (1 (2 I) (1 (2 like) (1 (3 adding) (2 (2 the) (2 (2 reference) (2 (2 to) (2 (2 (2 sum) (2 types)) (2 here)))))))) (2 ,)) (2 but)) (1 (2 I) (2 (2 would) (2 (2 (2 (2 (2 (3 add) (2 (2 a) (2 (2 parenthetical) (2 (2 saying) (2 something))))) (2 (2 (2 like) (2 ``)) (2 (2 (2 the) (2 (2 type) (2 (2 theory) (2 term)))) (2 (2 for) (2 enums))))) (2 -RRB-)) (2 and)) (2 (2 remove) (2 (2 the) (2 (2 other) (2 parenthetical)))))))) (2 .))
Also, the inline-code shouldn't be inside the backticks, so add two more :)
And there shouldn't be a space before the inline-code.
(1 (2 Also) (1 (2 ,) (1 (1 (1 (1 (2 (2 the) (2 inline-code)) (1 (2 (2 should) (2 n't)) (2 (2 (2 (2 be) (2 (2 inside) (2 (2 the) (2 backticks)))) (2 ,)) (2 (2 so) (2 (3 add) (2 (2 two) (2 (2 more) (2 :-RRB-)))))))) (2 And)) (1 (2 there) (1 (2 (2 should) (2 n't)) (2 (2 be) (2 (2 (2 a) (2 space)) (2 (2 before) (2 (2 the) (2 inline-code)))))))) (2 .))))
Sum types were used before (first line of the enum part).
(2 (2 (2 Sum) (2 types)) (2 (2 (2 were) (2 (2 used) (2 (2 before) (2 (2 -LRB-) (2 (2 (2 (2 first) (2 line)) (2 (2 of) (2 (2 the) (2 (2 enum) (2 part))))) (2 -RRB-)))))) (2 .)))
What I tried to say was that enum allow us to have a better way both to represent information and use that representation.
(2 (2 (2 What) (2 (2 I) (2 (2 tried) (2 (2 to) (2 say))))) (2 (2 (2 was) (2 (2 that) (2 (2 enum) (2 (2 allow) (3 (3 us) (2 (2 to) (2 (2 have) (2 (2 (2 a) (2 (4 better) (2 way))) (2 (2 both) (2 (2 to) (2 (2 (3 (2 represent) (2 information)) (2 and)) (2 (2 use) (2 (2 that) (2 representation)))))))))))))) (2 .)))
Did we bring up 'sum types' already, or is this the first time mentioning them?
(1 (2 (1 (2 (2 (2 (2 Did) (2 we)) (2 (2 (2 (3 bring) (2 up)) (2 (2 `) (2 (2 sum) (2 (2 types) (2 '))))) (2 already))) (2 ,)) (2 or)) (2 (2 (2 is) (2 (2 this) (2 (2 the) (2 (2 first) (2 time))))) (2 (2 mentioning) (2 them)))) (2 ?))
Also "more simpler" is poor form, and this sentence is kind of a run-on.
(1 (2 Also) (1 (1 (1 (1 (1 (2 ``) (1 (2 (2 more) (2 simpler)) (1 (2 '') (1 (2 is) (1 (1 poor) (2 form)))))) (2 ,)) (2 and)) (2 (2 (2 this) (2 sentence)) (3 (2 is) (2 (3 kind) (2 (2 of) (2 (2 a) (2 run-on))))))) (2 .)))
No backticks for this block?
(1 (2 (2 (1 No) (2 backticks)) (2 (2 for) (2 (2 this) (2 block)))) (2 ?))
This change makes it worse, less pronouns are better.
(1 (1 (2 (2 This) (2 change)) (1 (2 makes) (1 (2 it) (1 worse)))) (2 (2 ,) (2 (2 (2 less) (2 pronouns)) (2 (3 (2 are) (4 better)) (2 .)))))
Thanks for taking some initiative on this!
(3 (3 (2 Thanks) (2 (2 for) (2 (2 (2 taking) (2 (2 some) (2 initiative))) (2 (2 on) (2 this))))) (2 !))
Closes #18169.
(2 (2 (2 Closes) (2 (2 #) (2 18169))) (2 .))
This just keeps getting better.
(3 (2 This) (3 (2 just) (3 (3 (2 keeps) (3 (2 getting) (4 better))) (2 .))))
I have a few more things, but they're all very small, and I'm really happy with how this is turning out.
(3 (3 (2 (2 (2 (2 I) (2 (2 have) (2 (2 a) (2 (2 few) (2 (2 more) (2 things)))))) (2 ,)) (2 but)) (3 (2 (2 (2 (2 they) (2 (2 (2 're) (2 all)) (2 (2 very) (2 small)))) (2 ,)) (2 and)) (3 (2 I) (3 (2 'm) (3 (2 really) (3 (4 happy) (2 (2 with) (2 (2 how) (2 (2 this) (2 (2 is) (2 (2 turning) (1 out)))))))))))) (2 .))
What's more inline-code is the first feature listed in rust home page so it seems rather important to mention them.
(3 (2 (2 What) (2 (2 's) (2 (2 more) (2 inline-code)))) (3 (3 (2 is) (3 (2 (2 the) (2 (2 first) (2 feature))) (3 (2 (2 listed) (2 (2 in) (2 (2 rust) (2 (2 home) (2 page))))) (3 (2 so) (3 (2 it) (3 (2 seems) (3 (2 rather) (3 (2 important) (2 (2 to) (2 (2 mention) (2 them))))))))))) (2 .)))
Plus, IMHO, it can't harm to call enums what they are, teaching some (basic) type theory is a good thing I think (it doesn't cost anything and teaches stuff :) )
inline-code.
(1 (2 Plus) (2 (2 ,) (1 (2 IMHO) (2 (2 ,) (1 (2 it) (1 (2 (2 (2 ca) (2 n't)) (2 (1 harm) (2 (2 to) (2 (2 call) (2 (2 enums) (1 (2 what) (1 (2 they) (1 (2 are) (2 (2 ,) (2 (2 teaching) (3 (2 (2 some) (2 (2 -LRB-) (2 (2 basic) (2 (2 -RRB-) (2 (2 type) (2 theory)))))) (3 (2 is) (3 (3 (2 a) (3 (3 good) (2 thing))) (2 (2 I) (2 (2 (2 think) (1 (2 -LRB-) (2 (1 (2 it) (1 (1 (1 (1 (2 does) (2 n't)) (2 (2 cost) (2 anything))) (2 and)) (2 (2 teaches) (2 (2 stuff) (2 :-RRB-))))) (2 -RRB-)))) (2 inline-code)))))))))))))))) (2 .)))))))
Closes #18169.
(2 (2 (2 Closes) (2 (2 #) (2 18169))) (2 .))
Ah, I see it now.
(2 (2 Ah) (3 (2 ,) (3 (2 I) (3 (2 (3 (2 see) (2 it)) (2 now)) (2 .)))))
@Florob I meant it as in a movie (wher eyou have the good guy, the bad guy and the others ^^)
If the joke is unsovory (I'm not a native english speaker so I may have failed my joke) i'll find new names :)
I would change this to 
duplicate of #32368.
(1 (1 (1 (2 @Florob) (1 (2 I) (1 (2 (2 meant) (2 it)) (1 (2 as) (1 (2 in) (1 (2 (2 a) (2 movie)) (1 (2 -LRB-) (1 (1 (2 (2 wher) (2 eyou)) (1 (2 have) (1 (1 (1 (2 (2 (2 the) (3 (3 good) (2 guy))) (2 ,)) (1 (2 the) (1 (0 bad) (2 guy)))) (2 and)) (2 (2 the) (2 (2 others) (2 (2 ^) (2 ^))))))) (2 -RRB-))))))))) (1 (2 (2 If) (2 (2 (2 the) (1 joke)) (2 (2 is) (2 unsovory)))) (2 (1 (2 -LRB-) (2 (1 (2 I) (1 (2 (2 (2 'm) (1 not)) (2 (2 a) (2 (2 native) (2 (2 english) (2 speaker))))) (1 (2 so) (1 (2 I) (1 (2 may) (1 (2 have) (1 (1 failed) (2 (2 my) (1 joke))))))))) (2 -RRB-))) (3 (2 i) (3 (2 'll) (2 (2 find) (2 (3 new) (2 names)))))))) (1 (1 (2 :-RRB-) (1 (2 I) (1 (2 would) (1 (2 change) (2 (2 this) (2 (2 to) (2 (2 duplicate) (2 (2 of) (2 (2 #) (2 32368)))))))))) (2 .)))
Arithmetic expressions trailing a conditional expression are not accepted as the result statement for a block.
(1 (2 (2 (2 Arithmetic) (2 expressions)) (2 (2 trailing) (2 (2 a) (2 (2 conditional) (2 expression))))) (1 (1 (2 (2 are) (1 not)) (2 (2 accepted) (2 (2 as) (2 (2 (2 the) (2 (2 result) (2 statement))) (2 (2 for) (2 (2 a) (2 block))))))) (2 .)))
For example, the following function compiles fine:.
(3 (2 (2 For) (2 example)) (2 (2 ,) (3 (2 (2 the) (2 (2 following) (2 function))) (3 (3 (3 (2 compiles) (3 fine)) (2 :)) (2 .)))))
but the next function fails, even though they appear semantically equivalent:.
(1 (2 but) (0 (2 (2 the) (2 (2 next) (2 function))) (0 (0 (0 (0 (0 fails) (2 ,)) (2 (2 even) (2 (2 though) (2 (2 they) (2 (2 appear) (2 (2 semantically) (2 equivalent))))))) (2 :)) (2 .))))
The errors in this case are:.
(2 (2 (2 (2 The) (1 errors)) (2 (2 in) (2 (2 this) (2 case)))) (2 (2 (2 are) (2 :)) (2 .)))
However, if I assign the expression to a variable, inference once again succeeds:.
(2 (1 However) (3 (2 ,) (3 (2 (2 if) (2 (2 I) (2 (2 (2 assign) (2 (2 the) (2 expression))) (2 (2 to) (2 (2 a) (2 variable)))))) (3 (2 ,) (3 (2 inference) (3 (2 (2 once) (2 again)) (3 (3 (3 succeeds) (2 :)) (2 .))))))))
Any idea what is up with this edge case?
(1 (3 Any) (1 (1 (2 idea) (1 (2 what) (1 (2 (2 is) (2 up)) (1 (2 with) (1 (2 this) (3 (3 edge) (2 case))))))) (2 ?)))
If I remember correctly this is behaviour is deliberate: When starting to parse an if statement, the parser has to decide whether it should be parsed as a statement (the type of which is inline-code) or as an expression.
(1 (1 (1 (1 (1 (2 If) (3 (2 I) (3 (2 remember) (3 correctly)))) (2 (2 this) (2 (2 is) (2 (2 behaviour) (2 (2 is) (2 deliberate)))))) (2 :)) (1 (2 (2 When) (2 (3 starting) (2 (2 to) (2 (2 parse) (2 (2 an) (2 (2 if) (2 statement))))))) (1 (2 ,) (1 (2 (2 the) (2 parser)) (1 (2 has) (2 (2 to) (1 (2 decide) (2 (2 whether) (2 (2 it) (2 (2 should) (2 (2 be) (2 (2 parsed) (2 (2 (2 (2 (2 as) (2 (2 a) (2 statement))) (2 (2 -LRB-) (2 (2 (2 (2 the) (2 (2 type) (2 (2 of) (2 which)))) (2 (2 is) (2 inline-code))) (2 -RRB-)))) (2 or)) (2 (2 as) (2 (2 an) (2 expression)))))))))))))))) (2 .))
So in you first and third case the if statement is parsed as an expression but in you second case it is parsed as a statement.
(1 (2 (2 So) (2 (2 in) (2 (2 (2 (2 you) (2 (2 first) (2 (2 and) (2 (2 third) (2 case))))) (2 the)) (2 (2 if) (2 (2 statement) (2 (2 is) (2 (2 parsed) (2 (2 as) (2 (2 an) (2 (2 expression) (2 (2 (2 but) (2 (2 in) (2 you))) (2 (2 second) (2 case))))))))))))) (3 (2 it) (3 (2 (2 is) (2 (2 parsed) (2 (2 as) (2 (2 a) (2 statement))))) (2 .))))
Otherwise this looks like a duplicate of #32368, which also has a more detailed explanation.
(2 (2 Otherwise) (3 (2 this) (3 (3 (2 looks) (3 (2 like) (3 (2 (2 a) (2 duplicate)) (3 (2 of) (3 (2 (2 (2 #) (2 32368)) (2 ,)) (3 (2 which) (3 (2 also) (3 (2 has) (3 (2 a) (3 (2 (2 more) (3 detailed)) (2 explanation))))))))))) (2 .))))
You can now do inline-code ... so this issue can be closed, thanks!
(3 (3 (2 (2 (2 You) (2 (2 (2 can) (2 now)) (2 (2 do) (2 inline-code)))) (2 ...)) (3 (2 so) (3 (2 (2 this) (2 issue)) (3 (2 can) (2 (2 (2 (2 be) (2 closed)) (2 ,)) (3 thanks)))))) (2 !))
Currently you can only create constant values of @str, like @"abc".
(3 (2 Currently) (3 (2 you) (3 (3 (2 (2 can) (2 only)) (3 (3 (3 (3 create) (2 (2 (2 constant) (2 values)) (2 (2 of) (2 @str)))) (2 ,)) (2 (2 like) (2 (2 @) (2 (2 ``) (2 (2 abc) (2 ''))))))) (2 .))))
There should be some way to turn &str and &[u8] (utf-8) values (and therefore also ~str and ~[u8] values) into @str values.
(1 (2 There) (1 (1 (2 should) (1 (2 be) (1 (2 some) (1 (2 way) (1 (2 to) (1 (2 turn) (1 (2 (2 &) (2 (2 (2 str) (2 and)) (2 &))) (1 (1 (2 -LSB-) (1 (2 (2 u8) (2 (2 -RSB-) (2 (2 (2 -LRB-) (2 (2 utf-8) (2 -RRB-))) (2 values)))) (1 (2 -LRB-) (1 (2 and) (1 (2 therefore) (2 (1 (2 (2 (2 also) (2 (2 ~) (2 str))) (2 and)) (2 (2 ~) (2 (2 -LSB-) (2 (2 u8) (2 (2 -RSB-) (2 values)))))) (2 -RRB-))))))) (2 (2 into) (2 (2 @str) (2 values))))))))))) (2 .)))
&str should carry methods that produce inline-code and inline-code, yes.
(3 (2 (3 (3 (2 &) (1 (2 str) (1 (2 should) (3 (2 carry) (2 (2 methods) (2 (2 that) (2 (2 produce) (2 (2 (2 inline-code) (2 and)) (2 inline-code))))))))) (2 ,)) (2 yes)) (2 .))
Doesn't need to be a separate general trait.
(1 (1 (2 (3 Does) (2 n't)) (2 (2 need) (2 (2 to) (2 (2 be) (2 (2 a) (2 (2 separate) (2 (2 general) (2 trait)))))))) (2 .))
I think the ToStr trait should probably take a callback-taking-inline-code, not return inline-code, fwiw.
(1 (2 I) (1 (1 (2 think) (1 (2 (2 the) (2 (2 ToStr) (2 trait))) (1 (2 (2 should) (2 probably)) (1 (2 take) (1 (1 (1 (2 (2 (2 a) (2 callback-taking-inline-code)) (2 ,)) (1 (1 not) (2 (2 return) (2 inline-code)))) (2 ,)) (2 fwiw)))))) (2 .)))
But when we have default methods the latter can be built on the former easily.
(2 (2 But) (2 (2 (2 when) (2 (2 we) (2 (2 have) (2 (2 default) (2 methods))))) (2 (2 (2 the) (2 latter)) (2 (2 (2 can) (2 (2 be) (2 (2 (2 built) (2 (2 on) (2 (2 the) (2 former)))) (3 easily)))) (2 .)))))
@pcwalton I have no objections to that.
(1 (1 (2 @pcwalton) (1 (2 I) (2 (1 (2 have) (2 (1 no) (2 objections))) (2 (2 to) (2 that))))) (2 .))
I would be happy even with just a method on &str, for now.
(3 (2 I) (3 (3 (2 would) (3 (3 (2 be) (4 happy)) (3 (2 even) (3 (2 with) (3 (2 (2 just) (2 (2 a) (2 method))) (2 (2 on) (3 (2 (2 (2 &) (2 str)) (2 ,)) (2 (2 for) (2 now))))))))) (2 .)))
Possibly a inline-code trait?
(2 (2 Possibly) (2 (2 (2 a) (2 (2 inline-code) (2 trait))) (2 ?)))
Currently the ZSH completions are quite old an nearly useless.
(1 (2 Currently) (1 (2 (2 the) (2 (2 ZSH) (2 completions))) (1 (1 (2 are) (1 (2 (2 quite) (2 (2 old) (2 (2 an) (2 nearly)))) (1 useless))) (2 .))))
This
brings them up to be compatible with current rust and makes them far
more useful.
(3 (2 This) (3 (2 (3 (2 (2 brings) (2 (2 them) (2 (2 up) (2 (2 to) (2 (2 be) (2 (3 compatible) (2 (2 with) (2 (2 current) (2 rust))))))))) (2 and)) (2 (2 makes) (2 (2 them) (2 (2 far) (2 (2 more) (2 useful)))))) (2 .)))
Closes #17305.
(2 (2 (2 Closes) (2 (2 #) (2 17305))) (2 .))
Currently the ZSH completions are quite old an nearly useless.
(1 (2 Currently) (1 (2 (2 the) (2 (2 ZSH) (2 completions))) (1 (1 (2 are) (1 (2 (2 quite) (2 (2 old) (2 (2 an) (2 nearly)))) (1 useless))) (2 .))))
This
brings them up to be compatible with current rust and makes them far
more useful.
(3 (2 This) (3 (2 (3 (2 (2 brings) (2 (2 them) (2 (2 up) (2 (2 to) (2 (2 be) (2 (3 compatible) (2 (2 with) (2 (2 current) (2 rust))))))))) (2 and)) (2 (2 makes) (2 (2 them) (2 (2 far) (2 (2 more) (2 useful)))))) (2 .)))
Closes #17305.
(2 (2 (2 Closes) (2 (2 #) (2 17305))) (2 .))
Can I force travis to try again?
(2 (2 (2 (2 Can) (2 I)) (2 (2 force) (2 (2 travis) (2 (2 to) (2 (2 try) (2 again)))))) (2 ?))
The failure wasn't mine.
(1 (1 (2 The) (0 failure)) (2 (2 (2 (2 was) (2 n't)) (2 mine)) (2 .)))
I think the travis builds have been failing for a while.
(1 (2 I) (1 (1 (2 think) (1 (2 (2 the) (2 travis)) (1 (2 builds) (1 (2 have) (1 (2 been) (1 (1 failing) (2 (2 for) (2 (2 a) (2 while))))))))) (2 .)))
I have no idea why this hasn't been fixed yet, or where the issue is.
(1 (2 I) (1 (1 (2 have) (1 (2 (1 no) (2 idea)) (1 (1 (1 (1 (2 why) (1 (2 this) (2 (2 (2 has) (2 n't)) (2 (2 been) (2 (2 fixed) (2 yet)))))) (2 ,)) (2 or)) (2 (2 where) (2 (2 (2 the) (2 issue)) (2 is)))))) (2 .)))
Huh.
(2 (2 Huh) (2 .))
Well can I get a pull in that case?
(2 (2 Well) (2 (2 (2 (2 can) (2 I)) (2 (2 get) (2 (2 (2 a) (2 pull)) (2 (2 in) (2 (2 that) (2 case)))))) (2 ?)))
Other example:.
(2 (2 Other) (2 (2 (2 example) (2 :)) (2 .)))
This example is derived from inline-code.
(2 (2 (2 This) (2 example)) (2 (2 (2 is) (2 (2 derived) (2 (2 from) (2 inline-code)))) (2 .)))
upstream llvm bug: URL.
(2 (2 (2 (2 (2 upstream) (2 (2 llvm) (2 bug))) (2 :)) (2 URL)) (2 .))
Interestingly, if you go from inline-code to an object, then the assertion is triggered.
(1 (2 Interestingly) (1 (2 ,) (1 (2 (2 if) (2 (2 you) (2 (2 (2 go) (2 (2 from) (2 inline-code))) (2 (2 to) (2 (2 an) (2 object)))))) (1 (2 ,) (1 (2 then) (2 (2 (2 the) (2 assertion)) (2 (2 (2 is) (2 triggered)) (2 .))))))))
If you go from inline-code to IR to an object (through inline-code), no assertion is triggered.
(1 (2 (2 If) (2 (2 you) (2 (2 (2 go) (2 (2 from) (2 inline-code))) (2 (2 to) (2 (2 IR) (2 (2 to) (2 (2 (2 an) (2 object)) (2 (2 -LRB-) (2 (2 (2 through) (2 inline-code)) (2 -RRB-)))))))))) (1 (2 ,) (1 (2 (1 no) (2 assertion)) (2 (2 (2 is) (2 triggered)) (2 .)))))
Maybe we've set up LLVM incorrectly?
(2 (2 Maybe) (2 (2 we) (2 (2 (2 've) (2 (2 (2 set) (2 (2 up) (2 LLVM))) (2 incorrectly))) (2 ?))))
Same error for inline-code.
(1 (1 (1 (2 Same) (1 error)) (2 (2 for) (2 inline-code))) (2 .))
This blocks inline-code on windows: cc #12745 #13439.
(1 (2 (2 (2 (2 (2 This) (2 (2 blocks) (2 inline-code))) (2 (2 on) (2 windows))) (2 :)) (2 (2 (2 cc) (2 (2 #) (2 12745))) (2 (2 #) (2 13439)))) (2 .))
Updated title and minimal example.
(2 (2 (2 Updated) (2 (2 (2 title) (2 and)) (2 (2 minimal) (2 example)))) (2 .))
(was: inline-code triggers LLVM assertion error on windows)
inline-code generates inline-code which cause error.
(1 (2 -LRB-) (1 (2 was) (1 (2 :) (1 (2 inline-code) (1 (1 (1 (2 triggers) (1 (1 (1 (2 LLVM) (1 (2 assertion) (1 error))) (2 (2 on) (2 windows))) (2 -RRB-))) (1 (2 (2 inline-code) (2 (2 generates) (2 inline-code))) (1 (2 which) (1 (2 cause) (1 error))))) (2 .))))))
----
Original: inline-code triggers LLVM assertion error on windows
cc #10872 .
(1 (2 --) (1 (1 (1 (2 (2 Original) (2 :)) (1 (1 (2 inline-code) (1 (2 triggers) (1 (2 LLVM) (1 (2 assertion) (1 error))))) (2 (2 on) (2 windows)))) (2 (2 cc) (2 (2 #) (2 10872)))) (2 .)))
We want a test though.
(1 (2 We) (2 (2 (2 (2 want) (2 (2 a) (2 test))) (2 though)) (2 .)))
Off the top of my head, looks like some sort of confusion involving drop flags.
(1 (3 (2 Off) (3 (2 (2 the) (2 top)) (2 (2 of) (2 (2 my) (2 head))))) (1 (2 ,) (1 (2 looks) (2 (1 (2 like) (2 (2 (2 (2 some) (2 sort)) (2 (2 of) (2 confusion))) (2 (2 involving) (2 (2 drop) (2 flags))))) (2 .)))))
Fixed now.
(2 (2 (2 Fixed) (2 now)) (2 .))
Confirmed working in latest nightly.
(2 (2 (2 Confirmed) (2 (2 working) (2 (2 in) (2 (2 latest) (2 nightly))))) (2 .))
Yes, it works when adding inline-code to the struct.
(3 (2 Yes) (3 (2 ,) (3 (2 it) (3 (3 (2 works) (2 (2 when) (3 (3 (3 adding) (2 inline-code)) (2 (2 to) (2 (2 the) (2 struct)))))) (2 .)))))
This doesn't yet work with inline-code, but will once filling drop is removed completely (after old trans is removed, presumably).
(1 (2 This) (1 (1 (1 (1 (1 (1 (1 (2 does) (2 n't)) (2 yet)) (2 (2 work) (2 (2 with) (2 inline-code)))) (2 ,)) (2 but)) (1 (2 will) (2 (2 once) (2 (3 filling) (1 (2 drop) (1 (2 is) (2 (2 (2 removed) (2 completely)) (2 (2 -LRB-) (2 (1 (2 after) (1 (2 (2 old) (2 trans)) (2 (2 is) (2 (2 (2 removed) (2 ,)) (2 presumably))))) (2 -RRB-)))))))))) (2 .)))
gives:.
(2 (2 (2 gives) (2 :)) (2 .))
Hey folks,
This patch series does some work on the json decoder, specifically with auto decoding of enums.
(1 (2 Hey) (1 (2 folks) (1 (2 ,) (1 (2 (2 This) (2 (2 patch) (2 series))) (2 (2 (2 (2 (2 does) (2 (2 (2 some) (2 work)) (2 (2 on) (2 (2 the) (2 (2 json) (2 decoder)))))) (2 ,)) (2 (2 specifically) (2 (2 with) (2 (2 (2 auto) (2 decoding)) (2 (2 of) (2 enums)))))) (2 .))))))
Previously, we would take this code:.
(2 (2 Previously) (2 (2 ,) (2 (2 we) (2 (2 (2 (2 would) (2 (2 take) (2 (2 this) (2 code)))) (2 :)) (2 .)))))
and would encode a value of this enum to either inline-code or inline-code.
(1 (2 and) (1 (1 (2 would) (2 (2 (2 encode) (3 (2 (2 a) (2 value)) (2 (2 of) (2 (2 this) (2 enum))))) (2 (2 to) (2 (2 either) (2 (2 (2 inline-code) (2 or)) (2 inline-code)))))) (2 .)))
I've changed this to inline-code or inline-code.
(2 (2 I) (2 (2 (2 've) (2 (2 (2 changed) (2 this)) (2 (2 to) (2 (2 (2 inline-code) (2 or)) (2 inline-code))))) (2 .)))
This matches the style of the O'Caml json library json-wheel.
(2 (2 This) (2 (2 (2 matches) (2 (2 (2 the) (2 style)) (2 (2 of) (2 (2 the) (2 (2 O'Caml) (2 (2 json) (2 (2 library) (2 json-wheel)))))))) (2 .)))
I've added tests to make sure all this work.
(3 (2 I) (3 (3 (2 've) (3 (3 (2 added) (2 tests)) (2 (2 to) (3 (2 (2 make) (2 sure)) (2 (2 all) (2 (2 this) (2 work))))))) (2 .)))
In order to make this change, I added passing a inline-code vec to inline-code so the json decoder can convert the name of a variant into it's position.
(1 (2 (2 (2 In) (2 order)) (2 (2 to) (2 (2 make) (2 (2 this) (2 change))))) (1 (2 ,) (1 (2 I) (1 (1 (2 added) (1 (2 (2 passing) (2 (2 a) (2 (2 inline-code) (2 vec)))) (1 (2 to) (1 (2 inline-code) (1 (2 so) (3 (2 (2 the) (2 (2 json) (2 decoder))) (2 (2 can) (3 (2 (2 convert) (2 (2 (2 the) (2 name)) (2 (2 of) (2 (2 a) (2 variant))))) (2 (2 into) (2 (2 (2 it) (2 's)) (2 position))))))))))) (2 .)))))
I also changed the impl of inline-code for inline-code to have the right upper casing.
(1 (2 I) (1 (2 also) (1 (1 (2 (2 (2 changed) (2 (2 (2 the) (2 impl)) (2 (2 of) (2 inline-code)))) (2 (2 for) (2 inline-code))) (2 (2 to) (2 (2 have) (2 (2 the) (3 (3 right) (2 (2 upper) (2 casing))))))) (2 .))))
I also did some work on the parser, which allows for inline-code statements (#5572), fixed the pretty printer properly expanding inline-code expressions, and removed inline-code, which doesn't appear to be used anymore.
(1 (2 I) (1 (2 also) (1 (1 (2 (2 did) (2 (2 some) (2 work))) (1 (2 on) (1 (2 (2 (2 the) (2 parser)) (2 ,)) (1 (2 which) (1 (2 allows) (1 (2 for) (1 (1 (1 (1 (2 (2 (2 inline-code) (2 statements)) (2 (2 -LRB-) (2 (2 (2 #) (2 5572)) (2 -RRB-)))) (2 ,)) (3 (3 (3 (3 (2 (2 fixed) (2 (2 the) (2 (4 pretty) (2 printer)))) (2 (2 properly) (2 (2 expanding) (2 (2 inline-code) (2 expressions))))) (2 ,)) (2 and)) (2 (2 removed) (2 inline-code)))) (2 ,)) (1 (2 which) (1 (1 (2 does) (2 n't)) (2 (2 appear) (2 (2 to) (2 (2 be) (2 (2 used) (2 anymore)))))))))))))) (2 .))))
Hey folks,
This patch series does some work on the json decoder, specifically with auto decoding of enums.
(1 (2 Hey) (1 (2 folks) (1 (2 ,) (1 (2 (2 This) (2 (2 patch) (2 series))) (2 (2 (2 (2 (2 does) (2 (2 (2 some) (2 work)) (2 (2 on) (2 (2 the) (2 (2 json) (2 decoder)))))) (2 ,)) (2 (2 specifically) (2 (2 with) (2 (2 (2 auto) (2 decoding)) (2 (2 of) (2 enums)))))) (2 .))))))
Previously, we would take this code:.
(2 (2 Previously) (2 (2 ,) (2 (2 we) (2 (2 (2 (2 would) (2 (2 take) (2 (2 this) (2 code)))) (2 :)) (2 .)))))
and would encode a value of this enum to either inline-code or inline-code.
(1 (2 and) (1 (1 (2 would) (2 (2 (2 encode) (3 (2 (2 a) (2 value)) (2 (2 of) (2 (2 this) (2 enum))))) (2 (2 to) (2 (2 either) (2 (2 (2 inline-code) (2 or)) (2 inline-code)))))) (2 .)))
I've changed this to inline-code or inline-code.
(2 (2 I) (2 (2 (2 've) (2 (2 (2 changed) (2 this)) (2 (2 to) (2 (2 (2 inline-code) (2 or)) (2 inline-code))))) (2 .)))
This matches the style of the O'Caml json library json-wheel.
(2 (2 This) (2 (2 (2 matches) (2 (2 (2 the) (2 style)) (2 (2 of) (2 (2 the) (2 (2 O'Caml) (2 (2 json) (2 (2 library) (2 json-wheel)))))))) (2 .)))
I've added tests to make sure all this work.
(3 (2 I) (3 (3 (2 've) (3 (3 (2 added) (2 tests)) (2 (2 to) (3 (2 (2 make) (2 sure)) (2 (2 all) (2 (2 this) (2 work))))))) (2 .)))
In order to make this change, I added passing a inline-code vec to inline-code so the json decoder can convert the name of a variant into it's position.
(1 (2 (2 (2 In) (2 order)) (2 (2 to) (2 (2 make) (2 (2 this) (2 change))))) (1 (2 ,) (1 (2 I) (1 (1 (2 added) (1 (2 (2 passing) (2 (2 a) (2 (2 inline-code) (2 vec)))) (1 (2 to) (1 (2 inline-code) (1 (2 so) (3 (2 (2 the) (2 (2 json) (2 decoder))) (2 (2 can) (3 (2 (2 convert) (2 (2 (2 the) (2 name)) (2 (2 of) (2 (2 a) (2 variant))))) (2 (2 into) (2 (2 (2 it) (2 's)) (2 position))))))))))) (2 .)))))
I also changed the impl of inline-code for inline-code to have the right upper casing.
(1 (2 I) (1 (2 also) (1 (1 (2 (2 (2 changed) (2 (2 (2 the) (2 impl)) (2 (2 of) (2 inline-code)))) (2 (2 for) (2 inline-code))) (2 (2 to) (2 (2 have) (2 (2 the) (3 (3 right) (2 (2 upper) (2 casing))))))) (2 .))))
I also did some work on the parser, which allows for inline-code statements (#5572), fixed the pretty printer properly expanding inline-code expressions, and removed inline-code, which doesn't appear to be used anymore.
(1 (2 I) (1 (2 also) (1 (1 (2 (2 did) (2 (2 some) (2 work))) (1 (2 on) (1 (2 (2 (2 the) (2 parser)) (2 ,)) (1 (2 which) (1 (2 allows) (1 (2 for) (1 (1 (1 (1 (2 (2 (2 inline-code) (2 statements)) (2 (2 -LRB-) (2 (2 (2 #) (2 5572)) (2 -RRB-)))) (2 ,)) (3 (3 (3 (3 (2 (2 fixed) (2 (2 the) (2 (4 pretty) (2 printer)))) (2 (2 properly) (2 (2 expanding) (2 (2 inline-code) (2 expressions))))) (2 ,)) (2 and)) (2 (2 removed) (2 inline-code)))) (2 ,)) (1 (2 which) (1 (1 (2 does) (2 n't)) (2 (2 appear) (2 (2 to) (2 (2 be) (2 (2 used) (2 anymore)))))))))))))) (2 .))))
I did consider this idea, but it's very brittle.
(2 (2 (2 (2 (2 (2 I) (2 (2 did) (2 (2 consider) (2 (2 this) (2 idea))))) (2 ,)) (2 but)) (2 (2 it) (2 (2 's) (2 (2 very) (2 brittle))))) (2 .))
You'll need to run this hypothetical converter every time you modify your own projects, taking care to keep it in sync with your crate file.
(1 (2 You) (1 (1 (2 'll) (1 (1 (1 (2 need) (1 (2 to) (1 (1 (2 (2 run) (2 (2 this) (2 (2 hypothetical) (2 converter)))) (2 (2 every) (2 time))) (2 (2 you) (2 (2 modify) (2 (2 your) (2 (2 own) (2 projects)))))))) (2 ,)) (3 (2 (2 taking) (3 care)) (2 (2 to) (2 (2 (2 keep) (2 it)) (2 (2 in) (2 (2 sync) (2 (2 with) (2 (2 your) (2 (2 crate) (2 file))))))))))) (2 .)))
On the server side: 0install doesn't support downloading git repositories directly, only tarballs.
(1 (2 (2 On) (2 (2 the) (2 (2 server) (2 side)))) (1 (2 :) (1 (2 0install) (1 (2 (1 (2 does) (2 n't)) (1 (2 (2 (2 (2 support) (2 (2 downloading) (2 (2 git) (2 repositories)))) (2 directly)) (2 ,)) (2 (2 only) (2 tarballs)))) (2 .)))))
So we have to serve archives from the server as well.
(1 (2 So) (2 (2 we) (2 (2 (2 have) (2 (2 to) (2 (2 (2 (2 serve) (2 archives)) (2 (2 from) (2 (2 the) (2 server)))) (2 (2 as) (3 well))))) (2 .))))
There's also a leaky abstraction here.
(1 (2 There) (2 (2 (2 (2 's) (2 also)) (2 (2 (2 a) (2 (2 leaky) (2 abstraction))) (2 here))) (2 .)))
Despite our best attempts at hiding the 0install syntax, the user will need to learn about the format eventually, when they run into the limits of our annotation system.
(1 (2 (2 Despite) (3 (3 (2 our) (3 (4 best) (2 attempts))) (2 (2 at) (2 (2 hiding) (2 (2 the) (2 (2 0install) (2 syntax))))))) (2 (2 ,) (2 (2 (2 the) (2 user)) (2 (2 (2 will) (2 (2 need) (2 (2 to) (2 (2 (2 (2 (2 (2 learn) (2 about)) (2 (2 the) (2 format))) (2 eventually)) (2 ,)) (2 (2 when) (2 (2 they) (2 (2 run) (2 (2 into) (2 (2 (2 the) (2 limits)) (2 (2 of) (2 (2 our) (2 (2 annotation) (2 system))))))))))))) (2 .)))))
Then they'll have two syntaxes to worry about.
(2 (2 Then) (2 (2 they) (2 (2 (2 'll) (2 (2 (2 have) (2 (2 two) (2 syntaxes))) (2 (2 to) (2 (1 worry) (2 about))))) (2 .))))
That's possible, and a bit more elegant, but difficult.
(2 (2 That) (2 (2 (2 's) (2 (3 (3 (3 (2 (2 (2 possible) (2 ,)) (2 and)) (3 (2 (2 a) (2 bit)) (3 (2 more) (4 elegant)))) (2 ,)) (2 but)) (1 difficult))) (2 .)))
The existing code seems to be tightly coupled to the XML representation, so it'll take a bit of hacking to work.
(3 (3 (2 (2 (2 (2 (2 The) (2 (2 existing) (2 code))) (2 (2 seems) (2 (2 to) (2 (2 be) (2 (2 tightly) (2 (2 coupled) (2 (2 to) (2 (2 the) (2 (2 XML) (2 representation)))))))))) (2 ,)) (2 so)) (3 (2 it) (2 (2 'll) (3 (2 (2 take) (2 (2 (2 a) (2 bit)) (2 (2 of) (2 hacking)))) (2 (2 to) (2 work)))))) (2 .))
I've given up with 0install, at least for now.
(2 (2 I) (2 (2 (2 've) (2 (2 (2 (2 given) (2 up)) (2 (2 with) (2 (2 (2 0install) (2 ,)) (2 (2 at) (1 least))))) (2 (2 for) (2 now)))) (2 .)))
Feel free to pick up where I left off.
(1 (2 Feel) (2 (2 (3 free) (1 (2 to) (1 (2 (2 pick) (2 up)) (1 (2 where) (1 (2 I) (2 (2 left) (1 off))))))) (2 .)))
Packaging is not a 1.0 issue.
(1 (2 Packaging) (1 (1 (1 (2 is) (1 not)) (2 (2 a) (2 (2 1.0) (2 issue)))) (2 .)))
Assigning P-high.
(2 (2 Assigning) (2 (2 P-high) (2 .)))
I had a chance yesterday night to explore 0install, after a discussion earlier in #10041.
(3 (2 I) (3 (3 (2 had) (3 (2 (2 a) (2 (2 chance) (2 (2 yesterday) (2 night)))) (2 (2 to) (2 (2 (2 (2 explore) (2 0install)) (2 ,)) (2 (2 after) (2 (2 (2 (2 a) (2 discussion)) (2 earlier)) (2 (2 in) (2 (2 #) (2 10041))))))))) (2 .)))
There are a few ways around the issues you mentioned concerning the XML files: we could implement a linter to check and bound the DOF, we could write a converter to convert the current annotations to this XML format (possibly server-side), or fork 0install and implement json.
(1 (1 (2 (2 (2 There) (2 (2 are) (2 (2 (2 a) (2 (2 few) (2 ways))) (2 (2 around) (2 (2 (2 the) (2 issues)) (2 (2 you) (2 (2 mentioned) (2 (2 concerning) (2 (2 the) (2 (2 XML) (2 files))))))))))) (2 :)) (2 (2 we) (1 (2 could) (1 (2 implement) (1 (2 a) (1 (2 linter) (1 (2 to) (1 (1 (1 (3 (2 (2 (3 check) (2 and)) (3 bound)) (2 (2 the) (2 DOF))) (1 (2 ,) (1 (1 (2 we) (1 (2 could) (1 (2 write) (1 (2 a) (1 (2 converter) (1 (2 to) (1 (3 (2 (2 convert) (2 (2 the) (2 (2 current) (2 annotations)))) (2 (2 to) (2 (2 this) (2 (2 XML) (2 format))))) (2 (2 -LRB-) (2 (2 possibly) (2 (2 server-side) (2 -RRB-))))))))))) (2 ,)))) (2 or)) (2 (2 (2 (2 fork) (2 0install)) (2 and)) (2 (2 implement) (2 json))))))))))) (2 .))
I must say that 0install looks very complete, but I haven't had the chance/time to really use it.
(1 (1 (2 (2 (1 (2 I) (1 (2 must) (2 (2 say) (1 (2 that) (1 (2 0install) (3 (2 looks) (3 (2 very) (3 complete)))))))) (2 ,)) (2 but)) (1 (2 I) (1 (2 (2 have) (2 n't)) (1 (2 (2 had) (2 (2 the) (2 chance/time))) (2 (2 to) (2 (2 really) (2 (2 use) (2 it)))))))) (2 .))
I'm looking forward to your experimentations.
(2 (2 I) (2 (2 (2 'm) (2 (2 (2 looking) (2 forward)) (2 (2 to) (2 (2 your) (2 experimentations))))) (2 .)))
.
(2 .)
This seems a good field explore.
(3 (2 This) (3 (3 (2 seems) (3 (3 (2 a) (3 (3 good) (2 field))) (2 explore))) (2 .)))
I'm not a 0install expert, but I like the user capabilities and system manager integration.
(1 (1 (1 (1 (1 (2 I) (1 (2 (2 'm) (1 not)) (3 (2 a) (3 (2 0install) (2 expert))))) (2 ,)) (2 but)) (2 (2 I) (2 (2 like) (2 (2 (2 (2 the) (2 (2 user) (2 capabilities))) (2 and)) (2 (2 system) (2 (2 manager) (2 integration))))))) (2 .))
OTOH, from what I have read this would solve only the binary-distibution problem, while source-building is still relying on other tools.
(1 (3 (2 (2 OTOH) (2 ,)) (2 (2 (2 from) (2 what)) (2 (2 I) (2 (2 have) (2 (2 read) (2 this)))))) (1 (1 (2 would) (1 (1 (1 (2 solve) (1 (2 only) (2 (2 the) (2 (2 binary-distibution) (1 problem))))) (2 ,)) (2 (2 while) (2 (2 source-building) (2 (2 (2 is) (2 still)) (2 (2 relying) (2 (2 on) (2 (2 other) (2 tools))))))))) (2 .)))
Zero Install is a robust cross-platform package manager.
(3 (2 (2 Zero) (2 Install)) (3 (3 (2 is) (3 (2 a) (3 (3 robust) (2 (2 cross-platform) (2 (2 package) (2 manager)))))) (2 .)))
It will be able to handle external dependencies on native libraries well and there are already many packages available.
(1 (1 (3 (3 (2 It) (3 (2 will) (2 (2 be) (2 (3 able) (2 (2 to) (2 (2 (2 (2 handle) (2 (2 external) (2 dependencies))) (2 (2 on) (2 (2 native) (2 libraries)))) (3 well))))))) (2 and)) (2 (2 there) (2 (2 (2 are) (2 already)) (2 (2 (2 many) (2 packages)) (3 available))))) (2 .))
It has support for dependency handling, package signing, tooling for maintaining repositories, coexisting package versions, and even graphical tools.
(1 (2 It) (0 (1 (2 has) (1 (1 (2 support) (1 (2 for) (1 (1 (2 (2 (2 dependency) (2 handling)) (2 ,)) (2 (2 package) (3 signing))) (2 ,)))) (1 (2 tooling) (1 (2 for) (1 (2 maintaining) (1 (1 (1 (1 (2 (2 repositories) (2 ,)) (2 (2 coexisting) (2 (2 package) (2 versions)))) (2 ,)) (2 and)) (2 (2 even) (2 (2 graphical) (2 tools))))))))) (2 .)))
It also has optional integration with the system package manager via PackageKit to avoid duplication where possible.
(1 (2 It) (1 (2 also) (1 (1 (2 has) (1 (3 (2 (2 optional) (2 integration)) (3 (2 with) (3 (2 (2 the) (2 (2 system) (2 (2 package) (2 manager)))) (2 (2 via) (2 PackageKit))))) (1 (2 to) (1 (2 (1 avoid) (2 duplication)) (2 (2 where) (2 possible)))))) (2 .))))
I don't think we should try to rebuild this ourselves.
(2 (2 I) (2 (2 (2 (2 do) (2 n't)) (2 (2 think) (2 (2 we) (2 (2 should) (2 (2 (2 try) (2 (2 to) (2 (2 rebuild) (2 this)))) (2 ourselves)))))) (2 .)))
Cargo is going in a different direction.
(3 (2 Cargo) (3 (2 (2 is) (2 (2 going) (2 (2 in) (2 (2 a) (2 (2 different) (2 direction)))))) (2 .)))
Where did you get to, and what are you stuck on?
(1 (2 (2 (2 (2 Where) (2 (2 (2 did) (2 you)) (2 (2 get) (2 to)))) (2 ,)) (2 and)) (1 (2 what) (1 (2 (2 (2 are) (2 you)) (2 (2 stuck) (2 on))) (2 ?))))
I had a cursory look into 0install today.
(2 (2 I) (2 (2 (2 (2 had) (2 (2 a) (2 (1 cursory) (2 look)))) (2 (2 into) (2 (2 0install) (2 today)))) (2 .)))
Here's what I've found.
(2 (2 Here) (2 (2 (2 's) (2 (2 what) (2 (2 I) (2 (2 've) (2 found))))) (2 .)))
Every 0install package is defined by an XML metadata file, called a "feed".
(1 (2 (2 Every) (3 (2 0install) (2 package))) (1 (1 (2 is) (1 (3 defined) (1 (2 by) (1 (2 (2 (2 an) (2 (2 XML) (2 (2 metadata) (2 file)))) (2 ,)) (2 (2 called) (2 (2 a) (2 (2 ``) (2 (2 feed) (2 ''))))))))) (2 .)))
The feed contains the package name, description, version, dependencies &c -- the kind of metadata we already provide in inline-code.
(1 (2 (2 The) (2 feed)) (1 (1 (2 contains) (1 (1 (1 (2 the) (2 (2 package) (1 (2 name) (2 (2 ,) (1 (2 description) (2 (2 ,) (2 (2 version) (2 (2 ,) (2 (2 (2 dependencies) (2 &)) (2 c)))))))))) (2 --)) (2 (2 (2 the) (3 kind)) (2 (2 of) (2 (2 metadata) (2 (2 we) (2 (2 already) (2 (2 provide) (2 (2 in) (2 inline-code)))))))))) (2 .)))
Dependencies are specified similarly to rustpkg -- using URLs -- but instead of linking to the git repository, we link to the appropriate XML feed instead.
(1 (1 (2 Dependencies) (1 (2 are) (1 (2 (2 specified) (2 similarly)) (1 (2 (2 (2 (2 (2 to) (2 rustpkg)) (2 (2 --) (2 (2 (2 using) (2 URLs)) (2 --)))) (2 but)) (2 instead)) (1 (2 of) (1 (2 linking) (2 (2 to) (2 (2 the) (2 (2 git) (2 repository)))))))))) (1 (2 ,) (2 (2 we) (1 (1 (3 (2 link) (2 (2 to) (2 (2 the) (2 (3 appropriate) (2 (2 XML) (2 feed)))))) (2 instead)) (2 .)))))
The 0install resolver recursively downloads these feeds, building a graph of dependencies, before running a SAT solver on the whole lot.
(1 (1 (1 (1 (1 (2 (2 (2 The) (2 (2 0install) (2 resolver))) (2 (2 recursively) (2 downloads))) (2 (2 these) (2 feeds))) (2 ,)) (1 (2 (2 (2 building) (2 (2 (2 a) (2 graph)) (2 (2 of) (2 dependencies)))) (2 ,)) (2 (2 before) (2 (2 running) (2 (2 a) (2 (2 SAT) (2 solver))))))) (2 (2 on) (2 (2 the) (2 (2 whole) (2 lot))))) (2 .))
Packages are installed in a global cache, keyed by a checksum of the package contents.
(1 (2 Packages) (1 (1 (2 are) (1 (2 installed) (1 (2 in) (1 (2 (2 (2 a) (2 (2 global) (2 cache))) (2 ,)) (2 (2 keyed) (2 (2 by) (2 (2 (2 a) (2 checksum)) (2 (2 of) (2 (2 the) (2 (2 package) (2 contents))))))))))) (2 .)))
This checksum is included in the feed.
(1 (2 (2 This) (2 checksum)) (2 (2 (2 is) (2 (2 included) (2 (2 in) (2 (2 the) (2 feed))))) (2 .)))
We should eventually remove the hash suffixes from our library names, since 0install makes this system redundant.
(1 (2 We) (1 (1 (2 (2 should) (2 eventually)) (1 (1 (2 (2 (2 remove) (2 (2 the) (2 (1 hash) (2 suffixes)))) (2 (2 from) (2 (2 our) (2 (2 library) (2 names))))) (2 ,)) (2 (2 since) (1 (2 0install) (1 (2 makes) (2 (2 (2 this) (2 system)) (1 redundant))))))) (2 .)))
A good first step would be to write feeds for inline-code, inline-code et al., and publish them on the main site.
(3 (3 (2 A) (3 (3 good) (2 (2 first) (2 step)))) (1 (2 (2 would) (2 (2 be) (2 (2 to) (2 (2 (2 (2 (2 write) (2 (2 feeds) (2 (2 for) (2 (2 inline-code) (2 (2 ,) (2 (2 inline-code) (2 (2 et) (2 al.)))))))) (2 ,)) (2 and)) (2 (2 (2 publish) (2 them)) (2 (2 on) (2 (2 the) (2 (2 main) (2 site))))))))) (2 .)))
The packaging tutorial has plenty of info on this.
(3 (2 (2 The) (2 (2 packaging) (2 tutorial))) (3 (3 (2 has) (2 (2 plenty) (2 (2 of) (2 (2 info) (2 (2 on) (2 this)))))) (2 .)))
Next, we should figure out how to build Rust packages with 0install -- maybe write a cheat sheet mapping rustpkg annotations to 0install elements.
(1 (2 Next) (1 (2 ,) (1 (2 we) (1 (1 (2 should) (1 (1 (2 (2 (2 (2 (2 (2 figure) (1 out)) (2 (2 how) (2 (2 to) (2 (2 (2 build) (2 (2 Rust) (2 packages))) (2 (2 with) (2 0install)))))) (2 --)) (2 maybe)) (2 write)) (1 (2 a) (1 (1 cheat) (2 (2 sheet) (2 mapping))))) (2 (2 (2 rustpkg) (2 annotations)) (2 (2 to) (2 (2 0install) (2 elements)))))) (2 .)))))
The only issue I have is usability.
(1 (2 (2 (2 The) (2 (2 only) (2 issue))) (2 (2 I) (2 have))) (2 (2 (2 is) (2 usability)) (2 .)))
0install's XML format is much harder to write than our current annotations, and has too many degrees of freedom.
(1 (2 (2 (2 0install) (2 's)) (2 (2 XML) (2 format))) (1 (1 (1 (1 (1 (2 (2 is) (2 (2 much) (2 harder))) (2 (2 to) (2 (2 write) (2 (2 than) (2 (2 our) (2 (2 current) (2 annotations))))))) (2 ,)) (2 and)) (1 (2 has) (1 (1 (1 (2 too) (2 many)) (3 degrees)) (2 (2 of) (3 freedom))))) (2 .)))
We can solve this by writing a wrapper (let's call it inline-code) that generates feeds automatically, but that sounds a bit hacky.
(1 (2 We) (1 (1 (2 can) (1 (2 (2 solve) (2 this)) (1 (2 by) (1 (2 writing) (1 (2 (2 (2 a) (2 wrapper)) (2 (2 -LRB-) (2 (2 (2 let) (2 (2 's) (2 (2 call) (2 (2 it) (2 inline-code))))) (2 -RRB-)))) (1 (2 that) (1 (2 generates) (2 (2 (2 (2 (2 feeds) (2 automatically)) (2 ,)) (2 but)) (2 (2 that) (2 (2 (2 sounds) (2 (2 a) (2 bit))) (2 hacky))))))))))) (2 .)))
Any ideas?
(2 (3 Any) (2 (2 ideas) (2 ?)))
