{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5464", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5464/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5464/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5464/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/5464", "id": 187822308, "node_id": "MDU6SXNzdWUxODc4MjIzMDg=", "number": 5464, "title": "Can't find input_layer after freezing graph for Cifar10 model (it uses shuffle queue)", "user": {"login": "ghost", "id": 10137, "node_id": "MDQ6VXNlcjEwMTM3", "avatar_url": "https://avatars3.githubusercontent.com/u/10137?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ghost", "html_url": "https://github.com/ghost", "followers_url": "https://api.github.com/users/ghost/followers", "following_url": "https://api.github.com/users/ghost/following{/other_user}", "gists_url": "https://api.github.com/users/ghost/gists{/gist_id}", "starred_url": "https://api.github.com/users/ghost/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ghost/subscriptions", "organizations_url": "https://api.github.com/users/ghost/orgs", "repos_url": "https://api.github.com/users/ghost/repos", "events_url": "https://api.github.com/users/ghost/events{/privacy}", "received_events_url": "https://api.github.com/users/ghost/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 404586594, "node_id": "MDU6TGFiZWw0MDQ1ODY1OTQ=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:awaiting%20tensorflower", "name": "stat:awaiting tensorflower", "color": "f4b400", "default": false}, {"id": 473184161, "node_id": "MDU6TGFiZWw0NzMxODQxNjE=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:support", "name": "type:support", "color": "159b2e", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 6, "created_at": "2016-11-07T20:45:00Z", "updated_at": "2017-06-16T21:39:27Z", "closed_at": "2017-06-16T21:39:27Z", "author_association": "NONE", "body_html": "<p>I've run <a href=\"https://github.com/tensorflow/tensorflow/blob/master/tensorflow/models/image/cifar10/cifar10_train.py\">cifar10_train.py</a> example for some time and saved graph and checkpoint files. After that I used freeze_graph.py from python/tools and it worked fine, no errors. Later I've built <a href=\"https://github.com/tensorflow/tensorflow/tree/master/tensorflow/examples/label_image\">label_image</a> example, it worked fine with it's predefined values, but when I tried to use frozen graph and provided different flags, it failed because I couldn't find proper --input_layer value. I've tried many different values but nothing worked.</p>\n<p>I've tried most of operations as --input_layer in this code snippet from Cifar10 example but none worked for me:</p>\n<pre><code>def read_cifar10(filename_queue):\n  \"\"\"Reads and parses examples from CIFAR10 data files.\n\n  Recommendation: if you want N-way read parallelism, call this function\n  N times.  This will give you N independent Readers reading different\n  files &amp; positions within those files, which will give better mixing of\n  examples.\n\n  Args:\n    filename_queue: A queue of strings with the filenames to read from.\n\n  Returns:\n    An object representing a single example, with the following fields:\n      height: number of rows in the result (32)\n      width: number of columns in the result (32)\n      depth: number of color channels in the result (3)\n      key: a scalar string Tensor describing the filename &amp; record number\n        for this example.\n      label: an int32 Tensor with the label in the range 0..9.\n      uint8image: a [height, width, depth] uint8 Tensor with the image data\n  \"\"\"\n\n  class CIFAR10Record(object):\n    pass\n  result = CIFAR10Record()\n\n  # Dimensions of the images in the CIFAR-10 dataset.\n  # See http://www.cs.toronto.edu/~kriz/cifar.html for a description of the\n  # input format.\n  label_bytes = 1  # 2 for CIFAR-100\n  result.height = 32\n  result.width = 32\n  result.depth = 3\n  image_bytes = result.height * result.width * result.depth\n  # Every record consists of a label followed by the image, with a\n  # fixed number of bytes for each.\n  record_bytes = label_bytes + image_bytes\n\n  # Read a record, getting filenames from the filename_queue.  No\n  # header or footer in the CIFAR-10 format, so we leave header_bytes\n  # and footer_bytes at their default of 0.\n  reader = tf.FixedLengthRecordReader(record_bytes=record_bytes)\n  result.key, value = reader.read(filename_queue)\n\n  # Convert from a string to a vector of uint8 that is record_bytes long.\n  record_bytes = tf.decode_raw(value, tf.uint8, name=\"input_layer_node\")\n\n  # The first bytes represent the label, which we convert from uint8-&gt;int32.\n  result.label = tf.cast(\n      tf.slice(record_bytes, [0], [label_bytes]), tf.int32)\n\n  # The remaining bytes after the label represent the image, which we reshape\n  # from [depth * height * width] to [depth, height, width].\n  depth_major = tf.reshape(tf.slice(record_bytes, [label_bytes], [image_bytes]),\n                           [result.depth, result.height, result.width])\n  # Convert from [depth, height, width] to [height, width, depth].\n  result.uint8image = tf.transpose(depth_major, [1, 2, 0])\n\n  return result\n</code></pre>\n<p>Anyone had success with this one?</p>\n<blockquote>\n<h3>Environment info</h3>\n<p>Operating System: Ubuntu 14.04<br>\nCUDA: 8.0<br>\ncuDNN: 5.0<br>\ntf.<strong>version</strong><br>\n'0.11.0rc2'</p>\n</blockquote>", "body_text": "I've run cifar10_train.py example for some time and saved graph and checkpoint files. After that I used freeze_graph.py from python/tools and it worked fine, no errors. Later I've built label_image example, it worked fine with it's predefined values, but when I tried to use frozen graph and provided different flags, it failed because I couldn't find proper --input_layer value. I've tried many different values but nothing worked.\nI've tried most of operations as --input_layer in this code snippet from Cifar10 example but none worked for me:\ndef read_cifar10(filename_queue):\n  \"\"\"Reads and parses examples from CIFAR10 data files.\n\n  Recommendation: if you want N-way read parallelism, call this function\n  N times.  This will give you N independent Readers reading different\n  files & positions within those files, which will give better mixing of\n  examples.\n\n  Args:\n    filename_queue: A queue of strings with the filenames to read from.\n\n  Returns:\n    An object representing a single example, with the following fields:\n      height: number of rows in the result (32)\n      width: number of columns in the result (32)\n      depth: number of color channels in the result (3)\n      key: a scalar string Tensor describing the filename & record number\n        for this example.\n      label: an int32 Tensor with the label in the range 0..9.\n      uint8image: a [height, width, depth] uint8 Tensor with the image data\n  \"\"\"\n\n  class CIFAR10Record(object):\n    pass\n  result = CIFAR10Record()\n\n  # Dimensions of the images in the CIFAR-10 dataset.\n  # See http://www.cs.toronto.edu/~kriz/cifar.html for a description of the\n  # input format.\n  label_bytes = 1  # 2 for CIFAR-100\n  result.height = 32\n  result.width = 32\n  result.depth = 3\n  image_bytes = result.height * result.width * result.depth\n  # Every record consists of a label followed by the image, with a\n  # fixed number of bytes for each.\n  record_bytes = label_bytes + image_bytes\n\n  # Read a record, getting filenames from the filename_queue.  No\n  # header or footer in the CIFAR-10 format, so we leave header_bytes\n  # and footer_bytes at their default of 0.\n  reader = tf.FixedLengthRecordReader(record_bytes=record_bytes)\n  result.key, value = reader.read(filename_queue)\n\n  # Convert from a string to a vector of uint8 that is record_bytes long.\n  record_bytes = tf.decode_raw(value, tf.uint8, name=\"input_layer_node\")\n\n  # The first bytes represent the label, which we convert from uint8->int32.\n  result.label = tf.cast(\n      tf.slice(record_bytes, [0], [label_bytes]), tf.int32)\n\n  # The remaining bytes after the label represent the image, which we reshape\n  # from [depth * height * width] to [depth, height, width].\n  depth_major = tf.reshape(tf.slice(record_bytes, [label_bytes], [image_bytes]),\n                           [result.depth, result.height, result.width])\n  # Convert from [depth, height, width] to [height, width, depth].\n  result.uint8image = tf.transpose(depth_major, [1, 2, 0])\n\n  return result\n\nAnyone had success with this one?\n\nEnvironment info\nOperating System: Ubuntu 14.04\nCUDA: 8.0\ncuDNN: 5.0\ntf.version\n'0.11.0rc2'", "body": "I've run [cifar10_train.py]( https://github.com/tensorflow/tensorflow/blob/master/tensorflow/models/image/cifar10/cifar10_train.py\r\n) example for some time and saved graph and checkpoint files. After that I used freeze_graph.py from python/tools and it worked fine, no errors. Later I've built [label_image](https://github.com/tensorflow/tensorflow/tree/master/tensorflow/examples/label_image) example, it worked fine with it's predefined values, but when I tried to use frozen graph and provided different flags, it failed because I couldn't find proper --input_layer value. I've tried many different values but nothing worked.\r\n\r\nI've tried most of operations as --input_layer in this code snippet from Cifar10 example but none worked for me:\r\n\r\n```\r\ndef read_cifar10(filename_queue):\r\n  \"\"\"Reads and parses examples from CIFAR10 data files.\r\n\r\n  Recommendation: if you want N-way read parallelism, call this function\r\n  N times.  This will give you N independent Readers reading different\r\n  files & positions within those files, which will give better mixing of\r\n  examples.\r\n\r\n  Args:\r\n    filename_queue: A queue of strings with the filenames to read from.\r\n\r\n  Returns:\r\n    An object representing a single example, with the following fields:\r\n      height: number of rows in the result (32)\r\n      width: number of columns in the result (32)\r\n      depth: number of color channels in the result (3)\r\n      key: a scalar string Tensor describing the filename & record number\r\n        for this example.\r\n      label: an int32 Tensor with the label in the range 0..9.\r\n      uint8image: a [height, width, depth] uint8 Tensor with the image data\r\n  \"\"\"\r\n\r\n  class CIFAR10Record(object):\r\n    pass\r\n  result = CIFAR10Record()\r\n\r\n  # Dimensions of the images in the CIFAR-10 dataset.\r\n  # See http://www.cs.toronto.edu/~kriz/cifar.html for a description of the\r\n  # input format.\r\n  label_bytes = 1  # 2 for CIFAR-100\r\n  result.height = 32\r\n  result.width = 32\r\n  result.depth = 3\r\n  image_bytes = result.height * result.width * result.depth\r\n  # Every record consists of a label followed by the image, with a\r\n  # fixed number of bytes for each.\r\n  record_bytes = label_bytes + image_bytes\r\n\r\n  # Read a record, getting filenames from the filename_queue.  No\r\n  # header or footer in the CIFAR-10 format, so we leave header_bytes\r\n  # and footer_bytes at their default of 0.\r\n  reader = tf.FixedLengthRecordReader(record_bytes=record_bytes)\r\n  result.key, value = reader.read(filename_queue)\r\n\r\n  # Convert from a string to a vector of uint8 that is record_bytes long.\r\n  record_bytes = tf.decode_raw(value, tf.uint8, name=\"input_layer_node\")\r\n\r\n  # The first bytes represent the label, which we convert from uint8->int32.\r\n  result.label = tf.cast(\r\n      tf.slice(record_bytes, [0], [label_bytes]), tf.int32)\r\n\r\n  # The remaining bytes after the label represent the image, which we reshape\r\n  # from [depth * height * width] to [depth, height, width].\r\n  depth_major = tf.reshape(tf.slice(record_bytes, [label_bytes], [image_bytes]),\r\n                           [result.depth, result.height, result.width])\r\n  # Convert from [depth, height, width] to [height, width, depth].\r\n  result.uint8image = tf.transpose(depth_major, [1, 2, 0])\r\n\r\n  return result\r\n```\r\n\r\nAnyone had success with this one?\r\n\r\n>### Environment info\r\n>Operating System: Ubuntu 14.04\r\n>CUDA: 8.0\r\n>cuDNN: 5.0\r\n>tf.__version__\r\n'0.11.0rc2'\r\n\r\n"}