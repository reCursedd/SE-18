{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/328223705", "html_url": "https://github.com/tensorflow/tensorflow/issues/12118#issuecomment-328223705", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/12118", "id": 328223705, "node_id": "MDEyOklzc3VlQ29tbWVudDMyODIyMzcwNQ==", "user": {"login": "iganichev", "id": 9123400, "node_id": "MDQ6VXNlcjkxMjM0MDA=", "avatar_url": "https://avatars2.githubusercontent.com/u/9123400?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iganichev", "html_url": "https://github.com/iganichev", "followers_url": "https://api.github.com/users/iganichev/followers", "following_url": "https://api.github.com/users/iganichev/following{/other_user}", "gists_url": "https://api.github.com/users/iganichev/gists{/gist_id}", "starred_url": "https://api.github.com/users/iganichev/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iganichev/subscriptions", "organizations_url": "https://api.github.com/users/iganichev/orgs", "repos_url": "https://api.github.com/users/iganichev/repos", "events_url": "https://api.github.com/users/iganichev/events{/privacy}", "received_events_url": "https://api.github.com/users/iganichev/received_events", "type": "User", "site_admin": false}, "created_at": "2017-09-08T21:59:02Z", "updated_at": "2017-09-08T23:07:48Z", "author_association": "MEMBER", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=1294940\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/eaplatanios\">@eaplatanios</a>:</p>\n<ol>\n<li>Yes it does</li>\n<li>Assuming by \"close\" you mean calling TF_DeleteFunction, yes. Deleting the TF_Function struct does not do anything with the copies of the function that were added to graphs.</li>\n<li>I will add ImportFunctionDef. It should be pretty easy and I can see it being useful.</li>\n<li>GraphGetFunctions is a bit tricky. Functions are currently added to graphs as FunctionDef objects (plus (function_name, gradient_name) pairs in pending changes). We can reconstruct an equivalent TF_Function object from a graph, but it won't be the same TF_Function object that was added to the graph. I can see this causing confusion. If you need this functionality, I would suggest the following approach. Get GraphDef from graph, get FunctionDefs from this GraphDef, use ImportFunctionDef to create TF_Function objects. This approach is not super efficient, but hopefully does not need to run often and in critical paths. If performance of this functionality is critical, we can think about adding a TF_GraphGetFunctionDefinitionLibrary function. This will be as efficient as we can get with the current design.</li>\n</ol>", "body_text": "@eaplatanios:\n\nYes it does\nAssuming by \"close\" you mean calling TF_DeleteFunction, yes. Deleting the TF_Function struct does not do anything with the copies of the function that were added to graphs.\nI will add ImportFunctionDef. It should be pretty easy and I can see it being useful.\nGraphGetFunctions is a bit tricky. Functions are currently added to graphs as FunctionDef objects (plus (function_name, gradient_name) pairs in pending changes). We can reconstruct an equivalent TF_Function object from a graph, but it won't be the same TF_Function object that was added to the graph. I can see this causing confusion. If you need this functionality, I would suggest the following approach. Get GraphDef from graph, get FunctionDefs from this GraphDef, use ImportFunctionDef to create TF_Function objects. This approach is not super efficient, but hopefully does not need to run often and in critical paths. If performance of this functionality is critical, we can think about adding a TF_GraphGetFunctionDefinitionLibrary function. This will be as efficient as we can get with the current design.", "body": "@eaplatanios:\r\n1. Yes it does\r\n2. Assuming by \"close\" you mean calling TF_DeleteFunction, yes. Deleting the TF_Function struct does not do anything with the copies of the function that were added to graphs.\r\n3. I will add ImportFunctionDef. It should be pretty easy and I can see it being useful.\r\n4. GraphGetFunctions is a bit tricky. Functions are currently added to graphs as FunctionDef objects (plus (function_name, gradient_name) pairs in pending changes). We can reconstruct an equivalent TF_Function object from a graph, but it won't be the same TF_Function object that was added to the graph. I can see this causing confusion. If you need this functionality, I would suggest the following approach. Get GraphDef from graph, get FunctionDefs from this GraphDef, use ImportFunctionDef to create TF_Function objects. This approach is not super efficient, but hopefully does not need to run often and in critical paths. If performance of this functionality is critical, we can think about adding a TF_GraphGetFunctionDefinitionLibrary function. This will be as efficient as we can get with the current design."}