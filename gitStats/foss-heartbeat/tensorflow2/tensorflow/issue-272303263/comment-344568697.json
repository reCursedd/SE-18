{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/344568697", "html_url": "https://github.com/tensorflow/tensorflow/issues/14374#issuecomment-344568697", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/14374", "id": 344568697, "node_id": "MDEyOklzc3VlQ29tbWVudDM0NDU2ODY5Nw==", "user": {"login": "boeddeker", "id": 13744128, "node_id": "MDQ6VXNlcjEzNzQ0MTI4", "avatar_url": "https://avatars3.githubusercontent.com/u/13744128?v=4", "gravatar_id": "", "url": "https://api.github.com/users/boeddeker", "html_url": "https://github.com/boeddeker", "followers_url": "https://api.github.com/users/boeddeker/followers", "following_url": "https://api.github.com/users/boeddeker/following{/other_user}", "gists_url": "https://api.github.com/users/boeddeker/gists{/gist_id}", "starred_url": "https://api.github.com/users/boeddeker/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/boeddeker/subscriptions", "organizations_url": "https://api.github.com/users/boeddeker/orgs", "repos_url": "https://api.github.com/users/boeddeker/repos", "events_url": "https://api.github.com/users/boeddeker/events{/privacy}", "received_events_url": "https://api.github.com/users/boeddeker/received_events", "type": "User", "site_admin": false}, "created_at": "2017-11-15T11:44:39Z", "updated_at": "2017-11-15T11:45:25Z", "author_association": "CONTRIBUTOR", "body_html": "<p>How about to allow the input of <code>get_placeholders</code> to be anything, that can be passed to <code>tf.Session.run</code>?</p>\n<p>Here the code that I use to get the placeholders:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">def</span> <span class=\"pl-en\">get_placeholder</span>(<span class=\"pl-smi\">tensor</span>, <span class=\"pl-smi\">return_op</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">False</span>):\n    <span class=\"pl-s\"><span class=\"pl-pds\">\"\"\"</span></span>\n<span class=\"pl-s\">    Returns a list of placeholders,</span>\n<span class=\"pl-s\">    if placeholder order is predictable else a set of placeholders.</span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">    <span class=\"pl-k\">&gt;&gt;&gt; </span>a = tf.placeholder(tf.float32)</span>\n<span class=\"pl-s\">    <span class=\"pl-k\">&gt;&gt;&gt; </span>b = a ** 2</span>\n<span class=\"pl-s\">    <span class=\"pl-k\">&gt;&gt;&gt; </span>get_placeholder(b)</span>\n<span class=\"pl-s\">    [&lt;tf.Tensor 'Placeholder:0' shape=&lt;unknown&gt; dtype=float32&gt;]</span>\n<span class=\"pl-s\">    <span class=\"pl-k\">&gt;&gt;&gt; </span>get_placeholder({'b': b})</span>\n<span class=\"pl-s\">    [&lt;tf.Tensor 'Placeholder:0' shape=&lt;unknown&gt; dtype=float32&gt;]</span>\n<span class=\"pl-s\">    <span class=\"pl-k\">&gt;&gt;&gt; </span>get_placeholder([b])</span>\n<span class=\"pl-s\">    [&lt;tf.Tensor 'Placeholder:0' shape=&lt;unknown&gt; dtype=float32&gt;]</span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">    <span class=\"pl-k\">&gt;&gt;&gt; </span>from IPython.lib.pretty import pprint</span>\n<span class=\"pl-s\">    <span class=\"pl-k\">&gt;&gt;&gt; </span>a = tf.placeholder(tf.float32, name='a')</span>\n<span class=\"pl-s\">    <span class=\"pl-k\">&gt;&gt;&gt; </span>b = tf.placeholder(tf.float32, name='b')</span>\n<span class=\"pl-s\">    <span class=\"pl-k\">&gt;&gt;&gt; </span>c = a + b</span>\n<span class=\"pl-s\">    <span class=\"pl-k\">&gt;&gt;&gt; </span>pprint(get_placeholder(c))</span>\n<span class=\"pl-s\">    [&lt;tf.Tensor 'a:0' shape=&lt;unknown&gt; dtype=float32&gt;,</span>\n<span class=\"pl-s\">     &lt;tf.Tensor 'b:0' shape=&lt;unknown&gt; dtype=float32&gt;]</span>\n<span class=\"pl-s\">    <span class=\"pl-k\">&gt;&gt;&gt; </span>pprint(get_placeholder(a + 2))</span>\n<span class=\"pl-s\">    [&lt;tf.Tensor 'a:0' shape=&lt;unknown&gt; dtype=float32&gt;]</span>\n<span class=\"pl-s\">    <span class=\"pl-k\">&gt;&gt;&gt; </span>pprint(get_placeholder(c, True))</span>\n<span class=\"pl-s\">    [&lt;tf.Operation 'a' type=Placeholder&gt;, &lt;tf.Operation 'b' type=Placeholder&gt;]</span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">    <span class=\"pl-pds\">\"\"\"</span></span>\n    tensor_list <span class=\"pl-k\">=</span> nest.flatten(tensor)\n\n    <span class=\"pl-k\">def</span> <span class=\"pl-en\">get_inputs</span>(<span class=\"pl-smi\">obj</span>):\n        <span class=\"pl-k\">if</span> <span class=\"pl-c1\">isinstance</span>(obj, tf.Tensor):\n            <span class=\"pl-k\">return</span> obj.op.inputs\n        <span class=\"pl-k\">elif</span> <span class=\"pl-c1\">isinstance</span>(obj, tf.Operation):\n            <span class=\"pl-k\">return</span> obj.inputs\n        <span class=\"pl-k\">else</span>:\n            <span class=\"pl-k\">raise</span> <span class=\"pl-c1\">TypeError</span>(obj)\n\n    todo <span class=\"pl-k\">=</span> <span class=\"pl-c1\">list</span>(chain(<span class=\"pl-k\">*</span>[<span class=\"pl-c1\">list</span>((t, i) <span class=\"pl-k\">for</span> i <span class=\"pl-k\">in</span> get_inputs(t)) <span class=\"pl-k\">for</span> t <span class=\"pl-k\">in</span> tensor_list]))\n\n    visited <span class=\"pl-k\">=</span> <span class=\"pl-c1\">set</span>()\n    placeholders <span class=\"pl-k\">=</span> <span class=\"pl-c1\">list</span>()\n\n    counter <span class=\"pl-k\">=</span> <span class=\"pl-c1\">0</span>\n\n    <span class=\"pl-k\">while</span> <span class=\"pl-c1\">len</span>(todo) <span class=\"pl-k\">&gt;</span> <span class=\"pl-c1\">0</span>:\n        parent, tensor <span class=\"pl-k\">=</span> todo.pop(<span class=\"pl-c1\">0</span>)\n\n        <span class=\"pl-k\">if</span> tensor <span class=\"pl-k\">in</span> visited:\n            <span class=\"pl-k\">continue</span>\n        visited.add(tensor)\n        <span class=\"pl-k\">if</span> tensor.op.type <span class=\"pl-k\">==</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>Placeholder<span class=\"pl-pds\">'</span></span>:\n            placeholders.append(tensor)\n            counter <span class=\"pl-k\">+=</span> <span class=\"pl-c1\">1</span>\n\n        todo.extend(<span class=\"pl-c1\">list</span>((tensor, i) <span class=\"pl-k\">for</span> i <span class=\"pl-k\">in</span> tensor.op.inputs))\n\n    <span class=\"pl-k\">if</span> return_op:\n        placeholders <span class=\"pl-k\">=</span> [p.op <span class=\"pl-k\">for</span> p <span class=\"pl-k\">in</span> placeholders]\n\n    <span class=\"pl-k\">return</span> placeholders</pre></div>", "body_text": "How about to allow the input of get_placeholders to be anything, that can be passed to tf.Session.run?\nHere the code that I use to get the placeholders:\ndef get_placeholder(tensor, return_op=False):\n    \"\"\"\n    Returns a list of placeholders,\n    if placeholder order is predictable else a set of placeholders.\n\n    >>> a = tf.placeholder(tf.float32)\n    >>> b = a ** 2\n    >>> get_placeholder(b)\n    [<tf.Tensor 'Placeholder:0' shape=<unknown> dtype=float32>]\n    >>> get_placeholder({'b': b})\n    [<tf.Tensor 'Placeholder:0' shape=<unknown> dtype=float32>]\n    >>> get_placeholder([b])\n    [<tf.Tensor 'Placeholder:0' shape=<unknown> dtype=float32>]\n\n    >>> from IPython.lib.pretty import pprint\n    >>> a = tf.placeholder(tf.float32, name='a')\n    >>> b = tf.placeholder(tf.float32, name='b')\n    >>> c = a + b\n    >>> pprint(get_placeholder(c))\n    [<tf.Tensor 'a:0' shape=<unknown> dtype=float32>,\n     <tf.Tensor 'b:0' shape=<unknown> dtype=float32>]\n    >>> pprint(get_placeholder(a + 2))\n    [<tf.Tensor 'a:0' shape=<unknown> dtype=float32>]\n    >>> pprint(get_placeholder(c, True))\n    [<tf.Operation 'a' type=Placeholder>, <tf.Operation 'b' type=Placeholder>]\n\n    \"\"\"\n    tensor_list = nest.flatten(tensor)\n\n    def get_inputs(obj):\n        if isinstance(obj, tf.Tensor):\n            return obj.op.inputs\n        elif isinstance(obj, tf.Operation):\n            return obj.inputs\n        else:\n            raise TypeError(obj)\n\n    todo = list(chain(*[list((t, i) for i in get_inputs(t)) for t in tensor_list]))\n\n    visited = set()\n    placeholders = list()\n\n    counter = 0\n\n    while len(todo) > 0:\n        parent, tensor = todo.pop(0)\n\n        if tensor in visited:\n            continue\n        visited.add(tensor)\n        if tensor.op.type == 'Placeholder':\n            placeholders.append(tensor)\n            counter += 1\n\n        todo.extend(list((tensor, i) for i in tensor.op.inputs))\n\n    if return_op:\n        placeholders = [p.op for p in placeholders]\n\n    return placeholders", "body": "How about to allow the input of `get_placeholders` to be anything, that can be passed to `tf.Session.run`?\r\n\r\nHere the code that I use to get the placeholders:\r\n```python\r\ndef get_placeholder(tensor, return_op=False):\r\n    \"\"\"\r\n    Returns a list of placeholders,\r\n    if placeholder order is predictable else a set of placeholders.\r\n\r\n    >>> a = tf.placeholder(tf.float32)\r\n    >>> b = a ** 2\r\n    >>> get_placeholder(b)\r\n    [<tf.Tensor 'Placeholder:0' shape=<unknown> dtype=float32>]\r\n    >>> get_placeholder({'b': b})\r\n    [<tf.Tensor 'Placeholder:0' shape=<unknown> dtype=float32>]\r\n    >>> get_placeholder([b])\r\n    [<tf.Tensor 'Placeholder:0' shape=<unknown> dtype=float32>]\r\n\r\n    >>> from IPython.lib.pretty import pprint\r\n    >>> a = tf.placeholder(tf.float32, name='a')\r\n    >>> b = tf.placeholder(tf.float32, name='b')\r\n    >>> c = a + b\r\n    >>> pprint(get_placeholder(c))\r\n    [<tf.Tensor 'a:0' shape=<unknown> dtype=float32>,\r\n     <tf.Tensor 'b:0' shape=<unknown> dtype=float32>]\r\n    >>> pprint(get_placeholder(a + 2))\r\n    [<tf.Tensor 'a:0' shape=<unknown> dtype=float32>]\r\n    >>> pprint(get_placeholder(c, True))\r\n    [<tf.Operation 'a' type=Placeholder>, <tf.Operation 'b' type=Placeholder>]\r\n\r\n    \"\"\"\r\n    tensor_list = nest.flatten(tensor)\r\n\r\n    def get_inputs(obj):\r\n        if isinstance(obj, tf.Tensor):\r\n            return obj.op.inputs\r\n        elif isinstance(obj, tf.Operation):\r\n            return obj.inputs\r\n        else:\r\n            raise TypeError(obj)\r\n\r\n    todo = list(chain(*[list((t, i) for i in get_inputs(t)) for t in tensor_list]))\r\n\r\n    visited = set()\r\n    placeholders = list()\r\n\r\n    counter = 0\r\n\r\n    while len(todo) > 0:\r\n        parent, tensor = todo.pop(0)\r\n\r\n        if tensor in visited:\r\n            continue\r\n        visited.add(tensor)\r\n        if tensor.op.type == 'Placeholder':\r\n            placeholders.append(tensor)\r\n            counter += 1\r\n\r\n        todo.extend(list((tensor, i) for i in tensor.op.inputs))\r\n\r\n    if return_op:\r\n        placeholders = [p.op for p in placeholders]\r\n\r\n    return placeholders\r\n```"}