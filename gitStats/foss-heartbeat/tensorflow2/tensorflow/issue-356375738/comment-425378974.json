{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/425378974", "html_url": "https://github.com/tensorflow/tensorflow/issues/22019#issuecomment-425378974", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/22019", "id": 425378974, "node_id": "MDEyOklzc3VlQ29tbWVudDQyNTM3ODk3NA==", "user": {"login": "ram1897", "id": 17523110, "node_id": "MDQ6VXNlcjE3NTIzMTEw", "avatar_url": "https://avatars0.githubusercontent.com/u/17523110?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ram1897", "html_url": "https://github.com/ram1897", "followers_url": "https://api.github.com/users/ram1897/followers", "following_url": "https://api.github.com/users/ram1897/following{/other_user}", "gists_url": "https://api.github.com/users/ram1897/gists{/gist_id}", "starred_url": "https://api.github.com/users/ram1897/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ram1897/subscriptions", "organizations_url": "https://api.github.com/users/ram1897/orgs", "repos_url": "https://api.github.com/users/ram1897/repos", "events_url": "https://api.github.com/users/ram1897/events{/privacy}", "received_events_url": "https://api.github.com/users/ram1897/received_events", "type": "User", "site_admin": false}, "created_at": "2018-09-28T09:30:32Z", "updated_at": "2018-09-28T09:30:32Z", "author_association": "NONE", "body_html": "<p>If None of the above works for you, copy this code into freeze_graph.py for a Short Term Fix</p>\n<h1>Copyright 2015 The TensorFlow Authors. All Rights Reserved.</h1>\n<h1></h1>\n<h1>Licensed under the Apache License, Version 2.0 (the \"License\");</h1>\n<h1>you may not use this file except in compliance with the License.</h1>\n<h1>You may obtain a copy of the License at</h1>\n<h1></h1>\n<h1><a href=\"http://www.apache.org/licenses/LICENSE-2.0\" rel=\"nofollow\">http://www.apache.org/licenses/LICENSE-2.0</a></h1>\n<h1></h1>\n<h1>Unless required by applicable law or agreed to in writing, software</h1>\n<h1>distributed under the License is distributed on an \"AS IS\" BASIS,</h1>\n<h1>WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</h1>\n<h1>See the License for the specific language governing permissions and</h1>\n<h1>limitations under the License.</h1>\n<h1>==============================================================================</h1>\n<p>\"\"\"Converts checkpoint variables into Const ops in a standalone GraphDef file.</p>\n<p>This script is designed to take a GraphDef proto, a SaverDef proto, and a set of<br>\nvariable values stored in a checkpoint file, and output a GraphDef with all of<br>\nthe variable ops converted into const ops containing the values of the<br>\nvariables.</p>\n<p>It's useful to do this when we need to load a single file in C++, especially in<br>\nenvironments like mobile or embedded where we may not have access to the<br>\nRestoreTensor ops and file loading calls that they rely on.</p>\n<p>An example of command-line usage is:<br>\nbazel build tensorflow/python/tools:freeze_graph &amp;&amp; <br>\nbazel-bin/tensorflow/python/tools/freeze_graph <br>\n--input_graph=some_graph_def.pb <br>\n--input_checkpoint=model.ckpt-8361242 <br>\n--output_graph=/tmp/frozen_graph.pb --output_node_names=softmax</p>\n<p>You can also look at freeze_graph_test.py for an example of how to use it.</p>\n<p>\"\"\"<br>\nfrom <strong>future</strong> import absolute_import<br>\nfrom <strong>future</strong> import division<br>\nfrom <strong>future</strong> import print_function</p>\n<p>import argparse<br>\nimport sys</p>\n<p>from google.protobuf import text_format</p>\n<p>from tensorflow.core.framework import graph_pb2<br>\nfrom tensorflow.core.protobuf import saver_pb2<br>\nfrom tensorflow.python import pywrap_tensorflow<br>\nfrom tensorflow.python.client import session<br>\nfrom tensorflow.python.framework import graph_util<br>\nfrom tensorflow.python.framework import importer<br>\nfrom tensorflow.python.platform import app<br>\nfrom tensorflow.python.platform import gfile<br>\nfrom tensorflow.python.training import saver as saver_lib</p>\n<p>FLAGS = None</p>\n<p>def freeze_graph(input_graph,<br>\ninput_saver,<br>\ninput_binary,<br>\ninput_checkpoint,<br>\noutput_node_names,<br>\nrestore_op_name,<br>\nfilename_tensor_name,<br>\noutput_graph,<br>\nclear_devices,<br>\ninitializer_nodes,<br>\nvariable_names_blacklist=\"\"):<br>\n\"\"\"Converts all variables in a graph and checkpoint into constants.\"\"\"</p>\n<p>del restore_op_name, filename_tensor_name  # Unused by updated loading code.</p>\n<p>if not gfile.Exists(input_graph):<br>\nprint(\"Input graph file '\" + input_graph + \"' does not exist!\")<br>\nreturn -1</p>\n<p>if input_saver and not gfile.Exists(input_saver):<br>\nprint(\"Input saver file '\" + input_saver + \"' does not exist!\")<br>\nreturn -1</p>\n<h1>'input_checkpoint' may be a prefix if we're using Saver V2 format</h1>\n<p>if not saver_lib.checkpoint_exists(input_checkpoint):<br>\nprint(\"Input checkpoint '\" + input_checkpoint + \"' doesn't exist!\")<br>\nreturn -1</p>\n<p>if not output_node_names:<br>\nprint(\"You need to supply the name of a node to --output_node_names.\")<br>\nreturn -1</p>\n<p>input_graph_def = graph_pb2.GraphDef()<br>\nmode = \"rb\" if input_binary else \"r\"<br>\nwith gfile.FastGFile(input_graph, mode) as f:<br>\nif input_binary:<br>\ninput_graph_def.ParseFromString(f.read())<br>\nelse:<br>\ntext_format.Merge(f.read(), input_graph_def)</p>\n<h1>Remove all the explicit device specifications for this node. This helps to</h1>\n<h1>make the graph more portable.</h1>\n<p>if clear_devices:<br>\nfor node in input_graph_def.node:<br>\nnode.device = \"\"</p>\n<p>_ = importer.import_graph_def(input_graph_def, name=\"\")</p>\n<p>with session.Session() as sess:<br>\nif input_saver:<br>\nwith gfile.FastGFile(input_saver, mode) as f:<br>\nsaver_def = saver_pb2.SaverDef()<br>\nif input_binary:<br>\nsaver_def.ParseFromString(f.read())<br>\nelse:<br>\ntext_format.Merge(f.read(), saver_def)<br>\nsaver = saver_lib.Saver(saver_def=saver_def)<br>\nsaver.restore(sess, input_checkpoint)<br>\nelse:<br>\nvar_list = {}<br>\nreader = pywrap_tensorflow.NewCheckpointReader(input_checkpoint)<br>\nvar_to_shape_map = reader.get_variable_to_shape_map()<br>\nfor key in var_to_shape_map:<br>\ntry:<br>\ntensor = sess.graph.get_tensor_by_name(key + \":0\")<br>\nexcept KeyError:<br>\n# This tensor doesn't exist in the graph (for example it's<br>\n# 'global_step' or a similar housekeeping element) so skip it.<br>\ncontinue<br>\nvar_list[key] = tensor<br>\nsaver = saver_lib.Saver(var_list=var_list)<br>\nsaver.restore(sess, input_checkpoint)<br>\nif initializer_nodes:<br>\nsess.run(initializer_nodes)</p>\n<pre><code>variable_names_blacklist = (variable_names_blacklist.split(\",\") if\n                            variable_names_blacklist else None)\noutput_graph_def = graph_util.convert_variables_to_constants(\n    sess,\n    input_graph_def,\n    output_node_names.split(\",\"),\n    variable_names_blacklist=variable_names_blacklist)\n</code></pre>\n<p>with gfile.GFile(output_graph, \"wb\") as f:<br>\nf.write(output_graph_def.SerializeToString())<br>\nprint(\"%d ops in the final graph.\" % len(output_graph_def.node))</p>\n<p>def main(unused_args):<br>\nfreeze_graph(FLAGS.input_graph, FLAGS.input_saver, FLAGS.input_binary,<br>\nFLAGS.input_checkpoint, FLAGS.output_node_names,<br>\nFLAGS.restore_op_name, FLAGS.filename_tensor_name,<br>\nFLAGS.output_graph, FLAGS.clear_devices, FLAGS.initializer_nodes,<br>\nFLAGS.variable_names_blacklist)</p>\n<p>if <strong>name</strong> == \"<strong>main</strong>\":<br>\nparser = argparse.ArgumentParser()<br>\nparser.register(\"type\", \"bool\", lambda v: v.lower() == \"true\")<br>\nparser.add_argument(<br>\n\"--input_graph\",<br>\ntype=str,<br>\ndefault=\"\",<br>\nhelp=\"TensorFlow 'GraphDef' file to load.\")<br>\nparser.add_argument(<br>\n\"--input_saver\",<br>\ntype=str,<br>\ndefault=\"\",<br>\nhelp=\"TensorFlow saver file to load.\")<br>\nparser.add_argument(<br>\n\"--input_checkpoint\",<br>\ntype=str,<br>\ndefault=\"\",<br>\nhelp=\"TensorFlow variables file to load.\")<br>\nparser.add_argument(<br>\n\"--output_graph\",<br>\ntype=str,<br>\ndefault=\"\",<br>\nhelp=\"Output 'GraphDef' file name.\")<br>\nparser.add_argument(<br>\n\"--input_binary\",<br>\nnargs=\"?\",<br>\nconst=True,<br>\ntype=\"bool\",<br>\ndefault=False,<br>\nhelp=\"Whether the input files are in binary format.\")<br>\nparser.add_argument(<br>\n\"--output_node_names\",<br>\ntype=str,<br>\ndefault=\"\",<br>\nhelp=\"The name of the output nodes, comma separated.\")<br>\nparser.add_argument(<br>\n\"--restore_op_name\",<br>\ntype=str,<br>\ndefault=\"save/restore_all\",<br>\nhelp=\"The name of the master restore operator.\")<br>\nparser.add_argument(<br>\n\"--filename_tensor_name\",<br>\ntype=str,<br>\ndefault=\"save/Const:0\",<br>\nhelp=\"The name of the tensor holding the save path.\")<br>\nparser.add_argument(<br>\n\"--clear_devices\",<br>\nnargs=\"?\",<br>\nconst=True,<br>\ntype=\"bool\",<br>\ndefault=True,<br>\nhelp=\"Whether to remove device specifications.\")<br>\nparser.add_argument(<br>\n\"--initializer_nodes\",<br>\ntype=str,<br>\ndefault=\"\",<br>\nhelp=\"comma separated list of initializer nodes to run before freezing.\")<br>\nparser.add_argument(<br>\n\"--variable_names_blacklist\",<br>\ntype=str,<br>\ndefault=\"\",<br>\nhelp=\"\"\"<br>\ncomma separated list of variables to skip converting to constants<br>\n\"\"\")<br>\nFLAGS, unparsed = parser.parse_known_args()<br>\napp.run(main=main, argv=[sys.argv[0]] + unparsed)</p>", "body_text": "If None of the above works for you, copy this code into freeze_graph.py for a Short Term Fix\nCopyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================\n\"\"\"Converts checkpoint variables into Const ops in a standalone GraphDef file.\nThis script is designed to take a GraphDef proto, a SaverDef proto, and a set of\nvariable values stored in a checkpoint file, and output a GraphDef with all of\nthe variable ops converted into const ops containing the values of the\nvariables.\nIt's useful to do this when we need to load a single file in C++, especially in\nenvironments like mobile or embedded where we may not have access to the\nRestoreTensor ops and file loading calls that they rely on.\nAn example of command-line usage is:\nbazel build tensorflow/python/tools:freeze_graph && \nbazel-bin/tensorflow/python/tools/freeze_graph \n--input_graph=some_graph_def.pb \n--input_checkpoint=model.ckpt-8361242 \n--output_graph=/tmp/frozen_graph.pb --output_node_names=softmax\nYou can also look at freeze_graph_test.py for an example of how to use it.\n\"\"\"\nfrom future import absolute_import\nfrom future import division\nfrom future import print_function\nimport argparse\nimport sys\nfrom google.protobuf import text_format\nfrom tensorflow.core.framework import graph_pb2\nfrom tensorflow.core.protobuf import saver_pb2\nfrom tensorflow.python import pywrap_tensorflow\nfrom tensorflow.python.client import session\nfrom tensorflow.python.framework import graph_util\nfrom tensorflow.python.framework import importer\nfrom tensorflow.python.platform import app\nfrom tensorflow.python.platform import gfile\nfrom tensorflow.python.training import saver as saver_lib\nFLAGS = None\ndef freeze_graph(input_graph,\ninput_saver,\ninput_binary,\ninput_checkpoint,\noutput_node_names,\nrestore_op_name,\nfilename_tensor_name,\noutput_graph,\nclear_devices,\ninitializer_nodes,\nvariable_names_blacklist=\"\"):\n\"\"\"Converts all variables in a graph and checkpoint into constants.\"\"\"\ndel restore_op_name, filename_tensor_name  # Unused by updated loading code.\nif not gfile.Exists(input_graph):\nprint(\"Input graph file '\" + input_graph + \"' does not exist!\")\nreturn -1\nif input_saver and not gfile.Exists(input_saver):\nprint(\"Input saver file '\" + input_saver + \"' does not exist!\")\nreturn -1\n'input_checkpoint' may be a prefix if we're using Saver V2 format\nif not saver_lib.checkpoint_exists(input_checkpoint):\nprint(\"Input checkpoint '\" + input_checkpoint + \"' doesn't exist!\")\nreturn -1\nif not output_node_names:\nprint(\"You need to supply the name of a node to --output_node_names.\")\nreturn -1\ninput_graph_def = graph_pb2.GraphDef()\nmode = \"rb\" if input_binary else \"r\"\nwith gfile.FastGFile(input_graph, mode) as f:\nif input_binary:\ninput_graph_def.ParseFromString(f.read())\nelse:\ntext_format.Merge(f.read(), input_graph_def)\nRemove all the explicit device specifications for this node. This helps to\nmake the graph more portable.\nif clear_devices:\nfor node in input_graph_def.node:\nnode.device = \"\"\n_ = importer.import_graph_def(input_graph_def, name=\"\")\nwith session.Session() as sess:\nif input_saver:\nwith gfile.FastGFile(input_saver, mode) as f:\nsaver_def = saver_pb2.SaverDef()\nif input_binary:\nsaver_def.ParseFromString(f.read())\nelse:\ntext_format.Merge(f.read(), saver_def)\nsaver = saver_lib.Saver(saver_def=saver_def)\nsaver.restore(sess, input_checkpoint)\nelse:\nvar_list = {}\nreader = pywrap_tensorflow.NewCheckpointReader(input_checkpoint)\nvar_to_shape_map = reader.get_variable_to_shape_map()\nfor key in var_to_shape_map:\ntry:\ntensor = sess.graph.get_tensor_by_name(key + \":0\")\nexcept KeyError:\n# This tensor doesn't exist in the graph (for example it's\n# 'global_step' or a similar housekeeping element) so skip it.\ncontinue\nvar_list[key] = tensor\nsaver = saver_lib.Saver(var_list=var_list)\nsaver.restore(sess, input_checkpoint)\nif initializer_nodes:\nsess.run(initializer_nodes)\nvariable_names_blacklist = (variable_names_blacklist.split(\",\") if\n                            variable_names_blacklist else None)\noutput_graph_def = graph_util.convert_variables_to_constants(\n    sess,\n    input_graph_def,\n    output_node_names.split(\",\"),\n    variable_names_blacklist=variable_names_blacklist)\n\nwith gfile.GFile(output_graph, \"wb\") as f:\nf.write(output_graph_def.SerializeToString())\nprint(\"%d ops in the final graph.\" % len(output_graph_def.node))\ndef main(unused_args):\nfreeze_graph(FLAGS.input_graph, FLAGS.input_saver, FLAGS.input_binary,\nFLAGS.input_checkpoint, FLAGS.output_node_names,\nFLAGS.restore_op_name, FLAGS.filename_tensor_name,\nFLAGS.output_graph, FLAGS.clear_devices, FLAGS.initializer_nodes,\nFLAGS.variable_names_blacklist)\nif name == \"main\":\nparser = argparse.ArgumentParser()\nparser.register(\"type\", \"bool\", lambda v: v.lower() == \"true\")\nparser.add_argument(\n\"--input_graph\",\ntype=str,\ndefault=\"\",\nhelp=\"TensorFlow 'GraphDef' file to load.\")\nparser.add_argument(\n\"--input_saver\",\ntype=str,\ndefault=\"\",\nhelp=\"TensorFlow saver file to load.\")\nparser.add_argument(\n\"--input_checkpoint\",\ntype=str,\ndefault=\"\",\nhelp=\"TensorFlow variables file to load.\")\nparser.add_argument(\n\"--output_graph\",\ntype=str,\ndefault=\"\",\nhelp=\"Output 'GraphDef' file name.\")\nparser.add_argument(\n\"--input_binary\",\nnargs=\"?\",\nconst=True,\ntype=\"bool\",\ndefault=False,\nhelp=\"Whether the input files are in binary format.\")\nparser.add_argument(\n\"--output_node_names\",\ntype=str,\ndefault=\"\",\nhelp=\"The name of the output nodes, comma separated.\")\nparser.add_argument(\n\"--restore_op_name\",\ntype=str,\ndefault=\"save/restore_all\",\nhelp=\"The name of the master restore operator.\")\nparser.add_argument(\n\"--filename_tensor_name\",\ntype=str,\ndefault=\"save/Const:0\",\nhelp=\"The name of the tensor holding the save path.\")\nparser.add_argument(\n\"--clear_devices\",\nnargs=\"?\",\nconst=True,\ntype=\"bool\",\ndefault=True,\nhelp=\"Whether to remove device specifications.\")\nparser.add_argument(\n\"--initializer_nodes\",\ntype=str,\ndefault=\"\",\nhelp=\"comma separated list of initializer nodes to run before freezing.\")\nparser.add_argument(\n\"--variable_names_blacklist\",\ntype=str,\ndefault=\"\",\nhelp=\"\"\"\ncomma separated list of variables to skip converting to constants\n\"\"\")\nFLAGS, unparsed = parser.parse_known_args()\napp.run(main=main, argv=[sys.argv[0]] + unparsed)", "body": "If None of the above works for you, copy this code into freeze_graph.py for a Short Term Fix\r\n# Copyright 2015 The TensorFlow Authors. All Rights Reserved.\r\n#\r\n# Licensed under the Apache License, Version 2.0 (the \"License\");\r\n# you may not use this file except in compliance with the License.\r\n# You may obtain a copy of the License at\r\n#\r\n#     http://www.apache.org/licenses/LICENSE-2.0\r\n#\r\n# Unless required by applicable law or agreed to in writing, software\r\n# distributed under the License is distributed on an \"AS IS\" BASIS,\r\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n# See the License for the specific language governing permissions and\r\n# limitations under the License.\r\n# ==============================================================================\r\n\"\"\"Converts checkpoint variables into Const ops in a standalone GraphDef file.\r\n\r\nThis script is designed to take a GraphDef proto, a SaverDef proto, and a set of\r\nvariable values stored in a checkpoint file, and output a GraphDef with all of\r\nthe variable ops converted into const ops containing the values of the\r\nvariables.\r\n\r\nIt's useful to do this when we need to load a single file in C++, especially in\r\nenvironments like mobile or embedded where we may not have access to the\r\nRestoreTensor ops and file loading calls that they rely on.\r\n\r\nAn example of command-line usage is:\r\nbazel build tensorflow/python/tools:freeze_graph && \\\r\nbazel-bin/tensorflow/python/tools/freeze_graph \\\r\n--input_graph=some_graph_def.pb \\\r\n--input_checkpoint=model.ckpt-8361242 \\\r\n--output_graph=/tmp/frozen_graph.pb --output_node_names=softmax\r\n\r\nYou can also look at freeze_graph_test.py for an example of how to use it.\r\n\r\n\"\"\"\r\nfrom __future__ import absolute_import\r\nfrom __future__ import division\r\nfrom __future__ import print_function\r\n\r\nimport argparse\r\nimport sys\r\n\r\nfrom google.protobuf import text_format\r\n\r\nfrom tensorflow.core.framework import graph_pb2\r\nfrom tensorflow.core.protobuf import saver_pb2\r\nfrom tensorflow.python import pywrap_tensorflow\r\nfrom tensorflow.python.client import session\r\nfrom tensorflow.python.framework import graph_util\r\nfrom tensorflow.python.framework import importer\r\nfrom tensorflow.python.platform import app\r\nfrom tensorflow.python.platform import gfile\r\nfrom tensorflow.python.training import saver as saver_lib\r\n\r\nFLAGS = None\r\n\r\n\r\ndef freeze_graph(input_graph,\r\n                 input_saver,\r\n                 input_binary,\r\n                 input_checkpoint,\r\n                 output_node_names,\r\n                 restore_op_name,\r\n                 filename_tensor_name,\r\n                 output_graph,\r\n                 clear_devices,\r\n                 initializer_nodes,\r\n                 variable_names_blacklist=\"\"):\r\n  \"\"\"Converts all variables in a graph and checkpoint into constants.\"\"\"\r\n\r\n  del restore_op_name, filename_tensor_name  # Unused by updated loading code.\r\n\r\n  if not gfile.Exists(input_graph):\r\n    print(\"Input graph file '\" + input_graph + \"' does not exist!\")\r\n    return -1\r\n\r\n  if input_saver and not gfile.Exists(input_saver):\r\n    print(\"Input saver file '\" + input_saver + \"' does not exist!\")\r\n    return -1\r\n\r\n  # 'input_checkpoint' may be a prefix if we're using Saver V2 format\r\n  if not saver_lib.checkpoint_exists(input_checkpoint):\r\n    print(\"Input checkpoint '\" + input_checkpoint + \"' doesn't exist!\")\r\n    return -1\r\n\r\n  if not output_node_names:\r\n    print(\"You need to supply the name of a node to --output_node_names.\")\r\n    return -1\r\n\r\n  input_graph_def = graph_pb2.GraphDef()\r\n  mode = \"rb\" if input_binary else \"r\"\r\n  with gfile.FastGFile(input_graph, mode) as f:\r\n    if input_binary:\r\n      input_graph_def.ParseFromString(f.read())\r\n    else:\r\n      text_format.Merge(f.read(), input_graph_def)\r\n  # Remove all the explicit device specifications for this node. This helps to\r\n  # make the graph more portable.\r\n  if clear_devices:\r\n    for node in input_graph_def.node:\r\n      node.device = \"\"\r\n\r\n  _ = importer.import_graph_def(input_graph_def, name=\"\")\r\n\r\n  with session.Session() as sess:\r\n    if input_saver:\r\n      with gfile.FastGFile(input_saver, mode) as f:\r\n        saver_def = saver_pb2.SaverDef()\r\n        if input_binary:\r\n          saver_def.ParseFromString(f.read())\r\n        else:\r\n          text_format.Merge(f.read(), saver_def)\r\n        saver = saver_lib.Saver(saver_def=saver_def)\r\n        saver.restore(sess, input_checkpoint)\r\n    else:\r\n      var_list = {}\r\n      reader = pywrap_tensorflow.NewCheckpointReader(input_checkpoint)\r\n      var_to_shape_map = reader.get_variable_to_shape_map()\r\n      for key in var_to_shape_map:\r\n        try:\r\n          tensor = sess.graph.get_tensor_by_name(key + \":0\")\r\n        except KeyError:\r\n          # This tensor doesn't exist in the graph (for example it's\r\n          # 'global_step' or a similar housekeeping element) so skip it.\r\n          continue\r\n        var_list[key] = tensor\r\n      saver = saver_lib.Saver(var_list=var_list)\r\n      saver.restore(sess, input_checkpoint)\r\n      if initializer_nodes:\r\n        sess.run(initializer_nodes)\r\n\r\n    variable_names_blacklist = (variable_names_blacklist.split(\",\") if\r\n                                variable_names_blacklist else None)\r\n    output_graph_def = graph_util.convert_variables_to_constants(\r\n        sess,\r\n        input_graph_def,\r\n        output_node_names.split(\",\"),\r\n        variable_names_blacklist=variable_names_blacklist)\r\n\r\n  with gfile.GFile(output_graph, \"wb\") as f:\r\n    f.write(output_graph_def.SerializeToString())\r\n  print(\"%d ops in the final graph.\" % len(output_graph_def.node))\r\n\r\n\r\ndef main(unused_args):\r\n  freeze_graph(FLAGS.input_graph, FLAGS.input_saver, FLAGS.input_binary,\r\n               FLAGS.input_checkpoint, FLAGS.output_node_names,\r\n               FLAGS.restore_op_name, FLAGS.filename_tensor_name,\r\n               FLAGS.output_graph, FLAGS.clear_devices, FLAGS.initializer_nodes,\r\n               FLAGS.variable_names_blacklist)\r\n\r\n\r\nif __name__ == \"__main__\":\r\n  parser = argparse.ArgumentParser()\r\n  parser.register(\"type\", \"bool\", lambda v: v.lower() == \"true\")\r\n  parser.add_argument(\r\n      \"--input_graph\",\r\n      type=str,\r\n      default=\"\",\r\n      help=\"TensorFlow \\'GraphDef\\' file to load.\")\r\n  parser.add_argument(\r\n      \"--input_saver\",\r\n      type=str,\r\n      default=\"\",\r\n      help=\"TensorFlow saver file to load.\")\r\n  parser.add_argument(\r\n      \"--input_checkpoint\",\r\n      type=str,\r\n      default=\"\",\r\n      help=\"TensorFlow variables file to load.\")\r\n  parser.add_argument(\r\n      \"--output_graph\",\r\n      type=str,\r\n      default=\"\",\r\n      help=\"Output \\'GraphDef\\' file name.\")\r\n  parser.add_argument(\r\n      \"--input_binary\",\r\n      nargs=\"?\",\r\n      const=True,\r\n      type=\"bool\",\r\n      default=False,\r\n      help=\"Whether the input files are in binary format.\")\r\n  parser.add_argument(\r\n      \"--output_node_names\",\r\n      type=str,\r\n      default=\"\",\r\n      help=\"The name of the output nodes, comma separated.\")\r\n  parser.add_argument(\r\n      \"--restore_op_name\",\r\n      type=str,\r\n      default=\"save/restore_all\",\r\n      help=\"The name of the master restore operator.\")\r\n  parser.add_argument(\r\n      \"--filename_tensor_name\",\r\n      type=str,\r\n      default=\"save/Const:0\",\r\n      help=\"The name of the tensor holding the save path.\")\r\n  parser.add_argument(\r\n      \"--clear_devices\",\r\n      nargs=\"?\",\r\n      const=True,\r\n      type=\"bool\",\r\n      default=True,\r\n      help=\"Whether to remove device specifications.\")\r\n  parser.add_argument(\r\n      \"--initializer_nodes\",\r\n      type=str,\r\n      default=\"\",\r\n      help=\"comma separated list of initializer nodes to run before freezing.\")\r\n  parser.add_argument(\r\n      \"--variable_names_blacklist\",\r\n      type=str,\r\n      default=\"\",\r\n      help=\"\"\"\\\r\n      comma separated list of variables to skip converting to constants\\\r\n      \"\"\")\r\n  FLAGS, unparsed = parser.parse_known_args()\r\n  app.run(main=main, argv=[sys.argv[0]] + unparsed)\r\n\r\n"}