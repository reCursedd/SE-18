{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/307514507", "html_url": "https://github.com/tensorflow/tensorflow/issues/9498#issuecomment-307514507", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9498", "id": 307514507, "node_id": "MDEyOklzc3VlQ29tbWVudDMwNzUxNDUwNw==", "user": {"login": "lancerts", "id": 7495155, "node_id": "MDQ6VXNlcjc0OTUxNTU=", "avatar_url": "https://avatars2.githubusercontent.com/u/7495155?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lancerts", "html_url": "https://github.com/lancerts", "followers_url": "https://api.github.com/users/lancerts/followers", "following_url": "https://api.github.com/users/lancerts/following{/other_user}", "gists_url": "https://api.github.com/users/lancerts/gists{/gist_id}", "starred_url": "https://api.github.com/users/lancerts/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lancerts/subscriptions", "organizations_url": "https://api.github.com/users/lancerts/orgs", "repos_url": "https://api.github.com/users/lancerts/repos", "events_url": "https://api.github.com/users/lancerts/events{/privacy}", "received_events_url": "https://api.github.com/users/lancerts/received_events", "type": "User", "site_admin": false}, "created_at": "2017-06-09T22:28:58Z", "updated_at": "2017-06-09T22:28:58Z", "author_association": "NONE", "body_html": "<p>Nice suggestion! This has puzzled me for weeks.<br>\nI just asked a question earlier in the stackover flow.</p>\n<p>Suppose we set every_n_steps = 100 so the monitor will be called every 100 steps.</p>\n<p>Also, suppose the input_fn function for the validation monitor will yield a streaming of data. Let's assume 10 batches.</p>\n<p>Case 1: the auc state is reset every time the validation monitor is called, there for, the streaming is done for the 10 batches in each validation step.</p>\n<p>Case 2: the auc state is NOT reset, so the streaming auc is computed from the first call of validation monitor. Namely, the first output (at 100 steps) is computed from 10 batches, the second validation output (at 200 steps) is computed based on the streaming auc after the first call and also the 10 batches fed in. The third output (at 300 steps) is computed based on the streaming auc after the second call and also the 10 batches fed in.</p>\n<p>Question1, which one of the scenarios is implemented?</p>\n<p>Question2, if we use tf.metrics.auc, what is the difference? In this doc they say:</p>\n<p>For estimation of the metric over a stream of data, the function creates an update_op operation that updates these variables and returns the auc.<br>\nso this also computes the streamed auc?!</p>\n<p>So, the streaming is from the very beginning or within each call for the validation monitor?<br>\nIf it is from the very beginning, i guess we have to initialize mannerly and do things like<br>\nfor i in range(n_epochs):<br>\ntf.initilize.local_variables()<br>\nm.fit(..)<br>\nwhich is not efficient....</p>", "body_text": "Nice suggestion! This has puzzled me for weeks.\nI just asked a question earlier in the stackover flow.\nSuppose we set every_n_steps = 100 so the monitor will be called every 100 steps.\nAlso, suppose the input_fn function for the validation monitor will yield a streaming of data. Let's assume 10 batches.\nCase 1: the auc state is reset every time the validation monitor is called, there for, the streaming is done for the 10 batches in each validation step.\nCase 2: the auc state is NOT reset, so the streaming auc is computed from the first call of validation monitor. Namely, the first output (at 100 steps) is computed from 10 batches, the second validation output (at 200 steps) is computed based on the streaming auc after the first call and also the 10 batches fed in. The third output (at 300 steps) is computed based on the streaming auc after the second call and also the 10 batches fed in.\nQuestion1, which one of the scenarios is implemented?\nQuestion2, if we use tf.metrics.auc, what is the difference? In this doc they say:\nFor estimation of the metric over a stream of data, the function creates an update_op operation that updates these variables and returns the auc.\nso this also computes the streamed auc?!\nSo, the streaming is from the very beginning or within each call for the validation monitor?\nIf it is from the very beginning, i guess we have to initialize mannerly and do things like\nfor i in range(n_epochs):\ntf.initilize.local_variables()\nm.fit(..)\nwhich is not efficient....", "body": "Nice suggestion! This has puzzled me for weeks.\r\nI just asked a question earlier in the stackover flow.\r\n\r\n\r\nSuppose we set every_n_steps = 100 so the monitor will be called every 100 steps.\r\n\r\nAlso, suppose the input_fn function for the validation monitor will yield a streaming of data. Let's assume 10 batches.\r\n\r\nCase 1: the auc state is reset every time the validation monitor is called, there for, the streaming is done for the 10 batches in each validation step.\r\n\r\nCase 2: the auc state is NOT reset, so the streaming auc is computed from the first call of validation monitor. Namely, the first output (at 100 steps) is computed from 10 batches, the second validation output (at 200 steps) is computed based on the streaming auc after the first call and also the 10 batches fed in. The third output (at 300 steps) is computed based on the streaming auc after the second call and also the 10 batches fed in.\r\n\r\nQuestion1, which one of the scenarios is implemented?\r\n\r\nQuestion2, if we use tf.metrics.auc, what is the difference? In this doc they say:\r\n\r\nFor estimation of the metric over a stream of data, the function creates an update_op operation that updates these variables and returns the auc.\r\nso this also computes the streamed auc?!\r\n\r\nSo, the streaming is from the very beginning or within each call for the validation monitor?\r\nIf it is from the very beginning, i guess we have to initialize mannerly and do things like\r\nfor i in range(n_epochs):\r\n   tf.initilize.local_variables()\r\n  m.fit(..)\r\nwhich is not efficient...."}