{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13683", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13683/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13683/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13683/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/13683", "id": 265225100, "node_id": "MDU6SXNzdWUyNjUyMjUxMDA=", "number": 13683, "title": "How to feed SparseTensor in C++ API?", "user": {"login": "formath", "id": 6040127, "node_id": "MDQ6VXNlcjYwNDAxMjc=", "avatar_url": "https://avatars3.githubusercontent.com/u/6040127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/formath", "html_url": "https://github.com/formath", "followers_url": "https://api.github.com/users/formath/followers", "following_url": "https://api.github.com/users/formath/following{/other_user}", "gists_url": "https://api.github.com/users/formath/gists{/gist_id}", "starred_url": "https://api.github.com/users/formath/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/formath/subscriptions", "organizations_url": "https://api.github.com/users/formath/orgs", "repos_url": "https://api.github.com/users/formath/repos", "events_url": "https://api.github.com/users/formath/events{/privacy}", "received_events_url": "https://api.github.com/users/formath/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 404586594, "node_id": "MDU6TGFiZWw0MDQ1ODY1OTQ=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:awaiting%20tensorflower", "name": "stat:awaiting tensorflower", "color": "f4b400", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2017-10-13T09:28:07Z", "updated_at": "2017-10-20T07:13:03Z", "closed_at": "2017-10-20T07:13:03Z", "author_association": "CONTRIBUTOR", "body_html": "<p>I trained model via python. After training done, I want to load the model and its checkpoint for prediction via C++. But I can't find any solutions about how to feed SparseTensor or Example in C++ API.</p>\n<p>python train code:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">with</span> tf.name_scope(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>input<span class=\"pl-pds\">'</span></span>):\n    filename_queue <span class=\"pl-k\">=</span> tf.train.string_input_producer(\n    tf.train.match_filenames_once(file_name), <span class=\"pl-v\">num_epochs</span><span class=\"pl-k\">=</span>max_epoch)\n    serialized_example <span class=\"pl-k\">=</span> <span class=\"pl-c1\">self</span>.Decode(filename_queue)\n    capacity <span class=\"pl-k\">=</span> thread_num <span class=\"pl-k\">*</span> batch_size <span class=\"pl-k\">+</span> min_after_dequeue\n    batch_serialized_example <span class=\"pl-k\">=</span> tf.train.shuffle_batch(\n                                    [serialized_example],\n                                    <span class=\"pl-v\">batch_size</span><span class=\"pl-k\">=</span>batch_size,\n                                    <span class=\"pl-v\">num_threads</span><span class=\"pl-k\">=</span>thread_num,\n                                    <span class=\"pl-v\">capacity</span><span class=\"pl-k\">=</span>capacity,\n                                    <span class=\"pl-v\">min_after_dequeue</span><span class=\"pl-k\">=</span>min_after_dequeue)\n    features <span class=\"pl-k\">=</span> {}\n    features[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>label<span class=\"pl-pds\">'</span></span>] <span class=\"pl-k\">=</span> tf.FixedLenFeature([], tf.float32)\n    features[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>continuous_feature<span class=\"pl-pds\">'</span></span>] <span class=\"pl-k\">=</span> tf.FixedLenFeature([], tf.float32)\n    features[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>sparse_id<span class=\"pl-pds\">'</span></span>] <span class=\"pl-k\">=</span> tf.VarLenFeature(tf.int64)\n    features[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>sparse_val<span class=\"pl-pds\">'</span></span>] <span class=\"pl-k\">=</span> tf.VarLenFeature(tf.float32)\n    instance <span class=\"pl-k\">=</span> tf.parse_example(batch_serialized_example, features)\n\n    label_tensor <span class=\"pl-k\">=</span> instance[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>label<span class=\"pl-pds\">'</span></span>]\n    continuous_feature_tensor <span class=\"pl-k\">=</span> instance[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>continuous_val<span class=\"pl-pds\">'</span></span>]\n    sparse_id_tensor <span class=\"pl-k\">=</span> instance[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>sparse_id<span class=\"pl-pds\">'</span></span>]\n    sparse_val_tensor <span class=\"pl-k\">=</span> instance[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>sparse_val<span class=\"pl-pds\">'</span></span>]\n\n<span class=\"pl-k\">with</span> tf.variable_scope(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>emb<span class=\"pl-pds\">\"</span></span>) <span class=\"pl-k\">as</span> scope:\n    embedding_variable <span class=\"pl-k\">=</span> tf.Variable(tf.truncated_normal([<span class=\"pl-c1\">1000000</span>, <span class=\"pl-c1\">50</span>], <span class=\"pl-v\">stddev</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">0.05</span>), <span class=\"pl-v\">name</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>emb_matrix<span class=\"pl-pds\">'</span></span>)\n    embedding <span class=\"pl-k\">=</span> tf.nn.embedding_lookup_sparse(embedding_variable, sparse_id_tensor, sparse_val_tensor, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>mod<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-v\">combiner</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span>sum<span class=\"pl-pds\">\"</span></span>)\nnet <span class=\"pl-k\">=</span> tf.concat([embedding, continuous_feature_tensor], <span class=\"pl-c1\">1</span>, <span class=\"pl-v\">name</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>concat<span class=\"pl-pds\">'</span></span>)\ndim <span class=\"pl-k\">=</span> net.get_shape().as_list()[<span class=\"pl-c1\">1</span>]\nweight <span class=\"pl-k\">=</span> tf.Variable(tf.truncated_normal([dim, <span class=\"pl-c1\">100</span>], <span class=\"pl-v\">stddev</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">0.05</span>), <span class=\"pl-v\">name</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>fully_weight<span class=\"pl-pds\">'</span></span>)\nbias <span class=\"pl-k\">=</span> tf.Variable(tf.truncated_normal([<span class=\"pl-c1\">100</span>], <span class=\"pl-v\">stddev</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">0.05</span>), <span class=\"pl-v\">name</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>fully_bias<span class=\"pl-pds\">'</span></span>)\nnet <span class=\"pl-k\">=</span> tf.matmul(net, weight) <span class=\"pl-k\">+</span> bias\ncross_entropy <span class=\"pl-k\">=</span> tf.nn.sparse_softmax_cross_entropy_with_logits(<span class=\"pl-v\">logits</span><span class=\"pl-k\">=</span>net, <span class=\"pl-v\">labels</span><span class=\"pl-k\">=</span>label_tensor, <span class=\"pl-v\">name</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>cross_entropy<span class=\"pl-pds\">'</span></span>)</pre></div>\n<p>In C++, all solutions I have found is to feed <code>vector&lt;pair&lt;string, Tensor&gt;&gt;</code> into <code>session.Run()</code>. However, in my model, I don't know which function in C++ I should use.</p>\n<p>Thanks.</p>\n<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=577277\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/martinwicke\">@martinwicke</a></p>", "body_text": "I trained model via python. After training done, I want to load the model and its checkpoint for prediction via C++. But I can't find any solutions about how to feed SparseTensor or Example in C++ API.\npython train code:\nwith tf.name_scope('input'):\n    filename_queue = tf.train.string_input_producer(\n    tf.train.match_filenames_once(file_name), num_epochs=max_epoch)\n    serialized_example = self.Decode(filename_queue)\n    capacity = thread_num * batch_size + min_after_dequeue\n    batch_serialized_example = tf.train.shuffle_batch(\n                                    [serialized_example],\n                                    batch_size=batch_size,\n                                    num_threads=thread_num,\n                                    capacity=capacity,\n                                    min_after_dequeue=min_after_dequeue)\n    features = {}\n    features['label'] = tf.FixedLenFeature([], tf.float32)\n    features['continuous_feature'] = tf.FixedLenFeature([], tf.float32)\n    features['sparse_id'] = tf.VarLenFeature(tf.int64)\n    features['sparse_val'] = tf.VarLenFeature(tf.float32)\n    instance = tf.parse_example(batch_serialized_example, features)\n\n    label_tensor = instance['label']\n    continuous_feature_tensor = instance['continuous_val']\n    sparse_id_tensor = instance['sparse_id']\n    sparse_val_tensor = instance['sparse_val']\n\nwith tf.variable_scope(\"emb\") as scope:\n    embedding_variable = tf.Variable(tf.truncated_normal([1000000, 50], stddev=0.05), name='emb_matrix')\n    embedding = tf.nn.embedding_lookup_sparse(embedding_variable, sparse_id_tensor, sparse_val_tensor, \"mod\", combiner=\"sum\")\nnet = tf.concat([embedding, continuous_feature_tensor], 1, name='concat')\ndim = net.get_shape().as_list()[1]\nweight = tf.Variable(tf.truncated_normal([dim, 100], stddev=0.05), name='fully_weight')\nbias = tf.Variable(tf.truncated_normal([100], stddev=0.05), name='fully_bias')\nnet = tf.matmul(net, weight) + bias\ncross_entropy = tf.nn.sparse_softmax_cross_entropy_with_logits(logits=net, labels=label_tensor, name='cross_entropy')\nIn C++, all solutions I have found is to feed vector<pair<string, Tensor>> into session.Run(). However, in my model, I don't know which function in C++ I should use.\nThanks.\n@martinwicke", "body": "I trained model via python. After training done, I want to load the model and its checkpoint for prediction via C++. But I can't find any solutions about how to feed SparseTensor or Example in C++ API.\r\n\r\npython train code:\r\n```python\r\nwith tf.name_scope('input'):\r\n    filename_queue = tf.train.string_input_producer(\r\n    tf.train.match_filenames_once(file_name), num_epochs=max_epoch)\r\n    serialized_example = self.Decode(filename_queue)\r\n    capacity = thread_num * batch_size + min_after_dequeue\r\n    batch_serialized_example = tf.train.shuffle_batch(\r\n                                    [serialized_example],\r\n                                    batch_size=batch_size,\r\n                                    num_threads=thread_num,\r\n                                    capacity=capacity,\r\n                                    min_after_dequeue=min_after_dequeue)\r\n    features = {}\r\n    features['label'] = tf.FixedLenFeature([], tf.float32)\r\n    features['continuous_feature'] = tf.FixedLenFeature([], tf.float32)\r\n    features['sparse_id'] = tf.VarLenFeature(tf.int64)\r\n    features['sparse_val'] = tf.VarLenFeature(tf.float32)\r\n    instance = tf.parse_example(batch_serialized_example, features)\r\n\r\n    label_tensor = instance['label']\r\n    continuous_feature_tensor = instance['continuous_val']\r\n    sparse_id_tensor = instance['sparse_id']\r\n    sparse_val_tensor = instance['sparse_val']\r\n\r\nwith tf.variable_scope(\"emb\") as scope:\r\n    embedding_variable = tf.Variable(tf.truncated_normal([1000000, 50], stddev=0.05), name='emb_matrix')\r\n    embedding = tf.nn.embedding_lookup_sparse(embedding_variable, sparse_id_tensor, sparse_val_tensor, \"mod\", combiner=\"sum\")\r\nnet = tf.concat([embedding, continuous_feature_tensor], 1, name='concat')\r\ndim = net.get_shape().as_list()[1]\r\nweight = tf.Variable(tf.truncated_normal([dim, 100], stddev=0.05), name='fully_weight')\r\nbias = tf.Variable(tf.truncated_normal([100], stddev=0.05), name='fully_bias')\r\nnet = tf.matmul(net, weight) + bias\r\ncross_entropy = tf.nn.sparse_softmax_cross_entropy_with_logits(logits=net, labels=label_tensor, name='cross_entropy')\r\n```\r\n\r\nIn C++, all solutions I have found is to feed `vector<pair<string, Tensor>>` into `session.Run()`. However, in my model, I don't know which function in C++ I should use. \r\n\r\nThanks.\r\n\r\n@martinwicke "}