{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/288141453", "html_url": "https://github.com/tensorflow/tensorflow/issues/8547#issuecomment-288141453", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8547", "id": 288141453, "node_id": "MDEyOklzc3VlQ29tbWVudDI4ODE0MTQ1Mw==", "user": {"login": "kayhan-batmanghelich", "id": 12301533, "node_id": "MDQ6VXNlcjEyMzAxNTMz", "avatar_url": "https://avatars2.githubusercontent.com/u/12301533?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kayhan-batmanghelich", "html_url": "https://github.com/kayhan-batmanghelich", "followers_url": "https://api.github.com/users/kayhan-batmanghelich/followers", "following_url": "https://api.github.com/users/kayhan-batmanghelich/following{/other_user}", "gists_url": "https://api.github.com/users/kayhan-batmanghelich/gists{/gist_id}", "starred_url": "https://api.github.com/users/kayhan-batmanghelich/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kayhan-batmanghelich/subscriptions", "organizations_url": "https://api.github.com/users/kayhan-batmanghelich/orgs", "repos_url": "https://api.github.com/users/kayhan-batmanghelich/repos", "events_url": "https://api.github.com/users/kayhan-batmanghelich/events{/privacy}", "received_events_url": "https://api.github.com/users/kayhan-batmanghelich/received_events", "type": "User", "site_admin": false}, "created_at": "2017-03-21T16:46:13Z", "updated_at": "2017-03-21T16:46:13Z", "author_association": "NONE", "body_html": "<p>OK. I was not sure that Hessian works correctly, so that code in the min code you need to compute the hessian of a quadratic function:<br>\n$ f(x) =  1/2* x^T A x + b^T x + c$<br>\nThe hessian of this function is A. In the code, you see:</p>\n<pre><code>            feed_dict = {A: np.float32(np.vstack([[1,2,3],[4,5,6],[7,8,9]])), \n                         b: np.float32(np.repeat(3,dim).reshape(dim,1)) , c: [1]}\n</code></pre>\n<p>and the function is defined here:</p>\n<pre><code>        fx = 0.5 * tf.matmul(tf.matmul(tf.transpose(x), A), x) + tf.matmul(tf.transpose(b), x) + c\n\n</code></pre>\n<p>So the result should be:</p>\n<pre><code>[[ 1.  2.  3.]\n [ 4.  5.  6.]\n [ 7.  8.  9.]]\n</code></pre>\n<p>I don't think this is misunderstanding of how TF work (it is possible) because the code is simple. Here is how the hessian is computed:</p>\n<pre><code>        # Get gradients of fx with repect to x\n        dfx = tf.gradients(fx, x)[0]\n        # Compute hessian\n        for i in range(dim):\n            dfx_i = tf.slice(dfx, begin=[i,0] , size=[1,1])\n            ddfx_i = tf.gradients(dfx_i, x)[0] \n\n            if i == 0: hess = [ ddfx_i ]\n            else: hess.append(ddfx_i) \n\n        # make a matrix from the list\n        hess = tf.stack(hess,axis=0)\n        hess = tf.squeeze(hess)\n</code></pre>\n<p>am I missing something?</p>", "body_text": "OK. I was not sure that Hessian works correctly, so that code in the min code you need to compute the hessian of a quadratic function:\n$ f(x) =  1/2* x^T A x + b^T x + c$\nThe hessian of this function is A. In the code, you see:\n            feed_dict = {A: np.float32(np.vstack([[1,2,3],[4,5,6],[7,8,9]])), \n                         b: np.float32(np.repeat(3,dim).reshape(dim,1)) , c: [1]}\n\nand the function is defined here:\n        fx = 0.5 * tf.matmul(tf.matmul(tf.transpose(x), A), x) + tf.matmul(tf.transpose(b), x) + c\n\n\nSo the result should be:\n[[ 1.  2.  3.]\n [ 4.  5.  6.]\n [ 7.  8.  9.]]\n\nI don't think this is misunderstanding of how TF work (it is possible) because the code is simple. Here is how the hessian is computed:\n        # Get gradients of fx with repect to x\n        dfx = tf.gradients(fx, x)[0]\n        # Compute hessian\n        for i in range(dim):\n            dfx_i = tf.slice(dfx, begin=[i,0] , size=[1,1])\n            ddfx_i = tf.gradients(dfx_i, x)[0] \n\n            if i == 0: hess = [ ddfx_i ]\n            else: hess.append(ddfx_i) \n\n        # make a matrix from the list\n        hess = tf.stack(hess,axis=0)\n        hess = tf.squeeze(hess)\n\nam I missing something?", "body": "OK. I was not sure that Hessian works correctly, so that code in the min code you need to compute the hessian of a quadratic function:\r\n$ f(x) =  1/2* x^T A x + b^T x + c$\r\nThe hessian of this function is A. In the code, you see:\r\n```\r\n            feed_dict = {A: np.float32(np.vstack([[1,2,3],[4,5,6],[7,8,9]])), \r\n                         b: np.float32(np.repeat(3,dim).reshape(dim,1)) , c: [1]}\r\n```\r\n\r\nand the function is defined here:\r\n```\r\n        fx = 0.5 * tf.matmul(tf.matmul(tf.transpose(x), A), x) + tf.matmul(tf.transpose(b), x) + c\r\n\r\n```\r\n\r\nSo the result should be:\r\n```\r\n[[ 1.  2.  3.]\r\n [ 4.  5.  6.]\r\n [ 7.  8.  9.]]\r\n```\r\n\r\nI don't think this is misunderstanding of how TF work (it is possible) because the code is simple. Here is how the hessian is computed:\r\n\r\n```\r\n        # Get gradients of fx with repect to x\r\n        dfx = tf.gradients(fx, x)[0]\r\n        # Compute hessian\r\n        for i in range(dim):\r\n            dfx_i = tf.slice(dfx, begin=[i,0] , size=[1,1])\r\n            ddfx_i = tf.gradients(dfx_i, x)[0] \r\n\r\n            if i == 0: hess = [ ddfx_i ]\r\n            else: hess.append(ddfx_i) \r\n\r\n        # make a matrix from the list\r\n        hess = tf.stack(hess,axis=0)\r\n        hess = tf.squeeze(hess)\r\n```\r\n\r\nam I missing something?\r\n\r\n "}