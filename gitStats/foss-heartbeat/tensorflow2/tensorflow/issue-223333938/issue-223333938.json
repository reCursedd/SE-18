{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9357", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9357/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9357/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9357/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/9357", "id": 223333938, "node_id": "MDU6SXNzdWUyMjMzMzM5Mzg=", "number": 9357, "title": "init_op and concurrent.futures freeze forever", "user": {"login": "morgangiraud", "id": 1278248, "node_id": "MDQ6VXNlcjEyNzgyNDg=", "avatar_url": "https://avatars0.githubusercontent.com/u/1278248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/morgangiraud", "html_url": "https://github.com/morgangiraud", "followers_url": "https://api.github.com/users/morgangiraud/followers", "following_url": "https://api.github.com/users/morgangiraud/following{/other_user}", "gists_url": "https://api.github.com/users/morgangiraud/gists{/gist_id}", "starred_url": "https://api.github.com/users/morgangiraud/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/morgangiraud/subscriptions", "organizations_url": "https://api.github.com/users/morgangiraud/orgs", "repos_url": "https://api.github.com/users/morgangiraud/repos", "events_url": "https://api.github.com/users/morgangiraud/events{/privacy}", "received_events_url": "https://api.github.com/users/morgangiraud/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 386191887, "node_id": "MDU6TGFiZWwzODYxOTE4ODc=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:awaiting%20response", "name": "stat:awaiting response", "color": "f4b400", "default": false}, {"id": 473172988, "node_id": "MDU6TGFiZWw0NzMxNzI5ODg=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:bug/performance", "name": "type:bug/performance", "color": "159b2e", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2017-04-21T09:46:50Z", "updated_at": "2017-06-16T21:06:10Z", "closed_at": "2017-06-16T21:06:10Z", "author_association": "NONE", "body_html": "<h2><strong>System Information:</strong></h2>\n<p>OS Platform and Distribution: MAC OSX<br>\nTensorFlow installed from: <code>pip install tensorflow</code><br>\nTensorFlow version : 1.0.0<br>\nPython version : Python 3.6.1</p>\n<p>I found a  bug trying to run multiple agent in parallel using python, it boiled down to the code below:</p>\n<ul>\n<li>If i try to init an agent asynchronously after init an agent synchronously, it freezes forever</li>\n<li>if i do it the other way around, everything is fine</li>\n</ul>\n<p>Does anyone has an idea on this one?</p>\n<h2><strong>Source Code:</strong></h2>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">import</span> tensorflow <span class=\"pl-k\">as</span> tf\n<span class=\"pl-k\">import</span> concurrent.futures\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> Very basic model</span>\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">Agent</span>(<span class=\"pl-c1\">object</span>):\n    <span class=\"pl-k\">def</span> <span class=\"pl-c1\">__init__</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>):\n        graph <span class=\"pl-k\">=</span> tf.Graph()\n        <span class=\"pl-k\">with</span> graph.as_default():\n            <span class=\"pl-c1\">self</span>.Qs <span class=\"pl-k\">=</span> tf.get_variable(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>Qs<span class=\"pl-pds\">'</span></span>, <span class=\"pl-v\">shape</span><span class=\"pl-k\">=</span>[<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">1</span>])\n            <span class=\"pl-c1\">self</span>.init_op <span class=\"pl-k\">=</span> tf.global_variables_initializer()\n        <span class=\"pl-c1\">self</span>.sess <span class=\"pl-k\">=</span> tf.Session(<span class=\"pl-v\">graph</span><span class=\"pl-k\">=</span>graph)\n\n        <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>Before init_op<span class=\"pl-pds\">'</span></span>)\n        <span class=\"pl-c1\">self</span>.sess.run(<span class=\"pl-c1\">self</span>.init_op)\n        <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>After init_op<span class=\"pl-pds\">'</span></span>)\n\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">execute_run</span>():\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>In execute<span class=\"pl-pds\">'</span></span>)\n    agent <span class=\"pl-k\">=</span> Agent()\n\n<span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>*** First: we create an agent asynchronously<span class=\"pl-pds\">'</span></span>)\n<span class=\"pl-k\">with</span> concurrent.futures.ProcessPoolExecutor(<span class=\"pl-c1\">1</span>) <span class=\"pl-k\">as</span> executor:\n    concurrent.futures.wait([executor.submit(execute_run)])\n\n<span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>*** Then: we create an agent synchronously<span class=\"pl-pds\">'</span></span>)\nagent <span class=\"pl-k\">=</span> Agent()\n\n<span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>So far, everything is fine<span class=\"pl-pds\">'</span></span>)\n\n\n<span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>*** Finally: we create an agent asynchronously again<span class=\"pl-pds\">'</span></span>)\n<span class=\"pl-k\">with</span> concurrent.futures.ProcessPoolExecutor(<span class=\"pl-c1\">1</span>) <span class=\"pl-k\">as</span> executor:\n    concurrent.futures.wait([executor.submit(execute_run)])\n\n<span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>You<span class=\"pl-cce\">\\'</span>ll never see this as we  can<span class=\"pl-cce\">\\'</span>t get passed the init_op<span class=\"pl-pds\">'</span></span>)</pre></div>\n<h2><strong>output:</strong></h2>\n<div class=\"highlight highlight-source-shell\"><pre><span class=\"pl-k\">***</span> First: we create an agent asynchronously\nIn execute\nBefore init_op\nAfter init_op\n<span class=\"pl-k\">***</span> Then: we create an agent synchronously\nBefore init_op\nAfter init_op\nSo far, everything is fine\n<span class=\"pl-k\">***</span> Finally: we create an agent asynchronously again\nIn execute\nBefore init_op</pre></div>", "body_text": "System Information:\nOS Platform and Distribution: MAC OSX\nTensorFlow installed from: pip install tensorflow\nTensorFlow version : 1.0.0\nPython version : Python 3.6.1\nI found a  bug trying to run multiple agent in parallel using python, it boiled down to the code below:\n\nIf i try to init an agent asynchronously after init an agent synchronously, it freezes forever\nif i do it the other way around, everything is fine\n\nDoes anyone has an idea on this one?\nSource Code:\nimport tensorflow as tf\nimport concurrent.futures\n\n# Very basic model\nclass Agent(object):\n    def __init__(self):\n        graph = tf.Graph()\n        with graph.as_default():\n            self.Qs = tf.get_variable('Qs', shape=[1, 1])\n            self.init_op = tf.global_variables_initializer()\n        self.sess = tf.Session(graph=graph)\n\n        print('Before init_op')\n        self.sess.run(self.init_op)\n        print('After init_op')\n\n\ndef execute_run():\n    print('In execute')\n    agent = Agent()\n\nprint('*** First: we create an agent asynchronously')\nwith concurrent.futures.ProcessPoolExecutor(1) as executor:\n    concurrent.futures.wait([executor.submit(execute_run)])\n\nprint('*** Then: we create an agent synchronously')\nagent = Agent()\n\nprint('So far, everything is fine')\n\n\nprint('*** Finally: we create an agent asynchronously again')\nwith concurrent.futures.ProcessPoolExecutor(1) as executor:\n    concurrent.futures.wait([executor.submit(execute_run)])\n\nprint('You\\'ll never see this as we  can\\'t get passed the init_op')\noutput:\n*** First: we create an agent asynchronously\nIn execute\nBefore init_op\nAfter init_op\n*** Then: we create an agent synchronously\nBefore init_op\nAfter init_op\nSo far, everything is fine\n*** Finally: we create an agent asynchronously again\nIn execute\nBefore init_op", "body": "## **System Information:**\r\n\r\nOS Platform and Distribution: MAC OSX\r\nTensorFlow installed from: `pip install tensorflow` \r\nTensorFlow version : 1.0.0\r\nPython version : Python 3.6.1\r\n\r\nI found a  bug trying to run multiple agent in parallel using python, it boiled down to the code below:\r\n- If i try to init an agent asynchronously after init an agent synchronously, it freezes forever\r\n- if i do it the other way around, everything is fine\r\n\r\nDoes anyone has an idea on this one?\r\n\r\n## **Source Code:**\r\n```python\r\nimport tensorflow as tf\r\nimport concurrent.futures\r\n\r\n# Very basic model\r\nclass Agent(object):\r\n    def __init__(self):\r\n        graph = tf.Graph()\r\n        with graph.as_default():\r\n            self.Qs = tf.get_variable('Qs', shape=[1, 1])\r\n            self.init_op = tf.global_variables_initializer()\r\n        self.sess = tf.Session(graph=graph)\r\n\r\n        print('Before init_op')\r\n        self.sess.run(self.init_op)\r\n        print('After init_op')\r\n\r\n\r\ndef execute_run():\r\n    print('In execute')\r\n    agent = Agent()\r\n\r\nprint('*** First: we create an agent asynchronously')\r\nwith concurrent.futures.ProcessPoolExecutor(1) as executor:\r\n    concurrent.futures.wait([executor.submit(execute_run)])\r\n\r\nprint('*** Then: we create an agent synchronously')\r\nagent = Agent()\r\n\r\nprint('So far, everything is fine')\r\n\r\n\r\nprint('*** Finally: we create an agent asynchronously again')\r\nwith concurrent.futures.ProcessPoolExecutor(1) as executor:\r\n    concurrent.futures.wait([executor.submit(execute_run)])\r\n\r\nprint('You\\'ll never see this as we  can\\'t get passed the init_op')\r\n```\r\n\r\n## **output:**\r\n```bash\r\n*** First: we create an agent asynchronously\r\nIn execute\r\nBefore init_op\r\nAfter init_op\r\n*** Then: we create an agent synchronously\r\nBefore init_op\r\nAfter init_op\r\nSo far, everything is fine\r\n*** Finally: we create an agent asynchronously again\r\nIn execute\r\nBefore init_op\r\n```"}