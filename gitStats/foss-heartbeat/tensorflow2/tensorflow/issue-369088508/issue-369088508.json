{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/22894", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/22894/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/22894/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/22894/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/22894", "id": 369088508, "node_id": "MDU6SXNzdWUzNjkwODg1MDg=", "number": 22894, "title": "Can't use CTCBeamSearchDecoder in c++, LINK ERROR occur,BUG in CTCBeamSearchDecoder 's source code", "user": {"login": "yjcn", "id": 8858803, "node_id": "MDQ6VXNlcjg4NTg4MDM=", "avatar_url": "https://avatars3.githubusercontent.com/u/8858803?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yjcn", "html_url": "https://github.com/yjcn", "followers_url": "https://api.github.com/users/yjcn/followers", "following_url": "https://api.github.com/users/yjcn/following{/other_user}", "gists_url": "https://api.github.com/users/yjcn/gists{/gist_id}", "starred_url": "https://api.github.com/users/yjcn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yjcn/subscriptions", "organizations_url": "https://api.github.com/users/yjcn/orgs", "repos_url": "https://api.github.com/users/yjcn/repos", "events_url": "https://api.github.com/users/yjcn/events{/privacy}", "received_events_url": "https://api.github.com/users/yjcn/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "open", "locked": false, "assignee": {"login": "ebrevdo", "id": 1794715, "node_id": "MDQ6VXNlcjE3OTQ3MTU=", "avatar_url": "https://avatars0.githubusercontent.com/u/1794715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebrevdo", "html_url": "https://github.com/ebrevdo", "followers_url": "https://api.github.com/users/ebrevdo/followers", "following_url": "https://api.github.com/users/ebrevdo/following{/other_user}", "gists_url": "https://api.github.com/users/ebrevdo/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebrevdo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebrevdo/subscriptions", "organizations_url": "https://api.github.com/users/ebrevdo/orgs", "repos_url": "https://api.github.com/users/ebrevdo/repos", "events_url": "https://api.github.com/users/ebrevdo/events{/privacy}", "received_events_url": "https://api.github.com/users/ebrevdo/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "ebrevdo", "id": 1794715, "node_id": "MDQ6VXNlcjE3OTQ3MTU=", "avatar_url": "https://avatars0.githubusercontent.com/u/1794715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebrevdo", "html_url": "https://github.com/ebrevdo", "followers_url": "https://api.github.com/users/ebrevdo/followers", "following_url": "https://api.github.com/users/ebrevdo/following{/other_user}", "gists_url": "https://api.github.com/users/ebrevdo/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebrevdo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebrevdo/subscriptions", "organizations_url": "https://api.github.com/users/ebrevdo/orgs", "repos_url": "https://api.github.com/users/ebrevdo/repos", "events_url": "https://api.github.com/users/ebrevdo/events{/privacy}", "received_events_url": "https://api.github.com/users/ebrevdo/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 3, "created_at": "2018-10-11T12:04:02Z", "updated_at": "2018-11-19T01:59:28Z", "closed_at": null, "author_association": "NONE", "body_html": "<h3>System information</h3>\n<ul>\n<li><strong>Have I written custom code (as opposed to using a stock example script provided in TensorFlow)</strong>:NO</li>\n<li><strong>OS Platform and Distribution (e.g., Linux Ubuntu 16.04)</strong>: Windows 10 Pro 1803</li>\n<li><strong>Mobile device (e.g. iPhone 8, Pixel 2, Samsung Galaxy) if the issue happens on mobile device</strong>:N/A</li>\n<li><strong>TensorFlow installed from (source or binary)</strong>: from source</li>\n<li><strong>TensorFlow version (use command below)</strong>: r1.4  and r1.10</li>\n<li><strong>Python version</strong>: 3.6</li>\n<li><strong>Bazel version (if compiling from source)</strong>: cmake 3.12.2</li>\n<li><strong>GCC/Compiler version (if compiling from source)</strong>: VS 2015</li>\n<li><strong>CUDA/cuDNN version</strong>: N/A</li>\n<li><strong>GPU model and memory</strong>: N/A</li>\n<li><strong>Exact command to reproduce</strong>:N/A</li>\n</ul>\n<h3>Describe the problem</h3>\n<p>I want to use <a href=\"https://github.com/tensorflow/tensorflow/blob/r1.10/tensorflow/core/util/ctc/ctc_beam_search.h\">CTCBeamSearchDecoder </a>, but there is a link error when I call CTCBeamSearchDecoder  constructor  function(<code>CTCBeamSearchDecoder&lt;&gt; decoder(num_classes, 10 * top_paths, &amp;default_scorer);</code>).  And I comment the constructor  function, the error disappear.  I test the r1.4 tensorflow.lib complied by myself with cmake and r1.10 <a href=\"https://github.com/fo40225/tensorflow-windows-wheel/tree/master/1.10.0/cpp\">download from github</a> . <strong>So I think there might be a bug in CTCBeamSearchDecoder  's source code.</strong></p>\n<h3>Source code / logs</h3>\n<p>This is the test code which is from <a href=\"https://github.com/tensorflow/tensorflow/blob/r1.10/tensorflow/core/util/ctc/ctc_beam_search_test.cc\">ctc_beam_search_test.cc</a>. The code is very simple.</p>\n<pre><code>#include \"third_party/eigen3/Eigen/Core\"\n//#include \"tensorflow/core/platform/env.h\"\n#include \"tensorflow/core/util/ctc/ctc_beam_search.h\"\n#include &lt;vector&gt;\nvoid test()\n{\n\tusing tensorflow::ctc::CTCBeamSearchDecoder;\n\tusing tensorflow::ctc::CTCDecoder;\n\tconst int batch_size = 1;\n\tconst int timesteps = 5;\n\tconst int top_paths = 3;\n\tconst int num_classes = 6;\n\n\t// Plain decoder using hibernating beam search algorithm.\n\tCTCBeamSearchDecoder&lt;&gt;::DefaultBeamScorer default_scorer;\n        //COMMENT AND NO ERROR\n\tCTCBeamSearchDecoder&lt;&gt; decoder(num_classes, 10 * top_paths, &amp;default_scorer);\n\n\t// Dictionary decoder, allowing only two dictionary words : {3}, {3, 1}.\n\t//DictionaryBeamScorer dictionary_scorer;\n\t//CTCBeamSearchDecoder&lt;HistoryBeamState&gt; dictionary_decoder(num_classes, top_paths, &amp;dictionary_scorer);\n\n\t// Raw data containers (arrays of floats, ints, etc.).\n\tint sequence_lengths[batch_size] = { timesteps };\n\tfloat input_data_mat[timesteps][batch_size][num_classes] = {\n\t\t{ { 0, 0.6, 0, 0.4, 0, 0 } },\n\t\t{ { 0, 0.5, 0, 0.5, 0, 0 } },\n\t\t{ { 0, 0.4, 0, 0.6, 0, 0 } },\n\t\t{ { 0, 0.4, 0, 0.6, 0, 0 } },\n\t\t{ { 0, 0.4, 0, 0.6, 0, 0 } } };\n\n\t// The CTCDecoder works with log-probs.\n\tfor (int t = 0; t &lt; timesteps; ++t) {\n\t\tfor (int b = 0; b &lt; batch_size; ++b) {\n\t\t\tfor (int c = 0; c &lt; num_classes; ++c) {\n\t\t\t\tinput_data_mat[t][b][c] = std::log(input_data_mat[t][b][c]);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Plain output, without any additional scoring.\n\tstd::vector&lt;CTCDecoder::Output&gt; expected_output = {\n\t\t{ { 1, 3 },{ 1, 3, 1 },{ 3, 1, 3 } },\n\t};\n\n\t// Dictionary outputs: preference for dictionary candidates. The\n\t// second-candidate is there, despite it not being a dictionary word, due to\n\t// stronger probability in the input to the decoder.\n\tstd::vector&lt;CTCDecoder::Output&gt; expected_dict_output = {\n\t\t{ { 3 },{ 1, 3 },{ 3, 1 } },\n\t};\n\n\t// Convert data containers to the format accepted by the decoder, simply\n\t// mapping the memory from the container to an Eigen::ArrayXi,::MatrixXf,\n\t// using Eigen::Map.\n\tEigen::Map&lt;const Eigen::ArrayXi&gt; seq_len(&amp;sequence_lengths[0], batch_size);\n\tstd::vector&lt;Eigen::Map&lt;const Eigen::MatrixXf&gt;&gt; inputs;\n\tinputs.reserve(timesteps);\n\tfor (int t = 0; t &lt; timesteps; ++t) {\n\t\tinputs.emplace_back(&amp;input_data_mat[t][0][0], batch_size, num_classes);\n\t}\n\n\t// Prepare containers for output and scores.\n\tstd::vector&lt;CTCDecoder::Output&gt; outputs(top_paths);\n\tfor (CTCDecoder::Output&amp; output : outputs) {\n\t\toutput.resize(batch_size);\n\t}\n\tfloat score[batch_size][top_paths] = { { 0.0 } };\n\tEigen::Map&lt;Eigen::MatrixXf&gt; scores(&amp;score[0][0], batch_size, top_paths);\n}\nint main()\n{\n\ttest();\n\treturn 0;\n}\n\n</code></pre>\n<p>This is complier 's error log.</p>\n<pre><code>error LNK2001 unresolved external symbol  \"void __cdecl tensorflow::internal::MakeCheckOpValueString&lt;unsigned char&gt;(class std::basic_ostream&lt;char,struct std::char_traits&lt;char&gt; &gt; *,unsigned char const &amp;)\" (??$MakeCheckOpValueString@E@internal@tensorflow@@YAXPEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEBE@Z)\ttest1\tC:\\Users\\46099\\Desktop\\testtf\\test1\\test1\\main.obj\t1\n</code></pre>", "body_text": "System information\n\nHave I written custom code (as opposed to using a stock example script provided in TensorFlow):NO\nOS Platform and Distribution (e.g., Linux Ubuntu 16.04): Windows 10 Pro 1803\nMobile device (e.g. iPhone 8, Pixel 2, Samsung Galaxy) if the issue happens on mobile device:N/A\nTensorFlow installed from (source or binary): from source\nTensorFlow version (use command below): r1.4  and r1.10\nPython version: 3.6\nBazel version (if compiling from source): cmake 3.12.2\nGCC/Compiler version (if compiling from source): VS 2015\nCUDA/cuDNN version: N/A\nGPU model and memory: N/A\nExact command to reproduce:N/A\n\nDescribe the problem\nI want to use CTCBeamSearchDecoder , but there is a link error when I call CTCBeamSearchDecoder  constructor  function(CTCBeamSearchDecoder<> decoder(num_classes, 10 * top_paths, &default_scorer);).  And I comment the constructor  function, the error disappear.  I test the r1.4 tensorflow.lib complied by myself with cmake and r1.10 download from github . So I think there might be a bug in CTCBeamSearchDecoder  's source code.\nSource code / logs\nThis is the test code which is from ctc_beam_search_test.cc. The code is very simple.\n#include \"third_party/eigen3/Eigen/Core\"\n//#include \"tensorflow/core/platform/env.h\"\n#include \"tensorflow/core/util/ctc/ctc_beam_search.h\"\n#include <vector>\nvoid test()\n{\n\tusing tensorflow::ctc::CTCBeamSearchDecoder;\n\tusing tensorflow::ctc::CTCDecoder;\n\tconst int batch_size = 1;\n\tconst int timesteps = 5;\n\tconst int top_paths = 3;\n\tconst int num_classes = 6;\n\n\t// Plain decoder using hibernating beam search algorithm.\n\tCTCBeamSearchDecoder<>::DefaultBeamScorer default_scorer;\n        //COMMENT AND NO ERROR\n\tCTCBeamSearchDecoder<> decoder(num_classes, 10 * top_paths, &default_scorer);\n\n\t// Dictionary decoder, allowing only two dictionary words : {3}, {3, 1}.\n\t//DictionaryBeamScorer dictionary_scorer;\n\t//CTCBeamSearchDecoder<HistoryBeamState> dictionary_decoder(num_classes, top_paths, &dictionary_scorer);\n\n\t// Raw data containers (arrays of floats, ints, etc.).\n\tint sequence_lengths[batch_size] = { timesteps };\n\tfloat input_data_mat[timesteps][batch_size][num_classes] = {\n\t\t{ { 0, 0.6, 0, 0.4, 0, 0 } },\n\t\t{ { 0, 0.5, 0, 0.5, 0, 0 } },\n\t\t{ { 0, 0.4, 0, 0.6, 0, 0 } },\n\t\t{ { 0, 0.4, 0, 0.6, 0, 0 } },\n\t\t{ { 0, 0.4, 0, 0.6, 0, 0 } } };\n\n\t// The CTCDecoder works with log-probs.\n\tfor (int t = 0; t < timesteps; ++t) {\n\t\tfor (int b = 0; b < batch_size; ++b) {\n\t\t\tfor (int c = 0; c < num_classes; ++c) {\n\t\t\t\tinput_data_mat[t][b][c] = std::log(input_data_mat[t][b][c]);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Plain output, without any additional scoring.\n\tstd::vector<CTCDecoder::Output> expected_output = {\n\t\t{ { 1, 3 },{ 1, 3, 1 },{ 3, 1, 3 } },\n\t};\n\n\t// Dictionary outputs: preference for dictionary candidates. The\n\t// second-candidate is there, despite it not being a dictionary word, due to\n\t// stronger probability in the input to the decoder.\n\tstd::vector<CTCDecoder::Output> expected_dict_output = {\n\t\t{ { 3 },{ 1, 3 },{ 3, 1 } },\n\t};\n\n\t// Convert data containers to the format accepted by the decoder, simply\n\t// mapping the memory from the container to an Eigen::ArrayXi,::MatrixXf,\n\t// using Eigen::Map.\n\tEigen::Map<const Eigen::ArrayXi> seq_len(&sequence_lengths[0], batch_size);\n\tstd::vector<Eigen::Map<const Eigen::MatrixXf>> inputs;\n\tinputs.reserve(timesteps);\n\tfor (int t = 0; t < timesteps; ++t) {\n\t\tinputs.emplace_back(&input_data_mat[t][0][0], batch_size, num_classes);\n\t}\n\n\t// Prepare containers for output and scores.\n\tstd::vector<CTCDecoder::Output> outputs(top_paths);\n\tfor (CTCDecoder::Output& output : outputs) {\n\t\toutput.resize(batch_size);\n\t}\n\tfloat score[batch_size][top_paths] = { { 0.0 } };\n\tEigen::Map<Eigen::MatrixXf> scores(&score[0][0], batch_size, top_paths);\n}\nint main()\n{\n\ttest();\n\treturn 0;\n}\n\n\nThis is complier 's error log.\nerror LNK2001 unresolved external symbol  \"void __cdecl tensorflow::internal::MakeCheckOpValueString<unsigned char>(class std::basic_ostream<char,struct std::char_traits<char> > *,unsigned char const &)\" (??$MakeCheckOpValueString@E@internal@tensorflow@@YAXPEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEBE@Z)\ttest1\tC:\\Users\\46099\\Desktop\\testtf\\test1\\test1\\main.obj\t1", "body": "### System information\r\n- **Have I written custom code (as opposed to using a stock example script provided in TensorFlow)**:NO\r\n- **OS Platform and Distribution (e.g., Linux Ubuntu 16.04)**: Windows 10 Pro 1803\r\n- **Mobile device (e.g. iPhone 8, Pixel 2, Samsung Galaxy) if the issue happens on mobile device**:N/A\r\n- **TensorFlow installed from (source or binary)**: from source\r\n- **TensorFlow version (use command below)**: r1.4  and r1.10\r\n- **Python version**: 3.6\r\n- **Bazel version (if compiling from source)**: cmake 3.12.2\r\n- **GCC/Compiler version (if compiling from source)**: VS 2015\r\n- **CUDA/cuDNN version**: N/A\r\n- **GPU model and memory**: N/A\r\n- **Exact command to reproduce**:N/A\r\n\r\n### Describe the problem\r\n I want to use [CTCBeamSearchDecoder ](https://github.com/tensorflow/tensorflow/blob/r1.10/tensorflow/core/util/ctc/ctc_beam_search.h), but there is a link error when I call CTCBeamSearchDecoder  constructor  function(`CTCBeamSearchDecoder<> decoder(num_classes, 10 * top_paths, &default_scorer);`).  And I comment the constructor  function, the error disappear.  I test the r1.4 tensorflow.lib complied by myself with cmake and r1.10 [download from github](https://github.com/fo40225/tensorflow-windows-wheel/tree/master/1.10.0/cpp) . **So I think there might be a bug in CTCBeamSearchDecoder  's source code.**\t\r\n### Source code / logs\r\nThis is the test code which is from [ctc_beam_search_test.cc](https://github.com/tensorflow/tensorflow/blob/r1.10/tensorflow/core/util/ctc/ctc_beam_search_test.cc). The code is very simple.\r\n```\r\n#include \"third_party/eigen3/Eigen/Core\"\r\n//#include \"tensorflow/core/platform/env.h\"\r\n#include \"tensorflow/core/util/ctc/ctc_beam_search.h\"\r\n#include <vector>\r\nvoid test()\r\n{\r\n\tusing tensorflow::ctc::CTCBeamSearchDecoder;\r\n\tusing tensorflow::ctc::CTCDecoder;\r\n\tconst int batch_size = 1;\r\n\tconst int timesteps = 5;\r\n\tconst int top_paths = 3;\r\n\tconst int num_classes = 6;\r\n\r\n\t// Plain decoder using hibernating beam search algorithm.\r\n\tCTCBeamSearchDecoder<>::DefaultBeamScorer default_scorer;\r\n        //COMMENT AND NO ERROR\r\n\tCTCBeamSearchDecoder<> decoder(num_classes, 10 * top_paths, &default_scorer);\r\n\r\n\t// Dictionary decoder, allowing only two dictionary words : {3}, {3, 1}.\r\n\t//DictionaryBeamScorer dictionary_scorer;\r\n\t//CTCBeamSearchDecoder<HistoryBeamState> dictionary_decoder(num_classes, top_paths, &dictionary_scorer);\r\n\r\n\t// Raw data containers (arrays of floats, ints, etc.).\r\n\tint sequence_lengths[batch_size] = { timesteps };\r\n\tfloat input_data_mat[timesteps][batch_size][num_classes] = {\r\n\t\t{ { 0, 0.6, 0, 0.4, 0, 0 } },\r\n\t\t{ { 0, 0.5, 0, 0.5, 0, 0 } },\r\n\t\t{ { 0, 0.4, 0, 0.6, 0, 0 } },\r\n\t\t{ { 0, 0.4, 0, 0.6, 0, 0 } },\r\n\t\t{ { 0, 0.4, 0, 0.6, 0, 0 } } };\r\n\r\n\t// The CTCDecoder works with log-probs.\r\n\tfor (int t = 0; t < timesteps; ++t) {\r\n\t\tfor (int b = 0; b < batch_size; ++b) {\r\n\t\t\tfor (int c = 0; c < num_classes; ++c) {\r\n\t\t\t\tinput_data_mat[t][b][c] = std::log(input_data_mat[t][b][c]);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Plain output, without any additional scoring.\r\n\tstd::vector<CTCDecoder::Output> expected_output = {\r\n\t\t{ { 1, 3 },{ 1, 3, 1 },{ 3, 1, 3 } },\r\n\t};\r\n\r\n\t// Dictionary outputs: preference for dictionary candidates. The\r\n\t// second-candidate is there, despite it not being a dictionary word, due to\r\n\t// stronger probability in the input to the decoder.\r\n\tstd::vector<CTCDecoder::Output> expected_dict_output = {\r\n\t\t{ { 3 },{ 1, 3 },{ 3, 1 } },\r\n\t};\r\n\r\n\t// Convert data containers to the format accepted by the decoder, simply\r\n\t// mapping the memory from the container to an Eigen::ArrayXi,::MatrixXf,\r\n\t// using Eigen::Map.\r\n\tEigen::Map<const Eigen::ArrayXi> seq_len(&sequence_lengths[0], batch_size);\r\n\tstd::vector<Eigen::Map<const Eigen::MatrixXf>> inputs;\r\n\tinputs.reserve(timesteps);\r\n\tfor (int t = 0; t < timesteps; ++t) {\r\n\t\tinputs.emplace_back(&input_data_mat[t][0][0], batch_size, num_classes);\r\n\t}\r\n\r\n\t// Prepare containers for output and scores.\r\n\tstd::vector<CTCDecoder::Output> outputs(top_paths);\r\n\tfor (CTCDecoder::Output& output : outputs) {\r\n\t\toutput.resize(batch_size);\r\n\t}\r\n\tfloat score[batch_size][top_paths] = { { 0.0 } };\r\n\tEigen::Map<Eigen::MatrixXf> scores(&score[0][0], batch_size, top_paths);\r\n}\r\nint main()\r\n{\r\n\ttest();\r\n\treturn 0;\r\n}\r\n\r\n```\r\nThis is complier 's error log.\r\n```\r\nerror LNK2001 unresolved external symbol  \"void __cdecl tensorflow::internal::MakeCheckOpValueString<unsigned char>(class std::basic_ostream<char,struct std::char_traits<char> > *,unsigned char const &)\" (??$MakeCheckOpValueString@E@internal@tensorflow@@YAXPEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEBE@Z)\ttest1\tC:\\Users\\46099\\Desktop\\testtf\\test1\\test1\\main.obj\t1\r\n```\r\n"}