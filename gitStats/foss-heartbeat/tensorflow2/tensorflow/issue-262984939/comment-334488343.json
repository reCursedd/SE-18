{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/334488343", "html_url": "https://github.com/tensorflow/tensorflow/issues/13498#issuecomment-334488343", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13498", "id": 334488343, "node_id": "MDEyOklzc3VlQ29tbWVudDMzNDQ4ODM0Mw==", "user": {"login": "eaplatanios", "id": 1294940, "node_id": "MDQ6VXNlcjEyOTQ5NDA=", "avatar_url": "https://avatars2.githubusercontent.com/u/1294940?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eaplatanios", "html_url": "https://github.com/eaplatanios", "followers_url": "https://api.github.com/users/eaplatanios/followers", "following_url": "https://api.github.com/users/eaplatanios/following{/other_user}", "gists_url": "https://api.github.com/users/eaplatanios/gists{/gist_id}", "starred_url": "https://api.github.com/users/eaplatanios/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eaplatanios/subscriptions", "organizations_url": "https://api.github.com/users/eaplatanios/orgs", "repos_url": "https://api.github.com/users/eaplatanios/repos", "events_url": "https://api.github.com/users/eaplatanios/events{/privacy}", "received_events_url": "https://api.github.com/users/eaplatanios/received_events", "type": "User", "site_admin": false}, "created_at": "2017-10-05T14:48:06Z", "updated_at": "2017-10-05T14:48:06Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Hey <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=88808\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/skye\">@skye</a>! :) That's great! Regarding the executor, I feel that, it should at least guarantee that the graph will not be serialized before session creation. In the case of nodes and <code>NodeDef</code>s though, I noticed that the node def is finalized when the node builder's finalize method is called and is probably used as is by the executor after that. I feel that this shouldn't really be happening. In either case, these are all edge cases I guess that are not even supported by the public API and so I understand that they are not a priority.</p>\n<p>By the way, it might be worth also looking into the <code>ClearControlInputs</code> method because there will probably also be an issue there (although I haven't tested that).</p>\n<p>And yeah so, I was going to email you about that. I ended up implementing all of the control flow functionality (including conds and while loops) in the Scala side. There are a couple reasons for that:</p>\n<ul>\n<li>The C++ functionality will probably take a lot of time to come to a point where I can use it. I need to be able to provide implementation of unsupported gradients from the Scala side and I also need support for indexed slices and sparse tensors. Given that I already support all these constructs on my Scala API, it felt easier to just go with that.</li>\n<li>I've been needing that for my research and so this saves me lots of time.</li>\n<li>Also, I already support stacks (i.e., nested loops and combinations of conds and loops).<br>\nI've followed the Python implementation, while simplifying it wherever I could and re-structuring it a bit. The document helped a lot by the way, in getting a grasp of what's going on. :)</li>\n</ul>\n<p>I will push my implementation soon and link to it here if you want to use it and talk about it to help add support for nesting/stacks, etc. on the C++ side.</p>\n<p>As a side note, there are a couple of things I don't really like in how control flow support is currently implemented and if there is indeed a discussion going on about that, it may be worth mentioning them. I guess an important starting point would be to clear up what's happening with control dependencies when nesting control flow constructs. Currently, it's a bit too complicated for no good reason, I think.</p>", "body_text": "Hey @skye! :) That's great! Regarding the executor, I feel that, it should at least guarantee that the graph will not be serialized before session creation. In the case of nodes and NodeDefs though, I noticed that the node def is finalized when the node builder's finalize method is called and is probably used as is by the executor after that. I feel that this shouldn't really be happening. In either case, these are all edge cases I guess that are not even supported by the public API and so I understand that they are not a priority.\nBy the way, it might be worth also looking into the ClearControlInputs method because there will probably also be an issue there (although I haven't tested that).\nAnd yeah so, I was going to email you about that. I ended up implementing all of the control flow functionality (including conds and while loops) in the Scala side. There are a couple reasons for that:\n\nThe C++ functionality will probably take a lot of time to come to a point where I can use it. I need to be able to provide implementation of unsupported gradients from the Scala side and I also need support for indexed slices and sparse tensors. Given that I already support all these constructs on my Scala API, it felt easier to just go with that.\nI've been needing that for my research and so this saves me lots of time.\nAlso, I already support stacks (i.e., nested loops and combinations of conds and loops).\nI've followed the Python implementation, while simplifying it wherever I could and re-structuring it a bit. The document helped a lot by the way, in getting a grasp of what's going on. :)\n\nI will push my implementation soon and link to it here if you want to use it and talk about it to help add support for nesting/stacks, etc. on the C++ side.\nAs a side note, there are a couple of things I don't really like in how control flow support is currently implemented and if there is indeed a discussion going on about that, it may be worth mentioning them. I guess an important starting point would be to clear up what's happening with control dependencies when nesting control flow constructs. Currently, it's a bit too complicated for no good reason, I think.", "body": "Hey @skye! :) That's great! Regarding the executor, I feel that, it should at least guarantee that the graph will not be serialized before session creation. In the case of nodes and `NodeDef`s though, I noticed that the node def is finalized when the node builder's finalize method is called and is probably used as is by the executor after that. I feel that this shouldn't really be happening. In either case, these are all edge cases I guess that are not even supported by the public API and so I understand that they are not a priority.\r\n\r\nBy the way, it might be worth also looking into the `ClearControlInputs` method because there will probably also be an issue there (although I haven't tested that).\r\n\r\nAnd yeah so, I was going to email you about that. I ended up implementing all of the control flow functionality (including conds and while loops) in the Scala side. There are a couple reasons for that:\r\n- The C++ functionality will probably take a lot of time to come to a point where I can use it. I need to be able to provide implementation of unsupported gradients from the Scala side and I also need support for indexed slices and sparse tensors. Given that I already support all these constructs on my Scala API, it felt easier to just go with that.\r\n- I've been needing that for my research and so this saves me lots of time.\r\n- Also, I already support stacks (i.e., nested loops and combinations of conds and loops).\r\nI've followed the Python implementation, while simplifying it wherever I could and re-structuring it a bit. The document helped a lot by the way, in getting a grasp of what's going on. :)\r\n\r\nI will push my implementation soon and link to it here if you want to use it and talk about it to help add support for nesting/stacks, etc. on the C++ side.\r\n\r\nAs a side note, there are a couple of things I don't really like in how control flow support is currently implemented and if there is indeed a discussion going on about that, it may be worth mentioning them. I guess an important starting point would be to clear up what's happening with control dependencies when nesting control flow constructs. Currently, it's a bit too complicated for no good reason, I think."}