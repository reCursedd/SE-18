{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/334346344", "html_url": "https://github.com/tensorflow/tensorflow/issues/13498#issuecomment-334346344", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13498", "id": 334346344, "node_id": "MDEyOklzc3VlQ29tbWVudDMzNDM0NjM0NA==", "user": {"login": "eaplatanios", "id": 1294940, "node_id": "MDQ6VXNlcjEyOTQ5NDA=", "avatar_url": "https://avatars2.githubusercontent.com/u/1294940?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eaplatanios", "html_url": "https://github.com/eaplatanios", "followers_url": "https://api.github.com/users/eaplatanios/followers", "following_url": "https://api.github.com/users/eaplatanios/following{/other_user}", "gists_url": "https://api.github.com/users/eaplatanios/gists{/gist_id}", "starred_url": "https://api.github.com/users/eaplatanios/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eaplatanios/subscriptions", "organizations_url": "https://api.github.com/users/eaplatanios/orgs", "repos_url": "https://api.github.com/users/eaplatanios/repos", "events_url": "https://api.github.com/users/eaplatanios/events{/privacy}", "received_events_url": "https://api.github.com/users/eaplatanios/received_events", "type": "User", "site_admin": false}, "created_at": "2017-10-05T03:07:05Z", "updated_at": "2017-10-05T03:07:05Z", "author_association": "CONTRIBUTOR", "body_html": "<p>FYI, if you want to replicate that behavior using the Python API, you can do the following:</p>\n<ol>\n<li>Set <code>_USE_C_API</code> in <code>python/framework/ops.py</code> to <code>True</code>.</li>\n<li>Move this (in <code>python/framework/ops.py</code>):\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-c\"><span class=\"pl-c\">#</span> Add this op to the current control flow context:</span>\n<span class=\"pl-c1\">self</span>._control_flow_context <span class=\"pl-k\">=</span> g._get_control_flow_context()  <span class=\"pl-c\"><span class=\"pl-c\">#</span> pylint: disable=protected-access</span>\n<span class=\"pl-k\">if</span> <span class=\"pl-c1\">self</span>._control_flow_context <span class=\"pl-k\">is</span> <span class=\"pl-k\">not</span> <span class=\"pl-c1\">None</span>:\n  <span class=\"pl-c\"><span class=\"pl-c\">#</span> <span class=\"pl-k\">TODO</span>(skyewm): consider refactoring this to call self._create_c_op()</span>\n  <span class=\"pl-c\"><span class=\"pl-c\">#</span> first. This would require updating the TF_Operation's ID (see the</span>\n  <span class=\"pl-c\"><span class=\"pl-c\">#</span> comment and self._id_value update below). The disadvantage of calling</span>\n  <span class=\"pl-c\"><span class=\"pl-c\">#</span> AddOp() first is that we need to maintain Operation state that is</span>\n  <span class=\"pl-c\"><span class=\"pl-c\">#</span> accessed by AddOp() in Python, e.g. the input Tensors.</span>\n  <span class=\"pl-c1\">self</span>._control_flow_context.AddOp(<span class=\"pl-c1\">self</span>)</pre></div>\nafter the <code>_c_op</code> initialization.</li>\n<li>Try running the following simple script:\n<div class=\"highlight highlight-source-python\"><pre>p <span class=\"pl-k\">=</span> tf.constant(<span class=\"pl-c1\">True</span>)\nt <span class=\"pl-k\">=</span> <span class=\"pl-k\">lambda</span>: tf.constant(<span class=\"pl-c1\">True</span>)\nf <span class=\"pl-k\">=</span> <span class=\"pl-k\">lambda</span>: tf.constant(<span class=\"pl-c1\">False</span>)\nr <span class=\"pl-k\">=</span> tf.cond(p, t, f)\n<span class=\"pl-c1\">print</span>(r.eval(<span class=\"pl-v\">session</span><span class=\"pl-k\">=</span>tf.Session()))</pre></div>\n</li>\n</ol>\n<p>This will print <code>False</code>, even though it should be printing <code>True</code>. The reason is that the false branch output is fed into the merge op first.</p>\n<p>Also CCing <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=2469592\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/itsmeolivia\">@itsmeolivia</a> since I think she's been working on making the Python API to use the C API.</p>", "body_text": "FYI, if you want to replicate that behavior using the Python API, you can do the following:\n\nSet _USE_C_API in python/framework/ops.py to True.\nMove this (in python/framework/ops.py):\n# Add this op to the current control flow context:\nself._control_flow_context = g._get_control_flow_context()  # pylint: disable=protected-access\nif self._control_flow_context is not None:\n  # TODO(skyewm): consider refactoring this to call self._create_c_op()\n  # first. This would require updating the TF_Operation's ID (see the\n  # comment and self._id_value update below). The disadvantage of calling\n  # AddOp() first is that we need to maintain Operation state that is\n  # accessed by AddOp() in Python, e.g. the input Tensors.\n  self._control_flow_context.AddOp(self)\nafter the _c_op initialization.\nTry running the following simple script:\np = tf.constant(True)\nt = lambda: tf.constant(True)\nf = lambda: tf.constant(False)\nr = tf.cond(p, t, f)\nprint(r.eval(session=tf.Session()))\n\n\nThis will print False, even though it should be printing True. The reason is that the false branch output is fed into the merge op first.\nAlso CCing @itsmeolivia since I think she's been working on making the Python API to use the C API.", "body": "FYI, if you want to replicate that behavior using the Python API, you can do the following:\r\n\r\n1. Set `_USE_C_API` in `python/framework/ops.py` to `True`.\r\n2. Move this (in `python/framework/ops.py`):\r\n    ```python\r\n    # Add this op to the current control flow context:\r\n    self._control_flow_context = g._get_control_flow_context()  # pylint: disable=protected-access\r\n    if self._control_flow_context is not None:\r\n      # TODO(skyewm): consider refactoring this to call self._create_c_op()\r\n      # first. This would require updating the TF_Operation's ID (see the\r\n      # comment and self._id_value update below). The disadvantage of calling\r\n      # AddOp() first is that we need to maintain Operation state that is\r\n      # accessed by AddOp() in Python, e.g. the input Tensors.\r\n      self._control_flow_context.AddOp(self)\r\n    ```\r\n    after the `_c_op` initialization.\r\n3. Try running the following simple script:\r\n    ```python\r\n    p = tf.constant(True)\r\n    t = lambda: tf.constant(True)\r\n    f = lambda: tf.constant(False)\r\n    r = tf.cond(p, t, f)\r\n    print(r.eval(session=tf.Session()))\r\n    ```\r\n\r\nThis will print `False`, even though it should be printing `True`. The reason is that the false branch output is fed into the merge op first.\r\n\r\nAlso CCing @itsmeolivia since I think she's been working on making the Python API to use the C API.\r\n"}