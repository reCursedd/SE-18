{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5482", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5482/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5482/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5482/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/5482", "id": 188113125, "node_id": "MDU6SXNzdWUxODgxMTMxMjU=", "number": 5482, "title": "TensorFlow crashing on IBM POWER; request debug advice", "user": {"login": "hartb", "id": 18429659, "node_id": "MDQ6VXNlcjE4NDI5NjU5", "avatar_url": "https://avatars1.githubusercontent.com/u/18429659?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hartb", "html_url": "https://github.com/hartb", "followers_url": "https://api.github.com/users/hartb/followers", "following_url": "https://api.github.com/users/hartb/following{/other_user}", "gists_url": "https://api.github.com/users/hartb/gists{/gist_id}", "starred_url": "https://api.github.com/users/hartb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hartb/subscriptions", "organizations_url": "https://api.github.com/users/hartb/orgs", "repos_url": "https://api.github.com/users/hartb/repos", "events_url": "https://api.github.com/users/hartb/events{/privacy}", "received_events_url": "https://api.github.com/users/hartb/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 404586558, "node_id": "MDU6TGFiZWw0MDQ1ODY1NTg=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:community%20support", "name": "stat:community support", "color": "f4b400", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 6, "created_at": "2016-11-08T21:50:03Z", "updated_at": "2016-11-16T16:04:29Z", "closed_at": "2016-11-16T16:04:29Z", "author_association": "CONTRIBUTOR", "body_html": "<p>We're seeing various crashes while running TensorFlow on IBM POWER systems with Ubuntu 16.04. We'd welcome any debugging advice or comments, especially about debug features or about reducing the size/complexity of TF to simplify debug.</p>\n<p>Problem isolation information:</p>\n<ul>\n<li>\n<p>Occurs with any of TF 0.9, 0.10, and recent master (e.g. <a class=\"commit-link\" data-hovercard-type=\"commit\" data-hovercard-url=\"https://github.com/tensorflow/tensorflow/commit/2cbb9b529a6723ebbe07663156b18c04fbaf4531/hovercard\" href=\"https://github.com/tensorflow/tensorflow/commit/2cbb9b529a6723ebbe07663156b18c04fbaf4531\"><tt>2cbb9b5</tt></a> of Oct 26th)</p>\n</li>\n<li>\n<p>Occurs while training inception model on ILSVRC 2012 dataset. Model is from: <a href=\"https://github.com/tensorflow/models.git\">https://github.com/tensorflow/models.git</a>  inception/</p>\n</li>\n<li>\n<p>Independent of CUDA / GPU; occurs even if we compile with:<br>\nTF_NEED_CUDA=0<br>\nTF_NEED_GCP=0<br>\nTF_NEED_HDFS=0</p>\n</li>\n<li>\n<p>Occurs after varying run times. Appears to occur sooner with higher thread counts. Very possibly a race of some sort.</p>\n</li>\n<li>\n<p>Does not occur with Ubuntu 15.10's GLIBC 2.21 (or earlier) but does occur with Ubuntu 16.04's GLIBC 2.23 (or later). So appears to be a problem in (or at least exposed by) GLIBC 2.22 or 2.23.</p>\n</li>\n<li>\n<p>TF runs (mostly) clean under valgrind --tool=memcheck. (There are some complaints about bad behavior by python at startup, but then silence. We see similar complaints running other python apps.)</p>\n</li>\n</ul>\n<p>To try to simplify analysis, we're:</p>\n<ul>\n<li>\n<p>Building without CUDA, GCP, HDFS support</p>\n</li>\n<li>\n<p>Limiting threading by forcing tensorflow/core/platform/posix/port.cc NumSchedulableCPUs() to return a small value</p>\n</li>\n<li>\n<p>Forcing gcc to perform extra stack checking (updating tf_copts in tensorflow/tensorflow.bzl to include \"-fstack-protector-all\")</p>\n</li>\n</ul>\n<p>Nature of the crash:</p>\n<p>The crash is usually a segfault, and often because a pointer was damaged while it was sitting on the stack.</p>\n<p>The damage is quite consistent. Under linux on POWER, pointers to stack and heap will generally have the form 0x00003nnn nnnnnnnn. The damage always seems to be that the high half-word is changed from 0x0000 to 0x0001 (so looks like a short/half is set or incremented).</p>\n<p>Occasionally the damaged pointer started life as NULL, and so we end up with a dereference of 0x0001000000000000.</p>\n<p>In one case the pointer that was damaged was the stack pointer (r1), which would not normally be itself stored and retrieved from the stack. So maybe in that damage occurred:<br>\na) while the thread was inactive and r1 sitting in a context save area,<br>\nb) in some odd case where r1 was saved on the stack, e.g. setjmp() / longjmp().</p>\n<p>That suggests the crashing thread may not be the thread that's causing the damage.</p>\n<p>I didn't find any obvious matches on stackoverflow (no crash reports with \"stack smashing\" or \"power\"). I did see (unresolved) issue <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"163577697\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/tensorflow/tensorflow/issues/3174\" data-hovercard-type=\"issue\" data-hovercard-url=\"/tensorflow/tensorflow/issues/3174/hovercard\" href=\"https://github.com/tensorflow/tensorflow/issues/3174\">#3174</a> from July, but can't be sure that's related.</p>", "body_text": "We're seeing various crashes while running TensorFlow on IBM POWER systems with Ubuntu 16.04. We'd welcome any debugging advice or comments, especially about debug features or about reducing the size/complexity of TF to simplify debug.\nProblem isolation information:\n\n\nOccurs with any of TF 0.9, 0.10, and recent master (e.g. 2cbb9b5 of Oct 26th)\n\n\nOccurs while training inception model on ILSVRC 2012 dataset. Model is from: https://github.com/tensorflow/models.git  inception/\n\n\nIndependent of CUDA / GPU; occurs even if we compile with:\nTF_NEED_CUDA=0\nTF_NEED_GCP=0\nTF_NEED_HDFS=0\n\n\nOccurs after varying run times. Appears to occur sooner with higher thread counts. Very possibly a race of some sort.\n\n\nDoes not occur with Ubuntu 15.10's GLIBC 2.21 (or earlier) but does occur with Ubuntu 16.04's GLIBC 2.23 (or later). So appears to be a problem in (or at least exposed by) GLIBC 2.22 or 2.23.\n\n\nTF runs (mostly) clean under valgrind --tool=memcheck. (There are some complaints about bad behavior by python at startup, but then silence. We see similar complaints running other python apps.)\n\n\nTo try to simplify analysis, we're:\n\n\nBuilding without CUDA, GCP, HDFS support\n\n\nLimiting threading by forcing tensorflow/core/platform/posix/port.cc NumSchedulableCPUs() to return a small value\n\n\nForcing gcc to perform extra stack checking (updating tf_copts in tensorflow/tensorflow.bzl to include \"-fstack-protector-all\")\n\n\nNature of the crash:\nThe crash is usually a segfault, and often because a pointer was damaged while it was sitting on the stack.\nThe damage is quite consistent. Under linux on POWER, pointers to stack and heap will generally have the form 0x00003nnn nnnnnnnn. The damage always seems to be that the high half-word is changed from 0x0000 to 0x0001 (so looks like a short/half is set or incremented).\nOccasionally the damaged pointer started life as NULL, and so we end up with a dereference of 0x0001000000000000.\nIn one case the pointer that was damaged was the stack pointer (r1), which would not normally be itself stored and retrieved from the stack. So maybe in that damage occurred:\na) while the thread was inactive and r1 sitting in a context save area,\nb) in some odd case where r1 was saved on the stack, e.g. setjmp() / longjmp().\nThat suggests the crashing thread may not be the thread that's causing the damage.\nI didn't find any obvious matches on stackoverflow (no crash reports with \"stack smashing\" or \"power\"). I did see (unresolved) issue #3174 from July, but can't be sure that's related.", "body": "We're seeing various crashes while running TensorFlow on IBM POWER systems with Ubuntu 16.04. We'd welcome any debugging advice or comments, especially about debug features or about reducing the size/complexity of TF to simplify debug.\r\n\r\nProblem isolation information:\r\n\r\n- Occurs with any of TF 0.9, 0.10, and recent master (e.g. 2cbb9b52 of Oct 26th)\r\n\r\n- Occurs while training inception model on ILSVRC 2012 dataset. Model is from: https://github.com/tensorflow/models.git  inception/\r\n\r\n- Independent of CUDA / GPU; occurs even if we compile with:\r\n    TF_NEED_CUDA=0\r\n    TF_NEED_GCP=0\r\n    TF_NEED_HDFS=0\r\n\r\n- Occurs after varying run times. Appears to occur sooner with higher thread counts. Very possibly a race of some sort.\r\n\r\n- Does not occur with Ubuntu 15.10's GLIBC 2.21 (or earlier) but does occur with Ubuntu 16.04's GLIBC 2.23 (or later). So appears to be a problem in (or at least exposed by) GLIBC 2.22 or 2.23.\r\n\r\n- TF runs (mostly) clean under valgrind --tool=memcheck. (There are some complaints about bad behavior by python at startup, but then silence. We see similar complaints running other python apps.)\r\n\r\n\r\nTo try to simplify analysis, we're:\r\n\r\n- Building without CUDA, GCP, HDFS support\r\n\r\n- Limiting threading by forcing tensorflow/core/platform/posix/port.cc NumSchedulableCPUs() to return a small value\r\n\r\n- Forcing gcc to perform extra stack checking (updating tf_copts in tensorflow/tensorflow.bzl to include \"-fstack-protector-all\")\r\n\r\n\r\nNature of the crash:\r\n\r\nThe crash is usually a segfault, and often because a pointer was damaged while it was sitting on the stack.\r\n\r\nThe damage is quite consistent. Under linux on POWER, pointers to stack and heap will generally have the form 0x00003nnn nnnnnnnn. The damage always seems to be that the high half-word is changed from 0x0000 to 0x0001 (so looks like a short/half is set or incremented).\r\n\r\nOccasionally the damaged pointer started life as NULL, and so we end up with a dereference of 0x0001000000000000.\r\n\r\nIn one case the pointer that was damaged was the stack pointer (r1), which would not normally be itself stored and retrieved from the stack. So maybe in that damage occurred:\r\na) while the thread was inactive and r1 sitting in a context save area,\r\nb) in some odd case where r1 was saved on the stack, e.g. setjmp() / longjmp().\r\n\r\nThat suggests the crashing thread may not be the thread that's causing the damage.\r\n\r\nI didn't find any obvious matches on stackoverflow (no crash reports with \"stack smashing\" or \"power\"). I did see (unresolved) issue #3174 from July, but can't be sure that's related."}