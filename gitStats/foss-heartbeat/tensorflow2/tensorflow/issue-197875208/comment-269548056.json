{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/269548056", "html_url": "https://github.com/tensorflow/tensorflow/issues/6541#issuecomment-269548056", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/6541", "id": 269548056, "node_id": "MDEyOklzc3VlQ29tbWVudDI2OTU0ODA1Ng==", "user": {"login": "aselle", "id": 326106, "node_id": "MDQ6VXNlcjMyNjEwNg==", "avatar_url": "https://avatars1.githubusercontent.com/u/326106?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aselle", "html_url": "https://github.com/aselle", "followers_url": "https://api.github.com/users/aselle/followers", "following_url": "https://api.github.com/users/aselle/following{/other_user}", "gists_url": "https://api.github.com/users/aselle/gists{/gist_id}", "starred_url": "https://api.github.com/users/aselle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aselle/subscriptions", "organizations_url": "https://api.github.com/users/aselle/orgs", "repos_url": "https://api.github.com/users/aselle/repos", "events_url": "https://api.github.com/users/aselle/events{/privacy}", "received_events_url": "https://api.github.com/users/aselle/received_events", "type": "User", "site_admin": false}, "created_at": "2016-12-28T22:01:34Z", "updated_at": "2016-12-28T22:01:34Z", "author_association": "MEMBER", "body_html": "<p>Likely you are measuring the overhead of .run(), the copying of the feed variable spec which doesn't happen in numpy. In general, you will get good performance if each .run() does a significant portion of work. For example, I move your computation into a while loop inside tensorflow graph and get</p>\n<pre><code>tensorflow:0.0105199813843s\nnumpy:0.040412902832s\n</code></pre>\n<p>Here's the code:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">import</span> numpy <span class=\"pl-k\">as</span> np\n<span class=\"pl-k\">import</span> tensorflow <span class=\"pl-k\">as</span> tf\n<span class=\"pl-k\">import</span> time\n\nniterations<span class=\"pl-k\">=</span><span class=\"pl-c1\">1000</span>\nN<span class=\"pl-k\">=</span><span class=\"pl-c1\">1024</span>\nwav <span class=\"pl-k\">=</span> np.random.random_sample((N,))\nspec <span class=\"pl-k\">=</span> np.fft.fft(wav)[:N<span class=\"pl-k\">/</span><span class=\"pl-c1\">2</span><span class=\"pl-k\">+</span><span class=\"pl-c1\">1</span>]\n\nsess <span class=\"pl-k\">=</span> tf.Session()\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> Create and initialize variables</span>\ncnt <span class=\"pl-k\">=</span> tf.Variable(tf.constant(niterations))\nspecVar <span class=\"pl-k\">=</span> tf.Variable(spec, <span class=\"pl-v\">dtype</span><span class=\"pl-k\">=</span>tf.complex64)\nsess.run(tf.variables_initializer([specVar,cnt]))\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> While loop that counts down to zero and computes reverse and forward fft's</span>\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">condition</span>(<span class=\"pl-smi\">x</span>,<span class=\"pl-smi\">cnt</span>):\n  <span class=\"pl-k\">return</span> cnt <span class=\"pl-k\">&lt;=</span> <span class=\"pl-c1\">0</span>\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">body</span>(<span class=\"pl-smi\">x</span>,<span class=\"pl-smi\">cnt</span>):\n  xrev<span class=\"pl-k\">=</span>tf.ifft(x)\n  xnew<span class=\"pl-k\">=</span>tf.fft(xrev)\n  cntnew<span class=\"pl-k\">=</span>cnt<span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>\n  <span class=\"pl-k\">return</span> xnew, cntnew\n\nstart <span class=\"pl-k\">=</span> time.time()\ntf.while_loop(condition, body, [specVar,cnt], <span class=\"pl-v\">parallel_iterations</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">1</span>)\n\n<span class=\"pl-c1\">print</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>tensorflow:<span class=\"pl-c1\">{}</span>s<span class=\"pl-pds\">'</span></span>.format(time.time()<span class=\"pl-k\">-</span>start)\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> Equivalent numpy loop</span>\nstart <span class=\"pl-k\">=</span> time.time()\nx <span class=\"pl-k\">=</span> spec\n<span class=\"pl-k\">for</span> i <span class=\"pl-k\">in</span> <span class=\"pl-c1\">range</span>(niterations):\n   xrev <span class=\"pl-k\">=</span> np.fft.ifft(x)\n   x<span class=\"pl-k\">=</span> np.fft.fft(xrev)\n   \n<span class=\"pl-c1\">print</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>numpy:<span class=\"pl-c1\">{}</span>s<span class=\"pl-pds\">'</span></span>.format(time.time() <span class=\"pl-k\">-</span> start)\n</pre></div>", "body_text": "Likely you are measuring the overhead of .run(), the copying of the feed variable spec which doesn't happen in numpy. In general, you will get good performance if each .run() does a significant portion of work. For example, I move your computation into a while loop inside tensorflow graph and get\ntensorflow:0.0105199813843s\nnumpy:0.040412902832s\n\nHere's the code:\nimport numpy as np\nimport tensorflow as tf\nimport time\n\nniterations=1000\nN=1024\nwav = np.random.random_sample((N,))\nspec = np.fft.fft(wav)[:N/2+1]\n\nsess = tf.Session()\n\n# Create and initialize variables\ncnt = tf.Variable(tf.constant(niterations))\nspecVar = tf.Variable(spec, dtype=tf.complex64)\nsess.run(tf.variables_initializer([specVar,cnt]))\n\n# While loop that counts down to zero and computes reverse and forward fft's\ndef condition(x,cnt):\n  return cnt <= 0\n\ndef body(x,cnt):\n  xrev=tf.ifft(x)\n  xnew=tf.fft(xrev)\n  cntnew=cnt-1\n  return xnew, cntnew\n\nstart = time.time()\ntf.while_loop(condition, body, [specVar,cnt], parallel_iterations=1)\n\nprint 'tensorflow:{}s'.format(time.time()-start)\n\n# Equivalent numpy loop\nstart = time.time()\nx = spec\nfor i in range(niterations):\n   xrev = np.fft.ifft(x)\n   x= np.fft.fft(xrev)\n   \nprint 'numpy:{}s'.format(time.time() - start)", "body": "Likely you are measuring the overhead of .run(), the copying of the feed variable spec which doesn't happen in numpy. In general, you will get good performance if each .run() does a significant portion of work. For example, I move your computation into a while loop inside tensorflow graph and get\r\n```\r\ntensorflow:0.0105199813843s\r\nnumpy:0.040412902832s\r\n```\r\n\r\nHere's the code:\r\n```python\r\nimport numpy as np\r\nimport tensorflow as tf\r\nimport time\r\n\r\nniterations=1000\r\nN=1024\r\nwav = np.random.random_sample((N,))\r\nspec = np.fft.fft(wav)[:N/2+1]\r\n\r\nsess = tf.Session()\r\n\r\n# Create and initialize variables\r\ncnt = tf.Variable(tf.constant(niterations))\r\nspecVar = tf.Variable(spec, dtype=tf.complex64)\r\nsess.run(tf.variables_initializer([specVar,cnt]))\r\n\r\n# While loop that counts down to zero and computes reverse and forward fft's\r\ndef condition(x,cnt):\r\n  return cnt <= 0\r\n\r\ndef body(x,cnt):\r\n  xrev=tf.ifft(x)\r\n  xnew=tf.fft(xrev)\r\n  cntnew=cnt-1\r\n  return xnew, cntnew\r\n\r\nstart = time.time()\r\ntf.while_loop(condition, body, [specVar,cnt], parallel_iterations=1)\r\n\r\nprint 'tensorflow:{}s'.format(time.time()-start)\r\n\r\n# Equivalent numpy loop\r\nstart = time.time()\r\nx = spec\r\nfor i in range(niterations):\r\n   xrev = np.fft.ifft(x)\r\n   x= np.fft.fft(xrev)\r\n   \r\nprint 'numpy:{}s'.format(time.time() - start)\r\n\r\n```"}