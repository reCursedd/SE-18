{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/176768089", "html_url": "https://github.com/tensorflow/tensorflow/issues/22#issuecomment-176768089", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/22", "id": 176768089, "node_id": "MDEyOklzc3VlQ29tbWVudDE3Njc2ODA4OQ==", "user": {"login": "karlrupp", "id": 3027176, "node_id": "MDQ6VXNlcjMwMjcxNzY=", "avatar_url": "https://avatars1.githubusercontent.com/u/3027176?v=4", "gravatar_id": "", "url": "https://api.github.com/users/karlrupp", "html_url": "https://github.com/karlrupp", "followers_url": "https://api.github.com/users/karlrupp/followers", "following_url": "https://api.github.com/users/karlrupp/following{/other_user}", "gists_url": "https://api.github.com/users/karlrupp/gists{/gist_id}", "starred_url": "https://api.github.com/users/karlrupp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/karlrupp/subscriptions", "organizations_url": "https://api.github.com/users/karlrupp/orgs", "repos_url": "https://api.github.com/users/karlrupp/repos", "events_url": "https://api.github.com/users/karlrupp/events{/privacy}", "received_events_url": "https://api.github.com/users/karlrupp/received_events", "type": "User", "site_admin": false}, "created_at": "2016-01-29T14:04:49Z", "updated_at": "2016-01-29T14:04:49Z", "author_association": "NONE", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=1710528\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/bhack\">@bhack</a> Which new Google group?</p>\n<p>Other than that, OpenCL and CUDA are too different programming approaches. CUDA works the way it is because one company has full control over everything, so it can embed binary blobs and who knows what in the final executable. This cannot be done with OpenCL, unless one goes down the SyCL path (I have my concerns...) and the SyCL compiler vendor has full control over all possible target architectures (unlikely or impossible in practice). Overall, my opinion is that a good OpenCL-enabled library needs more than just a few tweaks here and there. Probably not what you wanted to hear, but you asked for my opinion :-)</p>", "body_text": "@bhack Which new Google group?\nOther than that, OpenCL and CUDA are too different programming approaches. CUDA works the way it is because one company has full control over everything, so it can embed binary blobs and who knows what in the final executable. This cannot be done with OpenCL, unless one goes down the SyCL path (I have my concerns...) and the SyCL compiler vendor has full control over all possible target architectures (unlikely or impossible in practice). Overall, my opinion is that a good OpenCL-enabled library needs more than just a few tweaks here and there. Probably not what you wanted to hear, but you asked for my opinion :-)", "body": "@bhack Which new Google group?\n\nOther than that, OpenCL and CUDA are too different programming approaches. CUDA works the way it is because one company has full control over everything, so it can embed binary blobs and who knows what in the final executable. This cannot be done with OpenCL, unless one goes down the SyCL path (I have my concerns...) and the SyCL compiler vendor has full control over all possible target architectures (unlikely or impossible in practice). Overall, my opinion is that a good OpenCL-enabled library needs more than just a few tweaks here and there. Probably not what you wanted to hear, but you asked for my opinion :-)\n"}