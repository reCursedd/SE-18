{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/351127279", "html_url": "https://github.com/tensorflow/tensorflow/issues/22#issuecomment-351127279", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/22", "id": 351127279, "node_id": "MDEyOklzc3VlQ29tbWVudDM1MTEyNzI3OQ==", "user": {"login": "keryell", "id": 1821746, "node_id": "MDQ6VXNlcjE4MjE3NDY=", "avatar_url": "https://avatars3.githubusercontent.com/u/1821746?v=4", "gravatar_id": "", "url": "https://api.github.com/users/keryell", "html_url": "https://github.com/keryell", "followers_url": "https://api.github.com/users/keryell/followers", "following_url": "https://api.github.com/users/keryell/following{/other_user}", "gists_url": "https://api.github.com/users/keryell/gists{/gist_id}", "starred_url": "https://api.github.com/users/keryell/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/keryell/subscriptions", "organizations_url": "https://api.github.com/users/keryell/orgs", "repos_url": "https://api.github.com/users/keryell/repos", "events_url": "https://api.github.com/users/keryell/events{/privacy}", "received_events_url": "https://api.github.com/users/keryell/received_events", "type": "User", "site_admin": false}, "created_at": "2017-12-12T17:39:37Z", "updated_at": "2017-12-12T17:39:37Z", "author_association": "NONE", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=9366725\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/mirh\">@mirh</a> to clarify the \"acronyms of magically random technologies [...] making [you] mad\":</p>\n<p>In the Khronos Group realm, OpenCL is the low-level non-single source API and SYCL is the high-level <em>single-source</em> C++ domain-specific embedded language (DSeL). SYCL is expected to be built on top of OpenCL, so by transitivity when you use SYCL, often you use OpenCL.</p>\n<p>Since TensorFlow uses Eigen which uses a <em>single-source</em> C++ approach with <em>single-source</em> CUDA, when it was later ported to OpenCL, SYCL was chosen because it is the Khronos Group standard way to have <em>single-source</em> C++.</p>\n<p>But if you think about CUDA, it is even more subtle.</p>\n<p>Almost everybody uses the high-level  <em>single-source</em> version of CUDA which is actually named \"CUDA <strong>Runtime</strong> API\". This is somehow similar to SYCL.<br>\nBut there is actually a less known low-level <em>non single-source</em> version of CUDA which is called \"CUDA <strong>Driver</strong> API\", similar to OpenCL, and used for example by the \"CUDA <strong>Runtime</strong> API\" implementation itself.</p>\n<p>Since it is a kind of FAQ, I clarified a little bit <a href=\"https://en.wikipedia.org/wiki/SYCL\" rel=\"nofollow\">https://en.wikipedia.org/wiki/SYCL</a> and <a href=\"https://en.wikipedia.org/wiki/CUDA\" rel=\"nofollow\">https://en.wikipedia.org/wiki/CUDA</a></p>", "body_text": "@mirh to clarify the \"acronyms of magically random technologies [...] making [you] mad\":\nIn the Khronos Group realm, OpenCL is the low-level non-single source API and SYCL is the high-level single-source C++ domain-specific embedded language (DSeL). SYCL is expected to be built on top of OpenCL, so by transitivity when you use SYCL, often you use OpenCL.\nSince TensorFlow uses Eigen which uses a single-source C++ approach with single-source CUDA, when it was later ported to OpenCL, SYCL was chosen because it is the Khronos Group standard way to have single-source C++.\nBut if you think about CUDA, it is even more subtle.\nAlmost everybody uses the high-level  single-source version of CUDA which is actually named \"CUDA Runtime API\". This is somehow similar to SYCL.\nBut there is actually a less known low-level non single-source version of CUDA which is called \"CUDA Driver API\", similar to OpenCL, and used for example by the \"CUDA Runtime API\" implementation itself.\nSince it is a kind of FAQ, I clarified a little bit https://en.wikipedia.org/wiki/SYCL and https://en.wikipedia.org/wiki/CUDA", "body": "@mirh to clarify the \"acronyms of magically random technologies [...] making [you] mad\":\r\n\r\nIn the Khronos Group realm, OpenCL is the low-level non-single source API and SYCL is the high-level *single-source* C++ domain-specific embedded language (DSeL). SYCL is expected to be built on top of OpenCL, so by transitivity when you use SYCL, often you use OpenCL.\r\n\r\nSince TensorFlow uses Eigen which uses a *single-source* C++ approach with *single-source* CUDA, when it was later ported to OpenCL, SYCL was chosen because it is the Khronos Group standard way to have *single-source* C++.\r\n\r\nBut if you think about CUDA, it is even more subtle.\r\n\r\nAlmost everybody uses the high-level  *single-source* version of CUDA which is actually named \"CUDA **Runtime** API\". This is somehow similar to SYCL.\r\nBut there is actually a less known low-level *non single-source* version of CUDA which is called \"CUDA **Driver** API\", similar to OpenCL, and used for example by the \"CUDA **Runtime** API\" implementation itself.\r\n\r\nSince it is a kind of FAQ, I clarified a little bit https://en.wikipedia.org/wiki/SYCL and https://en.wikipedia.org/wiki/CUDA"}