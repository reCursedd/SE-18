{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/279120632", "html_url": "https://github.com/tensorflow/tensorflow/issues/5842#issuecomment-279120632", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5842", "id": 279120632, "node_id": "MDEyOklzc3VlQ29tbWVudDI3OTEyMDYzMg==", "user": {"login": "AidanGG", "id": 10514295, "node_id": "MDQ6VXNlcjEwNTE0Mjk1", "avatar_url": "https://avatars3.githubusercontent.com/u/10514295?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AidanGG", "html_url": "https://github.com/AidanGG", "followers_url": "https://api.github.com/users/AidanGG/followers", "following_url": "https://api.github.com/users/AidanGG/following{/other_user}", "gists_url": "https://api.github.com/users/AidanGG/gists{/gist_id}", "starred_url": "https://api.github.com/users/AidanGG/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AidanGG/subscriptions", "organizations_url": "https://api.github.com/users/AidanGG/orgs", "repos_url": "https://api.github.com/users/AidanGG/repos", "events_url": "https://api.github.com/users/AidanGG/events{/privacy}", "received_events_url": "https://api.github.com/users/AidanGG/received_events", "type": "User", "site_admin": false}, "created_at": "2017-02-11T04:34:52Z", "updated_at": "2017-02-11T04:34:52Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Hi <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=16907534\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/rmlarsen\">@rmlarsen</a>, I have been using</p>\n<pre><code>rank = tf.shape(tf.where(tf.greater_equal(s, np.finfo(dtype.real_dtype.as_numpy_dtype).eps * s[0] * tf.cast(tf.size(s), dtype.real_dtype))))[0]\n</code></pre>\n<p>and slicing <code>U</code>, <code>s</code> and  <code>V</code> by this <code>rank</code>. This works well enough for my purpose.</p>", "body_text": "Hi @rmlarsen, I have been using\nrank = tf.shape(tf.where(tf.greater_equal(s, np.finfo(dtype.real_dtype.as_numpy_dtype).eps * s[0] * tf.cast(tf.size(s), dtype.real_dtype))))[0]\n\nand slicing U, s and  V by this rank. This works well enough for my purpose.", "body": "Hi @rmlarsen, I have been using\r\n```\r\nrank = tf.shape(tf.where(tf.greater_equal(s, np.finfo(dtype.real_dtype.as_numpy_dtype).eps * s[0] * tf.cast(tf.size(s), dtype.real_dtype))))[0]\r\n```\r\nand slicing `U`, `s` and  `V` by this `rank`. This works well enough for my purpose."}