{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/258649659", "html_url": "https://github.com/tensorflow/tensorflow/issues/5308#issuecomment-258649659", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5308", "id": 258649659, "node_id": "MDEyOklzc3VlQ29tbWVudDI1ODY0OTY1OQ==", "user": {"login": "drpngx", "id": 20959853, "node_id": "MDQ6VXNlcjIwOTU5ODUz", "avatar_url": "https://avatars1.githubusercontent.com/u/20959853?v=4", "gravatar_id": "", "url": "https://api.github.com/users/drpngx", "html_url": "https://github.com/drpngx", "followers_url": "https://api.github.com/users/drpngx/followers", "following_url": "https://api.github.com/users/drpngx/following{/other_user}", "gists_url": "https://api.github.com/users/drpngx/gists{/gist_id}", "starred_url": "https://api.github.com/users/drpngx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/drpngx/subscriptions", "organizations_url": "https://api.github.com/users/drpngx/orgs", "repos_url": "https://api.github.com/users/drpngx/repos", "events_url": "https://api.github.com/users/drpngx/events{/privacy}", "received_events_url": "https://api.github.com/users/drpngx/received_events", "type": "User", "site_admin": false}, "created_at": "2016-11-05T23:37:12Z", "updated_at": "2016-11-05T23:37:12Z", "author_association": "MEMBER", "body_html": "<p>Thanks for looking into this!</p>\n<p>We want to retain some of the ease and flexibility that we have, while disallowing accidental imports.</p>\n<p>Here's what we do:</p>\n<ol>\n<li>We document symbols that we should use, with <code>@@foo</code></li>\n<li>We use <code>remove_undocumented</code> to delete all symbols from \"selected\" modules/packages</li>\n<li>We have a whitelist</li>\n</ol>\n<p>\"Selected\" modules/packages are those that are imported into the <code>tf</code> namespace, for instance: <code>app</code>, <code>image</code>, <code>nn</code>, etc., transitively on down. For instance, <code>tf.app.flags</code>.</p>\n<p>These packages have a choice of (first one chosen to be the predominant solution):</p>\n<ol>\n<li>Have no implementation, just <code>from .. import *</code>, or <code>from .. import Foo</code>. They typically have a counterpart, called <code>_impl</code>, for instance, <code>gradients_impl.py</code></li>\n<li>Have implementation, but use underscore for all packages used solely for implementation as you suggest</li>\n</ol>\n<p>Here is an example module using the first variant, dubbed dual API/implementation:</p>\n<p><code>gradients.py</code>: (API module)</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-s\"><span class=\"pl-pds\">\"\"\"</span>Gradients doc</span>\n<span class=\"pl-s\">@@some_func</span>\n<span class=\"pl-s\"><span class=\"pl-pds\">\"\"\"</span></span>\n<span class=\"pl-k\">from</span> .. <span class=\"pl-k\">import</span> remove_undocumented\n<span class=\"pl-k\">from</span> ..gradients_impl <span class=\"pl-k\">import</span> <span class=\"pl-k\">*</span>\nremove_undocumented(<span class=\"pl-c1\">__name__</span>, [<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>some_other_func<span class=\"pl-pds\">\"</span></span>])</pre></div>\n<p><code>gradients_impl.py</code>: (implementation module)</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">import</span> some_module\n<span class=\"pl-k\">from</span> ... <span class=\"pl-k\">import</span> some_useful_module\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">some_func</span>(): <span class=\"pl-k\">pass</span>\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">some_other_func</span>(): <span class=\"pl-k\">pass</span>\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> No remove_undocumented.</span></pre></div>\n<p><code>foo.py</code>: (internal implementation module which requires some functions defined in <code>gradients_impl</code>. We make sure that <code>foo.py</code> is never imported in the <code>tf</code> namespace, directly or transitively:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">from</span> tensorflow...<span class=\"pl-k\">import</span> gradients_impl\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">foo</span>(<span class=\"pl-smi\">x</span>):\n   <span class=\"pl-k\">return</span> gradients_impl.my_internally_useful_function(x <span class=\"pl-k\">+</span> <span class=\"pl-c1\">1</span>)</pre></div>\n<p>There are no <code>import *</code> in <code>gradients_impl</code>.</p>\n<p>Here's an example module using the second variant (dubbed the fused api/implementation).</p>\n<p><code>logging.py</code>:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-s\"><span class=\"pl-pds\">\"\"\"</span>Logging things</span>\n<span class=\"pl-s\">@@print_stderr</span>\n<span class=\"pl-s\"><span class=\"pl-pds\">\"\"\"</span></span>\n<span class=\"pl-k\">import</span> sys <span class=\"pl-k\">as</span> _sys\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">print_stderr</span>(<span class=\"pl-smi\">msg</span>):\n   _sys.stderr.write(msg)\n\nremove_undocumented(<span class=\"pl-c1\">__name__</span>, [])</pre></div>\n<p>To recap, (after the change is fully complete)</p>\n<ol>\n<li>As a tensorflow user, (minus a handful of exceptions such as <code>tfdbg</code>), you are only allowed to use <code>import tensorflow as tf</code></li>\n<li>As a tensorflow developer, you are encouraged to use <code>from tensorflow... import ...</code> in your modules</li>\n<li>As a tensorflow developer, you are not allowed to use <code>import *</code> in your implementation modules, only in API modules</li>\n<li>So, more or less our internal code remains the same, except that we have to be careful in a handful of modules (perhaps 20 or so)</li>\n<li>As a tensorflow user, you no longer have access to internal modules that have not been explicitly exported via a whitelist or a documentation reference.</li>\n</ol>\n<p>HTH</p>", "body_text": "Thanks for looking into this!\nWe want to retain some of the ease and flexibility that we have, while disallowing accidental imports.\nHere's what we do:\n\nWe document symbols that we should use, with @@foo\nWe use remove_undocumented to delete all symbols from \"selected\" modules/packages\nWe have a whitelist\n\n\"Selected\" modules/packages are those that are imported into the tf namespace, for instance: app, image, nn, etc., transitively on down. For instance, tf.app.flags.\nThese packages have a choice of (first one chosen to be the predominant solution):\n\nHave no implementation, just from .. import *, or from .. import Foo. They typically have a counterpart, called _impl, for instance, gradients_impl.py\nHave implementation, but use underscore for all packages used solely for implementation as you suggest\n\nHere is an example module using the first variant, dubbed dual API/implementation:\ngradients.py: (API module)\n\"\"\"Gradients doc\n@@some_func\n\"\"\"\nfrom .. import remove_undocumented\nfrom ..gradients_impl import *\nremove_undocumented(__name__, [\"some_other_func\"])\ngradients_impl.py: (implementation module)\nimport some_module\nfrom ... import some_useful_module\n\ndef some_func(): pass\ndef some_other_func(): pass\n# No remove_undocumented.\nfoo.py: (internal implementation module which requires some functions defined in gradients_impl. We make sure that foo.py is never imported in the tf namespace, directly or transitively:\nfrom tensorflow...import gradients_impl\n\ndef foo(x):\n   return gradients_impl.my_internally_useful_function(x + 1)\nThere are no import * in gradients_impl.\nHere's an example module using the second variant (dubbed the fused api/implementation).\nlogging.py:\n\"\"\"Logging things\n@@print_stderr\n\"\"\"\nimport sys as _sys\n\ndef print_stderr(msg):\n   _sys.stderr.write(msg)\n\nremove_undocumented(__name__, [])\nTo recap, (after the change is fully complete)\n\nAs a tensorflow user, (minus a handful of exceptions such as tfdbg), you are only allowed to use import tensorflow as tf\nAs a tensorflow developer, you are encouraged to use from tensorflow... import ... in your modules\nAs a tensorflow developer, you are not allowed to use import * in your implementation modules, only in API modules\nSo, more or less our internal code remains the same, except that we have to be careful in a handful of modules (perhaps 20 or so)\nAs a tensorflow user, you no longer have access to internal modules that have not been explicitly exported via a whitelist or a documentation reference.\n\nHTH", "body": "Thanks for looking into this!\n\nWe want to retain some of the ease and flexibility that we have, while disallowing accidental imports.\n\nHere's what we do:\n1. We document symbols that we should use, with `@@foo`\n2. We use `remove_undocumented` to delete all symbols from \"selected\" modules/packages\n3. We have a whitelist\n\n\"Selected\" modules/packages are those that are imported into the `tf` namespace, for instance: `app`, `image`, `nn`, etc., transitively on down. For instance, `tf.app.flags`.\n\nThese packages have a choice of (first one chosen to be the predominant solution):\n1. Have no implementation, just `from .. import *`, or `from .. import Foo`. They typically have a counterpart, called `_impl`, for instance, `gradients_impl.py`\n2. Have implementation, but use underscore for all packages used solely for implementation as you suggest\n\nHere is an example module using the first variant, dubbed dual API/implementation:\n\n`gradients.py`: (API module)\n\n``` python\n\"\"\"Gradients doc\n@@some_func\n\"\"\"\nfrom .. import remove_undocumented\nfrom ..gradients_impl import *\nremove_undocumented(__name__, [\"some_other_func\"])\n```\n\n`gradients_impl.py`: (implementation module)\n\n``` python\n\nimport some_module\nfrom ... import some_useful_module\n\ndef some_func(): pass\ndef some_other_func(): pass\n# No remove_undocumented.\n```\n\n`foo.py`: (internal implementation module which requires some functions defined in `gradients_impl`. We make sure that `foo.py` is never imported in the `tf` namespace, directly or transitively:\n\n``` python\n\nfrom tensorflow...import gradients_impl\n\ndef foo(x):\n   return gradients_impl.my_internally_useful_function(x + 1)\n```\n\nThere are no `import *` in `gradients_impl`.\n\nHere's an example module using the second variant (dubbed the fused api/implementation).\n\n`logging.py`:\n\n``` python\n\"\"\"Logging things\n@@print_stderr\n\"\"\"\nimport sys as _sys\n\ndef print_stderr(msg):\n   _sys.stderr.write(msg)\n\nremove_undocumented(__name__, [])\n```\n\nTo recap, (after the change is fully complete)\n1. As a tensorflow user, (minus a handful of exceptions such as `tfdbg`), you are only allowed to use `import tensorflow as tf`\n2. As a tensorflow developer, you are encouraged to use `from tensorflow... import ...` in your modules\n3. As a tensorflow developer, you are not allowed to use `import *` in your implementation modules, only in API modules\n4. So, more or less our internal code remains the same, except that we have to be careful in a handful of modules (perhaps 20 or so)\n5. As a tensorflow user, you no longer have access to internal modules that have not been explicitly exported via a whitelist or a documentation reference.\n\nHTH\n"}