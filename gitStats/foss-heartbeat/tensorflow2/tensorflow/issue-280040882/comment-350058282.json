{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/350058282", "html_url": "https://github.com/tensorflow/tensorflow/issues/15178#issuecomment-350058282", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/15178", "id": 350058282, "node_id": "MDEyOklzc3VlQ29tbWVudDM1MDA1ODI4Mg==", "user": {"login": "mrry", "id": 192142, "node_id": "MDQ6VXNlcjE5MjE0Mg==", "avatar_url": "https://avatars1.githubusercontent.com/u/192142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mrry", "html_url": "https://github.com/mrry", "followers_url": "https://api.github.com/users/mrry/followers", "following_url": "https://api.github.com/users/mrry/following{/other_user}", "gists_url": "https://api.github.com/users/mrry/gists{/gist_id}", "starred_url": "https://api.github.com/users/mrry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mrry/subscriptions", "organizations_url": "https://api.github.com/users/mrry/orgs", "repos_url": "https://api.github.com/users/mrry/repos", "events_url": "https://api.github.com/users/mrry/events{/privacy}", "received_events_url": "https://api.github.com/users/mrry/received_events", "type": "User", "site_admin": false}, "created_at": "2017-12-07T18:45:59Z", "updated_at": "2017-12-07T18:45:59Z", "author_association": "CONTRIBUTOR", "body_html": "<p>It looks like the problem stems from <code>feature_column.categorical_column_with_vocabulary_list()</code> requiring a defined rank for its input. By default <code>Dataset.from_generator()</code> does not know anything about the shapes of the tensors that it generates, but you can work around this by passing <code>output_shapes</code> when you create it. The following input function worked for me:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">def</span> <span class=\"pl-en\">input_fn</span>():\n    <span class=\"pl-k\">def</span> <span class=\"pl-en\">gen</span>():\n        <span class=\"pl-k\">for</span> i <span class=\"pl-k\">in</span> <span class=\"pl-c1\">range</span>(<span class=\"pl-c1\">100000</span>):\n            <span class=\"pl-k\">for</span> j <span class=\"pl-k\">in</span> <span class=\"pl-c1\">range</span>(<span class=\"pl-c1\">10</span>):\n                <span class=\"pl-k\">yield</span> {<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>in<span class=\"pl-pds\">\"</span></span>: <span class=\"pl-c1\">str</span>(j)}, j<span class=\"pl-k\">+</span><span class=\"pl-c1\">1</span>\n    data <span class=\"pl-k\">=</span> tf.data.Dataset.from_generator(gen, ({<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>in<span class=\"pl-pds\">\"</span></span>: tf.string}, tf.int32),\n                                          <span class=\"pl-v\">output_shapes</span><span class=\"pl-k\">=</span>({<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>in<span class=\"pl-pds\">\"</span></span>: []}, []))\n    data <span class=\"pl-k\">=</span> data.batch(<span class=\"pl-c1\">10</span>)\n    iterator <span class=\"pl-k\">=</span> data.make_one_shot_iterator()\n    <span class=\"pl-k\">return</span> iterator.get_next()</pre></div>", "body_text": "It looks like the problem stems from feature_column.categorical_column_with_vocabulary_list() requiring a defined rank for its input. By default Dataset.from_generator() does not know anything about the shapes of the tensors that it generates, but you can work around this by passing output_shapes when you create it. The following input function worked for me:\ndef input_fn():\n    def gen():\n        for i in range(100000):\n            for j in range(10):\n                yield {\"in\": str(j)}, j+1\n    data = tf.data.Dataset.from_generator(gen, ({\"in\": tf.string}, tf.int32),\n                                          output_shapes=({\"in\": []}, []))\n    data = data.batch(10)\n    iterator = data.make_one_shot_iterator()\n    return iterator.get_next()", "body": "It looks like the problem stems from `feature_column.categorical_column_with_vocabulary_list()` requiring a defined rank for its input. By default `Dataset.from_generator()` does not know anything about the shapes of the tensors that it generates, but you can work around this by passing `output_shapes` when you create it. The following input function worked for me:\r\n\r\n```python\r\ndef input_fn():\r\n    def gen():\r\n        for i in range(100000):\r\n            for j in range(10):\r\n                yield {\"in\": str(j)}, j+1\r\n    data = tf.data.Dataset.from_generator(gen, ({\"in\": tf.string}, tf.int32),\r\n                                          output_shapes=({\"in\": []}, []))\r\n    data = data.batch(10)\r\n    iterator = data.make_one_shot_iterator()\r\n    return iterator.get_next()\r\n```"}