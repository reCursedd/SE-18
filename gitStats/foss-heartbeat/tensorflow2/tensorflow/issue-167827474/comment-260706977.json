{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/260706977", "html_url": "https://github.com/tensorflow/tensorflow/issues/3527#issuecomment-260706977", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/3527", "id": 260706977, "node_id": "MDEyOklzc3VlQ29tbWVudDI2MDcwNjk3Nw==", "user": {"login": "Nayana-ibm", "id": 20816038, "node_id": "MDQ6VXNlcjIwODE2MDM4", "avatar_url": "https://avatars0.githubusercontent.com/u/20816038?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nayana-ibm", "html_url": "https://github.com/Nayana-ibm", "followers_url": "https://api.github.com/users/Nayana-ibm/followers", "following_url": "https://api.github.com/users/Nayana-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/Nayana-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nayana-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nayana-ibm/subscriptions", "organizations_url": "https://api.github.com/users/Nayana-ibm/orgs", "repos_url": "https://api.github.com/users/Nayana-ibm/repos", "events_url": "https://api.github.com/users/Nayana-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/Nayana-ibm/received_events", "type": "User", "site_admin": false}, "created_at": "2016-11-15T17:23:22Z", "updated_at": "2016-11-15T17:23:22Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=70511\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/girving\">@girving</a> We are using pdb to debug test case and tried to print the op.outputs[0].eval() . The mismatch we could observe after _add_op(self, op) is being called as below:</p>\n<pre><code>ret = Operation(node_def, self, inputs=inputs, output_types=dtypes,\n                    control_inputs=control_inputs, input_types=input_types,\n                    original_op=self._default_original_op, op_def=op_def)\n    if compute_shapes:\n      set_shapes_for_outputs(ret)\n-------------&gt; **here,  ret.outputs[0].eval() gives NotFoundError**\n    self._add_op(ret)\n-------------&gt; **here,  p ret.outputs[0].eval() gives array([3, 5, 7]) ( expected output is array[4,2,8])**\n</code></pre>\n<p>About <code>self.lock</code>, this is used in the definition of _add_op function( filename: python/framework/ops.py):</p>\n<pre><code>\nwith self._lock:\n      # pylint: disable=protected-access\n      if op._id in self._nodes_by_id:\n        raise ValueError(\"cannot add an op with id %d as it already \"\n                         \"exists in the graph\" % op._id)\n      if op.name in self._nodes_by_name:\n        raise ValueError(\"cannot add op with name %s as that name \"\n                         \"is already used\" % op.name)\n      self._nodes_by_id[op._id] = op\n      self._nodes_by_name[op.name] = op\nself._version = max(self._version, op._id)\n</code></pre>\n<p>In self.lock is defined in def <strong>init</strong>(self) from Graph object as (filename: python/framework/ops.py):</p>\n<pre><code>self._lock = threading.Lock()\nself._nodes_by_id = dict() # GUARDED_BY(self._lock)\n</code></pre>", "body_text": "@girving We are using pdb to debug test case and tried to print the op.outputs[0].eval() . The mismatch we could observe after _add_op(self, op) is being called as below:\nret = Operation(node_def, self, inputs=inputs, output_types=dtypes,\n                    control_inputs=control_inputs, input_types=input_types,\n                    original_op=self._default_original_op, op_def=op_def)\n    if compute_shapes:\n      set_shapes_for_outputs(ret)\n-------------> **here,  ret.outputs[0].eval() gives NotFoundError**\n    self._add_op(ret)\n-------------> **here,  p ret.outputs[0].eval() gives array([3, 5, 7]) ( expected output is array[4,2,8])**\n\nAbout self.lock, this is used in the definition of _add_op function( filename: python/framework/ops.py):\n\nwith self._lock:\n      # pylint: disable=protected-access\n      if op._id in self._nodes_by_id:\n        raise ValueError(\"cannot add an op with id %d as it already \"\n                         \"exists in the graph\" % op._id)\n      if op.name in self._nodes_by_name:\n        raise ValueError(\"cannot add op with name %s as that name \"\n                         \"is already used\" % op.name)\n      self._nodes_by_id[op._id] = op\n      self._nodes_by_name[op.name] = op\nself._version = max(self._version, op._id)\n\nIn self.lock is defined in def init(self) from Graph object as (filename: python/framework/ops.py):\nself._lock = threading.Lock()\nself._nodes_by_id = dict() # GUARDED_BY(self._lock)", "body": "@girving We are using pdb to debug test case and tried to print the op.outputs[0].eval() . The mismatch we could observe after _add_op(self, op) is being called as below:\n\n```\nret = Operation(node_def, self, inputs=inputs, output_types=dtypes,\n                    control_inputs=control_inputs, input_types=input_types,\n                    original_op=self._default_original_op, op_def=op_def)\n    if compute_shapes:\n      set_shapes_for_outputs(ret)\n-------------> **here,  ret.outputs[0].eval() gives NotFoundError**\n    self._add_op(ret)\n-------------> **here,  p ret.outputs[0].eval() gives array([3, 5, 7]) ( expected output is array[4,2,8])**\n```\n\nAbout `self.lock`, this is used in the definition of _add_op function( filename: python/framework/ops.py):\n\n```\n\nwith self._lock:\n      # pylint: disable=protected-access\n      if op._id in self._nodes_by_id:\n        raise ValueError(\"cannot add an op with id %d as it already \"\n                         \"exists in the graph\" % op._id)\n      if op.name in self._nodes_by_name:\n        raise ValueError(\"cannot add op with name %s as that name \"\n                         \"is already used\" % op.name)\n      self._nodes_by_id[op._id] = op\n      self._nodes_by_name[op.name] = op\nself._version = max(self._version, op._id)\n```\n\nIn self.lock is defined in def **init**(self) from Graph object as (filename: python/framework/ops.py):\n\n```\nself._lock = threading.Lock()\nself._nodes_by_id = dict() # GUARDED_BY(self._lock)\n```\n"}