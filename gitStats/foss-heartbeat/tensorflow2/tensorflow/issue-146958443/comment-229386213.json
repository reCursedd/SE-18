{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/229386213", "html_url": "https://github.com/tensorflow/tensorflow/issues/1824#issuecomment-229386213", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/1824", "id": 229386213, "node_id": "MDEyOklzc3VlQ29tbWVudDIyOTM4NjIxMw==", "user": {"login": "prb12", "id": 11547801, "node_id": "MDQ6VXNlcjExNTQ3ODAx", "avatar_url": "https://avatars1.githubusercontent.com/u/11547801?v=4", "gravatar_id": "", "url": "https://api.github.com/users/prb12", "html_url": "https://github.com/prb12", "followers_url": "https://api.github.com/users/prb12/followers", "following_url": "https://api.github.com/users/prb12/following{/other_user}", "gists_url": "https://api.github.com/users/prb12/gists{/gist_id}", "starred_url": "https://api.github.com/users/prb12/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/prb12/subscriptions", "organizations_url": "https://api.github.com/users/prb12/orgs", "repos_url": "https://api.github.com/users/prb12/repos", "events_url": "https://api.github.com/users/prb12/events{/privacy}", "received_events_url": "https://api.github.com/users/prb12/received_events", "type": "User", "site_admin": false}, "created_at": "2016-06-29T15:07:40Z", "updated_at": "2016-06-29T15:07:40Z", "author_association": "MEMBER", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=5780644\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/srp1970\">@srp1970</a> Without seeing your entire program it's hard to know, but one thing you should bear in mind is that this tracing mechanism is designed to capture just a single step (i.e. a single call to session.run()).  The <code>run_metadata</code> protobuf is an <em>out</em> parameter of the <code>session.run</code> call, and will be overwritten each time - i.e. you shouldn't really use it for multiple calls.</p>\n<p>I'm not sure what the python swig wrapper will do if you reuse a non-empty proto.  It <em>may</em> attempt to merge in the new results - but it's very unlikely that the <code>Timeline</code> code with know how to deal with this.</p>\n<p>Perhaps you could try printing out the contents of step_stats?  Then try tracing just a single run call?</p>", "body_text": "@srp1970 Without seeing your entire program it's hard to know, but one thing you should bear in mind is that this tracing mechanism is designed to capture just a single step (i.e. a single call to session.run()).  The run_metadata protobuf is an out parameter of the session.run call, and will be overwritten each time - i.e. you shouldn't really use it for multiple calls.\nI'm not sure what the python swig wrapper will do if you reuse a non-empty proto.  It may attempt to merge in the new results - but it's very unlikely that the Timeline code with know how to deal with this.\nPerhaps you could try printing out the contents of step_stats?  Then try tracing just a single run call?", "body": "@srp1970 Without seeing your entire program it's hard to know, but one thing you should bear in mind is that this tracing mechanism is designed to capture just a single step (i.e. a single call to session.run()).  The `run_metadata` protobuf is an _out_ parameter of the `session.run` call, and will be overwritten each time - i.e. you shouldn't really use it for multiple calls.   \n\nI'm not sure what the python swig wrapper will do if you reuse a non-empty proto.  It _may_ attempt to merge in the new results - but it's very unlikely that the `Timeline` code with know how to deal with this. \n\nPerhaps you could try printing out the contents of step_stats?  Then try tracing just a single run call?\n"}