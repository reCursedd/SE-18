{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/293829953", "html_url": "https://github.com/tensorflow/tensorflow/issues/9138#issuecomment-293829953", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9138", "id": 293829953, "node_id": "MDEyOklzc3VlQ29tbWVudDI5MzgyOTk1Mw==", "user": {"login": "maks-a", "id": 2526944, "node_id": "MDQ6VXNlcjI1MjY5NDQ=", "avatar_url": "https://avatars2.githubusercontent.com/u/2526944?v=4", "gravatar_id": "", "url": "https://api.github.com/users/maks-a", "html_url": "https://github.com/maks-a", "followers_url": "https://api.github.com/users/maks-a/followers", "following_url": "https://api.github.com/users/maks-a/following{/other_user}", "gists_url": "https://api.github.com/users/maks-a/gists{/gist_id}", "starred_url": "https://api.github.com/users/maks-a/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/maks-a/subscriptions", "organizations_url": "https://api.github.com/users/maks-a/orgs", "repos_url": "https://api.github.com/users/maks-a/repos", "events_url": "https://api.github.com/users/maks-a/events{/privacy}", "received_events_url": "https://api.github.com/users/maks-a/received_events", "type": "User", "site_admin": false}, "created_at": "2017-04-13T08:44:57Z", "updated_at": "2017-04-13T08:56:35Z", "author_association": "NONE", "body_html": "<blockquote>\n<p>Do you actually see anything alarming?</p>\n</blockquote>\n<p>it may get undefined behavior if the value returned by <code>c-&gt;Value(tree_depth)</code> is more than 31.</p>\n<div class=\"highlight highlight-source-c++\"><pre>#<span class=\"pl-k\">include</span> <span class=\"pl-s\"><span class=\"pl-pds\">&lt;</span>iostream<span class=\"pl-pds\">&gt;</span></span>\n<span class=\"pl-k\">using</span> <span class=\"pl-k\">namespace</span> <span class=\"pl-en\">std</span><span class=\"pl-k\">;</span>\n\n<span class=\"pl-k\">int</span> <span class=\"pl-en\">main</span>() {\n  <span class=\"pl-k\">for</span> (<span class=\"pl-c1\">int64_t</span> v = <span class=\"pl-c1\">29</span>; v &lt; <span class=\"pl-c1\">35</span>; ++v) {\n    <span class=\"pl-c1\">int64_t</span> a = (<span class=\"pl-c1\">1L</span> &lt;&lt; v) - <span class=\"pl-c1\">1</span>;\n    <span class=\"pl-c1\">int64_t</span> b = (<span class=\"pl-c1\">1</span>  &lt;&lt; v) - <span class=\"pl-c1\">1</span>;\n    cout &lt;&lt; <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>value=<span class=\"pl-pds\">\"</span></span> &lt;&lt; v &lt;&lt; <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>, <span class=\"pl-pds\">\"</span></span>;\n    cout &lt;&lt; <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>a=<span class=\"pl-pds\">\"</span></span> &lt;&lt; a &lt;&lt; <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>, <span class=\"pl-pds\">\"</span></span>;\n    cout &lt;&lt; <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>b=<span class=\"pl-pds\">\"</span></span> &lt;&lt; b &lt;&lt; <span class=\"pl-s\"><span class=\"pl-pds\">\"</span> - <span class=\"pl-pds\">\"</span></span> &lt;&lt; (a==b ? <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>OK <span class=\"pl-pds\">\"</span></span> : <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>FAIL!<span class=\"pl-pds\">\"</span></span>) &lt;&lt; endl;\n  }\n  <span class=\"pl-k\">return</span> <span class=\"pl-c1\">0</span>;\n}</pre></div>\n<p>That produces the following output:</p>\n<pre><code>value=29, a=536870911, b=536870911 - OK \nvalue=30, a=1073741823, b=1073741823 - OK \nvalue=31, a=2147483647, b=2147483647 - OK \nvalue=32, a=4294967295, b=0 - FAIL!\nvalue=33, a=8589934591, b=1 - FAIL!\nvalue=34, a=17179869183, b=3 - FAIL!\n</code></pre>\n<p>Explanation from the article:</p>\n<blockquote>\n<p>PVS-Studio warning: V629 Consider inspecting the '1 &lt;&lt; c-&gt;Value(tree_depth)' expression. Bit shifting of the 32-bit value with a subsequent expansion to the 64-bit type. unpack_path_op.cc 55</p>\n<p>The strangeness of this code is in the fact that the 32 and 64 bit values are mixed in the shift and assignment operations. The literal 1 is a 32-bit value, for which a left-side shift is performed. The result of the shift still has a 32-bit type, but is written to the 64-bit variable. It is suspicious, because we may get undefined behavior if the value returned by the Value method is more than 32.</p>\n<p>Here is a quote from the standard: The value of E1 &lt;&lt; E2 is E1 left-shifted E2 bit positions; vacated bits are zero-filled. If E1 has an unsigned type, the value of the result is E1 * 2^E2, reduced modulo one more than the maximum value representable in the result type. Otherwise, if E1 has a signed type and non-negative value, and E1*2^E2 is representable in the result type, then that is the resulting value; otherwise, the behavior is undefined.</p>\n<p>This code can be fixed by writing 1 as a 64-bit literal or doing the type extension via casting. More details on the shift operations can be found in the article \"Wade not in unknown waters. Part three\".</p>\n</blockquote>", "body_text": "Do you actually see anything alarming?\n\nit may get undefined behavior if the value returned by c->Value(tree_depth) is more than 31.\n#include <iostream>\nusing namespace std;\n\nint main() {\n  for (int64_t v = 29; v < 35; ++v) {\n    int64_t a = (1L << v) - 1;\n    int64_t b = (1  << v) - 1;\n    cout << \"value=\" << v << \", \";\n    cout << \"a=\" << a << \", \";\n    cout << \"b=\" << b << \" - \" << (a==b ? \"OK \" : \"FAIL!\") << endl;\n  }\n  return 0;\n}\nThat produces the following output:\nvalue=29, a=536870911, b=536870911 - OK \nvalue=30, a=1073741823, b=1073741823 - OK \nvalue=31, a=2147483647, b=2147483647 - OK \nvalue=32, a=4294967295, b=0 - FAIL!\nvalue=33, a=8589934591, b=1 - FAIL!\nvalue=34, a=17179869183, b=3 - FAIL!\n\nExplanation from the article:\n\nPVS-Studio warning: V629 Consider inspecting the '1 << c->Value(tree_depth)' expression. Bit shifting of the 32-bit value with a subsequent expansion to the 64-bit type. unpack_path_op.cc 55\nThe strangeness of this code is in the fact that the 32 and 64 bit values are mixed in the shift and assignment operations. The literal 1 is a 32-bit value, for which a left-side shift is performed. The result of the shift still has a 32-bit type, but is written to the 64-bit variable. It is suspicious, because we may get undefined behavior if the value returned by the Value method is more than 32.\nHere is a quote from the standard: The value of E1 << E2 is E1 left-shifted E2 bit positions; vacated bits are zero-filled. If E1 has an unsigned type, the value of the result is E1 * 2^E2, reduced modulo one more than the maximum value representable in the result type. Otherwise, if E1 has a signed type and non-negative value, and E1*2^E2 is representable in the result type, then that is the resulting value; otherwise, the behavior is undefined.\nThis code can be fixed by writing 1 as a 64-bit literal or doing the type extension via casting. More details on the shift operations can be found in the article \"Wade not in unknown waters. Part three\".", "body": "> Do you actually see anything alarming?\r\n\r\nit may get undefined behavior if the value returned by `c->Value(tree_depth)` is more than 31.\r\n```cpp\r\n#include <iostream>\r\nusing namespace std;\r\n\r\nint main() {\r\n  for (int64_t v = 29; v < 35; ++v) {\r\n    int64_t a = (1L << v) - 1;\r\n    int64_t b = (1  << v) - 1;\r\n    cout << \"value=\" << v << \", \";\r\n    cout << \"a=\" << a << \", \";\r\n    cout << \"b=\" << b << \" - \" << (a==b ? \"OK \" : \"FAIL!\") << endl;\r\n  }\r\n  return 0;\r\n}\r\n```\r\nThat produces the following output:\r\n```\r\nvalue=29, a=536870911, b=536870911 - OK \r\nvalue=30, a=1073741823, b=1073741823 - OK \r\nvalue=31, a=2147483647, b=2147483647 - OK \r\nvalue=32, a=4294967295, b=0 - FAIL!\r\nvalue=33, a=8589934591, b=1 - FAIL!\r\nvalue=34, a=17179869183, b=3 - FAIL!\r\n```\r\nExplanation from the article:\r\n\r\n> PVS-Studio warning: V629 Consider inspecting the '1 << c->Value(tree_depth)' expression. Bit shifting of the 32-bit value with a subsequent expansion to the 64-bit type. unpack_path_op.cc 55\r\n> \r\n> The strangeness of this code is in the fact that the 32 and 64 bit values are mixed in the shift and assignment operations. The literal 1 is a 32-bit value, for which a left-side shift is performed. The result of the shift still has a 32-bit type, but is written to the 64-bit variable. It is suspicious, because we may get undefined behavior if the value returned by the Value method is more than 32.\r\n> \r\n> Here is a quote from the standard: The value of E1 << E2 is E1 left-shifted E2 bit positions; vacated bits are zero-filled. If E1 has an unsigned type, the value of the result is E1 * 2^E2, reduced modulo one more than the maximum value representable in the result type. Otherwise, if E1 has a signed type and non-negative value, and E1*2^E2 is representable in the result type, then that is the resulting value; otherwise, the behavior is undefined.\r\n> \r\n> This code can be fixed by writing 1 as a 64-bit literal or doing the type extension via casting. More details on the shift operations can be found in the article \"Wade not in unknown waters. Part three\"."}