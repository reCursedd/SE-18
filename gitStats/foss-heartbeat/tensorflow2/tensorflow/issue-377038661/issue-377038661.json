{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/23475", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/23475/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/23475/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/23475/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/23475", "id": 377038661, "node_id": "MDU6SXNzdWUzNzcwMzg2NjE=", "number": 23475, "title": "Using tensor as parameter for tf.range and tf.slice", "user": {"login": "WhoisZihan", "id": 36412994, "node_id": "MDQ6VXNlcjM2NDEyOTk0", "avatar_url": "https://avatars0.githubusercontent.com/u/36412994?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WhoisZihan", "html_url": "https://github.com/WhoisZihan", "followers_url": "https://api.github.com/users/WhoisZihan/followers", "following_url": "https://api.github.com/users/WhoisZihan/following{/other_user}", "gists_url": "https://api.github.com/users/WhoisZihan/gists{/gist_id}", "starred_url": "https://api.github.com/users/WhoisZihan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WhoisZihan/subscriptions", "organizations_url": "https://api.github.com/users/WhoisZihan/orgs", "repos_url": "https://api.github.com/users/WhoisZihan/repos", "events_url": "https://api.github.com/users/WhoisZihan/events{/privacy}", "received_events_url": "https://api.github.com/users/WhoisZihan/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2018-11-03T09:28:04Z", "updated_at": "2018-11-08T01:44:35Z", "closed_at": "2018-11-07T18:10:26Z", "author_association": "NONE", "body_html": "<p><strong>System information</strong></p>\n<ul>\n<li>TensorFlow version (you are using): 1.11 cpu, Python 3.6.5</li>\n<li>Are you willing to contribute it (Yes/No): Yes? But contribute what?</li>\n</ul>\n<p><strong>Describe the feature and the current behavior/state.</strong><br>\nI am using a model that will generate 2 intermediate values <code>yp1</code> and <code>yp2</code>( with shape [1, ] ) during training, who are supposed to be the start index and end index of another tensor <code>context_idxs</code> who has type [1, *] where the second dimension will change each input.</p>\n<p>Now I'd like to extract <code>context_idxs[yp1 : yp2]</code> and further feed them into another LSTM cell, but since yp1 and yp2 is tensor, I could not do that directly or with <code>tf.slice</code>. I find a function called <code>tf.gather</code> that seems to be what I'm looking for, however, I need to generate a range <code>[yp1, yp1+1, yp1+2, ..., yp2]</code> to use <code>tf.gather</code>.</p>\n<p>Then here comes the problem. <code>tf.range</code> seems  not to support using tensor as parameter. However, I can't know the value of yp1 and yp2 in the model (I know how to print them in sess.run, but I'm using them inside the model rather than from outside the graph).</p>\n<p>I'll use a quick example</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-c1\">self</span>.yp1 <span class=\"pl-k\">=</span> tf.argmax(tf.reduce_max(outer, <span class=\"pl-v\">axis</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">2</span>), <span class=\"pl-v\">axis</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">1</span>)\n<span class=\"pl-c1\">self</span>.yp2 <span class=\"pl-k\">=</span> tf.argmax(tf.reduce_max(outer, <span class=\"pl-v\">axis</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">1</span>), <span class=\"pl-v\">axis</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">1</span>)\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> ??</span>\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> how do I get context_idxs[yp1 : yp2]? If context_idxs has shape [64, *], how do I get context_idxs[ : , yp1 : yp2]?</span></pre></div>\n<p>My questions are:</p>\n<ol>\n<li>How can I get dynamic slice <code>context_idxs[yp1 : yp2]</code> of one tensor based on other tensors?</li>\n<li>If I want to batch some values, for example, the yp1 and yp2 becomes <code>[64, 1]</code>, and context_idxs becomes [64, *], is there still any way to do so?</li>\n<li>Is there any other way to show the value of variable just-in-time without having to <code>sess.run</code> each time? Something like normal python will be great.</li>\n</ol>\n<p><strong>Will this change the current api? How?</strong><br>\nMaybe. I know tensorflow is based on graph but I think allowing just-in-time calculation of values will greatly make debugging easier. Normal python will make life much easier...</p>\n<p><strong>Who will benefit with this feature?</strong><br>\nI don't know if anyone else needs it as I'm not an expert.</p>\n<p><strong>Any Other info.</strong><br>\nUbuntu 18.04.1<br>\nPython 3.6.5</p>", "body_text": "System information\n\nTensorFlow version (you are using): 1.11 cpu, Python 3.6.5\nAre you willing to contribute it (Yes/No): Yes? But contribute what?\n\nDescribe the feature and the current behavior/state.\nI am using a model that will generate 2 intermediate values yp1 and yp2( with shape [1, ] ) during training, who are supposed to be the start index and end index of another tensor context_idxs who has type [1, *] where the second dimension will change each input.\nNow I'd like to extract context_idxs[yp1 : yp2] and further feed them into another LSTM cell, but since yp1 and yp2 is tensor, I could not do that directly or with tf.slice. I find a function called tf.gather that seems to be what I'm looking for, however, I need to generate a range [yp1, yp1+1, yp1+2, ..., yp2] to use tf.gather.\nThen here comes the problem. tf.range seems  not to support using tensor as parameter. However, I can't know the value of yp1 and yp2 in the model (I know how to print them in sess.run, but I'm using them inside the model rather than from outside the graph).\nI'll use a quick example\nself.yp1 = tf.argmax(tf.reduce_max(outer, axis=2), axis=1)\nself.yp2 = tf.argmax(tf.reduce_max(outer, axis=1), axis=1)\n\n# ??\n# how do I get context_idxs[yp1 : yp2]? If context_idxs has shape [64, *], how do I get context_idxs[ : , yp1 : yp2]?\nMy questions are:\n\nHow can I get dynamic slice context_idxs[yp1 : yp2] of one tensor based on other tensors?\nIf I want to batch some values, for example, the yp1 and yp2 becomes [64, 1], and context_idxs becomes [64, *], is there still any way to do so?\nIs there any other way to show the value of variable just-in-time without having to sess.run each time? Something like normal python will be great.\n\nWill this change the current api? How?\nMaybe. I know tensorflow is based on graph but I think allowing just-in-time calculation of values will greatly make debugging easier. Normal python will make life much easier...\nWho will benefit with this feature?\nI don't know if anyone else needs it as I'm not an expert.\nAny Other info.\nUbuntu 18.04.1\nPython 3.6.5", "body": "**System information**\r\n- TensorFlow version (you are using): 1.11 cpu, Python 3.6.5\r\n- Are you willing to contribute it (Yes/No): Yes? But contribute what?\r\n\r\n\r\n**Describe the feature and the current behavior/state.**\r\nI am using a model that will generate 2 intermediate values `yp1` and `yp2`( with shape [1, ] ) during training, who are supposed to be the start index and end index of another tensor `context_idxs` who has type [1, *] where the second dimension will change each input.\r\n\r\nNow I'd like to extract `context_idxs[yp1 : yp2]` and further feed them into another LSTM cell, but since yp1 and yp2 is tensor, I could not do that directly or with `tf.slice`. I find a function called `tf.gather` that seems to be what I'm looking for, however, I need to generate a range `[yp1, yp1+1, yp1+2, ..., yp2]` to use `tf.gather`.\r\n\r\nThen here comes the problem. `tf.range` seems  not to support using tensor as parameter. However, I can't know the value of yp1 and yp2 in the model (I know how to print them in sess.run, but I'm using them inside the model rather than from outside the graph).\r\n\r\nI'll use a quick example\r\n```python\r\nself.yp1 = tf.argmax(tf.reduce_max(outer, axis=2), axis=1)\r\nself.yp2 = tf.argmax(tf.reduce_max(outer, axis=1), axis=1)\r\n\r\n# ??\r\n# how do I get context_idxs[yp1 : yp2]? If context_idxs has shape [64, *], how do I get context_idxs[ : , yp1 : yp2]?\r\n```\r\n\r\nMy questions are:\r\n1. How can I get dynamic slice `context_idxs[yp1 : yp2]` of one tensor based on other tensors?\r\n2. If I want to batch some values, for example, the yp1 and yp2 becomes `[64, 1]`, and context_idxs becomes [64, *], is there still any way to do so?\r\n3. Is there any other way to show the value of variable just-in-time without having to `sess.run` each time? Something like normal python will be great.\r\n\r\n**Will this change the current api? How?**\r\nMaybe. I know tensorflow is based on graph but I think allowing just-in-time calculation of values will greatly make debugging easier. Normal python will make life much easier...\r\n\r\n**Who will benefit with this feature?**\r\nI don't know if anyone else needs it as I'm not an expert.\r\n\r\n**Any Other info.**\r\nUbuntu 18.04.1\r\nPython 3.6.5\r\n"}