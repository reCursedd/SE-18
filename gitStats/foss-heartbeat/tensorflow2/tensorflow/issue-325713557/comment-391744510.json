{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/391744510", "html_url": "https://github.com/tensorflow/tensorflow/issues/19499#issuecomment-391744510", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/19499", "id": 391744510, "node_id": "MDEyOklzc3VlQ29tbWVudDM5MTc0NDUxMA==", "user": {"login": "mrry", "id": 192142, "node_id": "MDQ6VXNlcjE5MjE0Mg==", "avatar_url": "https://avatars1.githubusercontent.com/u/192142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mrry", "html_url": "https://github.com/mrry", "followers_url": "https://api.github.com/users/mrry/followers", "following_url": "https://api.github.com/users/mrry/following{/other_user}", "gists_url": "https://api.github.com/users/mrry/gists{/gist_id}", "starred_url": "https://api.github.com/users/mrry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mrry/subscriptions", "organizations_url": "https://api.github.com/users/mrry/orgs", "repos_url": "https://api.github.com/users/mrry/repos", "events_url": "https://api.github.com/users/mrry/events{/privacy}", "received_events_url": "https://api.github.com/users/mrry/received_events", "type": "User", "site_admin": false}, "created_at": "2018-05-24T14:53:51Z", "updated_at": "2018-05-24T14:53:51Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Ugh, yes, whatever we do to that kernel implementation, the current version will still leak the <code>OpKernel</code> object and related guff for each iterator. As a strawman, we could solve it with (i) a new version of <code>IteratorHandleOp</code> that creates the handle doesn't retain a resource, and (ii) some API for creating-and-running-but-not-caching a kernel in eager mode. (CCing <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=16018\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/asimshankar\">@asimshankar</a> since kernel lifetimes in eager is something we've talked about in the past.)</p>\n<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=316167\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/LionelCons\">@LionelCons</a> In the meantime, here's a workaround that should alleviate the file handle leak:</p>\n<div class=\"highlight highlight-source-python\"><pre>dataset <span class=\"pl-k\">=</span> tf.data.TextLineDataset(fp)\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> ...</span>\n<span class=\"pl-k\">for</span> epoch <span class=\"pl-k\">in</span> <span class=\"pl-v\">xrange</span>(epochs):\n  <span class=\"pl-c\"><span class=\"pl-c\">#</span> ...</span>\n  <span class=\"pl-k\">for</span> (x, y) <span class=\"pl-k\">in</span> dataset.take(<span class=\"pl-c1\">MAX_BATCHES</span>):\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> ...</span></pre></div>", "body_text": "Ugh, yes, whatever we do to that kernel implementation, the current version will still leak the OpKernel object and related guff for each iterator. As a strawman, we could solve it with (i) a new version of IteratorHandleOp that creates the handle doesn't retain a resource, and (ii) some API for creating-and-running-but-not-caching a kernel in eager mode. (CCing @asimshankar since kernel lifetimes in eager is something we've talked about in the past.)\n@LionelCons In the meantime, here's a workaround that should alleviate the file handle leak:\ndataset = tf.data.TextLineDataset(fp)\n# ...\nfor epoch in xrange(epochs):\n  # ...\n  for (x, y) in dataset.take(MAX_BATCHES):\n    # ...", "body": "Ugh, yes, whatever we do to that kernel implementation, the current version will still leak the `OpKernel` object and related guff for each iterator. As a strawman, we could solve it with (i) a new version of `IteratorHandleOp` that creates the handle doesn't retain a resource, and (ii) some API for creating-and-running-but-not-caching a kernel in eager mode. (CCing @asimshankar since kernel lifetimes in eager is something we've talked about in the past.)\r\n\r\n@LionelCons In the meantime, here's a workaround that should alleviate the file handle leak:\r\n\r\n```python\r\ndataset = tf.data.TextLineDataset(fp)\r\n# ...\r\nfor epoch in xrange(epochs):\r\n  # ...\r\n  for (x, y) in dataset.take(MAX_BATCHES):\r\n    # ...\r\n```"}