{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/391543456", "html_url": "https://github.com/tensorflow/tensorflow/issues/19499#issuecomment-391543456", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/19499", "id": 391543456, "node_id": "MDEyOklzc3VlQ29tbWVudDM5MTU0MzQ1Ng==", "user": {"login": "allenlavoie", "id": 3731025, "node_id": "MDQ6VXNlcjM3MzEwMjU=", "avatar_url": "https://avatars3.githubusercontent.com/u/3731025?v=4", "gravatar_id": "", "url": "https://api.github.com/users/allenlavoie", "html_url": "https://github.com/allenlavoie", "followers_url": "https://api.github.com/users/allenlavoie/followers", "following_url": "https://api.github.com/users/allenlavoie/following{/other_user}", "gists_url": "https://api.github.com/users/allenlavoie/gists{/gist_id}", "starred_url": "https://api.github.com/users/allenlavoie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/allenlavoie/subscriptions", "organizations_url": "https://api.github.com/users/allenlavoie/orgs", "repos_url": "https://api.github.com/users/allenlavoie/repos", "events_url": "https://api.github.com/users/allenlavoie/events{/privacy}", "received_events_url": "https://api.github.com/users/allenlavoie/received_events", "type": "User", "site_admin": false}, "created_at": "2018-05-24T00:13:30Z", "updated_at": "2018-05-24T00:13:30Z", "author_association": "MEMBER", "body_html": "<p>There is a reference leak, but I don't think it's in Python. DestroyResourceOp gets run and Unrefs the resource, but it looks like IteratorHandleOp is <a href=\"https://github.com/tensorflow/tensorflow/blob/f8b74d642420dcf2f5cab763b41884a05777ea45/tensorflow/core/kernels/data/iterator_ops.cc#L510\">keeping a reference to the resource in its OpKernel</a>. AFAIK kernels are never deleted when executing eagerly, they just sit around in the kernel cache.</p>\n<p>I've verified that removing the reference from IteratorHandleOp fixes the \"files not closed\" issue (they get closed when DestroyResourceOp runs). I can think of horrible hacks to get this to happen only when executing eagerly, but maybe we should discuss tomorrow.</p>", "body_text": "There is a reference leak, but I don't think it's in Python. DestroyResourceOp gets run and Unrefs the resource, but it looks like IteratorHandleOp is keeping a reference to the resource in its OpKernel. AFAIK kernels are never deleted when executing eagerly, they just sit around in the kernel cache.\nI've verified that removing the reference from IteratorHandleOp fixes the \"files not closed\" issue (they get closed when DestroyResourceOp runs). I can think of horrible hacks to get this to happen only when executing eagerly, but maybe we should discuss tomorrow.", "body": "There is a reference leak, but I don't think it's in Python. DestroyResourceOp gets run and Unrefs the resource, but it looks like IteratorHandleOp is [keeping a reference to the resource in its OpKernel](https://github.com/tensorflow/tensorflow/blob/f8b74d642420dcf2f5cab763b41884a05777ea45/tensorflow/core/kernels/data/iterator_ops.cc#L510). AFAIK kernels are never deleted when executing eagerly, they just sit around in the kernel cache.\r\n\r\nI've verified that removing the reference from IteratorHandleOp fixes the \"files not closed\" issue (they get closed when DestroyResourceOp runs). I can think of horrible hacks to get this to happen only when executing eagerly, but maybe we should discuss tomorrow."}