{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/186358297", "pull_request_review_id": 117918719, "id": 186358297, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NjM1ODI5Nw==", "diff_hunk": "@@ -0,0 +1,218 @@\n+/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+#include \"tensorflow/core/framework/dataset.h\"\n+#include \"tensorflow/core/framework/partial_tensor_shape.h\"\n+#include \"tensorflow/core/framework/tensor.h\"\n+\n+namespace tensorflow {\n+\n+namespace {\n+\n+// See documentation in ../ops/dataset_ops.cc for a high-level\n+// description of the following op.\n+\n+// This is based on zip_dataset_op.cc\n+class UnorderedMergeDatasetOp : public DatasetOpKernel {\n+ public:\n+  explicit UnorderedMergeDatasetOp(OpKernelConstruction* ctx)\n+      : DatasetOpKernel(ctx) {}\n+\n+  void MakeDataset(OpKernelContext* ctx, DatasetBase** output) override {\n+    std::vector<DatasetBase*> inputs;\n+    DatasetBase* input0;\n+    OP_REQUIRES_OK(ctx, GetDatasetFromVariantTensor(ctx->input(0), &input0));\n+    inputs.push_back(input0);\n+    for (size_t i = 1; i < ctx->num_inputs(); ++i) {\n+      DatasetBase* input;\n+      OP_REQUIRES_OK(ctx, GetDatasetFromVariantTensor(ctx->input(i), &input));\n+      // from VerifyTypesMatch()\n+      OP_REQUIRES(\n+          ctx, input0->output_dtypes().size() == input->output_dtypes().size(),\n+          errors::InvalidArgument(\n+              \"Number of components does not match: expected \",\n+              input0->output_dtypes().size(), \" types but got \",\n+              input->output_dtypes().size(), \".\"));\n+      for (size_t i = 0; i < input0->output_dtypes().size(); ++i) {\n+        OP_REQUIRES(ctx,\n+                    input0->output_dtypes()[i] == input->output_dtypes()[i],\n+                    errors::InvalidArgument(\n+                        \"Data type mismatch at component \", i, \": expected \",\n+                        DataTypeString(input0->output_dtypes()[i]), \" but got \",\n+                        DataTypeString(input->output_dtypes()[i]), \".\"));\n+      }\n+      // from VerifyShapesCompatible()\n+      OP_REQUIRES(\n+          ctx, input0->output_shapes().size() == input->output_shapes().size(),\n+          errors::InvalidArgument(\n+              \"Number of components does not match: expected \",\n+              input0->output_shapes().size(), \" types but got \",\n+              input->output_shapes().size(), \".\"));\n+      for (size_t i = 0; i < input0->output_shapes().size(); ++i) {\n+        OP_REQUIRES(ctx, input0->output_shapes()[i].IsCompatibleWith(\n+                             input->output_shapes()[i]),\n+                    errors::InvalidArgument(\n+                        \"Incompatible shapes at component \", i, \": expected \",\n+                        input0->output_shapes()[i].DebugString(), \" but got \",\n+                        input->output_shapes()[i].DebugString(), \".\"));\n+      }\n+      inputs.push_back(input);\n+    }\n+    *output = new Dataset(ctx, inputs);\n+  }\n+\n+ private:\n+  class Dataset : public GraphDatasetBase {\n+   public:\n+    explicit Dataset(OpKernelContext* ctx,\n+                     const std::vector<DatasetBase*>& inputs)\n+        : GraphDatasetBase(ctx), inputs_(inputs) {\n+      const auto& input = inputs_[0];\n+      for (DataType dt : input->output_dtypes()) {\n+        output_dtypes_.push_back(dt);\n+      }\n+      output_shapes_.insert(output_shapes_.end(),\n+                            input->output_shapes().begin(),\n+                            input->output_shapes().end());\n+      for (const auto& input : inputs_) {\n+        input->Ref();\n+      }\n+    }\n+\n+    ~Dataset() override {\n+      for (const auto& input : inputs_) {\n+        input->Unref();\n+      }\n+    }\n+\n+    std::unique_ptr<IteratorBase> MakeIterator(\n+        const string& prefix) const override {\n+      return std::unique_ptr<IteratorBase>(\n+          new Iterator({this, strings::StrCat(prefix, \"::UnorderedMerge\")}));\n+    }\n+\n+    const DataTypeVector& output_dtypes() const override {\n+      return output_dtypes_;\n+    }\n+\n+    const std::vector<PartialTensorShape>& output_shapes() const override {\n+      return output_shapes_;\n+    }\n+\n+    string DebugString() override { return \"UnorderedMergeDatasetOp::Dataset\"; }\n+\n+   protected:\n+    Status AsGraphDefInternal(OpKernelContext* ctx, DatasetGraphDefBuilder* b,\n+                              Node** output) const override {\n+      std::vector<Node*> input_graph_nodes;\n+      input_graph_nodes.reserve(inputs_.size());\n+      for (const auto& input : inputs_) {\n+        Node* input_node;\n+        TF_RETURN_IF_ERROR(b->AddParentDataset(ctx, input, &input_node));\n+        input_graph_nodes.emplace_back(input_node);\n+      }\n+      TF_RETURN_IF_ERROR(b->AddDataset(\n+          this, {}, {std::make_pair(0, input_graph_nodes)}, {}, output));\n+      return Status::OK();\n+    }\n+\n+   private:\n+    class Iterator : public DatasetIterator<Dataset> {\n+     public:\n+      explicit Iterator(const Params& params)\n+          : DatasetIterator<Dataset>(params) {\n+        input_impls_.reserve(params.dataset->inputs_.size());\n+        size_t idx = 0;\n+        for (const auto& input : params.dataset->inputs_) {\n+          input_impls_.emplace_back(input->MakeIterator(\n+              strings::StrCat(params.prefix, \"[\", idx++, \"]\")));\n+        }\n+      }\n+\n+      Status GetNextInternal(IteratorContext* ctx,\n+                             std::vector<Tensor>* out_tensors,\n+                             bool* end_of_sequence) override {\n+        mutex_lock l(mu_);\n+        if (input_impls_.empty()) {\n+          *end_of_sequence = true;\n+          return Status::OK();\n+        }\n+        out_tensors->clear();\n+        out_tensors->reserve(1);\n+        int orig_input_start = input_start;\n+        do {\n+          const auto& input_impl = input_impls_[input_start];\n+          std::vector<Tensor> input_tensors;\n+          TF_RETURN_IF_ERROR(\n+              input_impl->GetNext(ctx, &input_tensors, end_of_sequence));", "path": "tensorflow/contrib/data/kernels/unordered_merge_dataset_op.cc", "position": 158, "original_position": 158, "commit_id": "b905186aa9015d240abde9690383b40525a2f02c", "original_commit_id": "482f6c7c20c58f345793ec681033ae4da4beed7e", "user": {"login": "deasuke", "id": 1057390, "node_id": "MDQ6VXNlcjEwNTczOTA=", "avatar_url": "https://avatars0.githubusercontent.com/u/1057390?v=4", "gravatar_id": "", "url": "https://api.github.com/users/deasuke", "html_url": "https://github.com/deasuke", "followers_url": "https://api.github.com/users/deasuke/followers", "following_url": "https://api.github.com/users/deasuke/following{/other_user}", "gists_url": "https://api.github.com/users/deasuke/gists{/gist_id}", "starred_url": "https://api.github.com/users/deasuke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/deasuke/subscriptions", "organizations_url": "https://api.github.com/users/deasuke/orgs", "repos_url": "https://api.github.com/users/deasuke/repos", "events_url": "https://api.github.com/users/deasuke/events{/privacy}", "received_events_url": "https://api.github.com/users/deasuke/received_events", "type": "User", "site_admin": false}, "body": "The API tf.contrib.data.sample_from_datasets looks like a new one and maybe satisfy my original request -- my request **allows** (not requires) non-deterministic behavior -- if it's fast enough. I think I have to try evaluating it.\r\n", "created_at": "2018-05-07T08:25:24Z", "updated_at": "2018-05-07T08:25:24Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/17760#discussion_r186358297", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/17760", "author_association": "NONE", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/186358297"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/17760#discussion_r186358297"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/17760"}}, "body_html": "<p>The API tf.contrib.data.sample_from_datasets looks like a new one and maybe satisfy my original request -- my request <strong>allows</strong> (not requires) non-deterministic behavior -- if it's fast enough. I think I have to try evaluating it.</p>", "body_text": "The API tf.contrib.data.sample_from_datasets looks like a new one and maybe satisfy my original request -- my request allows (not requires) non-deterministic behavior -- if it's fast enough. I think I have to try evaluating it.", "in_reply_to_id": 185869468}