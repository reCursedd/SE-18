{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8330", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8330/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8330/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8330/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/8330", "id": 213628617, "node_id": "MDU6SXNzdWUyMTM2Mjg2MTc=", "number": 8330, "title": "Uncatchable exception messages when using slice_input_producer and batch", "user": {"login": "MicaelCarvalho", "id": 17184992, "node_id": "MDQ6VXNlcjE3MTg0OTky", "avatar_url": "https://avatars3.githubusercontent.com/u/17184992?v=4", "gravatar_id": "", "url": "https://api.github.com/users/MicaelCarvalho", "html_url": "https://github.com/MicaelCarvalho", "followers_url": "https://api.github.com/users/MicaelCarvalho/followers", "following_url": "https://api.github.com/users/MicaelCarvalho/following{/other_user}", "gists_url": "https://api.github.com/users/MicaelCarvalho/gists{/gist_id}", "starred_url": "https://api.github.com/users/MicaelCarvalho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/MicaelCarvalho/subscriptions", "organizations_url": "https://api.github.com/users/MicaelCarvalho/orgs", "repos_url": "https://api.github.com/users/MicaelCarvalho/repos", "events_url": "https://api.github.com/users/MicaelCarvalho/events{/privacy}", "received_events_url": "https://api.github.com/users/MicaelCarvalho/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 404586594, "node_id": "MDU6TGFiZWw0MDQ1ODY1OTQ=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:awaiting%20tensorflower", "name": "stat:awaiting tensorflower", "color": "f4b400", "default": false}, {"id": 473172988, "node_id": "MDU6TGFiZWw0NzMxNzI5ODg=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:bug/performance", "name": "type:bug/performance", "color": "159b2e", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 7, "created_at": "2017-03-12T19:47:52Z", "updated_at": "2017-06-16T17:12:55Z", "closed_at": "2017-06-16T17:12:55Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Hello,</p>\n<p><code>Out of range</code> messages are being thrown by the code below, and they seem to be uncatchable \u2014 I even tried enclosing the whole code with <code>try:</code>, <code>except: pass</code>, but the messages are still printed. While they don't really seem to affect the rest of the code, since we are taking the exact amount of examples available, these messages are quite annoying because with a big pipeline they can get really messy and ruin real-time visualization of logs (the number of errors has a relation with the number of threads).</p>\n<p>If I try to evaluate an extra epoch, then TF raises an exception I can catch, because this time I tried to evaluate an example I don't have, but this isn't the case here.</p>\n<p><strong>Operating System:</strong> Debian 4.8.15-2<br>\n<strong>Installed version of CUDA and cuDNN:</strong> CUDA 8, cuDNN 5<br>\n<strong>python3 -c \"import tensorflow; print(tensorflow.<strong>version</strong>)\"</strong>: 1.0.0</p>\n<h3>Reproducible example</h3>\n<pre><code>import tensorflow as tf\nimport time\n\nnum_epochs = 6\n\na = ([tf.constant(i) for i in range(2)],[tf.constant(i) for i in range(2)])\n\nq1 = tf.train.slice_input_producer(a, num_epochs=num_epochs, shuffle=True, capacity=4)\nq2 = tf.train.batch(q1, batch_size=2, num_threads=2, enqueue_many=False, capacity=4, allow_smaller_final_batch=True)\n\ninit = [tf.global_variables_initializer(), tf.local_variables_initializer()]\nsess = tf.Session()\ncoord = tf.train.Coordinator()\nsess.run(init)\nthreads = tf.train.start_queue_runners(coord=coord, sess=sess)\n\ntest_number = 1\nfor i in range(num_epochs):\n\tprint('Testing %d' % test_number)\n\tignore = sess.run(q2)\n\ttest_number = test_number + 1\n\ttime.sleep(3)\nprint('Done.')\n</code></pre>\n<h3>Output</h3>\n<pre><code>(...initialization messages...)\nTesting 1\nW tensorflow/core/framework/op_kernel.cc:993] Out of range: Reached limit of 6\n         [[Node: input_producer/input_producer/fraction_of_4_full/limit_epochs/CountUpTo = CountUpTo[T=DT_INT64, _class=[\"loc:@input_producer/input_producer/fraction_of_4_full/limit_epochs/epochs\"], limit=6, _device=\"/job:localhost/replica:0/task:0/cpu:0\"](input_producer/input_producer/fraction_of_4_full/limit_epochs/epochs)]]\nTesting 2\nTesting 3\nTesting 4\nW tensorflow/core/framework/op_kernel.cc:993] Out of range: FIFOQueue '_0_input_producer/input_producer/fraction_of_4_full/fraction_of_4_full' is closed and has insufficient elements (requested 1, current size 0)\n         [[Node: input_producer/fraction_of_4_full_Dequeue = QueueDequeueV2[component_types=[DT_INT32], timeout_ms=-1, _device=\"/job:localhost/replica:0/task:0/cpu:0\"](input_producer/input_producer/fraction_of_4_full/fraction_of_4_full)]]\nW tensorflow/core/framework/op_kernel.cc:993] Out of range: FIFOQueue '_0_input_producer/input_producer/fraction_of_4_full/fraction_of_4_full' is closed and has insufficient elements (requested 1, current size 0)\n         [[Node: input_producer/fraction_of_4_full_Dequeue = QueueDequeueV2[component_types=[DT_INT32], timeout_ms=-1, _device=\"/job:localhost/replica:0/task:0/cpu:0\"](input_producer/input_producer/fraction_of_4_full/fraction_of_4_full)]]\nTesting 5\nTesting 6\nDone.\n</code></pre>\n<p>These messages may vary: on multiple runs of the same code, the first one sometimes isn't printed, and the number of messages after <code>Testing 4</code> also changes.</p>\n<p>The documentation of <code>batch</code> states:</p>\n<blockquote>\n<p>The returned operation is a dequeue operation and will throw tf.errors.OutOfRangeError if the input queue is exhausted. If this operation is feeding another input queue, its queue runner will catch this exception, however, if this operation is used in your main thread you are responsible for catching this yourself.</p>\n</blockquote>\n<p>However, no further instruction is given. And since a <code>try: except:</code> didn't work, I'm guessing this is a bug. Could anyone clarify this behavior?</p>\n<p>Thanks in advance.</p>", "body_text": "Hello,\nOut of range messages are being thrown by the code below, and they seem to be uncatchable \u2014 I even tried enclosing the whole code with try:, except: pass, but the messages are still printed. While they don't really seem to affect the rest of the code, since we are taking the exact amount of examples available, these messages are quite annoying because with a big pipeline they can get really messy and ruin real-time visualization of logs (the number of errors has a relation with the number of threads).\nIf I try to evaluate an extra epoch, then TF raises an exception I can catch, because this time I tried to evaluate an example I don't have, but this isn't the case here.\nOperating System: Debian 4.8.15-2\nInstalled version of CUDA and cuDNN: CUDA 8, cuDNN 5\npython3 -c \"import tensorflow; print(tensorflow.version)\": 1.0.0\nReproducible example\nimport tensorflow as tf\nimport time\n\nnum_epochs = 6\n\na = ([tf.constant(i) for i in range(2)],[tf.constant(i) for i in range(2)])\n\nq1 = tf.train.slice_input_producer(a, num_epochs=num_epochs, shuffle=True, capacity=4)\nq2 = tf.train.batch(q1, batch_size=2, num_threads=2, enqueue_many=False, capacity=4, allow_smaller_final_batch=True)\n\ninit = [tf.global_variables_initializer(), tf.local_variables_initializer()]\nsess = tf.Session()\ncoord = tf.train.Coordinator()\nsess.run(init)\nthreads = tf.train.start_queue_runners(coord=coord, sess=sess)\n\ntest_number = 1\nfor i in range(num_epochs):\n\tprint('Testing %d' % test_number)\n\tignore = sess.run(q2)\n\ttest_number = test_number + 1\n\ttime.sleep(3)\nprint('Done.')\n\nOutput\n(...initialization messages...)\nTesting 1\nW tensorflow/core/framework/op_kernel.cc:993] Out of range: Reached limit of 6\n         [[Node: input_producer/input_producer/fraction_of_4_full/limit_epochs/CountUpTo = CountUpTo[T=DT_INT64, _class=[\"loc:@input_producer/input_producer/fraction_of_4_full/limit_epochs/epochs\"], limit=6, _device=\"/job:localhost/replica:0/task:0/cpu:0\"](input_producer/input_producer/fraction_of_4_full/limit_epochs/epochs)]]\nTesting 2\nTesting 3\nTesting 4\nW tensorflow/core/framework/op_kernel.cc:993] Out of range: FIFOQueue '_0_input_producer/input_producer/fraction_of_4_full/fraction_of_4_full' is closed and has insufficient elements (requested 1, current size 0)\n         [[Node: input_producer/fraction_of_4_full_Dequeue = QueueDequeueV2[component_types=[DT_INT32], timeout_ms=-1, _device=\"/job:localhost/replica:0/task:0/cpu:0\"](input_producer/input_producer/fraction_of_4_full/fraction_of_4_full)]]\nW tensorflow/core/framework/op_kernel.cc:993] Out of range: FIFOQueue '_0_input_producer/input_producer/fraction_of_4_full/fraction_of_4_full' is closed and has insufficient elements (requested 1, current size 0)\n         [[Node: input_producer/fraction_of_4_full_Dequeue = QueueDequeueV2[component_types=[DT_INT32], timeout_ms=-1, _device=\"/job:localhost/replica:0/task:0/cpu:0\"](input_producer/input_producer/fraction_of_4_full/fraction_of_4_full)]]\nTesting 5\nTesting 6\nDone.\n\nThese messages may vary: on multiple runs of the same code, the first one sometimes isn't printed, and the number of messages after Testing 4 also changes.\nThe documentation of batch states:\n\nThe returned operation is a dequeue operation and will throw tf.errors.OutOfRangeError if the input queue is exhausted. If this operation is feeding another input queue, its queue runner will catch this exception, however, if this operation is used in your main thread you are responsible for catching this yourself.\n\nHowever, no further instruction is given. And since a try: except: didn't work, I'm guessing this is a bug. Could anyone clarify this behavior?\nThanks in advance.", "body": "Hello,\r\n\r\n`Out of range` messages are being thrown by the code below, and they seem to be uncatchable \u2014 I even tried enclosing the whole code with `try:`, `except: pass`, but the messages are still printed. While they don't really seem to affect the rest of the code, since we are taking the exact amount of examples available, these messages are quite annoying because with a big pipeline they can get really messy and ruin real-time visualization of logs (the number of errors has a relation with the number of threads).\r\n\r\nIf I try to evaluate an extra epoch, then TF raises an exception I can catch, because this time I tried to evaluate an example I don't have, but this isn't the case here.\r\n\r\n**Operating System:** Debian 4.8.15-2\r\n**Installed version of CUDA and cuDNN:** CUDA 8, cuDNN 5\r\n**python3 -c \"import tensorflow; print(tensorflow.__version__)\"**: 1.0.0\r\n\r\n### Reproducible example\r\n\r\n```\r\nimport tensorflow as tf\r\nimport time\r\n\r\nnum_epochs = 6\r\n\r\na = ([tf.constant(i) for i in range(2)],[tf.constant(i) for i in range(2)])\r\n\r\nq1 = tf.train.slice_input_producer(a, num_epochs=num_epochs, shuffle=True, capacity=4)\r\nq2 = tf.train.batch(q1, batch_size=2, num_threads=2, enqueue_many=False, capacity=4, allow_smaller_final_batch=True)\r\n\r\ninit = [tf.global_variables_initializer(), tf.local_variables_initializer()]\r\nsess = tf.Session()\r\ncoord = tf.train.Coordinator()\r\nsess.run(init)\r\nthreads = tf.train.start_queue_runners(coord=coord, sess=sess)\r\n\r\ntest_number = 1\r\nfor i in range(num_epochs):\r\n\tprint('Testing %d' % test_number)\r\n\tignore = sess.run(q2)\r\n\ttest_number = test_number + 1\r\n\ttime.sleep(3)\r\nprint('Done.')\r\n```\r\n\r\n### Output\r\n\r\n```\r\n(...initialization messages...)\r\nTesting 1\r\nW tensorflow/core/framework/op_kernel.cc:993] Out of range: Reached limit of 6\r\n         [[Node: input_producer/input_producer/fraction_of_4_full/limit_epochs/CountUpTo = CountUpTo[T=DT_INT64, _class=[\"loc:@input_producer/input_producer/fraction_of_4_full/limit_epochs/epochs\"], limit=6, _device=\"/job:localhost/replica:0/task:0/cpu:0\"](input_producer/input_producer/fraction_of_4_full/limit_epochs/epochs)]]\r\nTesting 2\r\nTesting 3\r\nTesting 4\r\nW tensorflow/core/framework/op_kernel.cc:993] Out of range: FIFOQueue '_0_input_producer/input_producer/fraction_of_4_full/fraction_of_4_full' is closed and has insufficient elements (requested 1, current size 0)\r\n         [[Node: input_producer/fraction_of_4_full_Dequeue = QueueDequeueV2[component_types=[DT_INT32], timeout_ms=-1, _device=\"/job:localhost/replica:0/task:0/cpu:0\"](input_producer/input_producer/fraction_of_4_full/fraction_of_4_full)]]\r\nW tensorflow/core/framework/op_kernel.cc:993] Out of range: FIFOQueue '_0_input_producer/input_producer/fraction_of_4_full/fraction_of_4_full' is closed and has insufficient elements (requested 1, current size 0)\r\n         [[Node: input_producer/fraction_of_4_full_Dequeue = QueueDequeueV2[component_types=[DT_INT32], timeout_ms=-1, _device=\"/job:localhost/replica:0/task:0/cpu:0\"](input_producer/input_producer/fraction_of_4_full/fraction_of_4_full)]]\r\nTesting 5\r\nTesting 6\r\nDone.\r\n```\r\n\r\nThese messages may vary: on multiple runs of the same code, the first one sometimes isn't printed, and the number of messages after `Testing 4` also changes.\r\n\r\nThe documentation of `batch` states:\r\n> The returned operation is a dequeue operation and will throw tf.errors.OutOfRangeError if the input queue is exhausted. If this operation is feeding another input queue, its queue runner will catch this exception, however, if this operation is used in your main thread you are responsible for catching this yourself.\r\n\r\nHowever, no further instruction is given. And since a `try: except:` didn't work, I'm guessing this is a bug. Could anyone clarify this behavior?\r\n\r\nThanks in advance."}