{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/308845542", "html_url": "https://github.com/tensorflow/tensorflow/issues/8330#issuecomment-308845542", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8330", "id": 308845542, "node_id": "MDEyOklzc3VlQ29tbWVudDMwODg0NTU0Mg==", "user": {"login": "MicaelCarvalho", "id": 17184992, "node_id": "MDQ6VXNlcjE3MTg0OTky", "avatar_url": "https://avatars3.githubusercontent.com/u/17184992?v=4", "gravatar_id": "", "url": "https://api.github.com/users/MicaelCarvalho", "html_url": "https://github.com/MicaelCarvalho", "followers_url": "https://api.github.com/users/MicaelCarvalho/followers", "following_url": "https://api.github.com/users/MicaelCarvalho/following{/other_user}", "gists_url": "https://api.github.com/users/MicaelCarvalho/gists{/gist_id}", "starred_url": "https://api.github.com/users/MicaelCarvalho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/MicaelCarvalho/subscriptions", "organizations_url": "https://api.github.com/users/MicaelCarvalho/orgs", "repos_url": "https://api.github.com/users/MicaelCarvalho/repos", "events_url": "https://api.github.com/users/MicaelCarvalho/events{/privacy}", "received_events_url": "https://api.github.com/users/MicaelCarvalho/received_events", "type": "User", "site_admin": false}, "created_at": "2017-06-15T19:40:21Z", "updated_at": "2017-06-15T19:40:21Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=16366894\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/ymrabet\">@ymrabet</a> that is not the solution. :-)</p>\n<p>Setting num_epochs to None makes the threads continuously feed the queue, without ever stopping. This way, the queue never gets emptied and the problem doesn't happen.</p>\n<p>However, in some situations it is desirable to precisely control the number of epochs, specially when shuffle is enabled, to ensure every sample was seen N times; and in these situations the uncatchable exception messages occur. It won't actually pose big problems, since it's just a message being printed, but it seems to be impossible to block the printing of it (except with some hacky solution like setting high log levels throughout the application, and losing all important logs of tensorflow).</p>", "body_text": "@ymrabet that is not the solution. :-)\nSetting num_epochs to None makes the threads continuously feed the queue, without ever stopping. This way, the queue never gets emptied and the problem doesn't happen.\nHowever, in some situations it is desirable to precisely control the number of epochs, specially when shuffle is enabled, to ensure every sample was seen N times; and in these situations the uncatchable exception messages occur. It won't actually pose big problems, since it's just a message being printed, but it seems to be impossible to block the printing of it (except with some hacky solution like setting high log levels throughout the application, and losing all important logs of tensorflow).", "body": "@ymrabet that is not the solution. :-)\r\n\r\nSetting num_epochs to None makes the threads continuously feed the queue, without ever stopping. This way, the queue never gets emptied and the problem doesn't happen.\r\n\r\nHowever, in some situations it is desirable to precisely control the number of epochs, specially when shuffle is enabled, to ensure every sample was seen N times; and in these situations the uncatchable exception messages occur. It won't actually pose big problems, since it's just a message being printed, but it seems to be impossible to block the printing of it (except with some hacky solution like setting high log levels throughout the application, and losing all important logs of tensorflow)."}