{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/308879035", "html_url": "https://github.com/tensorflow/tensorflow/issues/8330#issuecomment-308879035", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8330", "id": 308879035, "node_id": "MDEyOklzc3VlQ29tbWVudDMwODg3OTAzNQ==", "user": {"login": "MicaelCarvalho", "id": 17184992, "node_id": "MDQ6VXNlcjE3MTg0OTky", "avatar_url": "https://avatars3.githubusercontent.com/u/17184992?v=4", "gravatar_id": "", "url": "https://api.github.com/users/MicaelCarvalho", "html_url": "https://github.com/MicaelCarvalho", "followers_url": "https://api.github.com/users/MicaelCarvalho/followers", "following_url": "https://api.github.com/users/MicaelCarvalho/following{/other_user}", "gists_url": "https://api.github.com/users/MicaelCarvalho/gists{/gist_id}", "starred_url": "https://api.github.com/users/MicaelCarvalho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/MicaelCarvalho/subscriptions", "organizations_url": "https://api.github.com/users/MicaelCarvalho/orgs", "repos_url": "https://api.github.com/users/MicaelCarvalho/repos", "events_url": "https://api.github.com/users/MicaelCarvalho/events{/privacy}", "received_events_url": "https://api.github.com/users/MicaelCarvalho/received_events", "type": "User", "site_admin": false}, "created_at": "2017-06-15T22:07:00Z", "updated_at": "2017-06-15T22:09:29Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=16366894\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/ymrabet\">@ymrabet</a> the problem happens because <code>slice_input_producer</code> only generates the specified number of epochs of input, while <code>batch</code> has no parameter to control the number of epochs, therefore it \"runs forever\".</p>\n<p>Internally, <code>batch</code> creates threads to feed an input queue, from which batches are taken. These threads keep pulling samples from the input tensor indefinitely. The problem occurs when they try to pull a sample and <code>slice_input_producer</code> has finished its job (i.e. there are no samples left, <code>slice_input_producer</code>'s pool is empty).</p>\n<p>The exception is then uncatchable and intractable because it is raised inside each of these threads, when they try to get a new sample and there is none left. Each thread, after raising the exception, has no predefined way of treating it (and that's the problem), so it goes all the way up to the interpreter, which by default prints the exception and kills \"the program\". Since each thread is individually handled, \"the program\" means \"the thread\"; so the thread gets terminated and the error message printed.</p>\n<p>That being said, the number of messages one sees should match exactly the number of threads created by <code>batch</code>, because it is only printed when a thread dies (but weirdly it doesn't always match, and that's something to be investigated maybe). It has no other impact because each thread dies individually, without affecting the main program, and the expected behavior <em>in this case</em> would be closing the threads, which is happening anyway because of the exception.</p>", "body_text": "@ymrabet the problem happens because slice_input_producer only generates the specified number of epochs of input, while batch has no parameter to control the number of epochs, therefore it \"runs forever\".\nInternally, batch creates threads to feed an input queue, from which batches are taken. These threads keep pulling samples from the input tensor indefinitely. The problem occurs when they try to pull a sample and slice_input_producer has finished its job (i.e. there are no samples left, slice_input_producer's pool is empty).\nThe exception is then uncatchable and intractable because it is raised inside each of these threads, when they try to get a new sample and there is none left. Each thread, after raising the exception, has no predefined way of treating it (and that's the problem), so it goes all the way up to the interpreter, which by default prints the exception and kills \"the program\". Since each thread is individually handled, \"the program\" means \"the thread\"; so the thread gets terminated and the error message printed.\nThat being said, the number of messages one sees should match exactly the number of threads created by batch, because it is only printed when a thread dies (but weirdly it doesn't always match, and that's something to be investigated maybe). It has no other impact because each thread dies individually, without affecting the main program, and the expected behavior in this case would be closing the threads, which is happening anyway because of the exception.", "body": "@ymrabet the problem happens because `slice_input_producer` only generates the specified number of epochs of input, while `batch` has no parameter to control the number of epochs, therefore it \"runs forever\".\r\n\r\nInternally, `batch` creates threads to feed an input queue, from which batches are taken. These threads keep pulling samples from the input tensor indefinitely. The problem occurs when they try to pull a sample and `slice_input_producer` has finished its job (i.e. there are no samples left, `slice_input_producer`'s pool is empty).\r\n\r\nThe exception is then uncatchable and intractable because it is raised inside each of these threads, when they try to get a new sample and there is none left. Each thread, after raising the exception, has no predefined way of treating it (and that's the problem), so it goes all the way up to the interpreter, which by default prints the exception and kills \"the program\". Since each thread is individually handled, \"the program\" means \"the thread\"; so the thread gets terminated and the error message printed.\r\n\r\nThat being said, the number of messages one sees should match exactly the number of threads created by `batch`, because it is only printed when a thread dies (but weirdly it doesn't always match, and that's something to be investigated maybe). It has no other impact because each thread dies individually, without affecting the main program, and the expected behavior _in this case_ would be closing the threads, which is happening anyway because of the exception."}