{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/389611457", "html_url": "https://github.com/tensorflow/tensorflow/issues/19041#issuecomment-389611457", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/19041", "id": 389611457, "node_id": "MDEyOklzc3VlQ29tbWVudDM4OTYxMTQ1Nw==", "user": {"login": "zeyademam", "id": 28906340, "node_id": "MDQ6VXNlcjI4OTA2MzQw", "avatar_url": "https://avatars0.githubusercontent.com/u/28906340?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zeyademam", "html_url": "https://github.com/zeyademam", "followers_url": "https://api.github.com/users/zeyademam/followers", "following_url": "https://api.github.com/users/zeyademam/following{/other_user}", "gists_url": "https://api.github.com/users/zeyademam/gists{/gist_id}", "starred_url": "https://api.github.com/users/zeyademam/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zeyademam/subscriptions", "organizations_url": "https://api.github.com/users/zeyademam/orgs", "repos_url": "https://api.github.com/users/zeyademam/repos", "events_url": "https://api.github.com/users/zeyademam/events{/privacy}", "received_events_url": "https://api.github.com/users/zeyademam/received_events", "type": "User", "site_admin": false}, "created_at": "2018-05-16T18:01:49Z", "updated_at": "2018-05-16T18:07:56Z", "author_association": "NONE", "body_html": "<p>I am not using place holders in setting up and training the estimator, this is done internally by the estimator object. Here is a code snippet on how I set up the estimator and train it.</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">import</span> numpy <span class=\"pl-k\">as</span> np\n<span class=\"pl-k\">import</span> tensorflow <span class=\"pl-k\">as</span> tf\n<span class=\"pl-k\">from</span> keras.datasets <span class=\"pl-k\">import</span> cifar10\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">model_fn</span>(<span class=\"pl-smi\">features</span>, <span class=\"pl-smi\">labels</span>, <span class=\"pl-smi\">mode</span>, <span class=\"pl-smi\">params</span>):\n\n    x <span class=\"pl-k\">=</span> tf.reshape(features[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>x<span class=\"pl-pds\">'</span></span>], [<span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">32</span>, <span class=\"pl-c1\">32</span>, <span class=\"pl-c1\">3</span>])\n    x <span class=\"pl-k\">=</span> tf.to_float(x)\n    flatten <span class=\"pl-k\">=</span> tf.layers.flatten(x)\n    logits <span class=\"pl-k\">=</span> tf.layers.dense(<span class=\"pl-v\">inputs</span><span class=\"pl-k\">=</span>flatten,\n                             <span class=\"pl-v\">units</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">10</span>)\n\n\n    predictions <span class=\"pl-k\">=</span> {\n        <span class=\"pl-s\"><span class=\"pl-pds\">'</span>classes<span class=\"pl-pds\">'</span></span>: tf.argmax(<span class=\"pl-v\">input</span><span class=\"pl-k\">=</span>logits, <span class=\"pl-v\">axis</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">1</span>),\n        <span class=\"pl-s\"><span class=\"pl-pds\">'</span>probabilities<span class=\"pl-pds\">'</span></span>: tf.nn.softmax(logits, <span class=\"pl-v\">name</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>softmax_tensor<span class=\"pl-pds\">'</span></span>)\n    }\n\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> Calculate Loss (for both TRAIN and EVAL modes)</span>\n    l2_loss <span class=\"pl-k\">=</span> tf.losses.get_regularization_losses()\n    loss <span class=\"pl-k\">=</span> tf.losses.sparse_softmax_cross_entropy(<span class=\"pl-v\">labels</span><span class=\"pl-k\">=</span>labels, <span class=\"pl-v\">logits</span><span class=\"pl-k\">=</span>logits)\n    loss <span class=\"pl-k\">+=</span> tf.reduce_sum(l2_loss)\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> Calculate Accuracy (for both TRAIN and EVAL modes)</span>\n    accuracy <span class=\"pl-k\">=</span> tf.metrics.accuracy(<span class=\"pl-v\">labels</span><span class=\"pl-k\">=</span>labels,\n                                   <span class=\"pl-v\">predictions</span><span class=\"pl-k\">=</span>predictions[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>classes<span class=\"pl-pds\">'</span></span>],\n                                   <span class=\"pl-v\">name</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>acc_op<span class=\"pl-pds\">'</span></span>)\n    metrics <span class=\"pl-k\">=</span> {<span class=\"pl-s\"><span class=\"pl-pds\">'</span>accuracy<span class=\"pl-pds\">'</span></span>: accuracy}\n\n    <span class=\"pl-k\">if</span> mode <span class=\"pl-k\">==</span> tf.estimator.ModeKeys.<span class=\"pl-c1\">TRAIN</span>:\n        optimizer <span class=\"pl-k\">=</span> tf.train.AdamOptimizer()\n        learning_rate <span class=\"pl-k\">=</span> optimizer._lr\n        train_op <span class=\"pl-k\">=</span> optimizer.minimize(\n            <span class=\"pl-v\">loss</span><span class=\"pl-k\">=</span>loss,\n            <span class=\"pl-v\">global_step</span><span class=\"pl-k\">=</span>tf.train.get_global_step())\n\n\n        <span class=\"pl-k\">return</span> tf.estimator.EstimatorSpec(<span class=\"pl-v\">mode</span><span class=\"pl-k\">=</span>mode,\n                                          <span class=\"pl-v\">loss</span><span class=\"pl-k\">=</span>loss,\n                                          <span class=\"pl-v\">train_op</span><span class=\"pl-k\">=</span>train_op)\n\n\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> Add evaluation metrics (for EVAL mode)</span>\n    <span class=\"pl-k\">if</span> mode <span class=\"pl-k\">==</span> tf.estimator.ModeKeys.<span class=\"pl-c1\">EVAL</span>:\n        <span class=\"pl-k\">return</span> tf.estimator.EstimatorSpec(<span class=\"pl-v\">mode</span><span class=\"pl-k\">=</span>mode,\n                                          <span class=\"pl-v\">loss</span><span class=\"pl-k\">=</span>loss,\n                                          <span class=\"pl-v\">eval_metric_ops</span><span class=\"pl-k\">=</span>metrics)\n\n\n<span class=\"pl-k\">if</span> <span class=\"pl-c1\">__name__</span><span class=\"pl-k\">==</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>__main__<span class=\"pl-pds\">'</span></span>:\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> Load CIFAR10 data</span>\n    (x_train, y_train), (x_test, y_test) <span class=\"pl-k\">=</span> cifar10.load_data()\n\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> Cast y arrays into int32</span>\n    y_train <span class=\"pl-k\">=</span> np.array(y_train, <span class=\"pl-v\">dtype</span><span class=\"pl-k\">=</span>np.int32)\n\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> Create the Estimator</span>\n    model_dir <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>/home/zeyad/delete_me/<span class=\"pl-pds\">'</span></span>\n    classifier <span class=\"pl-k\">=</span> tf.estimator.Estimator(\n        <span class=\"pl-v\">model_fn</span><span class=\"pl-k\">=</span>model_fn,\n        <span class=\"pl-v\">params</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">None</span>,\n        <span class=\"pl-v\">model_dir</span><span class=\"pl-k\">=</span>model_dir)\n\n    input_fn <span class=\"pl-k\">=</span> tf.estimator.inputs.numpy_input_fn(<span class=\"pl-v\">x</span><span class=\"pl-k\">=</span>{<span class=\"pl-s\"><span class=\"pl-pds\">'</span>x<span class=\"pl-pds\">'</span></span>:x_train},\n                                                  <span class=\"pl-v\">y</span><span class=\"pl-k\">=</span>y_train,\n                                                  <span class=\"pl-v\">batch_size</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">1</span>, <span class=\"pl-v\">shuffle</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">True</span>)\n\n    classifier.train(\n        <span class=\"pl-v\">input_fn</span><span class=\"pl-k\">=</span>input_fn,\n        <span class=\"pl-v\">max_steps</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">5</span>)\n</pre></div>\n<p>Now after the above saves the checkpoint files, I would like to load those checkpoint files using the following snippet, but I am not sure how to retrieve the input placeholder by name:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">import</span> tensorflow <span class=\"pl-k\">as</span> tf\n\nmodel_dir <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>/home/zeyad/delete_me/<span class=\"pl-pds\">'</span></span>\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">attack</span>():\n\n    sess <span class=\"pl-k\">=</span> tf.Session()\n    saver <span class=\"pl-k\">=</span> tf.train.import_meta_graph(model_dir<span class=\"pl-k\">+</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>/model.ckpt-1.meta<span class=\"pl-pds\">'</span></span>)\n    saver.restore(sess, tf.train.latest_checkpoint(model_dir))\n    graph <span class=\"pl-k\">=</span> tf.get_default_graph()\n\n    inputs <span class=\"pl-k\">=</span> graph.get_tensor_by_name()     <span class=\"pl-c\"><span class=\"pl-c\">#</span> what do i put here?</span></pre></div>\n<p>If I were able to do that then i can implement things such as implementing an adversarial attack on a previously saved network, disabling dropout, etc...</p>", "body_text": "I am not using place holders in setting up and training the estimator, this is done internally by the estimator object. Here is a code snippet on how I set up the estimator and train it.\nimport numpy as np\nimport tensorflow as tf\nfrom keras.datasets import cifar10\n\ndef model_fn(features, labels, mode, params):\n\n    x = tf.reshape(features['x'], [-1, 32, 32, 3])\n    x = tf.to_float(x)\n    flatten = tf.layers.flatten(x)\n    logits = tf.layers.dense(inputs=flatten,\n                             units=10)\n\n\n    predictions = {\n        'classes': tf.argmax(input=logits, axis=1),\n        'probabilities': tf.nn.softmax(logits, name='softmax_tensor')\n    }\n\n    # Calculate Loss (for both TRAIN and EVAL modes)\n    l2_loss = tf.losses.get_regularization_losses()\n    loss = tf.losses.sparse_softmax_cross_entropy(labels=labels, logits=logits)\n    loss += tf.reduce_sum(l2_loss)\n    # Calculate Accuracy (for both TRAIN and EVAL modes)\n    accuracy = tf.metrics.accuracy(labels=labels,\n                                   predictions=predictions['classes'],\n                                   name='acc_op')\n    metrics = {'accuracy': accuracy}\n\n    if mode == tf.estimator.ModeKeys.TRAIN:\n        optimizer = tf.train.AdamOptimizer()\n        learning_rate = optimizer._lr\n        train_op = optimizer.minimize(\n            loss=loss,\n            global_step=tf.train.get_global_step())\n\n\n        return tf.estimator.EstimatorSpec(mode=mode,\n                                          loss=loss,\n                                          train_op=train_op)\n\n\n    # Add evaluation metrics (for EVAL mode)\n    if mode == tf.estimator.ModeKeys.EVAL:\n        return tf.estimator.EstimatorSpec(mode=mode,\n                                          loss=loss,\n                                          eval_metric_ops=metrics)\n\n\nif __name__== '__main__':\n    # Load CIFAR10 data\n    (x_train, y_train), (x_test, y_test) = cifar10.load_data()\n\n    # Cast y arrays into int32\n    y_train = np.array(y_train, dtype=np.int32)\n\n    # Create the Estimator\n    model_dir = '/home/zeyad/delete_me/'\n    classifier = tf.estimator.Estimator(\n        model_fn=model_fn,\n        params=None,\n        model_dir=model_dir)\n\n    input_fn = tf.estimator.inputs.numpy_input_fn(x={'x':x_train},\n                                                  y=y_train,\n                                                  batch_size=1, shuffle=True)\n\n    classifier.train(\n        input_fn=input_fn,\n        max_steps=5)\n\nNow after the above saves the checkpoint files, I would like to load those checkpoint files using the following snippet, but I am not sure how to retrieve the input placeholder by name:\nimport tensorflow as tf\n\nmodel_dir = '/home/zeyad/delete_me/'\ndef attack():\n\n    sess = tf.Session()\n    saver = tf.train.import_meta_graph(model_dir+'/model.ckpt-1.meta')\n    saver.restore(sess, tf.train.latest_checkpoint(model_dir))\n    graph = tf.get_default_graph()\n\n    inputs = graph.get_tensor_by_name()     # what do i put here?\nIf I were able to do that then i can implement things such as implementing an adversarial attack on a previously saved network, disabling dropout, etc...", "body": "I am not using place holders in setting up and training the estimator, this is done internally by the estimator object. Here is a code snippet on how I set up the estimator and train it.\r\n\r\n```python\r\nimport numpy as np\r\nimport tensorflow as tf\r\nfrom keras.datasets import cifar10\r\n\r\ndef model_fn(features, labels, mode, params):\r\n\r\n    x = tf.reshape(features['x'], [-1, 32, 32, 3])\r\n    x = tf.to_float(x)\r\n    flatten = tf.layers.flatten(x)\r\n    logits = tf.layers.dense(inputs=flatten,\r\n                             units=10)\r\n\r\n\r\n    predictions = {\r\n        'classes': tf.argmax(input=logits, axis=1),\r\n        'probabilities': tf.nn.softmax(logits, name='softmax_tensor')\r\n    }\r\n\r\n    # Calculate Loss (for both TRAIN and EVAL modes)\r\n    l2_loss = tf.losses.get_regularization_losses()\r\n    loss = tf.losses.sparse_softmax_cross_entropy(labels=labels, logits=logits)\r\n    loss += tf.reduce_sum(l2_loss)\r\n    # Calculate Accuracy (for both TRAIN and EVAL modes)\r\n    accuracy = tf.metrics.accuracy(labels=labels,\r\n                                   predictions=predictions['classes'],\r\n                                   name='acc_op')\r\n    metrics = {'accuracy': accuracy}\r\n\r\n    if mode == tf.estimator.ModeKeys.TRAIN:\r\n        optimizer = tf.train.AdamOptimizer()\r\n        learning_rate = optimizer._lr\r\n        train_op = optimizer.minimize(\r\n            loss=loss,\r\n            global_step=tf.train.get_global_step())\r\n\r\n\r\n        return tf.estimator.EstimatorSpec(mode=mode,\r\n                                          loss=loss,\r\n                                          train_op=train_op)\r\n\r\n\r\n    # Add evaluation metrics (for EVAL mode)\r\n    if mode == tf.estimator.ModeKeys.EVAL:\r\n        return tf.estimator.EstimatorSpec(mode=mode,\r\n                                          loss=loss,\r\n                                          eval_metric_ops=metrics)\r\n\r\n\r\nif __name__== '__main__':\r\n    # Load CIFAR10 data\r\n    (x_train, y_train), (x_test, y_test) = cifar10.load_data()\r\n\r\n    # Cast y arrays into int32\r\n    y_train = np.array(y_train, dtype=np.int32)\r\n\r\n    # Create the Estimator\r\n    model_dir = '/home/zeyad/delete_me/'\r\n    classifier = tf.estimator.Estimator(\r\n        model_fn=model_fn,\r\n        params=None,\r\n        model_dir=model_dir)\r\n\r\n    input_fn = tf.estimator.inputs.numpy_input_fn(x={'x':x_train},\r\n                                                  y=y_train,\r\n                                                  batch_size=1, shuffle=True)\r\n\r\n    classifier.train(\r\n        input_fn=input_fn,\r\n        max_steps=5)\r\n\r\n```\r\n\r\nNow after the above saves the checkpoint files, I would like to load those checkpoint files using the following snippet, but I am not sure how to retrieve the input placeholder by name:\r\n\r\n```python\r\nimport tensorflow as tf\r\n\r\nmodel_dir = '/home/zeyad/delete_me/'\r\ndef attack():\r\n\r\n    sess = tf.Session()\r\n    saver = tf.train.import_meta_graph(model_dir+'/model.ckpt-1.meta')\r\n    saver.restore(sess, tf.train.latest_checkpoint(model_dir))\r\n    graph = tf.get_default_graph()\r\n\r\n    inputs = graph.get_tensor_by_name()     # what do i put here?\r\n```\r\n\r\nIf I were able to do that then i can implement things such as implementing an adversarial attack on a previously saved network, disabling dropout, etc... \r\n"}