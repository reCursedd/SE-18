{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/277893752", "html_url": "https://github.com/tensorflow/tensorflow/issues/7314#issuecomment-277893752", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/7314", "id": 277893752, "node_id": "MDEyOklzc3VlQ29tbWVudDI3Nzg5Mzc1Mg==", "user": {"login": "yaroslavvb", "id": 23068, "node_id": "MDQ6VXNlcjIzMDY4", "avatar_url": "https://avatars3.githubusercontent.com/u/23068?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yaroslavvb", "html_url": "https://github.com/yaroslavvb", "followers_url": "https://api.github.com/users/yaroslavvb/followers", "following_url": "https://api.github.com/users/yaroslavvb/following{/other_user}", "gists_url": "https://api.github.com/users/yaroslavvb/gists{/gist_id}", "starred_url": "https://api.github.com/users/yaroslavvb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yaroslavvb/subscriptions", "organizations_url": "https://api.github.com/users/yaroslavvb/orgs", "repos_url": "https://api.github.com/users/yaroslavvb/repos", "events_url": "https://api.github.com/users/yaroslavvb/events{/privacy}", "received_events_url": "https://api.github.com/users/yaroslavvb/received_events", "type": "User", "site_admin": false}, "created_at": "2017-02-07T03:47:46Z", "updated_at": "2017-02-07T03:47:46Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Seems like an odd one out since other input producers give queues. cc <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=15258583\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/josh11b\">@josh11b</a> who added this code</p>\n<pre><code>with ops.name_scope(name, \"input_producer\", tensor_list):\n    tensor_list = ops.convert_n_to_tensor_or_indexed_slices(tensor_list)\n    if not tensor_list:\n      raise ValueError(\n          \"Expected at least one tensor in slice_input_producer().\")\n    range_size = array_ops.shape(tensor_list[0])[0]\n    # TODO(josh11b): Add an assertion that the first dimension of\n    # everything in TensorList matches. Maybe just check the inferred shapes?\n    queue = range_input_producer(range_size, num_epochs=num_epochs,\n                                 shuffle=shuffle, seed=seed, capacity=capacity,\n                                 shared_name=shared_name)\n    index = queue.dequeue()\n    output = [array_ops.gather(t, index) for t in tensor_list]\n    return output\n</code></pre>", "body_text": "Seems like an odd one out since other input producers give queues. cc @josh11b who added this code\nwith ops.name_scope(name, \"input_producer\", tensor_list):\n    tensor_list = ops.convert_n_to_tensor_or_indexed_slices(tensor_list)\n    if not tensor_list:\n      raise ValueError(\n          \"Expected at least one tensor in slice_input_producer().\")\n    range_size = array_ops.shape(tensor_list[0])[0]\n    # TODO(josh11b): Add an assertion that the first dimension of\n    # everything in TensorList matches. Maybe just check the inferred shapes?\n    queue = range_input_producer(range_size, num_epochs=num_epochs,\n                                 shuffle=shuffle, seed=seed, capacity=capacity,\n                                 shared_name=shared_name)\n    index = queue.dequeue()\n    output = [array_ops.gather(t, index) for t in tensor_list]\n    return output", "body": "Seems like an odd one out since other input producers give queues. cc @josh11b who added this code\r\n\r\n```\r\nwith ops.name_scope(name, \"input_producer\", tensor_list):\r\n    tensor_list = ops.convert_n_to_tensor_or_indexed_slices(tensor_list)\r\n    if not tensor_list:\r\n      raise ValueError(\r\n          \"Expected at least one tensor in slice_input_producer().\")\r\n    range_size = array_ops.shape(tensor_list[0])[0]\r\n    # TODO(josh11b): Add an assertion that the first dimension of\r\n    # everything in TensorList matches. Maybe just check the inferred shapes?\r\n    queue = range_input_producer(range_size, num_epochs=num_epochs,\r\n                                 shuffle=shuffle, seed=seed, capacity=capacity,\r\n                                 shared_name=shared_name)\r\n    index = queue.dequeue()\r\n    output = [array_ops.gather(t, index) for t in tensor_list]\r\n    return output\r\n```"}