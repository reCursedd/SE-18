{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/277771091", "html_url": "https://github.com/tensorflow/tensorflow/issues/7149#issuecomment-277771091", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/7149", "id": 277771091, "node_id": "MDEyOklzc3VlQ29tbWVudDI3Nzc3MTA5MQ==", "user": {"login": "karllessard", "id": 10109534, "node_id": "MDQ6VXNlcjEwMTA5NTM0", "avatar_url": "https://avatars3.githubusercontent.com/u/10109534?v=4", "gravatar_id": "", "url": "https://api.github.com/users/karllessard", "html_url": "https://github.com/karllessard", "followers_url": "https://api.github.com/users/karllessard/followers", "following_url": "https://api.github.com/users/karllessard/following{/other_user}", "gists_url": "https://api.github.com/users/karllessard/gists{/gist_id}", "starred_url": "https://api.github.com/users/karllessard/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/karllessard/subscriptions", "organizations_url": "https://api.github.com/users/karllessard/orgs", "repos_url": "https://api.github.com/users/karllessard/repos", "events_url": "https://api.github.com/users/karllessard/events{/privacy}", "received_events_url": "https://api.github.com/users/karllessard/received_events", "type": "User", "site_admin": false}, "created_at": "2017-02-06T18:33:49Z", "updated_at": "2017-02-06T18:33:49Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Anyone curious to see how a static API for building a graph may look like, I've pushed a little POC to my <a href=\"https://github.com/karllessard/tensorflow/tree/java-static-api/tensorflow/java\">repo</a> (this <a href=\"https://github.com/karllessard/tensorflow/commit/d2a5518a5830ec9d0b81912b95e3e33b64bd5ec5\">commit</a>)  that minimally fulfill the requirements of the <a href=\"https://github.com/karllessard/tensorflow/blob/java-static-api/tensorflow/java/src/main/java/org/tensorflow/examples/LabelImage2.java\">LabelImage</a> example.</p>\n<p>This POC focuses on the following point:</p>\n<ol>\n<li>\n<p>Group operations into related topics, like the C++ client does, by generating a static API per /tensorflow/core/ops/* library (e.g. <a href=\"https://github.com/karllessard/tensorflow/blob/java-static-api/tensorflow/java/src/main/java/org/tensorflow/ops/image/ImageOps.java\">ImageOps</a>, <a href=\"https://github.com/karllessard/tensorflow/blob/java-static-api/tensorflow/java/src/main/java/org/tensorflow/ops/array/ArrayOps.java\">ArrayOps</a>, ...)</p>\n</li>\n<li>\n<p>Allow optional parametrization using operation-specific methods encapsulated in their own classes (e.g. the <a href=\"https://github.com/karllessard/tensorflow/blob/java-static-api/tensorflow/java/src/main/java/org/tensorflow/ops/image/DecodeJpeg.java\">DecodeJpeg</a> interface)</p>\n</li>\n<li>\n<p>Keep the simplicity and elegance of the solution from the previous version of LabelImage while allowing more flexibility to support all cases (e.g. multi-output operations, etc). The following lists supported technics to connect nodes together.</p>\n</li>\n</ol>\n<p>a) Functionally</p>\n<div class=\"highlight highlight-source-java\"><pre>op1(s, op2(s, const(s, x)), const(s, y));</pre></div>\n<p>b) By node references</p>\n<div class=\"highlight highlight-source-java\"><pre><span class=\"pl-smi\">Const</span> c1 <span class=\"pl-k\">=</span> const(s, x);\n<span class=\"pl-smi\">Const</span> c2 <span class=\"pl-k\">=</span> const(s, y);\nop1(s, op2(s, c1), c2);</pre></div>\n<p>c) By node lookups</p>\n<div class=\"highlight highlight-source-java\"><pre>op2(s, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>op2<span class=\"pl-pds\">\"</span></span>, const(s, x));\nop1(s, s<span class=\"pl-k\">.</span>node(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>op2<span class=\"pl-pds\">\"</span></span>), const(s, y));</pre></div>\n<p>Technics b) and c) allows us to access output value other than the default (0) one for multi-output operations. For example:</p>\n<div class=\"highlight highlight-source-java\"><pre>op1(s, s<span class=\"pl-k\">.</span>node(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>op2<span class=\"pl-pds\">\"</span></span>)<span class=\"pl-k\">.</span>output(<span class=\"pl-c1\">1</span>), const(s, y));</pre></div>\n<p>Any comments are more than welcomed</p>", "body_text": "Anyone curious to see how a static API for building a graph may look like, I've pushed a little POC to my repo (this commit)  that minimally fulfill the requirements of the LabelImage example.\nThis POC focuses on the following point:\n\n\nGroup operations into related topics, like the C++ client does, by generating a static API per /tensorflow/core/ops/* library (e.g. ImageOps, ArrayOps, ...)\n\n\nAllow optional parametrization using operation-specific methods encapsulated in their own classes (e.g. the DecodeJpeg interface)\n\n\nKeep the simplicity and elegance of the solution from the previous version of LabelImage while allowing more flexibility to support all cases (e.g. multi-output operations, etc). The following lists supported technics to connect nodes together.\n\n\na) Functionally\nop1(s, op2(s, const(s, x)), const(s, y));\nb) By node references\nConst c1 = const(s, x);\nConst c2 = const(s, y);\nop1(s, op2(s, c1), c2);\nc) By node lookups\nop2(s, \"op2\", const(s, x));\nop1(s, s.node(\"op2\"), const(s, y));\nTechnics b) and c) allows us to access output value other than the default (0) one for multi-output operations. For example:\nop1(s, s.node(\"op2\").output(1), const(s, y));\nAny comments are more than welcomed", "body": "Anyone curious to see how a static API for building a graph may look like, I've pushed a little POC to my [repo](https://github.com/karllessard/tensorflow/tree/java-static-api/tensorflow/java) (this [commit](https://github.com/karllessard/tensorflow/commit/d2a5518a5830ec9d0b81912b95e3e33b64bd5ec5))  that minimally fulfill the requirements of the [LabelImage](https://github.com/karllessard/tensorflow/blob/java-static-api/tensorflow/java/src/main/java/org/tensorflow/examples/LabelImage2.java) example.\r\n\r\nThis POC focuses on the following point:\r\n\r\n1. Group operations into related topics, like the C++ client does, by generating a static API per /tensorflow/core/ops/* library (e.g. [ImageOps](https://github.com/karllessard/tensorflow/blob/java-static-api/tensorflow/java/src/main/java/org/tensorflow/ops/image/ImageOps.java), [ArrayOps](https://github.com/karllessard/tensorflow/blob/java-static-api/tensorflow/java/src/main/java/org/tensorflow/ops/array/ArrayOps.java), ...)\r\n\r\n2. Allow optional parametrization using operation-specific methods encapsulated in their own classes (e.g. the [DecodeJpeg](https://github.com/karllessard/tensorflow/blob/java-static-api/tensorflow/java/src/main/java/org/tensorflow/ops/image/DecodeJpeg.java) interface)\r\n\r\n3. Keep the simplicity and elegance of the solution from the previous version of LabelImage while allowing more flexibility to support all cases (e.g. multi-output operations, etc). The following lists supported technics to connect nodes together.\r\n  \r\na) Functionally\r\n```java\r\nop1(s, op2(s, const(s, x)), const(s, y));\r\n``` \r\nb) By node references\r\n```java\r\nConst c1 = const(s, x);\r\nConst c2 = const(s, y);\r\nop1(s, op2(s, c1), c2);\r\n```\r\nc) By node lookups\r\n```java\r\nop2(s, \"op2\", const(s, x));\r\nop1(s, s.node(\"op2\"), const(s, y));\r\n```\r\n\r\nTechnics b) and c) allows us to access output value other than the default (0) one for multi-output operations. For example:\r\n```java\r\nop1(s, s.node(\"op2\").output(1), const(s, y));\r\n```\r\n\r\nAny comments are more than welcomed"}