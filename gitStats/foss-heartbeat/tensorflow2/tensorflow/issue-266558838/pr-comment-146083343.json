{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/146083343", "pull_request_review_id": 70970705, "id": 146083343, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE0NjA4MzM0Mw==", "diff_hunk": "@@ -75,34 +67,86 @@ class BincountOp : public OpKernel {\n           for (int64 i = start_ind; i < limit_ind; i++) {\n             int32 value = arr(i);\n             if (value < size) {\n-              if (has_weights) {\n-                partial_bins(worker_id, value) += weights(i);\n-              } else {\n-                // Complex numbers don't support \"++\".\n-                partial_bins(worker_id, value) += T(1);\n-              }\n+              // Complex numbers don't support \"++\".\n+              partial_bins(worker_id, value) += T(1);\n             }\n           }\n         });\n-    TensorShape output_shape({size});\n-    Tensor* output_t;\n-    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, output_shape, &output_t));\n+\n     // Sum the partial bins along the 0th axis.\n     Eigen::array<int, 1> reduce_dims({0});\n-    output_t->flat<T>().device(ctx->eigen_cpu_device()) =\n-        partial_bins.sum(reduce_dims);\n+    output.device(context->eigen_cpu_device()) = partial_bins.sum(reduce_dims);\n+    return Status::OK();\n   }\n };\n \n-#define REGISTER(TYPE)                                               \\\n+}  // namespace functor\n+\n+template <typename Device, typename T>\n+class BincountOp : public OpKernel {\n+ public:\n+  explicit BincountOp(OpKernelConstruction* ctx) : OpKernel(ctx) {}\n+\n+  void Compute(OpKernelContext* ctx) override {\n+    const Tensor& arr_t = ctx->input(0);\n+    const Tensor& size_tensor = ctx->input(1);\n+    const Tensor& weights_t = ctx->input(2);\n+\n+    int32 size = size_tensor.scalar<int32>()();\n+    OP_REQUIRES(ctx, size >= 0, errors::InvalidArgument(\n+                                    \"size (\", size, \") must be non-negative\"));\n+\n+    const bool has_weights = weights_t.NumElements() > 0;\n+    OP_REQUIRES(ctx, !(has_weights && arr_t.shape() != weights_t.shape()),\n+                errors::InvalidArgument(\n+                    \"If weights are passed, they must have the same shape (\" +\n+                    weights_t.shape().DebugString() + \") as arr (\" +\n+                    arr_t.shape().DebugString() + \")\"));\n+    const auto arr = arr_t.flat<int32>();\n+    const auto weights = weights_t.flat<T>();\n+\n+    if (weights.size() == 0) {\n+      Tensor* output_t;\n+      OP_REQUIRES_OK(ctx,\n+                     ctx->allocate_output(0, TensorShape({size}), &output_t));\n+      auto output = output_t->flat<T>();\n+      OP_REQUIRES_OK(\n+          ctx, functor::BincountFunctor<Device, T>::Compute(ctx, arr, output));\n+    } else {", "path": "tensorflow/core/kernels/bincount_op.cc", "position": null, "original_position": 140, "commit_id": "95ec3de3c5b4baeed1d6db825f48289f7a4d1bbf", "original_commit_id": "a1efcaaf6d1a783170eae7387e19957667e24145", "user": {"login": "ekelsen", "id": 2533174, "node_id": "MDQ6VXNlcjI1MzMxNzQ=", "avatar_url": "https://avatars0.githubusercontent.com/u/2533174?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ekelsen", "html_url": "https://github.com/ekelsen", "followers_url": "https://api.github.com/users/ekelsen/followers", "following_url": "https://api.github.com/users/ekelsen/following{/other_user}", "gists_url": "https://api.github.com/users/ekelsen/gists{/gist_id}", "starred_url": "https://api.github.com/users/ekelsen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ekelsen/subscriptions", "organizations_url": "https://api.github.com/users/ekelsen/orgs", "repos_url": "https://api.github.com/users/ekelsen/repos", "events_url": "https://api.github.com/users/ekelsen/events{/privacy}", "received_events_url": "https://api.github.com/users/ekelsen/received_events", "type": "User", "site_admin": false}, "body": "Please handle the case of weights being None in the graph (ie edit the python code for the bincount op) by calling unsorted_segment_sum there after reduce_max.  The C++ code for bincount only needs to handle the case where the weights are implicitly one.\r\n\r\nIt's better to not have high level ops alias to the same underlying calculation; it only makes analyzing the graph harder.", "created_at": "2017-10-20T23:00:34Z", "updated_at": "2017-11-05T16:19:59Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/13813#discussion_r146083343", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/13813", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/146083343"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/13813#discussion_r146083343"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/13813"}}, "body_html": "<p>Please handle the case of weights being None in the graph (ie edit the python code for the bincount op) by calling unsorted_segment_sum there after reduce_max.  The C++ code for bincount only needs to handle the case where the weights are implicitly one.</p>\n<p>It's better to not have high level ops alias to the same underlying calculation; it only makes analyzing the graph harder.</p>", "body_text": "Please handle the case of weights being None in the graph (ie edit the python code for the bincount op) by calling unsorted_segment_sum there after reduce_max.  The C++ code for bincount only needs to handle the case where the weights are implicitly one.\nIt's better to not have high level ops alias to the same underlying calculation; it only makes analyzing the graph harder."}