{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/146121819", "pull_request_review_id": 71023516, "id": 146121819, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE0NjEyMTgxOQ==", "diff_hunk": "@@ -75,34 +66,71 @@ class BincountOp : public OpKernel {\n           for (int64 i = start_ind; i < limit_ind; i++) {\n             int32 value = arr(i);\n             if (value < size) {\n-              if (has_weights) {\n-                partial_bins(worker_id, value) += weights(i);\n-              } else {\n-                // Complex numbers don't support \"++\".\n-                partial_bins(worker_id, value) += T(1);\n-              }\n+              // Complex numbers don't support \"++\".\n+              partial_bins(worker_id, value) += T(1);\n             }\n           }\n         });\n-    TensorShape output_shape({size});\n-    Tensor* output_t;\n-    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, output_shape, &output_t));\n+\n     // Sum the partial bins along the 0th axis.\n     Eigen::array<int, 1> reduce_dims({0});\n-    output_t->flat<T>().device(ctx->eigen_cpu_device()) =\n-        partial_bins.sum(reduce_dims);\n+    output.device(context->eigen_cpu_device()) = partial_bins.sum(reduce_dims);\n+    return Status::OK();\n   }\n };\n \n-#define REGISTER(TYPE)                                               \\\n+}  // namespace functor\n+\n+template <typename Device, typename T>\n+class BincountOp : public OpKernel {\n+ public:\n+  explicit BincountOp(OpKernelConstruction* ctx) : OpKernel(ctx) {}\n+\n+  void Compute(OpKernelContext* ctx) override {\n+    const Tensor& arr_t = ctx->input(0);\n+    const Tensor& size_tensor = ctx->input(1);\n+    const Tensor& weights_t = ctx->input(2);\n+\n+    int32 size = size_tensor.scalar<int32>()();\n+    OP_REQUIRES(ctx, size >= 0, errors::InvalidArgument(\n+                                    \"size (\", size, \") must be non-negative\"));\n+\n+    OP_REQUIRES(\n+        ctx, (weights_t.NumElements() == 0),\n+        errors::InvalidArgument(\"Weights should not be passed as it should be \"", "path": "tensorflow/core/kernels/bincount_op.cc", "position": null, "original_position": 122, "commit_id": "95ec3de3c5b4baeed1d6db825f48289f7a4d1bbf", "original_commit_id": "8c0c7b55ce50ee2008396d652dd8e2f24cfbb1e1", "user": {"login": "ekelsen", "id": 2533174, "node_id": "MDQ6VXNlcjI1MzMxNzQ=", "avatar_url": "https://avatars0.githubusercontent.com/u/2533174?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ekelsen", "html_url": "https://github.com/ekelsen", "followers_url": "https://api.github.com/users/ekelsen/followers", "following_url": "https://api.github.com/users/ekelsen/following{/other_user}", "gists_url": "https://api.github.com/users/ekelsen/gists{/gist_id}", "starred_url": "https://api.github.com/users/ekelsen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ekelsen/subscriptions", "organizations_url": "https://api.github.com/users/ekelsen/orgs", "repos_url": "https://api.github.com/users/ekelsen/repos", "events_url": "https://api.github.com/users/ekelsen/events{/privacy}", "received_events_url": "https://api.github.com/users/ekelsen/received_events", "type": "User", "site_admin": false}, "body": "I'm sorry, I should've said this earlier, the CPU implementation needs to retain the ability to handle weights != None.  This is because of backwards compatibility - graphs that were created must still run correctly in a new version of TF.  (This is only true for the CPU version, as the GPU version didn't exist).\r\n\r\nSo basically, the CPU code needs to continue to be able to handle weights, but the graph code should stay as it is so that all _future_ graphs use unsorted_segment_sum instead.  Once six months have passed, we can remove the CPU code, although more likely, it will simply stay around forever.", "created_at": "2017-10-22T04:44:52Z", "updated_at": "2017-11-05T16:19:59Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/13813#discussion_r146121819", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/13813", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/146121819"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/13813#discussion_r146121819"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/13813"}}, "body_html": "<p>I'm sorry, I should've said this earlier, the CPU implementation needs to retain the ability to handle weights != None.  This is because of backwards compatibility - graphs that were created must still run correctly in a new version of TF.  (This is only true for the CPU version, as the GPU version didn't exist).</p>\n<p>So basically, the CPU code needs to continue to be able to handle weights, but the graph code should stay as it is so that all <em>future</em> graphs use unsorted_segment_sum instead.  Once six months have passed, we can remove the CPU code, although more likely, it will simply stay around forever.</p>", "body_text": "I'm sorry, I should've said this earlier, the CPU implementation needs to retain the ability to handle weights != None.  This is because of backwards compatibility - graphs that were created must still run correctly in a new version of TF.  (This is only true for the CPU version, as the GPU version didn't exist).\nSo basically, the CPU code needs to continue to be able to handle weights, but the graph code should stay as it is so that all future graphs use unsorted_segment_sum instead.  Once six months have passed, we can remove the CPU code, although more likely, it will simply stay around forever."}