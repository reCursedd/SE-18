{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/280973114", "html_url": "https://github.com/tensorflow/tensorflow/issues/6189#issuecomment-280973114", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/6189", "id": 280973114, "node_id": "MDEyOklzc3VlQ29tbWVudDI4MDk3MzExNA==", "user": {"login": "eamartin", "id": 287200, "node_id": "MDQ6VXNlcjI4NzIwMA==", "avatar_url": "https://avatars2.githubusercontent.com/u/287200?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eamartin", "html_url": "https://github.com/eamartin", "followers_url": "https://api.github.com/users/eamartin/followers", "following_url": "https://api.github.com/users/eamartin/following{/other_user}", "gists_url": "https://api.github.com/users/eamartin/gists{/gist_id}", "starred_url": "https://api.github.com/users/eamartin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eamartin/subscriptions", "organizations_url": "https://api.github.com/users/eamartin/orgs", "repos_url": "https://api.github.com/users/eamartin/repos", "events_url": "https://api.github.com/users/eamartin/events{/privacy}", "received_events_url": "https://api.github.com/users/eamartin/received_events", "type": "User", "site_admin": false}, "created_at": "2017-02-20T02:27:11Z", "updated_at": "2017-02-20T02:27:11Z", "author_association": "NONE", "body_html": "<p>Here's a use-case for re-opening variable scopes without renaming.<br>\nConsider a OOP design where a class declares a couple of TensorFlow variables and then provides multiple methods on those variables.</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">class</span> <span class=\"pl-en\">Foo</span>(<span class=\"pl-c1\">object</span>):\n    <span class=\"pl-k\">def</span> <span class=\"pl-c1\">__init__</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>):\n        <span class=\"pl-c1\">self</span>.x <span class=\"pl-k\">=</span> tf.get_variable(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>x<span class=\"pl-pds\">'</span></span>, [], <span class=\"pl-v\">initializer</span><span class=\"pl-k\">=</span>tf.constant(<span class=\"pl-c1\">0.0</span>))\n\n    <span class=\"pl-k\">def</span> <span class=\"pl-en\">meth</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>, <span class=\"pl-smi\">foo</span>):\n        z <span class=\"pl-k\">=</span> tf.multiply(foo, <span class=\"pl-c1\">3.14</span>, <span class=\"pl-v\">name</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>z<span class=\"pl-pds\">'</span></span>)\n        <span class=\"pl-c1\">self</span>.x.assign(z)</pre></div>\n<p>The easiest to visualize (in TensorBoard) pattern would to be have one variable scope per instance of class and call of method.</p>\n<div class=\"highlight highlight-source-python\"><pre>f0 <span class=\"pl-k\">=</span> Foo()      <span class=\"pl-c\"><span class=\"pl-c\">#</span> Foo/__init__/x</span>\nf1 <span class=\"pl-k\">=</span> Foo()      <span class=\"pl-c\"><span class=\"pl-c\">#</span> Foo_1/__init__/x</span>\nf0.meth(<span class=\"pl-c1\">1.0</span>)    <span class=\"pl-c\"><span class=\"pl-c\">#</span> Foo/meth/*</span>\nf0.meth(<span class=\"pl-c1\">2.0</span>)    <span class=\"pl-c\"><span class=\"pl-c\">#</span> Foo/meth_1/*</span>\nf1.meth(<span class=\"pl-c1\">3.0</span>)    <span class=\"pl-c\"><span class=\"pl-c\">#</span> Foo_1/meth/*</span></pre></div>\n<p>The way that I thought of to implement this is to create a VariableScope on each instance, and then reopen it for each method call before creating another variable scope for the method. The reopening of the variable scope for each method call without changing the naming is currently not possible, so this scheme doesn't work.</p>", "body_text": "Here's a use-case for re-opening variable scopes without renaming.\nConsider a OOP design where a class declares a couple of TensorFlow variables and then provides multiple methods on those variables.\nclass Foo(object):\n    def __init__(self):\n        self.x = tf.get_variable('x', [], initializer=tf.constant(0.0))\n\n    def meth(self, foo):\n        z = tf.multiply(foo, 3.14, name='z')\n        self.x.assign(z)\nThe easiest to visualize (in TensorBoard) pattern would to be have one variable scope per instance of class and call of method.\nf0 = Foo()      # Foo/__init__/x\nf1 = Foo()      # Foo_1/__init__/x\nf0.meth(1.0)    # Foo/meth/*\nf0.meth(2.0)    # Foo/meth_1/*\nf1.meth(3.0)    # Foo_1/meth/*\nThe way that I thought of to implement this is to create a VariableScope on each instance, and then reopen it for each method call before creating another variable scope for the method. The reopening of the variable scope for each method call without changing the naming is currently not possible, so this scheme doesn't work.", "body": "Here's a use-case for re-opening variable scopes without renaming.\r\nConsider a OOP design where a class declares a couple of TensorFlow variables and then provides multiple methods on those variables.\r\n\r\n```python\r\nclass Foo(object):\r\n    def __init__(self):\r\n        self.x = tf.get_variable('x', [], initializer=tf.constant(0.0))\r\n\r\n    def meth(self, foo):\r\n        z = tf.multiply(foo, 3.14, name='z')\r\n        self.x.assign(z)\r\n```\r\n\r\nThe easiest to visualize (in TensorBoard) pattern would to be have one variable scope per instance of class and call of method.\r\n```python\r\nf0 = Foo()      # Foo/__init__/x\r\nf1 = Foo()      # Foo_1/__init__/x\r\nf0.meth(1.0)    # Foo/meth/*\r\nf0.meth(2.0)    # Foo/meth_1/*\r\nf1.meth(3.0)    # Foo_1/meth/*\r\n```\r\n\r\nThe way that I thought of to implement this is to create a VariableScope on each instance, and then reopen it for each method call before creating another variable scope for the method. The reopening of the variable scope for each method call without changing the naming is currently not possible, so this scheme doesn't work."}