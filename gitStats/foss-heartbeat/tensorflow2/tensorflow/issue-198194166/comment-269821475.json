{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/269821475", "html_url": "https://github.com/tensorflow/tensorflow/pull/6577#issuecomment-269821475", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/6577", "id": 269821475, "node_id": "MDEyOklzc3VlQ29tbWVudDI2OTgyMTQ3NQ==", "user": {"login": "EronWright", "id": 1775518, "node_id": "MDQ6VXNlcjE3NzU1MTg=", "avatar_url": "https://avatars0.githubusercontent.com/u/1775518?v=4", "gravatar_id": "", "url": "https://api.github.com/users/EronWright", "html_url": "https://github.com/EronWright", "followers_url": "https://api.github.com/users/EronWright/followers", "following_url": "https://api.github.com/users/EronWright/following{/other_user}", "gists_url": "https://api.github.com/users/EronWright/gists{/gist_id}", "starred_url": "https://api.github.com/users/EronWright/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/EronWright/subscriptions", "organizations_url": "https://api.github.com/users/EronWright/orgs", "repos_url": "https://api.github.com/users/EronWright/repos", "events_url": "https://api.github.com/users/EronWright/events{/privacy}", "received_events_url": "https://api.github.com/users/EronWright/received_events", "type": "User", "site_admin": false}, "created_at": "2016-12-30T21:02:08Z", "updated_at": "2016-12-30T21:35:36Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=16018\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/asimshankar\">@asimshankar</a> please have a look, thanks.  I think that the NIO buffer classes are the most efficient way to provide a general bulk-access pattern while minimizing new JNI code.  I listed various scenarios in <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"198191206\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/tensorflow/tensorflow/issues/6576\" data-hovercard-type=\"issue\" data-hovercard-url=\"/tensorflow/tensorflow/issues/6576/hovercard\" href=\"https://github.com/tensorflow/tensorflow/issues/6576\">#6576</a> but my primary goal was efficient serialization.</p>\n<p>An important design goal was to avoid sharing the native tensor's buffer address while leveraging the optimized <code>put</code> methods on the typed <code>Buffer</code> classes.</p>", "body_text": "@asimshankar please have a look, thanks.  I think that the NIO buffer classes are the most efficient way to provide a general bulk-access pattern while minimizing new JNI code.  I listed various scenarios in #6576 but my primary goal was efficient serialization.\nAn important design goal was to avoid sharing the native tensor's buffer address while leveraging the optimized put methods on the typed Buffer classes.", "body": "@asimshankar please have a look, thanks.  I think that the NIO buffer classes are the most efficient way to provide a general bulk-access pattern while minimizing new JNI code.  I listed various scenarios in #6576 but my primary goal was efficient serialization.\r\n\r\nAn important design goal was to avoid sharing the native tensor's buffer address while leveraging the optimized `put` methods on the typed `Buffer` classes.\r\n"}