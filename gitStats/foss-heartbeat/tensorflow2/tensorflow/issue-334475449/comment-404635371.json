{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/404635371", "html_url": "https://github.com/tensorflow/tensorflow/pull/20183#issuecomment-404635371", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/20183", "id": 404635371, "node_id": "MDEyOklzc3VlQ29tbWVudDQwNDYzNTM3MQ==", "user": {"login": "jlebar", "id": 150663, "node_id": "MDQ6VXNlcjE1MDY2Mw==", "avatar_url": "https://avatars1.githubusercontent.com/u/150663?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jlebar", "html_url": "https://github.com/jlebar", "followers_url": "https://api.github.com/users/jlebar/followers", "following_url": "https://api.github.com/users/jlebar/following{/other_user}", "gists_url": "https://api.github.com/users/jlebar/gists{/gist_id}", "starred_url": "https://api.github.com/users/jlebar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jlebar/subscriptions", "organizations_url": "https://api.github.com/users/jlebar/orgs", "repos_url": "https://api.github.com/users/jlebar/repos", "events_url": "https://api.github.com/users/jlebar/events{/privacy}", "received_events_url": "https://api.github.com/users/jlebar/received_events", "type": "User", "site_admin": false}, "created_at": "2018-07-12T20:10:22Z", "updated_at": "2018-07-12T20:10:22Z", "author_association": "MEMBER", "body_html": "<p>If I understand this correctly, the idea is that in your fork of XLA, you modify :plugin and :plugin_backend to add dependencies on your new plugins.  Then these get pulled in as dependencies of the relevant XLA libraries.</p>\n<p>Is that right?</p>\n<p>But if you're already modifying XLA's build files, to add new deps to :plugin and :plugin_backend, what's the problem created by instead modifying the rules that depend on :plugin and :plugin_backend to depend on your new library?  That is, what does this layer of indirection buy us?</p>\n<p>We already do the direct-dependencies approach for cpu/gpu, and I'm afraid that the indirect-dependency approach here will be fragile, because by its nature, it's completely untested.</p>\n<p>I'm also not sure what :plugin is used for; it seems to be a dead library.</p>", "body_text": "If I understand this correctly, the idea is that in your fork of XLA, you modify :plugin and :plugin_backend to add dependencies on your new plugins.  Then these get pulled in as dependencies of the relevant XLA libraries.\nIs that right?\nBut if you're already modifying XLA's build files, to add new deps to :plugin and :plugin_backend, what's the problem created by instead modifying the rules that depend on :plugin and :plugin_backend to depend on your new library?  That is, what does this layer of indirection buy us?\nWe already do the direct-dependencies approach for cpu/gpu, and I'm afraid that the indirect-dependency approach here will be fragile, because by its nature, it's completely untested.\nI'm also not sure what :plugin is used for; it seems to be a dead library.", "body": "If I understand this correctly, the idea is that in your fork of XLA, you modify :plugin and :plugin_backend to add dependencies on your new plugins.  Then these get pulled in as dependencies of the relevant XLA libraries.\r\n\r\nIs that right?\r\n\r\nBut if you're already modifying XLA's build files, to add new deps to :plugin and :plugin_backend, what's the problem created by instead modifying the rules that depend on :plugin and :plugin_backend to depend on your new library?  That is, what does this layer of indirection buy us?\r\n\r\nWe already do the direct-dependencies approach for cpu/gpu, and I'm afraid that the indirect-dependency approach here will be fragile, because by its nature, it's completely untested.\r\n\r\nI'm also not sure what :plugin is used for; it seems to be a dead library."}