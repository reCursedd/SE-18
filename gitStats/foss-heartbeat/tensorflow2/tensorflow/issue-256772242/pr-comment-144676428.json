{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/144676428", "pull_request_review_id": 69368959, "id": 144676428, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE0NDY3NjQyOA==", "diff_hunk": "@@ -416,6 +417,119 @@ bool ConsumeNonWhitespace(StringPiece* s, StringPiece* val) {\n   }\n }\n \n+Status SplitUTF8(StringPiece text, const string& delim,\n+                 std::vector<string>* result) {\n+  // Bytes    Byte 1    Byte 2    Byte 3    Byte 4\n+  //   1     0xxxxxxx\n+  //   2     110xxxxx  10xxxxxx\n+  //   3     1110xxxx  10xxxxxx  10xxxxxx\n+  //   4     11110xxx  10xxxxxx  10xxxxxx  10xxxxxx\n+  result->clear();\n+  result->reserve(text.size());\n+  size_t off = 0, len = 0;\n+  bool advance = true;\n+  for (size_t i = 0; i < text.size(); ++i) {\n+    if (off == i) {\n+      if ((text[i] & 0x80) == 0x00) {\n+        string entry = text.substr(off, 1).ToString();\n+        if (delim == \"\") {\n+          // If delim is \"\" then always advance\n+          result->emplace_back(entry);\n+        } else if (delim != entry) {", "path": "tensorflow/core/lib/strings/str_util.cc", "position": null, "original_position": 30, "commit_id": "95f2a5cf9d08d4ed07eb88057ead689ce61faa54", "original_commit_id": "5d767978be03a123d2b95fce16e060a5836074b9", "user": {"login": "asimshankar", "id": 16018, "node_id": "MDQ6VXNlcjE2MDE4", "avatar_url": "https://avatars2.githubusercontent.com/u/16018?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asimshankar", "html_url": "https://github.com/asimshankar", "followers_url": "https://api.github.com/users/asimshankar/followers", "following_url": "https://api.github.com/users/asimshankar/following{/other_user}", "gists_url": "https://api.github.com/users/asimshankar/gists{/gist_id}", "starred_url": "https://api.github.com/users/asimshankar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asimshankar/subscriptions", "organizations_url": "https://api.github.com/users/asimshankar/orgs", "repos_url": "https://api.github.com/users/asimshankar/repos", "events_url": "https://api.github.com/users/asimshankar/events{/privacy}", "received_events_url": "https://api.github.com/users/asimshankar/received_events", "type": "User", "site_admin": false}, "body": "Could this be made a little more compact by separating out the length determination from the emplacement? Something like:\r\n\r\n```c++\r\nsize_t char_start = 0;\r\nsize_t len = 0;\r\nfor (size_t i = 0; i < text.size(); ++i) {\r\n  if (char_start == i) {\r\n    // Determine byte length of next character.\r\n    const char c = text[i];\r\n    if (c & 0x80 == 0x00) {\r\n     len = 1;\r\n    } else if (c & 0xE0 == 0xC0) {\r\n      len = 2;\r\n    } else if (c & 0xF0 == 0xE0) {\r\n      len = 3;\r\n    } else if (c & 0XF8 == 0xF0) {\r\n      len = 4;\r\n   } else {\r\n    result->clear();\r\n    return errors::InvalidArgument(\"Invalid UTF-8 encoding at byte \", i);\r\n   }\r\n   // Validate all intermediate bytes are valid UTF-8\r\n   if (TF_PREDICT_FALSE((len > 1 && (text[i] & 0xC0) != 0x80)) {\r\n      /*  return error */\r\n   }\r\n   // Reached the end of a character\r\n   if (char_start + len == i + 1) {\r\n     const StringPiece entry = text.substr(char_start, len).ToString();\r\n     char_start += len;\r\n     if (delim == \"\") {\r\n       result->emplace_back(entry);\r\n     } else if (delim == entry) {\r\n        advance = true;\r\n     } else if (advance) {\r\n        advance = false;\r\n        result->emplace_back(entry);\r\n    } else {\r\n        result->back() = result->back() + entry;\r\n   }\r\n}\r\n```", "created_at": "2017-10-13T23:38:17Z", "updated_at": "2018-05-27T18:27:55Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/12971#discussion_r144676428", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/12971", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/144676428"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/12971#discussion_r144676428"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/12971"}}, "body_html": "<p>Could this be made a little more compact by separating out the length determination from the emplacement? Something like:</p>\n<div class=\"highlight highlight-source-c++\"><pre><span class=\"pl-c1\">size_t</span> char_start = <span class=\"pl-c1\">0</span>;\n<span class=\"pl-c1\">size_t</span> len = <span class=\"pl-c1\">0</span>;\n<span class=\"pl-k\">for</span> (<span class=\"pl-c1\">size_t</span> i = <span class=\"pl-c1\">0</span>; i &lt; text.size(); ++i) {\n  <span class=\"pl-k\">if</span> (char_start == i) {\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span> Determine byte length of next character.</span>\n    <span class=\"pl-k\">const</span> <span class=\"pl-k\">char</span> c = text[i];\n    <span class=\"pl-k\">if</span> (c &amp; <span class=\"pl-c1\">0x80</span> == <span class=\"pl-c1\">0x00</span>) {\n     len = <span class=\"pl-c1\">1</span>;\n    } <span class=\"pl-k\">else</span> <span class=\"pl-k\">if</span> (c &amp; <span class=\"pl-c1\">0xE0</span> == <span class=\"pl-c1\">0xC0</span>) {\n      len = <span class=\"pl-c1\">2</span>;\n    } <span class=\"pl-k\">else</span> <span class=\"pl-k\">if</span> (c &amp; <span class=\"pl-c1\">0xF0</span> == <span class=\"pl-c1\">0xE0</span>) {\n      len = <span class=\"pl-c1\">3</span>;\n    } <span class=\"pl-k\">else</span> <span class=\"pl-k\">if</span> (c &amp; <span class=\"pl-c1\">0XF8</span> == <span class=\"pl-c1\">0xF0</span>) {\n      len = <span class=\"pl-c1\">4</span>;\n   } <span class=\"pl-k\">else</span> {\n    result-&gt;<span class=\"pl-c1\">clear</span>();\n    <span class=\"pl-k\">return</span> <span class=\"pl-c1\">errors::InvalidArgument</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Invalid UTF-8 encoding at byte <span class=\"pl-pds\">\"</span></span>, i);\n   }\n   <span class=\"pl-c\"><span class=\"pl-c\">//</span> Validate all intermediate bytes are valid UTF-8</span>\n   <span class=\"pl-k\">if</span> (<span class=\"pl-c1\">TF_PREDICT_FALSE</span>((len &gt; <span class=\"pl-c1\">1</span> &amp;&amp; (text[i] &amp; <span class=\"pl-c1\">0xC0</span>) != <span class=\"pl-c1\">0x80</span>)) {\n      <span class=\"pl-c\"><span class=\"pl-c\">/*</span>  return error <span class=\"pl-c\">*/</span></span>\n   }\n   <span class=\"pl-c\"><span class=\"pl-c\">//</span> Reached the end of a character</span>\n   <span class=\"pl-k\">if</span> (char_start + len == i + <span class=\"pl-c1\">1</span>) {\n     <span class=\"pl-k\">const</span> StringPiece entry = text.<span class=\"pl-c1\">substr</span>(char_start, len).<span class=\"pl-c1\">ToString</span>();\n     char_start += len;\n     <span class=\"pl-k\">if</span> (delim == <span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"pl-pds\">\"</span></span>) {\n       result-&gt;<span class=\"pl-c1\">emplace_back</span>(entry);\n     } <span class=\"pl-k\">else</span> <span class=\"pl-k\">if</span> (delim == entry) {\n        advance = <span class=\"pl-c1\">true</span>;\n     } <span class=\"pl-k\">else</span> <span class=\"pl-k\">if</span> (advance) {\n        advance = <span class=\"pl-c1\">false</span>;\n        result-&gt;<span class=\"pl-c1\">emplace_back</span>(entry);\n    } <span class=\"pl-k\">else</span> {\n        result-&gt;<span class=\"pl-c1\">back</span>() = result-&gt;<span class=\"pl-c1\">back</span>() + entry;\n   }\n}</pre></div>", "body_text": "Could this be made a little more compact by separating out the length determination from the emplacement? Something like:\nsize_t char_start = 0;\nsize_t len = 0;\nfor (size_t i = 0; i < text.size(); ++i) {\n  if (char_start == i) {\n    // Determine byte length of next character.\n    const char c = text[i];\n    if (c & 0x80 == 0x00) {\n     len = 1;\n    } else if (c & 0xE0 == 0xC0) {\n      len = 2;\n    } else if (c & 0xF0 == 0xE0) {\n      len = 3;\n    } else if (c & 0XF8 == 0xF0) {\n      len = 4;\n   } else {\n    result->clear();\n    return errors::InvalidArgument(\"Invalid UTF-8 encoding at byte \", i);\n   }\n   // Validate all intermediate bytes are valid UTF-8\n   if (TF_PREDICT_FALSE((len > 1 && (text[i] & 0xC0) != 0x80)) {\n      /*  return error */\n   }\n   // Reached the end of a character\n   if (char_start + len == i + 1) {\n     const StringPiece entry = text.substr(char_start, len).ToString();\n     char_start += len;\n     if (delim == \"\") {\n       result->emplace_back(entry);\n     } else if (delim == entry) {\n        advance = true;\n     } else if (advance) {\n        advance = false;\n        result->emplace_back(entry);\n    } else {\n        result->back() = result->back() + entry;\n   }\n}"}