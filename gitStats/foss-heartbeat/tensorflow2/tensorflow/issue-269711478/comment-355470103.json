{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/355470103", "html_url": "https://github.com/tensorflow/tensorflow/issues/14104#issuecomment-355470103", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/14104", "id": 355470103, "node_id": "MDEyOklzc3VlQ29tbWVudDM1NTQ3MDEwMw==", "user": {"login": "ebrevdo", "id": 1794715, "node_id": "MDQ6VXNlcjE3OTQ3MTU=", "avatar_url": "https://avatars0.githubusercontent.com/u/1794715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebrevdo", "html_url": "https://github.com/ebrevdo", "followers_url": "https://api.github.com/users/ebrevdo/followers", "following_url": "https://api.github.com/users/ebrevdo/following{/other_user}", "gists_url": "https://api.github.com/users/ebrevdo/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebrevdo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebrevdo/subscriptions", "organizations_url": "https://api.github.com/users/ebrevdo/orgs", "repos_url": "https://api.github.com/users/ebrevdo/repos", "events_url": "https://api.github.com/users/ebrevdo/events{/privacy}", "received_events_url": "https://api.github.com/users/ebrevdo/received_events", "type": "User", "site_admin": false}, "created_at": "2018-01-05T04:26:49Z", "updated_at": "2018-01-05T04:26:49Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Looking more carefully; I see that you're expecting the mutable variable C in the body of <code>construct_C</code>.  But Variables are not like regular tensors; you cannot pass them through a <code>tf.while_loop</code> in this way.  Instead what you want to do is:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">def</span> <span class=\"pl-en\">construct_C</span>(<span class=\"pl-smi\">k</span>):\n  <span class=\"pl-k\">with</span> tf.control_dependencies([tf.scatter_add(C, k, upd_c)]):\n    <span class=\"pl-k\">return</span> k <span class=\"pl-k\">+</span> <span class=\"pl-c1\">1</span>\n\nthen later:\n\n<span class=\"pl-k\">with</span> tf.control_dependencies([tf.while_loop(stop_cond, construct_C, [tf.constant(<span class=\"pl-c1\">1</span>)]):\n  constructed_C_value = tf.identity(C)  <span class=\"pl-c\"><span class=\"pl-c\">#</span> or C.read_value(), i think</span></pre></div>\n<p>the reason is that <code>C</code>, as a Variable, exists outside of regular flow control.  you can mutate it as you see fit.  We do provide some sugar, like <code>C1 = tf.scatter_add(C, ...)</code>, but all this does is creates a control dependency to update the variable pointed to by both <code>C</code> and <code>C1</code>, to be executed when you access <code>C1</code>.  This kind of sugar doesn't propagate through <code>tf.while_loop</code>; but the example I gave above should work just fine.</p>", "body_text": "Looking more carefully; I see that you're expecting the mutable variable C in the body of construct_C.  But Variables are not like regular tensors; you cannot pass them through a tf.while_loop in this way.  Instead what you want to do is:\ndef construct_C(k):\n  with tf.control_dependencies([tf.scatter_add(C, k, upd_c)]):\n    return k + 1\n\nthen later:\n\nwith tf.control_dependencies([tf.while_loop(stop_cond, construct_C, [tf.constant(1)]):\n  constructed_C_value = tf.identity(C)  # or C.read_value(), i think\nthe reason is that C, as a Variable, exists outside of regular flow control.  you can mutate it as you see fit.  We do provide some sugar, like C1 = tf.scatter_add(C, ...), but all this does is creates a control dependency to update the variable pointed to by both C and C1, to be executed when you access C1.  This kind of sugar doesn't propagate through tf.while_loop; but the example I gave above should work just fine.", "body": "Looking more carefully; I see that you're expecting the mutable variable C in the body of `construct_C`.  But Variables are not like regular tensors; you cannot pass them through a `tf.while_loop` in this way.  Instead what you want to do is:\r\n\r\n```python\r\ndef construct_C(k):\r\n  with tf.control_dependencies([tf.scatter_add(C, k, upd_c)]):\r\n    return k + 1\r\n\r\nthen later:\r\n\r\nwith tf.control_dependencies([tf.while_loop(stop_cond, construct_C, [tf.constant(1)]):\r\n  constructed_C_value = tf.identity(C)  # or C.read_value(), i think\r\n```\r\n\r\nthe reason is that `C`, as a Variable, exists outside of regular flow control.  you can mutate it as you see fit.  We do provide some sugar, like `C1 = tf.scatter_add(C, ...)`, but all this does is creates a control dependency to update the variable pointed to by both `C` and `C1`, to be executed when you access `C1`.  This kind of sugar doesn't propagate through `tf.while_loop`; but the example I gave above should work just fine."}