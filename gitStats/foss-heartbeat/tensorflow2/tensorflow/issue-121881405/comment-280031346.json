{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/280031346", "html_url": "https://github.com/tensorflow/tensorflow/issues/492#issuecomment-280031346", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/492", "id": 280031346, "node_id": "MDEyOklzc3VlQ29tbWVudDI4MDAzMTM0Ng==", "user": {"login": "yaroslavvb", "id": 23068, "node_id": "MDQ6VXNlcjIzMDY4", "avatar_url": "https://avatars3.githubusercontent.com/u/23068?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yaroslavvb", "html_url": "https://github.com/yaroslavvb", "followers_url": "https://api.github.com/users/yaroslavvb/followers", "following_url": "https://api.github.com/users/yaroslavvb/following{/other_user}", "gists_url": "https://api.github.com/users/yaroslavvb/gists{/gist_id}", "starred_url": "https://api.github.com/users/yaroslavvb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yaroslavvb/subscriptions", "organizations_url": "https://api.github.com/users/yaroslavvb/orgs", "repos_url": "https://api.github.com/users/yaroslavvb/repos", "events_url": "https://api.github.com/users/yaroslavvb/events{/privacy}", "received_events_url": "https://api.github.com/users/yaroslavvb/received_events", "type": "User", "site_admin": false}, "created_at": "2017-02-15T14:52:40Z", "updated_at": "2017-02-15T17:35:08Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=10166968\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/kvrd18\">@kvrd18</a> I'm working on it (not affiliated with TensorFlow team). Finding memory-efficient execution order is an NP-hard problem, but there are usable heuristics.</p>\n<p>One piece is a better node scheduling algorithm -- <a href=\"https://github.com/yaroslavvb/stuff/tree/master/linearize\">https://github.com/yaroslavvb/stuff/tree/master/linearize</a></p>\n<p>This algorithm will add control dependencies to force a particular order on a graph. In particular, graph like below will always use constant memory to execute after running through <code>linearize</code>. (TensorFlow default algorithm uses memory proportional to length of the graph in worst case)</p>\n <p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://cloud.githubusercontent.com/assets/23068/21414408/06033508-c7b4-11e6-939b-f0607d8e2a3a.png\"><img src=\"https://cloud.githubusercontent.com/assets/23068/21414408/06033508-c7b4-11e6-939b-f0607d8e2a3a.png\" style=\"max-width:100%;\"></a></p>", "body_text": "@kvrd18 I'm working on it (not affiliated with TensorFlow team). Finding memory-efficient execution order is an NP-hard problem, but there are usable heuristics.\nOne piece is a better node scheduling algorithm -- https://github.com/yaroslavvb/stuff/tree/master/linearize\nThis algorithm will add control dependencies to force a particular order on a graph. In particular, graph like below will always use constant memory to execute after running through linearize. (TensorFlow default algorithm uses memory proportional to length of the graph in worst case)", "body": "@kvrd18 I'm working on it (not affiliated with TensorFlow team). Finding memory-efficient execution order is an NP-hard problem, but there are usable heuristics.\r\n\r\nOne piece is a better node scheduling algorithm -- https://github.com/yaroslavvb/stuff/tree/master/linearize\r\n\r\nThis algorithm will add control dependencies to force a particular order on a graph. In particular, graph like below will always use constant memory to execute after running through `linearize`. (TensorFlow default algorithm uses memory proportional to length of the graph in worst case)\r\n\r\n <img src=https://cloud.githubusercontent.com/assets/23068/21414408/06033508-c7b4-11e6-939b-f0607d8e2a3a.png>"}