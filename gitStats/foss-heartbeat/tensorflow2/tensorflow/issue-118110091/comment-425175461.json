{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/425175461", "html_url": "https://github.com/tensorflow/tensorflow/issues/312#issuecomment-425175461", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/312", "id": 425175461, "node_id": "MDEyOklzc3VlQ29tbWVudDQyNTE3NTQ2MQ==", "user": {"login": "danielgordon10", "id": 7245472, "node_id": "MDQ6VXNlcjcyNDU0NzI=", "avatar_url": "https://avatars2.githubusercontent.com/u/7245472?v=4", "gravatar_id": "", "url": "https://api.github.com/users/danielgordon10", "html_url": "https://github.com/danielgordon10", "followers_url": "https://api.github.com/users/danielgordon10/followers", "following_url": "https://api.github.com/users/danielgordon10/following{/other_user}", "gists_url": "https://api.github.com/users/danielgordon10/gists{/gist_id}", "starred_url": "https://api.github.com/users/danielgordon10/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/danielgordon10/subscriptions", "organizations_url": "https://api.github.com/users/danielgordon10/orgs", "repos_url": "https://api.github.com/users/danielgordon10/repos", "events_url": "https://api.github.com/users/danielgordon10/events{/privacy}", "received_events_url": "https://api.github.com/users/danielgordon10/received_events", "type": "User", "site_admin": false}, "created_at": "2018-09-27T17:25:08Z", "updated_at": "2018-09-27T17:25:08Z", "author_association": "CONTRIBUTOR", "body_html": "<p>If anyone is interested, I have updated my original code to give more feedback and work for directories as well. I haven't tried the slim solution, but it probably works equally as well, though it may not give as much nice feedback.</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">def</span> <span class=\"pl-en\">restore</span>(<span class=\"pl-smi\">session</span>, <span class=\"pl-smi\">save_file</span>, <span class=\"pl-smi\">raise_if_not_found</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">False</span>, <span class=\"pl-smi\">copy_mismatched_shapes</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">False</span>):\n    <span class=\"pl-k\">if</span> <span class=\"pl-k\">not</span> os.path.exists(save_file) <span class=\"pl-k\">and</span> raise_if_not_found:\n        <span class=\"pl-k\">raise</span> <span class=\"pl-c1\">Exception</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>File <span class=\"pl-c1\">%s</span> not found<span class=\"pl-pds\">'</span></span> <span class=\"pl-k\">%</span> save_file)\n    reader <span class=\"pl-k\">=</span> tf.train.NewCheckpointReader(save_file)\n    saved_shapes <span class=\"pl-k\">=</span> reader.get_variable_to_shape_map()\n    var_names <span class=\"pl-k\">=</span> <span class=\"pl-c1\">sorted</span>([(var.name, var.name.split(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>:<span class=\"pl-pds\">'</span></span>)[<span class=\"pl-c1\">0</span>]) <span class=\"pl-k\">for</span> var <span class=\"pl-k\">in</span> tf.global_variables()\n            <span class=\"pl-k\">if</span> var.name.split(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>:<span class=\"pl-pds\">'</span></span>)[<span class=\"pl-c1\">0</span>] <span class=\"pl-k\">in</span> saved_shapes])\n    var_name_to_var <span class=\"pl-k\">=</span> {var.name : var <span class=\"pl-k\">for</span> var <span class=\"pl-k\">in</span> tf.global_variables()}\n    restore_vars <span class=\"pl-k\">=</span> []\n    restored_var_names <span class=\"pl-k\">=</span> <span class=\"pl-c1\">set</span>()\n    restored_var_new_shape <span class=\"pl-k\">=</span> []\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>Restoring:<span class=\"pl-pds\">'</span></span>)\n    <span class=\"pl-k\">with</span> tf.variable_scope(tf.get_variable_scope(), <span class=\"pl-v\">reuse</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">True</span>):\n        <span class=\"pl-k\">for</span> var_name, saved_var_name <span class=\"pl-k\">in</span> var_names:\n            <span class=\"pl-k\">if</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>global_step<span class=\"pl-pds\">'</span></span> <span class=\"pl-k\">in</span> var_name:\n                restored_var_names.add(saved_var_name)\n                <span class=\"pl-k\">continue</span>\n            curr_var <span class=\"pl-k\">=</span> var_name_to_var[var_name]\n            var_shape <span class=\"pl-k\">=</span> curr_var.get_shape().as_list()\n            <span class=\"pl-k\">if</span> var_shape <span class=\"pl-k\">==</span> saved_shapes[saved_var_name]:\n                restore_vars.append(curr_var)\n                <span class=\"pl-c1\">print</span>(<span class=\"pl-c1\">str</span>(saved_var_name) <span class=\"pl-k\">+</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span> -&gt; <span class=\"pl-cce\">\\t</span><span class=\"pl-pds\">'</span></span> <span class=\"pl-k\">+</span> <span class=\"pl-c1\">str</span>(var_shape) <span class=\"pl-k\">+</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span> = <span class=\"pl-pds\">'</span></span> <span class=\"pl-k\">+</span>\n                      <span class=\"pl-c1\">str</span>(<span class=\"pl-c1\">int</span>(np.prod(var_shape) <span class=\"pl-k\">*</span> <span class=\"pl-c1\">4</span> <span class=\"pl-k\">/</span> <span class=\"pl-c1\">10</span><span class=\"pl-k\">**</span><span class=\"pl-c1\">6</span>)) <span class=\"pl-k\">+</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>MB<span class=\"pl-pds\">'</span></span>)\n                restored_var_names.add(saved_var_name)\n            <span class=\"pl-k\">else</span>:\n                <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>Shape mismatch for var<span class=\"pl-pds\">'</span></span>, saved_var_name, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>expected<span class=\"pl-pds\">'</span></span>, var_shape,\n                      <span class=\"pl-s\"><span class=\"pl-pds\">'</span>got<span class=\"pl-pds\">'</span></span>, saved_shapes[saved_var_name])\n                restored_var_new_shape.append((saved_var_name, curr_var, reader.get_tensor(saved_var_name)))\n                <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>bad things<span class=\"pl-pds\">'</span></span>)\n    ignored_var_names <span class=\"pl-k\">=</span> <span class=\"pl-c1\">sorted</span>(<span class=\"pl-c1\">list</span>(<span class=\"pl-c1\">set</span>(saved_shapes.keys()) <span class=\"pl-k\">-</span> restored_var_names))\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span><span class=\"pl-cce\">\\n</span><span class=\"pl-pds\">'</span></span>)\n    <span class=\"pl-k\">if</span> <span class=\"pl-c1\">len</span>(ignored_var_names) <span class=\"pl-k\">==</span> <span class=\"pl-c1\">0</span>:\n        <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>Restored all variables<span class=\"pl-pds\">'</span></span>)\n    <span class=\"pl-k\">else</span>:\n        <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>Did not restore:<span class=\"pl-pds\">'</span></span> <span class=\"pl-k\">+</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span><span class=\"pl-cce\">\\n\\t</span><span class=\"pl-pds\">'</span></span>.join(ignored_var_names))\n\n    <span class=\"pl-k\">if</span> <span class=\"pl-c1\">len</span>(restore_vars) <span class=\"pl-k\">&gt;</span> <span class=\"pl-c1\">0</span>:\n        saver <span class=\"pl-k\">=</span> tf.train.Saver(restore_vars)\n        saver.restore(session, save_file)\n\n    <span class=\"pl-k\">if</span> <span class=\"pl-c1\">len</span>(restored_var_new_shape) <span class=\"pl-k\">&gt;</span> <span class=\"pl-c1\">0</span> <span class=\"pl-k\">and</span> copy_mismatched_shapes:\n        <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>trying to restore misshapen variables<span class=\"pl-pds\">'</span></span>)\n        assign_ops <span class=\"pl-k\">=</span> []\n        <span class=\"pl-k\">for</span> name, kk, vv <span class=\"pl-k\">in</span> restored_var_new_shape:\n            copy_sizes <span class=\"pl-k\">=</span> np.minimum(kk.get_shape().as_list(), vv.shape)\n            slices <span class=\"pl-k\">=</span> [<span class=\"pl-c1\">slice</span>(<span class=\"pl-c1\">0</span>,cs) <span class=\"pl-k\">for</span> cs <span class=\"pl-k\">in</span> copy_sizes]\n            <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>copy shape<span class=\"pl-pds\">'</span></span>, name, kk.get_shape().as_list(), <span class=\"pl-s\"><span class=\"pl-pds\">'</span>-&gt;<span class=\"pl-pds\">'</span></span>, copy_sizes.tolist())\n            new_arr <span class=\"pl-k\">=</span> session.run(kk)\n            new_arr[slices] <span class=\"pl-k\">=</span> vv[slices]\n            assign_ops.append(tf.assign(kk, new_arr))\n        session.run(assign_ops)\n        <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>Copying unmatched weights done<span class=\"pl-pds\">'</span></span>)\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>Restored <span class=\"pl-c1\">%s</span><span class=\"pl-pds\">'</span></span> <span class=\"pl-k\">%</span> save_file)\n    <span class=\"pl-k\">try</span>:\n        start_iter <span class=\"pl-k\">=</span> <span class=\"pl-c1\">int</span>(save_file.split(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>-<span class=\"pl-pds\">'</span></span>)[<span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>])\n    <span class=\"pl-k\">except</span> <span class=\"pl-c1\">ValueError</span>:\n        <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>Could not parse start iter, assuming 0<span class=\"pl-pds\">'</span></span>)\n        start_iter <span class=\"pl-k\">=</span> <span class=\"pl-c1\">0</span>\n    <span class=\"pl-k\">return</span> start_iter\n\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">restore_from_dir</span>(<span class=\"pl-smi\">sess</span>, <span class=\"pl-smi\">folder_path</span>, <span class=\"pl-smi\">raise_if_not_found</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">False</span>, <span class=\"pl-smi\">copy_mismatched_shapes</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">False</span>):\n    start_iter <span class=\"pl-k\">=</span> <span class=\"pl-c1\">0</span>\n    ckpt <span class=\"pl-k\">=</span> tf.train.get_checkpoint_state(folder_path)\n    <span class=\"pl-k\">if</span> ckpt <span class=\"pl-k\">and</span> ckpt.model_checkpoint_path:\n        <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>Restoring<span class=\"pl-pds\">'</span></span>)\n        start_iter <span class=\"pl-k\">=</span> restore(sess, ckpt.model_checkpoint_path, raise_if_not_found, copy_mismatched_shapes)\n    <span class=\"pl-k\">else</span>:\n        <span class=\"pl-k\">if</span> raise_if_not_found:\n            <span class=\"pl-k\">raise</span> <span class=\"pl-c1\">Exception</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>No checkpoint to restore in <span class=\"pl-c1\">%s</span><span class=\"pl-pds\">'</span></span> <span class=\"pl-k\">%</span> folder_path)\n        <span class=\"pl-k\">else</span>:\n            <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>No checkpoint to restore in <span class=\"pl-c1\">%s</span><span class=\"pl-pds\">'</span></span> <span class=\"pl-k\">%</span> folder_path)\n    <span class=\"pl-k\">return</span> start_iter</pre></div>", "body_text": "If anyone is interested, I have updated my original code to give more feedback and work for directories as well. I haven't tried the slim solution, but it probably works equally as well, though it may not give as much nice feedback.\ndef restore(session, save_file, raise_if_not_found=False, copy_mismatched_shapes=False):\n    if not os.path.exists(save_file) and raise_if_not_found:\n        raise Exception('File %s not found' % save_file)\n    reader = tf.train.NewCheckpointReader(save_file)\n    saved_shapes = reader.get_variable_to_shape_map()\n    var_names = sorted([(var.name, var.name.split(':')[0]) for var in tf.global_variables()\n            if var.name.split(':')[0] in saved_shapes])\n    var_name_to_var = {var.name : var for var in tf.global_variables()}\n    restore_vars = []\n    restored_var_names = set()\n    restored_var_new_shape = []\n    print('Restoring:')\n    with tf.variable_scope(tf.get_variable_scope(), reuse=True):\n        for var_name, saved_var_name in var_names:\n            if 'global_step' in var_name:\n                restored_var_names.add(saved_var_name)\n                continue\n            curr_var = var_name_to_var[var_name]\n            var_shape = curr_var.get_shape().as_list()\n            if var_shape == saved_shapes[saved_var_name]:\n                restore_vars.append(curr_var)\n                print(str(saved_var_name) + ' -> \\t' + str(var_shape) + ' = ' +\n                      str(int(np.prod(var_shape) * 4 / 10**6)) + 'MB')\n                restored_var_names.add(saved_var_name)\n            else:\n                print('Shape mismatch for var', saved_var_name, 'expected', var_shape,\n                      'got', saved_shapes[saved_var_name])\n                restored_var_new_shape.append((saved_var_name, curr_var, reader.get_tensor(saved_var_name)))\n                print('bad things')\n    ignored_var_names = sorted(list(set(saved_shapes.keys()) - restored_var_names))\n    print('\\n')\n    if len(ignored_var_names) == 0:\n        print('Restored all variables')\n    else:\n        print('Did not restore:' + '\\n\\t'.join(ignored_var_names))\n\n    if len(restore_vars) > 0:\n        saver = tf.train.Saver(restore_vars)\n        saver.restore(session, save_file)\n\n    if len(restored_var_new_shape) > 0 and copy_mismatched_shapes:\n        print('trying to restore misshapen variables')\n        assign_ops = []\n        for name, kk, vv in restored_var_new_shape:\n            copy_sizes = np.minimum(kk.get_shape().as_list(), vv.shape)\n            slices = [slice(0,cs) for cs in copy_sizes]\n            print('copy shape', name, kk.get_shape().as_list(), '->', copy_sizes.tolist())\n            new_arr = session.run(kk)\n            new_arr[slices] = vv[slices]\n            assign_ops.append(tf.assign(kk, new_arr))\n        session.run(assign_ops)\n        print('Copying unmatched weights done')\n    print('Restored %s' % save_file)\n    try:\n        start_iter = int(save_file.split('-')[-1])\n    except ValueError:\n        print('Could not parse start iter, assuming 0')\n        start_iter = 0\n    return start_iter\n\n\ndef restore_from_dir(sess, folder_path, raise_if_not_found=False, copy_mismatched_shapes=False):\n    start_iter = 0\n    ckpt = tf.train.get_checkpoint_state(folder_path)\n    if ckpt and ckpt.model_checkpoint_path:\n        print('Restoring')\n        start_iter = restore(sess, ckpt.model_checkpoint_path, raise_if_not_found, copy_mismatched_shapes)\n    else:\n        if raise_if_not_found:\n            raise Exception('No checkpoint to restore in %s' % folder_path)\n        else:\n            print('No checkpoint to restore in %s' % folder_path)\n    return start_iter", "body": "If anyone is interested, I have updated my original code to give more feedback and work for directories as well. I haven't tried the slim solution, but it probably works equally as well, though it may not give as much nice feedback.\r\n\r\n```python\r\ndef restore(session, save_file, raise_if_not_found=False, copy_mismatched_shapes=False):\r\n    if not os.path.exists(save_file) and raise_if_not_found:\r\n        raise Exception('File %s not found' % save_file)\r\n    reader = tf.train.NewCheckpointReader(save_file)\r\n    saved_shapes = reader.get_variable_to_shape_map()\r\n    var_names = sorted([(var.name, var.name.split(':')[0]) for var in tf.global_variables()\r\n            if var.name.split(':')[0] in saved_shapes])\r\n    var_name_to_var = {var.name : var for var in tf.global_variables()}\r\n    restore_vars = []\r\n    restored_var_names = set()\r\n    restored_var_new_shape = []\r\n    print('Restoring:')\r\n    with tf.variable_scope(tf.get_variable_scope(), reuse=True):\r\n        for var_name, saved_var_name in var_names:\r\n            if 'global_step' in var_name:\r\n                restored_var_names.add(saved_var_name)\r\n                continue\r\n            curr_var = var_name_to_var[var_name]\r\n            var_shape = curr_var.get_shape().as_list()\r\n            if var_shape == saved_shapes[saved_var_name]:\r\n                restore_vars.append(curr_var)\r\n                print(str(saved_var_name) + ' -> \\t' + str(var_shape) + ' = ' +\r\n                      str(int(np.prod(var_shape) * 4 / 10**6)) + 'MB')\r\n                restored_var_names.add(saved_var_name)\r\n            else:\r\n                print('Shape mismatch for var', saved_var_name, 'expected', var_shape,\r\n                      'got', saved_shapes[saved_var_name])\r\n                restored_var_new_shape.append((saved_var_name, curr_var, reader.get_tensor(saved_var_name)))\r\n                print('bad things')\r\n    ignored_var_names = sorted(list(set(saved_shapes.keys()) - restored_var_names))\r\n    print('\\n')\r\n    if len(ignored_var_names) == 0:\r\n        print('Restored all variables')\r\n    else:\r\n        print('Did not restore:' + '\\n\\t'.join(ignored_var_names))\r\n\r\n    if len(restore_vars) > 0:\r\n        saver = tf.train.Saver(restore_vars)\r\n        saver.restore(session, save_file)\r\n\r\n    if len(restored_var_new_shape) > 0 and copy_mismatched_shapes:\r\n        print('trying to restore misshapen variables')\r\n        assign_ops = []\r\n        for name, kk, vv in restored_var_new_shape:\r\n            copy_sizes = np.minimum(kk.get_shape().as_list(), vv.shape)\r\n            slices = [slice(0,cs) for cs in copy_sizes]\r\n            print('copy shape', name, kk.get_shape().as_list(), '->', copy_sizes.tolist())\r\n            new_arr = session.run(kk)\r\n            new_arr[slices] = vv[slices]\r\n            assign_ops.append(tf.assign(kk, new_arr))\r\n        session.run(assign_ops)\r\n        print('Copying unmatched weights done')\r\n    print('Restored %s' % save_file)\r\n    try:\r\n        start_iter = int(save_file.split('-')[-1])\r\n    except ValueError:\r\n        print('Could not parse start iter, assuming 0')\r\n        start_iter = 0\r\n    return start_iter\r\n\r\n\r\ndef restore_from_dir(sess, folder_path, raise_if_not_found=False, copy_mismatched_shapes=False):\r\n    start_iter = 0\r\n    ckpt = tf.train.get_checkpoint_state(folder_path)\r\n    if ckpt and ckpt.model_checkpoint_path:\r\n        print('Restoring')\r\n        start_iter = restore(sess, ckpt.model_checkpoint_path, raise_if_not_found, copy_mismatched_shapes)\r\n    else:\r\n        if raise_if_not_found:\r\n            raise Exception('No checkpoint to restore in %s' % folder_path)\r\n        else:\r\n            print('No checkpoint to restore in %s' % folder_path)\r\n    return start_iter\r\n```"}