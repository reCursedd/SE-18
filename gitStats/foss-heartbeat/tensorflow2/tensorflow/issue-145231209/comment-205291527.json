{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/205291527", "html_url": "https://github.com/tensorflow/tensorflow/issues/1742#issuecomment-205291527", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/1742", "id": 205291527, "node_id": "MDEyOklzc3VlQ29tbWVudDIwNTI5MTUyNw==", "user": {"login": "mbhenry", "id": 6217742, "node_id": "MDQ6VXNlcjYyMTc3NDI=", "avatar_url": "https://avatars3.githubusercontent.com/u/6217742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mbhenry", "html_url": "https://github.com/mbhenry", "followers_url": "https://api.github.com/users/mbhenry/followers", "following_url": "https://api.github.com/users/mbhenry/following{/other_user}", "gists_url": "https://api.github.com/users/mbhenry/gists{/gist_id}", "starred_url": "https://api.github.com/users/mbhenry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mbhenry/subscriptions", "organizations_url": "https://api.github.com/users/mbhenry/orgs", "repos_url": "https://api.github.com/users/mbhenry/repos", "events_url": "https://api.github.com/users/mbhenry/events{/privacy}", "received_events_url": "https://api.github.com/users/mbhenry/received_events", "type": "User", "site_admin": false}, "created_at": "2016-04-04T13:12:35Z", "updated_at": "2016-04-04T13:12:35Z", "author_association": "NONE", "body_html": "<p>Thanks for pointing me to gather_nd.  It did take a bit more effort to generate the index list from the label_length arrays, but I got it working.  Below is the code.</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">def</span> <span class=\"pl-en\">ctc_label_dense_to_sparse</span>( <span class=\"pl-smi\">labels</span>, <span class=\"pl-smi\">label_lengths</span> ):\n    label_shape <span class=\"pl-k\">=</span> tf.shape( labels )\n    num_batches_tns <span class=\"pl-k\">=</span> tf.pack( [label_shape[<span class=\"pl-c1\">0</span>]] )\n    max_num_labels_tns <span class=\"pl-k\">=</span> tf.pack( [label_shape[<span class=\"pl-c1\">1</span>]] )\n    <span class=\"pl-k\">def</span> <span class=\"pl-en\">range_less_than</span>(<span class=\"pl-smi\">previous_state</span>, <span class=\"pl-smi\">current_input</span>):\n        <span class=\"pl-k\">return</span> tf.expand_dims( tf.range( label_shape[<span class=\"pl-c1\">1</span>] ), <span class=\"pl-c1\">0</span> ) <span class=\"pl-k\">&lt;</span> current_input\n\n    init <span class=\"pl-k\">=</span> tf.cast( tf.fill( max_num_labels_tns, <span class=\"pl-c1\">0</span> ), tf.bool )\n    dense_mask <span class=\"pl-k\">=</span> functional_ops.scan(range_less_than, label_lengths , <span class=\"pl-v\">initializer</span><span class=\"pl-k\">=</span>init, \n         <span class=\"pl-v\">parallel_iterations</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">1</span>)\n    dense_mask <span class=\"pl-k\">=</span> dense_mask[ :, <span class=\"pl-c1\">0</span>, : ]\n\n    label_array <span class=\"pl-k\">=</span> tf.reshape( tf.tile( tf.range( <span class=\"pl-c1\">0</span>, label_shape[<span class=\"pl-c1\">1</span>] ), num_batches_tns ),\n          label_shape )\n    label_ind <span class=\"pl-k\">=</span> tf.boolean_mask( label_array, dense_mask )\n\n    batch_array <span class=\"pl-k\">=</span> tf.transpose( tf.reshape( tf.tile( tf.range( <span class=\"pl-c1\">0</span>,  label_shape[<span class=\"pl-c1\">0</span>] ), max_num_labels_tns ),\n          tf.reverse( label_shape,[<span class=\"pl-c1\">True</span>]) ) )\n    batch_ind <span class=\"pl-k\">=</span> tf.boolean_mask( batch_array, dense_mask )\n\n    indices <span class=\"pl-k\">=</span> tf.transpose( tf.reshape( tf.concat( <span class=\"pl-c1\">0</span>, [batch_ind, label_ind] ), [<span class=\"pl-c1\">2</span>,<span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>] ) )\n    vals_sparse <span class=\"pl-k\">=</span> tf.gather_nd( labels, indices )\n    <span class=\"pl-k\">return</span> tf.SparseTensor( tf.to_int64(indices), vals_sparse, tf.to_int64( label_shape ) )</pre></div>\n<p>For now I may put this in a Keras PR, unless you think it has a place in the TensorFlow API.</p>", "body_text": "Thanks for pointing me to gather_nd.  It did take a bit more effort to generate the index list from the label_length arrays, but I got it working.  Below is the code.\ndef ctc_label_dense_to_sparse( labels, label_lengths ):\n    label_shape = tf.shape( labels )\n    num_batches_tns = tf.pack( [label_shape[0]] )\n    max_num_labels_tns = tf.pack( [label_shape[1]] )\n    def range_less_than(previous_state, current_input):\n        return tf.expand_dims( tf.range( label_shape[1] ), 0 ) < current_input\n\n    init = tf.cast( tf.fill( max_num_labels_tns, 0 ), tf.bool )\n    dense_mask = functional_ops.scan(range_less_than, label_lengths , initializer=init, \n         parallel_iterations=1)\n    dense_mask = dense_mask[ :, 0, : ]\n\n    label_array = tf.reshape( tf.tile( tf.range( 0, label_shape[1] ), num_batches_tns ),\n          label_shape )\n    label_ind = tf.boolean_mask( label_array, dense_mask )\n\n    batch_array = tf.transpose( tf.reshape( tf.tile( tf.range( 0,  label_shape[0] ), max_num_labels_tns ),\n          tf.reverse( label_shape,[True]) ) )\n    batch_ind = tf.boolean_mask( batch_array, dense_mask )\n\n    indices = tf.transpose( tf.reshape( tf.concat( 0, [batch_ind, label_ind] ), [2,-1] ) )\n    vals_sparse = tf.gather_nd( labels, indices )\n    return tf.SparseTensor( tf.to_int64(indices), vals_sparse, tf.to_int64( label_shape ) )\nFor now I may put this in a Keras PR, unless you think it has a place in the TensorFlow API.", "body": "Thanks for pointing me to gather_nd.  It did take a bit more effort to generate the index list from the label_length arrays, but I got it working.  Below is the code.\n\n``` python\ndef ctc_label_dense_to_sparse( labels, label_lengths ):\n    label_shape = tf.shape( labels )\n    num_batches_tns = tf.pack( [label_shape[0]] )\n    max_num_labels_tns = tf.pack( [label_shape[1]] )\n    def range_less_than(previous_state, current_input):\n        return tf.expand_dims( tf.range( label_shape[1] ), 0 ) < current_input\n\n    init = tf.cast( tf.fill( max_num_labels_tns, 0 ), tf.bool )\n    dense_mask = functional_ops.scan(range_less_than, label_lengths , initializer=init, \n         parallel_iterations=1)\n    dense_mask = dense_mask[ :, 0, : ]\n\n    label_array = tf.reshape( tf.tile( tf.range( 0, label_shape[1] ), num_batches_tns ),\n          label_shape )\n    label_ind = tf.boolean_mask( label_array, dense_mask )\n\n    batch_array = tf.transpose( tf.reshape( tf.tile( tf.range( 0,  label_shape[0] ), max_num_labels_tns ),\n          tf.reverse( label_shape,[True]) ) )\n    batch_ind = tf.boolean_mask( batch_array, dense_mask )\n\n    indices = tf.transpose( tf.reshape( tf.concat( 0, [batch_ind, label_ind] ), [2,-1] ) )\n    vals_sparse = tf.gather_nd( labels, indices )\n    return tf.SparseTensor( tf.to_int64(indices), vals_sparse, tf.to_int64( label_shape ) )\n```\n\nFor now I may put this in a Keras PR, unless you think it has a place in the TensorFlow API. \n"}