{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/226061708", "html_url": "https://github.com/tensorflow/tensorflow/issues/2255#issuecomment-226061708", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2255", "id": 226061708, "node_id": "MDEyOklzc3VlQ29tbWVudDIyNjA2MTcwOA==", "user": {"login": "khaotik", "id": 6271084, "node_id": "MDQ6VXNlcjYyNzEwODQ=", "avatar_url": "https://avatars3.githubusercontent.com/u/6271084?v=4", "gravatar_id": "", "url": "https://api.github.com/users/khaotik", "html_url": "https://github.com/khaotik", "followers_url": "https://api.github.com/users/khaotik/followers", "following_url": "https://api.github.com/users/khaotik/following{/other_user}", "gists_url": "https://api.github.com/users/khaotik/gists{/gist_id}", "starred_url": "https://api.github.com/users/khaotik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/khaotik/subscriptions", "organizations_url": "https://api.github.com/users/khaotik/orgs", "repos_url": "https://api.github.com/users/khaotik/repos", "events_url": "https://api.github.com/users/khaotik/events{/privacy}", "received_events_url": "https://api.github.com/users/khaotik/received_events", "type": "User", "site_admin": false}, "created_at": "2016-06-15T01:07:42Z", "updated_at": "2016-06-15T01:11:14Z", "author_association": "NONE", "body_html": "<p>@LeavesBreathe</p>\n<blockquote>\n<p>Why do you multiply 3 separate times by fft_scale -- in the original paper this is not called for.</p>\n</blockquote>\n<p>My bad. One line in the code is supposed to be commented out, already edited. There should be only one FFT/IFFT pair.<br>\nAs for why I multiply <code>fft_scale</code>, is due to TF's FFT is not a normalized FFT, it will scale the norm of the vector being FFTed. For example:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-c1\">print</span>(raw_fft( [<span class=\"pl-c1\">1</span>.,<span class=\"pl-c1\">1</span>.] )) <span class=\"pl-c\"><span class=\"pl-c\">#</span>[2.,0.]</span>\n<span class=\"pl-c1\">print</span>(normalized_fft([<span class=\"pl-c1\">1</span>., <span class=\"pl-c1\">1</span>.])) <span class=\"pl-c\"><span class=\"pl-c\">#</span>[1.4142, 0.]</span></pre></div>\n<blockquote>\n<p>Your <code>diag</code> variables do not appear to be diagonal, but rather normal complex matrices.</p>\n</blockquote>\n<p>They are diagonal.<br>\nIf you multiply (NOT <code>matmul</code>) tensor <code>x</code> of shape <code>[4]</code> with tensor <code>y</code> of shape <code>[100,4]</code>, you get broadcasted multiplication in TF, which is equivalent to <code>matmul( y, diag(x) )</code>.</p>\n<blockquote>\n<p>In your <code>modrelu</code> function you multiply by <code>in_c</code>. From my impression, the paper simply uses as <code>modrelu</code> as an activation function and do not multiply the output by <code>in_c</code></p>\n</blockquote>\n<p><code>modrelu</code>, by design, changes the abs of input complex number to its ReLU-ed value while keeping phase intact. My <code>modReLU</code> does this: Calculated ReLU-ed abs, then multiply it by normalized input complex number. This is consistent with original paper.</p>", "body_text": "@LeavesBreathe\n\nWhy do you multiply 3 separate times by fft_scale -- in the original paper this is not called for.\n\nMy bad. One line in the code is supposed to be commented out, already edited. There should be only one FFT/IFFT pair.\nAs for why I multiply fft_scale, is due to TF's FFT is not a normalized FFT, it will scale the norm of the vector being FFTed. For example:\nprint(raw_fft( [1.,1.] )) #[2.,0.]\nprint(normalized_fft([1., 1.])) #[1.4142, 0.]\n\nYour diag variables do not appear to be diagonal, but rather normal complex matrices.\n\nThey are diagonal.\nIf you multiply (NOT matmul) tensor x of shape [4] with tensor y of shape [100,4], you get broadcasted multiplication in TF, which is equivalent to matmul( y, diag(x) ).\n\nIn your modrelu function you multiply by in_c. From my impression, the paper simply uses as modrelu as an activation function and do not multiply the output by in_c\n\nmodrelu, by design, changes the abs of input complex number to its ReLU-ed value while keeping phase intact. My modReLU does this: Calculated ReLU-ed abs, then multiply it by normalized input complex number. This is consistent with original paper.", "body": "@LeavesBreathe\n\n> Why do you multiply 3 separate times by fft_scale -- in the original paper this is not called for.\n\nMy bad. One line in the code is supposed to be commented out, already edited. There should be only one FFT/IFFT pair.\nAs for why I multiply `fft_scale`, is due to TF's FFT is not a normalized FFT, it will scale the norm of the vector being FFTed. For example:\n\n``` python\nprint(raw_fft( [1.,1.] )) #[2.,0.]\nprint(normalized_fft([1., 1.])) #[1.4142, 0.]\n```\n\n> Your `diag` variables do not appear to be diagonal, but rather normal complex matrices.\n\nThey are diagonal.\nIf you multiply (NOT `matmul`) tensor `x` of shape `[4]` with tensor `y` of shape `[100,4]`, you get broadcasted multiplication in TF, which is equivalent to `matmul( y, diag(x) )`.\n\n> In your `modrelu` function you multiply by `in_c`. From my impression, the paper simply uses as `modrelu` as an activation function and do not multiply the output by `in_c`\n\n`modrelu`, by design, changes the abs of input complex number to its ReLU-ed value while keeping phase intact. My `modReLU` does this: Calculated ReLU-ed abs, then multiply it by normalized input complex number. This is consistent with original paper.\n"}