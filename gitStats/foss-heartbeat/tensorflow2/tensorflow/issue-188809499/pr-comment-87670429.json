{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/87670429", "pull_request_review_id": 8277660, "id": 87670429, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDg3NjcwNDI5", "diff_hunk": "@@ -100,6 +101,40 @@ while [ \"$TF_NEED_HDFS\" == \"\" ]; do\n   esac\n done\n \n+while [ \"$TF_NEED_LIBJPEG_TURBO\" == \"\" ]; do", "path": "configure", "position": 12, "original_position": 12, "commit_id": "e6969722f8e5ff698d7de1272d9779e2e7aae3aa", "original_commit_id": "e6969722f8e5ff698d7de1272d9779e2e7aae3aa", "user": {"login": "mkolod", "id": 476135, "node_id": "MDQ6VXNlcjQ3NjEzNQ==", "avatar_url": "https://avatars1.githubusercontent.com/u/476135?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mkolod", "html_url": "https://github.com/mkolod", "followers_url": "https://api.github.com/users/mkolod/followers", "following_url": "https://api.github.com/users/mkolod/following{/other_user}", "gists_url": "https://api.github.com/users/mkolod/gists{/gist_id}", "starred_url": "https://api.github.com/users/mkolod/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mkolod/subscriptions", "organizations_url": "https://api.github.com/users/mkolod/orgs", "repos_url": "https://api.github.com/users/mkolod/repos", "events_url": "https://api.github.com/users/mkolod/events{/privacy}", "received_events_url": "https://api.github.com/users/mkolod/received_events", "type": "User", "site_admin": false}, "body": "@jart The challenge here is that libjpeg-turbo is an assembly-based code base, rather than pure C (hand-written SIMD for various JPEG functions, see [here](http://www.libjpeg-turbo.org/About/SIMDCoverage) - this is hand-written SSE2 for x86, NEON for ARM, etc.). This means that the configuration for it is pretty tricky, and the default build for libjpeg is based on autotools (autoconf, automake) as well as nasm. This makes it messy because suddenly for one library substitution, the build grows from Bazel to 3 additional build tools. If the lib substitution is optional, users who don't care about the improved performance can keep building like they always have, just with Bazel. Users who might benefit from the extra performance and don't mind installing extra tools could do so, but I think forcing extra tools on every user would be painful. The other issue here is that as far as I know, doing assembly builds by themselves directly in Bazel would also be non-trivial, hence I'm reusing the build definitions from libjpeg-turbo's code base.\n", "created_at": "2016-11-11T22:40:23Z", "updated_at": "2016-11-11T22:41:57Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/5547#discussion_r87670429", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/5547", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/87670429"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/5547#discussion_r87670429"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/5547"}}, "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=49262\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/jart\">@jart</a> The challenge here is that libjpeg-turbo is an assembly-based code base, rather than pure C (hand-written SIMD for various JPEG functions, see <a href=\"http://www.libjpeg-turbo.org/About/SIMDCoverage\" rel=\"nofollow\">here</a> - this is hand-written SSE2 for x86, NEON for ARM, etc.). This means that the configuration for it is pretty tricky, and the default build for libjpeg is based on autotools (autoconf, automake) as well as nasm. This makes it messy because suddenly for one library substitution, the build grows from Bazel to 3 additional build tools. If the lib substitution is optional, users who don't care about the improved performance can keep building like they always have, just with Bazel. Users who might benefit from the extra performance and don't mind installing extra tools could do so, but I think forcing extra tools on every user would be painful. The other issue here is that as far as I know, doing assembly builds by themselves directly in Bazel would also be non-trivial, hence I'm reusing the build definitions from libjpeg-turbo's code base.</p>", "body_text": "@jart The challenge here is that libjpeg-turbo is an assembly-based code base, rather than pure C (hand-written SIMD for various JPEG functions, see here - this is hand-written SSE2 for x86, NEON for ARM, etc.). This means that the configuration for it is pretty tricky, and the default build for libjpeg is based on autotools (autoconf, automake) as well as nasm. This makes it messy because suddenly for one library substitution, the build grows from Bazel to 3 additional build tools. If the lib substitution is optional, users who don't care about the improved performance can keep building like they always have, just with Bazel. Users who might benefit from the extra performance and don't mind installing extra tools could do so, but I think forcing extra tools on every user would be painful. The other issue here is that as far as I know, doing assembly builds by themselves directly in Bazel would also be non-trivial, hence I'm reusing the build definitions from libjpeg-turbo's code base.", "in_reply_to_id": 87669328}