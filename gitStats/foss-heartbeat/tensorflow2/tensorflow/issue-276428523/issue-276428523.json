{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/14841", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/14841/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/14841/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/14841/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/14841", "id": 276428523, "node_id": "MDU6SXNzdWUyNzY0Mjg1MjM=", "number": 14841, "title": "Estimators cause Out of range warning on FIFOQueue and fail to run all training steps", "user": {"login": "pfc", "id": 276335, "node_id": "MDQ6VXNlcjI3NjMzNQ==", "avatar_url": "https://avatars3.githubusercontent.com/u/276335?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pfc", "html_url": "https://github.com/pfc", "followers_url": "https://api.github.com/users/pfc/followers", "following_url": "https://api.github.com/users/pfc/following{/other_user}", "gists_url": "https://api.github.com/users/pfc/gists{/gist_id}", "starred_url": "https://api.github.com/users/pfc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pfc/subscriptions", "organizations_url": "https://api.github.com/users/pfc/orgs", "repos_url": "https://api.github.com/users/pfc/repos", "events_url": "https://api.github.com/users/pfc/events{/privacy}", "received_events_url": "https://api.github.com/users/pfc/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 404586594, "node_id": "MDU6TGFiZWw0MDQ1ODY1OTQ=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:awaiting%20tensorflower", "name": "stat:awaiting tensorflower", "color": "f4b400", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2017-11-23T16:25:39Z", "updated_at": "2017-11-28T18:07:40Z", "closed_at": "2017-11-28T18:07:39Z", "author_association": "NONE", "body_html": "<h3>System information</h3>\n<ul>\n<li><strong>OS Platform and Distribution (e.g., Linux Ubuntu 16.04)</strong>: 4.13.12-1-ARCH</li>\n<li><strong>TensorFlow installed from (source or binary)</strong>: Binary</li>\n<li><strong>TensorFlow version (use command below)</strong>: 1.4.0</li>\n<li><strong>Python version</strong>: 3.6.3</li>\n<li><strong>CUDA/cuDNN version</strong>: 9.0.176-4/7.0.3-1</li>\n<li><strong>GPU model and memory</strong>: 1080/1070</li>\n</ul>\n<h3>Describe the problem</h3>\n<p>Trying to use estimators with a trivially small network fails to train for more than one step due to FIFOQueue closing with insufficient elements.</p>\n<h3>Source code / logs</h3>\n<p>In the following example I try to train a single neuron for 1000 steps at a time.  set_size changes the training set's size.  With set_size=1000 I would expect training to complete 1000 steps however only 8 steps are completed and an Out of range warning is printed.  Setting set_size to 10 leads to only a single step being completed, I would expect at least 10 steps to complete, possible all 1000 if the input_fn is called repeatedly to fill a queue(not sure what default behaviour is supposed to be).  Setting set_size=1000000 allows the entire 1k training steps to complete.</p>\n<p>code:</p>\n<pre><code>import numpy as np\nimport tensorflow as tf\nimport models\n\nset_size = 1000\n\nparams = {\"learning_rate\":0.00001}\n\ndef model_fn(features, labels, mode, params):\n    \"\"\"Build model for Estimator here\"\"\"\n    ####Build graph\n    input_layer = tf.reshape(features[\"x\"],[-1,1])\n    hidden_layer = tf.layers.dense(input_layer,1,activation=tf.nn.relu)\n    output_layer = hidden_layer\n    \n    ####Prediction mode\n    if mode == tf.estimator.ModeKeys.PREDICT:\n        predictions = {\"y\":output_layer}\n        return tf.estimator.EstimatorSpec(mode=mode,predictions=predictions)\n    \n    loss = tf.losses.mean_squared_error(labels,output_layer)\n    \n    ####Training mode\n    if mode == tf.estimator.ModeKeys.TRAIN:\n        optimizer = tf.train.GradientDescentOptimizer(learning_rate=params[\"learning_rate\"])\n        train_op = optimizer.minimize(loss=loss,global_step=tf.train.get_global_step())\n        return tf.estimator.EstimatorSpec(\n            mode=mode,\n            loss=loss,\n            train_op=train_op)\n    \n    ####Eval mode\n    elif mode == tf.estimator.ModeKeys.EVAL:\n        eval_metric_ops = {\"rmse\":tf.metrics.root_mean_squared_error(labels,output_layer)}\n        return tf.estimator.EstimatorSpec(\n            mode=mode,\n            loss=loss,\n            eval_metric_ops=eval_metric_ops)\n        \n\ninput_fn = tf.estimator.inputs.numpy_input_fn(\n    x={'x':np.array([[float(x)] for x in range(set_size)])},\n    y=np.array([[float(x*2)] for x in range(set_size)]),\n    shuffle=False\n)\n\n\ndef test():\n    nn = tf.estimator.Estimator(model_fn=model_fn, params=params)\n    for x in range(5):\n        print('START LOOP:',x)\n        a = nn.train(input_fn=input_fn,steps=1000)\n        print('--------')\n        b = nn.evaluate(input_fn=input_fn)\n        print(\"----STATS----\",b)\n    print('Done loop')\n    c = nn.predict(input_fn=input_fn)\n    #print('Predictions:',[x for x in c])\n\nif __name__ == \"__main__\":\n    test()\n</code></pre>\n<p>warning:</p>\n<blockquote>\n<p>2017-11-23 11:23:52.370395: W tensorflow/core/framework/op_kernel.cc:1192] Out of range: FIFOQueue '_2_enqueue_input/fifo_queue' is closed and has insufficient elements (requested 128, current size 0)<br>\n[[Node: fifo_queue_DequeueUpTo = QueueDequeueUpToV2[component_types=[DT_INT64, DT_DOUBLE, DT_DOUBLE], timeout_ms=-1, _device=\"/job:localhost/replica:0/task:0/device:CPU:0\"](enqueue_input/fifo_queue, fifo_queue_DequeueUpTo/n)]]</p>\n</blockquote>\n<p>Edit: This may be due to something in tf.estimator.inputs.numpy_input_fn as creating the input_fn manually does not cause the warning and early termination of training.</p>", "body_text": "System information\n\nOS Platform and Distribution (e.g., Linux Ubuntu 16.04): 4.13.12-1-ARCH\nTensorFlow installed from (source or binary): Binary\nTensorFlow version (use command below): 1.4.0\nPython version: 3.6.3\nCUDA/cuDNN version: 9.0.176-4/7.0.3-1\nGPU model and memory: 1080/1070\n\nDescribe the problem\nTrying to use estimators with a trivially small network fails to train for more than one step due to FIFOQueue closing with insufficient elements.\nSource code / logs\nIn the following example I try to train a single neuron for 1000 steps at a time.  set_size changes the training set's size.  With set_size=1000 I would expect training to complete 1000 steps however only 8 steps are completed and an Out of range warning is printed.  Setting set_size to 10 leads to only a single step being completed, I would expect at least 10 steps to complete, possible all 1000 if the input_fn is called repeatedly to fill a queue(not sure what default behaviour is supposed to be).  Setting set_size=1000000 allows the entire 1k training steps to complete.\ncode:\nimport numpy as np\nimport tensorflow as tf\nimport models\n\nset_size = 1000\n\nparams = {\"learning_rate\":0.00001}\n\ndef model_fn(features, labels, mode, params):\n    \"\"\"Build model for Estimator here\"\"\"\n    ####Build graph\n    input_layer = tf.reshape(features[\"x\"],[-1,1])\n    hidden_layer = tf.layers.dense(input_layer,1,activation=tf.nn.relu)\n    output_layer = hidden_layer\n    \n    ####Prediction mode\n    if mode == tf.estimator.ModeKeys.PREDICT:\n        predictions = {\"y\":output_layer}\n        return tf.estimator.EstimatorSpec(mode=mode,predictions=predictions)\n    \n    loss = tf.losses.mean_squared_error(labels,output_layer)\n    \n    ####Training mode\n    if mode == tf.estimator.ModeKeys.TRAIN:\n        optimizer = tf.train.GradientDescentOptimizer(learning_rate=params[\"learning_rate\"])\n        train_op = optimizer.minimize(loss=loss,global_step=tf.train.get_global_step())\n        return tf.estimator.EstimatorSpec(\n            mode=mode,\n            loss=loss,\n            train_op=train_op)\n    \n    ####Eval mode\n    elif mode == tf.estimator.ModeKeys.EVAL:\n        eval_metric_ops = {\"rmse\":tf.metrics.root_mean_squared_error(labels,output_layer)}\n        return tf.estimator.EstimatorSpec(\n            mode=mode,\n            loss=loss,\n            eval_metric_ops=eval_metric_ops)\n        \n\ninput_fn = tf.estimator.inputs.numpy_input_fn(\n    x={'x':np.array([[float(x)] for x in range(set_size)])},\n    y=np.array([[float(x*2)] for x in range(set_size)]),\n    shuffle=False\n)\n\n\ndef test():\n    nn = tf.estimator.Estimator(model_fn=model_fn, params=params)\n    for x in range(5):\n        print('START LOOP:',x)\n        a = nn.train(input_fn=input_fn,steps=1000)\n        print('--------')\n        b = nn.evaluate(input_fn=input_fn)\n        print(\"----STATS----\",b)\n    print('Done loop')\n    c = nn.predict(input_fn=input_fn)\n    #print('Predictions:',[x for x in c])\n\nif __name__ == \"__main__\":\n    test()\n\nwarning:\n\n2017-11-23 11:23:52.370395: W tensorflow/core/framework/op_kernel.cc:1192] Out of range: FIFOQueue '_2_enqueue_input/fifo_queue' is closed and has insufficient elements (requested 128, current size 0)\n[[Node: fifo_queue_DequeueUpTo = QueueDequeueUpToV2[component_types=[DT_INT64, DT_DOUBLE, DT_DOUBLE], timeout_ms=-1, _device=\"/job:localhost/replica:0/task:0/device:CPU:0\"](enqueue_input/fifo_queue, fifo_queue_DequeueUpTo/n)]]\n\nEdit: This may be due to something in tf.estimator.inputs.numpy_input_fn as creating the input_fn manually does not cause the warning and early termination of training.", "body": "### System information\r\n- **OS Platform and Distribution (e.g., Linux Ubuntu 16.04)**: 4.13.12-1-ARCH\r\n- **TensorFlow installed from (source or binary)**: Binary\r\n- **TensorFlow version (use command below)**: 1.4.0\r\n- **Python version**: 3.6.3\r\n- **CUDA/cuDNN version**: 9.0.176-4/7.0.3-1\r\n- **GPU model and memory**: 1080/1070\r\n\r\n### Describe the problem\r\nTrying to use estimators with a trivially small network fails to train for more than one step due to FIFOQueue closing with insufficient elements.\r\n\r\n### Source code / logs\r\nIn the following example I try to train a single neuron for 1000 steps at a time.  set_size changes the training set's size.  With set_size=1000 I would expect training to complete 1000 steps however only 8 steps are completed and an Out of range warning is printed.  Setting set_size to 10 leads to only a single step being completed, I would expect at least 10 steps to complete, possible all 1000 if the input_fn is called repeatedly to fill a queue(not sure what default behaviour is supposed to be).  Setting set_size=1000000 allows the entire 1k training steps to complete.\r\n\r\ncode:\r\n\r\n```\r\nimport numpy as np\r\nimport tensorflow as tf\r\nimport models\r\n\r\nset_size = 1000\r\n\r\nparams = {\"learning_rate\":0.00001}\r\n\r\ndef model_fn(features, labels, mode, params):\r\n    \"\"\"Build model for Estimator here\"\"\"\r\n    ####Build graph\r\n    input_layer = tf.reshape(features[\"x\"],[-1,1])\r\n    hidden_layer = tf.layers.dense(input_layer,1,activation=tf.nn.relu)\r\n    output_layer = hidden_layer\r\n    \r\n    ####Prediction mode\r\n    if mode == tf.estimator.ModeKeys.PREDICT:\r\n        predictions = {\"y\":output_layer}\r\n        return tf.estimator.EstimatorSpec(mode=mode,predictions=predictions)\r\n    \r\n    loss = tf.losses.mean_squared_error(labels,output_layer)\r\n    \r\n    ####Training mode\r\n    if mode == tf.estimator.ModeKeys.TRAIN:\r\n        optimizer = tf.train.GradientDescentOptimizer(learning_rate=params[\"learning_rate\"])\r\n        train_op = optimizer.minimize(loss=loss,global_step=tf.train.get_global_step())\r\n        return tf.estimator.EstimatorSpec(\r\n            mode=mode,\r\n            loss=loss,\r\n            train_op=train_op)\r\n    \r\n    ####Eval mode\r\n    elif mode == tf.estimator.ModeKeys.EVAL:\r\n        eval_metric_ops = {\"rmse\":tf.metrics.root_mean_squared_error(labels,output_layer)}\r\n        return tf.estimator.EstimatorSpec(\r\n            mode=mode,\r\n            loss=loss,\r\n            eval_metric_ops=eval_metric_ops)\r\n        \r\n\r\ninput_fn = tf.estimator.inputs.numpy_input_fn(\r\n    x={'x':np.array([[float(x)] for x in range(set_size)])},\r\n    y=np.array([[float(x*2)] for x in range(set_size)]),\r\n    shuffle=False\r\n)\r\n\r\n\r\ndef test():\r\n    nn = tf.estimator.Estimator(model_fn=model_fn, params=params)\r\n    for x in range(5):\r\n        print('START LOOP:',x)\r\n        a = nn.train(input_fn=input_fn,steps=1000)\r\n        print('--------')\r\n        b = nn.evaluate(input_fn=input_fn)\r\n        print(\"----STATS----\",b)\r\n    print('Done loop')\r\n    c = nn.predict(input_fn=input_fn)\r\n    #print('Predictions:',[x for x in c])\r\n\r\nif __name__ == \"__main__\":\r\n    test()\r\n```\r\nwarning:\r\n> 2017-11-23 11:23:52.370395: W tensorflow/core/framework/op_kernel.cc:1192] Out of range: FIFOQueue '_2_enqueue_input/fifo_queue' is closed and has insufficient elements (requested 128, current size 0)\r\n> \t [[Node: fifo_queue_DequeueUpTo = QueueDequeueUpToV2[component_types=[DT_INT64, DT_DOUBLE, DT_DOUBLE], timeout_ms=-1, _device=\"/job:localhost/replica:0/task:0/device:CPU:0\"](enqueue_input/fifo_queue, fifo_queue_DequeueUpTo/n)]]\r\n\r\nEdit: This may be due to something in tf.estimator.inputs.numpy_input_fn as creating the input_fn manually does not cause the warning and early termination of training."}