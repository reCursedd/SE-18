{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/230141401", "html_url": "https://github.com/tensorflow/tensorflow/issues/2940#issuecomment-230141401", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2940", "id": 230141401, "node_id": "MDEyOklzc3VlQ29tbWVudDIzMDE0MTQwMQ==", "user": {"login": "Invisibility", "id": 4239191, "node_id": "MDQ6VXNlcjQyMzkxOTE=", "avatar_url": "https://avatars2.githubusercontent.com/u/4239191?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Invisibility", "html_url": "https://github.com/Invisibility", "followers_url": "https://api.github.com/users/Invisibility/followers", "following_url": "https://api.github.com/users/Invisibility/following{/other_user}", "gists_url": "https://api.github.com/users/Invisibility/gists{/gist_id}", "starred_url": "https://api.github.com/users/Invisibility/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Invisibility/subscriptions", "organizations_url": "https://api.github.com/users/Invisibility/orgs", "repos_url": "https://api.github.com/users/Invisibility/repos", "events_url": "https://api.github.com/users/Invisibility/events{/privacy}", "received_events_url": "https://api.github.com/users/Invisibility/received_events", "type": "User", "site_admin": false}, "created_at": "2016-07-03T08:12:55Z", "updated_at": "2016-07-03T08:12:55Z", "author_association": "CONTRIBUTOR", "body_html": "<p>I also hit the same issue on Mac. I investigated a little bit.</p>\n<p>As mentioned earlier in this thread, the crash happens because tensorflow couldn't load a cuda shared library. tensorflow shouldn't crash but it did because <code>LOG(INFO) &lt;&lt;  ... &lt;&lt; getenv(\"LD_LIBRARY_PATH\")</code> doesn't support char pointer being nullptr. I enclosed the relevant code at the end of this message.</p>\n<p>As for why tensorflow didn't find the cuda shared library, in my case, it was because ipython from anaconda doesn't inherit the environment variable from my bash shell. I switched to use python instead of ipython, tensorflow was able to load the cuda shared library.</p>\n<p>Hopefully this finding will help others who have similar problem.</p>\n<p><code>tensorflow/stream_executor/dso_loader.cc@93</code></p>\n<pre><code>/* static */ port::Status DsoLoader::GetDsoHandle(port::StringPiece path,\n                                                  void** dso_handle,\n                                                  LoadKind load_kind) {\n\n  int dynload_flags =\n      RTLD_LAZY | (load_kind == LoadKind::kLocal ? RTLD_LOCAL : RTLD_GLOBAL);\n  string path_string = path.ToString();\n  *dso_handle = dlopen(path_string.c_str(), dynload_flags);\n  if (*dso_handle == nullptr) {\n    LOG(INFO) &lt;&lt; \"Couldn't open CUDA library \" &lt;&lt; path\n              &lt;&lt; \". LD_LIBRARY_PATH: \" &lt;&lt; getenv(\"LD_LIBRARY_PATH\");\n    return port::Status(\n        port::error::FAILED_PRECONDITION,\n        port::StrCat(\"could not dlopen DSO: \", path, \"; dlerror: \", dlerror()));\n  }\n  LOG(INFO) &lt;&lt; \"successfully opened CUDA library \" &lt;&lt; path\n            &lt;&lt; (load_kind == LoadKind::kLocal ? \" locally\" : \" globally\");\n  return port::Status::OK();\n}\n</code></pre>\n<p><code>probably common.cc in protobuf</code></p>\n<pre><code>LogMessage&amp; LogMessage::operator&lt;&lt;(const char* value) {\n  message_ += value;\n  return *this;\n}\n</code></pre>\n<p><code>XCode c++ library string</code></p>\n<pre><code>...\n\n_LIBCPP_INLINE_VISIBILITY basic_string&amp; operator+=(const value_type* __s)         {return append(__s);}\n\n...\n\nbasic_string&lt;_CharT, _Traits, _Allocator&gt;::append(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::append received nullptr\");\n    return append(__s, traits_type::length(__s));\n}\n\n...\n\nstatic inline size_t length(const char_type* __s) {return strlen(__s);}\n</code></pre>", "body_text": "I also hit the same issue on Mac. I investigated a little bit.\nAs mentioned earlier in this thread, the crash happens because tensorflow couldn't load a cuda shared library. tensorflow shouldn't crash but it did because LOG(INFO) <<  ... << getenv(\"LD_LIBRARY_PATH\") doesn't support char pointer being nullptr. I enclosed the relevant code at the end of this message.\nAs for why tensorflow didn't find the cuda shared library, in my case, it was because ipython from anaconda doesn't inherit the environment variable from my bash shell. I switched to use python instead of ipython, tensorflow was able to load the cuda shared library.\nHopefully this finding will help others who have similar problem.\ntensorflow/stream_executor/dso_loader.cc@93\n/* static */ port::Status DsoLoader::GetDsoHandle(port::StringPiece path,\n                                                  void** dso_handle,\n                                                  LoadKind load_kind) {\n\n  int dynload_flags =\n      RTLD_LAZY | (load_kind == LoadKind::kLocal ? RTLD_LOCAL : RTLD_GLOBAL);\n  string path_string = path.ToString();\n  *dso_handle = dlopen(path_string.c_str(), dynload_flags);\n  if (*dso_handle == nullptr) {\n    LOG(INFO) << \"Couldn't open CUDA library \" << path\n              << \". LD_LIBRARY_PATH: \" << getenv(\"LD_LIBRARY_PATH\");\n    return port::Status(\n        port::error::FAILED_PRECONDITION,\n        port::StrCat(\"could not dlopen DSO: \", path, \"; dlerror: \", dlerror()));\n  }\n  LOG(INFO) << \"successfully opened CUDA library \" << path\n            << (load_kind == LoadKind::kLocal ? \" locally\" : \" globally\");\n  return port::Status::OK();\n}\n\nprobably common.cc in protobuf\nLogMessage& LogMessage::operator<<(const char* value) {\n  message_ += value;\n  return *this;\n}\n\nXCode c++ library string\n...\n\n_LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const value_type* __s)         {return append(__s);}\n\n...\n\nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::append received nullptr\");\n    return append(__s, traits_type::length(__s));\n}\n\n...\n\nstatic inline size_t length(const char_type* __s) {return strlen(__s);}", "body": "I also hit the same issue on Mac. I investigated a little bit.\n\nAs mentioned earlier in this thread, the crash happens because tensorflow couldn't load a cuda shared library. tensorflow shouldn't crash but it did because `LOG(INFO) <<  ... << getenv(\"LD_LIBRARY_PATH\")` doesn't support char pointer being nullptr. I enclosed the relevant code at the end of this message.\n\nAs for why tensorflow didn't find the cuda shared library, in my case, it was because ipython from anaconda doesn't inherit the environment variable from my bash shell. I switched to use python instead of ipython, tensorflow was able to load the cuda shared library.\n\nHopefully this finding will help others who have similar problem.\n\n`tensorflow/stream_executor/dso_loader.cc@93`\n\n```\n/* static */ port::Status DsoLoader::GetDsoHandle(port::StringPiece path,\n                                                  void** dso_handle,\n                                                  LoadKind load_kind) {\n\n  int dynload_flags =\n      RTLD_LAZY | (load_kind == LoadKind::kLocal ? RTLD_LOCAL : RTLD_GLOBAL);\n  string path_string = path.ToString();\n  *dso_handle = dlopen(path_string.c_str(), dynload_flags);\n  if (*dso_handle == nullptr) {\n    LOG(INFO) << \"Couldn't open CUDA library \" << path\n              << \". LD_LIBRARY_PATH: \" << getenv(\"LD_LIBRARY_PATH\");\n    return port::Status(\n        port::error::FAILED_PRECONDITION,\n        port::StrCat(\"could not dlopen DSO: \", path, \"; dlerror: \", dlerror()));\n  }\n  LOG(INFO) << \"successfully opened CUDA library \" << path\n            << (load_kind == LoadKind::kLocal ? \" locally\" : \" globally\");\n  return port::Status::OK();\n}\n```\n\n`probably common.cc in protobuf`\n\n```\nLogMessage& LogMessage::operator<<(const char* value) {\n  message_ += value;\n  return *this;\n}\n```\n\n`XCode c++ library string`\n\n```\n...\n\n_LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const value_type* __s)         {return append(__s);}\n\n...\n\nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::append received nullptr\");\n    return append(__s, traits_type::length(__s));\n}\n\n...\n\nstatic inline size_t length(const char_type* __s) {return strlen(__s);}\n```\n"}