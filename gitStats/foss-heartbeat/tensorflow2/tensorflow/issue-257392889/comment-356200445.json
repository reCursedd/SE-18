{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/356200445", "html_url": "https://github.com/tensorflow/tensorflow/issues/13016#issuecomment-356200445", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13016", "id": 356200445, "node_id": "MDEyOklzc3VlQ29tbWVudDM1NjIwMDQ0NQ==", "user": {"login": "leandro-gracia-gil", "id": 8785797, "node_id": "MDQ6VXNlcjg3ODU3OTc=", "avatar_url": "https://avatars1.githubusercontent.com/u/8785797?v=4", "gravatar_id": "", "url": "https://api.github.com/users/leandro-gracia-gil", "html_url": "https://github.com/leandro-gracia-gil", "followers_url": "https://api.github.com/users/leandro-gracia-gil/followers", "following_url": "https://api.github.com/users/leandro-gracia-gil/following{/other_user}", "gists_url": "https://api.github.com/users/leandro-gracia-gil/gists{/gist_id}", "starred_url": "https://api.github.com/users/leandro-gracia-gil/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/leandro-gracia-gil/subscriptions", "organizations_url": "https://api.github.com/users/leandro-gracia-gil/orgs", "repos_url": "https://api.github.com/users/leandro-gracia-gil/repos", "events_url": "https://api.github.com/users/leandro-gracia-gil/events{/privacy}", "received_events_url": "https://api.github.com/users/leandro-gracia-gil/received_events", "type": "User", "site_admin": false}, "created_at": "2018-01-09T07:19:57Z", "updated_at": "2018-01-09T09:41:26Z", "author_association": "CONTRIBUTOR", "body_html": "<p>The error I mentioned immediately above does not happen with 1.4.1. It seems I accidentally caused it while testing when I used different versions of Tensorflow (1.5.0rc0 and 1.4.0) on different machines. This wasn't the case when I reported the bug, so please ignore that last comment.</p>\n<p>Back to the original problem, I'm still able to reproduce it in some configurations.</p>\n<ul>\n<li>Fails when running foo in Windows 10 and bar in Linux, but for some reason it works if doing the reverse (bar in Windows 10, foo in Linux).</li>\n<li>Fails when running foo in Windows 10 and bar in Bash on Windows 10 in the same host. Again, the reverse works.</li>\n<li>Works both ways when using Linux and Bash on Windows 10 (which is a virtualized Linux).</li>\n<li>Using Windows 10 on both sides (either localhost or 2 different hosts) works too.</li>\n</ul>\n<p>So, this seems to suggest that the problem happens when running the task foo directly on Windows 10 and involving some other OS (even if it's in the same host). However,  although I couldn't test it this time, I see that my original bug report also mentioned the problem happened between Linux and Mac OS X servers. If this is still the case then the problem would not be Windows-specific, but actually triggered by running tf.train.Servers in different OS, at least in some foo/bar task placement configurations.</p>\n<p>The fact that it works between 2 Windows 10 hosts or by reversing the roles, and that it can also fail in localhost across 2 OS in the same machine makes me doubt this is a networking problem. If anything, it would be some kind of low-level networking issue arising from differences between OS.</p>\n<p>I tried setting <code>GRPC_VERBOSITY=DEBUG</code> but I didn't see anything suspicious. Just in case, I forced some errors by putting IPs intentionally wrong, and I did get error logs in that case.</p>\n<p>I've also tried the following simpler code as suggested and it works fine. Both sessions are initialized without any problems.</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">def</span> <span class=\"pl-en\">foo_job</span>():\n  server <span class=\"pl-k\">=</span> tf.train.Server(cluster_spec, <span class=\"pl-v\">job_name</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>foo<span class=\"pl-pds\">'</span></span>, <span class=\"pl-v\">task_index</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">0</span>)\n  <span class=\"pl-k\">with</span> tf.Session(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>grpc://<span class=\"pl-pds\">'</span></span> <span class=\"pl-k\">+</span> cluster_spec.as_dict()[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>bar<span class=\"pl-pds\">'</span></span>][<span class=\"pl-c1\">0</span>]) <span class=\"pl-k\">as</span> session:\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> Run something to force the use of the remote session.</span>\n    <span class=\"pl-k\">with</span> tf.device(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>job:bar/task:0<span class=\"pl-pds\">'</span></span>):\n      session.run(tf.no_op())\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>**** Session started! ****<span class=\"pl-pds\">\"</span></span>)\n    server.join()\n\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">bar_job</span>():\n  server <span class=\"pl-k\">=</span> tf.train.Server(cluster_spec, <span class=\"pl-v\">job_name</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>bar<span class=\"pl-pds\">'</span></span>, <span class=\"pl-v\">task_index</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">0</span>)\n  <span class=\"pl-k\">with</span> tf.Session(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>grpc://<span class=\"pl-pds\">'</span></span> <span class=\"pl-k\">+</span> cluster_spec.as_dict()[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>foo<span class=\"pl-pds\">'</span></span>][<span class=\"pl-c1\">0</span>]) <span class=\"pl-k\">as</span> session:\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> Run something to force the use of the remote session.</span>\n    <span class=\"pl-k\">with</span> tf.device(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>job:foo/task:0<span class=\"pl-pds\">'</span></span>):\n      session.run(tf.no_op())\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>**** Session started! ****<span class=\"pl-pds\">\"</span></span>)\n    server.join()</pre></div>\n<p>Furthermore, if after a working session initialization I try to run the variable initialization, then the bar side never sees it.</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">def</span> <span class=\"pl-en\">foo_job</span>():\n  server <span class=\"pl-k\">=</span> tf.train.Server(cluster_spec, <span class=\"pl-v\">job_name</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>foo<span class=\"pl-pds\">'</span></span>, <span class=\"pl-v\">task_index</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">0</span>)\n  <span class=\"pl-k\">with</span> tf.Session(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>grpc://<span class=\"pl-pds\">'</span></span> <span class=\"pl-k\">+</span> cluster_spec.as_dict()[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>bar<span class=\"pl-pds\">'</span></span>][<span class=\"pl-c1\">0</span>]) <span class=\"pl-k\">as</span> session:\n    <span class=\"pl-k\">with</span> tf.device(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>job:bar/task:0<span class=\"pl-pds\">'</span></span>):\n      session.run(tf.no_op())\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>**** Session started! ****<span class=\"pl-pds\">\"</span></span>)\n\n    <span class=\"pl-k\">while</span> <span class=\"pl-c1\">True</span>:\n      <span class=\"pl-c\"><span class=\"pl-c\">#</span> This loops forever saying b'foo/W' is not initialized. Doesn't matter how long you wait.</span>\n      <span class=\"pl-c\"><span class=\"pl-c\">#</span> Meanwhile, the other job says all variables have been initialized.</span>\n      vars_left <span class=\"pl-k\">=</span> session.run(bar_pending_vars)\n      <span class=\"pl-k\">if</span> <span class=\"pl-c1\">len</span>(vars_left) <span class=\"pl-k\">==</span> <span class=\"pl-c1\">0</span>:\n        <span class=\"pl-k\">break</span>\n\n      <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Bar -- Variables not initialized: <span class=\"pl-pds\">\"</span></span>, vars_left)\n      sleep(<span class=\"pl-c1\">1</span>)\n\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Bar -- Variables initialized!<span class=\"pl-pds\">\"</span></span>)\n    server.join()\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">bar_job</span>():\n  server <span class=\"pl-k\">=</span> tf.train.Server(cluster_spec, <span class=\"pl-v\">job_name</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>bar<span class=\"pl-pds\">'</span></span>, <span class=\"pl-v\">task_index</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">0</span>)\n  <span class=\"pl-k\">with</span> tf.Session(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>grpc://<span class=\"pl-pds\">'</span></span> <span class=\"pl-k\">+</span> cluster_spec.as_dict()[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>foo<span class=\"pl-pds\">'</span></span>][<span class=\"pl-c1\">0</span>]) <span class=\"pl-k\">as</span> session:\n    <span class=\"pl-k\">with</span> tf.device(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>job:foo/task:0<span class=\"pl-pds\">'</span></span>):\n      session.run(tf.no_op())\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>**** Session started! ****<span class=\"pl-pds\">\"</span></span>)\n\n    session.run(foo_init_vars)\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Foo -- Variables not initialized: <span class=\"pl-pds\">\"</span></span>, session.run(foo_pending_vars))\n\n    server.join()</pre></div>\n<p>Note that with that same code, if you swap in which hosts the foo and bar servers are started (foo goes to Linux instead of Windows) then the problem does not happen.</p>\n<p>So, the issue is definitely still there. If you want me to try anything else please let me know. I'll be happy to help.</p>", "body_text": "The error I mentioned immediately above does not happen with 1.4.1. It seems I accidentally caused it while testing when I used different versions of Tensorflow (1.5.0rc0 and 1.4.0) on different machines. This wasn't the case when I reported the bug, so please ignore that last comment.\nBack to the original problem, I'm still able to reproduce it in some configurations.\n\nFails when running foo in Windows 10 and bar in Linux, but for some reason it works if doing the reverse (bar in Windows 10, foo in Linux).\nFails when running foo in Windows 10 and bar in Bash on Windows 10 in the same host. Again, the reverse works.\nWorks both ways when using Linux and Bash on Windows 10 (which is a virtualized Linux).\nUsing Windows 10 on both sides (either localhost or 2 different hosts) works too.\n\nSo, this seems to suggest that the problem happens when running the task foo directly on Windows 10 and involving some other OS (even if it's in the same host). However,  although I couldn't test it this time, I see that my original bug report also mentioned the problem happened between Linux and Mac OS X servers. If this is still the case then the problem would not be Windows-specific, but actually triggered by running tf.train.Servers in different OS, at least in some foo/bar task placement configurations.\nThe fact that it works between 2 Windows 10 hosts or by reversing the roles, and that it can also fail in localhost across 2 OS in the same machine makes me doubt this is a networking problem. If anything, it would be some kind of low-level networking issue arising from differences between OS.\nI tried setting GRPC_VERBOSITY=DEBUG but I didn't see anything suspicious. Just in case, I forced some errors by putting IPs intentionally wrong, and I did get error logs in that case.\nI've also tried the following simpler code as suggested and it works fine. Both sessions are initialized without any problems.\ndef foo_job():\n  server = tf.train.Server(cluster_spec, job_name='foo', task_index=0)\n  with tf.Session('grpc://' + cluster_spec.as_dict()['bar'][0]) as session:\n    # Run something to force the use of the remote session.\n    with tf.device('job:bar/task:0'):\n      session.run(tf.no_op())\n    print(\"**** Session started! ****\")\n    server.join()\n\n\ndef bar_job():\n  server = tf.train.Server(cluster_spec, job_name='bar', task_index=0)\n  with tf.Session('grpc://' + cluster_spec.as_dict()['foo'][0]) as session:\n    # Run something to force the use of the remote session.\n    with tf.device('job:foo/task:0'):\n      session.run(tf.no_op())\n    print(\"**** Session started! ****\")\n    server.join()\nFurthermore, if after a working session initialization I try to run the variable initialization, then the bar side never sees it.\ndef foo_job():\n  server = tf.train.Server(cluster_spec, job_name='foo', task_index=0)\n  with tf.Session('grpc://' + cluster_spec.as_dict()['bar'][0]) as session:\n    with tf.device('job:bar/task:0'):\n      session.run(tf.no_op())\n    print(\"**** Session started! ****\")\n\n    while True:\n      # This loops forever saying b'foo/W' is not initialized. Doesn't matter how long you wait.\n      # Meanwhile, the other job says all variables have been initialized.\n      vars_left = session.run(bar_pending_vars)\n      if len(vars_left) == 0:\n        break\n\n      print(\"Bar -- Variables not initialized: \", vars_left)\n      sleep(1)\n\n    print(\"Bar -- Variables initialized!\")\n    server.join()\n\ndef bar_job():\n  server = tf.train.Server(cluster_spec, job_name='bar', task_index=0)\n  with tf.Session('grpc://' + cluster_spec.as_dict()['foo'][0]) as session:\n    with tf.device('job:foo/task:0'):\n      session.run(tf.no_op())\n    print(\"**** Session started! ****\")\n\n    session.run(foo_init_vars)\n    print(\"Foo -- Variables not initialized: \", session.run(foo_pending_vars))\n\n    server.join()\nNote that with that same code, if you swap in which hosts the foo and bar servers are started (foo goes to Linux instead of Windows) then the problem does not happen.\nSo, the issue is definitely still there. If you want me to try anything else please let me know. I'll be happy to help.", "body": "The error I mentioned immediately above does not happen with 1.4.1. It seems I accidentally caused it while testing when I used different versions of Tensorflow (1.5.0rc0 and 1.4.0) on different machines. This wasn't the case when I reported the bug, so please ignore that last comment.\r\n\r\nBack to the original problem, I'm still able to reproduce it in some configurations.\r\n- Fails when running foo in Windows 10 and bar in Linux, but for some reason it works if doing the reverse (bar in Windows 10, foo in Linux).\r\n- Fails when running foo in Windows 10 and bar in Bash on Windows 10 in the same host. Again, the reverse works.\r\n- Works both ways when using Linux and Bash on Windows 10 (which is a virtualized Linux).\r\n- Using Windows 10 on both sides (either localhost or 2 different hosts) works too.\r\n\r\nSo, this seems to suggest that the problem happens when running the task foo directly on Windows 10 and involving some other OS (even if it's in the same host). However,  although I couldn't test it this time, I see that my original bug report also mentioned the problem happened between Linux and Mac OS X servers. If this is still the case then the problem would not be Windows-specific, but actually triggered by running tf.train.Servers in different OS, at least in some foo/bar task placement configurations.\r\n\r\nThe fact that it works between 2 Windows 10 hosts or by reversing the roles, and that it can also fail in localhost across 2 OS in the same machine makes me doubt this is a networking problem. If anything, it would be some kind of low-level networking issue arising from differences between OS.\r\n\r\nI tried setting `GRPC_VERBOSITY=DEBUG` but I didn't see anything suspicious. Just in case, I forced some errors by putting IPs intentionally wrong, and I did get error logs in that case.\r\n\r\nI've also tried the following simpler code as suggested and it works fine. Both sessions are initialized without any problems.\r\n```python\r\ndef foo_job():\r\n  server = tf.train.Server(cluster_spec, job_name='foo', task_index=0)\r\n  with tf.Session('grpc://' + cluster_spec.as_dict()['bar'][0]) as session:\r\n    # Run something to force the use of the remote session.\r\n    with tf.device('job:bar/task:0'):\r\n      session.run(tf.no_op())\r\n    print(\"**** Session started! ****\")\r\n    server.join()\r\n\r\n\r\ndef bar_job():\r\n  server = tf.train.Server(cluster_spec, job_name='bar', task_index=0)\r\n  with tf.Session('grpc://' + cluster_spec.as_dict()['foo'][0]) as session:\r\n    # Run something to force the use of the remote session.\r\n    with tf.device('job:foo/task:0'):\r\n      session.run(tf.no_op())\r\n    print(\"**** Session started! ****\")\r\n    server.join()\r\n```\r\n\r\nFurthermore, if after a working session initialization I try to run the variable initialization, then the bar side never sees it.\r\n```python\r\ndef foo_job():\r\n  server = tf.train.Server(cluster_spec, job_name='foo', task_index=0)\r\n  with tf.Session('grpc://' + cluster_spec.as_dict()['bar'][0]) as session:\r\n    with tf.device('job:bar/task:0'):\r\n      session.run(tf.no_op())\r\n    print(\"**** Session started! ****\")\r\n\r\n    while True:\r\n      # This loops forever saying b'foo/W' is not initialized. Doesn't matter how long you wait.\r\n      # Meanwhile, the other job says all variables have been initialized.\r\n      vars_left = session.run(bar_pending_vars)\r\n      if len(vars_left) == 0:\r\n        break\r\n\r\n      print(\"Bar -- Variables not initialized: \", vars_left)\r\n      sleep(1)\r\n\r\n    print(\"Bar -- Variables initialized!\")\r\n    server.join()\r\n\r\ndef bar_job():\r\n  server = tf.train.Server(cluster_spec, job_name='bar', task_index=0)\r\n  with tf.Session('grpc://' + cluster_spec.as_dict()['foo'][0]) as session:\r\n    with tf.device('job:foo/task:0'):\r\n      session.run(tf.no_op())\r\n    print(\"**** Session started! ****\")\r\n\r\n    session.run(foo_init_vars)\r\n    print(\"Foo -- Variables not initialized: \", session.run(foo_pending_vars))\r\n\r\n    server.join()\r\n```\r\n\r\nNote that with that same code, if you swap in which hosts the foo and bar servers are started (foo goes to Linux instead of Windows) then the problem does not happen.\r\n\r\nSo, the issue is definitely still there. If you want me to try anything else please let me know. I'll be happy to help.\r\n  \r\n  "}