{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/206693719", "pull_request_review_id": 142158258, "id": 206693719, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwNjY5MzcxOQ==", "diff_hunk": "@@ -0,0 +1,56 @@\n+package org.tensorflow.op.core;\n+\n+import java.nio.ByteBuffer;\n+\n+import org.tensorflow.DataType;\n+import org.tensorflow.Operand;\n+import org.tensorflow.Output;\n+import org.tensorflow.Shape;\n+import org.tensorflow.op.Op;\n+import org.tensorflow.op.Scope;\n+import org.tensorflow.op.annotation.Operator;\n+\n+/**\n+ * An operator creating a constant initialized with zeros w.r.t its type and shape.\n+ *\n+ * @param <T> constant type\n+ */\n+@Operator\n+public class Zeros<T> implements Op, Operand<T> {", "path": "tensorflow/java/src/main/java/org/tensorflow/op/core/Zeros.java", "position": 37, "original_position": 19, "commit_id": "e3bc2b0e764cacafb1156bc84299790fd9e60b89", "original_commit_id": "e5231a18a70064edc37aa12c7c7bbe9d0412cbd0", "user": {"login": "asimshankar", "id": 16018, "node_id": "MDQ6VXNlcjE2MDE4", "avatar_url": "https://avatars2.githubusercontent.com/u/16018?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asimshankar", "html_url": "https://github.com/asimshankar", "followers_url": "https://api.github.com/users/asimshankar/followers", "following_url": "https://api.github.com/users/asimshankar/following{/other_user}", "gists_url": "https://api.github.com/users/asimshankar/gists{/gist_id}", "starred_url": "https://api.github.com/users/asimshankar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asimshankar/subscriptions", "organizations_url": "https://api.github.com/users/asimshankar/orgs", "repos_url": "https://api.github.com/users/asimshankar/repos", "events_url": "https://api.github.com/users/asimshankar/events{/privacy}", "received_events_url": "https://api.github.com/users/asimshankar/received_events", "type": "User", "site_admin": false}, "body": "I meant that both `Zeros` and `ZerosLike` take (as input) tensors computed at graph execution time. The former uses the input as the shape of the output, the latter uses the shape of the input tensor as the shape of the output tensor. For example, in:\r\n\r\n```python\r\nimport tensorflow as tf\r\n\r\nx = tf.placeholder(tf.int32)\r\nz0 = tf.zeros(x)\r\nz1 = tf.zeros_like(x)\r\n\r\nwith tf.Session() as sess:\r\n  print(sess.run([z0, z1], feed_dict={x: [1, 1]}))\r\n```\r\n`z0` will evaluate to `[[0.]]`, while `z1` will evaluate to `[0., 0.]`.\r\nNote that `tf.zeros` in a [pretty trivial wrapper](https://github.com/tensorflow/tensorflow/blob/25c197e02393bd44f50079945409009dd4d434f8/tensorflow/python/ops/array_ops.py#L1550) over [`tf.fill`](https://www.tensorflow.org/api_docs/python/tf/fill).\r\n\r\nAlso, the shape is known only at graph execution time. And when it is known, it is fully specified.\r\nWhich is why I think having `Zeros.create()` use a `Shape` argument isn't quite right. The type of the `shape` argument should be `Output<Integer>` or `Output<Float>`.\r\n\r\nSomething like:\r\n\r\n```java\r\npublic class Zeros<T> implements Op, Operand<T> {\r\n  public static <T> Zeros<T> create(Scope scope, Class<T> type, Output<Integer> shape) {\r\n    return create(scope, type, shape);\r\n  }\r\n\r\n  public static <T> Zeros<T> create(Scope scope, Class<T> type, Output<Long> shape) {\r\n    return create(scope, type, shape);\r\n  }\r\n\r\n  private static <T, U> Zeros<T> create(Scope scope, Class<T> type, Output<U> shape) {\r\n    Output<T> zero = Constant.create(scope, type, new long[]{}, ByteBuffer.allocate(DataType.fromClass(type).byteSize());\r\n     return Fill<T>(scope, type, shape, zero);\r\n   }\r\n}    \r\n```\r\n\r\nAnd callers would do something like:\r\n\r\n```java\r\nOutput<Float> zeroMatrix = ops.zeros(ops.constant(new long[]{2, 2}));\r\n```\r\n\r\nLet me know if that makes sense, or if I'm misunderstanding.\r\n", "created_at": "2018-07-31T21:44:46Z", "updated_at": "2018-08-03T19:04:27Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/21092#discussion_r206693719", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/21092", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/206693719"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/21092#discussion_r206693719"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/21092"}}, "body_html": "<p>I meant that both <code>Zeros</code> and <code>ZerosLike</code> take (as input) tensors computed at graph execution time. The former uses the input as the shape of the output, the latter uses the shape of the input tensor as the shape of the output tensor. For example, in:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">import</span> tensorflow <span class=\"pl-k\">as</span> tf\n\nx <span class=\"pl-k\">=</span> tf.placeholder(tf.int32)\nz0 <span class=\"pl-k\">=</span> tf.zeros(x)\nz1 <span class=\"pl-k\">=</span> tf.zeros_like(x)\n\n<span class=\"pl-k\">with</span> tf.Session() <span class=\"pl-k\">as</span> sess:\n  <span class=\"pl-c1\">print</span>(sess.run([z0, z1], <span class=\"pl-v\">feed_dict</span><span class=\"pl-k\">=</span>{x: [<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">1</span>]}))</pre></div>\n<p><code>z0</code> will evaluate to <code>[[0.]]</code>, while <code>z1</code> will evaluate to <code>[0., 0.]</code>.<br>\nNote that <code>tf.zeros</code> in a <a href=\"https://github.com/tensorflow/tensorflow/blob/25c197e02393bd44f50079945409009dd4d434f8/tensorflow/python/ops/array_ops.py#L1550\">pretty trivial wrapper</a> over <a href=\"https://www.tensorflow.org/api_docs/python/tf/fill\" rel=\"nofollow\"><code>tf.fill</code></a>.</p>\n<p>Also, the shape is known only at graph execution time. And when it is known, it is fully specified.<br>\nWhich is why I think having <code>Zeros.create()</code> use a <code>Shape</code> argument isn't quite right. The type of the <code>shape</code> argument should be <code>Output&lt;Integer&gt;</code> or <code>Output&lt;Float&gt;</code>.</p>\n<p>Something like:</p>\n<div class=\"highlight highlight-source-java\"><pre><span class=\"pl-k\">public</span> <span class=\"pl-k\">class</span> <span class=\"pl-en\">Zeros</span>&lt;T&gt; <span class=\"pl-k\">implements</span> <span class=\"pl-e\">Op</span>, <span class=\"pl-e\">Operand&lt;<span class=\"pl-smi\">T</span>&gt;</span> {\n  <span class=\"pl-k\">public</span> <span class=\"pl-k\">static</span> <span class=\"pl-k\">&lt;<span class=\"pl-smi\">T</span>&gt;</span> <span class=\"pl-k\">Zeros&lt;<span class=\"pl-smi\">T</span>&gt;</span> <span class=\"pl-en\">create</span>(<span class=\"pl-smi\">Scope</span> <span class=\"pl-v\">scope</span>, <span class=\"pl-k\">Class&lt;<span class=\"pl-smi\">T</span>&gt;</span> <span class=\"pl-v\">type</span>, <span class=\"pl-k\">Output&lt;<span class=\"pl-smi\">Integer</span>&gt;</span> <span class=\"pl-v\">shape</span>) {\n    <span class=\"pl-k\">return</span> create(scope, type, shape);\n  }\n\n  <span class=\"pl-k\">public</span> <span class=\"pl-k\">static</span> <span class=\"pl-k\">&lt;<span class=\"pl-smi\">T</span>&gt;</span> <span class=\"pl-k\">Zeros&lt;<span class=\"pl-smi\">T</span>&gt;</span> <span class=\"pl-en\">create</span>(<span class=\"pl-smi\">Scope</span> <span class=\"pl-v\">scope</span>, <span class=\"pl-k\">Class&lt;<span class=\"pl-smi\">T</span>&gt;</span> <span class=\"pl-v\">type</span>, <span class=\"pl-k\">Output&lt;<span class=\"pl-smi\">Long</span>&gt;</span> <span class=\"pl-v\">shape</span>) {\n    <span class=\"pl-k\">return</span> create(scope, type, shape);\n  }\n\n  <span class=\"pl-k\">private</span> <span class=\"pl-k\">static</span> <span class=\"pl-k\">&lt;<span class=\"pl-smi\">T</span>, <span class=\"pl-smi\">U</span>&gt;</span> <span class=\"pl-k\">Zeros&lt;<span class=\"pl-smi\">T</span>&gt;</span> <span class=\"pl-en\">create</span>(<span class=\"pl-smi\">Scope</span> <span class=\"pl-v\">scope</span>, <span class=\"pl-k\">Class&lt;<span class=\"pl-smi\">T</span>&gt;</span> <span class=\"pl-v\">type</span>, <span class=\"pl-k\">Output&lt;<span class=\"pl-smi\">U</span>&gt;</span> <span class=\"pl-v\">shape</span>) {\n    <span class=\"pl-k\">Output&lt;<span class=\"pl-smi\">T</span>&gt;</span> zero <span class=\"pl-k\">=</span> <span class=\"pl-smi\">Constant</span><span class=\"pl-k\">.</span>create(scope, type, <span class=\"pl-k\">new</span> <span class=\"pl-smi\">long</span>[]{}, <span class=\"pl-smi\">ByteBuffer</span><span class=\"pl-k\">.</span>allocate(<span class=\"pl-smi\">DataType</span><span class=\"pl-k\">.</span>fromClass(type)<span class=\"pl-k\">.</span>byteSize());\n     <span class=\"pl-k\">return</span> <span class=\"pl-k\">Fill&lt;<span class=\"pl-smi\">T</span>&gt;</span>(scope, type, shape, zero);\n   }\n}    </pre></div>\n<p>And callers would do something like:</p>\n<div class=\"highlight highlight-source-java\"><pre><span class=\"pl-k\">Output&lt;<span class=\"pl-smi\">Float</span>&gt;</span> zeroMatrix <span class=\"pl-k\">=</span> ops<span class=\"pl-k\">.</span>zeros(ops<span class=\"pl-k\">.</span>constant(<span class=\"pl-k\">new</span> <span class=\"pl-smi\">long</span>[]{<span class=\"pl-c1\">2</span>, <span class=\"pl-c1\">2</span>}));</pre></div>\n<p>Let me know if that makes sense, or if I'm misunderstanding.</p>", "body_text": "I meant that both Zeros and ZerosLike take (as input) tensors computed at graph execution time. The former uses the input as the shape of the output, the latter uses the shape of the input tensor as the shape of the output tensor. For example, in:\nimport tensorflow as tf\n\nx = tf.placeholder(tf.int32)\nz0 = tf.zeros(x)\nz1 = tf.zeros_like(x)\n\nwith tf.Session() as sess:\n  print(sess.run([z0, z1], feed_dict={x: [1, 1]}))\nz0 will evaluate to [[0.]], while z1 will evaluate to [0., 0.].\nNote that tf.zeros in a pretty trivial wrapper over tf.fill.\nAlso, the shape is known only at graph execution time. And when it is known, it is fully specified.\nWhich is why I think having Zeros.create() use a Shape argument isn't quite right. The type of the shape argument should be Output<Integer> or Output<Float>.\nSomething like:\npublic class Zeros<T> implements Op, Operand<T> {\n  public static <T> Zeros<T> create(Scope scope, Class<T> type, Output<Integer> shape) {\n    return create(scope, type, shape);\n  }\n\n  public static <T> Zeros<T> create(Scope scope, Class<T> type, Output<Long> shape) {\n    return create(scope, type, shape);\n  }\n\n  private static <T, U> Zeros<T> create(Scope scope, Class<T> type, Output<U> shape) {\n    Output<T> zero = Constant.create(scope, type, new long[]{}, ByteBuffer.allocate(DataType.fromClass(type).byteSize());\n     return Fill<T>(scope, type, shape, zero);\n   }\n}    \nAnd callers would do something like:\nOutput<Float> zeroMatrix = ops.zeros(ops.constant(new long[]{2, 2}));\nLet me know if that makes sense, or if I'm misunderstanding.", "in_reply_to_id": 205214147}