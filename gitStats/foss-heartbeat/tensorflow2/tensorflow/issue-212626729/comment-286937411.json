{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/286937411", "html_url": "https://github.com/tensorflow/tensorflow/issues/8182#issuecomment-286937411", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8182", "id": 286937411, "node_id": "MDEyOklzc3VlQ29tbWVudDI4NjkzNzQxMQ==", "user": {"login": "nOkuda", "id": 1238620, "node_id": "MDQ6VXNlcjEyMzg2MjA=", "avatar_url": "https://avatars3.githubusercontent.com/u/1238620?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nOkuda", "html_url": "https://github.com/nOkuda", "followers_url": "https://api.github.com/users/nOkuda/followers", "following_url": "https://api.github.com/users/nOkuda/following{/other_user}", "gists_url": "https://api.github.com/users/nOkuda/gists{/gist_id}", "starred_url": "https://api.github.com/users/nOkuda/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nOkuda/subscriptions", "organizations_url": "https://api.github.com/users/nOkuda/orgs", "repos_url": "https://api.github.com/users/nOkuda/repos", "events_url": "https://api.github.com/users/nOkuda/events{/privacy}", "received_events_url": "https://api.github.com/users/nOkuda/received_events", "type": "User", "site_admin": false}, "created_at": "2017-03-16T02:12:45Z", "updated_at": "2017-03-29T18:17:17Z", "author_association": "NONE", "body_html": "<p>I'm expecting <code>bucket_by_sequence_length</code> to dequeue all buckets once it's reached the end of the queue that's feeding into it.  Instead, it does not.</p>\n<p>If what I'm expecting is not intended behavior, how do I dequeue the buckets once the feeding queue is empty?</p>\n<p>To address your two points:  I am calling <code>coord.request_stop()</code> when I catch the <code>OutOfRangeError</code> exception.  Also, the <code>OutOfRangeError</code> exception is coming from the top queue built by <code>bucket_by_sequence_length</code>, not from the <code>string_input_producer</code>.  To see the <code>OutOfRangeError</code> behavior I have described, add a <code>print(err.node_def.name)</code> in the <code>except</code> block.</p>\n<p>I accept that the top queue of <code>bucket_by_sequence_length</code> may be passing up the <code>OutOfRangeError</code> from <code>string_input_producer</code>; but if that is the case, then I would expect <code>err.node_def.name</code> to be related to the dequeue from the <code>string_input_producer</code>.  Instead, the output name is <code>batch_dequeue/bucket/dequeue_top</code>.</p>\n<p>I'm also recalling reading that <code>OutOfRangeError</code>s do not come from queues dequeueing into another queue.  I can't remember where I read that, though.  Something about threads sleeping when there's nothing left to dequeue.  Maybe it was in the <a href=\"https://www.tensorflow.org/programmers_guide/threading_and_queues\" rel=\"nofollow\">Threading and Queueing</a> instructions?  If doesn't work like that, I have no idea how <code>bucket_by_sequence_length</code> would work in the lazy manner it purports to in the <a href=\"https://www.tensorflow.org/versions/master/api_docs/python/contrib.training/bucketing#bucket_by_sequence_length\" rel=\"nofollow\">documentation</a>.</p>", "body_text": "I'm expecting bucket_by_sequence_length to dequeue all buckets once it's reached the end of the queue that's feeding into it.  Instead, it does not.\nIf what I'm expecting is not intended behavior, how do I dequeue the buckets once the feeding queue is empty?\nTo address your two points:  I am calling coord.request_stop() when I catch the OutOfRangeError exception.  Also, the OutOfRangeError exception is coming from the top queue built by bucket_by_sequence_length, not from the string_input_producer.  To see the OutOfRangeError behavior I have described, add a print(err.node_def.name) in the except block.\nI accept that the top queue of bucket_by_sequence_length may be passing up the OutOfRangeError from string_input_producer; but if that is the case, then I would expect err.node_def.name to be related to the dequeue from the string_input_producer.  Instead, the output name is batch_dequeue/bucket/dequeue_top.\nI'm also recalling reading that OutOfRangeErrors do not come from queues dequeueing into another queue.  I can't remember where I read that, though.  Something about threads sleeping when there's nothing left to dequeue.  Maybe it was in the Threading and Queueing instructions?  If doesn't work like that, I have no idea how bucket_by_sequence_length would work in the lazy manner it purports to in the documentation.", "body": "I'm expecting `bucket_by_sequence_length` to dequeue all buckets once it's reached the end of the queue that's feeding into it.  Instead, it does not.\r\n\r\nIf what I'm expecting is not intended behavior, how do I dequeue the buckets once the feeding queue is empty?\r\n\r\nTo address your two points:  I am calling `coord.request_stop()` when I catch the `OutOfRangeError` exception.  Also, the `OutOfRangeError` exception is coming from the top queue built by `bucket_by_sequence_length`, not from the `string_input_producer`.  To see the `OutOfRangeError` behavior I have described, add a `print(err.node_def.name)` in the `except` block.\r\n\r\nI accept that the top queue of `bucket_by_sequence_length` may be passing up the `OutOfRangeError` from `string_input_producer`; but if that is the case, then I would expect `err.node_def.name` to be related to the dequeue from the `string_input_producer`.  Instead, the output name is `batch_dequeue/bucket/dequeue_top`.\r\n\r\nI'm also recalling reading that `OutOfRangeError`s do not come from queues dequeueing into another queue.  I can't remember where I read that, though.  Something about threads sleeping when there's nothing left to dequeue.  Maybe it was in the [Threading and Queueing](https://www.tensorflow.org/programmers_guide/threading_and_queues) instructions?  If doesn't work like that, I have no idea how `bucket_by_sequence_length` would work in the lazy manner it purports to in the [documentation](https://www.tensorflow.org/versions/master/api_docs/python/contrib.training/bucketing#bucket_by_sequence_length)."}