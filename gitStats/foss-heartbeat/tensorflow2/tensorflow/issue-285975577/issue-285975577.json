{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/15847", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/15847/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/15847/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/15847/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/15847", "id": 285975577, "node_id": "MDU6SXNzdWUyODU5NzU1Nzc=", "number": 15847, "title": "Reinitializing an iterator throws an OutOfRangeError when using a MonitoredSession with NanTensorHook", "user": {"login": "Hackempluf", "id": 8088862, "node_id": "MDQ6VXNlcjgwODg4NjI=", "avatar_url": "https://avatars1.githubusercontent.com/u/8088862?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Hackempluf", "html_url": "https://github.com/Hackempluf", "followers_url": "https://api.github.com/users/Hackempluf/followers", "following_url": "https://api.github.com/users/Hackempluf/following{/other_user}", "gists_url": "https://api.github.com/users/Hackempluf/gists{/gist_id}", "starred_url": "https://api.github.com/users/Hackempluf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Hackempluf/subscriptions", "organizations_url": "https://api.github.com/users/Hackempluf/orgs", "repos_url": "https://api.github.com/users/Hackempluf/repos", "events_url": "https://api.github.com/users/Hackempluf/events{/privacy}", "received_events_url": "https://api.github.com/users/Hackempluf/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 299643928, "node_id": "MDU6TGFiZWwyOTk2NDM5Mjg=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:contributions%20welcome", "name": "stat:contributions welcome", "color": "f4b400", "default": false}, {"id": 473173272, "node_id": "MDU6TGFiZWw0NzMxNzMyNzI=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:feature", "name": "type:feature", "color": "159b2e", "default": false}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2018-01-04T12:47:10Z", "updated_at": "2018-01-11T18:39:16Z", "closed_at": null, "author_association": "NONE", "body_html": "<h3>System information</h3>\n<ul>\n<li><strong>Have I written custom code (as opposed to using a stock example script provided in TensorFlow)</strong>:<br>\nyes</li>\n<li><strong>OS Platform and Distribution (e.g., Linux Ubuntu 16.04)</strong>:<br>\nWindows 10</li>\n<li><strong>TensorFlow installed from (source or binary)</strong>:<br>\nbinary</li>\n<li><strong>TensorFlow version (use command below)</strong>:<br>\n1.4.0</li>\n<li><strong>Python version</strong>:<br>\n3.5.4</li>\n<li><strong>Bazel version (if compiling from source)</strong>:</li>\n<li><strong>GCC/Compiler version (if compiling from source)</strong>:</li>\n<li><strong>CUDA/cuDNN version</strong>:<br>\nedit: none, using CPU only</li>\n<li><strong>GPU model and memory</strong>:</li>\n<li><strong>Exact command to reproduce</strong>:<br>\nSee below under source code</li>\n</ul>\n<h3>Describe the problem</h3>\n<p>When using a Monitored Training Session with a NanTensorHook and an Iterator from a Dataset, reinitializing the Iterator causes an OutOfRangeError.<br>\nThis is likely because the NanTensorHook adds the loss value to the SessionRunArgs, but the evaluation of the loss-value then fails since no more data are available from the iterator.</p>\n<p>Ideally, there should be a way to reinitialize the iterator without the hooks beeing executed.</p>\n<h3>Source code / logs</h3>\n<p>example code to reproduce the problem</p>\n<pre><code>import tensorflow as tf\n\ndataset = tf.data.Dataset.range(100)\ndataset = dataset.map(lambda x: (0, x))\ndataset = dataset.batch(64)\niterator = dataset.make_initializable_iterator()\n(label, element) = iterator.get_next()\n\n# pseudo loss for the NanTensorHook\nloss = tf.reduce_mean(1 - label)\n\nglobal_step = tf.train.get_or_create_global_step()\nscaffold = tf.train.Scaffold(local_init_op=iterator.initializer)\n\nwith tf.train.MonitoredTrainingSession(\n        scaffold=scaffold,\n        hooks=[tf.train.NanTensorHook(loss_tensor=loss)]) as sess:\n    # Compute for 5 epochs.\n    for epoch in range(5):\n        print('epoch: ' + str(epoch))\n        try:\n            while not sess.should_stop():\n                sess.run(element)\n        except tf.errors.OutOfRangeError:\n            print('end')\n\n        if sess.should_stop():\n            break\n\n        # the following line silently fails, since an OutOfRangeError is thrown\n        sess.run(iterator.initializer)\n</code></pre>\n<p>Removing the NanTensorHook or placing the <code>sess.run(iterator.initializer)</code> call inside an try-except-statement provides a workaround for this problem</p>\n<pre><code>        try:\n            sess.run(iterator.initializer)\n        except tf.errors.OutOfRangeError:\n            print('Out of range errors occurs')\n</code></pre>", "body_text": "System information\n\nHave I written custom code (as opposed to using a stock example script provided in TensorFlow):\nyes\nOS Platform and Distribution (e.g., Linux Ubuntu 16.04):\nWindows 10\nTensorFlow installed from (source or binary):\nbinary\nTensorFlow version (use command below):\n1.4.0\nPython version:\n3.5.4\nBazel version (if compiling from source):\nGCC/Compiler version (if compiling from source):\nCUDA/cuDNN version:\nedit: none, using CPU only\nGPU model and memory:\nExact command to reproduce:\nSee below under source code\n\nDescribe the problem\nWhen using a Monitored Training Session with a NanTensorHook and an Iterator from a Dataset, reinitializing the Iterator causes an OutOfRangeError.\nThis is likely because the NanTensorHook adds the loss value to the SessionRunArgs, but the evaluation of the loss-value then fails since no more data are available from the iterator.\nIdeally, there should be a way to reinitialize the iterator without the hooks beeing executed.\nSource code / logs\nexample code to reproduce the problem\nimport tensorflow as tf\n\ndataset = tf.data.Dataset.range(100)\ndataset = dataset.map(lambda x: (0, x))\ndataset = dataset.batch(64)\niterator = dataset.make_initializable_iterator()\n(label, element) = iterator.get_next()\n\n# pseudo loss for the NanTensorHook\nloss = tf.reduce_mean(1 - label)\n\nglobal_step = tf.train.get_or_create_global_step()\nscaffold = tf.train.Scaffold(local_init_op=iterator.initializer)\n\nwith tf.train.MonitoredTrainingSession(\n        scaffold=scaffold,\n        hooks=[tf.train.NanTensorHook(loss_tensor=loss)]) as sess:\n    # Compute for 5 epochs.\n    for epoch in range(5):\n        print('epoch: ' + str(epoch))\n        try:\n            while not sess.should_stop():\n                sess.run(element)\n        except tf.errors.OutOfRangeError:\n            print('end')\n\n        if sess.should_stop():\n            break\n\n        # the following line silently fails, since an OutOfRangeError is thrown\n        sess.run(iterator.initializer)\n\nRemoving the NanTensorHook or placing the sess.run(iterator.initializer) call inside an try-except-statement provides a workaround for this problem\n        try:\n            sess.run(iterator.initializer)\n        except tf.errors.OutOfRangeError:\n            print('Out of range errors occurs')", "body": "### System information\r\n- **Have I written custom code (as opposed to using a stock example script provided in TensorFlow)**:\r\nyes\r\n- **OS Platform and Distribution (e.g., Linux Ubuntu 16.04)**: \r\nWindows 10\r\n- **TensorFlow installed from (source or binary)**:\r\nbinary\r\n- **TensorFlow version (use command below)**:\r\n1.4.0\r\n- **Python version**: \r\n3.5.4\r\n- **Bazel version (if compiling from source)**:\r\n- **GCC/Compiler version (if compiling from source)**:\r\n- **CUDA/cuDNN version**:\r\nedit: none, using CPU only\r\n- **GPU model and memory**:\r\n- **Exact command to reproduce**:\r\nSee below under source code\r\n\r\n### Describe the problem\r\nWhen using a Monitored Training Session with a NanTensorHook and an Iterator from a Dataset, reinitializing the Iterator causes an OutOfRangeError. \r\nThis is likely because the NanTensorHook adds the loss value to the SessionRunArgs, but the evaluation of the loss-value then fails since no more data are available from the iterator.\r\n\r\nIdeally, there should be a way to reinitialize the iterator without the hooks beeing executed.\r\n\r\n### Source code / logs\r\nexample code to reproduce the problem\r\n```\r\nimport tensorflow as tf\r\n\r\ndataset = tf.data.Dataset.range(100)\r\ndataset = dataset.map(lambda x: (0, x))\r\ndataset = dataset.batch(64)\r\niterator = dataset.make_initializable_iterator()\r\n(label, element) = iterator.get_next()\r\n\r\n# pseudo loss for the NanTensorHook\r\nloss = tf.reduce_mean(1 - label)\r\n\r\nglobal_step = tf.train.get_or_create_global_step()\r\nscaffold = tf.train.Scaffold(local_init_op=iterator.initializer)\r\n\r\nwith tf.train.MonitoredTrainingSession(\r\n        scaffold=scaffold,\r\n        hooks=[tf.train.NanTensorHook(loss_tensor=loss)]) as sess:\r\n    # Compute for 5 epochs.\r\n    for epoch in range(5):\r\n        print('epoch: ' + str(epoch))\r\n        try:\r\n            while not sess.should_stop():\r\n                sess.run(element)\r\n        except tf.errors.OutOfRangeError:\r\n            print('end')\r\n\r\n        if sess.should_stop():\r\n            break\r\n\r\n        # the following line silently fails, since an OutOfRangeError is thrown\r\n        sess.run(iterator.initializer)\r\n```\r\nRemoving the NanTensorHook or placing the `sess.run(iterator.initializer)` call inside an try-except-statement provides a workaround for this problem\r\n```\r\n        try:\r\n            sess.run(iterator.initializer)\r\n        except tf.errors.OutOfRangeError:\r\n            print('Out of range errors occurs')\r\n```\r\n\r\n  "}