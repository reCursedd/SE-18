{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2603", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2603/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2603/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2603/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/2603", "id": 157844864, "node_id": "MDU6SXNzdWUxNTc4NDQ4NjQ=", "number": 2603, "title": "Feature request: Tensorboard streaming", "user": {"login": "SpencerC", "id": 817672, "node_id": "MDQ6VXNlcjgxNzY3Mg==", "avatar_url": "https://avatars3.githubusercontent.com/u/817672?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SpencerC", "html_url": "https://github.com/SpencerC", "followers_url": "https://api.github.com/users/SpencerC/followers", "following_url": "https://api.github.com/users/SpencerC/following{/other_user}", "gists_url": "https://api.github.com/users/SpencerC/gists{/gist_id}", "starred_url": "https://api.github.com/users/SpencerC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SpencerC/subscriptions", "organizations_url": "https://api.github.com/users/SpencerC/orgs", "repos_url": "https://api.github.com/users/SpencerC/repos", "events_url": "https://api.github.com/users/SpencerC/events{/privacy}", "received_events_url": "https://api.github.com/users/SpencerC/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 284285184, "node_id": "MDU6TGFiZWwyODQyODUxODQ=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/comp:tensorboard", "name": "comp:tensorboard", "color": "0052cc", "default": false}, {"id": 473173272, "node_id": "MDU6TGFiZWw0NzMxNzMyNzI=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:feature", "name": "type:feature", "color": "159b2e", "default": false}], "state": "closed", "locked": false, "assignee": {"login": "jart", "id": 49262, "node_id": "MDQ6VXNlcjQ5MjYy", "avatar_url": "https://avatars1.githubusercontent.com/u/49262?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jart", "html_url": "https://github.com/jart", "followers_url": "https://api.github.com/users/jart/followers", "following_url": "https://api.github.com/users/jart/following{/other_user}", "gists_url": "https://api.github.com/users/jart/gists{/gist_id}", "starred_url": "https://api.github.com/users/jart/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jart/subscriptions", "organizations_url": "https://api.github.com/users/jart/orgs", "repos_url": "https://api.github.com/users/jart/repos", "events_url": "https://api.github.com/users/jart/events{/privacy}", "received_events_url": "https://api.github.com/users/jart/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "jart", "id": 49262, "node_id": "MDQ6VXNlcjQ5MjYy", "avatar_url": "https://avatars1.githubusercontent.com/u/49262?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jart", "html_url": "https://github.com/jart", "followers_url": "https://api.github.com/users/jart/followers", "following_url": "https://api.github.com/users/jart/following{/other_user}", "gists_url": "https://api.github.com/users/jart/gists{/gist_id}", "starred_url": "https://api.github.com/users/jart/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jart/subscriptions", "organizations_url": "https://api.github.com/users/jart/orgs", "repos_url": "https://api.github.com/users/jart/repos", "events_url": "https://api.github.com/users/jart/events{/privacy}", "received_events_url": "https://api.github.com/users/jart/received_events", "type": "User", "site_admin": false}, {"login": "decentralion", "id": 1400023, "node_id": "MDQ6VXNlcjE0MDAwMjM=", "avatar_url": "https://avatars2.githubusercontent.com/u/1400023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/decentralion", "html_url": "https://github.com/decentralion", "followers_url": "https://api.github.com/users/decentralion/followers", "following_url": "https://api.github.com/users/decentralion/following{/other_user}", "gists_url": "https://api.github.com/users/decentralion/gists{/gist_id}", "starred_url": "https://api.github.com/users/decentralion/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/decentralion/subscriptions", "organizations_url": "https://api.github.com/users/decentralion/orgs", "repos_url": "https://api.github.com/users/decentralion/repos", "events_url": "https://api.github.com/users/decentralion/events{/privacy}", "received_events_url": "https://api.github.com/users/decentralion/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 7, "created_at": "2016-06-01T07:55:32Z", "updated_at": "2017-06-16T19:32:26Z", "closed_at": "2017-06-16T19:32:26Z", "author_association": "NONE", "body_html": "<p>The new Tensorboard refresh button looks great, and will certainly be a bit more civilized than rapidly swapping the horizontal axis view to update the data. :)</p>\n<p>But what if Tensorboard could be optionally updated in real time, whenever a summary writer was flushed? I've written systems before where past data is loaded along with the page, and new data is added continuously via a web socket. Would this work in Tensorboard's current architecture?</p>\n<p>If my understanding is correct, Tensorboard currently updates itself every 120 seconds by reading the event files in the log directory. Could Tensorboard also open a local socket and bounce summary updates from a connected Tensorflow process to websocket clients?</p>\n<p>I was thinking of hacking a streaming system together on my branch, but I figured I should reach out first to see if this is already in the roadmap. If it isn't, is this feature something you might like to merge if I can get it to work robustly?</p>", "body_text": "The new Tensorboard refresh button looks great, and will certainly be a bit more civilized than rapidly swapping the horizontal axis view to update the data. :)\nBut what if Tensorboard could be optionally updated in real time, whenever a summary writer was flushed? I've written systems before where past data is loaded along with the page, and new data is added continuously via a web socket. Would this work in Tensorboard's current architecture?\nIf my understanding is correct, Tensorboard currently updates itself every 120 seconds by reading the event files in the log directory. Could Tensorboard also open a local socket and bounce summary updates from a connected Tensorflow process to websocket clients?\nI was thinking of hacking a streaming system together on my branch, but I figured I should reach out first to see if this is already in the roadmap. If it isn't, is this feature something you might like to merge if I can get it to work robustly?", "body": "The new Tensorboard refresh button looks great, and will certainly be a bit more civilized than rapidly swapping the horizontal axis view to update the data. :)\n\nBut what if Tensorboard could be optionally updated in real time, whenever a summary writer was flushed? I've written systems before where past data is loaded along with the page, and new data is added continuously via a web socket. Would this work in Tensorboard's current architecture?\n\nIf my understanding is correct, Tensorboard currently updates itself every 120 seconds by reading the event files in the log directory. Could Tensorboard also open a local socket and bounce summary updates from a connected Tensorflow process to websocket clients?\n\nI was thinking of hacking a streaming system together on my branch, but I figured I should reach out first to see if this is already in the roadmap. If it isn't, is this feature something you might like to merge if I can get it to work robustly?\n"}