{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/377232948", "html_url": "https://github.com/tensorflow/tensorflow/issues/17794#issuecomment-377232948", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/17794", "id": 377232948, "node_id": "MDEyOklzc3VlQ29tbWVudDM3NzIzMjk0OA==", "user": {"login": "SivamPillai", "id": 6624314, "node_id": "MDQ6VXNlcjY2MjQzMTQ=", "avatar_url": "https://avatars3.githubusercontent.com/u/6624314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SivamPillai", "html_url": "https://github.com/SivamPillai", "followers_url": "https://api.github.com/users/SivamPillai/followers", "following_url": "https://api.github.com/users/SivamPillai/following{/other_user}", "gists_url": "https://api.github.com/users/SivamPillai/gists{/gist_id}", "starred_url": "https://api.github.com/users/SivamPillai/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SivamPillai/subscriptions", "organizations_url": "https://api.github.com/users/SivamPillai/orgs", "repos_url": "https://api.github.com/users/SivamPillai/repos", "events_url": "https://api.github.com/users/SivamPillai/events{/privacy}", "received_events_url": "https://api.github.com/users/SivamPillai/received_events", "type": "User", "site_admin": false}, "created_at": "2018-03-29T13:21:25Z", "updated_at": "2018-03-29T13:21:25Z", "author_association": "NONE", "body_html": "<p>The problem here seems to be with the differentiability of the loss function. In your custom loss function, you use <code>K.cast</code> which is not differentiable and hence produces <code>None</code> values at the output.</p>\n<p>You may want to replace that with a different function or operation in order to use <code>roc_auc_score</code> as a loss function.</p>\n<p>If you can make sure that the values of <code>y_true</code> are either 1 or 0 before they are used in this function (Which I believe should be possible since it is the ground truth labels) here's a small hack to perform the boolean_mask operation without using <code>K.cast</code>.</p>\n<blockquote>\n<p>pos = tf.boolean_mask(y_pred, K.cast(y_true, tf.bool))<br>\nneg = tf.boolean_mask(y_pred, ~K.cast(y_true, tf.bool))</p>\n</blockquote>\n<p>replace with</p>\n<blockquote>\n<p>pos = tf.boolean_mask(y_pred, y_true)<br>\nneg = tf.boolean_mask(y_pred, (y_true-1)*(-1))</p>\n</blockquote>\n<p>I have used a similar technique in the past for numpy arrays and so should also work for tensors!</p>\n<p>Good luck!</p>\n<p>SP</p>", "body_text": "The problem here seems to be with the differentiability of the loss function. In your custom loss function, you use K.cast which is not differentiable and hence produces None values at the output.\nYou may want to replace that with a different function or operation in order to use roc_auc_score as a loss function.\nIf you can make sure that the values of y_true are either 1 or 0 before they are used in this function (Which I believe should be possible since it is the ground truth labels) here's a small hack to perform the boolean_mask operation without using K.cast.\n\npos = tf.boolean_mask(y_pred, K.cast(y_true, tf.bool))\nneg = tf.boolean_mask(y_pred, ~K.cast(y_true, tf.bool))\n\nreplace with\n\npos = tf.boolean_mask(y_pred, y_true)\nneg = tf.boolean_mask(y_pred, (y_true-1)*(-1))\n\nI have used a similar technique in the past for numpy arrays and so should also work for tensors!\nGood luck!\nSP", "body": "The problem here seems to be with the differentiability of the loss function. In your custom loss function, you use `K.cast` which is not differentiable and hence produces `None` values at the output.\r\n\r\nYou may want to replace that with a different function or operation in order to use `roc_auc_score` as a loss function.\r\n\r\nIf you can make sure that the values of `y_true` are either 1 or 0 before they are used in this function (Which I believe should be possible since it is the ground truth labels) here's a small hack to perform the boolean_mask operation without using `K.cast`.\r\n\r\n> pos = tf.boolean_mask(y_pred, K.cast(y_true, tf.bool))\r\n    neg = tf.boolean_mask(y_pred, ~K.cast(y_true, tf.bool))\r\n\r\nreplace with\r\n\r\n> pos = tf.boolean_mask(y_pred, y_true)\r\n   neg = tf.boolean_mask(y_pred, (y_true-1)*(-1))\r\n\r\nI have used a similar technique in the past for numpy arrays and so should also work for tensors!\r\n\r\nGood luck!\r\n\r\nSP"}