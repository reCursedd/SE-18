{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/329820157", "html_url": "https://github.com/tensorflow/tensorflow/issues/12453#issuecomment-329820157", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/12453", "id": 329820157, "node_id": "MDEyOklzc3VlQ29tbWVudDMyOTgyMDE1Nw==", "user": {"login": "Threynaud", "id": 13488732, "node_id": "MDQ6VXNlcjEzNDg4NzMy", "avatar_url": "https://avatars1.githubusercontent.com/u/13488732?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Threynaud", "html_url": "https://github.com/Threynaud", "followers_url": "https://api.github.com/users/Threynaud/followers", "following_url": "https://api.github.com/users/Threynaud/following{/other_user}", "gists_url": "https://api.github.com/users/Threynaud/gists{/gist_id}", "starred_url": "https://api.github.com/users/Threynaud/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Threynaud/subscriptions", "organizations_url": "https://api.github.com/users/Threynaud/orgs", "repos_url": "https://api.github.com/users/Threynaud/repos", "events_url": "https://api.github.com/users/Threynaud/events{/privacy}", "received_events_url": "https://api.github.com/users/Threynaud/received_events", "type": "User", "site_admin": false}, "created_at": "2017-09-15T15:43:09Z", "updated_at": "2017-09-15T17:24:22Z", "author_association": "NONE", "body_html": "<p>You're right, I misunderstood what you meant by \"loss components\" my bad..<br>\nDoes the following looks ok to you:</p>\n<pre><code>target_skills = tf.cast(labels['skills'], tf.float32)\n\n# Compute the mask\nmask_skills = tf.count_nonzero(target_skills, 1)\nmask_skills = tf.cast(mask_skills, tf.bool)\n\n#Compute all the losses components\nlosses_skills = tf.losses.sigmoid_cross_entropy(\n    target_skills, logits_skills)\n\n# Apply the mask\nmasked_losses = tf.boolean_mask(losses_skills, mask_skills)\n\n# Reduce\nloss_skills = tf.reduce_sum(masked_losses)\n</code></pre>\n<p>and that for each loss corresponding to each head of the network. Then sum all the masked losses and apply the optimizer on the resulting loss.</p>\n<p>I have troubles understanding how the optimizer handles the mask but it is because of my limited knowledge about gradient computation in tf...</p>\n<p>EDIT: I found out that I might need to set the <code>reduction</code> param of the loss to 'none' to  apply the mask...</p>", "body_text": "You're right, I misunderstood what you meant by \"loss components\" my bad..\nDoes the following looks ok to you:\ntarget_skills = tf.cast(labels['skills'], tf.float32)\n\n# Compute the mask\nmask_skills = tf.count_nonzero(target_skills, 1)\nmask_skills = tf.cast(mask_skills, tf.bool)\n\n#Compute all the losses components\nlosses_skills = tf.losses.sigmoid_cross_entropy(\n    target_skills, logits_skills)\n\n# Apply the mask\nmasked_losses = tf.boolean_mask(losses_skills, mask_skills)\n\n# Reduce\nloss_skills = tf.reduce_sum(masked_losses)\n\nand that for each loss corresponding to each head of the network. Then sum all the masked losses and apply the optimizer on the resulting loss.\nI have troubles understanding how the optimizer handles the mask but it is because of my limited knowledge about gradient computation in tf...\nEDIT: I found out that I might need to set the reduction param of the loss to 'none' to  apply the mask...", "body": "You're right, I misunderstood what you meant by \"loss components\" my bad..\r\nDoes the following looks ok to you:\r\n```\r\ntarget_skills = tf.cast(labels['skills'], tf.float32)\r\n\r\n# Compute the mask\r\nmask_skills = tf.count_nonzero(target_skills, 1)\r\nmask_skills = tf.cast(mask_skills, tf.bool)\r\n\r\n#Compute all the losses components\r\nlosses_skills = tf.losses.sigmoid_cross_entropy(\r\n    target_skills, logits_skills)\r\n\r\n# Apply the mask\r\nmasked_losses = tf.boolean_mask(losses_skills, mask_skills)\r\n\r\n# Reduce\r\nloss_skills = tf.reduce_sum(masked_losses)\r\n``` \r\n and that for each loss corresponding to each head of the network. Then sum all the masked losses and apply the optimizer on the resulting loss.\r\n\r\nI have troubles understanding how the optimizer handles the mask but it is because of my limited knowledge about gradient computation in tf...\r\n\r\nEDIT: I found out that I might need to set the `reduction` param of the loss to 'none' to  apply the mask..."}