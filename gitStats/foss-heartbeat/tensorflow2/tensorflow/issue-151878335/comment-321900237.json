{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/321900237", "html_url": "https://github.com/tensorflow/tensorflow/issues/2169#issuecomment-321900237", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2169", "id": 321900237, "node_id": "MDEyOklzc3VlQ29tbWVudDMyMTkwMDIzNw==", "user": {"login": "MilesZhao", "id": 15339939, "node_id": "MDQ6VXNlcjE1MzM5OTM5", "avatar_url": "https://avatars0.githubusercontent.com/u/15339939?v=4", "gravatar_id": "", "url": "https://api.github.com/users/MilesZhao", "html_url": "https://github.com/MilesZhao", "followers_url": "https://api.github.com/users/MilesZhao/followers", "following_url": "https://api.github.com/users/MilesZhao/following{/other_user}", "gists_url": "https://api.github.com/users/MilesZhao/gists{/gist_id}", "starred_url": "https://api.github.com/users/MilesZhao/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/MilesZhao/subscriptions", "organizations_url": "https://api.github.com/users/MilesZhao/orgs", "repos_url": "https://api.github.com/users/MilesZhao/repos", "events_url": "https://api.github.com/users/MilesZhao/events{/privacy}", "received_events_url": "https://api.github.com/users/MilesZhao/received_events", "type": "User", "site_admin": false}, "created_at": "2017-08-11T19:33:50Z", "updated_at": "2017-08-11T19:33:50Z", "author_association": "NONE", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=11971499\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/isaacgerg\">@isaacgerg</a>  I think we can use tf.gradients to realize this on CPUs. Firstly we do gradients of max-pooled results with respect to feature maps, which helps us find the locations of maximum values. Secondly, according to the locations, we can do up-pooling stuff, a.k.a re-construct something. This is a little tricky. In our case, we only have a maximum value for each feature map. SO, the \"where it is\" information is straightforward and  we can use this to re-construct partial image.</p>", "body_text": "@isaacgerg  I think we can use tf.gradients to realize this on CPUs. Firstly we do gradients of max-pooled results with respect to feature maps, which helps us find the locations of maximum values. Secondly, according to the locations, we can do up-pooling stuff, a.k.a re-construct something. This is a little tricky. In our case, we only have a maximum value for each feature map. SO, the \"where it is\" information is straightforward and  we can use this to re-construct partial image.", "body": "@isaacgerg  I think we can use tf.gradients to realize this on CPUs. Firstly we do gradients of max-pooled results with respect to feature maps, which helps us find the locations of maximum values. Secondly, according to the locations, we can do up-pooling stuff, a.k.a re-construct something. This is a little tricky. In our case, we only have a maximum value for each feature map. SO, the \"where it is\" information is straightforward and  we can use this to re-construct partial image."}