{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/235985126", "html_url": "https://github.com/tensorflow/tensorflow/issues/2169#issuecomment-235985126", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2169", "id": 235985126, "node_id": "MDEyOklzc3VlQ29tbWVudDIzNTk4NTEyNg==", "user": {"login": "wenouyang", "id": 5430158, "node_id": "MDQ6VXNlcjU0MzAxNTg=", "avatar_url": "https://avatars0.githubusercontent.com/u/5430158?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wenouyang", "html_url": "https://github.com/wenouyang", "followers_url": "https://api.github.com/users/wenouyang/followers", "following_url": "https://api.github.com/users/wenouyang/following{/other_user}", "gists_url": "https://api.github.com/users/wenouyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/wenouyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wenouyang/subscriptions", "organizations_url": "https://api.github.com/users/wenouyang/orgs", "repos_url": "https://api.github.com/users/wenouyang/repos", "events_url": "https://api.github.com/users/wenouyang/events{/privacy}", "received_events_url": "https://api.github.com/users/wenouyang/received_events", "type": "User", "site_admin": false}, "created_at": "2016-07-28T18:35:21Z", "updated_at": "2016-07-28T18:37:53Z", "author_association": "NONE", "body_html": "<p>In the Tensorflow implementation (<a href=\"https://github.com/MarvinTeichmann/tensorflow-fcn/blob/master/fcn32_vgg.py\">https://github.com/MarvinTeichmann/tensorflow-fcn/blob/master/fcn32_vgg.py</a>) of fully convolutional model (<a href=\"https://people.eecs.berkeley.edu/~jonlong/long_shelhamer_fcn.pdf\" rel=\"nofollow\">https://people.eecs.berkeley.edu/~jonlong/long_shelhamer_fcn.pdf</a>), author define a function of</p>\n<pre><code>``def _upscore_layer(self, bottom, shape,\n                   num_classes, name, debug,\n                   ksize=4, stride=2):\n       strides = [1, stride, stride, 1]\n        with tf.variable_scope(name):\n        in_features = bottom.get_shape()[3].value\n\n        if shape is None:\n            # Compute shape out of Bottom\n            in_shape = tf.shape(bottom)\n\n            h = ((in_shape[1] - 1) * stride) + 1\n            w = ((in_shape[2] - 1) * stride) + 1\n            new_shape = [in_shape[0], h, w, num_classes]\n        else:\n            new_shape = [shape[0], shape[1], shape[2], num_classes]\n        output_shape = tf.pack(new_shape)\n\n        logging.debug(\"Layer: %s, Fan-in: %d\" % (name, in_features))\n        f_shape = [ksize, ksize, num_classes, in_features]\n\n        # create\n        num_input = ksize * ksize * in_features / stride\n        stddev = (2 / num_input)**0.5\n\n        weights = self.get_deconv_filter(f_shape)\n        deconv = tf.nn.conv2d_transpose(bottom, weights, output_shape,\n                                        strides=strides, padding='SAME')\n\n        if debug:\n            deconv = tf.Print(deconv, [tf.shape(deconv)],\n                              message='Shape of %s' % name,\n                              summarize=4, first_n=1)\n\n    _activation_summary(deconv)\n    return deconv\n</code></pre>\n<p>Looks like author just uses tf.nn.conv2d_transpose to do the upsampling. Is my understanding correct?</p>", "body_text": "In the Tensorflow implementation (https://github.com/MarvinTeichmann/tensorflow-fcn/blob/master/fcn32_vgg.py) of fully convolutional model (https://people.eecs.berkeley.edu/~jonlong/long_shelhamer_fcn.pdf), author define a function of\n``def _upscore_layer(self, bottom, shape,\n                   num_classes, name, debug,\n                   ksize=4, stride=2):\n       strides = [1, stride, stride, 1]\n        with tf.variable_scope(name):\n        in_features = bottom.get_shape()[3].value\n\n        if shape is None:\n            # Compute shape out of Bottom\n            in_shape = tf.shape(bottom)\n\n            h = ((in_shape[1] - 1) * stride) + 1\n            w = ((in_shape[2] - 1) * stride) + 1\n            new_shape = [in_shape[0], h, w, num_classes]\n        else:\n            new_shape = [shape[0], shape[1], shape[2], num_classes]\n        output_shape = tf.pack(new_shape)\n\n        logging.debug(\"Layer: %s, Fan-in: %d\" % (name, in_features))\n        f_shape = [ksize, ksize, num_classes, in_features]\n\n        # create\n        num_input = ksize * ksize * in_features / stride\n        stddev = (2 / num_input)**0.5\n\n        weights = self.get_deconv_filter(f_shape)\n        deconv = tf.nn.conv2d_transpose(bottom, weights, output_shape,\n                                        strides=strides, padding='SAME')\n\n        if debug:\n            deconv = tf.Print(deconv, [tf.shape(deconv)],\n                              message='Shape of %s' % name,\n                              summarize=4, first_n=1)\n\n    _activation_summary(deconv)\n    return deconv\n\nLooks like author just uses tf.nn.conv2d_transpose to do the upsampling. Is my understanding correct?", "body": "In the Tensorflow implementation (https://github.com/MarvinTeichmann/tensorflow-fcn/blob/master/fcn32_vgg.py) of fully convolutional model (https://people.eecs.berkeley.edu/~jonlong/long_shelhamer_fcn.pdf), author define a function of \n\n```\n``def _upscore_layer(self, bottom, shape,\n                   num_classes, name, debug,\n                   ksize=4, stride=2):\n       strides = [1, stride, stride, 1]\n        with tf.variable_scope(name):\n        in_features = bottom.get_shape()[3].value\n\n        if shape is None:\n            # Compute shape out of Bottom\n            in_shape = tf.shape(bottom)\n\n            h = ((in_shape[1] - 1) * stride) + 1\n            w = ((in_shape[2] - 1) * stride) + 1\n            new_shape = [in_shape[0], h, w, num_classes]\n        else:\n            new_shape = [shape[0], shape[1], shape[2], num_classes]\n        output_shape = tf.pack(new_shape)\n\n        logging.debug(\"Layer: %s, Fan-in: %d\" % (name, in_features))\n        f_shape = [ksize, ksize, num_classes, in_features]\n\n        # create\n        num_input = ksize * ksize * in_features / stride\n        stddev = (2 / num_input)**0.5\n\n        weights = self.get_deconv_filter(f_shape)\n        deconv = tf.nn.conv2d_transpose(bottom, weights, output_shape,\n                                        strides=strides, padding='SAME')\n\n        if debug:\n            deconv = tf.Print(deconv, [tf.shape(deconv)],\n                              message='Shape of %s' % name,\n                              summarize=4, first_n=1)\n\n    _activation_summary(deconv)\n    return deconv\n```\n\nLooks like author just uses tf.nn.conv2d_transpose to do the upsampling. Is my understanding correct?\n"}