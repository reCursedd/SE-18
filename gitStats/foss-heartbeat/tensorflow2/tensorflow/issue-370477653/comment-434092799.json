{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/434092799", "html_url": "https://github.com/tensorflow/tensorflow/pull/23011#issuecomment-434092799", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/23011", "id": 434092799, "node_id": "MDEyOklzc3VlQ29tbWVudDQzNDA5Mjc5OQ==", "user": {"login": "calid", "id": 494405, "node_id": "MDQ6VXNlcjQ5NDQwNQ==", "avatar_url": "https://avatars3.githubusercontent.com/u/494405?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calid", "html_url": "https://github.com/calid", "followers_url": "https://api.github.com/users/calid/followers", "following_url": "https://api.github.com/users/calid/following{/other_user}", "gists_url": "https://api.github.com/users/calid/gists{/gist_id}", "starred_url": "https://api.github.com/users/calid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calid/subscriptions", "organizations_url": "https://api.github.com/users/calid/orgs", "repos_url": "https://api.github.com/users/calid/repos", "events_url": "https://api.github.com/users/calid/events{/privacy}", "received_events_url": "https://api.github.com/users/calid/received_events", "type": "User", "site_admin": false}, "created_at": "2018-10-29T21:46:00Z", "updated_at": "2018-10-29T21:46:00Z", "author_association": "NONE", "body_html": "<p>Ah, ok I understand.  So the difference is the new code tries to be defensive and handle locking/synchronization internally, whereas your example handles locking in the user defined <code>next</code> function.  But you're right, locking the entire generator <code>next</code> means the threads can't parallelize expensive operations that are thread-safe within <code>next</code>.  If it's a precondition the user must handle locking themselves (if necessary) that changes things.  I was under the impression the Enqueuer classes were supposed to handle all synchronization.</p>\n<p>So if I understood you correctly, I can remove the internal locking around the generator and it's up to the user to synchronize correctly in their <code>next</code>, if necessary?  Is this documented?  If not let's add that?</p>", "body_text": "Ah, ok I understand.  So the difference is the new code tries to be defensive and handle locking/synchronization internally, whereas your example handles locking in the user defined next function.  But you're right, locking the entire generator next means the threads can't parallelize expensive operations that are thread-safe within next.  If it's a precondition the user must handle locking themselves (if necessary) that changes things.  I was under the impression the Enqueuer classes were supposed to handle all synchronization.\nSo if I understood you correctly, I can remove the internal locking around the generator and it's up to the user to synchronize correctly in their next, if necessary?  Is this documented?  If not let's add that?", "body": "Ah, ok I understand.  So the difference is the new code tries to be defensive and handle locking/synchronization internally, whereas your example handles locking in the user defined `next` function.  But you're right, locking the entire generator `next` means the threads can't parallelize expensive operations that are thread-safe within `next`.  If it's a precondition the user must handle locking themselves (if necessary) that changes things.  I was under the impression the Enqueuer classes were supposed to handle all synchronization.\r\n\r\nSo if I understood you correctly, I can remove the internal locking around the generator and it's up to the user to synchronize correctly in their `next`, if necessary?  Is this documented?  If not let's add that?"}