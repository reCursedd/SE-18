{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/434080170", "html_url": "https://github.com/tensorflow/tensorflow/pull/23011#issuecomment-434080170", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/23011", "id": 434080170, "node_id": "MDEyOklzc3VlQ29tbWVudDQzNDA4MDE3MA==", "user": {"login": "Dref360", "id": 8976546, "node_id": "MDQ6VXNlcjg5NzY1NDY=", "avatar_url": "https://avatars3.githubusercontent.com/u/8976546?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dref360", "html_url": "https://github.com/Dref360", "followers_url": "https://api.github.com/users/Dref360/followers", "following_url": "https://api.github.com/users/Dref360/following{/other_user}", "gists_url": "https://api.github.com/users/Dref360/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dref360/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dref360/subscriptions", "organizations_url": "https://api.github.com/users/Dref360/orgs", "repos_url": "https://api.github.com/users/Dref360/repos", "events_url": "https://api.github.com/users/Dref360/events{/privacy}", "received_events_url": "https://api.github.com/users/Dref360/received_events", "type": "User", "site_admin": false}, "created_at": "2018-10-29T21:06:35Z", "updated_at": "2018-10-29T21:06:35Z", "author_association": "CONTRIBUTOR", "body_html": "<p>It works when we add a <code>stop()</code> Thanks!</p>\n<p>A user is allowed to define an object which implements <code>next</code> and we should see a speedup when using threads.</p>\n<p>Using generators with processes is allowed for legacy purposes. (We do raise a warning inside fit_generator.)</p>\n<p>Example with threads</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">import</span> threading\n\n<span class=\"pl-k\">from</span> keras.utils <span class=\"pl-k\">import</span> GeneratorEnqueuer\n<span class=\"pl-k\">import</span> numpy <span class=\"pl-k\">as</span> np\n<span class=\"pl-k\">import</span> time\n\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">PowTwo</span>:\n    <span class=\"pl-s\"><span class=\"pl-pds\">\"\"\"</span>Class to implement an iterator</span>\n<span class=\"pl-s\">    of powers of two<span class=\"pl-pds\">\"\"\"</span></span>\n\n    <span class=\"pl-k\">def</span> <span class=\"pl-c1\">__init__</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>, <span class=\"pl-smi\">max</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">0</span>):\n        <span class=\"pl-c1\">self</span>.n <span class=\"pl-k\">=</span> <span class=\"pl-c1\">0</span>\n        <span class=\"pl-c1\">self</span>.max <span class=\"pl-k\">=</span> <span class=\"pl-c1\">max</span>\n        <span class=\"pl-c1\">self</span>.lock <span class=\"pl-k\">=</span> threading.Lock()\n\n    <span class=\"pl-k\">def</span> <span class=\"pl-c1\">__iter__</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>):\n        <span class=\"pl-k\">return</span> <span class=\"pl-c1\">self</span>\n\n    <span class=\"pl-k\">def</span> <span class=\"pl-c1\">__next__</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>):\n        <span class=\"pl-k\">return</span> <span class=\"pl-c1\">self</span>.next()\n\n    <span class=\"pl-k\">def</span> <span class=\"pl-c1\">next</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>):\n        <span class=\"pl-k\">if</span> <span class=\"pl-c1\">self</span>.n <span class=\"pl-k\">&lt;=</span> <span class=\"pl-c1\">self</span>.max:\n            <span class=\"pl-c\"><span class=\"pl-c\">#</span> Exemple: Get the paths to a list of images</span>\n            <span class=\"pl-k\">with</span> <span class=\"pl-c1\">self</span>.lock:\n                result <span class=\"pl-k\">=</span> <span class=\"pl-c1\">2</span> <span class=\"pl-k\">**</span> <span class=\"pl-c1\">self</span>.n\n                <span class=\"pl-c1\">self</span>.n <span class=\"pl-k\">+=</span> <span class=\"pl-c1\">1</span>\n            <span class=\"pl-c\"><span class=\"pl-c\">#</span> Load the images, resize, data augmentation</span>\n            time.sleep(<span class=\"pl-c1\">1</span>)\n            <span class=\"pl-c\"><span class=\"pl-c\">#</span> Return the batch.</span>\n            <span class=\"pl-k\">return</span> result\n        <span class=\"pl-k\">else</span>:\n            <span class=\"pl-k\">raise</span> <span class=\"pl-c1\">StopIteration</span>\n\ngen2 <span class=\"pl-k\">=</span> GeneratorEnqueuer(PowTwo(<span class=\"pl-c1\">40</span>),<span class=\"pl-v\">use_multiprocessing</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">False</span>)\ngen2.start(<span class=\"pl-c1\">10</span>,<span class=\"pl-c1\">10</span>)\ng2 <span class=\"pl-k\">=</span> gen2.get()\n\ns <span class=\"pl-k\">=</span> time.time()\nacc <span class=\"pl-k\">=</span> [i <span class=\"pl-k\">for</span> i,_ <span class=\"pl-k\">in</span> <span class=\"pl-c1\">zip</span>(g2, <span class=\"pl-c1\">range</span>(<span class=\"pl-c1\">20</span>))]\ngen2.stop()\n<span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Gen<span class=\"pl-pds\">\"</span></span>, time.time() <span class=\"pl-k\">-</span> s)</pre></div>\n<p>I do see that the new version has a slowdown factor of x10 while this is entirely threadsafe. (3 sec on master,30 secs for the new version).</p>\n<p>I do see a similar behavior with Sequences which are read-only structures and should not require any locking mechanism.</p>", "body_text": "It works when we add a stop() Thanks!\nA user is allowed to define an object which implements next and we should see a speedup when using threads.\nUsing generators with processes is allowed for legacy purposes. (We do raise a warning inside fit_generator.)\nExample with threads\nimport threading\n\nfrom keras.utils import GeneratorEnqueuer\nimport numpy as np\nimport time\n\nclass PowTwo:\n    \"\"\"Class to implement an iterator\n    of powers of two\"\"\"\n\n    def __init__(self, max = 0):\n        self.n = 0\n        self.max = max\n        self.lock = threading.Lock()\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        return self.next()\n\n    def next(self):\n        if self.n <= self.max:\n            # Exemple: Get the paths to a list of images\n            with self.lock:\n                result = 2 ** self.n\n                self.n += 1\n            # Load the images, resize, data augmentation\n            time.sleep(1)\n            # Return the batch.\n            return result\n        else:\n            raise StopIteration\n\ngen2 = GeneratorEnqueuer(PowTwo(40),use_multiprocessing=False)\ngen2.start(10,10)\ng2 = gen2.get()\n\ns = time.time()\nacc = [i for i,_ in zip(g2, range(20))]\ngen2.stop()\nprint(\"Gen\", time.time() - s)\nI do see that the new version has a slowdown factor of x10 while this is entirely threadsafe. (3 sec on master,30 secs for the new version).\nI do see a similar behavior with Sequences which are read-only structures and should not require any locking mechanism.", "body": "It works when we add a `stop()` Thanks!\r\n\r\nA user is allowed to define an object which implements `next` and we should see a speedup when using threads. \r\n\r\nUsing generators with processes is allowed for legacy purposes. (We do raise a warning inside fit_generator.)\r\n\r\nExample with threads\r\n```python\r\nimport threading\r\n\r\nfrom keras.utils import GeneratorEnqueuer\r\nimport numpy as np\r\nimport time\r\n\r\nclass PowTwo:\r\n    \"\"\"Class to implement an iterator\r\n    of powers of two\"\"\"\r\n\r\n    def __init__(self, max = 0):\r\n        self.n = 0\r\n        self.max = max\r\n        self.lock = threading.Lock()\r\n\r\n    def __iter__(self):\r\n        return self\r\n\r\n    def __next__(self):\r\n        return self.next()\r\n\r\n    def next(self):\r\n        if self.n <= self.max:\r\n            # Exemple: Get the paths to a list of images\r\n            with self.lock:\r\n                result = 2 ** self.n\r\n                self.n += 1\r\n            # Load the images, resize, data augmentation\r\n            time.sleep(1)\r\n            # Return the batch.\r\n            return result\r\n        else:\r\n            raise StopIteration\r\n\r\ngen2 = GeneratorEnqueuer(PowTwo(40),use_multiprocessing=False)\r\ngen2.start(10,10)\r\ng2 = gen2.get()\r\n\r\ns = time.time()\r\nacc = [i for i,_ in zip(g2, range(20))]\r\ngen2.stop()\r\nprint(\"Gen\", time.time() - s)\r\n```\r\n\r\nI do see that the new version has a slowdown factor of x10 while this is entirely threadsafe. (3 sec on master,30 secs for the new version).\r\n\r\nI do see a similar behavior with Sequences which are read-only structures and should not require any locking mechanism.\r\n\r\n"}