{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/20586", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/20586/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/20586/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/20586/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/20586", "id": 338810311, "node_id": "MDU6SXNzdWUzMzg4MTAzMTE=", "number": 20586, "title": "REGISTER_KERNEL_BUILDER fails type constraint check for valid integral types", "user": {"login": "Bidski", "id": 2320984, "node_id": "MDQ6VXNlcjIzMjA5ODQ=", "avatar_url": "https://avatars1.githubusercontent.com/u/2320984?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Bidski", "html_url": "https://github.com/Bidski", "followers_url": "https://api.github.com/users/Bidski/followers", "following_url": "https://api.github.com/users/Bidski/following{/other_user}", "gists_url": "https://api.github.com/users/Bidski/gists{/gist_id}", "starred_url": "https://api.github.com/users/Bidski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Bidski/subscriptions", "organizations_url": "https://api.github.com/users/Bidski/orgs", "repos_url": "https://api.github.com/users/Bidski/repos", "events_url": "https://api.github.com/users/Bidski/events{/privacy}", "received_events_url": "https://api.github.com/users/Bidski/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 386191887, "node_id": "MDU6TGFiZWwzODYxOTE4ODc=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:awaiting%20response", "name": "stat:awaiting response", "color": "f4b400", "default": false}], "state": "closed", "locked": false, "assignee": {"login": "alextp", "id": 5061, "node_id": "MDQ6VXNlcjUwNjE=", "avatar_url": "https://avatars0.githubusercontent.com/u/5061?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alextp", "html_url": "https://github.com/alextp", "followers_url": "https://api.github.com/users/alextp/followers", "following_url": "https://api.github.com/users/alextp/following{/other_user}", "gists_url": "https://api.github.com/users/alextp/gists{/gist_id}", "starred_url": "https://api.github.com/users/alextp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alextp/subscriptions", "organizations_url": "https://api.github.com/users/alextp/orgs", "repos_url": "https://api.github.com/users/alextp/repos", "events_url": "https://api.github.com/users/alextp/events{/privacy}", "received_events_url": "https://api.github.com/users/alextp/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "alextp", "id": 5061, "node_id": "MDQ6VXNlcjUwNjE=", "avatar_url": "https://avatars0.githubusercontent.com/u/5061?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alextp", "html_url": "https://github.com/alextp", "followers_url": "https://api.github.com/users/alextp/followers", "following_url": "https://api.github.com/users/alextp/following{/other_user}", "gists_url": "https://api.github.com/users/alextp/gists{/gist_id}", "starred_url": "https://api.github.com/users/alextp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alextp/subscriptions", "organizations_url": "https://api.github.com/users/alextp/orgs", "repos_url": "https://api.github.com/users/alextp/repos", "events_url": "https://api.github.com/users/alextp/events{/privacy}", "received_events_url": "https://api.github.com/users/alextp/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 11, "created_at": "2018-07-06T05:30:50Z", "updated_at": "2018-09-17T16:54:07Z", "closed_at": "2018-09-17T16:54:07Z", "author_association": "NONE", "body_html": "<h3>System information</h3>\n<ul>\n<li><strong>Have I written custom code (as opposed to using a stock example script provided in TensorFlow)</strong>: Yes</li>\n<li><strong>OS Platform and Distribution (e.g., Linux Ubuntu 16.04)</strong>: Linux Mint 18.2 Sonya (based on Ubuntu 16.04)</li>\n<li><strong>TensorFlow installed from (source or binary)</strong>: Source</li>\n<li><strong>TensorFlow version (use command below)</strong>: latest master (last commit <a class=\"commit-link\" data-hovercard-type=\"commit\" data-hovercard-url=\"https://github.com/tensorflow/tensorflow/commit/b2fe2a874bade4782aaca5c44bf29e7ff6c39200/hovercard\" href=\"https://github.com/tensorflow/tensorflow/commit/b2fe2a874bade4782aaca5c44bf29e7ff6c39200\"><tt>b2fe2a8</tt></a>)</li>\n<li><strong>Python version</strong>: 3.5.2</li>\n<li><strong>Bazel version (if compiling from source)</strong>: 0.15.0</li>\n<li><strong>GCC/Compiler version (if compiling from source)</strong>: 7.3.0</li>\n<li><strong>CUDA/cuDNN version</strong>: 9.2/7.1</li>\n<li><strong>GPU model and memory</strong>: GX1080Ti 11GB</li>\n<li><strong>Exact command to reproduce</strong>: N/A</li>\n</ul>\n<h3>Describe the problem</h3>\n<p>When writing a custom op and registering a kernel builder using <code>REGISTER_KERNEL_BUILDER</code>, specifying a type constraint of int64_t will fail on some machines. This also fails for unsigned types too (as you would expect).</p>\n<p>The problem occurs due to lines 381-403 in <code>tensorflow/core/framework/types.h</code></p>\n<pre><code>MATCH_TYPE_AND_ENUM(float, DT_FLOAT);\nMATCH_TYPE_AND_ENUM(double, DT_DOUBLE);\nMATCH_TYPE_AND_ENUM(int32, DT_INT32);\nMATCH_TYPE_AND_ENUM(uint32, DT_UINT32);\nMATCH_TYPE_AND_ENUM(uint16, DT_UINT16);\nMATCH_TYPE_AND_ENUM(uint8, DT_UINT8);\nMATCH_TYPE_AND_ENUM(int16, DT_INT16);\nMATCH_TYPE_AND_ENUM(int8, DT_INT8);\nMATCH_TYPE_AND_ENUM(string, DT_STRING);\nMATCH_TYPE_AND_ENUM(complex64, DT_COMPLEX64);\nMATCH_TYPE_AND_ENUM(complex128, DT_COMPLEX128);\nMATCH_TYPE_AND_ENUM(int64, DT_INT64);\nMATCH_TYPE_AND_ENUM(uint64, DT_UINT64);\nMATCH_TYPE_AND_ENUM(bool, DT_BOOL);\nMATCH_TYPE_AND_ENUM(qint8, DT_QINT8);\nMATCH_TYPE_AND_ENUM(quint8, DT_QUINT8);\nMATCH_TYPE_AND_ENUM(qint16, DT_QINT16);\nMATCH_TYPE_AND_ENUM(quint16, DT_QUINT16);\nMATCH_TYPE_AND_ENUM(qint32, DT_QINT32);\nMATCH_TYPE_AND_ENUM(bfloat16, DT_BFLOAT16);\nMATCH_TYPE_AND_ENUM(Eigen::half, DT_HALF);\nMATCH_TYPE_AND_ENUM(ResourceHandle, DT_RESOURCE);\nMATCH_TYPE_AND_ENUM(Variant, DT_VARIANT);\n</code></pre>\n<p>In this case, <code>int64</code> is being <code>typedef</code>'d to <code>long long</code> (<code>tensorflow/core/platform/default/integral_types.h</code>), however on some systems <code>int64_t</code> is <code>typedef</code>'d as <code>__int64</code> (or potentially some other variation that results in a 64-bit signed type). Because of this <code>int64_t != to int64</code> and the type constraint check fails.</p>\n<p>On my system in particular, this code</p>\n<pre><code>#include &lt;cstdint&gt;\n#include &lt;iostream&gt;\n\nint main(void) {\n    std::cout &lt;&lt; \"int64_t...............: \"\n              &lt;&lt; \"(\" &lt;&lt; typeid(int64_t).name() &lt;&lt; \") \" &lt;&lt; sizeof(int64_t) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"long..................: \"\n              &lt;&lt; \"(\" &lt;&lt; typeid(long).name() &lt;&lt; \") \" &lt;&lt; sizeof(long) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"long int..............: \"\n              &lt;&lt; \"(\" &lt;&lt; typeid(long int).name() &lt;&lt; \") \" &lt;&lt; sizeof(long int) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"long long int.........: \"\n              &lt;&lt; \"(\" &lt;&lt; typeid(long long int).name() &lt;&lt; \") \" &lt;&lt; sizeof(long long int) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"long long.............: \"\n              &lt;&lt; \"(\" &lt;&lt; typeid(long long).name() &lt;&lt; \") \" &lt;&lt; sizeof(long long) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"uint64_t..............: \"\n              &lt;&lt; \"(\" &lt;&lt; typeid(uint64_t).name() &lt;&lt; \") \" &lt;&lt; sizeof(int64_t) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"unsigned long.........: \"\n              &lt;&lt; \"(\" &lt;&lt; typeid(unsigned long).name() &lt;&lt; \") \" &lt;&lt; sizeof(unsigned long) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"unsigned long int.....: \"\n              &lt;&lt; \"(\" &lt;&lt; typeid(unsigned long int).name() &lt;&lt; \") \" &lt;&lt; sizeof(unsigned long int) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"unsigned long long int: \"\n              &lt;&lt; \"(\" &lt;&lt; typeid(unsigned long long int).name() &lt;&lt; \") \" &lt;&lt; sizeof(unsigned long long int) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"unsigned long long....: \"\n              &lt;&lt; \"(\" &lt;&lt; typeid(unsigned long long).name() &lt;&lt; \") \" &lt;&lt; sizeof(unsigned long long) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"long long == int64_t? \" &lt;&lt; (std::is_same&lt;long long, int64_t&gt;::value ? \"yes\" : \"no\") &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"(sizeof(long long) == 8) &amp;&amp; std::is_signed&lt;long long&gt;::value? \"\n              &lt;&lt; ((sizeof(long long) == 8) &amp;&amp; std::is_signed&lt;long long&gt;::value ? \"yes\" : \"no\") &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"(sizeof(int64_t) == 8) &amp;&amp; std::is_signed&lt;int64_t&gt;::value? \"\n              &lt;&lt; ((sizeof(int64_t) == 8) &amp;&amp; std::is_signed&lt;int64_t&gt;::value ? \"yes\" : \"no\") &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"unsigned long long == uint64_t? \"\n              &lt;&lt; (std::is_same&lt;unsigned long long, uint64_t&gt;::value ? \"yes\" : \"no\") &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"(sizeof(unsigned long long) == 8) &amp;&amp; !std::is_signed&lt;unsigned long long&gt;::value? \"\n              &lt;&lt; ((sizeof(unsigned long long) == 8) &amp;&amp; !std::is_signed&lt;unsigned long long&gt;::value ? \"yes\" : \"no\")\n              &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"(sizeof(uint64_t) == 8) &amp;&amp; !std::is_signed&lt;uint64_t&gt;::value? \"\n              &lt;&lt; ((sizeof(uint64_t) == 8) &amp;&amp; !std::is_signed&lt;uint64_t&gt;::value ? \"yes\" : \"no\") &lt;&lt; std::endl;\n    return 0;\n}\n\n</code></pre>\n<p>produces this output</p>\n<pre><code>int64_t...............: (l) 8\nlong..................: (l) 8\nlong int..............: (l) 8\nlong long int.........: (x) 8\nlong long.............: (x) 8\nuint64_t..............: (m) 8\nunsigned long.........: (m) 8\nunsigned long int.....: (m) 8\nunsigned long long int: (y) 8\nunsigned long long....: (y) 8\nlong long == int64_t? no\n(sizeof(long long) == 8) &amp;&amp; std::is_signed&lt;long long&gt;::value? yes\n(sizeof(int64_t) == 8) &amp;&amp; std::is_signed&lt;int64_t&gt;::value? yes\nunsigned long long == uint64_t? no\n(sizeof(unsigned long long) == 8) &amp;&amp; !std::is_signed&lt;unsigned long long&gt;::value? yes\n(sizeof(uint64_t) == 8) &amp;&amp; !std::is_signed&lt;uint64_t&gt;::value? yes\n\n</code></pre>\n<p>On a system where the current type constraint check works, the same code outputs this</p>\n<pre><code>int64_t...............: (x) 8\nlong..................: (l) 8\nlong int..............: (l) 8\nlong long int.........: (x) 8\nlong long.............: (x) 8\nuint64_t..............: (y) 8\nunsigned long.........: (m) 8\nunsigned long int.....: (m) 8\nunsigned long long int: (y) 8\nunsigned long long....: (y) 8\nlong long == int64_t? yes\n(sizeof(long long) == 8) &amp;&amp; std::is_signed&lt;long long&gt;::value? yes\n(sizeof(int64_t) == 8) &amp;&amp; std::is_signed&lt;int64_t&gt;::value? yes\nunsigned long long == uint64_t? yes\n(sizeof(unsigned long long) == 8) &amp;&amp; !std::is_signed&lt;unsigned long long&gt;::value? yes\n(sizeof(uint64_t) == 8) &amp;&amp; !std::is_signed&lt;uint64_t&gt;::value? yes\n</code></pre>\n<p>Since using an <code>int64_t</code> should be supported (as it is equivalent to <code>long long</code>), I propose that the code be modified to either use the integral types defined in <code>cstdint</code> (<code>int8_t</code>, <code>int16_t</code>, <code>int32_t</code>, <code>int64_t</code>), or the check should be changed to look for a 64-bit type that is signed using a combination of <code>sizeof</code> and <code>std::is_signed</code></p>\n<h3>Source code / logs</h3>\n<p>The following example produces the error</p>\n<pre><code>#include &lt;tensorflow/core/framework/op.h&gt;\n#include &lt;tensorflow/core/framework/op_kernel.h&gt;\n\nREGISTER_OP(\"ExampleOp\").Attr(\"T: {int32, int64, uint32, uint64}\");\n\ntemplate &lt;typename T&gt;\nclass ExampleOp : public tensorflow::OpKernel {\npublic:\n  explicit ExampleOp(tensorflow::OpKernelConstruction* context) : OpKernel(context) {}\n\n  void Compute(tensorflow::OpKernelContext* context) override {}\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"ExampleOp\").Device(tensorflow::DEVICE_CPU).TypeConstraint&lt;int32_t&gt;(\"T\"), ExampleOp&lt;int32_t&gt;);\nREGISTER_KERNEL_BUILDER(Name(\"ExampleOp\").Device(tensorflow::DEVICE_CPU).TypeConstraint&lt;int64_t&gt;(\"T\"), ExampleOp&lt;int64_t&gt;);\nREGISTER_KERNEL_BUILDER(Name(\"ExampleOp\").Device(tensorflow::DEVICE_CPU).TypeConstraint&lt;uint32_t&gt;(\"T\"), ExampleOp&lt;uint32_t&gt;);\nREGISTER_KERNEL_BUILDER(Name(\"ExampleOp\").Device(tensorflow::DEVICE_CPU).TypeConstraint&lt;uint64_t&gt;(\"T\"), ExampleOp&lt;uint64_t&gt;);\n</code></pre>\n<p>Here is the resulting compilation log</p>\n<pre><code>/usr/bin/c++  -Dmwe_EXPORTS -isystem /usr/local/lib/python3.5/dist-packages/tensorflow/include -I../src -march=native -mtune=native -fPIC -O3 -DNDEBUG -fPIC   -march=native -mtune=native -MD -MT CMakeFiles/mwe.dir/mwe.cpp.o -MF CMakeFiles/mwe.dir/mwe.cpp.o.d -o CMakeFiles/mwe.dir/mwe.cpp.o -c ../mwe.cpp\nIn file included from /usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/tensor.h:23:0,\n                 from /usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/device_base.h:23,\n                 from /usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/op_kernel.h:26,\n                 from ../mwe.cpp:2:\n/usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/types.h: In instantiation of \u2018struct tensorflow::DataTypeToEnum&lt;long int&gt;\u2019:\n/usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/kernel_def_builder.h:82:62:   required from \u2018tensorflow::KernelDefBuilder&amp; tensorflow::KernelDefBuilder::TypeConstraint(const char*) [with T = long int]\u2019\n../mwe.cpp:16:1:   required from here\n/usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/types.h:356:3: error: static assertion failed: Specified Data Type not supported\n   static_assert(IsValidDataType&lt;T&gt;::value, \"Specified Data Type not supported\");\n   ^~~~~~~~~~~~~\nIn file included from /usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/op_kernel.h:28:0,\n                 from ../mwe.cpp:2:\n/usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/kernel_def_builder.h: In instantiation of \u2018tensorflow::KernelDefBuilder&amp; tensorflow::KernelDefBuilder::TypeConstraint(const char*) [with T = long int]\u2019:\n../mwe.cpp:16:1:   required from here\n/usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/kernel_def_builder.h:82:62: error: \u2018v\u2019 is not a member of \u2018tensorflow::DataTypeToEnum&lt;long int&gt;\u2019\n   return this-&gt;TypeConstraint(attr_name, DataTypeToEnum&lt;T&gt;::v());\n                                          ~~~~~~~~~~~~~~~~~~~~^~\nIn file included from /usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/tensor.h:23:0,\n                 from /usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/device_base.h:23,\n                 from /usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/op_kernel.h:26,\n                 from ../mwe.cpp:2:\n/usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/types.h: In instantiation of \u2018struct tensorflow::DataTypeToEnum&lt;long unsigned int&gt;\u2019:\n/usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/kernel_def_builder.h:82:62:   required from \u2018tensorflow::KernelDefBuilder&amp; tensorflow::KernelDefBuilder::TypeConstraint(const char*) [with T = long unsigned int]\u2019\n../mwe.cpp:20:1:   required from here\n/usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/types.h:356:3: error: static assertion failed: Specified Data Type not supported\n   static_assert(IsValidDataType&lt;T&gt;::value, \"Specified Data Type not supported\");\n   ^~~~~~~~~~~~~\nIn file included from /usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/op_kernel.h:28:0,\n                 from ../mwe.cpp:2:\n/usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/kernel_def_builder.h: In instantiation of \u2018tensorflow::KernelDefBuilder&amp; tensorflow::KernelDefBuilder::TypeConstraint(const char*) [with T = long unsigned int]\u2019:\n../mwe.cpp:20:1:   required from here\n/usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/kernel_def_builder.h:82:62: error: \u2018v\u2019 is not a member of \u2018tensorflow::DataTypeToEnum&lt;long unsigned int&gt;\u2019\n   return this-&gt;TypeConstraint(attr_name, DataTypeToEnum&lt;T&gt;::v());\n                                          ~~~~~~~~~~~~~~~~~~~~^~\n</code></pre>\n<p>EDIT: Added a minimal working example</p>", "body_text": "System information\n\nHave I written custom code (as opposed to using a stock example script provided in TensorFlow): Yes\nOS Platform and Distribution (e.g., Linux Ubuntu 16.04): Linux Mint 18.2 Sonya (based on Ubuntu 16.04)\nTensorFlow installed from (source or binary): Source\nTensorFlow version (use command below): latest master (last commit b2fe2a8)\nPython version: 3.5.2\nBazel version (if compiling from source): 0.15.0\nGCC/Compiler version (if compiling from source): 7.3.0\nCUDA/cuDNN version: 9.2/7.1\nGPU model and memory: GX1080Ti 11GB\nExact command to reproduce: N/A\n\nDescribe the problem\nWhen writing a custom op and registering a kernel builder using REGISTER_KERNEL_BUILDER, specifying a type constraint of int64_t will fail on some machines. This also fails for unsigned types too (as you would expect).\nThe problem occurs due to lines 381-403 in tensorflow/core/framework/types.h\nMATCH_TYPE_AND_ENUM(float, DT_FLOAT);\nMATCH_TYPE_AND_ENUM(double, DT_DOUBLE);\nMATCH_TYPE_AND_ENUM(int32, DT_INT32);\nMATCH_TYPE_AND_ENUM(uint32, DT_UINT32);\nMATCH_TYPE_AND_ENUM(uint16, DT_UINT16);\nMATCH_TYPE_AND_ENUM(uint8, DT_UINT8);\nMATCH_TYPE_AND_ENUM(int16, DT_INT16);\nMATCH_TYPE_AND_ENUM(int8, DT_INT8);\nMATCH_TYPE_AND_ENUM(string, DT_STRING);\nMATCH_TYPE_AND_ENUM(complex64, DT_COMPLEX64);\nMATCH_TYPE_AND_ENUM(complex128, DT_COMPLEX128);\nMATCH_TYPE_AND_ENUM(int64, DT_INT64);\nMATCH_TYPE_AND_ENUM(uint64, DT_UINT64);\nMATCH_TYPE_AND_ENUM(bool, DT_BOOL);\nMATCH_TYPE_AND_ENUM(qint8, DT_QINT8);\nMATCH_TYPE_AND_ENUM(quint8, DT_QUINT8);\nMATCH_TYPE_AND_ENUM(qint16, DT_QINT16);\nMATCH_TYPE_AND_ENUM(quint16, DT_QUINT16);\nMATCH_TYPE_AND_ENUM(qint32, DT_QINT32);\nMATCH_TYPE_AND_ENUM(bfloat16, DT_BFLOAT16);\nMATCH_TYPE_AND_ENUM(Eigen::half, DT_HALF);\nMATCH_TYPE_AND_ENUM(ResourceHandle, DT_RESOURCE);\nMATCH_TYPE_AND_ENUM(Variant, DT_VARIANT);\n\nIn this case, int64 is being typedef'd to long long (tensorflow/core/platform/default/integral_types.h), however on some systems int64_t is typedef'd as __int64 (or potentially some other variation that results in a 64-bit signed type). Because of this int64_t != to int64 and the type constraint check fails.\nOn my system in particular, this code\n#include <cstdint>\n#include <iostream>\n\nint main(void) {\n    std::cout << \"int64_t...............: \"\n              << \"(\" << typeid(int64_t).name() << \") \" << sizeof(int64_t) << std::endl;\n    std::cout << \"long..................: \"\n              << \"(\" << typeid(long).name() << \") \" << sizeof(long) << std::endl;\n    std::cout << \"long int..............: \"\n              << \"(\" << typeid(long int).name() << \") \" << sizeof(long int) << std::endl;\n    std::cout << \"long long int.........: \"\n              << \"(\" << typeid(long long int).name() << \") \" << sizeof(long long int) << std::endl;\n    std::cout << \"long long.............: \"\n              << \"(\" << typeid(long long).name() << \") \" << sizeof(long long) << std::endl;\n    std::cout << \"uint64_t..............: \"\n              << \"(\" << typeid(uint64_t).name() << \") \" << sizeof(int64_t) << std::endl;\n    std::cout << \"unsigned long.........: \"\n              << \"(\" << typeid(unsigned long).name() << \") \" << sizeof(unsigned long) << std::endl;\n    std::cout << \"unsigned long int.....: \"\n              << \"(\" << typeid(unsigned long int).name() << \") \" << sizeof(unsigned long int) << std::endl;\n    std::cout << \"unsigned long long int: \"\n              << \"(\" << typeid(unsigned long long int).name() << \") \" << sizeof(unsigned long long int) << std::endl;\n    std::cout << \"unsigned long long....: \"\n              << \"(\" << typeid(unsigned long long).name() << \") \" << sizeof(unsigned long long) << std::endl;\n    std::cout << \"long long == int64_t? \" << (std::is_same<long long, int64_t>::value ? \"yes\" : \"no\") << std::endl;\n    std::cout << \"(sizeof(long long) == 8) && std::is_signed<long long>::value? \"\n              << ((sizeof(long long) == 8) && std::is_signed<long long>::value ? \"yes\" : \"no\") << std::endl;\n    std::cout << \"(sizeof(int64_t) == 8) && std::is_signed<int64_t>::value? \"\n              << ((sizeof(int64_t) == 8) && std::is_signed<int64_t>::value ? \"yes\" : \"no\") << std::endl;\n    std::cout << \"unsigned long long == uint64_t? \"\n              << (std::is_same<unsigned long long, uint64_t>::value ? \"yes\" : \"no\") << std::endl;\n    std::cout << \"(sizeof(unsigned long long) == 8) && !std::is_signed<unsigned long long>::value? \"\n              << ((sizeof(unsigned long long) == 8) && !std::is_signed<unsigned long long>::value ? \"yes\" : \"no\")\n              << std::endl;\n    std::cout << \"(sizeof(uint64_t) == 8) && !std::is_signed<uint64_t>::value? \"\n              << ((sizeof(uint64_t) == 8) && !std::is_signed<uint64_t>::value ? \"yes\" : \"no\") << std::endl;\n    return 0;\n}\n\n\nproduces this output\nint64_t...............: (l) 8\nlong..................: (l) 8\nlong int..............: (l) 8\nlong long int.........: (x) 8\nlong long.............: (x) 8\nuint64_t..............: (m) 8\nunsigned long.........: (m) 8\nunsigned long int.....: (m) 8\nunsigned long long int: (y) 8\nunsigned long long....: (y) 8\nlong long == int64_t? no\n(sizeof(long long) == 8) && std::is_signed<long long>::value? yes\n(sizeof(int64_t) == 8) && std::is_signed<int64_t>::value? yes\nunsigned long long == uint64_t? no\n(sizeof(unsigned long long) == 8) && !std::is_signed<unsigned long long>::value? yes\n(sizeof(uint64_t) == 8) && !std::is_signed<uint64_t>::value? yes\n\n\nOn a system where the current type constraint check works, the same code outputs this\nint64_t...............: (x) 8\nlong..................: (l) 8\nlong int..............: (l) 8\nlong long int.........: (x) 8\nlong long.............: (x) 8\nuint64_t..............: (y) 8\nunsigned long.........: (m) 8\nunsigned long int.....: (m) 8\nunsigned long long int: (y) 8\nunsigned long long....: (y) 8\nlong long == int64_t? yes\n(sizeof(long long) == 8) && std::is_signed<long long>::value? yes\n(sizeof(int64_t) == 8) && std::is_signed<int64_t>::value? yes\nunsigned long long == uint64_t? yes\n(sizeof(unsigned long long) == 8) && !std::is_signed<unsigned long long>::value? yes\n(sizeof(uint64_t) == 8) && !std::is_signed<uint64_t>::value? yes\n\nSince using an int64_t should be supported (as it is equivalent to long long), I propose that the code be modified to either use the integral types defined in cstdint (int8_t, int16_t, int32_t, int64_t), or the check should be changed to look for a 64-bit type that is signed using a combination of sizeof and std::is_signed\nSource code / logs\nThe following example produces the error\n#include <tensorflow/core/framework/op.h>\n#include <tensorflow/core/framework/op_kernel.h>\n\nREGISTER_OP(\"ExampleOp\").Attr(\"T: {int32, int64, uint32, uint64}\");\n\ntemplate <typename T>\nclass ExampleOp : public tensorflow::OpKernel {\npublic:\n  explicit ExampleOp(tensorflow::OpKernelConstruction* context) : OpKernel(context) {}\n\n  void Compute(tensorflow::OpKernelContext* context) override {}\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"ExampleOp\").Device(tensorflow::DEVICE_CPU).TypeConstraint<int32_t>(\"T\"), ExampleOp<int32_t>);\nREGISTER_KERNEL_BUILDER(Name(\"ExampleOp\").Device(tensorflow::DEVICE_CPU).TypeConstraint<int64_t>(\"T\"), ExampleOp<int64_t>);\nREGISTER_KERNEL_BUILDER(Name(\"ExampleOp\").Device(tensorflow::DEVICE_CPU).TypeConstraint<uint32_t>(\"T\"), ExampleOp<uint32_t>);\nREGISTER_KERNEL_BUILDER(Name(\"ExampleOp\").Device(tensorflow::DEVICE_CPU).TypeConstraint<uint64_t>(\"T\"), ExampleOp<uint64_t>);\n\nHere is the resulting compilation log\n/usr/bin/c++  -Dmwe_EXPORTS -isystem /usr/local/lib/python3.5/dist-packages/tensorflow/include -I../src -march=native -mtune=native -fPIC -O3 -DNDEBUG -fPIC   -march=native -mtune=native -MD -MT CMakeFiles/mwe.dir/mwe.cpp.o -MF CMakeFiles/mwe.dir/mwe.cpp.o.d -o CMakeFiles/mwe.dir/mwe.cpp.o -c ../mwe.cpp\nIn file included from /usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/tensor.h:23:0,\n                 from /usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/device_base.h:23,\n                 from /usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/op_kernel.h:26,\n                 from ../mwe.cpp:2:\n/usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/types.h: In instantiation of \u2018struct tensorflow::DataTypeToEnum<long int>\u2019:\n/usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/kernel_def_builder.h:82:62:   required from \u2018tensorflow::KernelDefBuilder& tensorflow::KernelDefBuilder::TypeConstraint(const char*) [with T = long int]\u2019\n../mwe.cpp:16:1:   required from here\n/usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/types.h:356:3: error: static assertion failed: Specified Data Type not supported\n   static_assert(IsValidDataType<T>::value, \"Specified Data Type not supported\");\n   ^~~~~~~~~~~~~\nIn file included from /usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/op_kernel.h:28:0,\n                 from ../mwe.cpp:2:\n/usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/kernel_def_builder.h: In instantiation of \u2018tensorflow::KernelDefBuilder& tensorflow::KernelDefBuilder::TypeConstraint(const char*) [with T = long int]\u2019:\n../mwe.cpp:16:1:   required from here\n/usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/kernel_def_builder.h:82:62: error: \u2018v\u2019 is not a member of \u2018tensorflow::DataTypeToEnum<long int>\u2019\n   return this->TypeConstraint(attr_name, DataTypeToEnum<T>::v());\n                                          ~~~~~~~~~~~~~~~~~~~~^~\nIn file included from /usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/tensor.h:23:0,\n                 from /usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/device_base.h:23,\n                 from /usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/op_kernel.h:26,\n                 from ../mwe.cpp:2:\n/usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/types.h: In instantiation of \u2018struct tensorflow::DataTypeToEnum<long unsigned int>\u2019:\n/usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/kernel_def_builder.h:82:62:   required from \u2018tensorflow::KernelDefBuilder& tensorflow::KernelDefBuilder::TypeConstraint(const char*) [with T = long unsigned int]\u2019\n../mwe.cpp:20:1:   required from here\n/usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/types.h:356:3: error: static assertion failed: Specified Data Type not supported\n   static_assert(IsValidDataType<T>::value, \"Specified Data Type not supported\");\n   ^~~~~~~~~~~~~\nIn file included from /usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/op_kernel.h:28:0,\n                 from ../mwe.cpp:2:\n/usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/kernel_def_builder.h: In instantiation of \u2018tensorflow::KernelDefBuilder& tensorflow::KernelDefBuilder::TypeConstraint(const char*) [with T = long unsigned int]\u2019:\n../mwe.cpp:20:1:   required from here\n/usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/kernel_def_builder.h:82:62: error: \u2018v\u2019 is not a member of \u2018tensorflow::DataTypeToEnum<long unsigned int>\u2019\n   return this->TypeConstraint(attr_name, DataTypeToEnum<T>::v());\n                                          ~~~~~~~~~~~~~~~~~~~~^~\n\nEDIT: Added a minimal working example", "body": "### System information\r\n- **Have I written custom code (as opposed to using a stock example script provided in TensorFlow)**: Yes\r\n- **OS Platform and Distribution (e.g., Linux Ubuntu 16.04)**: Linux Mint 18.2 Sonya (based on Ubuntu 16.04)\r\n- **TensorFlow installed from (source or binary)**: Source\r\n- **TensorFlow version (use command below)**: latest master (last commit https://github.com/tensorflow/tensorflow/commit/b2fe2a874bade4782aaca5c44bf29e7ff6c39200)\r\n- **Python version**: 3.5.2\r\n- **Bazel version (if compiling from source)**: 0.15.0\r\n- **GCC/Compiler version (if compiling from source)**: 7.3.0\r\n- **CUDA/cuDNN version**: 9.2/7.1\r\n- **GPU model and memory**: GX1080Ti 11GB\r\n- **Exact command to reproduce**: N/A\r\n\r\n### Describe the problem\r\nWhen writing a custom op and registering a kernel builder using `REGISTER_KERNEL_BUILDER`, specifying a type constraint of int64_t will fail on some machines. This also fails for unsigned types too (as you would expect).\r\n\r\nThe problem occurs due to lines 381-403 in `tensorflow/core/framework/types.h`\r\n```\r\nMATCH_TYPE_AND_ENUM(float, DT_FLOAT);\r\nMATCH_TYPE_AND_ENUM(double, DT_DOUBLE);\r\nMATCH_TYPE_AND_ENUM(int32, DT_INT32);\r\nMATCH_TYPE_AND_ENUM(uint32, DT_UINT32);\r\nMATCH_TYPE_AND_ENUM(uint16, DT_UINT16);\r\nMATCH_TYPE_AND_ENUM(uint8, DT_UINT8);\r\nMATCH_TYPE_AND_ENUM(int16, DT_INT16);\r\nMATCH_TYPE_AND_ENUM(int8, DT_INT8);\r\nMATCH_TYPE_AND_ENUM(string, DT_STRING);\r\nMATCH_TYPE_AND_ENUM(complex64, DT_COMPLEX64);\r\nMATCH_TYPE_AND_ENUM(complex128, DT_COMPLEX128);\r\nMATCH_TYPE_AND_ENUM(int64, DT_INT64);\r\nMATCH_TYPE_AND_ENUM(uint64, DT_UINT64);\r\nMATCH_TYPE_AND_ENUM(bool, DT_BOOL);\r\nMATCH_TYPE_AND_ENUM(qint8, DT_QINT8);\r\nMATCH_TYPE_AND_ENUM(quint8, DT_QUINT8);\r\nMATCH_TYPE_AND_ENUM(qint16, DT_QINT16);\r\nMATCH_TYPE_AND_ENUM(quint16, DT_QUINT16);\r\nMATCH_TYPE_AND_ENUM(qint32, DT_QINT32);\r\nMATCH_TYPE_AND_ENUM(bfloat16, DT_BFLOAT16);\r\nMATCH_TYPE_AND_ENUM(Eigen::half, DT_HALF);\r\nMATCH_TYPE_AND_ENUM(ResourceHandle, DT_RESOURCE);\r\nMATCH_TYPE_AND_ENUM(Variant, DT_VARIANT);\r\n```\r\nIn this case, `int64` is being `typedef`'d to `long long` (`tensorflow/core/platform/default/integral_types.h`), however on some systems `int64_t` is `typedef`'d as `__int64` (or potentially some other variation that results in a 64-bit signed type). Because of this `int64_t != to int64` and the type constraint check fails.\r\n\r\nOn my system in particular, this code\r\n```\r\n#include <cstdint>\r\n#include <iostream>\r\n\r\nint main(void) {\r\n    std::cout << \"int64_t...............: \"\r\n              << \"(\" << typeid(int64_t).name() << \") \" << sizeof(int64_t) << std::endl;\r\n    std::cout << \"long..................: \"\r\n              << \"(\" << typeid(long).name() << \") \" << sizeof(long) << std::endl;\r\n    std::cout << \"long int..............: \"\r\n              << \"(\" << typeid(long int).name() << \") \" << sizeof(long int) << std::endl;\r\n    std::cout << \"long long int.........: \"\r\n              << \"(\" << typeid(long long int).name() << \") \" << sizeof(long long int) << std::endl;\r\n    std::cout << \"long long.............: \"\r\n              << \"(\" << typeid(long long).name() << \") \" << sizeof(long long) << std::endl;\r\n    std::cout << \"uint64_t..............: \"\r\n              << \"(\" << typeid(uint64_t).name() << \") \" << sizeof(int64_t) << std::endl;\r\n    std::cout << \"unsigned long.........: \"\r\n              << \"(\" << typeid(unsigned long).name() << \") \" << sizeof(unsigned long) << std::endl;\r\n    std::cout << \"unsigned long int.....: \"\r\n              << \"(\" << typeid(unsigned long int).name() << \") \" << sizeof(unsigned long int) << std::endl;\r\n    std::cout << \"unsigned long long int: \"\r\n              << \"(\" << typeid(unsigned long long int).name() << \") \" << sizeof(unsigned long long int) << std::endl;\r\n    std::cout << \"unsigned long long....: \"\r\n              << \"(\" << typeid(unsigned long long).name() << \") \" << sizeof(unsigned long long) << std::endl;\r\n    std::cout << \"long long == int64_t? \" << (std::is_same<long long, int64_t>::value ? \"yes\" : \"no\") << std::endl;\r\n    std::cout << \"(sizeof(long long) == 8) && std::is_signed<long long>::value? \"\r\n              << ((sizeof(long long) == 8) && std::is_signed<long long>::value ? \"yes\" : \"no\") << std::endl;\r\n    std::cout << \"(sizeof(int64_t) == 8) && std::is_signed<int64_t>::value? \"\r\n              << ((sizeof(int64_t) == 8) && std::is_signed<int64_t>::value ? \"yes\" : \"no\") << std::endl;\r\n    std::cout << \"unsigned long long == uint64_t? \"\r\n              << (std::is_same<unsigned long long, uint64_t>::value ? \"yes\" : \"no\") << std::endl;\r\n    std::cout << \"(sizeof(unsigned long long) == 8) && !std::is_signed<unsigned long long>::value? \"\r\n              << ((sizeof(unsigned long long) == 8) && !std::is_signed<unsigned long long>::value ? \"yes\" : \"no\")\r\n              << std::endl;\r\n    std::cout << \"(sizeof(uint64_t) == 8) && !std::is_signed<uint64_t>::value? \"\r\n              << ((sizeof(uint64_t) == 8) && !std::is_signed<uint64_t>::value ? \"yes\" : \"no\") << std::endl;\r\n    return 0;\r\n}\r\n\r\n```\r\nproduces this output\r\n```\r\nint64_t...............: (l) 8\r\nlong..................: (l) 8\r\nlong int..............: (l) 8\r\nlong long int.........: (x) 8\r\nlong long.............: (x) 8\r\nuint64_t..............: (m) 8\r\nunsigned long.........: (m) 8\r\nunsigned long int.....: (m) 8\r\nunsigned long long int: (y) 8\r\nunsigned long long....: (y) 8\r\nlong long == int64_t? no\r\n(sizeof(long long) == 8) && std::is_signed<long long>::value? yes\r\n(sizeof(int64_t) == 8) && std::is_signed<int64_t>::value? yes\r\nunsigned long long == uint64_t? no\r\n(sizeof(unsigned long long) == 8) && !std::is_signed<unsigned long long>::value? yes\r\n(sizeof(uint64_t) == 8) && !std::is_signed<uint64_t>::value? yes\r\n\r\n```\r\n\r\nOn a system where the current type constraint check works, the same code outputs this\r\n```\r\nint64_t...............: (x) 8\r\nlong..................: (l) 8\r\nlong int..............: (l) 8\r\nlong long int.........: (x) 8\r\nlong long.............: (x) 8\r\nuint64_t..............: (y) 8\r\nunsigned long.........: (m) 8\r\nunsigned long int.....: (m) 8\r\nunsigned long long int: (y) 8\r\nunsigned long long....: (y) 8\r\nlong long == int64_t? yes\r\n(sizeof(long long) == 8) && std::is_signed<long long>::value? yes\r\n(sizeof(int64_t) == 8) && std::is_signed<int64_t>::value? yes\r\nunsigned long long == uint64_t? yes\r\n(sizeof(unsigned long long) == 8) && !std::is_signed<unsigned long long>::value? yes\r\n(sizeof(uint64_t) == 8) && !std::is_signed<uint64_t>::value? yes\r\n```\r\n\r\nSince using an `int64_t` should be supported (as it is equivalent to `long long`), I propose that the code be modified to either use the integral types defined in `cstdint` (`int8_t`, `int16_t`, `int32_t`, `int64_t`), or the check should be changed to look for a 64-bit type that is signed using a combination of `sizeof` and `std::is_signed`\r\n\r\n### Source code / logs\r\nThe following example produces the error\r\n```\r\n#include <tensorflow/core/framework/op.h>\r\n#include <tensorflow/core/framework/op_kernel.h>\r\n\r\nREGISTER_OP(\"ExampleOp\").Attr(\"T: {int32, int64, uint32, uint64}\");\r\n\r\ntemplate <typename T>\r\nclass ExampleOp : public tensorflow::OpKernel {\r\npublic:\r\n  explicit ExampleOp(tensorflow::OpKernelConstruction* context) : OpKernel(context) {}\r\n\r\n  void Compute(tensorflow::OpKernelContext* context) override {}\r\n};\r\n\r\nREGISTER_KERNEL_BUILDER(Name(\"ExampleOp\").Device(tensorflow::DEVICE_CPU).TypeConstraint<int32_t>(\"T\"), ExampleOp<int32_t>);\r\nREGISTER_KERNEL_BUILDER(Name(\"ExampleOp\").Device(tensorflow::DEVICE_CPU).TypeConstraint<int64_t>(\"T\"), ExampleOp<int64_t>);\r\nREGISTER_KERNEL_BUILDER(Name(\"ExampleOp\").Device(tensorflow::DEVICE_CPU).TypeConstraint<uint32_t>(\"T\"), ExampleOp<uint32_t>);\r\nREGISTER_KERNEL_BUILDER(Name(\"ExampleOp\").Device(tensorflow::DEVICE_CPU).TypeConstraint<uint64_t>(\"T\"), ExampleOp<uint64_t>);\r\n```\r\n\r\nHere is the resulting compilation log\r\n```\r\n/usr/bin/c++  -Dmwe_EXPORTS -isystem /usr/local/lib/python3.5/dist-packages/tensorflow/include -I../src -march=native -mtune=native -fPIC -O3 -DNDEBUG -fPIC   -march=native -mtune=native -MD -MT CMakeFiles/mwe.dir/mwe.cpp.o -MF CMakeFiles/mwe.dir/mwe.cpp.o.d -o CMakeFiles/mwe.dir/mwe.cpp.o -c ../mwe.cpp\r\nIn file included from /usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/tensor.h:23:0,\r\n                 from /usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/device_base.h:23,\r\n                 from /usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/op_kernel.h:26,\r\n                 from ../mwe.cpp:2:\r\n/usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/types.h: In instantiation of \u2018struct tensorflow::DataTypeToEnum<long int>\u2019:\r\n/usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/kernel_def_builder.h:82:62:   required from \u2018tensorflow::KernelDefBuilder& tensorflow::KernelDefBuilder::TypeConstraint(const char*) [with T = long int]\u2019\r\n../mwe.cpp:16:1:   required from here\r\n/usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/types.h:356:3: error: static assertion failed: Specified Data Type not supported\r\n   static_assert(IsValidDataType<T>::value, \"Specified Data Type not supported\");\r\n   ^~~~~~~~~~~~~\r\nIn file included from /usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/op_kernel.h:28:0,\r\n                 from ../mwe.cpp:2:\r\n/usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/kernel_def_builder.h: In instantiation of \u2018tensorflow::KernelDefBuilder& tensorflow::KernelDefBuilder::TypeConstraint(const char*) [with T = long int]\u2019:\r\n../mwe.cpp:16:1:   required from here\r\n/usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/kernel_def_builder.h:82:62: error: \u2018v\u2019 is not a member of \u2018tensorflow::DataTypeToEnum<long int>\u2019\r\n   return this->TypeConstraint(attr_name, DataTypeToEnum<T>::v());\r\n                                          ~~~~~~~~~~~~~~~~~~~~^~\r\nIn file included from /usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/tensor.h:23:0,\r\n                 from /usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/device_base.h:23,\r\n                 from /usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/op_kernel.h:26,\r\n                 from ../mwe.cpp:2:\r\n/usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/types.h: In instantiation of \u2018struct tensorflow::DataTypeToEnum<long unsigned int>\u2019:\r\n/usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/kernel_def_builder.h:82:62:   required from \u2018tensorflow::KernelDefBuilder& tensorflow::KernelDefBuilder::TypeConstraint(const char*) [with T = long unsigned int]\u2019\r\n../mwe.cpp:20:1:   required from here\r\n/usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/types.h:356:3: error: static assertion failed: Specified Data Type not supported\r\n   static_assert(IsValidDataType<T>::value, \"Specified Data Type not supported\");\r\n   ^~~~~~~~~~~~~\r\nIn file included from /usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/op_kernel.h:28:0,\r\n                 from ../mwe.cpp:2:\r\n/usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/kernel_def_builder.h: In instantiation of \u2018tensorflow::KernelDefBuilder& tensorflow::KernelDefBuilder::TypeConstraint(const char*) [with T = long unsigned int]\u2019:\r\n../mwe.cpp:20:1:   required from here\r\n/usr/local/lib/python3.5/dist-packages/tensorflow/include/tensorflow/core/framework/kernel_def_builder.h:82:62: error: \u2018v\u2019 is not a member of \u2018tensorflow::DataTypeToEnum<long unsigned int>\u2019\r\n   return this->TypeConstraint(attr_name, DataTypeToEnum<T>::v());\r\n                                          ~~~~~~~~~~~~~~~~~~~~^~\r\n```\r\n\r\nEDIT: Added a minimal working example"}