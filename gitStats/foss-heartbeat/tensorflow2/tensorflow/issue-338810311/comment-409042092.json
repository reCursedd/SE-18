{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/409042092", "html_url": "https://github.com/tensorflow/tensorflow/issues/20586#issuecomment-409042092", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/20586", "id": 409042092, "node_id": "MDEyOklzc3VlQ29tbWVudDQwOTA0MjA5Mg==", "user": {"login": "Bidski", "id": 2320984, "node_id": "MDQ6VXNlcjIzMjA5ODQ=", "avatar_url": "https://avatars1.githubusercontent.com/u/2320984?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Bidski", "html_url": "https://github.com/Bidski", "followers_url": "https://api.github.com/users/Bidski/followers", "following_url": "https://api.github.com/users/Bidski/following{/other_user}", "gists_url": "https://api.github.com/users/Bidski/gists{/gist_id}", "starred_url": "https://api.github.com/users/Bidski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Bidski/subscriptions", "organizations_url": "https://api.github.com/users/Bidski/orgs", "repos_url": "https://api.github.com/users/Bidski/repos", "events_url": "https://api.github.com/users/Bidski/events{/privacy}", "received_events_url": "https://api.github.com/users/Bidski/received_events", "type": "User", "site_admin": false}, "created_at": "2018-07-30T23:13:53Z", "updated_at": "2018-07-30T23:13:53Z", "author_association": "NONE", "body_html": "<p>Using <code>#ifdef</code>s (or similar) to figure out when a system is \"broken\" sounds like a pretty ugly hack to me. What would you even check for in this instance?</p>\n<p>As I explained in the PR, using <code>tensorflow::int64</code> and friends is only a viable solution if everyone knows</p>\n<ol>\n<li>that these types exist (I had no idea of their existence until I stumbled across this error and began digging through the source to find the reason), and</li>\n<li>that it is required that they are used to achieve the intended results</li>\n</ol>\n<p>It is not obvious from any documentation that I have seen that either of these two things are the case, and I think it has been a large fluke that this issue has not arisen until now.</p>\n<p>I would also argue that it would be more precise, and just better overall, if the <code>typedef</code>s were changed to use the standard types that are defined in <code>cstdint</code> (<code>std::int64_t</code> and friends) as these types will guarantee that values have an exact width on every system that supports the type. A <code>long long</code> is guaranteed to be \"at least 64 bits\", so there may be some systems where a <code>long long</code> is larger than 64 bits. In instances where a type must be <em>exactly</em> 64 bits using a <code>long long</code> is asking for trouble.</p>\n<p>In either case, the PR that I have proposed will guard you against all of these issues and will allow anything that the system deems is \"a signed integral type that is 64 bits in size\" to be matched up to the <code>DT_INT64</code> enum value. To me, this seems like what should be the intended behaviour.</p>", "body_text": "Using #ifdefs (or similar) to figure out when a system is \"broken\" sounds like a pretty ugly hack to me. What would you even check for in this instance?\nAs I explained in the PR, using tensorflow::int64 and friends is only a viable solution if everyone knows\n\nthat these types exist (I had no idea of their existence until I stumbled across this error and began digging through the source to find the reason), and\nthat it is required that they are used to achieve the intended results\n\nIt is not obvious from any documentation that I have seen that either of these two things are the case, and I think it has been a large fluke that this issue has not arisen until now.\nI would also argue that it would be more precise, and just better overall, if the typedefs were changed to use the standard types that are defined in cstdint (std::int64_t and friends) as these types will guarantee that values have an exact width on every system that supports the type. A long long is guaranteed to be \"at least 64 bits\", so there may be some systems where a long long is larger than 64 bits. In instances where a type must be exactly 64 bits using a long long is asking for trouble.\nIn either case, the PR that I have proposed will guard you against all of these issues and will allow anything that the system deems is \"a signed integral type that is 64 bits in size\" to be matched up to the DT_INT64 enum value. To me, this seems like what should be the intended behaviour.", "body": "Using `#ifdef`s (or similar) to figure out when a system is \"broken\" sounds like a pretty ugly hack to me. What would you even check for in this instance? \r\n\r\nAs I explained in the PR, using `tensorflow::int64` and friends is only a viable solution if everyone knows\r\n\r\n1. that these types exist (I had no idea of their existence until I stumbled across this error and began digging through the source to find the reason), and\r\n1. that it is required that they are used to achieve the intended results\r\n\r\nIt is not obvious from any documentation that I have seen that either of these two things are the case, and I think it has been a large fluke that this issue has not arisen until now.\r\n\r\nI would also argue that it would be more precise, and just better overall, if the `typedef`s were changed to use the standard types that are defined in `cstdint` (`std::int64_t` and friends) as these types will guarantee that values have an exact width on every system that supports the type. A `long long` is guaranteed to be \"at least 64 bits\", so there may be some systems where a `long long` is larger than 64 bits. In instances where a type must be _exactly_ 64 bits using a `long long` is asking for trouble.\r\n\r\nIn either case, the PR that I have proposed will guard you against all of these issues and will allow anything that the system deems is \"a signed integral type that is 64 bits in size\" to be matched up to the `DT_INT64` enum value. To me, this seems like what should be the intended behaviour."}