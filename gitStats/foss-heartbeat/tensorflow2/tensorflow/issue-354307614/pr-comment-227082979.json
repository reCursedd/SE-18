{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/227082979", "pull_request_review_id": 167043851, "id": 227082979, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNzA4Mjk3OQ==", "diff_hunk": "@@ -0,0 +1,36 @@\n+/*\n+Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+*/\n+\n+package op\n+\n+import tf \"github.com/tensorflow/tensorflow/tensorflow/go\"\n+\n+// Gradients adds gradients computation ops to the graph according to scope.\n+//\n+// Arguments:\n+//  y: output of the function to derive\n+//  x: inputs of the function for which partial derivatives are computed\n+//  dx: if not null, the partial derivatives of some loss function L w.r.t. y\n+//\n+//  return the partial derivatives\n+func Gradients(scope *Scope, y []tf.Output, x []tf.Output, dx ...tf.Output) (output []tf.Output) {\n+\tvar err error\n+\tif output, err = scope.graph.AddGradients(scope.opName(scope.uniqueName(\"Gradients\")), y, x, dx); err != nil {", "path": "tensorflow/go/op/gradients.go", "position": null, "original_position": 31, "commit_id": "a911ecf5a94e037554f677670762b0122c062b41", "original_commit_id": "8c9d5eb52b0d8e551b0e751186edfcdecbef62fb", "user": {"login": "asimshankar", "id": 16018, "node_id": "MDQ6VXNlcjE2MDE4", "avatar_url": "https://avatars2.githubusercontent.com/u/16018?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asimshankar", "html_url": "https://github.com/asimshankar", "followers_url": "https://api.github.com/users/asimshankar/followers", "following_url": "https://api.github.com/users/asimshankar/following{/other_user}", "gists_url": "https://api.github.com/users/asimshankar/gists{/gist_id}", "starred_url": "https://api.github.com/users/asimshankar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asimshankar/subscriptions", "organizations_url": "https://api.github.com/users/asimshankar/orgs", "repos_url": "https://api.github.com/users/asimshankar/repos", "events_url": "https://api.github.com/users/asimshankar/events{/privacy}", "received_events_url": "https://api.github.com/users/asimshankar/received_events", "type": "User", "site_admin": false}, "body": "What I'd like to avoid here is confusion in that `Gradients` here takes a `Scope` as an argument but then ignores the fields of `Scope`. The user has no way of knowing what the difference between `Gradients` and a \"common op\" is (the API here isn't calling this out as something different from a \"common op\").\r\n\r\nThis confusion doesn't exist in the C API because there is no notion of a \"scope\".\r\nIt doesn't exist in the Java API yet because the Java scope doesn't implement control dependencies or device annotations yet.\r\n\r\nThere are ways to respect control dependencies and devices, for example, for control dependencies one option would be to first insert an `IdentityN` node for the inputs, add a control dependency on that, and then add the gradients. This would ensure that the gradient computation doesn't begin till the control inputs have been computed.\r\n\r\nI realized this will be a bit of work. Hence, my suggestion for this PR is to have `Gradients` lead to an error if it sees things in `Scope` that it does not support. To be more concrete, do something like:\r\n\r\n```go\r\nfunc Gradients(scope *Scope, y, ...) (output []tf.Output) {\r\n  if len(scope.controlDependencies) > 0 {\r\n    s.UpdateErr(\"Gradients\", fmt.Errorf(\"Gradients does not currently support control dependencies (via Scope.WithControlDependencies).\"));\r\n  }\r\n  if s.device != \"\" {\r\n   s.UpdateErr(\"Gradients\", fmt.Errorf(\"Gradients does not currently support device annotations (via Scope.WithDevice).\"))\r\n  }\r\n  ...\r\n}\r\n```\r\n\r\n(And to be extra helpful, perhaps add a comment inside `struct Scope` to remind future developers that if they add any field here, they should update the `Gradients` function to handle it)\r\n\r\nDoes that make sense?", "created_at": "2018-10-22T18:25:01Z", "updated_at": "2018-11-21T06:08:04Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/21895#discussion_r227082979", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/21895", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/227082979"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/21895#discussion_r227082979"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/21895"}}, "body_html": "<p>What I'd like to avoid here is confusion in that <code>Gradients</code> here takes a <code>Scope</code> as an argument but then ignores the fields of <code>Scope</code>. The user has no way of knowing what the difference between <code>Gradients</code> and a \"common op\" is (the API here isn't calling this out as something different from a \"common op\").</p>\n<p>This confusion doesn't exist in the C API because there is no notion of a \"scope\".<br>\nIt doesn't exist in the Java API yet because the Java scope doesn't implement control dependencies or device annotations yet.</p>\n<p>There are ways to respect control dependencies and devices, for example, for control dependencies one option would be to first insert an <code>IdentityN</code> node for the inputs, add a control dependency on that, and then add the gradients. This would ensure that the gradient computation doesn't begin till the control inputs have been computed.</p>\n<p>I realized this will be a bit of work. Hence, my suggestion for this PR is to have <code>Gradients</code> lead to an error if it sees things in <code>Scope</code> that it does not support. To be more concrete, do something like:</p>\n<div class=\"highlight highlight-source-go\"><pre><span class=\"pl-k\">func</span> <span class=\"pl-en\">Gradients</span>(<span class=\"pl-v\">scope</span> *<span class=\"pl-v\">Scope</span>, <span class=\"pl-v\">y</span>, ...) (<span class=\"pl-v\">output</span> []<span class=\"pl-v\">tf</span>.<span class=\"pl-v\">Output</span>) {\n  <span class=\"pl-k\">if</span> <span class=\"pl-c1\">len</span>(scope.<span class=\"pl-smi\">controlDependencies</span>) &gt; <span class=\"pl-c1\">0</span> {\n    s.<span class=\"pl-c1\">UpdateErr</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Gradients<span class=\"pl-pds\">\"</span></span>, fmt.<span class=\"pl-c1\">Errorf</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Gradients does not currently support control dependencies (via Scope.WithControlDependencies).<span class=\"pl-pds\">\"</span></span>));\n  }\n  <span class=\"pl-k\">if</span> s.<span class=\"pl-smi\">device</span> != <span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"pl-pds\">\"</span></span> {\n   s.<span class=\"pl-c1\">UpdateErr</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Gradients<span class=\"pl-pds\">\"</span></span>, fmt.<span class=\"pl-c1\">Errorf</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Gradients does not currently support device annotations (via Scope.WithDevice).<span class=\"pl-pds\">\"</span></span>))\n  }\n  ...\n}</pre></div>\n<p>(And to be extra helpful, perhaps add a comment inside <code>struct Scope</code> to remind future developers that if they add any field here, they should update the <code>Gradients</code> function to handle it)</p>\n<p>Does that make sense?</p>", "body_text": "What I'd like to avoid here is confusion in that Gradients here takes a Scope as an argument but then ignores the fields of Scope. The user has no way of knowing what the difference between Gradients and a \"common op\" is (the API here isn't calling this out as something different from a \"common op\").\nThis confusion doesn't exist in the C API because there is no notion of a \"scope\".\nIt doesn't exist in the Java API yet because the Java scope doesn't implement control dependencies or device annotations yet.\nThere are ways to respect control dependencies and devices, for example, for control dependencies one option would be to first insert an IdentityN node for the inputs, add a control dependency on that, and then add the gradients. This would ensure that the gradient computation doesn't begin till the control inputs have been computed.\nI realized this will be a bit of work. Hence, my suggestion for this PR is to have Gradients lead to an error if it sees things in Scope that it does not support. To be more concrete, do something like:\nfunc Gradients(scope *Scope, y, ...) (output []tf.Output) {\n  if len(scope.controlDependencies) > 0 {\n    s.UpdateErr(\"Gradients\", fmt.Errorf(\"Gradients does not currently support control dependencies (via Scope.WithControlDependencies).\"));\n  }\n  if s.device != \"\" {\n   s.UpdateErr(\"Gradients\", fmt.Errorf(\"Gradients does not currently support device annotations (via Scope.WithDevice).\"))\n  }\n  ...\n}\n(And to be extra helpful, perhaps add a comment inside struct Scope to remind future developers that if they add any field here, they should update the Gradients function to handle it)\nDoes that make sense?", "in_reply_to_id": 222117365}