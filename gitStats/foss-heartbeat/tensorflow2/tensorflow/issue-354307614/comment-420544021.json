{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/420544021", "html_url": "https://github.com/tensorflow/tensorflow/pull/21895#issuecomment-420544021", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/21895", "id": 420544021, "node_id": "MDEyOklzc3VlQ29tbWVudDQyMDU0NDAyMQ==", "user": {"login": "Cibifang", "id": 9337824, "node_id": "MDQ6VXNlcjkzMzc4MjQ=", "avatar_url": "https://avatars1.githubusercontent.com/u/9337824?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Cibifang", "html_url": "https://github.com/Cibifang", "followers_url": "https://api.github.com/users/Cibifang/followers", "following_url": "https://api.github.com/users/Cibifang/following{/other_user}", "gists_url": "https://api.github.com/users/Cibifang/gists{/gist_id}", "starred_url": "https://api.github.com/users/Cibifang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Cibifang/subscriptions", "organizations_url": "https://api.github.com/users/Cibifang/orgs", "repos_url": "https://api.github.com/users/Cibifang/repos", "events_url": "https://api.github.com/users/Cibifang/events{/privacy}", "received_events_url": "https://api.github.com/users/Cibifang/received_events", "type": "User", "site_admin": false}, "created_at": "2018-09-12T07:34:56Z", "updated_at": "2018-09-12T07:34:56Z", "author_association": "NONE", "body_html": "<p>Hi, <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=16018\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/asimshankar\">@asimshankar</a> Can you take a look again?</p>\n<p>Some details:</p>\n<ol>\n<li>\n<p>Different with Java implementation, <code>Gradients</code> have <code>prefix</code> as a parameters.<br>\nIf we just use <code>scope.namespace</code> as prefix, It will cause some problems:</p>\n<pre><code>// When scope.namespace == \"\"\n// the grads1[0].Op.Name() will start with \"gradients/\"\ngrads0 := Gradients(s,  []tf.Output{y0}, []tf.Output{x})\n\n// the grads1[0].Op.Name() will start with \"gradients_1/\"\ngrads1 := Gradients(s,  []tf.Output{y0}, []tf.Output{x})\n</code></pre>\n<p>It's OK because the scope.namespace is \"\", so the prefix is \"\".</p>\n<p>But something will be wrong when `scope.namespace is not \"\"</p>\n<pre><code>// When scope.namespace == \"sub\"\n // the grads1[0].Op.Name() will start with \"sub/\"\n grads0 := Gradients(s,  []tf.Output{y0}, []tf.Output{x})\n\n // It will cause error because use conflicted prefix `sub`\n grads1 := Gradients(s,  []tf.Output{y0}, []tf.Output{x})\n</code></pre>\n</li>\n</ol>\n<p>In the Java Implementation, it is solved by a new class <code>NameScope</code> with new method <code>makeOpName</code>.</p>\n<pre><code>// When scope.namespace == \"sub\"\n// If don't want to set prefix\n// grad0.dy(0).op().name() will start with \"sub/Gradients/\"\nGradients grad0 = Gradients.create(scope, y, Arrays.asList(x));\n\n// If want to set prefix \"MyGradients/\"\n// grad1.dy(0).op().name() will start with \"sub/MyGradients/`\nradients grad1 = Gradients.create(scope.withName(\"MyGradients\"), y, Arrays.asList(x));\n</code></pre>\n<p>to same with the implementation in Java, we need to add a <code>NameScope</code> struct, or add <code>opName</code>  to <code>Scope</code> structure(to be a default op name as prefix for Gradients). I don't know if it is good to do that for this feature.<br>\nSo just add a <code>prefix</code> para to method <code>Gradients</code></p>\n<ol start=\"2\">\n<li>Enforce uniqueness of custom prefixes for gradients in method <code>Gradients</code> in op package, just like in Java</li>\n</ol>", "body_text": "Hi, @asimshankar Can you take a look again?\nSome details:\n\n\nDifferent with Java implementation, Gradients have prefix as a parameters.\nIf we just use scope.namespace as prefix, It will cause some problems:\n// When scope.namespace == \"\"\n// the grads1[0].Op.Name() will start with \"gradients/\"\ngrads0 := Gradients(s,  []tf.Output{y0}, []tf.Output{x})\n\n// the grads1[0].Op.Name() will start with \"gradients_1/\"\ngrads1 := Gradients(s,  []tf.Output{y0}, []tf.Output{x})\n\nIt's OK because the scope.namespace is \"\", so the prefix is \"\".\nBut something will be wrong when `scope.namespace is not \"\"\n// When scope.namespace == \"sub\"\n // the grads1[0].Op.Name() will start with \"sub/\"\n grads0 := Gradients(s,  []tf.Output{y0}, []tf.Output{x})\n\n // It will cause error because use conflicted prefix `sub`\n grads1 := Gradients(s,  []tf.Output{y0}, []tf.Output{x})\n\n\n\nIn the Java Implementation, it is solved by a new class NameScope with new method makeOpName.\n// When scope.namespace == \"sub\"\n// If don't want to set prefix\n// grad0.dy(0).op().name() will start with \"sub/Gradients/\"\nGradients grad0 = Gradients.create(scope, y, Arrays.asList(x));\n\n// If want to set prefix \"MyGradients/\"\n// grad1.dy(0).op().name() will start with \"sub/MyGradients/`\nradients grad1 = Gradients.create(scope.withName(\"MyGradients\"), y, Arrays.asList(x));\n\nto same with the implementation in Java, we need to add a NameScope struct, or add opName  to Scope structure(to be a default op name as prefix for Gradients). I don't know if it is good to do that for this feature.\nSo just add a prefix para to method Gradients\n\nEnforce uniqueness of custom prefixes for gradients in method Gradients in op package, just like in Java", "body": "Hi, @asimshankar Can you take a look again?\r\n\r\nSome details:\r\n1. Different with Java implementation, `Gradients` have `prefix` as a parameters.\r\n  If we just use `scope.namespace` as prefix, It will cause some problems:\r\n    ```\r\n    // When scope.namespace == \"\"\r\n    // the grads1[0].Op.Name() will start with \"gradients/\"\r\n    grads0 := Gradients(s,  []tf.Output{y0}, []tf.Output{x})\r\n\r\n    // the grads1[0].Op.Name() will start with \"gradients_1/\"\r\n    grads1 := Gradients(s,  []tf.Output{y0}, []tf.Output{x})\r\n    ```\r\n   It's OK because the scope.namespace is \"\", so the prefix is \"\".\r\n\r\n   But something will be wrong when `scope.namespace is not \"\"\r\n   ```\r\n   // When scope.namespace == \"sub\"\r\n    // the grads1[0].Op.Name() will start with \"sub/\"\r\n    grads0 := Gradients(s,  []tf.Output{y0}, []tf.Output{x})\r\n\r\n    // It will cause error because use conflicted prefix `sub`\r\n    grads1 := Gradients(s,  []tf.Output{y0}, []tf.Output{x})\r\n   ```\r\n\r\n  In the Java Implementation, it is solved by a new class `NameScope` with new method `makeOpName`.\r\n  ```\r\n  // When scope.namespace == \"sub\"\r\n  // If don't want to set prefix\r\n  // grad0.dy(0).op().name() will start with \"sub/Gradients/\"\r\n  Gradients grad0 = Gradients.create(scope, y, Arrays.asList(x));\r\n\r\n  // If want to set prefix \"MyGradients/\"\r\n  // grad1.dy(0).op().name() will start with \"sub/MyGradients/`\r\n  radients grad1 = Gradients.create(scope.withName(\"MyGradients\"), y, Arrays.asList(x));\r\n  ```\r\n\r\n  to same with the implementation in Java, we need to add a `NameScope` struct, or add `opName`  to `Scope` structure(to be a default op name as prefix for Gradients). I don't know if it is good to do that for this feature. \r\n  So just add a `prefix` para to method `Gradients`\r\n\r\n2. Enforce uniqueness of custom prefixes for gradients in method `Gradients` in op package, just like in Java"}