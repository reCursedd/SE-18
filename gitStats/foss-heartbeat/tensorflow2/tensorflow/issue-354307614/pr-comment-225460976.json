{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/225460976", "pull_request_review_id": 165062124, "id": 225460976, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTQ2MDk3Ng==", "diff_hunk": "@@ -0,0 +1,36 @@\n+/*\n+Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+*/\n+\n+package op\n+\n+import tf \"github.com/tensorflow/tensorflow/tensorflow/go\"\n+\n+// Gradients adds gradients computation ops to the graph according to scope.\n+//\n+// Arguments:\n+//  y: output of the function to derive\n+//  x: inputs of the function for which partial derivatives are computed\n+//  dx: if not null, the partial derivatives of some loss function L w.r.t. y\n+//\n+//  return the partial derivatives\n+func Gradients(scope *Scope, y []tf.Output, x []tf.Output, dx ...tf.Output) (output []tf.Output) {\n+\tvar err error\n+\tif output, err = scope.graph.AddGradients(scope.opName(scope.uniqueName(\"Gradients\")), y, x, dx); err != nil {", "path": "tensorflow/go/op/gradients.go", "position": null, "original_position": 31, "commit_id": "a911ecf5a94e037554f677670762b0122c062b41", "original_commit_id": "8c9d5eb52b0d8e551b0e751186edfcdecbef62fb", "user": {"login": "Cibifang", "id": 9337824, "node_id": "MDQ6VXNlcjkzMzc4MjQ=", "avatar_url": "https://avatars1.githubusercontent.com/u/9337824?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Cibifang", "html_url": "https://github.com/Cibifang", "followers_url": "https://api.github.com/users/Cibifang/followers", "following_url": "https://api.github.com/users/Cibifang/following{/other_user}", "gists_url": "https://api.github.com/users/Cibifang/gists{/gist_id}", "starred_url": "https://api.github.com/users/Cibifang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Cibifang/subscriptions", "organizations_url": "https://api.github.com/users/Cibifang/orgs", "repos_url": "https://api.github.com/users/Cibifang/repos", "events_url": "https://api.github.com/users/Cibifang/events{/privacy}", "received_events_url": "https://api.github.com/users/Cibifang/received_events", "type": "User", "site_admin": false}, "body": "Sorry for the delay. I'm not sure what you are meaning about \"missing other elements of the `scope`\"...\r\n\r\nIf you are talking about `ControlDependencies` or `Device`, I think `WithControlDependencies` and `WithDevice` is already enough if who want to set them.\r\n\r\nOf course we can also add it to `Gradient` and set it in `Gradient`,but the parameters will be more complex. \r\nBecause the `dx` is already a optional parameters and it's a `[]Outputs`. So the declaration will be like below:\r\n```\r\nfunc Gradients(scope *Scope, y []tf.Output, x []tf.Output, option ...map[string]interface{}) (output []tf.Output)\r\n```\r\nAnd the call will be like:\r\n```\r\nsub := s.SubScope(\"sub\")\r\ngrads1 := Gradients(sub, []tf.Output{y2}, {\"dx\":[]tf.Output{x1, x2}, \"device\": \"...\", \"something\":\"something\"})\r\n```\r\nThe implementation will be like:\r\n```\r\nattrs := map[string]interface{}{}\r\nfor key, a := range optional {\r\n\tif key == \"device\" {\r\n\t\tdx = a.([]tf.Output)\r\n\t} else {\r\n\t\ta(attrs)\r\n\t}\r\n}\r\nscope.graph.AddGradients(scope.opName(\"Gradients\"), y, x, dx)\r\nopspec := tf.OpSpec{\r\n\tType: \"Gradients\",\r\n\tInput: []tf.Input{},\r\n\tAttrs: attrs,\r\n}\r\nop := scope.AddOperation(opspec)\r\n```\r\n\r\nIt adds too much complexity but only helps us dond't need `WithControlDependencies` or `WithDevice`.  I'm not sure it is well.", "created_at": "2018-10-16T09:20:41Z", "updated_at": "2018-11-21T06:08:04Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/21895#discussion_r225460976", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/21895", "author_association": "NONE", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/225460976"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/21895#discussion_r225460976"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/21895"}}, "body_html": "<p>Sorry for the delay. I'm not sure what you are meaning about \"missing other elements of the <code>scope</code>\"...</p>\n<p>If you are talking about <code>ControlDependencies</code> or <code>Device</code>, I think <code>WithControlDependencies</code> and <code>WithDevice</code> is already enough if who want to set them.</p>\n<p>Of course we can also add it to <code>Gradient</code> and set it in <code>Gradient</code>,but the parameters will be more complex.<br>\nBecause the <code>dx</code> is already a optional parameters and it's a <code>[]Outputs</code>. So the declaration will be like below:</p>\n<pre><code>func Gradients(scope *Scope, y []tf.Output, x []tf.Output, option ...map[string]interface{}) (output []tf.Output)\n</code></pre>\n<p>And the call will be like:</p>\n<pre><code>sub := s.SubScope(\"sub\")\ngrads1 := Gradients(sub, []tf.Output{y2}, {\"dx\":[]tf.Output{x1, x2}, \"device\": \"...\", \"something\":\"something\"})\n</code></pre>\n<p>The implementation will be like:</p>\n<pre><code>attrs := map[string]interface{}{}\nfor key, a := range optional {\n\tif key == \"device\" {\n\t\tdx = a.([]tf.Output)\n\t} else {\n\t\ta(attrs)\n\t}\n}\nscope.graph.AddGradients(scope.opName(\"Gradients\"), y, x, dx)\nopspec := tf.OpSpec{\n\tType: \"Gradients\",\n\tInput: []tf.Input{},\n\tAttrs: attrs,\n}\nop := scope.AddOperation(opspec)\n</code></pre>\n<p>It adds too much complexity but only helps us dond't need <code>WithControlDependencies</code> or <code>WithDevice</code>.  I'm not sure it is well.</p>", "body_text": "Sorry for the delay. I'm not sure what you are meaning about \"missing other elements of the scope\"...\nIf you are talking about ControlDependencies or Device, I think WithControlDependencies and WithDevice is already enough if who want to set them.\nOf course we can also add it to Gradient and set it in Gradient,but the parameters will be more complex.\nBecause the dx is already a optional parameters and it's a []Outputs. So the declaration will be like below:\nfunc Gradients(scope *Scope, y []tf.Output, x []tf.Output, option ...map[string]interface{}) (output []tf.Output)\n\nAnd the call will be like:\nsub := s.SubScope(\"sub\")\ngrads1 := Gradients(sub, []tf.Output{y2}, {\"dx\":[]tf.Output{x1, x2}, \"device\": \"...\", \"something\":\"something\"})\n\nThe implementation will be like:\nattrs := map[string]interface{}{}\nfor key, a := range optional {\n\tif key == \"device\" {\n\t\tdx = a.([]tf.Output)\n\t} else {\n\t\ta(attrs)\n\t}\n}\nscope.graph.AddGradients(scope.opName(\"Gradients\"), y, x, dx)\nopspec := tf.OpSpec{\n\tType: \"Gradients\",\n\tInput: []tf.Input{},\n\tAttrs: attrs,\n}\nop := scope.AddOperation(opspec)\n\nIt adds too much complexity but only helps us dond't need WithControlDependencies or WithDevice.  I'm not sure it is well.", "in_reply_to_id": 222117365}