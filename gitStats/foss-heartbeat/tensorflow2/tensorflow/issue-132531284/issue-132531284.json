{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/1037", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/1037/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/1037/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/1037/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/1037", "id": 132531284, "node_id": "MDU6SXNzdWUxMzI1MzEyODQ=", "number": 1037, "title": "bidirectional_rnn return state", "user": {"login": "lucaswiser", "id": 13629847, "node_id": "MDQ6VXNlcjEzNjI5ODQ3", "avatar_url": "https://avatars1.githubusercontent.com/u/13629847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lucaswiser", "html_url": "https://github.com/lucaswiser", "followers_url": "https://api.github.com/users/lucaswiser/followers", "following_url": "https://api.github.com/users/lucaswiser/following{/other_user}", "gists_url": "https://api.github.com/users/lucaswiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/lucaswiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lucaswiser/subscriptions", "organizations_url": "https://api.github.com/users/lucaswiser/orgs", "repos_url": "https://api.github.com/users/lucaswiser/repos", "events_url": "https://api.github.com/users/lucaswiser/events{/privacy}", "received_events_url": "https://api.github.com/users/lucaswiser/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": {"login": "ebrevdo", "id": 1794715, "node_id": "MDQ6VXNlcjE3OTQ3MTU=", "avatar_url": "https://avatars0.githubusercontent.com/u/1794715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebrevdo", "html_url": "https://github.com/ebrevdo", "followers_url": "https://api.github.com/users/ebrevdo/followers", "following_url": "https://api.github.com/users/ebrevdo/following{/other_user}", "gists_url": "https://api.github.com/users/ebrevdo/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebrevdo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebrevdo/subscriptions", "organizations_url": "https://api.github.com/users/ebrevdo/orgs", "repos_url": "https://api.github.com/users/ebrevdo/repos", "events_url": "https://api.github.com/users/ebrevdo/events{/privacy}", "received_events_url": "https://api.github.com/users/ebrevdo/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "ebrevdo", "id": 1794715, "node_id": "MDQ6VXNlcjE3OTQ3MTU=", "avatar_url": "https://avatars0.githubusercontent.com/u/1794715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebrevdo", "html_url": "https://github.com/ebrevdo", "followers_url": "https://api.github.com/users/ebrevdo/followers", "following_url": "https://api.github.com/users/ebrevdo/following{/other_user}", "gists_url": "https://api.github.com/users/ebrevdo/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebrevdo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebrevdo/subscriptions", "organizations_url": "https://api.github.com/users/ebrevdo/orgs", "repos_url": "https://api.github.com/users/ebrevdo/repos", "events_url": "https://api.github.com/users/ebrevdo/events{/privacy}", "received_events_url": "https://api.github.com/users/ebrevdo/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 12, "created_at": "2016-02-09T20:54:09Z", "updated_at": "2016-06-10T18:51:59Z", "closed_at": "2016-06-10T18:51:59Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Hi I am wondering why the bi-directional rnn doesn't return a final state? From a code point of view it would be very easy to return. I.e line 301 in rnn.py</p>\n<p>output_fw, _ = rnn(cell_fw, inputs, initial_state_fw, dtype,<br>\nsequence_length)</p>\n<p>One could just return _ (named as final_state or whatever) with the concatenated outputs at the end. Is there any theoretical reason why you would never want the final output state? I was planning on feeding the final forward state as the initial state of the forward and backward rnn's on the next pass. The reason I am wanting to do this is the sequences I am working on are much longer than the number of steps I can unroll (seqs are about 15k on average, I'm unrolling 1000 steps) so continuing state is pretty important. It seems weird that the bidirectional rnn would even have the ability to input an initial state but you can't return the output state (what state would you feed in if not the output of the last pass?)</p>\n<p>Let me know what you think, i'm no rnn expert.</p>\n<p>Off topic but does anyone have any advice for super long sequences? What is the maximum you think I could unroll? Are there other techniques I could use besides long unroll and refeeding the outputs? Can LSTM even learn 1000+ step dependencies?</p>", "body_text": "Hi I am wondering why the bi-directional rnn doesn't return a final state? From a code point of view it would be very easy to return. I.e line 301 in rnn.py\noutput_fw, _ = rnn(cell_fw, inputs, initial_state_fw, dtype,\nsequence_length)\nOne could just return _ (named as final_state or whatever) with the concatenated outputs at the end. Is there any theoretical reason why you would never want the final output state? I was planning on feeding the final forward state as the initial state of the forward and backward rnn's on the next pass. The reason I am wanting to do this is the sequences I am working on are much longer than the number of steps I can unroll (seqs are about 15k on average, I'm unrolling 1000 steps) so continuing state is pretty important. It seems weird that the bidirectional rnn would even have the ability to input an initial state but you can't return the output state (what state would you feed in if not the output of the last pass?)\nLet me know what you think, i'm no rnn expert.\nOff topic but does anyone have any advice for super long sequences? What is the maximum you think I could unroll? Are there other techniques I could use besides long unroll and refeeding the outputs? Can LSTM even learn 1000+ step dependencies?", "body": "Hi I am wondering why the bi-directional rnn doesn't return a final state? From a code point of view it would be very easy to return. I.e line 301 in rnn.py  \n\n output_fw, _ = rnn(cell_fw, inputs, initial_state_fw, dtype,\n                       sequence_length)\n\nOne could just return _ (named as final_state or whatever) with the concatenated outputs at the end. Is there any theoretical reason why you would never want the final output state? I was planning on feeding the final forward state as the initial state of the forward and backward rnn's on the next pass. The reason I am wanting to do this is the sequences I am working on are much longer than the number of steps I can unroll (seqs are about 15k on average, I'm unrolling 1000 steps) so continuing state is pretty important. It seems weird that the bidirectional rnn would even have the ability to input an initial state but you can't return the output state (what state would you feed in if not the output of the last pass?) \n\nLet me know what you think, i'm no rnn expert. \n\nOff topic but does anyone have any advice for super long sequences? What is the maximum you think I could unroll? Are there other techniques I could use besides long unroll and refeeding the outputs? Can LSTM even learn 1000+ step dependencies? \n"}