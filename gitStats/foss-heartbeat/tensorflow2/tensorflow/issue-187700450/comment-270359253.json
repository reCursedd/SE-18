{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/270359253", "html_url": "https://github.com/tensorflow/tensorflow/pull/5450#issuecomment-270359253", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5450", "id": 270359253, "node_id": "MDEyOklzc3VlQ29tbWVudDI3MDM1OTI1Mw==", "user": {"login": "namrata-ibm", "id": 21953668, "node_id": "MDQ6VXNlcjIxOTUzNjY4", "avatar_url": "https://avatars3.githubusercontent.com/u/21953668?v=4", "gravatar_id": "", "url": "https://api.github.com/users/namrata-ibm", "html_url": "https://github.com/namrata-ibm", "followers_url": "https://api.github.com/users/namrata-ibm/followers", "following_url": "https://api.github.com/users/namrata-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/namrata-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/namrata-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/namrata-ibm/subscriptions", "organizations_url": "https://api.github.com/users/namrata-ibm/orgs", "repos_url": "https://api.github.com/users/namrata-ibm/repos", "events_url": "https://api.github.com/users/namrata-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/namrata-ibm/received_events", "type": "User", "site_admin": false}, "created_at": "2017-01-04T12:23:16Z", "updated_at": "2017-01-04T12:23:16Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=326106\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/aselle\">@aselle</a> , ok, so I tried running the test without setting decode_raw option for little endian, This caused the test to fail with error <code>\"UnimplementedError: Unimplemented support for little_endian=true\"</code>.<br>\nNext, I removed below assert to verify if the further code for copying the data works. This resulted in test case to pass on Big Endian as it copies data  byte-by-byte.</p>\n<pre><code>     DCHECK_EQ(flat_in.size(), out.dimensions()[0]);\n-    OP_REQUIRES(\n-        context,\n-        little_endian_ == ::tensorflow::port::kLittleEndian || sizeof(T) == 1,\n-        errors::Unimplemented(\"Unimplemented support for little_endian=\",\n-                              little_endian_ ? \"true\" : \"false\"));\n     // Endianness matches, so just copy each string byte-for-byte.\n     T* out_data = out.data();\n     for (int64 i = 0; i &lt; flat_in.size(); ++i) {\n\t   const T* in_data = reinterpret_cast&lt;const T*&gt;(flat_in(i).data());\n       memcpy(out_data, in_data, str_size);\n       out_data += added_dim;\n     }\n\n</code></pre>\n<p>The only change in <a href=\"https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/kernel_tests/decode_raw_op_test.py\">test case </a>for Int16 for Big Endian was</p>\n<pre><code>     if sys.byteorder == \"big\": \n        self.assertAllEqual([[ord(\"A\") * 256 + ord(\"a\"), \n                                ord(\"B\") * 256 + ord(\"C\")]], result) \n     else: \n        self.assertAllEqual([[ord(\"A\") + ord(\"a\") * 256, \n                                ord(\"B\") + ord(\"C\") * 256]], result) \n\n</code></pre>", "body_text": "@aselle , ok, so I tried running the test without setting decode_raw option for little endian, This caused the test to fail with error \"UnimplementedError: Unimplemented support for little_endian=true\".\nNext, I removed below assert to verify if the further code for copying the data works. This resulted in test case to pass on Big Endian as it copies data  byte-by-byte.\n     DCHECK_EQ(flat_in.size(), out.dimensions()[0]);\n-    OP_REQUIRES(\n-        context,\n-        little_endian_ == ::tensorflow::port::kLittleEndian || sizeof(T) == 1,\n-        errors::Unimplemented(\"Unimplemented support for little_endian=\",\n-                              little_endian_ ? \"true\" : \"false\"));\n     // Endianness matches, so just copy each string byte-for-byte.\n     T* out_data = out.data();\n     for (int64 i = 0; i < flat_in.size(); ++i) {\n\t   const T* in_data = reinterpret_cast<const T*>(flat_in(i).data());\n       memcpy(out_data, in_data, str_size);\n       out_data += added_dim;\n     }\n\n\nThe only change in test case for Int16 for Big Endian was\n     if sys.byteorder == \"big\": \n        self.assertAllEqual([[ord(\"A\") * 256 + ord(\"a\"), \n                                ord(\"B\") * 256 + ord(\"C\")]], result) \n     else: \n        self.assertAllEqual([[ord(\"A\") + ord(\"a\") * 256, \n                                ord(\"B\") + ord(\"C\") * 256]], result)", "body": "@aselle , ok, so I tried running the test without setting decode_raw option for little endian, This caused the test to fail with error `\"UnimplementedError: Unimplemented support for little_endian=true\"`. \r\nNext, I removed below assert to verify if the further code for copying the data works. This resulted in test case to pass on Big Endian as it copies data  byte-by-byte.\r\n\r\n```\r\n     DCHECK_EQ(flat_in.size(), out.dimensions()[0]);\r\n-    OP_REQUIRES(\r\n-        context,\r\n-        little_endian_ == ::tensorflow::port::kLittleEndian || sizeof(T) == 1,\r\n-        errors::Unimplemented(\"Unimplemented support for little_endian=\",\r\n-                              little_endian_ ? \"true\" : \"false\"));\r\n     // Endianness matches, so just copy each string byte-for-byte.\r\n     T* out_data = out.data();\r\n     for (int64 i = 0; i < flat_in.size(); ++i) {\r\n\t   const T* in_data = reinterpret_cast<const T*>(flat_in(i).data());\r\n       memcpy(out_data, in_data, str_size);\r\n       out_data += added_dim;\r\n     }\r\n\r\n```\r\nThe only change in [test case ](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/kernel_tests/decode_raw_op_test.py)for Int16 for Big Endian was  \r\n```\r\n     if sys.byteorder == \"big\": \r\n        self.assertAllEqual([[ord(\"A\") * 256 + ord(\"a\"), \r\n                                ord(\"B\") * 256 + ord(\"C\")]], result) \r\n     else: \r\n        self.assertAllEqual([[ord(\"A\") + ord(\"a\") * 256, \r\n                                ord(\"B\") + ord(\"C\") * 256]], result) \r\n\r\n```\t\t\t\t\r\n"}