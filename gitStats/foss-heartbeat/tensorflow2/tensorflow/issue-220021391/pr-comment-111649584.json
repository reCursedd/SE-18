{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/111649584", "pull_request_review_id": 32912211, "id": 111649584, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDExMTY0OTU4NA==", "diff_hunk": "@@ -97,9 +84,141 @@ class FFTGPUBase : public OpKernel {\n   virtual bool IsForward() const = 0;\n   virtual bool IsReal() const = 0;\n \n- private:\n+  // The function that actually computes the FFT.\n+  virtual void DoFFT(OpKernelContext* ctx, const Tensor& in, uint64* fft_shape,\n+                     Tensor* out) = 0;\n+};\n+\n+typedef Eigen::ThreadPoolDevice CPUDevice;\n+\n+template <typename Device, typename TInput, typename TOutput,\n+          int FFTResultType, int FFTDir, int FFTRank>\n+struct FFTFunctor {\n+  void operator()(const Device& d,\n+                  typename TTypes<TOutput, FFTRank + 1>::Tensor output,\n+                  typename TTypes<TInput, FFTRank + 1>::Tensor input) {\n+    // Create the axes (which are always trailing).\n+    auto axes = Eigen::ArrayXi::LinSpaced(FFTRank, 1, FFTRank);\n+    // Evaluate the fft on the specified device.\n+    output.device(d) = input.template fft<FFTResultType, FFTDir>(axes);\n+  }\n+};\n+\n+template <bool Forward, bool _Real, int FFTRank>\n+class FFTCPU : public FFTBase {\n+ public:\n+  using FFTBase::FFTBase;\n+ protected:\n+  int Rank() const override { return FFTRank; }\n+  bool IsForward() const override { return Forward; }\n+  bool IsReal() const override { return _Real; }\n+\n+  void DoFFT(OpKernelContext* ctx, const Tensor& in, uint64* fft_shape,\n+             Tensor* out) override {\n+    if (!IsReal()) {\n+      auto input = ((Tensor) in).flat_inner_dims<complex64, FFTRank + 1>();\n+\n+      // Apply the functor.\n+      FFTFunctor<CPUDevice, complex64, complex64, Eigen::BothParts,\n+                Forward ? Eigen::FFT_FORWARD : Eigen::FFT_REVERSE,\n+                FFTRank> functor;\n+      functor(ctx->eigen_device<CPUDevice>(),\n+              out->flat_inner_dims<complex64, FFTRank + 1>(), input);\n+    }\n+    else {\n+      if (IsForward()) {\n+        auto input = ((Tensor) in).flat_inner_dims<float, FFTRank + 1>();\n+        // Create a temporary placeholder for the full FFT.\n+        Tensor temp;\n+        OP_REQUIRES_OK(ctx,ctx->allocate_temp(\n+          DataTypeToEnum<complex64>::v(), in.shape(), &temp\n+        ));\n+        auto full_fft = temp.flat_inner_dims<complex64, FFTRank + 1>();\n+        // Apply the functor.\n+        FFTFunctor<CPUDevice, float, complex64, Eigen::BothParts,\n+                  Eigen::FFT_FORWARD, FFTRank> functor;\n+        functor(ctx->eigen_device<CPUDevice>(), full_fft, input);\n+        // Create zero indices for slicing.\n+        Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> startIndices;\n+        // Convert output to tensor and get tensor size for slicing.\n+        auto output = out->flat_inner_dims<complex64, FFTRank + 1>();\n+        auto sizes = output.dimensions();\n+        // Slice the full FFT to get the non-negative frequency components only.\n+        output.slice(startIndices, sizes) =\n+          full_fft.slice(startIndices, sizes);\n+      }\n+      else {\n+        auto input = ((Tensor) in).flat_inner_dims<complex64, FFTRank + 1>();\n+        // The first dimension contains the zero-frequency component which we\n+        // do not want to duplicate. So we reconstruct the complex signal by\n+        // (1) slicing from the second element, (2) reversing the order,\n+        // (3) taking the complex conjugate, (4) concatenating with the original\n+        // input. Note that for an even input length, the last element is the\n+        // Nyquist frequency which we also do not want to duplicate.\n+        Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> startIndices;\n+        startIndices[FFTRank] = 1;\n+        auto sizes = input.dimensions();\n+        if (sizes[FFTRank] % 2 == 0) {\n+          sizes[FFTRank] -= 1;\n+        }\n+        auto cc = input.slice(startIndices, sizes).conjugate()\n+          .reverse(FFTRank);\n+        auto full_fft = input.concatenate(cc, FFTRank);\n+\n+        // Evaluate the IFFT\n+        auto output = out->flat_inner_dims<float, FFTRank + 1>();\n+        FFTFunctor<CPUDevice, complex64, float, Eigen::RealPart,\n+                  Eigen::FFT_REVERSE, FFTRank> functor;\n+        functor(ctx->eigen_device<CPUDevice>(), output, full_fft);", "path": "tensorflow/core/kernels/fft_ops.cc", "position": null, "original_position": 126, "commit_id": "e6da919d85a75ba32258b3e578d8dbe0dd49188e", "original_commit_id": "cfce2b036ea33aeb2742fb4219e75c2652dad3c7", "user": {"login": "rryan", "id": 26527, "node_id": "MDQ6VXNlcjI2NTI3", "avatar_url": "https://avatars3.githubusercontent.com/u/26527?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rryan", "html_url": "https://github.com/rryan", "followers_url": "https://api.github.com/users/rryan/followers", "following_url": "https://api.github.com/users/rryan/following{/other_user}", "gists_url": "https://api.github.com/users/rryan/gists{/gist_id}", "starred_url": "https://api.github.com/users/rryan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rryan/subscriptions", "organizations_url": "https://api.github.com/users/rryan/orgs", "repos_url": "https://api.github.com/users/rryan/repos", "events_url": "https://api.github.com/users/rryan/events{/privacy}", "received_events_url": "https://api.github.com/users/rryan/received_events", "type": "User", "site_admin": false}, "body": "Based on the compiler errors I'm seeing here:\r\nhttps://ci.tensorflow.org/job/tensorflow-pull-requests-cpu/4430/console\r\nthey all seem to be from the IRFFT here (line 172):\r\n```\r\ntensorflow/core/kernels/fft_ops.cc:172:65: error: no match for call to\r\n\r\n'(tensorflow::FFTFunctor<Eigen::ThreadPoolDevice, std::complex<float>, float, 0, 1, 3>) (const Eigen::ThreadPoolDevice&, Eigen::TensorMap<Eigen::Tensor<float, 4, 1, long int>, 16, Eigen::MakePointer>&, Eigen::TensorConcatenationOp<const int, Eigen::TensorMap<Eigen::Tensor<std::complex<float>, 4, 1, long int>, 16, Eigen::MakePointer>, Eigen::TensorReverseOp<const int, const Eigen::TensorCwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::TensorSlicingOp<const Eigen::DSizes<long int, 4>, const Eigen::DSizes<long int, 4>, Eigen::TensorMap<Eigen::Tensor<std::complex<float>, 4, 1, long int>, 16, Eigen::MakePointer> > > > >&)'\r\n         functor(ctx->eigen_device<CPUDevice>(), output, full_fft);\r\n\r\nno known conversion for argument 3 from \r\n\r\n'Eigen::TensorConcatenationOp<const int, Eigen::TensorMap<Eigen::Tensor<std::complex<float>, 4, 1, long int>, 16, Eigen::MakePointer>, Eigen::TensorReverseOp<const int, const Eigen::TensorCwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::TensorSlicingOp<const Eigen::DSizes<long int, 4>, const Eigen::DSizes<long int, 4>, Eigen::TensorMap<Eigen::Tensor<std::complex<float>, 4, 1, long int>, 16, Eigen::MakePointer> > > > >'\r\n\r\nto \r\n\r\n'tensorflow::TTypes<std::complex<float>, 4, long int>::Tensor {aka Eigen::TensorMap<Eigen::Tensor<std::complex<float>, 4, 1, long int>, 16, Eigen::MakePointer>}'\r\n```\r\n\r\nI think one problem is that `Eigen::TensorConcatenationOp<const int, Eigen::TensorMap<Eigen::Tensor<std::complex<float>, 4, 1, long int>, 16, Eigen::MakePointer>, Eigen::TensorReverseOp<const int, const Eigen::TensorCwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::TensorSlicingOp<const Eigen::DSizes<long int, 4>, const Eigen::DSizes<long int, 4>, Eigen::TensorMap<Eigen::Tensor<std::complex<float>, 4, 1, long int>, 16, Eigen::MakePointer> > > > >` is not convertible to `typename TTypes<TInput, FFTRank + 1>::Tensor`. \r\n\r\nMaybe FFTFunctor needs to be changed to take expressions as arguments instead of TensorMaps?\r\n\r\nI think it would also work to push the Eigen expressions here (which aren't convertible to TensorMap without an `.eval()`?) into a template specialization of FFTFunctor for TInput=float TOutput=complex64 and TInput=complex64 TOutput=float ? ", "created_at": "2017-04-14T23:27:43Z", "updated_at": "2017-05-17T11:28:15Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/9029#discussion_r111649584", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/9029", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/111649584"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/9029#discussion_r111649584"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/9029"}}, "body_html": "<p>Based on the compiler errors I'm seeing here:<br>\n<a href=\"https://ci.tensorflow.org/job/tensorflow-pull-requests-cpu/4430/console\" rel=\"nofollow\">https://ci.tensorflow.org/job/tensorflow-pull-requests-cpu/4430/console</a><br>\nthey all seem to be from the IRFFT here (line 172):</p>\n<pre><code>tensorflow/core/kernels/fft_ops.cc:172:65: error: no match for call to\n\n'(tensorflow::FFTFunctor&lt;Eigen::ThreadPoolDevice, std::complex&lt;float&gt;, float, 0, 1, 3&gt;) (const Eigen::ThreadPoolDevice&amp;, Eigen::TensorMap&lt;Eigen::Tensor&lt;float, 4, 1, long int&gt;, 16, Eigen::MakePointer&gt;&amp;, Eigen::TensorConcatenationOp&lt;const int, Eigen::TensorMap&lt;Eigen::Tensor&lt;std::complex&lt;float&gt;, 4, 1, long int&gt;, 16, Eigen::MakePointer&gt;, Eigen::TensorReverseOp&lt;const int, const Eigen::TensorCwiseUnaryOp&lt;Eigen::internal::scalar_conjugate_op&lt;std::complex&lt;float&gt; &gt;, const Eigen::TensorSlicingOp&lt;const Eigen::DSizes&lt;long int, 4&gt;, const Eigen::DSizes&lt;long int, 4&gt;, Eigen::TensorMap&lt;Eigen::Tensor&lt;std::complex&lt;float&gt;, 4, 1, long int&gt;, 16, Eigen::MakePointer&gt; &gt; &gt; &gt; &gt;&amp;)'\n         functor(ctx-&gt;eigen_device&lt;CPUDevice&gt;(), output, full_fft);\n\nno known conversion for argument 3 from \n\n'Eigen::TensorConcatenationOp&lt;const int, Eigen::TensorMap&lt;Eigen::Tensor&lt;std::complex&lt;float&gt;, 4, 1, long int&gt;, 16, Eigen::MakePointer&gt;, Eigen::TensorReverseOp&lt;const int, const Eigen::TensorCwiseUnaryOp&lt;Eigen::internal::scalar_conjugate_op&lt;std::complex&lt;float&gt; &gt;, const Eigen::TensorSlicingOp&lt;const Eigen::DSizes&lt;long int, 4&gt;, const Eigen::DSizes&lt;long int, 4&gt;, Eigen::TensorMap&lt;Eigen::Tensor&lt;std::complex&lt;float&gt;, 4, 1, long int&gt;, 16, Eigen::MakePointer&gt; &gt; &gt; &gt; &gt;'\n\nto \n\n'tensorflow::TTypes&lt;std::complex&lt;float&gt;, 4, long int&gt;::Tensor {aka Eigen::TensorMap&lt;Eigen::Tensor&lt;std::complex&lt;float&gt;, 4, 1, long int&gt;, 16, Eigen::MakePointer&gt;}'\n</code></pre>\n<p>I think one problem is that <code>Eigen::TensorConcatenationOp&lt;const int, Eigen::TensorMap&lt;Eigen::Tensor&lt;std::complex&lt;float&gt;, 4, 1, long int&gt;, 16, Eigen::MakePointer&gt;, Eigen::TensorReverseOp&lt;const int, const Eigen::TensorCwiseUnaryOp&lt;Eigen::internal::scalar_conjugate_op&lt;std::complex&lt;float&gt; &gt;, const Eigen::TensorSlicingOp&lt;const Eigen::DSizes&lt;long int, 4&gt;, const Eigen::DSizes&lt;long int, 4&gt;, Eigen::TensorMap&lt;Eigen::Tensor&lt;std::complex&lt;float&gt;, 4, 1, long int&gt;, 16, Eigen::MakePointer&gt; &gt; &gt; &gt; &gt;</code> is not convertible to <code>typename TTypes&lt;TInput, FFTRank + 1&gt;::Tensor</code>.</p>\n<p>Maybe FFTFunctor needs to be changed to take expressions as arguments instead of TensorMaps?</p>\n<p>I think it would also work to push the Eigen expressions here (which aren't convertible to TensorMap without an <code>.eval()</code>?) into a template specialization of FFTFunctor for TInput=float TOutput=complex64 and TInput=complex64 TOutput=float ?</p>", "body_text": "Based on the compiler errors I'm seeing here:\nhttps://ci.tensorflow.org/job/tensorflow-pull-requests-cpu/4430/console\nthey all seem to be from the IRFFT here (line 172):\ntensorflow/core/kernels/fft_ops.cc:172:65: error: no match for call to\n\n'(tensorflow::FFTFunctor<Eigen::ThreadPoolDevice, std::complex<float>, float, 0, 1, 3>) (const Eigen::ThreadPoolDevice&, Eigen::TensorMap<Eigen::Tensor<float, 4, 1, long int>, 16, Eigen::MakePointer>&, Eigen::TensorConcatenationOp<const int, Eigen::TensorMap<Eigen::Tensor<std::complex<float>, 4, 1, long int>, 16, Eigen::MakePointer>, Eigen::TensorReverseOp<const int, const Eigen::TensorCwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::TensorSlicingOp<const Eigen::DSizes<long int, 4>, const Eigen::DSizes<long int, 4>, Eigen::TensorMap<Eigen::Tensor<std::complex<float>, 4, 1, long int>, 16, Eigen::MakePointer> > > > >&)'\n         functor(ctx->eigen_device<CPUDevice>(), output, full_fft);\n\nno known conversion for argument 3 from \n\n'Eigen::TensorConcatenationOp<const int, Eigen::TensorMap<Eigen::Tensor<std::complex<float>, 4, 1, long int>, 16, Eigen::MakePointer>, Eigen::TensorReverseOp<const int, const Eigen::TensorCwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::TensorSlicingOp<const Eigen::DSizes<long int, 4>, const Eigen::DSizes<long int, 4>, Eigen::TensorMap<Eigen::Tensor<std::complex<float>, 4, 1, long int>, 16, Eigen::MakePointer> > > > >'\n\nto \n\n'tensorflow::TTypes<std::complex<float>, 4, long int>::Tensor {aka Eigen::TensorMap<Eigen::Tensor<std::complex<float>, 4, 1, long int>, 16, Eigen::MakePointer>}'\n\nI think one problem is that Eigen::TensorConcatenationOp<const int, Eigen::TensorMap<Eigen::Tensor<std::complex<float>, 4, 1, long int>, 16, Eigen::MakePointer>, Eigen::TensorReverseOp<const int, const Eigen::TensorCwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::complex<float> >, const Eigen::TensorSlicingOp<const Eigen::DSizes<long int, 4>, const Eigen::DSizes<long int, 4>, Eigen::TensorMap<Eigen::Tensor<std::complex<float>, 4, 1, long int>, 16, Eigen::MakePointer> > > > > is not convertible to typename TTypes<TInput, FFTRank + 1>::Tensor.\nMaybe FFTFunctor needs to be changed to take expressions as arguments instead of TensorMaps?\nI think it would also work to push the Eigen expressions here (which aren't convertible to TensorMap without an .eval()?) into a template specialization of FFTFunctor for TInput=float TOutput=complex64 and TInput=complex64 TOutput=float ?"}