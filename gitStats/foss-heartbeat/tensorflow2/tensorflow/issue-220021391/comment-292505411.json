{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/292505411", "html_url": "https://github.com/tensorflow/tensorflow/pull/9029#issuecomment-292505411", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9029", "id": 292505411, "node_id": "MDEyOklzc3VlQ29tbWVudDI5MjUwNTQxMQ==", "user": {"login": "tillahoffmann", "id": 966348, "node_id": "MDQ6VXNlcjk2NjM0OA==", "avatar_url": "https://avatars2.githubusercontent.com/u/966348?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tillahoffmann", "html_url": "https://github.com/tillahoffmann", "followers_url": "https://api.github.com/users/tillahoffmann/followers", "following_url": "https://api.github.com/users/tillahoffmann/following{/other_user}", "gists_url": "https://api.github.com/users/tillahoffmann/gists{/gist_id}", "starred_url": "https://api.github.com/users/tillahoffmann/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tillahoffmann/subscriptions", "organizations_url": "https://api.github.com/users/tillahoffmann/orgs", "repos_url": "https://api.github.com/users/tillahoffmann/repos", "events_url": "https://api.github.com/users/tillahoffmann/events{/privacy}", "received_events_url": "https://api.github.com/users/tillahoffmann/received_events", "type": "User", "site_admin": false}, "created_at": "2017-04-07T10:43:40Z", "updated_at": "2017-04-07T15:14:23Z", "author_association": "CONTRIBUTOR", "body_html": "<p>The (I)RFFT needs some amount of tensor manipulation. After playing around with the problem a bit, it seems like using the <code>FFTFunctor</code> is actually quite restrictive. Instead, it would make sense to build an operation tree as described <a href=\"https://bitbucket.org/eigen/eigen/src/default/unsupported/Eigen/CXX11/src/Tensor/README.md?fileviewer=file-view-default\" rel=\"nofollow\">here</a>. So, for the RFFT I was thinking of</p>\n<div class=\"highlight highlight-source-c++\"><pre><span class=\"pl-k\">auto</span> axes = Eigen::ArrayXi::LinSpaced(FFTRank, <span class=\"pl-c1\">1</span>, FFTRank);\n<span class=\"pl-k\">auto</span> device = ctx-&gt;eigen_device&lt;CPUDevice&gt;();\n<span class=\"pl-k\">auto</span> input = ((Tensor) in).flat_inner_dims&lt;<span class=\"pl-k\">float</span>, FFTRank + <span class=\"pl-c1\">1</span>&gt;();\n<span class=\"pl-k\">auto</span> output = out-&gt;flat_inner_dims&lt;complex64, FFTRank + <span class=\"pl-c1\">1</span>&gt;();\nEigen::DSizes&lt;Eigen::DenseIndex, FFTRank + <span class=\"pl-c1\">1</span>&gt; startIndices;\n<span class=\"pl-k\">auto</span> op = (input.<span class=\"pl-k\">template </span>fft&lt;Eigen::BothParts, Eigen::FFT_FORWARD&gt;(axes))\n  .slice(startIndices, output.dimensions());\noutput.device(device) = op;</pre></div>\n<p>and for the IRFFT</p>\n<div class=\"highlight highlight-source-c++\"><pre><span class=\"pl-k\">auto</span> axes = Eigen::ArrayXi::LinSpaced(FFTRank, <span class=\"pl-c1\">1</span>, FFTRank);\n<span class=\"pl-k\">auto</span> device = ctx-&gt;eigen_device&lt;CPUDevice&gt;();\n<span class=\"pl-k\">auto</span> input = ((Tensor) in).flat_inner_dims&lt;<span class=\"pl-k\">float</span>, FFTRank + <span class=\"pl-c1\">1</span>&gt;();\n<span class=\"pl-k\">auto</span> output = out-&gt;flat_inner_dims&lt;complex64, FFTRank + <span class=\"pl-c1\">1</span>&gt;();\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> The first dimension contains the zero-frequency component which we</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> do not want to duplicate. So we reconstruct the complex signal by</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> (1) slicing from the second element, (2) reversing the order,</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> (3) taking the complex conjugate, (4) concatenating with the original</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> input. Note that for an even input length, the last element is the</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> Nyquist frequency which we also do not want to duplicate.</span>\nEigen::DSizes&lt;Eigen::DenseIndex, FFTRank + <span class=\"pl-c1\">1</span>&gt; startIndices;\nstartIndices[FFTRank] = <span class=\"pl-c1\">1</span>;\n<span class=\"pl-k\">auto</span> sizes = input.dimensions();\n<span class=\"pl-k\">if</span> (sizes[FFTRank] % <span class=\"pl-c1\">2</span> == <span class=\"pl-c1\">0</span>) {\n  sizes[FFTRank] -= <span class=\"pl-c1\">1</span>;\n}\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> Compute the complex conjugate and reverse.</span>\n<span class=\"pl-k\">auto</span> cc = input.slice(startIndices, sizes).conjugate()\n  .reverse(FFTRank);\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> Reconstruct the full FFT.</span>\n<span class=\"pl-k\">auto</span> full_fft = input.concatenate(cc, FFTRank);\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> Take the inverse</span>\noutput.device(device) = full_fft.<span class=\"pl-k\">template </span>fft&lt;Eigen::RealPart, Eigen:FFT_FORWARD&gt;(axes);</pre></div>\n<p>Unfortunately, I can't get it to compile because of some const mismatch:</p>\n<pre><code>In file included from ./third_party/eigen3/unsupported/Eigen/CXX11/Tensor:4:\nIn file included from external/eigen_archive/unsupported/Eigen/CXX11/Tensor:125:\nexternal/eigen_archive/unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h:203:51: error: cannot initialize return object of type 'Scalar *' (aka 'float *') with an lvalue of type 'CoeffReturnType *const' (aka 'std::__1::complex&lt;float&gt; *const')\n  EIGEN_DEVICE_FUNC Scalar* data() const { return m_data; }\n</code></pre>\n<p>Here is a minimum example reproducing the same error.</p>\n<div class=\"highlight highlight-source-c++\"><pre>#<span class=\"pl-k\">include</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>unsupported/Eigen/CXX11/Tensor<span class=\"pl-pds\">\"</span></span>\n\n<span class=\"pl-k\">int</span> <span class=\"pl-en\">main</span>() {\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span> Create input tensor.</span>\n    Eigen::Tensor&lt;<span class=\"pl-k\">float</span>, <span class=\"pl-c1\">2</span>&gt; <span class=\"pl-c1\">input</span>(<span class=\"pl-c1\">5</span>, <span class=\"pl-c1\">5</span>);\n    input.<span class=\"pl-c1\">setRandom</span>();\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span> Create arrays for axes and slicing.</span>\n    Eigen::ArrayXi axes = {<span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">1</span>};\n    Eigen::DSizes&lt;Eigen::DenseIndex, <span class=\"pl-c1\">2</span>&gt; startIndices;\n    Eigen::DSizes&lt;Eigen::DenseIndex, <span class=\"pl-c1\">2</span>&gt; sizes = input.<span class=\"pl-c1\">dimensions</span>();\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span> Construct the graph and evaluate.</span>\n    <span class=\"pl-k\">auto</span> op = input.<span class=\"pl-k\">template</span> <span class=\"pl-smi\">fft</span>&lt;Eigen::BothParts, Eigen::FFT_FORWARD&gt;(axes).<span class=\"pl-c1\">slice</span>(startIndices, sizes);\n    Eigen::Tensor&lt;std::complex&lt;<span class=\"pl-k\">float</span>&gt;, <span class=\"pl-c1\">2</span>&gt; output = op;\n}</pre></div>\n<p><s>Alright, RFFT is added but I can't quite get the IRFFT to compile. In particular, the compiler isn't happy about passing the reconstructed full FFT (with negative frequencies) to the functor. Help from someone with more Eigen-knowledge would be great. Here's the compiler message.</s></p><s>\n<pre><code>tensorflow/core/kernels/fft_ops.cc:172:9: error: no matching function for call to object of type 'FFTFunctor&lt;CPUDevice, complex64, float, Eigen::RealPart, Eigen::FFT_REVERSE, 3&gt;' (aka 'FFTFunctor&lt;Eigen::ThreadPoolDevice, complex&lt;float&gt;, float, Eigen::RealPart, Eigen::FFT_REVERSE, 3&gt;')\n        functor(ctx-&gt;eigen_device&lt;CPUDevice&gt;(), output, full_fft);\n        ^~~~~~~\ntensorflow/core/kernels/fft_ops.cc:198:25: note: in instantiation of member function 'tensorflow::FFTCPU&lt;true, true, 3&gt;::DoFFT' requested here\n                        FFTCPU&lt;true, true, 3&gt;);\n                        ^\ntensorflow/core/kernels/fft_ops.cc:97:8: note: candidate function not viable: no known conversion from 'Eigen::TensorConcatenationOp&lt;const int, Eigen::TensorMap&lt;Eigen::Tensor&lt;std::__1::complex&lt;float&gt;, 4, 1, long&gt;, 16, MakePointer&gt;, Eigen::TensorReverseOp&lt;const int, const Eigen::TensorCwiseUnaryOp&lt;Eigen::internal::scalar_conjugate_op&lt;std::__1::complex&lt;float&gt; &gt;, const Eigen::TensorSlicingOp&lt;const Eigen::DSizes&lt;long, 4&gt;, const Eigen::DSizes&lt;long, 4&gt;, Eigen::TensorMap&lt;Eigen::Tensor&lt;std::__1::complex&lt;float&gt;, 4, 1, long&gt;, 16, MakePointer&gt; &gt; &gt; &gt; &gt;' to 'typename TTypes&lt;complex&lt;float&gt;, 3 + 1&gt;::Tensor' (aka 'TensorMap&lt;Eigen::Tensor&lt;complex&lt;float&gt;, 4, Eigen::RowMajor, long&gt;, Eigen::Aligned&gt;') for 3rd argument\n  void operator()(const Device&amp; d,\n</code></pre>\n</s><p><s>I've tried casting to <code>typename TTypes&lt;complex64, FFTRank + 1&gt;</code> to force an evaluation of the intermediate state but it wasn't happy with that either.</s></p>", "body_text": "The (I)RFFT needs some amount of tensor manipulation. After playing around with the problem a bit, it seems like using the FFTFunctor is actually quite restrictive. Instead, it would make sense to build an operation tree as described here. So, for the RFFT I was thinking of\nauto axes = Eigen::ArrayXi::LinSpaced(FFTRank, 1, FFTRank);\nauto device = ctx->eigen_device<CPUDevice>();\nauto input = ((Tensor) in).flat_inner_dims<float, FFTRank + 1>();\nauto output = out->flat_inner_dims<complex64, FFTRank + 1>();\nEigen::DSizes<Eigen::DenseIndex, FFTRank + 1> startIndices;\nauto op = (input.template fft<Eigen::BothParts, Eigen::FFT_FORWARD>(axes))\n  .slice(startIndices, output.dimensions());\noutput.device(device) = op;\nand for the IRFFT\nauto axes = Eigen::ArrayXi::LinSpaced(FFTRank, 1, FFTRank);\nauto device = ctx->eigen_device<CPUDevice>();\nauto input = ((Tensor) in).flat_inner_dims<float, FFTRank + 1>();\nauto output = out->flat_inner_dims<complex64, FFTRank + 1>();\n// The first dimension contains the zero-frequency component which we\n// do not want to duplicate. So we reconstruct the complex signal by\n// (1) slicing from the second element, (2) reversing the order,\n// (3) taking the complex conjugate, (4) concatenating with the original\n// input. Note that for an even input length, the last element is the\n// Nyquist frequency which we also do not want to duplicate.\nEigen::DSizes<Eigen::DenseIndex, FFTRank + 1> startIndices;\nstartIndices[FFTRank] = 1;\nauto sizes = input.dimensions();\nif (sizes[FFTRank] % 2 == 0) {\n  sizes[FFTRank] -= 1;\n}\n// Compute the complex conjugate and reverse.\nauto cc = input.slice(startIndices, sizes).conjugate()\n  .reverse(FFTRank);\n// Reconstruct the full FFT.\nauto full_fft = input.concatenate(cc, FFTRank);\n// Take the inverse\noutput.device(device) = full_fft.template fft<Eigen::RealPart, Eigen:FFT_FORWARD>(axes);\nUnfortunately, I can't get it to compile because of some const mismatch:\nIn file included from ./third_party/eigen3/unsupported/Eigen/CXX11/Tensor:4:\nIn file included from external/eigen_archive/unsupported/Eigen/CXX11/Tensor:125:\nexternal/eigen_archive/unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h:203:51: error: cannot initialize return object of type 'Scalar *' (aka 'float *') with an lvalue of type 'CoeffReturnType *const' (aka 'std::__1::complex<float> *const')\n  EIGEN_DEVICE_FUNC Scalar* data() const { return m_data; }\n\nHere is a minimum example reproducing the same error.\n#include \"unsupported/Eigen/CXX11/Tensor\"\n\nint main() {\n    // Create input tensor.\n    Eigen::Tensor<float, 2> input(5, 5);\n    input.setRandom();\n    // Create arrays for axes and slicing.\n    Eigen::ArrayXi axes = {0, 1};\n    Eigen::DSizes<Eigen::DenseIndex, 2> startIndices;\n    Eigen::DSizes<Eigen::DenseIndex, 2> sizes = input.dimensions();\n    // Construct the graph and evaluate.\n    auto op = input.template fft<Eigen::BothParts, Eigen::FFT_FORWARD>(axes).slice(startIndices, sizes);\n    Eigen::Tensor<std::complex<float>, 2> output = op;\n}\nAlright, RFFT is added but I can't quite get the IRFFT to compile. In particular, the compiler isn't happy about passing the reconstructed full FFT (with negative frequencies) to the functor. Help from someone with more Eigen-knowledge would be great. Here's the compiler message.\ntensorflow/core/kernels/fft_ops.cc:172:9: error: no matching function for call to object of type 'FFTFunctor<CPUDevice, complex64, float, Eigen::RealPart, Eigen::FFT_REVERSE, 3>' (aka 'FFTFunctor<Eigen::ThreadPoolDevice, complex<float>, float, Eigen::RealPart, Eigen::FFT_REVERSE, 3>')\n        functor(ctx->eigen_device<CPUDevice>(), output, full_fft);\n        ^~~~~~~\ntensorflow/core/kernels/fft_ops.cc:198:25: note: in instantiation of member function 'tensorflow::FFTCPU<true, true, 3>::DoFFT' requested here\n                        FFTCPU<true, true, 3>);\n                        ^\ntensorflow/core/kernels/fft_ops.cc:97:8: note: candidate function not viable: no known conversion from 'Eigen::TensorConcatenationOp<const int, Eigen::TensorMap<Eigen::Tensor<std::__1::complex<float>, 4, 1, long>, 16, MakePointer>, Eigen::TensorReverseOp<const int, const Eigen::TensorCwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::__1::complex<float> >, const Eigen::TensorSlicingOp<const Eigen::DSizes<long, 4>, const Eigen::DSizes<long, 4>, Eigen::TensorMap<Eigen::Tensor<std::__1::complex<float>, 4, 1, long>, 16, MakePointer> > > > >' to 'typename TTypes<complex<float>, 3 + 1>::Tensor' (aka 'TensorMap<Eigen::Tensor<complex<float>, 4, Eigen::RowMajor, long>, Eigen::Aligned>') for 3rd argument\n  void operator()(const Device& d,\n\nI've tried casting to typename TTypes<complex64, FFTRank + 1> to force an evaluation of the intermediate state but it wasn't happy with that either.", "body": "The (I)RFFT needs some amount of tensor manipulation. After playing around with the problem a bit, it seems like using the `FFTFunctor` is actually quite restrictive. Instead, it would make sense to build an operation tree as described [here](https://bitbucket.org/eigen/eigen/src/default/unsupported/Eigen/CXX11/src/Tensor/README.md?fileviewer=file-view-default). So, for the RFFT I was thinking of\r\n\r\n```cpp\r\nauto axes = Eigen::ArrayXi::LinSpaced(FFTRank, 1, FFTRank);\r\nauto device = ctx->eigen_device<CPUDevice>();\r\nauto input = ((Tensor) in).flat_inner_dims<float, FFTRank + 1>();\r\nauto output = out->flat_inner_dims<complex64, FFTRank + 1>();\r\nEigen::DSizes<Eigen::DenseIndex, FFTRank + 1> startIndices;\r\nauto op = (input.template fft<Eigen::BothParts, Eigen::FFT_FORWARD>(axes))\r\n  .slice(startIndices, output.dimensions());\r\noutput.device(device) = op;\r\n```\r\n\r\nand for the IRFFT\r\n\r\n```cpp\r\nauto axes = Eigen::ArrayXi::LinSpaced(FFTRank, 1, FFTRank);\r\nauto device = ctx->eigen_device<CPUDevice>();\r\nauto input = ((Tensor) in).flat_inner_dims<float, FFTRank + 1>();\r\nauto output = out->flat_inner_dims<complex64, FFTRank + 1>();\r\n// The first dimension contains the zero-frequency component which we\r\n// do not want to duplicate. So we reconstruct the complex signal by\r\n// (1) slicing from the second element, (2) reversing the order,\r\n// (3) taking the complex conjugate, (4) concatenating with the original\r\n// input. Note that for an even input length, the last element is the\r\n// Nyquist frequency which we also do not want to duplicate.\r\nEigen::DSizes<Eigen::DenseIndex, FFTRank + 1> startIndices;\r\nstartIndices[FFTRank] = 1;\r\nauto sizes = input.dimensions();\r\nif (sizes[FFTRank] % 2 == 0) {\r\n  sizes[FFTRank] -= 1;\r\n}\r\n// Compute the complex conjugate and reverse.\r\nauto cc = input.slice(startIndices, sizes).conjugate()\r\n  .reverse(FFTRank);\r\n// Reconstruct the full FFT.\r\nauto full_fft = input.concatenate(cc, FFTRank);\r\n// Take the inverse\r\noutput.device(device) = full_fft.template fft<Eigen::RealPart, Eigen:FFT_FORWARD>(axes);\r\n```\r\n\r\nUnfortunately, I can't get it to compile because of some const mismatch:\r\n\r\n```\r\nIn file included from ./third_party/eigen3/unsupported/Eigen/CXX11/Tensor:4:\r\nIn file included from external/eigen_archive/unsupported/Eigen/CXX11/Tensor:125:\r\nexternal/eigen_archive/unsupported/Eigen/CXX11/src/Tensor/TensorFFT.h:203:51: error: cannot initialize return object of type 'Scalar *' (aka 'float *') with an lvalue of type 'CoeffReturnType *const' (aka 'std::__1::complex<float> *const')\r\n  EIGEN_DEVICE_FUNC Scalar* data() const { return m_data; }\r\n```\r\n\r\nHere is a minimum example reproducing the same error.\r\n\r\n```cpp\r\n#include \"unsupported/Eigen/CXX11/Tensor\"\r\n\r\nint main() {\r\n    // Create input tensor.\r\n    Eigen::Tensor<float, 2> input(5, 5);\r\n    input.setRandom();\r\n    // Create arrays for axes and slicing.\r\n    Eigen::ArrayXi axes = {0, 1};\r\n    Eigen::DSizes<Eigen::DenseIndex, 2> startIndices;\r\n    Eigen::DSizes<Eigen::DenseIndex, 2> sizes = input.dimensions();\r\n    // Construct the graph and evaluate.\r\n    auto op = input.template fft<Eigen::BothParts, Eigen::FFT_FORWARD>(axes).slice(startIndices, sizes);\r\n    Eigen::Tensor<std::complex<float>, 2> output = op;\r\n}\r\n```\r\n\r\n<s>Alright, RFFT is added but I can't quite get the IRFFT to compile. In particular, the compiler isn't happy about passing the reconstructed full FFT (with negative frequencies) to the functor. Help from someone with more Eigen-knowledge would be great. Here's the compiler message.\r\n\r\n```\r\ntensorflow/core/kernels/fft_ops.cc:172:9: error: no matching function for call to object of type 'FFTFunctor<CPUDevice, complex64, float, Eigen::RealPart, Eigen::FFT_REVERSE, 3>' (aka 'FFTFunctor<Eigen::ThreadPoolDevice, complex<float>, float, Eigen::RealPart, Eigen::FFT_REVERSE, 3>')\r\n        functor(ctx->eigen_device<CPUDevice>(), output, full_fft);\r\n        ^~~~~~~\r\ntensorflow/core/kernels/fft_ops.cc:198:25: note: in instantiation of member function 'tensorflow::FFTCPU<true, true, 3>::DoFFT' requested here\r\n                        FFTCPU<true, true, 3>);\r\n                        ^\r\ntensorflow/core/kernels/fft_ops.cc:97:8: note: candidate function not viable: no known conversion from 'Eigen::TensorConcatenationOp<const int, Eigen::TensorMap<Eigen::Tensor<std::__1::complex<float>, 4, 1, long>, 16, MakePointer>, Eigen::TensorReverseOp<const int, const Eigen::TensorCwiseUnaryOp<Eigen::internal::scalar_conjugate_op<std::__1::complex<float> >, const Eigen::TensorSlicingOp<const Eigen::DSizes<long, 4>, const Eigen::DSizes<long, 4>, Eigen::TensorMap<Eigen::Tensor<std::__1::complex<float>, 4, 1, long>, 16, MakePointer> > > > >' to 'typename TTypes<complex<float>, 3 + 1>::Tensor' (aka 'TensorMap<Eigen::Tensor<complex<float>, 4, Eigen::RowMajor, long>, Eigen::Aligned>') for 3rd argument\r\n  void operator()(const Device& d,\r\n```\r\n\r\nI've tried casting to `typename TTypes<complex64, FFTRank + 1>` to force an evaluation of the intermediate state but it wasn't happy with that either.</s>"}