{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5000", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5000/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5000/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5000/events", "html_url": "https://github.com/tensorflow/tensorflow/pull/5000", "id": 183297552, "node_id": "MDExOlB1bGxSZXF1ZXN0ODk1NDMzMjI=", "number": 5000, "title": "Add support for dict Input to DataFeeder, StreamingDataFeeder, Estimator.fit() and Estimator.evaluate()", "user": {"login": "abhitopia", "id": 12864026, "node_id": "MDQ6VXNlcjEyODY0MDI2", "avatar_url": "https://avatars1.githubusercontent.com/u/12864026?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abhitopia", "html_url": "https://github.com/abhitopia", "followers_url": "https://api.github.com/users/abhitopia/followers", "following_url": "https://api.github.com/users/abhitopia/following{/other_user}", "gists_url": "https://api.github.com/users/abhitopia/gists{/gist_id}", "starred_url": "https://api.github.com/users/abhitopia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abhitopia/subscriptions", "organizations_url": "https://api.github.com/users/abhitopia/orgs", "repos_url": "https://api.github.com/users/abhitopia/repos", "events_url": "https://api.github.com/users/abhitopia/events{/privacy}", "received_events_url": "https://api.github.com/users/abhitopia/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 300136613, "node_id": "MDU6TGFiZWwzMDAxMzY2MTM=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/cla:%20no", "name": "cla: no", "color": "eb6420", "default": false}, {"id": 404586594, "node_id": "MDU6TGFiZWw0MDQ1ODY1OTQ=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:awaiting%20tensorflower", "name": "stat:awaiting tensorflower", "color": "f4b400", "default": false}], "state": "closed", "locked": false, "assignee": {"login": "martinwicke", "id": 577277, "node_id": "MDQ6VXNlcjU3NzI3Nw==", "avatar_url": "https://avatars2.githubusercontent.com/u/577277?v=4", "gravatar_id": "", "url": "https://api.github.com/users/martinwicke", "html_url": "https://github.com/martinwicke", "followers_url": "https://api.github.com/users/martinwicke/followers", "following_url": "https://api.github.com/users/martinwicke/following{/other_user}", "gists_url": "https://api.github.com/users/martinwicke/gists{/gist_id}", "starred_url": "https://api.github.com/users/martinwicke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/martinwicke/subscriptions", "organizations_url": "https://api.github.com/users/martinwicke/orgs", "repos_url": "https://api.github.com/users/martinwicke/repos", "events_url": "https://api.github.com/users/martinwicke/events{/privacy}", "received_events_url": "https://api.github.com/users/martinwicke/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "martinwicke", "id": 577277, "node_id": "MDQ6VXNlcjU3NzI3Nw==", "avatar_url": "https://avatars2.githubusercontent.com/u/577277?v=4", "gravatar_id": "", "url": "https://api.github.com/users/martinwicke", "html_url": "https://github.com/martinwicke", "followers_url": "https://api.github.com/users/martinwicke/followers", "following_url": "https://api.github.com/users/martinwicke/following{/other_user}", "gists_url": "https://api.github.com/users/martinwicke/gists{/gist_id}", "starred_url": "https://api.github.com/users/martinwicke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/martinwicke/subscriptions", "organizations_url": "https://api.github.com/users/martinwicke/orgs", "repos_url": "https://api.github.com/users/martinwicke/repos", "events_url": "https://api.github.com/users/martinwicke/events{/privacy}", "received_events_url": "https://api.github.com/users/martinwicke/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 18, "created_at": "2016-10-16T22:51:32Z", "updated_at": "2016-11-11T17:26:37Z", "closed_at": "2016-11-11T15:58:44Z", "author_association": "CONTRIBUTOR", "pull_request": {"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/5000", "html_url": "https://github.com/tensorflow/tensorflow/pull/5000", "diff_url": "https://github.com/tensorflow/tensorflow/pull/5000.diff", "patch_url": "https://github.com/tensorflow/tensorflow/pull/5000.patch"}, "body_html": "<h1>Problem</h1>\n<p>The <code>Estimator.fit()</code> function takes as argument either</p>\n<ul>\n<li>(<code>x</code>, <code>y</code>, and <code>batch_size</code>) where <code>x</code> and <code>y</code> could be numpy arrays or iterators.\n<ul>\n<li><strong>PROS</strong>\n<ol>\n<li>Easy to use.</li>\n<li>Allows feeding data from arbitrary source as long as problem can be decomposed into <code>x</code> and <code>y</code>.</li>\n</ol>\n</li>\n<li><strong>CONS</strong>\n<ol>\n<li>No provision to provide epoch</li>\n<li>In case, <code>x</code> and <code>y</code> are arrays, the data aggregate must be available as opposed to reading on the fly ( say from database)</li>\n<li>Whether array or iterator, <code>x</code> and <code>y</code> can't be dictionaries. Most complex problems cannot be reduced to input matrix and output matrix and may require multiple input features matrices.</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><code>input_fn</code> - this is callback function which must return <code>features</code> and <code>target</code> tensors or dictionary of tensors.\n<ul>\n<li><strong>PROS</strong>\n<ol>\n<li>Allows feeding data from arbitrary source (in theory).</li>\n<li>returned features and targets can be dictionary thus allowing to solve complex problems which takes multiple inputs.</li>\n</ol>\n</li>\n<li><strong>CONS</strong>\n<ol>\n<li>Only found support for reading files using <code>read_batch_examples()</code>, <code>read_batch_features()</code>, <code>read_batch_record_features()</code>, etc.</li>\n<li>No support for passing placeholder and feed_fn to allow for arbitrary source of input data which don't require queue.</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h1>Relevant discussions</h1>\n<ol>\n<li><a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"180402007\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/tensorflow/tensorflow/issues/4696\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/tensorflow/tensorflow/pull/4696/hovercard?comment_id=253632403&amp;comment_type=issue_comment\" href=\"https://github.com/tensorflow/tensorflow/pull/4696#issuecomment-253632403\">#4696 (comment)</a></li>\n<li><a href=\"http://stackoverflow.com/questions/39855375/how-to-use-streamingdatafeeder-as-contrib-learn-estimator-fits-input-fn\" rel=\"nofollow\">http://stackoverflow.com/questions/39855375/how-to-use-streamingdatafeeder-as-contrib-learn-estimator-fits-input-fn</a></li>\n</ol>\n<h1>Additional problem</h1>\n<p>Currently the self.feature_info (feature signature) must be same for training as well as evaluation. However, there can be cases where evaluation if done differently than training. For example, DualEncoderLSTM model where training just requires Context and Utterance, while Evaluation (Validation) requires context and multiple utterances.</p>\n<h1>Solution</h1>\n<p>This PR basically combines the pros of using (<code>x</code>, <code>y</code>, and <code>batch_size</code>) with pros of input_fn by allowing <code>x</code>, <code>y</code> to be dictionary of multiple arrays. This also works for <code>x</code> and <code>y</code> iterators returning dictionary of streaming data.</p>\n<p>Also, added support for different feature/target signature for training and evaluation.</p>", "body_text": "Problem\nThe Estimator.fit() function takes as argument either\n\n(x, y, and batch_size) where x and y could be numpy arrays or iterators.\n\nPROS\n\nEasy to use.\nAllows feeding data from arbitrary source as long as problem can be decomposed into x and y.\n\n\nCONS\n\nNo provision to provide epoch\nIn case, x and y are arrays, the data aggregate must be available as opposed to reading on the fly ( say from database)\nWhether array or iterator, x and y can't be dictionaries. Most complex problems cannot be reduced to input matrix and output matrix and may require multiple input features matrices.\n\n\n\n\ninput_fn - this is callback function which must return features and target tensors or dictionary of tensors.\n\nPROS\n\nAllows feeding data from arbitrary source (in theory).\nreturned features and targets can be dictionary thus allowing to solve complex problems which takes multiple inputs.\n\n\nCONS\n\nOnly found support for reading files using read_batch_examples(), read_batch_features(), read_batch_record_features(), etc.\nNo support for passing placeholder and feed_fn to allow for arbitrary source of input data which don't require queue.\n\n\n\n\n\nRelevant discussions\n\n#4696 (comment)\nhttp://stackoverflow.com/questions/39855375/how-to-use-streamingdatafeeder-as-contrib-learn-estimator-fits-input-fn\n\nAdditional problem\nCurrently the self.feature_info (feature signature) must be same for training as well as evaluation. However, there can be cases where evaluation if done differently than training. For example, DualEncoderLSTM model where training just requires Context and Utterance, while Evaluation (Validation) requires context and multiple utterances.\nSolution\nThis PR basically combines the pros of using (x, y, and batch_size) with pros of input_fn by allowing x, y to be dictionary of multiple arrays. This also works for x and y iterators returning dictionary of streaming data.\nAlso, added support for different feature/target signature for training and evaluation.", "body": "# Problem\n\nThe `Estimator.fit()` function takes as argument either\n- (`x`, `y`, and `batch_size`) where `x` and `y` could be numpy arrays or iterators.\n  - **PROS**\n    1.   Easy to use.\n    2.  Allows feeding data from arbitrary source as long as problem can be decomposed into `x` and `y`.\n  - **CONS**\n    1.  No provision to provide epoch\n    2.  In case, `x` and `y` are arrays, the data aggregate must be available as opposed to reading on the fly ( say from database)\n    3. Whether array or iterator, `x` and `y` can't be dictionaries. Most complex problems cannot be reduced to input matrix and output matrix and may require multiple input features matrices.\n- `input_fn` - this is callback function which must return `features` and `target` tensors or dictionary of tensors.\n  - **PROS**\n    1. Allows feeding data from arbitrary source (in theory).\n    2. returned features and targets can be dictionary thus allowing to solve complex problems which takes multiple inputs.\n  - **CONS**\n    1. Only found support for reading files using `read_batch_examples()`, `read_batch_features()`, `read_batch_record_features()`, etc.\n    2. No support for passing placeholder and feed_fn to allow for arbitrary source of input data which don't require queue.\n# Relevant discussions\n1. https://github.com/tensorflow/tensorflow/pull/4696#issuecomment-253632403\n2. http://stackoverflow.com/questions/39855375/how-to-use-streamingdatafeeder-as-contrib-learn-estimator-fits-input-fn\n# Additional problem\n\nCurrently the self.feature_info (feature signature) must be same for training as well as evaluation. However, there can be cases where evaluation if done differently than training. For example, DualEncoderLSTM model where training just requires Context and Utterance, while Evaluation (Validation) requires context and multiple utterances.\n# Solution\n\nThis PR basically combines the pros of using (`x`, `y`, and `batch_size`) with pros of input_fn by allowing `x`, `y` to be dictionary of multiple arrays. This also works for `x` and `y` iterators returning dictionary of streaming data. \n\nAlso, added support for different feature/target signature for training and evaluation.\n"}