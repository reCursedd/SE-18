{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9816", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9816/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9816/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9816/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/9816", "id": 227705888, "node_id": "MDU6SXNzdWUyMjc3MDU4ODg=", "number": 9816, "title": "Variable validate_shape not honored", "user": {"login": "dloyer", "id": 3138048, "node_id": "MDQ6VXNlcjMxMzgwNDg=", "avatar_url": "https://avatars3.githubusercontent.com/u/3138048?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dloyer", "html_url": "https://github.com/dloyer", "followers_url": "https://api.github.com/users/dloyer/followers", "following_url": "https://api.github.com/users/dloyer/following{/other_user}", "gists_url": "https://api.github.com/users/dloyer/gists{/gist_id}", "starred_url": "https://api.github.com/users/dloyer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dloyer/subscriptions", "organizations_url": "https://api.github.com/users/dloyer/orgs", "repos_url": "https://api.github.com/users/dloyer/repos", "events_url": "https://api.github.com/users/dloyer/events{/privacy}", "received_events_url": "https://api.github.com/users/dloyer/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 386191887, "node_id": "MDU6TGFiZWwzODYxOTE4ODc=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:awaiting%20response", "name": "stat:awaiting response", "color": "f4b400", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2017-05-10T14:48:02Z", "updated_at": "2017-06-16T22:11:33Z", "closed_at": "2017-06-16T22:11:33Z", "author_association": "NONE", "body_html": "<p>A Variable with validate_shape=True does not seem to be honored and throws a error.  I am using two Variables to store the contents of a SparseTensor and the assign fails because the sizes do not match on one, but not the other Variable.</p>\n<p>Platform:  Ubuntu 14.04<br>\nCode:  Both build from source and binary release<br>\nVersion: 1.1.0</p>\n<p>2017-05-10 14:36:12.973654: W tensorflow/core/framework/op_kernel.cc:1152] Invalid argument: Assign requires shapes of both tensors to match. lhs shape= [1] rhs shape= [10]<br>\n[[Node: Assign = Assign[T=DT_INT32, _class=[\"loc:@Variable_1\"], use_locking=true, validate_shape=true, _device=\"/job:localhost/replica:0/task:0/cpu:0\"](Variable_1, SparseAdd:1)]]<br>\n2017-05-10 14:36:12.973661: W tensorflow/core/framework/op_kernel.cc:1152] Invalid argument: Assign requires shapes of both tensors to match. lhs shape= [1] rhs shape= [10]<br>\n[[Node: Assign = Assign[T=DT_INT32, _class=[\"loc:@Variable_1\"], use_locking=true, validate_shape=true, _device=\"/job:localhost/replica:0/task:0/cpu:0\"](Variable_1, SparseAdd:1)]]<br>\n2017-05-10 14:36:12.973657: W tensorflow/core/framework/op_kernel.cc:1152] Invalid argument: Assign requires shapes of both tensors to match. lhs shape= [1] rhs shape= [10]<br>\n[[Node: Assign = Assign[T=DT_INT32, _class=[\"loc:@Variable_1\"], use_locking=true, validate_shape=true, _device=\"/job:localhost/replica:0/task:0/cpu:0\"](Variable_1, SparseAdd:1)]]<br>\ndone<br>\nTraceback (most recent call last):<br>\nFile \"parse.py\", line 52, in <br>\nprint(sess.run([st2, asop2]))<br>\nFile \"/usr/local/lib/python2.7/dist-packages/tensorflow/python/client/session.py\", line 778, in run<br>\nrun_metadata_ptr)<br>\nFile \"/usr/local/lib/python2.7/dist-packages/tensorflow/python/client/session.py\", line 982, in _run<br>\nfeed_dict_string, options, run_metadata)<br>\nFile \"/usr/local/lib/python2.7/dist-packages/tensorflow/python/client/session.py\", line 1032, in _do_run<br>\ntarget_list, options, run_metadata)<br>\nFile \"/usr/local/lib/python2.7/dist-packages/tensorflow/python/client/session.py\", line 1052, in _do_call<br>\nraise type(e)(node_def, op, message)<br>\ntensorflow.python.framework.errors_impl.InvalidArgumentError: Assign requires shapes of both tensors to match. lhs shape= [1] rhs shape= [10]<br>\n[[Node: Assign = Assign[T=DT_INT32, _class=[\"loc:@Variable_1\"], use_locking=true, validate_shape=true, _device=\"/job:localhost/replica:0/task:0/cpu:0\"](Variable_1, SparseAdd:1)]]</p>\n<p>Caused by op u'Assign', defined at:<br>\nFile \"parse.py\", line 39, in <br>\nasop2 = tf.assign(var_feature_count_cnt, st2.values)<br>\nFile \"/usr/local/lib/python2.7/dist-packages/tensorflow/python/ops/state_ops.py\", line 270, in assign<br>\nvalidate_shape=validate_shape)<br>\nFile \"/usr/local/lib/python2.7/dist-packages/tensorflow/python/ops/gen_state_ops.py\", line 47, in assign<br>\nuse_locking=use_locking, name=name)<br>\nFile \"/usr/local/lib/python2.7/dist-packages/tensorflow/python/framework/op_def_library.py\", line 768, in apply_op<br>\nop_def=op_def)<br>\nFile \"/usr/local/lib/python2.7/dist-packages/tensorflow/python/framework/ops.py\", line 2336, in create_op<br>\noriginal_op=self._default_original_op, op_def=op_def)<br>\nFile \"/usr/local/lib/python2.7/dist-packages/tensorflow/python/framework/ops.py\", line 1228, in <strong>init</strong><br>\nself._traceback = _extract_stack()</p>\n<p>InvalidArgumentError (see above for traceback): Assign requires shapes of both tensors to match. lhs shape= [1] rhs shape= [10]<br>\n[[Node: Assign = Assign[T=DT_INT32, _class=[\"loc:@Variable_1\"], use_locking=true, validate_shape=true, _device=\"/job:localhost/replica:0/task:0/cpu:0\"](Variable_1, SparseAdd:1)]]</p>\n<p>Code:<br>\nimport tensorflow as tf</p>\n<h1>parse logic</h1>\n<h1>start with example feature list</h1>\n<h1>parse into distinct tokens</h1>\n<h1>collect counts</h1>\n<p>file_queue = tf.FIFOQueue(100, [tf.string])</p>\n<h1>the feature count that we maintain between batches</h1>\n<h1>must be kept in a variable, but variables dont support sparse tensors</h1>\n<h1>so we have to keep the source index and value arrays</h1>\n<p>var_feature_count_idx = tf.Variable(tf.zeros([1,1],dtype=tf.int64), validate_shape=False)<br>\nvar_feature_count_cnt = tf.Variable(tf.zeros([1],dtype=tf.int32), validate_shape=False)</p>\n<p>#read a chunk of features<br>\nreader = tf.TextLineReader()<br>\n_, line = reader.read_up_to(file_queue, 1000)</p>\n<p>#parse into tokens<br>\ntokens = tf.string_split(line,delimiter='\\t')<br>\nvals = tf.string_to_hash_bucket_fast(tokens.values, 1024) # hash<br>\ny, idx, count = tf.unique_with_counts(vals)  # get distinct<br>\ny2 = tf.expand_dims(y,1)</p>\n<h1>now create a sparse array with the hashbucket of as the index</h1>\n<p>fcount = tf.SparseTensor(indices=y2,values=count,dense_shape=[1024]) # running count of features</p>\n<h1>update the global count</h1>\n<p>st = tf.SparseTensor(indices=var_feature_count_idx, values=tf.identity(var_feature_count_cnt), dense_shape=[1024])<br>\nst2 = tf.sparse_add(st, fcount)<br>\n#asop1 = tf.assign(var_feature_count_idx, st2.indices)<br>\nasop2 = tf.assign(var_feature_count_cnt, st2.values)</p>\n<p>with tf.Session() as sess:<br>\nsess.run(tf.global_variables_initializer())<br>\nsess.run(file_queue.enqueue_many((['features.txt'],)))<br>\nsess.run(file_queue.close())</p>\n<p>try:<br>\nwhile True:<br>\nprint(sess.run([st2, asop2]))<br>\nexcept tf.errors.OutOfRangeError:<br>\nprint 'load finished!'<br>\nfinally:<br>\nprint 'done'</p>", "body_text": "A Variable with validate_shape=True does not seem to be honored and throws a error.  I am using two Variables to store the contents of a SparseTensor and the assign fails because the sizes do not match on one, but not the other Variable.\nPlatform:  Ubuntu 14.04\nCode:  Both build from source and binary release\nVersion: 1.1.0\n2017-05-10 14:36:12.973654: W tensorflow/core/framework/op_kernel.cc:1152] Invalid argument: Assign requires shapes of both tensors to match. lhs shape= [1] rhs shape= [10]\n[[Node: Assign = Assign[T=DT_INT32, _class=[\"loc:@Variable_1\"], use_locking=true, validate_shape=true, _device=\"/job:localhost/replica:0/task:0/cpu:0\"](Variable_1, SparseAdd:1)]]\n2017-05-10 14:36:12.973661: W tensorflow/core/framework/op_kernel.cc:1152] Invalid argument: Assign requires shapes of both tensors to match. lhs shape= [1] rhs shape= [10]\n[[Node: Assign = Assign[T=DT_INT32, _class=[\"loc:@Variable_1\"], use_locking=true, validate_shape=true, _device=\"/job:localhost/replica:0/task:0/cpu:0\"](Variable_1, SparseAdd:1)]]\n2017-05-10 14:36:12.973657: W tensorflow/core/framework/op_kernel.cc:1152] Invalid argument: Assign requires shapes of both tensors to match. lhs shape= [1] rhs shape= [10]\n[[Node: Assign = Assign[T=DT_INT32, _class=[\"loc:@Variable_1\"], use_locking=true, validate_shape=true, _device=\"/job:localhost/replica:0/task:0/cpu:0\"](Variable_1, SparseAdd:1)]]\ndone\nTraceback (most recent call last):\nFile \"parse.py\", line 52, in \nprint(sess.run([st2, asop2]))\nFile \"/usr/local/lib/python2.7/dist-packages/tensorflow/python/client/session.py\", line 778, in run\nrun_metadata_ptr)\nFile \"/usr/local/lib/python2.7/dist-packages/tensorflow/python/client/session.py\", line 982, in _run\nfeed_dict_string, options, run_metadata)\nFile \"/usr/local/lib/python2.7/dist-packages/tensorflow/python/client/session.py\", line 1032, in _do_run\ntarget_list, options, run_metadata)\nFile \"/usr/local/lib/python2.7/dist-packages/tensorflow/python/client/session.py\", line 1052, in _do_call\nraise type(e)(node_def, op, message)\ntensorflow.python.framework.errors_impl.InvalidArgumentError: Assign requires shapes of both tensors to match. lhs shape= [1] rhs shape= [10]\n[[Node: Assign = Assign[T=DT_INT32, _class=[\"loc:@Variable_1\"], use_locking=true, validate_shape=true, _device=\"/job:localhost/replica:0/task:0/cpu:0\"](Variable_1, SparseAdd:1)]]\nCaused by op u'Assign', defined at:\nFile \"parse.py\", line 39, in \nasop2 = tf.assign(var_feature_count_cnt, st2.values)\nFile \"/usr/local/lib/python2.7/dist-packages/tensorflow/python/ops/state_ops.py\", line 270, in assign\nvalidate_shape=validate_shape)\nFile \"/usr/local/lib/python2.7/dist-packages/tensorflow/python/ops/gen_state_ops.py\", line 47, in assign\nuse_locking=use_locking, name=name)\nFile \"/usr/local/lib/python2.7/dist-packages/tensorflow/python/framework/op_def_library.py\", line 768, in apply_op\nop_def=op_def)\nFile \"/usr/local/lib/python2.7/dist-packages/tensorflow/python/framework/ops.py\", line 2336, in create_op\noriginal_op=self._default_original_op, op_def=op_def)\nFile \"/usr/local/lib/python2.7/dist-packages/tensorflow/python/framework/ops.py\", line 1228, in init\nself._traceback = _extract_stack()\nInvalidArgumentError (see above for traceback): Assign requires shapes of both tensors to match. lhs shape= [1] rhs shape= [10]\n[[Node: Assign = Assign[T=DT_INT32, _class=[\"loc:@Variable_1\"], use_locking=true, validate_shape=true, _device=\"/job:localhost/replica:0/task:0/cpu:0\"](Variable_1, SparseAdd:1)]]\nCode:\nimport tensorflow as tf\nparse logic\nstart with example feature list\nparse into distinct tokens\ncollect counts\nfile_queue = tf.FIFOQueue(100, [tf.string])\nthe feature count that we maintain between batches\nmust be kept in a variable, but variables dont support sparse tensors\nso we have to keep the source index and value arrays\nvar_feature_count_idx = tf.Variable(tf.zeros([1,1],dtype=tf.int64), validate_shape=False)\nvar_feature_count_cnt = tf.Variable(tf.zeros([1],dtype=tf.int32), validate_shape=False)\n#read a chunk of features\nreader = tf.TextLineReader()\n_, line = reader.read_up_to(file_queue, 1000)\n#parse into tokens\ntokens = tf.string_split(line,delimiter='\\t')\nvals = tf.string_to_hash_bucket_fast(tokens.values, 1024) # hash\ny, idx, count = tf.unique_with_counts(vals)  # get distinct\ny2 = tf.expand_dims(y,1)\nnow create a sparse array with the hashbucket of as the index\nfcount = tf.SparseTensor(indices=y2,values=count,dense_shape=[1024]) # running count of features\nupdate the global count\nst = tf.SparseTensor(indices=var_feature_count_idx, values=tf.identity(var_feature_count_cnt), dense_shape=[1024])\nst2 = tf.sparse_add(st, fcount)\n#asop1 = tf.assign(var_feature_count_idx, st2.indices)\nasop2 = tf.assign(var_feature_count_cnt, st2.values)\nwith tf.Session() as sess:\nsess.run(tf.global_variables_initializer())\nsess.run(file_queue.enqueue_many((['features.txt'],)))\nsess.run(file_queue.close())\ntry:\nwhile True:\nprint(sess.run([st2, asop2]))\nexcept tf.errors.OutOfRangeError:\nprint 'load finished!'\nfinally:\nprint 'done'", "body": "A Variable with validate_shape=True does not seem to be honored and throws a error.  I am using two Variables to store the contents of a SparseTensor and the assign fails because the sizes do not match on one, but not the other Variable.  \r\n\r\nPlatform:  Ubuntu 14.04\r\nCode:  Both build from source and binary release\r\nVersion: 1.1.0\r\n\r\n2017-05-10 14:36:12.973654: W tensorflow/core/framework/op_kernel.cc:1152] Invalid argument: Assign requires shapes of both tensors to match. lhs shape= [1] rhs shape= [10]\r\n\t [[Node: Assign = Assign[T=DT_INT32, _class=[\"loc:@Variable_1\"], use_locking=true, validate_shape=true, _device=\"/job:localhost/replica:0/task:0/cpu:0\"](Variable_1, SparseAdd:1)]]\r\n2017-05-10 14:36:12.973661: W tensorflow/core/framework/op_kernel.cc:1152] Invalid argument: Assign requires shapes of both tensors to match. lhs shape= [1] rhs shape= [10]\r\n\t [[Node: Assign = Assign[T=DT_INT32, _class=[\"loc:@Variable_1\"], use_locking=true, validate_shape=true, _device=\"/job:localhost/replica:0/task:0/cpu:0\"](Variable_1, SparseAdd:1)]]\r\n2017-05-10 14:36:12.973657: W tensorflow/core/framework/op_kernel.cc:1152] Invalid argument: Assign requires shapes of both tensors to match. lhs shape= [1] rhs shape= [10]\r\n\t [[Node: Assign = Assign[T=DT_INT32, _class=[\"loc:@Variable_1\"], use_locking=true, validate_shape=true, _device=\"/job:localhost/replica:0/task:0/cpu:0\"](Variable_1, SparseAdd:1)]]\r\ndone\r\nTraceback (most recent call last):\r\n  File \"parse.py\", line 52, in <module>\r\n    print(sess.run([st2, asop2]))\r\n  File \"/usr/local/lib/python2.7/dist-packages/tensorflow/python/client/session.py\", line 778, in run\r\n    run_metadata_ptr)\r\n  File \"/usr/local/lib/python2.7/dist-packages/tensorflow/python/client/session.py\", line 982, in _run\r\n    feed_dict_string, options, run_metadata)\r\n  File \"/usr/local/lib/python2.7/dist-packages/tensorflow/python/client/session.py\", line 1032, in _do_run\r\n    target_list, options, run_metadata)\r\n  File \"/usr/local/lib/python2.7/dist-packages/tensorflow/python/client/session.py\", line 1052, in _do_call\r\n    raise type(e)(node_def, op, message)\r\ntensorflow.python.framework.errors_impl.InvalidArgumentError: Assign requires shapes of both tensors to match. lhs shape= [1] rhs shape= [10]\r\n\t [[Node: Assign = Assign[T=DT_INT32, _class=[\"loc:@Variable_1\"], use_locking=true, validate_shape=true, _device=\"/job:localhost/replica:0/task:0/cpu:0\"](Variable_1, SparseAdd:1)]]\r\n\r\nCaused by op u'Assign', defined at:\r\n  File \"parse.py\", line 39, in <module>\r\n    asop2 = tf.assign(var_feature_count_cnt, st2.values)\r\n  File \"/usr/local/lib/python2.7/dist-packages/tensorflow/python/ops/state_ops.py\", line 270, in assign\r\n    validate_shape=validate_shape)\r\n  File \"/usr/local/lib/python2.7/dist-packages/tensorflow/python/ops/gen_state_ops.py\", line 47, in assign\r\n    use_locking=use_locking, name=name)\r\n  File \"/usr/local/lib/python2.7/dist-packages/tensorflow/python/framework/op_def_library.py\", line 768, in apply_op\r\n    op_def=op_def)\r\n  File \"/usr/local/lib/python2.7/dist-packages/tensorflow/python/framework/ops.py\", line 2336, in create_op\r\n    original_op=self._default_original_op, op_def=op_def)\r\n  File \"/usr/local/lib/python2.7/dist-packages/tensorflow/python/framework/ops.py\", line 1228, in __init__\r\n    self._traceback = _extract_stack()\r\n\r\nInvalidArgumentError (see above for traceback): Assign requires shapes of both tensors to match. lhs shape= [1] rhs shape= [10]\r\n\t [[Node: Assign = Assign[T=DT_INT32, _class=[\"loc:@Variable_1\"], use_locking=true, validate_shape=true, _device=\"/job:localhost/replica:0/task:0/cpu:0\"](Variable_1, SparseAdd:1)]]\r\n\r\n\r\n\r\nCode:\r\nimport tensorflow as tf\r\n\r\n\r\n# parse logic\r\n# start with example feature list\r\n# parse into distinct tokens\r\n# collect counts\r\nfile_queue = tf.FIFOQueue(100, [tf.string])\r\n\r\n# the feature count that we maintain between batches\r\n# must be kept in a variable, but variables dont support sparse tensors\r\n# so we have to keep the source index and value arrays\r\nvar_feature_count_idx = tf.Variable(tf.zeros([1,1],dtype=tf.int64), validate_shape=False)\r\nvar_feature_count_cnt = tf.Variable(tf.zeros([1],dtype=tf.int32), validate_shape=False)\r\n\r\n#read a chunk of features\r\nreader = tf.TextLineReader()\r\n_, line = reader.read_up_to(file_queue, 1000)\r\n\r\n#parse into tokens\r\ntokens = tf.string_split(line,delimiter='\\t')\r\nvals = tf.string_to_hash_bucket_fast(tokens.values, 1024) # hash\r\ny, idx, count = tf.unique_with_counts(vals)  # get distinct\r\ny2 = tf.expand_dims(y,1)\r\n\r\n# now create a sparse array with the hashbucket of as the index\r\nfcount = tf.SparseTensor(indices=y2,values=count,dense_shape=[1024]) # running count of features\r\n\r\n# update the global count\r\nst = tf.SparseTensor(indices=var_feature_count_idx, values=tf.identity(var_feature_count_cnt), dense_shape=[1024])\r\nst2 = tf.sparse_add(st, fcount)\r\n#asop1 = tf.assign(var_feature_count_idx, st2.indices)\r\nasop2 = tf.assign(var_feature_count_cnt, st2.values)\r\n\r\nwith tf.Session() as sess:\r\n  sess.run(tf.global_variables_initializer())\r\n  sess.run(file_queue.enqueue_many((['features.txt'],)))\r\n  sess.run(file_queue.close())\r\n\r\n  try:\r\n    while True:\r\n      print(sess.run([st2, asop2]))\r\n  except tf.errors.OutOfRangeError:\r\n    print 'load finished!'\r\n  finally:\r\n    print 'done'\r\n\r\n\r\n"}