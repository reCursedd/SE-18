{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/266338679", "html_url": "https://github.com/tensorflow/tensorflow/issues/6256#issuecomment-266338679", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/6256", "id": 266338679, "node_id": "MDEyOklzc3VlQ29tbWVudDI2NjMzODY3OQ==", "user": {"login": "mrry", "id": 192142, "node_id": "MDQ6VXNlcjE5MjE0Mg==", "avatar_url": "https://avatars1.githubusercontent.com/u/192142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mrry", "html_url": "https://github.com/mrry", "followers_url": "https://api.github.com/users/mrry/followers", "following_url": "https://api.github.com/users/mrry/following{/other_user}", "gists_url": "https://api.github.com/users/mrry/gists{/gist_id}", "starred_url": "https://api.github.com/users/mrry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mrry/subscriptions", "organizations_url": "https://api.github.com/users/mrry/orgs", "repos_url": "https://api.github.com/users/mrry/repos", "events_url": "https://api.github.com/users/mrry/events{/privacy}", "received_events_url": "https://api.github.com/users/mrry/received_events", "type": "User", "site_admin": false}, "created_at": "2016-12-12T04:03:09Z", "updated_at": "2016-12-12T04:03:09Z", "author_association": "CONTRIBUTOR", "body_html": "<p>We're aware of the inefficiencies in the client-to-and-from-master path when using the distributed runtime, and have plans to cut down on the serialization overhead, especially in the common case where the client and master (and often worker) are colocated in the same process.</p>\n<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=23068\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/yaroslavvb\">@yaroslavvb</a> Can you share more about what your use case is for fetching large values from the distributed runtime? We haven't spent much time optimizing this until now because the common case in distributed execution involves running a training op that returns nothing (or perhaps some small progress indicator values). It would be good to understand your use case so we can prioritize the various steps we can take to improve performance here!</p>", "body_text": "We're aware of the inefficiencies in the client-to-and-from-master path when using the distributed runtime, and have plans to cut down on the serialization overhead, especially in the common case where the client and master (and often worker) are colocated in the same process.\n@yaroslavvb Can you share more about what your use case is for fetching large values from the distributed runtime? We haven't spent much time optimizing this until now because the common case in distributed execution involves running a training op that returns nothing (or perhaps some small progress indicator values). It would be good to understand your use case so we can prioritize the various steps we can take to improve performance here!", "body": "We're aware of the inefficiencies in the client-to-and-from-master path when using the distributed runtime, and have plans to cut down on the serialization overhead, especially in the common case where the client and master (and often worker) are colocated in the same process.\r\n\r\n@yaroslavvb Can you share more about what your use case is for fetching large values from the distributed runtime? We haven't spent much time optimizing this until now because the common case in distributed execution involves running a training op that returns nothing (or perhaps some small progress indicator values). It would be good to understand your use case so we can prioritize the various steps we can take to improve performance here!"}