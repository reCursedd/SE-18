{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/386428737", "html_url": "https://github.com/tensorflow/tensorflow/pull/18796#issuecomment-386428737", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/18796", "id": 386428737, "node_id": "MDEyOklzc3VlQ29tbWVudDM4NjQyODczNw==", "user": {"login": "asimshankar", "id": 16018, "node_id": "MDQ6VXNlcjE2MDE4", "avatar_url": "https://avatars2.githubusercontent.com/u/16018?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asimshankar", "html_url": "https://github.com/asimshankar", "followers_url": "https://api.github.com/users/asimshankar/followers", "following_url": "https://api.github.com/users/asimshankar/following{/other_user}", "gists_url": "https://api.github.com/users/asimshankar/gists{/gist_id}", "starred_url": "https://api.github.com/users/asimshankar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asimshankar/subscriptions", "organizations_url": "https://api.github.com/users/asimshankar/orgs", "repos_url": "https://api.github.com/users/asimshankar/repos", "events_url": "https://api.github.com/users/asimshankar/events{/privacy}", "received_events_url": "https://api.github.com/users/asimshankar/received_events", "type": "User", "site_admin": false}, "created_at": "2018-05-03T20:37:39Z", "updated_at": "2018-05-03T20:37:39Z", "author_association": "MEMBER", "body_html": "<p>Thanks for the contribution.</p>\n<p>We have debated this before, and while I admit that the decision isn't set in stone, the feeling was that the finalizer should be avoided in this case. There is some discussion in the <a href=\"http://www.informit.com/articles/article.aspx?p=1216151&amp;seqNum=7\" rel=\"nofollow\">Effective Java book</a>. In particular, since the native peers of these classes can hold on to a significant chunk of resources (e.g., large amounts of memory) - encouraging cleanup on the finalizer may seem convenient but actually makes it harder to reason about and debug the memory footprint of a program (for example, if the memory footprint goes up and down as the GC runs, making it hard to associate with the code that is missing the <code>close()</code> calls).</p>\n<p>So I'd suggest that we do not merge this PR, but I say so with the humility that I could be wrong :)</p>", "body_text": "Thanks for the contribution.\nWe have debated this before, and while I admit that the decision isn't set in stone, the feeling was that the finalizer should be avoided in this case. There is some discussion in the Effective Java book. In particular, since the native peers of these classes can hold on to a significant chunk of resources (e.g., large amounts of memory) - encouraging cleanup on the finalizer may seem convenient but actually makes it harder to reason about and debug the memory footprint of a program (for example, if the memory footprint goes up and down as the GC runs, making it hard to associate with the code that is missing the close() calls).\nSo I'd suggest that we do not merge this PR, but I say so with the humility that I could be wrong :)", "body": "Thanks for the contribution.\r\n\r\nWe have debated this before, and while I admit that the decision isn't set in stone, the feeling was that the finalizer should be avoided in this case. There is some discussion in the [Effective Java book](http://www.informit.com/articles/article.aspx?p=1216151&seqNum=7). In particular, since the native peers of these classes can hold on to a significant chunk of resources (e.g., large amounts of memory) - encouraging cleanup on the finalizer may seem convenient but actually makes it harder to reason about and debug the memory footprint of a program (for example, if the memory footprint goes up and down as the GC runs, making it hard to associate with the code that is missing the `close()` calls).\r\n\r\nSo I'd suggest that we do not merge this PR, but I say so with the humility that I could be wrong :)"}