{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11806", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11806/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11806/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11806/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/11806", "id": 245964377, "node_id": "MDU6SXNzdWUyNDU5NjQzNzc=", "number": 11806, "title": "sparse ClusterSpec fails when using tf.cond", "user": {"login": "mavenlin", "id": 1367713, "node_id": "MDQ6VXNlcjEzNjc3MTM=", "avatar_url": "https://avatars0.githubusercontent.com/u/1367713?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mavenlin", "html_url": "https://github.com/mavenlin", "followers_url": "https://api.github.com/users/mavenlin/followers", "following_url": "https://api.github.com/users/mavenlin/following{/other_user}", "gists_url": "https://api.github.com/users/mavenlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/mavenlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mavenlin/subscriptions", "organizations_url": "https://api.github.com/users/mavenlin/orgs", "repos_url": "https://api.github.com/users/mavenlin/repos", "events_url": "https://api.github.com/users/mavenlin/events{/privacy}", "received_events_url": "https://api.github.com/users/mavenlin/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 404586594, "node_id": "MDU6TGFiZWw0MDQ1ODY1OTQ=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:awaiting%20tensorflower", "name": "stat:awaiting tensorflower", "color": "f4b400", "default": false}, {"id": 473172988, "node_id": "MDU6TGFiZWw0NzMxNzI5ODg=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:bug/performance", "name": "type:bug/performance", "color": "159b2e", "default": false}], "state": "open", "locked": false, "assignee": {"login": "asimshankar", "id": 16018, "node_id": "MDQ6VXNlcjE2MDE4", "avatar_url": "https://avatars2.githubusercontent.com/u/16018?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asimshankar", "html_url": "https://github.com/asimshankar", "followers_url": "https://api.github.com/users/asimshankar/followers", "following_url": "https://api.github.com/users/asimshankar/following{/other_user}", "gists_url": "https://api.github.com/users/asimshankar/gists{/gist_id}", "starred_url": "https://api.github.com/users/asimshankar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asimshankar/subscriptions", "organizations_url": "https://api.github.com/users/asimshankar/orgs", "repos_url": "https://api.github.com/users/asimshankar/repos", "events_url": "https://api.github.com/users/asimshankar/events{/privacy}", "received_events_url": "https://api.github.com/users/asimshankar/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "asimshankar", "id": 16018, "node_id": "MDQ6VXNlcjE2MDE4", "avatar_url": "https://avatars2.githubusercontent.com/u/16018?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asimshankar", "html_url": "https://github.com/asimshankar", "followers_url": "https://api.github.com/users/asimshankar/followers", "following_url": "https://api.github.com/users/asimshankar/following{/other_user}", "gists_url": "https://api.github.com/users/asimshankar/gists{/gist_id}", "starred_url": "https://api.github.com/users/asimshankar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asimshankar/subscriptions", "organizations_url": "https://api.github.com/users/asimshankar/orgs", "repos_url": "https://api.github.com/users/asimshankar/repos", "events_url": "https://api.github.com/users/asimshankar/events{/privacy}", "received_events_url": "https://api.github.com/users/asimshankar/received_events", "type": "User", "site_admin": false}, {"login": "saeta", "id": 1284535, "node_id": "MDQ6VXNlcjEyODQ1MzU=", "avatar_url": "https://avatars1.githubusercontent.com/u/1284535?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saeta", "html_url": "https://github.com/saeta", "followers_url": "https://api.github.com/users/saeta/followers", "following_url": "https://api.github.com/users/saeta/following{/other_user}", "gists_url": "https://api.github.com/users/saeta/gists{/gist_id}", "starred_url": "https://api.github.com/users/saeta/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saeta/subscriptions", "organizations_url": "https://api.github.com/users/saeta/orgs", "repos_url": "https://api.github.com/users/saeta/repos", "events_url": "https://api.github.com/users/saeta/events{/privacy}", "received_events_url": "https://api.github.com/users/saeta/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 3, "created_at": "2017-07-27T08:30:47Z", "updated_at": "2018-11-12T18:51:09Z", "closed_at": null, "author_association": "CONTRIBUTOR", "body_html": "<p>Here's the minimal code to reproduce.<br>\non machine 1 and machine 2</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">import</span> sys\n<span class=\"pl-k\">import</span> tensorflow <span class=\"pl-k\">as</span> tf\n\ncluster_spec <span class=\"pl-k\">=</span> tf.train.ClusterSpec({\n  <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>a<span class=\"pl-pds\">\"</span></span>: { <span class=\"pl-c1\">0</span>: <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>machine1:8000<span class=\"pl-pds\">\"</span></span> },\n  <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>b<span class=\"pl-pds\">\"</span></span>: { <span class=\"pl-c1\">0</span>: <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>machine2:8001<span class=\"pl-pds\">\"</span></span> },\n})\njobname <span class=\"pl-k\">=</span> sys.argv[<span class=\"pl-c1\">1</span>]\ntaskid <span class=\"pl-k\">=</span> <span class=\"pl-c1\">int</span>(sys.argv[<span class=\"pl-c1\">2</span>])\nserver <span class=\"pl-k\">=</span> tf.train.Server(cluster_spec, jobname, taskid)\n\n<span class=\"pl-k\">with</span> tf.device(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>/job:a/task:0/cpu:0<span class=\"pl-pds\">\"</span></span>):\n  queue <span class=\"pl-k\">=</span> tf.FIFOQueue(\n    <span class=\"pl-v\">capacity</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">100</span>, <span class=\"pl-v\">dtypes</span><span class=\"pl-k\">=</span>[tf.int64],\n    <span class=\"pl-v\">shapes</span><span class=\"pl-k\">=</span>[[]], <span class=\"pl-v\">shared_name</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span>a_queue<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-v\">name</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span>a_queue<span class=\"pl-pds\">\"</span></span>)\n\n<span class=\"pl-k\">if</span> jobname <span class=\"pl-k\">==</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>a<span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">and</span> taskid <span class=\"pl-k\">==</span> <span class=\"pl-c1\">0</span>:\n  enqueue_op <span class=\"pl-k\">=</span> queue.enqueue(<span class=\"pl-c1\">10</span>)\n  sess <span class=\"pl-k\">=</span> tf.Session(server.target)\n  <span class=\"pl-k\">while</span> <span class=\"pl-c1\">True</span>:\n    sess.run(enqueue_op)\n<span class=\"pl-k\">else</span>:\n  dequeue_op <span class=\"pl-k\">=</span> queue.dequeue()\n  sess <span class=\"pl-k\">=</span> tf.Session(server.target)\n  <span class=\"pl-k\">while</span> <span class=\"pl-c1\">True</span>:\n    <span class=\"pl-c1\">print</span>(sess.run(dequeue_op))</pre></div>\n<p>on machine 3:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">import</span> sys\n<span class=\"pl-k\">import</span> tensorflow <span class=\"pl-k\">as</span> tf\n\ncluster_spec <span class=\"pl-k\">=</span> tf.train.ClusterSpec({\n  <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>a<span class=\"pl-pds\">\"</span></span>: { <span class=\"pl-c1\">0</span>: <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>machine1:8000<span class=\"pl-pds\">\"</span></span> },\n  <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>b<span class=\"pl-pds\">\"</span></span>: { <span class=\"pl-c1\">1</span>: <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>machine3:8001<span class=\"pl-pds\">\"</span></span> },\n})\njobname <span class=\"pl-k\">=</span> sys.argv[<span class=\"pl-c1\">1</span>]\ntaskid <span class=\"pl-k\">=</span> <span class=\"pl-c1\">int</span>(sys.argv[<span class=\"pl-c1\">2</span>])\nserver <span class=\"pl-k\">=</span> tf.train.Server(cluster_spec, jobname, taskid)\n\n<span class=\"pl-k\">with</span> tf.device(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>/job:a/task:0/cpu:0<span class=\"pl-pds\">\"</span></span>):\n  queue <span class=\"pl-k\">=</span> tf.FIFOQueue(\n    <span class=\"pl-v\">capacity</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">100</span>, <span class=\"pl-v\">dtypes</span><span class=\"pl-k\">=</span>[tf.int64],\n    <span class=\"pl-v\">shapes</span><span class=\"pl-k\">=</span>[[]], <span class=\"pl-v\">shared_name</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span>a_queue<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-v\">name</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span>a_queue<span class=\"pl-pds\">\"</span></span>)\n\n<span class=\"pl-k\">if</span> jobname <span class=\"pl-k\">==</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>a<span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">and</span> taskid <span class=\"pl-k\">==</span> <span class=\"pl-c1\">0</span>:\n  enqueue_op <span class=\"pl-k\">=</span> queue.enqueue(<span class=\"pl-c1\">10</span>)\n  sess <span class=\"pl-k\">=</span> tf.Session(server.target)\n  <span class=\"pl-k\">while</span> <span class=\"pl-c1\">True</span>:\n    sess.run(enqueue_op)\n<span class=\"pl-k\">else</span>:\n  <span class=\"pl-k\">with</span> tf.device(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>/job:b/task:1<span class=\"pl-pds\">\"</span></span>):\n    out <span class=\"pl-k\">=</span> queue.dequeue()\n    queue_b <span class=\"pl-k\">=</span> tf.FIFOQueue(<span class=\"pl-v\">capacity</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">100</span>, <span class=\"pl-v\">dtypes</span><span class=\"pl-k\">=</span>[tf.int64], <span class=\"pl-v\">shapes</span><span class=\"pl-k\">=</span>[[]], <span class=\"pl-v\">name</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span>b_queue<span class=\"pl-pds\">\"</span></span>)\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> 1.</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> enq = queue_b.enqueue(out)</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> no_op = tf.no_op()</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> out = tf.cond(tf.equal(out, 10), lambda: enq, lambda: no_op)</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> 2.</span>\n    out <span class=\"pl-k\">=</span> tf.cond(tf.equal(out, <span class=\"pl-c1\">10</span>), <span class=\"pl-k\">lambda</span>: queue_b.enqueue(out), <span class=\"pl-k\">lambda</span>: tf.no_op())\n\n  sess <span class=\"pl-k\">=</span> tf.Session(server.target)\n  <span class=\"pl-k\">while</span> <span class=\"pl-c1\">True</span>:\n    <span class=\"pl-c1\">print</span>(sess.run(out))</pre></div>\n<p>On machine3, it crashes complaining</p>\n<div class=\"highlight highlight-source-shell\"><pre>tensorflow.python.framework.errors_impl.InternalError: No worker known as /job:b/replica:0/task:1\n\t [[Node: cond/pred_id_S5 <span class=\"pl-k\">=</span> _HostRecv[client_terminated<span class=\"pl-k\">=</span>false, recv_device<span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span>/job:a/replica:0/task:0/cpu:0<span class=\"pl-pds\">\"</span></span>, send_device<span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span>/job:b/replica:0/task:1/gpu:0<span class=\"pl-pds\">\"</span></span>, send_device_incarnation<span class=\"pl-k\">=</span>720279685140440577, tensor_name<span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span>edge_8_cond/pred_id<span class=\"pl-pds\">\"</span></span>, tensor_type<span class=\"pl-k\">=</span>DT_BOOL, _device<span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span>/job:a/replica:0/task:0/cpu:0<span class=\"pl-pds\">\"</span></span>]()]]</pre></div>\n<p>There is no problem if the true_fn and false_fn just returns a already constructed op, like in the commented code.</p>", "body_text": "Here's the minimal code to reproduce.\non machine 1 and machine 2\nimport sys\nimport tensorflow as tf\n\ncluster_spec = tf.train.ClusterSpec({\n  \"a\": { 0: \"machine1:8000\" },\n  \"b\": { 0: \"machine2:8001\" },\n})\njobname = sys.argv[1]\ntaskid = int(sys.argv[2])\nserver = tf.train.Server(cluster_spec, jobname, taskid)\n\nwith tf.device(\"/job:a/task:0/cpu:0\"):\n  queue = tf.FIFOQueue(\n    capacity=100, dtypes=[tf.int64],\n    shapes=[[]], shared_name=\"a_queue\", name=\"a_queue\")\n\nif jobname == \"a\" and taskid == 0:\n  enqueue_op = queue.enqueue(10)\n  sess = tf.Session(server.target)\n  while True:\n    sess.run(enqueue_op)\nelse:\n  dequeue_op = queue.dequeue()\n  sess = tf.Session(server.target)\n  while True:\n    print(sess.run(dequeue_op))\non machine 3:\nimport sys\nimport tensorflow as tf\n\ncluster_spec = tf.train.ClusterSpec({\n  \"a\": { 0: \"machine1:8000\" },\n  \"b\": { 1: \"machine3:8001\" },\n})\njobname = sys.argv[1]\ntaskid = int(sys.argv[2])\nserver = tf.train.Server(cluster_spec, jobname, taskid)\n\nwith tf.device(\"/job:a/task:0/cpu:0\"):\n  queue = tf.FIFOQueue(\n    capacity=100, dtypes=[tf.int64],\n    shapes=[[]], shared_name=\"a_queue\", name=\"a_queue\")\n\nif jobname == \"a\" and taskid == 0:\n  enqueue_op = queue.enqueue(10)\n  sess = tf.Session(server.target)\n  while True:\n    sess.run(enqueue_op)\nelse:\n  with tf.device(\"/job:b/task:1\"):\n    out = queue.dequeue()\n    queue_b = tf.FIFOQueue(capacity=100, dtypes=[tf.int64], shapes=[[]], name=\"b_queue\")\n    # 1.\n    # enq = queue_b.enqueue(out)\n    # no_op = tf.no_op()\n    # out = tf.cond(tf.equal(out, 10), lambda: enq, lambda: no_op)\n    # 2.\n    out = tf.cond(tf.equal(out, 10), lambda: queue_b.enqueue(out), lambda: tf.no_op())\n\n  sess = tf.Session(server.target)\n  while True:\n    print(sess.run(out))\nOn machine3, it crashes complaining\ntensorflow.python.framework.errors_impl.InternalError: No worker known as /job:b/replica:0/task:1\n\t [[Node: cond/pred_id_S5 = _HostRecv[client_terminated=false, recv_device=\"/job:a/replica:0/task:0/cpu:0\", send_device=\"/job:b/replica:0/task:1/gpu:0\", send_device_incarnation=720279685140440577, tensor_name=\"edge_8_cond/pred_id\", tensor_type=DT_BOOL, _device=\"/job:a/replica:0/task:0/cpu:0\"]()]]\nThere is no problem if the true_fn and false_fn just returns a already constructed op, like in the commented code.", "body": "Here's the minimal code to reproduce.\r\non machine 1 and machine 2\r\n```python\r\nimport sys\r\nimport tensorflow as tf\r\n\r\ncluster_spec = tf.train.ClusterSpec({\r\n  \"a\": { 0: \"machine1:8000\" },\r\n  \"b\": { 0: \"machine2:8001\" },\r\n})\r\njobname = sys.argv[1]\r\ntaskid = int(sys.argv[2])\r\nserver = tf.train.Server(cluster_spec, jobname, taskid)\r\n\r\nwith tf.device(\"/job:a/task:0/cpu:0\"):\r\n  queue = tf.FIFOQueue(\r\n    capacity=100, dtypes=[tf.int64],\r\n    shapes=[[]], shared_name=\"a_queue\", name=\"a_queue\")\r\n\r\nif jobname == \"a\" and taskid == 0:\r\n  enqueue_op = queue.enqueue(10)\r\n  sess = tf.Session(server.target)\r\n  while True:\r\n    sess.run(enqueue_op)\r\nelse:\r\n  dequeue_op = queue.dequeue()\r\n  sess = tf.Session(server.target)\r\n  while True:\r\n    print(sess.run(dequeue_op))\r\n```\r\n\r\non machine 3:\r\n\r\n```python\r\nimport sys\r\nimport tensorflow as tf\r\n\r\ncluster_spec = tf.train.ClusterSpec({\r\n  \"a\": { 0: \"machine1:8000\" },\r\n  \"b\": { 1: \"machine3:8001\" },\r\n})\r\njobname = sys.argv[1]\r\ntaskid = int(sys.argv[2])\r\nserver = tf.train.Server(cluster_spec, jobname, taskid)\r\n\r\nwith tf.device(\"/job:a/task:0/cpu:0\"):\r\n  queue = tf.FIFOQueue(\r\n    capacity=100, dtypes=[tf.int64],\r\n    shapes=[[]], shared_name=\"a_queue\", name=\"a_queue\")\r\n\r\nif jobname == \"a\" and taskid == 0:\r\n  enqueue_op = queue.enqueue(10)\r\n  sess = tf.Session(server.target)\r\n  while True:\r\n    sess.run(enqueue_op)\r\nelse:\r\n  with tf.device(\"/job:b/task:1\"):\r\n    out = queue.dequeue()\r\n    queue_b = tf.FIFOQueue(capacity=100, dtypes=[tf.int64], shapes=[[]], name=\"b_queue\")\r\n    # 1.\r\n    # enq = queue_b.enqueue(out)\r\n    # no_op = tf.no_op()\r\n    # out = tf.cond(tf.equal(out, 10), lambda: enq, lambda: no_op)\r\n    # 2.\r\n    out = tf.cond(tf.equal(out, 10), lambda: queue_b.enqueue(out), lambda: tf.no_op())\r\n\r\n  sess = tf.Session(server.target)\r\n  while True:\r\n    print(sess.run(out))\r\n```\r\n\r\nOn machine3, it crashes complaining\r\n\r\n```shell\r\ntensorflow.python.framework.errors_impl.InternalError: No worker known as /job:b/replica:0/task:1\r\n\t [[Node: cond/pred_id_S5 = _HostRecv[client_terminated=false, recv_device=\"/job:a/replica:0/task:0/cpu:0\", send_device=\"/job:b/replica:0/task:1/gpu:0\", send_device_incarnation=720279685140440577, tensor_name=\"edge_8_cond/pred_id\", tensor_type=DT_BOOL, _device=\"/job:a/replica:0/task:0/cpu:0\"]()]]\r\n```\r\nThere is no problem if the true_fn and false_fn just returns a already constructed op, like in the commented code."}