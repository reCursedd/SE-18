{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/16779", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/16779/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/16779/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/16779/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/16779", "id": 294491341, "node_id": "MDU6SXNzdWUyOTQ0OTEzNDE=", "number": 16779, "title": "Cross-Compiling the TensorFlow wheel for NVIDIA Jetson with CUDA support", "user": {"login": "ljanyst", "id": 126975, "node_id": "MDQ6VXNlcjEyNjk3NQ==", "avatar_url": "https://avatars3.githubusercontent.com/u/126975?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljanyst", "html_url": "https://github.com/ljanyst", "followers_url": "https://api.github.com/users/ljanyst/followers", "following_url": "https://api.github.com/users/ljanyst/following{/other_user}", "gists_url": "https://api.github.com/users/ljanyst/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljanyst/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljanyst/subscriptions", "organizations_url": "https://api.github.com/users/ljanyst/orgs", "repos_url": "https://api.github.com/users/ljanyst/repos", "events_url": "https://api.github.com/users/ljanyst/events{/privacy}", "received_events_url": "https://api.github.com/users/ljanyst/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 299643928, "node_id": "MDU6TGFiZWwyOTk2NDM5Mjg=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:contributions%20welcome", "name": "stat:contributions welcome", "color": "f4b400", "default": false}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2018-02-05T18:15:14Z", "updated_at": "2018-02-09T17:55:06Z", "closed_at": null, "author_association": "NONE", "body_html": "<h3>System information</h3>\n<ul>\n<li><strong>Have I written custom code (as opposed to using a stock example script provided in TensorFlow)</strong>: Yes</li>\n<li><strong>OS Platform and Distribution (e.g., Linux Ubuntu 16.04)</strong>: Linux Ubuntu 16.04</li>\n<li><strong>TensorFlow installed from (source or binary)</strong>: Source</li>\n<li><strong>TensorFlow version (use command below)</strong>: 1.5.0</li>\n<li><strong>Python version</strong>:  3.5.2</li>\n<li><strong>Bazel version (if compiling from source)</strong>: 0.10.0</li>\n<li><strong>GCC/Compiler version (if compiling from source)</strong>: gcc version 5.4.0 20160609</li>\n<li><strong>CUDA/cuDNN version</strong>: 8.0/6.0</li>\n<li><strong>GPU model and memory</strong>: Irrelevant</li>\n<li><strong>Exact command to reproduce</strong>:</li>\n</ul>\n<ul>\n<li>Install gcc cross-compiler: <code>sudo apt-get install gcc-aarch64-linux-gnu g++-aarch64-linux-gnu</code></li>\n<li>Install the CUDA <code>cross-aarch64</code> packages</li>\n<li>Build Python 3.5.2 for the target</li>\n<li>I wrote a short blog post with the details: <a href=\"https://jany.st/post/2018-02-05-cross-compiling-tensorflow-for-jetson-tx1-with-bazel.html\" rel=\"nofollow\">https://jany.st/post/2018-02-05-cross-compiling-tensorflow-for-jetson-tx1-with-bazel.html</a></li>\n</ul>\n<pre><code>git clone https://github.com/ljanyst/tensorflow.git\ncd tensorflow\ngit checkout v1.5.0-cross-jetson-tx1\ncd third_party/toolchains/cpus/aarch64\n./configure.py\ncd ../../../..\n./configure\nbazel build  --config=opt --config=cuda \\\n   --crosstool_top=//third_party/toolchains/cpus/aarch64:toolchain \\\n    --cpu=arm  --compiler=cuda \\\n    //tensorflow/tools/pip_package:build_pip_package\n</code></pre>\n<h3>Describe the problem</h3>\n<p>I have succeeded, but I encountered a bunch of issues on the way. Due to my unfamiliarity with Bazel, my solution is rather hacky. It looks to me like properly fixing it is a rather low hanging fruit for a person familiar with Bazel, so I document what I have discovered here.</p>\n<h4>1. Configuring CUDA for the target</h4>\n<p>I could not find a way in the to check CUDA configuration script whether the source is supposed to be configured for a cross build, so I ended up changing the hardcoded paths: <a class=\"commit-link\" data-hovercard-type=\"commit\" data-hovercard-url=\"https://github.com/ljanyst/tensorflow/commit/1a2a75fed9a9576c4e9e8f89ee556263cf22deaf/hovercard\" href=\"https://github.com/ljanyst/tensorflow/commit/1a2a75fed9a9576c4e9e8f89ee556263cf22deaf\">ljanyst@<tt>1a2a75f</tt></a> If there was a way to check if we're building for a platform that is different from the one of the build host, this could be easily turned into some sort of an if statement.</p>\n<h4>2. Specifying target Python installation</h4>\n<p>I could not find an easy way to patch that through, so I ended up putting it in the <a href=\"https://github.com/ljanyst/tensorflow/blob/v1.5.0-cross-jetson-tx1/third_party/toolchains/cpus/aarch64/CROSSTOOL.in\">CROSSTOOL</a> file:</p>\n<pre><code>cxx_flag: \"-isystem\"\ncxx_flag: \"__TARGET_PYTHON_INCLUDES__\"\n</code></pre>\n<h4>3. Code generators depend on <code>libtensorflow_framework.so</code> which, in turn, depends on CUDA</h4>\n<p>This means that I needed to have the CUDA and cuDNN libraries for the build host and needed to pass the relevant library paths to the compiler <a href=\"https://github.com/ljanyst/tensorflow/blob/v1.5.0-cross-jetson-tx1/third_party/toolchains/cpus/aarch64/crosstool_wrapper_host_tf_framework#L41\">in a wrapper script</a>.</p>\n<h4>4. Linking of the code generators fails on the build-host side</h4>\n<p>Bazel builds both the code generators and <code>libtensorflow_framework.so</code> for the host, but does not link the binaries against the framework library.</p>\n<p>I have worked around the two above issues by writing a compiler wrapper scripts doing the following:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">if</span> ofile <span class=\"pl-k\">is</span> <span class=\"pl-k\">not</span> <span class=\"pl-c1\">None</span>:\n    is_gen <span class=\"pl-k\">=</span> ofile.endswith(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>py_wrappers_cc<span class=\"pl-pds\">'</span></span>) <span class=\"pl-k\">or</span> ofile.endswith(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>gen_cc<span class=\"pl-pds\">'</span></span>)\n    <span class=\"pl-k\">if</span> is_cuda <span class=\"pl-k\">==</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>yes<span class=\"pl-pds\">'</span></span> <span class=\"pl-k\">and</span> (ofile.endswith(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>libtensorflow_framework.so<span class=\"pl-pds\">'</span></span>) <span class=\"pl-k\">or</span> is_gen):\n        cuda_libdirs <span class=\"pl-k\">=</span> [\n            <span class=\"pl-s\"><span class=\"pl-pds\">'</span>-L<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span><span class=\"pl-c1\">{}</span>/targets/x86_64-linux/lib<span class=\"pl-pds\">'</span></span>.format(cuda_dir),\n            <span class=\"pl-s\"><span class=\"pl-pds\">'</span>-L<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span><span class=\"pl-c1\">{}</span>/targets/x86_64-linux/lib/stubs<span class=\"pl-pds\">'</span></span>.format(cuda_dir),\n            <span class=\"pl-s\"><span class=\"pl-pds\">'</span>-L<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span><span class=\"pl-c1\">{}</span>/lib64<span class=\"pl-pds\">'</span></span>.format(cudnn_dir),\n        ]\n\n    <span class=\"pl-k\">if</span> is_gen:\n        tf_libs <span class=\"pl-k\">+=</span> [\n            <span class=\"pl-s\"><span class=\"pl-pds\">'</span>-L<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>bazel-out/host/bin/tensorflow<span class=\"pl-pds\">'</span></span>,\n            <span class=\"pl-s\"><span class=\"pl-pds\">'</span>-ltensorflow_framework<span class=\"pl-pds\">'</span></span>\n]\n\ncall([find_executable(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>gcc<span class=\"pl-pds\">'</span></span>)] <span class=\"pl-k\">+</span> cuda_libdirs <span class=\"pl-k\">+</span> args <span class=\"pl-k\">+</span> tf_libs)</pre></div>\n<h4>5. Incomplete RPATH in the target-side <code>libtensorflow_framwork.so</code></h4>\n<p>The library gets linked using a bunch of RPATH parameters, but one seems to be missing. It causes linking errors down the road. I have added the following to the original <code>crosstool_wrapper_driver_is_not_gcc</code> script to fix the problem:</p>\n<div class=\"highlight highlight-source-python\"><pre>  ofile <span class=\"pl-k\">=</span> GetOptionValue(sys.argv[<span class=\"pl-c1\">1</span>:], <span class=\"pl-s\"><span class=\"pl-pds\">'</span>o<span class=\"pl-pds\">'</span></span>)\n  <span class=\"pl-k\">if</span> ofile <span class=\"pl-k\">and</span> ofile[<span class=\"pl-c1\">0</span>].endswith(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>libtensorflow_framework.so<span class=\"pl-pds\">'</span></span>):\n    cpu_compiler_flags <span class=\"pl-k\">+=</span> [\n        <span class=\"pl-s\"><span class=\"pl-pds\">'</span>-Wl,-rpath,<span class=\"pl-pds\">'</span></span><span class=\"pl-k\">+</span>os.getcwd()<span class=\"pl-k\">+</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>/bazel-out/arm-py3-opt/genfiles/external/local_config_cuda/cuda/cuda/lib<span class=\"pl-pds\">'</span></span>,\n    ]</pre></div>\n<h4>6. Platform metadata of the resulting wheel package</h4>\n<p>Since the build host platform is <code>linux_x86_64</code>, this ends up being written in the wheel metadata. The issue can be fixed by manually passing the <code>--plat-name</code> parameter to distutils. I have, therefore, added <a class=\"commit-link\" data-hovercard-type=\"commit\" data-hovercard-url=\"https://github.com/ljanyst/tensorflow/commit/a9b952e3850b0c416a37f4f4b488adf8189638a7/hovercard\" href=\"https://github.com/ljanyst/tensorflow/commit/a9b952e3850b0c416a37f4f4b488adf8189638a7\">ljanyst@<tt>a9b952e</tt></a> to <code>build_pip_package.sh</code>. Please let me know if you'd like a pull request.</p>\n<p>It hope it's helpful.</p>", "body_text": "System information\n\nHave I written custom code (as opposed to using a stock example script provided in TensorFlow): Yes\nOS Platform and Distribution (e.g., Linux Ubuntu 16.04): Linux Ubuntu 16.04\nTensorFlow installed from (source or binary): Source\nTensorFlow version (use command below): 1.5.0\nPython version:  3.5.2\nBazel version (if compiling from source): 0.10.0\nGCC/Compiler version (if compiling from source): gcc version 5.4.0 20160609\nCUDA/cuDNN version: 8.0/6.0\nGPU model and memory: Irrelevant\nExact command to reproduce:\n\n\nInstall gcc cross-compiler: sudo apt-get install gcc-aarch64-linux-gnu g++-aarch64-linux-gnu\nInstall the CUDA cross-aarch64 packages\nBuild Python 3.5.2 for the target\nI wrote a short blog post with the details: https://jany.st/post/2018-02-05-cross-compiling-tensorflow-for-jetson-tx1-with-bazel.html\n\ngit clone https://github.com/ljanyst/tensorflow.git\ncd tensorflow\ngit checkout v1.5.0-cross-jetson-tx1\ncd third_party/toolchains/cpus/aarch64\n./configure.py\ncd ../../../..\n./configure\nbazel build  --config=opt --config=cuda \\\n   --crosstool_top=//third_party/toolchains/cpus/aarch64:toolchain \\\n    --cpu=arm  --compiler=cuda \\\n    //tensorflow/tools/pip_package:build_pip_package\n\nDescribe the problem\nI have succeeded, but I encountered a bunch of issues on the way. Due to my unfamiliarity with Bazel, my solution is rather hacky. It looks to me like properly fixing it is a rather low hanging fruit for a person familiar with Bazel, so I document what I have discovered here.\n1. Configuring CUDA for the target\nI could not find a way in the to check CUDA configuration script whether the source is supposed to be configured for a cross build, so I ended up changing the hardcoded paths: ljanyst@1a2a75f If there was a way to check if we're building for a platform that is different from the one of the build host, this could be easily turned into some sort of an if statement.\n2. Specifying target Python installation\nI could not find an easy way to patch that through, so I ended up putting it in the CROSSTOOL file:\ncxx_flag: \"-isystem\"\ncxx_flag: \"__TARGET_PYTHON_INCLUDES__\"\n\n3. Code generators depend on libtensorflow_framework.so which, in turn, depends on CUDA\nThis means that I needed to have the CUDA and cuDNN libraries for the build host and needed to pass the relevant library paths to the compiler in a wrapper script.\n4. Linking of the code generators fails on the build-host side\nBazel builds both the code generators and libtensorflow_framework.so for the host, but does not link the binaries against the framework library.\nI have worked around the two above issues by writing a compiler wrapper scripts doing the following:\nif ofile is not None:\n    is_gen = ofile.endswith('py_wrappers_cc') or ofile.endswith('gen_cc')\n    if is_cuda == 'yes' and (ofile.endswith('libtensorflow_framework.so') or is_gen):\n        cuda_libdirs = [\n            '-L', '{}/targets/x86_64-linux/lib'.format(cuda_dir),\n            '-L', '{}/targets/x86_64-linux/lib/stubs'.format(cuda_dir),\n            '-L', '{}/lib64'.format(cudnn_dir),\n        ]\n\n    if is_gen:\n        tf_libs += [\n            '-L', 'bazel-out/host/bin/tensorflow',\n            '-ltensorflow_framework'\n]\n\ncall([find_executable('gcc')] + cuda_libdirs + args + tf_libs)\n5. Incomplete RPATH in the target-side libtensorflow_framwork.so\nThe library gets linked using a bunch of RPATH parameters, but one seems to be missing. It causes linking errors down the road. I have added the following to the original crosstool_wrapper_driver_is_not_gcc script to fix the problem:\n  ofile = GetOptionValue(sys.argv[1:], 'o')\n  if ofile and ofile[0].endswith('libtensorflow_framework.so'):\n    cpu_compiler_flags += [\n        '-Wl,-rpath,'+os.getcwd()+'/bazel-out/arm-py3-opt/genfiles/external/local_config_cuda/cuda/cuda/lib',\n    ]\n6. Platform metadata of the resulting wheel package\nSince the build host platform is linux_x86_64, this ends up being written in the wheel metadata. The issue can be fixed by manually passing the --plat-name parameter to distutils. I have, therefore, added ljanyst@a9b952e to build_pip_package.sh. Please let me know if you'd like a pull request.\nIt hope it's helpful.", "body": "### System information\r\n- **Have I written custom code (as opposed to using a stock example script provided in TensorFlow)**: Yes\r\n- **OS Platform and Distribution (e.g., Linux Ubuntu 16.04)**: Linux Ubuntu 16.04\r\n- **TensorFlow installed from (source or binary)**: Source\r\n- **TensorFlow version (use command below)**: 1.5.0\r\n- **Python version**:  3.5.2\r\n- **Bazel version (if compiling from source)**: 0.10.0\r\n- **GCC/Compiler version (if compiling from source)**: gcc version 5.4.0 20160609\r\n- **CUDA/cuDNN version**: 8.0/6.0\r\n- **GPU model and memory**: Irrelevant\r\n- **Exact command to reproduce**:\r\n\r\n* Install gcc cross-compiler: `sudo apt-get install gcc-aarch64-linux-gnu g++-aarch64-linux-gnu`\r\n* Install the CUDA `cross-aarch64` packages\r\n* Build Python 3.5.2 for the target\r\n* I wrote a short blog post with the details: https://jany.st/post/2018-02-05-cross-compiling-tensorflow-for-jetson-tx1-with-bazel.html\r\n\r\n```\r\ngit clone https://github.com/ljanyst/tensorflow.git\r\ncd tensorflow\r\ngit checkout v1.5.0-cross-jetson-tx1\r\ncd third_party/toolchains/cpus/aarch64\r\n./configure.py\r\ncd ../../../..\r\n./configure\r\nbazel build  --config=opt --config=cuda \\\r\n   --crosstool_top=//third_party/toolchains/cpus/aarch64:toolchain \\\r\n    --cpu=arm  --compiler=cuda \\\r\n    //tensorflow/tools/pip_package:build_pip_package\r\n```\r\n### Describe the problem\r\nI have succeeded, but I encountered a bunch of issues on the way. Due to my unfamiliarity with Bazel, my solution is rather hacky. It looks to me like properly fixing it is a rather low hanging fruit for a person familiar with Bazel, so I document what I have discovered here.\r\n\r\n#### 1. Configuring CUDA for the target\r\n\r\nI could not find a way in the to check CUDA configuration script whether the source is supposed to be configured for a cross build, so I ended up changing the hardcoded paths: https://github.com/ljanyst/tensorflow/commit/1a2a75fed9a9576c4e9e8f89ee556263cf22deaf If there was a way to check if we're building for a platform that is different from the one of the build host, this could be easily turned into some sort of an if statement.\r\n\r\n#### 2. Specifying target Python installation\r\n\r\nI could not find an easy way to patch that through, so I ended up putting it in the [CROSSTOOL](https://github.com/ljanyst/tensorflow/blob/v1.5.0-cross-jetson-tx1/third_party/toolchains/cpus/aarch64/CROSSTOOL.in) file:\r\n\r\n```\r\ncxx_flag: \"-isystem\"\r\ncxx_flag: \"__TARGET_PYTHON_INCLUDES__\"\r\n```\r\n\r\n#### 3. Code generators depend on `libtensorflow_framework.so` which, in turn, depends on CUDA\r\n\r\nThis means that I needed to have the CUDA and cuDNN libraries for the build host and needed to pass the relevant library paths to the compiler [in a wrapper script](https://github.com/ljanyst/tensorflow/blob/v1.5.0-cross-jetson-tx1/third_party/toolchains/cpus/aarch64/crosstool_wrapper_host_tf_framework#L41).\r\n\r\n#### 4. Linking of the code generators fails on the build-host side\r\n\r\nBazel builds both the code generators and `libtensorflow_framework.so` for the host, but does not link the binaries against the framework library.\r\n\r\nI have worked around the two above issues by writing a compiler wrapper scripts doing the following:\r\n\r\n```python\r\nif ofile is not None:\r\n    is_gen = ofile.endswith('py_wrappers_cc') or ofile.endswith('gen_cc')\r\n    if is_cuda == 'yes' and (ofile.endswith('libtensorflow_framework.so') or is_gen):\r\n        cuda_libdirs = [\r\n            '-L', '{}/targets/x86_64-linux/lib'.format(cuda_dir),\r\n            '-L', '{}/targets/x86_64-linux/lib/stubs'.format(cuda_dir),\r\n            '-L', '{}/lib64'.format(cudnn_dir),\r\n        ]\r\n\r\n    if is_gen:\r\n        tf_libs += [\r\n            '-L', 'bazel-out/host/bin/tensorflow',\r\n            '-ltensorflow_framework'\r\n]\r\n\r\ncall([find_executable('gcc')] + cuda_libdirs + args + tf_libs)\r\n```\r\n\r\n#### 5. Incomplete RPATH in the target-side `libtensorflow_framwork.so`\r\n\r\nThe library gets linked using a bunch of RPATH parameters, but one seems to be missing. It causes linking errors down the road. I have added the following to the original `crosstool_wrapper_driver_is_not_gcc` script to fix the problem:\r\n\r\n```python\r\n  ofile = GetOptionValue(sys.argv[1:], 'o')\r\n  if ofile and ofile[0].endswith('libtensorflow_framework.so'):\r\n    cpu_compiler_flags += [\r\n        '-Wl,-rpath,'+os.getcwd()+'/bazel-out/arm-py3-opt/genfiles/external/local_config_cuda/cuda/cuda/lib',\r\n    ]\r\n```\r\n\r\n#### 6. Platform metadata of the resulting wheel package\r\n\r\nSince the build host platform is `linux_x86_64`, this ends up being written in the wheel metadata. The issue can be fixed by manually passing the `--plat-name` parameter to distutils. I have, therefore, added https://github.com/ljanyst/tensorflow/commit/a9b952e3850b0c416a37f4f4b488adf8189638a7 to `build_pip_package.sh`. Please let me know if you'd like a pull request.\r\n\r\nIt hope it's helpful.\r\n"}