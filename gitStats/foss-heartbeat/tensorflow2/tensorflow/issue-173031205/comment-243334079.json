{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/243334079", "html_url": "https://github.com/tensorflow/tensorflow/issues/4022#issuecomment-243334079", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/4022", "id": 243334079, "node_id": "MDEyOklzc3VlQ29tbWVudDI0MzMzNDA3OQ==", "user": {"login": "ebrevdo", "id": 1794715, "node_id": "MDQ6VXNlcjE3OTQ3MTU=", "avatar_url": "https://avatars0.githubusercontent.com/u/1794715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebrevdo", "html_url": "https://github.com/ebrevdo", "followers_url": "https://api.github.com/users/ebrevdo/followers", "following_url": "https://api.github.com/users/ebrevdo/following{/other_user}", "gists_url": "https://api.github.com/users/ebrevdo/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebrevdo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebrevdo/subscriptions", "organizations_url": "https://api.github.com/users/ebrevdo/orgs", "repos_url": "https://api.github.com/users/ebrevdo/repos", "events_url": "https://api.github.com/users/ebrevdo/events{/privacy}", "received_events_url": "https://api.github.com/users/ebrevdo/received_events", "type": "User", "site_admin": false}, "created_at": "2016-08-30T05:05:27Z", "updated_at": "2016-08-30T05:05:27Z", "author_association": "CONTRIBUTOR", "body_html": "<p>I'll answer regarding the behavior of your \"correct script\":</p>\n<p>When you call <code>tf.train.batch</code> with <code>enqueue_many=False</code>, here is the sequence of what is being added to the <code>PaddingFIFOQueue</code> underneath:</p>\n<pre><code>n=0, insert []  # the empty vector\nn=1, insert [1]\nn=2, insert [1, 2]\nn=3, insert [1, 2, 3]\nn=4, insert [1, 2, 3, 4]\n</code></pre>\n<p>note in each case you are inserting a <em>single batch element</em> which is a vector.  just that the vectors have varying lengths.  this is because you used <code>enqueue_many=False</code>, so each input Tensor is considered one single batch element.</p>\n<p>As a result, when you <code>dequeue_many</code> with <code>batch_size=5</code> you are asking for these 5 elements back.  The <code>PaddingFIFOQueue</code> pads these entries to the length of the longest one in the minibatch (4, from <code>n=4</code>) and you get <code>5</code> rows out:</p>\n<pre><code>[       ]\n[1      ]\n[1 2    ]\n[1 2 3  ]\n[1 2 3 4]\n</code></pre>\n<p>note that <code>PaddingFIFOQueue</code> pads integer valued outputs with <code>0</code>s.</p>\n<p>In contrast, when you call <code>tf.train.batch</code> with <code>enqueue_many=True</code>, each enqueue of <code>y</code> is treated as some variable number of scalars to be added to the <code>PaddingFIFOQueue</code>.  That is, here is what gets added at each step:</p>\n<pre><code>n=0, insert nothing\nn=1, insert 1\nn=2, insert 1, then insert 2\nn=3, insert 1, then insert 2, then insert 3\nn=4, insert 1, then insert 2, then insert 3, then insert 4\n</code></pre>\n<p>You then ask for <code>5</code> elements from this scalar component.  The <code>PaddingFIFOQueue</code> sees you are asking for 5 scalars and as a result, no padding is necessary.  It returns to you:</p>\n<pre><code>[1]  # the single entry from the n=1 insert\n[1]  # first entry from the n=2 inserts\n[2]  # second entry from the n=2 inserts\n[1]  # first entry from the n=3 inserts\n[2]  # second entry from the n=3 inserts\n</code></pre>\n<p>(except you saw it as a vector, here i've written it as a column vector to show that each row is a scalar, and is considered a minibatch entry)</p>", "body_text": "I'll answer regarding the behavior of your \"correct script\":\nWhen you call tf.train.batch with enqueue_many=False, here is the sequence of what is being added to the PaddingFIFOQueue underneath:\nn=0, insert []  # the empty vector\nn=1, insert [1]\nn=2, insert [1, 2]\nn=3, insert [1, 2, 3]\nn=4, insert [1, 2, 3, 4]\n\nnote in each case you are inserting a single batch element which is a vector.  just that the vectors have varying lengths.  this is because you used enqueue_many=False, so each input Tensor is considered one single batch element.\nAs a result, when you dequeue_many with batch_size=5 you are asking for these 5 elements back.  The PaddingFIFOQueue pads these entries to the length of the longest one in the minibatch (4, from n=4) and you get 5 rows out:\n[       ]\n[1      ]\n[1 2    ]\n[1 2 3  ]\n[1 2 3 4]\n\nnote that PaddingFIFOQueue pads integer valued outputs with 0s.\nIn contrast, when you call tf.train.batch with enqueue_many=True, each enqueue of y is treated as some variable number of scalars to be added to the PaddingFIFOQueue.  That is, here is what gets added at each step:\nn=0, insert nothing\nn=1, insert 1\nn=2, insert 1, then insert 2\nn=3, insert 1, then insert 2, then insert 3\nn=4, insert 1, then insert 2, then insert 3, then insert 4\n\nYou then ask for 5 elements from this scalar component.  The PaddingFIFOQueue sees you are asking for 5 scalars and as a result, no padding is necessary.  It returns to you:\n[1]  # the single entry from the n=1 insert\n[1]  # first entry from the n=2 inserts\n[2]  # second entry from the n=2 inserts\n[1]  # first entry from the n=3 inserts\n[2]  # second entry from the n=3 inserts\n\n(except you saw it as a vector, here i've written it as a column vector to show that each row is a scalar, and is considered a minibatch entry)", "body": "I'll answer regarding the behavior of your \"correct script\":\n\nWhen you call `tf.train.batch` with `enqueue_many=False`, here is the sequence of what is being added to the `PaddingFIFOQueue` underneath:\n\n```\nn=0, insert []  # the empty vector\nn=1, insert [1]\nn=2, insert [1, 2]\nn=3, insert [1, 2, 3]\nn=4, insert [1, 2, 3, 4]\n```\n\nnote in each case you are inserting a _single batch element_ which is a vector.  just that the vectors have varying lengths.  this is because you used `enqueue_many=False`, so each input Tensor is considered one single batch element.\n\nAs a result, when you `dequeue_many` with `batch_size=5` you are asking for these 5 elements back.  The `PaddingFIFOQueue` pads these entries to the length of the longest one in the minibatch (4, from `n=4`) and you get `5` rows out:\n\n```\n[       ]\n[1      ]\n[1 2    ]\n[1 2 3  ]\n[1 2 3 4]\n```\n\nnote that `PaddingFIFOQueue` pads integer valued outputs with `0`s.\n\nIn contrast, when you call `tf.train.batch` with `enqueue_many=True`, each enqueue of `y` is treated as some variable number of scalars to be added to the `PaddingFIFOQueue`.  That is, here is what gets added at each step:\n\n```\nn=0, insert nothing\nn=1, insert 1\nn=2, insert 1, then insert 2\nn=3, insert 1, then insert 2, then insert 3\nn=4, insert 1, then insert 2, then insert 3, then insert 4\n```\n\nYou then ask for `5` elements from this scalar component.  The `PaddingFIFOQueue` sees you are asking for 5 scalars and as a result, no padding is necessary.  It returns to you:\n\n```\n[1]  # the single entry from the n=1 insert\n[1]  # first entry from the n=2 inserts\n[2]  # second entry from the n=2 inserts\n[1]  # first entry from the n=3 inserts\n[2]  # second entry from the n=3 inserts\n```\n\n(except you saw it as a vector, here i've written it as a column vector to show that each row is a scalar, and is considered a minibatch entry)\n"}