{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/210976087", "pull_request_review_id": 147297338, "id": 210976087, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDk3NjA4Nw==", "diff_hunk": "@@ -0,0 +1,529 @@\n+\"\"\"Assemble common TF Dockerfiles from many parts.\n+\n+This script constructs TF's Dockerfiles by aggregating partial\n+Dockerfiles. See README.md for usage examples.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+from __future__ import division\n+from __future__ import print_function\n+\n+import copy\n+import errno\n+import os\n+import os.path\n+import re\n+import shutil\n+import textwrap\n+\n+from absl import app\n+from absl import flags\n+import cerberus\n+import yaml\n+\n+FLAGS = flags.FLAGS\n+\n+flags.DEFINE_boolean(\n+    'dry_run', False, 'Do not actually generate Dockerfiles', short_name='n')\n+\n+flags.DEFINE_string(\n+    'spec_file',\n+    './spec.yml',\n+    'Path to a YAML specification file',\n+    short_name='s')\n+\n+flags.DEFINE_string(\n+    'output_dir',\n+    '.', ('Path to an output directory for Dockerfiles. '\n+          'Will be created if it doesn\\'t exist.'),\n+    short_name='o')\n+\n+flags.DEFINE_string(\n+    'partial_dir',\n+    './partials',\n+    'Path to a directory containing foo.partial.Dockerfile partial files.',\n+    short_name='p')\n+\n+flags.DEFINE_boolean(\n+    'quiet_dry_run',\n+    True,\n+    'Do not print contents of dry run Dockerfiles.',\n+    short_name='q')\n+\n+flags.DEFINE_boolean(\n+    'validate', True, 'Validate generated Dockerfiles', short_name='c')\n+\n+# Schema to verify the contents of spec.yml with Cerberus.\n+# Must be converted to a dict from yaml to work.\n+# Note: can add python references with e.g.\n+# !!python/name:builtins.str\n+# !!python/name:__main__.funcname\n+SCHEMA_TEXT = \"\"\"\n+header:\n+  type: string\n+\n+partials:\n+  type: dict\n+  keyschema:\n+    type: string\n+  valueschema:\n+    type: dict\n+    schema:\n+      desc:\n+        type: string\n+      args:\n+        type: dict\n+        keyschema:\n+          type: string\n+        valueschema:\n+          anyof:\n+            - type: [ boolean, number, string ]\n+            - type: dict\n+              schema:\n+                 default:\n+                    type: [ boolean, number, string ]\n+                 desc:\n+                    type: string\n+                 options:\n+                    type: list\n+                    schema:\n+                       type: string\n+\n+images:\n+  keyschema:\n+    type: string\n+  valueschema:\n+    type: dict\n+    schema:\n+      desc:\n+        type: string\n+      arg-defaults:\n+        type: list\n+        schema:\n+          anyof:\n+            - type: dict\n+              keyschema:\n+                type: string\n+                arg_in_use: true\n+              valueschema:\n+                type: string\n+            - type: string\n+              isimage: true\n+      create-dockerfile:\n+        type: boolean\n+      partials:\n+        type: list\n+        schema:\n+          anyof:\n+            - type: dict\n+              keyschema:\n+                type: string\n+                regex: image\n+              valueschema:\n+                type: string\n+                isimage: true\n+            - type: string\n+              ispartial: true\n+\"\"\"\n+\n+\n+class TfDockerValidator(cerberus.Validator):\n+  \"\"\"Custom Cerberus validator for TF dockerfile spec.\n+\n+  Note that each custom validator's docstring must end with a segment describing\n+  its own validation schema.\n+  \"\"\"\n+\n+  def _validate_ispartial(self, ispartial, field, value):\n+    \"\"\"Validate that a partial references an existing partial spec.\n+\n+    Args:\n+      ispartial: Value of the rule, a bool\n+      field: The field being validated\n+      value: The field's value\n+\n+    The rule's arguments are validated against this schema:\n+    {'type': 'boolean'}\n+    \"\"\"\n+    if ispartial and value not in self.root_document.get('partials', dict()):\n+      self._error(field, '{} is not an existing partial.'.format(value))\n+\n+  def _validate_isimage(self, isimage, field, value):\n+    \"\"\"Validate that an image references an existing partial spec.\n+\n+    Args:\n+      isimage: Value of the rule, a bool\n+      field: The field being validated\n+      value: The field's value\n+\n+    The rule's arguments are validated against this schema:\n+    {'type': 'boolean'}\n+    \"\"\"\n+    if isimage and value not in self.root_document.get('images', dict()):\n+      self._error(field, '{} is not an existing image.'.format(value))\n+\n+  def _validate_arg_in_use(self, arg_in_use, field, value):\n+    \"\"\"Validate that an arg references an existing partial spec's args.\n+\n+    Args:\n+      arg_in_use: Value of the rule, a bool\n+      field: The field being validated\n+      value: The field's value\n+\n+    The rule's arguments are validated against this schema:\n+    {'type': 'boolean'}\n+    \"\"\"\n+    if arg_in_use:\n+      for partial in self.root_document.get('partials', dict()).values():\n+        if value in partial.get('args', tuple()):\n+          return\n+      self._error(field, '{} is not an arg used in any partial.'.format(value))\n+\n+\n+def build_partial_description(partial_spec):\n+  \"\"\"Create the documentation lines for a specific partial.\n+\n+  Generates something like this:\n+\n+    # This is the partial's description, from spec.yml.\n+    # --build-arg ARG_NAME=argdefault\n+    #    this is one of the args.\n+    # --build-arg ANOTHER_ARG=(some|choices)\n+    #    another arg.\n+\n+  Args:\n+    partial_spec: A dict representing one of the partials from spec.yml. Doesn't\n+      include the name of the partial; is a dict like { desc: ..., args: ... }.\n+\n+  Returns:\n+    A commented string describing this partial.\n+  \"\"\"\n+\n+  # Start from linewrapped desc field\n+  lines = []\n+  wrapper = textwrap.TextWrapper(\n+      initial_indent='# ', subsequent_indent='# ', width=80)\n+  description = wrapper.fill(partial_spec.get('desc', '( no comments )'))\n+  lines.extend(['#', description])\n+\n+  # Document each arg\n+  for arg, arg_data in partial_spec.get('args', dict()).items():\n+\n+    # Wrap arg description with comment lines\n+    desc = arg_data.get('desc', '( no description )')\n+    desc = textwrap.fill(\n+        desc,\n+        initial_indent='#    ',\n+        subsequent_indent='#    ',\n+        width=80,\n+        drop_whitespace=False)\n+\n+    # Document (each|option|like|this)\n+    if 'options' in arg_data:\n+      arg_options = ' ({})'.format('|'.join(arg_data['options']))\n+    else:\n+      arg_options = ''\n+\n+    # Add usage sample\n+    arg_use = '# --build-arg {}={}{}'.format(arg,\n+                                             arg_data.get('default', '(unset)'),\n+                                             arg_options)\n+    lines.extend([arg_use, desc])\n+  return '\\n'.join(lines)\n+\n+\n+def construct_contents(partial_specs, image_spec):\n+  \"\"\"Assemble the dockerfile contents for an image spec.\n+\n+  It assembles a concrete list of partial references into a single, large\n+  string.\n+  Also expands argument defaults, so that the resulting Dockerfile doesn't have\n+  to be configured with --build-arg=... every time. That is, any ARG directive\n+  will be updated with a new default value.\n+\n+  Args:\n+    partial_specs: The dict from spec.yml[\"partials\"].\n+    image_spec: One of the dict values from spec.yml[\"images\"].\n+\n+  Returns:\n+    A string containing a valid Dockerfile based on the partials listed in\n+    image_spec.\n+  \"\"\"\n+  processed_partial_strings = []\n+  for partial_name in image_spec['partials']:\n+\n+    # Apply image arg-defaults to existing arg defaults\n+    partial_spec = copy.deepcopy(partial_specs[partial_name])\n+    args = partial_spec.get('args', dict())\n+    for k_v in image_spec.get('arg-defaults', []):\n+      arg, value = list(k_v.items())[0]\n+      if arg in args:\n+        args[arg]['default'] = value\n+\n+    # Read partial file contents\n+    filename = partial_spec.get('file', partial_name)\n+    partial_path = os.path.join(FLAGS.partial_dir,\n+                                '{}.partial.Dockerfile'.format(filename))\n+    with open(partial_path, 'r') as f_partial:\n+      partial_contents = f_partial.read()\n+\n+    # Replace ARG FOO=BAR with ARG FOO=[new-default]\n+    for arg, arg_data in args.items():\n+      if 'default' in arg_data and arg_data['default']:\n+        default = '={}'.format(arg_data['default'])\n+      else:\n+        default = ''\n+      partial_contents = re.sub(r'ARG {}.*'.format(arg), 'ARG {}{}'.format(\n+          arg, default), partial_contents)\n+    processed_partial_strings.append(partial_contents)\n+  return '\\n'.join(processed_partial_strings)\n+\n+\n+# Create a directory and its parents, even if it already exists\n+def mkdir_p(path):\n+  try:\n+    os.makedirs(path)\n+  except OSError as e:\n+    if e.errno != errno.EEXIST:\n+      raise\n+\n+\n+def construct_documentation(header, partial_specs, image_spec):\n+  \"\"\"Assemble all of the documentation for a single dockerfile.\n+\n+  Builds explanations of included partials and available build args.\n+\n+  Args:\n+    header: The string from spec.yml[\"header\"]; will be commented and wrapped.\n+    partial_specs: The dict from spec.yml[\"partials\"].\n+    image_spec: The spec for the dockerfile being built.\n+\n+  Returns:\n+    A string containing a commented header that documents the contents of the\n+    dockerfile.\n+\n+  \"\"\"\n+  # Comment and wrap header and image description\n+  commented_header = '\\n'.join(['# ' + l for l in header.splitlines()])\n+  commented_desc = '\\n'.join(\n+      ['# ' + l for l in image_spec.get('desc', '').splitlines()])\n+  partial_descriptions = []\n+\n+  # Build documentation for each partial in the image\n+  for partial in image_spec['partials']:\n+\n+    # Copy partial data for default args unique to this image\n+    partial_spec = copy.deepcopy(partial_specs[partial])\n+    args = partial_spec.get('args', dict())\n+\n+    # Overwrite any existing arg defaults\n+    for k_v in image_spec.get('arg-defaults', []):\n+      arg, value = list(k_v.items())[0]\n+      if arg in args:\n+        args[arg]['default'] = value\n+\n+    # Build the description from new args\n+    partial_description = build_partial_description(partial_spec)\n+    partial_descriptions.append(partial_description)\n+\n+  contents = [commented_header, '#', commented_desc] + partial_descriptions\n+  return '\\n'.join(contents) + '\\n'\n+\n+\n+def normalize_partial_args(partial_specs):\n+  \"\"\"Normalize the shorthand form of a partial's args specification.\n+\n+  Turns this:\n+\n+    partial:\n+      args:\n+        SOME_ARG: arg_value\n+\n+  Into this:\n+\n+    partial:\n+       args:\n+         SOME_ARG:\n+            default: arg_value\n+\n+  Args:\n+    partial_specs: The dict from spec.yml[\"partials\"]. This dict is modified in\n+      place.\n+\n+  Returns:\n+    The modified contents of partial_specs.\n+\n+  \"\"\"\n+  for _, partial in partial_specs.items():\n+    args = partial.get('args', dict())\n+    for arg, value in args.items():\n+      if not isinstance(value, dict):\n+        new_value = {'default': value}\n+        args[arg] = new_value\n+  return partial_specs\n+\n+\n+def flatten_args_references(image_specs):\n+  \"\"\"Resolve all default-args in each image spec to a concrete dict.\n+\n+  Turns this:\n+\n+    example-image:\n+      arg-defaults:\n+        - MY_ARG: ARG_VALUE\n+\n+    another-example:\n+      arg-defaults:\n+        - ANOTHER_ARG: ANOTHER_VALUE\n+        - example_image\n+\n+  Into this:\n+\n+    example-image:\n+      arg-defaults:\n+        - MY_ARG: ARG_VALUE\n+\n+    another-example:\n+      arg-defaults:\n+        - ANOTHER_ARG: ANOTHER_VALUE\n+        - MY_ARG: ARG_VALUE\n+\n+  Args:\n+    image_specs: A dict of image_spec dicts; should be the contents of the\n+      \"images\" key in the global spec.yaml. This dict is modified in place and\n+      then returned.\n+\n+  Returns:\n+    The modified contents of image_specs.\n+  \"\"\"\n+  for _, image_spec in image_specs.items():\n+    too_deep = 0\n+    while str in map(type, image_spec.get('arg-defaults', [])) and too_deep < 5:\n+      new_args = []\n+      for arg in image_spec['arg-defaults']:\n+        if isinstance(arg, str):\n+          new_args.extend(image_specs[arg]['arg-defaults'])\n+        else:\n+          new_args.append(arg)\n+      image_spec['arg-defaults'] = new_args\n+      too_deep += 1\n+  return image_specs\n+\n+\n+def flatten_partial_references(image_specs):\n+  \"\"\"Resolve all partial references in each image spec to a concrete list.\n+\n+  Turns this:\n+\n+    example-image:\n+      partials:\n+        - foo\n+\n+    another-example:\n+      partials:\n+        - bar\n+        - image: example-image\n+        - bat\n+\n+  Into this:\n+\n+    example-image:\n+      partials:\n+        - foo\n+\n+    another-example:\n+      partials:\n+        - bar\n+        - foo\n+        - bat\n+  Args:\n+    image_specs: A dict of image_spec dicts; should be the contents of the\n+      \"images\" key in the global spec.yaml. This dict is modified in place and\n+      then returned.\n+\n+  Returns:\n+    The modified contents of image_specs.\n+  \"\"\"\n+  for _, image_spec in image_specs.items():\n+    too_deep = 0\n+    while dict in map(type, image_spec['partials']) and too_deep < 5:\n+      new_partials = []\n+      for partial in image_spec['partials']:\n+        if isinstance(partial, str):\n+          new_partials.append(partial)\n+        else:\n+          new_partials.extend(image_specs[partial['image']]['partials'])\n+      image_spec['partials'] = new_partials\n+      too_deep += 1\n+  return image_specs\n+\n+\n+def construct_dockerfiles(tf_spec):\n+  \"\"\"Generate a mapping of {\"cpu\": <cpu dockerfile contents>, ...}.\n+\n+  Args:\n+    tf_spec: The full spec.yml loaded as a python object.\n+\n+  Returns:\n+    A string:string dict of short names (\"cpu-devel\") to Dockerfile contents.\n+  \"\"\"\n+  names_to_contents = dict()\n+  image_specs = tf_spec['images']\n+  image_specs = flatten_partial_references(image_specs)\n+  image_specs = flatten_args_references(image_specs)\n+  partial_specs = tf_spec['partials']\n+  partial_specs = normalize_partial_args(partial_specs)\n+\n+  for name, image_spec in image_specs.items():\n+    if not image_spec.get('create-dockerfile', True):\n+      continue\n+    documentation = construct_documentation(tf_spec['header'], partial_specs,\n+                                            image_spec)\n+    contents = construct_contents(partial_specs, image_spec)\n+    names_to_contents[name] = '\\n'.join([documentation, contents])\n+  return names_to_contents\n+\n+\n+def main(argv):\n+  if len(argv) > 1:\n+    raise app.UsageError('Too many command-line arguments.')", "path": "tensorflow/tools/dockerfiles/assembler.py", "position": null, "original_position": 489, "commit_id": "5bfdb84bc54e52b509a366991ea4f5156c1fca34", "original_commit_id": "00869fc36a952418ffa75fd4fd5763b993251dd2", "user": {"login": "gunan", "id": 7946809, "node_id": "MDQ6VXNlcjc5NDY4MDk=", "avatar_url": "https://avatars3.githubusercontent.com/u/7946809?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gunan", "html_url": "https://github.com/gunan", "followers_url": "https://api.github.com/users/gunan/followers", "following_url": "https://api.github.com/users/gunan/following{/other_user}", "gists_url": "https://api.github.com/users/gunan/gists{/gist_id}", "starred_url": "https://api.github.com/users/gunan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gunan/subscriptions", "organizations_url": "https://api.github.com/users/gunan/orgs", "repos_url": "https://api.github.com/users/gunan/repos", "events_url": "https://api.github.com/users/gunan/events{/privacy}", "received_events_url": "https://api.github.com/users/gunan/received_events", "type": "User", "site_admin": false}, "body": "Maybe rewrite this error as: Unexpected command line args found: \r\nis there a way to also foce print the \"help\" documenting all the flags?", "created_at": "2018-08-17T17:17:03Z", "updated_at": "2018-08-23T19:56:53Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/21291#discussion_r210976087", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/21291", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/210976087"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/21291#discussion_r210976087"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/21291"}}, "body_html": "<p>Maybe rewrite this error as: Unexpected command line args found:<br>\nis there a way to also foce print the \"help\" documenting all the flags?</p>", "body_text": "Maybe rewrite this error as: Unexpected command line args found:\nis there a way to also foce print the \"help\" documenting all the flags?"}