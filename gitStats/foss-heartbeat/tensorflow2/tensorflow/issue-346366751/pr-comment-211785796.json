{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/211785796", "pull_request_review_id": 148281978, "id": 211785796, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMTc4NTc5Ng==", "diff_hunk": "@@ -0,0 +1,529 @@\n+\"\"\"Assemble common TF Dockerfiles from many parts.\n+\n+This script constructs TF's Dockerfiles by aggregating partial\n+Dockerfiles. See README.md for usage examples.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+from __future__ import division\n+from __future__ import print_function\n+\n+import copy\n+import errno\n+import os\n+import os.path\n+import re\n+import shutil\n+import textwrap\n+\n+from absl import app\n+from absl import flags\n+import cerberus\n+import yaml\n+\n+FLAGS = flags.FLAGS\n+\n+flags.DEFINE_boolean(\n+    'dry_run', False, 'Do not actually generate Dockerfiles', short_name='n')\n+\n+flags.DEFINE_string(\n+    'spec_file',\n+    './spec.yml',\n+    'Path to a YAML specification file',\n+    short_name='s')\n+\n+flags.DEFINE_string(\n+    'output_dir',\n+    '.', ('Path to an output directory for Dockerfiles. '\n+          'Will be created if it doesn\\'t exist.'),\n+    short_name='o')\n+\n+flags.DEFINE_string(\n+    'partial_dir',\n+    './partials',\n+    'Path to a directory containing foo.partial.Dockerfile partial files.',\n+    short_name='p')\n+\n+flags.DEFINE_boolean(\n+    'quiet_dry_run',\n+    True,\n+    'Do not print contents of dry run Dockerfiles.',\n+    short_name='q')\n+\n+flags.DEFINE_boolean(\n+    'validate', True, 'Validate generated Dockerfiles', short_name='c')\n+\n+# Schema to verify the contents of spec.yml with Cerberus.\n+# Must be converted to a dict from yaml to work.\n+# Note: can add python references with e.g.\n+# !!python/name:builtins.str\n+# !!python/name:__main__.funcname\n+SCHEMA_TEXT = \"\"\"\n+header:\n+  type: string\n+\n+partials:\n+  type: dict\n+  keyschema:\n+    type: string\n+  valueschema:\n+    type: dict\n+    schema:\n+      desc:\n+        type: string\n+      args:\n+        type: dict\n+        keyschema:\n+          type: string\n+        valueschema:\n+          anyof:\n+            - type: [ boolean, number, string ]\n+            - type: dict\n+              schema:\n+                 default:\n+                    type: [ boolean, number, string ]\n+                 desc:\n+                    type: string\n+                 options:\n+                    type: list\n+                    schema:\n+                       type: string\n+\n+images:\n+  keyschema:\n+    type: string\n+  valueschema:\n+    type: dict\n+    schema:\n+      desc:\n+        type: string\n+      arg-defaults:\n+        type: list\n+        schema:\n+          anyof:\n+            - type: dict\n+              keyschema:\n+                type: string\n+                arg_in_use: true\n+              valueschema:\n+                type: string\n+            - type: string\n+              isimage: true\n+      create-dockerfile:\n+        type: boolean\n+      partials:\n+        type: list\n+        schema:\n+          anyof:\n+            - type: dict\n+              keyschema:\n+                type: string\n+                regex: image\n+              valueschema:\n+                type: string\n+                isimage: true\n+            - type: string\n+              ispartial: true\n+\"\"\"\n+\n+\n+class TfDockerValidator(cerberus.Validator):\n+  \"\"\"Custom Cerberus validator for TF dockerfile spec.\n+\n+  Note that each custom validator's docstring must end with a segment describing\n+  its own validation schema.\n+  \"\"\"\n+\n+  def _validate_ispartial(self, ispartial, field, value):\n+    \"\"\"Validate that a partial references an existing partial spec.\n+\n+    Args:\n+      ispartial: Value of the rule, a bool\n+      field: The field being validated\n+      value: The field's value\n+\n+    The rule's arguments are validated against this schema:\n+    {'type': 'boolean'}\n+    \"\"\"\n+    if ispartial and value not in self.root_document.get('partials', dict()):\n+      self._error(field, '{} is not an existing partial.'.format(value))\n+\n+  def _validate_isimage(self, isimage, field, value):\n+    \"\"\"Validate that an image references an existing partial spec.\n+\n+    Args:\n+      isimage: Value of the rule, a bool\n+      field: The field being validated\n+      value: The field's value\n+\n+    The rule's arguments are validated against this schema:\n+    {'type': 'boolean'}\n+    \"\"\"\n+    if isimage and value not in self.root_document.get('images', dict()):\n+      self._error(field, '{} is not an existing image.'.format(value))\n+\n+  def _validate_arg_in_use(self, arg_in_use, field, value):\n+    \"\"\"Validate that an arg references an existing partial spec's args.\n+\n+    Args:\n+      arg_in_use: Value of the rule, a bool\n+      field: The field being validated\n+      value: The field's value\n+\n+    The rule's arguments are validated against this schema:\n+    {'type': 'boolean'}\n+    \"\"\"\n+    if arg_in_use:\n+      for partial in self.root_document.get('partials', dict()).values():\n+        if value in partial.get('args', tuple()):\n+          return\n+      self._error(field, '{} is not an arg used in any partial.'.format(value))\n+\n+\n+def build_partial_description(partial_spec):\n+  \"\"\"Create the documentation lines for a specific partial.\n+\n+  Generates something like this:\n+\n+    # This is the partial's description, from spec.yml.\n+    # --build-arg ARG_NAME=argdefault\n+    #    this is one of the args.\n+    # --build-arg ANOTHER_ARG=(some|choices)\n+    #    another arg.\n+\n+  Args:\n+    partial_spec: A dict representing one of the partials from spec.yml. Doesn't\n+      include the name of the partial; is a dict like { desc: ..., args: ... }.\n+\n+  Returns:\n+    A commented string describing this partial.\n+  \"\"\"\n+\n+  # Start from linewrapped desc field\n+  lines = []\n+  wrapper = textwrap.TextWrapper(\n+      initial_indent='# ', subsequent_indent='# ', width=80)\n+  description = wrapper.fill(partial_spec.get('desc', '( no comments )'))\n+  lines.extend(['#', description])\n+\n+  # Document each arg\n+  for arg, arg_data in partial_spec.get('args', dict()).items():\n+\n+    # Wrap arg description with comment lines\n+    desc = arg_data.get('desc', '( no description )')\n+    desc = textwrap.fill(\n+        desc,\n+        initial_indent='#    ',\n+        subsequent_indent='#    ',\n+        width=80,\n+        drop_whitespace=False)\n+\n+    # Document (each|option|like|this)\n+    if 'options' in arg_data:\n+      arg_options = ' ({})'.format('|'.join(arg_data['options']))\n+    else:\n+      arg_options = ''\n+\n+    # Add usage sample\n+    arg_use = '# --build-arg {}={}{}'.format(arg,\n+                                             arg_data.get('default', '(unset)'),\n+                                             arg_options)\n+    lines.extend([arg_use, desc])\n+  return '\\n'.join(lines)\n+\n+\n+def construct_contents(partial_specs, image_spec):\n+  \"\"\"Assemble the dockerfile contents for an image spec.\n+\n+  It assembles a concrete list of partial references into a single, large\n+  string.\n+  Also expands argument defaults, so that the resulting Dockerfile doesn't have\n+  to be configured with --build-arg=... every time. That is, any ARG directive\n+  will be updated with a new default value.\n+\n+  Args:\n+    partial_specs: The dict from spec.yml[\"partials\"].\n+    image_spec: One of the dict values from spec.yml[\"images\"].\n+\n+  Returns:\n+    A string containing a valid Dockerfile based on the partials listed in\n+    image_spec.\n+  \"\"\"\n+  processed_partial_strings = []\n+  for partial_name in image_spec['partials']:\n+\n+    # Apply image arg-defaults to existing arg defaults\n+    partial_spec = copy.deepcopy(partial_specs[partial_name])\n+    args = partial_spec.get('args', dict())\n+    for k_v in image_spec.get('arg-defaults', []):\n+      arg, value = list(k_v.items())[0]\n+      if arg in args:\n+        args[arg]['default'] = value\n+\n+    # Read partial file contents\n+    filename = partial_spec.get('file', partial_name)\n+    partial_path = os.path.join(FLAGS.partial_dir,\n+                                '{}.partial.Dockerfile'.format(filename))\n+    with open(partial_path, 'r') as f_partial:\n+      partial_contents = f_partial.read()\n+\n+    # Replace ARG FOO=BAR with ARG FOO=[new-default]\n+    for arg, arg_data in args.items():\n+      if 'default' in arg_data and arg_data['default']:\n+        default = '={}'.format(arg_data['default'])\n+      else:\n+        default = ''", "path": "tensorflow/tools/dockerfiles/assembler.py", "position": 290, "original_position": 275, "commit_id": "5bfdb84bc54e52b509a366991ea4f5156c1fca34", "original_commit_id": "00869fc36a952418ffa75fd4fd5763b993251dd2", "user": {"login": "angersson", "id": 32465472, "node_id": "MDQ6VXNlcjMyNDY1NDcy", "avatar_url": "https://avatars2.githubusercontent.com/u/32465472?v=4", "gravatar_id": "", "url": "https://api.github.com/users/angersson", "html_url": "https://github.com/angersson", "followers_url": "https://api.github.com/users/angersson/followers", "following_url": "https://api.github.com/users/angersson/following{/other_user}", "gists_url": "https://api.github.com/users/angersson/gists{/gist_id}", "starred_url": "https://api.github.com/users/angersson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/angersson/subscriptions", "organizations_url": "https://api.github.com/users/angersson/orgs", "repos_url": "https://api.github.com/users/angersson/repos", "events_url": "https://api.github.com/users/angersson/events{/privacy}", "received_events_url": "https://api.github.com/users/angersson/received_events", "type": "User", "site_admin": false}, "body": "How's this?", "created_at": "2018-08-21T22:59:45Z", "updated_at": "2018-08-23T19:56:53Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/21291#discussion_r211785796", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/21291", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/211785796"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/21291#discussion_r211785796"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/21291"}}, "body_html": "<p>How's this?</p>", "body_text": "How's this?", "in_reply_to_id": 210975134}