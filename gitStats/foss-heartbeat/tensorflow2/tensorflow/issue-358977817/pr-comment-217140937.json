{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/217140937", "pull_request_review_id": 154784165, "id": 217140937, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNzE0MDkzNw==", "diff_hunk": "@@ -0,0 +1,763 @@\n+# Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+# ==============================================================================\n+\n+\"\"\"Ignite Dataset.\"\"\"\n+from __future__ import absolute_import\n+from __future__ import division\n+from __future__ import print_function\n+\n+import socket\n+import struct\n+import ssl\n+import abc\n+\n+from tensorflow.contrib.ignite.python.ops import ignite_op_loader  # pylint: disable=unused-import\n+from tensorflow.contrib.ignite.python.ops import gen_dataset_ops\n+from tensorflow.python.data.ops.dataset_ops import Dataset\n+from tensorflow.python.framework import dtypes\n+from tensorflow.python.framework import ops\n+from tensorflow.python.framework import tensor_shape\n+\n+class Readable():\n+  \"\"\"Readable abstract class that exposes methods to do reading-related\n+     operations.\n+  \"\"\"\n+\n+  @abc.abstractmethod\n+  def __init__(self):\n+    pass\n+\n+  def read_byte(self):\n+    \"\"\"Reads and returnes byte.\"\"\"\n+    return self.__read(\"b\", 1)\n+\n+  def read_short(self):\n+    \"\"\"Reads and returns short (2 bytes, little-endian).\"\"\"\n+    return self.__read(\"h\", 2)\n+\n+  def read_int(self):\n+    \"\"\"Reads and returns int (4 bytes, little-endian).\"\"\"\n+    return self.__read(\"i\", 4)\n+\n+  def read_long(self):\n+    \"\"\"Reads and returns long (8 bytes, little-endian).\"\"\"\n+    return self.__read(\"q\", 8)\n+\n+  def skip(self, length):\n+    \"\"\"Skips the specified number of bytes.\"\"\"\n+    self.read_data(length)\n+\n+  @abc.abstractmethod\n+  def read_data(self, length):\n+    \"\"\"Reads the specified number of bytes and returns them as a buffer.\"\"\"\n+    return None\n+\n+  def __read(self, data_type, length):\n+    \"\"\"Reads, unpacks and returns specified type (little-endian).\"\"\"\n+    data_buffer = self.read_data(length)\n+    return struct.unpack(\"<\" + data_type, data_buffer)[0]\n+\n+class DataBuffer(Readable):\n+  \"\"\"DataBuffer class that exposes methods to read data from a byte buffer.\"\"\"\n+\n+  def __init__(self, data_buffer):\n+    \"\"\"Constructs a new instance of DataBuffer based on the specified byte\n+       buffer.\n+\n+    Args:\n+      buffer: Buffer to be read.\n+    \"\"\"\n+    Readable.__init__(self)\n+    self.buffer = data_buffer\n+    self.ptr = 0\n+\n+  def read_data(self, length):\n+    \"\"\"Reads the specified number of bytes and returns them as a buffer.\"\"\"\n+    data_buffer = self.buffer[self.ptr:][:length]\n+    self.ptr += length\n+    return data_buffer\n+\n+class TcpClient(Readable):\n+  \"\"\"TcpClient class that exposes methods to read data from a socket.\"\"\"\n+\n+  def __init__(self, host, port, certfile=None, keyfile=None, password=None):\n+    \"\"\"Constructs a new instance of TcpClient based on the specified host\n+       and port.\n+\n+    Args:\n+      host: Host to be connected.\n+      port: Port to be connected.\n+      certfile: File in PEM format containing the certificate as well as any\n+        number of CA certificates needed to establish the certificate\u2019s\n+        authenticity.\n+      keyfile: File containing the private key (otherwise the private key\n+        will be taken from certfile as well).\n+      password: Password to be used if the private key is encrypted and a\n+        password is necessary.\n+    \"\"\"\n+    Readable.__init__(self)\n+    self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n+\n+    if certfile is not None:\n+      context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n+      context.load_cert_chain(certfile, keyfile, password)\n+      self.sock = context.wrap_socket(self.sock)\n+    else:\n+      if keyfile is not None:\n+        raise Exception(\"SSL is disabled, keyfile must not be specified \\\n+          (to enable SSL specify certfile)\")\n+      if password is not None:\n+        raise Exception(\"SSL is disabled, password must not be specified \\\n+          (to enable SSL specify certfile)\")\n+\n+    self.host = host\n+    self.port = port\n+\n+  def __enter__(self):\n+    \"\"\"Connects to host and port specified in the constructor.\"\"\"\n+    self.sock.connect((self.host, self.port))\n+    return self\n+\n+  def __exit__(self, t, v, traceback):\n+    \"\"\"Disconnects the socket.\"\"\"\n+    self.sock.close()\n+\n+  def write_byte(self, v):\n+    \"\"\"Writes the specified byte.\"\"\"\n+    self.__write(v, \"b\")\n+\n+  def write_short(self, v):\n+    \"\"\"Writes the specified short (2 bytes, little-endian).\"\"\"\n+    self.__write(v, \"h\")\n+\n+  def write_int(self, v):\n+    \"\"\"Writes the specified short (4 bytes, little-endian).\"\"\"\n+    self.__write(v, \"i\")\n+\n+  def write_long(self, v):\n+    \"\"\"Writes the specified int (8 bytes, little-endian).\"\"\"\n+    self.__write(v, \"q\")\n+\n+  def write_string(self, v):\n+    \"\"\"Writes the specified string.\"\"\"\n+    self.sock.sendall(v.encode(\"UTF-8\"))\n+\n+  def read_data(self, length):\n+    \"\"\"Reads the specified number of bytes and returns them as a buffer.\"\"\"\n+    data_buffer = None\n+    rem = length\n+    while rem > 0:\n+      buf = self.sock.recv(rem)\n+      rem = rem - len(buf)\n+      if data_buffer is None:\n+        data_buffer = buf\n+      else:\n+        data_buffer += buf\n+    return data_buffer\n+\n+  def __write(self, value, data_type):\n+    \"\"\"Packs and writes data using the specified type (little-endian).\"\"\"\n+    data_buffer = struct.pack(\"<\" + data_type, value)\n+    self.sock.sendall(data_buffer)\n+\n+class BinaryType():\n+  \"\"\"BinaryType class that encapsulated type id, type name and fields.\"\"\"\n+\n+  def __init__(self, type_id, type_name, fields):\n+    \"\"\"Constructs a new instance of BinaryType.\"\"\"\n+    self.type_id = type_id\n+    self.type_name = type_name\n+    self.fields = fields\n+\n+class BinaryField():\n+  \"\"\"BinaryField class that encapsulated field name, type id and field id.\"\"\"\n+\n+  def __init__(self, field_name, type_id, field_id):\n+    \"\"\"Constructs a new instance of BinaryField.\"\"\"\n+    self.field_name = field_name\n+    self.type_id = type_id\n+    self.field_id = field_id\n+\n+# Binary types defined in Apache Ignite Thin client and supported by\n+# TensorFlow on Apache Ignite, see\n+# https://apacheignite.readme.io/v2.6/docs/binary-client-protocol.\n+types = {\n+    1: (dtypes.uint8, False),\n+    2: (dtypes.int16, False),\n+    3: (dtypes.int32, False),\n+    4: (dtypes.int64, False),\n+    5: (dtypes.float32, False),\n+    6: (dtypes.float64, False),\n+    7: (dtypes.uint16, False),\n+    8: (dtypes.bool, False),\n+    9: (dtypes.string, False),\n+    12: (dtypes.uint8, True),\n+    13: (dtypes.int16, True),\n+    14: (dtypes.int32, True),\n+    15: (dtypes.int64, True),\n+    16: (dtypes.float32, True),\n+    17: (dtypes.float64, True),\n+    18: (dtypes.uint16, True),\n+    19: (dtypes.bool, True),\n+    20: (dtypes.string, True)\n+}\n+\n+class TypeTreeNode():\n+  \"\"\"TypeTreeNode class exposes methods to format object tree structure\n+     data.\n+  \"\"\"\n+  def __init__(self, name, type_id, fields=None, permutation=None):\n+    \"\"\"Constructs a new instance of TypeTreeNode.\n+\n+    Args:\n+      name: Name of the object tree node.\n+      type_id: Type id of the object tree node.\n+      fields: List of fields (children of the object tree node).\n+      permutation: Permutation that should be applied to order object children.\n+    \"\"\"\n+    self.name = name\n+    self.type_id = type_id\n+    self.fields = fields\n+    self.permutation = permutation\n+\n+  def to_output_classes(self):\n+    \"\"\"Formats the tree object the way required in 'output_classes' property of\n+       dataset.\n+    \"\"\"\n+    if self.fields is None:\n+      return ops.Tensor\n+    output_classes = {}\n+    for field in self.fields:\n+      output_classes[field.name] = field.to_output_classes()\n+    return output_classes\n+\n+  def to_output_shapes(self):\n+    \"\"\"Formats the tree object the way required in 'output_shapes' property of\n+       dataset.\n+    \"\"\"\n+    if self.fields is None:\n+      object_type = types[self.type_id]\n+      if object_type is not None:\n+        is_array = object_type[1]\n+        if is_array:\n+          return tensor_shape.TensorShape([None])\n+        return tensor_shape.TensorShape([])\n+      raise Exception(\"Unsupported type [type_id=%d]\" % self.type_id)\n+    output_shapes = {}\n+    for field in self.fields:\n+      output_shapes[field.name] = field.to_output_shapes()\n+    return output_shapes\n+\n+  def to_output_types(self):\n+    \"\"\"Formats the tree object the way required in 'output_types' property of\n+       dataset.\n+    \"\"\"\n+    if self.fields is None:\n+      object_type = types[self.type_id]\n+      if object_type is not None:\n+        return object_type[0]\n+      raise Exception(\"Unsupported type [type_id=%d]\" % self.type_id)\n+    else:\n+      output_types = {}\n+      for field in self.fields:\n+        output_types[field.name] = field.to_output_types()\n+      return output_types\n+\n+  def to_flat(self):\n+    \"\"\"Returns a list of leaf node types.\"\"\"\n+    return self.to_flat_rec([])\n+\n+  def to_permutation(self):\n+    \"\"\"Returns a permutation that should be applied to order object leafs.\"\"\"", "path": "tensorflow/contrib/ignite/python/ops/ignite_dataset_ops.py", "position": null, "original_position": 283, "commit_id": "90c68770467701a23d23a85c5d769f6f4fa39f0f", "original_commit_id": "0b6654bc223f4f3807209043dc34ccb07b55474e", "user": {"login": "dmitrievanthony", "id": 1028969, "node_id": "MDQ6VXNlcjEwMjg5Njk=", "avatar_url": "https://avatars3.githubusercontent.com/u/1028969?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dmitrievanthony", "html_url": "https://github.com/dmitrievanthony", "followers_url": "https://api.github.com/users/dmitrievanthony/followers", "following_url": "https://api.github.com/users/dmitrievanthony/following{/other_user}", "gists_url": "https://api.github.com/users/dmitrievanthony/gists{/gist_id}", "starred_url": "https://api.github.com/users/dmitrievanthony/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dmitrievanthony/subscriptions", "organizations_url": "https://api.github.com/users/dmitrievanthony/orgs", "repos_url": "https://api.github.com/users/dmitrievanthony/repos", "events_url": "https://api.github.com/users/dmitrievanthony/events{/privacy}", "received_events_url": "https://api.github.com/users/dmitrievanthony/received_events", "type": "User", "site_admin": false}, "body": "Thanks, fixed.", "created_at": "2018-09-12T18:27:01Z", "updated_at": "2018-09-24T09:16:00Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/22210#discussion_r217140937", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/22210", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/217140937"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/22210#discussion_r217140937"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/22210"}}, "body_html": "<p>Thanks, fixed.</p>", "body_text": "Thanks, fixed.", "in_reply_to_id": 216719055}