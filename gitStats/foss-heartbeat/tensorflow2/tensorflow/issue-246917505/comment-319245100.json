{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/319245100", "html_url": "https://github.com/tensorflow/tensorflow/issues/11923#issuecomment-319245100", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11923", "id": 319245100, "node_id": "MDEyOklzc3VlQ29tbWVudDMxOTI0NTEwMA==", "user": {"login": "currivan", "id": 10430506, "node_id": "MDQ6VXNlcjEwNDMwNTA2", "avatar_url": "https://avatars3.githubusercontent.com/u/10430506?v=4", "gravatar_id": "", "url": "https://api.github.com/users/currivan", "html_url": "https://github.com/currivan", "followers_url": "https://api.github.com/users/currivan/followers", "following_url": "https://api.github.com/users/currivan/following{/other_user}", "gists_url": "https://api.github.com/users/currivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/currivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/currivan/subscriptions", "organizations_url": "https://api.github.com/users/currivan/orgs", "repos_url": "https://api.github.com/users/currivan/repos", "events_url": "https://api.github.com/users/currivan/events{/privacy}", "received_events_url": "https://api.github.com/users/currivan/received_events", "type": "User", "site_admin": false}, "created_at": "2017-08-01T01:52:20Z", "updated_at": "2017-08-01T03:06:18Z", "author_association": "NONE", "body_html": "<p>Tracked the issue down to memory reuse. The keys for the <code>_DECORATED_OPS</code> dict in arg_scope.py are <code>str(func)</code>, which are based on the function's address. When memory is reused and a new function has the same address as a garbage collected one, the old one still appears in the decorator dictionary.</p>\n<p>Simple fix is to always update the dict for the latest call to the decorator:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">def</span> <span class=\"pl-en\">_add_op</span>(<span class=\"pl-smi\">op</span>):\n    key_op <span class=\"pl-k\">=</span> _key_op(op)\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span>if key_op not in _DECORATED_OPS:</span>\n    <span class=\"pl-c1\">_DECORATED_OPS</span>[key_op] <span class=\"pl-k\">=</span> _kwarg_names(op)</pre></div>", "body_text": "Tracked the issue down to memory reuse. The keys for the _DECORATED_OPS dict in arg_scope.py are str(func), which are based on the function's address. When memory is reused and a new function has the same address as a garbage collected one, the old one still appears in the decorator dictionary.\nSimple fix is to always update the dict for the latest call to the decorator:\ndef _add_op(op):\n    key_op = _key_op(op)\n    #if key_op not in _DECORATED_OPS:\n    _DECORATED_OPS[key_op] = _kwarg_names(op)", "body": "Tracked the issue down to memory reuse. The keys for the `_DECORATED_OPS` dict in arg_scope.py are `str(func)`, which are based on the function's address. When memory is reused and a new function has the same address as a garbage collected one, the old one still appears in the decorator dictionary.\r\n\r\nSimple fix is to always update the dict for the latest call to the decorator:\r\n\r\n```python\r\ndef _add_op(op):\r\n    key_op = _key_op(op)\r\n    #if key_op not in _DECORATED_OPS:\r\n    _DECORATED_OPS[key_op] = _kwarg_names(op)\r\n```\r\n"}