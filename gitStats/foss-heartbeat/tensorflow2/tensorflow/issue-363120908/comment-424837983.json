{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/424837983", "html_url": "https://github.com/tensorflow/tensorflow/issues/22481#issuecomment-424837983", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/22481", "id": 424837983, "node_id": "MDEyOklzc3VlQ29tbWVudDQyNDgzNzk4Mw==", "user": {"login": "axch", "id": 233710, "node_id": "MDQ6VXNlcjIzMzcxMA==", "avatar_url": "https://avatars3.githubusercontent.com/u/233710?v=4", "gravatar_id": "", "url": "https://api.github.com/users/axch", "html_url": "https://github.com/axch", "followers_url": "https://api.github.com/users/axch/followers", "following_url": "https://api.github.com/users/axch/following{/other_user}", "gists_url": "https://api.github.com/users/axch/gists{/gist_id}", "starred_url": "https://api.github.com/users/axch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/axch/subscriptions", "organizations_url": "https://api.github.com/users/axch/orgs", "repos_url": "https://api.github.com/users/axch/repos", "events_url": "https://api.github.com/users/axch/events{/privacy}", "received_events_url": "https://api.github.com/users/axch/received_events", "type": "User", "site_admin": false}, "created_at": "2018-09-26T19:19:27Z", "updated_at": "2018-09-26T19:19:27Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Just to make sure we are both on the same page, I am not talking about masking input NaNs (which, I agree, would be weirdly specific) but about propagating them.  The interface I think we should implement is the same as numpy:</p>\n<pre><code>&gt;&gt;&gt; np.percentile([float(\"nan\"), 1.0], 50)\nnan\n&gt;&gt;&gt; np.percentile([1.0, float(\"nan\")], 50)\nnan\n&gt;&gt;&gt; np.percentile([1.0, 2.0, 3.0, 4.0, float(\"nan\")], 20)\nnan\n&gt;&gt;&gt; np.percentile([1.0, 2.0, 3.0, 4.0], 20)\n1.6000000000000001\n&gt;&gt;&gt; np.percentile([1.0, float(\"nan\"), 2.0, 3.0, 4.0], 20)\nnan\n</code></pre>\n<p>This can, of course, be done in user-land:</p>\n<pre><code>def nan_propagating_percentile(x, q, axis):\n  nan_batch_members = tf.reduce_any(tf.isnan(x), axis=axis)\n  return tf.where(\n    nan_batch_members,\n    np.nan * tf.ones(tf.shape(nan_batch_members), dtype=x.dtype),\n    percentile(x, q, axis=axis))\n</code></pre>\n<p>but that seems like something of an imposition.  <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=1137078\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/jvdillon\">@jvdillon</a>: How do you value the cost of <code>is_nan</code> + <code>reduce_any</code> + <code>where</code> (for an operation that already includes a sort and slice) in comparison with the benefit of API compatibility, and of avoiding giving non-<code>NaN</code> answers on <code>NaN</code> inputs?</p>", "body_text": "Just to make sure we are both on the same page, I am not talking about masking input NaNs (which, I agree, would be weirdly specific) but about propagating them.  The interface I think we should implement is the same as numpy:\n>>> np.percentile([float(\"nan\"), 1.0], 50)\nnan\n>>> np.percentile([1.0, float(\"nan\")], 50)\nnan\n>>> np.percentile([1.0, 2.0, 3.0, 4.0, float(\"nan\")], 20)\nnan\n>>> np.percentile([1.0, 2.0, 3.0, 4.0], 20)\n1.6000000000000001\n>>> np.percentile([1.0, float(\"nan\"), 2.0, 3.0, 4.0], 20)\nnan\n\nThis can, of course, be done in user-land:\ndef nan_propagating_percentile(x, q, axis):\n  nan_batch_members = tf.reduce_any(tf.isnan(x), axis=axis)\n  return tf.where(\n    nan_batch_members,\n    np.nan * tf.ones(tf.shape(nan_batch_members), dtype=x.dtype),\n    percentile(x, q, axis=axis))\n\nbut that seems like something of an imposition.  @jvdillon: How do you value the cost of is_nan + reduce_any + where (for an operation that already includes a sort and slice) in comparison with the benefit of API compatibility, and of avoiding giving non-NaN answers on NaN inputs?", "body": "Just to make sure we are both on the same page, I am not talking about masking input NaNs (which, I agree, would be weirdly specific) but about propagating them.  The interface I think we should implement is the same as numpy:\r\n```\r\n>>> np.percentile([float(\"nan\"), 1.0], 50)\r\nnan\r\n>>> np.percentile([1.0, float(\"nan\")], 50)\r\nnan\r\n>>> np.percentile([1.0, 2.0, 3.0, 4.0, float(\"nan\")], 20)\r\nnan\r\n>>> np.percentile([1.0, 2.0, 3.0, 4.0], 20)\r\n1.6000000000000001\r\n>>> np.percentile([1.0, float(\"nan\"), 2.0, 3.0, 4.0], 20)\r\nnan\r\n```\r\n\r\nThis can, of course, be done in user-land:\r\n```\r\ndef nan_propagating_percentile(x, q, axis):\r\n  nan_batch_members = tf.reduce_any(tf.isnan(x), axis=axis)\r\n  return tf.where(\r\n    nan_batch_members,\r\n    np.nan * tf.ones(tf.shape(nan_batch_members), dtype=x.dtype),\r\n    percentile(x, q, axis=axis))\r\n```\r\n\r\nbut that seems like something of an imposition.  @jvdillon: How do you value the cost of `is_nan` + `reduce_any` + `where` (for an operation that already includes a sort and slice) in comparison with the benefit of API compatibility, and of avoiding giving non-`NaN` answers on `NaN` inputs?"}