{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/6414", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/6414/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/6414/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/6414/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/6414", "id": 196611943, "node_id": "MDU6SXNzdWUxOTY2MTE5NDM=", "number": 6414, "title": "Feature suggestion: Loss Normalization", "user": {"login": "Hvass-Labs", "id": 13588114, "node_id": "MDQ6VXNlcjEzNTg4MTE0", "avatar_url": "https://avatars2.githubusercontent.com/u/13588114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Hvass-Labs", "html_url": "https://github.com/Hvass-Labs", "followers_url": "https://api.github.com/users/Hvass-Labs/followers", "following_url": "https://api.github.com/users/Hvass-Labs/following{/other_user}", "gists_url": "https://api.github.com/users/Hvass-Labs/gists{/gist_id}", "starred_url": "https://api.github.com/users/Hvass-Labs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Hvass-Labs/subscriptions", "organizations_url": "https://api.github.com/users/Hvass-Labs/orgs", "repos_url": "https://api.github.com/users/Hvass-Labs/repos", "events_url": "https://api.github.com/users/Hvass-Labs/events{/privacy}", "received_events_url": "https://api.github.com/users/Hvass-Labs/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": {"login": "martinwicke", "id": 577277, "node_id": "MDQ6VXNlcjU3NzI3Nw==", "avatar_url": "https://avatars2.githubusercontent.com/u/577277?v=4", "gravatar_id": "", "url": "https://api.github.com/users/martinwicke", "html_url": "https://github.com/martinwicke", "followers_url": "https://api.github.com/users/martinwicke/followers", "following_url": "https://api.github.com/users/martinwicke/following{/other_user}", "gists_url": "https://api.github.com/users/martinwicke/gists{/gist_id}", "starred_url": "https://api.github.com/users/martinwicke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/martinwicke/subscriptions", "organizations_url": "https://api.github.com/users/martinwicke/orgs", "repos_url": "https://api.github.com/users/martinwicke/repos", "events_url": "https://api.github.com/users/martinwicke/events{/privacy}", "received_events_url": "https://api.github.com/users/martinwicke/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "martinwicke", "id": 577277, "node_id": "MDQ6VXNlcjU3NzI3Nw==", "avatar_url": "https://avatars2.githubusercontent.com/u/577277?v=4", "gravatar_id": "", "url": "https://api.github.com/users/martinwicke", "html_url": "https://github.com/martinwicke", "followers_url": "https://api.github.com/users/martinwicke/followers", "following_url": "https://api.github.com/users/martinwicke/following{/other_user}", "gists_url": "https://api.github.com/users/martinwicke/gists{/gist_id}", "starred_url": "https://api.github.com/users/martinwicke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/martinwicke/subscriptions", "organizations_url": "https://api.github.com/users/martinwicke/orgs", "repos_url": "https://api.github.com/users/martinwicke/repos", "events_url": "https://api.github.com/users/martinwicke/events{/privacy}", "received_events_url": "https://api.github.com/users/martinwicke/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 4, "created_at": "2016-12-20T08:21:36Z", "updated_at": "2017-03-13T14:11:45Z", "closed_at": "2017-03-13T14:11:44Z", "author_association": "CONTRIBUTOR", "body_html": "<p>I would like to suggest the following feature be added to TensorFlow. As far as I know, the feature does not exist in TensorFlow. There are some issues that must be discussed and solved before making the pull-request.</p>\n<h3>Motivation</h3>\n<p>When optimizing multiple objectives in TensorFlow, the combined loss-function is typically a weighted sum of the individual loss-functions. Finding the weights for the loss-functions is done experimentally as the weights may depend on a number of factors.</p>\n<p>For example, in Style Transfer we want to combine two images so the result has the 'style' of one input image and the 'content' of another image. We do this by creating two loss-functions that we will optimize together. The problem is that when we choose different layers in the neural network for the loss-functions, then their magnitudes may change dramatically, so the weights for the loss-functions will also need to be modified.</p>\n<p>The solution I came up with in my recent tutorial on Style Transfer, is to automatically normalize each loss-function so we can define the weights independently of any given choice of layers:</p>\n<p><a href=\"https://github.com/Hvass-Labs/TensorFlow-Tutorials/blob/master/15_Style_Transfer.ipynb\">https://github.com/Hvass-Labs/TensorFlow-Tutorials/blob/master/15_Style_Transfer.ipynb</a></p>\n<p>The solution I propose below is a bit more elegant than in the tutorial, and I think it can be made even better.</p>\n<h3>Overall Idea</h3>\n<p>The idea is to evaluate each loss-function to its scalar-value and then divide the loss-function with this scalar-value. This creates a new node in the TensorFlow graph which holds the original loss-function divided by some scalar-value. The new node in the graph is still a mathematical function that can be differentiated, and for the given input it evaluates to the value 1. We do this normalization for each of the loss-functions so they all evaluate to 1. Then we can define loss-weights more easily and independently of e.g. the exact choice of layers in the Style Transfer algorithm.</p>\n<h3>Code</h3>\n<p>In terms of pseudo-code, what we want to do is simply:</p>\n<pre><code>def loss_normalize(loss):\n    return loss / value_of(loss)\n</code></pre>\n<p>But if we merely return <code>loss/loss</code> then it does not calculate the value of <code>loss</code> for the denominator, instead we get a mathematical function divided by itself. I also tried <code>tf.identity(loss)</code> but that did not work either. Neither does type-casting.</p>\n<p>So we need a small hack. We create a scalar float-variable and assign the loss-value to it. When the variable is used in an assignment like this, then it is not necessary to initialize it first. This works:</p>\n<pre><code>def loss_normalize(loss):\n    loss_value = tf.Variable(1.0)\n    \n    loss_normalized = loss / loss_value.assign(loss)\n\n    return loss_normalized\n</code></pre>\n<h3>Usage</h3>\n<p>Imagine that we have defined two loss functions, e.g.:</p>\n<pre><code>style_loss = ...\ncontent_loss = ...\n</code></pre>\n<p>Normally we would have some strange weights that might need to be changed if we choose different layers in the network for the loss-functions. These weights do not indicate how we are actually weighting the loss-functions for the style and content, for example:</p>\n<pre><code>combined_loss = 1e-10 * style_loss + 1e-3 * content_loss\n</code></pre>\n<p>If instead we normalize the loss-functions first, then we can define the weights more intuitively. For example, we might want 90% of the combined-loss to be for the style and only 10% for the content. We would do it like this:</p>\n<pre><code>combined_loss = 0.9 * loss_normalize(style_loss) + \\\n                0.1 * loss_normalize(content_loss)\n</code></pre>\n<p>Even if you change the layers used in the two loss-functions, we do not need to change our weights. This may be useful in many other applications than just Style Transfer.</p>\n<h3>Issues</h3>\n<p>Before I make a pull-request there are several issues that must be discussed and solved.</p>\n<ol>\n<li>\n<p>The hack using a variable to get the loss-value is not very elegant. I wonder if it would be possible to add something like <code>value_of(loss)</code> to TensorFlow? I guess it would be a bit similar to <code>loss.eval()</code> except that we don't want to run the session.</p>\n</li>\n<li>\n<p>Division by zero should be handled somehow. If the loss-function is inherently non-negative then we can add a small number such as 1e-10 to the denominator. But this would not be bomb-proof for loss-functions that can take on negative values. Is there a good standard solution for this in TensorFlow?</p>\n</li>\n<li>\n<p>It might be a better design to make <code>loss_normalize()</code> take a list of loss-functions so we don't have to wrap all of the loss-functions individually. What do you think? Is there an elegant way of implementing this in TensorFlow, or do I have to resort to Python's list comprehension?</p>\n</li>\n<li>\n<p>It might be useful to have a placeholder bool that decides whether or not to update the normalization. This would allow us to normalize the loss-functions only in the first iteration, or we could normalize every n'th iteration. The reason this might be useful, is that the optimizer might get trapped in a local optimum if we normalize the loss-functions in every iteration. I experimented a bit with <code>tf.placeholder_with_default()</code> and <code>tf.cond()</code> but it gave me some strange errors about tensor-shapes. Any ideas on how to make an elegant implementation for this?</p>\n</li>\n</ol>", "body_text": "I would like to suggest the following feature be added to TensorFlow. As far as I know, the feature does not exist in TensorFlow. There are some issues that must be discussed and solved before making the pull-request.\nMotivation\nWhen optimizing multiple objectives in TensorFlow, the combined loss-function is typically a weighted sum of the individual loss-functions. Finding the weights for the loss-functions is done experimentally as the weights may depend on a number of factors.\nFor example, in Style Transfer we want to combine two images so the result has the 'style' of one input image and the 'content' of another image. We do this by creating two loss-functions that we will optimize together. The problem is that when we choose different layers in the neural network for the loss-functions, then their magnitudes may change dramatically, so the weights for the loss-functions will also need to be modified.\nThe solution I came up with in my recent tutorial on Style Transfer, is to automatically normalize each loss-function so we can define the weights independently of any given choice of layers:\nhttps://github.com/Hvass-Labs/TensorFlow-Tutorials/blob/master/15_Style_Transfer.ipynb\nThe solution I propose below is a bit more elegant than in the tutorial, and I think it can be made even better.\nOverall Idea\nThe idea is to evaluate each loss-function to its scalar-value and then divide the loss-function with this scalar-value. This creates a new node in the TensorFlow graph which holds the original loss-function divided by some scalar-value. The new node in the graph is still a mathematical function that can be differentiated, and for the given input it evaluates to the value 1. We do this normalization for each of the loss-functions so they all evaluate to 1. Then we can define loss-weights more easily and independently of e.g. the exact choice of layers in the Style Transfer algorithm.\nCode\nIn terms of pseudo-code, what we want to do is simply:\ndef loss_normalize(loss):\n    return loss / value_of(loss)\n\nBut if we merely return loss/loss then it does not calculate the value of loss for the denominator, instead we get a mathematical function divided by itself. I also tried tf.identity(loss) but that did not work either. Neither does type-casting.\nSo we need a small hack. We create a scalar float-variable and assign the loss-value to it. When the variable is used in an assignment like this, then it is not necessary to initialize it first. This works:\ndef loss_normalize(loss):\n    loss_value = tf.Variable(1.0)\n    \n    loss_normalized = loss / loss_value.assign(loss)\n\n    return loss_normalized\n\nUsage\nImagine that we have defined two loss functions, e.g.:\nstyle_loss = ...\ncontent_loss = ...\n\nNormally we would have some strange weights that might need to be changed if we choose different layers in the network for the loss-functions. These weights do not indicate how we are actually weighting the loss-functions for the style and content, for example:\ncombined_loss = 1e-10 * style_loss + 1e-3 * content_loss\n\nIf instead we normalize the loss-functions first, then we can define the weights more intuitively. For example, we might want 90% of the combined-loss to be for the style and only 10% for the content. We would do it like this:\ncombined_loss = 0.9 * loss_normalize(style_loss) + \\\n                0.1 * loss_normalize(content_loss)\n\nEven if you change the layers used in the two loss-functions, we do not need to change our weights. This may be useful in many other applications than just Style Transfer.\nIssues\nBefore I make a pull-request there are several issues that must be discussed and solved.\n\n\nThe hack using a variable to get the loss-value is not very elegant. I wonder if it would be possible to add something like value_of(loss) to TensorFlow? I guess it would be a bit similar to loss.eval() except that we don't want to run the session.\n\n\nDivision by zero should be handled somehow. If the loss-function is inherently non-negative then we can add a small number such as 1e-10 to the denominator. But this would not be bomb-proof for loss-functions that can take on negative values. Is there a good standard solution for this in TensorFlow?\n\n\nIt might be a better design to make loss_normalize() take a list of loss-functions so we don't have to wrap all of the loss-functions individually. What do you think? Is there an elegant way of implementing this in TensorFlow, or do I have to resort to Python's list comprehension?\n\n\nIt might be useful to have a placeholder bool that decides whether or not to update the normalization. This would allow us to normalize the loss-functions only in the first iteration, or we could normalize every n'th iteration. The reason this might be useful, is that the optimizer might get trapped in a local optimum if we normalize the loss-functions in every iteration. I experimented a bit with tf.placeholder_with_default() and tf.cond() but it gave me some strange errors about tensor-shapes. Any ideas on how to make an elegant implementation for this?", "body": "I would like to suggest the following feature be added to TensorFlow. As far as I know, the feature does not exist in TensorFlow. There are some issues that must be discussed and solved before making the pull-request.\r\n\r\n### Motivation\r\n\r\nWhen optimizing multiple objectives in TensorFlow, the combined loss-function is typically a weighted sum of the individual loss-functions. Finding the weights for the loss-functions is done experimentally as the weights may depend on a number of factors.\r\n\r\nFor example, in Style Transfer we want to combine two images so the result has the 'style' of one input image and the 'content' of another image. We do this by creating two loss-functions that we will optimize together. The problem is that when we choose different layers in the neural network for the loss-functions, then their magnitudes may change dramatically, so the weights for the loss-functions will also need to be modified.\r\n\r\nThe solution I came up with in my recent tutorial on Style Transfer, is to automatically normalize each loss-function so we can define the weights independently of any given choice of layers:\r\n\r\nhttps://github.com/Hvass-Labs/TensorFlow-Tutorials/blob/master/15_Style_Transfer.ipynb\r\n\r\nThe solution I propose below is a bit more elegant than in the tutorial, and I think it can be made even better.\r\n\r\n### Overall Idea\r\n\r\nThe idea is to evaluate each loss-function to its scalar-value and then divide the loss-function with this scalar-value. This creates a new node in the TensorFlow graph which holds the original loss-function divided by some scalar-value. The new node in the graph is still a mathematical function that can be differentiated, and for the given input it evaluates to the value 1. We do this normalization for each of the loss-functions so they all evaluate to 1. Then we can define loss-weights more easily and independently of e.g. the exact choice of layers in the Style Transfer algorithm.\r\n\r\n### Code\r\n\r\nIn terms of pseudo-code, what we want to do is simply:\r\n\r\n    def loss_normalize(loss):\r\n        return loss / value_of(loss)\r\n\r\nBut if we merely return `loss/loss` then it does not calculate the value of `loss` for the denominator, instead we get a mathematical function divided by itself. I also tried `tf.identity(loss)` but that did not work either. Neither does type-casting.\r\n\r\nSo we need a small hack. We create a scalar float-variable and assign the loss-value to it. When the variable is used in an assignment like this, then it is not necessary to initialize it first. This works:\r\n\r\n    def loss_normalize(loss):\r\n        loss_value = tf.Variable(1.0)\r\n        \r\n        loss_normalized = loss / loss_value.assign(loss)\r\n\r\n        return loss_normalized\r\n\r\n### Usage\r\n\r\nImagine that we have defined two loss functions, e.g.:\r\n\r\n    style_loss = ...\r\n    content_loss = ...\r\n\r\nNormally we would have some strange weights that might need to be changed if we choose different layers in the network for the loss-functions. These weights do not indicate how we are actually weighting the loss-functions for the style and content, for example:\r\n\r\n    combined_loss = 1e-10 * style_loss + 1e-3 * content_loss\r\n\r\nIf instead we normalize the loss-functions first, then we can define the weights more intuitively. For example, we might want 90% of the combined-loss to be for the style and only 10% for the content. We would do it like this:\r\n\r\n    combined_loss = 0.9 * loss_normalize(style_loss) + \\\r\n                    0.1 * loss_normalize(content_loss)\r\n\r\nEven if you change the layers used in the two loss-functions, we do not need to change our weights. This may be useful in many other applications than just Style Transfer.\r\n\r\n### Issues\r\n\r\nBefore I make a pull-request there are several issues that must be discussed and solved.\r\n\r\n1) The hack using a variable to get the loss-value is not very elegant. I wonder if it would be possible to add something like `value_of(loss)` to TensorFlow? I guess it would be a bit similar to `loss.eval()` except that we don't want to run the session.\r\n\r\n2) Division by zero should be handled somehow. If the loss-function is inherently non-negative then we can add a small number such as 1e-10 to the denominator. But this would not be bomb-proof for loss-functions that can take on negative values. Is there a good standard solution for this in TensorFlow?\r\n\r\n3) It might be a better design to make `loss_normalize()` take a list of loss-functions so we don't have to wrap all of the loss-functions individually. What do you think? Is there an elegant way of implementing this in TensorFlow, or do I have to resort to Python's list comprehension?\r\n\r\n4) It might be useful to have a placeholder bool that decides whether or not to update the normalization. This would allow us to normalize the loss-functions only in the first iteration, or we could normalize every n'th iteration. The reason this might be useful, is that the optimizer might get trapped in a local optimum if we normalize the loss-functions in every iteration. I experimented a bit with `tf.placeholder_with_default()` and `tf.cond()` but it gave me some strange errors about tensor-shapes. Any ideas on how to make an elegant implementation for this?\r\n"}