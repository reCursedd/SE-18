{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/275903996", "html_url": "https://github.com/tensorflow/tensorflow/issues/2296#issuecomment-275903996", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2296", "id": 275903996, "node_id": "MDEyOklzc3VlQ29tbWVudDI3NTkwMzk5Ng==", "user": {"login": "rizasif", "id": 8410351, "node_id": "MDQ6VXNlcjg0MTAzNTE=", "avatar_url": "https://avatars1.githubusercontent.com/u/8410351?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rizasif", "html_url": "https://github.com/rizasif", "followers_url": "https://api.github.com/users/rizasif/followers", "following_url": "https://api.github.com/users/rizasif/following{/other_user}", "gists_url": "https://api.github.com/users/rizasif/gists{/gist_id}", "starred_url": "https://api.github.com/users/rizasif/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rizasif/subscriptions", "organizations_url": "https://api.github.com/users/rizasif/orgs", "repos_url": "https://api.github.com/users/rizasif/repos", "events_url": "https://api.github.com/users/rizasif/events{/privacy}", "received_events_url": "https://api.github.com/users/rizasif/received_events", "type": "User", "site_admin": false}, "created_at": "2017-01-29T09:53:25Z", "updated_at": "2017-01-29T09:54:10Z", "author_association": "CONTRIBUTOR", "body_html": "<p>So I placed some checks in the retrain.py file and its working fine now. From What I understand this is not because of a faulty image file but a faulty bottleneck file. As soon as the error was caught by my checks, the script started creating new bottleneck files instead of checking the cached ones.</p>\n<p>In other words, if an incomplete bottleneck file exists in the cache then this error arises  (this file can be produced because of sudden system shutdown).</p>\n<p>Please add some checks to the code. I'll paste my solution below:</p>\n<pre><code>#retrain.py\n...\ndef get_or_create_bottleneck(sess, image_lists, label_name, index, image_dir,\n                             category, bottleneck_dir, jpeg_data_tensor,\n                             bottleneck_tensor):\n...\n  with open(bottleneck_path, 'r') as bottleneck_file:\n    bottleneck_string = bottleneck_file.read()\n  \n  #avoiding non float values\n    try:\n      bottleneck_values = [float(x) for x in bottleneck_string.split(',')]\n    except:\n      print(\"Invalid float found, sending None instead\")\n      return None\n\n  return bottleneck_values\n\n...\ndef cache_bottlenecks(sess, image_lists, image_dir, bottleneck_dir,\n                      jpeg_data_tensor, bottleneck_tensor):\n...\n      for index, unused_base_name in enumerate(category_list):\n        bNeck = get_or_create_bottleneck(sess, image_lists, label_name, index,\n                                 image_dir, category, bottleneck_dir,\n                                 jpeg_data_tensor, bottleneck_tensor)\n        if bNeck is not None:\n          how_many_bottlenecks += 1\n          if how_many_bottlenecks % 100 == 0:\n            print(str(how_many_bottlenecks) + ' bottleneck files created.')\n\n...\ndef get_random_cached_bottlenecks(sess, image_lists, how_many, category,\n                                  bottleneck_dir, image_dir, jpeg_data_tensor,\n                                  bottleneck_tensor):\n...\n  for unused_i in range(how_many):\n    label_index = random.randrange(class_count)\n    label_name = list(image_lists.keys())[label_index]\n    image_index = random.randrange(MAX_NUM_IMAGES_PER_CLASS + 1)\n    bottleneck = get_or_create_bottleneck(sess, image_lists, label_name,\n                                          image_index, image_dir, category,\n                                          bottleneck_dir, jpeg_data_tensor,\n                                          bottleneck_tensor)\n    if bottleneck is not None:\n      ground_truth = np.zeros(class_count, dtype=np.float32)\n      ground_truth[label_index] = 1.0\n      bottlenecks.append(bottleneck)\n      ground_truths.append(ground_truth)\n  return bottlenecks, ground_truths\n\n...\ndef get_random_distorted_bottlenecks(\n    sess, image_lists, how_many, category, image_dir, input_jpeg_tensor,\n    distorted_image, resized_input_tensor, bottleneck_tensor):\n...\n    bottleneck = run_bottleneck_on_image(sess, distorted_image_data,\n                                         resized_input_tensor,\n                                         bottleneck_tensor)\n    if bottleneck is not None:\n      ground_truth = np.zeros(class_count, dtype=np.float32)\n      ground_truth[label_index] = 1.0\n      bottlenecks.append(bottleneck)\n      ground_truths.append(ground_truth)\n  return bottlenecks, ground_truths\n</code></pre>", "body_text": "So I placed some checks in the retrain.py file and its working fine now. From What I understand this is not because of a faulty image file but a faulty bottleneck file. As soon as the error was caught by my checks, the script started creating new bottleneck files instead of checking the cached ones.\nIn other words, if an incomplete bottleneck file exists in the cache then this error arises  (this file can be produced because of sudden system shutdown).\nPlease add some checks to the code. I'll paste my solution below:\n#retrain.py\n...\ndef get_or_create_bottleneck(sess, image_lists, label_name, index, image_dir,\n                             category, bottleneck_dir, jpeg_data_tensor,\n                             bottleneck_tensor):\n...\n  with open(bottleneck_path, 'r') as bottleneck_file:\n    bottleneck_string = bottleneck_file.read()\n  \n  #avoiding non float values\n    try:\n      bottleneck_values = [float(x) for x in bottleneck_string.split(',')]\n    except:\n      print(\"Invalid float found, sending None instead\")\n      return None\n\n  return bottleneck_values\n\n...\ndef cache_bottlenecks(sess, image_lists, image_dir, bottleneck_dir,\n                      jpeg_data_tensor, bottleneck_tensor):\n...\n      for index, unused_base_name in enumerate(category_list):\n        bNeck = get_or_create_bottleneck(sess, image_lists, label_name, index,\n                                 image_dir, category, bottleneck_dir,\n                                 jpeg_data_tensor, bottleneck_tensor)\n        if bNeck is not None:\n          how_many_bottlenecks += 1\n          if how_many_bottlenecks % 100 == 0:\n            print(str(how_many_bottlenecks) + ' bottleneck files created.')\n\n...\ndef get_random_cached_bottlenecks(sess, image_lists, how_many, category,\n                                  bottleneck_dir, image_dir, jpeg_data_tensor,\n                                  bottleneck_tensor):\n...\n  for unused_i in range(how_many):\n    label_index = random.randrange(class_count)\n    label_name = list(image_lists.keys())[label_index]\n    image_index = random.randrange(MAX_NUM_IMAGES_PER_CLASS + 1)\n    bottleneck = get_or_create_bottleneck(sess, image_lists, label_name,\n                                          image_index, image_dir, category,\n                                          bottleneck_dir, jpeg_data_tensor,\n                                          bottleneck_tensor)\n    if bottleneck is not None:\n      ground_truth = np.zeros(class_count, dtype=np.float32)\n      ground_truth[label_index] = 1.0\n      bottlenecks.append(bottleneck)\n      ground_truths.append(ground_truth)\n  return bottlenecks, ground_truths\n\n...\ndef get_random_distorted_bottlenecks(\n    sess, image_lists, how_many, category, image_dir, input_jpeg_tensor,\n    distorted_image, resized_input_tensor, bottleneck_tensor):\n...\n    bottleneck = run_bottleneck_on_image(sess, distorted_image_data,\n                                         resized_input_tensor,\n                                         bottleneck_tensor)\n    if bottleneck is not None:\n      ground_truth = np.zeros(class_count, dtype=np.float32)\n      ground_truth[label_index] = 1.0\n      bottlenecks.append(bottleneck)\n      ground_truths.append(ground_truth)\n  return bottlenecks, ground_truths", "body": "So I placed some checks in the retrain.py file and its working fine now. From What I understand this is not because of a faulty image file but a faulty bottleneck file. As soon as the error was caught by my checks, the script started creating new bottleneck files instead of checking the cached ones. \r\n\r\nIn other words, if an incomplete bottleneck file exists in the cache then this error arises  (this file can be produced because of sudden system shutdown).\r\n\r\nPlease add some checks to the code. I'll paste my solution below:\r\n\r\n```\r\n#retrain.py\r\n...\r\ndef get_or_create_bottleneck(sess, image_lists, label_name, index, image_dir,\r\n                             category, bottleneck_dir, jpeg_data_tensor,\r\n                             bottleneck_tensor):\r\n...\r\n  with open(bottleneck_path, 'r') as bottleneck_file:\r\n    bottleneck_string = bottleneck_file.read()\r\n  \r\n  #avoiding non float values\r\n    try:\r\n      bottleneck_values = [float(x) for x in bottleneck_string.split(',')]\r\n    except:\r\n      print(\"Invalid float found, sending None instead\")\r\n      return None\r\n\r\n  return bottleneck_values\r\n\r\n...\r\ndef cache_bottlenecks(sess, image_lists, image_dir, bottleneck_dir,\r\n                      jpeg_data_tensor, bottleneck_tensor):\r\n...\r\n      for index, unused_base_name in enumerate(category_list):\r\n        bNeck = get_or_create_bottleneck(sess, image_lists, label_name, index,\r\n                                 image_dir, category, bottleneck_dir,\r\n                                 jpeg_data_tensor, bottleneck_tensor)\r\n        if bNeck is not None:\r\n          how_many_bottlenecks += 1\r\n          if how_many_bottlenecks % 100 == 0:\r\n            print(str(how_many_bottlenecks) + ' bottleneck files created.')\r\n\r\n...\r\ndef get_random_cached_bottlenecks(sess, image_lists, how_many, category,\r\n                                  bottleneck_dir, image_dir, jpeg_data_tensor,\r\n                                  bottleneck_tensor):\r\n...\r\n  for unused_i in range(how_many):\r\n    label_index = random.randrange(class_count)\r\n    label_name = list(image_lists.keys())[label_index]\r\n    image_index = random.randrange(MAX_NUM_IMAGES_PER_CLASS + 1)\r\n    bottleneck = get_or_create_bottleneck(sess, image_lists, label_name,\r\n                                          image_index, image_dir, category,\r\n                                          bottleneck_dir, jpeg_data_tensor,\r\n                                          bottleneck_tensor)\r\n    if bottleneck is not None:\r\n      ground_truth = np.zeros(class_count, dtype=np.float32)\r\n      ground_truth[label_index] = 1.0\r\n      bottlenecks.append(bottleneck)\r\n      ground_truths.append(ground_truth)\r\n  return bottlenecks, ground_truths\r\n\r\n...\r\ndef get_random_distorted_bottlenecks(\r\n    sess, image_lists, how_many, category, image_dir, input_jpeg_tensor,\r\n    distorted_image, resized_input_tensor, bottleneck_tensor):\r\n...\r\n    bottleneck = run_bottleneck_on_image(sess, distorted_image_data,\r\n                                         resized_input_tensor,\r\n                                         bottleneck_tensor)\r\n    if bottleneck is not None:\r\n      ground_truth = np.zeros(class_count, dtype=np.float32)\r\n      ground_truth[label_index] = 1.0\r\n      bottlenecks.append(bottleneck)\r\n      ground_truths.append(ground_truth)\r\n  return bottlenecks, ground_truths"}