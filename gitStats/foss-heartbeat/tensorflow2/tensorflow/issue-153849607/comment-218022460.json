{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/218022460", "html_url": "https://github.com/tensorflow/tensorflow/issues/2296#issuecomment-218022460", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2296", "id": 218022460, "node_id": "MDEyOklzc3VlQ29tbWVudDIxODAyMjQ2MA==", "user": {"login": "dave-andersen", "id": 827870, "node_id": "MDQ6VXNlcjgyNzg3MA==", "avatar_url": "https://avatars3.githubusercontent.com/u/827870?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dave-andersen", "html_url": "https://github.com/dave-andersen", "followers_url": "https://api.github.com/users/dave-andersen/followers", "following_url": "https://api.github.com/users/dave-andersen/following{/other_user}", "gists_url": "https://api.github.com/users/dave-andersen/gists{/gist_id}", "starred_url": "https://api.github.com/users/dave-andersen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dave-andersen/subscriptions", "organizations_url": "https://api.github.com/users/dave-andersen/orgs", "repos_url": "https://api.github.com/users/dave-andersen/repos", "events_url": "https://api.github.com/users/dave-andersen/events{/privacy}", "received_events_url": "https://api.github.com/users/dave-andersen/received_events", "type": "User", "site_admin": false}, "created_at": "2016-05-09T23:48:26Z", "updated_at": "2016-05-09T23:48:26Z", "author_association": "CONTRIBUTOR", "body_html": "<p>I have a helper program I used to validate all of the imagenet files, but it's a little too Google-specific to be useful more broadly.  The heart of it, though, was just:</p>\n<p>... do something to read in your JPEG into a string called image_buffer ...</p>\n<p>features = tf.parse_single_example(example_serialized, feature_map)<br>\nimage_buffer = features['image']<br>\nfilename = features['filename']</p>\n<p>image_saved = tf.Variable('')<br>\nsave_image = image_saved.assign(image_buffer)<br>\ndecode_saved_image = tf.image.decode_jpeg(image_saved)</p>\n<p>init = tf.initialize_all_variables()<br>\nwith tf.control_dependencies([decode_saved_image]):<br>\nforce_decode_no_copy = tf.no_op()</p>\n<p>with tf.Session() as sess:<br>\nsess.run(init)<br>\ntf.start_queue_runners()</p>\n<pre><code>try:\n  while True:\n    key, fn, _ = sess.run([exid, filename, save_image])\n    try:\n      _ = sess.run(force_decode_no_copy)\n    except:\n      print \"Error decoding \", key, fn\n\nexcept tf.errors.OutOfRangeError:\n  print \"OK\"\n</code></pre>\n<p>You just need a wrapper mechanism to run a bunch of parallel threads for this and handle the input depending on how you're getting it all read in.</p>", "body_text": "I have a helper program I used to validate all of the imagenet files, but it's a little too Google-specific to be useful more broadly.  The heart of it, though, was just:\n... do something to read in your JPEG into a string called image_buffer ...\nfeatures = tf.parse_single_example(example_serialized, feature_map)\nimage_buffer = features['image']\nfilename = features['filename']\nimage_saved = tf.Variable('')\nsave_image = image_saved.assign(image_buffer)\ndecode_saved_image = tf.image.decode_jpeg(image_saved)\ninit = tf.initialize_all_variables()\nwith tf.control_dependencies([decode_saved_image]):\nforce_decode_no_copy = tf.no_op()\nwith tf.Session() as sess:\nsess.run(init)\ntf.start_queue_runners()\ntry:\n  while True:\n    key, fn, _ = sess.run([exid, filename, save_image])\n    try:\n      _ = sess.run(force_decode_no_copy)\n    except:\n      print \"Error decoding \", key, fn\n\nexcept tf.errors.OutOfRangeError:\n  print \"OK\"\n\nYou just need a wrapper mechanism to run a bunch of parallel threads for this and handle the input depending on how you're getting it all read in.", "body": "I have a helper program I used to validate all of the imagenet files, but it's a little too Google-specific to be useful more broadly.  The heart of it, though, was just:\n\n... do something to read in your JPEG into a string called image_buffer ...\n\n  features = tf.parse_single_example(example_serialized, feature_map)\n  image_buffer = features['image']\n  filename = features['filename']\n\n  image_saved = tf.Variable('')\n  save_image = image_saved.assign(image_buffer)\n  decode_saved_image = tf.image.decode_jpeg(image_saved)\n\n  init = tf.initialize_all_variables()\n  with tf.control_dependencies([decode_saved_image]):\n    force_decode_no_copy = tf.no_op()\n\n  with tf.Session() as sess:\n    sess.run(init)\n    tf.start_queue_runners()\n\n```\ntry:\n  while True:\n    key, fn, _ = sess.run([exid, filename, save_image])\n    try:\n      _ = sess.run(force_decode_no_copy)\n    except:\n      print \"Error decoding \", key, fn\n\nexcept tf.errors.OutOfRangeError:\n  print \"OK\"\n```\n\nYou just need a wrapper mechanism to run a bunch of parallel threads for this and handle the input depending on how you're getting it all read in.\n"}