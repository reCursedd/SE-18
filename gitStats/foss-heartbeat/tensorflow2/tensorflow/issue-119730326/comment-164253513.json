{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/164253513", "html_url": "https://github.com/tensorflow/tensorflow/issues/387#issuecomment-164253513", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/387", "id": 164253513, "node_id": "MDEyOklzc3VlQ29tbWVudDE2NDI1MzUxMw==", "user": {"login": "jjallaire", "id": 104391, "node_id": "MDQ6VXNlcjEwNDM5MQ==", "avatar_url": "https://avatars2.githubusercontent.com/u/104391?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jjallaire", "html_url": "https://github.com/jjallaire", "followers_url": "https://api.github.com/users/jjallaire/followers", "following_url": "https://api.github.com/users/jjallaire/following{/other_user}", "gists_url": "https://api.github.com/users/jjallaire/gists{/gist_id}", "starred_url": "https://api.github.com/users/jjallaire/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jjallaire/subscriptions", "organizations_url": "https://api.github.com/users/jjallaire/orgs", "repos_url": "https://api.github.com/users/jjallaire/repos", "events_url": "https://api.github.com/users/jjallaire/events{/privacy}", "received_events_url": "https://api.github.com/users/jjallaire/received_events", "type": "User", "site_admin": false}, "created_at": "2015-12-13T12:27:29Z", "updated_at": "2015-12-13T12:27:29Z", "author_association": "NONE", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=70511\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/girving\">@girving</a> Interested in your guidance on the various ways to pursue R bindings. Read your comment here providing the lay of the land for Rust (<a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"119750224\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/tensorflow/tensorflow/issues/388\" data-hovercard-type=\"issue\" data-hovercard-url=\"/tensorflow/tensorflow/issues/388/hovercard?comment_id=161019498&amp;comment_type=issue_comment\" href=\"https://github.com/tensorflow/tensorflow/issues/388#issuecomment-161019498\">#388 (comment)</a>). We obviously can pursue SWIG bindings to the existing C++ classes and then pickup additional functionality from the C++ layer once more of the features from the python layer are moved there.</p>\n<p>However, we're most interested in creating idiomatic bindings for R and to get this exactly right are in no way deterred by the fact that it may take a lot of effort (much of which is duplicated). I can think of a few ways to approach creating these bindings:</p>\n<ol>\n<li>Create a wrapper for sessions / invocation using the C API then create the graph definition bindings by going directly to proto. This possibility seems to be anticipated/encouraged here: <a href=\"https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/public/tensor_c_api.h#L55-L59\">https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/public/tensor_c_api.h#L55-L59</a></li>\n<li>Call the C++ layer via SWIG bindings.</li>\n<li>Call python directly from R using e.g. boost::python or pybind11. Assuming that NumPy arrays can be marshaled to from R arrays with no copying I'm assuming this would have no performance problems since the python code is just defining a graph.</li>\n</ol>\n<p>To me the first option has the greatest appeal because there would be no impedance problems associated with translating idiomatic R into graphs, we'd just figure out the right syntax and express it as a graph definition rather than contorting it through the C++ layer. The comment above seems to imply that this would be an effective path, but I haven't spent enough time looking to know whether this would be a monumental amount of work that would be constantly challenged to keep up or just something to grind through once (not deterred at all by having to spend on the order of hundreds of hours in the initial effort). I also like the idea of using the C API because those entry points could be loaded dynamically, meaning that the R bindings could be built separately and made available on CRAN and could work with any installed version of TensorFlow.</p>\n<p>We could also combine the creation of proto-based idiomatic R bindings with another binding that parrots the python API. This would allow R users to easily translate and use python or C++ API based examples but at the same time have a first class R binding that makes maximum sense to R users.</p>\n<p>Your thoughts and feedback very much appreciated!</p>", "body_text": "@girving Interested in your guidance on the various ways to pursue R bindings. Read your comment here providing the lay of the land for Rust (#388 (comment)). We obviously can pursue SWIG bindings to the existing C++ classes and then pickup additional functionality from the C++ layer once more of the features from the python layer are moved there.\nHowever, we're most interested in creating idiomatic bindings for R and to get this exactly right are in no way deterred by the fact that it may take a lot of effort (much of which is duplicated). I can think of a few ways to approach creating these bindings:\n\nCreate a wrapper for sessions / invocation using the C API then create the graph definition bindings by going directly to proto. This possibility seems to be anticipated/encouraged here: https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/public/tensor_c_api.h#L55-L59\nCall the C++ layer via SWIG bindings.\nCall python directly from R using e.g. boost::python or pybind11. Assuming that NumPy arrays can be marshaled to from R arrays with no copying I'm assuming this would have no performance problems since the python code is just defining a graph.\n\nTo me the first option has the greatest appeal because there would be no impedance problems associated with translating idiomatic R into graphs, we'd just figure out the right syntax and express it as a graph definition rather than contorting it through the C++ layer. The comment above seems to imply that this would be an effective path, but I haven't spent enough time looking to know whether this would be a monumental amount of work that would be constantly challenged to keep up or just something to grind through once (not deterred at all by having to spend on the order of hundreds of hours in the initial effort). I also like the idea of using the C API because those entry points could be loaded dynamically, meaning that the R bindings could be built separately and made available on CRAN and could work with any installed version of TensorFlow.\nWe could also combine the creation of proto-based idiomatic R bindings with another binding that parrots the python API. This would allow R users to easily translate and use python or C++ API based examples but at the same time have a first class R binding that makes maximum sense to R users.\nYour thoughts and feedback very much appreciated!", "body": "@girving Interested in your guidance on the various ways to pursue R bindings. Read your comment here providing the lay of the land for Rust (https://github.com/tensorflow/tensorflow/issues/388#issuecomment-161019498). We obviously can pursue SWIG bindings to the existing C++ classes and then pickup additional functionality from the C++ layer once more of the features from the python layer are moved there.\n\nHowever, we're most interested in creating idiomatic bindings for R and to get this exactly right are in no way deterred by the fact that it may take a lot of effort (much of which is duplicated). I can think of a few ways to approach creating these bindings:\n1. Create a wrapper for sessions / invocation using the C API then create the graph definition bindings by going directly to proto. This possibility seems to be anticipated/encouraged here: https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/public/tensor_c_api.h#L55-L59\n2. Call the C++ layer via SWIG bindings.\n3. Call python directly from R using e.g. boost::python or pybind11. Assuming that NumPy arrays can be marshaled to from R arrays with no copying I'm assuming this would have no performance problems since the python code is just defining a graph.\n\nTo me the first option has the greatest appeal because there would be no impedance problems associated with translating idiomatic R into graphs, we'd just figure out the right syntax and express it as a graph definition rather than contorting it through the C++ layer. The comment above seems to imply that this would be an effective path, but I haven't spent enough time looking to know whether this would be a monumental amount of work that would be constantly challenged to keep up or just something to grind through once (not deterred at all by having to spend on the order of hundreds of hours in the initial effort). I also like the idea of using the C API because those entry points could be loaded dynamically, meaning that the R bindings could be built separately and made available on CRAN and could work with any installed version of TensorFlow.\n\nWe could also combine the creation of proto-based idiomatic R bindings with another binding that parrots the python API. This would allow R users to easily translate and use python or C++ API based examples but at the same time have a first class R binding that makes maximum sense to R users.\n\nYour thoughts and feedback very much appreciated!\n"}