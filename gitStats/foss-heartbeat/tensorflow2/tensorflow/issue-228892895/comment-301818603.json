{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/301818603", "html_url": "https://github.com/tensorflow/tensorflow/issues/9925#issuecomment-301818603", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9925", "id": 301818603, "node_id": "MDEyOklzc3VlQ29tbWVudDMwMTgxODYwMw==", "user": {"login": "yaroslavvb", "id": 23068, "node_id": "MDQ6VXNlcjIzMDY4", "avatar_url": "https://avatars3.githubusercontent.com/u/23068?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yaroslavvb", "html_url": "https://github.com/yaroslavvb", "followers_url": "https://api.github.com/users/yaroslavvb/followers", "following_url": "https://api.github.com/users/yaroslavvb/following{/other_user}", "gists_url": "https://api.github.com/users/yaroslavvb/gists{/gist_id}", "starred_url": "https://api.github.com/users/yaroslavvb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yaroslavvb/subscriptions", "organizations_url": "https://api.github.com/users/yaroslavvb/orgs", "repos_url": "https://api.github.com/users/yaroslavvb/repos", "events_url": "https://api.github.com/users/yaroslavvb/events{/privacy}", "received_events_url": "https://api.github.com/users/yaroslavvb/received_events", "type": "User", "site_admin": false}, "created_at": "2017-05-16T15:26:22Z", "updated_at": "2017-05-16T15:28:35Z", "author_association": "CONTRIBUTOR", "body_html": "<p>BTW, I used following work-around to rewrite colocation constraints in copied graph to point to copied ops. I couldn't find format of colocation groups documented so just assumed they are in the form <code>_class: loc:@opname</code> and it seemed to work</p>\n<pre><code>from tensorflow.core.framework import attr_value_pb2\nimport tensorflow.contrib.graph_editor as ge\n\ncopied_sgv, info = ge.copy_with_input_replacements(ge.sgv(self.ops),\n                                                   replacements)\n\ndef to_bytes(s): return s.encode('ascii')\ndef from_bytes(s): return s.decode('ascii')\n\n# fix colocation constraints to point to copied ops\nnew_ops = [info._transformed_ops[op] for op in self.ops]\nfor new_op in new_ops:\n  assert len(new_op.colocation_groups()) == 1\n  colocation_group = new_op.colocation_groups()[0]\n  assert colocation_group.startswith(b'loc:@')\n  colocated_with_name = from_bytes(colocation_group[len(b'loc:@'):])\n\n  # if there were no colocation constraints, the op gets colocated with\n  # itself (default colocation group), ignore that constraint\n  if colocated_with_name == new_op.name:\n    continue\n\n  colocation_op = g.get_operation_by_name(colocated_with_name)\n  if colocation_op in info._transformed_ops:\n    new_colocation_op = info._transformed_ops[colocation_op]\n  else:\n    # TODO: make it work with variables\n    assert colocation_op in self.input_ops\n    colocation_op_idx = self.input_ops.index(colocation_op)\n    new_colocation_op = new_inputs[colocation_op_idx].op\n    \n  # overwrite existing _class attribute with new colocation constraints\n  new_colocation_groups = [b'loc:@'+to_bytes(new_colocation_op.name)]\n  new_op.node_def.attr[\"_class\"].CopyFrom(attr_value_pb2.AttrValue(\n    list=attr_value_pb2.AttrValue.ListValue(s=new_colocation_groups)))\n</code></pre>", "body_text": "BTW, I used following work-around to rewrite colocation constraints in copied graph to point to copied ops. I couldn't find format of colocation groups documented so just assumed they are in the form _class: loc:@opname and it seemed to work\nfrom tensorflow.core.framework import attr_value_pb2\nimport tensorflow.contrib.graph_editor as ge\n\ncopied_sgv, info = ge.copy_with_input_replacements(ge.sgv(self.ops),\n                                                   replacements)\n\ndef to_bytes(s): return s.encode('ascii')\ndef from_bytes(s): return s.decode('ascii')\n\n# fix colocation constraints to point to copied ops\nnew_ops = [info._transformed_ops[op] for op in self.ops]\nfor new_op in new_ops:\n  assert len(new_op.colocation_groups()) == 1\n  colocation_group = new_op.colocation_groups()[0]\n  assert colocation_group.startswith(b'loc:@')\n  colocated_with_name = from_bytes(colocation_group[len(b'loc:@'):])\n\n  # if there were no colocation constraints, the op gets colocated with\n  # itself (default colocation group), ignore that constraint\n  if colocated_with_name == new_op.name:\n    continue\n\n  colocation_op = g.get_operation_by_name(colocated_with_name)\n  if colocation_op in info._transformed_ops:\n    new_colocation_op = info._transformed_ops[colocation_op]\n  else:\n    # TODO: make it work with variables\n    assert colocation_op in self.input_ops\n    colocation_op_idx = self.input_ops.index(colocation_op)\n    new_colocation_op = new_inputs[colocation_op_idx].op\n    \n  # overwrite existing _class attribute with new colocation constraints\n  new_colocation_groups = [b'loc:@'+to_bytes(new_colocation_op.name)]\n  new_op.node_def.attr[\"_class\"].CopyFrom(attr_value_pb2.AttrValue(\n    list=attr_value_pb2.AttrValue.ListValue(s=new_colocation_groups)))", "body": "BTW, I used following work-around to rewrite colocation constraints in copied graph to point to copied ops. I couldn't find format of colocation groups documented so just assumed they are in the form `_class: loc:@opname` and it seemed to work \r\n\r\n    from tensorflow.core.framework import attr_value_pb2\r\n    import tensorflow.contrib.graph_editor as ge\r\n\r\n    copied_sgv, info = ge.copy_with_input_replacements(ge.sgv(self.ops),\r\n                                                       replacements)\r\n\r\n    def to_bytes(s): return s.encode('ascii')\r\n    def from_bytes(s): return s.decode('ascii')\r\n\r\n    # fix colocation constraints to point to copied ops\r\n    new_ops = [info._transformed_ops[op] for op in self.ops]\r\n    for new_op in new_ops:\r\n      assert len(new_op.colocation_groups()) == 1\r\n      colocation_group = new_op.colocation_groups()[0]\r\n      assert colocation_group.startswith(b'loc:@')\r\n      colocated_with_name = from_bytes(colocation_group[len(b'loc:@'):])\r\n    \r\n      # if there were no colocation constraints, the op gets colocated with\r\n      # itself (default colocation group), ignore that constraint\r\n      if colocated_with_name == new_op.name:\r\n        continue\r\n    \r\n      colocation_op = g.get_operation_by_name(colocated_with_name)\r\n      if colocation_op in info._transformed_ops:\r\n        new_colocation_op = info._transformed_ops[colocation_op]\r\n      else:\r\n        # TODO: make it work with variables\r\n        assert colocation_op in self.input_ops\r\n        colocation_op_idx = self.input_ops.index(colocation_op)\r\n        new_colocation_op = new_inputs[colocation_op_idx].op\r\n        \r\n      # overwrite existing _class attribute with new colocation constraints\r\n      new_colocation_groups = [b'loc:@'+to_bytes(new_colocation_op.name)]\r\n      new_op.node_def.attr[\"_class\"].CopyFrom(attr_value_pb2.AttrValue(\r\n        list=attr_value_pb2.AttrValue.ListValue(s=new_colocation_groups)))\r\n"}