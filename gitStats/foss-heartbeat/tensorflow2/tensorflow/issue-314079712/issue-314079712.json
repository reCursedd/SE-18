{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/18491", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/18491/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/18491/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/18491/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/18491", "id": 314079712, "node_id": "MDU6SXNzdWUzMTQwNzk3MTI=", "number": 18491, "title": "crf_log_likelihood become 2x slower after upgrade TensorFlow from 1.4 to 1.7", "user": {"login": "SimpleJian", "id": 5996147, "node_id": "MDQ6VXNlcjU5OTYxNDc=", "avatar_url": "https://avatars1.githubusercontent.com/u/5996147?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimpleJian", "html_url": "https://github.com/SimpleJian", "followers_url": "https://api.github.com/users/SimpleJian/followers", "following_url": "https://api.github.com/users/SimpleJian/following{/other_user}", "gists_url": "https://api.github.com/users/SimpleJian/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimpleJian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimpleJian/subscriptions", "organizations_url": "https://api.github.com/users/SimpleJian/orgs", "repos_url": "https://api.github.com/users/SimpleJian/repos", "events_url": "https://api.github.com/users/SimpleJian/events{/privacy}", "received_events_url": "https://api.github.com/users/SimpleJian/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "open", "locked": false, "assignee": {"login": "rmlarsen", "id": 16907534, "node_id": "MDQ6VXNlcjE2OTA3NTM0", "avatar_url": "https://avatars2.githubusercontent.com/u/16907534?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rmlarsen", "html_url": "https://github.com/rmlarsen", "followers_url": "https://api.github.com/users/rmlarsen/followers", "following_url": "https://api.github.com/users/rmlarsen/following{/other_user}", "gists_url": "https://api.github.com/users/rmlarsen/gists{/gist_id}", "starred_url": "https://api.github.com/users/rmlarsen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rmlarsen/subscriptions", "organizations_url": "https://api.github.com/users/rmlarsen/orgs", "repos_url": "https://api.github.com/users/rmlarsen/repos", "events_url": "https://api.github.com/users/rmlarsen/events{/privacy}", "received_events_url": "https://api.github.com/users/rmlarsen/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "rmlarsen", "id": 16907534, "node_id": "MDQ6VXNlcjE2OTA3NTM0", "avatar_url": "https://avatars2.githubusercontent.com/u/16907534?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rmlarsen", "html_url": "https://github.com/rmlarsen", "followers_url": "https://api.github.com/users/rmlarsen/followers", "following_url": "https://api.github.com/users/rmlarsen/following{/other_user}", "gists_url": "https://api.github.com/users/rmlarsen/gists{/gist_id}", "starred_url": "https://api.github.com/users/rmlarsen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rmlarsen/subscriptions", "organizations_url": "https://api.github.com/users/rmlarsen/orgs", "repos_url": "https://api.github.com/users/rmlarsen/repos", "events_url": "https://api.github.com/users/rmlarsen/events{/privacy}", "received_events_url": "https://api.github.com/users/rmlarsen/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 5, "created_at": "2018-04-13T12:00:14Z", "updated_at": "2018-11-14T19:17:07Z", "closed_at": null, "author_association": "NONE", "body_html": "<h3>System information</h3>\n<ul>\n<li><strong>Have I written custom code (as opposed to using a stock example script provided in TensorFlow)</strong>: yes</li>\n<li><strong>OS Platform and Distribution (e.g., Linux Ubuntu 16.04)</strong>: CentOS Linux release 7.4.1708</li>\n<li><strong>TensorFlow installed from (source or binary)</strong>: pip install tensorflow-gpu==1.4.0, pip install tensorflow-gpu==1.7.0</li>\n<li><strong>TensorFlow version (use command below)</strong>: 1.4 and 1.7</li>\n<li><strong>Python version</strong>:  2.7.5</li>\n<li><strong>Bazel version (if compiling from source)</strong>: N/A (not compiled from source)</li>\n<li><strong>GCC/Compiler version (if compiling from source)</strong>: N/A (not compiled from source)</li>\n<li><strong>CUDA/cuDNN version</strong>: CUDA8.0 + cuDNN6.0 for Tensorflow 1.4, CUDA9 + cuDNN7.0 for Tensorflow 1.7</li>\n<li><strong>GPU model and memory</strong>: GeForce GTX 1080 Ti, 11178MiB</li>\n<li><strong>Exact command to reproduce</strong>: python profile_crf.py</li>\n</ul>\n<h3>Describe the problem</h3>\n<p>After upgrade TensorFlow from 1.4 to 1.7,  crf become 2x slower.</p>\n<p>When run in TF1.4, it cost about 19 seconds every 100 steps, but about 43 seconds every 100 steps in TF1.7, the source code are the same, see below.</p>\n<h3>Source code / logs</h3>\n<p>the source code are modified from<br>\n<a href=\"https://github.com/tensorflow/tensorflow/tree/master/tensorflow/contrib/crf\">https://github.com/tensorflow/tensorflow/tree/master/tensorflow/contrib/crf</a></p>\n<pre><code>import numpy as np\nimport tensorflow as tf\nimport time\n\n# Data settings.\nnum_examples = 1000\nnum_words = 100\nnum_features = 1000\nnum_tags = 50\n\n# Random features.\nx = np.random.rand(num_examples, num_words, num_features).astype(np.float32)\n\n# Random tag indices representing the gold sequence.\ny = np.random.randint(num_tags, size=[num_examples, num_words]).astype(np.int32)\n\n# All sequences in this example have the same length, but they can be variable in a real model.\n# sequence_lengths = np.full(num_examples, num_words - 1, dtype=np.int32)\nsequence_lengths = np.full(num_examples, num_words, dtype=np.int32)\n\n# Train and evaluate the model.\nwith tf.Graph().as_default():\n  with tf.Session() as session:\n    # Add the data to the TensorFlow graph.\n    x_t = tf.constant(x)\n    y_t = tf.constant(y)\n    sequence_lengths_t = tf.constant(sequence_lengths)\n\n    # Compute unary scores from a linear layer.\n    weights = tf.get_variable(\"weights\", [num_features, num_tags])\n    matricized_x_t = tf.reshape(x_t, [-1, num_features])\n    matricized_unary_scores = tf.matmul(matricized_x_t, weights)\n    unary_scores = tf.reshape(matricized_unary_scores,\n                              [num_examples, num_words, num_tags])\n\n    # Compute the log-likelihood of the gold sequences and keep the transition\n    # params for inference at test time.\n    log_likelihood, transition_params = tf.contrib.crf.crf_log_likelihood(\n        unary_scores, y_t, sequence_lengths_t)\n\n    # Compute the viterbi sequence and score.\n    viterbi_sequence, viterbi_score = tf.contrib.crf.crf_decode(\n        unary_scores, transition_params, sequence_lengths_t)\n\n    # Add a training op to tune the parameters.\n    loss = tf.reduce_mean(-log_likelihood)\n    train_op = tf.train.GradientDescentOptimizer(0.01).minimize(loss)\n\n    session.run(tf.global_variables_initializer())\n\n    mask = (np.expand_dims(np.arange(num_words), axis=0) &lt;\n            np.expand_dims(sequence_lengths, axis=1))\n    total_labels = np.sum(sequence_lengths)\n\n    # Train for a fixed number of iterations.\n    seconds = 0\n    for i in range(500):\n      start_time = time.time()\n      tf_viterbi_sequence, _ = session.run([viterbi_sequence, train_op])\n      seconds += time.time() - start_time\n      if i&gt;0 and i % 100 == 0:\n        print('time elapsed: {}'.format(seconds))\n        seconds = 0\n        correct_labels = np.sum((y == tf_viterbi_sequence) * mask)\n        accuracy = 100.0 * correct_labels / float(total_labels)\n        print(\"Accuracy: %.2f%%\" % accuracy)\n</code></pre>", "body_text": "System information\n\nHave I written custom code (as opposed to using a stock example script provided in TensorFlow): yes\nOS Platform and Distribution (e.g., Linux Ubuntu 16.04): CentOS Linux release 7.4.1708\nTensorFlow installed from (source or binary): pip install tensorflow-gpu==1.4.0, pip install tensorflow-gpu==1.7.0\nTensorFlow version (use command below): 1.4 and 1.7\nPython version:  2.7.5\nBazel version (if compiling from source): N/A (not compiled from source)\nGCC/Compiler version (if compiling from source): N/A (not compiled from source)\nCUDA/cuDNN version: CUDA8.0 + cuDNN6.0 for Tensorflow 1.4, CUDA9 + cuDNN7.0 for Tensorflow 1.7\nGPU model and memory: GeForce GTX 1080 Ti, 11178MiB\nExact command to reproduce: python profile_crf.py\n\nDescribe the problem\nAfter upgrade TensorFlow from 1.4 to 1.7,  crf become 2x slower.\nWhen run in TF1.4, it cost about 19 seconds every 100 steps, but about 43 seconds every 100 steps in TF1.7, the source code are the same, see below.\nSource code / logs\nthe source code are modified from\nhttps://github.com/tensorflow/tensorflow/tree/master/tensorflow/contrib/crf\nimport numpy as np\nimport tensorflow as tf\nimport time\n\n# Data settings.\nnum_examples = 1000\nnum_words = 100\nnum_features = 1000\nnum_tags = 50\n\n# Random features.\nx = np.random.rand(num_examples, num_words, num_features).astype(np.float32)\n\n# Random tag indices representing the gold sequence.\ny = np.random.randint(num_tags, size=[num_examples, num_words]).astype(np.int32)\n\n# All sequences in this example have the same length, but they can be variable in a real model.\n# sequence_lengths = np.full(num_examples, num_words - 1, dtype=np.int32)\nsequence_lengths = np.full(num_examples, num_words, dtype=np.int32)\n\n# Train and evaluate the model.\nwith tf.Graph().as_default():\n  with tf.Session() as session:\n    # Add the data to the TensorFlow graph.\n    x_t = tf.constant(x)\n    y_t = tf.constant(y)\n    sequence_lengths_t = tf.constant(sequence_lengths)\n\n    # Compute unary scores from a linear layer.\n    weights = tf.get_variable(\"weights\", [num_features, num_tags])\n    matricized_x_t = tf.reshape(x_t, [-1, num_features])\n    matricized_unary_scores = tf.matmul(matricized_x_t, weights)\n    unary_scores = tf.reshape(matricized_unary_scores,\n                              [num_examples, num_words, num_tags])\n\n    # Compute the log-likelihood of the gold sequences and keep the transition\n    # params for inference at test time.\n    log_likelihood, transition_params = tf.contrib.crf.crf_log_likelihood(\n        unary_scores, y_t, sequence_lengths_t)\n\n    # Compute the viterbi sequence and score.\n    viterbi_sequence, viterbi_score = tf.contrib.crf.crf_decode(\n        unary_scores, transition_params, sequence_lengths_t)\n\n    # Add a training op to tune the parameters.\n    loss = tf.reduce_mean(-log_likelihood)\n    train_op = tf.train.GradientDescentOptimizer(0.01).minimize(loss)\n\n    session.run(tf.global_variables_initializer())\n\n    mask = (np.expand_dims(np.arange(num_words), axis=0) <\n            np.expand_dims(sequence_lengths, axis=1))\n    total_labels = np.sum(sequence_lengths)\n\n    # Train for a fixed number of iterations.\n    seconds = 0\n    for i in range(500):\n      start_time = time.time()\n      tf_viterbi_sequence, _ = session.run([viterbi_sequence, train_op])\n      seconds += time.time() - start_time\n      if i>0 and i % 100 == 0:\n        print('time elapsed: {}'.format(seconds))\n        seconds = 0\n        correct_labels = np.sum((y == tf_viterbi_sequence) * mask)\n        accuracy = 100.0 * correct_labels / float(total_labels)\n        print(\"Accuracy: %.2f%%\" % accuracy)", "body": "### System information\r\n- **Have I written custom code (as opposed to using a stock example script provided in TensorFlow)**: yes\r\n- **OS Platform and Distribution (e.g., Linux Ubuntu 16.04)**: CentOS Linux release 7.4.1708\r\n- **TensorFlow installed from (source or binary)**: pip install tensorflow-gpu==1.4.0, pip install tensorflow-gpu==1.7.0\r\n- **TensorFlow version (use command below)**: 1.4 and 1.7\r\n- **Python version**:  2.7.5\r\n- **Bazel version (if compiling from source)**: N/A (not compiled from source)\r\n- **GCC/Compiler version (if compiling from source)**: N/A (not compiled from source)\r\n- **CUDA/cuDNN version**: CUDA8.0 + cuDNN6.0 for Tensorflow 1.4, CUDA9 + cuDNN7.0 for Tensorflow 1.7\r\n- **GPU model and memory**: GeForce GTX 1080 Ti, 11178MiB\r\n- **Exact command to reproduce**: python profile_crf.py\r\n\r\n### Describe the problem\r\nAfter upgrade TensorFlow from 1.4 to 1.7,  crf become 2x slower.\r\n\r\nWhen run in TF1.4, it cost about 19 seconds every 100 steps, but about 43 seconds every 100 steps in TF1.7, the source code are the same, see below.\r\n### Source code / logs\r\nthe source code are modified from \r\nhttps://github.com/tensorflow/tensorflow/tree/master/tensorflow/contrib/crf\r\n```\r\nimport numpy as np\r\nimport tensorflow as tf\r\nimport time\r\n\r\n# Data settings.\r\nnum_examples = 1000\r\nnum_words = 100\r\nnum_features = 1000\r\nnum_tags = 50\r\n\r\n# Random features.\r\nx = np.random.rand(num_examples, num_words, num_features).astype(np.float32)\r\n\r\n# Random tag indices representing the gold sequence.\r\ny = np.random.randint(num_tags, size=[num_examples, num_words]).astype(np.int32)\r\n\r\n# All sequences in this example have the same length, but they can be variable in a real model.\r\n# sequence_lengths = np.full(num_examples, num_words - 1, dtype=np.int32)\r\nsequence_lengths = np.full(num_examples, num_words, dtype=np.int32)\r\n\r\n# Train and evaluate the model.\r\nwith tf.Graph().as_default():\r\n  with tf.Session() as session:\r\n    # Add the data to the TensorFlow graph.\r\n    x_t = tf.constant(x)\r\n    y_t = tf.constant(y)\r\n    sequence_lengths_t = tf.constant(sequence_lengths)\r\n\r\n    # Compute unary scores from a linear layer.\r\n    weights = tf.get_variable(\"weights\", [num_features, num_tags])\r\n    matricized_x_t = tf.reshape(x_t, [-1, num_features])\r\n    matricized_unary_scores = tf.matmul(matricized_x_t, weights)\r\n    unary_scores = tf.reshape(matricized_unary_scores,\r\n                              [num_examples, num_words, num_tags])\r\n\r\n    # Compute the log-likelihood of the gold sequences and keep the transition\r\n    # params for inference at test time.\r\n    log_likelihood, transition_params = tf.contrib.crf.crf_log_likelihood(\r\n        unary_scores, y_t, sequence_lengths_t)\r\n\r\n    # Compute the viterbi sequence and score.\r\n    viterbi_sequence, viterbi_score = tf.contrib.crf.crf_decode(\r\n        unary_scores, transition_params, sequence_lengths_t)\r\n\r\n    # Add a training op to tune the parameters.\r\n    loss = tf.reduce_mean(-log_likelihood)\r\n    train_op = tf.train.GradientDescentOptimizer(0.01).minimize(loss)\r\n\r\n    session.run(tf.global_variables_initializer())\r\n\r\n    mask = (np.expand_dims(np.arange(num_words), axis=0) <\r\n            np.expand_dims(sequence_lengths, axis=1))\r\n    total_labels = np.sum(sequence_lengths)\r\n\r\n    # Train for a fixed number of iterations.\r\n    seconds = 0\r\n    for i in range(500):\r\n      start_time = time.time()\r\n      tf_viterbi_sequence, _ = session.run([viterbi_sequence, train_op])\r\n      seconds += time.time() - start_time\r\n      if i>0 and i % 100 == 0:\r\n        print('time elapsed: {}'.format(seconds))\r\n        seconds = 0\r\n        correct_labels = np.sum((y == tf_viterbi_sequence) * mask)\r\n        accuracy = 100.0 * correct_labels / float(total_labels)\r\n        print(\"Accuracy: %.2f%%\" % accuracy)\r\n```"}