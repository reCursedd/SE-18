{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/12298", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/12298/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/12298/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/12298/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/12298", "id": 250356929, "node_id": "MDU6SXNzdWUyNTAzNTY5Mjk=", "number": 12298, "title": "iOS: thread pools appear to spin forever, even after session close", "user": {"login": "sadlerjw", "id": 2762244, "node_id": "MDQ6VXNlcjI3NjIyNDQ=", "avatar_url": "https://avatars3.githubusercontent.com/u/2762244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sadlerjw", "html_url": "https://github.com/sadlerjw", "followers_url": "https://api.github.com/users/sadlerjw/followers", "following_url": "https://api.github.com/users/sadlerjw/following{/other_user}", "gists_url": "https://api.github.com/users/sadlerjw/gists{/gist_id}", "starred_url": "https://api.github.com/users/sadlerjw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sadlerjw/subscriptions", "organizations_url": "https://api.github.com/users/sadlerjw/orgs", "repos_url": "https://api.github.com/users/sadlerjw/repos", "events_url": "https://api.github.com/users/sadlerjw/events{/privacy}", "received_events_url": "https://api.github.com/users/sadlerjw/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 6, "created_at": "2017-08-15T15:53:34Z", "updated_at": "2017-08-28T03:48:22Z", "closed_at": "2017-08-28T03:48:22Z", "author_association": "CONTRIBUTOR", "body_html": "<h3>System information</h3>\n<ul>\n<li><strong>Have I written custom code (as opposed to using a stock example script provided in TensorFlow)</strong>: No. Built for iOS using provided scripts. Defined ops to be included in build as documented (using <code>ops_to_register.h</code>).</li>\n<li><strong>OS Platform and Distribution (e.g., Linux Ubuntu 16.04)</strong>: Built on macOS 10.12.6 for distribution on iOS</li>\n<li><strong>TensorFlow installed from (source or binary)</strong>: source</li>\n<li><strong>TensorFlow version (use command below)</strong>: Unsure, sorry, my python environment is all messed up right now. My HEAD is at <a class=\"commit-link\" data-hovercard-type=\"commit\" data-hovercard-url=\"https://github.com/tensorflow/tensorflow/commit/0d2f6918322c7bf29d1de3075b0d4ed3b1b72919/hovercard\" href=\"https://github.com/tensorflow/tensorflow/commit/0d2f6918322c7bf29d1de3075b0d4ed3b1b72919\"><tt>0d2f691</tt></a></li>\n<li><strong>Python version</strong>: 2.7.12, but I believe that's irrelevant for this issue</li>\n<li><strong>Bazel version (if compiling from source)</strong>: 0.5.1-homebrew, but I'm using <code>build_all_ios.sh</code> instead of Bazel to build</li>\n<li><strong>CUDA/cuDNN version</strong>: Unknown</li>\n<li><strong>GPU model and memory</strong>: iPhone 7 Plus, but AFAIK GPU is unavailable on iOS</li>\n<li><strong>Exact command to reproduce</strong>: No particular command. Please see description of issue</li>\n</ul>\n<p>Also <a href=\"https://stackoverflow.com/questions/45682837/tensorflow-thread-pools-appear-to-spin-forever-even-after-session-is-closed\" rel=\"nofollow\">asked about this</a> on Stack Overflow, where it was suggested I file an issue</p>\n<h3>Describe the problem</h3>\n<p>I believe this is a bug in Tensorflow. I am running Tensorflow on iOS, using the C++ API. I'm doing some image classification. I have a long-lived session, and I call <code>Run</code> many times on it, to evaluate different images from a backlog. Once I'm done, the <code>RunQueue</code>s (via <code>NonBlockingThreadPool</code>s) continue to pin the CPU at near max usage. They appear to be stuck in the <code>Steal</code> loop, presumably with no work to do.</p>\n<h3>Source code / logs</h3>\n<p>I tried <code>Close()</code>ing and then <code>delete</code>ing the session, and having read some of the C++ source, this <em>should</em> have shut down the thread pools that belong to the session, but this didn't change the situation:</p>\n<div class=\"highlight highlight-source-objc++\"><pre><span class=\"pl-k\">auto</span> status = session-&gt;<span class=\"pl-en\">Close</span>();\n<span class=\"pl-k\">delete</span> session;\nsession = <span class=\"pl-c1\">nil</span>;</pre></div>\n<p>I tried setting some specific configuration options so I could be sure that the session did in fact own its thread pools instead of using a global thread pool, but this didn't help either:</p>\n<div class=\"highlight highlight-source-objc++\"><pre>tensorflow::SessionOptions options;\noptions.config.clear_session_inter_op_thread_pool();\noptions.config.set_use_per_session_threads(<span class=\"pl-c1\">true</span>);\n<span class=\"pl-k\">auto</span> status = tensorflow::NewSession(options, &amp;session);</pre></div>\n<p>One thing to note: while my understanding is that this isn't necessary, I did also try using a mutex to ensure that <code>Close</code> and <code>delete</code> would not be called concurrently with any call to <code>Run</code>, but again, no luck.</p>\n<p>The only thing that <em>has</em> reduced CPU load to a reasonable level is to set <code>inter_op_parallelism_threads</code> to <code>1</code>. This doesn't resolve the underlying problem (that the threads are never cleaned up), but it <em>does</em> mean that the <code>Steal</code> loop is avoided, so the thread just blocks forever.</p>", "body_text": "System information\n\nHave I written custom code (as opposed to using a stock example script provided in TensorFlow): No. Built for iOS using provided scripts. Defined ops to be included in build as documented (using ops_to_register.h).\nOS Platform and Distribution (e.g., Linux Ubuntu 16.04): Built on macOS 10.12.6 for distribution on iOS\nTensorFlow installed from (source or binary): source\nTensorFlow version (use command below): Unsure, sorry, my python environment is all messed up right now. My HEAD is at 0d2f691\nPython version: 2.7.12, but I believe that's irrelevant for this issue\nBazel version (if compiling from source): 0.5.1-homebrew, but I'm using build_all_ios.sh instead of Bazel to build\nCUDA/cuDNN version: Unknown\nGPU model and memory: iPhone 7 Plus, but AFAIK GPU is unavailable on iOS\nExact command to reproduce: No particular command. Please see description of issue\n\nAlso asked about this on Stack Overflow, where it was suggested I file an issue\nDescribe the problem\nI believe this is a bug in Tensorflow. I am running Tensorflow on iOS, using the C++ API. I'm doing some image classification. I have a long-lived session, and I call Run many times on it, to evaluate different images from a backlog. Once I'm done, the RunQueues (via NonBlockingThreadPools) continue to pin the CPU at near max usage. They appear to be stuck in the Steal loop, presumably with no work to do.\nSource code / logs\nI tried Close()ing and then deleteing the session, and having read some of the C++ source, this should have shut down the thread pools that belong to the session, but this didn't change the situation:\nauto status = session->Close();\ndelete session;\nsession = nil;\nI tried setting some specific configuration options so I could be sure that the session did in fact own its thread pools instead of using a global thread pool, but this didn't help either:\ntensorflow::SessionOptions options;\noptions.config.clear_session_inter_op_thread_pool();\noptions.config.set_use_per_session_threads(true);\nauto status = tensorflow::NewSession(options, &session);\nOne thing to note: while my understanding is that this isn't necessary, I did also try using a mutex to ensure that Close and delete would not be called concurrently with any call to Run, but again, no luck.\nThe only thing that has reduced CPU load to a reasonable level is to set inter_op_parallelism_threads to 1. This doesn't resolve the underlying problem (that the threads are never cleaned up), but it does mean that the Steal loop is avoided, so the thread just blocks forever.", "body": "### System information\r\n- **Have I written custom code (as opposed to using a stock example script provided in TensorFlow)**: No. Built for iOS using provided scripts. Defined ops to be included in build as documented (using `ops_to_register.h`).\r\n- **OS Platform and Distribution (e.g., Linux Ubuntu 16.04)**: Built on macOS 10.12.6 for distribution on iOS\r\n- **TensorFlow installed from (source or binary)**: source\r\n- **TensorFlow version (use command below)**: Unsure, sorry, my python environment is all messed up right now. My HEAD is at 0d2f6918322c7bf29d1de3075b0d4ed3b1b72919\r\n- **Python version**: 2.7.12, but I believe that's irrelevant for this issue\r\n- **Bazel version (if compiling from source)**: 0.5.1-homebrew, but I'm using `build_all_ios.sh` instead of Bazel to build\r\n- **CUDA/cuDNN version**: Unknown\r\n- **GPU model and memory**: iPhone 7 Plus, but AFAIK GPU is unavailable on iOS\r\n- **Exact command to reproduce**: No particular command. Please see description of issue\r\n\r\nAlso [asked about this](https://stackoverflow.com/questions/45682837/tensorflow-thread-pools-appear-to-spin-forever-even-after-session-is-closed) on Stack Overflow, where it was suggested I file an issue\r\n\r\n### Describe the problem\r\nI believe this is a bug in Tensorflow. I am running Tensorflow on iOS, using the C++ API. I'm doing some image classification. I have a long-lived session, and I call `Run` many times on it, to evaluate different images from a backlog. Once I'm done, the `RunQueue`s (via `NonBlockingThreadPool`s) continue to pin the CPU at near max usage. They appear to be stuck in the `Steal` loop, presumably with no work to do.\r\n\r\n### Source code / logs\r\nI tried `Close()`ing and then `delete`ing the session, and having read some of the C++ source, this *should* have shut down the thread pools that belong to the session, but this didn't change the situation:\r\n```objc++\r\nauto status = session->Close();\r\ndelete session;\r\nsession = nil;\r\n```\r\nI tried setting some specific configuration options so I could be sure that the session did in fact own its thread pools instead of using a global thread pool, but this didn't help either:\r\n```objc++\r\ntensorflow::SessionOptions options;\r\noptions.config.clear_session_inter_op_thread_pool();\r\noptions.config.set_use_per_session_threads(true);\r\nauto status = tensorflow::NewSession(options, &session);\r\n```\r\n\r\nOne thing to note: while my understanding is that this isn't necessary, I did also try using a mutex to ensure that `Close` and `delete` would not be called concurrently with any call to `Run`, but again, no luck.\r\n\r\nThe only thing that *has* reduced CPU load to a reasonable level is to set `inter_op_parallelism_threads` to `1`. This doesn't resolve the underlying problem (that the threads are never cleaned up), but it *does* mean that the `Steal` loop is avoided, so the thread just blocks forever."}