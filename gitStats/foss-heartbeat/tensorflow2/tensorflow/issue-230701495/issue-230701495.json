{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/10134", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/10134/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/10134/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/10134/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/10134", "id": 230701495, "node_id": "MDU6SXNzdWUyMzA3MDE0OTU=", "number": 10134, "title": "C++ Tensor's Slice assignment works unexpectedly when using GPU", "user": {"login": "Zardinality", "id": 13702822, "node_id": "MDQ6VXNlcjEzNzAyODIy", "avatar_url": "https://avatars2.githubusercontent.com/u/13702822?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zardinality", "html_url": "https://github.com/Zardinality", "followers_url": "https://api.github.com/users/Zardinality/followers", "following_url": "https://api.github.com/users/Zardinality/following{/other_user}", "gists_url": "https://api.github.com/users/Zardinality/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zardinality/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zardinality/subscriptions", "organizations_url": "https://api.github.com/users/Zardinality/orgs", "repos_url": "https://api.github.com/users/Zardinality/repos", "events_url": "https://api.github.com/users/Zardinality/events{/privacy}", "received_events_url": "https://api.github.com/users/Zardinality/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2017-05-23T13:11:39Z", "updated_at": "2017-06-17T14:56:42Z", "closed_at": "2017-06-17T14:56:42Z", "author_association": "NONE", "body_html": "<h3>System information</h3>\n<ul>\n<li><strong>Have I written custom code (as opposed to using a stock example script provided in TensorFlow)</strong>:<br>\nYes</li>\n<li><strong>OS Platform and Distribution (e.g., Linux Ubuntu 16.04)</strong>:<br>\nLinux 3.16.0-4-amd64 <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"115886302\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/tensorflow/tensorflow/issues/1\" data-hovercard-type=\"issue\" data-hovercard-url=\"/tensorflow/tensorflow/issues/1/hovercard\" href=\"https://github.com/tensorflow/tensorflow/issues/1\">#1</a> SMP Debian 3.16.7-ckt20-1+deb8u2 (2016-01-02) x86_64 GNU/Linux</li>\n<li><strong>TensorFlow installed from (source or binary)</strong>:<br>\nbinary</li>\n<li><strong>TensorFlow version (use command below)</strong>:<br>\ntensorflow-gpu (1.1.0rc2)</li>\n<li><strong>Bazel version (if compiling from source)</strong>:<br>\nNone</li>\n<li><strong>CUDA/cuDNN version</strong>:<br>\ncuda 8.0</li>\n<li><strong>GPU model and memory</strong>:<br>\nGeForce GTX 1080 8110Mb</li>\n<li><strong>Exact command to reproduce</strong>:<br>\nSee below.</li>\n</ul>\n<h3>Describe the problem</h3>\n<p><code>tensorflow::Tensor::Slice</code> returns another <code>tensorflow::Tensor</code> , which is the slice of the original <code>Tensor</code> in the first dimension,  but if you assign a slice to another when writing operation with <code>GPUDevice</code> , it seems to fail to work like expected,</p>\n<p>In gist below I write a simple operation which set the output as the same value of input, by setting each slice of output in the first dimension to be the same of input. When registered only CPUKernel, this op works well, but when registered only GPUKernel, it gives some random values I had no idea with.</p>\n<p>I use <code>g++ -std=c++11 -shared -o CopyByBatchOp.so CopyByBatchOp.cc -I $TF_INC -fPIC -lcudart -L $CUDA_HOME/lib64 -D GOOGLE_CUDA=1 -Wfatal-e rrors -I $CUDA_HOME/include -D_GLIBCXX_USE_CXX11_ABI=0</code> to compile the operation, for both GPU version and CPU version.</p>\n<p>After compiling, I use <code>test_op = tf.load_op_library('CopyByBatchOp.so')</code> in Python to load it. A simple test script is included in gist below.</p>\n<p>FYI, I've been looking for a way to assign a slice of one tensor to another slice for a long time, Eigen tensors works well by <code>      output.slice(start, size).device(d) = input.slice(start, size);</code> with <code>d</code> as some <code>CPUDevice</code>, but somehow breakdown when I use a <code>GPUDevice</code>, could not figure out why since I don't know how to debug it. I guess maybe the two problems are relevant.</p>\n<h3>Source code / logs</h3>\n<p><a href=\"https://gist.github.com/Zardinality/616137e6edc309af57a3cbbb5032d848\">gist</a></p>", "body_text": "System information\n\nHave I written custom code (as opposed to using a stock example script provided in TensorFlow):\nYes\nOS Platform and Distribution (e.g., Linux Ubuntu 16.04):\nLinux 3.16.0-4-amd64 #1 SMP Debian 3.16.7-ckt20-1+deb8u2 (2016-01-02) x86_64 GNU/Linux\nTensorFlow installed from (source or binary):\nbinary\nTensorFlow version (use command below):\ntensorflow-gpu (1.1.0rc2)\nBazel version (if compiling from source):\nNone\nCUDA/cuDNN version:\ncuda 8.0\nGPU model and memory:\nGeForce GTX 1080 8110Mb\nExact command to reproduce:\nSee below.\n\nDescribe the problem\ntensorflow::Tensor::Slice returns another tensorflow::Tensor , which is the slice of the original Tensor in the first dimension,  but if you assign a slice to another when writing operation with GPUDevice , it seems to fail to work like expected,\nIn gist below I write a simple operation which set the output as the same value of input, by setting each slice of output in the first dimension to be the same of input. When registered only CPUKernel, this op works well, but when registered only GPUKernel, it gives some random values I had no idea with.\nI use g++ -std=c++11 -shared -o CopyByBatchOp.so CopyByBatchOp.cc -I $TF_INC -fPIC -lcudart -L $CUDA_HOME/lib64 -D GOOGLE_CUDA=1 -Wfatal-e rrors -I $CUDA_HOME/include -D_GLIBCXX_USE_CXX11_ABI=0 to compile the operation, for both GPU version and CPU version.\nAfter compiling, I use test_op = tf.load_op_library('CopyByBatchOp.so') in Python to load it. A simple test script is included in gist below.\nFYI, I've been looking for a way to assign a slice of one tensor to another slice for a long time, Eigen tensors works well by       output.slice(start, size).device(d) = input.slice(start, size); with d as some CPUDevice, but somehow breakdown when I use a GPUDevice, could not figure out why since I don't know how to debug it. I guess maybe the two problems are relevant.\nSource code / logs\ngist", "body": "### System information\r\n\r\n- **Have I written custom code (as opposed to using a stock example script provided in TensorFlow)**: \r\n  Yes\r\n- **OS Platform and Distribution (e.g., Linux Ubuntu 16.04)**: \r\n  Linux 3.16.0-4-amd64 #1 SMP Debian 3.16.7-ckt20-1+deb8u2 (2016-01-02) x86_64 GNU/Linux\r\n- **TensorFlow installed from (source or binary)**:\r\n  binary\r\n- **TensorFlow version (use command below)**:\r\n  tensorflow-gpu (1.1.0rc2)\r\n- **Bazel version (if compiling from source)**:\r\n  None\r\n- **CUDA/cuDNN version**:\r\n  cuda 8.0\r\n- **GPU model and memory**:\r\n  GeForce GTX 1080 8110Mb\r\n- **Exact command to reproduce**:\r\n  See below.\r\n\r\n### Describe the problem\r\n\r\n`tensorflow::Tensor::Slice` returns another `tensorflow::Tensor` , which is the slice of the original `Tensor` in the first dimension,  but if you assign a slice to another when writing operation with `GPUDevice` , it seems to fail to work like expected,\r\n\r\nIn gist below I write a simple operation which set the output as the same value of input, by setting each slice of output in the first dimension to be the same of input. When registered only CPUKernel, this op works well, but when registered only GPUKernel, it gives some random values I had no idea with.\r\n\r\nI use `g++ -std=c++11 -shared -o CopyByBatchOp.so CopyByBatchOp.cc -I $TF_INC -fPIC -lcudart -L $CUDA_HOME/lib64 -D GOOGLE_CUDA=1 -Wfatal-e\r\nrrors -I $CUDA_HOME/include -D_GLIBCXX_USE_CXX11_ABI=0` to compile the operation, for both GPU version and CPU version.\r\n\r\nAfter compiling, I use `test_op = tf.load_op_library('CopyByBatchOp.so')` in Python to load it. A simple test script is included in gist below.\r\n\r\n\r\n\r\nFYI, I've been looking for a way to assign a slice of one tensor to another slice for a long time, Eigen tensors works well by `      output.slice(start, size).device(d) = input.slice(start, size);` with `d` as some `CPUDevice`, but somehow breakdown when I use a `GPUDevice`, could not figure out why since I don't know how to debug it. I guess maybe the two problems are relevant.\r\n\r\n### Source code / logs\r\n\r\n[gist](https://gist.github.com/Zardinality/616137e6edc309af57a3cbbb5032d848)"}