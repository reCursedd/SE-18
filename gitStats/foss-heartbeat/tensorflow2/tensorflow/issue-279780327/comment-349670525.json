{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/349670525", "html_url": "https://github.com/tensorflow/tensorflow/issues/15158#issuecomment-349670525", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/15158", "id": 349670525, "node_id": "MDEyOklzc3VlQ29tbWVudDM0OTY3MDUyNQ==", "user": {"login": "maxfiedler", "id": 4192637, "node_id": "MDQ6VXNlcjQxOTI2Mzc=", "avatar_url": "https://avatars1.githubusercontent.com/u/4192637?v=4", "gravatar_id": "", "url": "https://api.github.com/users/maxfiedler", "html_url": "https://github.com/maxfiedler", "followers_url": "https://api.github.com/users/maxfiedler/followers", "following_url": "https://api.github.com/users/maxfiedler/following{/other_user}", "gists_url": "https://api.github.com/users/maxfiedler/gists{/gist_id}", "starred_url": "https://api.github.com/users/maxfiedler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/maxfiedler/subscriptions", "organizations_url": "https://api.github.com/users/maxfiedler/orgs", "repos_url": "https://api.github.com/users/maxfiedler/repos", "events_url": "https://api.github.com/users/maxfiedler/events{/privacy}", "received_events_url": "https://api.github.com/users/maxfiedler/received_events", "type": "User", "site_admin": false}, "created_at": "2017-12-06T15:18:18Z", "updated_at": "2017-12-06T15:18:18Z", "author_association": "NONE", "body_html": "<p>Simple solution could be: (in _HookedSession) marked with **</p>\n<pre><code>def run(self, fetches, feed_dict=None, options=None, run_metadata=None, **hooks_to_trigger=[None]**):\n    \"\"\"See base class.\"\"\"\n    if self.should_stop():\n      raise RuntimeError('Run called even after should_stop requested.')\n\n    actual_fetches = {'caller': fetches}\n\n    run_context = session_run_hook.SessionRunContext(\n        original_args=session_run_hook.SessionRunArgs(fetches, feed_dict),\n        session=self._sess)\n\n    options = options or config_pb2.RunOptions()\n    feed_dict = self._call_hook_before_run(run_context, actual_fetches,\n                                           feed_dict, options, **hooks_to_trigger**)\n\n    # Do session run.\n    run_metadata = run_metadata or config_pb2.RunMetadata()\n    outputs = _WrappedSession.run(self,\n                                  fetches=actual_fetches,\n                                  feed_dict=feed_dict,\n                                  options=options,\n                                  run_metadata=run_metadata)\n\n    for hook in **list(set(self._hooks).intersection(hooks_to_trigger))**:\n      hook.after_run(\n          run_context,\n          session_run_hook.SessionRunValues(\n              results=outputs[hook] if hook in outputs else None,\n              options=options,\n              run_metadata=run_metadata))\n    self._should_stop = self._should_stop or run_context.stop_requested\n\nreturn outputs['caller']\n</code></pre>", "body_text": "Simple solution could be: (in _HookedSession) marked with **\ndef run(self, fetches, feed_dict=None, options=None, run_metadata=None, **hooks_to_trigger=[None]**):\n    \"\"\"See base class.\"\"\"\n    if self.should_stop():\n      raise RuntimeError('Run called even after should_stop requested.')\n\n    actual_fetches = {'caller': fetches}\n\n    run_context = session_run_hook.SessionRunContext(\n        original_args=session_run_hook.SessionRunArgs(fetches, feed_dict),\n        session=self._sess)\n\n    options = options or config_pb2.RunOptions()\n    feed_dict = self._call_hook_before_run(run_context, actual_fetches,\n                                           feed_dict, options, **hooks_to_trigger**)\n\n    # Do session run.\n    run_metadata = run_metadata or config_pb2.RunMetadata()\n    outputs = _WrappedSession.run(self,\n                                  fetches=actual_fetches,\n                                  feed_dict=feed_dict,\n                                  options=options,\n                                  run_metadata=run_metadata)\n\n    for hook in **list(set(self._hooks).intersection(hooks_to_trigger))**:\n      hook.after_run(\n          run_context,\n          session_run_hook.SessionRunValues(\n              results=outputs[hook] if hook in outputs else None,\n              options=options,\n              run_metadata=run_metadata))\n    self._should_stop = self._should_stop or run_context.stop_requested\n\nreturn outputs['caller']", "body": "Simple solution could be: (in _HookedSession) marked with **\r\n```\r\ndef run(self, fetches, feed_dict=None, options=None, run_metadata=None, **hooks_to_trigger=[None]**):\r\n    \"\"\"See base class.\"\"\"\r\n    if self.should_stop():\r\n      raise RuntimeError('Run called even after should_stop requested.')\r\n\r\n    actual_fetches = {'caller': fetches}\r\n\r\n    run_context = session_run_hook.SessionRunContext(\r\n        original_args=session_run_hook.SessionRunArgs(fetches, feed_dict),\r\n        session=self._sess)\r\n\r\n    options = options or config_pb2.RunOptions()\r\n    feed_dict = self._call_hook_before_run(run_context, actual_fetches,\r\n                                           feed_dict, options, **hooks_to_trigger**)\r\n\r\n    # Do session run.\r\n    run_metadata = run_metadata or config_pb2.RunMetadata()\r\n    outputs = _WrappedSession.run(self,\r\n                                  fetches=actual_fetches,\r\n                                  feed_dict=feed_dict,\r\n                                  options=options,\r\n                                  run_metadata=run_metadata)\r\n\r\n    for hook in **list(set(self._hooks).intersection(hooks_to_trigger))**:\r\n      hook.after_run(\r\n          run_context,\r\n          session_run_hook.SessionRunValues(\r\n              results=outputs[hook] if hook in outputs else None,\r\n              options=options,\r\n              run_metadata=run_metadata))\r\n    self._should_stop = self._should_stop or run_context.stop_requested\r\n\r\nreturn outputs['caller']\r\n```\r\n"}