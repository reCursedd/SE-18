{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/15158", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/15158/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/15158/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/15158/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/15158", "id": 279780327, "node_id": "MDU6SXNzdWUyNzk3ODAzMjc=", "number": 15158, "title": "Feature: MonitoredSession should have run() method with 'hooks_to_trigger' argument: run(..., hooks_to_trigger=[hooks[1], hooks[3], ...])", "user": {"login": "maxfiedler", "id": 4192637, "node_id": "MDQ6VXNlcjQxOTI2Mzc=", "avatar_url": "https://avatars1.githubusercontent.com/u/4192637?v=4", "gravatar_id": "", "url": "https://api.github.com/users/maxfiedler", "html_url": "https://github.com/maxfiedler", "followers_url": "https://api.github.com/users/maxfiedler/followers", "following_url": "https://api.github.com/users/maxfiedler/following{/other_user}", "gists_url": "https://api.github.com/users/maxfiedler/gists{/gist_id}", "starred_url": "https://api.github.com/users/maxfiedler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/maxfiedler/subscriptions", "organizations_url": "https://api.github.com/users/maxfiedler/orgs", "repos_url": "https://api.github.com/users/maxfiedler/repos", "events_url": "https://api.github.com/users/maxfiedler/events{/privacy}", "received_events_url": "https://api.github.com/users/maxfiedler/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 8, "created_at": "2017-12-06T14:50:46Z", "updated_at": "2017-12-11T18:12:23Z", "closed_at": "2017-12-06T17:05:57Z", "author_association": "NONE", "body_html": "<p>At the moment the session_run_hooks are passed to the constructor of MonitoredSession(..., hooks=[...])<br>\nand then they get executed for EVERY session.run() call within the MonitoredSession block.</p>\n<p>This is inefficient and problematic.</p>\n<p>E.g., if I define a LoggingTensorHook, I want the logging output to be evaluated and printed at most ONCE per global step and not after some auxiliary session.run() calls that only evaluate the size of some queue or whatever else.</p>\n<p>If you use feedable iterators, the current MonitoredSession implementation actually crashes the program, see <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"255772759\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/tensorflow/tensorflow/issues/12859\" data-hovercard-type=\"issue\" data-hovercard-url=\"/tensorflow/tensorflow/issues/12859/hovercard?comment_id=348290076&amp;comment_type=issue_comment\" href=\"https://github.com/tensorflow/tensorflow/issues/12859#issuecomment-348290076\">#12859 (comment)</a></p>\n<p>The best solution in my opinion would be, to be able to specify which run() calls should actually trigger the before_run and after_run methods of the hooks, e.g. via some flag-argument in MonitoredSession.run(..., execute_hooks=True)<br>\nor alternatively pass a list of specific hooks whose before_run and after_run methods should be triggered by a run call, via MonitoredSession.run(..., hooks_to_trigger=[...])</p>", "body_text": "At the moment the session_run_hooks are passed to the constructor of MonitoredSession(..., hooks=[...])\nand then they get executed for EVERY session.run() call within the MonitoredSession block.\nThis is inefficient and problematic.\nE.g., if I define a LoggingTensorHook, I want the logging output to be evaluated and printed at most ONCE per global step and not after some auxiliary session.run() calls that only evaluate the size of some queue or whatever else.\nIf you use feedable iterators, the current MonitoredSession implementation actually crashes the program, see #12859 (comment)\nThe best solution in my opinion would be, to be able to specify which run() calls should actually trigger the before_run and after_run methods of the hooks, e.g. via some flag-argument in MonitoredSession.run(..., execute_hooks=True)\nor alternatively pass a list of specific hooks whose before_run and after_run methods should be triggered by a run call, via MonitoredSession.run(..., hooks_to_trigger=[...])", "body": "At the moment the session_run_hooks are passed to the constructor of MonitoredSession(..., hooks=[...]) \r\nand then they get executed for EVERY session.run() call within the MonitoredSession block.\r\n\r\nThis is inefficient and problematic.\r\n\r\nE.g., if I define a LoggingTensorHook, I want the logging output to be evaluated and printed at most ONCE per global step and not after some auxiliary session.run() calls that only evaluate the size of some queue or whatever else.\r\n\r\nIf you use feedable iterators, the current MonitoredSession implementation actually crashes the program, see https://github.com/tensorflow/tensorflow/issues/12859#issuecomment-348290076\r\n\r\nThe best solution in my opinion would be, to be able to specify which run() calls should actually trigger the before_run and after_run methods of the hooks, e.g. via some flag-argument in MonitoredSession.run(..., execute_hooks=True)\r\nor alternatively pass a list of specific hooks whose before_run and after_run methods should be triggered by a run call, via MonitoredSession.run(..., hooks_to_trigger=[...])\r\n"}