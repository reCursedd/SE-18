{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/246883990", "html_url": "https://github.com/tensorflow/tensorflow/issues/4359#issuecomment-246883990", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/4359", "id": 246883990, "node_id": "MDEyOklzc3VlQ29tbWVudDI0Njg4Mzk5MA==", "user": {"login": "aidan-plenert-macdonald", "id": 6690599, "node_id": "MDQ6VXNlcjY2OTA1OTk=", "avatar_url": "https://avatars2.githubusercontent.com/u/6690599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aidan-plenert-macdonald", "html_url": "https://github.com/aidan-plenert-macdonald", "followers_url": "https://api.github.com/users/aidan-plenert-macdonald/followers", "following_url": "https://api.github.com/users/aidan-plenert-macdonald/following{/other_user}", "gists_url": "https://api.github.com/users/aidan-plenert-macdonald/gists{/gist_id}", "starred_url": "https://api.github.com/users/aidan-plenert-macdonald/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aidan-plenert-macdonald/subscriptions", "organizations_url": "https://api.github.com/users/aidan-plenert-macdonald/orgs", "repos_url": "https://api.github.com/users/aidan-plenert-macdonald/repos", "events_url": "https://api.github.com/users/aidan-plenert-macdonald/events{/privacy}", "received_events_url": "https://api.github.com/users/aidan-plenert-macdonald/received_events", "type": "User", "site_admin": false}, "created_at": "2016-09-14T02:04:58Z", "updated_at": "2016-09-14T02:04:58Z", "author_association": "NONE", "body_html": "<p>Few questions.</p>\n<h2>About Feature Request</h2>\n<p>By dynamically, I assume you are referring to at compile time, but self-contained code changes. If you mean at runtime via dynamic module loading, I don't know off hand how to do this, but I think we can figure it out.</p>\n<p>How do you wish to handle the kernel code? Should I plan to have new hardware supported by developers modifying the <code>tensorflow/core/kernels/*</code> and registering the new hardware? Or do you want this also separated. Although this currently is handled with macros and registration systems in the C++, but I ask from a build perspective. We could make a new folder that contains all the code for extra devices and contains all the build scripts over there. It this is done, I can write template files that have all the basic structural code (many projects do this for configuration scripts) that a user could basically rename and be ready to go.</p>\n<h2>About TensorFlow</h2>\n<p><a href=\"http://stackoverflow.com/questions/39481453/tensorflow-device-contexts-streams-and-context-switching\" rel=\"nofollow\">TensorFlow Device Contexts, Streams, and Context Switching</a></p>", "body_text": "Few questions.\nAbout Feature Request\nBy dynamically, I assume you are referring to at compile time, but self-contained code changes. If you mean at runtime via dynamic module loading, I don't know off hand how to do this, but I think we can figure it out.\nHow do you wish to handle the kernel code? Should I plan to have new hardware supported by developers modifying the tensorflow/core/kernels/* and registering the new hardware? Or do you want this also separated. Although this currently is handled with macros and registration systems in the C++, but I ask from a build perspective. We could make a new folder that contains all the code for extra devices and contains all the build scripts over there. It this is done, I can write template files that have all the basic structural code (many projects do this for configuration scripts) that a user could basically rename and be ready to go.\nAbout TensorFlow\nTensorFlow Device Contexts, Streams, and Context Switching", "body": "Few questions.\n\n## About Feature Request\n\nBy dynamically, I assume you are referring to at compile time, but self-contained code changes. If you mean at runtime via dynamic module loading, I don't know off hand how to do this, but I think we can figure it out.\n\nHow do you wish to handle the kernel code? Should I plan to have new hardware supported by developers modifying the `tensorflow/core/kernels/*` and registering the new hardware? Or do you want this also separated. Although this currently is handled with macros and registration systems in the C++, but I ask from a build perspective. We could make a new folder that contains all the code for extra devices and contains all the build scripts over there. It this is done, I can write template files that have all the basic structural code (many projects do this for configuration scripts) that a user could basically rename and be ready to go.\n\n## About TensorFlow\n\n[TensorFlow Device Contexts, Streams, and Context Switching](http://stackoverflow.com/questions/39481453/tensorflow-device-contexts-streams-and-context-switching)\n"}