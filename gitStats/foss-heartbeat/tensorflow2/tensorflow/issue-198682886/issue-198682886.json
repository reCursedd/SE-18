{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/6634", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/6634/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/6634/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/6634/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/6634", "id": 198682886, "node_id": "MDU6SXNzdWUxOTg2ODI4ODY=", "number": 6634, "title": "Nestable custom_getters", "user": {"login": "tarvaina", "id": 2739, "node_id": "MDQ6VXNlcjI3Mzk=", "avatar_url": "https://avatars1.githubusercontent.com/u/2739?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tarvaina", "html_url": "https://github.com/tarvaina", "followers_url": "https://api.github.com/users/tarvaina/followers", "following_url": "https://api.github.com/users/tarvaina/following{/other_user}", "gists_url": "https://api.github.com/users/tarvaina/gists{/gist_id}", "starred_url": "https://api.github.com/users/tarvaina/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tarvaina/subscriptions", "organizations_url": "https://api.github.com/users/tarvaina/orgs", "repos_url": "https://api.github.com/users/tarvaina/repos", "events_url": "https://api.github.com/users/tarvaina/events{/privacy}", "received_events_url": "https://api.github.com/users/tarvaina/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 299643928, "node_id": "MDU6TGFiZWwyOTk2NDM5Mjg=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:contributions%20welcome", "name": "stat:contributions welcome", "color": "f4b400", "default": false}, {"id": 473173272, "node_id": "MDU6TGFiZWw0NzMxNzMyNzI=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:feature", "name": "type:feature", "color": "159b2e", "default": false}], "state": "closed", "locked": false, "assignee": {"login": "ebrevdo", "id": 1794715, "node_id": "MDQ6VXNlcjE3OTQ3MTU=", "avatar_url": "https://avatars0.githubusercontent.com/u/1794715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebrevdo", "html_url": "https://github.com/ebrevdo", "followers_url": "https://api.github.com/users/ebrevdo/followers", "following_url": "https://api.github.com/users/ebrevdo/following{/other_user}", "gists_url": "https://api.github.com/users/ebrevdo/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebrevdo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebrevdo/subscriptions", "organizations_url": "https://api.github.com/users/ebrevdo/orgs", "repos_url": "https://api.github.com/users/ebrevdo/repos", "events_url": "https://api.github.com/users/ebrevdo/events{/privacy}", "received_events_url": "https://api.github.com/users/ebrevdo/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "ebrevdo", "id": 1794715, "node_id": "MDQ6VXNlcjE3OTQ3MTU=", "avatar_url": "https://avatars0.githubusercontent.com/u/1794715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebrevdo", "html_url": "https://github.com/ebrevdo", "followers_url": "https://api.github.com/users/ebrevdo/followers", "following_url": "https://api.github.com/users/ebrevdo/following{/other_user}", "gists_url": "https://api.github.com/users/ebrevdo/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebrevdo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebrevdo/subscriptions", "organizations_url": "https://api.github.com/users/ebrevdo/orgs", "repos_url": "https://api.github.com/users/ebrevdo/repos", "events_url": "https://api.github.com/users/ebrevdo/events{/privacy}", "received_events_url": "https://api.github.com/users/ebrevdo/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 6, "created_at": "2017-01-04T11:07:00Z", "updated_at": "2017-08-11T07:26:34Z", "closed_at": "2017-08-11T07:26:34Z", "author_association": "NONE", "body_html": "<p>In TF 0.12 (and probably in earlier versions too), only one custom_getter is active at a time:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">import</span> tensorflow <span class=\"pl-k\">as</span> tf\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">postfix_name</span>(<span class=\"pl-smi\">postfix</span>):\n    <span class=\"pl-k\">def</span> <span class=\"pl-en\">custom_getter</span>(<span class=\"pl-smi\">getter</span>, <span class=\"pl-smi\">name</span>, <span class=\"pl-k\">*</span><span class=\"pl-smi\">args</span>, <span class=\"pl-k\">**</span><span class=\"pl-smi\">kwargs</span>):\n        <span class=\"pl-k\">return</span> getter(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"pl-c1\">{}{}</span><span class=\"pl-pds\">\"</span></span>.format(name, postfix), <span class=\"pl-k\">*</span>args, <span class=\"pl-k\">**</span>kwargs)\n    <span class=\"pl-k\">return</span> custom_getter\n\n<span class=\"pl-k\">with</span> tf.Graph().as_default():\n    <span class=\"pl-k\">with</span> tf.variable_scope(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>A<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-v\">custom_getter</span><span class=\"pl-k\">=</span>postfix_name(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>_A<span class=\"pl-pds\">\"</span></span>)):\n        <span class=\"pl-k\">with</span> tf.variable_scope(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>B<span class=\"pl-pds\">\"</span></span>):\n            var1 <span class=\"pl-k\">=</span> tf.get_variable(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>var1<span class=\"pl-pds\">\"</span></span>, [])\n        <span class=\"pl-k\">with</span> tf.variable_scope(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>C<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-v\">custom_getter</span><span class=\"pl-k\">=</span>postfix_name(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>_C<span class=\"pl-pds\">\"</span></span>)):\n            var2 <span class=\"pl-k\">=</span> tf.get_variable(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>var2<span class=\"pl-pds\">\"</span></span>, [])\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> Current functionality:</span>\n<span class=\"pl-k\">assert</span> tf.<span class=\"pl-c1\">VERSION</span> <span class=\"pl-k\">==</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>0.12.1<span class=\"pl-pds\">'</span></span>\n<span class=\"pl-k\">assert</span> var1.name <span class=\"pl-k\">==</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>A/B/var1_A:0<span class=\"pl-pds\">'</span></span>\n<span class=\"pl-k\">assert</span> var2.name <span class=\"pl-k\">==</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>A/C/var2_C:0<span class=\"pl-pds\">'</span></span></pre></div>\n<p>This is surprising to the user \u2013 at least to me it was \u2013 and limits the usefulness of custom_getters.</p>\n<p>I propose that nested custom_getters are applied recursively instead, like this:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-c\"><span class=\"pl-c\">#</span> Proposal:</span>\n<span class=\"pl-k\">assert</span> var1.name <span class=\"pl-k\">==</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>A/B/var1_A:0<span class=\"pl-pds\">'</span></span>\n<span class=\"pl-k\">assert</span> var2.name <span class=\"pl-k\">==</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>A/C/var2_C_A:0<span class=\"pl-pds\">'</span></span></pre></div>\n<p>This would be useful since we often want to apply different transformations to weights before they are used. Here's a pseudo-code of a real-life use case:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">with</span> tf.variable_scope(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>weight_normed<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-v\">custom_getter</span><span class=\"pl-k\">=</span>weight_normed):\n    <span class=\"pl-k\">with</span> tf.variable_scope(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>model<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-v\">custom_getter</span><span class=\"pl-k\">=</span>track_variables):\n        real_out <span class=\"pl-k\">=</span> model(x)\n    <span class=\"pl-k\">with</span> tf.variable_scope(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>model<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-v\">custom_getter</span><span class=\"pl-k\">=</span>simulate_variables):\n        simulated_out <span class=\"pl-k\">=</span> model(x)</pre></div>", "body_text": "In TF 0.12 (and probably in earlier versions too), only one custom_getter is active at a time:\nimport tensorflow as tf\n\ndef postfix_name(postfix):\n    def custom_getter(getter, name, *args, **kwargs):\n        return getter(\"{}{}\".format(name, postfix), *args, **kwargs)\n    return custom_getter\n\nwith tf.Graph().as_default():\n    with tf.variable_scope(\"A\", custom_getter=postfix_name(\"_A\")):\n        with tf.variable_scope(\"B\"):\n            var1 = tf.get_variable(\"var1\", [])\n        with tf.variable_scope(\"C\", custom_getter=postfix_name(\"_C\")):\n            var2 = tf.get_variable(\"var2\", [])\n\n# Current functionality:\nassert tf.VERSION == '0.12.1'\nassert var1.name == 'A/B/var1_A:0'\nassert var2.name == 'A/C/var2_C:0'\nThis is surprising to the user \u2013 at least to me it was \u2013 and limits the usefulness of custom_getters.\nI propose that nested custom_getters are applied recursively instead, like this:\n# Proposal:\nassert var1.name == 'A/B/var1_A:0'\nassert var2.name == 'A/C/var2_C_A:0'\nThis would be useful since we often want to apply different transformations to weights before they are used. Here's a pseudo-code of a real-life use case:\nwith tf.variable_scope(\"weight_normed\", custom_getter=weight_normed):\n    with tf.variable_scope(\"model\", custom_getter=track_variables):\n        real_out = model(x)\n    with tf.variable_scope(\"model\", custom_getter=simulate_variables):\n        simulated_out = model(x)", "body": "In TF 0.12 (and probably in earlier versions too), only one custom_getter is active at a time:\r\n\r\n```python\r\nimport tensorflow as tf\r\n\r\ndef postfix_name(postfix):\r\n    def custom_getter(getter, name, *args, **kwargs):\r\n        return getter(\"{}{}\".format(name, postfix), *args, **kwargs)\r\n    return custom_getter\r\n\r\nwith tf.Graph().as_default():\r\n    with tf.variable_scope(\"A\", custom_getter=postfix_name(\"_A\")):\r\n        with tf.variable_scope(\"B\"):\r\n            var1 = tf.get_variable(\"var1\", [])\r\n        with tf.variable_scope(\"C\", custom_getter=postfix_name(\"_C\")):\r\n            var2 = tf.get_variable(\"var2\", [])\r\n\r\n# Current functionality:\r\nassert tf.VERSION == '0.12.1'\r\nassert var1.name == 'A/B/var1_A:0'\r\nassert var2.name == 'A/C/var2_C:0'\r\n```\r\n\r\nThis is surprising to the user \u2013 at least to me it was \u2013 and limits the usefulness of custom_getters.\r\n\r\nI propose that nested custom_getters are applied recursively instead, like this:\r\n\r\n```python\r\n# Proposal:\r\nassert var1.name == 'A/B/var1_A:0'\r\nassert var2.name == 'A/C/var2_C_A:0'\r\n```\r\n\r\nThis would be useful since we often want to apply different transformations to weights before they are used. Here's a pseudo-code of a real-life use case:\r\n\r\n```python\r\nwith tf.variable_scope(\"weight_normed\", custom_getter=weight_normed):\r\n    with tf.variable_scope(\"model\", custom_getter=track_variables):\r\n        real_out = model(x)\r\n    with tf.variable_scope(\"model\", custom_getter=simulate_variables):\r\n        simulated_out = model(x)\r\n```"}