{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/377890718", "html_url": "https://github.com/tensorflow/tensorflow/issues/18080#issuecomment-377890718", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/18080", "id": 377890718, "node_id": "MDEyOklzc3VlQ29tbWVudDM3Nzg5MDcxOA==", "user": {"login": "jinay1991", "id": 9047750, "node_id": "MDQ6VXNlcjkwNDc3NTA=", "avatar_url": "https://avatars2.githubusercontent.com/u/9047750?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jinay1991", "html_url": "https://github.com/jinay1991", "followers_url": "https://api.github.com/users/jinay1991/followers", "following_url": "https://api.github.com/users/jinay1991/following{/other_user}", "gists_url": "https://api.github.com/users/jinay1991/gists{/gist_id}", "starred_url": "https://api.github.com/users/jinay1991/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jinay1991/subscriptions", "organizations_url": "https://api.github.com/users/jinay1991/orgs", "repos_url": "https://api.github.com/users/jinay1991/repos", "events_url": "https://api.github.com/users/jinay1991/events{/privacy}", "received_events_url": "https://api.github.com/users/jinay1991/received_events", "type": "User", "site_admin": false}, "created_at": "2018-04-02T09:10:07Z", "updated_at": "2018-04-02T09:11:11Z", "author_association": "NONE", "body_html": "<pre><code>with tf.gfile.GFile(model_filename1, \"rb\") as f:\n    graph_def = tf.GraphDef()\n    graph_def.ParseFromString(f.read())\n\nwith tf.Graph().as_default() as graph1:\n    tf.import_graph_def(graph_def)\n\nwith tf.gfile.GFile(model_filename2, \"rb\") as f:\n    graph_def = tf.GraphDef()\n    graph_def.ParseFromString(f.read())\n\nwith tf.Graph().as_default() as graph2:\n    tf.import_graph_def(graph_def)\n\nsess1 = tf.Session(graph=graph1)\nsess2 = tf.Session(graph=graph2)\n</code></pre>\n<p>Above code might not work as it is, as I have not got chance to test these. But idea was that we can create two session type object for each models and call their run methods, obviously if you are using CUDA Hardware you will be blocked by calling run() if both called same time due to locking mechanism set by CUDA HW (CUDA_VISIBLE_DEVICES). But you can run this by setting Queue or calling run() one after another.</p>\n<p>I have loaded two graphs on same GPU (one graph was for preprocessing and another one was object classification) and it worked well for me. (I called run() one after another as I required output of 1st graph to be fed in to 2nd).</p>\n<p>Hope you get idea.</p>", "body_text": "with tf.gfile.GFile(model_filename1, \"rb\") as f:\n    graph_def = tf.GraphDef()\n    graph_def.ParseFromString(f.read())\n\nwith tf.Graph().as_default() as graph1:\n    tf.import_graph_def(graph_def)\n\nwith tf.gfile.GFile(model_filename2, \"rb\") as f:\n    graph_def = tf.GraphDef()\n    graph_def.ParseFromString(f.read())\n\nwith tf.Graph().as_default() as graph2:\n    tf.import_graph_def(graph_def)\n\nsess1 = tf.Session(graph=graph1)\nsess2 = tf.Session(graph=graph2)\n\nAbove code might not work as it is, as I have not got chance to test these. But idea was that we can create two session type object for each models and call their run methods, obviously if you are using CUDA Hardware you will be blocked by calling run() if both called same time due to locking mechanism set by CUDA HW (CUDA_VISIBLE_DEVICES). But you can run this by setting Queue or calling run() one after another.\nI have loaded two graphs on same GPU (one graph was for preprocessing and another one was object classification) and it worked well for me. (I called run() one after another as I required output of 1st graph to be fed in to 2nd).\nHope you get idea.", "body": "```\r\nwith tf.gfile.GFile(model_filename1, \"rb\") as f:\r\n    graph_def = tf.GraphDef()\r\n    graph_def.ParseFromString(f.read())\r\n\r\nwith tf.Graph().as_default() as graph1:\r\n    tf.import_graph_def(graph_def)\r\n\r\nwith tf.gfile.GFile(model_filename2, \"rb\") as f:\r\n    graph_def = tf.GraphDef()\r\n    graph_def.ParseFromString(f.read())\r\n\r\nwith tf.Graph().as_default() as graph2:\r\n    tf.import_graph_def(graph_def)\r\n\r\nsess1 = tf.Session(graph=graph1)\r\nsess2 = tf.Session(graph=graph2)\r\n```\r\n\r\nAbove code might not work as it is, as I have not got chance to test these. But idea was that we can create two session type object for each models and call their run methods, obviously if you are using CUDA Hardware you will be blocked by calling run() if both called same time due to locking mechanism set by CUDA HW (CUDA_VISIBLE_DEVICES). But you can run this by setting Queue or calling run() one after another.\r\n\r\nI have loaded two graphs on same GPU (one graph was for preprocessing and another one was object classification) and it worked well for me. (I called run() one after another as I required output of 1st graph to be fed in to 2nd).\r\n\r\nHope you get idea."}