{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/415487579", "html_url": "https://github.com/tensorflow/tensorflow/issues/21582#issuecomment-415487579", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/21582", "id": 415487579, "node_id": "MDEyOklzc3VlQ29tbWVudDQxNTQ4NzU3OQ==", "user": {"login": "jkeller-miovision", "id": 12238721, "node_id": "MDQ6VXNlcjEyMjM4NzIx", "avatar_url": "https://avatars2.githubusercontent.com/u/12238721?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jkeller-miovision", "html_url": "https://github.com/jkeller-miovision", "followers_url": "https://api.github.com/users/jkeller-miovision/followers", "following_url": "https://api.github.com/users/jkeller-miovision/following{/other_user}", "gists_url": "https://api.github.com/users/jkeller-miovision/gists{/gist_id}", "starred_url": "https://api.github.com/users/jkeller-miovision/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jkeller-miovision/subscriptions", "organizations_url": "https://api.github.com/users/jkeller-miovision/orgs", "repos_url": "https://api.github.com/users/jkeller-miovision/repos", "events_url": "https://api.github.com/users/jkeller-miovision/events{/privacy}", "received_events_url": "https://api.github.com/users/jkeller-miovision/received_events", "type": "User", "site_admin": false}, "created_at": "2018-08-23T16:48:16Z", "updated_at": "2018-08-23T16:48:16Z", "author_association": "NONE", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=20959853\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/drpngx\">@drpngx</a> Sorry for the delay in getting back to you.</p>\n<p>Python is not involved this application.  This is a C++ executable which links against the TF C api.   To reproduce the issue, I think you may need concurrent invocations of TF_SessionRun().  I re-ran with the Google provided binaries, and here is a sample strack trace:</p>\n<pre><code>==1151== 400 bytes in 1 blocks are possibly lost in loss record 83,360 of 85,527\n==1151==    at 0x4C2DBF6: malloc (vg_replace_malloc.c:299)\n==1151==    by 0xD68CC34: nsync::nsync_waiter_new_() (in /usr/local/lib/libtensorflow_framework.so)\n==1151==    by 0xD68E6F1: nsync::nsync_mu_lock(nsync::nsync_mu_s_*) (in /usr/local/lib/libtensorflow_framework.so)\n==1151==    by 0x52577A6: tensorflow::ExtendSessionGraphHelper(TF_Session*, TF_Status*) (in /usr/local/lib/libtensorflow.so)\n==1151==    by 0x52599B0: TF_SessionRun (in /usr/local/lib/libtensorflow.so)\n==1151==    by 0x4E9A5C: streamagent::SSD::detect(std::vector&lt;miocv::PixelView&lt;miocv::RGBA8888&gt;, std::allocator&lt;miocv::PixelView&lt;miocv::RGBA8888&gt; &gt; &gt; const&amp;, std::vector&lt;std::vector&lt;streamagent::ObjectDetectorBox, std::allocator&lt;streamagent::ObjectDetectorBox&gt; &gt;*, std::allocator&lt;std::vector&lt;streamagent::ObjectDetectorBox, std::allocator&lt;streamagent::ObjectDetectorBox&gt; &gt;*&gt; &gt; const&amp;, double) (in /home/ubuntu/miocv-builder/build/components/streamagent/streamagent-integration_tests)\n==1151==    by 0x49A70B: streamagent::RunningPipeline::pipelineThreadMain(long, long) (in /home/ubuntu/miocv-builder/build/components/streamagent/streamagent-integration_tests)\n==1151==    by 0xBF97C7F: ??? (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21)\n==1151==    by 0xC7876B9: start_thread (pthread_create.c:333)\n==1151==    by 0xCAA441C: clone (clone.S:109)\n==1151== \n{\n   &lt;insert_a_suppression_name_here&gt;\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:malloc\n   fun:_ZN5nsync17nsync_waiter_new_Ev\n   fun:_ZN5nsync13nsync_mu_lockEPNS_11nsync_mu_s_E\n   fun:_ZN10tensorflow24ExtendSessionGraphHelperEP10TF_SessionP9TF_Status\n   fun:TF_SessionRun\n   fun:_ZN11streamagent3SSD6detectERKSt6vectorIN5miocv9PixelViewINS2_8RGBA8888EEESaIS5_EERKS1_IPS1_INS_17ObjectDetectorBoxESaISA_EESaISD_EEd\n   fun:_ZN11streamagent15RunningPipeline18pipelineThreadMainEll\n   obj:/usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21\n   fun:start_thread\n   fun:clone\n}\n</code></pre>\n<p>The same leak occurs in different contexts as well.   As you can see, memory is being allocated in nsync::nsync_waiter_new_().   As I mentioned in my first post, I can see by inspection of <a href=\"https://github.com/google/nsync/blob/master/internal/common.c\">https://github.com/google/nsync/blob/master/internal/common.c</a> that the memory is not deallocated in this case.</p>", "body_text": "@drpngx Sorry for the delay in getting back to you.\nPython is not involved this application.  This is a C++ executable which links against the TF C api.   To reproduce the issue, I think you may need concurrent invocations of TF_SessionRun().  I re-ran with the Google provided binaries, and here is a sample strack trace:\n==1151== 400 bytes in 1 blocks are possibly lost in loss record 83,360 of 85,527\n==1151==    at 0x4C2DBF6: malloc (vg_replace_malloc.c:299)\n==1151==    by 0xD68CC34: nsync::nsync_waiter_new_() (in /usr/local/lib/libtensorflow_framework.so)\n==1151==    by 0xD68E6F1: nsync::nsync_mu_lock(nsync::nsync_mu_s_*) (in /usr/local/lib/libtensorflow_framework.so)\n==1151==    by 0x52577A6: tensorflow::ExtendSessionGraphHelper(TF_Session*, TF_Status*) (in /usr/local/lib/libtensorflow.so)\n==1151==    by 0x52599B0: TF_SessionRun (in /usr/local/lib/libtensorflow.so)\n==1151==    by 0x4E9A5C: streamagent::SSD::detect(std::vector<miocv::PixelView<miocv::RGBA8888>, std::allocator<miocv::PixelView<miocv::RGBA8888> > > const&, std::vector<std::vector<streamagent::ObjectDetectorBox, std::allocator<streamagent::ObjectDetectorBox> >*, std::allocator<std::vector<streamagent::ObjectDetectorBox, std::allocator<streamagent::ObjectDetectorBox> >*> > const&, double) (in /home/ubuntu/miocv-builder/build/components/streamagent/streamagent-integration_tests)\n==1151==    by 0x49A70B: streamagent::RunningPipeline::pipelineThreadMain(long, long) (in /home/ubuntu/miocv-builder/build/components/streamagent/streamagent-integration_tests)\n==1151==    by 0xBF97C7F: ??? (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21)\n==1151==    by 0xC7876B9: start_thread (pthread_create.c:333)\n==1151==    by 0xCAA441C: clone (clone.S:109)\n==1151== \n{\n   <insert_a_suppression_name_here>\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:malloc\n   fun:_ZN5nsync17nsync_waiter_new_Ev\n   fun:_ZN5nsync13nsync_mu_lockEPNS_11nsync_mu_s_E\n   fun:_ZN10tensorflow24ExtendSessionGraphHelperEP10TF_SessionP9TF_Status\n   fun:TF_SessionRun\n   fun:_ZN11streamagent3SSD6detectERKSt6vectorIN5miocv9PixelViewINS2_8RGBA8888EEESaIS5_EERKS1_IPS1_INS_17ObjectDetectorBoxESaISA_EESaISD_EEd\n   fun:_ZN11streamagent15RunningPipeline18pipelineThreadMainEll\n   obj:/usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21\n   fun:start_thread\n   fun:clone\n}\n\nThe same leak occurs in different contexts as well.   As you can see, memory is being allocated in nsync::nsync_waiter_new_().   As I mentioned in my first post, I can see by inspection of https://github.com/google/nsync/blob/master/internal/common.c that the memory is not deallocated in this case.", "body": "@drpngx Sorry for the delay in getting back to you.\r\n\r\nPython is not involved this application.  This is a C++ executable which links against the TF C api.   To reproduce the issue, I think you may need concurrent invocations of TF_SessionRun().  I re-ran with the Google provided binaries, and here is a sample strack trace:\r\n\r\n```\r\n==1151== 400 bytes in 1 blocks are possibly lost in loss record 83,360 of 85,527\r\n==1151==    at 0x4C2DBF6: malloc (vg_replace_malloc.c:299)\r\n==1151==    by 0xD68CC34: nsync::nsync_waiter_new_() (in /usr/local/lib/libtensorflow_framework.so)\r\n==1151==    by 0xD68E6F1: nsync::nsync_mu_lock(nsync::nsync_mu_s_*) (in /usr/local/lib/libtensorflow_framework.so)\r\n==1151==    by 0x52577A6: tensorflow::ExtendSessionGraphHelper(TF_Session*, TF_Status*) (in /usr/local/lib/libtensorflow.so)\r\n==1151==    by 0x52599B0: TF_SessionRun (in /usr/local/lib/libtensorflow.so)\r\n==1151==    by 0x4E9A5C: streamagent::SSD::detect(std::vector<miocv::PixelView<miocv::RGBA8888>, std::allocator<miocv::PixelView<miocv::RGBA8888> > > const&, std::vector<std::vector<streamagent::ObjectDetectorBox, std::allocator<streamagent::ObjectDetectorBox> >*, std::allocator<std::vector<streamagent::ObjectDetectorBox, std::allocator<streamagent::ObjectDetectorBox> >*> > const&, double) (in /home/ubuntu/miocv-builder/build/components/streamagent/streamagent-integration_tests)\r\n==1151==    by 0x49A70B: streamagent::RunningPipeline::pipelineThreadMain(long, long) (in /home/ubuntu/miocv-builder/build/components/streamagent/streamagent-integration_tests)\r\n==1151==    by 0xBF97C7F: ??? (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21)\r\n==1151==    by 0xC7876B9: start_thread (pthread_create.c:333)\r\n==1151==    by 0xCAA441C: clone (clone.S:109)\r\n==1151== \r\n{\r\n   <insert_a_suppression_name_here>\r\n   Memcheck:Leak\r\n   match-leak-kinds: possible\r\n   fun:malloc\r\n   fun:_ZN5nsync17nsync_waiter_new_Ev\r\n   fun:_ZN5nsync13nsync_mu_lockEPNS_11nsync_mu_s_E\r\n   fun:_ZN10tensorflow24ExtendSessionGraphHelperEP10TF_SessionP9TF_Status\r\n   fun:TF_SessionRun\r\n   fun:_ZN11streamagent3SSD6detectERKSt6vectorIN5miocv9PixelViewINS2_8RGBA8888EEESaIS5_EERKS1_IPS1_INS_17ObjectDetectorBoxESaISA_EESaISD_EEd\r\n   fun:_ZN11streamagent15RunningPipeline18pipelineThreadMainEll\r\n   obj:/usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21\r\n   fun:start_thread\r\n   fun:clone\r\n}\r\n```\r\n\r\nThe same leak occurs in different contexts as well.   As you can see, memory is being allocated in nsync::nsync_waiter_new_().   As I mentioned in my first post, I can see by inspection of https://github.com/google/nsync/blob/master/internal/common.c that the memory is not deallocated in this case.  "}