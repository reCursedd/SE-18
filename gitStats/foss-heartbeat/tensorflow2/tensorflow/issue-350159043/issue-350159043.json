{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/21582", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/21582/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/21582/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/21582/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/21582", "id": 350159043, "node_id": "MDU6SXNzdWUzNTAxNTkwNDM=", "number": 21582, "title": "Memory leak due to nsync::nsync_waiter_new_()?", "user": {"login": "jkeller-miovision", "id": 12238721, "node_id": "MDQ6VXNlcjEyMjM4NzIx", "avatar_url": "https://avatars2.githubusercontent.com/u/12238721?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jkeller-miovision", "html_url": "https://github.com/jkeller-miovision", "followers_url": "https://api.github.com/users/jkeller-miovision/followers", "following_url": "https://api.github.com/users/jkeller-miovision/following{/other_user}", "gists_url": "https://api.github.com/users/jkeller-miovision/gists{/gist_id}", "starred_url": "https://api.github.com/users/jkeller-miovision/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jkeller-miovision/subscriptions", "organizations_url": "https://api.github.com/users/jkeller-miovision/orgs", "repos_url": "https://api.github.com/users/jkeller-miovision/repos", "events_url": "https://api.github.com/users/jkeller-miovision/events{/privacy}", "received_events_url": "https://api.github.com/users/jkeller-miovision/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": {"login": "drpngx", "id": 20959853, "node_id": "MDQ6VXNlcjIwOTU5ODUz", "avatar_url": "https://avatars1.githubusercontent.com/u/20959853?v=4", "gravatar_id": "", "url": "https://api.github.com/users/drpngx", "html_url": "https://github.com/drpngx", "followers_url": "https://api.github.com/users/drpngx/followers", "following_url": "https://api.github.com/users/drpngx/following{/other_user}", "gists_url": "https://api.github.com/users/drpngx/gists{/gist_id}", "starred_url": "https://api.github.com/users/drpngx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/drpngx/subscriptions", "organizations_url": "https://api.github.com/users/drpngx/orgs", "repos_url": "https://api.github.com/users/drpngx/repos", "events_url": "https://api.github.com/users/drpngx/events{/privacy}", "received_events_url": "https://api.github.com/users/drpngx/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "drpngx", "id": 20959853, "node_id": "MDQ6VXNlcjIwOTU5ODUz", "avatar_url": "https://avatars1.githubusercontent.com/u/20959853?v=4", "gravatar_id": "", "url": "https://api.github.com/users/drpngx", "html_url": "https://github.com/drpngx", "followers_url": "https://api.github.com/users/drpngx/followers", "following_url": "https://api.github.com/users/drpngx/following{/other_user}", "gists_url": "https://api.github.com/users/drpngx/gists{/gist_id}", "starred_url": "https://api.github.com/users/drpngx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/drpngx/subscriptions", "organizations_url": "https://api.github.com/users/drpngx/orgs", "repos_url": "https://api.github.com/users/drpngx/repos", "events_url": "https://api.github.com/users/drpngx/events{/privacy}", "received_events_url": "https://api.github.com/users/drpngx/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 6, "created_at": "2018-08-13T19:21:40Z", "updated_at": "2018-08-25T00:06:05Z", "closed_at": "2018-08-25T00:06:05Z", "author_association": "NONE", "body_html": "<h3>System information</h3>\n<ul>\n<li>\n<p><strong>Have I written custom code (as opposed to using a stock example script provided in TensorFlow)</strong>:<br>\nYes</p>\n</li>\n<li>\n<p><strong>OS Platform and Distribution (e.g., Linux Ubuntu 16.04)</strong>:<br>\nLinux Ubuntu 16.04</p>\n</li>\n<li>\n<p><strong>Mobile device (e.g. iPhone 8, Pixel 2, Samsung Galaxy) if the issue happens on mobile device</strong>:</p>\n</li>\n<li>\n<p><strong>TensorFlow installed from (source or binary)</strong>:<br>\nMy own build from source as well as google binary found at: <a href=\"https://storage.googleapis.com/tensorflow/libtensorflow/libtensorflow-cpu-linux-x86_64-1.8.0.tar.gz\" rel=\"nofollow\">https://storage.googleapis.com/tensorflow/libtensorflow/libtensorflow-cpu-linux-x86_64-1.8.0.tar.gz</a></p>\n</li>\n<li>\n<p><strong>TensorFlow version (use command below)</strong>:<br>\n1.8.0 - using C APi, not python</p>\n</li>\n<li>\n<p><strong>Python version</strong>:</p>\n</li>\n<li>\n<p><strong>Bazel version (if compiling from source)</strong>:</p>\n</li>\n<li>\n<p><strong>GCC/Compiler version (if compiling from source)</strong>:</p>\n</li>\n<li>\n<p><strong>CUDA/cuDNN version</strong>:</p>\n</li>\n<li>\n<p><strong>GPU model and memory</strong>:</p>\n</li>\n<li>\n<p><strong>Exact command to reproduce</strong>:</p>\n</li>\n</ul>\n<p>N/A, using google TF 1.8.0 cpu build, calling libtensorflow.so via C API</p>\n<h3>Describe the problem</h3>\n<p>I get valgrind reported memory leak(s), when using TF 1.8 (updating from previously used TF 1.2).  Specifically, the leak comes from nsync::nsync_waiter_new_().   The valgrind output looks like this:</p>\n<p><code>==1947== 400 bytes in 1 blocks are possibly lost in loss record 80,541 of 82,598 ==1947==    at 0x4C2DBF6: malloc (vg_replace_malloc.c:299) ==1947==    by 0xC9A6C34: nsync::nsync_waiter_new_() (in /usr/local/lib/libtensorflow_framework.so) ==1947==    by 0xC9A741E: nsync::nsync_cv_wait_with_deadline_generic(nsync::nsync_cv_s_*, void*, void (*)(void*), void (*)(void*), timespec, nsync::nsync_note_s_*) (in /usr/local/lib/libtensorflow_framework.so) ==1947==    by 0xC9A7AE4: nsync::nsync_cv_wait_with_deadline(nsync::nsync_cv_s_*, nsync::nsync_mu_s_*, timespec, nsync::nsync_note_s_*) (in /usr/local/lib/libtensorflow_framework.so) ==1947==    by 0x73DCA4A: ??? (in /usr/local/lib/libtensorflow.so) ==1947==    by 0x73DCA9A: ??? (in /usr/local/lib/libtensorflow.so) ==1947==    by 0x73E228F: ??? (in /usr/local/lib/libtensorflow.so) ==1947==    by 0x73EBCE4: ??? (in /usr/local/lib/libtensorflow.so) ==1947==    by 0x5258D29: ??? (in /usr/local/lib/libtensorflow.so) ==1947==    by 0x5259925: TF_SessionRun (in /usr/local/lib/libtensorflow.so)</code></p>\n<p>I think I may have found the source by looking at the nsync code located at: <a href=\"https://github.com/google/nsync/blob/master/internal/common.c\">https://github.com/google/nsync/blob/master/internal/common.c</a></p>\n<p>I cannot observe where the memory allocated by malloc() in nsync_waiter_new_() is freed().  Furthermore, I don't see how the memory could safely be freed because the function allows for a caller-supplied allocator, which it conditionally uses, but does not seem to record which allocator was used, or have a mechanism for calling a caller-provided free().</p>\n<p>I believe that this is a memory leak bug in Tensorflow, being caused by the nsync dependency.</p>\n<p>Because the optimized monolithic build of libtensorflow does not seem to have debug symbols enabled by default, and because this call can occur in so many different contexts; it is difficult to generate an appropriate valgrind suppresions file which does not suppress too much.</p>", "body_text": "System information\n\n\nHave I written custom code (as opposed to using a stock example script provided in TensorFlow):\nYes\n\n\nOS Platform and Distribution (e.g., Linux Ubuntu 16.04):\nLinux Ubuntu 16.04\n\n\nMobile device (e.g. iPhone 8, Pixel 2, Samsung Galaxy) if the issue happens on mobile device:\n\n\nTensorFlow installed from (source or binary):\nMy own build from source as well as google binary found at: https://storage.googleapis.com/tensorflow/libtensorflow/libtensorflow-cpu-linux-x86_64-1.8.0.tar.gz\n\n\nTensorFlow version (use command below):\n1.8.0 - using C APi, not python\n\n\nPython version:\n\n\nBazel version (if compiling from source):\n\n\nGCC/Compiler version (if compiling from source):\n\n\nCUDA/cuDNN version:\n\n\nGPU model and memory:\n\n\nExact command to reproduce:\n\n\nN/A, using google TF 1.8.0 cpu build, calling libtensorflow.so via C API\nDescribe the problem\nI get valgrind reported memory leak(s), when using TF 1.8 (updating from previously used TF 1.2).  Specifically, the leak comes from nsync::nsync_waiter_new_().   The valgrind output looks like this:\n==1947== 400 bytes in 1 blocks are possibly lost in loss record 80,541 of 82,598 ==1947==    at 0x4C2DBF6: malloc (vg_replace_malloc.c:299) ==1947==    by 0xC9A6C34: nsync::nsync_waiter_new_() (in /usr/local/lib/libtensorflow_framework.so) ==1947==    by 0xC9A741E: nsync::nsync_cv_wait_with_deadline_generic(nsync::nsync_cv_s_*, void*, void (*)(void*), void (*)(void*), timespec, nsync::nsync_note_s_*) (in /usr/local/lib/libtensorflow_framework.so) ==1947==    by 0xC9A7AE4: nsync::nsync_cv_wait_with_deadline(nsync::nsync_cv_s_*, nsync::nsync_mu_s_*, timespec, nsync::nsync_note_s_*) (in /usr/local/lib/libtensorflow_framework.so) ==1947==    by 0x73DCA4A: ??? (in /usr/local/lib/libtensorflow.so) ==1947==    by 0x73DCA9A: ??? (in /usr/local/lib/libtensorflow.so) ==1947==    by 0x73E228F: ??? (in /usr/local/lib/libtensorflow.so) ==1947==    by 0x73EBCE4: ??? (in /usr/local/lib/libtensorflow.so) ==1947==    by 0x5258D29: ??? (in /usr/local/lib/libtensorflow.so) ==1947==    by 0x5259925: TF_SessionRun (in /usr/local/lib/libtensorflow.so)\nI think I may have found the source by looking at the nsync code located at: https://github.com/google/nsync/blob/master/internal/common.c\nI cannot observe where the memory allocated by malloc() in nsync_waiter_new_() is freed().  Furthermore, I don't see how the memory could safely be freed because the function allows for a caller-supplied allocator, which it conditionally uses, but does not seem to record which allocator was used, or have a mechanism for calling a caller-provided free().\nI believe that this is a memory leak bug in Tensorflow, being caused by the nsync dependency.\nBecause the optimized monolithic build of libtensorflow does not seem to have debug symbols enabled by default, and because this call can occur in so many different contexts; it is difficult to generate an appropriate valgrind suppresions file which does not suppress too much.", "body": "### System information\r\n- **Have I written custom code (as opposed to using a stock example script provided in TensorFlow)**: \r\nYes\r\n- **OS Platform and Distribution (e.g., Linux Ubuntu 16.04)**:\r\nLinux Ubuntu 16.04\r\n\r\n- **Mobile device (e.g. iPhone 8, Pixel 2, Samsung Galaxy) if the issue happens on mobile device**:\r\n- **TensorFlow installed from (source or binary)**:\r\nMy own build from source as well as google binary found at: https://storage.googleapis.com/tensorflow/libtensorflow/libtensorflow-cpu-linux-x86_64-1.8.0.tar.gz\r\n\r\n- **TensorFlow version (use command below)**:\r\n1.8.0 - using C APi, not python\r\n\r\n- **Python version**: \r\n- **Bazel version (if compiling from source)**: \r\n- **GCC/Compiler version (if compiling from source)**:\r\n- **CUDA/cuDNN version**:\r\n- **GPU model and memory**:\r\n- **Exact command to reproduce**:\r\n\r\nN/A, using google TF 1.8.0 cpu build, calling libtensorflow.so via C API\r\n\r\n### Describe the problem\r\n\r\nI get valgrind reported memory leak(s), when using TF 1.8 (updating from previously used TF 1.2).  Specifically, the leak comes from nsync::nsync_waiter_new_().   The valgrind output looks like this:\r\n\r\n`==1947== 400 bytes in 1 blocks are possibly lost in loss record 80,541 of 82,598\r\n==1947==    at 0x4C2DBF6: malloc (vg_replace_malloc.c:299)\r\n==1947==    by 0xC9A6C34: nsync::nsync_waiter_new_() (in /usr/local/lib/libtensorflow_framework.so)\r\n==1947==    by 0xC9A741E: nsync::nsync_cv_wait_with_deadline_generic(nsync::nsync_cv_s_*, void*, void (*)(void*), void (*)(void*), timespec, nsync::nsync_note_s_*) (in /usr/local/lib/libtensorflow_framework.so)\r\n==1947==    by 0xC9A7AE4: nsync::nsync_cv_wait_with_deadline(nsync::nsync_cv_s_*, nsync::nsync_mu_s_*, timespec, nsync::nsync_note_s_*) (in /usr/local/lib/libtensorflow_framework.so)\r\n==1947==    by 0x73DCA4A: ??? (in /usr/local/lib/libtensorflow.so)\r\n==1947==    by 0x73DCA9A: ??? (in /usr/local/lib/libtensorflow.so)\r\n==1947==    by 0x73E228F: ??? (in /usr/local/lib/libtensorflow.so)\r\n==1947==    by 0x73EBCE4: ??? (in /usr/local/lib/libtensorflow.so)\r\n==1947==    by 0x5258D29: ??? (in /usr/local/lib/libtensorflow.so)\r\n==1947==    by 0x5259925: TF_SessionRun (in /usr/local/lib/libtensorflow.so)`\r\n\r\nI think I may have found the source by looking at the nsync code located at: https://github.com/google/nsync/blob/master/internal/common.c\r\n\r\nI cannot observe where the memory allocated by malloc() in nsync_waiter_new_() is freed().  Furthermore, I don't see how the memory could safely be freed because the function allows for a caller-supplied allocator, which it conditionally uses, but does not seem to record which allocator was used, or have a mechanism for calling a caller-provided free().\r\n\r\nI believe that this is a memory leak bug in Tensorflow, being caused by the nsync dependency.  \r\n\r\nBecause the optimized monolithic build of libtensorflow does not seem to have debug symbols enabled by default, and because this call can occur in so many different contexts; it is difficult to generate an appropriate valgrind suppresions file which does not suppress too much.\r\n\r\n\r\n"}