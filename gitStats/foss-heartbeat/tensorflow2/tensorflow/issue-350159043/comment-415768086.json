{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/415768086", "html_url": "https://github.com/tensorflow/tensorflow/issues/21582#issuecomment-415768086", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/21582", "id": 415768086, "node_id": "MDEyOklzc3VlQ29tbWVudDQxNTc2ODA4Ng==", "user": {"login": "jkeller-miovision", "id": 12238721, "node_id": "MDQ6VXNlcjEyMjM4NzIx", "avatar_url": "https://avatars2.githubusercontent.com/u/12238721?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jkeller-miovision", "html_url": "https://github.com/jkeller-miovision", "followers_url": "https://api.github.com/users/jkeller-miovision/followers", "following_url": "https://api.github.com/users/jkeller-miovision/following{/other_user}", "gists_url": "https://api.github.com/users/jkeller-miovision/gists{/gist_id}", "starred_url": "https://api.github.com/users/jkeller-miovision/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jkeller-miovision/subscriptions", "organizations_url": "https://api.github.com/users/jkeller-miovision/orgs", "repos_url": "https://api.github.com/users/jkeller-miovision/repos", "events_url": "https://api.github.com/users/jkeller-miovision/events{/privacy}", "received_events_url": "https://api.github.com/users/jkeller-miovision/received_events", "type": "User", "site_admin": false}, "created_at": "2018-08-24T14:01:57Z", "updated_at": "2018-08-24T14:04:00Z", "author_association": "NONE", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=10168793\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/m3bm3b\">@m3bm3b</a></p>\n<p>Thanks for the lengthly explanation.  I really do appreciate it.  I believe that I follow you completely, and I was aware of the linked lists involved.  I do not believe that valgrind is reporting this because of the 'interior pointer' use.  Rather, as you mention:</p>\n<blockquote>\n<p>Those blocks are not supposed to be deallocated, but when no longer in use<br>\nare instead put into a free pool and reused, for reasons that I give below.</p>\n</blockquote>\n<p>These structs are allocated in common.c line 189 or 187.  I believe that the pointer returned by that allocation, is never passed to any implementation of free() - instead, as you mention, these structs are placed on the free_waiters DLL, and re-used.  However they are not freed within the lifetime of the process.  It depends on one's semantic interpretation, but I believe this memory is 'leaked' in the same way that a dynamically allocated singleton object/struct ptr is leaked if it is never deallocated.  As you mention, there is a guaranteed limit on the amount of this memory based on the max number of concurrently executing threads.</p>\n<p>Another way to appease leak-checking tools in cases like this would be to deallocate members of the free_waiters list at process exit time (via a atexit() handler, or an explicit library de-initialization function).  It is understandable (to me) if that is not a desired design decision.</p>\n<p>For my use case, I would be very happy if I could figure out the correct invocation to bazel so that I can build an optimized, monolithic, libtensorflow that still has symbols available to generate a specific valgrind suppression for this case.   So far I have not found a way to enable those three options simultaneously - but I have almost no experience with bazel, so I'm sure it can be done.  As it stands now, I cannot differentiate on anything besides the exported C API symbols, so I must suppress everything that occurs within the context of TF_SessionRun().</p>\n<p>Specifically, I have needed to use the monolithic build to prevent libtensorflow from exporting symbols from it's dependencies (libpng, protobuf, etc...) as they clash with other versions of the same libraries that my executable links in.</p>\n<p>Thanks again for your thorough explanation!</p>", "body_text": "@m3bm3b\nThanks for the lengthly explanation.  I really do appreciate it.  I believe that I follow you completely, and I was aware of the linked lists involved.  I do not believe that valgrind is reporting this because of the 'interior pointer' use.  Rather, as you mention:\n\nThose blocks are not supposed to be deallocated, but when no longer in use\nare instead put into a free pool and reused, for reasons that I give below.\n\nThese structs are allocated in common.c line 189 or 187.  I believe that the pointer returned by that allocation, is never passed to any implementation of free() - instead, as you mention, these structs are placed on the free_waiters DLL, and re-used.  However they are not freed within the lifetime of the process.  It depends on one's semantic interpretation, but I believe this memory is 'leaked' in the same way that a dynamically allocated singleton object/struct ptr is leaked if it is never deallocated.  As you mention, there is a guaranteed limit on the amount of this memory based on the max number of concurrently executing threads.\nAnother way to appease leak-checking tools in cases like this would be to deallocate members of the free_waiters list at process exit time (via a atexit() handler, or an explicit library de-initialization function).  It is understandable (to me) if that is not a desired design decision.\nFor my use case, I would be very happy if I could figure out the correct invocation to bazel so that I can build an optimized, monolithic, libtensorflow that still has symbols available to generate a specific valgrind suppression for this case.   So far I have not found a way to enable those three options simultaneously - but I have almost no experience with bazel, so I'm sure it can be done.  As it stands now, I cannot differentiate on anything besides the exported C API symbols, so I must suppress everything that occurs within the context of TF_SessionRun().\nSpecifically, I have needed to use the monolithic build to prevent libtensorflow from exporting symbols from it's dependencies (libpng, protobuf, etc...) as they clash with other versions of the same libraries that my executable links in.\nThanks again for your thorough explanation!", "body": "@m3bm3b \r\n\r\nThanks for the lengthly explanation.  I really do appreciate it.  I believe that I follow you completely, and I was aware of the linked lists involved.  I do not believe that valgrind is reporting this because of the 'interior pointer' use.  Rather, as you mention:\r\n\r\n> Those blocks are not supposed to be deallocated, but when no longer in use\r\n> are instead put into a free pool and reused, for reasons that I give below.\r\n\r\nThese structs are allocated in common.c line 189 or 187.  I believe that the pointer returned by that allocation, is never passed to any implementation of free() - instead, as you mention, these structs are placed on the free_waiters DLL, and re-used.  However they are not freed within the lifetime of the process.  It depends on one's semantic interpretation, but I believe this memory is 'leaked' in the same way that a dynamically allocated singleton object/struct ptr is leaked if it is never deallocated.  As you mention, there is a guaranteed limit on the amount of this memory based on the max number of concurrently executing threads.  \r\n\r\nAnother way to appease leak-checking tools in cases like this would be to deallocate members of the free_waiters list at process exit time (via a atexit() handler, or an explicit library de-initialization function).  It is understandable (to me) if that is not a desired design decision.\r\n\r\nFor my use case, I would be very happy if I could figure out the correct invocation to bazel so that I can build an optimized, monolithic, libtensorflow that still has symbols available to generate a specific valgrind suppression for this case.   So far I have not found a way to enable those three options simultaneously - but I have almost no experience with bazel, so I'm sure it can be done.  As it stands now, I cannot differentiate on anything besides the exported C API symbols, so I must suppress everything that occurs within the context of TF_SessionRun().\r\n\r\nSpecifically, I have needed to use the monolithic build to prevent libtensorflow from exporting symbols from it's dependencies (libpng, protobuf, etc...) as they clash with other versions of the same libraries that my executable links in.\r\n\r\nThanks again for your thorough explanation!\r\n\r\n"}