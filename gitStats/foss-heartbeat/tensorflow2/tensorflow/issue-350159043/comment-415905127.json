{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/415905127", "html_url": "https://github.com/tensorflow/tensorflow/issues/21582#issuecomment-415905127", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/21582", "id": 415905127, "node_id": "MDEyOklzc3VlQ29tbWVudDQxNTkwNTEyNw==", "user": {"login": "m3bm3b", "id": 10168793, "node_id": "MDQ6VXNlcjEwMTY4Nzkz", "avatar_url": "https://avatars0.githubusercontent.com/u/10168793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m3bm3b", "html_url": "https://github.com/m3bm3b", "followers_url": "https://api.github.com/users/m3bm3b/followers", "following_url": "https://api.github.com/users/m3bm3b/following{/other_user}", "gists_url": "https://api.github.com/users/m3bm3b/gists{/gist_id}", "starred_url": "https://api.github.com/users/m3bm3b/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m3bm3b/subscriptions", "organizations_url": "https://api.github.com/users/m3bm3b/orgs", "repos_url": "https://api.github.com/users/m3bm3b/repos", "events_url": "https://api.github.com/users/m3bm3b/events{/privacy}", "received_events_url": "https://api.github.com/users/m3bm3b/received_events", "type": "User", "site_admin": false}, "created_at": "2018-08-24T23:09:18Z", "updated_at": "2018-08-24T23:09:18Z", "author_association": "NONE", "body_html": "<blockquote>\n<p>I do not believe that valgrind is reporting this because of the 'interior pointer' use.</p>\n</blockquote>\n<p>I do not understand why belief comes into this.  We have data.</p>\n<p>First, the valgrind documentation that I cited says rather<br>\nunequivocally that the \"possibly lost\" error message you quoted<br>\n<em>is</em> about interior pointers.  It would be remarkable if the author had lied<br>\nabout this topic.</p>\n<p>Second, one can do the experiment of allocating and then failing to free a block,<br>\nfirst using a pointer to the block's start, and then a pointer to the block's interior.<br>\nIn the first case, valgrind does <em>not</em> treat the unfreed memory as an error.<br>\nIn the second case, it does report an error (because of the interior pointer),<br>\nand it yields the \"possibly lost\" error message that you quote in<br>\nyour opening message.</p>\n<p>I give examples of such an experiment at the end of this message.</p>\n<blockquote>\n<p>Another way to appease leak-checking tools in cases like this would be to<br>\ndeallocate members of the free_waiters list at process exit time<br>\n(via a atexit() handler, or an explicit library de-initialization function).</p>\n</blockquote>\n<p>That's not going to be effective, even<br>\nleaving aside the fact that valgrind is <em>not</em> complaining that the<br>\nobject is still live at exit() time.</p>\n<p>Morevoer, as a general rule, attempting to free memory<br>\nat exit time, whether in atexit() handlers, library de-initialization fuinctions,<br>\nof C++ static destructors is actually dangerous,<br>\nand I recommend against it.</p>\n<p>First, it serves no rational purpose to free memory in an address space that<br>\nis about to be completely blown away.  At best, it wastes CPU cycles.<br>\nA fitting analogy is:<br>\n<a href=\"https://en.wiktionary.org/wiki/rearrange_the_deck_chairs_on_the_Titanic\" rel=\"nofollow\">https://en.wiktionary.org/wiki/rearrange_the_deck_chairs_on_the_Titanic</a></p>\n<p>In addition, in the case you're suggesting, it doesn't actually achieve your apparent<br>\ngoal of causing there to be no allocated nsync waiter structs at exit() time.<br>\nEven if the thread calling exit() removes all the waiter structs from the nsync's free list:</p>\n<ol>\n<li>every extant thread will still have a waiter struct that you cannot free safely<br>\n(the only reason valgrind is not complaining about those structs is that<br>\nthe thread-local pointers are not interior pointers); and</li>\n<li>any of those threads might put another waiter struct back on nsync's free list<br>\nafter the atexit() handler had emptied it---those threads are still running while the<br>\natexit() handlers are running.<br>\nThus this approach does not reliably achieve the goal: no matter what you do in the<br>\natexit() handler, there will always be some waiter structs not freed when the<br>\naddress space exists, and sometimes there will even be some on the free<br>\nlist that the atexit() handler tried in vain to empty.</li>\n</ol>\n<p>And worst of all, in general (though not in the case of the nsync waiter free list),<br>\nif another thread touched a variable or data structure<br>\nthat had been \"cleaned up\" by an atexit() handler (or destructor of a static C++ variable),<br>\nthe process might not exit cleanly, but might instead crash or deadlock because it touched<br>\na variable that was no longer valid.</p>\n<p>The probability of such problems increases with the size of the programme,<br>\nbecause the developer calling exit() and the developers writing the atexit() handlers<br>\nknow less about what else is going on within the address space.<br>\nThus, the issues are more pressing in large code bases.  People who write<br>\nprogrammes of only modest size may not come across this issue for a long time.</p>\n<p>Notice that the problems are even more common in C++ programmes, because<br>\nin that language it's easy accidentally to create a static variable with a dangerous<br>\nnon-trivial destructor.<br>\nThis is why C++ has quick_exit() (which is like exit() but doesn't run destructors or<br>\natexit() handlers), and why Google's C++ style guide prohibits the use of<br>\nnon-trivial destructors on static variables.  (see<br>\n<a href=\"https://en.cppreference.com/w/cpp/utility/program/quick_exit\" rel=\"nofollow\">https://en.cppreference.com/w/cpp/utility/program/quick_exit</a><br>\nand<br>\n<a href=\"https://google.github.io/styleguide/cppguide.html#Static_and_Global_Variables\" rel=\"nofollow\">https://google.github.io/styleguide/cppguide.html#Static_and_Global_Variables</a><br>\n).</p>\n<p>To summarize, in a large, mulitthreaded programme there is no safe way to guarantee<br>\nto deallocate internal  memory reousrces at exit().<br>\natexit() handlers are best used to flush I/O buffers<br>\nand if possible to release <em>external</em> resources that might<br>\notherwise have to time out (e.g., early release of a lease in a<br>\ndistributed system, or to abort a database transaction that<br>\nwould otherwise have to time out).</p>\n<pre><code>             ---------------\n</code></pre>\n<p>Here's the experiment with valgrind:</p>\n<p>Below are two programmes \"start_ptr\" and \"interior_ptr\":</p>\n<ul>\n<li>Each allocates a 32-byte block, and never frees it.</li>\n<li>Each stores a pointer to the block in a static variable.</li>\n<li>In each, the pointer is still there when the programme exits.<br>\nThe only difference is that \"start_ptr\" stores a pointer to the start of the block,<br>\nwhile interior_ptr stores a pointer to the byte at offset 8 within the block.</li>\n</ul>\n<p>For \"start_ptr\", valgrind memcheck reports \"0 errors\",<br>\nand gives no stack trace.    It does report \"in use at exit: 32 bytes in 1 blocks\",<br>\nbut it doesn't regard this as an error.    By giving an extra flag, you can get<br>\nit to report the location where the allocation happened, but it reports it<br>\nas \"still reachable\", not \"possibly lost\" (the error from your report),<br>\nand still will not report it as an error.</p>\n<p>For \"interior_ptr\",  valgrind memcheck reports \"1 errors\" [sic], and<br>\ndetails the error saying  \"32 bytes in 1 blocks are possibly lost\"<br>\n(matching your error report) at \"main (interior_ptr.c:4)\".</p>\n<p>$ cat &gt; start_ptr.c &lt;&lt;EOF<br>\n#include &lt;stdlib.h&gt;<br>\nstatic char *ptr;<br>\nint main (int argc, char *argv[]) {<br>\nptr = (char *) malloc (32);<br>\nreturn (0);<br>\n}<br>\nEOF<br>\n$ cc -g start_ptr.c -o start_ptr<br>\n$ valgrind --tool=memcheck --leak-check=full ./start_ptr<br>\n...<br>\n==17720== HEAP SUMMARY:<br>\n==17720==     in use at exit: 32 bytes in 1 blocks<br>\n==17720==   total heap usage: 1 allocs, 0 frees, 32 bytes allocated<br>\n==17720==<br>\n==17720== LEAK SUMMARY:<br>\n==17720==    definitely lost: 0 bytes in 0 blocks<br>\n==17720==    indirectly lost: 0 bytes in 0 blocks<br>\n==17720==      possibly lost: 0 bytes in 0 blocks<br>\n==17720==    still reachable: 32 bytes in 1 blocks<br>\n==17720==         suppressed: 0 bytes in 0 blocks<br>\n==17720== Reachable blocks (those to which a pointer was found) are not shown.<br>\n==17720== To see them, rerun with: --leak-check=full --show-leak-kinds=all<br>\n==17720==<br>\n==17720== For counts of detected and suppressed errors, rerun with: -v<br>\n==17720== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</p>\n<p>$ cat &gt; interior_ptr.c &lt;&lt;EOF<br>\n#include &lt;stdlib.h&gt;<br>\nstatic char *ptr;<br>\nint main (int argc, char *argv[]) {<br>\nptr = 8 + (char *) malloc (32);<br>\nreturn (0);<br>\n}<br>\nEOF<br>\n$ cc -g interior_ptr.c -o interior_ptr<br>\n$ valgrind --tool=memcheck --leak-check=full ./interior_ptr<br>\n==17748== Memcheck, a memory error detector<br>\n==17748== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.<br>\n==17748== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info<br>\n==17748== Command: ./interior_ptr<br>\n==17748==<br>\n==17748==<br>\n==17748== HEAP SUMMARY:<br>\n==17748==     in use at exit: 32 bytes in 1 blocks<br>\n==17748==   total heap usage: 1 allocs, 0 frees, 32 bytes allocated<br>\n==17748==<br>\n==17748== 32 bytes in 1 blocks are possibly lost in loss record 1 of 1<br>\n==17748==    at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)<br>\n==17748==    by 0x40053E: main (interior_ptr.c:4)<br>\n==17748==<br>\n==17748== LEAK SUMMARY:<br>\n==17748==    definitely lost: 0 bytes in 0 blocks<br>\n==17748==    indirectly lost: 0 bytes in 0 blocks<br>\n==17748==      possibly lost: 32 bytes in 1 blocks<br>\n==17748==    still reachable: 0 bytes in 0 blocks<br>\n==17748==         suppressed: 0 bytes in 0 blocks<br>\n==17748==<br>\n==17748== For counts of detected and suppressed errors, rerun with: -v<br>\n==17748== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)</p>", "body_text": "I do not believe that valgrind is reporting this because of the 'interior pointer' use.\n\nI do not understand why belief comes into this.  We have data.\nFirst, the valgrind documentation that I cited says rather\nunequivocally that the \"possibly lost\" error message you quoted\nis about interior pointers.  It would be remarkable if the author had lied\nabout this topic.\nSecond, one can do the experiment of allocating and then failing to free a block,\nfirst using a pointer to the block's start, and then a pointer to the block's interior.\nIn the first case, valgrind does not treat the unfreed memory as an error.\nIn the second case, it does report an error (because of the interior pointer),\nand it yields the \"possibly lost\" error message that you quote in\nyour opening message.\nI give examples of such an experiment at the end of this message.\n\nAnother way to appease leak-checking tools in cases like this would be to\ndeallocate members of the free_waiters list at process exit time\n(via a atexit() handler, or an explicit library de-initialization function).\n\nThat's not going to be effective, even\nleaving aside the fact that valgrind is not complaining that the\nobject is still live at exit() time.\nMorevoer, as a general rule, attempting to free memory\nat exit time, whether in atexit() handlers, library de-initialization fuinctions,\nof C++ static destructors is actually dangerous,\nand I recommend against it.\nFirst, it serves no rational purpose to free memory in an address space that\nis about to be completely blown away.  At best, it wastes CPU cycles.\nA fitting analogy is:\nhttps://en.wiktionary.org/wiki/rearrange_the_deck_chairs_on_the_Titanic\nIn addition, in the case you're suggesting, it doesn't actually achieve your apparent\ngoal of causing there to be no allocated nsync waiter structs at exit() time.\nEven if the thread calling exit() removes all the waiter structs from the nsync's free list:\n\nevery extant thread will still have a waiter struct that you cannot free safely\n(the only reason valgrind is not complaining about those structs is that\nthe thread-local pointers are not interior pointers); and\nany of those threads might put another waiter struct back on nsync's free list\nafter the atexit() handler had emptied it---those threads are still running while the\natexit() handlers are running.\nThus this approach does not reliably achieve the goal: no matter what you do in the\natexit() handler, there will always be some waiter structs not freed when the\naddress space exists, and sometimes there will even be some on the free\nlist that the atexit() handler tried in vain to empty.\n\nAnd worst of all, in general (though not in the case of the nsync waiter free list),\nif another thread touched a variable or data structure\nthat had been \"cleaned up\" by an atexit() handler (or destructor of a static C++ variable),\nthe process might not exit cleanly, but might instead crash or deadlock because it touched\na variable that was no longer valid.\nThe probability of such problems increases with the size of the programme,\nbecause the developer calling exit() and the developers writing the atexit() handlers\nknow less about what else is going on within the address space.\nThus, the issues are more pressing in large code bases.  People who write\nprogrammes of only modest size may not come across this issue for a long time.\nNotice that the problems are even more common in C++ programmes, because\nin that language it's easy accidentally to create a static variable with a dangerous\nnon-trivial destructor.\nThis is why C++ has quick_exit() (which is like exit() but doesn't run destructors or\natexit() handlers), and why Google's C++ style guide prohibits the use of\nnon-trivial destructors on static variables.  (see\nhttps://en.cppreference.com/w/cpp/utility/program/quick_exit\nand\nhttps://google.github.io/styleguide/cppguide.html#Static_and_Global_Variables\n).\nTo summarize, in a large, mulitthreaded programme there is no safe way to guarantee\nto deallocate internal  memory reousrces at exit().\natexit() handlers are best used to flush I/O buffers\nand if possible to release external resources that might\notherwise have to time out (e.g., early release of a lease in a\ndistributed system, or to abort a database transaction that\nwould otherwise have to time out).\n             ---------------\n\nHere's the experiment with valgrind:\nBelow are two programmes \"start_ptr\" and \"interior_ptr\":\n\nEach allocates a 32-byte block, and never frees it.\nEach stores a pointer to the block in a static variable.\nIn each, the pointer is still there when the programme exits.\nThe only difference is that \"start_ptr\" stores a pointer to the start of the block,\nwhile interior_ptr stores a pointer to the byte at offset 8 within the block.\n\nFor \"start_ptr\", valgrind memcheck reports \"0 errors\",\nand gives no stack trace.    It does report \"in use at exit: 32 bytes in 1 blocks\",\nbut it doesn't regard this as an error.    By giving an extra flag, you can get\nit to report the location where the allocation happened, but it reports it\nas \"still reachable\", not \"possibly lost\" (the error from your report),\nand still will not report it as an error.\nFor \"interior_ptr\",  valgrind memcheck reports \"1 errors\" [sic], and\ndetails the error saying  \"32 bytes in 1 blocks are possibly lost\"\n(matching your error report) at \"main (interior_ptr.c:4)\".\n$ cat > start_ptr.c <<EOF\n#include <stdlib.h>\nstatic char *ptr;\nint main (int argc, char *argv[]) {\nptr = (char *) malloc (32);\nreturn (0);\n}\nEOF\n$ cc -g start_ptr.c -o start_ptr\n$ valgrind --tool=memcheck --leak-check=full ./start_ptr\n...\n==17720== HEAP SUMMARY:\n==17720==     in use at exit: 32 bytes in 1 blocks\n==17720==   total heap usage: 1 allocs, 0 frees, 32 bytes allocated\n==17720==\n==17720== LEAK SUMMARY:\n==17720==    definitely lost: 0 bytes in 0 blocks\n==17720==    indirectly lost: 0 bytes in 0 blocks\n==17720==      possibly lost: 0 bytes in 0 blocks\n==17720==    still reachable: 32 bytes in 1 blocks\n==17720==         suppressed: 0 bytes in 0 blocks\n==17720== Reachable blocks (those to which a pointer was found) are not shown.\n==17720== To see them, rerun with: --leak-check=full --show-leak-kinds=all\n==17720==\n==17720== For counts of detected and suppressed errors, rerun with: -v\n==17720== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)\n$ cat > interior_ptr.c <<EOF\n#include <stdlib.h>\nstatic char *ptr;\nint main (int argc, char *argv[]) {\nptr = 8 + (char *) malloc (32);\nreturn (0);\n}\nEOF\n$ cc -g interior_ptr.c -o interior_ptr\n$ valgrind --tool=memcheck --leak-check=full ./interior_ptr\n==17748== Memcheck, a memory error detector\n==17748== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.\n==17748== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info\n==17748== Command: ./interior_ptr\n==17748==\n==17748==\n==17748== HEAP SUMMARY:\n==17748==     in use at exit: 32 bytes in 1 blocks\n==17748==   total heap usage: 1 allocs, 0 frees, 32 bytes allocated\n==17748==\n==17748== 32 bytes in 1 blocks are possibly lost in loss record 1 of 1\n==17748==    at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n==17748==    by 0x40053E: main (interior_ptr.c:4)\n==17748==\n==17748== LEAK SUMMARY:\n==17748==    definitely lost: 0 bytes in 0 blocks\n==17748==    indirectly lost: 0 bytes in 0 blocks\n==17748==      possibly lost: 32 bytes in 1 blocks\n==17748==    still reachable: 0 bytes in 0 blocks\n==17748==         suppressed: 0 bytes in 0 blocks\n==17748==\n==17748== For counts of detected and suppressed errors, rerun with: -v\n==17748== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)", "body": ">  I do not believe that valgrind is reporting this because of the 'interior pointer' use.\r\n\r\nI do not understand why belief comes into this.  We have data.\r\n\r\nFirst, the valgrind documentation that I cited says rather \r\nunequivocally that the \"possibly lost\" error message you quoted  \r\n_is_ about interior pointers.  It would be remarkable if the author had lied\r\nabout this topic.\r\n\r\nSecond, one can do the experiment of allocating and then failing to free a block,\r\nfirst using a pointer to the block's start, and then a pointer to the block's interior.\r\nIn the first case, valgrind does _not_ treat the unfreed memory as an error.\r\nIn the second case, it does report an error (because of the interior pointer),\r\nand it yields the \"possibly lost\" error message that you quote in\r\nyour opening message.\r\n\r\nI give examples of such an experiment at the end of this message.\r\n\r\n\r\n> Another way to appease leak-checking tools in cases like this would be to \r\n> deallocate members of the free_waiters list at process exit time \r\n> (via a atexit() handler, or an explicit library de-initialization function).\r\n\r\nThat's not going to be effective, even\r\nleaving aside the fact that valgrind is _not_ complaining that the \r\nobject is still live at exit() time.   \r\n\r\nMorevoer, as a general rule, attempting to free memory\r\nat exit time, whether in atexit() handlers, library de-initialization fuinctions,\r\nof C++ static destructors is actually dangerous,\r\nand I recommend against it.\r\n\r\n\r\nFirst, it serves no rational purpose to free memory in an address space that \r\nis about to be completely blown away.  At best, it wastes CPU cycles.\r\nA fitting analogy is:\r\n     https://en.wiktionary.org/wiki/rearrange_the_deck_chairs_on_the_Titanic\r\n\r\n\r\nIn addition, in the case you're suggesting, it doesn't actually achieve your apparent\r\ngoal of causing there to be no allocated nsync waiter structs at exit() time.   \r\nEven if the thread calling exit() removes all the waiter structs from the nsync's free list:\r\n1. every extant thread will still have a waiter struct that you cannot free safely\r\n(the only reason valgrind is not complaining about those structs is that \r\nthe thread-local pointers are not interior pointers); and\r\n2. any of those threads might put another waiter struct back on nsync's free list\r\nafter the atexit() handler had emptied it---those threads are still running while the \r\natexit() handlers are running.\r\nThus this approach does not reliably achieve the goal: no matter what you do in the\r\natexit() handler, there will always be some waiter structs not freed when the \r\naddress space exists, and sometimes there will even be some on the free\r\nlist that the atexit() handler tried in vain to empty.\r\n\r\nAnd worst of all, in general (though not in the case of the nsync waiter free list),\r\nif another thread touched a variable or data structure\r\nthat had been \"cleaned up\" by an atexit() handler (or destructor of a static C++ variable),\r\nthe process might not exit cleanly, but might instead crash or deadlock because it touched\r\na variable that was no longer valid.\r\n\r\nThe probability of such problems increases with the size of the programme,\r\nbecause the developer calling exit() and the developers writing the atexit() handlers\r\nknow less about what else is going on within the address space.\r\nThus, the issues are more pressing in large code bases.  People who write \r\nprogrammes of only modest size may not come across this issue for a long time.\r\n\r\nNotice that the problems are even more common in C++ programmes, because \r\nin that language it's easy accidentally to create a static variable with a dangerous \r\nnon-trivial destructor.\r\nThis is why C++ has quick_exit() (which is like exit() but doesn't run destructors or \r\natexit() handlers), and why Google's C++ style guide prohibits the use of \r\nnon-trivial destructors on static variables.  (see       \r\n  https://en.cppreference.com/w/cpp/utility/program/quick_exit\r\nand \r\n  https://google.github.io/styleguide/cppguide.html#Static_and_Global_Variables\r\n). \r\n\r\nTo summarize, in a large, mulitthreaded programme there is no safe way to guarantee \r\nto deallocate internal  memory reousrces at exit().   \r\natexit() handlers are best used to flush I/O buffers\r\nand if possible to release _external_ resources that might \r\notherwise have to time out (e.g., early release of a lease in a \r\ndistributed system, or to abort a database transaction that \r\nwould otherwise have to time out).\r\n\r\n\r\n                 ---------------\r\n\r\nHere's the experiment with valgrind:\r\n\r\nBelow are two programmes \"start_ptr\" and \"interior_ptr\":\r\n- Each allocates a 32-byte block, and never frees it.\r\n- Each stores a pointer to the block in a static variable.\r\n- In each, the pointer is still there when the programme exits.\r\nThe only difference is that \"start_ptr\" stores a pointer to the start of the block,\r\nwhile interior_ptr stores a pointer to the byte at offset 8 within the block.\r\n\r\nFor \"start_ptr\", valgrind memcheck reports \"0 errors\", \r\nand gives no stack trace.    It does report \"in use at exit: 32 bytes in 1 blocks\", \r\nbut it doesn't regard this as an error.    By giving an extra flag, you can get \r\nit to report the location where the allocation happened, but it reports it\r\nas \"still reachable\", not \"possibly lost\" (the error from your report), \r\nand still will not report it as an error.\r\n\r\nFor \"interior_ptr\",  valgrind memcheck reports \"1 errors\" [sic], and \r\ndetails the error saying  \"32 bytes in 1 blocks are possibly lost\"\r\n(matching your error report) at \"main (interior_ptr.c:4)\".\r\n\r\n$ cat > start_ptr.c <<EOF\r\n#include <stdlib.h>\r\nstatic char *ptr;\r\nint main (int argc, char *argv[]) {\r\n        ptr = (char *) malloc (32);\r\n        return (0);\r\n}\r\nEOF\r\n$ cc -g start_ptr.c -o start_ptr       \r\n$ valgrind --tool=memcheck --leak-check=full ./start_ptr\r\n...\r\n==17720== HEAP SUMMARY:\r\n==17720==     in use at exit: 32 bytes in 1 blocks\r\n==17720==   total heap usage: 1 allocs, 0 frees, 32 bytes allocated\r\n==17720== \r\n==17720== LEAK SUMMARY:\r\n==17720==    definitely lost: 0 bytes in 0 blocks\r\n==17720==    indirectly lost: 0 bytes in 0 blocks\r\n==17720==      possibly lost: 0 bytes in 0 blocks\r\n==17720==    still reachable: 32 bytes in 1 blocks\r\n==17720==         suppressed: 0 bytes in 0 blocks\r\n==17720== Reachable blocks (those to which a pointer was found) are not shown.\r\n==17720== To see them, rerun with: --leak-check=full --show-leak-kinds=all\r\n==17720== \r\n==17720== For counts of detected and suppressed errors, rerun with: -v\r\n==17720== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)\r\n\r\n\r\n$ cat > interior_ptr.c <<EOF\r\n#include <stdlib.h>\r\nstatic char *ptr;\r\nint main (int argc, char *argv[]) {\r\n        ptr = 8 + (char *) malloc (32);\r\n        return (0);\r\n}\r\nEOF\r\n$ cc -g interior_ptr.c -o interior_ptr \r\n$ valgrind --tool=memcheck --leak-check=full ./interior_ptr \r\n==17748== Memcheck, a memory error detector\r\n==17748== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.\r\n==17748== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info\r\n==17748== Command: ./interior_ptr\r\n==17748== \r\n==17748== \r\n==17748== HEAP SUMMARY:\r\n==17748==     in use at exit: 32 bytes in 1 blocks\r\n==17748==   total heap usage: 1 allocs, 0 frees, 32 bytes allocated\r\n==17748== \r\n==17748== 32 bytes in 1 blocks are possibly lost in loss record 1 of 1\r\n==17748==    at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==17748==    by 0x40053E: main (interior_ptr.c:4)\r\n==17748== \r\n==17748== LEAK SUMMARY:\r\n==17748==    definitely lost: 0 bytes in 0 blocks\r\n==17748==    indirectly lost: 0 bytes in 0 blocks\r\n==17748==      possibly lost: 32 bytes in 1 blocks\r\n==17748==    still reachable: 0 bytes in 0 blocks\r\n==17748==         suppressed: 0 bytes in 0 blocks\r\n==17748== \r\n==17748== For counts of detected and suppressed errors, rerun with: -v\r\n==17748== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)\r\n"}