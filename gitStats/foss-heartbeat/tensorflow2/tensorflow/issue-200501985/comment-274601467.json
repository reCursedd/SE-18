{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/274601467", "html_url": "https://github.com/tensorflow/tensorflow/issues/6816#issuecomment-274601467", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/6816", "id": 274601467, "node_id": "MDEyOklzc3VlQ29tbWVudDI3NDYwMTQ2Nw==", "user": {"login": "jlebar", "id": 150663, "node_id": "MDQ6VXNlcjE1MDY2Mw==", "avatar_url": "https://avatars1.githubusercontent.com/u/150663?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jlebar", "html_url": "https://github.com/jlebar", "followers_url": "https://api.github.com/users/jlebar/followers", "following_url": "https://api.github.com/users/jlebar/following{/other_user}", "gists_url": "https://api.github.com/users/jlebar/gists{/gist_id}", "starred_url": "https://api.github.com/users/jlebar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jlebar/subscriptions", "organizations_url": "https://api.github.com/users/jlebar/orgs", "repos_url": "https://api.github.com/users/jlebar/repos", "events_url": "https://api.github.com/users/jlebar/events{/privacy}", "received_events_url": "https://api.github.com/users/jlebar/received_events", "type": "User", "site_admin": false}, "created_at": "2017-01-23T20:06:12Z", "updated_at": "2017-01-23T20:06:12Z", "author_association": "MEMBER", "body_html": "<p>Running this through cuda-memcheck, I'm seeing a bunch of errors of the form</p>\n<pre><code>========= Invalid __global__ read of size 4\n=========     at 0x000000b8 in _copy\n=========     by thread (13,0,0) in block (866,0,0)\n=========     Address 0x3bdac0c83cce9646 is misaligned\n</code></pre>\n<p>That address is indeed misaligned.</p>\n<p>The body of the _copy kernel (which you can get by setting the TF_CPP_MIN_VLOG_LEVEL env var to 2) is</p>\n<pre><code>.visible .entry _copy(\n\t.param .u64 _copy_param_0,\n\t.param .u64 _copy_param_1,\n\t.param .u64 _copy_param_2\n)\n.maxntid 32, 1, 1\n{\n\t.reg .pred \t%p&lt;2&gt;;\n\t.reg .b32 \t%r&lt;6&gt;;\n\t.reg .b64 \t%rd&lt;10&gt;;\n\n\tmov.u32 \t%r1, %ctaid.x;\n\tmov.u32 \t%r2, %tid.x;\n\tshl.b32 \t%r3, %r1, 5;\n\tor.b32  \t%r4, %r3, %r2;\n\tsetp.lt.u32 \t%p1, %r4, 401408;\n\t@%p1 bra \tLBB1_2;\n\tbra.uni \tLBB1_1;\nLBB1_2:\n\tld.param.u64 \t%rd4, [_copy_param_0];\n\tld.param.u64 \t%rd5, [_copy_param_1];\n\tcvta.to.global.u64 \t%rd1, %rd5;\n\tcvta.to.global.u64 \t%rd2, %rd4;\n\tcvt.u64.u32 \t%rd3, %r4;\n\tld.global.u64 \t%rd6, [%rd2+8];\n\tshl.b64 \t%rd7, %rd3, 2;\n\tadd.s64 \t%rd8, %rd6, %rd7;\n\tld.u32 \t%r5, [%rd8];\n\tadd.s64 \t%rd9, %rd1, %rd7;\n\tst.global.u32 \t[%rd9], %r5;\nLBB1_1:\n\tret;\n}\n</code></pre>\n<p>There's only one 32-bit read in this kernel, <code>ld.u32 %r5, [%rd8]</code>, so presumably that's the bad one.</p>\n<p><code>rd8</code> is the sum of <code>%rd3 &lt;&lt; 2</code> and a value read from memory.  Clearly <code>%rd3 &lt;&lt; 2</code> is aligned, so the problem must be that the value we're reading from memory is not.</p>\n<p>Not sure yet where this bad value in memory is coming from.</p>\n<p>(Incidentally, we should be able to figure out somehow that rd8 is in the global addr space and emit <code>ld.global.u32</code>.  But that's just an efficiency problem, not one of correctness.)</p>", "body_text": "Running this through cuda-memcheck, I'm seeing a bunch of errors of the form\n========= Invalid __global__ read of size 4\n=========     at 0x000000b8 in _copy\n=========     by thread (13,0,0) in block (866,0,0)\n=========     Address 0x3bdac0c83cce9646 is misaligned\n\nThat address is indeed misaligned.\nThe body of the _copy kernel (which you can get by setting the TF_CPP_MIN_VLOG_LEVEL env var to 2) is\n.visible .entry _copy(\n\t.param .u64 _copy_param_0,\n\t.param .u64 _copy_param_1,\n\t.param .u64 _copy_param_2\n)\n.maxntid 32, 1, 1\n{\n\t.reg .pred \t%p<2>;\n\t.reg .b32 \t%r<6>;\n\t.reg .b64 \t%rd<10>;\n\n\tmov.u32 \t%r1, %ctaid.x;\n\tmov.u32 \t%r2, %tid.x;\n\tshl.b32 \t%r3, %r1, 5;\n\tor.b32  \t%r4, %r3, %r2;\n\tsetp.lt.u32 \t%p1, %r4, 401408;\n\t@%p1 bra \tLBB1_2;\n\tbra.uni \tLBB1_1;\nLBB1_2:\n\tld.param.u64 \t%rd4, [_copy_param_0];\n\tld.param.u64 \t%rd5, [_copy_param_1];\n\tcvta.to.global.u64 \t%rd1, %rd5;\n\tcvta.to.global.u64 \t%rd2, %rd4;\n\tcvt.u64.u32 \t%rd3, %r4;\n\tld.global.u64 \t%rd6, [%rd2+8];\n\tshl.b64 \t%rd7, %rd3, 2;\n\tadd.s64 \t%rd8, %rd6, %rd7;\n\tld.u32 \t%r5, [%rd8];\n\tadd.s64 \t%rd9, %rd1, %rd7;\n\tst.global.u32 \t[%rd9], %r5;\nLBB1_1:\n\tret;\n}\n\nThere's only one 32-bit read in this kernel, ld.u32 %r5, [%rd8], so presumably that's the bad one.\nrd8 is the sum of %rd3 << 2 and a value read from memory.  Clearly %rd3 << 2 is aligned, so the problem must be that the value we're reading from memory is not.\nNot sure yet where this bad value in memory is coming from.\n(Incidentally, we should be able to figure out somehow that rd8 is in the global addr space and emit ld.global.u32.  But that's just an efficiency problem, not one of correctness.)", "body": "Running this through cuda-memcheck, I'm seeing a bunch of errors of the form\r\n\r\n    ========= Invalid __global__ read of size 4\r\n    =========     at 0x000000b8 in _copy\r\n    =========     by thread (13,0,0) in block (866,0,0)\r\n    =========     Address 0x3bdac0c83cce9646 is misaligned\r\n\r\nThat address is indeed misaligned.\r\n\r\nThe body of the _copy kernel (which you can get by setting the TF_CPP_MIN_VLOG_LEVEL env var to 2) is\r\n\r\n\t.visible .entry _copy(\r\n\t\t.param .u64 _copy_param_0,\r\n\t\t.param .u64 _copy_param_1,\r\n\t\t.param .u64 _copy_param_2\r\n\t)\r\n\t.maxntid 32, 1, 1\r\n\t{\r\n\t\t.reg .pred \t%p<2>;\r\n\t\t.reg .b32 \t%r<6>;\r\n\t\t.reg .b64 \t%rd<10>;\r\n\r\n\t\tmov.u32 \t%r1, %ctaid.x;\r\n\t\tmov.u32 \t%r2, %tid.x;\r\n\t\tshl.b32 \t%r3, %r1, 5;\r\n\t\tor.b32  \t%r4, %r3, %r2;\r\n\t\tsetp.lt.u32 \t%p1, %r4, 401408;\r\n\t\t@%p1 bra \tLBB1_2;\r\n\t\tbra.uni \tLBB1_1;\r\n\tLBB1_2:\r\n\t\tld.param.u64 \t%rd4, [_copy_param_0];\r\n\t\tld.param.u64 \t%rd5, [_copy_param_1];\r\n\t\tcvta.to.global.u64 \t%rd1, %rd5;\r\n\t\tcvta.to.global.u64 \t%rd2, %rd4;\r\n\t\tcvt.u64.u32 \t%rd3, %r4;\r\n\t\tld.global.u64 \t%rd6, [%rd2+8];\r\n\t\tshl.b64 \t%rd7, %rd3, 2;\r\n\t\tadd.s64 \t%rd8, %rd6, %rd7;\r\n\t\tld.u32 \t%r5, [%rd8];\r\n\t\tadd.s64 \t%rd9, %rd1, %rd7;\r\n\t\tst.global.u32 \t[%rd9], %r5;\r\n\tLBB1_1:\r\n\t\tret;\r\n\t}\r\n\r\nThere's only one 32-bit read in this kernel, `ld.u32 %r5, [%rd8]`, so presumably that's the bad one.\r\n\r\n`rd8` is the sum of `%rd3 << 2` and a value read from memory.  Clearly `%rd3 << 2` is aligned, so the problem must be that the value we're reading from memory is not.\r\n\r\nNot sure yet where this bad value in memory is coming from.\r\n\r\n(Incidentally, we should be able to figure out somehow that rd8 is in the global addr space and emit `ld.global.u32`.  But that's just an efficiency problem, not one of correctness.)"}