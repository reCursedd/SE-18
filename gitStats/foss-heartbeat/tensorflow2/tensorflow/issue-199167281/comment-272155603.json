{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/272155603", "html_url": "https://github.com/tensorflow/tensorflow/pull/6689#issuecomment-272155603", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/6689", "id": 272155603, "node_id": "MDEyOklzc3VlQ29tbWVudDI3MjE1NTYwMw==", "user": {"login": "Nayana-ibm", "id": 20816038, "node_id": "MDQ6VXNlcjIwODE2MDM4", "avatar_url": "https://avatars0.githubusercontent.com/u/20816038?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nayana-ibm", "html_url": "https://github.com/Nayana-ibm", "followers_url": "https://api.github.com/users/Nayana-ibm/followers", "following_url": "https://api.github.com/users/Nayana-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/Nayana-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nayana-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nayana-ibm/subscriptions", "organizations_url": "https://api.github.com/users/Nayana-ibm/orgs", "repos_url": "https://api.github.com/users/Nayana-ibm/repos", "events_url": "https://api.github.com/users/Nayana-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/Nayana-ibm/received_events", "type": "User", "site_admin": false}, "created_at": "2017-01-12T12:51:56Z", "updated_at": "2017-01-12T12:51:56Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=144114\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/rohan100jain\">@rohan100jain</a>  <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=20959853\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/drpngx\">@drpngx</a>  Other solution we could think is to add check for little endian platform.<br>\nBelow is the patch:</p>\n<pre><code>--- a/tensorflow/core/kernels/decode_raw_op.cc\n+++ b/tensorflow/core/kernels/decode_raw_op.cc\n@@ -69,6 +69,15 @@ class DecodeRawOp : public OpKernel {\n         context, context-&gt;allocate_output(\"output\", out_shape, &amp;output_tensor));\n     auto out = output_tensor-&gt;flat_inner_dims&lt;T&gt;();\n     DCHECK_EQ(flat_in.size(), out.dimensions()[0]);\n+\n+    if (::tensorflow::port::kLittleEndian) {\n      OP_REQUIRES(\n        context,\n        little_endian_ == ::tensorflow::port::kLittleEndian || sizeof(T) == 1,\n        errors::Unimplemented(\"Unimplemented support for little_endian=\",\n                              little_endian_ ? \"true\" : \"false\"));\n+    }\n   // Endianness matches, so just copy each string byte-for-byte.\n</code></pre>", "body_text": "@rohan100jain  @drpngx  Other solution we could think is to add check for little endian platform.\nBelow is the patch:\n--- a/tensorflow/core/kernels/decode_raw_op.cc\n+++ b/tensorflow/core/kernels/decode_raw_op.cc\n@@ -69,6 +69,15 @@ class DecodeRawOp : public OpKernel {\n         context, context->allocate_output(\"output\", out_shape, &output_tensor));\n     auto out = output_tensor->flat_inner_dims<T>();\n     DCHECK_EQ(flat_in.size(), out.dimensions()[0]);\n+\n+    if (::tensorflow::port::kLittleEndian) {\n      OP_REQUIRES(\n        context,\n        little_endian_ == ::tensorflow::port::kLittleEndian || sizeof(T) == 1,\n        errors::Unimplemented(\"Unimplemented support for little_endian=\",\n                              little_endian_ ? \"true\" : \"false\"));\n+    }\n   // Endianness matches, so just copy each string byte-for-byte.", "body": "@rohan100jain  @drpngx  Other solution we could think is to add check for little endian platform. \r\nBelow is the patch: \r\n\r\n```\r\n--- a/tensorflow/core/kernels/decode_raw_op.cc\r\n+++ b/tensorflow/core/kernels/decode_raw_op.cc\r\n@@ -69,6 +69,15 @@ class DecodeRawOp : public OpKernel {\r\n         context, context->allocate_output(\"output\", out_shape, &output_tensor));\r\n     auto out = output_tensor->flat_inner_dims<T>();\r\n     DCHECK_EQ(flat_in.size(), out.dimensions()[0]);\r\n+\r\n+    if (::tensorflow::port::kLittleEndian) {\r\n      OP_REQUIRES(\r\n        context,\r\n        little_endian_ == ::tensorflow::port::kLittleEndian || sizeof(T) == 1,\r\n        errors::Unimplemented(\"Unimplemented support for little_endian=\",\r\n                              little_endian_ ? \"true\" : \"false\"));\r\n+    }\r\n   // Endianness matches, so just copy each string byte-for-byte.\r\n ```"}