{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/10091", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/10091/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/10091/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/10091/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/10091", "id": 230292957, "node_id": "MDU6SXNzdWUyMzAyOTI5NTc=", "number": 10091, "title": "tf.assign does not change the shape of variables correctly", "user": {"login": "Catk1ns0n", "id": 20182783, "node_id": "MDQ6VXNlcjIwMTgyNzgz", "avatar_url": "https://avatars3.githubusercontent.com/u/20182783?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Catk1ns0n", "html_url": "https://github.com/Catk1ns0n", "followers_url": "https://api.github.com/users/Catk1ns0n/followers", "following_url": "https://api.github.com/users/Catk1ns0n/following{/other_user}", "gists_url": "https://api.github.com/users/Catk1ns0n/gists{/gist_id}", "starred_url": "https://api.github.com/users/Catk1ns0n/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Catk1ns0n/subscriptions", "organizations_url": "https://api.github.com/users/Catk1ns0n/orgs", "repos_url": "https://api.github.com/users/Catk1ns0n/repos", "events_url": "https://api.github.com/users/Catk1ns0n/events{/privacy}", "received_events_url": "https://api.github.com/users/Catk1ns0n/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 473184161, "node_id": "MDU6TGFiZWw0NzMxODQxNjE=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:support", "name": "type:support", "color": "159b2e", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2017-05-22T06:08:20Z", "updated_at": "2017-11-16T13:51:17Z", "closed_at": "2017-05-28T03:14:27Z", "author_association": "NONE", "body_html": "<p>Hi,</p>\n<p>I have discovered what I believe to be a bug with tf.assign. This occurs when I have a matrix with a shape, e.g. (2, 3), and assign it a new, larger matrix, e.g. with the shape (2, 4). When you get the shape of your updated variable, its shape has not changed i.e. (2, 3) is returned. Furthermore, if you use tf.add on your new matrix and a matrix with the same shape (2, 4) as the updated matrix an exception is thrown:<br>\n<code>ValueError: Dimensions must be equal, but are 3 and 4 for 'Add_2' (op: 'Add') with input shapes: [2,3], [2,4].</code></p>\n<p>Similar exceptions are also thrown when you try and use tf.matmult, tf.subtract, etc. on your updated variable.</p>\n<p>Below is an example of this issue.</p>\n<pre><code>import tensorflow as tf\n\nimport numpy as np\n\n# Initialise some variables\nsess = tf.Session()\nx = tf.Variable(tf.ones([2, 3]))\ny = tf.Variable(tf.ones([2, 3]))\nz = tf.Variable(tf.ones([2, 4]))\nsess.run(tf.variables_initializer([x, y, z]))\n\n# Print information about the original matrix\nprint(x.get_shape())\nprint(x.eval(session=sess))\nprint(tf.add(x, y).eval(session=sess))\nprint()\n\n# Enlarge the matrix by assigning it a new set of values\nsess.run(tf.assign(x, np.ones([2, 4]), validate_shape=False))\n\n# Print information about the new matrix\nprint(x.get_shape())\nprint(x.eval(session=sess))\nprint()\n\n# Try add the updated matrix to a matrix with the same ORIGINAL shape\n# I would expect this to fail because I have changed the shape\ntry:\n  print(tf.add(x, y).eval(session=sess))\nexcept:\n  print(\"Could not add x and y\")\nprint()\n\n# Try add the updated matrix to a matrix with the same shape\n# I would NOT expect this to fail because they both have the same shapes\ntry:\n  print(tf.add(x, z).eval(session=sess))\nexcept:\n  print(\"Could not add x and z\")\nprint()\n\n# Try add the updated matrix to a matrix that had the same ORIGINAL\n# shape as it, but has been updated so their actual shapes are the same\na = tf.Variable(tf.ones([2, 3]))\nsess.run(tf.variables_initializer([a,]))\nsess.run(tf.assign(a, np.ones([2, 4]), validate_shape=False))\nprint(tf.add(x, a).eval(session=sess))\n</code></pre>\n<p>The output of this code is:</p>\n<p><code></code></p><pre><code>(2, 3)<br>\n[[ 1.  1.  1.]<br>\n[ 1.  1.  1.]]<br>\n[[ 2.  2.  2.]<br>\n[ 2.  2.  2.]]<p></p>\n<p>(2, 3)<br>\n[[ 1.  1.  1.  1.]<br>\n[ 1.  1.  1.  1.]]</p>\n<p>Could not add x and y</p>\n<p>Could not add x and z</p>\n</code><p><code>[[ 2.  2.  2.  2.]<br>\n[ 2.  2.  2.  2.]]<br>\n</code></p></pre><p></p>", "body_text": "Hi,\nI have discovered what I believe to be a bug with tf.assign. This occurs when I have a matrix with a shape, e.g. (2, 3), and assign it a new, larger matrix, e.g. with the shape (2, 4). When you get the shape of your updated variable, its shape has not changed i.e. (2, 3) is returned. Furthermore, if you use tf.add on your new matrix and a matrix with the same shape (2, 4) as the updated matrix an exception is thrown:\nValueError: Dimensions must be equal, but are 3 and 4 for 'Add_2' (op: 'Add') with input shapes: [2,3], [2,4].\nSimilar exceptions are also thrown when you try and use tf.matmult, tf.subtract, etc. on your updated variable.\nBelow is an example of this issue.\nimport tensorflow as tf\n\nimport numpy as np\n\n# Initialise some variables\nsess = tf.Session()\nx = tf.Variable(tf.ones([2, 3]))\ny = tf.Variable(tf.ones([2, 3]))\nz = tf.Variable(tf.ones([2, 4]))\nsess.run(tf.variables_initializer([x, y, z]))\n\n# Print information about the original matrix\nprint(x.get_shape())\nprint(x.eval(session=sess))\nprint(tf.add(x, y).eval(session=sess))\nprint()\n\n# Enlarge the matrix by assigning it a new set of values\nsess.run(tf.assign(x, np.ones([2, 4]), validate_shape=False))\n\n# Print information about the new matrix\nprint(x.get_shape())\nprint(x.eval(session=sess))\nprint()\n\n# Try add the updated matrix to a matrix with the same ORIGINAL shape\n# I would expect this to fail because I have changed the shape\ntry:\n  print(tf.add(x, y).eval(session=sess))\nexcept:\n  print(\"Could not add x and y\")\nprint()\n\n# Try add the updated matrix to a matrix with the same shape\n# I would NOT expect this to fail because they both have the same shapes\ntry:\n  print(tf.add(x, z).eval(session=sess))\nexcept:\n  print(\"Could not add x and z\")\nprint()\n\n# Try add the updated matrix to a matrix that had the same ORIGINAL\n# shape as it, but has been updated so their actual shapes are the same\na = tf.Variable(tf.ones([2, 3]))\nsess.run(tf.variables_initializer([a,]))\nsess.run(tf.assign(a, np.ones([2, 4]), validate_shape=False))\nprint(tf.add(x, a).eval(session=sess))\n\nThe output of this code is:\n(2, 3)\n[[ 1.  1.  1.]\n[ 1.  1.  1.]]\n[[ 2.  2.  2.]\n[ 2.  2.  2.]]\n(2, 3)\n[[ 1.  1.  1.  1.]\n[ 1.  1.  1.  1.]]\nCould not add x and y\nCould not add x and z\n[[ 2.  2.  2.  2.]\n[ 2.  2.  2.  2.]]", "body": "Hi,\r\n\r\nI have discovered what I believe to be a bug with tf.assign. This occurs when I have a matrix with a shape, e.g. (2, 3), and assign it a new, larger matrix, e.g. with the shape (2, 4). When you get the shape of your updated variable, its shape has not changed i.e. (2, 3) is returned. Furthermore, if you use tf.add on your new matrix and a matrix with the same shape (2, 4) as the updated matrix an exception is thrown:\r\n`ValueError: Dimensions must be equal, but are 3 and 4 for 'Add_2' (op: 'Add') with input shapes: [2,3], [2,4].`\r\n\r\nSimilar exceptions are also thrown when you try and use tf.matmult, tf.subtract, etc. on your updated variable.\r\n\r\nBelow is an example of this issue.\r\n\r\n<pre><code>import tensorflow as tf\r\n\r\nimport numpy as np\r\n\r\n# Initialise some variables\r\nsess = tf.Session()\r\nx = tf.Variable(tf.ones([2, 3]))\r\ny = tf.Variable(tf.ones([2, 3]))\r\nz = tf.Variable(tf.ones([2, 4]))\r\nsess.run(tf.variables_initializer([x, y, z]))\r\n\r\n# Print information about the original matrix\r\nprint(x.get_shape())\r\nprint(x.eval(session=sess))\r\nprint(tf.add(x, y).eval(session=sess))\r\nprint()\r\n\r\n# Enlarge the matrix by assigning it a new set of values\r\nsess.run(tf.assign(x, np.ones([2, 4]), validate_shape=False))\r\n\r\n# Print information about the new matrix\r\nprint(x.get_shape())\r\nprint(x.eval(session=sess))\r\nprint()\r\n\r\n# Try add the updated matrix to a matrix with the same ORIGINAL shape\r\n# I would expect this to fail because I have changed the shape\r\ntry:\r\n  print(tf.add(x, y).eval(session=sess))\r\nexcept:\r\n  print(\"Could not add x and y\")\r\nprint()\r\n\r\n# Try add the updated matrix to a matrix with the same shape\r\n# I would NOT expect this to fail because they both have the same shapes\r\ntry:\r\n  print(tf.add(x, z).eval(session=sess))\r\nexcept:\r\n  print(\"Could not add x and z\")\r\nprint()\r\n\r\n# Try add the updated matrix to a matrix that had the same ORIGINAL\r\n# shape as it, but has been updated so their actual shapes are the same\r\na = tf.Variable(tf.ones([2, 3]))\r\nsess.run(tf.variables_initializer([a,]))\r\nsess.run(tf.assign(a, np.ones([2, 4]), validate_shape=False))\r\nprint(tf.add(x, a).eval(session=sess))\r\n</code></pre>\r\n\r\nThe output of this code is:\r\n\r\n<code><pre>(2, 3)\r\n[[ 1.  1.  1.]\r\n [ 1.  1.  1.]]\r\n[[ 2.  2.  2.]\r\n [ 2.  2.  2.]]\r\n\r\n(2, 3)\r\n[[ 1.  1.  1.  1.]\r\n [ 1.  1.  1.  1.]]\r\n\r\nCould not add x and y\r\n\r\nCould not add x and z\r\n\r\n[[ 2.  2.  2.  2.]\r\n [ 2.  2.  2.  2.]]\r\n</code></pre>"}