{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/354947119", "html_url": "https://github.com/tensorflow/tensorflow/issues/12054#issuecomment-354947119", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/12054", "id": 354947119, "node_id": "MDEyOklzc3VlQ29tbWVudDM1NDk0NzExOQ==", "user": {"login": "leandro-gracia-gil", "id": 8785797, "node_id": "MDQ6VXNlcjg3ODU3OTc=", "avatar_url": "https://avatars1.githubusercontent.com/u/8785797?v=4", "gravatar_id": "", "url": "https://api.github.com/users/leandro-gracia-gil", "html_url": "https://github.com/leandro-gracia-gil", "followers_url": "https://api.github.com/users/leandro-gracia-gil/followers", "following_url": "https://api.github.com/users/leandro-gracia-gil/following{/other_user}", "gists_url": "https://api.github.com/users/leandro-gracia-gil/gists{/gist_id}", "starred_url": "https://api.github.com/users/leandro-gracia-gil/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/leandro-gracia-gil/subscriptions", "organizations_url": "https://api.github.com/users/leandro-gracia-gil/orgs", "repos_url": "https://api.github.com/users/leandro-gracia-gil/repos", "events_url": "https://api.github.com/users/leandro-gracia-gil/events{/privacy}", "received_events_url": "https://api.github.com/users/leandro-gracia-gil/received_events", "type": "User", "site_admin": false}, "created_at": "2018-01-03T06:55:34Z", "updated_at": "2018-01-03T06:55:34Z", "author_association": "CONTRIBUTOR", "body_html": "<p>While I'm not against closing this, I disagree with the idea that the new tf.data API should deprecate the queue API. While tf.data does a pretty good job to simplify input pipelines, queues can also be used to perform more complex tasks like synchronizing distributed jobs within the TF graph and creating message pipelines across them.</p>\n<p>For example, a tf.FIFOQueue can also be used as a distributed semaphore that locks in two ways: when acquiring with value (size) zero and when releasing with value of N (capacity). This can be used to perform mutually exclusive operations in different jobs if needed, creating distributed barriers and so on.</p>\n<p>Similarly tf.FIFOQueue and tf.PaddingFIFOQueue can be used to implement a tensor-based messaging system across jobs.</p>\n<p>Note that using python synchronization mechanisms is not always an alternative. For example, in my use case all I can use are TF operations restored from a graph def that I call using the C API in Windows. In that case being able to do all the above within the TF graph is a must.</p>\n<p>So, please, consider not deprecating queues even if their API is frozen. They do have more uses than just setting up an input pipeline.</p>", "body_text": "While I'm not against closing this, I disagree with the idea that the new tf.data API should deprecate the queue API. While tf.data does a pretty good job to simplify input pipelines, queues can also be used to perform more complex tasks like synchronizing distributed jobs within the TF graph and creating message pipelines across them.\nFor example, a tf.FIFOQueue can also be used as a distributed semaphore that locks in two ways: when acquiring with value (size) zero and when releasing with value of N (capacity). This can be used to perform mutually exclusive operations in different jobs if needed, creating distributed barriers and so on.\nSimilarly tf.FIFOQueue and tf.PaddingFIFOQueue can be used to implement a tensor-based messaging system across jobs.\nNote that using python synchronization mechanisms is not always an alternative. For example, in my use case all I can use are TF operations restored from a graph def that I call using the C API in Windows. In that case being able to do all the above within the TF graph is a must.\nSo, please, consider not deprecating queues even if their API is frozen. They do have more uses than just setting up an input pipeline.", "body": "While I'm not against closing this, I disagree with the idea that the new tf.data API should deprecate the queue API. While tf.data does a pretty good job to simplify input pipelines, queues can also be used to perform more complex tasks like synchronizing distributed jobs within the TF graph and creating message pipelines across them.\r\n\r\nFor example, a tf.FIFOQueue can also be used as a distributed semaphore that locks in two ways: when acquiring with value (size) zero and when releasing with value of N (capacity). This can be used to perform mutually exclusive operations in different jobs if needed, creating distributed barriers and so on.\r\n\r\nSimilarly tf.FIFOQueue and tf.PaddingFIFOQueue can be used to implement a tensor-based messaging system across jobs.\r\n\r\nNote that using python synchronization mechanisms is not always an alternative. For example, in my use case all I can use are TF operations restored from a graph def that I call using the C API in Windows. In that case being able to do all the above within the TF graph is a must.\r\n\r\nSo, please, consider not deprecating queues even if their API is frozen. They do have more uses than just setting up an input pipeline."}