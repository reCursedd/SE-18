{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/14655", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/14655/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/14655/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/14655/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/14655", "id": 274875168, "node_id": "MDU6SXNzdWUyNzQ4NzUxNjg=", "number": 14655, "title": "Support dynamic partition in loss function", "user": {"login": "jfpuget", "id": 10423052, "node_id": "MDQ6VXNlcjEwNDIzMDUy", "avatar_url": "https://avatars3.githubusercontent.com/u/10423052?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jfpuget", "html_url": "https://github.com/jfpuget", "followers_url": "https://api.github.com/users/jfpuget/followers", "following_url": "https://api.github.com/users/jfpuget/following{/other_user}", "gists_url": "https://api.github.com/users/jfpuget/gists{/gist_id}", "starred_url": "https://api.github.com/users/jfpuget/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jfpuget/subscriptions", "organizations_url": "https://api.github.com/users/jfpuget/orgs", "repos_url": "https://api.github.com/users/jfpuget/repos", "events_url": "https://api.github.com/users/jfpuget/events{/privacy}", "received_events_url": "https://api.github.com/users/jfpuget/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 386191887, "node_id": "MDU6TGFiZWwzODYxOTE4ODc=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:awaiting%20response", "name": "stat:awaiting response", "color": "f4b400", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 16, "created_at": "2017-11-17T14:05:50Z", "updated_at": "2018-07-02T00:46:11Z", "closed_at": "2017-11-20T14:34:45Z", "author_association": "NONE", "body_html": "<h3>System information</h3>\n<p>Python 3.6.1, Ubuntu 16.04, TF 1.3</p>\n<h3>Describe the problem</h3>\n<p>I am trying to implement a loss function in Tensorflow similar to the Theano loss function described here: <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"189002256\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/Lasagne/Lasagne/issues/767\" data-hovercard-type=\"issue\" data-hovercard-url=\"/Lasagne/Lasagne/issues/767/hovercard\" href=\"https://github.com/Lasagne/Lasagne/issues/767\">Lasagne/Lasagne#767</a></p>\n<p>I have tried several code but they all lead to runtime error.  Seems that dynamically sized tensors aren't supported in loss function.  I have tried various optimizers, including adam, without success.</p>\n<p>When tested standalone, the function works fine and produces results similar to a numpy based implementation.</p>\n<h3>Source code / logs</h3>\n<p>Here is one code I tried:</p>\n<pre><code>import tensorflow as tf\n\ndef pair_loss(y_true, y_pred):\n    y_true = tf.cast(y_true, tf.int32)\n    parts = tf.dynamic_partition(y_pred, y_true, 2)\n    y_pos = parts[1]\n    y_neg = parts[0]\n    y_pos = tf.expand_dims(y_pos, 0)\n    y_neg = tf.expand_dims(y_neg, -1)\n    out = tf.sigmoid(y_neg - y_pos)\n    return tf.reduce_mean(out, axis=-1)\n</code></pre>\n<p>Here is the theano code for reference:</p>\n<pre><code>import theano\n\ndef calc_auroc_loss(pred_vr, y_vr):\n    pos_pred_vr = pred_vr[y_vr.nonzero()]\n    neg_pred_vr = pred_vr[theano.tensor.eq(y_vr, 0).nonzero()]\n    pred_diffs_vr = pos_pred_vr.dimshuffle(0, 'x') - neg_pred_vr.dimshuffle('x', 0)\n    num_pairs_vr = theano.tensor.sum(theano.tensor.eq(y_vr, 1)) * theano.tensor.sum(theano.tensor.eq(y_vr, 0))\n    auroc_vr = theano.tensor.sum(theano.tensor.nnet.sigmoid(pred_diffs_vr)) / num_pairs_vr\n    return -auroc_vr\n</code></pre>", "body_text": "System information\nPython 3.6.1, Ubuntu 16.04, TF 1.3\nDescribe the problem\nI am trying to implement a loss function in Tensorflow similar to the Theano loss function described here: Lasagne/Lasagne#767\nI have tried several code but they all lead to runtime error.  Seems that dynamically sized tensors aren't supported in loss function.  I have tried various optimizers, including adam, without success.\nWhen tested standalone, the function works fine and produces results similar to a numpy based implementation.\nSource code / logs\nHere is one code I tried:\nimport tensorflow as tf\n\ndef pair_loss(y_true, y_pred):\n    y_true = tf.cast(y_true, tf.int32)\n    parts = tf.dynamic_partition(y_pred, y_true, 2)\n    y_pos = parts[1]\n    y_neg = parts[0]\n    y_pos = tf.expand_dims(y_pos, 0)\n    y_neg = tf.expand_dims(y_neg, -1)\n    out = tf.sigmoid(y_neg - y_pos)\n    return tf.reduce_mean(out, axis=-1)\n\nHere is the theano code for reference:\nimport theano\n\ndef calc_auroc_loss(pred_vr, y_vr):\n    pos_pred_vr = pred_vr[y_vr.nonzero()]\n    neg_pred_vr = pred_vr[theano.tensor.eq(y_vr, 0).nonzero()]\n    pred_diffs_vr = pos_pred_vr.dimshuffle(0, 'x') - neg_pred_vr.dimshuffle('x', 0)\n    num_pairs_vr = theano.tensor.sum(theano.tensor.eq(y_vr, 1)) * theano.tensor.sum(theano.tensor.eq(y_vr, 0))\n    auroc_vr = theano.tensor.sum(theano.tensor.nnet.sigmoid(pred_diffs_vr)) / num_pairs_vr\n    return -auroc_vr", "body": "\r\n\r\n### System information\r\n\r\nPython 3.6.1, Ubuntu 16.04, TF 1.3\r\n\r\n### Describe the problem\r\n\r\nI am trying to implement a loss function in Tensorflow similar to the Theano loss function described here: https://github.com/Lasagne/Lasagne/issues/767\r\n\r\nI have tried several code but they all lead to runtime error.  Seems that dynamically sized tensors aren't supported in loss function.  I have tried various optimizers, including adam, without success.\r\n\r\nWhen tested standalone, the function works fine and produces results similar to a numpy based implementation.\r\n\r\n### Source code / logs\r\n  Here is one code I tried:\r\n\r\n    import tensorflow as tf\r\n    \r\n    def pair_loss(y_true, y_pred):\r\n        y_true = tf.cast(y_true, tf.int32)\r\n        parts = tf.dynamic_partition(y_pred, y_true, 2)\r\n        y_pos = parts[1]\r\n        y_neg = parts[0]\r\n        y_pos = tf.expand_dims(y_pos, 0)\r\n        y_neg = tf.expand_dims(y_neg, -1)\r\n        out = tf.sigmoid(y_neg - y_pos)\r\n        return tf.reduce_mean(out, axis=-1)\r\n\r\nHere is the theano code for reference:\r\n\r\n    import theano\r\n    \r\n    def calc_auroc_loss(pred_vr, y_vr):\r\n        pos_pred_vr = pred_vr[y_vr.nonzero()]\r\n        neg_pred_vr = pred_vr[theano.tensor.eq(y_vr, 0).nonzero()]\r\n        pred_diffs_vr = pos_pred_vr.dimshuffle(0, 'x') - neg_pred_vr.dimshuffle('x', 0)\r\n        num_pairs_vr = theano.tensor.sum(theano.tensor.eq(y_vr, 1)) * theano.tensor.sum(theano.tensor.eq(y_vr, 0))\r\n        auroc_vr = theano.tensor.sum(theano.tensor.nnet.sigmoid(pred_diffs_vr)) / num_pairs_vr\r\n        return -auroc_vr"}