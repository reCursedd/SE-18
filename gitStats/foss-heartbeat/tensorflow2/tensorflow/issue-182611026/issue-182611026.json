{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/4920", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/4920/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/4920/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/4920/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/4920", "id": 182611026, "node_id": "MDU6SXNzdWUxODI2MTEwMjY=", "number": 4920, "title": "Better support for initializing variables that depend on each other", "user": {"login": "yaroslavvb", "id": 23068, "node_id": "MDQ6VXNlcjIzMDY4", "avatar_url": "https://avatars3.githubusercontent.com/u/23068?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yaroslavvb", "html_url": "https://github.com/yaroslavvb", "followers_url": "https://api.github.com/users/yaroslavvb/followers", "following_url": "https://api.github.com/users/yaroslavvb/following{/other_user}", "gists_url": "https://api.github.com/users/yaroslavvb/gists{/gist_id}", "starred_url": "https://api.github.com/users/yaroslavvb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yaroslavvb/subscriptions", "organizations_url": "https://api.github.com/users/yaroslavvb/orgs", "repos_url": "https://api.github.com/users/yaroslavvb/repos", "events_url": "https://api.github.com/users/yaroslavvb/events{/privacy}", "received_events_url": "https://api.github.com/users/yaroslavvb/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 299643928, "node_id": "MDU6TGFiZWwyOTk2NDM5Mjg=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:contributions%20welcome", "name": "stat:contributions welcome", "color": "f4b400", "default": false}, {"id": 473173272, "node_id": "MDU6TGFiZWw0NzMxNzMyNzI=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:feature", "name": "type:feature", "color": "159b2e", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 31, "created_at": "2016-10-12T19:21:13Z", "updated_at": "2017-07-11T18:01:35Z", "closed_at": "2017-06-16T20:28:51Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Currently there's no easy way to properly initialize variables when some variables initial values depend on other variables, and initialization has to be split over several <code>.run</code> calls. This kind of initialization happens with data-dependent parameter init.</p>\n<p>This could be solved if there were something like <code>var.initialized_value()</code>, but which only runs initializer if the variable hasn't been initialized already.</p>\n<p>Example:</p>\n<pre><code>a = tf.get_variable(\"a\", shape=())\nb = tf.get_variable(\"b\", initializer=a.initialized_value())\nc = tf.placeholder(tf.float32, shape=())\nd = tf.get_variable(\"d\", initializer=a.initialized_value()+c)\n\nsess.run([a.initializer, b.initializer])\nsess.run([d.initializer], feed_dict={c: 0})\nsess.run([a, b, d])\n\nOut[]: [0.30858743, -1.2756943, 0.30858743]\n</code></pre>\n<p>Here, <code>a</code> and <code>b</code> end up with different values because initializer for <code>a</code> has been run twice, which is counter-intuitive, the user expects <code>a,b,d</code> to have same values</p>", "body_text": "Currently there's no easy way to properly initialize variables when some variables initial values depend on other variables, and initialization has to be split over several .run calls. This kind of initialization happens with data-dependent parameter init.\nThis could be solved if there were something like var.initialized_value(), but which only runs initializer if the variable hasn't been initialized already.\nExample:\na = tf.get_variable(\"a\", shape=())\nb = tf.get_variable(\"b\", initializer=a.initialized_value())\nc = tf.placeholder(tf.float32, shape=())\nd = tf.get_variable(\"d\", initializer=a.initialized_value()+c)\n\nsess.run([a.initializer, b.initializer])\nsess.run([d.initializer], feed_dict={c: 0})\nsess.run([a, b, d])\n\nOut[]: [0.30858743, -1.2756943, 0.30858743]\n\nHere, a and b end up with different values because initializer for a has been run twice, which is counter-intuitive, the user expects a,b,d to have same values", "body": "Currently there's no easy way to properly initialize variables when some variables initial values depend on other variables, and initialization has to be split over several `.run` calls. This kind of initialization happens with data-dependent parameter init.\n\nThis could be solved if there were something like `var.initialized_value()`, but which only runs initializer if the variable hasn't been initialized already.\n\nExample:\n\n```\na = tf.get_variable(\"a\", shape=())\nb = tf.get_variable(\"b\", initializer=a.initialized_value())\nc = tf.placeholder(tf.float32, shape=())\nd = tf.get_variable(\"d\", initializer=a.initialized_value()+c)\n\nsess.run([a.initializer, b.initializer])\nsess.run([d.initializer], feed_dict={c: 0})\nsess.run([a, b, d])\n\nOut[]: [0.30858743, -1.2756943, 0.30858743]\n```\n\nHere, `a` and `b` end up with different values because initializer for `a` has been run twice, which is counter-intuitive, the user expects `a,b,d` to have same values\n"}