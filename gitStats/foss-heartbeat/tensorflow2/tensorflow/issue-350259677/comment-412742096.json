{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/412742096", "html_url": "https://github.com/tensorflow/tensorflow/issues/21590#issuecomment-412742096", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/21590", "id": 412742096, "node_id": "MDEyOklzc3VlQ29tbWVudDQxMjc0MjA5Ng==", "user": {"login": "tavramov", "id": 30814992, "node_id": "MDQ6VXNlcjMwODE0OTky", "avatar_url": "https://avatars2.githubusercontent.com/u/30814992?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tavramov", "html_url": "https://github.com/tavramov", "followers_url": "https://api.github.com/users/tavramov/followers", "following_url": "https://api.github.com/users/tavramov/following{/other_user}", "gists_url": "https://api.github.com/users/tavramov/gists{/gist_id}", "starred_url": "https://api.github.com/users/tavramov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tavramov/subscriptions", "organizations_url": "https://api.github.com/users/tavramov/orgs", "repos_url": "https://api.github.com/users/tavramov/repos", "events_url": "https://api.github.com/users/tavramov/events{/privacy}", "received_events_url": "https://api.github.com/users/tavramov/received_events", "type": "User", "site_admin": false}, "created_at": "2018-08-14T03:22:04Z", "updated_at": "2018-08-14T03:22:04Z", "author_association": "NONE", "body_html": "<p>Another experiment does point to the root cause being the <code>num_epochs=1</code> argument in <code>tf.estimator.inputs.numpy_input_fn()</code></p>\n<p>The evaluation metrics get evaluated properly if the input_fn is defined like this:</p>\n<pre><code>  eval_input_fn = tf.estimator.inputs.numpy_input_fn(\n      x={\"x\": eval_data},\n      y=eval_labels,\n      num_epochs=None,\n      shuffle=False)\n</code></pre>\n<p>And of course to avoid an infinite loop, one must define the steps argument in <code>InMemoryEvaluatorHook</code>:</p>\n<p><code>evaluator = tf.contrib.estimator.InMemoryEvaluatorHook(estimator=mnist_classifier, input_fn=eval_input_fn, every_n_iter=50, steps 1000)</code></p>\n<p>Output with these changes looks like this:<br>\nINFO:tensorflow:Saving dict for global step 0: accuracy = 0.0903359, global_step = 0, loss = 2.30868<br>\nINFO:tensorflow:Saving dict for global step 50: accuracy = 0.114852, global_step = 50, loss = 2.301<br>\nINFO:tensorflow:Saving dict for global step 100: accuracy = 0.149109, global_step = 100, loss = 2.29303<br>\nINFO:tensorflow:Saving dict for global step 150: accuracy = 0.196461, global_step = 150, loss = 2.28513<br>\nINFO:tensorflow:Saving dict for global step 200: accuracy = 0.23625, global_step = 200, loss = 2.27739</p>", "body_text": "Another experiment does point to the root cause being the num_epochs=1 argument in tf.estimator.inputs.numpy_input_fn()\nThe evaluation metrics get evaluated properly if the input_fn is defined like this:\n  eval_input_fn = tf.estimator.inputs.numpy_input_fn(\n      x={\"x\": eval_data},\n      y=eval_labels,\n      num_epochs=None,\n      shuffle=False)\n\nAnd of course to avoid an infinite loop, one must define the steps argument in InMemoryEvaluatorHook:\nevaluator = tf.contrib.estimator.InMemoryEvaluatorHook(estimator=mnist_classifier, input_fn=eval_input_fn, every_n_iter=50, steps 1000)\nOutput with these changes looks like this:\nINFO:tensorflow:Saving dict for global step 0: accuracy = 0.0903359, global_step = 0, loss = 2.30868\nINFO:tensorflow:Saving dict for global step 50: accuracy = 0.114852, global_step = 50, loss = 2.301\nINFO:tensorflow:Saving dict for global step 100: accuracy = 0.149109, global_step = 100, loss = 2.29303\nINFO:tensorflow:Saving dict for global step 150: accuracy = 0.196461, global_step = 150, loss = 2.28513\nINFO:tensorflow:Saving dict for global step 200: accuracy = 0.23625, global_step = 200, loss = 2.27739", "body": "Another experiment does point to the root cause being the `num_epochs=1` argument in `tf.estimator.inputs.numpy_input_fn()`\r\n\r\nThe evaluation metrics get evaluated properly if the input_fn is defined like this:\r\n```\r\n  eval_input_fn = tf.estimator.inputs.numpy_input_fn(\r\n      x={\"x\": eval_data},\r\n      y=eval_labels,\r\n      num_epochs=None,\r\n      shuffle=False)\r\n```\r\nAnd of course to avoid an infinite loop, one must define the steps argument in `InMemoryEvaluatorHook`:\r\n\r\n`evaluator = tf.contrib.estimator.InMemoryEvaluatorHook(estimator=mnist_classifier, input_fn=eval_input_fn, every_n_iter=50, steps 1000)`\r\n\r\nOutput with these changes looks like this:\r\nINFO:tensorflow:Saving dict for global step 0: accuracy = 0.0903359, global_step = 0, loss = 2.30868\r\nINFO:tensorflow:Saving dict for global step 50: accuracy = 0.114852, global_step = 50, loss = 2.301\r\nINFO:tensorflow:Saving dict for global step 100: accuracy = 0.149109, global_step = 100, loss = 2.29303\r\nINFO:tensorflow:Saving dict for global step 150: accuracy = 0.196461, global_step = 150, loss = 2.28513\r\nINFO:tensorflow:Saving dict for global step 200: accuracy = 0.23625, global_step = 200, loss = 2.27739"}