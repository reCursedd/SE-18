{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/400621173", "html_url": "https://github.com/tensorflow/tensorflow/pull/20284#issuecomment-400621173", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/20284", "id": 400621173, "node_id": "MDEyOklzc3VlQ29tbWVudDQwMDYyMTE3Mw==", "user": {"login": "msarahan", "id": 38393, "node_id": "MDQ6VXNlcjM4Mzkz", "avatar_url": "https://avatars3.githubusercontent.com/u/38393?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msarahan", "html_url": "https://github.com/msarahan", "followers_url": "https://api.github.com/users/msarahan/followers", "following_url": "https://api.github.com/users/msarahan/following{/other_user}", "gists_url": "https://api.github.com/users/msarahan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msarahan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msarahan/subscriptions", "organizations_url": "https://api.github.com/users/msarahan/orgs", "repos_url": "https://api.github.com/users/msarahan/repos", "events_url": "https://api.github.com/users/msarahan/events{/privacy}", "received_events_url": "https://api.github.com/users/msarahan/received_events", "type": "User", "site_admin": false}, "created_at": "2018-06-27T10:23:12Z", "updated_at": "2018-06-27T10:23:12Z", "author_association": "NONE", "body_html": "<p>Thanks <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=363227\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/perfinion\">@perfinion</a>.  The problem with hardcoded paths at all is that we don't really use them for conda packages.  $PREFIX points to some path that looks like /usr or /usr/local (with include, bin, and lib subdirs), but it is not a fixed path.  For example, during a package build, it will be something like</p>\n<p><code>/home/msarahan/miniconda3/conda-bld/tensorflow_(timestamp)/_h_env_(pad)</code></p>\n<p>with (pad) representing enough placeholder characters to get us to a 255 character padding for any fixed paths that get baked into binaries.  That's essential to relocatability.</p>\n<p>Not having dynamic paths is a pretty big non-starter for us.</p>\n<p>Adding --action_env=PREFIX is definitely something I knew we'd need to use - I'm just curious about how to incorporate that into the BUILD files.</p>\n<p>To put headers and libs onto the search paths, I first symlinked my $PREFIX var in my build script to a location within the Tensforflow third_party folder, and added that folder to the include and link paths:</p>\n<pre><code>licenses([\"notice\"])  # BSD/MIT-like license\n\nfilegroup(\n    name = \"LICENSE\",\n    visibility = [\"//visibility:public\"],\n)\n\ncc_library(\n    name = \"png\",\n    copts = [\"-Ithird_party/systemlibs/include\"],\n    linkopts = [\"-lpng\", \"-Lthirdparty/systemlibs/lib\"],\n    visibility = [\"//visibility:public\"],\n)\n</code></pre>\n<p>That worked OK, seemingly.  Next I was hung up on the hard-coded paths as I mentioned before.  I began to try something a little different, based on what I found at <a href=\"https://stackoverflow.com/questions/43928653/call-llvm-config-prefix-and-use-it-in-a-build-rule/43936381#43936381\" rel=\"nofollow\">https://stackoverflow.com/questions/43928653/call-llvm-config-prefix-and-use-it-in-a-build-rule/43936381#43936381</a>.</p>\n<p>I removed the BUILD files completely, and instead tried to generate them more dynamically:</p>\n<pre><code>def _curl_impl(repository_ctx):\n  prefix_path = repository_ctx.os.getenv(\"PREFIX\", \"/usr\")\n  repository_ctx.symlink(prefix_path, \"external_prefix\")\n  repository_ctx.file(\"curl.BUILD\", \"\"\"\nlicenses([\"notice\"])  # MIT/X derivative license\n\nfilegroup(\n    name = \"COPYING\",\n    visibility = [\"//visibility:public\"],\n)\n\ncc_library(\n    name = \"curl\",\n    copts = [\"-Iexternal_prefix/include\"],\n    linkopts = [\"-lcurl\", \"-Lexternal_prefix/lib\"],\n    visibility = [\"//visibility:public\"],\n)\n\"\"\")\n</code></pre>\n<p>I have not gotten this working yet, but I think it might work.  It would still require --action_env=PREFIX, but that's fine with me.  Any thoughts on the viability of this approach?  It need not be part of this PR, if it is better to get this initial work in and then adapt.</p>", "body_text": "Thanks @perfinion.  The problem with hardcoded paths at all is that we don't really use them for conda packages.  $PREFIX points to some path that looks like /usr or /usr/local (with include, bin, and lib subdirs), but it is not a fixed path.  For example, during a package build, it will be something like\n/home/msarahan/miniconda3/conda-bld/tensorflow_(timestamp)/_h_env_(pad)\nwith (pad) representing enough placeholder characters to get us to a 255 character padding for any fixed paths that get baked into binaries.  That's essential to relocatability.\nNot having dynamic paths is a pretty big non-starter for us.\nAdding --action_env=PREFIX is definitely something I knew we'd need to use - I'm just curious about how to incorporate that into the BUILD files.\nTo put headers and libs onto the search paths, I first symlinked my $PREFIX var in my build script to a location within the Tensforflow third_party folder, and added that folder to the include and link paths:\nlicenses([\"notice\"])  # BSD/MIT-like license\n\nfilegroup(\n    name = \"LICENSE\",\n    visibility = [\"//visibility:public\"],\n)\n\ncc_library(\n    name = \"png\",\n    copts = [\"-Ithird_party/systemlibs/include\"],\n    linkopts = [\"-lpng\", \"-Lthirdparty/systemlibs/lib\"],\n    visibility = [\"//visibility:public\"],\n)\n\nThat worked OK, seemingly.  Next I was hung up on the hard-coded paths as I mentioned before.  I began to try something a little different, based on what I found at https://stackoverflow.com/questions/43928653/call-llvm-config-prefix-and-use-it-in-a-build-rule/43936381#43936381.\nI removed the BUILD files completely, and instead tried to generate them more dynamically:\ndef _curl_impl(repository_ctx):\n  prefix_path = repository_ctx.os.getenv(\"PREFIX\", \"/usr\")\n  repository_ctx.symlink(prefix_path, \"external_prefix\")\n  repository_ctx.file(\"curl.BUILD\", \"\"\"\nlicenses([\"notice\"])  # MIT/X derivative license\n\nfilegroup(\n    name = \"COPYING\",\n    visibility = [\"//visibility:public\"],\n)\n\ncc_library(\n    name = \"curl\",\n    copts = [\"-Iexternal_prefix/include\"],\n    linkopts = [\"-lcurl\", \"-Lexternal_prefix/lib\"],\n    visibility = [\"//visibility:public\"],\n)\n\"\"\")\n\nI have not gotten this working yet, but I think it might work.  It would still require --action_env=PREFIX, but that's fine with me.  Any thoughts on the viability of this approach?  It need not be part of this PR, if it is better to get this initial work in and then adapt.", "body": "Thanks @perfinion.  The problem with hardcoded paths at all is that we don't really use them for conda packages.  $PREFIX points to some path that looks like /usr or /usr/local (with include, bin, and lib subdirs), but it is not a fixed path.  For example, during a package build, it will be something like  \r\n\r\n``/home/msarahan/miniconda3/conda-bld/tensorflow_(timestamp)/_h_env_(pad)``\r\n\r\nwith (pad) representing enough placeholder characters to get us to a 255 character padding for any fixed paths that get baked into binaries.  That's essential to relocatability.\r\n\r\nNot having dynamic paths is a pretty big non-starter for us.\r\n\r\nAdding --action_env=PREFIX is definitely something I knew we'd need to use - I'm just curious about how to incorporate that into the BUILD files.\r\n\r\nTo put headers and libs onto the search paths, I first symlinked my $PREFIX var in my build script to a location within the Tensforflow third_party folder, and added that folder to the include and link paths:\r\n\r\n```\r\nlicenses([\"notice\"])  # BSD/MIT-like license\r\n\r\nfilegroup(\r\n    name = \"LICENSE\",\r\n    visibility = [\"//visibility:public\"],\r\n)\r\n\r\ncc_library(\r\n    name = \"png\",\r\n    copts = [\"-Ithird_party/systemlibs/include\"],\r\n    linkopts = [\"-lpng\", \"-Lthirdparty/systemlibs/lib\"],\r\n    visibility = [\"//visibility:public\"],\r\n)\r\n```\r\n\r\nThat worked OK, seemingly.  Next I was hung up on the hard-coded paths as I mentioned before.  I began to try something a little different, based on what I found at https://stackoverflow.com/questions/43928653/call-llvm-config-prefix-and-use-it-in-a-build-rule/43936381#43936381.\r\n\r\nI removed the BUILD files completely, and instead tried to generate them more dynamically:\r\n\r\n```\r\ndef _curl_impl(repository_ctx):\r\n  prefix_path = repository_ctx.os.getenv(\"PREFIX\", \"/usr\")\r\n  repository_ctx.symlink(prefix_path, \"external_prefix\")\r\n  repository_ctx.file(\"curl.BUILD\", \"\"\"\r\nlicenses([\"notice\"])  # MIT/X derivative license\r\n\r\nfilegroup(\r\n    name = \"COPYING\",\r\n    visibility = [\"//visibility:public\"],\r\n)\r\n\r\ncc_library(\r\n    name = \"curl\",\r\n    copts = [\"-Iexternal_prefix/include\"],\r\n    linkopts = [\"-lcurl\", \"-Lexternal_prefix/lib\"],\r\n    visibility = [\"//visibility:public\"],\r\n)\r\n\"\"\")\r\n```\r\n\r\nI have not gotten this working yet, but I think it might work.  It would still require --action_env=PREFIX, but that's fine with me.  Any thoughts on the viability of this approach?  It need not be part of this PR, if it is better to get this initial work in and then adapt."}