{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/214449629", "html_url": "https://github.com/tensorflow/tensorflow/issues/2050#issuecomment-214449629", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2050", "id": 214449629, "node_id": "MDEyOklzc3VlQ29tbWVudDIxNDQ0OTYyOQ==", "user": {"login": "decentralion", "id": 1400023, "node_id": "MDQ6VXNlcjE0MDAwMjM=", "avatar_url": "https://avatars2.githubusercontent.com/u/1400023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/decentralion", "html_url": "https://github.com/decentralion", "followers_url": "https://api.github.com/users/decentralion/followers", "following_url": "https://api.github.com/users/decentralion/following{/other_user}", "gists_url": "https://api.github.com/users/decentralion/gists{/gist_id}", "starred_url": "https://api.github.com/users/decentralion/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/decentralion/subscriptions", "organizations_url": "https://api.github.com/users/decentralion/orgs", "repos_url": "https://api.github.com/users/decentralion/repos", "events_url": "https://api.github.com/users/decentralion/events{/privacy}", "received_events_url": "https://api.github.com/users/decentralion/received_events", "type": "User", "site_admin": false}, "created_at": "2016-04-25T17:24:38Z", "updated_at": "2016-04-25T17:24:38Z", "author_association": "CONTRIBUTOR", "body_html": "<p>I see; that makes sense then. Your help with adding this feature would be extremely welcome :) here's an overview of how we could do it.</p>\n<p>Overall, TensorBoard consists of a few major pieces. On the backend, there are the <a href=\"https://github.com/tensorflow/tensorflow/blob/0ebbb99084091bba963f7b452d9f2fa93c70f6e2/tensorflow/python/summary/event_multiplexer.py\"><code>EventMultiplexer</code></a> and <a href=\"https://github.com/tensorflow/tensorflow/blob/0ebbb99084091bba963f7b452d9f2fa93c70f6e2/tensorflow/python/summary/event_accumulator.py\"><code>EventAccumulator</code></a>, a pair of classes which provide an API for accessing summary data from TensorFlow.</p>\n<p>The <a href=\"https://github.com/tensorflow/tensorflow/blob/0ebbb99084091bba963f7b452d9f2fa93c70f6e2/tensorflow/tensorboard/backend/server.py\"><code>Server</code></a> instantiates these classes and creates a <code>MultiplexerReloadingThread</code> which sets a timer to automatically reload the <code>Multiplexer</code>. If the <code>Multiplexer</code> is already caught-up to historical data, it will generally load very quickly, but if you just turned TensorBoard on and it has 5 gigs of historical data to chew through, it may take a while.</p>\n<p><a href=\"https://github.com/tensorflow/tensorflow/blob/0ebbb99084091bba963f7b452d9f2fa93c70f6e2/tensorflow/tensorboard/backend/handler.py#L460\"><code>handler.py</code></a> contains all the handlers for the server's routes. The API is documented in the file <a href=\"https://github.com/tensorflow/tensorflow/blob/0ebbb99084091bba963f7b452d9f2fa93c70f6e2/tensorflow/tensorboard/http_api.md\">http_api.md</a>. Please take a moment to read that (the next paragraph will assume some familiarity).</p>\n<p>The way reloading works is as follows: the user clicks the reload button, which calls the <code>reload</code> method that is implemented by <code>TF.Backend.Behavior</code>. The behavior first reloads the run-tag mapping, and then triggers every existing data display element (e.g. a chart or image loader) to reload.</p>\n<p>Thus, if we want to have the reload trigger a backend reload, we should have the first method that is called on the backend (the <code>runs</code> route) delay while the backend reloads. I think a good way to implement this would be to have an optional query parameter passed to the route (?reload), and if the query is present, then rather than respond immediately, the server reloads the backend and then responds.</p>\n<p>However, as I mentioned above, the reload may take a long time if the server just turned on and there is a lot of historical data to explore. So we'll need to have a timeout, say 5s - if the backend reload takes more than 5 seconds, then we resolve early even though we aren't done loading.</p>\n<p>It would be really nice to further return some info on whether the backend is done loading or not so we can put a little \"data still loading!\" type indicator, but this change is complicated enough without doing that :)</p>\n<p>Does that seem reasonable?</p>", "body_text": "I see; that makes sense then. Your help with adding this feature would be extremely welcome :) here's an overview of how we could do it.\nOverall, TensorBoard consists of a few major pieces. On the backend, there are the EventMultiplexer and EventAccumulator, a pair of classes which provide an API for accessing summary data from TensorFlow.\nThe Server instantiates these classes and creates a MultiplexerReloadingThread which sets a timer to automatically reload the Multiplexer. If the Multiplexer is already caught-up to historical data, it will generally load very quickly, but if you just turned TensorBoard on and it has 5 gigs of historical data to chew through, it may take a while.\nhandler.py contains all the handlers for the server's routes. The API is documented in the file http_api.md. Please take a moment to read that (the next paragraph will assume some familiarity).\nThe way reloading works is as follows: the user clicks the reload button, which calls the reload method that is implemented by TF.Backend.Behavior. The behavior first reloads the run-tag mapping, and then triggers every existing data display element (e.g. a chart or image loader) to reload.\nThus, if we want to have the reload trigger a backend reload, we should have the first method that is called on the backend (the runs route) delay while the backend reloads. I think a good way to implement this would be to have an optional query parameter passed to the route (?reload), and if the query is present, then rather than respond immediately, the server reloads the backend and then responds.\nHowever, as I mentioned above, the reload may take a long time if the server just turned on and there is a lot of historical data to explore. So we'll need to have a timeout, say 5s - if the backend reload takes more than 5 seconds, then we resolve early even though we aren't done loading.\nIt would be really nice to further return some info on whether the backend is done loading or not so we can put a little \"data still loading!\" type indicator, but this change is complicated enough without doing that :)\nDoes that seem reasonable?", "body": "I see; that makes sense then. Your help with adding this feature would be extremely welcome :) here's an overview of how we could do it.\n\nOverall, TensorBoard consists of a few major pieces. On the backend, there are the [`EventMultiplexer`](https://github.com/tensorflow/tensorflow/blob/0ebbb99084091bba963f7b452d9f2fa93c70f6e2/tensorflow/python/summary/event_multiplexer.py) and [`EventAccumulator`](https://github.com/tensorflow/tensorflow/blob/0ebbb99084091bba963f7b452d9f2fa93c70f6e2/tensorflow/python/summary/event_accumulator.py), a pair of classes which provide an API for accessing summary data from TensorFlow. \n\nThe [`Server`](https://github.com/tensorflow/tensorflow/blob/0ebbb99084091bba963f7b452d9f2fa93c70f6e2/tensorflow/tensorboard/backend/server.py) instantiates these classes and creates a `MultiplexerReloadingThread` which sets a timer to automatically reload the `Multiplexer`. If the `Multiplexer` is already caught-up to historical data, it will generally load very quickly, but if you just turned TensorBoard on and it has 5 gigs of historical data to chew through, it may take a while.\n\n[`handler.py`](https://github.com/tensorflow/tensorflow/blob/0ebbb99084091bba963f7b452d9f2fa93c70f6e2/tensorflow/tensorboard/backend/handler.py#L460) contains all the handlers for the server's routes. The API is documented in the file [http_api.md](https://github.com/tensorflow/tensorflow/blob/0ebbb99084091bba963f7b452d9f2fa93c70f6e2/tensorflow/tensorboard/http_api.md). Please take a moment to read that (the next paragraph will assume some familiarity).\n\nThe way reloading works is as follows: the user clicks the reload button, which calls the `reload` method that is implemented by `TF.Backend.Behavior`. The behavior first reloads the run-tag mapping, and then triggers every existing data display element (e.g. a chart or image loader) to reload.\n\nThus, if we want to have the reload trigger a backend reload, we should have the first method that is called on the backend (the `runs` route) delay while the backend reloads. I think a good way to implement this would be to have an optional query parameter passed to the route (?reload), and if the query is present, then rather than respond immediately, the server reloads the backend and then responds.\n\nHowever, as I mentioned above, the reload may take a long time if the server just turned on and there is a lot of historical data to explore. So we'll need to have a timeout, say 5s - if the backend reload takes more than 5 seconds, then we resolve early even though we aren't done loading.\n\nIt would be really nice to further return some info on whether the backend is done loading or not so we can put a little \"data still loading!\" type indicator, but this change is complicated enough without doing that :)\n\nDoes that seem reasonable?\n"}