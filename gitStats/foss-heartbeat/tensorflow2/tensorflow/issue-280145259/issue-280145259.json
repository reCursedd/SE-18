{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/15183", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/15183/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/15183/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/15183/events", "html_url": "https://github.com/tensorflow/tensorflow/pull/15183", "id": 280145259, "node_id": "MDExOlB1bGxSZXF1ZXN0MTU3MDA1Mjk2", "number": 15183, "title": "estimator: allow export_outputs to be a Tensor", "user": {"login": "boeddeker", "id": 13744128, "node_id": "MDQ6VXNlcjEzNzQ0MTI4", "avatar_url": "https://avatars3.githubusercontent.com/u/13744128?v=4", "gravatar_id": "", "url": "https://api.github.com/users/boeddeker", "html_url": "https://github.com/boeddeker", "followers_url": "https://api.github.com/users/boeddeker/followers", "following_url": "https://api.github.com/users/boeddeker/following{/other_user}", "gists_url": "https://api.github.com/users/boeddeker/gists{/gist_id}", "starred_url": "https://api.github.com/users/boeddeker/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/boeddeker/subscriptions", "organizations_url": "https://api.github.com/users/boeddeker/orgs", "repos_url": "https://api.github.com/users/boeddeker/repos", "events_url": "https://api.github.com/users/boeddeker/events{/privacy}", "received_events_url": "https://api.github.com/users/boeddeker/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 390482148, "node_id": "MDU6TGFiZWwzOTA0ODIxNDg=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/awaiting%20review", "name": "awaiting review", "color": "fef2c0", "default": false}, {"id": 300136587, "node_id": "MDU6TGFiZWwzMDAxMzY1ODc=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/cla:%20yes", "name": "cla: yes", "color": "009800", "default": false}], "state": "open", "locked": false, "assignee": {"login": "caisq", "id": 16824702, "node_id": "MDQ6VXNlcjE2ODI0NzAy", "avatar_url": "https://avatars2.githubusercontent.com/u/16824702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/caisq", "html_url": "https://github.com/caisq", "followers_url": "https://api.github.com/users/caisq/followers", "following_url": "https://api.github.com/users/caisq/following{/other_user}", "gists_url": "https://api.github.com/users/caisq/gists{/gist_id}", "starred_url": "https://api.github.com/users/caisq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/caisq/subscriptions", "organizations_url": "https://api.github.com/users/caisq/orgs", "repos_url": "https://api.github.com/users/caisq/repos", "events_url": "https://api.github.com/users/caisq/events{/privacy}", "received_events_url": "https://api.github.com/users/caisq/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "caisq", "id": 16824702, "node_id": "MDQ6VXNlcjE2ODI0NzAy", "avatar_url": "https://avatars2.githubusercontent.com/u/16824702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/caisq", "html_url": "https://github.com/caisq", "followers_url": "https://api.github.com/users/caisq/followers", "following_url": "https://api.github.com/users/caisq/following{/other_user}", "gists_url": "https://api.github.com/users/caisq/gists{/gist_id}", "starred_url": "https://api.github.com/users/caisq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/caisq/subscriptions", "organizations_url": "https://api.github.com/users/caisq/orgs", "repos_url": "https://api.github.com/users/caisq/repos", "events_url": "https://api.github.com/users/caisq/events{/privacy}", "received_events_url": "https://api.github.com/users/caisq/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 3, "created_at": "2017-12-07T14:16:33Z", "updated_at": "2018-11-22T18:53:04Z", "closed_at": null, "author_association": "CONTRIBUTOR", "pull_request": {"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/15183", "html_url": "https://github.com/tensorflow/tensorflow/pull/15183", "diff_url": "https://github.com/tensorflow/tensorflow/pull/15183.diff", "patch_url": "https://github.com/tensorflow/tensorflow/pull/15183.patch"}, "body_html": "<p>When someone wants to use <code>tf.estimator.Estimator.export_savedmodel</code> to save the predictions of a model and <code>tf.contrib.predictor.from_saved_model</code> to load the prediction function, it is currently necessary to define boilerplate code. This PR reduces the amount of code.</p>\n<p>Currently:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-c1\">...</span>\nret[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>export_outputs<span class=\"pl-pds\">'</span></span>] <span class=\"pl-k\">=</span> {\n        <span class=\"pl-s\"><span class=\"pl-pds\">'</span>predictions<span class=\"pl-pds\">'</span></span>: tf.estimator.export.PredictOutput(\n            {<span class=\"pl-s\"><span class=\"pl-pds\">'</span>predictions<span class=\"pl-pds\">'</span></span>: ret[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>predictions<span class=\"pl-pds\">'</span></span>]}\n        )\n    }\ntf.estimator.EstimatorSpec(<span class=\"pl-k\">**</span>ret)</pre></div>\n<p>With this PR the following is enough:</p>\n<div class=\"highlight highlight-source-python\"><pre>ret[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>export_outputs<span class=\"pl-pds\">'</span></span>] <span class=\"pl-k\">=</span> {<span class=\"pl-s\"><span class=\"pl-pds\">'</span>predictions<span class=\"pl-pds\">'</span></span>: ret[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>predictions<span class=\"pl-pds\">'</span></span>]}\nret[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>export_outputs<span class=\"pl-pds\">'</span></span>] <span class=\"pl-k\">=</span> ret[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>predictions<span class=\"pl-pds\">'</span></span>]</pre></div>\n<p>The predictor repr for the first example is equal to the original code</p>\n<div class=\"highlight highlight-source-python\"><pre>SavedModelPredictor <span class=\"pl-k\">with</span> feed tensors {<span class=\"pl-s\"><span class=\"pl-pds\">'</span>x<span class=\"pl-pds\">'</span></span>: <span class=\"pl-k\">&lt;</span>tf.Tensor <span class=\"pl-s\"><span class=\"pl-pds\">'</span>Placeholder:0<span class=\"pl-pds\">'</span></span> shape=(<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">10</span>) dtype=float32<span class=\"pl-k\">&gt;</span>} <span class=\"pl-k\">and</span> fetch_tensors {<span class=\"pl-s\"><span class=\"pl-pds\">'</span>predictions<span class=\"pl-pds\">'</span></span>: <span class=\"pl-k\">&lt;</span>tf.Tensor <span class=\"pl-s\"><span class=\"pl-pds\">'</span>dense/Relu:0<span class=\"pl-pds\">'</span></span> shape=(<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">10</span>) dtype=float32<span class=\"pl-k\">&gt;</span>}</pre></div>\n<p>and for the second the output name changes</p>\n<div class=\"highlight highlight-source-python\"><pre>SavedModelPredictor <span class=\"pl-k\">with</span> feed tensors {<span class=\"pl-s\"><span class=\"pl-pds\">'</span>x<span class=\"pl-pds\">'</span></span>: <span class=\"pl-k\">&lt;</span>tf.Tensor <span class=\"pl-s\"><span class=\"pl-pds\">'</span>Placeholder:0<span class=\"pl-pds\">'</span></span> shape=(<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">10</span>) dtype=float32<span class=\"pl-k\">&gt;</span>} <span class=\"pl-k\">and</span> fetch_tensors {<span class=\"pl-s\"><span class=\"pl-pds\">'</span>output<span class=\"pl-pds\">'</span></span>: <span class=\"pl-k\">&lt;</span>tf.Tensor <span class=\"pl-s\"><span class=\"pl-pds\">'</span>dense/Relu:0<span class=\"pl-pds\">'</span></span> shape=(<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">10</span>) dtype=float32<span class=\"pl-k\">&gt;</span>}</pre></div>\n<p>When someone wants to verify the code, here a full example:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">from</span> types <span class=\"pl-k\">import</span> SimpleNamespace\n<span class=\"pl-k\">import</span> numpy <span class=\"pl-k\">as</span> np\n<span class=\"pl-k\">import</span> tensorflow <span class=\"pl-k\">as</span> tf\n<span class=\"pl-k\">from</span> tensorflow.contrib <span class=\"pl-k\">import</span> predictor\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">model_fn</span>(<span class=\"pl-smi\">features</span>, <span class=\"pl-smi\">labels</span>, <span class=\"pl-smi\">mode</span>):\n    <span class=\"pl-k\">assert</span> labels <span class=\"pl-k\">is</span> <span class=\"pl-c1\">None</span>, labels\n    x <span class=\"pl-k\">=</span> features[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>x<span class=\"pl-pds\">'</span></span>]\n    y <span class=\"pl-k\">=</span> features[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>y<span class=\"pl-pds\">'</span></span>]\n    \n    y_hat <span class=\"pl-k\">=</span> tf.layers.Dense(<span class=\"pl-c1\">10</span>, tf.nn.relu)(x)\n    loss <span class=\"pl-k\">=</span> tf.losses.mean_squared_error(y, y_hat)\n    train_op <span class=\"pl-k\">=</span> tf.train.AdamOptimizer(<span class=\"pl-v\">learning_rate</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">0.001</span>).minimize(loss)\n    \n    ret <span class=\"pl-k\">=</span> <span class=\"pl-c1\">dict</span>(\n        <span class=\"pl-v\">mode</span><span class=\"pl-k\">=</span>mode,\n        <span class=\"pl-v\">loss</span><span class=\"pl-k\">=</span>loss,\n        <span class=\"pl-v\">predictions</span><span class=\"pl-k\">=</span>y_hat,\n        <span class=\"pl-v\">train_op</span><span class=\"pl-k\">=</span>train_op,\n    )\n\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> Boilderplate:</span>\n    ret[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>export_outputs<span class=\"pl-pds\">'</span></span>] <span class=\"pl-k\">=</span> {  <span class=\"pl-c\"><span class=\"pl-c\">#</span> &lt;------------------- old</span>\n        <span class=\"pl-s\"><span class=\"pl-pds\">'</span>predictions<span class=\"pl-pds\">'</span></span>: tf.estimator.export.PredictOutput(\n            {<span class=\"pl-s\"><span class=\"pl-pds\">'</span>predictions<span class=\"pl-pds\">'</span></span>: ret[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>predictions<span class=\"pl-pds\">'</span></span>]}\n        )\n    }\n    ret[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>export_outputs<span class=\"pl-pds\">'</span></span>] <span class=\"pl-k\">=</span> {<span class=\"pl-s\"><span class=\"pl-pds\">'</span>predictions<span class=\"pl-pds\">'</span></span>: ret[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>predictions<span class=\"pl-pds\">'</span></span>]}  <span class=\"pl-c\"><span class=\"pl-c\">#</span> &lt;------------------- new</span>\n    ret[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>export_outputs<span class=\"pl-pds\">'</span></span>] <span class=\"pl-k\">=</span> ret[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>predictions<span class=\"pl-pds\">'</span></span>]  <span class=\"pl-c\"><span class=\"pl-c\">#</span> &lt;------------------- new alternate</span>\n    \n    <span class=\"pl-k\">return</span> tf.estimator.EstimatorSpec(<span class=\"pl-k\">**</span>ret)\n        \nestimator <span class=\"pl-k\">=</span> tf.estimator.Estimator(\n    <span class=\"pl-v\">model_fn</span><span class=\"pl-k\">=</span>model_fn\n)\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">generator</span>():\n    x <span class=\"pl-k\">=</span> np.random.randn(<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">10</span>).astype(np.float32)\n    y <span class=\"pl-k\">=</span> np.random.randn(<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">10</span>).astype(np.float32)\n    <span class=\"pl-k\">yield</span> {<span class=\"pl-s\"><span class=\"pl-pds\">'</span>x<span class=\"pl-pds\">'</span></span>: x, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>y<span class=\"pl-pds\">'</span></span>: y}\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">input_fn</span>():\n    ds <span class=\"pl-k\">=</span> tf.data.Dataset.from_generator(generator, {<span class=\"pl-s\"><span class=\"pl-pds\">'</span>x<span class=\"pl-pds\">'</span></span>: tf.float32, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>y<span class=\"pl-pds\">'</span></span>: tf.float32}, {<span class=\"pl-s\"><span class=\"pl-pds\">'</span>x<span class=\"pl-pds\">'</span></span>: [<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">10</span>], <span class=\"pl-s\"><span class=\"pl-pds\">'</span>y<span class=\"pl-pds\">'</span></span>: [<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">10</span>]})\n    it <span class=\"pl-k\">=</span> ds.make_one_shot_iterator()\n    element <span class=\"pl-k\">=</span> it.get_next()\n    <span class=\"pl-k\">return</span> element\n\nestimator.train(input_fn)\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">serving_input_receiver_fn</span>():\n    x <span class=\"pl-k\">=</span> tf.placeholder(tf.float32, [<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">10</span>])\n    y <span class=\"pl-k\">=</span> tf.placeholder(tf.float32, [<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">10</span>])\n    \n    ret <span class=\"pl-k\">=</span> SimpleNamespace()\n    ret.features <span class=\"pl-k\">=</span> {<span class=\"pl-s\"><span class=\"pl-pds\">'</span>x<span class=\"pl-pds\">'</span></span>: x, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>y<span class=\"pl-pds\">'</span></span>: y}  <span class=\"pl-c\"><span class=\"pl-c\">#</span> for graph def</span>\n    ret.receiver_tensors <span class=\"pl-k\">=</span> {<span class=\"pl-s\"><span class=\"pl-pds\">'</span>x<span class=\"pl-pds\">'</span></span>: x}  <span class=\"pl-c\"><span class=\"pl-c\">#</span> for serving</span>\n    ret.receiver_tensors_alternatives <span class=\"pl-k\">=</span> <span class=\"pl-c1\">None</span>\n    <span class=\"pl-k\">return</span> ret\n\n\nmodel_path <span class=\"pl-k\">=</span> estimator.export_savedmodel(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>tmp<span class=\"pl-pds\">'</span></span>, serving_input_receiver_fn)\n\npredict_fn <span class=\"pl-k\">=</span> predictor.from_saved_model(model_path)\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> predict_fn({'x': np.random.randn(1, 10)})</span>\npredict_fn</pre></div>", "body_text": "When someone wants to use tf.estimator.Estimator.export_savedmodel to save the predictions of a model and tf.contrib.predictor.from_saved_model to load the prediction function, it is currently necessary to define boilerplate code. This PR reduces the amount of code.\nCurrently:\n...\nret['export_outputs'] = {\n        'predictions': tf.estimator.export.PredictOutput(\n            {'predictions': ret['predictions']}\n        )\n    }\ntf.estimator.EstimatorSpec(**ret)\nWith this PR the following is enough:\nret['export_outputs'] = {'predictions': ret['predictions']}\nret['export_outputs'] = ret['predictions']\nThe predictor repr for the first example is equal to the original code\nSavedModelPredictor with feed tensors {'x': <tf.Tensor 'Placeholder:0' shape=(1, 10) dtype=float32>} and fetch_tensors {'predictions': <tf.Tensor 'dense/Relu:0' shape=(1, 10) dtype=float32>}\nand for the second the output name changes\nSavedModelPredictor with feed tensors {'x': <tf.Tensor 'Placeholder:0' shape=(1, 10) dtype=float32>} and fetch_tensors {'output': <tf.Tensor 'dense/Relu:0' shape=(1, 10) dtype=float32>}\nWhen someone wants to verify the code, here a full example:\nfrom types import SimpleNamespace\nimport numpy as np\nimport tensorflow as tf\nfrom tensorflow.contrib import predictor\n\ndef model_fn(features, labels, mode):\n    assert labels is None, labels\n    x = features['x']\n    y = features['y']\n    \n    y_hat = tf.layers.Dense(10, tf.nn.relu)(x)\n    loss = tf.losses.mean_squared_error(y, y_hat)\n    train_op = tf.train.AdamOptimizer(learning_rate=0.001).minimize(loss)\n    \n    ret = dict(\n        mode=mode,\n        loss=loss,\n        predictions=y_hat,\n        train_op=train_op,\n    )\n\n    # Boilderplate:\n    ret['export_outputs'] = {  # <------------------- old\n        'predictions': tf.estimator.export.PredictOutput(\n            {'predictions': ret['predictions']}\n        )\n    }\n    ret['export_outputs'] = {'predictions': ret['predictions']}  # <------------------- new\n    ret['export_outputs'] = ret['predictions']  # <------------------- new alternate\n    \n    return tf.estimator.EstimatorSpec(**ret)\n        \nestimator = tf.estimator.Estimator(\n    model_fn=model_fn\n)\n\ndef generator():\n    x = np.random.randn(1, 10).astype(np.float32)\n    y = np.random.randn(1, 10).astype(np.float32)\n    yield {'x': x, 'y': y}\n\ndef input_fn():\n    ds = tf.data.Dataset.from_generator(generator, {'x': tf.float32, 'y': tf.float32}, {'x': [1, 10], 'y': [1, 10]})\n    it = ds.make_one_shot_iterator()\n    element = it.get_next()\n    return element\n\nestimator.train(input_fn)\n\ndef serving_input_receiver_fn():\n    x = tf.placeholder(tf.float32, [1, 10])\n    y = tf.placeholder(tf.float32, [1, 10])\n    \n    ret = SimpleNamespace()\n    ret.features = {'x': x, 'y': y}  # for graph def\n    ret.receiver_tensors = {'x': x}  # for serving\n    ret.receiver_tensors_alternatives = None\n    return ret\n\n\nmodel_path = estimator.export_savedmodel('tmp', serving_input_receiver_fn)\n\npredict_fn = predictor.from_saved_model(model_path)\n# predict_fn({'x': np.random.randn(1, 10)})\npredict_fn", "body": "When someone wants to use `tf.estimator.Estimator.export_savedmodel` to save the predictions of a model and `tf.contrib.predictor.from_saved_model` to load the prediction function, it is currently necessary to define boilerplate code. This PR reduces the amount of code.\r\n\r\nCurrently:\r\n```python\r\n...\r\nret['export_outputs'] = {\r\n        'predictions': tf.estimator.export.PredictOutput(\r\n            {'predictions': ret['predictions']}\r\n        )\r\n    }\r\ntf.estimator.EstimatorSpec(**ret)\r\n```\r\nWith this PR the following is enough:\r\n```python\r\nret['export_outputs'] = {'predictions': ret['predictions']}\r\nret['export_outputs'] = ret['predictions']\r\n```\r\nThe predictor repr for the first example is equal to the original code\r\n```python\r\nSavedModelPredictor with feed tensors {'x': <tf.Tensor 'Placeholder:0' shape=(1, 10) dtype=float32>} and fetch_tensors {'predictions': <tf.Tensor 'dense/Relu:0' shape=(1, 10) dtype=float32>}\r\n```\r\nand for the second the output name changes\r\n```python\r\nSavedModelPredictor with feed tensors {'x': <tf.Tensor 'Placeholder:0' shape=(1, 10) dtype=float32>} and fetch_tensors {'output': <tf.Tensor 'dense/Relu:0' shape=(1, 10) dtype=float32>}\r\n```\r\n\r\nWhen someone wants to verify the code, here a full example:\r\n```python\r\nfrom types import SimpleNamespace\r\nimport numpy as np\r\nimport tensorflow as tf\r\nfrom tensorflow.contrib import predictor\r\n\r\ndef model_fn(features, labels, mode):\r\n    assert labels is None, labels\r\n    x = features['x']\r\n    y = features['y']\r\n    \r\n    y_hat = tf.layers.Dense(10, tf.nn.relu)(x)\r\n    loss = tf.losses.mean_squared_error(y, y_hat)\r\n    train_op = tf.train.AdamOptimizer(learning_rate=0.001).minimize(loss)\r\n    \r\n    ret = dict(\r\n        mode=mode,\r\n        loss=loss,\r\n        predictions=y_hat,\r\n        train_op=train_op,\r\n    )\r\n\r\n    # Boilderplate:\r\n    ret['export_outputs'] = {  # <------------------- old\r\n        'predictions': tf.estimator.export.PredictOutput(\r\n            {'predictions': ret['predictions']}\r\n        )\r\n    }\r\n    ret['export_outputs'] = {'predictions': ret['predictions']}  # <------------------- new\r\n    ret['export_outputs'] = ret['predictions']  # <------------------- new alternate\r\n    \r\n    return tf.estimator.EstimatorSpec(**ret)\r\n        \r\nestimator = tf.estimator.Estimator(\r\n    model_fn=model_fn\r\n)\r\n\r\ndef generator():\r\n    x = np.random.randn(1, 10).astype(np.float32)\r\n    y = np.random.randn(1, 10).astype(np.float32)\r\n    yield {'x': x, 'y': y}\r\n\r\ndef input_fn():\r\n    ds = tf.data.Dataset.from_generator(generator, {'x': tf.float32, 'y': tf.float32}, {'x': [1, 10], 'y': [1, 10]})\r\n    it = ds.make_one_shot_iterator()\r\n    element = it.get_next()\r\n    return element\r\n\r\nestimator.train(input_fn)\r\n\r\ndef serving_input_receiver_fn():\r\n    x = tf.placeholder(tf.float32, [1, 10])\r\n    y = tf.placeholder(tf.float32, [1, 10])\r\n    \r\n    ret = SimpleNamespace()\r\n    ret.features = {'x': x, 'y': y}  # for graph def\r\n    ret.receiver_tensors = {'x': x}  # for serving\r\n    ret.receiver_tensors_alternatives = None\r\n    return ret\r\n\r\n\r\nmodel_path = estimator.export_savedmodel('tmp', serving_input_receiver_fn)\r\n\r\npredict_fn = predictor.from_saved_model(model_path)\r\n# predict_fn({'x': np.random.randn(1, 10)})\r\npredict_fn\r\n```"}