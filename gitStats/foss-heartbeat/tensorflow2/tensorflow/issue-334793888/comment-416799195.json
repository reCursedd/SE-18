{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/416799195", "html_url": "https://github.com/tensorflow/tensorflow/issues/20218#issuecomment-416799195", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/20218", "id": 416799195, "node_id": "MDEyOklzc3VlQ29tbWVudDQxNjc5OTE5NQ==", "user": {"login": "allenlavoie", "id": 3731025, "node_id": "MDQ6VXNlcjM3MzEwMjU=", "avatar_url": "https://avatars3.githubusercontent.com/u/3731025?v=4", "gravatar_id": "", "url": "https://api.github.com/users/allenlavoie", "html_url": "https://github.com/allenlavoie", "followers_url": "https://api.github.com/users/allenlavoie/followers", "following_url": "https://api.github.com/users/allenlavoie/following{/other_user}", "gists_url": "https://api.github.com/users/allenlavoie/gists{/gist_id}", "starred_url": "https://api.github.com/users/allenlavoie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/allenlavoie/subscriptions", "organizations_url": "https://api.github.com/users/allenlavoie/orgs", "repos_url": "https://api.github.com/users/allenlavoie/repos", "events_url": "https://api.github.com/users/allenlavoie/events{/privacy}", "received_events_url": "https://api.github.com/users/allenlavoie/received_events", "type": "User", "site_admin": false}, "created_at": "2018-08-29T02:07:44Z", "updated_at": "2018-08-29T02:07:44Z", "author_association": "MEMBER", "body_html": "<p>The PyObject issue was probably just host-side (and now that I think about it, you may not have run into it unless you were using a nightly from the past week or so). Not sure the gc.collect() is necessary there; just using it to get a stable count of objects in case there are reference cycles.</p>\n<p>The zeros caching issue will affect GPU too, since (I assume) we cache GPU Tensors. But all my testing was CPU-only so far.</p>\n<p>This caching helps avoid re-creating zero Tensors during backprop and is limited to 256 entries, but when running your model ~60 entries was tens of gigabytes. Sounds from Akshay like the solution will be to cap the size of the cache. (And maybe we should cap it more aggressively for GPU Tensors since memory will be more constrained?)</p>", "body_text": "The PyObject issue was probably just host-side (and now that I think about it, you may not have run into it unless you were using a nightly from the past week or so). Not sure the gc.collect() is necessary there; just using it to get a stable count of objects in case there are reference cycles.\nThe zeros caching issue will affect GPU too, since (I assume) we cache GPU Tensors. But all my testing was CPU-only so far.\nThis caching helps avoid re-creating zero Tensors during backprop and is limited to 256 entries, but when running your model ~60 entries was tens of gigabytes. Sounds from Akshay like the solution will be to cap the size of the cache. (And maybe we should cap it more aggressively for GPU Tensors since memory will be more constrained?)", "body": "The PyObject issue was probably just host-side (and now that I think about it, you may not have run into it unless you were using a nightly from the past week or so). Not sure the gc.collect() is necessary there; just using it to get a stable count of objects in case there are reference cycles.\r\n\r\nThe zeros caching issue will affect GPU too, since (I assume) we cache GPU Tensors. But all my testing was CPU-only so far.\r\n\r\nThis caching helps avoid re-creating zero Tensors during backprop and is limited to 256 entries, but when running your model ~60 entries was tens of gigabytes. Sounds from Akshay like the solution will be to cap the size of the cache. (And maybe we should cap it more aggressively for GPU Tensors since memory will be more constrained?)"}