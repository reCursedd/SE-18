{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/17127", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/17127/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/17127/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/17127/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/17127", "id": 298273327, "node_id": "MDU6SXNzdWUyOTgyNzMzMjc=", "number": 17127, "title": "Write to tensor array fails within while loop", "user": {"login": "rays2pix", "id": 8069175, "node_id": "MDQ6VXNlcjgwNjkxNzU=", "avatar_url": "https://avatars3.githubusercontent.com/u/8069175?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rays2pix", "html_url": "https://github.com/rays2pix", "followers_url": "https://api.github.com/users/rays2pix/followers", "following_url": "https://api.github.com/users/rays2pix/following{/other_user}", "gists_url": "https://api.github.com/users/rays2pix/gists{/gist_id}", "starred_url": "https://api.github.com/users/rays2pix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rays2pix/subscriptions", "organizations_url": "https://api.github.com/users/rays2pix/orgs", "repos_url": "https://api.github.com/users/rays2pix/repos", "events_url": "https://api.github.com/users/rays2pix/events{/privacy}", "received_events_url": "https://api.github.com/users/rays2pix/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 386191887, "node_id": "MDU6TGFiZWwzODYxOTE4ODc=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:awaiting%20response", "name": "stat:awaiting response", "color": "f4b400", "default": false}], "state": "closed", "locked": false, "assignee": {"login": "skye", "id": 88808, "node_id": "MDQ6VXNlcjg4ODA4", "avatar_url": "https://avatars1.githubusercontent.com/u/88808?v=4", "gravatar_id": "", "url": "https://api.github.com/users/skye", "html_url": "https://github.com/skye", "followers_url": "https://api.github.com/users/skye/followers", "following_url": "https://api.github.com/users/skye/following{/other_user}", "gists_url": "https://api.github.com/users/skye/gists{/gist_id}", "starred_url": "https://api.github.com/users/skye/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/skye/subscriptions", "organizations_url": "https://api.github.com/users/skye/orgs", "repos_url": "https://api.github.com/users/skye/repos", "events_url": "https://api.github.com/users/skye/events{/privacy}", "received_events_url": "https://api.github.com/users/skye/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "skye", "id": 88808, "node_id": "MDQ6VXNlcjg4ODA4", "avatar_url": "https://avatars1.githubusercontent.com/u/88808?v=4", "gravatar_id": "", "url": "https://api.github.com/users/skye", "html_url": "https://github.com/skye", "followers_url": "https://api.github.com/users/skye/followers", "following_url": "https://api.github.com/users/skye/following{/other_user}", "gists_url": "https://api.github.com/users/skye/gists{/gist_id}", "starred_url": "https://api.github.com/users/skye/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/skye/subscriptions", "organizations_url": "https://api.github.com/users/skye/orgs", "repos_url": "https://api.github.com/users/skye/repos", "events_url": "https://api.github.com/users/skye/events{/privacy}", "received_events_url": "https://api.github.com/users/skye/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 5, "created_at": "2018-02-19T13:22:50Z", "updated_at": "2018-04-03T21:33:45Z", "closed_at": "2018-04-03T21:33:45Z", "author_association": "NONE", "body_html": "<h3>System information</h3>\n<ul>\n<li><strong>Have I written custom code (as opposed to using a stock example script provided in TensorFlow)</strong>:<br>\nYes I am writing a while loop that reads and also updates the tensor array that's being passed to it.</li>\n<li><strong>OS Platform and Distribution (e.g., Linux Ubuntu 16.04)</strong>:<br>\nUbuntu 16.04</li>\n<li><strong>TensorFlow installed from (source or binary)</strong>:<br>\nBinary</li>\n<li><strong>TensorFlow version (use command below)</strong>:<br>\n1.3</li>\n<li><strong>Python version</strong>:<br>\n3.6</li>\n<li><strong>Bazel version (if compiling from source)</strong>:</li>\n<li><strong>GCC/Compiler version (if compiling from source)</strong>:</li>\n<li><strong>CUDA/cuDNN version</strong>:</li>\n<li><strong>GPU model and memory</strong>:</li>\n<li><strong>Exact command to reproduce</strong>:</li>\n</ul>\n<h3>Describe the problem</h3>\n<p>When I attempt to write to a tensor array within a while loop, it leads me to an error<br>\n\"Could not write to TensorArray index 0 because it has already been read.\"</p>\n<h3>Source code</h3>\n<pre><code>def tf_soft_nms(boxes,scores,nms_t,dt_t):\n\n  sigma = tf.constant(0.3)\n  y1 = tf.gather(boxes,0,axis=1)\n  x1 = tf.gather(boxes,1,axis=1)\n  y2 = tf.gather(boxes,2,axis=1)\n  x2 = tf.gather(boxes,3,axis=1)\n  area = tf.multiply((y2-y1) , (x2-x1))\n\n\n  picked_ixs = tf.TensorArray(tf.int32,clear_after_read=False,size=0,dynamic_size=True)\n  scores_ta = tf.TensorArray(scores.dtype,clear_after_read=False,size=scores.shape[0],colocate_with_first_write_call=False)\n  scores_ta = scores_ta.unstack(scores)\n  loop_vars = (picked_ixs,scores_ta,nms_t,dt_t)\n  score_p = tf.Print(scores,[scores],\"all_Scores\")\n\n  def cond(picked_ixs,scores,nms_t,dt_t):\n    scores_tf = scores.stack()\n    valid_indexes = tf.greater(scores_tf,dt_t)\n    valid = tf.Print(valid_indexes,[valid_indexes],\"Conditional check\")\n    #scores = scores.write(0,tf.constant(0.0))\n    return tf.reduce_any(valid_indexes)\n\n  def nms_iter(picked_ixs,scores_ta,nms_t,dt_t):\n    global area\n    global boxes\n    #sort scores pick top score\n    scores_tf = scores_ip.stack()\n    scores_ixs = tf.nn.top_k(scores_tf,tf.shape(scores_tf)[0]).indices\n    pick = scores_ixs[0]\n\n\n    #write top score to picked\n    write_index = picked_ixs.size()\n    picked_ixs = picked_ixs.write(write_index,pick)\n    scores_ta = scores_ta.write(pick,tf.constant(0.2))\n    picked_tf = picked_ixs.stack()\n     return picked_ixs,scores_ta,nms_t,dt_t\n\n</code></pre>", "body_text": "System information\n\nHave I written custom code (as opposed to using a stock example script provided in TensorFlow):\nYes I am writing a while loop that reads and also updates the tensor array that's being passed to it.\nOS Platform and Distribution (e.g., Linux Ubuntu 16.04):\nUbuntu 16.04\nTensorFlow installed from (source or binary):\nBinary\nTensorFlow version (use command below):\n1.3\nPython version:\n3.6\nBazel version (if compiling from source):\nGCC/Compiler version (if compiling from source):\nCUDA/cuDNN version:\nGPU model and memory:\nExact command to reproduce:\n\nDescribe the problem\nWhen I attempt to write to a tensor array within a while loop, it leads me to an error\n\"Could not write to TensorArray index 0 because it has already been read.\"\nSource code\ndef tf_soft_nms(boxes,scores,nms_t,dt_t):\n\n  sigma = tf.constant(0.3)\n  y1 = tf.gather(boxes,0,axis=1)\n  x1 = tf.gather(boxes,1,axis=1)\n  y2 = tf.gather(boxes,2,axis=1)\n  x2 = tf.gather(boxes,3,axis=1)\n  area = tf.multiply((y2-y1) , (x2-x1))\n\n\n  picked_ixs = tf.TensorArray(tf.int32,clear_after_read=False,size=0,dynamic_size=True)\n  scores_ta = tf.TensorArray(scores.dtype,clear_after_read=False,size=scores.shape[0],colocate_with_first_write_call=False)\n  scores_ta = scores_ta.unstack(scores)\n  loop_vars = (picked_ixs,scores_ta,nms_t,dt_t)\n  score_p = tf.Print(scores,[scores],\"all_Scores\")\n\n  def cond(picked_ixs,scores,nms_t,dt_t):\n    scores_tf = scores.stack()\n    valid_indexes = tf.greater(scores_tf,dt_t)\n    valid = tf.Print(valid_indexes,[valid_indexes],\"Conditional check\")\n    #scores = scores.write(0,tf.constant(0.0))\n    return tf.reduce_any(valid_indexes)\n\n  def nms_iter(picked_ixs,scores_ta,nms_t,dt_t):\n    global area\n    global boxes\n    #sort scores pick top score\n    scores_tf = scores_ip.stack()\n    scores_ixs = tf.nn.top_k(scores_tf,tf.shape(scores_tf)[0]).indices\n    pick = scores_ixs[0]\n\n\n    #write top score to picked\n    write_index = picked_ixs.size()\n    picked_ixs = picked_ixs.write(write_index,pick)\n    scores_ta = scores_ta.write(pick,tf.constant(0.2))\n    picked_tf = picked_ixs.stack()\n     return picked_ixs,scores_ta,nms_t,dt_t", "body": "\r\n\r\n\r\n\r\n### System information\r\n- **Have I written custom code (as opposed to using a stock example script provided in TensorFlow)**:\r\n Yes I am writing a while loop that reads and also updates the tensor array that's being passed to it.\r\n- **OS Platform and Distribution (e.g., Linux Ubuntu 16.04)**:\r\nUbuntu 16.04\r\n- **TensorFlow installed from (source or binary)**:\r\nBinary\r\n- **TensorFlow version (use command below)**:\r\n1.3\r\n- **Python version**: \r\n3.6\r\n- **Bazel version (if compiling from source)**:\r\n- **GCC/Compiler version (if compiling from source)**:\r\n- **CUDA/cuDNN version**:\r\n- **GPU model and memory**:\r\n- **Exact command to reproduce**:\r\n\r\n\r\n### Describe the problem\r\nWhen I attempt to write to a tensor array within a while loop, it leads me to an error \r\n\"Could not write to TensorArray index 0 because it has already been read.\"\r\n\r\n### Source code \r\n\r\n\r\n```\r\ndef tf_soft_nms(boxes,scores,nms_t,dt_t):\r\n\r\n  sigma = tf.constant(0.3)\r\n  y1 = tf.gather(boxes,0,axis=1)\r\n  x1 = tf.gather(boxes,1,axis=1)\r\n  y2 = tf.gather(boxes,2,axis=1)\r\n  x2 = tf.gather(boxes,3,axis=1)\r\n  area = tf.multiply((y2-y1) , (x2-x1))\r\n\r\n\r\n  picked_ixs = tf.TensorArray(tf.int32,clear_after_read=False,size=0,dynamic_size=True)\r\n  scores_ta = tf.TensorArray(scores.dtype,clear_after_read=False,size=scores.shape[0],colocate_with_first_write_call=False)\r\n  scores_ta = scores_ta.unstack(scores)\r\n  loop_vars = (picked_ixs,scores_ta,nms_t,dt_t)\r\n  score_p = tf.Print(scores,[scores],\"all_Scores\")\r\n\r\n  def cond(picked_ixs,scores,nms_t,dt_t):\r\n    scores_tf = scores.stack()\r\n    valid_indexes = tf.greater(scores_tf,dt_t)\r\n    valid = tf.Print(valid_indexes,[valid_indexes],\"Conditional check\")\r\n    #scores = scores.write(0,tf.constant(0.0))\r\n    return tf.reduce_any(valid_indexes)\r\n\r\n  def nms_iter(picked_ixs,scores_ta,nms_t,dt_t):\r\n    global area\r\n    global boxes\r\n    #sort scores pick top score\r\n    scores_tf = scores_ip.stack()\r\n    scores_ixs = tf.nn.top_k(scores_tf,tf.shape(scores_tf)[0]).indices\r\n    pick = scores_ixs[0]\r\n\r\n\r\n    #write top score to picked\r\n    write_index = picked_ixs.size()\r\n    picked_ixs = picked_ixs.write(write_index,pick)\r\n    scores_ta = scores_ta.write(pick,tf.constant(0.2))\r\n    picked_tf = picked_ixs.stack()\r\n     return picked_ixs,scores_ta,nms_t,dt_t\r\n\r\n```\r\n\r\n"}