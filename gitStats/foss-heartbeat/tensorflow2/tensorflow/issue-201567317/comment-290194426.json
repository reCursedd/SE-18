{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/290194426", "html_url": "https://github.com/tensorflow/tensorflow/issues/6926#issuecomment-290194426", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/6926", "id": 290194426, "node_id": "MDEyOklzc3VlQ29tbWVudDI5MDE5NDQyNg==", "user": {"login": "dazraf", "id": 178520, "node_id": "MDQ6VXNlcjE3ODUyMA==", "avatar_url": "https://avatars1.githubusercontent.com/u/178520?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dazraf", "html_url": "https://github.com/dazraf", "followers_url": "https://api.github.com/users/dazraf/followers", "following_url": "https://api.github.com/users/dazraf/following{/other_user}", "gists_url": "https://api.github.com/users/dazraf/gists{/gist_id}", "starred_url": "https://api.github.com/users/dazraf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dazraf/subscriptions", "organizations_url": "https://api.github.com/users/dazraf/orgs", "repos_url": "https://api.github.com/users/dazraf/repos", "events_url": "https://api.github.com/users/dazraf/events{/privacy}", "received_events_url": "https://api.github.com/users/dazraf/received_events", "type": "User", "site_admin": false}, "created_at": "2017-03-29T19:09:43Z", "updated_at": "2017-03-29T19:09:43Z", "author_association": "NONE", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=16018\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/asimshankar\">@asimshankar</a> : I see your point. So adapting what I wrote:</p>\n<ol>\n<li>as a libX developer, I want to bind to a single dependency that allows me to write my logic.</li>\n<li>as a user of libX, in another java project, I would like to reference libX and also add a dependency to leverage my GPU.</li>\n</ol>\n<p>Do these make sense?<br>\nThe model you proposed works perfectly for <code>1.</code>. A single reference <code>org.tensorflow:tensorflow:&lt;version&gt;</code> to bind to is nice and easy.</p>\n<p>For <code>2.</code>, I'm looking for a maven packaging of the GPU specific libraries - something like <code>org.tensorflow:tensorflow-windows-gpu:&lt;version&gt;</code> such that at runtime, <code>tensorflow</code> discovers <code>tensorflow-windows-gpu</code>, unpacks it, and binds to its native lib.</p>\n<p>This is how the <code>netty-native</code> libraries work - netty looks for a well-known class on the classpath, which is provided by the <code>-native-</code> library. Netty invokes this class, which in turn unpacks the binary (it not already present) in a well known location etc ..</p>\n<p>So in summary, the proposition is that Java developers of <code>2.</code> would prefer the installation of the GPU library to be controllable by maven.</p>\n<p>Is that a clearer narrative?</p>", "body_text": "@asimshankar : I see your point. So adapting what I wrote:\n\nas a libX developer, I want to bind to a single dependency that allows me to write my logic.\nas a user of libX, in another java project, I would like to reference libX and also add a dependency to leverage my GPU.\n\nDo these make sense?\nThe model you proposed works perfectly for 1.. A single reference org.tensorflow:tensorflow:<version> to bind to is nice and easy.\nFor 2., I'm looking for a maven packaging of the GPU specific libraries - something like org.tensorflow:tensorflow-windows-gpu:<version> such that at runtime, tensorflow discovers tensorflow-windows-gpu, unpacks it, and binds to its native lib.\nThis is how the netty-native libraries work - netty looks for a well-known class on the classpath, which is provided by the -native- library. Netty invokes this class, which in turn unpacks the binary (it not already present) in a well known location etc ..\nSo in summary, the proposition is that Java developers of 2. would prefer the installation of the GPU library to be controllable by maven.\nIs that a clearer narrative?", "body": "@asimshankar : I see your point. So adapting what I wrote:\r\n\r\n1. as a libX developer, I want to bind to a single dependency that allows me to write my logic. \r\n2. as a user of libX, in another java project, I would like to reference libX and also add a dependency to leverage my GPU. \r\n\r\nDo these make sense?\r\nThe model you proposed works perfectly for `1.`. A single reference `org.tensorflow:tensorflow:<version>` to bind to is nice and easy.\r\n\r\nFor `2.`, I'm looking for a maven packaging of the GPU specific libraries - something like `org.tensorflow:tensorflow-windows-gpu:<version>` such that at runtime, `tensorflow` discovers `tensorflow-windows-gpu`, unpacks it, and binds to its native lib.\r\n\r\nThis is how the `netty-native` libraries work - netty looks for a well-known class on the classpath, which is provided by the `-native-` library. Netty invokes this class, which in turn unpacks the binary (it not already present) in a well known location etc ..\r\n\r\nSo in summary, the proposition is that Java developers of `2.` would prefer the installation of the GPU library to be controllable by maven.\r\n\r\nIs that a clearer narrative?"}