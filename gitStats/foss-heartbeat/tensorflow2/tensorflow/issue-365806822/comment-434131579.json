{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/434131579", "html_url": "https://github.com/tensorflow/tensorflow/issues/22665#issuecomment-434131579", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/22665", "id": 434131579, "node_id": "MDEyOklzc3VlQ29tbWVudDQzNDEzMTU3OQ==", "user": {"login": "acowley", "id": 124545, "node_id": "MDQ6VXNlcjEyNDU0NQ==", "avatar_url": "https://avatars0.githubusercontent.com/u/124545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/acowley", "html_url": "https://github.com/acowley", "followers_url": "https://api.github.com/users/acowley/followers", "following_url": "https://api.github.com/users/acowley/following{/other_user}", "gists_url": "https://api.github.com/users/acowley/gists{/gist_id}", "starred_url": "https://api.github.com/users/acowley/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/acowley/subscriptions", "organizations_url": "https://api.github.com/users/acowley/orgs", "repos_url": "https://api.github.com/users/acowley/repos", "events_url": "https://api.github.com/users/acowley/events{/privacy}", "received_events_url": "https://api.github.com/users/acowley/received_events", "type": "User", "site_admin": false}, "created_at": "2018-10-30T00:43:15Z", "updated_at": "2018-10-30T00:43:15Z", "author_association": "NONE", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=1310395\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/TravisWhitaker\">@TravisWhitaker</a> Yes, exactly, I used a custom <code>buildBazelPackage</code>. I abandoned <code>bazel fetch</code> due to this Issue, and baked the patches to the hard coded <code>/usr/bin/ar</code> paths used by bazel into <code>src/main/tools/process-wrapper-legacy.cc</code> (part of the bazel source) itself. This is horribly gross, but I also needed to patch dozens of other paths in <code>tensorflow</code>, so I could stomach it as a temporary fix.</p>\n<div class=\"highlight highlight-source-nix\"><pre><span class=\"pl-v\">rocm-bazel</span> <span class=\"pl-ii\">=</span> (<span class=\"pl-v\">pkgs</span><span class=\"pl-k\">.</span><span class=\"pl-v\">bazel</span><span class=\"pl-k\">.</span><span class=\"pl-v\">override</span> {<span class=\"pl-e\">enableNixHacks</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">true</span>;})<span class=\"pl-k\">.</span><span class=\"pl-v\">overrideAttrs</span> (<span class=\"pl-smi\">old</span>: {\n    <span class=\"pl-c\"># Packages that bazel fetches often include hard-coded paths to</span>\n    <span class=\"pl-c\"># /usr/bin/ar. We in turn hard code a fix for that here. If</span>\n    <span class=\"pl-c\"># bazel's fetch command works for your build, then this is not</span>\n    <span class=\"pl-c\"># needed as these paths can be patched after download but before</span>\n    <span class=\"pl-c\"># build. If fetching does not work, and you need to rely upon</span>\n    <span class=\"pl-c\"># downloads during the build phase, this can help.</span>\n    <span class=\"pl-e\">postPatch</span> <span class=\"pl-k\">=</span> <span class=\"pl-v\">old</span><span class=\"pl-k\">.</span><span class=\"pl-v\">postPatch</span> <span class=\"pl-k\">+</span> <span class=\"pl-s\"><span class=\"pl-pds\">''</span></span>\n<span class=\"pl-s\">      find -type f -name CROSSTOOL\\* -exec sed -i -e 's,/usr/bin/ar,<span class=\"pl-mi\"><span class=\"pl-pse\">${</span><span class=\"pl-v\">pkgs</span><span class=\"pl-k\">.</span><span class=\"pl-v\">binutils</span><span class=\"pl-k\">.</span><span class=\"pl-v\">bintools</span><span class=\"pl-pse\">}</span></span>/bin/ar,g' {} \\;</span>\n<span class=\"pl-s\">      sed -e 's|if (execvp(opt.args\\[0\\]|if (execvp(strcmp(opt.args[0], \"/usr/bin/ar\") == 0 ? \"<span class=\"pl-mi\"><span class=\"pl-pse\">${</span><span class=\"pl-v\">pkgs</span><span class=\"pl-k\">.</span><span class=\"pl-v\">binutils</span><span class=\"pl-k\">.</span><span class=\"pl-v\">bintools</span><span class=\"pl-pse\">}</span></span>/bin/ar\" : opt.args[0]|' \\</span>\n<span class=\"pl-s\">          -e 's|\\(#include &lt;vector&gt;\\)|\\1\\n#include &lt;cstring&gt;|' \\</span>\n<span class=\"pl-s\">          -i src/main/tools/process-wrapper-legacy.cc</span>\n<span class=\"pl-s\">    <span class=\"pl-pds\">''</span></span>;\n  })<span class=\"pl-ii\">;</span></pre></div>", "body_text": "@TravisWhitaker Yes, exactly, I used a custom buildBazelPackage. I abandoned bazel fetch due to this Issue, and baked the patches to the hard coded /usr/bin/ar paths used by bazel into src/main/tools/process-wrapper-legacy.cc (part of the bazel source) itself. This is horribly gross, but I also needed to patch dozens of other paths in tensorflow, so I could stomach it as a temporary fix.\nrocm-bazel = (pkgs.bazel.override {enableNixHacks = true;}).overrideAttrs (old: {\n    # Packages that bazel fetches often include hard-coded paths to\n    # /usr/bin/ar. We in turn hard code a fix for that here. If\n    # bazel's fetch command works for your build, then this is not\n    # needed as these paths can be patched after download but before\n    # build. If fetching does not work, and you need to rely upon\n    # downloads during the build phase, this can help.\n    postPatch = old.postPatch + ''\n      find -type f -name CROSSTOOL\\* -exec sed -i -e 's,/usr/bin/ar,${pkgs.binutils.bintools}/bin/ar,g' {} \\;\n      sed -e 's|if (execvp(opt.args\\[0\\]|if (execvp(strcmp(opt.args[0], \"/usr/bin/ar\") == 0 ? \"${pkgs.binutils.bintools}/bin/ar\" : opt.args[0]|' \\\n          -e 's|\\(#include <vector>\\)|\\1\\n#include <cstring>|' \\\n          -i src/main/tools/process-wrapper-legacy.cc\n    '';\n  });", "body": "@TravisWhitaker Yes, exactly, I used a custom `buildBazelPackage`. I abandoned `bazel fetch` due to this Issue, and baked the patches to the hard coded `/usr/bin/ar` paths used by bazel into `src/main/tools/process-wrapper-legacy.cc` (part of the bazel source) itself. This is horribly gross, but I also needed to patch dozens of other paths in `tensorflow`, so I could stomach it as a temporary fix.\r\n\r\n```nix\r\nrocm-bazel = (pkgs.bazel.override {enableNixHacks = true;}).overrideAttrs (old: {\r\n    # Packages that bazel fetches often include hard-coded paths to\r\n    # /usr/bin/ar. We in turn hard code a fix for that here. If\r\n    # bazel's fetch command works for your build, then this is not\r\n    # needed as these paths can be patched after download but before\r\n    # build. If fetching does not work, and you need to rely upon\r\n    # downloads during the build phase, this can help.\r\n    postPatch = old.postPatch + ''\r\n      find -type f -name CROSSTOOL\\* -exec sed -i -e 's,/usr/bin/ar,${pkgs.binutils.bintools}/bin/ar,g' {} \\;\r\n      sed -e 's|if (execvp(opt.args\\[0\\]|if (execvp(strcmp(opt.args[0], \"/usr/bin/ar\") == 0 ? \"${pkgs.binutils.bintools}/bin/ar\" : opt.args[0]|' \\\r\n          -e 's|\\(#include <vector>\\)|\\1\\n#include <cstring>|' \\\r\n          -i src/main/tools/process-wrapper-legacy.cc\r\n    '';\r\n  });\r\n```"}