{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/4893", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/4893/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/4893/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/4893/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/4893", "id": 182279835, "node_id": "MDU6SXNzdWUxODIyNzk4MzU=", "number": 4893, "title": "How to create `input_fn` using `read_batch_examples` with `num_epochs` set?", "user": {"login": "craymichael", "id": 20629897, "node_id": "MDQ6VXNlcjIwNjI5ODk3", "avatar_url": "https://avatars2.githubusercontent.com/u/20629897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/craymichael", "html_url": "https://github.com/craymichael", "followers_url": "https://api.github.com/users/craymichael/followers", "following_url": "https://api.github.com/users/craymichael/following{/other_user}", "gists_url": "https://api.github.com/users/craymichael/gists{/gist_id}", "starred_url": "https://api.github.com/users/craymichael/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/craymichael/subscriptions", "organizations_url": "https://api.github.com/users/craymichael/orgs", "repos_url": "https://api.github.com/users/craymichael/repos", "events_url": "https://api.github.com/users/craymichael/events{/privacy}", "received_events_url": "https://api.github.com/users/craymichael/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2016-10-11T14:31:42Z", "updated_at": "2016-10-14T21:52:44Z", "closed_at": "2016-10-14T05:30:35Z", "author_association": "NONE", "body_html": "<p>TF Version: 0.10.0rc</p>\n<h2>Update</h2>\n<p>Solved the issue, see <a href=\"http://stackoverflow.com/q/39877710/6557588\" rel=\"nofollow\">StackOverflow post here for solution</a>.</p>\n<h2>Original non-Issue...</h2>\n<p>I have a basic <code>input_fn</code> that can be used with Tensorflow Estimators below. It works flawlessly without setting the <code>num_epochs</code> parameter; the obtained tensor has a discrete shape. Pass in <code>num_epochs</code> as anything other than <code>None</code> results in an unknown shape. My issue lies with constructing sparse tensors whilst using <code>num_epochs</code>; I cannot figure out how to generically create said tensors without knowing the shape of the input tensor.</p>\n<p>Can anyone think of a solution to this problem? I'd like to be able to pass <code>num_epochs=1</code> to be able to evaluate only 1 time over the data set, as well as to pass to <code>predict</code> to yield a set of predictions the size of the data set, no more no less.</p>\n<div class=\"highlight highlight-source-python\"><pre>    <span class=\"pl-k\">def</span> <span class=\"pl-en\">input_fn</span>(<span class=\"pl-smi\">batch_size</span>):\n        examples_op <span class=\"pl-k\">=</span> tf.contrib.learn.read_batch_examples(\n            <span class=\"pl-c1\">FILE_NAMES</span>,\n            <span class=\"pl-v\">batch_size</span><span class=\"pl-k\">=</span>batch_size,\n            <span class=\"pl-v\">reader</span><span class=\"pl-k\">=</span>tf.TextLineReader,\n            <span class=\"pl-v\">num_epochs</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">1</span>,\n            <span class=\"pl-v\">parse_fn</span><span class=\"pl-k\">=</span><span class=\"pl-k\">lambda</span> <span class=\"pl-smi\">x</span>: tf.decode_csv(x, [tf.constant([<span class=\"pl-s\"><span class=\"pl-pds\">'</span><span class=\"pl-pds\">'</span></span>], <span class=\"pl-v\">dtype</span><span class=\"pl-k\">=</span>tf.string)] <span class=\"pl-k\">*</span> <span class=\"pl-c1\">len</span>(<span class=\"pl-c1\">HEADERS</span>)))\n\n        examples_dict <span class=\"pl-k\">=</span> {}\n        <span class=\"pl-k\">for</span> i, header <span class=\"pl-k\">in</span> <span class=\"pl-c1\">enumerate</span>(<span class=\"pl-c1\">HEADERS</span>):\n            examples_dict[header] <span class=\"pl-k\">=</span> examples_op[:, i]\n\n        continuous_cols <span class=\"pl-k\">=</span> {k: tf.string_to_number(examples_dict[k], <span class=\"pl-v\">out_type</span><span class=\"pl-k\">=</span>tf.float32)\n                           <span class=\"pl-k\">for</span> k <span class=\"pl-k\">in</span> <span class=\"pl-c1\">CONTINUOUS_FEATURES</span>}\n\n        <span class=\"pl-c\"><span class=\"pl-c\">#</span> Problems lay here while creating sparse categorical tensors</span>\n        categorical_cols <span class=\"pl-k\">=</span> {\n            k: tf.SparseTensor(\n                <span class=\"pl-v\">indices</span><span class=\"pl-k\">=</span>[[i, <span class=\"pl-c1\">0</span>] <span class=\"pl-k\">for</span> i <span class=\"pl-k\">in</span> <span class=\"pl-c1\">range</span>(examples_dict[k].get_shape()[<span class=\"pl-c1\">0</span>])],\n                <span class=\"pl-v\">values</span><span class=\"pl-k\">=</span>examples_dict[k],\n                <span class=\"pl-v\">shape</span><span class=\"pl-k\">=</span>[<span class=\"pl-c1\">int</span>(examples_dict[k].get_shape()[<span class=\"pl-c1\">0</span>]), <span class=\"pl-c1\">1</span>])\n            <span class=\"pl-k\">for</span> k <span class=\"pl-k\">in</span> <span class=\"pl-c1\">CATEGORICAL_FEATURES</span>}\n\n        feature_cols <span class=\"pl-k\">=</span> <span class=\"pl-c1\">dict</span>(continuous_cols)\n        feature_cols.update(categorical_cols)\n        label <span class=\"pl-k\">=</span> tf.string_to_number(examples_dict[<span class=\"pl-c1\">LABEL</span>], <span class=\"pl-v\">out_type</span><span class=\"pl-k\">=</span>tf.int32)\n\n        <span class=\"pl-k\">return</span> feature_cols, label</pre></div>", "body_text": "TF Version: 0.10.0rc\nUpdate\nSolved the issue, see StackOverflow post here for solution.\nOriginal non-Issue...\nI have a basic input_fn that can be used with Tensorflow Estimators below. It works flawlessly without setting the num_epochs parameter; the obtained tensor has a discrete shape. Pass in num_epochs as anything other than None results in an unknown shape. My issue lies with constructing sparse tensors whilst using num_epochs; I cannot figure out how to generically create said tensors without knowing the shape of the input tensor.\nCan anyone think of a solution to this problem? I'd like to be able to pass num_epochs=1 to be able to evaluate only 1 time over the data set, as well as to pass to predict to yield a set of predictions the size of the data set, no more no less.\n    def input_fn(batch_size):\n        examples_op = tf.contrib.learn.read_batch_examples(\n            FILE_NAMES,\n            batch_size=batch_size,\n            reader=tf.TextLineReader,\n            num_epochs=1,\n            parse_fn=lambda x: tf.decode_csv(x, [tf.constant([''], dtype=tf.string)] * len(HEADERS)))\n\n        examples_dict = {}\n        for i, header in enumerate(HEADERS):\n            examples_dict[header] = examples_op[:, i]\n\n        continuous_cols = {k: tf.string_to_number(examples_dict[k], out_type=tf.float32)\n                           for k in CONTINUOUS_FEATURES}\n\n        # Problems lay here while creating sparse categorical tensors\n        categorical_cols = {\n            k: tf.SparseTensor(\n                indices=[[i, 0] for i in range(examples_dict[k].get_shape()[0])],\n                values=examples_dict[k],\n                shape=[int(examples_dict[k].get_shape()[0]), 1])\n            for k in CATEGORICAL_FEATURES}\n\n        feature_cols = dict(continuous_cols)\n        feature_cols.update(categorical_cols)\n        label = tf.string_to_number(examples_dict[LABEL], out_type=tf.int32)\n\n        return feature_cols, label", "body": "TF Version: 0.10.0rc\n## Update\n\nSolved the issue, see [StackOverflow post here for solution](http://stackoverflow.com/q/39877710/6557588).\n## Original non-Issue...\n\nI have a basic `input_fn` that can be used with Tensorflow Estimators below. It works flawlessly without setting the `num_epochs` parameter; the obtained tensor has a discrete shape. Pass in `num_epochs` as anything other than `None` results in an unknown shape. My issue lies with constructing sparse tensors whilst using `num_epochs`; I cannot figure out how to generically create said tensors without knowing the shape of the input tensor.\n\nCan anyone think of a solution to this problem? I'd like to be able to pass `num_epochs=1` to be able to evaluate only 1 time over the data set, as well as to pass to `predict` to yield a set of predictions the size of the data set, no more no less.\n\n``` python\n    def input_fn(batch_size):\n        examples_op = tf.contrib.learn.read_batch_examples(\n            FILE_NAMES,\n            batch_size=batch_size,\n            reader=tf.TextLineReader,\n            num_epochs=1,\n            parse_fn=lambda x: tf.decode_csv(x, [tf.constant([''], dtype=tf.string)] * len(HEADERS)))\n\n        examples_dict = {}\n        for i, header in enumerate(HEADERS):\n            examples_dict[header] = examples_op[:, i]\n\n        continuous_cols = {k: tf.string_to_number(examples_dict[k], out_type=tf.float32)\n                           for k in CONTINUOUS_FEATURES}\n\n        # Problems lay here while creating sparse categorical tensors\n        categorical_cols = {\n            k: tf.SparseTensor(\n                indices=[[i, 0] for i in range(examples_dict[k].get_shape()[0])],\n                values=examples_dict[k],\n                shape=[int(examples_dict[k].get_shape()[0]), 1])\n            for k in CATEGORICAL_FEATURES}\n\n        feature_cols = dict(continuous_cols)\n        feature_cols.update(categorical_cols)\n        label = tf.string_to_number(examples_dict[LABEL], out_type=tf.int32)\n\n        return feature_cols, label\n```\n"}