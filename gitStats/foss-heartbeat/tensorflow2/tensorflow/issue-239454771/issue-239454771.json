{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11138", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11138/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11138/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11138/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/11138", "id": 239454771, "node_id": "MDU6SXNzdWUyMzk0NTQ3NzE=", "number": 11138, "title": "Hang when fitting tensorflow learn model which contains crossed sparse_column_with_* columns and the data is loaded with pandas_input_fn", "user": {"login": "bensowden", "id": 4046078, "node_id": "MDQ6VXNlcjQwNDYwNzg=", "avatar_url": "https://avatars3.githubusercontent.com/u/4046078?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bensowden", "html_url": "https://github.com/bensowden", "followers_url": "https://api.github.com/users/bensowden/followers", "following_url": "https://api.github.com/users/bensowden/following{/other_user}", "gists_url": "https://api.github.com/users/bensowden/gists{/gist_id}", "starred_url": "https://api.github.com/users/bensowden/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bensowden/subscriptions", "organizations_url": "https://api.github.com/users/bensowden/orgs", "repos_url": "https://api.github.com/users/bensowden/repos", "events_url": "https://api.github.com/users/bensowden/events{/privacy}", "received_events_url": "https://api.github.com/users/bensowden/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 473172988, "node_id": "MDU6TGFiZWw0NzMxNzI5ODg=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:bug/performance", "name": "type:bug/performance", "color": "159b2e", "default": false}], "state": "closed", "locked": false, "assignee": {"login": "xiejw", "id": 1184671, "node_id": "MDQ6VXNlcjExODQ2NzE=", "avatar_url": "https://avatars1.githubusercontent.com/u/1184671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xiejw", "html_url": "https://github.com/xiejw", "followers_url": "https://api.github.com/users/xiejw/followers", "following_url": "https://api.github.com/users/xiejw/following{/other_user}", "gists_url": "https://api.github.com/users/xiejw/gists{/gist_id}", "starred_url": "https://api.github.com/users/xiejw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xiejw/subscriptions", "organizations_url": "https://api.github.com/users/xiejw/orgs", "repos_url": "https://api.github.com/users/xiejw/repos", "events_url": "https://api.github.com/users/xiejw/events{/privacy}", "received_events_url": "https://api.github.com/users/xiejw/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "xiejw", "id": 1184671, "node_id": "MDQ6VXNlcjExODQ2NzE=", "avatar_url": "https://avatars1.githubusercontent.com/u/1184671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xiejw", "html_url": "https://github.com/xiejw", "followers_url": "https://api.github.com/users/xiejw/followers", "following_url": "https://api.github.com/users/xiejw/following{/other_user}", "gists_url": "https://api.github.com/users/xiejw/gists{/gist_id}", "starred_url": "https://api.github.com/users/xiejw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xiejw/subscriptions", "organizations_url": "https://api.github.com/users/xiejw/orgs", "repos_url": "https://api.github.com/users/xiejw/repos", "events_url": "https://api.github.com/users/xiejw/events{/privacy}", "received_events_url": "https://api.github.com/users/xiejw/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 6, "created_at": "2017-06-29T11:56:41Z", "updated_at": "2018-11-16T23:18:40Z", "closed_at": "2018-11-16T23:18:40Z", "author_association": "NONE", "body_html": "<h3>System information</h3>\n<ul>\n<li><strong>Have I written custom code (as opposed to using a stock example script provided in TensorFlow)</strong>: Yes</li>\n<li><strong>OS Platform and Distribution (e.g., Linux Ubuntu 16.04)</strong>: Run on Databricks GPU cluster (Ubuntu 16.04.1 LTS)</li>\n<li><strong>TensorFlow installed from (source or binary)</strong>: pip installed tensorflow-gpu</li>\n<li><strong>TensorFlow version (use command below)</strong>: v1.2.0-rc2-21-g12f033d 1.2.0</li>\n<li><strong>Bazel version (if compiling from source)</strong>: n/a</li>\n<li><strong>CUDA/cuDNN version</strong>: CUDA: Version 8.0, cuDNN: Version 5.1 for CUDA 8.0</li>\n<li><strong>GPU model and memory</strong>:</li>\n<li><strong>Exact command to reproduce</strong>:</li>\n</ul>\n<h3>Describe the problem</h3>\n<p>When building Linear models with the tensorflow learn libraries the program hangs if the pandas input function (tensorflow.estimator.inputs.pandas_input_fn) is used and a crossed_column (tensorflow.contrib.layers.crossed_column) is constructed from a sparse_column_with_*. This issue is not seen in the tensorflow tutorials as they use constant tensor's to input the data which does not scale to large datasets. This also only occurs if crossing sparse_column_with_* columns, bucketized continuous columns do not cause a hang.</p>\n<p>The final line of output before the code hangs is: <code>INFO:tensorflow:Create CheckpointSaverHook.</code></p>\n<h3>Source code / logs</h3>\n<p>Minimum working example of bug (with example of code that works and code that breaks):</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">import</span> pandas <span class=\"pl-k\">as</span> pd\n<span class=\"pl-k\">import</span> tensorflow <span class=\"pl-k\">as</span> tf\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> Some sample data</span>\ndf <span class=\"pl-k\">=</span> pd.DataFrame({<span class=\"pl-s\"><span class=\"pl-pds\">'</span>label<span class=\"pl-pds\">'</span></span> : [<span class=\"pl-c1\">0</span>,<span class=\"pl-c1\">1</span>,<span class=\"pl-c1\">1</span>,<span class=\"pl-c1\">0</span>], <span class=\"pl-s\"><span class=\"pl-pds\">'</span>con1<span class=\"pl-pds\">'</span></span> : [<span class=\"pl-c1\">10</span>,<span class=\"pl-c1\">20</span>,<span class=\"pl-c1\">30</span>,<span class=\"pl-c1\">40</span>], <span class=\"pl-s\"><span class=\"pl-pds\">'</span>con2<span class=\"pl-pds\">'</span></span> : [<span class=\"pl-c1\">1</span>,<span class=\"pl-c1\">4</span>,<span class=\"pl-c1\">9</span>,<span class=\"pl-c1\">16</span>], <span class=\"pl-s\"><span class=\"pl-pds\">'</span>cat1<span class=\"pl-pds\">'</span></span> : [<span class=\"pl-s\"><span class=\"pl-pds\">'</span>a<span class=\"pl-pds\">'</span></span>,<span class=\"pl-s\"><span class=\"pl-pds\">'</span>a<span class=\"pl-pds\">'</span></span>,<span class=\"pl-s\"><span class=\"pl-pds\">'</span>b<span class=\"pl-pds\">'</span></span>,<span class=\"pl-s\"><span class=\"pl-pds\">'</span>b<span class=\"pl-pds\">'</span></span>], <span class=\"pl-s\"><span class=\"pl-pds\">'</span>cat2<span class=\"pl-pds\">'</span></span> : [<span class=\"pl-s\"><span class=\"pl-pds\">'</span>c<span class=\"pl-pds\">'</span></span>,<span class=\"pl-s\"><span class=\"pl-pds\">'</span>d<span class=\"pl-pds\">'</span></span>,<span class=\"pl-s\"><span class=\"pl-pds\">'</span>c<span class=\"pl-pds\">'</span></span>,<span class=\"pl-s\"><span class=\"pl-pds\">'</span>d<span class=\"pl-pds\">'</span></span>]})\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> Sparse base columns</span>\n<span class=\"pl-k\">from</span> tensorflow.contrib.layers <span class=\"pl-k\">import</span> sparse_column_with_keys, sparse_column_with_hash_bucket\nsparse_cat1 <span class=\"pl-k\">=</span> sparse_column_with_keys(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>cat1<span class=\"pl-pds\">'</span></span>, <span class=\"pl-v\">keys</span><span class=\"pl-k\">=</span>[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>a<span class=\"pl-pds\">'</span></span>,<span class=\"pl-s\"><span class=\"pl-pds\">'</span>b<span class=\"pl-pds\">'</span></span>])\nsparse_cat2 <span class=\"pl-k\">=</span> sparse_column_with_hash_bucket(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>cat2<span class=\"pl-pds\">'</span></span>, <span class=\"pl-v\">hash_bucket_size</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">10</span>)\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> Bucketised columns</span>\n<span class=\"pl-k\">from</span> tensorflow.contrib.layers <span class=\"pl-k\">import</span> real_valued_column, bucketized_column\nbucket_con1 <span class=\"pl-k\">=</span> bucketized_column(real_valued_column(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>con1<span class=\"pl-pds\">'</span></span>), <span class=\"pl-v\">boundaries</span><span class=\"pl-k\">=</span>[<span class=\"pl-c1\">5</span>,<span class=\"pl-c1\">15</span>,<span class=\"pl-c1\">25</span>,<span class=\"pl-c1\">35</span>])\nbucket_con2 <span class=\"pl-k\">=</span> bucketized_column(real_valued_column(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>con2<span class=\"pl-pds\">'</span></span>), <span class=\"pl-v\">boundaries</span><span class=\"pl-k\">=</span>[<span class=\"pl-c1\">5</span>,<span class=\"pl-c1\">15</span>,<span class=\"pl-c1\">25</span>,<span class=\"pl-c1\">35</span>])\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> Crossed columns</span>\n<span class=\"pl-k\">from</span> tensorflow.contrib.layers <span class=\"pl-k\">import</span> crossed_column\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> This works with both inputs:</span>\ncross_bb <span class=\"pl-k\">=</span> crossed_column([bucket_con1, bucket_con2], <span class=\"pl-v\">hash_bucket_size</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">100</span>)\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> Both these hang with pandas input:</span>\ncross_cc <span class=\"pl-k\">=</span> crossed_column([sparse_cat1, sparse_cat2], <span class=\"pl-v\">hash_bucket_size</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">100</span>)\ncross_bc <span class=\"pl-k\">=</span> crossed_column([bucket_con1, sparse_cat1], <span class=\"pl-v\">hash_bucket_size</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">100</span>)\n\nfeature_columns <span class=\"pl-k\">=</span> [sparse_cat1, sparse_cat2, cross_bb, cross_cc, cross_bc]\nmodel <span class=\"pl-k\">=</span> tf.contrib.learn.LinearClassifier(<span class=\"pl-v\">feature_columns</span><span class=\"pl-k\">=</span>feature_columns)\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> Use pandas input - doesn't work</span>\ntrain_gen_fun <span class=\"pl-k\">=</span> tf.estimator.inputs.pandas_input_fn(df, <span class=\"pl-v\">batch_size</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">len</span>(df), <span class=\"pl-v\">num_epochs</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">None</span>, <span class=\"pl-v\">shuffle</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">True</span>)\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> Split out the label from the features</span>\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">input_fn1</span>(<span class=\"pl-smi\">gen</span>) :\n  features <span class=\"pl-k\">=</span> gen()\n  target <span class=\"pl-k\">=</span> features.pop(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>label<span class=\"pl-pds\">'</span></span>)\n  <span class=\"pl-k\">return</span> features, target\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> Use constant input - does work</span>\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">input_fn2</span>(<span class=\"pl-smi\">df</span>):\n  feature_cols <span class=\"pl-k\">=</span> {\n    <span class=\"pl-s\"><span class=\"pl-pds\">'</span>con1<span class=\"pl-pds\">'</span></span> : tf.constant(df[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>con1<span class=\"pl-pds\">'</span></span>].values),\n    <span class=\"pl-s\"><span class=\"pl-pds\">'</span>con2<span class=\"pl-pds\">'</span></span> : tf.constant(df[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>con2<span class=\"pl-pds\">'</span></span>].values),\n    <span class=\"pl-s\"><span class=\"pl-pds\">'</span>cat1<span class=\"pl-pds\">'</span></span> : tf.SparseTensor(<span class=\"pl-v\">indices</span><span class=\"pl-k\">=</span>[[i, <span class=\"pl-c1\">0</span>] <span class=\"pl-k\">for</span> i <span class=\"pl-k\">in</span> <span class=\"pl-c1\">range</span>(df[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>cat1<span class=\"pl-pds\">'</span></span>].size)],\n                             <span class=\"pl-v\">values</span><span class=\"pl-k\">=</span>df[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>cat1<span class=\"pl-pds\">'</span></span>].values, <span class=\"pl-v\">dense_shape</span><span class=\"pl-k\">=</span>[df[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>cat1<span class=\"pl-pds\">'</span></span>].size, <span class=\"pl-c1\">1</span>]),\n    <span class=\"pl-s\"><span class=\"pl-pds\">'</span>cat2<span class=\"pl-pds\">'</span></span> : tf.SparseTensor(<span class=\"pl-v\">indices</span><span class=\"pl-k\">=</span>[[i, <span class=\"pl-c1\">0</span>] <span class=\"pl-k\">for</span> i <span class=\"pl-k\">in</span> <span class=\"pl-c1\">range</span>(df[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>cat2<span class=\"pl-pds\">'</span></span>].size)],\n                             <span class=\"pl-v\">values</span><span class=\"pl-k\">=</span>df[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>cat2<span class=\"pl-pds\">'</span></span>].values, <span class=\"pl-v\">dense_shape</span><span class=\"pl-k\">=</span>[df[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>cat2<span class=\"pl-pds\">'</span></span>].size, <span class=\"pl-c1\">1</span>]),\n  }\n  label <span class=\"pl-k\">=</span> tf.constant(df[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>label<span class=\"pl-pds\">'</span></span>].values)\n  <span class=\"pl-k\">return</span> feature_cols, label\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> This hangs</span>\nmodel.fit(<span class=\"pl-v\">input_fn</span><span class=\"pl-k\">=</span><span class=\"pl-k\">lambda</span>:input_fn1(train_gen_fun), <span class=\"pl-v\">steps</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">10</span>)\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> This works</span>\nmodel.fit(<span class=\"pl-v\">input_fn</span><span class=\"pl-k\">=</span><span class=\"pl-k\">lambda</span>:input_fn2(df), <span class=\"pl-v\">steps</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">10</span>)</pre></div>", "body_text": "System information\n\nHave I written custom code (as opposed to using a stock example script provided in TensorFlow): Yes\nOS Platform and Distribution (e.g., Linux Ubuntu 16.04): Run on Databricks GPU cluster (Ubuntu 16.04.1 LTS)\nTensorFlow installed from (source or binary): pip installed tensorflow-gpu\nTensorFlow version (use command below): v1.2.0-rc2-21-g12f033d 1.2.0\nBazel version (if compiling from source): n/a\nCUDA/cuDNN version: CUDA: Version 8.0, cuDNN: Version 5.1 for CUDA 8.0\nGPU model and memory:\nExact command to reproduce:\n\nDescribe the problem\nWhen building Linear models with the tensorflow learn libraries the program hangs if the pandas input function (tensorflow.estimator.inputs.pandas_input_fn) is used and a crossed_column (tensorflow.contrib.layers.crossed_column) is constructed from a sparse_column_with_*. This issue is not seen in the tensorflow tutorials as they use constant tensor's to input the data which does not scale to large datasets. This also only occurs if crossing sparse_column_with_* columns, bucketized continuous columns do not cause a hang.\nThe final line of output before the code hangs is: INFO:tensorflow:Create CheckpointSaverHook.\nSource code / logs\nMinimum working example of bug (with example of code that works and code that breaks):\nimport pandas as pd\nimport tensorflow as tf\n\n# Some sample data\ndf = pd.DataFrame({'label' : [0,1,1,0], 'con1' : [10,20,30,40], 'con2' : [1,4,9,16], 'cat1' : ['a','a','b','b'], 'cat2' : ['c','d','c','d']})\n\n# Sparse base columns\nfrom tensorflow.contrib.layers import sparse_column_with_keys, sparse_column_with_hash_bucket\nsparse_cat1 = sparse_column_with_keys('cat1', keys=['a','b'])\nsparse_cat2 = sparse_column_with_hash_bucket('cat2', hash_bucket_size=10)\n\n# Bucketised columns\nfrom tensorflow.contrib.layers import real_valued_column, bucketized_column\nbucket_con1 = bucketized_column(real_valued_column('con1'), boundaries=[5,15,25,35])\nbucket_con2 = bucketized_column(real_valued_column('con2'), boundaries=[5,15,25,35])\n\n# Crossed columns\nfrom tensorflow.contrib.layers import crossed_column\n# This works with both inputs:\ncross_bb = crossed_column([bucket_con1, bucket_con2], hash_bucket_size=100)\n# Both these hang with pandas input:\ncross_cc = crossed_column([sparse_cat1, sparse_cat2], hash_bucket_size=100)\ncross_bc = crossed_column([bucket_con1, sparse_cat1], hash_bucket_size=100)\n\nfeature_columns = [sparse_cat1, sparse_cat2, cross_bb, cross_cc, cross_bc]\nmodel = tf.contrib.learn.LinearClassifier(feature_columns=feature_columns)\n\n# Use pandas input - doesn't work\ntrain_gen_fun = tf.estimator.inputs.pandas_input_fn(df, batch_size=len(df), num_epochs=None, shuffle=True)\n# Split out the label from the features\ndef input_fn1(gen) :\n  features = gen()\n  target = features.pop('label')\n  return features, target\n\n# Use constant input - does work\ndef input_fn2(df):\n  feature_cols = {\n    'con1' : tf.constant(df['con1'].values),\n    'con2' : tf.constant(df['con2'].values),\n    'cat1' : tf.SparseTensor(indices=[[i, 0] for i in range(df['cat1'].size)],\n                             values=df['cat1'].values, dense_shape=[df['cat1'].size, 1]),\n    'cat2' : tf.SparseTensor(indices=[[i, 0] for i in range(df['cat2'].size)],\n                             values=df['cat2'].values, dense_shape=[df['cat2'].size, 1]),\n  }\n  label = tf.constant(df['label'].values)\n  return feature_cols, label\n\n# This hangs\nmodel.fit(input_fn=lambda:input_fn1(train_gen_fun), steps=10)\n\n# This works\nmodel.fit(input_fn=lambda:input_fn2(df), steps=10)", "body": "### System information\r\n- **Have I written custom code (as opposed to using a stock example script provided in TensorFlow)**: Yes\r\n- **OS Platform and Distribution (e.g., Linux Ubuntu 16.04)**: Run on Databricks GPU cluster (Ubuntu 16.04.1 LTS)\r\n- **TensorFlow installed from (source or binary)**: pip installed tensorflow-gpu\r\n- **TensorFlow version (use command below)**: v1.2.0-rc2-21-g12f033d 1.2.0\r\n- **Bazel version (if compiling from source)**: n/a\r\n- **CUDA/cuDNN version**: CUDA: Version 8.0, cuDNN: Version 5.1 for CUDA 8.0\r\n- **GPU model and memory**:\r\n- **Exact command to reproduce**:\r\n\r\n### Describe the problem\r\n\r\nWhen building Linear models with the tensorflow learn libraries the program hangs if the pandas input function (tensorflow.estimator.inputs.pandas_input_fn) is used and a crossed_column (tensorflow.contrib.layers.crossed_column) is constructed from a sparse_column_with_\\*. This issue is not seen in the tensorflow tutorials as they use constant tensor's to input the data which does not scale to large datasets. This also only occurs if crossing sparse_column_with_\\* columns, bucketized continuous columns do not cause a hang.\r\n\r\nThe final line of output before the code hangs is: `INFO:tensorflow:Create CheckpointSaverHook.`\r\n\r\n### Source code / logs\r\n\r\nMinimum working example of bug (with example of code that works and code that breaks):\r\n\r\n```python\r\nimport pandas as pd\r\nimport tensorflow as tf\r\n\r\n# Some sample data\r\ndf = pd.DataFrame({'label' : [0,1,1,0], 'con1' : [10,20,30,40], 'con2' : [1,4,9,16], 'cat1' : ['a','a','b','b'], 'cat2' : ['c','d','c','d']})\r\n\r\n# Sparse base columns\r\nfrom tensorflow.contrib.layers import sparse_column_with_keys, sparse_column_with_hash_bucket\r\nsparse_cat1 = sparse_column_with_keys('cat1', keys=['a','b'])\r\nsparse_cat2 = sparse_column_with_hash_bucket('cat2', hash_bucket_size=10)\r\n\r\n# Bucketised columns\r\nfrom tensorflow.contrib.layers import real_valued_column, bucketized_column\r\nbucket_con1 = bucketized_column(real_valued_column('con1'), boundaries=[5,15,25,35])\r\nbucket_con2 = bucketized_column(real_valued_column('con2'), boundaries=[5,15,25,35])\r\n\r\n# Crossed columns\r\nfrom tensorflow.contrib.layers import crossed_column\r\n# This works with both inputs:\r\ncross_bb = crossed_column([bucket_con1, bucket_con2], hash_bucket_size=100)\r\n# Both these hang with pandas input:\r\ncross_cc = crossed_column([sparse_cat1, sparse_cat2], hash_bucket_size=100)\r\ncross_bc = crossed_column([bucket_con1, sparse_cat1], hash_bucket_size=100)\r\n\r\nfeature_columns = [sparse_cat1, sparse_cat2, cross_bb, cross_cc, cross_bc]\r\nmodel = tf.contrib.learn.LinearClassifier(feature_columns=feature_columns)\r\n\r\n# Use pandas input - doesn't work\r\ntrain_gen_fun = tf.estimator.inputs.pandas_input_fn(df, batch_size=len(df), num_epochs=None, shuffle=True)\r\n# Split out the label from the features\r\ndef input_fn1(gen) :\r\n  features = gen()\r\n  target = features.pop('label')\r\n  return features, target\r\n\r\n# Use constant input - does work\r\ndef input_fn2(df):\r\n  feature_cols = {\r\n    'con1' : tf.constant(df['con1'].values),\r\n    'con2' : tf.constant(df['con2'].values),\r\n    'cat1' : tf.SparseTensor(indices=[[i, 0] for i in range(df['cat1'].size)],\r\n                             values=df['cat1'].values, dense_shape=[df['cat1'].size, 1]),\r\n    'cat2' : tf.SparseTensor(indices=[[i, 0] for i in range(df['cat2'].size)],\r\n                             values=df['cat2'].values, dense_shape=[df['cat2'].size, 1]),\r\n  }\r\n  label = tf.constant(df['label'].values)\r\n  return feature_cols, label\r\n\r\n# This hangs\r\nmodel.fit(input_fn=lambda:input_fn1(train_gen_fun), steps=10)\r\n\r\n# This works\r\nmodel.fit(input_fn=lambda:input_fn2(df), steps=10)\r\n```\r\n"}