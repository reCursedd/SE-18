{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/235601341", "html_url": "https://github.com/tensorflow/tensorflow/issues/1830#issuecomment-235601341", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/1830", "id": 235601341, "node_id": "MDEyOklzc3VlQ29tbWVudDIzNTYwMTM0MQ==", "user": {"login": "MaZhuang", "id": 6137461, "node_id": "MDQ6VXNlcjYxMzc0NjE=", "avatar_url": "https://avatars0.githubusercontent.com/u/6137461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/MaZhuang", "html_url": "https://github.com/MaZhuang", "followers_url": "https://api.github.com/users/MaZhuang/followers", "following_url": "https://api.github.com/users/MaZhuang/following{/other_user}", "gists_url": "https://api.github.com/users/MaZhuang/gists{/gist_id}", "starred_url": "https://api.github.com/users/MaZhuang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/MaZhuang/subscriptions", "organizations_url": "https://api.github.com/users/MaZhuang/orgs", "repos_url": "https://api.github.com/users/MaZhuang/repos", "events_url": "https://api.github.com/users/MaZhuang/events{/privacy}", "received_events_url": "https://api.github.com/users/MaZhuang/received_events", "type": "User", "site_admin": false}, "created_at": "2016-07-27T14:25:02Z", "updated_at": "2016-07-27T14:27:25Z", "author_association": "NONE", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=1794715\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/ebrevdo\">@ebrevdo</a> THANKS! Correct me if I miss something, the value of the state in currently rnn function will inherit the value from previous state if the the time step t is larger than the sentence length. Conceptually, the same trick can be applied to output without any further difficulty.  It seems that we can simply replace zero_output=zero_output in the following code with zero_output = output to achieve this and set the initial value of output to be zero_output.<br>\n`for time, input_ in enumerate(inputs):</p>\n<pre><code>  if time &gt; 0: varscope.reuse_variables()\n  # pylint: disable=cell-var-from-loop\n  call_cell = lambda: cell(input_, state)\n  # pylint: enable=cell-var-from-loop\n  if sequence_length is not None:\n    (output, state) = _rnn_step(\n        time=time,\n        sequence_length=sequence_length,\n        min_sequence_length=min_sequence_length,\n        max_sequence_length=max_sequence_length,\n        zero_output=zero_output,\n        state=state,\n        call_cell=call_cell,\n        state_size=cell.state_size)\n  else:\n    (output, state) = call_cell()\n  outputs.append(output)\n</code></pre>\n<p>`</p>", "body_text": "@ebrevdo THANKS! Correct me if I miss something, the value of the state in currently rnn function will inherit the value from previous state if the the time step t is larger than the sentence length. Conceptually, the same trick can be applied to output without any further difficulty.  It seems that we can simply replace zero_output=zero_output in the following code with zero_output = output to achieve this and set the initial value of output to be zero_output.\n`for time, input_ in enumerate(inputs):\n  if time > 0: varscope.reuse_variables()\n  # pylint: disable=cell-var-from-loop\n  call_cell = lambda: cell(input_, state)\n  # pylint: enable=cell-var-from-loop\n  if sequence_length is not None:\n    (output, state) = _rnn_step(\n        time=time,\n        sequence_length=sequence_length,\n        min_sequence_length=min_sequence_length,\n        max_sequence_length=max_sequence_length,\n        zero_output=zero_output,\n        state=state,\n        call_cell=call_cell,\n        state_size=cell.state_size)\n  else:\n    (output, state) = call_cell()\n  outputs.append(output)\n\n`", "body": "@ebrevdo THANKS! Correct me if I miss something, the value of the state in currently rnn function will inherit the value from previous state if the the time step t is larger than the sentence length. Conceptually, the same trick can be applied to output without any further difficulty.  It seems that we can simply replace zero_output=zero_output in the following code with zero_output = output to achieve this and set the initial value of output to be zero_output. \n`for time, input_ in enumerate(inputs):\n\n```\n  if time > 0: varscope.reuse_variables()\n  # pylint: disable=cell-var-from-loop\n  call_cell = lambda: cell(input_, state)\n  # pylint: enable=cell-var-from-loop\n  if sequence_length is not None:\n    (output, state) = _rnn_step(\n        time=time,\n        sequence_length=sequence_length,\n        min_sequence_length=min_sequence_length,\n        max_sequence_length=max_sequence_length,\n        zero_output=zero_output,\n        state=state,\n        call_cell=call_cell,\n        state_size=cell.state_size)\n  else:\n    (output, state) = call_cell()\n  outputs.append(output)\n```\n\n`\n"}