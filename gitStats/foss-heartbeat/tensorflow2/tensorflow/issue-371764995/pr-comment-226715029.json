{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/226715029", "pull_request_review_id": 166609500, "id": 226715029, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNjcxNTAyOQ==", "diff_hunk": "@@ -176,49 +176,64 @@ def _binary_assert(sym, opname, op_func, static_func,\n     if context.executing_eagerly():\n       test = op_func(x, y)\n       condition = math_ops.reduce_all(test)\n-      if not condition:\n-        # Prepare a message with first elements of x and y.\n-        summary_msg = ''\n-        # Default to printing 3 elements like control_flow_ops.Assert (used\n-        # by graph mode) does.\n-        summarize = 3 if summarize is None else summarize\n-        if summarize:\n-          # reshape((-1,)) is the fastest way to get a flat array view.\n-          x_np = x.numpy().reshape((-1,))\n-          y_np = y.numpy().reshape((-1,))\n-          x_sum = min(x_np.size, summarize)\n-          y_sum = min(y_np.size, summarize)\n-          summary_msg = ('First %d elements of x:\\n%s\\n'\n-                         'First %d elements of y:\\n%s\\n' %\n-                         (x_sum, x_np[:x_sum],\n-                          y_sum, y_np[:y_sum]))\n-\n-        index_and_values_str = ''\n-        if x.shape == y.shape and x.shape.as_list():\n-          # If the shapes of x and y are the same (and not scalars),\n-          # Get the values that actually differed and their indices.\n-          # If shapes are different this information is more confusing\n-          # than useful.\n-          mask = math_ops.logical_not(test)\n-          indices = array_ops.where(mask)\n-          indices_np = indices.numpy()\n-          x_vals = array_ops.boolean_mask(x, mask)\n-          y_vals = array_ops.boolean_mask(y, mask)\n-          summarize = min(summarize, indices_np.shape[0])\n-          index_and_values_str = (\n-              'Indices of first %s different values:\\n%s\\n'\n-              'Corresponding x values:\\n%s\\n'\n-              'Corresponding y values:\\n%s\\n' %\n-              (summarize, indices_np[:summarize],\n-               x_vals.numpy().reshape((-1,))[:summarize],\n-               y_vals.numpy().reshape((-1,))[:summarize]))\n+      if condition:\n+        return\n+      else:\n+        if data is None:\n+          # Prepare a message with first elements of x and y.\n+          data = []\n+          if message is not None:\n+            data.append(message)\n+\n+          data.append('Condition x %s y did not hold.' % sym)\n+\n+          # Default to printing 3 elements like control_flow_ops.Assert (used\n+          # by graph mode) does. Also treat negative values as \"print\n+          # everything\" for consistency with Tensor::SummarizeValue().\n+          if summarize is None:\n+            summarize = 3\n+          elif summarize < 0:\n+            summarize = 1e9 # Code below will find exact size of x and y.\n+\n+          if summarize > 0:\n+            if x.shape == y.shape and x.shape.as_list():\n+              # If the shapes of x and y are the same (and not scalars),\n+              # Get the values that actually differed and their indices.\n+              # If shapes are different this information is more confusing\n+              # than useful.\n+              mask = math_ops.logical_not(test)\n+              indices = array_ops.where(mask)\n+              indices_np = indices.numpy()\n+              x_vals = array_ops.boolean_mask(x, mask)\n+              y_vals = array_ops.boolean_mask(y, mask)\n+              num_vals = min(summarize, indices_np.shape[0])\n+              data.append('Indices of first %d different values:' % num_vals)\n+              data.append(indices_np[:num_vals])\n+              data.append('Corresponding x values:')\n+              data.append(x_vals.numpy().reshape((-1,))[:num_vals])\n+              data.append('Corresponding y values:')\n+              data.append(y_vals.numpy().reshape((-1,))[:num_vals])\n+            \n+          if summarize > 0:", "path": "tensorflow/python/ops/check_ops.py", "position": null, "original_position": 78, "commit_id": "6e45e6ae21529ffebd4c0856cb1c2c8a278bf780", "original_commit_id": "10ff0fa69a06d520e38ceb790ee865d720d7266a", "user": {"login": "iganichev", "id": 9123400, "node_id": "MDQ6VXNlcjkxMjM0MDA=", "avatar_url": "https://avatars2.githubusercontent.com/u/9123400?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iganichev", "html_url": "https://github.com/iganichev", "followers_url": "https://api.github.com/users/iganichev/followers", "following_url": "https://api.github.com/users/iganichev/following{/other_user}", "gists_url": "https://api.github.com/users/iganichev/gists{/gist_id}", "starred_url": "https://api.github.com/users/iganichev/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iganichev/subscriptions", "organizations_url": "https://api.github.com/users/iganichev/orgs", "repos_url": "https://api.github.com/users/iganichev/repos", "events_url": "https://api.github.com/users/iganichev/events{/privacy}", "received_events_url": "https://api.github.com/users/iganichev/received_events", "type": "User", "site_admin": false}, "body": "does not seem necessary", "created_at": "2018-10-19T16:57:06Z", "updated_at": "2018-10-19T18:30:17Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/23090#discussion_r226715029", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/23090", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/226715029"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/23090#discussion_r226715029"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/23090"}}, "body_html": "<p>does not seem necessary</p>", "body_text": "does not seem necessary"}