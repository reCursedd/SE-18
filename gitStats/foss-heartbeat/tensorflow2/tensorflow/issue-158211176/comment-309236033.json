{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/309236033", "html_url": "https://github.com/tensorflow/tensorflow/issues/2625#issuecomment-309236033", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2625", "id": 309236033, "node_id": "MDEyOklzc3VlQ29tbWVudDMwOTIzNjAzMw==", "user": {"login": "lakshayg", "id": 7976315, "node_id": "MDQ6VXNlcjc5NzYzMTU=", "avatar_url": "https://avatars0.githubusercontent.com/u/7976315?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lakshayg", "html_url": "https://github.com/lakshayg", "followers_url": "https://api.github.com/users/lakshayg/followers", "following_url": "https://api.github.com/users/lakshayg/following{/other_user}", "gists_url": "https://api.github.com/users/lakshayg/gists{/gist_id}", "starred_url": "https://api.github.com/users/lakshayg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lakshayg/subscriptions", "organizations_url": "https://api.github.com/users/lakshayg/orgs", "repos_url": "https://api.github.com/users/lakshayg/repos", "events_url": "https://api.github.com/users/lakshayg/events{/privacy}", "received_events_url": "https://api.github.com/users/lakshayg/received_events", "type": "User", "site_admin": false}, "created_at": "2017-06-17T19:45:22Z", "updated_at": "2017-06-17T19:45:22Z", "author_association": "CONTRIBUTOR", "body_html": "<p>I have started working on this issue by implementing a modified version of Kahan summation in <strong>eigen</strong>. I have created the following functor.</p>\n<div class=\"highlight highlight-source-c++\"><pre><span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">typename</span> T&gt; <span class=\"pl-k\">struct</span> <span class=\"pl-en\">NeumaierSumReducer</span>\n{\n  <span class=\"pl-k\">static</span> <span class=\"pl-k\">const</span> <span class=\"pl-k\">bool</span> PacketAccess = <span class=\"pl-c1\">false</span>; <span class=\"pl-c\"><span class=\"pl-c\">//</span>packet_traits&lt;T&gt;::HasAdd;</span>\n  <span class=\"pl-k\">static</span> <span class=\"pl-k\">const</span> <span class=\"pl-k\">bool</span> IsStateful = <span class=\"pl-c1\">true</span>;\n\n  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE\n  <span class=\"pl-en\">NeumaierSumReducer</span>() : compensation_(<span class=\"pl-c1\">0</span>) { }\n\n  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <span class=\"pl-k\">void</span> <span class=\"pl-en\">reduce</span>(<span class=\"pl-k\">const</span> T t, T* accum) {\n    internal::scalar_sum_op&lt;T&gt; sum_op;\n    internal::scalar_difference_op&lt;T&gt; diff_op;\n    internal::scalar_abs_op&lt;T&gt; abs_op;\n    T tempSum_ = <span class=\"pl-c1\">sum_op</span>(*accum, t);\n    <span class=\"pl-k\">if</span> (<span class=\"pl-c1\">abs_op</span>(*accum) &gt;= <span class=\"pl-c1\">abs_op</span>(t)) {\n      compensation_ += <span class=\"pl-c1\">sum_op</span>(<span class=\"pl-c1\">diff_op</span>(*accum, tempSum_), t);\n    } <span class=\"pl-k\">else</span> {\n      compensation_ += <span class=\"pl-c1\">sum_op</span>(<span class=\"pl-c1\">diff_op</span>(t, tempSum_), *accum);\n    }\n    *accum = tempSum_;\n  }\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>template &lt;typename Packet&gt;</span>\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void reducePacket(const Packet&amp; p, Packet* accum) {</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span>Packet tempSum_ = padd&lt;Packet&gt;(*accum, p);</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span>if (pabs&lt;Packet&gt;(*accum) &gt;= pabs&lt;Packet&gt;(p)) {</span>\n      <span class=\"pl-c\"><span class=\"pl-c\">//</span>compensation_ += predux(padd&lt;Packet&gt;(psub&lt;Packet&gt;(*accum, tempSum_), p));</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span>} else {</span>\n      <span class=\"pl-c\"><span class=\"pl-c\">//</span>compensation_ += predux(padd&lt;Packet&gt;(psub&lt;Packet&gt;(p, tempSum_), *accum));</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span>}</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span>(*accum) = tempSum_;</span>\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>}</span>\n\n  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T <span class=\"pl-en\">initialize</span>() <span class=\"pl-k\">const</span> {\n    internal::scalar_cast_op&lt;<span class=\"pl-k\">int</span>, T&gt; conv;\n    <span class=\"pl-k\">return</span> <span class=\"pl-c1\">conv</span>(<span class=\"pl-c1\">0</span>);\n  }\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>template &lt;typename Packet&gt;</span>\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Packet initializePacket() const {</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span>return pset1&lt;Packet&gt;(initialize());</span>\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>}</span>\n  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T <span class=\"pl-en\">finalize</span>(<span class=\"pl-k\">const</span> T accum) <span class=\"pl-k\">const</span> {\n    <span class=\"pl-k\">return</span> accum + compensation_;\n  }\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>template &lt;typename Packet&gt;</span>\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Packet finalizePacket(const Packet&amp; vaccum) const {</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span>return vaccum;</span>\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>}</span>\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>template &lt;typename Packet&gt;</span>\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T finalizeBoth(const T saccum, const Packet&amp; vaccum) const {</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span>internal::scalar_sum_op&lt;T&gt; sum_op;</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span>return sum_op(sum_op(saccum, predux(vaccum)), compensation_);</span>\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span>}</span>\n\n  <span class=\"pl-k\">protected:</span>\n    T compensation_;\n};\n\n#<span class=\"pl-k\">define</span> <span class=\"pl-en\">SumReducer</span> NeumaierSumReducer\n\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">typename</span> T, <span class=\"pl-k\">typename</span> Device&gt;\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">reducer_traits</span>&lt;NeumaierSumReducer&lt;T&gt;, Device&gt; {\n  <span class=\"pl-k\">enum</span> {\n    Cost = <span class=\"pl-c1\">4</span> * NumTraits&lt;T&gt;::AddCost,\n    PacketAccess = <span class=\"pl-c1\">false</span><span class=\"pl-c\"><span class=\"pl-c\">//</span>PacketType&lt;T, Device&gt;::HasAdd</span>\n  };\n};\n</pre></div>\n<p>I commented out the code for <code>SumReducer</code> and used <code>#define</code> to replace all instances of <code>SumReducer</code> with <code>NeumaierSumReducer</code>. All the relevant tests seem to be running fine after this change.</p>\n<p>Now I am facing 2 issues:</p>\n<ol>\n<li>I am unable to get the functor working with <code>Packet</code> as I do not understand it completely. I tried creating a compensation variable of type <code>Packet</code> but it gave an error saying that <code>Packet</code> does not name a type.</li>\n<li>I am unable to see if the change actually made any improvement. I tried with a custom code and gave it a case which should cause erroneous results with the standard summation method but work well with the modified algorithm. But both the versions seem to be performing identically. I used a debugger to see if the <code>SumReducer</code> functor was being used but surprisingly, it was never used when computing the sum.</li>\n</ol>\n<p>Here is the sample code</p>\n<div class=\"highlight highlight-source-c++\"><pre>#<span class=\"pl-k\">include</span> <span class=\"pl-s\"><span class=\"pl-pds\">&lt;</span>iostream<span class=\"pl-pds\">&gt;</span></span>\n#<span class=\"pl-k\">include</span> <span class=\"pl-s\"><span class=\"pl-pds\">&lt;</span>Eigen/Dense<span class=\"pl-pds\">&gt;</span></span>\n#<span class=\"pl-k\">include</span> <span class=\"pl-s\"><span class=\"pl-pds\">&lt;</span>iomanip<span class=\"pl-pds\">&gt;</span></span>\n\n<span class=\"pl-k\">using</span> <span class=\"pl-k\">namespace</span> <span class=\"pl-en\">std</span><span class=\"pl-k\">;</span>\n<span class=\"pl-k\">int</span> <span class=\"pl-en\">main</span>()\n{\n  Eigen::Matrix2f mat;\n  mat &lt;&lt; <span class=\"pl-c1\">1000000000.0</span>, <span class=\"pl-c1\">2.00002</span>,\n         <span class=\"pl-c1\">1.00003</span>, -<span class=\"pl-c1\">1000000000.0</span>;\n  cout &lt;&lt; <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Here is mat.sum():       <span class=\"pl-pds\">\"</span></span> &lt;&lt; <span class=\"pl-c1\">std::setprecision</span>(<span class=\"pl-c1\">10</span>) &lt;&lt; mat.<span class=\"pl-c1\">sum</span>()       &lt;&lt; endl;\n}</pre></div>\n<p>Any hints will be helpful. The eigen mailing list doesn't seem to be very active.</p>", "body_text": "I have started working on this issue by implementing a modified version of Kahan summation in eigen. I have created the following functor.\ntemplate <typename T> struct NeumaierSumReducer\n{\n  static const bool PacketAccess = false; //packet_traits<T>::HasAdd;\n  static const bool IsStateful = true;\n\n  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE\n  NeumaierSumReducer() : compensation_(0) { }\n\n  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void reduce(const T t, T* accum) {\n    internal::scalar_sum_op<T> sum_op;\n    internal::scalar_difference_op<T> diff_op;\n    internal::scalar_abs_op<T> abs_op;\n    T tempSum_ = sum_op(*accum, t);\n    if (abs_op(*accum) >= abs_op(t)) {\n      compensation_ += sum_op(diff_op(*accum, tempSum_), t);\n    } else {\n      compensation_ += sum_op(diff_op(t, tempSum_), *accum);\n    }\n    *accum = tempSum_;\n  }\n  //template <typename Packet>\n  //EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void reducePacket(const Packet& p, Packet* accum) {\n    //Packet tempSum_ = padd<Packet>(*accum, p);\n    //if (pabs<Packet>(*accum) >= pabs<Packet>(p)) {\n      //compensation_ += predux(padd<Packet>(psub<Packet>(*accum, tempSum_), p));\n    //} else {\n      //compensation_ += predux(padd<Packet>(psub<Packet>(p, tempSum_), *accum));\n    //}\n    //(*accum) = tempSum_;\n  //}\n\n  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T initialize() const {\n    internal::scalar_cast_op<int, T> conv;\n    return conv(0);\n  }\n  //template <typename Packet>\n  //EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Packet initializePacket() const {\n    //return pset1<Packet>(initialize());\n  //}\n  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T finalize(const T accum) const {\n    return accum + compensation_;\n  }\n  //template <typename Packet>\n  //EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Packet finalizePacket(const Packet& vaccum) const {\n    //return vaccum;\n  //}\n  //template <typename Packet>\n  //EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T finalizeBoth(const T saccum, const Packet& vaccum) const {\n    //internal::scalar_sum_op<T> sum_op;\n    //return sum_op(sum_op(saccum, predux(vaccum)), compensation_);\n  //}\n\n  protected:\n    T compensation_;\n};\n\n#define SumReducer NeumaierSumReducer\n\ntemplate <typename T, typename Device>\nstruct reducer_traits<NeumaierSumReducer<T>, Device> {\n  enum {\n    Cost = 4 * NumTraits<T>::AddCost,\n    PacketAccess = false//PacketType<T, Device>::HasAdd\n  };\n};\n\nI commented out the code for SumReducer and used #define to replace all instances of SumReducer with NeumaierSumReducer. All the relevant tests seem to be running fine after this change.\nNow I am facing 2 issues:\n\nI am unable to get the functor working with Packet as I do not understand it completely. I tried creating a compensation variable of type Packet but it gave an error saying that Packet does not name a type.\nI am unable to see if the change actually made any improvement. I tried with a custom code and gave it a case which should cause erroneous results with the standard summation method but work well with the modified algorithm. But both the versions seem to be performing identically. I used a debugger to see if the SumReducer functor was being used but surprisingly, it was never used when computing the sum.\n\nHere is the sample code\n#include <iostream>\n#include <Eigen/Dense>\n#include <iomanip>\n\nusing namespace std;\nint main()\n{\n  Eigen::Matrix2f mat;\n  mat << 1000000000.0, 2.00002,\n         1.00003, -1000000000.0;\n  cout << \"Here is mat.sum():       \" << std::setprecision(10) << mat.sum()       << endl;\n}\nAny hints will be helpful. The eigen mailing list doesn't seem to be very active.", "body": "I have started working on this issue by implementing a modified version of Kahan summation in **eigen**. I have created the following functor.\r\n\r\n```cpp\r\ntemplate <typename T> struct NeumaierSumReducer\r\n{\r\n  static const bool PacketAccess = false; //packet_traits<T>::HasAdd;\r\n  static const bool IsStateful = true;\r\n\r\n  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE\r\n  NeumaierSumReducer() : compensation_(0) { }\r\n\r\n  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void reduce(const T t, T* accum) {\r\n    internal::scalar_sum_op<T> sum_op;\r\n    internal::scalar_difference_op<T> diff_op;\r\n    internal::scalar_abs_op<T> abs_op;\r\n    T tempSum_ = sum_op(*accum, t);\r\n    if (abs_op(*accum) >= abs_op(t)) {\r\n      compensation_ += sum_op(diff_op(*accum, tempSum_), t);\r\n    } else {\r\n      compensation_ += sum_op(diff_op(t, tempSum_), *accum);\r\n    }\r\n    *accum = tempSum_;\r\n  }\r\n  //template <typename Packet>\r\n  //EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void reducePacket(const Packet& p, Packet* accum) {\r\n    //Packet tempSum_ = padd<Packet>(*accum, p);\r\n    //if (pabs<Packet>(*accum) >= pabs<Packet>(p)) {\r\n      //compensation_ += predux(padd<Packet>(psub<Packet>(*accum, tempSum_), p));\r\n    //} else {\r\n      //compensation_ += predux(padd<Packet>(psub<Packet>(p, tempSum_), *accum));\r\n    //}\r\n    //(*accum) = tempSum_;\r\n  //}\r\n\r\n  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T initialize() const {\r\n    internal::scalar_cast_op<int, T> conv;\r\n    return conv(0);\r\n  }\r\n  //template <typename Packet>\r\n  //EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Packet initializePacket() const {\r\n    //return pset1<Packet>(initialize());\r\n  //}\r\n  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T finalize(const T accum) const {\r\n    return accum + compensation_;\r\n  }\r\n  //template <typename Packet>\r\n  //EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Packet finalizePacket(const Packet& vaccum) const {\r\n    //return vaccum;\r\n  //}\r\n  //template <typename Packet>\r\n  //EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T finalizeBoth(const T saccum, const Packet& vaccum) const {\r\n    //internal::scalar_sum_op<T> sum_op;\r\n    //return sum_op(sum_op(saccum, predux(vaccum)), compensation_);\r\n  //}\r\n\r\n  protected:\r\n    T compensation_;\r\n};\r\n\r\n#define SumReducer NeumaierSumReducer\r\n\r\ntemplate <typename T, typename Device>\r\nstruct reducer_traits<NeumaierSumReducer<T>, Device> {\r\n  enum {\r\n    Cost = 4 * NumTraits<T>::AddCost,\r\n    PacketAccess = false//PacketType<T, Device>::HasAdd\r\n  };\r\n};\r\n\r\n```\r\nI commented out the code for `SumReducer` and used `#define` to replace all instances of `SumReducer` with `NeumaierSumReducer`. All the relevant tests seem to be running fine after this change.\r\n\r\nNow I am facing 2 issues:\r\n\r\n1. I am unable to get the functor working with `Packet` as I do not understand it completely. I tried creating a compensation variable of type `Packet` but it gave an error saying that `Packet` does not name a type.\r\n2. I am unable to see if the change actually made any improvement. I tried with a custom code and gave it a case which should cause erroneous results with the standard summation method but work well with the modified algorithm. But both the versions seem to be performing identically. I used a debugger to see if the `SumReducer` functor was being used but surprisingly, it was never used when computing the sum.\r\n\r\nHere is the sample code\r\n```cpp\r\n#include <iostream>\r\n#include <Eigen/Dense>\r\n#include <iomanip>\r\n\r\nusing namespace std;\r\nint main()\r\n{\r\n  Eigen::Matrix2f mat;\r\n  mat << 1000000000.0, 2.00002,\r\n         1.00003, -1000000000.0;\r\n  cout << \"Here is mat.sum():       \" << std::setprecision(10) << mat.sum()       << endl;\r\n}\r\n```\r\n\r\nAny hints will be helpful. The eigen mailing list doesn't seem to be very active."}