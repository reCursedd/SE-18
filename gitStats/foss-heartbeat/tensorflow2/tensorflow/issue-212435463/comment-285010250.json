{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/285010250", "html_url": "https://github.com/tensorflow/tensorflow/issues/8168#issuecomment-285010250", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8168", "id": 285010250, "node_id": "MDEyOklzc3VlQ29tbWVudDI4NTAxMDI1MA==", "user": {"login": "MicaelCarvalho", "id": 17184992, "node_id": "MDQ6VXNlcjE3MTg0OTky", "avatar_url": "https://avatars3.githubusercontent.com/u/17184992?v=4", "gravatar_id": "", "url": "https://api.github.com/users/MicaelCarvalho", "html_url": "https://github.com/MicaelCarvalho", "followers_url": "https://api.github.com/users/MicaelCarvalho/followers", "following_url": "https://api.github.com/users/MicaelCarvalho/following{/other_user}", "gists_url": "https://api.github.com/users/MicaelCarvalho/gists{/gist_id}", "starred_url": "https://api.github.com/users/MicaelCarvalho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/MicaelCarvalho/subscriptions", "organizations_url": "https://api.github.com/users/MicaelCarvalho/orgs", "repos_url": "https://api.github.com/users/MicaelCarvalho/repos", "events_url": "https://api.github.com/users/MicaelCarvalho/events{/privacy}", "received_events_url": "https://api.github.com/users/MicaelCarvalho/received_events", "type": "User", "site_admin": false}, "created_at": "2017-03-08T10:53:33Z", "updated_at": "2017-03-08T10:53:33Z", "author_association": "CONTRIBUTOR", "body_html": "<p>I didn't know <code>tf.train.maybe_batch</code> neither, but I don't think it can solve the problem. A quick read on its doc shows:</p>\n<blockquote>\n<p>keep_input: A bool Tensor. This tensor controls whether the input is added to the queue or not. If it is a scalar and evaluates True, then tensors are all added to the queue. If it is a vector and enqueue_many is True, then each example is added to the queue only if the corresponding value in keep_input is True. This tensor essentially acts as a filtering mechanism.</p>\n</blockquote>\n<p>It seems the <code>keep_input</code> parameter can only control <code>enqueue</code>, whereas I'm trying to control <code>dequeue</code> (i.e. do not <code>dequeue</code> from validation if we're training, and do not <code>dequeue</code> from train if we're validating).</p>\n<p>In my understanding, part of the philosophy behind TensorFlow is to have a well built graph, without having to manually control these things \u2014 like calling dequeue from two different places based on a \"python condition\", but rather embed it all into the graph and let TF optimize its way through it. In this perspective, not being able to implement a source selector in the graph sounds like a major fault.</p>\n<p>Since I don't see a possible solution for this, I'm going to switch to the manual conditioning. Thank you very much for the help <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=23068\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/yaroslavvb\">@yaroslavvb</a>, I learned a lot here. :-)</p>\n<p>PS: Leaving the issue open for a member's response and/or as a feature suggestion.</p>", "body_text": "I didn't know tf.train.maybe_batch neither, but I don't think it can solve the problem. A quick read on its doc shows:\n\nkeep_input: A bool Tensor. This tensor controls whether the input is added to the queue or not. If it is a scalar and evaluates True, then tensors are all added to the queue. If it is a vector and enqueue_many is True, then each example is added to the queue only if the corresponding value in keep_input is True. This tensor essentially acts as a filtering mechanism.\n\nIt seems the keep_input parameter can only control enqueue, whereas I'm trying to control dequeue (i.e. do not dequeue from validation if we're training, and do not dequeue from train if we're validating).\nIn my understanding, part of the philosophy behind TensorFlow is to have a well built graph, without having to manually control these things \u2014 like calling dequeue from two different places based on a \"python condition\", but rather embed it all into the graph and let TF optimize its way through it. In this perspective, not being able to implement a source selector in the graph sounds like a major fault.\nSince I don't see a possible solution for this, I'm going to switch to the manual conditioning. Thank you very much for the help @yaroslavvb, I learned a lot here. :-)\nPS: Leaving the issue open for a member's response and/or as a feature suggestion.", "body": "I didn't know `tf.train.maybe_batch` neither, but I don't think it can solve the problem. A quick read on its doc shows:\r\n\r\n> keep_input: A bool Tensor. This tensor controls whether the input is added to the queue or not. If it is a scalar and evaluates True, then tensors are all added to the queue. If it is a vector and enqueue_many is True, then each example is added to the queue only if the corresponding value in keep_input is True. This tensor essentially acts as a filtering mechanism.\r\n\r\nIt seems the `keep_input` parameter can only control `enqueue`, whereas I'm trying to control `dequeue` (i.e. do not `dequeue` from validation if we're training, and do not `dequeue` from train if we're validating).\r\n\r\nIn my understanding, part of the philosophy behind TensorFlow is to have a well built graph, without having to manually control these things \u2014 like calling dequeue from two different places based on a \"python condition\", but rather embed it all into the graph and let TF optimize its way through it. In this perspective, not being able to implement a source selector in the graph sounds like a major fault.\r\n\r\nSince I don't see a possible solution for this, I'm going to switch to the manual conditioning. Thank you very much for the help @yaroslavvb, I learned a lot here. :-)\r\n\r\nPS: Leaving the issue open for a member's response and/or as a feature suggestion."}