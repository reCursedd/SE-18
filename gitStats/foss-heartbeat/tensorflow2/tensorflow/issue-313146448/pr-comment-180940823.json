{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/180940823", "pull_request_review_id": 111452123, "id": 180940823, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4MDk0MDgyMw==", "diff_hunk": "@@ -646,6 +646,207 @@ def compute(i, a_flat, tas):\n     return output_pack(results_flat)\n \n \n+def scanr(fn, elems, initializer=None, parallel_iterations=10, back_prop=True,\n+          swap_memory=False, infer_shape=True, name=None):\n+  \"\"\"scanr on the list of tensors unpacked from `elems` on dimension 0.\n+\n+  The simplest version of `scanr` repeatedly applies the callable `fn` to a\n+  sequence of elements from last to first. The elements are made of the tensors\n+  unpacked from `elems` on dimension 0. The callable fn takes two tensors as\n+  arguments. The first argument is the accumulated value computed from the\n+  preceding invocation of fn. If `initializer` is None, `elems` must contain\n+  at least one element, and its last element is used as the initializer.\n+\n+  Suppose that `elems` is unpacked into `values`, a list of tensors. The shape\n+  of the result tensor is `[len(values)] + fn(initializer, values[0]).shape`.\n+\n+  This method also allows multi-arity `elems` and accumulator.  If `elems`\n+  is a (possibly nested) list or tuple of tensors, then each of these tensors\n+  must have a matching first (unpack) dimension.  The second argument of\n+  `fn` must match the structure of `elems`.\n+\n+  If no `initializer` is provided, the output structure and dtypes of `fn`\n+  are assumed to be the same as its input; and in this case, the first\n+  argument of `fn` must match the structure of `elems`.\n+\n+  If an `initializer` is provided, then the output of `fn` must have the same\n+  structure as `initializer`; and the first argument of `fn` must match\n+  this structure.\n+\n+  For example, if `elems` is `(t1, [t2, t3])` and `initializer` is\n+  `[i1, i2]` then an appropriate signature for `fn` in `python2` is:\n+  `fn = lambda (acc_p1, acc_p2), (t1, [t2, t3]):` and `fn` must return a list,\n+  `[acc_n1, acc_n2]`.  An alternative correct signature for `fn`, and the\n+   one that works in `python3`, is:\n+  `fn = lambda a, t:`, where `a` and `t` correspond to the input tuples.\n+\n+  Args:\n+    fn: The callable to be performed.  It accepts two arguments.  The first\n+      will have the same structure as `initializer` if one is provided,\n+      otherwise it will have the same structure as `elems`.  The second\n+      will have the same (possibly nested) structure as `elems`.  Its output\n+      must have the same structure as `initializer` if one is provided,\n+      otherwise it must have the same structure as `elems`.\n+    elems: A tensor or (possibly nested) sequence of tensors, each of which\n+      will be unpacked along their first dimension.  The nested sequence\n+      of the resulting slices will be the first argument to `fn`.\n+    initializer: (optional) A tensor or (possibly nested) sequence of tensors,\n+      initial value for the accumulator, and the expected output type of `fn`.\n+    parallel_iterations: (optional) The number of iterations allowed to run\n+      in parallel.\n+    back_prop: (optional) True enables support for back propagation.\n+    swap_memory: (optional) True enables GPU-CPU memory swapping.\n+    infer_shape: (optional) False disables tests for consistent output shapes.\n+    name: (optional) Name prefix for the returned tensors.\n+\n+  Returns:\n+    A tensor or (possibly nested) sequence of tensors.  Each tensor packs the\n+    results of applying `fn` to tensors unpacked from `elems` along the first\n+    dimension, and the previous accumulator value(s), from first to last.\n+\n+  Raises:\n+    TypeError: if `fn` is not callable or the structure of the output of\n+      `fn` and `initializer` do not match.\n+    ValueError: if the lengths of the output of `fn` and `initializer`\n+      do not match.\n+\n+  Examples:\n+    ```python\n+    elems = np.array([1, 2, 3, 4, 5, 6])\n+    sum = scanr(lambda a, x: a + x, elems)\n+    # sum == [720, 720, 360, 120, 30, 6]\n+    ```\n+\n+    ```python\n+    elems = np.array([1, 2, 3, 4, 5, 6])\n+    initializer = np.array(0)\n+    sum_one = scan(\n+        lambda a, x: x[0] - x[1] + a, (elems + 1, elems), initializer)\n+    # sum_one == [6, 5, 4, 3, 2, 1]", "path": "tensorflow/python/ops/functional_ops.py", "position": null, "original_position": 80, "commit_id": "e8e77146498655dd29619ff1fbb61b8c666cde04", "original_commit_id": "baeab5f36650b8fb8a881faae8114aa5de50aa5e", "user": {"login": "drpngx", "id": 20959853, "node_id": "MDQ6VXNlcjIwOTU5ODUz", "avatar_url": "https://avatars1.githubusercontent.com/u/20959853?v=4", "gravatar_id": "", "url": "https://api.github.com/users/drpngx", "html_url": "https://github.com/drpngx", "followers_url": "https://api.github.com/users/drpngx/followers", "following_url": "https://api.github.com/users/drpngx/following{/other_user}", "gists_url": "https://api.github.com/users/drpngx/gists{/gist_id}", "starred_url": "https://api.github.com/users/drpngx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/drpngx/subscriptions", "organizations_url": "https://api.github.com/users/drpngx/orgs", "repos_url": "https://api.github.com/users/drpngx/repos", "events_url": "https://api.github.com/users/drpngx/events{/privacy}", "received_events_url": "https://api.github.com/users/drpngx/received_events", "type": "User", "site_admin": false}, "body": "scanr?\r\n\r\nAlso, here and above: use tf.scanr", "created_at": "2018-04-12T01:10:01Z", "updated_at": "2018-05-14T19:17:54Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/18410#discussion_r180940823", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/18410", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/180940823"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/18410#discussion_r180940823"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/18410"}}, "body_html": "<p>scanr?</p>\n<p>Also, here and above: use tf.scanr</p>", "body_text": "scanr?\nAlso, here and above: use tf.scanr"}