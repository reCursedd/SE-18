{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9670", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9670/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9670/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9670/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/9670", "id": 226367964, "node_id": "MDU6SXNzdWUyMjYzNjc5NjQ=", "number": 9670, "title": "InvalidArgumentError even finished feeding the values, maybe hidden bug of variable dependency", "user": {"login": "rylanchiu", "id": 10586781, "node_id": "MDQ6VXNlcjEwNTg2Nzgx", "avatar_url": "https://avatars3.githubusercontent.com/u/10586781?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rylanchiu", "html_url": "https://github.com/rylanchiu", "followers_url": "https://api.github.com/users/rylanchiu/followers", "following_url": "https://api.github.com/users/rylanchiu/following{/other_user}", "gists_url": "https://api.github.com/users/rylanchiu/gists{/gist_id}", "starred_url": "https://api.github.com/users/rylanchiu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rylanchiu/subscriptions", "organizations_url": "https://api.github.com/users/rylanchiu/orgs", "repos_url": "https://api.github.com/users/rylanchiu/repos", "events_url": "https://api.github.com/users/rylanchiu/events{/privacy}", "received_events_url": "https://api.github.com/users/rylanchiu/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2017-05-04T18:24:48Z", "updated_at": "2017-05-05T20:57:30Z", "closed_at": "2017-05-05T20:57:30Z", "author_association": "NONE", "body_html": "<p>I have defined two classes of models, <code>x</code> and <code>y</code>.</p>\n<pre><code>class x():\n    def __init__(self, x_inp1, x_inp2):\n        # do sth...\n\n    def step(self, session, encoder_inputs):\n        input_feed = {}\n        for l in range(encoder_size):\n             input_feed[self.encoder_inputs[l].name] = encoder_inputs[l]\n        ...\n        output_feed = [x_output]\n        return session.run(x_output)\n\nclass y():\n    def __init__(self, y_inp1, y_inp2):\n        # do sth...\n\n    def step(self, encoder_inputs):\n        input_feed = {}\n        for l in range(encoder_size):\n             input_feed[self.encoder_inputs[l].name] = encoder_inputs[l]\n        ...\n</code></pre>\n<p>They have quite similar functions. And then I define another class to group them up.</p>\n<pre><code>class gp():\n    def __init__(self, x_inp1, x_inp2, y_inp1, y_inp2):\n        with tf.variable_scope('x'):\n              self.x_model = x(x_inp1, x_inp2)\n        with tf.variable_scope('y'):\n              self.y_model = y(y_inp1, y_inp2)\n    def step(self, session, encoder_inputs):\n        print('train x....')\n        x_output = self.x_model.step(session, encoder_inputs)\n        print('train y....')\n        y_output = self.y_model.step(session, x_output)\n        ...\n</code></pre>\n<p>Please notice that the <code>y_model</code> takes the output of <code>x_model</code> as input. And I run the <code>gp()</code> in the <code>main</code> function:</p>\n<pre><code>with tf.Session() as sess:\n     gp_m = gp(x_inp1, x_inp2, y_inp1, y_inp2)\n     gp_m.step(sess, x_inp1, x_inp2, y_inp1, y_inp2)\n</code></pre>\n<p>And after running  <code>x_output = self.x_model.step(encoder_inputs)</code> and begin to do <code>y_output = self.y_model.step(x_output)</code>, I got such an error:</p>\n<pre><code>InvalidArgumentError (see above for traceback): You must feed a value for placeholder tensor 'x/encoder0' with dtype int32\n [[Node: x/encoder0 = Placeholder[dtype=DT_INT32, shape=[], _device=\"/job:localhost/replica:0/task:0/cpu:0\"]()]]\n</code></pre>\n<p>Please notice this error points to the <code>x_model</code> even the step function of it has been finished, i.e., both <code>train x...</code> and <code>train y...</code> are shown. The <code>x_output</code> should be python list and numpy array, and it is not Tensorflow object anymore. So maybe there is any bug of the variable dependency? Or I have any wrong operation that cause such a kind of error?</p>\n<p>Here are the information maybe useful:</p>\n<h3>operation system:  mac os 10.10</h3>\n<h3>python: 3.5</h3>\n<h3>tensorflow: r1.0</h3>\n<h3>install: from binary</h3>\n<h3>install using pip</h3>", "body_text": "I have defined two classes of models, x and y.\nclass x():\n    def __init__(self, x_inp1, x_inp2):\n        # do sth...\n\n    def step(self, session, encoder_inputs):\n        input_feed = {}\n        for l in range(encoder_size):\n             input_feed[self.encoder_inputs[l].name] = encoder_inputs[l]\n        ...\n        output_feed = [x_output]\n        return session.run(x_output)\n\nclass y():\n    def __init__(self, y_inp1, y_inp2):\n        # do sth...\n\n    def step(self, encoder_inputs):\n        input_feed = {}\n        for l in range(encoder_size):\n             input_feed[self.encoder_inputs[l].name] = encoder_inputs[l]\n        ...\n\nThey have quite similar functions. And then I define another class to group them up.\nclass gp():\n    def __init__(self, x_inp1, x_inp2, y_inp1, y_inp2):\n        with tf.variable_scope('x'):\n              self.x_model = x(x_inp1, x_inp2)\n        with tf.variable_scope('y'):\n              self.y_model = y(y_inp1, y_inp2)\n    def step(self, session, encoder_inputs):\n        print('train x....')\n        x_output = self.x_model.step(session, encoder_inputs)\n        print('train y....')\n        y_output = self.y_model.step(session, x_output)\n        ...\n\nPlease notice that the y_model takes the output of x_model as input. And I run the gp() in the main function:\nwith tf.Session() as sess:\n     gp_m = gp(x_inp1, x_inp2, y_inp1, y_inp2)\n     gp_m.step(sess, x_inp1, x_inp2, y_inp1, y_inp2)\n\nAnd after running  x_output = self.x_model.step(encoder_inputs) and begin to do y_output = self.y_model.step(x_output), I got such an error:\nInvalidArgumentError (see above for traceback): You must feed a value for placeholder tensor 'x/encoder0' with dtype int32\n [[Node: x/encoder0 = Placeholder[dtype=DT_INT32, shape=[], _device=\"/job:localhost/replica:0/task:0/cpu:0\"]()]]\n\nPlease notice this error points to the x_model even the step function of it has been finished, i.e., both train x... and train y... are shown. The x_output should be python list and numpy array, and it is not Tensorflow object anymore. So maybe there is any bug of the variable dependency? Or I have any wrong operation that cause such a kind of error?\nHere are the information maybe useful:\noperation system:  mac os 10.10\npython: 3.5\ntensorflow: r1.0\ninstall: from binary\ninstall using pip", "body": "I have defined two classes of models, `x` and `y`. \r\n\r\n    class x():\r\n        def __init__(self, x_inp1, x_inp2):\r\n            # do sth...\r\n\r\n        def step(self, session, encoder_inputs):\r\n            input_feed = {}\r\n            for l in range(encoder_size):\r\n                 input_feed[self.encoder_inputs[l].name] = encoder_inputs[l]\r\n            ...\r\n            output_feed = [x_output]\r\n            return session.run(x_output)\r\n\r\n    class y():\r\n        def __init__(self, y_inp1, y_inp2):\r\n            # do sth...\r\n\r\n        def step(self, encoder_inputs):\r\n            input_feed = {}\r\n            for l in range(encoder_size):\r\n                 input_feed[self.encoder_inputs[l].name] = encoder_inputs[l]\r\n            ...\r\n\r\nThey have quite similar functions. And then I define another class to group them up.\r\n\r\n    class gp():\r\n        def __init__(self, x_inp1, x_inp2, y_inp1, y_inp2):\r\n            with tf.variable_scope('x'):\r\n                  self.x_model = x(x_inp1, x_inp2)\r\n            with tf.variable_scope('y'):\r\n                  self.y_model = y(y_inp1, y_inp2)\r\n        def step(self, session, encoder_inputs):\r\n            print('train x....')\r\n            x_output = self.x_model.step(session, encoder_inputs)\r\n            print('train y....')\r\n            y_output = self.y_model.step(session, x_output)\r\n            ...\r\n\r\nPlease notice that the `y_model` takes the output of `x_model` as input. And I run the `gp()` in the `main` function:\r\n    \r\n    with tf.Session() as sess:\r\n         gp_m = gp(x_inp1, x_inp2, y_inp1, y_inp2)\r\n         gp_m.step(sess, x_inp1, x_inp2, y_inp1, y_inp2)\r\n\r\nAnd after running  `x_output = self.x_model.step(encoder_inputs)` and begin to do `y_output = self.y_model.step(x_output)`, I got such an error:\r\n    \r\n    InvalidArgumentError (see above for traceback): You must feed a value for placeholder tensor 'x/encoder0' with dtype int32\r\n\t [[Node: x/encoder0 = Placeholder[dtype=DT_INT32, shape=[], _device=\"/job:localhost/replica:0/task:0/cpu:0\"]()]]\r\n\r\nPlease notice this error points to the `x_model` even the step function of it has been finished, i.e., both `train x...` and `train y...` are shown. The `x_output` should be python list and numpy array, and it is not Tensorflow object anymore. So maybe there is any bug of the variable dependency? Or I have any wrong operation that cause such a kind of error? \r\n\r\nHere are the information maybe useful:\r\n\r\n### operation system:  mac os 10.10\r\n### python: 3.5\r\n### tensorflow: r1.0\r\n### install: from binary\r\n### install using pip"}