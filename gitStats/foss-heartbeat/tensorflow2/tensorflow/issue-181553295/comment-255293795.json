{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/255293795", "html_url": "https://github.com/tensorflow/tensorflow/issues/4807#issuecomment-255293795", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/4807", "id": 255293795, "node_id": "MDEyOklzc3VlQ29tbWVudDI1NTI5Mzc5NQ==", "user": {"login": "mkolod", "id": 476135, "node_id": "MDQ6VXNlcjQ3NjEzNQ==", "avatar_url": "https://avatars1.githubusercontent.com/u/476135?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mkolod", "html_url": "https://github.com/mkolod", "followers_url": "https://api.github.com/users/mkolod/followers", "following_url": "https://api.github.com/users/mkolod/following{/other_user}", "gists_url": "https://api.github.com/users/mkolod/gists{/gist_id}", "starred_url": "https://api.github.com/users/mkolod/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mkolod/subscriptions", "organizations_url": "https://api.github.com/users/mkolod/orgs", "repos_url": "https://api.github.com/users/mkolod/repos", "events_url": "https://api.github.com/users/mkolod/events{/privacy}", "received_events_url": "https://api.github.com/users/mkolod/received_events", "type": "User", "site_admin": false}, "created_at": "2016-10-21T04:59:23Z", "updated_at": "2016-10-21T05:00:07Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=170179\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/jhseu\">@jhseu</a> I actually managed to add it in my own experiments, but it seems to be failing at runtime, even though compilation succeeds (more on this in a moment). I suppose the big question about how to distribute such a change to the community is how to deal with the fact that the libjpeg-turbo code is largely assembly (SSE2, NEON, AltiVec, etc.). When building from source, it may be tricky doing it from Bazel without say genrules. Also, the current assembly mnemonics specifically call for nasm, though maybe there's an easier way. In my experiments, I have a genrule that calls turbo's own build, which is based on autotools (autoconf/configure/make, with make calling nasm), but that's a Rube Goldberg solution at best. Another option is of course to pull a pre-built static lib (libjpeg.a) from some CDN, removing the dependence on dealing with building assembly code, and just having a cc_library that provides headers and uses a pre-built lib. I'm not sure which approach would be preferable to the community.</p>", "body_text": "@jhseu I actually managed to add it in my own experiments, but it seems to be failing at runtime, even though compilation succeeds (more on this in a moment). I suppose the big question about how to distribute such a change to the community is how to deal with the fact that the libjpeg-turbo code is largely assembly (SSE2, NEON, AltiVec, etc.). When building from source, it may be tricky doing it from Bazel without say genrules. Also, the current assembly mnemonics specifically call for nasm, though maybe there's an easier way. In my experiments, I have a genrule that calls turbo's own build, which is based on autotools (autoconf/configure/make, with make calling nasm), but that's a Rube Goldberg solution at best. Another option is of course to pull a pre-built static lib (libjpeg.a) from some CDN, removing the dependence on dealing with building assembly code, and just having a cc_library that provides headers and uses a pre-built lib. I'm not sure which approach would be preferable to the community.", "body": "@jhseu I actually managed to add it in my own experiments, but it seems to be failing at runtime, even though compilation succeeds (more on this in a moment). I suppose the big question about how to distribute such a change to the community is how to deal with the fact that the libjpeg-turbo code is largely assembly (SSE2, NEON, AltiVec, etc.). When building from source, it may be tricky doing it from Bazel without say genrules. Also, the current assembly mnemonics specifically call for nasm, though maybe there's an easier way. In my experiments, I have a genrule that calls turbo's own build, which is based on autotools (autoconf/configure/make, with make calling nasm), but that's a Rube Goldberg solution at best. Another option is of course to pull a pre-built static lib (libjpeg.a) from some CDN, removing the dependence on dealing with building assembly code, and just having a cc_library that provides headers and uses a pre-built lib. I'm not sure which approach would be preferable to the community.\n"}