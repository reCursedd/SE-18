{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11745", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11745/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11745/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11745/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/11745", "id": 245359694, "node_id": "MDU6SXNzdWUyNDUzNTk2OTQ=", "number": 11745, "title": "Using AOT compilation on network with bidirectionnal layer fails because of missing Exit on Switch node", "user": {"login": "lissyx", "id": 1645737, "node_id": "MDQ6VXNlcjE2NDU3Mzc=", "avatar_url": "https://avatars0.githubusercontent.com/u/1645737?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lissyx", "html_url": "https://github.com/lissyx", "followers_url": "https://api.github.com/users/lissyx/followers", "following_url": "https://api.github.com/users/lissyx/following{/other_user}", "gists_url": "https://api.github.com/users/lissyx/gists{/gist_id}", "starred_url": "https://api.github.com/users/lissyx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lissyx/subscriptions", "organizations_url": "https://api.github.com/users/lissyx/orgs", "repos_url": "https://api.github.com/users/lissyx/repos", "events_url": "https://api.github.com/users/lissyx/events{/privacy}", "received_events_url": "https://api.github.com/users/lissyx/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2017-07-25T10:41:18Z", "updated_at": "2017-08-14T17:45:16Z", "closed_at": "2017-07-25T10:47:40Z", "author_association": "CONTRIBUTOR", "body_html": "<p>I have been reproducing that for a while, ranging from 1.0.1 builds to current master. Running <code>tfcompile</code> fails like this:</p>\n<pre><code>tensorflow/bazel-bin/tensorflow/compiler/aot/tfcompile --graph=test.pb  --config=native_client/tfcompile.config.pbtxt\n2017-07-13 13:29:55.989141: I tensorflow/compiler/xla/service/platform_util.cc:58] platform Host present with 4 visible devices\nINVALID ARGUMENTS: Missing Exit successor to bidirectional_rnn/fw/fw/while/Switch\n</code></pre>\n<p>I have been able to find that this was 100% repro when we have the bidirectionnal layer in the network:</p>\n<pre><code>tf.nn.bidirectional_dynamic_rnn(...)\n</code></pre>\n<p>As long as there are no more bidirectionnal layers, then it is fine. I searched and I have not been able to find any documentation (but maybe I missed it?) that would state properly the status of the <code>Exit</code> node wrt <code>Switch</code> node. Further investigation would show that some of the <code>Switch</code> nodes in the network would be followed by one <code>Exit</code> but that this one was being followed by <code>Identity</code>.</p>\n<p>I assumed that the checks performed by <code>tfcompile</code> were too tight, and took a chance:</p>\n<pre><code>diff --git a/tensorflow/compiler/tf2xla/functionalize_control_flow.cc b/tensorflow/compiler/tf2xla/functionalize_control_flow.cc\nindex faa88ecfe..fda3cbd00 100644\n--- a/tensorflow/compiler/tf2xla/functionalize_control_flow.cc\n+++ b/tensorflow/compiler/tf2xla/functionalize_control_flow.cc\n@@ -383,8 +383,8 @@ Status FunctionalizeLoop(Graph* graph, Frame* frame,\n         }\n       }\n       if (arg.exit == nullptr) {\n-        return errors::InvalidArgument(\"Missing Exit successor to \",\n-                                       arg.switch_node-&gt;name());\n+        // return errors::InvalidArgument(\"Missing Exit successor to \",\n+        //                                arg.switch_node-&gt;name());\n       }\n     }\n   }\n@@ -454,7 +454,7 @@ Status FunctionalizeLoop(Graph* graph, Frame* frame,\n       graph-&gt;AddEdge(in_edge-&gt;src(), in_edge-&gt;src_output(), while_node, i);\n     }\n \n-    if (!arg.is_loop_invariant) {\n+    if (arg.exit != nullptr &amp;&amp; !arg.is_loop_invariant) {\n       std::vector&lt;const Edge*&gt; edges(arg.exit-&gt;out_edges().begin(),\n                                      arg.exit-&gt;out_edges().end());\n       for (const Edge* edge : edges) {\n</code></pre>\n<p>This indeed worked and I have been able to build (even cross-build for ARM/RPi3) a RNN-based network (using <code>BasicRNN</code> cells or <code>BasicLSTM</code> cells).</p>\n<p>So I guess that the questions is really: am I just lucky that it works because one <code>Switch</code> MUST really have an <code>Exit</code> node (and thus, is there something wrong in the current model), or is it just being picky ?</p>", "body_text": "I have been reproducing that for a while, ranging from 1.0.1 builds to current master. Running tfcompile fails like this:\ntensorflow/bazel-bin/tensorflow/compiler/aot/tfcompile --graph=test.pb  --config=native_client/tfcompile.config.pbtxt\n2017-07-13 13:29:55.989141: I tensorflow/compiler/xla/service/platform_util.cc:58] platform Host present with 4 visible devices\nINVALID ARGUMENTS: Missing Exit successor to bidirectional_rnn/fw/fw/while/Switch\n\nI have been able to find that this was 100% repro when we have the bidirectionnal layer in the network:\ntf.nn.bidirectional_dynamic_rnn(...)\n\nAs long as there are no more bidirectionnal layers, then it is fine. I searched and I have not been able to find any documentation (but maybe I missed it?) that would state properly the status of the Exit node wrt Switch node. Further investigation would show that some of the Switch nodes in the network would be followed by one Exit but that this one was being followed by Identity.\nI assumed that the checks performed by tfcompile were too tight, and took a chance:\ndiff --git a/tensorflow/compiler/tf2xla/functionalize_control_flow.cc b/tensorflow/compiler/tf2xla/functionalize_control_flow.cc\nindex faa88ecfe..fda3cbd00 100644\n--- a/tensorflow/compiler/tf2xla/functionalize_control_flow.cc\n+++ b/tensorflow/compiler/tf2xla/functionalize_control_flow.cc\n@@ -383,8 +383,8 @@ Status FunctionalizeLoop(Graph* graph, Frame* frame,\n         }\n       }\n       if (arg.exit == nullptr) {\n-        return errors::InvalidArgument(\"Missing Exit successor to \",\n-                                       arg.switch_node->name());\n+        // return errors::InvalidArgument(\"Missing Exit successor to \",\n+        //                                arg.switch_node->name());\n       }\n     }\n   }\n@@ -454,7 +454,7 @@ Status FunctionalizeLoop(Graph* graph, Frame* frame,\n       graph->AddEdge(in_edge->src(), in_edge->src_output(), while_node, i);\n     }\n \n-    if (!arg.is_loop_invariant) {\n+    if (arg.exit != nullptr && !arg.is_loop_invariant) {\n       std::vector<const Edge*> edges(arg.exit->out_edges().begin(),\n                                      arg.exit->out_edges().end());\n       for (const Edge* edge : edges) {\n\nThis indeed worked and I have been able to build (even cross-build for ARM/RPi3) a RNN-based network (using BasicRNN cells or BasicLSTM cells).\nSo I guess that the questions is really: am I just lucky that it works because one Switch MUST really have an Exit node (and thus, is there something wrong in the current model), or is it just being picky ?", "body": "I have been reproducing that for a while, ranging from 1.0.1 builds to current master. Running `tfcompile` fails like this:\r\n\r\n```\r\ntensorflow/bazel-bin/tensorflow/compiler/aot/tfcompile --graph=test.pb  --config=native_client/tfcompile.config.pbtxt\r\n2017-07-13 13:29:55.989141: I tensorflow/compiler/xla/service/platform_util.cc:58] platform Host present with 4 visible devices\r\nINVALID ARGUMENTS: Missing Exit successor to bidirectional_rnn/fw/fw/while/Switch\r\n```\r\n\r\nI have been able to find that this was 100% repro when we have the bidirectionnal layer in the network:\r\n```\r\ntf.nn.bidirectional_dynamic_rnn(...)\r\n```\r\n\r\nAs long as there are no more bidirectionnal layers, then it is fine. I searched and I have not been able to find any documentation (but maybe I missed it?) that would state properly the status of the `Exit` node wrt `Switch` node. Further investigation would show that some of the `Switch` nodes in the network would be followed by one `Exit` but that this one was being followed by `Identity`.\r\n\r\nI assumed that the checks performed by `tfcompile` were too tight, and took a chance:\r\n```\r\ndiff --git a/tensorflow/compiler/tf2xla/functionalize_control_flow.cc b/tensorflow/compiler/tf2xla/functionalize_control_flow.cc\r\nindex faa88ecfe..fda3cbd00 100644\r\n--- a/tensorflow/compiler/tf2xla/functionalize_control_flow.cc\r\n+++ b/tensorflow/compiler/tf2xla/functionalize_control_flow.cc\r\n@@ -383,8 +383,8 @@ Status FunctionalizeLoop(Graph* graph, Frame* frame,\r\n         }\r\n       }\r\n       if (arg.exit == nullptr) {\r\n-        return errors::InvalidArgument(\"Missing Exit successor to \",\r\n-                                       arg.switch_node->name());\r\n+        // return errors::InvalidArgument(\"Missing Exit successor to \",\r\n+        //                                arg.switch_node->name());\r\n       }\r\n     }\r\n   }\r\n@@ -454,7 +454,7 @@ Status FunctionalizeLoop(Graph* graph, Frame* frame,\r\n       graph->AddEdge(in_edge->src(), in_edge->src_output(), while_node, i);\r\n     }\r\n \r\n-    if (!arg.is_loop_invariant) {\r\n+    if (arg.exit != nullptr && !arg.is_loop_invariant) {\r\n       std::vector<const Edge*> edges(arg.exit->out_edges().begin(),\r\n                                      arg.exit->out_edges().end());\r\n       for (const Edge* edge : edges) {\r\n```\r\n\r\nThis indeed worked and I have been able to build (even cross-build for ARM/RPi3) a RNN-based network (using `BasicRNN` cells or `BasicLSTM` cells).\r\n\r\nSo I guess that the questions is really: am I just lucky that it works because one `Switch` MUST really have an `Exit` node (and thus, is there something wrong in the current model), or is it just being picky ?"}