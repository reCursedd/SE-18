{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9139", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9139/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9139/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9139/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/9139", "id": 220983676, "node_id": "MDU6SXNzdWUyMjA5ODM2NzY=", "number": 9139, "title": "Incorrect results when graph is split across several GPUs.", "user": {"login": "mjlm", "id": 5418069, "node_id": "MDQ6VXNlcjU0MTgwNjk=", "avatar_url": "https://avatars1.githubusercontent.com/u/5418069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mjlm", "html_url": "https://github.com/mjlm", "followers_url": "https://api.github.com/users/mjlm/followers", "following_url": "https://api.github.com/users/mjlm/following{/other_user}", "gists_url": "https://api.github.com/users/mjlm/gists{/gist_id}", "starred_url": "https://api.github.com/users/mjlm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mjlm/subscriptions", "organizations_url": "https://api.github.com/users/mjlm/orgs", "repos_url": "https://api.github.com/users/mjlm/repos", "events_url": "https://api.github.com/users/mjlm/events{/privacy}", "received_events_url": "https://api.github.com/users/mjlm/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2017-04-11T15:07:21Z", "updated_at": "2017-04-12T01:11:57Z", "closed_at": "2017-04-12T01:11:57Z", "author_association": "NONE", "body_html": "<p>Background info:</p>\n<ul>\n<li>Custom code</li>\n<li>Tensorflow r1.0 installed from binaries on Windows</li>\n<li>CUDA 8.0, cuDNN 5.1.5</li>\n<li>2 GPUs: GTX Titan X and Titan X Pascal</li>\n</ul>\n<p>Problem:</p>\n<p>I have a model that is small enough to be trained on a single GPU with 12GB memory. Training works fine and converges.</p>\n<p>However, when I evaluate the model with a validation set that is too large to fit on one of my GPUs, TensorFlow seems to use both of my GPUs (one GTX Titan X and one Titan X Pascal). When this happens, <strong>a large fraction of the results returned by TensorFlow are incorrect</strong>. The returned values are not completely missing, i.e. not all zero or something like that, but so inaccurate that the validation performance is terrible.</p>\n<p>More specifically, my model consists of a shared initial stage, followed by a list of ~50 sub-networks that all receive input from the shared stage, but are otherwise independent. Data is split using <code>tf.dynamic_partition()</code>. From the results that I get, it appears that TensorFlow moves some of the 50 sub-networks to the second GPU if the memory on the first one isn't sufficient. The moved sub-models then return incorrect results (the others are unchanged).</p>\n<p>If I instead force evaluation to be performed on the CPU, all results are as expected. All I need to do is add <code>with tf.device('/cpu:0')</code> to the very top of my script. The results also look good if I reduce the size of the validation set so that it fits onto one GPU.</p>\n<p>I am sorry for not providing a working example. I will try to create one, but it might take a while since, by nature of the problem, it needs to be a fairly large/complex model.</p>", "body_text": "Background info:\n\nCustom code\nTensorflow r1.0 installed from binaries on Windows\nCUDA 8.0, cuDNN 5.1.5\n2 GPUs: GTX Titan X and Titan X Pascal\n\nProblem:\nI have a model that is small enough to be trained on a single GPU with 12GB memory. Training works fine and converges.\nHowever, when I evaluate the model with a validation set that is too large to fit on one of my GPUs, TensorFlow seems to use both of my GPUs (one GTX Titan X and one Titan X Pascal). When this happens, a large fraction of the results returned by TensorFlow are incorrect. The returned values are not completely missing, i.e. not all zero or something like that, but so inaccurate that the validation performance is terrible.\nMore specifically, my model consists of a shared initial stage, followed by a list of ~50 sub-networks that all receive input from the shared stage, but are otherwise independent. Data is split using tf.dynamic_partition(). From the results that I get, it appears that TensorFlow moves some of the 50 sub-networks to the second GPU if the memory on the first one isn't sufficient. The moved sub-models then return incorrect results (the others are unchanged).\nIf I instead force evaluation to be performed on the CPU, all results are as expected. All I need to do is add with tf.device('/cpu:0') to the very top of my script. The results also look good if I reduce the size of the validation set so that it fits onto one GPU.\nI am sorry for not providing a working example. I will try to create one, but it might take a while since, by nature of the problem, it needs to be a fairly large/complex model.", "body": "Background info:\r\n- Custom code\r\n- Tensorflow r1.0 installed from binaries on Windows\r\n- CUDA 8.0, cuDNN 5.1.5\r\n- 2 GPUs: GTX Titan X and Titan X Pascal\r\n\r\nProblem:\r\n\r\nI have a model that is small enough to be trained on a single GPU with 12GB memory. Training works fine and converges.\r\n\r\nHowever, when I evaluate the model with a validation set that is too large to fit on one of my GPUs, TensorFlow seems to use both of my GPUs (one GTX Titan X and one Titan X Pascal). When this happens, **a large fraction of the results returned by TensorFlow are incorrect**. The returned values are not completely missing, i.e. not all zero or something like that, but so inaccurate that the validation performance is terrible. \r\n\r\nMore specifically, my model consists of a shared initial stage, followed by a list of ~50 sub-networks that all receive input from the shared stage, but are otherwise independent. Data is split using `tf.dynamic_partition()`. From the results that I get, it appears that TensorFlow moves some of the 50 sub-networks to the second GPU if the memory on the first one isn't sufficient. The moved sub-models then return incorrect results (the others are unchanged).\r\n\r\nIf I instead force evaluation to be performed on the CPU, all results are as expected. All I need to do is add `with tf.device('/cpu:0')` to the very top of my script. The results also look good if I reduce the size of the validation set so that it fits onto one GPU.\r\n\r\nI am sorry for not providing a working example. I will try to create one, but it might take a while since, by nature of the problem, it needs to be a fairly large/complex model.\r\n\r\n\r\n"}