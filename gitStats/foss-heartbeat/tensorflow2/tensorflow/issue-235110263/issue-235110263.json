{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/10641", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/10641/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/10641/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/10641/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/10641", "id": 235110263, "node_id": "MDU6SXNzdWUyMzUxMTAyNjM=", "number": 10641, "title": "bug: BeamSearchDecoder should not assume that  when time > 0 beam will be full", "user": {"login": "JerrikEph", "id": 17830427, "node_id": "MDQ6VXNlcjE3ODMwNDI3", "avatar_url": "https://avatars1.githubusercontent.com/u/17830427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JerrikEph", "html_url": "https://github.com/JerrikEph", "followers_url": "https://api.github.com/users/JerrikEph/followers", "following_url": "https://api.github.com/users/JerrikEph/following{/other_user}", "gists_url": "https://api.github.com/users/JerrikEph/gists{/gist_id}", "starred_url": "https://api.github.com/users/JerrikEph/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JerrikEph/subscriptions", "organizations_url": "https://api.github.com/users/JerrikEph/orgs", "repos_url": "https://api.github.com/users/JerrikEph/repos", "events_url": "https://api.github.com/users/JerrikEph/events{/privacy}", "received_events_url": "https://api.github.com/users/JerrikEph/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 473172988, "node_id": "MDU6TGFiZWw0NzMxNzI5ODg=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:bug/performance", "name": "type:bug/performance", "color": "159b2e", "default": false}], "state": "closed", "locked": false, "assignee": {"login": "ebrevdo", "id": 1794715, "node_id": "MDQ6VXNlcjE3OTQ3MTU=", "avatar_url": "https://avatars0.githubusercontent.com/u/1794715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebrevdo", "html_url": "https://github.com/ebrevdo", "followers_url": "https://api.github.com/users/ebrevdo/followers", "following_url": "https://api.github.com/users/ebrevdo/following{/other_user}", "gists_url": "https://api.github.com/users/ebrevdo/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebrevdo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebrevdo/subscriptions", "organizations_url": "https://api.github.com/users/ebrevdo/orgs", "repos_url": "https://api.github.com/users/ebrevdo/repos", "events_url": "https://api.github.com/users/ebrevdo/events{/privacy}", "received_events_url": "https://api.github.com/users/ebrevdo/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "ebrevdo", "id": 1794715, "node_id": "MDQ6VXNlcjE3OTQ3MTU=", "avatar_url": "https://avatars0.githubusercontent.com/u/1794715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebrevdo", "html_url": "https://github.com/ebrevdo", "followers_url": "https://api.github.com/users/ebrevdo/followers", "following_url": "https://api.github.com/users/ebrevdo/following{/other_user}", "gists_url": "https://api.github.com/users/ebrevdo/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebrevdo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebrevdo/subscriptions", "organizations_url": "https://api.github.com/users/ebrevdo/orgs", "repos_url": "https://api.github.com/users/ebrevdo/repos", "events_url": "https://api.github.com/users/ebrevdo/events{/privacy}", "received_events_url": "https://api.github.com/users/ebrevdo/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 7, "created_at": "2017-06-12T02:16:00Z", "updated_at": "2018-02-08T17:44:56Z", "closed_at": "2018-02-08T17:44:56Z", "author_association": "CONTRIBUTOR", "body_html": "<pre><code>  scores_flat = control_flow_ops.cond(\n      time &gt; 0,\n      lambda: array_ops.reshape(scores, [batch_size, -1]),\n      lambda: scores[:, 0])\n  num_available_beam = control_flow_ops.cond(\n      time &gt; 0,\n      lambda: math_ops.reduce_prod(scores_shape[1:]),\n      lambda: math_ops.reduce_prod(scores_shape[2:]))\n\n  # Pick the next beams according to the specified successors function\n  next_beam_size = math_ops.minimum(\n      ops.convert_to_tensor(\n          beam_width, dtype=dtypes.int32, name=\"beam_width\"),\n      num_available_beam)\n  next_beam_scores, word_indices = nn_ops.top_k(scores_flat, k=next_beam_size)\n  next_beam_scores.set_shape([static_batch_size, beam_width])\n  word_indices.set_shape([static_batch_size, beam_width])\n</code></pre>\n<p>code start from<br>\n<a href=\"https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/seq2seq/python/ops/beam_search_decoder.py#L510\">https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/seq2seq/python/ops/beam_search_decoder.py#L510</a></p>\n<p>Correct me if I am wrong, but I think this code is assuming that, when time &gt; 0 the beam will be full. It is true when the vocabulary is big such as is the case in machine translation. but if the vocabulary is small, the beam might won't be full when time &gt; 0 and might pose a problem.  the value of <code>next_beam_size </code> in the code seems must be <code>beam_width</code> or it will raise an error since <code>next_beam_scores.set_shape([static_batch_size, beam_width])</code>, which make <code> next_beam_size = math_ops.minimum</code> useless.</p>\n<p>I am trying to write a Pointer Network BeamSearch Decoder by modifying this source file. And the vocabulary is usually small, so there is a possibility that when time == 1 the beam won't be fully filled.</p>\n<p>I appreciate finally some one wrote a general BeamSeach decoder, that will make my life easier.</p>", "body_text": "scores_flat = control_flow_ops.cond(\n      time > 0,\n      lambda: array_ops.reshape(scores, [batch_size, -1]),\n      lambda: scores[:, 0])\n  num_available_beam = control_flow_ops.cond(\n      time > 0,\n      lambda: math_ops.reduce_prod(scores_shape[1:]),\n      lambda: math_ops.reduce_prod(scores_shape[2:]))\n\n  # Pick the next beams according to the specified successors function\n  next_beam_size = math_ops.minimum(\n      ops.convert_to_tensor(\n          beam_width, dtype=dtypes.int32, name=\"beam_width\"),\n      num_available_beam)\n  next_beam_scores, word_indices = nn_ops.top_k(scores_flat, k=next_beam_size)\n  next_beam_scores.set_shape([static_batch_size, beam_width])\n  word_indices.set_shape([static_batch_size, beam_width])\n\ncode start from\nhttps://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/seq2seq/python/ops/beam_search_decoder.py#L510\nCorrect me if I am wrong, but I think this code is assuming that, when time > 0 the beam will be full. It is true when the vocabulary is big such as is the case in machine translation. but if the vocabulary is small, the beam might won't be full when time > 0 and might pose a problem.  the value of next_beam_size  in the code seems must be beam_width or it will raise an error since next_beam_scores.set_shape([static_batch_size, beam_width]), which make  next_beam_size = math_ops.minimum useless.\nI am trying to write a Pointer Network BeamSearch Decoder by modifying this source file. And the vocabulary is usually small, so there is a possibility that when time == 1 the beam won't be fully filled.\nI appreciate finally some one wrote a general BeamSeach decoder, that will make my life easier.", "body": "```\r\n  scores_flat = control_flow_ops.cond(\r\n      time > 0,\r\n      lambda: array_ops.reshape(scores, [batch_size, -1]),\r\n      lambda: scores[:, 0])\r\n  num_available_beam = control_flow_ops.cond(\r\n      time > 0,\r\n      lambda: math_ops.reduce_prod(scores_shape[1:]),\r\n      lambda: math_ops.reduce_prod(scores_shape[2:]))\r\n\r\n  # Pick the next beams according to the specified successors function\r\n  next_beam_size = math_ops.minimum(\r\n      ops.convert_to_tensor(\r\n          beam_width, dtype=dtypes.int32, name=\"beam_width\"),\r\n      num_available_beam)\r\n  next_beam_scores, word_indices = nn_ops.top_k(scores_flat, k=next_beam_size)\r\n  next_beam_scores.set_shape([static_batch_size, beam_width])\r\n  word_indices.set_shape([static_batch_size, beam_width])\r\n``` \r\ncode start from\r\nhttps://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/seq2seq/python/ops/beam_search_decoder.py#L510\r\n\r\nCorrect me if I am wrong, but I think this code is assuming that, when time > 0 the beam will be full. It is true when the vocabulary is big such as is the case in machine translation. but if the vocabulary is small, the beam might won't be full when time > 0 and might pose a problem.  the value of `next_beam_size ` in the code seems must be `beam_width` or it will raise an error since `next_beam_scores.set_shape([static_batch_size, beam_width])`, which make ` next_beam_size = math_ops.minimum` useless.\r\n\r\nI am trying to write a Pointer Network BeamSearch Decoder by modifying this source file. And the vocabulary is usually small, so there is a possibility that when time == 1 the beam won't be fully filled. \r\n\r\nI appreciate finally some one wrote a general BeamSeach decoder, that will make my life easier.\r\n\r\n"}