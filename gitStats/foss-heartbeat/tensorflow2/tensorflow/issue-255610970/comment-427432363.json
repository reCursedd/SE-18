{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/427432363", "html_url": "https://github.com/tensorflow/tensorflow/issues/12851#issuecomment-427432363", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/12851", "id": 427432363, "node_id": "MDEyOklzc3VlQ29tbWVudDQyNzQzMjM2Mw==", "user": {"login": "jhultman", "id": 27909223, "node_id": "MDQ6VXNlcjI3OTA5MjIz", "avatar_url": "https://avatars3.githubusercontent.com/u/27909223?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jhultman", "html_url": "https://github.com/jhultman", "followers_url": "https://api.github.com/users/jhultman/followers", "following_url": "https://api.github.com/users/jhultman/following{/other_user}", "gists_url": "https://api.github.com/users/jhultman/gists{/gist_id}", "starred_url": "https://api.github.com/users/jhultman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jhultman/subscriptions", "organizations_url": "https://api.github.com/users/jhultman/orgs", "repos_url": "https://api.github.com/users/jhultman/repos", "events_url": "https://api.github.com/users/jhultman/events{/privacy}", "received_events_url": "https://api.github.com/users/jhultman/received_events", "type": "User", "site_admin": false}, "created_at": "2018-10-05T16:59:19Z", "updated_at": "2018-10-05T17:30:32Z", "author_association": "NONE", "body_html": "<p>Manually unzipping doesn't seem to respect the order of the tuple elements when shuffling the zipped dataset. Take a look at my minimum working example below:</p>\n<pre><code>import tensorflow as tf\n\nds = tf.data.Dataset.range(100)\nds = tf.data.Dataset.zip((ds, ds))\nds = ds.shuffle(100)\n\nx0 = ds.map(lambda *x: x[0])\nx1 = ds.map(lambda *x: x[1])\n\nds = tf.data.Dataset.zip((x0, x1))\n\nit = ds.make_one_shot_iterator()\ntup = it.get_next()\n\nwith tf.Session() as sess:\n    t0, t1 = sess.run(tup)\n    print((t0, t1))\n    \n&gt;&gt; (8, 94)\n</code></pre>\n<p>I would have expected t0 == t1, since the shuffle was only performed on the zipped dataset.</p>\n<p>My use case is that I have input filenames and label filenames, and I want to zip them, shuffle, and unzip while maintaining the pairing between input and label. I want to unzip since I have a complicated input pipeline which processes inputs and labels separately. Anyone have a suggestion for how to do this sort of shuffle? Seems like it should be an extremely common use case.</p>\n<p>Edit1: I should probably just make a new issue, but I'm a bit astonished by the following simple example as well. Is this really the expected behavior? This seems a bit unintuitive.</p>\n<p>Edit2: Passing an explicit nonzero seed to the shuffle solves the problem. But that defeats the entire purpose of my shuffle, which is to randomize the order every epoch. I suppose using the epoch itself as the seed could work, but seems like a very annoying work-around for such a simple problem.</p>\n<pre><code>import tensorflow as tf\n\nds = tf.data.Dataset.range(100).shuffle(100)\nds = tf.data.Dataset.zip((ds, ds))\ntup = ds.make_one_shot_iterator().get_next()\n\nwith tf.Session() as sess:\n    print(sess.run(tup))\n\n&gt;&gt; (42, 28)\n</code></pre>", "body_text": "Manually unzipping doesn't seem to respect the order of the tuple elements when shuffling the zipped dataset. Take a look at my minimum working example below:\nimport tensorflow as tf\n\nds = tf.data.Dataset.range(100)\nds = tf.data.Dataset.zip((ds, ds))\nds = ds.shuffle(100)\n\nx0 = ds.map(lambda *x: x[0])\nx1 = ds.map(lambda *x: x[1])\n\nds = tf.data.Dataset.zip((x0, x1))\n\nit = ds.make_one_shot_iterator()\ntup = it.get_next()\n\nwith tf.Session() as sess:\n    t0, t1 = sess.run(tup)\n    print((t0, t1))\n    \n>> (8, 94)\n\nI would have expected t0 == t1, since the shuffle was only performed on the zipped dataset.\nMy use case is that I have input filenames and label filenames, and I want to zip them, shuffle, and unzip while maintaining the pairing between input and label. I want to unzip since I have a complicated input pipeline which processes inputs and labels separately. Anyone have a suggestion for how to do this sort of shuffle? Seems like it should be an extremely common use case.\nEdit1: I should probably just make a new issue, but I'm a bit astonished by the following simple example as well. Is this really the expected behavior? This seems a bit unintuitive.\nEdit2: Passing an explicit nonzero seed to the shuffle solves the problem. But that defeats the entire purpose of my shuffle, which is to randomize the order every epoch. I suppose using the epoch itself as the seed could work, but seems like a very annoying work-around for such a simple problem.\nimport tensorflow as tf\n\nds = tf.data.Dataset.range(100).shuffle(100)\nds = tf.data.Dataset.zip((ds, ds))\ntup = ds.make_one_shot_iterator().get_next()\n\nwith tf.Session() as sess:\n    print(sess.run(tup))\n\n>> (42, 28)", "body": "Manually unzipping doesn't seem to respect the order of the tuple elements when shuffling the zipped dataset. Take a look at my minimum working example below:\r\n\r\n```\r\nimport tensorflow as tf\r\n\r\nds = tf.data.Dataset.range(100)\r\nds = tf.data.Dataset.zip((ds, ds))\r\nds = ds.shuffle(100)\r\n\r\nx0 = ds.map(lambda *x: x[0])\r\nx1 = ds.map(lambda *x: x[1])\r\n\r\nds = tf.data.Dataset.zip((x0, x1))\r\n\r\nit = ds.make_one_shot_iterator()\r\ntup = it.get_next()\r\n\r\nwith tf.Session() as sess:\r\n    t0, t1 = sess.run(tup)\r\n    print((t0, t1))\r\n    \r\n>> (8, 94)\r\n```\r\n\r\nI would have expected t0 == t1, since the shuffle was only performed on the zipped dataset. \r\n\r\nMy use case is that I have input filenames and label filenames, and I want to zip them, shuffle, and unzip while maintaining the pairing between input and label. I want to unzip since I have a complicated input pipeline which processes inputs and labels separately. Anyone have a suggestion for how to do this sort of shuffle? Seems like it should be an extremely common use case.\r\n\r\nEdit1: I should probably just make a new issue, but I'm a bit astonished by the following simple example as well. Is this really the expected behavior? This seems a bit unintuitive.\r\n\r\nEdit2: Passing an explicit nonzero seed to the shuffle solves the problem. But that defeats the entire purpose of my shuffle, which is to randomize the order every epoch. I suppose using the epoch itself as the seed could work, but seems like a very annoying work-around for such a simple problem.\r\n\r\n```\r\nimport tensorflow as tf\r\n\r\nds = tf.data.Dataset.range(100).shuffle(100)\r\nds = tf.data.Dataset.zip((ds, ds))\r\ntup = ds.make_one_shot_iterator().get_next()\r\n\r\nwith tf.Session() as sess:\r\n    print(sess.run(tup))\r\n\r\n>> (42, 28)\r\n```"}