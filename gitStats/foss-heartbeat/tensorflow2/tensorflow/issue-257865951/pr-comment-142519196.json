{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/142519196", "pull_request_review_id": 66893436, "id": 142519196, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE0MjUxOTE5Ng==", "diff_hunk": "@@ -413,6 +429,275 @@ struct PadInput<GPUDevice, T, int, NDIMS> {\n   }\n };\n \n+// TPF stands for Tile size Posibility Frontier. It denotes the tile size\n+// combinations that consume the most computational resources constrained by\n+// number of threads per SM limit, shared memory limit and overall degree of\n+// parallelism.\n+// Tile size combinations lying on this frontier would achieve the maximum\n+// utilization of available resources and combinations lying outside this\n+// frontier is not performance-wise profitable or simply not possible.\n+#define TPF_CHECKER(OP)                                                   \\\n+  size_of_t == 16 &&    (TileLongSide == 32   && (TileShortSide OP 4)  || \\\n+                         TileLongSide == 64   && (TileShortSide OP 4)  || \\\n+                         TileLongSide == 128  && (TileShortSide OP 4)  || \\\n+                         TileLongSide == 256  && (TileShortSide OP 2)) || \\\n+      size_of_t == 8 && (TileLongSide == 32   && (TileShortSide OP 15) || \\\n+                         TileLongSide == 64   && (TileShortSide OP 15) || \\\n+                         TileLongSide == 128  && (TileShortSide OP 8)  || \\\n+                         TileLongSide == 256  && (TileShortSide OP 4)  || \\\n+                         TileLongSide == 512  && (TileShortSide OP 2)) || \\\n+      size_of_t == 4 && (TileLongSide == 32   && (TileShortSide OP 15) || \\\n+                         TileLongSide == 64   && (TileShortSide OP 15) || \\\n+                         TileLongSide == 128  && (TileShortSide OP 15) || \\\n+                         TileLongSide == 256  && (TileShortSide OP 10) || \\\n+                         TileLongSide == 512  && (TileShortSide OP 4)  || \\\n+                         TileLongSide == 1024 && (TileShortSide OP 2)) || \\\n+      size_of_t == 2 && (TileLongSide == 32   && (TileShortSide OP 15) || \\\n+                         TileLongSide == 64   && (TileShortSide OP 15) || \\\n+                         TileLongSide == 128  && (TileShortSide OP 15) || \\\n+                         TileLongSide == 256  && (TileShortSide OP 10) || \\\n+                         TileLongSide == 512  && (TileShortSide OP 4)  || \\\n+                         TileLongSide == 1024 && (TileShortSide OP 2)) || \\\n+      size_of_t == 1 && (TileLongSide == 32   && (TileShortSide OP 15) || \\\n+                         TileLongSide == 64   && (TileShortSide OP 15) || \\\n+                         TileLongSide == 128  && (TileShortSide OP 15) || \\\n+                         TileLongSide == 256  && (TileShortSide OP 10) || \\\n+                         TileLongSide == 512  && (TileShortSide OP 4)  || \\\n+                         TileLongSide == 1024 && (TileShortSide OP 2))\n+\n+constexpr bool TileSizePossibilityFrontierCheck(int TileLongSide,\n+                                                int TileShortSide,\n+                                                int size_of_t, int mode) {\n+  // When mode is 0, this function checks whether the tile size combination lies\n+  // on the tile size possibility frontier. When mode is 1, it checks whether\n+  // the combination lies outside the frontier.\n+  return mode == 0 ? TPF_CHECKER(==) : TPF_CHECKER(>);\n+}\n+\n+#undef TPF_CHECKER\n+\n+// Recursive template function to search for the minimum tile size configuration\n+// satisfying the requested tile side lengths.\n+template <typename T, int TileLongSide, int TileShortSide, typename dummy = void>\n+struct BatchNarrowMatrixTransposeDispatcher {\n+  static void DoIt(const GPUDevice& d, int tile_size_i,\n+                                           int tile_size_j,\n+                                           int total_tiles_count,\n+                                           const T* input,\n+                                           const Dimension<3>& input_dims,\n+                                           T* output) {\n+\n+    static_assert((TileLongSide & (TileLongSide - 1)) == 0,\n+      \"The length of the longer side of the tile is always a power of 2.\");\n+    bool request_satisfied = max(tile_size_i, tile_size_j) <= TileLongSide &&\n+                             min(tile_size_i, tile_size_j) <= TileShortSide;\n+\n+    if (request_satisfied) {\n+      const int NumThread = TileLongSide;\n+      if (tile_size_i <= TileLongSide && tile_size_j <= TileShortSide) {\n+        SwapDimension1And2InTensor3UsingTiles<\n+            T, NumThread, TileLongSide,\n+            TileShortSide><<<total_tiles_count, NumThread, 0, d.stream()>>>(\n+            input, input_dims, output);\n+      }\n+      else if (tile_size_j <= TileLongSide && tile_size_i <= TileShortSide) {\n+        SwapDimension1And2InTensor3UsingTiles<\n+            T, NumThread, TileShortSide,\n+            TileLongSide><<<total_tiles_count, NumThread, 0, d.stream()>>>(\n+            input, input_dims, output);\n+      }\n+      return;\n+    }\n+\n+    // Kernel is not launched, meaning the launch configuration is not\n+    // satisfied.\n+    const bool long_side_request_not_satisfied =\n+        max(tile_size_i, tile_size_j) > TileLongSide;\n+\n+    // Increase launch parameters and try again.\n+    if (long_side_request_not_satisfied) {\n+      BatchNarrowMatrixTransposeDispatcher<T, TileLongSide * 2, TileShortSide>::\n+          DoIt(d, tile_size_i, tile_size_j,\n+                                       total_tiles_count, input, input_dims,\n+                                       output);\n+    } else {\n+      BatchNarrowMatrixTransposeDispatcher<T, TileLongSide, TileShortSide + 1>::\n+          DoIt(d, tile_size_i, tile_size_j,\n+                                       total_tiles_count, input, input_dims,\n+                                       output);\n+    }\n+  }\n+};\n+\n+template <typename T, int TileLongSide, int TileShortSide>\n+struct BatchNarrowMatrixTransposeDispatcher<\n+    T, TileLongSide, TileShortSide,\n+    typename std::enable_if<TileSizePossibilityFrontierCheck(\n+                                TileLongSide, TileShortSide, sizeof(T), 0),\n+                            void>::type> {\n+  static void DoIt(const GPUDevice& d, int tile_size_i,\n+                                           int tile_size_j,\n+                                           int total_tiles_count,\n+                                           const T* input,\n+                                           const Dimension<3>& input_dims,\n+                                           T* output) {\n+\n+    static_assert((TileLongSide & (TileLongSide - 1)) == 0,\n+      \"The length of the longer side of the tile is always a power of 2.\");\n+\n+    const int NumThread = TileLongSide;\n+    if (tile_size_i <= TileLongSide && tile_size_j <= TileShortSide)\n+      SwapDimension1And2InTensor3UsingTiles<\n+          T, NumThread, TileLongSide,\n+          TileShortSide><<<total_tiles_count, NumThread, 0, d.stream()>>>(\n+          input, input_dims, output);\n+    else if (tile_size_j <= TileLongSide && tile_size_i <= TileShortSide)\n+      SwapDimension1And2InTensor3UsingTiles<\n+          T, NumThread, TileShortSide,\n+          TileLongSide><<<total_tiles_count, NumThread, 0, d.stream()>>>(\n+          input, input_dims, output);\n+    return;\n+  }\n+};\n+\n+template <typename T, int TileLongSide, int TileShortSide>\n+struct BatchNarrowMatrixTransposeDispatcher<\n+    T, TileLongSide, TileShortSide,\n+    typename std::enable_if<TileSizePossibilityFrontierCheck(\n+                                TileLongSide, TileShortSide, sizeof(T),\n+                                /* mode = outside */ 1),\n+                            void>::type> {\n+  static void DoIt(const GPUDevice& d, int tile_size_i,\n+                                           int tile_size_j,\n+                                           int total_tiles_count,\n+                                           const T* input,\n+                                           const Dimension<3>& input_dims,\n+                                           T* output) {\n+    assert(false &&\n+           \"BatchNarrowMatrixTransposeDispatcher has requested an unexpected \"\n+           \"launch configuration. \");\n+  }", "path": "tensorflow/core/kernels/conv_ops_gpu_3.cu.cc", "position": null, "original_position": 321, "commit_id": "63d7a082d37c7db42ce52410cf240efda92eaa74", "original_commit_id": "372d4111b99467a9eb4b4866ae8b53ecba505512", "user": {"login": "tjingrant", "id": 6410074, "node_id": "MDQ6VXNlcjY0MTAwNzQ=", "avatar_url": "https://avatars1.githubusercontent.com/u/6410074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tjingrant", "html_url": "https://github.com/tjingrant", "followers_url": "https://api.github.com/users/tjingrant/followers", "following_url": "https://api.github.com/users/tjingrant/following{/other_user}", "gists_url": "https://api.github.com/users/tjingrant/gists{/gist_id}", "starred_url": "https://api.github.com/users/tjingrant/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tjingrant/subscriptions", "organizations_url": "https://api.github.com/users/tjingrant/orgs", "repos_url": "https://api.github.com/users/tjingrant/repos", "events_url": "https://api.github.com/users/tjingrant/events{/privacy}", "received_events_url": "https://api.github.com/users/tjingrant/received_events", "type": "User", "site_admin": false}, "body": "Hi, getting rid of this `DoIt` is conceptually easy; however I'm unable to arrive at a clean solution. I have `Doit` here because the compiler does not know that I always try doubling the long tile size to satisfy the requirement first and only then increment the short tile size. Thus when we are on the de facto `boundary` (as opposed to the `frontier`) of the convex tile size space we declare as performant, the compiler will try to increment the short dimension and compile a specialization that will never be invoked. \r\n\r\nFor instance, suppose we are compiling specializations with `floar4`. The recursive search procedure starts with tile size combination (32,2) and then one of the compilation paths goes like (64, 2), (128, 2), (128, 3). At (128, 3), we are at the boundary of the tile size space but not on the frontier. The compiler then takes the next step as (128, 4), effectively going out of boundary and then stopped by the base case mentioned above. \r\n\r\n- One approach I tried but didn't work:\r\n```\r\nif (long_side_request_not_satisfied) {\r\n      if (!TileSizePastFrontier(TileLongSide * 2, TileShortSide, sizeof(T)))\r\n          DoIt...\r\n    } else {\r\n      if (!TileSizePastFrontier(TileLongSide, TileShortSide + 1, sizeof(T)))\r\n          DoIt...\r\n    }\r\n```\r\nThe compiler doesn't seem to evaluate the conditional before further specialization.\r\n\r\n- I suppose I can also specialize the behavior of the boundary (excluding the frontier) case however this would be to exchange simplicity for additional assurance of correctness and I'm not sure such tradeoff is worthwhile.\r\n\r\nDo you see a better way of communicating to the compiler that incrementing the short side length after doubling the long side length is forbidden?", "created_at": "2017-10-03T20:50:24Z", "updated_at": "2017-12-28T20:26:00Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/13049#discussion_r142519196", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/13049", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/142519196"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/13049#discussion_r142519196"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/13049"}}, "body_html": "<p>Hi, getting rid of this <code>DoIt</code> is conceptually easy; however I'm unable to arrive at a clean solution. I have <code>Doit</code> here because the compiler does not know that I always try doubling the long tile size to satisfy the requirement first and only then increment the short tile size. Thus when we are on the de facto <code>boundary</code> (as opposed to the <code>frontier</code>) of the convex tile size space we declare as performant, the compiler will try to increment the short dimension and compile a specialization that will never be invoked.</p>\n<p>For instance, suppose we are compiling specializations with <code>floar4</code>. The recursive search procedure starts with tile size combination (32,2) and then one of the compilation paths goes like (64, 2), (128, 2), (128, 3). At (128, 3), we are at the boundary of the tile size space but not on the frontier. The compiler then takes the next step as (128, 4), effectively going out of boundary and then stopped by the base case mentioned above.</p>\n<ul>\n<li>One approach I tried but didn't work:</li>\n</ul>\n<pre><code>if (long_side_request_not_satisfied) {\n      if (!TileSizePastFrontier(TileLongSide * 2, TileShortSide, sizeof(T)))\n          DoIt...\n    } else {\n      if (!TileSizePastFrontier(TileLongSide, TileShortSide + 1, sizeof(T)))\n          DoIt...\n    }\n</code></pre>\n<p>The compiler doesn't seem to evaluate the conditional before further specialization.</p>\n<ul>\n<li>I suppose I can also specialize the behavior of the boundary (excluding the frontier) case however this would be to exchange simplicity for additional assurance of correctness and I'm not sure such tradeoff is worthwhile.</li>\n</ul>\n<p>Do you see a better way of communicating to the compiler that incrementing the short side length after doubling the long side length is forbidden?</p>", "body_text": "Hi, getting rid of this DoIt is conceptually easy; however I'm unable to arrive at a clean solution. I have Doit here because the compiler does not know that I always try doubling the long tile size to satisfy the requirement first and only then increment the short tile size. Thus when we are on the de facto boundary (as opposed to the frontier) of the convex tile size space we declare as performant, the compiler will try to increment the short dimension and compile a specialization that will never be invoked.\nFor instance, suppose we are compiling specializations with floar4. The recursive search procedure starts with tile size combination (32,2) and then one of the compilation paths goes like (64, 2), (128, 2), (128, 3). At (128, 3), we are at the boundary of the tile size space but not on the frontier. The compiler then takes the next step as (128, 4), effectively going out of boundary and then stopped by the base case mentioned above.\n\nOne approach I tried but didn't work:\n\nif (long_side_request_not_satisfied) {\n      if (!TileSizePastFrontier(TileLongSide * 2, TileShortSide, sizeof(T)))\n          DoIt...\n    } else {\n      if (!TileSizePastFrontier(TileLongSide, TileShortSide + 1, sizeof(T)))\n          DoIt...\n    }\n\nThe compiler doesn't seem to evaluate the conditional before further specialization.\n\nI suppose I can also specialize the behavior of the boundary (excluding the frontier) case however this would be to exchange simplicity for additional assurance of correctness and I'm not sure such tradeoff is worthwhile.\n\nDo you see a better way of communicating to the compiler that incrementing the short side length after doubling the long side length is forbidden?", "in_reply_to_id": 141923301}