{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/332383040", "html_url": "https://github.com/tensorflow/tensorflow/pull/13049#issuecomment-332383040", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13049", "id": 332383040, "node_id": "MDEyOklzc3VlQ29tbWVudDMzMjM4MzA0MA==", "user": {"login": "tjingrant", "id": 6410074, "node_id": "MDQ6VXNlcjY0MTAwNzQ=", "avatar_url": "https://avatars1.githubusercontent.com/u/6410074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tjingrant", "html_url": "https://github.com/tjingrant", "followers_url": "https://api.github.com/users/tjingrant/followers", "following_url": "https://api.github.com/users/tjingrant/following{/other_user}", "gists_url": "https://api.github.com/users/tjingrant/gists{/gist_id}", "starred_url": "https://api.github.com/users/tjingrant/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tjingrant/subscriptions", "organizations_url": "https://api.github.com/users/tjingrant/orgs", "repos_url": "https://api.github.com/users/tjingrant/repos", "events_url": "https://api.github.com/users/tjingrant/events{/privacy}", "received_events_url": "https://api.github.com/users/tjingrant/received_events", "type": "User", "site_admin": false}, "created_at": "2017-09-27T01:34:23Z", "updated_at": "2017-09-27T01:36:13Z", "author_association": "CONTRIBUTOR", "body_html": "<p>And a comment to your WDYT question regarding your suggestion of using enable::if to reduce cases down to 2:</p>\n<p>I played around with your neat trick and was able to get a much cleaner presentation. However, fundamentally we can't get below three cases. The \"base case\" you mentioned is really the boundary case. Visualizing all the tile sizes combinations in a 2D space, we face three constraints that, when considered all together, would define the <em>valid tile size combinations</em> subset: physical limit on thread numbers, physical limit on shared memory and further limit on the tile area (product of 2 tile sizes) to increase parallelism. I conveniently called the limit derived from these three constraints the <em>tile size possibility frontier</em>, drawing the name from the concept of <a href=\"https://en.wikipedia.org/wiki/Production%E2%80%93possibility_frontier\" rel=\"nofollow\">production possibility frontier</a>. I think this is a very intuitive name even without the parallel drawn.</p>\n<p>Thus with this frontier established, we have three cases:</p>\n<ul>\n<li>tile size combination lands in the interior of the frontier: we try to launch kernel and if request is not satisfied, we search for larger tile size combinations.</li>\n<li>tile size combination lands on the frontier: we launch regardless of whether request is satisfied, no search performed.</li>\n<li>tile size combination lands in the exterior of the frontier: even compiling such kernel would cause us trouble, thus specialize dispatcher to do nothing at all.</li>\n</ul>", "body_text": "And a comment to your WDYT question regarding your suggestion of using enable::if to reduce cases down to 2:\nI played around with your neat trick and was able to get a much cleaner presentation. However, fundamentally we can't get below three cases. The \"base case\" you mentioned is really the boundary case. Visualizing all the tile sizes combinations in a 2D space, we face three constraints that, when considered all together, would define the valid tile size combinations subset: physical limit on thread numbers, physical limit on shared memory and further limit on the tile area (product of 2 tile sizes) to increase parallelism. I conveniently called the limit derived from these three constraints the tile size possibility frontier, drawing the name from the concept of production possibility frontier. I think this is a very intuitive name even without the parallel drawn.\nThus with this frontier established, we have three cases:\n\ntile size combination lands in the interior of the frontier: we try to launch kernel and if request is not satisfied, we search for larger tile size combinations.\ntile size combination lands on the frontier: we launch regardless of whether request is satisfied, no search performed.\ntile size combination lands in the exterior of the frontier: even compiling such kernel would cause us trouble, thus specialize dispatcher to do nothing at all.", "body": "And a comment to your WDYT question regarding your suggestion of using enable::if to reduce cases down to 2:\r\n\r\nI played around with your neat trick and was able to get a much cleaner presentation. However, fundamentally we can't get below three cases. The \"base case\" you mentioned is really the boundary case. Visualizing all the tile sizes combinations in a 2D space, we face three constraints that, when considered all together, would define the _valid tile size combinations_ subset: physical limit on thread numbers, physical limit on shared memory and further limit on the tile area (product of 2 tile sizes) to increase parallelism. I conveniently called the limit derived from these three constraints the _tile size possibility frontier_, drawing the name from the concept of [production possibility frontier](https://en.wikipedia.org/wiki/Production%E2%80%93possibility_frontier). I think this is a very intuitive name even without the parallel drawn.\r\n\r\nThus with this frontier established, we have three cases:\r\n\r\n- tile size combination lands in the interior of the frontier: we try to launch kernel and if request is not satisfied, we search for larger tile size combinations.\r\n- tile size combination lands on the frontier: we launch regardless of whether request is satisfied, no search performed.\r\n- tile size combination lands in the exterior of the frontier: even compiling such kernel would cause us trouble, thus specialize dispatcher to do nothing at all."}