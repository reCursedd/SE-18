{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/4590", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/4590/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/4590/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/4590/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/4590", "id": 179330299, "node_id": "MDU6SXNzdWUxNzkzMzAyOTk=", "number": 4590, "title": "Better shape inference for tf.slice and tf.strided_slice", "user": {"login": "gibiansky", "id": 1865411, "node_id": "MDQ6VXNlcjE4NjU0MTE=", "avatar_url": "https://avatars3.githubusercontent.com/u/1865411?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gibiansky", "html_url": "https://github.com/gibiansky", "followers_url": "https://api.github.com/users/gibiansky/followers", "following_url": "https://api.github.com/users/gibiansky/following{/other_user}", "gists_url": "https://api.github.com/users/gibiansky/gists{/gist_id}", "starred_url": "https://api.github.com/users/gibiansky/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gibiansky/subscriptions", "organizations_url": "https://api.github.com/users/gibiansky/orgs", "repos_url": "https://api.github.com/users/gibiansky/repos", "events_url": "https://api.github.com/users/gibiansky/events{/privacy}", "received_events_url": "https://api.github.com/users/gibiansky/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 299643928, "node_id": "MDU6TGFiZWwyOTk2NDM5Mjg=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:contributions%20welcome", "name": "stat:contributions welcome", "color": "f4b400", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 8, "created_at": "2016-09-26T20:34:25Z", "updated_at": "2018-09-28T22:15:47Z", "closed_at": "2018-09-28T22:14:28Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Currently, if any of the values in the <code>size</code> argument is not a constant, the output shape is completely unknown (but the correct rank):</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> z <span class=\"pl-k\">=</span> tf.zeros((<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">2</span>, <span class=\"pl-c1\">3</span>))\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> z.get_shape().as_list()\n[<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">2</span>, <span class=\"pl-c1\">3</span>]\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> m <span class=\"pl-k\">=</span> tf.slice(z, [<span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">0</span>], [<span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>, <span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>, <span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>])\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> m.get_shape().as_list()\n[<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">2</span>, <span class=\"pl-c1\">3</span>]\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> m <span class=\"pl-k\">=</span> tf.slice(z, [<span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">0</span>], [tf.constant(<span class=\"pl-c1\">1</span>) <span class=\"pl-k\">+</span> <span class=\"pl-c1\">0</span>, <span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>, <span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>])\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> m.get_shape().as_list()\n[<span class=\"pl-c1\">None</span>, <span class=\"pl-c1\">None</span>, <span class=\"pl-c1\">None</span>]</pre></div>\n<p>The desired behaviour would instead treat the second and third dimensions correctly:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> m <span class=\"pl-k\">=</span> tf.slice(z, [<span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">0</span>], [tf.constant(<span class=\"pl-c1\">1</span>) <span class=\"pl-k\">+</span> <span class=\"pl-c1\">0</span>, <span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>, <span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>])\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> m.get_shape().as_list()\n[<span class=\"pl-c1\">None</span>, <span class=\"pl-c1\">2</span>, <span class=\"pl-c1\">3</span>]</pre></div>\n<p>Looking briefly at the code, this would requite being a bit more clever in terms of how constant values are computed; right now if anything in a <code>Pack</code>-ed array is unknown at graph construction time, the entire array is unknown (see <code>_ConstantValue</code>'s <code>Pack</code> case).</p>\n<p>I guess this request ends up being just a request for a better constant propagation system which supports partially-known tensors. Perhaps you already have other use cases for such a feature, in which case view this as just another request that such a feature would enable.</p>", "body_text": "Currently, if any of the values in the size argument is not a constant, the output shape is completely unknown (but the correct rank):\n>>> z = tf.zeros((1, 2, 3))\n>>> z.get_shape().as_list()\n[1, 2, 3]\n>>> m = tf.slice(z, [0, 0, 0], [-1, -1, -1])\n>>> m.get_shape().as_list()\n[1, 2, 3]\n>>> m = tf.slice(z, [0, 0, 0], [tf.constant(1) + 0, -1, -1])\n>>> m.get_shape().as_list()\n[None, None, None]\nThe desired behaviour would instead treat the second and third dimensions correctly:\n>>> m = tf.slice(z, [0, 0, 0], [tf.constant(1) + 0, -1, -1])\n>>> m.get_shape().as_list()\n[None, 2, 3]\nLooking briefly at the code, this would requite being a bit more clever in terms of how constant values are computed; right now if anything in a Pack-ed array is unknown at graph construction time, the entire array is unknown (see _ConstantValue's Pack case).\nI guess this request ends up being just a request for a better constant propagation system which supports partially-known tensors. Perhaps you already have other use cases for such a feature, in which case view this as just another request that such a feature would enable.", "body": "Currently, if any of the values in the `size` argument is not a constant, the output shape is completely unknown (but the correct rank):\n\n``` python\n>>> z = tf.zeros((1, 2, 3))\n>>> z.get_shape().as_list()\n[1, 2, 3]\n>>> m = tf.slice(z, [0, 0, 0], [-1, -1, -1])\n>>> m.get_shape().as_list()\n[1, 2, 3]\n>>> m = tf.slice(z, [0, 0, 0], [tf.constant(1) + 0, -1, -1])\n>>> m.get_shape().as_list()\n[None, None, None]\n```\n\nThe desired behaviour would instead treat the second and third dimensions correctly:\n\n``` python\n>>> m = tf.slice(z, [0, 0, 0], [tf.constant(1) + 0, -1, -1])\n>>> m.get_shape().as_list()\n[None, 2, 3]\n```\n\nLooking briefly at the code, this would requite being a bit more clever in terms of how constant values are computed; right now if anything in a `Pack`-ed array is unknown at graph construction time, the entire array is unknown (see `_ConstantValue`'s `Pack` case).\n\nI guess this request ends up being just a request for a better constant propagation system which supports partially-known tensors. Perhaps you already have other use cases for such a feature, in which case view this as just another request that such a feature would enable.\n"}