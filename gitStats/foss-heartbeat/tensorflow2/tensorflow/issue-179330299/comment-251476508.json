{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/251476508", "html_url": "https://github.com/tensorflow/tensorflow/issues/4590#issuecomment-251476508", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/4590", "id": 251476508, "node_id": "MDEyOklzc3VlQ29tbWVudDI1MTQ3NjUwOA==", "user": {"login": "gibiansky", "id": 1865411, "node_id": "MDQ6VXNlcjE4NjU0MTE=", "avatar_url": "https://avatars3.githubusercontent.com/u/1865411?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gibiansky", "html_url": "https://github.com/gibiansky", "followers_url": "https://api.github.com/users/gibiansky/followers", "following_url": "https://api.github.com/users/gibiansky/following{/other_user}", "gists_url": "https://api.github.com/users/gibiansky/gists{/gist_id}", "starred_url": "https://api.github.com/users/gibiansky/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gibiansky/subscriptions", "organizations_url": "https://api.github.com/users/gibiansky/orgs", "repos_url": "https://api.github.com/users/gibiansky/repos", "events_url": "https://api.github.com/users/gibiansky/events{/privacy}", "received_events_url": "https://api.github.com/users/gibiansky/received_events", "type": "User", "site_admin": false}, "created_at": "2016-10-04T18:43:35Z", "updated_at": "2016-10-04T18:43:35Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Yeah, I tried to trace through the code to figure out how I might implement better shape inference just for <code>tf.slice</code>, but it's tricky. It would require a fair bit more work on the constant propagation \u2013 namely, you'd need to have a way to represent \"partially known\" tensors. The <code>size</code> array is computed by doing <code>tf.pack([tf.constant(1) + 0, -1, -1])</code>, roughly, but <code>Pack</code> can only be constant-propagated if the <em>entire</em> tensor is known.</p>\n<p>If I had to do this, what I would do is change <a href=\"https://github.com/tensorflow/tensorflow/blob/c856366b739850a9f4b0bf1469de7f052619042b/tensorflow/python/framework/tensor_util.py#L555\"><code>_ConstantValue</code></a> to return a different data type. Right now it returns a <code>np.ndarray</code> containing the values that are in the tensor being converted to a constant (or <code>None</code> if the tensor is not a constant).</p>\n<p>Instead, it could return a tuple containing <code>(values, mask)</code>, where of types <code>(np.ndarray, np.ndarray)</code>, respectively, where <code>mask</code> is an array of booleans which select whether the respective elements are known (and their values are stored in <code>values</code>) or whether they are unknown. All cases where <code>_ConstantValues</code> currently returns non-None values would have <code>mask</code> be an array entirely of <code>True</code>; some cases where <code>None</code> is currently returned would be able to return a partially-True <code>mask</code>.</p>", "body_text": "Yeah, I tried to trace through the code to figure out how I might implement better shape inference just for tf.slice, but it's tricky. It would require a fair bit more work on the constant propagation \u2013 namely, you'd need to have a way to represent \"partially known\" tensors. The size array is computed by doing tf.pack([tf.constant(1) + 0, -1, -1]), roughly, but Pack can only be constant-propagated if the entire tensor is known.\nIf I had to do this, what I would do is change _ConstantValue to return a different data type. Right now it returns a np.ndarray containing the values that are in the tensor being converted to a constant (or None if the tensor is not a constant).\nInstead, it could return a tuple containing (values, mask), where of types (np.ndarray, np.ndarray), respectively, where mask is an array of booleans which select whether the respective elements are known (and their values are stored in values) or whether they are unknown. All cases where _ConstantValues currently returns non-None values would have mask be an array entirely of True; some cases where None is currently returned would be able to return a partially-True mask.", "body": "Yeah, I tried to trace through the code to figure out how I might implement better shape inference just for `tf.slice`, but it's tricky. It would require a fair bit more work on the constant propagation \u2013 namely, you'd need to have a way to represent \"partially known\" tensors. The `size` array is computed by doing `tf.pack([tf.constant(1) + 0, -1, -1])`, roughly, but `Pack` can only be constant-propagated if the _entire_ tensor is known. \n\nIf I had to do this, what I would do is change [`_ConstantValue`](https://github.com/tensorflow/tensorflow/blob/c856366b739850a9f4b0bf1469de7f052619042b/tensorflow/python/framework/tensor_util.py#L555) to return a different data type. Right now it returns a `np.ndarray` containing the values that are in the tensor being converted to a constant (or `None` if the tensor is not a constant).\n\nInstead, it could return a tuple containing `(values, mask)`, where of types `(np.ndarray, np.ndarray)`, respectively, where `mask` is an array of booleans which select whether the respective elements are known (and their values are stored in `values`) or whether they are unknown. All cases where `_ConstantValues` currently returns non-None values would have `mask` be an array entirely of `True`; some cases where `None` is currently returned would be able to return a partially-True `mask`.\n"}