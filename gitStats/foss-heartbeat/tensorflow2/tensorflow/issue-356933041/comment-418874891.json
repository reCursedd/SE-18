{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/418874891", "html_url": "https://github.com/tensorflow/tensorflow/issues/22062#issuecomment-418874891", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/22062", "id": 418874891, "node_id": "MDEyOklzc3VlQ29tbWVudDQxODg3NDg5MQ==", "user": {"login": "allenlavoie", "id": 3731025, "node_id": "MDQ6VXNlcjM3MzEwMjU=", "avatar_url": "https://avatars3.githubusercontent.com/u/3731025?v=4", "gravatar_id": "", "url": "https://api.github.com/users/allenlavoie", "html_url": "https://github.com/allenlavoie", "followers_url": "https://api.github.com/users/allenlavoie/followers", "following_url": "https://api.github.com/users/allenlavoie/following{/other_user}", "gists_url": "https://api.github.com/users/allenlavoie/gists{/gist_id}", "starred_url": "https://api.github.com/users/allenlavoie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/allenlavoie/subscriptions", "organizations_url": "https://api.github.com/users/allenlavoie/orgs", "repos_url": "https://api.github.com/users/allenlavoie/repos", "events_url": "https://api.github.com/users/allenlavoie/events{/privacy}", "received_events_url": "https://api.github.com/users/allenlavoie/received_events", "type": "User", "site_admin": false}, "created_at": "2018-09-05T20:43:54Z", "updated_at": "2018-09-05T20:43:54Z", "author_association": "MEMBER", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=26417094\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/ybsave\">@ybsave</a> I think the idea of 3 is that you could subclass <code>Layer</code> and pass the NumPy array to its constructor. You may then have to define <code>get_config</code> and <code>from_config</code>, but that's one path to getting everything serialized. The NumPy array would live with the <code>Layer</code> subclass.</p>\n<p>We are hoping to serialize/deserialize <code>Model</code>s as TensorFlow graphs soon, which should work around function bytecode issues.</p>\n<p>It does kinda seem like <code>Lambda</code> layers could capture in this case, but since the captured reference is to a mutable Python object getting the sematics exactly right seems super tricky.</p>", "body_text": "@ybsave I think the idea of 3 is that you could subclass Layer and pass the NumPy array to its constructor. You may then have to define get_config and from_config, but that's one path to getting everything serialized. The NumPy array would live with the Layer subclass.\nWe are hoping to serialize/deserialize Models as TensorFlow graphs soon, which should work around function bytecode issues.\nIt does kinda seem like Lambda layers could capture in this case, but since the captured reference is to a mutable Python object getting the sematics exactly right seems super tricky.", "body": "@ybsave I think the idea of 3 is that you could subclass `Layer` and pass the NumPy array to its constructor. You may then have to define `get_config` and `from_config`, but that's one path to getting everything serialized. The NumPy array would live with the `Layer` subclass.\r\n\r\nWe are hoping to serialize/deserialize `Model`s as TensorFlow graphs soon, which should work around function bytecode issues.\r\n\r\nIt does kinda seem like `Lambda` layers could capture in this case, but since the captured reference is to a mutable Python object getting the sematics exactly right seems super tricky."}