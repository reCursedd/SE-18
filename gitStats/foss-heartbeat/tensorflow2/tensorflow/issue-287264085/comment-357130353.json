{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/357130353", "html_url": "https://github.com/tensorflow/tensorflow/issues/15985#issuecomment-357130353", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/15985", "id": 357130353, "node_id": "MDEyOklzc3VlQ29tbWVudDM1NzEzMDM1Mw==", "user": {"login": "selcouthlyBlue", "id": 13268675, "node_id": "MDQ6VXNlcjEzMjY4Njc1", "avatar_url": "https://avatars2.githubusercontent.com/u/13268675?v=4", "gravatar_id": "", "url": "https://api.github.com/users/selcouthlyBlue", "html_url": "https://github.com/selcouthlyBlue", "followers_url": "https://api.github.com/users/selcouthlyBlue/followers", "following_url": "https://api.github.com/users/selcouthlyBlue/following{/other_user}", "gists_url": "https://api.github.com/users/selcouthlyBlue/gists{/gist_id}", "starred_url": "https://api.github.com/users/selcouthlyBlue/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/selcouthlyBlue/subscriptions", "organizations_url": "https://api.github.com/users/selcouthlyBlue/orgs", "repos_url": "https://api.github.com/users/selcouthlyBlue/repos", "events_url": "https://api.github.com/users/selcouthlyBlue/events{/privacy}", "received_events_url": "https://api.github.com/users/selcouthlyBlue/received_events", "type": "User", "site_admin": false}, "created_at": "2018-01-12T03:04:25Z", "updated_at": "2018-01-12T03:06:53Z", "author_association": "CONTRIBUTOR", "body_html": "<p>I tried using this to function to create a sparse matrix from a dense one:</p>\n<pre><code>def convert_to_sparse(labels, dtype=np.int32):\n    indices = []\n    values = []\n\n    for n, seq in enumerate(labels):\n        indices.extend(zip([n] * len(seq), range(len(seq))))\n        values.extend(seq)\n\n    indices = np.asarray(indices, dtype=dtype)\n    values = np.asarray(values, dtype=dtype)\n    shape = np.asarray([len(labels), np.asarray(indices).max(0)[1] + 1], dtype=dtype)\n\n    return indices, values, shape\n</code></pre>\n<p>When I placed the indices, values, and shape to create a <code>SparseTensor</code>:</p>\n<pre><code>print(tf.SparseTensor(\n        indices=sparse_y_train[0],\n        values=sparse_y_train[1],\n        dense_shape=sparse_y_train\n    ))\n</code></pre>\n<p>And compared it to a <code>SparseTensor</code> created from a <code>Tensor</code>:</p>\n<pre><code>indices = tf.where(tf.not_equal(labels, tf.constant(0, dtype=tf.int32)))\nvalues = tf.gather_nd(labels, indices)\nsparse_labels = tf.SparseTensor(indices, values, dense_shape=tf.shape(labels, out_type=tf.int64))\nprint(sparse_labels)\n</code></pre>\n<p>I got these respectively:</p>\n<pre><code>SparseTensor(indices=Tensor(\"SparseTensor/indices:0\", shape=(33, 2), dtype=int64), values=Tensor(\"SparseTensor/values:0\", shape=(33,), dtype=int32), dense_shape=Tensor(\"SparseTensor/dense_shape:0\", shape=(2,), dtype=int64))\n\nSparseTensor(indices=Tensor(\"Where:0\", shape=(?, 2), dtype=int64), values=Tensor(\"GatherNd:0\", shape=(?,), dtype=int32), dense_shape=Tensor(\"Shape:0\", shape=(2,), dtype=int64))\n</code></pre>\n<p>I guess this is the case of ctc_loss not being able to handle dynamic shapes for indices, values, and dense_shape for its labels parameter.</p>", "body_text": "I tried using this to function to create a sparse matrix from a dense one:\ndef convert_to_sparse(labels, dtype=np.int32):\n    indices = []\n    values = []\n\n    for n, seq in enumerate(labels):\n        indices.extend(zip([n] * len(seq), range(len(seq))))\n        values.extend(seq)\n\n    indices = np.asarray(indices, dtype=dtype)\n    values = np.asarray(values, dtype=dtype)\n    shape = np.asarray([len(labels), np.asarray(indices).max(0)[1] + 1], dtype=dtype)\n\n    return indices, values, shape\n\nWhen I placed the indices, values, and shape to create a SparseTensor:\nprint(tf.SparseTensor(\n        indices=sparse_y_train[0],\n        values=sparse_y_train[1],\n        dense_shape=sparse_y_train\n    ))\n\nAnd compared it to a SparseTensor created from a Tensor:\nindices = tf.where(tf.not_equal(labels, tf.constant(0, dtype=tf.int32)))\nvalues = tf.gather_nd(labels, indices)\nsparse_labels = tf.SparseTensor(indices, values, dense_shape=tf.shape(labels, out_type=tf.int64))\nprint(sparse_labels)\n\nI got these respectively:\nSparseTensor(indices=Tensor(\"SparseTensor/indices:0\", shape=(33, 2), dtype=int64), values=Tensor(\"SparseTensor/values:0\", shape=(33,), dtype=int32), dense_shape=Tensor(\"SparseTensor/dense_shape:0\", shape=(2,), dtype=int64))\n\nSparseTensor(indices=Tensor(\"Where:0\", shape=(?, 2), dtype=int64), values=Tensor(\"GatherNd:0\", shape=(?,), dtype=int32), dense_shape=Tensor(\"Shape:0\", shape=(2,), dtype=int64))\n\nI guess this is the case of ctc_loss not being able to handle dynamic shapes for indices, values, and dense_shape for its labels parameter.", "body": "I tried using this to function to create a sparse matrix from a dense one:\r\n\r\n```\r\ndef convert_to_sparse(labels, dtype=np.int32):\r\n    indices = []\r\n    values = []\r\n\r\n    for n, seq in enumerate(labels):\r\n        indices.extend(zip([n] * len(seq), range(len(seq))))\r\n        values.extend(seq)\r\n\r\n    indices = np.asarray(indices, dtype=dtype)\r\n    values = np.asarray(values, dtype=dtype)\r\n    shape = np.asarray([len(labels), np.asarray(indices).max(0)[1] + 1], dtype=dtype)\r\n\r\n    return indices, values, shape\r\n```\r\n\r\nWhen I placed the indices, values, and shape to create a `SparseTensor`:\r\n\r\n```\r\nprint(tf.SparseTensor(\r\n        indices=sparse_y_train[0],\r\n        values=sparse_y_train[1],\r\n        dense_shape=sparse_y_train\r\n    ))\r\n```\r\n\r\nAnd compared it to a `SparseTensor` created from a `Tensor`:\r\n\r\n```\r\nindices = tf.where(tf.not_equal(labels, tf.constant(0, dtype=tf.int32)))\r\nvalues = tf.gather_nd(labels, indices)\r\nsparse_labels = tf.SparseTensor(indices, values, dense_shape=tf.shape(labels, out_type=tf.int64))\r\nprint(sparse_labels)\r\n```\r\n\r\nI got these respectively:\r\n\r\n```\r\nSparseTensor(indices=Tensor(\"SparseTensor/indices:0\", shape=(33, 2), dtype=int64), values=Tensor(\"SparseTensor/values:0\", shape=(33,), dtype=int32), dense_shape=Tensor(\"SparseTensor/dense_shape:0\", shape=(2,), dtype=int64))\r\n\r\nSparseTensor(indices=Tensor(\"Where:0\", shape=(?, 2), dtype=int64), values=Tensor(\"GatherNd:0\", shape=(?,), dtype=int32), dense_shape=Tensor(\"Shape:0\", shape=(2,), dtype=int64))\r\n```\r\n\r\nI guess this is the case of ctc_loss not being able to handle dynamic shapes for indices, values, and dense_shape for its labels parameter."}