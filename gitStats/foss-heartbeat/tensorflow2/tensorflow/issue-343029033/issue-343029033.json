{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/20990", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/20990/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/20990/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/20990/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/20990", "id": 343029033, "node_id": "MDU6SXNzdWUzNDMwMjkwMzM=", "number": 20990, "title": "Convert_variables_to_constants return None after import", "user": {"login": "Jylomaki", "id": 16537704, "node_id": "MDQ6VXNlcjE2NTM3NzA0", "avatar_url": "https://avatars2.githubusercontent.com/u/16537704?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jylomaki", "html_url": "https://github.com/Jylomaki", "followers_url": "https://api.github.com/users/Jylomaki/followers", "following_url": "https://api.github.com/users/Jylomaki/following{/other_user}", "gists_url": "https://api.github.com/users/Jylomaki/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jylomaki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jylomaki/subscriptions", "organizations_url": "https://api.github.com/users/Jylomaki/orgs", "repos_url": "https://api.github.com/users/Jylomaki/repos", "events_url": "https://api.github.com/users/Jylomaki/events{/privacy}", "received_events_url": "https://api.github.com/users/Jylomaki/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 404586594, "node_id": "MDU6TGFiZWw0MDQ1ODY1OTQ=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:awaiting%20tensorflower", "name": "stat:awaiting tensorflower", "color": "f4b400", "default": false}], "state": "closed", "locked": false, "assignee": {"login": "poxvoculi", "id": 15676913, "node_id": "MDQ6VXNlcjE1Njc2OTEz", "avatar_url": "https://avatars2.githubusercontent.com/u/15676913?v=4", "gravatar_id": "", "url": "https://api.github.com/users/poxvoculi", "html_url": "https://github.com/poxvoculi", "followers_url": "https://api.github.com/users/poxvoculi/followers", "following_url": "https://api.github.com/users/poxvoculi/following{/other_user}", "gists_url": "https://api.github.com/users/poxvoculi/gists{/gist_id}", "starred_url": "https://api.github.com/users/poxvoculi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/poxvoculi/subscriptions", "organizations_url": "https://api.github.com/users/poxvoculi/orgs", "repos_url": "https://api.github.com/users/poxvoculi/repos", "events_url": "https://api.github.com/users/poxvoculi/events{/privacy}", "received_events_url": "https://api.github.com/users/poxvoculi/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "poxvoculi", "id": 15676913, "node_id": "MDQ6VXNlcjE1Njc2OTEz", "avatar_url": "https://avatars2.githubusercontent.com/u/15676913?v=4", "gravatar_id": "", "url": "https://api.github.com/users/poxvoculi", "html_url": "https://github.com/poxvoculi", "followers_url": "https://api.github.com/users/poxvoculi/followers", "following_url": "https://api.github.com/users/poxvoculi/following{/other_user}", "gists_url": "https://api.github.com/users/poxvoculi/gists{/gist_id}", "starred_url": "https://api.github.com/users/poxvoculi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/poxvoculi/subscriptions", "organizations_url": "https://api.github.com/users/poxvoculi/orgs", "repos_url": "https://api.github.com/users/poxvoculi/repos", "events_url": "https://api.github.com/users/poxvoculi/events{/privacy}", "received_events_url": "https://api.github.com/users/poxvoculi/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 3, "created_at": "2018-07-20T09:05:25Z", "updated_at": "2018-07-23T12:26:33Z", "closed_at": "2018-07-23T12:26:33Z", "author_association": "NONE", "body_html": "<h3>System information</h3>\n<ul>\n<li><strong>Have I written custom code (as opposed to using a stock example script provided in TensorFlow)</strong>:<br>\nYes, minimal example below</li>\n<li><strong>OS Platform and Distribution</strong>:Linux Ubuntu 16.04</li>\n<li><strong>TensorFlow installed from (source or binary)</strong>: using pip3</li>\n<li><strong>TensorFlow version (use command below)</strong>: git version: v1.8.0-0-g93bc2e2072 tf version 1.8.0</li>\n<li><strong>Python version</strong>: 3.5.2</li>\n<li><strong>CUDA/cuDNN version</strong>: not using (because of old GPU)</li>\n<li><strong>GPU model and memory</strong>: geforce 265</li>\n<li><strong>Exact command to reproduce</strong>:</li>\n</ul>\n<ol>\n<li>Convert a graph using tf.graph_util.convert_variables_to_constants</li>\n<li>Import resulting graph using tf.import_graph_def</li>\n<li>Eval the variables you want<br>\n(4. you get \"None\" on eval)</li>\n</ol>\n<h3>The problem</h3>\n<p>After converting variables to constant<br>\nImporting the graph_def results in a graph that always eval to None</p>\n<pre><code># minimal testing\nwith tf.Graph().as_default() as graphy:\n    with tf.Session() as sessy:\n        # declaring placeholder\n        place_holder = tf.placeholder(dtype=tf.float32,shape=[3])\n        tmp_feed = {place_holder:[1,1,1]}\n        \n        # declaring vars and outputs\n        rand = tf.random_uniform([3])\n        the_var = tf.Variable(rand,name=\"the_var\") # depend only on var\n        out = tf.add(the_var,place_holder, name=\"the_result_node\") # depend on var and placeholder\n        out2 = tf.multiply(place_holder,2.0, name=\"the_place_holder\") # depend only on placeholder\n        \n        # getting names of outputs &amp; vars\n        out_tensor = [the_var,out,out2]\n        out_names = [t.name.split(\":\")[0] for t in out_tensor]\n        var_names = [place_holder.name.split(\":\")[0]] # setting place_holder as blacklist as it must not be replaced by a constant ( doing this or not doesn't change result)\n        \n        # doing a first run to get a run comparison \n        sessy.run(tf.global_variables_initializer())\n        for t in out_tensor:\n            print(\"first eval\",t.name,sessy.run(t, feed_dict=tmp_feed))\n        \n        # freezing the graph\n        frozen_graphy = tf.graph_util.convert_variables_to_constants(\n                                                sess=sessy,\n                                                 input_graph_def=graphy.as_graph_def(),\n                                                 output_node_names=out_names,\n                                                 variable_names_blacklist=var_names)\n        print(\"freezing done, exported:\", out_names)\n        \n        # session has been closed seemingly by the convert\n            \n    # eval to check if the graph was actually modified. &lt; return different values &gt;\n    with tf.Session(graph=graphy) as sessu:\n        sessu.run(tf.global_variables_initializer())\n        for t in out_tensor:\n            print(\"second eval of graph1\",t.name,sessu.run(t, feed_dict=tmp_feed))\n        \n\n#print(frozen_graphy) # just checking what it look like\n\nprefixe = \"frozen_import\"\nwith tf.Graph().as_default() as grapho:\n    with tf.Session() as sesso:\n        print(\"importing frozen graph vars:\", out_names)\n        out_list = tf.import_graph_def(frozen_graphy,return_elements=out_names,name=prefixe)\n        print(\"outlist:\",out_list)\n        \n        # creating the feed dict for the placeholder\n        input_name = prefixe+\"/\"+var_names[0]\n        frozen_feed_dict={input_name+\":0\":[1,1,1]}\n        \n        # second eval to compare &lt; return None &gt;\n        sesso.run(tf.global_variables_initializer())\n        for t in out_list:\n            print(t.name,\" =\",sesso.run(t,feed_dict=frozen_feed_dict))\n            \n        # eval of placeholder: &lt; return its value &gt;\n        p_h = grapho.get_tensor_by_name(input_name+\":0\")\n        print(p_h.name, sesso.run(p_h, feed_dict=frozen_feed_dict))\n</code></pre>", "body_text": "System information\n\nHave I written custom code (as opposed to using a stock example script provided in TensorFlow):\nYes, minimal example below\nOS Platform and Distribution:Linux Ubuntu 16.04\nTensorFlow installed from (source or binary): using pip3\nTensorFlow version (use command below): git version: v1.8.0-0-g93bc2e2072 tf version 1.8.0\nPython version: 3.5.2\nCUDA/cuDNN version: not using (because of old GPU)\nGPU model and memory: geforce 265\nExact command to reproduce:\n\n\nConvert a graph using tf.graph_util.convert_variables_to_constants\nImport resulting graph using tf.import_graph_def\nEval the variables you want\n(4. you get \"None\" on eval)\n\nThe problem\nAfter converting variables to constant\nImporting the graph_def results in a graph that always eval to None\n# minimal testing\nwith tf.Graph().as_default() as graphy:\n    with tf.Session() as sessy:\n        # declaring placeholder\n        place_holder = tf.placeholder(dtype=tf.float32,shape=[3])\n        tmp_feed = {place_holder:[1,1,1]}\n        \n        # declaring vars and outputs\n        rand = tf.random_uniform([3])\n        the_var = tf.Variable(rand,name=\"the_var\") # depend only on var\n        out = tf.add(the_var,place_holder, name=\"the_result_node\") # depend on var and placeholder\n        out2 = tf.multiply(place_holder,2.0, name=\"the_place_holder\") # depend only on placeholder\n        \n        # getting names of outputs & vars\n        out_tensor = [the_var,out,out2]\n        out_names = [t.name.split(\":\")[0] for t in out_tensor]\n        var_names = [place_holder.name.split(\":\")[0]] # setting place_holder as blacklist as it must not be replaced by a constant ( doing this or not doesn't change result)\n        \n        # doing a first run to get a run comparison \n        sessy.run(tf.global_variables_initializer())\n        for t in out_tensor:\n            print(\"first eval\",t.name,sessy.run(t, feed_dict=tmp_feed))\n        \n        # freezing the graph\n        frozen_graphy = tf.graph_util.convert_variables_to_constants(\n                                                sess=sessy,\n                                                 input_graph_def=graphy.as_graph_def(),\n                                                 output_node_names=out_names,\n                                                 variable_names_blacklist=var_names)\n        print(\"freezing done, exported:\", out_names)\n        \n        # session has been closed seemingly by the convert\n            \n    # eval to check if the graph was actually modified. < return different values >\n    with tf.Session(graph=graphy) as sessu:\n        sessu.run(tf.global_variables_initializer())\n        for t in out_tensor:\n            print(\"second eval of graph1\",t.name,sessu.run(t, feed_dict=tmp_feed))\n        \n\n#print(frozen_graphy) # just checking what it look like\n\nprefixe = \"frozen_import\"\nwith tf.Graph().as_default() as grapho:\n    with tf.Session() as sesso:\n        print(\"importing frozen graph vars:\", out_names)\n        out_list = tf.import_graph_def(frozen_graphy,return_elements=out_names,name=prefixe)\n        print(\"outlist:\",out_list)\n        \n        # creating the feed dict for the placeholder\n        input_name = prefixe+\"/\"+var_names[0]\n        frozen_feed_dict={input_name+\":0\":[1,1,1]}\n        \n        # second eval to compare < return None >\n        sesso.run(tf.global_variables_initializer())\n        for t in out_list:\n            print(t.name,\" =\",sesso.run(t,feed_dict=frozen_feed_dict))\n            \n        # eval of placeholder: < return its value >\n        p_h = grapho.get_tensor_by_name(input_name+\":0\")\n        print(p_h.name, sesso.run(p_h, feed_dict=frozen_feed_dict))", "body": "### System information\r\n- **Have I written custom code (as opposed to using a stock example script provided in TensorFlow)**:\r\nYes, minimal example below\r\n- **OS Platform and Distribution**:Linux Ubuntu 16.04\r\n- **TensorFlow installed from (source or binary)**: using pip3\r\n- **TensorFlow version (use command below)**: git version: v1.8.0-0-g93bc2e2072 tf version 1.8.0\r\n- **Python version**: 3.5.2\r\n- **CUDA/cuDNN version**: not using (because of old GPU)\r\n- **GPU model and memory**: geforce 265\r\n- **Exact command to reproduce**:\r\n1. Convert a graph using tf.graph_util.convert_variables_to_constants\r\n2. Import resulting graph using tf.import_graph_def\r\n3. Eval the variables you want\r\n(4. you get \"None\" on eval)\r\n\r\n### The problem\r\nAfter converting variables to constant\r\nImporting the graph_def results in a graph that always eval to None\r\n\r\n```\r\n# minimal testing\r\nwith tf.Graph().as_default() as graphy:\r\n    with tf.Session() as sessy:\r\n        # declaring placeholder\r\n        place_holder = tf.placeholder(dtype=tf.float32,shape=[3])\r\n        tmp_feed = {place_holder:[1,1,1]}\r\n        \r\n        # declaring vars and outputs\r\n        rand = tf.random_uniform([3])\r\n        the_var = tf.Variable(rand,name=\"the_var\") # depend only on var\r\n        out = tf.add(the_var,place_holder, name=\"the_result_node\") # depend on var and placeholder\r\n        out2 = tf.multiply(place_holder,2.0, name=\"the_place_holder\") # depend only on placeholder\r\n        \r\n        # getting names of outputs & vars\r\n        out_tensor = [the_var,out,out2]\r\n        out_names = [t.name.split(\":\")[0] for t in out_tensor]\r\n        var_names = [place_holder.name.split(\":\")[0]] # setting place_holder as blacklist as it must not be replaced by a constant ( doing this or not doesn't change result)\r\n        \r\n        # doing a first run to get a run comparison \r\n        sessy.run(tf.global_variables_initializer())\r\n        for t in out_tensor:\r\n            print(\"first eval\",t.name,sessy.run(t, feed_dict=tmp_feed))\r\n        \r\n        # freezing the graph\r\n        frozen_graphy = tf.graph_util.convert_variables_to_constants(\r\n                                                sess=sessy,\r\n                                                 input_graph_def=graphy.as_graph_def(),\r\n                                                 output_node_names=out_names,\r\n                                                 variable_names_blacklist=var_names)\r\n        print(\"freezing done, exported:\", out_names)\r\n        \r\n        # session has been closed seemingly by the convert\r\n            \r\n    # eval to check if the graph was actually modified. < return different values >\r\n    with tf.Session(graph=graphy) as sessu:\r\n        sessu.run(tf.global_variables_initializer())\r\n        for t in out_tensor:\r\n            print(\"second eval of graph1\",t.name,sessu.run(t, feed_dict=tmp_feed))\r\n        \r\n\r\n#print(frozen_graphy) # just checking what it look like\r\n\r\nprefixe = \"frozen_import\"\r\nwith tf.Graph().as_default() as grapho:\r\n    with tf.Session() as sesso:\r\n        print(\"importing frozen graph vars:\", out_names)\r\n        out_list = tf.import_graph_def(frozen_graphy,return_elements=out_names,name=prefixe)\r\n        print(\"outlist:\",out_list)\r\n        \r\n        # creating the feed dict for the placeholder\r\n        input_name = prefixe+\"/\"+var_names[0]\r\n        frozen_feed_dict={input_name+\":0\":[1,1,1]}\r\n        \r\n        # second eval to compare < return None >\r\n        sesso.run(tf.global_variables_initializer())\r\n        for t in out_list:\r\n            print(t.name,\" =\",sesso.run(t,feed_dict=frozen_feed_dict))\r\n            \r\n        # eval of placeholder: < return its value >\r\n        p_h = grapho.get_tensor_by_name(input_name+\":0\")\r\n        print(p_h.name, sesso.run(p_h, feed_dict=frozen_feed_dict))\r\n```\r\n"}