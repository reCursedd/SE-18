{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/324373409", "html_url": "https://github.com/tensorflow/tensorflow/pull/12397#issuecomment-324373409", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/12397", "id": 324373409, "node_id": "MDEyOklzc3VlQ29tbWVudDMyNDM3MzQwOQ==", "user": {"login": "theflofly", "id": 3902382, "node_id": "MDQ6VXNlcjM5MDIzODI=", "avatar_url": "https://avatars1.githubusercontent.com/u/3902382?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theflofly", "html_url": "https://github.com/theflofly", "followers_url": "https://api.github.com/users/theflofly/followers", "following_url": "https://api.github.com/users/theflofly/following{/other_user}", "gists_url": "https://api.github.com/users/theflofly/gists{/gist_id}", "starred_url": "https://api.github.com/users/theflofly/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theflofly/subscriptions", "organizations_url": "https://api.github.com/users/theflofly/orgs", "repos_url": "https://api.github.com/users/theflofly/repos", "events_url": "https://api.github.com/users/theflofly/events{/privacy}", "received_events_url": "https://api.github.com/users/theflofly/received_events", "type": "User", "site_admin": false}, "created_at": "2017-08-23T15:31:39Z", "updated_at": "2017-08-23T15:31:39Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=88808\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/skye\">@skye</a>: I made changes in the gradient computation method to handle the case you outlined, I create a vector of boolean called <code>reachable_nodes</code> that I initialize doing a BFS from output to input. When counting how many node should be backpropagated for a given node, I only count it if <code>reachable_nodes[node id]</code> is equals to true. The same thing is done in the python gradient method.</p>\n<p>I added two more test cases for the case you outlined.</p>\n<p>I did not remove the stuff about <code>ThreeNodeVariable</code> because even if Const is simpler to use, it is particularly because we used Const and not Variable that we didn't see this bug before. I'll wait for your comment on that last point.</p>", "body_text": "@skye: I made changes in the gradient computation method to handle the case you outlined, I create a vector of boolean called reachable_nodes that I initialize doing a BFS from output to input. When counting how many node should be backpropagated for a given node, I only count it if reachable_nodes[node id] is equals to true. The same thing is done in the python gradient method.\nI added two more test cases for the case you outlined.\nI did not remove the stuff about ThreeNodeVariable because even if Const is simpler to use, it is particularly because we used Const and not Variable that we didn't see this bug before. I'll wait for your comment on that last point.", "body": "@skye: I made changes in the gradient computation method to handle the case you outlined, I create a vector of boolean called `reachable_nodes` that I initialize doing a BFS from output to input. When counting how many node should be backpropagated for a given node, I only count it if `reachable_nodes[node id]` is equals to true. The same thing is done in the python gradient method.\r\n\r\nI added two more test cases for the case you outlined.\r\n\r\nI did not remove the stuff about `ThreeNodeVariable` because even if Const is simpler to use, it is particularly because we used Const and not Variable that we didn't see this bug before. I'll wait for your comment on that last point."}