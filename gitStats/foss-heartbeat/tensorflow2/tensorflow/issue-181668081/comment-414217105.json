{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/414217105", "html_url": "https://github.com/tensorflow/tensorflow/issues/4820#issuecomment-414217105", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/4820", "id": 414217105, "node_id": "MDEyOklzc3VlQ29tbWVudDQxNDIxNzEwNQ==", "user": {"login": "whjiang", "id": 5162753, "node_id": "MDQ6VXNlcjUxNjI3NTM=", "avatar_url": "https://avatars1.githubusercontent.com/u/5162753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/whjiang", "html_url": "https://github.com/whjiang", "followers_url": "https://api.github.com/users/whjiang/followers", "following_url": "https://api.github.com/users/whjiang/following{/other_user}", "gists_url": "https://api.github.com/users/whjiang/gists{/gist_id}", "starred_url": "https://api.github.com/users/whjiang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/whjiang/subscriptions", "organizations_url": "https://api.github.com/users/whjiang/orgs", "repos_url": "https://api.github.com/users/whjiang/repos", "events_url": "https://api.github.com/users/whjiang/events{/privacy}", "received_events_url": "https://api.github.com/users/whjiang/received_events", "type": "User", "site_admin": false}, "created_at": "2018-08-20T07:03:39Z", "updated_at": "2018-08-20T07:08:18Z", "author_association": "NONE", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=5105569\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/suiyuan2009\">@suiyuan2009</a><br>\nBelow is a test that can reproduce:<br>\nWe want to make a call from C++ to python and TF. Thus, an embedded python interpreter is used.<br>\nHowever, the Py_EndInterpreter call fails with error message:</p>\n<blockquote>\n<p>Fatal Python error: Py_EndInterpreter: not the last thread</p>\n</blockquote>\n<p>This is because there is a daemon thread _EventLoggerThread is still running after the python script finishes.</p>\n<p>The output of this test is:</p>\n<blockquote>\n<p>[33, 67.0]<br>\n[&lt;_MainThread(MainThread, started 140735723737984)&gt;, &lt;_EventLoggerThread(Thread-1, started daemon 123145450090496)&gt;]<br>\nFatal Python error: Py_EndInterpreter: not the last thread</p>\n</blockquote>\n<p>test.py file:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-c\"><span class=\"pl-c\">#</span> import logging as logger</span>\n<span class=\"pl-k\">import</span> sys\n<span class=\"pl-k\">import</span> time\n<span class=\"pl-k\">import</span> tensorflow <span class=\"pl-k\">as</span> tf\n<span class=\"pl-k\">from</span> tensorflow.python.platform <span class=\"pl-k\">import</span> tf_logging <span class=\"pl-k\">as</span> logging\n<span class=\"pl-k\">from</span> tensorflow.python.client <span class=\"pl-k\">import</span> timeline\n<span class=\"pl-k\">import</span> threading\n\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">Train</span>(<span class=\"pl-c1\">object</span>):\n\n    <span class=\"pl-k\">def</span> <span class=\"pl-en\">run</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>):\n        v <span class=\"pl-k\">=</span> tf.Variable(<span class=\"pl-v\">dtype</span><span class=\"pl-k\">=</span>tf.float32, <span class=\"pl-v\">initial_value</span><span class=\"pl-k\">=</span>tf.constant(<span class=\"pl-c1\">1.0</span>))\n        a <span class=\"pl-k\">=</span> tf.placeholder(tf.float32, <span class=\"pl-v\">shape</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">None</span>, <span class=\"pl-v\">name</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span>a<span class=\"pl-pds\">\"</span></span>)\n        b <span class=\"pl-k\">=</span> tf.reduce_mean(a, <span class=\"pl-v\">name</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span>b<span class=\"pl-pds\">\"</span></span>)\n        c <span class=\"pl-k\">=</span> tf.add(b, v, <span class=\"pl-v\">name</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span>c<span class=\"pl-pds\">\"</span></span>)\n        add <span class=\"pl-k\">=</span> tf.assign(v, c, <span class=\"pl-v\">name</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span>assign<span class=\"pl-pds\">\"</span></span>)\n        global_step <span class=\"pl-k\">=</span> tf.contrib.framework.get_or_create_global_step()\n        <span class=\"pl-c1\">sum</span> <span class=\"pl-k\">=</span> tf.summary.scalar(<span class=\"pl-v\">name</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span>sum<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-v\">tensor</span><span class=\"pl-k\">=</span>c)\n        global_step_inc <span class=\"pl-k\">=</span> tf.assign_add(global_step, <span class=\"pl-c1\">1</span>)\n        hooks <span class=\"pl-k\">=</span> [tf.train.StopAtStepHook(<span class=\"pl-v\">last_step</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">20</span>)]\n        ckpt_dir <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>./tmp/s1/<span class=\"pl-pds\">'</span></span>\n        logging.info(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>begin run<span class=\"pl-pds\">'</span></span>)\n        <span class=\"pl-k\">with</span> tf.train.MonitoredTrainingSession(<span class=\"pl-v\">checkpoint_dir</span><span class=\"pl-k\">=</span>ckpt_dir, <span class=\"pl-v\">hooks</span><span class=\"pl-k\">=</span>hooks) <span class=\"pl-k\">as</span> mon_sess:\n            <span class=\"pl-k\">while</span> <span class=\"pl-k\">not</span> mon_sess.should_stop():\n                <span class=\"pl-c1\">print</span> (mon_sess.run([global_step_inc, add], <span class=\"pl-v\">feed_dict</span><span class=\"pl-k\">=</span>{a: [<span class=\"pl-c1\">1.0</span>, <span class=\"pl-c1\">2.0</span>, <span class=\"pl-c1\">3.0</span>]}))\n        logging.info(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>[finish run]<span class=\"pl-pds\">'</span></span>)\n\n\n<span class=\"pl-k\">if</span> <span class=\"pl-c1\">__name__</span> <span class=\"pl-k\">==</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>__main__<span class=\"pl-pds\">\"</span></span>:\n    <span class=\"pl-c1\">print</span>(sys.version)\n    Train().run()\n    <span class=\"pl-c1\">print</span> threading.enumerate()</pre></div>\n<p>And the test cpp code:</p>\n<div class=\"highlight highlight-source-c++\"><pre>#<span class=\"pl-k\">include</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Python.h<span class=\"pl-pds\">\"</span></span>\n#<span class=\"pl-k\">include</span><span class=\"pl-s\"><span class=\"pl-pds\">&lt;</span>iostream<span class=\"pl-pds\">&gt;</span></span>\n\n<span class=\"pl-k\">int</span> <span class=\"pl-en\">main</span>(<span class=\"pl-k\">int</span> argc, <span class=\"pl-k\">char</span>* argv[]) {\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span> initialize Python</span>\n    <span class=\"pl-c1\">Py_Initialize</span>() ;\n    <span class=\"pl-c1\">PyEval_InitThreads</span>() ; <span class=\"pl-c\"><span class=\"pl-c\">//</span> nb: creates and locks the GIL</span>\n    PyThreadState* state = <span class=\"pl-c1\">PyThreadState_Get</span>();\n    <span class=\"pl-c1\">PyEval_ReleaseThread</span>(state);\n\n    <span class=\"pl-c1\">PyEval_AcquireThread</span>(state);\n\n    <span class=\"pl-k\">const</span> <span class=\"pl-k\">char</span>* pythonFileName = argv[<span class=\"pl-c1\">1</span>];\n    <span class=\"pl-c1\">FILE</span>* to_run_script= <span class=\"pl-c1\">fopen</span>(pythonFileName, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>r<span class=\"pl-pds\">\"</span></span>);\n    std::cout &lt;&lt; <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Run file <span class=\"pl-pds\">\"</span></span> &lt;&lt; pythonFileName &lt;&lt; std::endl;\n    PyObject * main_module = <span class=\"pl-c1\">PyImport_ImportModule</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>__main__<span class=\"pl-pds\">\"</span></span>);\n    PyObject* global_symbol_table = <span class=\"pl-c1\">PyModule_GetDict</span>(main_module);;\n    <span class=\"pl-k\">if</span> (to_run_script != <span class=\"pl-c1\">NULL</span>) {\n        <span class=\"pl-c1\">PyRun_File</span>(to_run_script, pythonFileName, Py_file_input, global_symbol_table, global_symbol_table);\n\n        <span class=\"pl-c\"><span class=\"pl-c\">//</span> if python side has daemon thread. Py_EndInterpreter will throw 'not the last thread' exception.</span>\n        <span class=\"pl-c1\">Py_EndInterpreter</span>(state);\n\n        <span class=\"pl-k\">if</span> (!<span class=\"pl-c1\">PyErr_Occurred</span>()) {\n            <span class=\"pl-k\">return</span> <span class=\"pl-c1\">0</span>;\n        }<span class=\"pl-k\">else</span> {\n            <span class=\"pl-c1\">PyErr_PrintEx</span>(<span class=\"pl-c1\">1</span>);\n        }\n    }\n    <span class=\"pl-c1\">PyEval_ReleaseThread</span>(state);\n    <span class=\"pl-c1\">Py_Finalize</span>() ;\n}</pre></div>", "body_text": "@suiyuan2009\nBelow is a test that can reproduce:\nWe want to make a call from C++ to python and TF. Thus, an embedded python interpreter is used.\nHowever, the Py_EndInterpreter call fails with error message:\n\nFatal Python error: Py_EndInterpreter: not the last thread\n\nThis is because there is a daemon thread _EventLoggerThread is still running after the python script finishes.\nThe output of this test is:\n\n[33, 67.0]\n[<_MainThread(MainThread, started 140735723737984)>, <_EventLoggerThread(Thread-1, started daemon 123145450090496)>]\nFatal Python error: Py_EndInterpreter: not the last thread\n\ntest.py file:\n# import logging as logger\nimport sys\nimport time\nimport tensorflow as tf\nfrom tensorflow.python.platform import tf_logging as logging\nfrom tensorflow.python.client import timeline\nimport threading\n\nclass Train(object):\n\n    def run(self):\n        v = tf.Variable(dtype=tf.float32, initial_value=tf.constant(1.0))\n        a = tf.placeholder(tf.float32, shape=None, name=\"a\")\n        b = tf.reduce_mean(a, name=\"b\")\n        c = tf.add(b, v, name=\"c\")\n        add = tf.assign(v, c, name=\"assign\")\n        global_step = tf.contrib.framework.get_or_create_global_step()\n        sum = tf.summary.scalar(name=\"sum\", tensor=c)\n        global_step_inc = tf.assign_add(global_step, 1)\n        hooks = [tf.train.StopAtStepHook(last_step=20)]\n        ckpt_dir = './tmp/s1/'\n        logging.info('begin run')\n        with tf.train.MonitoredTrainingSession(checkpoint_dir=ckpt_dir, hooks=hooks) as mon_sess:\n            while not mon_sess.should_stop():\n                print (mon_sess.run([global_step_inc, add], feed_dict={a: [1.0, 2.0, 3.0]}))\n        logging.info('[finish run]')\n\n\nif __name__ == \"__main__\":\n    print(sys.version)\n    Train().run()\n    print threading.enumerate()\nAnd the test cpp code:\n#include \"Python.h\"\n#include<iostream>\n\nint main(int argc, char* argv[]) {\n    // initialize Python\n    Py_Initialize() ;\n    PyEval_InitThreads() ; // nb: creates and locks the GIL\n    PyThreadState* state = PyThreadState_Get();\n    PyEval_ReleaseThread(state);\n\n    PyEval_AcquireThread(state);\n\n    const char* pythonFileName = argv[1];\n    FILE* to_run_script= fopen(pythonFileName, \"r\");\n    std::cout << \"Run file \" << pythonFileName << std::endl;\n    PyObject * main_module = PyImport_ImportModule(\"__main__\");\n    PyObject* global_symbol_table = PyModule_GetDict(main_module);;\n    if (to_run_script != NULL) {\n        PyRun_File(to_run_script, pythonFileName, Py_file_input, global_symbol_table, global_symbol_table);\n\n        // if python side has daemon thread. Py_EndInterpreter will throw 'not the last thread' exception.\n        Py_EndInterpreter(state);\n\n        if (!PyErr_Occurred()) {\n            return 0;\n        }else {\n            PyErr_PrintEx(1);\n        }\n    }\n    PyEval_ReleaseThread(state);\n    Py_Finalize() ;\n}", "body": "@suiyuan2009 \r\nBelow is a test that can reproduce:\r\nWe want to make a call from C++ to python and TF. Thus, an embedded python interpreter is used. \r\nHowever, the Py_EndInterpreter call fails with error message: \r\n\r\n> Fatal Python error: Py_EndInterpreter: not the last thread\r\n\r\nThis is because there is a daemon thread _EventLoggerThread is still running after the python script finishes. \r\n\r\nThe output of this test is:\r\n>[33, 67.0]\r\n>[<_MainThread(MainThread, started 140735723737984)>, <_EventLoggerThread(Thread-1, started daemon 123145450090496)>]\r\n>Fatal Python error: Py_EndInterpreter: not the last thread\r\n\r\n\r\ntest.py file:\r\n```python\r\n# import logging as logger\r\nimport sys\r\nimport time\r\nimport tensorflow as tf\r\nfrom tensorflow.python.platform import tf_logging as logging\r\nfrom tensorflow.python.client import timeline\r\nimport threading\r\n\r\nclass Train(object):\r\n\r\n    def run(self):\r\n        v = tf.Variable(dtype=tf.float32, initial_value=tf.constant(1.0))\r\n        a = tf.placeholder(tf.float32, shape=None, name=\"a\")\r\n        b = tf.reduce_mean(a, name=\"b\")\r\n        c = tf.add(b, v, name=\"c\")\r\n        add = tf.assign(v, c, name=\"assign\")\r\n        global_step = tf.contrib.framework.get_or_create_global_step()\r\n        sum = tf.summary.scalar(name=\"sum\", tensor=c)\r\n        global_step_inc = tf.assign_add(global_step, 1)\r\n        hooks = [tf.train.StopAtStepHook(last_step=20)]\r\n        ckpt_dir = './tmp/s1/'\r\n        logging.info('begin run')\r\n        with tf.train.MonitoredTrainingSession(checkpoint_dir=ckpt_dir, hooks=hooks) as mon_sess:\r\n            while not mon_sess.should_stop():\r\n                print (mon_sess.run([global_step_inc, add], feed_dict={a: [1.0, 2.0, 3.0]}))\r\n        logging.info('[finish run]')\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    print(sys.version)\r\n    Train().run()\r\n    print threading.enumerate()\r\n```\r\n\r\nAnd the test cpp code:\r\n\r\n```cpp\r\n#include \"Python.h\"\r\n#include<iostream>\r\n\r\nint main(int argc, char* argv[]) {\r\n    // initialize Python\r\n    Py_Initialize() ;\r\n    PyEval_InitThreads() ; // nb: creates and locks the GIL\r\n    PyThreadState* state = PyThreadState_Get();\r\n    PyEval_ReleaseThread(state);\r\n\r\n    PyEval_AcquireThread(state);\r\n\r\n    const char* pythonFileName = argv[1];\r\n    FILE* to_run_script= fopen(pythonFileName, \"r\");\r\n    std::cout << \"Run file \" << pythonFileName << std::endl;\r\n    PyObject * main_module = PyImport_ImportModule(\"__main__\");\r\n    PyObject* global_symbol_table = PyModule_GetDict(main_module);;\r\n    if (to_run_script != NULL) {\r\n        PyRun_File(to_run_script, pythonFileName, Py_file_input, global_symbol_table, global_symbol_table);\r\n\r\n        // if python side has daemon thread. Py_EndInterpreter will throw 'not the last thread' exception.\r\n        Py_EndInterpreter(state);\r\n\r\n        if (!PyErr_Occurred()) {\r\n            return 0;\r\n        }else {\r\n            PyErr_PrintEx(1);\r\n        }\r\n    }\r\n    PyEval_ReleaseThread(state);\r\n    Py_Finalize() ;\r\n}\r\n```"}