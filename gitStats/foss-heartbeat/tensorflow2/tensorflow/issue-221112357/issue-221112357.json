{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9150", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9150/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9150/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9150/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/9150", "id": 221112357, "node_id": "MDU6SXNzdWUyMjExMTIzNTc=", "number": 9150, "title": "C API Tensors", "user": {"login": "eaplatanios", "id": 1294940, "node_id": "MDQ6VXNlcjEyOTQ5NDA=", "avatar_url": "https://avatars2.githubusercontent.com/u/1294940?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eaplatanios", "html_url": "https://github.com/eaplatanios", "followers_url": "https://api.github.com/users/eaplatanios/followers", "following_url": "https://api.github.com/users/eaplatanios/following{/other_user}", "gists_url": "https://api.github.com/users/eaplatanios/gists{/gist_id}", "starred_url": "https://api.github.com/users/eaplatanios/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eaplatanios/subscriptions", "organizations_url": "https://api.github.com/users/eaplatanios/orgs", "repos_url": "https://api.github.com/users/eaplatanios/repos", "events_url": "https://api.github.com/users/eaplatanios/events{/privacy}", "received_events_url": "https://api.github.com/users/eaplatanios/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 299643928, "node_id": "MDU6TGFiZWwyOTk2NDM5Mjg=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:contributions%20welcome", "name": "stat:contributions welcome", "color": "f4b400", "default": false}, {"id": 473173272, "node_id": "MDU6TGFiZWw0NzMxNzMyNzI=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:feature", "name": "type:feature", "color": "159b2e", "default": false}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 60, "created_at": "2017-04-11T23:49:14Z", "updated_at": "2017-08-15T19:34:51Z", "closed_at": null, "author_association": "CONTRIBUTOR", "body_html": "<p>I am currently using the C API and building a Scala API on top of it. It seems that what is done in the Python API and the Java API is that the tensors fed into sessions are being copied to buffers internal to the native library. I am also currently doing that in the Scala library but I was wondering if we can do the following:</p>\n<p>Let's assume we can share a pointer to the underlying data structure between C and Scala (through a Java NIO DirectMemoryBuffer for example). Then, is there any functionality to obtain a tensor \"view\" that is a slice of that tensor, directly using that buffer? I imagine that since the TF op kernels are implemented in C++, it should be possible to use the StridedSlice op directly on a tensor data structure (without needing to use a session). The same idea can be extended to other ops. So, first of all, is that true?</p>\n<p>Secondly, if it is, where is that functionality available in the C API (or exposed elsewhere) so that I can use it from within my Scala library? I currently do the indexing on the byte buffer myself, but that can be painful for arbitrary slices.</p>\n<p>One main issue with sharing a pointer is how to deal with the Java garbage collector. I haven't figured that out yet, but even if I can't do that, the above comment still applies. How can I use op kernels directly in order to manipulate tensors outside of the symbolic graph? That is useful for languages other than Python, where a library as powerful as numpy is not available.</p>\n<p>Thank you!</p>", "body_text": "I am currently using the C API and building a Scala API on top of it. It seems that what is done in the Python API and the Java API is that the tensors fed into sessions are being copied to buffers internal to the native library. I am also currently doing that in the Scala library but I was wondering if we can do the following:\nLet's assume we can share a pointer to the underlying data structure between C and Scala (through a Java NIO DirectMemoryBuffer for example). Then, is there any functionality to obtain a tensor \"view\" that is a slice of that tensor, directly using that buffer? I imagine that since the TF op kernels are implemented in C++, it should be possible to use the StridedSlice op directly on a tensor data structure (without needing to use a session). The same idea can be extended to other ops. So, first of all, is that true?\nSecondly, if it is, where is that functionality available in the C API (or exposed elsewhere) so that I can use it from within my Scala library? I currently do the indexing on the byte buffer myself, but that can be painful for arbitrary slices.\nOne main issue with sharing a pointer is how to deal with the Java garbage collector. I haven't figured that out yet, but even if I can't do that, the above comment still applies. How can I use op kernels directly in order to manipulate tensors outside of the symbolic graph? That is useful for languages other than Python, where a library as powerful as numpy is not available.\nThank you!", "body": "I am currently using the C API and building a Scala API on top of it. It seems that what is done in the Python API and the Java API is that the tensors fed into sessions are being copied to buffers internal to the native library. I am also currently doing that in the Scala library but I was wondering if we can do the following:\r\n\r\nLet's assume we can share a pointer to the underlying data structure between C and Scala (through a Java NIO DirectMemoryBuffer for example). Then, is there any functionality to obtain a tensor \"view\" that is a slice of that tensor, directly using that buffer? I imagine that since the TF op kernels are implemented in C++, it should be possible to use the StridedSlice op directly on a tensor data structure (without needing to use a session). The same idea can be extended to other ops. So, first of all, is that true?\r\n\r\nSecondly, if it is, where is that functionality available in the C API (or exposed elsewhere) so that I can use it from within my Scala library? I currently do the indexing on the byte buffer myself, but that can be painful for arbitrary slices.\r\n\r\nOne main issue with sharing a pointer is how to deal with the Java garbage collector. I haven't figured that out yet, but even if I can't do that, the above comment still applies. How can I use op kernels directly in order to manipulate tensors outside of the symbolic graph? That is useful for languages other than Python, where a library as powerful as numpy is not available.\r\n\r\nThank you!"}