{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/294027821", "html_url": "https://github.com/tensorflow/tensorflow/issues/9150#issuecomment-294027821", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9150", "id": 294027821, "node_id": "MDEyOklzc3VlQ29tbWVudDI5NDAyNzgyMQ==", "user": {"login": "alextp", "id": 5061, "node_id": "MDQ6VXNlcjUwNjE=", "avatar_url": "https://avatars0.githubusercontent.com/u/5061?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alextp", "html_url": "https://github.com/alextp", "followers_url": "https://api.github.com/users/alextp/followers", "following_url": "https://api.github.com/users/alextp/following{/other_user}", "gists_url": "https://api.github.com/users/alextp/gists{/gist_id}", "starred_url": "https://api.github.com/users/alextp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alextp/subscriptions", "organizations_url": "https://api.github.com/users/alextp/orgs", "repos_url": "https://api.github.com/users/alextp/repos", "events_url": "https://api.github.com/users/alextp/events{/privacy}", "received_events_url": "https://api.github.com/users/alextp/received_events", "type": "User", "site_admin": false}, "created_at": "2017-04-13T21:35:07Z", "updated_at": "2017-04-13T21:35:07Z", "author_association": "MEMBER", "body_html": "<div class=\"email-fragment\">Yes, sounds reasonable. I'd love to see something like this as a pull\nrequest for contrib, as there are other people interested in scala wrappers.</div>\n<span class=\"email-hidden-toggle\"><a href=\"#\">\u2026</a></span><div class=\"email-hidden-reply\">\n<div class=\"email-quoted-reply\">On Thu, Apr 13, 2017 at 2:32 PM, Anthony Platanios ***@***.*** &gt; wrote:\n That sounds good! After looking further into JNI, I suggest the following:\n\n    - Tensors are always backed by a direct ByteBuffer that is created on\n    the Scala/Java side.\n    - They have an \"asNative\" method that (through JNI) calls\n    \"TF_NewTensor\" in the C API. It also the JNI \"NewGlobalRef\" method to\n    create a global reference to the direct ByteBuffer object. This guarantees\n    that as long as TensorFlow native uses that byte buffer, it won't be\n    garbage collected by the JVM. As a deallocator function we provide a\n    function that the JNI \"DeleteGlobalRef\" method on the previously created\n    reference.\n\n And that's the only interaction between the native TensorFlow tensors API\n and the Scala/Java API. The rest of it (i.e., elements access, slicing,\n etc.) is all handled on the Scala side. The same could apply to the current\n Java API and void the copying.\n\n Does that sound reasonable?\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n &lt;<a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"221112357\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/tensorflow/tensorflow/issues/9150\" href=\"https://github.com/tensorflow/tensorflow/issues/9150#issuecomment-294027074\">#9150 (comment)</a>&gt;,\n or mute the thread\n &lt;<a href=\"https://github.com/notifications/unsubscribe-auth/AAATxQ910C4Pw034Gb_yKa2qQNMH2Wlmks5rvpR9gaJpZM4M6yMu\">https://github.com/notifications/unsubscribe-auth/AAATxQ910C4Pw034Gb_yKa2qQNMH2Wlmks5rvpR9gaJpZM4M6yMu</a>&gt;\n .\n</div>\n<div class=\"email-fragment\"></div>\n<div class=\"email-signature-reply\">-- \n - Alex</div>\n</div>", "body_text": "Yes, sounds reasonable. I'd love to see something like this as a pull\nrequest for contrib, as there are other people interested in scala wrappers.\n\u2026\nOn Thu, Apr 13, 2017 at 2:32 PM, Anthony Platanios ***@***.*** > wrote:\n That sounds good! After looking further into JNI, I suggest the following:\n\n    - Tensors are always backed by a direct ByteBuffer that is created on\n    the Scala/Java side.\n    - They have an \"asNative\" method that (through JNI) calls\n    \"TF_NewTensor\" in the C API. It also the JNI \"NewGlobalRef\" method to\n    create a global reference to the direct ByteBuffer object. This guarantees\n    that as long as TensorFlow native uses that byte buffer, it won't be\n    garbage collected by the JVM. As a deallocator function we provide a\n    function that the JNI \"DeleteGlobalRef\" method on the previously created\n    reference.\n\n And that's the only interaction between the native TensorFlow tensors API\n and the Scala/Java API. The rest of it (i.e., elements access, slicing,\n etc.) is all handled on the Scala side. The same could apply to the current\n Java API and void the copying.\n\n Does that sound reasonable?\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#9150 (comment)>,\n or mute the thread\n <https://github.com/notifications/unsubscribe-auth/AAATxQ910C4Pw034Gb_yKa2qQNMH2Wlmks5rvpR9gaJpZM4M6yMu>\n .\n\n\n-- \n - Alex", "body": "Yes, sounds reasonable. I'd love to see something like this as a pull\nrequest for contrib, as there are other people interested in scala wrappers.\n\nOn Thu, Apr 13, 2017 at 2:32 PM, Anthony Platanios <notifications@github.com\n> wrote:\n\n> That sounds good! After looking further into JNI, I suggest the following:\n>\n>    - Tensors are always backed by a direct ByteBuffer that is created on\n>    the Scala/Java side.\n>    - They have an \"asNative\" method that (through JNI) calls\n>    \"TF_NewTensor\" in the C API. It also the JNI \"NewGlobalRef\" method to\n>    create a global reference to the direct ByteBuffer object. This guarantees\n>    that as long as TensorFlow native uses that byte buffer, it won't be\n>    garbage collected by the JVM. As a deallocator function we provide a\n>    function that the JNI \"DeleteGlobalRef\" method on the previously created\n>    reference.\n>\n> And that's the only interaction between the native TensorFlow tensors API\n> and the Scala/Java API. The rest of it (i.e., elements access, slicing,\n> etc.) is all handled on the Scala side. The same could apply to the current\n> Java API and void the copying.\n>\n> Does that sound reasonable?\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tensorflow/tensorflow/issues/9150#issuecomment-294027074>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAATxQ910C4Pw034Gb_yKa2qQNMH2Wlmks5rvpR9gaJpZM4M6yMu>\n> .\n>\n\n\n\n-- \n - Alex\n"}