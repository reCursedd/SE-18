{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/293784345", "html_url": "https://github.com/tensorflow/tensorflow/issues/9150#issuecomment-293784345", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9150", "id": 293784345, "node_id": "MDEyOklzc3VlQ29tbWVudDI5Mzc4NDM0NQ==", "user": {"login": "asimshankar", "id": 16018, "node_id": "MDQ6VXNlcjE2MDE4", "avatar_url": "https://avatars2.githubusercontent.com/u/16018?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asimshankar", "html_url": "https://github.com/asimshankar", "followers_url": "https://api.github.com/users/asimshankar/followers", "following_url": "https://api.github.com/users/asimshankar/following{/other_user}", "gists_url": "https://api.github.com/users/asimshankar/gists{/gist_id}", "starred_url": "https://api.github.com/users/asimshankar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asimshankar/subscriptions", "organizations_url": "https://api.github.com/users/asimshankar/orgs", "repos_url": "https://api.github.com/users/asimshankar/repos", "events_url": "https://api.github.com/users/asimshankar/events{/privacy}", "received_events_url": "https://api.github.com/users/asimshankar/received_events", "type": "User", "site_admin": false}, "created_at": "2017-04-13T05:20:27Z", "updated_at": "2017-04-13T05:55:38Z", "author_association": "MEMBER", "body_html": "<p>The primitive that is offered is <code>TF_TensorData</code>, which provides the raw (flattened) tensor content. You could use that to build other views (using <code>TF_NewTensor</code> and making the buffer deallocation function be a no-op). However, in general, no, being able to invoke kernels directly on tensors and avoiding the symbolic graph is not something that the C API (or the TensorFlow runtime code) currently makes convenient.</p>\n<p>And as you gathered, with the JVM, sharing buffers with the C API will be problematic because of the garbage collector. In the Java API, the private <a href=\"https://github.com/tensorflow/tensorflow/blob/2acba51/tensorflow/java/src/main/java/org/tensorflow/Tensor.java#L472\"><code>Tensor.buffer()</code></a> method provides direct access to the contents of the tensor in the runtime, but using it correctly is tricky (as one must be sure that the garbage collector and C memory management don't interfere with each other). For this reason, it has not been made public.</p>", "body_text": "The primitive that is offered is TF_TensorData, which provides the raw (flattened) tensor content. You could use that to build other views (using TF_NewTensor and making the buffer deallocation function be a no-op). However, in general, no, being able to invoke kernels directly on tensors and avoiding the symbolic graph is not something that the C API (or the TensorFlow runtime code) currently makes convenient.\nAnd as you gathered, with the JVM, sharing buffers with the C API will be problematic because of the garbage collector. In the Java API, the private Tensor.buffer() method provides direct access to the contents of the tensor in the runtime, but using it correctly is tricky (as one must be sure that the garbage collector and C memory management don't interfere with each other). For this reason, it has not been made public.", "body": "The primitive that is offered is `TF_TensorData`, which provides the raw (flattened) tensor content. You could use that to build other views (using `TF_NewTensor` and making the buffer deallocation function be a no-op). However, in general, no, being able to invoke kernels directly on tensors and avoiding the symbolic graph is not something that the C API (or the TensorFlow runtime code) currently makes convenient.\r\n\r\nAnd as you gathered, with the JVM, sharing buffers with the C API will be problematic because of the garbage collector. In the Java API, the private [`Tensor.buffer()`](https://github.com/tensorflow/tensorflow/blob/2acba51/tensorflow/java/src/main/java/org/tensorflow/Tensor.java#L472) method provides direct access to the contents of the tensor in the runtime, but using it correctly is tricky (as one must be sure that the garbage collector and C memory management don't interfere with each other). For this reason, it has not been made public."}