{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/294027074", "html_url": "https://github.com/tensorflow/tensorflow/issues/9150#issuecomment-294027074", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9150", "id": 294027074, "node_id": "MDEyOklzc3VlQ29tbWVudDI5NDAyNzA3NA==", "user": {"login": "eaplatanios", "id": 1294940, "node_id": "MDQ6VXNlcjEyOTQ5NDA=", "avatar_url": "https://avatars2.githubusercontent.com/u/1294940?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eaplatanios", "html_url": "https://github.com/eaplatanios", "followers_url": "https://api.github.com/users/eaplatanios/followers", "following_url": "https://api.github.com/users/eaplatanios/following{/other_user}", "gists_url": "https://api.github.com/users/eaplatanios/gists{/gist_id}", "starred_url": "https://api.github.com/users/eaplatanios/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eaplatanios/subscriptions", "organizations_url": "https://api.github.com/users/eaplatanios/orgs", "repos_url": "https://api.github.com/users/eaplatanios/repos", "events_url": "https://api.github.com/users/eaplatanios/events{/privacy}", "received_events_url": "https://api.github.com/users/eaplatanios/received_events", "type": "User", "site_admin": false}, "created_at": "2017-04-13T21:31:21Z", "updated_at": "2017-04-13T21:31:21Z", "author_association": "CONTRIBUTOR", "body_html": "<p>That sounds good! After looking further into JNI, I suggest the following:</p>\n<ul>\n<li>Tensors are always backed by a direct ByteBuffer that is created on the Scala/Java side.</li>\n<li>They have an \"asNative\" method that (through JNI) calls \"TF_NewTensor\" in the C API. It also the JNI \"NewGlobalRef\" method to create a global reference to the direct ByteBuffer object. This guarantees that as long as TensorFlow native uses that byte buffer, it won't be garbage collected by the JVM. As a deallocator function we provide a function that the JNI \"DeleteGlobalRef\" method on the previously created reference.</li>\n</ul>\n<p>And that's the only interaction between the native TensorFlow tensors API and the Scala/Java API. The rest of it (i.e., elements access, slicing, etc.) is all handled on the Scala side. The same could apply to the current Java API and void the copying.</p>\n<p>Does that sound reasonable?</p>", "body_text": "That sounds good! After looking further into JNI, I suggest the following:\n\nTensors are always backed by a direct ByteBuffer that is created on the Scala/Java side.\nThey have an \"asNative\" method that (through JNI) calls \"TF_NewTensor\" in the C API. It also the JNI \"NewGlobalRef\" method to create a global reference to the direct ByteBuffer object. This guarantees that as long as TensorFlow native uses that byte buffer, it won't be garbage collected by the JVM. As a deallocator function we provide a function that the JNI \"DeleteGlobalRef\" method on the previously created reference.\n\nAnd that's the only interaction between the native TensorFlow tensors API and the Scala/Java API. The rest of it (i.e., elements access, slicing, etc.) is all handled on the Scala side. The same could apply to the current Java API and void the copying.\nDoes that sound reasonable?", "body": "That sounds good! After looking further into JNI, I suggest the following:\r\n\r\n- Tensors are always backed by a direct ByteBuffer that is created on the Scala/Java side.\r\n- They have an \"asNative\" method that (through JNI) calls \"TF_NewTensor\" in the C API. It also the JNI \"NewGlobalRef\" method to create a global reference to the direct ByteBuffer object. This guarantees that as long as TensorFlow native uses that byte buffer, it won't be garbage collected by the JVM. As a deallocator function we provide a function that the JNI \"DeleteGlobalRef\" method on the previously created reference.\r\n\r\nAnd that's the only interaction between the native TensorFlow tensors API and the Scala/Java API. The rest of it (i.e., elements access, slicing, etc.) is all handled on the Scala side. The same could apply to the current Java API and void the copying.\r\n\r\nDoes that sound reasonable?"}