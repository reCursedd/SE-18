{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/314988666", "html_url": "https://github.com/tensorflow/tensorflow/issues/11370#issuecomment-314988666", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11370", "id": 314988666, "node_id": "MDEyOklzc3VlQ29tbWVudDMxNDk4ODY2Ng==", "user": {"login": "christopherhelf", "id": 3281214, "node_id": "MDQ6VXNlcjMyODEyMTQ=", "avatar_url": "https://avatars1.githubusercontent.com/u/3281214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/christopherhelf", "html_url": "https://github.com/christopherhelf", "followers_url": "https://api.github.com/users/christopherhelf/followers", "following_url": "https://api.github.com/users/christopherhelf/following{/other_user}", "gists_url": "https://api.github.com/users/christopherhelf/gists{/gist_id}", "starred_url": "https://api.github.com/users/christopherhelf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/christopherhelf/subscriptions", "organizations_url": "https://api.github.com/users/christopherhelf/orgs", "repos_url": "https://api.github.com/users/christopherhelf/repos", "events_url": "https://api.github.com/users/christopherhelf/events{/privacy}", "received_events_url": "https://api.github.com/users/christopherhelf/received_events", "type": "User", "site_admin": false}, "created_at": "2017-07-13T06:53:06Z", "updated_at": "2017-07-13T14:18:36Z", "author_association": "NONE", "body_html": "<p>Would this be the right approach in general? Or doesn't this work with the depthwise-convolution math?</p>\n<p>So <code>Conv2D</code> has its filters as<br>\n[filter_height, filter_width, in_channels, out_channels]</p>\n<p>while <code>DepthwiseConv2dNative</code> has<br>\n[filter_height, filter_width, in_channels, channel_multiplier]</p>\n<p>So in the simple case of <code>channel_multiplier=1</code>, we have <code>out_channels=in_channels</code>, and <code>mul_values.shape().dim_size(0) == in_channels</code> and something like</p>\n<pre><code>auto weights_mapped = weights.tensor&lt;float, 4&gt;();\nauto scaled_weights_mapped = scaled_weights.tensor&lt;float, 4&gt;();\n\nfor (int64 cm = 0; cm &lt; weights.dim_size(3); ++cm) {\n  for (int64 ic = 0; ic &lt; weights.dim_size(2); ++ic) {\n    for (int64 w = 0; w &lt; weights.dim_size(1); ++w) {\n      for (int64 h = 0; h &lt; weights.dim_size(0); ++h) {\n        scaled_weights_mapped(h,w,ic,cm) = weights_mapped(h,w,ic,cm) * mul_values.flat&lt;float&gt;()(ic);\n      }\n    }\n  }\n}\n</code></pre>", "body_text": "Would this be the right approach in general? Or doesn't this work with the depthwise-convolution math?\nSo Conv2D has its filters as\n[filter_height, filter_width, in_channels, out_channels]\nwhile DepthwiseConv2dNative has\n[filter_height, filter_width, in_channels, channel_multiplier]\nSo in the simple case of channel_multiplier=1, we have out_channels=in_channels, and mul_values.shape().dim_size(0) == in_channels and something like\nauto weights_mapped = weights.tensor<float, 4>();\nauto scaled_weights_mapped = scaled_weights.tensor<float, 4>();\n\nfor (int64 cm = 0; cm < weights.dim_size(3); ++cm) {\n  for (int64 ic = 0; ic < weights.dim_size(2); ++ic) {\n    for (int64 w = 0; w < weights.dim_size(1); ++w) {\n      for (int64 h = 0; h < weights.dim_size(0); ++h) {\n        scaled_weights_mapped(h,w,ic,cm) = weights_mapped(h,w,ic,cm) * mul_values.flat<float>()(ic);\n      }\n    }\n  }\n}", "body": "Would this be the right approach in general? Or doesn't this work with the depthwise-convolution math?\r\n\r\nSo `Conv2D` has its filters as\r\n    [filter_height, filter_width, in_channels, out_channels]\r\n\r\nwhile `DepthwiseConv2dNative` has \r\n    [filter_height, filter_width, in_channels, channel_multiplier]\r\n\r\nSo in the simple case of `channel_multiplier=1`, we have `out_channels=in_channels`, and `mul_values.shape().dim_size(0) == in_channels` and something like\r\n\r\n    auto weights_mapped = weights.tensor<float, 4>();\r\n    auto scaled_weights_mapped = scaled_weights.tensor<float, 4>();\r\n\r\n    for (int64 cm = 0; cm < weights.dim_size(3); ++cm) {\r\n      for (int64 ic = 0; ic < weights.dim_size(2); ++ic) {\r\n        for (int64 w = 0; w < weights.dim_size(1); ++w) {\r\n          for (int64 h = 0; h < weights.dim_size(0); ++h) {\r\n            scaled_weights_mapped(h,w,ic,cm) = weights_mapped(h,w,ic,cm) * mul_values.flat<float>()(ic);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n"}