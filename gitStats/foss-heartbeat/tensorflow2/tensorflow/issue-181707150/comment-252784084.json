{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/252784084", "html_url": "https://github.com/tensorflow/tensorflow/pull/4826#issuecomment-252784084", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/4826", "id": 252784084, "node_id": "MDEyOklzc3VlQ29tbWVudDI1Mjc4NDA4NA==", "user": {"login": "DjangoPeng", "id": 16943353, "node_id": "MDQ6VXNlcjE2OTQzMzUz", "avatar_url": "https://avatars3.githubusercontent.com/u/16943353?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DjangoPeng", "html_url": "https://github.com/DjangoPeng", "followers_url": "https://api.github.com/users/DjangoPeng/followers", "following_url": "https://api.github.com/users/DjangoPeng/following{/other_user}", "gists_url": "https://api.github.com/users/DjangoPeng/gists{/gist_id}", "starred_url": "https://api.github.com/users/DjangoPeng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DjangoPeng/subscriptions", "organizations_url": "https://api.github.com/users/DjangoPeng/orgs", "repos_url": "https://api.github.com/users/DjangoPeng/repos", "events_url": "https://api.github.com/users/DjangoPeng/events{/privacy}", "received_events_url": "https://api.github.com/users/DjangoPeng/received_events", "type": "User", "site_admin": false}, "created_at": "2016-10-11T00:55:18Z", "updated_at": "2016-10-11T16:25:28Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=144114\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/rohan100jain\">@rohan100jain</a> I have updated and it can support for all dtypes including partitioned variables. When I define the function <code>_get_default_initializer()</code>, I found it's hard to cover <code>qint and bfloat</code> dtype. So I want to open a new PR to handle that, cause I think the fixed size dtype is a little different from the other dtypes.</p>\n<h2>Change log\uff1a</h2>\n<h3>variable_scope.py</h3>\n<ul>\n<li>Add a function called <code>_get_default_initializer()</code> handling variables when no initializer provided.</li>\n<li>It both works for single variable and partitioned variables, so you can find there are two calls, one in <code>_get_single_variable()</code>, another in <code>_get_partitioned_variable()</code></li>\n</ul>\n<h3>variable_scope_test.py</h3>\n<ul>\n<li>Add two class for testing single variable and partitioned variables.</li>\n<li>According to dtype, I divided initializer into <code>strings_initializer</code> and <code>zeros_initializer</code>.</li>\n</ul>\n<h3>array_ops.py</h3>\n<ul>\n<li>Add <code>strings()</code> for <code>tf.string</code> to set all elements to ''(empty string) of a tensor</li>\n</ul>\n<h3>init_ops.py</h3>\n<ul>\n<li>Add <code>strings_initializer()</code> for <code>tf.string</code> calling to <code>array_ops.strings()</code>. The definitions are similar to  the <code>init_ops.zeros_initializer()</code> and <code>array_ops.zeros()</code>.</li>\n</ul>\n<h3>dtypes.py</h3>\n<ul>\n<li>Add <code>is_bool()</code> and <code>is_string()</code> function for condition judgement in <code>_get_default_initializer</code></li>\n<li>Adjust the definitions by alphabetical order</li>\n</ul>\n<h3>Supported dtype list</h3>\n<ul>\n<li>tf.float16</li>\n<li>tf.float32</li>\n<li>tf.float64</li>\n<li>tf.int8</li>\n<li>tf.uint8</li>\n<li>tf.int16</li>\n<li>tf.uint16</li>\n<li>tf.int32</li>\n<li>tf.int64</li>\n<li>tf.bool</li>\n<li>tf.complex64</li>\n<li>tf.complex128</li>\n<li>tf.string</li>\n</ul>", "body_text": "@rohan100jain I have updated and it can support for all dtypes including partitioned variables. When I define the function _get_default_initializer(), I found it's hard to cover qint and bfloat dtype. So I want to open a new PR to handle that, cause I think the fixed size dtype is a little different from the other dtypes.\nChange log\uff1a\nvariable_scope.py\n\nAdd a function called _get_default_initializer() handling variables when no initializer provided.\nIt both works for single variable and partitioned variables, so you can find there are two calls, one in _get_single_variable(), another in _get_partitioned_variable()\n\nvariable_scope_test.py\n\nAdd two class for testing single variable and partitioned variables.\nAccording to dtype, I divided initializer into strings_initializer and zeros_initializer.\n\narray_ops.py\n\nAdd strings() for tf.string to set all elements to ''(empty string) of a tensor\n\ninit_ops.py\n\nAdd strings_initializer() for tf.string calling to array_ops.strings(). The definitions are similar to  the init_ops.zeros_initializer() and array_ops.zeros().\n\ndtypes.py\n\nAdd is_bool() and is_string() function for condition judgement in _get_default_initializer\nAdjust the definitions by alphabetical order\n\nSupported dtype list\n\ntf.float16\ntf.float32\ntf.float64\ntf.int8\ntf.uint8\ntf.int16\ntf.uint16\ntf.int32\ntf.int64\ntf.bool\ntf.complex64\ntf.complex128\ntf.string", "body": "@rohan100jain I have updated and it can support for all dtypes including partitioned variables. When I define the function `_get_default_initializer()`, I found it's hard to cover `qint and bfloat` dtype. So I want to open a new PR to handle that, cause I think the fixed size dtype is a little different from the other dtypes. \n\n## Change log\uff1a\n\n### variable_scope.py\n- Add a function called `_get_default_initializer()` handling variables when no initializer provided.\n- It both works for single variable and partitioned variables, so you can find there are two calls, one in `_get_single_variable()`, another in `_get_partitioned_variable()`\n\n### variable_scope_test.py\n- Add two class for testing single variable and partitioned variables.\n- According to dtype, I divided initializer into `strings_initializer` and `zeros_initializer`.\n\n### array_ops.py\n- Add `strings()` for `tf.string` to set all elements to ''(empty string) of a tensor\n\n### init_ops.py\n- Add `strings_initializer()` for `tf.string` calling to `array_ops.strings()`. The definitions are similar to  the `init_ops.zeros_initializer()` and `array_ops.zeros()`.\n\n### dtypes.py\n- Add `is_bool()` and `is_string()` function for condition judgement in `_get_default_initializer`\n- Adjust the definitions by alphabetical order \n\n### Supported dtype list\n- tf.float16\n- tf.float32\n- tf.float64\n- tf.int8\n- tf.uint8\n- tf.int16\n- tf.uint16\n- tf.int32\n- tf.int64\n- tf.bool\n- tf.complex64\n- tf.complex128\n- tf.string \n"}