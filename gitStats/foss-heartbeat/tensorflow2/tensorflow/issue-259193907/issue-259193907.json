{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13185", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13185/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13185/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13185/events", "html_url": "https://github.com/tensorflow/tensorflow/pull/13185", "id": 259193907, "node_id": "MDExOlB1bGxSZXF1ZXN0MTQyMTIxOTg2", "number": 13185, "title": "Fix random crashes in SessionRun()", "user": {"login": "anight", "id": 1214641, "node_id": "MDQ6VXNlcjEyMTQ2NDE=", "avatar_url": "https://avatars3.githubusercontent.com/u/1214641?v=4", "gravatar_id": "", "url": "https://api.github.com/users/anight", "html_url": "https://github.com/anight", "followers_url": "https://api.github.com/users/anight/followers", "following_url": "https://api.github.com/users/anight/following{/other_user}", "gists_url": "https://api.github.com/users/anight/gists{/gist_id}", "starred_url": "https://api.github.com/users/anight/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/anight/subscriptions", "organizations_url": "https://api.github.com/users/anight/orgs", "repos_url": "https://api.github.com/users/anight/repos", "events_url": "https://api.github.com/users/anight/events{/privacy}", "received_events_url": "https://api.github.com/users/anight/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 419840263, "node_id": "MDU6TGFiZWw0MTk4NDAyNjM=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/awaiting%20testing%20(then%20merge)", "name": "awaiting testing (then merge)", "color": "c2e0c6", "default": false}, {"id": 300136587, "node_id": "MDU6TGFiZWwzMDAxMzY1ODc=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/cla:%20yes", "name": "cla: yes", "color": "009800", "default": false}], "state": "closed", "locked": false, "assignee": {"login": "asimshankar", "id": 16018, "node_id": "MDQ6VXNlcjE2MDE4", "avatar_url": "https://avatars2.githubusercontent.com/u/16018?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asimshankar", "html_url": "https://github.com/asimshankar", "followers_url": "https://api.github.com/users/asimshankar/followers", "following_url": "https://api.github.com/users/asimshankar/following{/other_user}", "gists_url": "https://api.github.com/users/asimshankar/gists{/gist_id}", "starred_url": "https://api.github.com/users/asimshankar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asimshankar/subscriptions", "organizations_url": "https://api.github.com/users/asimshankar/orgs", "repos_url": "https://api.github.com/users/asimshankar/repos", "events_url": "https://api.github.com/users/asimshankar/events{/privacy}", "received_events_url": "https://api.github.com/users/asimshankar/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "asimshankar", "id": 16018, "node_id": "MDQ6VXNlcjE2MDE4", "avatar_url": "https://avatars2.githubusercontent.com/u/16018?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asimshankar", "html_url": "https://github.com/asimshankar", "followers_url": "https://api.github.com/users/asimshankar/followers", "following_url": "https://api.github.com/users/asimshankar/following{/other_user}", "gists_url": "https://api.github.com/users/asimshankar/gists{/gist_id}", "starred_url": "https://api.github.com/users/asimshankar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asimshankar/subscriptions", "organizations_url": "https://api.github.com/users/asimshankar/orgs", "repos_url": "https://api.github.com/users/asimshankar/repos", "events_url": "https://api.github.com/users/asimshankar/events{/privacy}", "received_events_url": "https://api.github.com/users/asimshankar/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 4, "created_at": "2017-09-20T14:54:50Z", "updated_at": "2017-10-04T15:02:12Z", "closed_at": "2017-09-20T20:38:21Z", "author_association": "CONTRIBUTOR", "pull_request": {"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/13185", "html_url": "https://github.com/tensorflow/tensorflow/pull/13185", "diff_url": "https://github.com/tensorflow/tensorflow/pull/13185.diff", "patch_url": "https://github.com/tensorflow/tensorflow/pull/13185.patch"}, "body_html": "<p>This patch <span class=\"issue-keyword tooltipped tooltipped-se\" aria-label=\"This pull request closes issue #13129.\">fixes</span> <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"258539637\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/tensorflow/tensorflow/issues/13129\" data-hovercard-type=\"issue\" data-hovercard-url=\"/tensorflow/tensorflow/issues/13129/hovercard\" href=\"https://github.com/tensorflow/tensorflow/issues/13129\">#13129</a></p>\n<p>The problem was with usage of runtime.SetFinalizer() in golang bindings. When a variable become unreferenced GC can harvest it any moment after. According to this <a href=\"https://tip.golang.org/pkg/runtime/#SetFinalizer\" rel=\"nofollow\">https://tip.golang.org/pkg/runtime/#SetFinalizer</a>:</p>\n<blockquote>\n<p>For example, if p points to a struct that contains a file descriptor d, and p has a finalizer that closes that file descriptor, and if the last use of p in a function is a call to syscall.Write(p.d, buf, size), then p may be unreachable as soon as the program enters syscall.Write. The finalizer may run at that moment, closing p.d, causing syscall.Write to fail because it is writing to a closed file descriptor (or, worse, to an entirely different file descriptor opened by a different goroutine). To avoid this problem, call runtime.KeepAlive(p) after the call to syscall.Write.</p>\n</blockquote>\n<p>In our case unreferenced variable was \"feeds\", i.e. input tensors. After investigations I have found out that func (t *Tensor) finalize() { C.TF_DeleteTensor(t.c) } was called a way before SessionRun() was finished and that was the cause of crash in my case.</p>", "body_text": "This patch fixes #13129\nThe problem was with usage of runtime.SetFinalizer() in golang bindings. When a variable become unreferenced GC can harvest it any moment after. According to this https://tip.golang.org/pkg/runtime/#SetFinalizer:\n\nFor example, if p points to a struct that contains a file descriptor d, and p has a finalizer that closes that file descriptor, and if the last use of p in a function is a call to syscall.Write(p.d, buf, size), then p may be unreachable as soon as the program enters syscall.Write. The finalizer may run at that moment, closing p.d, causing syscall.Write to fail because it is writing to a closed file descriptor (or, worse, to an entirely different file descriptor opened by a different goroutine). To avoid this problem, call runtime.KeepAlive(p) after the call to syscall.Write.\n\nIn our case unreferenced variable was \"feeds\", i.e. input tensors. After investigations I have found out that func (t *Tensor) finalize() { C.TF_DeleteTensor(t.c) } was called a way before SessionRun() was finished and that was the cause of crash in my case.", "body": "This patch fixes https://github.com/tensorflow/tensorflow/issues/13129\r\n\r\nThe problem was with usage of runtime.SetFinalizer() in golang bindings. When a variable become unreferenced GC can harvest it any moment after. According to this https://tip.golang.org/pkg/runtime/#SetFinalizer:\r\n\r\n> For example, if p points to a struct that contains a file descriptor d, and p has a finalizer that closes that file descriptor, and if the last use of p in a function is a call to syscall.Write(p.d, buf, size), then p may be unreachable as soon as the program enters syscall.Write. The finalizer may run at that moment, closing p.d, causing syscall.Write to fail because it is writing to a closed file descriptor (or, worse, to an entirely different file descriptor opened by a different goroutine). To avoid this problem, call runtime.KeepAlive(p) after the call to syscall.Write.\r\n\r\nIn our case unreferenced variable was \"feeds\", i.e. input tensors. After investigations I have found out that func (t *Tensor) finalize() { C.TF_DeleteTensor(t.c) } was called a way before SessionRun() was finished and that was the cause of crash in my case.\r\n\r\n"}