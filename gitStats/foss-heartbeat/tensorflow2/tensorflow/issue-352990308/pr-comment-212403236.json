{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/212403236", "pull_request_review_id": 149008816, "id": 212403236, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMjQwMzIzNg==", "diff_hunk": "@@ -0,0 +1,209 @@\n+# Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+# ==============================================================================\n+\"\"\"Estimator classes for TensorForest.\"\"\"\n+from __future__ import absolute_import\n+from __future__ import division\n+from __future__ import print_function\n+\n+import collections\n+\n+from tensorflow.python.estimator import estimator\n+from tensorflow.python.estimator.canned import head as head_lib\n+from tensorflow.python.ops.losses import losses\n+from tensorflow.python.summary import summary\n+from tensorflow.python.feature_column import feature_column as feature_column_lib\n+from tensorflow.python.ops import tensor_forest_ops, math_ops, array_ops\n+\n+from tensorflow.python.util.tf_export import estimator_export\n+\n+_ForestHParams = collections.namedtuple('TreeHParams', [\n+    'num_output',\n+    'n_trees', 'max_nodes', 'num_splits_to_consider',\n+    'split_after_samples', 'is_regression',\n+])\n+\n+TREE_PATHS_PREDICTION_KEY = 'tree_paths'\n+VARIANCE_PREDICTION_KEY = 'prediction_variance'\n+EPSILON = 0.000001\n+\n+\n+def _ensure_logits(head, logits):\n+  # For binary classification problems, convert probabilities to logits.\n+  # Includes hack to get around the fact that a probability might be 0 or\n+  # 1.\n+  if head.logits_dimension == 2:\n+    class_1_probs = array_ops.slice(logits, [0, 1], [-1, 1])\n+  return math_ops.log(\n+      math_ops.maximum(class_1_probs / math_ops.maximum(\n+          1.0 - class_1_probs, EPSILON), EPSILON))\n+\n+\n+def _bt_model_fn(features, labels, mode, head, sorted_feature_columns, forest_hparams, config, name='tensor_forest'):\n+  graph_builder = RandomForestGraphs(\n+      forest_hparams, config)\n+\n+  transformed_features = feature_column_lib._transform_features(\n+      features, sorted_feature_columns)\n+\n+  stacked_feature = array_ops.concat(transformed_features.values(), axis=1)\n+\n+  logits, tree_paths, regression_variance = graph_builder.inference_graph(\n+      stacked_feature)\n+\n+  logits = _ensure_logits(head, logits)\n+\n+  summary.scalar('average_tree_size', graph_builder.average_size())\n+\n+  training_graph = None\n+  # if labels is not None and mode == model_fn_lib.ModeKeys.TRAIN:\n+  #   with ops.control_dependencies([logits.op]):\n+  #     training_graph = control_flow_ops.group(\n+  #         graph_builder.training_graph(\n+  #             transformed_features, labels),\n+  #         state_ops.assign_add(training_util.get_global_step(), 1),\n+  #         name=name)\n+\n+  def _train_op_fn(unused_loss):\n+    return training_graph\n+\n+  estimator_spec = head.create_estimator_spec(\n+      features=features,\n+      mode=mode,\n+      labels=labels,\n+      train_op_fn=_train_op_fn,\n+      logits=logits)\n+\n+  extra_predictions = {\n+      TREE_PATHS_PREDICTION_KEY: tree_paths\n+  }\n+\n+  if not forest_hparams.is_classification:\n+      extra_predictions[VARIANCE_PREDICTION_KEY] = regression_variance,\n+\n+  estimator_spec = estimator_spec._replace(\n+      predictions=estimator_spec.predictions.update(extra_predictions))\n+\n+  return estimator_spec\n+\n+\n+class RandomForestGraphs(object):\n+  \"\"\"Builds TF graphs for random forest training and inference.\"\"\"\n+\n+  def __init__(self,\n+               params,\n+               configs,\n+               tree_configs=None,\n+               tree_stats=None):\n+    self.params = params\n+    self.configs = configs\n+    self.variables = tensor_forest_ops.ForestVariables(\n+        self.params,\n+        tree_configs=tree_configs,\n+        tree_stats=tree_stats)\n+    self.decision_trees = [\n+        RandomDecisionTreeGraphs(self.variables[i], self.params, i)\n+        for i in range(self.params.n_trees)\n+    ]\n+\n+  def inference_graph(self, input_data, **inference_args):\n+    probabilities = []\n+    paths = []\n+    for decision_tree in self.decision_trees:\n+      probs, path = decision_tree.inference_graph(\n+          input_data,\n+          **inference_args)\n+      probabilities.append(probs)\n+      paths.append(path)\n+    # shape of all_predict should be [batch_size, n_trees, num_outputs]\n+    all_predict = array_ops.stack(probabilities, axis=1)\n+    average_values = math_ops.div(\n+        math_ops.reduce_sum(all_predict, 1),\n+        self.params.n_trees,\n+        name='probabilities')\n+    tree_paths = array_ops.stack(paths, axis=1)\n+\n+    expected_squares = math_ops.div(\n+        math_ops.reduce_sum(all_predict * all_predict, 1),\n+        self.params.n_trees)\n+    regression_variance = math_ops.maximum(\n+        0., expected_squares - average_values * average_values)\n+\n+    return average_values, tree_paths, regression_variance\n+\n+  def average_size(self):\n+    sizes = []\n+    for decision_tree in self.decision_trees:\n+      sizes.append(decision_tree.size())\n+    return math_ops.reduce_mean(math_ops.to_float(array_ops.stack(sizes)))\n+\n+\n+class RandomDecisionTreeGraphs(object):\n+  \"\"\"Builds TF graphs for random tree training and inference.\"\"\"\n+\n+  def __init__(self, variables, params, tree_num):\n+    self.variables = variables\n+    self.params = params\n+    self.tree_num = tree_num\n+\n+  def inference_graph(self, input_data):\n+    return tensor_forest_ops.predict(\n+        self.variables.tree,\n+        input_data,\n+        params=self.params)\n+\n+  def size(self):\n+    return tensor_forest_ops.tree_size(self.variables.tree)\n+\n+\n+@estimator_export('estimator.TensorForestClassifier')\n+class TensorForestClassifier(estimator.Estimator):\n+\n+  def __init__(self,\n+               feature_columns,\n+               model_dir=None,\n+               n_classes=2,\n+               label_vocabulary=None,\n+               head=None,\n+               n_trees=100,\n+               max_nodes=1000,\n+               num_splits_to_consider=10,\n+               split_after_samples=250,\n+               config=None):\n+\n+    if head is None:\n+      head = head_lib._binary_logistic_or_multi_class_head(\n+          n_classes=n_classes,\n+          weight_column=None,\n+          label_vocabulary=label_vocabulary,\n+          loss_reduction=losses.Reduction.SUM_OVER_BATCH_SIZE)\n+\n+    forest_hparams = _ForestHParams(\n+        n_classes,\n+        n_trees,\n+        max_nodes,\n+        num_splits_to_consider,\n+        split_after_samples,", "path": "tensorflow/python/estimator/canned/tensor_forest.py", "position": null, "original_position": 197, "commit_id": "8e85fe418aa40e5e4d4d4700dd491f4cbef4b30e", "original_commit_id": "53a8c626c2fd8898be5cf74fa3b5afe14c443641", "user": {"login": "nataliaponomareva", "id": 4313109, "node_id": "MDQ6VXNlcjQzMTMxMDk=", "avatar_url": "https://avatars3.githubusercontent.com/u/4313109?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nataliaponomareva", "html_url": "https://github.com/nataliaponomareva", "followers_url": "https://api.github.com/users/nataliaponomareva/followers", "following_url": "https://api.github.com/users/nataliaponomareva/following{/other_user}", "gists_url": "https://api.github.com/users/nataliaponomareva/gists{/gist_id}", "starred_url": "https://api.github.com/users/nataliaponomareva/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nataliaponomareva/subscriptions", "organizations_url": "https://api.github.com/users/nataliaponomareva/orgs", "repos_url": "https://api.github.com/users/nataliaponomareva/repos", "events_url": "https://api.github.com/users/nataliaponomareva/events{/privacy}", "received_events_url": "https://api.github.com/users/nataliaponomareva/received_events", "type": "User", "site_admin": false}, "body": "split_node_after_samples, as per suggestion on tutorial", "created_at": "2018-08-23T18:00:32Z", "updated_at": "2018-11-13T17:25:40Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/21803#discussion_r212403236", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/21803", "author_association": "NONE", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/212403236"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/21803#discussion_r212403236"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/21803"}}, "body_html": "<p>split_node_after_samples, as per suggestion on tutorial</p>", "body_text": "split_node_after_samples, as per suggestion on tutorial"}