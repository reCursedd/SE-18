{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/1766", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/1766/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/1766/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/1766/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/1766", "id": 145631265, "node_id": "MDU6SXNzdWUxNDU2MzEyNjU=", "number": 1766, "title": "Multi-dimensional argmax and one-hot", "user": {"login": "rlrs", "id": 7533072, "node_id": "MDQ6VXNlcjc1MzMwNzI=", "avatar_url": "https://avatars2.githubusercontent.com/u/7533072?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rlrs", "html_url": "https://github.com/rlrs", "followers_url": "https://api.github.com/users/rlrs/followers", "following_url": "https://api.github.com/users/rlrs/following{/other_user}", "gists_url": "https://api.github.com/users/rlrs/gists{/gist_id}", "starred_url": "https://api.github.com/users/rlrs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rlrs/subscriptions", "organizations_url": "https://api.github.com/users/rlrs/orgs", "repos_url": "https://api.github.com/users/rlrs/repos", "events_url": "https://api.github.com/users/rlrs/events{/privacy}", "received_events_url": "https://api.github.com/users/rlrs/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2016-04-04T09:32:47Z", "updated_at": "2016-04-04T23:59:51Z", "closed_at": "2016-04-04T23:59:51Z", "author_association": "NONE", "body_html": "<p>This is a feature request, unless someone can show me how the following might be done with the current API.</p>\n<p>Say I have a tensor WxHxD, and I want to keep only the largest element in each WxH slice, setting the rest to zero. These indices could be obtained in numpy by doing something like<br>\n<code>(row,col) = np.unravel_index(A.argmax(), A.shape)</code><br>\non each slice WxH slice A.<br>\nCollecting the D row and column indices, I could create a boolean mask using advanced indexing<br>\n<code>mask[rows,cols, range(D)] = 1</code><br>\nThen, an elementwise multiplication between the WxHxD tensor and the mask gives the desired tensor.</p>", "body_text": "This is a feature request, unless someone can show me how the following might be done with the current API.\nSay I have a tensor WxHxD, and I want to keep only the largest element in each WxH slice, setting the rest to zero. These indices could be obtained in numpy by doing something like\n(row,col) = np.unravel_index(A.argmax(), A.shape)\non each slice WxH slice A.\nCollecting the D row and column indices, I could create a boolean mask using advanced indexing\nmask[rows,cols, range(D)] = 1\nThen, an elementwise multiplication between the WxHxD tensor and the mask gives the desired tensor.", "body": "This is a feature request, unless someone can show me how the following might be done with the current API.\n\nSay I have a tensor WxHxD, and I want to keep only the largest element in each WxH slice, setting the rest to zero. These indices could be obtained in numpy by doing something like\n`(row,col) = np.unravel_index(A.argmax(), A.shape)`\non each slice WxH slice A.\nCollecting the D row and column indices, I could create a boolean mask using advanced indexing\n`mask[rows,cols, range(D)] = 1`\nThen, an elementwise multiplication between the WxHxD tensor and the mask gives the desired tensor.\n"}