{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/20481", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/20481/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/20481/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/20481/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/20481", "id": 337614957, "node_id": "MDU6SXNzdWUzMzc2MTQ5NTc=", "number": 20481, "title": "tf.data.Dataset.from_tensor_slices incompatible with tuples?", "user": {"login": "patzm", "id": 5219726, "node_id": "MDQ6VXNlcjUyMTk3MjY=", "avatar_url": "https://avatars1.githubusercontent.com/u/5219726?v=4", "gravatar_id": "", "url": "https://api.github.com/users/patzm", "html_url": "https://github.com/patzm", "followers_url": "https://api.github.com/users/patzm/followers", "following_url": "https://api.github.com/users/patzm/following{/other_user}", "gists_url": "https://api.github.com/users/patzm/gists{/gist_id}", "starred_url": "https://api.github.com/users/patzm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/patzm/subscriptions", "organizations_url": "https://api.github.com/users/patzm/orgs", "repos_url": "https://api.github.com/users/patzm/repos", "events_url": "https://api.github.com/users/patzm/events{/privacy}", "received_events_url": "https://api.github.com/users/patzm/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2018-07-02T18:13:55Z", "updated_at": "2018-07-02T22:24:56Z", "closed_at": "2018-07-02T22:24:56Z", "author_association": "CONTRIBUTOR", "body_html": "<h3>System information</h3>\n<ul>\n<li><strong>Have I written custom code (as opposed to using a stock example script provided in TensorFlow)</strong>: no</li>\n<li><strong>OS Platform and Distribution (e.g., Linux Ubuntu 16.04)</strong>: Linux Ubuntu 16.04 and 18.04</li>\n<li><strong>TensorFlow installed from (source or binary)</strong>: binary</li>\n<li><strong>TensorFlow version (use command below)</strong>: <code>1.8.0</code></li>\n<li><strong>Python version</strong>: <code>2.7</code></li>\n<li><strong>CUDA/cuDNN version</strong>: 9.0 / 7.5 but also failing in CPU-only mode</li>\n<li><strong>GPU model and memory</strong>: P100</li>\n<li><strong>Exact command to reproduce</strong>:</li>\n</ul>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> <span class=\"pl-k\">import</span> tensorflow <span class=\"pl-k\">as</span> tf\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> \n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> data_list <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>tensors: A nested structure of tensors, each having the same size in the 0th dimension.<span class=\"pl-pds\">'</span></span>.split()\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> data_tuple <span class=\"pl-k\">=</span> <span class=\"pl-c1\">tuple</span>(data_list)\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>list: <span class=\"pl-c1\">{}</span><span class=\"pl-pds\">'</span></span>.format(data_list))\n<span class=\"pl-c1\">list</span>: [<span class=\"pl-s\"><span class=\"pl-pds\">'</span>tensors:<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>A<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>nested<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>structure<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>of<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>tensors,<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>each<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>having<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>the<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>same<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>size<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>in<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>the<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>0th<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>dimension.<span class=\"pl-pds\">'</span></span>]\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>tuple: <span class=\"pl-c1\">{}</span><span class=\"pl-pds\">'</span></span>.format(data_tuple))\n<span class=\"pl-c1\">tuple</span>: (<span class=\"pl-s\"><span class=\"pl-pds\">'</span>tensors:<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>A<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>nested<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>structure<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>of<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>tensors,<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>each<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>having<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>the<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>same<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>size<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>in<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>the<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>0th<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>dimension.<span class=\"pl-pds\">'</span></span>)\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> \n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> ds_l <span class=\"pl-k\">=</span> tf.data.Dataset.from_tensor_slices(data_list)\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> <span class=\"pl-k\">try</span>:\n<span class=\"pl-c1\">...</span>     ds_t <span class=\"pl-k\">=</span> tf.data.Dataset.from_tensor_slices(data_tuple)\n<span class=\"pl-c1\">...</span> <span class=\"pl-k\">except</span> <span class=\"pl-c1\">IndexError</span> <span class=\"pl-k\">as</span> e:\n<span class=\"pl-c1\">...</span>     <span class=\"pl-c1\">print</span>(e.message)\n<span class=\"pl-c1\">...</span> \n<span class=\"pl-c1\">list</span> index out of <span class=\"pl-c1\">range</span>\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> ds_l <span class=\"pl-k\">=</span> tf.data.Dataset.from_tensors(data_list)\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> ds_t <span class=\"pl-k\">=</span> tf.data.Dataset.from_tensors(data_tuple)\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> \n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> <span class=\"pl-k\">with</span> tf.Session() <span class=\"pl-k\">as</span> session:\n<span class=\"pl-c1\">...</span>     <span class=\"pl-k\">for</span> ds <span class=\"pl-k\">in</span> [ds_l, ds_t]:\n<span class=\"pl-c1\">...</span>         it <span class=\"pl-k\">=</span> ds.make_one_shot_iterator().get_next()\n<span class=\"pl-c1\">...</span>         <span class=\"pl-k\">while</span> <span class=\"pl-c1\">True</span>:\n<span class=\"pl-c1\">...</span>             <span class=\"pl-k\">try</span>:\n<span class=\"pl-c1\">...</span>                 <span class=\"pl-c1\">print</span>(session.run(it))\n<span class=\"pl-c1\">...</span>             <span class=\"pl-k\">except</span> tf.errors.OutOfRangeError:\n<span class=\"pl-c1\">...</span>                 <span class=\"pl-k\">break</span>\n<span class=\"pl-c1\">...</span> \n[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>tensors:<span class=\"pl-pds\">'</span></span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>A<span class=\"pl-pds\">'</span></span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>nested<span class=\"pl-pds\">'</span></span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>structure<span class=\"pl-pds\">'</span></span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>of<span class=\"pl-pds\">'</span></span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>tensors,<span class=\"pl-pds\">'</span></span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>each<span class=\"pl-pds\">'</span></span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>having<span class=\"pl-pds\">'</span></span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>the<span class=\"pl-pds\">'</span></span>\n<span class=\"pl-s\"><span class=\"pl-pds\">'</span>same<span class=\"pl-pds\">'</span></span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>size<span class=\"pl-pds\">'</span></span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>in<span class=\"pl-pds\">'</span></span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>the<span class=\"pl-pds\">'</span></span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>0th<span class=\"pl-pds\">'</span></span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>dimension.<span class=\"pl-pds\">'</span></span>]\n(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>tensors:<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>A<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>nested<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>structure<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>of<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>tensors,<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>each<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>having<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>the<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>same<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>size<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>in<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>the<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>0th<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>dimension.<span class=\"pl-pds\">'</span></span>)\n\n</pre></div>\n<h3>Describe the problem</h3>\n<p>Apparently one can not use <code>tf.data.Dataset.from_tensor_slices</code> with tuples. This is very counter-intuitive as they almost everywhere have the same behavior as lists.<br>\nAlso using <code>tf.data.Dataset.from_tensors</code> is no option. Even though this seems to handle tuples properly, one only gets a single element instead of <code>n</code> elements. This is in alignment with the documentation but does not fulfill the same functionality as <code>tf.data.Dataset.from_tensor_slices</code>.</p>\n<p>Am I just using it wrong, is the documentation to ambiguous or should this be fixed?</p>", "body_text": "System information\n\nHave I written custom code (as opposed to using a stock example script provided in TensorFlow): no\nOS Platform and Distribution (e.g., Linux Ubuntu 16.04): Linux Ubuntu 16.04 and 18.04\nTensorFlow installed from (source or binary): binary\nTensorFlow version (use command below): 1.8.0\nPython version: 2.7\nCUDA/cuDNN version: 9.0 / 7.5 but also failing in CPU-only mode\nGPU model and memory: P100\nExact command to reproduce:\n\n>>> import tensorflow as tf\n>>> \n>>> data_list = 'tensors: A nested structure of tensors, each having the same size in the 0th dimension.'.split()\n>>> data_tuple = tuple(data_list)\n>>> print('list: {}'.format(data_list))\nlist: ['tensors:', 'A', 'nested', 'structure', 'of', 'tensors,', 'each', 'having', 'the', 'same', 'size', 'in', 'the', '0th', 'dimension.']\n>>> print('tuple: {}'.format(data_tuple))\ntuple: ('tensors:', 'A', 'nested', 'structure', 'of', 'tensors,', 'each', 'having', 'the', 'same', 'size', 'in', 'the', '0th', 'dimension.')\n>>> \n>>> ds_l = tf.data.Dataset.from_tensor_slices(data_list)\n>>> try:\n...     ds_t = tf.data.Dataset.from_tensor_slices(data_tuple)\n... except IndexError as e:\n...     print(e.message)\n... \nlist index out of range\n>>> ds_l = tf.data.Dataset.from_tensors(data_list)\n>>> ds_t = tf.data.Dataset.from_tensors(data_tuple)\n>>> \n>>> with tf.Session() as session:\n...     for ds in [ds_l, ds_t]:\n...         it = ds.make_one_shot_iterator().get_next()\n...         while True:\n...             try:\n...                 print(session.run(it))\n...             except tf.errors.OutOfRangeError:\n...                 break\n... \n['tensors:' 'A' 'nested' 'structure' 'of' 'tensors,' 'each' 'having' 'the'\n'same' 'size' 'in' 'the' '0th' 'dimension.']\n('tensors:', 'A', 'nested', 'structure', 'of', 'tensors,', 'each', 'having', 'the', 'same', 'size', 'in', 'the', '0th', 'dimension.')\n\n\nDescribe the problem\nApparently one can not use tf.data.Dataset.from_tensor_slices with tuples. This is very counter-intuitive as they almost everywhere have the same behavior as lists.\nAlso using tf.data.Dataset.from_tensors is no option. Even though this seems to handle tuples properly, one only gets a single element instead of n elements. This is in alignment with the documentation but does not fulfill the same functionality as tf.data.Dataset.from_tensor_slices.\nAm I just using it wrong, is the documentation to ambiguous or should this be fixed?", "body": "### System information\r\n- **Have I written custom code (as opposed to using a stock example script provided in TensorFlow)**: no\r\n- **OS Platform and Distribution (e.g., Linux Ubuntu 16.04)**: Linux Ubuntu 16.04 and 18.04\r\n- **TensorFlow installed from (source or binary)**: binary\r\n- **TensorFlow version (use command below)**: `1.8.0`\r\n- **Python version**: `2.7`\r\n- **CUDA/cuDNN version**: 9.0 / 7.5 but also failing in CPU-only mode\r\n- **GPU model and memory**: P100\r\n- **Exact command to reproduce**:\r\n``` python\r\n>>> import tensorflow as tf\r\n>>> \r\n>>> data_list = 'tensors: A nested structure of tensors, each having the same size in the 0th dimension.'.split()\r\n>>> data_tuple = tuple(data_list)\r\n>>> print('list: {}'.format(data_list))\r\nlist: ['tensors:', 'A', 'nested', 'structure', 'of', 'tensors,', 'each', 'having', 'the', 'same', 'size', 'in', 'the', '0th', 'dimension.']\r\n>>> print('tuple: {}'.format(data_tuple))\r\ntuple: ('tensors:', 'A', 'nested', 'structure', 'of', 'tensors,', 'each', 'having', 'the', 'same', 'size', 'in', 'the', '0th', 'dimension.')\r\n>>> \r\n>>> ds_l = tf.data.Dataset.from_tensor_slices(data_list)\r\n>>> try:\r\n...     ds_t = tf.data.Dataset.from_tensor_slices(data_tuple)\r\n... except IndexError as e:\r\n...     print(e.message)\r\n... \r\nlist index out of range\r\n>>> ds_l = tf.data.Dataset.from_tensors(data_list)\r\n>>> ds_t = tf.data.Dataset.from_tensors(data_tuple)\r\n>>> \r\n>>> with tf.Session() as session:\r\n...     for ds in [ds_l, ds_t]:\r\n...         it = ds.make_one_shot_iterator().get_next()\r\n...         while True:\r\n...             try:\r\n...                 print(session.run(it))\r\n...             except tf.errors.OutOfRangeError:\r\n...                 break\r\n... \r\n['tensors:' 'A' 'nested' 'structure' 'of' 'tensors,' 'each' 'having' 'the'\r\n'same' 'size' 'in' 'the' '0th' 'dimension.']\r\n('tensors:', 'A', 'nested', 'structure', 'of', 'tensors,', 'each', 'having', 'the', 'same', 'size', 'in', 'the', '0th', 'dimension.')\r\n\r\n\r\n```\r\n\r\n### Describe the problem\r\nApparently one can not use `tf.data.Dataset.from_tensor_slices` with tuples. This is very counter-intuitive as they almost everywhere have the same behavior as lists.\r\nAlso using `tf.data.Dataset.from_tensors` is no option. Even though this seems to handle tuples properly, one only gets a single element instead of `n` elements. This is in alignment with the documentation but does not fulfill the same functionality as `tf.data.Dataset.from_tensor_slices`.\r\n\r\nAm I just using it wrong, is the documentation to ambiguous or should this be fixed?"}