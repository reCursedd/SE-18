{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9550", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9550/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9550/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9550/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/9550", "id": 225318324, "node_id": "MDU6SXNzdWUyMjUzMTgzMjQ=", "number": 9550, "title": "ctc_greedy_decoder inconsistent with ctc_beam_search_decoder", "user": {"login": "JuliusKunze", "id": 1497342, "node_id": "MDQ6VXNlcjE0OTczNDI=", "avatar_url": "https://avatars0.githubusercontent.com/u/1497342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JuliusKunze", "html_url": "https://github.com/JuliusKunze", "followers_url": "https://api.github.com/users/JuliusKunze/followers", "following_url": "https://api.github.com/users/JuliusKunze/following{/other_user}", "gists_url": "https://api.github.com/users/JuliusKunze/gists{/gist_id}", "starred_url": "https://api.github.com/users/JuliusKunze/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JuliusKunze/subscriptions", "organizations_url": "https://api.github.com/users/JuliusKunze/orgs", "repos_url": "https://api.github.com/users/JuliusKunze/repos", "events_url": "https://api.github.com/users/JuliusKunze/events{/privacy}", "received_events_url": "https://api.github.com/users/JuliusKunze/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 473172988, "node_id": "MDU6TGFiZWw0NzMxNzI5ODg=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:bug/performance", "name": "type:bug/performance", "color": "159b2e", "default": false}], "state": "closed", "locked": false, "assignee": {"login": "ebrevdo", "id": 1794715, "node_id": "MDQ6VXNlcjE3OTQ3MTU=", "avatar_url": "https://avatars0.githubusercontent.com/u/1794715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebrevdo", "html_url": "https://github.com/ebrevdo", "followers_url": "https://api.github.com/users/ebrevdo/followers", "following_url": "https://api.github.com/users/ebrevdo/following{/other_user}", "gists_url": "https://api.github.com/users/ebrevdo/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebrevdo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebrevdo/subscriptions", "organizations_url": "https://api.github.com/users/ebrevdo/orgs", "repos_url": "https://api.github.com/users/ebrevdo/repos", "events_url": "https://api.github.com/users/ebrevdo/events{/privacy}", "received_events_url": "https://api.github.com/users/ebrevdo/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "ebrevdo", "id": 1794715, "node_id": "MDQ6VXNlcjE3OTQ3MTU=", "avatar_url": "https://avatars0.githubusercontent.com/u/1794715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebrevdo", "html_url": "https://github.com/ebrevdo", "followers_url": "https://api.github.com/users/ebrevdo/followers", "following_url": "https://api.github.com/users/ebrevdo/following{/other_user}", "gists_url": "https://api.github.com/users/ebrevdo/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebrevdo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebrevdo/subscriptions", "organizations_url": "https://api.github.com/users/ebrevdo/orgs", "repos_url": "https://api.github.com/users/ebrevdo/repos", "events_url": "https://api.github.com/users/ebrevdo/events{/privacy}", "received_events_url": "https://api.github.com/users/ebrevdo/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 12, "created_at": "2017-04-30T10:22:38Z", "updated_at": "2018-09-09T16:25:48Z", "closed_at": "2018-09-09T16:25:48Z", "author_association": "NONE", "body_html": "<p>The following extract from the the <code>ctc_beam_search_decoder</code> documentation seems to be misleading:<br>\n\"The <code>ctc_greedy_decoder</code> is a special case of the <code>ctc_beam_search_decoder</code> with <code>top_paths=1</code> and <code>beam_width=1</code> (but that decoder is faster for this special case).\"</p>\n<p>Instead, the following results can be observed:</p>\n<table>\n<thead>\n<tr>\n<th>Decoding \"AA&lt;ctc_blank&gt;AA\" using</th>\n<th><code>merge_repeated=True</code></th>\n<th><code>merge_repeated=False</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>tf.nn.ctc_beam_search_decoder(top_paths=1, beam_width=1)</code></td>\n<td>\"A\"</td>\n<td>\"AA\"</td>\n</tr>\n<tr>\n<td><code>tf.nn.ctc_greedy_decoder()</code></td>\n<td>\"AA\"</td>\n<td>\"AAAA\"</td>\n</tr>\n</tbody>\n</table>\n<p>To reproduce:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">import</span> numpy <span class=\"pl-k\">as</span> np\n<span class=\"pl-k\">import</span> tensorflow <span class=\"pl-k\">as</span> tf\n<span class=\"pl-k\">from</span> unittest <span class=\"pl-k\">import</span> TestCase\n\n\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">CtcDecodersTest</span>(<span class=\"pl-e\">TestCase</span>):\n    <span class=\"pl-k\">def</span> <span class=\"pl-en\">test</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>):\n        <span class=\"pl-k\">def</span> <span class=\"pl-en\">decode_greedily</span>(<span class=\"pl-smi\">beam_search</span>: <span class=\"pl-c1\">bool</span>, <span class=\"pl-smi\">merge_repeated</span>: <span class=\"pl-c1\">bool</span>):\n            aa_ctc_blank_aa_logits <span class=\"pl-k\">=</span> tf.constant(np.array([[[<span class=\"pl-c1\">1.0</span>, <span class=\"pl-c1\">0.0</span>]], [[<span class=\"pl-c1\">1.0</span>, <span class=\"pl-c1\">0.0</span>]], [[<span class=\"pl-c1\">0.0</span>, <span class=\"pl-c1\">1.0</span>]],\n                                                    [[<span class=\"pl-c1\">1.0</span>, <span class=\"pl-c1\">0.0</span>]], [[<span class=\"pl-c1\">1.0</span>, <span class=\"pl-c1\">0.0</span>]]], <span class=\"pl-v\">dtype</span><span class=\"pl-k\">=</span>np.float32))\n            sequence_length <span class=\"pl-k\">=</span> tf.constant(np.array([<span class=\"pl-c1\">5</span>], <span class=\"pl-v\">dtype</span><span class=\"pl-k\">=</span>np.int32))\n\n            (decoded_list,), log_probabilities <span class=\"pl-k\">=</span> \\\n                tf.nn.ctc_beam_search_decoder(<span class=\"pl-v\">inputs</span><span class=\"pl-k\">=</span>aa_ctc_blank_aa_logits,\n                                              <span class=\"pl-v\">sequence_length</span><span class=\"pl-k\">=</span>sequence_length,\n                                              <span class=\"pl-v\">merge_repeated</span><span class=\"pl-k\">=</span>merge_repeated,\n                                              <span class=\"pl-v\">beam_width</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">1</span>) \\\n                    <span class=\"pl-k\">if</span> beam_search <span class=\"pl-k\">else</span> \\\n                    tf.nn.ctc_greedy_decoder(<span class=\"pl-v\">inputs</span><span class=\"pl-k\">=</span>aa_ctc_blank_aa_logits,\n                                             <span class=\"pl-v\">sequence_length</span><span class=\"pl-k\">=</span>sequence_length,\n                                             <span class=\"pl-v\">merge_repeated</span><span class=\"pl-k\">=</span>merge_repeated)\n\n            <span class=\"pl-k\">return</span> <span class=\"pl-c1\">list</span>(tf.Session().run(tf.sparse_tensor_to_dense(decoded_list)[<span class=\"pl-c1\">0</span>]))\n\n        <span class=\"pl-c1\">self</span>.assertEqual([<span class=\"pl-c1\">0</span>], decode_greedily(<span class=\"pl-v\">beam_search</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">True</span>, <span class=\"pl-v\">merge_repeated</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">True</span>))\n        <span class=\"pl-c1\">self</span>.assertEqual([<span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">0</span>], decode_greedily(<span class=\"pl-v\">beam_search</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">True</span>, <span class=\"pl-v\">merge_repeated</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">False</span>))\n        <span class=\"pl-c1\">self</span>.assertEqual([<span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">0</span>], decode_greedily(<span class=\"pl-v\">beam_search</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">False</span>, <span class=\"pl-v\">merge_repeated</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">True</span>))\n        <span class=\"pl-c1\">self</span>.assertEqual([<span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">0</span>], decode_greedily(<span class=\"pl-v\">beam_search</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">False</span>, <span class=\"pl-v\">merge_repeated</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">False</span>))</pre></div>\n<p>This is confusing and probably not intended.</p>\n<p>How to solve this:</p>\n<ul>\n<li>Adapt the documentation or</li>\n<li>Adapt the <code>ctc_beam_search_decoder</code> implementation to that of <code>ctc_greedy_decoder</code> or vice versa. Both directions would cover my use case (\"AA\"), this decision would depend on which of the other behaviors (\"A\" or \"AAAA\") is needed and which of them could be dropped.</li>\n</ul>\n<h3>System information</h3>\n<p>OSX 12.4, TensorFlow 1.1.0 CPU from binary</p>", "body_text": "The following extract from the the ctc_beam_search_decoder documentation seems to be misleading:\n\"The ctc_greedy_decoder is a special case of the ctc_beam_search_decoder with top_paths=1 and beam_width=1 (but that decoder is faster for this special case).\"\nInstead, the following results can be observed:\n\n\n\nDecoding \"AA<ctc_blank>AA\" using\nmerge_repeated=True\nmerge_repeated=False\n\n\n\n\ntf.nn.ctc_beam_search_decoder(top_paths=1, beam_width=1)\n\"A\"\n\"AA\"\n\n\ntf.nn.ctc_greedy_decoder()\n\"AA\"\n\"AAAA\"\n\n\n\nTo reproduce:\nimport numpy as np\nimport tensorflow as tf\nfrom unittest import TestCase\n\n\nclass CtcDecodersTest(TestCase):\n    def test(self):\n        def decode_greedily(beam_search: bool, merge_repeated: bool):\n            aa_ctc_blank_aa_logits = tf.constant(np.array([[[1.0, 0.0]], [[1.0, 0.0]], [[0.0, 1.0]],\n                                                    [[1.0, 0.0]], [[1.0, 0.0]]], dtype=np.float32))\n            sequence_length = tf.constant(np.array([5], dtype=np.int32))\n\n            (decoded_list,), log_probabilities = \\\n                tf.nn.ctc_beam_search_decoder(inputs=aa_ctc_blank_aa_logits,\n                                              sequence_length=sequence_length,\n                                              merge_repeated=merge_repeated,\n                                              beam_width=1) \\\n                    if beam_search else \\\n                    tf.nn.ctc_greedy_decoder(inputs=aa_ctc_blank_aa_logits,\n                                             sequence_length=sequence_length,\n                                             merge_repeated=merge_repeated)\n\n            return list(tf.Session().run(tf.sparse_tensor_to_dense(decoded_list)[0]))\n\n        self.assertEqual([0], decode_greedily(beam_search=True, merge_repeated=True))\n        self.assertEqual([0, 0], decode_greedily(beam_search=True, merge_repeated=False))\n        self.assertEqual([0, 0], decode_greedily(beam_search=False, merge_repeated=True))\n        self.assertEqual([0, 0, 0, 0], decode_greedily(beam_search=False, merge_repeated=False))\nThis is confusing and probably not intended.\nHow to solve this:\n\nAdapt the documentation or\nAdapt the ctc_beam_search_decoder implementation to that of ctc_greedy_decoder or vice versa. Both directions would cover my use case (\"AA\"), this decision would depend on which of the other behaviors (\"A\" or \"AAAA\") is needed and which of them could be dropped.\n\nSystem information\nOSX 12.4, TensorFlow 1.1.0 CPU from binary", "body": "The following extract from the the `ctc_beam_search_decoder` documentation seems to be misleading:\r\n\"The `ctc_greedy_decoder` is a special case of the `ctc_beam_search_decoder` with `top_paths=1` and `beam_width=1` (but that decoder is faster for this special case).\"\r\n\r\nInstead, the following results can be observed: \r\n\r\n| Decoding \"AA<ctc_blank>AA\" using | `merge_repeated=True` | `merge_repeated=False` |\r\n| --- | --- | --- |\r\n| `tf.nn.ctc_beam_search_decoder(top_paths=1, beam_width=1)` | \"A\"   | \"AA\" |\r\n| `tf.nn.ctc_greedy_decoder()` | \"AA\" | \"AAAA\" |\r\n\r\nTo reproduce:\r\n\r\n```python\r\nimport numpy as np\r\nimport tensorflow as tf\r\nfrom unittest import TestCase\r\n\r\n\r\nclass CtcDecodersTest(TestCase):\r\n    def test(self):\r\n        def decode_greedily(beam_search: bool, merge_repeated: bool):\r\n            aa_ctc_blank_aa_logits = tf.constant(np.array([[[1.0, 0.0]], [[1.0, 0.0]], [[0.0, 1.0]],\r\n                                                    [[1.0, 0.0]], [[1.0, 0.0]]], dtype=np.float32))\r\n            sequence_length = tf.constant(np.array([5], dtype=np.int32))\r\n\r\n            (decoded_list,), log_probabilities = \\\r\n                tf.nn.ctc_beam_search_decoder(inputs=aa_ctc_blank_aa_logits,\r\n                                              sequence_length=sequence_length,\r\n                                              merge_repeated=merge_repeated,\r\n                                              beam_width=1) \\\r\n                    if beam_search else \\\r\n                    tf.nn.ctc_greedy_decoder(inputs=aa_ctc_blank_aa_logits,\r\n                                             sequence_length=sequence_length,\r\n                                             merge_repeated=merge_repeated)\r\n\r\n            return list(tf.Session().run(tf.sparse_tensor_to_dense(decoded_list)[0]))\r\n\r\n        self.assertEqual([0], decode_greedily(beam_search=True, merge_repeated=True))\r\n        self.assertEqual([0, 0], decode_greedily(beam_search=True, merge_repeated=False))\r\n        self.assertEqual([0, 0], decode_greedily(beam_search=False, merge_repeated=True))\r\n        self.assertEqual([0, 0, 0, 0], decode_greedily(beam_search=False, merge_repeated=False))\r\n```\r\n\r\nThis is confusing and probably not intended.\r\n\r\nHow to solve this:\r\n\r\n- Adapt the documentation or\r\n- Adapt the `ctc_beam_search_decoder` implementation to that of `ctc_greedy_decoder` or vice versa. Both directions would cover my use case (\"AA\"), this decision would depend on which of the other behaviors (\"A\" or \"AAAA\") is needed and which of them could be dropped.\r\n\r\n### System information\r\nOSX 12.4, TensorFlow 1.1.0 CPU from binary"}