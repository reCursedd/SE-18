{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/7945", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/7945/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/7945/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/7945/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/7945", "id": 210836577, "node_id": "MDU6SXNzdWUyMTA4MzY1Nzc=", "number": 7945, "title": "Input producer freezes if queue runner not started", "user": {"login": "nightrome", "id": 1212780, "node_id": "MDQ6VXNlcjEyMTI3ODA=", "avatar_url": "https://avatars3.githubusercontent.com/u/1212780?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nightrome", "html_url": "https://github.com/nightrome", "followers_url": "https://api.github.com/users/nightrome/followers", "following_url": "https://api.github.com/users/nightrome/following{/other_user}", "gists_url": "https://api.github.com/users/nightrome/gists{/gist_id}", "starred_url": "https://api.github.com/users/nightrome/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nightrome/subscriptions", "organizations_url": "https://api.github.com/users/nightrome/orgs", "repos_url": "https://api.github.com/users/nightrome/repos", "events_url": "https://api.github.com/users/nightrome/events{/privacy}", "received_events_url": "https://api.github.com/users/nightrome/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2017-02-28T16:23:35Z", "updated_at": "2017-03-01T05:54:12Z", "closed_at": "2017-03-01T05:54:12Z", "author_association": "NONE", "body_html": "<p>Hi,</p>\n<p>my entire program freezes when I pop an image from an input queue before starting the queue runner. The terminal window becomes unresponsive (including CTRL+C or CTRL+D signals) and the only way to kill the process is to close the terminal window. In rare cases zombie processes remain even after closing the terminal.<br>\nI understand that I am <a href=\"https://github.com/tensorflow/tensorflow/issues/7034\" data-hovercard-type=\"issue\" data-hovercard-url=\"/tensorflow/tensorflow/issues/7034/hovercard\">not supposed to do that</a>, but I think that Tensorflow absolutely HAS to check whether the queue runner is already initialized and throw an exception otherwise. Several reported issues might be related to that: <a href=\"https://github.com/tensorflow/tensorflow/issues/7573\" data-hovercard-type=\"issue\" data-hovercard-url=\"/tensorflow/tensorflow/issues/7573/hovercard\">7503</a>, <a href=\"https://github.com/tensorflow/tensorflow/issues/7573\" data-hovercard-type=\"issue\" data-hovercard-url=\"/tensorflow/tensorflow/issues/7573/hovercard\">7573</a> etc.</p>\n<p>For reproducibility I provide a minimum (non-)working example. It requires a subfolder <code>images</code> with a handful of .jpg images:</p>\n<pre><code>import tensorflow as tf\n\n# Read images from queue\nfilename_queue = tf.train.string_input_producer(tf.train.match_filenames_once(\"./images/train/*.jpg\"), shuffle=False)\nimage_reader = tf.WholeFileReader()\n_, image_file = image_reader.read(filename_queue)\nimage_query = tf.image.decode_jpeg(image_file)\n\n# Decode the image as a JPEG file, resize and assign to a variable\nimage_query = tf.image.resize_images(image_query, (256, 256))\nimage_batch = tf.Variable(tf.zeros((256, 256, 3)), trainable=False, name=\"image_batch\")\nnext_image = tf.assign(image_batch, image_query)\nloss = tf.reduce_mean(image_batch)\n\n# Start a new session to show example output.\nwith tf.Session() as sess:\n    # Fix randomness, init variables and run threads\n    tf.set_random_seed(42)\n    tf.global_variables_initializer().run()\n\n    # Go to the next image\n    sess.run([next_image])\n\n    coord = tf.train.Coordinator()\n    threads = tf.train.start_queue_runners(coord=coord)\n\n    for i in xrange(0, 5):\n\n        # Get an image tensor and print its value.\n        image_tensor = sess.run([image_batch])\n        print(image_tensor[0][0, 0, 0])\n\n    # Finish off the filename queue coordinator.\n    coord.request_stop()\n    coord.join(threads)\n</code></pre>\n<p>and here is the working code (the line <code>sess.run([next_image])</code> was moved):</p>\n<pre><code>import tensorflow as tf\n\n# Read images from queue\nfilename_queue = tf.train.string_input_producer(tf.train.match_filenames_once(\"./images/train/*.jpg\"), shuffle=False)\nimage_reader = tf.WholeFileReader()\n_, image_file = image_reader.read(filename_queue)\nimage_query = tf.image.decode_jpeg(image_file)\n\n# Decode the image as a JPEG file, resize and assign to a variable\nimage_query = tf.image.resize_images(image_query, (256, 256))\nimage_batch = tf.Variable(tf.zeros((256, 256, 3)), trainable=False, name=\"image_batch\")\nnext_image = tf.assign(image_batch, image_query)\nloss = tf.reduce_mean(image_batch)\n\n# Start a new session to show example output.\nwith tf.Session() as sess:\n    # Fix randomness, init variables and run threads\n    tf.set_random_seed(42)\n    tf.global_variables_initializer().run()\n\n    coord = tf.train.Coordinator()\n    threads = tf.train.start_queue_runners(coord=coord)\n\n    for i in xrange(0, 5):\n        # Go to the next image\n        sess.run([next_image])\n\n        # Get an image tensor and print its value.\n        image_tensor = sess.run([image_batch])\n        print(image_tensor[0][0, 0, 0])\n\n    # Finish off the filename queue coordinator.\n    coord.request_stop()\n    coord.join(threads)\n</code></pre>", "body_text": "Hi,\nmy entire program freezes when I pop an image from an input queue before starting the queue runner. The terminal window becomes unresponsive (including CTRL+C or CTRL+D signals) and the only way to kill the process is to close the terminal window. In rare cases zombie processes remain even after closing the terminal.\nI understand that I am not supposed to do that, but I think that Tensorflow absolutely HAS to check whether the queue runner is already initialized and throw an exception otherwise. Several reported issues might be related to that: 7503, 7573 etc.\nFor reproducibility I provide a minimum (non-)working example. It requires a subfolder images with a handful of .jpg images:\nimport tensorflow as tf\n\n# Read images from queue\nfilename_queue = tf.train.string_input_producer(tf.train.match_filenames_once(\"./images/train/*.jpg\"), shuffle=False)\nimage_reader = tf.WholeFileReader()\n_, image_file = image_reader.read(filename_queue)\nimage_query = tf.image.decode_jpeg(image_file)\n\n# Decode the image as a JPEG file, resize and assign to a variable\nimage_query = tf.image.resize_images(image_query, (256, 256))\nimage_batch = tf.Variable(tf.zeros((256, 256, 3)), trainable=False, name=\"image_batch\")\nnext_image = tf.assign(image_batch, image_query)\nloss = tf.reduce_mean(image_batch)\n\n# Start a new session to show example output.\nwith tf.Session() as sess:\n    # Fix randomness, init variables and run threads\n    tf.set_random_seed(42)\n    tf.global_variables_initializer().run()\n\n    # Go to the next image\n    sess.run([next_image])\n\n    coord = tf.train.Coordinator()\n    threads = tf.train.start_queue_runners(coord=coord)\n\n    for i in xrange(0, 5):\n\n        # Get an image tensor and print its value.\n        image_tensor = sess.run([image_batch])\n        print(image_tensor[0][0, 0, 0])\n\n    # Finish off the filename queue coordinator.\n    coord.request_stop()\n    coord.join(threads)\n\nand here is the working code (the line sess.run([next_image]) was moved):\nimport tensorflow as tf\n\n# Read images from queue\nfilename_queue = tf.train.string_input_producer(tf.train.match_filenames_once(\"./images/train/*.jpg\"), shuffle=False)\nimage_reader = tf.WholeFileReader()\n_, image_file = image_reader.read(filename_queue)\nimage_query = tf.image.decode_jpeg(image_file)\n\n# Decode the image as a JPEG file, resize and assign to a variable\nimage_query = tf.image.resize_images(image_query, (256, 256))\nimage_batch = tf.Variable(tf.zeros((256, 256, 3)), trainable=False, name=\"image_batch\")\nnext_image = tf.assign(image_batch, image_query)\nloss = tf.reduce_mean(image_batch)\n\n# Start a new session to show example output.\nwith tf.Session() as sess:\n    # Fix randomness, init variables and run threads\n    tf.set_random_seed(42)\n    tf.global_variables_initializer().run()\n\n    coord = tf.train.Coordinator()\n    threads = tf.train.start_queue_runners(coord=coord)\n\n    for i in xrange(0, 5):\n        # Go to the next image\n        sess.run([next_image])\n\n        # Get an image tensor and print its value.\n        image_tensor = sess.run([image_batch])\n        print(image_tensor[0][0, 0, 0])\n\n    # Finish off the filename queue coordinator.\n    coord.request_stop()\n    coord.join(threads)", "body": "Hi,\r\n\r\nmy entire program freezes when I pop an image from an input queue before starting the queue runner. The terminal window becomes unresponsive (including CTRL+C or CTRL+D signals) and the only way to kill the process is to close the terminal window. In rare cases zombie processes remain even after closing the terminal. \r\nI understand that I am [not supposed to do that](https://github.com/tensorflow/tensorflow/issues/7034), but I think that Tensorflow absolutely HAS to check whether the queue runner is already initialized and throw an exception otherwise. Several reported issues might be related to that: [7503](https://github.com/tensorflow/tensorflow/issues/7573), [7573](https://github.com/tensorflow/tensorflow/issues/7573) etc.\r\n\r\nFor reproducibility I provide a minimum (non-)working example. It requires a subfolder `images` with a handful of .jpg images:\r\n```\r\nimport tensorflow as tf\r\n\r\n# Read images from queue\r\nfilename_queue = tf.train.string_input_producer(tf.train.match_filenames_once(\"./images/train/*.jpg\"), shuffle=False)\r\nimage_reader = tf.WholeFileReader()\r\n_, image_file = image_reader.read(filename_queue)\r\nimage_query = tf.image.decode_jpeg(image_file)\r\n\r\n# Decode the image as a JPEG file, resize and assign to a variable\r\nimage_query = tf.image.resize_images(image_query, (256, 256))\r\nimage_batch = tf.Variable(tf.zeros((256, 256, 3)), trainable=False, name=\"image_batch\")\r\nnext_image = tf.assign(image_batch, image_query)\r\nloss = tf.reduce_mean(image_batch)\r\n\r\n# Start a new session to show example output.\r\nwith tf.Session() as sess:\r\n    # Fix randomness, init variables and run threads\r\n    tf.set_random_seed(42)\r\n    tf.global_variables_initializer().run()\r\n\r\n    # Go to the next image\r\n    sess.run([next_image])\r\n\r\n    coord = tf.train.Coordinator()\r\n    threads = tf.train.start_queue_runners(coord=coord)\r\n\r\n    for i in xrange(0, 5):\r\n\r\n        # Get an image tensor and print its value.\r\n        image_tensor = sess.run([image_batch])\r\n        print(image_tensor[0][0, 0, 0])\r\n\r\n    # Finish off the filename queue coordinator.\r\n    coord.request_stop()\r\n    coord.join(threads)\r\n```\r\n\r\nand here is the working code (the line `sess.run([next_image])` was moved):\r\n```\r\nimport tensorflow as tf\r\n\r\n# Read images from queue\r\nfilename_queue = tf.train.string_input_producer(tf.train.match_filenames_once(\"./images/train/*.jpg\"), shuffle=False)\r\nimage_reader = tf.WholeFileReader()\r\n_, image_file = image_reader.read(filename_queue)\r\nimage_query = tf.image.decode_jpeg(image_file)\r\n\r\n# Decode the image as a JPEG file, resize and assign to a variable\r\nimage_query = tf.image.resize_images(image_query, (256, 256))\r\nimage_batch = tf.Variable(tf.zeros((256, 256, 3)), trainable=False, name=\"image_batch\")\r\nnext_image = tf.assign(image_batch, image_query)\r\nloss = tf.reduce_mean(image_batch)\r\n\r\n# Start a new session to show example output.\r\nwith tf.Session() as sess:\r\n    # Fix randomness, init variables and run threads\r\n    tf.set_random_seed(42)\r\n    tf.global_variables_initializer().run()\r\n\r\n    coord = tf.train.Coordinator()\r\n    threads = tf.train.start_queue_runners(coord=coord)\r\n\r\n    for i in xrange(0, 5):\r\n        # Go to the next image\r\n        sess.run([next_image])\r\n\r\n        # Get an image tensor and print its value.\r\n        image_tensor = sess.run([image_batch])\r\n        print(image_tensor[0][0, 0, 0])\r\n\r\n    # Finish off the filename queue coordinator.\r\n    coord.request_stop()\r\n    coord.join(threads)\r\n```"}