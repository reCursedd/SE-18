{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/323224063", "html_url": "https://github.com/tensorflow/tensorflow/issues/12374#issuecomment-323224063", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/12374", "id": 323224063, "node_id": "MDEyOklzc3VlQ29tbWVudDMyMzIyNDA2Mw==", "user": {"login": "eaplatanios", "id": 1294940, "node_id": "MDQ6VXNlcjEyOTQ5NDA=", "avatar_url": "https://avatars2.githubusercontent.com/u/1294940?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eaplatanios", "html_url": "https://github.com/eaplatanios", "followers_url": "https://api.github.com/users/eaplatanios/followers", "following_url": "https://api.github.com/users/eaplatanios/following{/other_user}", "gists_url": "https://api.github.com/users/eaplatanios/gists{/gist_id}", "starred_url": "https://api.github.com/users/eaplatanios/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eaplatanios/subscriptions", "organizations_url": "https://api.github.com/users/eaplatanios/orgs", "repos_url": "https://api.github.com/users/eaplatanios/repos", "events_url": "https://api.github.com/users/eaplatanios/events{/privacy}", "received_events_url": "https://api.github.com/users/eaplatanios/received_events", "type": "User", "site_admin": false}, "created_at": "2017-08-17T23:52:12Z", "updated_at": "2017-08-17T23:52:12Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=5061\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/alextp\">@alextp</a> I see. I guess you follow a sort of purely functional approach where if your data structures are immutable, you have more well-defined behavior and can optimize more. I was sort of expecting that response and it makes sense. Thanks for making it clear!:)</p>\n<p>I guess the next question would be to figure out in which use cases (potentially other than zeroing out a column), do users want to assign values to tensor slices. My use case came in the context of creating tensors using the new eager tensor execution API. In this case I was trying to pre-allocate the tensor buffer and then I was thinking of using assignment ops to fill it with values. The current approach to do this is to allocate the buffer in host memory, set the values manually, and then create the tensor object. Do you have any better ideas for this?</p>\n<p>I guess one reason for thinking of this as useful functionality was that I was thinking about it in the context of the eager execution API. In this case, we need no notions of graph or rewrites and optimizations and that kind of functionality feels natural.</p>", "body_text": "@alextp I see. I guess you follow a sort of purely functional approach where if your data structures are immutable, you have more well-defined behavior and can optimize more. I was sort of expecting that response and it makes sense. Thanks for making it clear!:)\nI guess the next question would be to figure out in which use cases (potentially other than zeroing out a column), do users want to assign values to tensor slices. My use case came in the context of creating tensors using the new eager tensor execution API. In this case I was trying to pre-allocate the tensor buffer and then I was thinking of using assignment ops to fill it with values. The current approach to do this is to allocate the buffer in host memory, set the values manually, and then create the tensor object. Do you have any better ideas for this?\nI guess one reason for thinking of this as useful functionality was that I was thinking about it in the context of the eager execution API. In this case, we need no notions of graph or rewrites and optimizations and that kind of functionality feels natural.", "body": "@alextp I see. I guess you follow a sort of purely functional approach where if your data structures are immutable, you have more well-defined behavior and can optimize more. I was sort of expecting that response and it makes sense. Thanks for making it clear!:)\r\n\r\nI guess the next question would be to figure out in which use cases (potentially other than zeroing out a column), do users want to assign values to tensor slices. My use case came in the context of creating tensors using the new eager tensor execution API. In this case I was trying to pre-allocate the tensor buffer and then I was thinking of using assignment ops to fill it with values. The current approach to do this is to allocate the buffer in host memory, set the values manually, and then create the tensor object. Do you have any better ideas for this?\r\n\r\nI guess one reason for thinking of this as useful functionality was that I was thinking about it in the context of the eager execution API. In this case, we need no notions of graph or rewrites and optimizations and that kind of functionality feels natural."}