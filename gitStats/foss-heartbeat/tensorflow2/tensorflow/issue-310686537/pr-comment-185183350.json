{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/185183350", "pull_request_review_id": 116490128, "id": 185183350, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NTE4MzM1MA==", "diff_hunk": "@@ -14,53 +14,429 @@ limitations under the License.\n ==============================================================================*/\n \n #include <string>\n+#include <map>\n+#include <vector>\n+#include <list>\n+#include <memory>\n+#include <set>\n+#include <ctime>\n \n+#include \"tensorflow/core/lib/core/errors.h\"\n #include \"tensorflow/core/lib/strings/str_util.h\"\n+#include \"tensorflow/core/lib/io/path.h\"\n #include \"tensorflow/core/platform/logging.h\"\n+#include \"tensorflow/core/platform/env.h\"\n+#include \"tensorflow/core/framework/op_gen_lib.h\"\n+#include \"tensorflow/java/src/gen/cc/java_defs.h\"\n+#include \"tensorflow/java/src/gen/cc/source_writer.h\"\n #include \"tensorflow/java/src/gen/cc/op_generator.h\"\n+#include \"tensorflow/java/src/gen/cc/op_specs.h\"\n \n namespace tensorflow {\n namespace java {\n namespace {\n \n-string CamelCase(const string& str, char delimiter, bool upper) {\n-  string result;\n-  bool cap = upper;\n-  for (string::const_iterator it = str.begin(); it != str.end(); ++it) {\n-    const char c = *it;\n-    if (c == delimiter) {\n-      cap = true;\n-    } else if (cap) {\n-      result += toupper(c);\n-      cap = false;\n+const char* kLicenseSnippet =\n+    \"tensorflow/java/src/gen/resources/license.java.snippet\";\n+\n+enum RenderMode {\n+  DEFAULT,\n+  SINGLE_OUTPUT,\n+  SINGLE_LIST_OUTPUT\n+};\n+\n+inline void AddArgument(const Variable& var, const string& description,\n+    Method* method_out, Javadoc* javadoc_out) {\n+  method_out->add_argument(var);\n+  javadoc_out->add_param_tag(var.name(), description);\n+}\n+\n+void CollectOpDependencies(const OpSpec& op, RenderMode mode,\n+    std::list<Type>* out) {\n+  out->push_back(Type::Class(\"Operation\", \"org.tensorflow\"));\n+  out->push_back(Type::Class(\"OperationBuilder\", \"org.tensorflow\"));\n+  out->push_back(Type::Class(\"Scope\", \"org.tensorflow.op\"));\n+  if (mode == SINGLE_OUTPUT) {\n+    out->push_back(Type::Class(\"Output\", \"org.tensorflow\"));\n+  } else if (mode == SINGLE_LIST_OUTPUT) {\n+    out->push_back(Type::Interface(\"Iterator\", \"java.util\"));\n+  }\n+  // Don't pay attention to duplicate types in the dependency list, they will\n+  // be filtered out by the SourceWriter.\n+  for (const ArgumentSpec& input : op.inputs()) {\n+    out->push_back(input.var().type());\n+    if (input.iterable()) {\n+      out->push_back(Type::Class(\"Operands\", \"org.tensorflow.op\"));\n+    }\n+  }\n+  for (const ArgumentSpec& output : op.outputs()) {\n+    out->push_back(output.var().type());\n+    if (output.iterable()) {\n+      out->push_back(Type::Class(\"Arrays\", \"java.util\"));\n+    }\n+  }\n+  for (const AttributeSpec& attribute : op.attributes()) {\n+    out->push_back(attribute.var().type());\n+    out->push_back(attribute.jni_type());\n+  }\n+  for (const AttributeSpec& optional_attribute : op.optional_attributes()) {\n+    out->push_back(optional_attribute.var().type());\n+  }\n+}\n+\n+void WriteSetAttrDirective(const AttributeSpec& attr, bool optional,\n+    SourceWriter* writer) {\n+  string var_name = optional ? \"opts.\" + attr.var().name() : attr.var().name();\n+  if (attr.iterable()) {\n+    string array_name = attr.var().name() + \"Array\";\n+    writer->AppendType(attr.jni_type())\n+        .Append(\"[] \" + array_name + \" = new \")\n+        .AppendType(attr.jni_type())\n+        .Append(\"[\" + var_name + \".size()];\")\n+        .EndLine()\n+        .BeginBlock(\"for (int i = 0; i < \" + array_name + \".length; ++i)\")\n+        .Append(array_name + \"[i] = \");\n+    if (attr.type().kind() == Type::GENERIC) {\n+      writer->Append(\"DataType.fromClass(\" + var_name + \".get(i));\");\n     } else {\n-      result += c;\n+      writer->Append(var_name + \".get(i);\");\n     }\n+    writer->EndLine()\n+        .EndBlock()\n+        .Append(\"opBuilder.setAttr(\\\"\" + attr.op_def_name() + \"\\\", \")\n+        .Append(array_name + \");\")\n+        .EndLine();\n+  } else {\n+    writer->Append(\"opBuilder.setAttr(\\\"\" + attr.op_def_name() + \"\\\", \");\n+    if (attr.var().type().name() == \"Class\") {\n+      writer->Append(\"DataType.fromClass(\" + var_name + \"));\");\n+    } else {\n+      writer->Append(var_name + \");\");\n+    }\n+    writer->EndLine();\n   }\n-  return result;\n }\n \n-}  // namespace\n+void RenderFactoryMethods(const OpSpec& op, const Type& op_class,\n+    SourceWriter* writer) {\n+  Method factory = Method::Create(\"create\", op_class);\n+  Javadoc factory_doc = Javadoc::Create(\n+      \"Factory method to create a class to wrap a new \" + op_class.name()\n+      + \" operation to the graph.\");\n+  Variable scope =\n+      Variable::Create(\"scope\", Type::Class(\"Scope\", \"org.tensorflow.op\"));\n+  AddArgument(scope, \"current graph scope\", &factory, &factory_doc);\n+  for (const ArgumentSpec& input : op.inputs()) {\n+    AddArgument(input.var(), input.description(), &factory, &factory_doc);\n+  }\n+  for (const AttributeSpec& attr : op.attributes()) {\n+    AddArgument(attr.var(), attr.description(), &factory, &factory_doc);\n+  }\n+  if (!op.optional_attributes().empty()) {\n+    AddArgument(Variable::Varargs(\"options\", Type::Class(\"Options\")),\n+        \"carries optional attributes values\", &factory, &factory_doc);\n+  }\n+  factory_doc.add_tag(\"return\", \"a new instance of \" + op_class.name());\n+\n+  writer->BeginMethod(factory, PUBLIC|STATIC, &factory_doc);\n+  writer->Append(\"OperationBuilder opBuilder = scope.graph().opBuilder(\\\"\"\n+      + op.graph_op_name() + \"\\\", scope.makeOpName(\\\"\"\n+      + op_class.name() + \"\\\"));\");\n+  writer->EndLine();\n+  for (const ArgumentSpec& input : op.inputs()) {\n+    if (input.iterable()) {\n+      writer->Append(\"opBuilder.addInputList(Operands.asOutputs(\"\n+          + input.var().name() + \"));\");\n+      writer->EndLine();\n+    } else {\n+      writer->Append(\"opBuilder.addInput(\" + input.var().name()\n+          + \".asOutput());\");\n+      writer->EndLine();\n+    }\n+  }\n+  for (const AttributeSpec& attribute : op.attributes()) {\n+    WriteSetAttrDirective(attribute, false, writer);\n+  }\n+  if (!op.optional_attributes().empty()) {\n+    writer->BeginBlock(\"if (options != null)\")\n+        .BeginBlock(\"for (Options opts : options)\");\n+    for (const AttributeSpec& attribute : op.optional_attributes()) {\n+      writer->BeginBlock(\"if (opts.\" + attribute.var().name() + \" != null)\");\n+      WriteSetAttrDirective(attribute, true, writer);\n+      writer->EndBlock();\n+    }\n+    writer->EndBlock().EndBlock();\n+  }\n+  writer->Append(\"return new \")\n+      .AppendType(op_class)\n+      .Append(\"(opBuilder.build());\")\n+      .EndLine();\n+  writer->EndMethod();\n+}\n+\n+void RenderConstructor(const OpSpec& op, const Type& op_class,\n+    SourceWriter* writer) {\n+  Variable operation =\n+      Variable::Create(\"operation\", Type::Class(\"Operation\", \"org.tensorflow\"));\n+  Method constructor = Method::ConstructorFor(op_class).add_argument(operation);\n+  for (const ArgumentSpec& output : op.outputs()) {\n+    if (output.iterable() && !output.type().unknown()) {\n+      constructor.add_annotation(\n+          Annotation::Create(\"SuppressWarnings\").attributes(\"\\\"unchecked\\\"\"));\n+      break;\n+    }\n+  }\n+  writer->BeginMethod(constructor, PRIVATE)\n+      .Append(\"super(operation);\")\n+      .EndLine();\n+  if (op.outputs().size() > 0) {\n+    writer->Append(\"int outputIdx = 0;\")\n+        .EndLine();\n+    for (const ArgumentSpec& output : op.outputs()) {\n+      if (output.iterable()) {\n+        string var_length = output.var().name() + \"Length\";\n+        writer->Append(\"int \" + var_length)\n+            .Append(\" = operation.outputListLength(\\\"\" + output.op_def_name()\n+                + \"\\\");\")\n+            .EndLine()\n+            .Append(output.var().name() + \" = Arrays.asList(\");\n+        if (!output.type().unknown()) {\n+          writer->Append(\"(\")\n+              .AppendType(output.var().type().parameters().front())\n+              .Append(\"[])\");\n+        }\n+        writer->Append(\"operation.outputList(outputIdx, \" + var_length + \"));\")\n+            .EndLine()\n+            .Append(\"outputIdx += \" + var_length + \";\")\n+            .EndLine();\n+      } else {\n+        writer->Append(output.var().name()\n+                + \" = operation.output(outputIdx++);\")\n+            .EndLine();\n+      }\n+    }\n+  }\n+  writer->EndMethod();\n+}\n+\n+void RenderGettersAndSetters(const OpSpec& op, SourceWriter* writer) {\n+  for (const AttributeSpec& attr : op.optional_attributes()) {\n+    Method setter =\n+        Method::Create(attr.var().name(), Type::Class(\"Options\"));\n+    Javadoc setter_doc = Javadoc::Create();\n+    AddArgument(attr.var(), attr.description(), &setter, &setter_doc);\n+    writer->BeginMethod(setter, PUBLIC|STATIC, &setter_doc)\n+        .Append(\"return new Options().\" + attr.var().name() + \"(\"\n+            + attr.var().name() + \");\")\n+        .EndLine()\n+        .EndMethod();\n+  }\n+  for (const ArgumentSpec& output : op.outputs()) {\n+    Method getter = Method::Create(output.var().name(), output.var().type());\n+    Javadoc getter_doc = Javadoc::Create(output.description());\n+    writer->BeginMethod(getter, PUBLIC, &getter_doc)\n+        .Append(\"return \" + output.var().name() + \";\")\n+        .EndLine()\n+        .EndMethod();\n+  }\n+}\n \n-OpGenerator::OpGenerator() : env(Env::Default()) {}\n+void RenderInterfaceImpl(const OpSpec& op, RenderMode mode,\n+    SourceWriter* writer) {\n+  ArgumentSpec output = op.outputs().front();\n \n-OpGenerator::~OpGenerator() {}\n+  if (mode == SINGLE_OUTPUT) {\n+    bool cast2obj = output.type().unknown();\n+    Type return_type = Type::Class(\"Output\", \"org.tensorflow\")\n+        .add_parameter(cast2obj ? Type::Class(\"Object\") : output.type());\n+    Method as_output = Method::Create(\"asOutput\", return_type)\n+        .add_annotation(Annotation::Create(\"Override\"));\n+    if (cast2obj) {\n+      as_output.add_annotation(\n+          Annotation::Create(\"SuppressWarnings\").attributes(\"\\\"unchecked\\\"\"));\n+    }\n+    writer->BeginMethod(as_output, PUBLIC);\n+    if (cast2obj) {\n+      writer->Append(\"return (\").AppendType(return_type).Append(\") \");\n+    } else {\n+      writer->Append(\"return \");\n+    }\n+    writer->Append(output.var().name() + \";\")\n+        .EndLine()\n+        .EndMethod();\n \n-Status OpGenerator::Run(const OpList& ops, const string& lib_name,\n-                        const string& base_package, const string& output_dir) {\n-  const string package =\n-      base_package + '.' + str_util::StringReplace(lib_name, \"_\", \"\", true);\n-  const string package_path =\n-      output_dir + '/' + str_util::StringReplace(package, \".\", \"/\", true);\n-  const string group = CamelCase(lib_name, '_', false);\n+  } else if (mode == SINGLE_LIST_OUTPUT) {\n+    Type operand = Type::Interface(\"Operand\", \"org.tensorflow\");\n+    if (output.type().unknown()) {\n+      operand.add_parameter(Type::Class(\"Object\"));\n+    } else {\n+      operand.add_parameter(output.type());\n+    }\n+    Type return_type = Type::Interface(\"Iterator\", \"java.util\")\n+        .add_parameter(operand);\n+    Method iterator = Method::Create(\"iterator\", return_type)\n+        .add_annotation(Annotation::Create(\"Override\"))\n+        .add_annotation(Annotation::Create(\"SuppressWarnings\")\n+            .attributes(\"{\\\"rawtypes\\\", \\\"unchecked\\\"}\"));\n+    // cast the output list using a raw List\n+    writer->BeginMethod(iterator, PUBLIC)\n+        .Append(\"return (\" + return_type.name() + \") \")\n+        .Append(output.var().name() + \".iterator();\")\n+        .EndLine()\n+        .EndMethod();\n+  }\n+}\n \n-  if (!env->FileExists(package_path).ok()) {\n-    TF_CHECK_OK(env->RecursivelyCreateDir(package_path));\n+void RenderOptionsClass(const OpSpec& op, const Type& op_class,\n+    SourceWriter* writer) {\n+  Type options_class = Type::Class(\"Options\");\n+  Javadoc options_doc = Javadoc::Create(\n+      \"Optional attributes for {@link \" + op_class.full_name() + \"}\");\n+  writer->BeginInnerType(options_class, PUBLIC | STATIC, &options_doc);\n+  for (const AttributeSpec& attr : op.optional_attributes()) {\n+    Method setter = Method::Create(attr.var().name(), options_class);\n+    Javadoc setter_doc = Javadoc::Create();\n+    AddArgument(attr.var(), attr.description(), &setter, &setter_doc);\n+    writer->BeginMethod(setter, PUBLIC, &setter_doc)\n+        .Append(\"this.\" + attr.var().name() + \" = \" + attr.var().name() + \";\")\n+        .EndLine()\n+        .Append(\"return this;\")\n+        .EndLine()\n+        .EndMethod();\n   }\n+  writer->EndLine();\n+  for (const AttributeSpec& optional_attribute : op.optional_attributes()) {\n+    writer->WriteField(optional_attribute.var(), PRIVATE);\n+  }\n+  Method constructor = Method::ConstructorFor(options_class);\n+  writer->BeginMethod(constructor, PRIVATE).EndMethod();\n+  writer->EndType();\n+}\n \n-  LOG(INFO) << \"Generating Java wrappers for '\" << lib_name << \"' operations\";\n-  // TODO(karllessard) generate wrappers from list of ops\n+inline Type ClassOf(const EndpointSpec& endpoint, const string& base_package) {\n+  return Type::Class(endpoint.name(),\n+      base_package + \".\" + str_util::Lowercase(endpoint.package()));\n+}\n \n+void GenerateOp(const OpSpec& op, const EndpointSpec& endpoint,\n+    const string& base_package, const string& output_dir, Env* env,\n+    const std::tm* timestamp) {\n+  Type op_class(ClassOf(endpoint, base_package)\n+      .add_supertype(Type::Class(\"PrimitiveOp\", \"org.tensorflow.op\")));\n+  Javadoc op_javadoc(endpoint.javadoc());\n+\n+  // op interfaces\n+  RenderMode mode = DEFAULT;\n+  if (op.outputs().size() == 1) {\n+    const ArgumentSpec& output = op.outputs().front();\n+    Type operand_type(output.type().unknown() ?\n+        Type::Class(\"Object\") : output.type());\n+    Type operand_inf(Type::Interface(\"Operand\", \"org.tensorflow\")\n+        .add_parameter(operand_type));\n+    if (output.iterable()) {\n+      mode = SINGLE_LIST_OUTPUT;\n+      op_class.add_supertype(Type::IterableOf(operand_inf));\n+    } else {\n+      mode = SINGLE_OUTPUT;\n+      op_class.add_supertype(operand_inf);\n+    }\n+  }\n+  // op generic parameters\n+  std::set<string> generics;\n+  for (const ArgumentSpec& output : op.outputs()) {\n+    if (output.type().kind() == Type::GENERIC && !output.type().unknown()\n+        && generics.find(output.type().name()) == generics.end()) {\n+      op_class.add_parameter(output.type());\n+      op_javadoc.add_param_tag(\"<\" + output.type().name() + \">\",\n+          \"data type for {@code \" + output.var().name() + \"()} output\");\n+      generics.insert(output.type().name());\n+    }\n+  }\n+  // op annotations\n+  char date[20];\n+  strftime(date, sizeof date, \"%FT%TZ\", timestamp);\n+  op_class.add_annotation(Annotation::Create(\"Generated\", \"javax.annotation\")\n+      .attributes(string(\"value = \\\"op_generator\\\", date = \\\"\") + date + \"\\\"\"));\n+  if (endpoint.deprecated()) {\n+    op_class.add_annotation(Annotation::Create(\"Deprecated\"));\n+    string explanation;\n+    if (!op.endpoints().front().deprecated()) {\n+      explanation = \"use {@link \" +\n+          ClassOf(op.endpoints().front(), base_package).full_name()\n+          + \"} instead\";\n+    } else {\n+      explanation = op.deprecation_explanation();\n+    }\n+    op_javadoc.add_tag(\"deprecated\", explanation);\n+  }\n+  if (!op.hidden()) {\n+    // expose the op in the Ops Graph API only if it is visible\n+    op_class.add_annotation(\n+        Annotation::Create(\"Operator\", \"org.tensorflow.op.annotation\")\n+          .attributes(\"group = \\\"\" + endpoint.package() + \"\\\"\"));\n+  }\n+  // create op class file\n+  string op_dir = io::JoinPath(output_dir,\n+      str_util::StringReplace(op_class.package(), \".\", \"/\", true));\n+  if (!env->FileExists(op_dir).ok()) {\n+    TF_CHECK_OK(Env::Default()->RecursivelyCreateDir(op_dir));\n+  }\n+  std::unique_ptr<tensorflow::WritableFile> op_file;\n+  TF_CHECK_OK(env->NewWritableFile(\n+      io::JoinPath(op_dir, op_class.name() + \".java\"), &op_file));\n+\n+  // render endpoint source code\n+  SourceFileWriter writer(op_file.get());\n+  std::list<Type> dependencies;\n+  CollectOpDependencies(op, mode, &dependencies);\n+  writer.WriteFromFile(kLicenseSnippet)\n+      .EndLine()\n+      .BeginType(op_class, PUBLIC|FINAL, &dependencies, &op_javadoc);\n+  if (!op.optional_attributes().empty()) {\n+    RenderOptionsClass(op, op_class, &writer);\n+  }\n+  RenderFactoryMethods(op, op_class, &writer);\n+  RenderGettersAndSetters(op, &writer);\n+  if (mode != DEFAULT) {\n+    RenderInterfaceImpl(op, mode, &writer);\n+  }\n+  writer.EndLine();\n+  for (const ArgumentSpec& output : op.outputs()) {\n+    writer.WriteField(output.var(), PRIVATE);\n+  }\n+  RenderConstructor(op, op_class, &writer);\n+  writer.EndType();\n+}\n+\n+}  // namespace\n+\n+Status OpGenerator::Run(const OpList& op_list, const string& base_package,\n+    const string& output_dir) {\n+  ApiDefMap api_map(op_list);\n+  if (!api_dirs_.empty()) {\n+    // Only load api files that correspond to the requested \"op_list\"\n+    for (const auto& op : op_list.op()) {\n+      for (const auto& api_def_dir : api_dirs_) {\n+        const std::string api_def_file_pattern =\n+            io::JoinPath(api_def_dir, \"api_def_\" + op.name() + \".pbtxt\");\n+        if (env_->FileExists(api_def_file_pattern).ok()) {\n+          TF_CHECK_OK(api_map.LoadFile(env_, api_def_file_pattern));\n+        }\n+      }\n+    }\n+  }\n+  api_map.UpdateDocs();\n+  time_t now;\n+  time(&now);\n+  for (const auto& op_def : op_list.op()) {\n+    const ApiDef* api_def = api_map.GetApiDef(op_def.name());\n+    if (api_def->visibility() != ApiDef::SKIP) {\n+      OpSpec op(OpSpec::Create(op_def, *api_def));\n+      for (const EndpointSpec& endpoint : op.endpoints()) {\n+        GenerateOp(op, endpoint, base_package, output_dir, env_, gmtime(&now));", "path": "tensorflow/java/src/gen/cc/op_generator.cc", "position": null, "original_position": 455, "commit_id": "3c799b44b841dc8c4e83fb3fbb61ad4146464f60", "original_commit_id": "d083215fc6f6ec8a314d7980c75a66449c474df6", "user": {"login": "asimshankar", "id": 16018, "node_id": "MDQ6VXNlcjE2MDE4", "avatar_url": "https://avatars2.githubusercontent.com/u/16018?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asimshankar", "html_url": "https://github.com/asimshankar", "followers_url": "https://api.github.com/users/asimshankar/followers", "following_url": "https://api.github.com/users/asimshankar/following{/other_user}", "gists_url": "https://api.github.com/users/asimshankar/gists{/gist_id}", "starred_url": "https://api.github.com/users/asimshankar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asimshankar/subscriptions", "organizations_url": "https://api.github.com/users/asimshankar/orgs", "repos_url": "https://api.github.com/users/asimshankar/repos", "events_url": "https://api.github.com/users/asimshankar/events{/privacy}", "received_events_url": "https://api.github.com/users/asimshankar/received_events", "type": "User", "site_admin": false}, "body": "I'd recommend against including the timestamp as an annotation in the generated files, that leads to spurious differences between identical builds.", "created_at": "2018-05-01T08:13:53Z", "updated_at": "2018-05-06T14:11:56Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/18192#discussion_r185183350", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/18192", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/185183350"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/18192#discussion_r185183350"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/18192"}}, "body_html": "<p>I'd recommend against including the timestamp as an annotation in the generated files, that leads to spurious differences between identical builds.</p>", "body_text": "I'd recommend against including the timestamp as an annotation in the generated files, that leads to spurious differences between identical builds."}