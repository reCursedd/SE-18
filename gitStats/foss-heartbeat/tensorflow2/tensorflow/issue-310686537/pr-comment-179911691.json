{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/179911691", "pull_request_review_id": 109203039, "id": 179911691, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE3OTkxMTY5MQ==", "diff_hunk": "@@ -0,0 +1,417 @@\n+/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include <map>\n+#include <vector>\n+#include <utility>\n+#include <string>\n+\n+#include \"tensorflow/core/framework/op.h\"\n+#include \"tensorflow/core/framework/types.h\"\n+#include \"tensorflow/core/lib/strings/str_util.h\"\n+#include \"tensorflow/core/platform/logging.h\"\n+#include \"tensorflow/java/src/gen/cc/op_parser.h\"\n+\n+namespace tensorflow {\n+namespace java {\n+namespace {\n+\n+string SnakeToCamelCase(const string& str, bool upper = false) {\n+  string result;\n+  bool cap = upper;\n+  for (string::const_iterator it = str.begin(); it != str.end(); ++it) {\n+    const char c = *it;\n+    if (c == '_') {\n+      cap = true;\n+    } else if (cap) {\n+      result += toupper(c);\n+      cap = false;\n+    } else {\n+      result += c;\n+    }\n+  }\n+  return result;\n+}\n+\n+bool IsRealNumber(DataType type) {\n+  for (DataType dt : RealNumberTypes()) {\n+    if (type == dt) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+bool IsRealNumbers(const AttrValue& values) {\n+  if (values.has_list()) {\n+    for (int i = 0; i < values.list().type_size(); ++i) {\n+      if (!IsRealNumber(values.list().type(i))) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+  return IsRealNumber(values.type());\n+}\n+\n+string ParseDocumentation(const string& text) {\n+  std::stringstream javadoc_text;\n+  string::const_iterator c_iter = text.cbegin();\n+  bool code = false;\n+  bool emphasis = false;\n+  bool list = false;\n+  while (c_iter != text.cend()) {\n+    char c = *c_iter++;\n+    int count = 1;\n+    switch (c) {\n+    case '\\n':\n+      if (!code) {\n+        // consumes all subsequent newlines, if there are more than one,\n+        // then there are two choices:\n+        // - if the next line starts with an asterisk, we are enumerating\n+        //   a list of items\n+        // - otherwise, we are starting a new paragraph\n+        for (; c_iter != text.cend() && *c_iter == '\\n'; ++count, ++c_iter) {}\n+        if (c_iter != text.cend()) {\n+          if (count > 1) {\n+            if (*c_iter != '*' && list) {\n+              javadoc_text << \"</li>\\n</ul>\\n\";\n+              list = false;\n+            } else if (*c_iter == '*' && !list) {\n+              javadoc_text << \"\\n<ul>\\n<li>\";\n+              list = true;\n+              c_iter++;\n+            } else {\n+              javadoc_text << \"\\n<p>\\n\";\n+            }\n+          } else if (list && *c_iter == '*') {\n+            javadoc_text << \"</li>\\n<li>\";\n+            c_iter++;\n+          } else {\n+            javadoc_text << '\\n';\n+          }\n+        }\n+      }\n+      break;\n+    case '`':\n+      // consumes all subsequent backquotes, those are use enclose code.\n+      // if there are more than 3, we are dealing with a pre-formatted block,\n+      // otherwise it is a single-line code snippet\n+      for (; c_iter != text.cend() && *c_iter == '`'; ++count, ++c_iter) {}\n+      if (count >= 3) {\n+        javadoc_text << (code ? \"\\n}</pre>\" : \"<pre>{@code\\n\");\n+      } else {\n+        javadoc_text << (code ? \"}\" : \"{@code \");\n+      }\n+      code = !code;\n+      break;\n+    case '*':\n+      if (!code) {\n+        // consumes all subsequent asterisks, if there are more than one, then\n+        // we put the text in bold, otherwise in italic\n+        for (; c_iter != text.cend() && *c_iter == '*'; ++count, ++c_iter) {}\n+        if (count > 1) {\n+          javadoc_text << (emphasis ? \"</b>\" : \"<b>\");\n+        } else {\n+          javadoc_text << (emphasis ? \"</i>\" : \"<i>\");\n+        }\n+        emphasis = !emphasis;\n+      } else {\n+        javadoc_text << '*';\n+      }\n+      break;\n+    default:\n+      javadoc_text << c;\n+      break;\n+    }\n+  }\n+  return javadoc_text.str();\n+}\n+\n+}  // namespace\n+\n+OpParser::OpParser(const OpDef& op_def, const ApiDef& api_def,\n+    const string& lib_name, const string& base_package)\n+  : op_def_(op_def), op_api_(api_def), lib_name_(lib_name),\n+    base_package_(base_package) {\n+}\n+\n+void OpParser::Parse(std::unique_ptr<OpSpec>* op_ptr) {\n+  visited_attrs_.clear();\n+  next_generic_ = 'T';\n+  op_ptr->reset(new OpSpec(op_api_.graph_op_name()));\n+  for (const string& next_input_name : op_api_.arg_order()) {\n+    for (int i = 0; i < op_def_.input_arg().size(); ++i) {\n+      if (op_def_.input_arg(i).name() == next_input_name) {\n+        ParseInput(op_def_.input_arg(i), op_api_.in_arg(i), op_ptr->get());\n+        break;\n+      }\n+    }\n+  }\n+  for (int i = 0; i < op_def_.attr().size(); ++i) {\n+    ParseAttribute(op_def_.attr(i), op_api_.attr(i), op_ptr->get());\n+  }\n+  for (int i = 0; i < op_def_.output_arg().size(); ++i) {\n+    ParseOutput(op_def_.output_arg(i), op_api_.out_arg(i), op_ptr->get());\n+  }\n+  BuildEndpoints(op_ptr->get());\n+}\n+\n+void OpParser::BuildEndpoints(OpSpec* op) {\n+  Javadoc op_doc = Javadoc::Create(ParseDocumentation(op_api_.summary()))\n+    .details(ParseDocumentation(op_api_.description()));\n+  std::vector<Type> op_supertypes;\n+  op_supertypes.push_back(Type::Class(\"PrimitiveOp\", \"org.tensorflow.op\"));\n+  std::map<string, const Type*> op_generics;\n+  for (const OpSpec::Operand& output : op->outputs()) {\n+    // declare generic output parameters at the Op class level\n+    const Type& data_type = output.data_type();\n+    if (data_type.kind() == Type::GENERIC && !data_type.unknown()\n+        && op_generics.find(data_type.name()) == op_generics.end()) {\n+      op_generics.insert(std::make_pair(data_type.name(), &data_type));\n+      op_doc.add_param_tag(\"<\" + data_type.name() + \">\",\n+          \"data type of output '\" + output.var().name() + \"'\");\n+    }\n+    // implement the Op as an (iteration of) Operand if it has only one output\n+    if (op->outputs().size() == 1) {\n+      Type operand_inf(Type::Interface(\"Operand\", \"org.tensorflow\"));\n+      operand_inf.add_parameter(data_type.unknown() ?\n+          Type::Class(\"Object\") : data_type);\n+      op_supertypes.push_back(output.iterable() ?\n+          Type::IterableOf(operand_inf) : operand_inf);\n+    }\n+  }\n+  for (const auto& endpoint_def : op_api_.endpoint()) {\n+    std::vector<string> name_tokens = str_util::Split(endpoint_def.name(), \".\");\n+    // if the endpoint specifies a package, use it, otherwise derive it from the\n+    // op library name.\n+    string name;\n+    string package;\n+    if (name_tokens.size() > 1) {\n+      package = str_util::Lowercase(name_tokens.at(0));\n+      name = name_tokens.at(1);\n+    } else {\n+      package = str_util::StringReplace(lib_name_, \"_\", \"\", true);\n+      name = name_tokens.at(0);\n+    }\n+    Type endpoint(Type::Class(name, base_package_ + \".\" + package));\n+    Javadoc endpoint_doc(op_doc);\n+    for (const auto& parameter : op_generics) {\n+      endpoint.add_parameter(*parameter.second);\n+    }\n+    for (const Type& supertype : op_supertypes) {\n+      endpoint.add_supertype(supertype);\n+    }\n+    if (endpoint_def.deprecation_version() > 0) {\n+      string explanation;\n+      if (op_api_.endpoint(0).deprecation_version() == 0) {\n+        explanation = \", use {@link \"\n+            + op->endpoints().at(0).type().full_name()\n+            + \"} instead\";\n+      } else {\n+        explanation = op_def_.deprecation().explanation();\n+      }\n+      endpoint_doc.add_tag(\"deprecated\", explanation);\n+      endpoint.add_annotation(Annotation::Create(\"Deprecated\"));\n+    }\n+    // only visible ops should be annotated for exposure in the Ops Graph API\n+    if (op_api_.visibility() != ApiDef::HIDDEN) {\n+      string group_name = SnakeToCamelCase(lib_name_);\n+      endpoint.add_annotation(\n+          Annotation::Create(\"Operator\", \"org.tensorflow.op.annotation\")\n+            .attributes(\"group = \\\"\" + group_name + \"\\\"\"));\n+    }\n+    op->add_endpoint(endpoint, endpoint_doc);\n+  }\n+}\n+\n+void OpParser::ParseInput(const OpDef_ArgDef& input_def,\n+    const ApiDef::Arg& input_api, OpSpec* op) {\n+  bool iterable = false;\n+  Type data_type = DataTypeOf(input_def, &iterable);\n+  Type type = Type::Interface(\"Operand\", \"org.tensorflow\")\n+    .add_parameter(data_type);\n+  if (iterable) {\n+    type = Type::IterableOf(type);\n+  }\n+  op->add_input(OpSpec::Operand(input_api.name(),\n+      Variable::Create(SnakeToCamelCase(input_api.rename_to()), type),\n+      data_type,\n+      ParseDocumentation(input_api.description()),\n+      iterable));\n+}\n+\n+void OpParser::ParseOutput(const OpDef_ArgDef& output_def,\n+    const ApiDef::Arg& output_api, OpSpec* op) {\n+  bool iterable = false;\n+  Type data_type = DataTypeOf(output_def, &iterable);\n+  Type type = Type::Class(\"Output\", \"org.tensorflow\")\n+    .add_parameter(data_type);\n+  if (iterable) {\n+    type = Type::ListOf(type);\n+  }\n+  op->add_output(OpSpec::Operand(output_api.name(),\n+      Variable::Create(SnakeToCamelCase(output_api.rename_to()), type),\n+      data_type,\n+      ParseDocumentation(output_api.description()),\n+      iterable));\n+}\n+\n+void OpParser::ParseAttribute(const OpDef_AttrDef& attr_def,\n+    const ApiDef::Attr& attr_api, OpSpec* op) {\n+  // do not parse attributes already visited, they have probably been inferred\n+  // before as an input argument type\n+  if (visited_attrs_.find(attr_def.name()) != visited_attrs_.cend()) {\n+    return;\n+  }\n+  bool iterable = false;\n+  Type data_type = DataTypeOf(attr_def, &iterable);\n+  // generic attributes should be passed as an explicit type\n+  bool explicit_type = data_type.kind() == Type::GENERIC && !iterable;\n+  Type type = explicit_type ?\n+      Type::Class(\"Class\").add_parameter(data_type) : data_type;\n+  if (iterable) {\n+    type = Type::ListOf(data_type);\n+  }\n+  OpSpec::Operand attr(attr_api.name(),\n+      Variable::Create(SnakeToCamelCase(attr_api.rename_to()), type),\n+      data_type,\n+      ParseDocumentation(attr_api.description()),\n+      iterable);\n+  // attributes with a default value are optional\n+  if (attr_api.has_default_value() && !explicit_type) {\n+    op->add_option(attr);\n+  } else {\n+    op->add_attribute(attr);\n+  }\n+  visited_attrs_.insert(std::make_pair(attr_api.name(), data_type));\n+}\n+\n+Type OpParser::DataTypeOf(const OpDef_ArgDef& arg, bool* iterable_out) {\n+  if (!arg.number_attr().empty()) {\n+    visited_attrs_.insert(std::make_pair(arg.number_attr(), Type::Int()));\n+    *iterable_out = true;\n+  }\n+  if (arg.type() != DataType::DT_INVALID) {\n+    // resolve type from DataType\n+    switch (arg.type()) {\n+      case DataType::DT_BOOL:\n+        return Type::Class(\"Boolean\");\n+\n+      case DataType::DT_STRING:\n+        return Type::Class(\"String\");\n+\n+      case DataType::DT_FLOAT:\n+        return Type::Class(\"Float\");\n+\n+      case DataType::DT_DOUBLE:\n+        return Type::Class(\"Double\");\n+\n+      case DataType::DT_UINT8:\n+        return Type::Class(\"UInt8\", \"org.tensorflow.types\");\n+\n+      case DataType::DT_INT32:\n+        return Type::Class(\"Integer\");\n+\n+      case DataType::DT_INT64:\n+        return Type::Class(\"Long\");\n+\n+      case DataType::DT_RESOURCE:\n+        // TODO(karllessard) create a Resource utility class that could be\n+        // used to store a resource and its type (passed in a second argument).\n+        // For now, we need to force a wildcard and we will unfortunately lose\n+        // track of the resource type.\n+        return Type::Wildcard();\n+\n+      default:\n+        break;\n+    }\n+  } else {\n+    // resolve type from type attribute\n+    string attr_name = arg.type_attr();\n+    if (attr_name.empty()) {\n+      attr_name = arg.type_list_attr();\n+      if (!attr_name.empty()) {\n+        *iterable_out = true;\n+        Type type = Type::Wildcard();\n+        visited_attrs_.insert(std::make_pair(attr_name, type));\n+        return type;\n+      }\n+    }\n+    for (const auto& attr : op_def_.attr()) {\n+      if (attr.name() == attr_name) {\n+        Type type = DataTypeOf(attr, iterable_out);\n+        visited_attrs_.insert(std::make_pair(attr_name, type));\n+        return type;\n+      }\n+    }\n+  }\n+  LOG(WARNING) << \"Data type for arg \\\"\" << arg.name() << \"\\\" is unknown\";\n+  return Type::Wildcard();\n+}\n+\n+Type OpParser::DataTypeOf(const OpDef_AttrDef& attr, bool* iterable_out) {", "path": "tensorflow/java/src/gen/cc/op_parser.cc", "position": null, "original_position": 365, "commit_id": "3c799b44b841dc8c4e83fb3fbb61ad4146464f60", "original_commit_id": "d86cedc3c46cc46168c90aefc82993f50ac680f8", "user": {"login": "asimshankar", "id": 16018, "node_id": "MDQ6VXNlcjE2MDE4", "avatar_url": "https://avatars2.githubusercontent.com/u/16018?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asimshankar", "html_url": "https://github.com/asimshankar", "followers_url": "https://api.github.com/users/asimshankar/followers", "following_url": "https://api.github.com/users/asimshankar/following{/other_user}", "gists_url": "https://api.github.com/users/asimshankar/gists{/gist_id}", "starred_url": "https://api.github.com/users/asimshankar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asimshankar/subscriptions", "organizations_url": "https://api.github.com/users/asimshankar/orgs", "repos_url": "https://api.github.com/users/asimshankar/repos", "events_url": "https://api.github.com/users/asimshankar/events{/privacy}", "received_events_url": "https://api.github.com/users/asimshankar/received_events", "type": "User", "site_admin": false}, "body": "How about calling this `JavaTypeOf` instead of `DataTypeOf` to avoid confusion with what the `DataType` enum in TensorFlow means? Or maybe just `TypeOf` for consistency with the return value type. Same comment goes for the method above.", "created_at": "2018-04-07T08:18:18Z", "updated_at": "2018-05-06T14:11:56Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/18192#discussion_r179911691", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/18192", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/179911691"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/18192#discussion_r179911691"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/18192"}}, "body_html": "<p>How about calling this <code>JavaTypeOf</code> instead of <code>DataTypeOf</code> to avoid confusion with what the <code>DataType</code> enum in TensorFlow means? Or maybe just <code>TypeOf</code> for consistency with the return value type. Same comment goes for the method above.</p>", "body_text": "How about calling this JavaTypeOf instead of DataTypeOf to avoid confusion with what the DataType enum in TensorFlow means? Or maybe just TypeOf for consistency with the return value type. Same comment goes for the method above."}