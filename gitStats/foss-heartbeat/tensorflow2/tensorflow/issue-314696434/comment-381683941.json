{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/381683941", "html_url": "https://github.com/tensorflow/tensorflow/pull/18561#issuecomment-381683941", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/18561", "id": 381683941, "node_id": "MDEyOklzc3VlQ29tbWVudDM4MTY4Mzk0MQ==", "user": {"login": "yongtang", "id": 6932348, "node_id": "MDQ6VXNlcjY5MzIzNDg=", "avatar_url": "https://avatars0.githubusercontent.com/u/6932348?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yongtang", "html_url": "https://github.com/yongtang", "followers_url": "https://api.github.com/users/yongtang/followers", "following_url": "https://api.github.com/users/yongtang/following{/other_user}", "gists_url": "https://api.github.com/users/yongtang/gists{/gist_id}", "starred_url": "https://api.github.com/users/yongtang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yongtang/subscriptions", "organizations_url": "https://api.github.com/users/yongtang/orgs", "repos_url": "https://api.github.com/users/yongtang/repos", "events_url": "https://api.github.com/users/yongtang/events{/privacy}", "received_events_url": "https://api.github.com/users/yongtang/received_events", "type": "User", "site_admin": false}, "created_at": "2018-04-16T17:24:40Z", "updated_at": "2018-04-16T17:24:40Z", "author_association": "MEMBER", "body_html": "<p>Thanks <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=577277\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/martinwicke\">@martinwicke</a>. I took a look at the implementation and verified that all pairs works.</p>\n<p>In case of complex data types, for complex type -&gt; real type, only the real part is returned. For real type to complex type, the imag part is set to 0 for returned value. For example,</p>\n<pre><code># python\n&gt;&gt;&gt; import tensorflow as tf\n&gt;&gt;&gt; v = tf.cast(tf.constant(1j), tf.float32)\n&gt;&gt;&gt; tf.Session().run(v)\n0.0\n&gt;&gt;&gt; \n</code></pre>\n<p>This seems to match numpy behavior with reasoning mentioned in the comment of the source code:</p>\n<p><div class=\"border rounded-1 my-2\">\n  <div class=\"f6 px-3 py-2 lh-condensed border-bottom bg-gray-light\">\n    <p class=\"mb-0 text-bold\">\n      <a href=\"https://github.com/tensorflow/tensorflow/blob/982549ea3423df4270ff154e5c764beb43d472da/tensorflow/core/kernels/cast_op.h#L75-L94\">tensorflow/tensorflow/core/kernels/cast_op.h</a>\n    </p>\n    <p class=\"mb-0 text-gray-light\">\n        Lines 75 to 94\n      in\n      <a data-pjax=\"true\" class=\"commit-tease-sha\" href=\"/tensorflow/tensorflow/commit/982549ea3423df4270ff154e5c764beb43d472da\">982549e</a>\n    </p>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper blob-wrapper-embedded data\">\n    <table class=\"highlight tab-size mb-0 js-file-line-container\" data-tab-size=\"8\">\n\n        <tbody><tr class=\"border-0\">\n          <td id=\"L75\" class=\"blob-num border-0 px-3 py-0 bg-white js-line-number\" data-line-number=\"75\"></td>\n          <td id=\"LC75\" class=\"blob-code border-0 px-3 py-0 bg-white blob-code-inner js-file-line\"> <span class=\"pl-c\"><span class=\"pl-c\">//</span> Eigen can't convert to/from complex numbers, because it is limited to cases</span> </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L76\" class=\"blob-num border-0 px-3 py-0 bg-white js-line-number\" data-line-number=\"76\"></td>\n          <td id=\"LC76\" class=\"blob-code border-0 px-3 py-0 bg-white blob-code-inner js-file-line\"> <span class=\"pl-c\"><span class=\"pl-c\">//</span> that can be static_casted. But numpy is able to cast to/from complex, which</span> </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L77\" class=\"blob-num border-0 px-3 py-0 bg-white js-line-number\" data-line-number=\"77\"></td>\n          <td id=\"LC77\" class=\"blob-code border-0 px-3 py-0 bg-white blob-code-inner js-file-line\"> <span class=\"pl-c\"><span class=\"pl-c\">//</span> we want to replicate. So we add specializations for complex here.</span> </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L78\" class=\"blob-num border-0 px-3 py-0 bg-white js-line-number\" data-line-number=\"78\"></td>\n          <td id=\"LC78\" class=\"blob-code border-0 px-3 py-0 bg-white blob-code-inner js-file-line\"> <span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">typename</span> From, <span class=\"pl-k\">typename</span> To&gt; </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L79\" class=\"blob-num border-0 px-3 py-0 bg-white js-line-number\" data-line-number=\"79\"></td>\n          <td id=\"LC79\" class=\"blob-code border-0 px-3 py-0 bg-white blob-code-inner js-file-line\"> <span class=\"pl-k\">struct</span> <span class=\"pl-en\">scalar_cast_op</span>&lt;std::complex&lt;From&gt;, To&gt; { </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L80\" class=\"blob-num border-0 px-3 py-0 bg-white js-line-number\" data-line-number=\"80\"></td>\n          <td id=\"LC80\" class=\"blob-code border-0 px-3 py-0 bg-white blob-code-inner js-file-line\">   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE To </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L81\" class=\"blob-num border-0 px-3 py-0 bg-white js-line-number\" data-line-number=\"81\"></td>\n          <td id=\"LC81\" class=\"blob-code border-0 px-3 py-0 bg-white blob-code-inner js-file-line\">   <span class=\"pl-en\">operator</span>()(<span class=\"pl-k\">const</span> std::complex&lt;From&gt;&amp; a) <span class=\"pl-k\">const</span> { </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L82\" class=\"blob-num border-0 px-3 py-0 bg-white js-line-number\" data-line-number=\"82\"></td>\n          <td id=\"LC82\" class=\"blob-code border-0 px-3 py-0 bg-white blob-code-inner js-file-line\">     <span class=\"pl-c\"><span class=\"pl-c\">//</span> Replicate numpy behavior of returning just the real part</span> </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L83\" class=\"blob-num border-0 px-3 py-0 bg-white js-line-number\" data-line-number=\"83\"></td>\n          <td id=\"LC83\" class=\"blob-code border-0 px-3 py-0 bg-white blob-code-inner js-file-line\">     <span class=\"pl-k\">return</span> <span class=\"pl-k\">static_cast</span>&lt;To&gt;(a.<span class=\"pl-c1\">real</span>()); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L84\" class=\"blob-num border-0 px-3 py-0 bg-white js-line-number\" data-line-number=\"84\"></td>\n          <td id=\"LC84\" class=\"blob-code border-0 px-3 py-0 bg-white blob-code-inner js-file-line\">   } </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L85\" class=\"blob-num border-0 px-3 py-0 bg-white js-line-number\" data-line-number=\"85\"></td>\n          <td id=\"LC85\" class=\"blob-code border-0 px-3 py-0 bg-white blob-code-inner js-file-line\"> }; </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L86\" class=\"blob-num border-0 px-3 py-0 bg-white js-line-number\" data-line-number=\"86\"></td>\n          <td id=\"LC86\" class=\"blob-code border-0 px-3 py-0 bg-white blob-code-inner js-file-line\">  </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L87\" class=\"blob-num border-0 px-3 py-0 bg-white js-line-number\" data-line-number=\"87\"></td>\n          <td id=\"LC87\" class=\"blob-code border-0 px-3 py-0 bg-white blob-code-inner js-file-line\"> <span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">typename</span> From, <span class=\"pl-k\">typename</span> To&gt; </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L88\" class=\"blob-num border-0 px-3 py-0 bg-white js-line-number\" data-line-number=\"88\"></td>\n          <td id=\"LC88\" class=\"blob-code border-0 px-3 py-0 bg-white blob-code-inner js-file-line\"> <span class=\"pl-k\">struct</span> <span class=\"pl-en\">scalar_cast_op</span>&lt;From, std::complex&lt;To&gt;&gt; { </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L89\" class=\"blob-num border-0 px-3 py-0 bg-white js-line-number\" data-line-number=\"89\"></td>\n          <td id=\"LC89\" class=\"blob-code border-0 px-3 py-0 bg-white blob-code-inner js-file-line\">   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE std::complex&lt;To&gt; <span class=\"pl-en\">operator</span>()( </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L90\" class=\"blob-num border-0 px-3 py-0 bg-white js-line-number\" data-line-number=\"90\"></td>\n          <td id=\"LC90\" class=\"blob-code border-0 px-3 py-0 bg-white blob-code-inner js-file-line\">       <span class=\"pl-k\">const</span> From&amp; a) <span class=\"pl-k\">const</span> { </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L91\" class=\"blob-num border-0 px-3 py-0 bg-white js-line-number\" data-line-number=\"91\"></td>\n          <td id=\"LC91\" class=\"blob-code border-0 px-3 py-0 bg-white blob-code-inner js-file-line\">     <span class=\"pl-c\"><span class=\"pl-c\">//</span> Replicate numpy behavior of setting the imaginary part to 0</span> </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L92\" class=\"blob-num border-0 px-3 py-0 bg-white js-line-number\" data-line-number=\"92\"></td>\n          <td id=\"LC92\" class=\"blob-code border-0 px-3 py-0 bg-white blob-code-inner js-file-line\">     <span class=\"pl-k\">return</span> std::complex&lt;To&gt;(<span class=\"pl-k\">static_cast</span>&lt;To&gt;(a), <span class=\"pl-c1\">To</span>(<span class=\"pl-c1\">0</span>)); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L93\" class=\"blob-num border-0 px-3 py-0 bg-white js-line-number\" data-line-number=\"93\"></td>\n          <td id=\"LC93\" class=\"blob-code border-0 px-3 py-0 bg-white blob-code-inner js-file-line\">   } </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L94\" class=\"blob-num border-0 px-3 py-0 bg-white js-line-number\" data-line-number=\"94\"></td>\n          <td id=\"LC94\" class=\"blob-code border-0 px-3 py-0 bg-white blob-code-inner js-file-line\"> }; </td>\n        </tr>\n    </tbody></table>\n  </div>\n</div>\n</p>\n<p>I have updated the PR with added docs to mentioned the processing of complex data types. Please take a look.</p>", "body_text": "Thanks @martinwicke. I took a look at the implementation and verified that all pairs works.\nIn case of complex data types, for complex type -> real type, only the real part is returned. For real type to complex type, the imag part is set to 0 for returned value. For example,\n# python\n>>> import tensorflow as tf\n>>> v = tf.cast(tf.constant(1j), tf.float32)\n>>> tf.Session().run(v)\n0.0\n>>> \n\nThis seems to match numpy behavior with reasoning mentioned in the comment of the source code:\n\n  \n    \n      tensorflow/tensorflow/core/kernels/cast_op.h\n    \n    \n        Lines 75 to 94\n      in\n      982549e\n    \n    \n    \n    \n\n        \n          \n           // Eigen can't convert to/from complex numbers, because it is limited to cases \n        \n\n        \n          \n           // that can be static_casted. But numpy is able to cast to/from complex, which \n        \n\n        \n          \n           // we want to replicate. So we add specializations for complex here. \n        \n\n        \n          \n           template <typename From, typename To> \n        \n\n        \n          \n           struct scalar_cast_op<std::complex<From>, To> { \n        \n\n        \n          \n             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE To \n        \n\n        \n          \n             operator()(const std::complex<From>& a) const { \n        \n\n        \n          \n               // Replicate numpy behavior of returning just the real part \n        \n\n        \n          \n               return static_cast<To>(a.real()); \n        \n\n        \n          \n             } \n        \n\n        \n          \n           }; \n        \n\n        \n          \n            \n        \n\n        \n          \n           template <typename From, typename To> \n        \n\n        \n          \n           struct scalar_cast_op<From, std::complex<To>> { \n        \n\n        \n          \n             EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE std::complex<To> operator()( \n        \n\n        \n          \n                 const From& a) const { \n        \n\n        \n          \n               // Replicate numpy behavior of setting the imaginary part to 0 \n        \n\n        \n          \n               return std::complex<To>(static_cast<To>(a), To(0)); \n        \n\n        \n          \n             } \n        \n\n        \n          \n           }; \n        \n    \n  \n\n\nI have updated the PR with added docs to mentioned the processing of complex data types. Please take a look.", "body": "Thanks @martinwicke. I took a look at the implementation and verified that all pairs works.\r\n\r\nIn case of complex data types, for complex type -> real type, only the real part is returned. For real type to complex type, the imag part is set to 0 for returned value. For example,\r\n```\r\n# python\r\n>>> import tensorflow as tf\r\n>>> v = tf.cast(tf.constant(1j), tf.float32)\r\n>>> tf.Session().run(v)\r\n0.0\r\n>>> \r\n```\r\n\r\nThis seems to match numpy behavior with reasoning mentioned in the comment of the source code:\r\n\r\nhttps://github.com/tensorflow/tensorflow/blob/982549ea3423df4270ff154e5c764beb43d472da/tensorflow/core/kernels/cast_op.h#L75-L94\r\n\r\nI have updated the PR with added docs to mentioned the processing of complex data types. Please take a look."}