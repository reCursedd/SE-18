{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/14623", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/14623/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/14623/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/14623/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/14623", "id": 274540563, "node_id": "MDU6SXNzdWUyNzQ1NDA1NjM=", "number": 14623, "title": "[BUG] tf.while_loop creates a seg-fault when setting parallel_iterations to high values", "user": {"login": "georgh", "id": 1831252, "node_id": "MDQ6VXNlcjE4MzEyNTI=", "avatar_url": "https://avatars2.githubusercontent.com/u/1831252?v=4", "gravatar_id": "", "url": "https://api.github.com/users/georgh", "html_url": "https://github.com/georgh", "followers_url": "https://api.github.com/users/georgh/followers", "following_url": "https://api.github.com/users/georgh/following{/other_user}", "gists_url": "https://api.github.com/users/georgh/gists{/gist_id}", "starred_url": "https://api.github.com/users/georgh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/georgh/subscriptions", "organizations_url": "https://api.github.com/users/georgh/orgs", "repos_url": "https://api.github.com/users/georgh/repos", "events_url": "https://api.github.com/users/georgh/events{/privacy}", "received_events_url": "https://api.github.com/users/georgh/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "open", "locked": false, "assignee": {"login": "skye", "id": 88808, "node_id": "MDQ6VXNlcjg4ODA4", "avatar_url": "https://avatars1.githubusercontent.com/u/88808?v=4", "gravatar_id": "", "url": "https://api.github.com/users/skye", "html_url": "https://github.com/skye", "followers_url": "https://api.github.com/users/skye/followers", "following_url": "https://api.github.com/users/skye/following{/other_user}", "gists_url": "https://api.github.com/users/skye/gists{/gist_id}", "starred_url": "https://api.github.com/users/skye/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/skye/subscriptions", "organizations_url": "https://api.github.com/users/skye/orgs", "repos_url": "https://api.github.com/users/skye/repos", "events_url": "https://api.github.com/users/skye/events{/privacy}", "received_events_url": "https://api.github.com/users/skye/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "skye", "id": 88808, "node_id": "MDQ6VXNlcjg4ODA4", "avatar_url": "https://avatars1.githubusercontent.com/u/88808?v=4", "gravatar_id": "", "url": "https://api.github.com/users/skye", "html_url": "https://github.com/skye", "followers_url": "https://api.github.com/users/skye/followers", "following_url": "https://api.github.com/users/skye/following{/other_user}", "gists_url": "https://api.github.com/users/skye/gists{/gist_id}", "starred_url": "https://api.github.com/users/skye/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/skye/subscriptions", "organizations_url": "https://api.github.com/users/skye/orgs", "repos_url": "https://api.github.com/users/skye/repos", "events_url": "https://api.github.com/users/skye/events{/privacy}", "received_events_url": "https://api.github.com/users/skye/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 5, "created_at": "2017-11-16T14:45:07Z", "updated_at": "2018-11-14T19:14:03Z", "closed_at": null, "author_association": "NONE", "body_html": "<h3>System information</h3>\n<ul>\n<li><strong>Have I written custom code (as opposed to using a stock example script provided in TensorFlow)</strong>: Yes</li>\n<li><strong>OS Platform and Distribution (e.g., Linux Ubuntu 16.04)</strong>: Ubuntu 16.04</li>\n<li><strong>TensorFlow installed from (source or binary)</strong>: both</li>\n<li><strong>TensorFlow version (use command below)</strong>: 1.3 / 1.4</li>\n<li><strong>Python version</strong>: 3.6</li>\n<li><strong>Bazel version (if compiling from source)</strong>: 0.5.4</li>\n<li><strong>GCC/Compiler version (if compiling from source)</strong>: 5.4.0</li>\n<li><strong>CUDA/cuDNN version</strong>: 8</li>\n<li><strong>GPU model and memory</strong>: Tesla P100-PCIE-16GB</li>\n<li><strong>Exact command to reproduce</strong>:</li>\n</ul>\n<h3>Describe the problem</h3>\n<p>The following code crashes on all of my test systems, with tensorflow 1.3 or 1.4.<br>\nDoesn't matter if build with MKL or without or using the pip-version.</p>\n<pre><code>import numpy as np\nimport tensorflow as tf\n\nnum_dim = 20\nFORMAT = tf.float64 #32 or 64 does not matter\nn = 3500 #reducing the number results in normal execution\n\ndef simpeLoop(alpha):\n      i = tf.constant(0)\n      m0 = tf.zeros([num_dim, 1], dtype=FORMAT)\n      cond = lambda i, m: i &lt; n\n      def body(ic, vec): \n            #a meaningless example, summing up the first num_dim elements of a vector \n            op = alpha[ic * num_dim:(ic + 1) * num_dim, :]\n            # with tf.control_dependencies([op]): #if you uncomment this, it will not fault!\n            return ic + 1, vec + op\n      loop = tf.while_loop(cond, body, [i, m0], parallel_iterations=10**4, back_prop=False)\n      return loop[1]\n\nwith tf.device('/cpu:0'):\n      alpha = tf.placeholder(FORMAT, [None, 1], name=\"alpha\")\n      fdict = {\n          alpha: np.random.rand(n * num_dim, 1),\n      }\n      op = simpeLoop(alpha)\n      op = tf.reduce_sum(op) #not necessary for the seg fault\n      init = tf.global_variables_initializer()\n\nconfig = tf.ConfigProto()\nthreads = 1\nconfig.intra_op_parallelism_threads = threads\nconfig.inter_op_parallelism_threads = threads\nsess = tf.Session(config=config)\nsess.run(init, feed_dict=fdict)\nprint(\"init\")\nprint(sess.run(op, feed_dict=fdict))\n</code></pre>\n<p>Adding the control_dependencies results in normal execution.</p>\n<p>The documentation states</p>\n<blockquote>\n<p>The maximum number of parallel iterations can be controlled by parallel_iterations, which gives users some control over memory consumption and execution order</p>\n</blockquote>\n<p>so I would expect parallel_iterations to be some kind of upper bound.<br>\nSmall tests like presented in  <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"256453334\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/tensorflow/tensorflow/issues/12937\" data-hovercard-type=\"issue\" data-hovercard-url=\"/tensorflow/tensorflow/issues/12937/hovercard\" href=\"https://github.com/tensorflow/tensorflow/issues/12937\">#12937</a> showed that increasing the parallel_iterations number results in higher performance. But setting it to high results in a seg fault.</p>", "body_text": "System information\n\nHave I written custom code (as opposed to using a stock example script provided in TensorFlow): Yes\nOS Platform and Distribution (e.g., Linux Ubuntu 16.04): Ubuntu 16.04\nTensorFlow installed from (source or binary): both\nTensorFlow version (use command below): 1.3 / 1.4\nPython version: 3.6\nBazel version (if compiling from source): 0.5.4\nGCC/Compiler version (if compiling from source): 5.4.0\nCUDA/cuDNN version: 8\nGPU model and memory: Tesla P100-PCIE-16GB\nExact command to reproduce:\n\nDescribe the problem\nThe following code crashes on all of my test systems, with tensorflow 1.3 or 1.4.\nDoesn't matter if build with MKL or without or using the pip-version.\nimport numpy as np\nimport tensorflow as tf\n\nnum_dim = 20\nFORMAT = tf.float64 #32 or 64 does not matter\nn = 3500 #reducing the number results in normal execution\n\ndef simpeLoop(alpha):\n      i = tf.constant(0)\n      m0 = tf.zeros([num_dim, 1], dtype=FORMAT)\n      cond = lambda i, m: i < n\n      def body(ic, vec): \n            #a meaningless example, summing up the first num_dim elements of a vector \n            op = alpha[ic * num_dim:(ic + 1) * num_dim, :]\n            # with tf.control_dependencies([op]): #if you uncomment this, it will not fault!\n            return ic + 1, vec + op\n      loop = tf.while_loop(cond, body, [i, m0], parallel_iterations=10**4, back_prop=False)\n      return loop[1]\n\nwith tf.device('/cpu:0'):\n      alpha = tf.placeholder(FORMAT, [None, 1], name=\"alpha\")\n      fdict = {\n          alpha: np.random.rand(n * num_dim, 1),\n      }\n      op = simpeLoop(alpha)\n      op = tf.reduce_sum(op) #not necessary for the seg fault\n      init = tf.global_variables_initializer()\n\nconfig = tf.ConfigProto()\nthreads = 1\nconfig.intra_op_parallelism_threads = threads\nconfig.inter_op_parallelism_threads = threads\nsess = tf.Session(config=config)\nsess.run(init, feed_dict=fdict)\nprint(\"init\")\nprint(sess.run(op, feed_dict=fdict))\n\nAdding the control_dependencies results in normal execution.\nThe documentation states\n\nThe maximum number of parallel iterations can be controlled by parallel_iterations, which gives users some control over memory consumption and execution order\n\nso I would expect parallel_iterations to be some kind of upper bound.\nSmall tests like presented in  #12937 showed that increasing the parallel_iterations number results in higher performance. But setting it to high results in a seg fault.", "body": "### System information\r\n- **Have I written custom code (as opposed to using a stock example script provided in TensorFlow)**: Yes\r\n- **OS Platform and Distribution (e.g., Linux Ubuntu 16.04)**: Ubuntu 16.04\r\n- **TensorFlow installed from (source or binary)**: both\r\n- **TensorFlow version (use command below)**: 1.3 / 1.4\r\n- **Python version**: 3.6\r\n- **Bazel version (if compiling from source)**: 0.5.4\r\n- **GCC/Compiler version (if compiling from source)**: 5.4.0\r\n- **CUDA/cuDNN version**: 8\r\n- **GPU model and memory**: Tesla P100-PCIE-16GB\r\n- **Exact command to reproduce**:\r\n### Describe the problem\r\n\r\nThe following code crashes on all of my test systems, with tensorflow 1.3 or 1.4.\r\nDoesn't matter if build with MKL or without or using the pip-version.\r\n```\r\nimport numpy as np\r\nimport tensorflow as tf\r\n\r\nnum_dim = 20\r\nFORMAT = tf.float64 #32 or 64 does not matter\r\nn = 3500 #reducing the number results in normal execution\r\n\r\ndef simpeLoop(alpha):\r\n      i = tf.constant(0)\r\n      m0 = tf.zeros([num_dim, 1], dtype=FORMAT)\r\n      cond = lambda i, m: i < n\r\n      def body(ic, vec): \r\n            #a meaningless example, summing up the first num_dim elements of a vector \r\n            op = alpha[ic * num_dim:(ic + 1) * num_dim, :]\r\n            # with tf.control_dependencies([op]): #if you uncomment this, it will not fault!\r\n            return ic + 1, vec + op\r\n      loop = tf.while_loop(cond, body, [i, m0], parallel_iterations=10**4, back_prop=False)\r\n      return loop[1]\r\n\r\nwith tf.device('/cpu:0'):\r\n      alpha = tf.placeholder(FORMAT, [None, 1], name=\"alpha\")\r\n      fdict = {\r\n          alpha: np.random.rand(n * num_dim, 1),\r\n      }\r\n      op = simpeLoop(alpha)\r\n      op = tf.reduce_sum(op) #not necessary for the seg fault\r\n      init = tf.global_variables_initializer()\r\n\r\nconfig = tf.ConfigProto()\r\nthreads = 1\r\nconfig.intra_op_parallelism_threads = threads\r\nconfig.inter_op_parallelism_threads = threads\r\nsess = tf.Session(config=config)\r\nsess.run(init, feed_dict=fdict)\r\nprint(\"init\")\r\nprint(sess.run(op, feed_dict=fdict))\r\n```\r\nAdding the control_dependencies results in normal execution.\r\n\r\nThe documentation states \r\n\r\n> The maximum number of parallel iterations can be controlled by parallel_iterations, which gives users some control over memory consumption and execution order\r\n\r\nso I would expect parallel_iterations to be some kind of upper bound. \r\nSmall tests like presented in  #12937 showed that increasing the parallel_iterations number results in higher performance. But setting it to high results in a seg fault.\r\n \r\n\r\n\r\n\r\n"}