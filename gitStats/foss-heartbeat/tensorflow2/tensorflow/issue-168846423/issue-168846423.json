{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/3610", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/3610/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/3610/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/3610/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/3610", "id": 168846423, "node_id": "MDU6SXNzdWUxNjg4NDY0MjM=", "number": 3610, "title": "Graph optimization and other features", "user": {"login": "sisp", "id": 2206639, "node_id": "MDQ6VXNlcjIyMDY2Mzk=", "avatar_url": "https://avatars1.githubusercontent.com/u/2206639?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sisp", "html_url": "https://github.com/sisp", "followers_url": "https://api.github.com/users/sisp/followers", "following_url": "https://api.github.com/users/sisp/following{/other_user}", "gists_url": "https://api.github.com/users/sisp/gists{/gist_id}", "starred_url": "https://api.github.com/users/sisp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sisp/subscriptions", "organizations_url": "https://api.github.com/users/sisp/orgs", "repos_url": "https://api.github.com/users/sisp/repos", "events_url": "https://api.github.com/users/sisp/events{/privacy}", "received_events_url": "https://api.github.com/users/sisp/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": {"login": "girving", "id": 70511, "node_id": "MDQ6VXNlcjcwNTEx", "avatar_url": "https://avatars1.githubusercontent.com/u/70511?v=4", "gravatar_id": "", "url": "https://api.github.com/users/girving", "html_url": "https://github.com/girving", "followers_url": "https://api.github.com/users/girving/followers", "following_url": "https://api.github.com/users/girving/following{/other_user}", "gists_url": "https://api.github.com/users/girving/gists{/gist_id}", "starred_url": "https://api.github.com/users/girving/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/girving/subscriptions", "organizations_url": "https://api.github.com/users/girving/orgs", "repos_url": "https://api.github.com/users/girving/repos", "events_url": "https://api.github.com/users/girving/events{/privacy}", "received_events_url": "https://api.github.com/users/girving/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "girving", "id": 70511, "node_id": "MDQ6VXNlcjcwNTEx", "avatar_url": "https://avatars1.githubusercontent.com/u/70511?v=4", "gravatar_id": "", "url": "https://api.github.com/users/girving", "html_url": "https://github.com/girving", "followers_url": "https://api.github.com/users/girving/followers", "following_url": "https://api.github.com/users/girving/following{/other_user}", "gists_url": "https://api.github.com/users/girving/gists{/gist_id}", "starred_url": "https://api.github.com/users/girving/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/girving/subscriptions", "organizations_url": "https://api.github.com/users/girving/orgs", "repos_url": "https://api.github.com/users/girving/repos", "events_url": "https://api.github.com/users/girving/events{/privacy}", "received_events_url": "https://api.github.com/users/girving/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 4, "created_at": "2016-08-02T10:04:09Z", "updated_at": "2017-09-12T18:28:34Z", "closed_at": "2016-08-02T18:34:39Z", "author_association": "NONE", "body_html": "<p>I've been using Theano for about 4 years now and love its flexibility due to the many available low-level ops that allow me to implement complicated and possibly non-standard models without needing to write C++/CUDA code (most of the time). In addition, I can focus almost exclusively on the model design and don't need to think much about numerical stability or suboptimal graph design leading to increased execution times because the graph optimization framework takes care of this. One common example is computing the log-loss of a categorical classifier which I can express na\u00efvely in Theano, but in most (all?) other tools including TensorFlow I need to use an op like <code>tf.nn.softmax_cross_entropy_with_logits</code>. In my opinion, the fact that I need to call these kinds of specialized ops <strong>manually</strong>, i.e. I need to know about them and think about when and how to use them in all kinds of situations, takes away many of the advantages of TensorFlow. Similarly, implementing model optimizers in C++/CUDA directly introduces unnecessary implementation complexity and does not take advantage of the fact that (most likely) all mathematical ops needed to specify the update formulas are already available (CPU and GPU kernels).</p>\n<p>I believe TensorFlow has a superior framework design in terms of keeping C++ and Python clearly separated and the inherent multi-device computing capabilities, but the aspects I described above make me very hesitant to use TensorFlow. Are there any plans to add a proper graph optimization framework similar to the one in Theano? And what are your reasons for implementing the model optimizers as individual kernels instead of reusing ops (like using the updates-dictionary in Theano)?</p>", "body_text": "I've been using Theano for about 4 years now and love its flexibility due to the many available low-level ops that allow me to implement complicated and possibly non-standard models without needing to write C++/CUDA code (most of the time). In addition, I can focus almost exclusively on the model design and don't need to think much about numerical stability or suboptimal graph design leading to increased execution times because the graph optimization framework takes care of this. One common example is computing the log-loss of a categorical classifier which I can express na\u00efvely in Theano, but in most (all?) other tools including TensorFlow I need to use an op like tf.nn.softmax_cross_entropy_with_logits. In my opinion, the fact that I need to call these kinds of specialized ops manually, i.e. I need to know about them and think about when and how to use them in all kinds of situations, takes away many of the advantages of TensorFlow. Similarly, implementing model optimizers in C++/CUDA directly introduces unnecessary implementation complexity and does not take advantage of the fact that (most likely) all mathematical ops needed to specify the update formulas are already available (CPU and GPU kernels).\nI believe TensorFlow has a superior framework design in terms of keeping C++ and Python clearly separated and the inherent multi-device computing capabilities, but the aspects I described above make me very hesitant to use TensorFlow. Are there any plans to add a proper graph optimization framework similar to the one in Theano? And what are your reasons for implementing the model optimizers as individual kernels instead of reusing ops (like using the updates-dictionary in Theano)?", "body": "I've been using Theano for about 4 years now and love its flexibility due to the many available low-level ops that allow me to implement complicated and possibly non-standard models without needing to write C++/CUDA code (most of the time). In addition, I can focus almost exclusively on the model design and don't need to think much about numerical stability or suboptimal graph design leading to increased execution times because the graph optimization framework takes care of this. One common example is computing the log-loss of a categorical classifier which I can express na\u00efvely in Theano, but in most (all?) other tools including TensorFlow I need to use an op like `tf.nn.softmax_cross_entropy_with_logits`. In my opinion, the fact that I need to call these kinds of specialized ops **manually**, i.e. I need to know about them and think about when and how to use them in all kinds of situations, takes away many of the advantages of TensorFlow. Similarly, implementing model optimizers in C++/CUDA directly introduces unnecessary implementation complexity and does not take advantage of the fact that (most likely) all mathematical ops needed to specify the update formulas are already available (CPU and GPU kernels).\n\nI believe TensorFlow has a superior framework design in terms of keeping C++ and Python clearly separated and the inherent multi-device computing capabilities, but the aspects I described above make me very hesitant to use TensorFlow. Are there any plans to add a proper graph optimization framework similar to the one in Theano? And what are your reasons for implementing the model optimizers as individual kernels instead of reusing ops (like using the updates-dictionary in Theano)?\n"}