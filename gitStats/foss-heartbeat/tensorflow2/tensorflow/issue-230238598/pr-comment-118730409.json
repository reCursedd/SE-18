{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/118730409", "pull_request_review_id": 40553244, "id": 118730409, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDExODczMDQwOQ==", "diff_hunk": "@@ -887,6 +887,10 @@ def __init__(self, tensors):\n     \"\"\"See `Dataset.from_tensor_slices()` for details.\"\"\"\n     super(TensorSliceDataset, self).__init__()\n     with ops.name_scope(\"tensors\"):\n+      tensors = ops.convert_n_to_tensor_or_indexed_slices(tensors)", "path": "tensorflow/contrib/data/python/ops/dataset_ops.py", "position": 4, "original_position": 4, "commit_id": "e76114017ff089e678d9e081aae3cc059226d583", "original_commit_id": "e76114017ff089e678d9e081aae3cc059226d583", "user": {"login": "mrry", "id": 192142, "node_id": "MDQ6VXNlcjE5MjE0Mg==", "avatar_url": "https://avatars1.githubusercontent.com/u/192142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mrry", "html_url": "https://github.com/mrry", "followers_url": "https://api.github.com/users/mrry/followers", "following_url": "https://api.github.com/users/mrry/following{/other_user}", "gists_url": "https://api.github.com/users/mrry/gists{/gist_id}", "starred_url": "https://api.github.com/users/mrry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mrry/subscriptions", "organizations_url": "https://api.github.com/users/mrry/orgs", "repos_url": "https://api.github.com/users/mrry/repos", "events_url": "https://api.github.com/users/mrry/events{/privacy}", "received_events_url": "https://api.github.com/users/mrry/received_events", "type": "User", "site_admin": false}, "body": "I think this raises a `ValueError` if the `tensors` argument is a single `tf.Tensor`, which is a valid \"nested structure\" to pass here. (`tf.train.slice_input_producer()` is more restrictive on the types that it accepts.) It would also fail on more complex nested structures, which are handled by the `nest.flatten()` on the lines below.\r\n\r\nPerhaps the right thing to do here is to raise a better error than the `IndexError` when the constructor flattens these arguments into four scalars? (The out-of-range is because `Dataset.from_tensor_slices()` requires each of its tensor arguments to have rank > 1, but there's currently no error checking code for that case.) The message could guide users to specify an explicit `tf.constant()` or `tf.convert_to_tensor()`.", "created_at": "2017-05-26T15:40:09Z", "updated_at": "2017-05-26T15:48:04Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/10082#discussion_r118730409", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/10082", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/118730409"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/10082#discussion_r118730409"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/10082"}}, "body_html": "<p>I think this raises a <code>ValueError</code> if the <code>tensors</code> argument is a single <code>tf.Tensor</code>, which is a valid \"nested structure\" to pass here. (<code>tf.train.slice_input_producer()</code> is more restrictive on the types that it accepts.) It would also fail on more complex nested structures, which are handled by the <code>nest.flatten()</code> on the lines below.</p>\n<p>Perhaps the right thing to do here is to raise a better error than the <code>IndexError</code> when the constructor flattens these arguments into four scalars? (The out-of-range is because <code>Dataset.from_tensor_slices()</code> requires each of its tensor arguments to have rank &gt; 1, but there's currently no error checking code for that case.) The message could guide users to specify an explicit <code>tf.constant()</code> or <code>tf.convert_to_tensor()</code>.</p>", "body_text": "I think this raises a ValueError if the tensors argument is a single tf.Tensor, which is a valid \"nested structure\" to pass here. (tf.train.slice_input_producer() is more restrictive on the types that it accepts.) It would also fail on more complex nested structures, which are handled by the nest.flatten() on the lines below.\nPerhaps the right thing to do here is to raise a better error than the IndexError when the constructor flattens these arguments into four scalars? (The out-of-range is because Dataset.from_tensor_slices() requires each of its tensor arguments to have rank > 1, but there's currently no error checking code for that case.) The message could guide users to specify an explicit tf.constant() or tf.convert_to_tensor()."}