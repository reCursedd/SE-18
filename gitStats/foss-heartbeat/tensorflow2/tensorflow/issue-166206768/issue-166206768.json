{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/3376", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/3376/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/3376/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/3376/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/3376", "id": 166206768, "node_id": "MDU6SXNzdWUxNjYyMDY3Njg=", "number": 3376, "title": "Element-wise tf.cond (like theano switch)", "user": {"login": "stas-sl", "id": 4602302, "node_id": "MDQ6VXNlcjQ2MDIzMDI=", "avatar_url": "https://avatars2.githubusercontent.com/u/4602302?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stas-sl", "html_url": "https://github.com/stas-sl", "followers_url": "https://api.github.com/users/stas-sl/followers", "following_url": "https://api.github.com/users/stas-sl/following{/other_user}", "gists_url": "https://api.github.com/users/stas-sl/gists{/gist_id}", "starred_url": "https://api.github.com/users/stas-sl/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stas-sl/subscriptions", "organizations_url": "https://api.github.com/users/stas-sl/orgs", "repos_url": "https://api.github.com/users/stas-sl/repos", "events_url": "https://api.github.com/users/stas-sl/events{/privacy}", "received_events_url": "https://api.github.com/users/stas-sl/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 299643928, "node_id": "MDU6TGFiZWwyOTk2NDM5Mjg=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:contributions%20welcome", "name": "stat:contributions welcome", "color": "f4b400", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2016-07-18T22:17:47Z", "updated_at": "2017-10-05T04:21:35Z", "closed_at": "2016-07-22T21:37:40Z", "author_association": "NONE", "body_html": "<p>When I try the following code:</p>\n<pre><code>import tensorflow as tf\nx = tf.placeholder('float32', shape=(None, None))\ntf.cond(x &gt;= 0.9, lambda: 1., lambda: x)\n</code></pre>\n<p>I get this error:</p>\n<pre><code>/Users/stas/.pyenv/versions/anaconda-2.4.0/lib/python2.7/site-packages/tensorflow/python/ops/control_flow_ops.pyc in cond(pred, fn1, fn2, name)\n   1314     if isinstance(pred, bool):\n   1315       raise TypeError(\"pred must not be a Python bool\")\n-&gt; 1316     p_2, p_1 = switch(pred, pred)\n   1317     pivot_1 = array_ops.identity(p_1, name=\"switch_t\")\n   1318     pivot_2 = array_ops.identity(p_2, name=\"switch_f\")\n\n/Users/stas/.pyenv/versions/anaconda-2.4.0/lib/python2.7/site-packages/tensorflow/python/ops/control_flow_ops.pyc in switch(data, pred, dtype, name)\n    258     pred = ops.convert_to_tensor(pred, name=\"pred\")\n    259     if isinstance(data, ops.Tensor):\n--&gt; 260       return gen_control_flow_ops._switch(data, pred, name=name)\n    261     else:\n    262       if not isinstance(data, (ops.IndexedSlices, ops.SparseTensor)):\n\n/Users/stas/.pyenv/versions/anaconda-2.4.0/lib/python2.7/site-packages/tensorflow/python/ops/gen_control_flow_ops.pyc in _switch(data, pred, name)\n    368     output_true: A `Tensor`. Has the same type as `data`. If `pred` is true, data will be forwarded to this output.\n    369   \"\"\"\n--&gt; 370   result = _op_def_lib.apply_op(\"Switch\", data=data, pred=pred, name=name)\n    371   return _SwitchOutput._make(result)\n    372\n\n/Users/stas/.pyenv/versions/anaconda-2.4.0/lib/python2.7/site-packages/tensorflow/python/ops/op_def_library.pyc in apply_op(self, op_type_name, name, **keywords)\n    702           op = g.create_op(op_type_name, inputs, output_types, name=scope,\n    703                            input_types=input_types, attrs=attr_protos,\n--&gt; 704                            op_def=op_def)\n    705           outputs = op.outputs\n    706           return _Restructure(ops.convert_n_to_tensor(outputs),\n\n/Users/stas/.pyenv/versions/anaconda-2.4.0/lib/python2.7/site-packages/tensorflow/python/framework/ops.pyc in create_op(self, op_type, inputs, dtypes, input_types, name, attrs, op_def, compute_shapes, compute_device)\n   2260                     original_op=self._default_original_op, op_def=op_def)\n   2261     if compute_shapes:\n-&gt; 2262       set_shapes_for_outputs(ret)\n   2263     self._add_op(ret)\n   2264     self._record_op_seen_by_control_dependencies(ret)\n\n/Users/stas/.pyenv/versions/anaconda-2.4.0/lib/python2.7/site-packages/tensorflow/python/framework/ops.pyc in set_shapes_for_outputs(op)\n   1700       raise RuntimeError(\"No shape function registered for standard op: %s\"\n   1701                          % op.type)\n-&gt; 1702   shapes = shape_func(op)\n   1703   if shapes is None:\n   1704     raise RuntimeError(\n\n/Users/stas/.pyenv/versions/anaconda-2.4.0/lib/python2.7/site-packages/tensorflow/python/ops/control_flow_ops.pyc in _SwitchShape(op)\n   2345 def _SwitchShape(op):\n   2346   input_shape = op.inputs[0].get_shape()\n-&gt; 2347   unused_pred_shape = op.inputs[1].get_shape().merge_with(tensor_shape.scalar())\n   2348   return [input_shape] * 2\n\n/Users/stas/.pyenv/versions/anaconda-2.4.0/lib/python2.7/site-packages/tensorflow/python/framework/tensor_shape.pyc in merge_with(self, other)\n    568       except ValueError:\n    569         raise ValueError(\"Shapes %s and %s are not compatible\" %\n--&gt; 570                          (self, other))\n    571\n    572   def concatenate(self, other):\n\nValueError: Shapes (?, ?) and () are not compatible\n</code></pre>\n<p>As I understand <em>pred</em> argument should be scalar, but what I need is element-wise condition.</p>\n<p>Though theano switch is working as expected:</p>\n<pre><code>import theano.tensor as T\nx = T.matrix()\nT.switch(x &gt;= 0.9, 1, x).eval({x: np.zeros((2,2), 'float32')})\n</code></pre>", "body_text": "When I try the following code:\nimport tensorflow as tf\nx = tf.placeholder('float32', shape=(None, None))\ntf.cond(x >= 0.9, lambda: 1., lambda: x)\n\nI get this error:\n/Users/stas/.pyenv/versions/anaconda-2.4.0/lib/python2.7/site-packages/tensorflow/python/ops/control_flow_ops.pyc in cond(pred, fn1, fn2, name)\n   1314     if isinstance(pred, bool):\n   1315       raise TypeError(\"pred must not be a Python bool\")\n-> 1316     p_2, p_1 = switch(pred, pred)\n   1317     pivot_1 = array_ops.identity(p_1, name=\"switch_t\")\n   1318     pivot_2 = array_ops.identity(p_2, name=\"switch_f\")\n\n/Users/stas/.pyenv/versions/anaconda-2.4.0/lib/python2.7/site-packages/tensorflow/python/ops/control_flow_ops.pyc in switch(data, pred, dtype, name)\n    258     pred = ops.convert_to_tensor(pred, name=\"pred\")\n    259     if isinstance(data, ops.Tensor):\n--> 260       return gen_control_flow_ops._switch(data, pred, name=name)\n    261     else:\n    262       if not isinstance(data, (ops.IndexedSlices, ops.SparseTensor)):\n\n/Users/stas/.pyenv/versions/anaconda-2.4.0/lib/python2.7/site-packages/tensorflow/python/ops/gen_control_flow_ops.pyc in _switch(data, pred, name)\n    368     output_true: A `Tensor`. Has the same type as `data`. If `pred` is true, data will be forwarded to this output.\n    369   \"\"\"\n--> 370   result = _op_def_lib.apply_op(\"Switch\", data=data, pred=pred, name=name)\n    371   return _SwitchOutput._make(result)\n    372\n\n/Users/stas/.pyenv/versions/anaconda-2.4.0/lib/python2.7/site-packages/tensorflow/python/ops/op_def_library.pyc in apply_op(self, op_type_name, name, **keywords)\n    702           op = g.create_op(op_type_name, inputs, output_types, name=scope,\n    703                            input_types=input_types, attrs=attr_protos,\n--> 704                            op_def=op_def)\n    705           outputs = op.outputs\n    706           return _Restructure(ops.convert_n_to_tensor(outputs),\n\n/Users/stas/.pyenv/versions/anaconda-2.4.0/lib/python2.7/site-packages/tensorflow/python/framework/ops.pyc in create_op(self, op_type, inputs, dtypes, input_types, name, attrs, op_def, compute_shapes, compute_device)\n   2260                     original_op=self._default_original_op, op_def=op_def)\n   2261     if compute_shapes:\n-> 2262       set_shapes_for_outputs(ret)\n   2263     self._add_op(ret)\n   2264     self._record_op_seen_by_control_dependencies(ret)\n\n/Users/stas/.pyenv/versions/anaconda-2.4.0/lib/python2.7/site-packages/tensorflow/python/framework/ops.pyc in set_shapes_for_outputs(op)\n   1700       raise RuntimeError(\"No shape function registered for standard op: %s\"\n   1701                          % op.type)\n-> 1702   shapes = shape_func(op)\n   1703   if shapes is None:\n   1704     raise RuntimeError(\n\n/Users/stas/.pyenv/versions/anaconda-2.4.0/lib/python2.7/site-packages/tensorflow/python/ops/control_flow_ops.pyc in _SwitchShape(op)\n   2345 def _SwitchShape(op):\n   2346   input_shape = op.inputs[0].get_shape()\n-> 2347   unused_pred_shape = op.inputs[1].get_shape().merge_with(tensor_shape.scalar())\n   2348   return [input_shape] * 2\n\n/Users/stas/.pyenv/versions/anaconda-2.4.0/lib/python2.7/site-packages/tensorflow/python/framework/tensor_shape.pyc in merge_with(self, other)\n    568       except ValueError:\n    569         raise ValueError(\"Shapes %s and %s are not compatible\" %\n--> 570                          (self, other))\n    571\n    572   def concatenate(self, other):\n\nValueError: Shapes (?, ?) and () are not compatible\n\nAs I understand pred argument should be scalar, but what I need is element-wise condition.\nThough theano switch is working as expected:\nimport theano.tensor as T\nx = T.matrix()\nT.switch(x >= 0.9, 1, x).eval({x: np.zeros((2,2), 'float32')})", "body": "When I try the following code:\n\n```\nimport tensorflow as tf\nx = tf.placeholder('float32', shape=(None, None))\ntf.cond(x >= 0.9, lambda: 1., lambda: x)\n```\n\nI get this error:\n\n```\n/Users/stas/.pyenv/versions/anaconda-2.4.0/lib/python2.7/site-packages/tensorflow/python/ops/control_flow_ops.pyc in cond(pred, fn1, fn2, name)\n   1314     if isinstance(pred, bool):\n   1315       raise TypeError(\"pred must not be a Python bool\")\n-> 1316     p_2, p_1 = switch(pred, pred)\n   1317     pivot_1 = array_ops.identity(p_1, name=\"switch_t\")\n   1318     pivot_2 = array_ops.identity(p_2, name=\"switch_f\")\n\n/Users/stas/.pyenv/versions/anaconda-2.4.0/lib/python2.7/site-packages/tensorflow/python/ops/control_flow_ops.pyc in switch(data, pred, dtype, name)\n    258     pred = ops.convert_to_tensor(pred, name=\"pred\")\n    259     if isinstance(data, ops.Tensor):\n--> 260       return gen_control_flow_ops._switch(data, pred, name=name)\n    261     else:\n    262       if not isinstance(data, (ops.IndexedSlices, ops.SparseTensor)):\n\n/Users/stas/.pyenv/versions/anaconda-2.4.0/lib/python2.7/site-packages/tensorflow/python/ops/gen_control_flow_ops.pyc in _switch(data, pred, name)\n    368     output_true: A `Tensor`. Has the same type as `data`. If `pred` is true, data will be forwarded to this output.\n    369   \"\"\"\n--> 370   result = _op_def_lib.apply_op(\"Switch\", data=data, pred=pred, name=name)\n    371   return _SwitchOutput._make(result)\n    372\n\n/Users/stas/.pyenv/versions/anaconda-2.4.0/lib/python2.7/site-packages/tensorflow/python/ops/op_def_library.pyc in apply_op(self, op_type_name, name, **keywords)\n    702           op = g.create_op(op_type_name, inputs, output_types, name=scope,\n    703                            input_types=input_types, attrs=attr_protos,\n--> 704                            op_def=op_def)\n    705           outputs = op.outputs\n    706           return _Restructure(ops.convert_n_to_tensor(outputs),\n\n/Users/stas/.pyenv/versions/anaconda-2.4.0/lib/python2.7/site-packages/tensorflow/python/framework/ops.pyc in create_op(self, op_type, inputs, dtypes, input_types, name, attrs, op_def, compute_shapes, compute_device)\n   2260                     original_op=self._default_original_op, op_def=op_def)\n   2261     if compute_shapes:\n-> 2262       set_shapes_for_outputs(ret)\n   2263     self._add_op(ret)\n   2264     self._record_op_seen_by_control_dependencies(ret)\n\n/Users/stas/.pyenv/versions/anaconda-2.4.0/lib/python2.7/site-packages/tensorflow/python/framework/ops.pyc in set_shapes_for_outputs(op)\n   1700       raise RuntimeError(\"No shape function registered for standard op: %s\"\n   1701                          % op.type)\n-> 1702   shapes = shape_func(op)\n   1703   if shapes is None:\n   1704     raise RuntimeError(\n\n/Users/stas/.pyenv/versions/anaconda-2.4.0/lib/python2.7/site-packages/tensorflow/python/ops/control_flow_ops.pyc in _SwitchShape(op)\n   2345 def _SwitchShape(op):\n   2346   input_shape = op.inputs[0].get_shape()\n-> 2347   unused_pred_shape = op.inputs[1].get_shape().merge_with(tensor_shape.scalar())\n   2348   return [input_shape] * 2\n\n/Users/stas/.pyenv/versions/anaconda-2.4.0/lib/python2.7/site-packages/tensorflow/python/framework/tensor_shape.pyc in merge_with(self, other)\n    568       except ValueError:\n    569         raise ValueError(\"Shapes %s and %s are not compatible\" %\n--> 570                          (self, other))\n    571\n    572   def concatenate(self, other):\n\nValueError: Shapes (?, ?) and () are not compatible\n```\n\nAs I understand _pred_ argument should be scalar, but what I need is element-wise condition.\n\nThough theano switch is working as expected:\n\n```\nimport theano.tensor as T\nx = T.matrix()\nT.switch(x >= 0.9, 1, x).eval({x: np.zeros((2,2), 'float32')})\n```\n"}