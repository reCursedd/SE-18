{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9741", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9741/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9741/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9741/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/9741", "id": 226872656, "node_id": "MDU6SXNzdWUyMjY4NzI2NTY=", "number": 9741, "title": "run own model on android", "user": {"login": "chenweiqian", "id": 16277253, "node_id": "MDQ6VXNlcjE2Mjc3MjUz", "avatar_url": "https://avatars3.githubusercontent.com/u/16277253?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chenweiqian", "html_url": "https://github.com/chenweiqian", "followers_url": "https://api.github.com/users/chenweiqian/followers", "following_url": "https://api.github.com/users/chenweiqian/following{/other_user}", "gists_url": "https://api.github.com/users/chenweiqian/gists{/gist_id}", "starred_url": "https://api.github.com/users/chenweiqian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chenweiqian/subscriptions", "organizations_url": "https://api.github.com/users/chenweiqian/orgs", "repos_url": "https://api.github.com/users/chenweiqian/repos", "events_url": "https://api.github.com/users/chenweiqian/events{/privacy}", "received_events_url": "https://api.github.com/users/chenweiqian/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2017-05-07T16:20:09Z", "updated_at": "2017-05-07T17:45:11Z", "closed_at": "2017-05-07T17:45:11Z", "author_association": "NONE", "body_html": "<p><strong>question:</strong><br>\ni run tensorflow SSD model on android. The android studio didn't throw error. But i can't detect anything.I test my pb file, it's seems right. I don't know why. Anyone who can help me? Thanks!!</p>\n<p><strong>code:</strong><br>\nbecause the model is based on tensorflow demo. so i just paste own code.</p>\n<pre><code>public List&lt;Recognition&gt; recognizeImage(final Bitmap bitmap) {\n    final SplitTimer timer = new SplitTimer(\"recognizeImage\");\n\n    // Log this method so that it can be analyzed with systrace.\n    Trace.beginSection(\"recognizeImage\");\n\n    Trace.beginSection(\"preprocessBitmap\");\n    // Preprocess the image data from 0-255 int to normalized float based\n    // on the provided parameters.\n    bitmap.getPixels(intValues, 0, bitmap.getWidth(), 0, 0, bitmap.getWidth(), bitmap.getHeight());\n\n    for (int i = 0; i &lt; intValues.length; ++i) {\n      floatValues[i * 3 + 0] = ((intValues[i] &gt;&gt; 16) &amp; 0xFF) / 255.0f;\n      floatValues[i * 3 + 1] = ((intValues[i] &gt;&gt; 8) &amp; 0xFF) / 255.0f;\n      floatValues[i * 3 + 2] = (intValues[i] &amp; 0xFF) / 255.0f;\n    }\n    Trace.endSection(); // preprocessBitmap\n\n    // Copy the input data into TensorFlow.\n    Trace.beginSection(\"fillNodeFloat\");\n    inferenceInterface.fillNodeFloat(\n            inputName, new int[] {1, inputSize, inputSize, 3}, floatValues);\n    Trace.endSection();\n\n    timer.endSplit(\"ready for inference\");\n\n    // Run the inference call.\n    Trace.beginSection(\"runInference\");\n    final int resultCode = inferenceInterface.runInference(outputNames);\n    if (resultCode != 0) {\n      throw new RuntimeException(\"Bad result code from inference: \" + resultCode);\n    }\n    Trace.endSection();\n\n    timer.endSplit(\"ran inference\");\n\n    // Copy the output Tensor back into the output array.\n    Trace.beginSection(\"readNodeFloat\");\n    //\u63a8\u7406\u5f97\u5230\u7684\u7ed3\u679c\n\n    final float[] outputs=new float[feat_shapes[0][0] * feat_shapes[0][1] * (anchor_sizes[0].length+anchor_ratios[0].length) * 4+\n                                          feat_shapes[1][0] * feat_shapes[1][1] * (anchor_sizes[1].length+anchor_ratios[1].length) * 4+\n                                          feat_shapes[2][0] * feat_shapes[2][1] * (anchor_sizes[2].length+anchor_ratios[2].length) * 4+\n                                          feat_shapes[3][0] * feat_shapes[3][1] * (anchor_sizes[3].length+anchor_ratios[3].length) * 4+\n                                          feat_shapes[4][0] * feat_shapes[4][1] * (anchor_sizes[4].length+anchor_ratios[4].length) * 4+\n                                          feat_shapes[5][0] * feat_shapes[5][1] * (anchor_sizes[5].length+anchor_ratios[5].length) * 4+\n                                          feat_shapes[0][0] * feat_shapes[0][1] * (anchor_sizes[0].length+anchor_ratios[0].length) * NUM_CLASSES+\n                                          feat_shapes[1][0] * feat_shapes[1][1] * (anchor_sizes[1].length+anchor_ratios[1].length) * NUM_CLASSES+\n                                          feat_shapes[2][0] * feat_shapes[2][1] * (anchor_sizes[2].length+anchor_ratios[2].length) * NUM_CLASSES+\n                                          feat_shapes[3][0] * feat_shapes[3][1] * (anchor_sizes[3].length+anchor_ratios[3].length) * NUM_CLASSES+\n                                          feat_shapes[4][0] * feat_shapes[4][1] * (anchor_sizes[4].length+anchor_ratios[4].length) * NUM_CLASSES+\n                                          feat_shapes[5][0] * feat_shapes[5][1] * (anchor_sizes[5].length+anchor_ratios[5].length) * NUM_CLASSES];\n\n    inferenceInterface.readNodeFloat(outputNames[0], outputs);\n    LOGGER.i(\"recognizeImage: \"+outputs);\n    Trace.endSection();\n\n    // Find the best detections.\n    final PriorityQueue&lt;Recognition&gt; pq =\n            new PriorityQueue&lt;Recognition&gt;(\n                    1,\n                    new Comparator&lt;Recognition&gt;() {\n                      @Override\n                      public int compare(final Recognition lhs, final Recognition rhs) {\n                        // Intentionally reversed to put high confidence at the head of the queue.\n                        return Float.compare(rhs.getConfidence(), lhs.getConfidence());\n                      }\n                    });\n\n    int num=0,offest=0;\n    float cx,cy,cw,ch,xpos,ypos,h,w;\n    for(int i=0;i&lt;6;i++)\n    {\n      for(int y=0;y&lt;feat_shapes[i][0];y++)\n      {\n        for(int x=0;x&lt;feat_shapes[i][1];x++)\n        {\n          ypos=(y+anchor_offset)*anchor_steps[i]/img_shape[0];\n          xpos=(x+anchor_offset)*anchor_steps[i]/img_shape[1];\n          //\u9884\u6d4b\u6846\n          for(int l=0;l&lt;(anchor_ratios[i].length+2);l++)\n          {\n            if(l==0)\n            {\n              h=anchor_sizes[i][0]/img_shape[0];\n              w=anchor_sizes[i][0]/img_shape[1];\n            }\n            else if(l==1)\n            {\n              h=Float.parseFloat(String.valueOf(Math.sqrt(anchor_sizes[i][0]*anchor_sizes[i][1])/img_shape[0]));\n              w=Float.parseFloat(String.valueOf(Math.sqrt(anchor_sizes[i][0]*anchor_sizes[i][1])/img_shape[1]));\n            }\n            else\n            {\n              h=Float.parseFloat(String.valueOf(anchor_sizes[i][0]/img_shape[0]/Math.sqrt(anchor_ratios[i][l-2])));\n              w=Float.parseFloat(String.valueOf(anchor_sizes[i][0]/img_shape[1]/Math.sqrt(anchor_ratios[i][l-2])));\n            }\n            //\u89e3\u7801\n            cx=outputs[offest]*w*prior_scaling[0]+xpos;\n            offest++;\n            cy=outputs[offest]*h*prior_scaling[1]+ypos;\n            offest++;\n            cw=Float.parseFloat(String.valueOf(w*Math.exp(outputs[offest]*prior_scaling[2])));\n            offest++;\n            ch=Float.parseFloat(String.valueOf(h*Math.exp(outputs[offest]*prior_scaling[3])));\n            offest++;\n            final RectF rect =\n                    new RectF(\n                            Math.max(0, cx - cw / 2),\n                            Math.max(0, cy - ch / 2),\n                            Math.min(1, cx + cw / 2),\n                            Math.min(1, cy + ch / 2));\n            //\u6311\u9009\u5927\u4e8eselect_threshold\u7684\u6846\n            offest++;\n            for(int m=1;m&lt;NUM_CLASSES;m++)\n            {\n              if(outputs[offest]&gt;select_threshold)\n              {\n                LOGGER.i(\n                        \"%s (%d) %f %s\", LABELS[m], m, outputs[offest], rect);\n                pq.add(new Recognition(\"\" + num, LABELS[m], outputs[offest], rect));\n                num++;\n              }\n              offest++;\n            }\n          }\n        }\n      }\n    }\n    timer.endSplit(\"decoded results\");\n\n    final ArrayList&lt;Recognition&gt; sort = new ArrayList&lt;Recognition&gt;();\n    for (int i = 0; i &lt; Math.min(pq.size(), top_k); ++i) {\n      sort.add(pq.poll());\n    }\n    timer.endSplit(\"sorted results\");\n\n    final ArrayList&lt;Recognition&gt; nms = new ArrayList&lt;Recognition&gt;();\n    float []keep_bboxes=new float[sort.size()];\n    for(int i=0;i&lt;sort.size();i++)\n    {\n      keep_bboxes[i]=1;\n    }\n    float overlap;\n    for(int i=0;i&lt;sort.size();i++)\n    {\n      if(keep_bboxes[i]==1)\n      {\n        for(int j=i+1;j&lt;sort.size();j++)\n        {\n          overlap=bboxes_jaccard(sort.get(i).getLocation(),sort.get(j).getLocation());\n          if(overlap&lt;nms_threshold||sort.get(i).getTitle()!=sort.get(j).getTitle())\n          {\n            nms.add(sort.get(i));\n          }\n          else\n            keep_bboxes[j]=0;\n        }\n      }\n    }\n    timer.endSplit(\"nms results\");\n\n    final ArrayList&lt;Recognition&gt; recognitions = new ArrayList&lt;Recognition&gt;();\n    for (int i = 0; i &lt; Math.min(nms.size(), MAX_RESULTS); ++i) {\n      recognitions.add(nms.get(i));\n    }\n    Trace.endSection(); // \"recognizeImage\"\n\n    timer.endSplit(\"processed results\");\n\n    return recognitions;\n  }\n</code></pre>", "body_text": "question:\ni run tensorflow SSD model on android. The android studio didn't throw error. But i can't detect anything.I test my pb file, it's seems right. I don't know why. Anyone who can help me? Thanks!!\ncode:\nbecause the model is based on tensorflow demo. so i just paste own code.\npublic List<Recognition> recognizeImage(final Bitmap bitmap) {\n    final SplitTimer timer = new SplitTimer(\"recognizeImage\");\n\n    // Log this method so that it can be analyzed with systrace.\n    Trace.beginSection(\"recognizeImage\");\n\n    Trace.beginSection(\"preprocessBitmap\");\n    // Preprocess the image data from 0-255 int to normalized float based\n    // on the provided parameters.\n    bitmap.getPixels(intValues, 0, bitmap.getWidth(), 0, 0, bitmap.getWidth(), bitmap.getHeight());\n\n    for (int i = 0; i < intValues.length; ++i) {\n      floatValues[i * 3 + 0] = ((intValues[i] >> 16) & 0xFF) / 255.0f;\n      floatValues[i * 3 + 1] = ((intValues[i] >> 8) & 0xFF) / 255.0f;\n      floatValues[i * 3 + 2] = (intValues[i] & 0xFF) / 255.0f;\n    }\n    Trace.endSection(); // preprocessBitmap\n\n    // Copy the input data into TensorFlow.\n    Trace.beginSection(\"fillNodeFloat\");\n    inferenceInterface.fillNodeFloat(\n            inputName, new int[] {1, inputSize, inputSize, 3}, floatValues);\n    Trace.endSection();\n\n    timer.endSplit(\"ready for inference\");\n\n    // Run the inference call.\n    Trace.beginSection(\"runInference\");\n    final int resultCode = inferenceInterface.runInference(outputNames);\n    if (resultCode != 0) {\n      throw new RuntimeException(\"Bad result code from inference: \" + resultCode);\n    }\n    Trace.endSection();\n\n    timer.endSplit(\"ran inference\");\n\n    // Copy the output Tensor back into the output array.\n    Trace.beginSection(\"readNodeFloat\");\n    //\u63a8\u7406\u5f97\u5230\u7684\u7ed3\u679c\n\n    final float[] outputs=new float[feat_shapes[0][0] * feat_shapes[0][1] * (anchor_sizes[0].length+anchor_ratios[0].length) * 4+\n                                          feat_shapes[1][0] * feat_shapes[1][1] * (anchor_sizes[1].length+anchor_ratios[1].length) * 4+\n                                          feat_shapes[2][0] * feat_shapes[2][1] * (anchor_sizes[2].length+anchor_ratios[2].length) * 4+\n                                          feat_shapes[3][0] * feat_shapes[3][1] * (anchor_sizes[3].length+anchor_ratios[3].length) * 4+\n                                          feat_shapes[4][0] * feat_shapes[4][1] * (anchor_sizes[4].length+anchor_ratios[4].length) * 4+\n                                          feat_shapes[5][0] * feat_shapes[5][1] * (anchor_sizes[5].length+anchor_ratios[5].length) * 4+\n                                          feat_shapes[0][0] * feat_shapes[0][1] * (anchor_sizes[0].length+anchor_ratios[0].length) * NUM_CLASSES+\n                                          feat_shapes[1][0] * feat_shapes[1][1] * (anchor_sizes[1].length+anchor_ratios[1].length) * NUM_CLASSES+\n                                          feat_shapes[2][0] * feat_shapes[2][1] * (anchor_sizes[2].length+anchor_ratios[2].length) * NUM_CLASSES+\n                                          feat_shapes[3][0] * feat_shapes[3][1] * (anchor_sizes[3].length+anchor_ratios[3].length) * NUM_CLASSES+\n                                          feat_shapes[4][0] * feat_shapes[4][1] * (anchor_sizes[4].length+anchor_ratios[4].length) * NUM_CLASSES+\n                                          feat_shapes[5][0] * feat_shapes[5][1] * (anchor_sizes[5].length+anchor_ratios[5].length) * NUM_CLASSES];\n\n    inferenceInterface.readNodeFloat(outputNames[0], outputs);\n    LOGGER.i(\"recognizeImage: \"+outputs);\n    Trace.endSection();\n\n    // Find the best detections.\n    final PriorityQueue<Recognition> pq =\n            new PriorityQueue<Recognition>(\n                    1,\n                    new Comparator<Recognition>() {\n                      @Override\n                      public int compare(final Recognition lhs, final Recognition rhs) {\n                        // Intentionally reversed to put high confidence at the head of the queue.\n                        return Float.compare(rhs.getConfidence(), lhs.getConfidence());\n                      }\n                    });\n\n    int num=0,offest=0;\n    float cx,cy,cw,ch,xpos,ypos,h,w;\n    for(int i=0;i<6;i++)\n    {\n      for(int y=0;y<feat_shapes[i][0];y++)\n      {\n        for(int x=0;x<feat_shapes[i][1];x++)\n        {\n          ypos=(y+anchor_offset)*anchor_steps[i]/img_shape[0];\n          xpos=(x+anchor_offset)*anchor_steps[i]/img_shape[1];\n          //\u9884\u6d4b\u6846\n          for(int l=0;l<(anchor_ratios[i].length+2);l++)\n          {\n            if(l==0)\n            {\n              h=anchor_sizes[i][0]/img_shape[0];\n              w=anchor_sizes[i][0]/img_shape[1];\n            }\n            else if(l==1)\n            {\n              h=Float.parseFloat(String.valueOf(Math.sqrt(anchor_sizes[i][0]*anchor_sizes[i][1])/img_shape[0]));\n              w=Float.parseFloat(String.valueOf(Math.sqrt(anchor_sizes[i][0]*anchor_sizes[i][1])/img_shape[1]));\n            }\n            else\n            {\n              h=Float.parseFloat(String.valueOf(anchor_sizes[i][0]/img_shape[0]/Math.sqrt(anchor_ratios[i][l-2])));\n              w=Float.parseFloat(String.valueOf(anchor_sizes[i][0]/img_shape[1]/Math.sqrt(anchor_ratios[i][l-2])));\n            }\n            //\u89e3\u7801\n            cx=outputs[offest]*w*prior_scaling[0]+xpos;\n            offest++;\n            cy=outputs[offest]*h*prior_scaling[1]+ypos;\n            offest++;\n            cw=Float.parseFloat(String.valueOf(w*Math.exp(outputs[offest]*prior_scaling[2])));\n            offest++;\n            ch=Float.parseFloat(String.valueOf(h*Math.exp(outputs[offest]*prior_scaling[3])));\n            offest++;\n            final RectF rect =\n                    new RectF(\n                            Math.max(0, cx - cw / 2),\n                            Math.max(0, cy - ch / 2),\n                            Math.min(1, cx + cw / 2),\n                            Math.min(1, cy + ch / 2));\n            //\u6311\u9009\u5927\u4e8eselect_threshold\u7684\u6846\n            offest++;\n            for(int m=1;m<NUM_CLASSES;m++)\n            {\n              if(outputs[offest]>select_threshold)\n              {\n                LOGGER.i(\n                        \"%s (%d) %f %s\", LABELS[m], m, outputs[offest], rect);\n                pq.add(new Recognition(\"\" + num, LABELS[m], outputs[offest], rect));\n                num++;\n              }\n              offest++;\n            }\n          }\n        }\n      }\n    }\n    timer.endSplit(\"decoded results\");\n\n    final ArrayList<Recognition> sort = new ArrayList<Recognition>();\n    for (int i = 0; i < Math.min(pq.size(), top_k); ++i) {\n      sort.add(pq.poll());\n    }\n    timer.endSplit(\"sorted results\");\n\n    final ArrayList<Recognition> nms = new ArrayList<Recognition>();\n    float []keep_bboxes=new float[sort.size()];\n    for(int i=0;i<sort.size();i++)\n    {\n      keep_bboxes[i]=1;\n    }\n    float overlap;\n    for(int i=0;i<sort.size();i++)\n    {\n      if(keep_bboxes[i]==1)\n      {\n        for(int j=i+1;j<sort.size();j++)\n        {\n          overlap=bboxes_jaccard(sort.get(i).getLocation(),sort.get(j).getLocation());\n          if(overlap<nms_threshold||sort.get(i).getTitle()!=sort.get(j).getTitle())\n          {\n            nms.add(sort.get(i));\n          }\n          else\n            keep_bboxes[j]=0;\n        }\n      }\n    }\n    timer.endSplit(\"nms results\");\n\n    final ArrayList<Recognition> recognitions = new ArrayList<Recognition>();\n    for (int i = 0; i < Math.min(nms.size(), MAX_RESULTS); ++i) {\n      recognitions.add(nms.get(i));\n    }\n    Trace.endSection(); // \"recognizeImage\"\n\n    timer.endSplit(\"processed results\");\n\n    return recognitions;\n  }", "body": "**question:**\r\ni run tensorflow SSD model on android. The android studio didn't throw error. But i can't detect anything.I test my pb file, it's seems right. I don't know why. Anyone who can help me? Thanks!!\r\n\r\n**code:**\r\nbecause the model is based on tensorflow demo. so i just paste own code.\r\n\r\n```\r\npublic List<Recognition> recognizeImage(final Bitmap bitmap) {\r\n    final SplitTimer timer = new SplitTimer(\"recognizeImage\");\r\n\r\n    // Log this method so that it can be analyzed with systrace.\r\n    Trace.beginSection(\"recognizeImage\");\r\n\r\n    Trace.beginSection(\"preprocessBitmap\");\r\n    // Preprocess the image data from 0-255 int to normalized float based\r\n    // on the provided parameters.\r\n    bitmap.getPixels(intValues, 0, bitmap.getWidth(), 0, 0, bitmap.getWidth(), bitmap.getHeight());\r\n\r\n    for (int i = 0; i < intValues.length; ++i) {\r\n      floatValues[i * 3 + 0] = ((intValues[i] >> 16) & 0xFF) / 255.0f;\r\n      floatValues[i * 3 + 1] = ((intValues[i] >> 8) & 0xFF) / 255.0f;\r\n      floatValues[i * 3 + 2] = (intValues[i] & 0xFF) / 255.0f;\r\n    }\r\n    Trace.endSection(); // preprocessBitmap\r\n\r\n    // Copy the input data into TensorFlow.\r\n    Trace.beginSection(\"fillNodeFloat\");\r\n    inferenceInterface.fillNodeFloat(\r\n            inputName, new int[] {1, inputSize, inputSize, 3}, floatValues);\r\n    Trace.endSection();\r\n\r\n    timer.endSplit(\"ready for inference\");\r\n\r\n    // Run the inference call.\r\n    Trace.beginSection(\"runInference\");\r\n    final int resultCode = inferenceInterface.runInference(outputNames);\r\n    if (resultCode != 0) {\r\n      throw new RuntimeException(\"Bad result code from inference: \" + resultCode);\r\n    }\r\n    Trace.endSection();\r\n\r\n    timer.endSplit(\"ran inference\");\r\n\r\n    // Copy the output Tensor back into the output array.\r\n    Trace.beginSection(\"readNodeFloat\");\r\n    //\u63a8\u7406\u5f97\u5230\u7684\u7ed3\u679c\r\n\r\n    final float[] outputs=new float[feat_shapes[0][0] * feat_shapes[0][1] * (anchor_sizes[0].length+anchor_ratios[0].length) * 4+\r\n                                          feat_shapes[1][0] * feat_shapes[1][1] * (anchor_sizes[1].length+anchor_ratios[1].length) * 4+\r\n                                          feat_shapes[2][0] * feat_shapes[2][1] * (anchor_sizes[2].length+anchor_ratios[2].length) * 4+\r\n                                          feat_shapes[3][0] * feat_shapes[3][1] * (anchor_sizes[3].length+anchor_ratios[3].length) * 4+\r\n                                          feat_shapes[4][0] * feat_shapes[4][1] * (anchor_sizes[4].length+anchor_ratios[4].length) * 4+\r\n                                          feat_shapes[5][0] * feat_shapes[5][1] * (anchor_sizes[5].length+anchor_ratios[5].length) * 4+\r\n                                          feat_shapes[0][0] * feat_shapes[0][1] * (anchor_sizes[0].length+anchor_ratios[0].length) * NUM_CLASSES+\r\n                                          feat_shapes[1][0] * feat_shapes[1][1] * (anchor_sizes[1].length+anchor_ratios[1].length) * NUM_CLASSES+\r\n                                          feat_shapes[2][0] * feat_shapes[2][1] * (anchor_sizes[2].length+anchor_ratios[2].length) * NUM_CLASSES+\r\n                                          feat_shapes[3][0] * feat_shapes[3][1] * (anchor_sizes[3].length+anchor_ratios[3].length) * NUM_CLASSES+\r\n                                          feat_shapes[4][0] * feat_shapes[4][1] * (anchor_sizes[4].length+anchor_ratios[4].length) * NUM_CLASSES+\r\n                                          feat_shapes[5][0] * feat_shapes[5][1] * (anchor_sizes[5].length+anchor_ratios[5].length) * NUM_CLASSES];\r\n\r\n    inferenceInterface.readNodeFloat(outputNames[0], outputs);\r\n    LOGGER.i(\"recognizeImage: \"+outputs);\r\n    Trace.endSection();\r\n\r\n    // Find the best detections.\r\n    final PriorityQueue<Recognition> pq =\r\n            new PriorityQueue<Recognition>(\r\n                    1,\r\n                    new Comparator<Recognition>() {\r\n                      @Override\r\n                      public int compare(final Recognition lhs, final Recognition rhs) {\r\n                        // Intentionally reversed to put high confidence at the head of the queue.\r\n                        return Float.compare(rhs.getConfidence(), lhs.getConfidence());\r\n                      }\r\n                    });\r\n\r\n    int num=0,offest=0;\r\n    float cx,cy,cw,ch,xpos,ypos,h,w;\r\n    for(int i=0;i<6;i++)\r\n    {\r\n      for(int y=0;y<feat_shapes[i][0];y++)\r\n      {\r\n        for(int x=0;x<feat_shapes[i][1];x++)\r\n        {\r\n          ypos=(y+anchor_offset)*anchor_steps[i]/img_shape[0];\r\n          xpos=(x+anchor_offset)*anchor_steps[i]/img_shape[1];\r\n          //\u9884\u6d4b\u6846\r\n          for(int l=0;l<(anchor_ratios[i].length+2);l++)\r\n          {\r\n            if(l==0)\r\n            {\r\n              h=anchor_sizes[i][0]/img_shape[0];\r\n              w=anchor_sizes[i][0]/img_shape[1];\r\n            }\r\n            else if(l==1)\r\n            {\r\n              h=Float.parseFloat(String.valueOf(Math.sqrt(anchor_sizes[i][0]*anchor_sizes[i][1])/img_shape[0]));\r\n              w=Float.parseFloat(String.valueOf(Math.sqrt(anchor_sizes[i][0]*anchor_sizes[i][1])/img_shape[1]));\r\n            }\r\n            else\r\n            {\r\n              h=Float.parseFloat(String.valueOf(anchor_sizes[i][0]/img_shape[0]/Math.sqrt(anchor_ratios[i][l-2])));\r\n              w=Float.parseFloat(String.valueOf(anchor_sizes[i][0]/img_shape[1]/Math.sqrt(anchor_ratios[i][l-2])));\r\n            }\r\n            //\u89e3\u7801\r\n            cx=outputs[offest]*w*prior_scaling[0]+xpos;\r\n            offest++;\r\n            cy=outputs[offest]*h*prior_scaling[1]+ypos;\r\n            offest++;\r\n            cw=Float.parseFloat(String.valueOf(w*Math.exp(outputs[offest]*prior_scaling[2])));\r\n            offest++;\r\n            ch=Float.parseFloat(String.valueOf(h*Math.exp(outputs[offest]*prior_scaling[3])));\r\n            offest++;\r\n            final RectF rect =\r\n                    new RectF(\r\n                            Math.max(0, cx - cw / 2),\r\n                            Math.max(0, cy - ch / 2),\r\n                            Math.min(1, cx + cw / 2),\r\n                            Math.min(1, cy + ch / 2));\r\n            //\u6311\u9009\u5927\u4e8eselect_threshold\u7684\u6846\r\n            offest++;\r\n            for(int m=1;m<NUM_CLASSES;m++)\r\n            {\r\n              if(outputs[offest]>select_threshold)\r\n              {\r\n                LOGGER.i(\r\n                        \"%s (%d) %f %s\", LABELS[m], m, outputs[offest], rect);\r\n                pq.add(new Recognition(\"\" + num, LABELS[m], outputs[offest], rect));\r\n                num++;\r\n              }\r\n              offest++;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    timer.endSplit(\"decoded results\");\r\n\r\n    final ArrayList<Recognition> sort = new ArrayList<Recognition>();\r\n    for (int i = 0; i < Math.min(pq.size(), top_k); ++i) {\r\n      sort.add(pq.poll());\r\n    }\r\n    timer.endSplit(\"sorted results\");\r\n\r\n    final ArrayList<Recognition> nms = new ArrayList<Recognition>();\r\n    float []keep_bboxes=new float[sort.size()];\r\n    for(int i=0;i<sort.size();i++)\r\n    {\r\n      keep_bboxes[i]=1;\r\n    }\r\n    float overlap;\r\n    for(int i=0;i<sort.size();i++)\r\n    {\r\n      if(keep_bboxes[i]==1)\r\n      {\r\n        for(int j=i+1;j<sort.size();j++)\r\n        {\r\n          overlap=bboxes_jaccard(sort.get(i).getLocation(),sort.get(j).getLocation());\r\n          if(overlap<nms_threshold||sort.get(i).getTitle()!=sort.get(j).getTitle())\r\n          {\r\n            nms.add(sort.get(i));\r\n          }\r\n          else\r\n            keep_bboxes[j]=0;\r\n        }\r\n      }\r\n    }\r\n    timer.endSplit(\"nms results\");\r\n\r\n    final ArrayList<Recognition> recognitions = new ArrayList<Recognition>();\r\n    for (int i = 0; i < Math.min(nms.size(), MAX_RESULTS); ++i) {\r\n      recognitions.add(nms.get(i));\r\n    }\r\n    Trace.endSection(); // \"recognizeImage\"\r\n\r\n    timer.endSplit(\"processed results\");\r\n\r\n    return recognitions;\r\n  }\r\n```"}