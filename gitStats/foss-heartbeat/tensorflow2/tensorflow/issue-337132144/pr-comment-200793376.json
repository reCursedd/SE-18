{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/200793376", "pull_request_review_id": 135183439, "id": 200793376, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDc5MzM3Ng==", "diff_hunk": "@@ -0,0 +1,1188 @@\n+{\n+  \"nbformat\": 4,\n+  \"nbformat_minor\": 0,\n+  \"metadata\": {\n+    \"colab\": {\n+      \"name\": \"image_captioning_with_attention.ipynb\",\n+      \"version\": \"0.3.2\",\n+      \"views\": {},\n+      \"default_view\": {},\n+      \"provenance\": [\n+        {\n+          \"file_id\": \"1HI8OK2sMjcx9CTWVn0122QAHOuXaOaMg\",\n+          \"timestamp\": 1530222436922\n+        }\n+      ],\n+      \"private_outputs\": true,\n+      \"collapsed_sections\": [],\n+      \"toc_visible\": true\n+    },\n+    \"kernelspec\": {\n+      \"display_name\": \"Python 3\",\n+      \"language\": \"python\",\n+      \"name\": \"python3\"\n+    },\n+    \"accelerator\": \"GPU\"\n+  },\n+  \"cells\": [\n+    {\n+      \"metadata\": {\n+        \"id\": \"K2s1A9eLRPEj\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"cell_type\": \"markdown\",\n+      \"source\": [\n+        \"##### Copyright 2018 The TensorFlow Authors.\\n\",\n+        \"\\n\",\n+        \"Licensed under the Apache License, Version 2.0 (the \\\"License\\\").\\n\"\n+      ]\n+    },\n+    {\n+      \"metadata\": {\n+        \"id\": \"Cffg2i257iMS\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"cell_type\": \"markdown\",\n+      \"source\": [\n+        \"# Image Captioning with Attention\\n\",\n+        \"\\n\",\n+        \"<table class=\\\"tfo-notebook-buttons\\\" align=\\\"left\\\"><td>\\n\",\n+        \"<a target=\\\"_blank\\\"  href=\\\"https://colab.sandbox.google.com/github/tensorflow/tensorflow/blob/master/tensorflow/contrib/eager/python/examples/generative_examples/image_captioning_with_attention.ipynb\\\">\\n\",\n+        \"    <img src=\\\"https://www.tensorflow.org/images/colab_logo_32px.png\\\" /><span>Run in Google Colab</span></a>  \\n\",\n+        \"</td><td>\\n\",\n+        \"<a target=\\\"_blank\\\"  href=\\\"https://github.com/tensorflow/tensorflow/tree/master/tensorflow/contrib/eager/python/examples/generative_examples/image_captioning_with_attention.ipynb\\\"><img width=32px src=\\\"https://www.tensorflow.org/images/GitHub-Mark-32px.png\\\" /><span>View source on GitHub</span></a></td></table>\"\n+      ]\n+    },\n+    {\n+      \"metadata\": {\n+        \"id\": \"QASbY_HGo4Lq\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"cell_type\": \"markdown\",\n+      \"source\": [\n+        \"Image captioning is the task of generating a caption for an image. Given an image like this:\\n\",\n+        \"\\n\",\n+        \"![alt text](https://tensorflow.org/images/surf.jpg) \\n\",\n+        \"\\n\",\n+        \"NOTE: This image was originally hosted at [https://commons.wikimedia.org/wiki/Surfing#/media/File:Surfing_in_Hawaii.jpg](https://commons.wikimedia.org/wiki/Surfing#/media/File:Surfing_in_Hawaii.jpg)\\n\",\n+        \"\\n\",\n+        \"Our goal is generate a caption, such as \\\"a surfer riding on a wave\\\". Here, we'll use an attention based model. This enables us to see which parts of the image the model focuses on as it generates a caption.\\n\",\n+        \"\\n\",\n+        \"![alt text](https://tensorflow.org/images/imcap_prediction.png)\\n\",\n+        \"\\n\",\n+        \"This model architecture below is similar to [Show, Attend and Tell: Neural Image Caption Generation with Visual Attention](https://arxiv.org/abs/1502.03044). \\n\",\n+        \"\\n\",\n+        \"The code uses [tf.keras](https://www.tensorflow.org/programmers_guide/keras) and [eager execution](https://www.tensorflow.org/programmers_guide/eager), which you can learn more about in the linked guides.\\n\",\n+        \"\\n\",\n+        \"This notebook is an end-to-end example. If you run it, it will download the  [MS-COCO](http://cocodataset.org/#home) dataset, preprocess and cache a subset of the images using Inception V3, train an encoder-decoder model, and use it to generate captions on new images.\\n\",\n+        \"\\n\",\n+        \"The code requires TensorFlow version >=1.9. If you're running this in [Colab]()\\n\",\n+        \"\\n\",\n+        \"In this example, we're training on a relatively small amount of data as an example. On a single P100 GPU, this example will take about ~2 hours to train. We train on the first 30,000 captions (corresponding to about ~20,000 images depending on shuffling, as there are multiple captions per image in the dataset)\"\n+      ]\n+    },\n+    {\n+      \"metadata\": {\n+        \"id\": \"U8l4RJ0XRPEm\",\n+        \"colab_type\": \"code\",\n+        \"colab\": {\n+          \"autoexec\": {\n+            \"startup\": false,\n+            \"wait_interval\": 0\n+          }\n+        }\n+      },\n+      \"cell_type\": \"code\",\n+      \"source\": [\n+        \"# Import TensorFlow and enable eager execution\\n\",\n+        \"# This code requires TensorFlow version >=1.9\\n\",\n+        \"import tensorflow as tf\\n\",\n+        \"tf.enable_eager_execution()\\n\",\n+        \"\\n\",\n+        \"# We'll generate plots of attention in order to see which parts of an image\\n\",\n+        \"# our model focuses on during captioning\\n\",\n+        \"import matplotlib.pyplot as plt\\n\",\n+        \"\\n\",\n+        \"# Scikit-learn includes many helpful utilities\\n\",\n+        \"from sklearn.model_selection import train_test_split\\n\",\n+        \"from sklearn.utils import shuffle\\n\",\n+        \"\\n\",\n+        \"import re\\n\",\n+        \"import numpy as np\\n\",\n+        \"import os\\n\",\n+        \"import time\\n\",\n+        \"import json\\n\",\n+        \"from glob import glob\\n\",\n+        \"from PIL import Image\\n\",\n+        \"import pickle\"\n+      ],\n+      \"execution_count\": 0,\n+      \"outputs\": []\n+    },\n+    {\n+      \"metadata\": {\n+        \"id\": \"b6qbGw8MRPE5\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"cell_type\": \"markdown\",\n+      \"source\": [\n+        \"## Download and prepare the MS-COCO dataset\\n\",\n+        \"\\n\",\n+        \"We will use the [MS-COCO dataset](http://cocodataset.org/#home) to train our model. This dataset contains >82,000 images, each of which has been annotated with at least 5 different captions. The code code below will download and extract the dataset automatically.  \\n\",\n+        \"\\n\",\n+        \"**Caution: large download ahead**. We'll use the training set, it's a 13GB file.\"\n+      ]\n+    },\n+    {\n+      \"metadata\": {\n+        \"id\": \"krQuPYTtRPE7\",\n+        \"colab_type\": \"code\",\n+        \"colab\": {\n+          \"autoexec\": {\n+            \"startup\": false,\n+            \"wait_interval\": 0\n+          }\n+        }\n+      },\n+      \"cell_type\": \"code\",\n+      \"source\": [\n+        \"annotation_zip = tf.keras.utils.get_file('captions.zip', \\n\",\n+        \"                                          cache_subdir=os.path.abspath('.'),\\n\",\n+        \"                                          origin = 'http://images.cocodataset.org/annotations/annotations_trainval2014.zip',\\n\",\n+        \"                                          extract = True)\\n\",\n+        \"annotation_file = os.path.dirname(annotation_zip)+'/annotations/captions_train2014.json'\\n\",\n+        \"\\n\",\n+        \"name_of_zip = 'train2014.zip'\\n\",\n+        \"if not os.path.exists(os.path.abspath('.') + '/' + name_of_zip):\\n\",\n+        \"  image_zip = tf.keras.utils.get_file(name_of_zip, \\n\",\n+        \"                                      cache_subdir=os.path.abspath('.'),\\n\",\n+        \"                                      origin = 'http://images.cocodataset.org/zips/train2014.zip',\\n\",\n+        \"                                      extract = True)\\n\",\n+        \"  PATH = os.path.dirname(image_zip)+'/train2014/'\\n\",\n+        \"else:\\n\",\n+        \"  PATH = os.path.abspath('.')+'/train2014/'\"\n+      ],\n+      \"execution_count\": 0,\n+      \"outputs\": []\n+    },\n+    {\n+      \"metadata\": {\n+        \"id\": \"aANEzb5WwSzg\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"cell_type\": \"markdown\",\n+      \"source\": [\n+        \"## Optionally, limit the size of the training set for faster training\\n\",\n+        \"For this example, we'll select a subset of 30,000 captions and use these and the corresponding images to train our model. As always, captioning quality will improve if you choose to use more data.\"\n+      ]\n+    },\n+    {\n+      \"metadata\": {\n+        \"id\": \"4G3b8x8_RPFD\",\n+        \"colab_type\": \"code\",\n+        \"colab\": {\n+          \"autoexec\": {\n+            \"startup\": false,\n+            \"wait_interval\": 0\n+          }\n+        }\n+      },\n+      \"cell_type\": \"code\",\n+      \"source\": [\n+        \"# read the json file\\n\",\n+        \"with open(annotation_file, 'r') as f:\\n\",\n+        \"    annotations = json.load(f)\\n\",\n+        \"\\n\",\n+        \"# storing the captions and the image name in vectors\\n\",\n+        \"all_captions = []\\n\",\n+        \"all_img_name_vector = []\\n\",\n+        \"\\n\",\n+        \"for annot in annotations['annotations']:\\n\",\n+        \"    caption = '<start> ' + annot['caption'] + ' <end>'\\n\",\n+        \"    image_id = annot['image_id']\\n\",\n+        \"    full_coco_image_path = PATH + 'COCO_train2014_' + '%012d.jpg' % (image_id)\\n\",\n+        \"    \\n\",\n+        \"    all_img_name_vector.append(full_coco_image_path)\\n\",\n+        \"    all_captions.append(caption)\\n\",\n+        \"\\n\",\n+        \"# shuffling the captions and image_names together\\n\",\n+        \"# setting a random state\\n\",\n+        \"train_captions, img_name_vector = shuffle(all_captions,\\n\",\n+        \"                                          all_img_name_vector,\\n\",\n+        \"                                          random_state=1)\\n\",\n+        \"\\n\",\n+        \"# selecting the first 30000 captions from the shuffled set\\n\",\n+        \"num_examples = 30000\\n\",\n+        \"train_captions = train_captions[:num_examples]\\n\",\n+        \"img_name_vector = img_name_vector[:num_examples]\"\n+      ],\n+      \"execution_count\": 0,\n+      \"outputs\": []\n+    },\n+    {\n+      \"metadata\": {\n+        \"id\": \"5fOGoXVLxEid\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"cell_type\": \"markdown\",\n+      \"source\": [\n+        \"## Inspect the data: display a caption and the corresponding image\"\n+      ]\n+    },\n+    {\n+      \"metadata\": {\n+        \"id\": \"JuC7WcHSRPFG\",\n+        \"colab_type\": \"code\",\n+        \"colab\": {\n+          \"autoexec\": {\n+            \"startup\": false,\n+            \"wait_interval\": 0\n+          }\n+        }\n+      },\n+      \"cell_type\": \"code\",\n+      \"source\": [\n+        \"plt.imshow(Image.open(img_name_vector[0]))\\n\",\n+        \"plt.title(train_captions[0])\\n\",\n+        \"plt.show()\"\n+      ],\n+      \"execution_count\": 0,\n+      \"outputs\": []\n+    },\n+    {\n+      \"metadata\": {\n+        \"id\": \"mPBMgK34RPFL\",\n+        \"colab_type\": \"code\",\n+        \"colab\": {\n+          \"autoexec\": {\n+            \"startup\": false,\n+            \"wait_interval\": 0\n+          }\n+        }\n+      },\n+      \"cell_type\": \"code\",\n+      \"source\": [\n+        \"len(train_captions), len(all_captions)\"\n+      ],\n+      \"execution_count\": 0,\n+      \"outputs\": []\n+    },\n+    {\n+      \"metadata\": {\n+        \"id\": \"8cSW4u-ORPFQ\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"cell_type\": \"markdown\",\n+      \"source\": [\n+        \"## Preprocess the images using InceptionV3\\n\",\n+        \"Next, we will use InceptionV3 (pretrained on Imagenet) to classify each image. We will extract features from the last convolutional layer. \\n\",\n+        \"\\n\",\n+        \"First, we will need to convert the images into the format inceptionV3 expects by:\\n\",\n+        \"* Resizing the image to (299, 299)\\n\",\n+        \"* Using the [preprocess_input](https://www.tensorflow.org/api_docs/python/tf/keras/applications/inception_v3/preprocess_input) method to place the pixels in the range of -1 to 1 (to match the format of the images used to train InceptionV3).\"\n+      ]\n+    },\n+    {\n+      \"metadata\": {\n+        \"id\": \"zXR0217aRPFR\",\n+        \"colab_type\": \"code\",\n+        \"colab\": {\n+          \"autoexec\": {\n+            \"startup\": false,\n+            \"wait_interval\": 0\n+          }\n+        }\n+      },\n+      \"cell_type\": \"code\",\n+      \"source\": [\n+        \"def load_image(image_path):\\n\",\n+        \"    img = tf.read_file(image_path)\\n\",\n+        \"    img = tf.image.decode_jpeg(img, channels=3)\\n\",\n+        \"    img = tf.image.resize_images(img, (299, 299))\\n\",\n+        \"    img = tf.keras.applications.inception_v3.preprocess_input(img)\\n\",\n+        \"    return img, image_path\"\n+      ],\n+      \"execution_count\": 0,\n+      \"outputs\": []\n+    },\n+    {\n+      \"metadata\": {\n+        \"id\": \"MDvIu4sXRPFV\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"cell_type\": \"markdown\",\n+      \"source\": [\n+        \"## Initialize InceptionV3 and load the pretrained Imagenet weights\\n\",\n+        \"\\n\",\n+        \"To do so, we'll create a tf.keras model where the output layer is the last convolutional layer in the InceptionV3 architecture. \\n\",\n+        \"* Each image is forwarded through the network and the vector that we get at the end is stored in a dictionary (image_name --> feature_vector). \\n\",\n+        \"* We use the last convolutional layer because we are using attention in this example. The shape of the output of this layer is ```8x8x2048```. \\n\",\n+        \"* We avoid doing this during training so it does not become a bottleneck. \\n\",\n+        \"* After all the images are passed through the network, we pickle the dictionary and save it to disk.\"\n+      ]\n+    },\n+    {\n+      \"metadata\": {\n+        \"id\": \"RD3vW4SsRPFW\",\n+        \"colab_type\": \"code\",\n+        \"colab\": {\n+          \"autoexec\": {\n+            \"startup\": false,\n+            \"wait_interval\": 0\n+          }\n+        }\n+      },\n+      \"cell_type\": \"code\",\n+      \"source\": [\n+        \"image_model = tf.keras.applications.InceptionV3(include_top=False, \\n\",\n+        \"                                                weights='imagenet')\\n\",\n+        \"new_input = image_model.input\\n\",\n+        \"hidden_layer = image_model.layers[-1].output\\n\",\n+        \"\\n\",\n+        \"image_features_extract_model = tf.keras.Model(new_input, hidden_layer)\"\n+      ],\n+      \"execution_count\": 0,\n+      \"outputs\": []\n+    },\n+    {\n+      \"metadata\": {\n+        \"id\": \"nyqH3zFwRPFi\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"cell_type\": \"markdown\",\n+      \"source\": [\n+        \"## Preprocess and tokenize the captions\\n\",\n+        \"\\n\",\n+        \"* First, we'll tokenize the captions (e.g., by splitting on spaces). This will give us a  vocabulary of all the unique words in the data (e.g., \\\"surfing\\\", \\\"football\\\", etc).\\n\",\n+        \"* Next, we'll limit the vocabulary size to the top 5,000 words to save memory. We'll replace all other words with the token \\\"UNK\\\" (for unknown).\\n\",\n+        \"* We will then pad all sequences to the be same length as the longest one. \\n\",\n+        \"* Finally, we create a word --> index mapping and vice-versa.\"\n+      ]\n+    },\n+    {\n+      \"metadata\": {\n+        \"id\": \"HZfK8RhQRPFj\",\n+        \"colab_type\": \"code\",\n+        \"colab\": {\n+          \"autoexec\": {\n+            \"startup\": false,\n+            \"wait_interval\": 0\n+          }\n+        }\n+      },\n+      \"cell_type\": \"code\",\n+      \"source\": [\n+        \"# This will find the maximum length of any caption in our dataset\\n\",\n+        \"def calc_max_length(tensor):\\n\",\n+        \"    return max(len(t) for t in tensor)\"\n+      ],\n+      \"execution_count\": 0,\n+      \"outputs\": []\n+    },\n+    {\n+      \"metadata\": {\n+        \"id\": \"oJGE34aiRPFo\",\n+        \"colab_type\": \"code\",\n+        \"colab\": {\n+          \"autoexec\": {\n+            \"startup\": false,\n+            \"wait_interval\": 0\n+          }\n+        }\n+      },\n+      \"cell_type\": \"code\",\n+      \"source\": [\n+        \"# choosing the top 5000 words from the vocabulary\\n\",\n+        \"top_k = 5000\\n\",\n+        \"tokenizer = tf.keras.preprocessing.text.Tokenizer(num_words=top_k, \\n\",\n+        \"                                                  oov_token=\\\"<unk>\\\", \\n\",\n+        \"                                                  filters='!\\\"#$%&()*+.,-/:;=?@[\\\\]^_`{|}~ ')\\n\",\n+        \"tokenizer.fit_on_texts(train_captions)\\n\",\n+        \"train_seqs = tokenizer.texts_to_sequences(train_captions)\"\n+      ],\n+      \"execution_count\": 0,\n+      \"outputs\": []\n+    },\n+    {\n+      \"metadata\": {\n+        \"id\": \"8Q44tNQVRPFt\",\n+        \"colab_type\": \"code\",\n+        \"colab\": {\n+          \"autoexec\": {\n+            \"startup\": false,\n+            \"wait_interval\": 0\n+          }\n+        }\n+      },\n+      \"cell_type\": \"code\",\n+      \"source\": [\n+        \"tokenizer.word_index = {key:value for key, value in tokenizer.word_index.items() if value <= top_k}\\n\",\n+        \"# putting <unk> token in the word2idx dictionary\\n\",\n+        \"tokenizer.word_index[tokenizer.oov_token] = top_k + 1\\n\",\n+        \"tokenizer.word_index['<pad>'] = 0\"\n+      ],\n+      \"execution_count\": 0,\n+      \"outputs\": []\n+    },\n+    {\n+      \"metadata\": {\n+        \"id\": \"0fpJb5ojRPFv\",\n+        \"colab_type\": \"code\",\n+        \"colab\": {\n+          \"autoexec\": {\n+            \"startup\": false,\n+            \"wait_interval\": 0\n+          }\n+        }\n+      },\n+      \"cell_type\": \"code\",\n+      \"source\": [\n+        \"# creating the tokenized vectors\\n\",\n+        \"train_seqs = tokenizer.texts_to_sequences(train_captions)\"\n+      ],\n+      \"execution_count\": 0,\n+      \"outputs\": []\n+    },\n+    {\n+      \"metadata\": {\n+        \"id\": \"olQArbgbRPF1\",\n+        \"colab_type\": \"code\",\n+        \"colab\": {\n+          \"autoexec\": {\n+            \"startup\": false,\n+            \"wait_interval\": 0\n+          }\n+        }\n+      },\n+      \"cell_type\": \"code\",\n+      \"source\": [\n+        \"# creating a reverse mapping (index -> word)\\n\",\n+        \"index_word = {value:key for key, value in tokenizer.word_index.items()}\"\n+      ],\n+      \"execution_count\": 0,\n+      \"outputs\": []\n+    },\n+    {\n+      \"metadata\": {\n+        \"id\": \"AidglIZVRPF4\",\n+        \"colab_type\": \"code\",\n+        \"colab\": {\n+          \"autoexec\": {\n+            \"startup\": false,\n+            \"wait_interval\": 0\n+          }\n+        }\n+      },\n+      \"cell_type\": \"code\",\n+      \"source\": [\n+        \"# padding each vector to the max_length of the captions\\n\",\n+        \"# if the max_length parameter is not provided, pad_sequences calculates that automatically\\n\",\n+        \"cap_vector = tf.keras.preprocessing.sequence.pad_sequences(train_seqs, padding='post')\"\n+      ],\n+      \"execution_count\": 0,\n+      \"outputs\": []\n+    },\n+    {\n+      \"metadata\": {\n+        \"id\": \"gL0wkttkRPGA\",\n+        \"colab_type\": \"code\",\n+        \"colab\": {\n+          \"autoexec\": {\n+            \"startup\": false,\n+            \"wait_interval\": 0\n+          }\n+        }\n+      },\n+      \"cell_type\": \"code\",\n+      \"source\": [\n+        \"# calculating the max_length \\n\",\n+        \"# used to store the attention weights\\n\",\n+        \"max_length = calc_max_length(train_seqs)\"\n+      ],\n+      \"execution_count\": 0,\n+      \"outputs\": []\n+    },\n+    {\n+      \"metadata\": {\n+        \"id\": \"M3CD75nDpvTI\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"cell_type\": \"markdown\",\n+      \"source\": [\n+        \"## Split the data into training and testing\"\n+      ]\n+    },\n+    {\n+      \"metadata\": {\n+        \"id\": \"iS7DDMszRPGF\",\n+        \"colab_type\": \"code\",\n+        \"colab\": {\n+          \"autoexec\": {\n+            \"startup\": false,\n+            \"wait_interval\": 0\n+          }\n+        }\n+      },\n+      \"cell_type\": \"code\",\n+      \"source\": [\n+        \"# Create training and validation sets using 80-20 split\\n\",\n+        \"img_name_train, img_name_val, cap_train, cap_val = train_test_split(img_name_vector, \\n\",\n+        \"                                                                    cap_vector, \\n\",\n+        \"                                                                    test_size=0.2, \\n\",\n+        \"                                                                    random_state=0)\"\n+      ],\n+      \"execution_count\": 0,\n+      \"outputs\": []\n+    },\n+    {\n+      \"metadata\": {\n+        \"id\": \"XmViPkRFRPGH\",\n+        \"colab_type\": \"code\",\n+        \"colab\": {\n+          \"autoexec\": {\n+            \"startup\": false,\n+            \"wait_interval\": 0\n+          }\n+        }\n+      },\n+      \"cell_type\": \"code\",\n+      \"source\": [\n+        \"len(img_name_train), len(cap_train), len(img_name_val), len(cap_val)\"\n+      ],\n+      \"execution_count\": 0,\n+      \"outputs\": []\n+    },\n+    {\n+      \"metadata\": {\n+        \"id\": \"rERqlR3WRPGO\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"cell_type\": \"markdown\",\n+      \"source\": [\n+        \"## Caching the features extracted from InceptionV3\\n\",\n+        \"\\n\",\n+        \"We will pre-process each image with InceptionV3 and cache the output to disk. Caching the output in RAM would be faster but memory intensive, requiring 8 \\\\* 8 \\\\* 2048 floats per image. At the time of writing, this would exceed the memory limitations of Colab (although these may change, an instance appears to have about 12GB of memory currently). \\n\",\n+        \"\\n\",\n+        \"Performance could be improved with a more sophisticated caching strategy (e.g., by sharding the images to reduce disk I/O) at the cost of more code.\\n\",\n+        \"\\n\",\n+        \"This will take some time to run. If you'd like to see a progress bar, you could: install [tqdm](https://github.com/tqdm/tqdm) (```!pip install tqdm```), then change this line: \\n\",\n+        \"\\n\",\n+        \"```for img, path in image_dataset:``` \\n\",\n+        \"\\n\",\n+        \"to:\\n\",\n+        \"\\n\",\n+        \"```for img, path in tqdm(image_dataset):```.\"\n+      ]\n+    },\n+    {\n+      \"metadata\": {\n+        \"id\": \"Dx_fvbVgRPGQ\",\n+        \"colab_type\": \"code\",\n+        \"colab\": {\n+          \"autoexec\": {\n+            \"startup\": false,\n+            \"wait_interval\": 0\n+          }\n+        }\n+      },\n+      \"cell_type\": \"code\",\n+      \"source\": [\n+        \"# getting the unique images\\n\",\n+        \"encode_train = sorted(set(img_name_train))\\n\",\n+        \"\\n\",\n+        \"# feel free to change the batch_size according to your system configuration\\n\",\n+        \"image_dataset = tf.data.Dataset.from_tensor_slices(encode_train) \\\\\\n\",\n+        \"                       .map(load_image) \\\\\\n\",\n+        \"                       .batch(16)\\n\",\n+        \"\\n\",\n+        \"for img, path in image_dataset:\\n\",\n+        \"  batch_features = image_features_extract_model(img)\\n\",\n+        \"  batch_features = tf.reshape(batch_features, \\n\",\n+        \"                              (batch_features.shape[0], -1, batch_features.shape[3]))\\n\",\n+        \"\\n\",\n+        \"  for bf, p in zip(batch_features, path):\\n\",\n+        \"    path_of_feature = p.numpy().decode(\\\"utf-8\\\")\\n\",\n+        \"    np.save(path_of_feature, bf.numpy())\"\n+      ],\n+      \"execution_count\": 0,\n+      \"outputs\": []\n+    },\n+    {\n+      \"metadata\": {\n+        \"id\": \"uEWM9xrYcg45\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"cell_type\": \"markdown\",\n+      \"source\": [\n+        \"## Our images and captions are ready! Next, let's create a tf.data dataset to use for training our model.\\n\",\n+        \"\\n\"\n+      ]\n+    },\n+    {\n+      \"metadata\": {\n+        \"id\": \"Q3TnZ1ToRPGV\",\n+        \"colab_type\": \"code\",\n+        \"colab\": {\n+          \"autoexec\": {\n+            \"startup\": false,\n+            \"wait_interval\": 0\n+          }\n+        }\n+      },\n+      \"cell_type\": \"code\",\n+      \"source\": [\n+        \"# feel free to change these parameters according to your system's configuration\\n\",\n+        \"\\n\",\n+        \"BATCH_SIZE = 64\\n\",\n+        \"BUFFER_SIZE = 1000\\n\",\n+        \"embedding_dim = 256\\n\",\n+        \"units = 512\\n\",\n+        \"vocab_size = len(tokenizer.word_index)\\n\",\n+        \"# shape of the vector extracted from InceptionV3 is (64, 2048)\\n\",\n+        \"# these two variables represent that\\n\",\n+        \"features_shape = 2048\\n\",\n+        \"attention_features_shape = 64\"\n+      ],\n+      \"execution_count\": 0,\n+      \"outputs\": []\n+    },\n+    {\n+      \"metadata\": {\n+        \"id\": \"SmZS2N0bXG3T\",\n+        \"colab_type\": \"code\",\n+        \"colab\": {\n+          \"autoexec\": {\n+            \"startup\": false,\n+            \"wait_interval\": 0\n+          }\n+        }\n+      },\n+      \"cell_type\": \"code\",\n+      \"source\": [\n+        \"# loading the numpy files \\n\",\n+        \"def map_func(img_name, cap):\\n\",\n+        \"    img_tensor = np.load(img_name.decode('utf-8')+'.npy')\\n\",\n+        \"    return img_tensor, cap\"\n+      ],\n+      \"execution_count\": 0,\n+      \"outputs\": []\n+    },\n+    {\n+      \"metadata\": {\n+        \"id\": \"FDF_Nm3tRPGZ\",\n+        \"colab_type\": \"code\",\n+        \"colab\": {\n+          \"autoexec\": {\n+            \"startup\": false,\n+            \"wait_interval\": 0\n+          }\n+        }\n+      },\n+      \"cell_type\": \"code\",\n+      \"source\": [\n+        \"dataset = tf.data.Dataset.from_tensor_slices((img_name_train, cap_train))\\n\",\n+        \"\\n\",\n+        \"# using map to load the numpy files in parallel\\n\",\n+        \"# NOTE: Be sure to set num_parallel_calls to the number of CPU cores you have\\n\",\n+        \"# https://www.tensorflow.org/api_docs/python/tf/py_func\\n\",\n+        \"dataset = dataset.map(lambda item1, item2: tf.py_func(\\n\",\n+        \"          map_func, [item1, item2], [tf.float32, tf.int32]), num_parallel_calls=16)\\n\",\n+        \"\\n\",\n+        \"# shuffling and batching\\n\",\n+        \"dataset = dataset.shuffle(BUFFER_SIZE)\\n\",\n+        \"# https://www.tensorflow.org/api_docs/python/tf/contrib/data/batch_and_drop_remainder\\n\",\n+        \"dataset = dataset.apply(tf.contrib.data.batch_and_drop_remainder(BATCH_SIZE))\\n\",\n+        \"dataset = dataset.prefetch(1)\"\n+      ],\n+      \"execution_count\": 0,\n+      \"outputs\": []\n+    },\n+    {\n+      \"metadata\": {\n+        \"id\": \"nrvoDphgRPGd\",\n+        \"colab_type\": \"text\"\n+      },\n+      \"cell_type\": \"markdown\",\n+      \"source\": [\n+        \"## Model\\n\",\n+        \"\\n\",\n+        \"Fun fact, the decoder below is identical to the one wrote in the example for [Neural Machine Translation with Attention]( https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/eager/python/examples/nmt_with_attention/nmt_with_attention.ipynb).\\n\",\n+        \"\\n\",\n+        \"The model architecture is inspired by the [Show, Attend and Tell](https://arxiv.org/pdf/1502.03044.pdf) paper.\\n\",\n+        \"\\n\",\n+        \"* In this example, we extract the features from the lower convolutional layer of InceptionV3 giving us a vector of shape (8, 8, 2048). \\n\",\n+        \"* We squash that to a shape of (64, 2048).\\n\",\n+        \"* This vector is then passed through the CNN Encoder(which consists of a single Fully connected layer).\\n\",\n+        \"* The RNN(here GRU) attends over the image to predict the next word.\"\n+      ]\n+    },\n+    {\n+      \"metadata\": {\n+        \"id\": \"AAppCGLKRPGd\",\n+        \"colab_type\": \"code\",\n+        \"colab\": {\n+          \"autoexec\": {\n+            \"startup\": false,\n+            \"wait_interval\": 0\n+          }\n+        }\n+      },\n+      \"cell_type\": \"code\",\n+      \"source\": [\n+        \"def gru(units):\\n\",\n+        \"  # If you have a GPU, we recommend using the CuDNNGRU layer (it provides a \\n\",\n+        \"  # significant speedup).\\n\",\n+        \"  if tf.test.is_gpu_available():\\n\",\n+        \"    return tf.keras.layers.CuDNNGRU(units, \\n\",\n+        \"                                    return_sequences=True, \\n\",\n+        \"                                    return_state=True, \\n\",\n+        \"                                    recurrent_initializer='glorot_uniform')\\n\",\n+        \"  else:\\n\",\n+        \"    return tf.keras.layers.GRU(units, \\n\",\n+        \"                               return_sequences=True, \\n\",\n+        \"                               return_state=True, \\n\",\n+        \"                               recurrent_activation='sigmoid', \\n\",\n+        \"                               recurrent_initializer='glorot_uniform')\"\n+      ],\n+      \"execution_count\": 0,\n+      \"outputs\": []\n+    },\n+    {\n+      \"metadata\": {\n+        \"id\": \"AZ7R1RxHRPGf\",\n+        \"colab_type\": \"code\",\n+        \"colab\": {\n+          \"autoexec\": {\n+            \"startup\": false,\n+            \"wait_interval\": 0\n+          }\n+        }\n+      },\n+      \"cell_type\": \"code\",\n+      \"source\": [\n+        \"class CNN_Encoder(tf.keras.Model):\\n\",\n+        \"    # Since we have already extracted the features and dumped it using pickle\\n\",\n+        \"    # This encoder passes those features through a Fully connected layer\\n\",\n+        \"    def __init__(self, embedding_dim):\\n\",\n+        \"        super(CNN_Encoder, self).__init__()\\n\",\n+        \"        # shape after fc == (batch_size, 64, embedding_dim)\\n\",\n+        \"        self.fc = tf.keras.layers.Dense(embedding_dim)\\n\",\n+        \"        \\n\",\n+        \"    def call(self, x):\\n\",\n+        \"        x = self.fc(x)\\n\",\n+        \"        x = tf.nn.relu(x)\\n\",\n+        \"        return x\"\n+      ],\n+      \"execution_count\": 0,\n+      \"outputs\": []\n+    },\n+    {\n+      \"metadata\": {\n+        \"id\": \"V9UbGQmERPGi\",\n+        \"colab_type\": \"code\",\n+        \"colab\": {\n+          \"autoexec\": {\n+            \"startup\": false,\n+            \"wait_interval\": 0\n+          }\n+        }\n+      },\n+      \"cell_type\": \"code\",\n+      \"source\": [\n+        \"class RNN_Decoder(tf.keras.Model):\\n\",\n+        \"  def __init__(self, embedding_dim, units, vocab_size, batch_size):\\n\",\n+        \"    super(RNN_Decoder, self).__init__()\\n\",\n+        \"    self.units = units\\n\",\n+        \"    self.batch_sz = batch_size\\n\",\n+        \"\\n\",\n+        \"    self.embedding = tf.keras.layers.Embedding(vocab_size, embedding_dim)\\n\",\n+        \"    self.gru = gru(self.units)\\n\",\n+        \"    self.fc1 = tf.keras.layers.Dense(self.units)\\n\",\n+        \"    self.fc2 = tf.keras.layers.Dense(vocab_size)\\n\",\n+        \"\\n\",\n+        \"    # used for attention\\n\",", "path": "tensorflow/contrib/eager/python/examples/generative_examples/image_captioning_with_attention.ipynb", "position": null, "original_position": 803, "commit_id": "25d69fd6ec7fa299df997f49f6be8bc0b6f87c67", "original_commit_id": "12b8fd801f592f9825da3e739d1cb146d50c8f34", "user": {"login": "yashk2810", "id": 14262417, "node_id": "MDQ6VXNlcjE0MjYyNDE3", "avatar_url": "https://avatars1.githubusercontent.com/u/14262417?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yashk2810", "html_url": "https://github.com/yashk2810", "followers_url": "https://api.github.com/users/yashk2810/followers", "following_url": "https://api.github.com/users/yashk2810/following{/other_user}", "gists_url": "https://api.github.com/users/yashk2810/gists{/gist_id}", "starred_url": "https://api.github.com/users/yashk2810/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yashk2810/subscriptions", "organizations_url": "https://api.github.com/users/yashk2810/orgs", "repos_url": "https://api.github.com/users/yashk2810/repos", "events_url": "https://api.github.com/users/yashk2810/events{/privacy}", "received_events_url": "https://api.github.com/users/yashk2810/received_events", "type": "User", "site_admin": false}, "body": "Done :)", "created_at": "2018-07-06T23:46:08Z", "updated_at": "2018-07-09T22:47:14Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/20429#discussion_r200793376", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/20429", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/200793376"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/20429#discussion_r200793376"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/20429"}}, "body_html": "<p>Done :)</p>", "body_text": "Done :)", "in_reply_to_id": 199637198}