{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/404266977", "html_url": "https://github.com/tensorflow/tensorflow/pull/20412#issuecomment-404266977", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/20412", "id": 404266977, "node_id": "MDEyOklzc3VlQ29tbWVudDQwNDI2Njk3Nw==", "user": {"login": "bioothod", "id": 1847575, "node_id": "MDQ6VXNlcjE4NDc1NzU=", "avatar_url": "https://avatars1.githubusercontent.com/u/1847575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bioothod", "html_url": "https://github.com/bioothod", "followers_url": "https://api.github.com/users/bioothod/followers", "following_url": "https://api.github.com/users/bioothod/following{/other_user}", "gists_url": "https://api.github.com/users/bioothod/gists{/gist_id}", "starred_url": "https://api.github.com/users/bioothod/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bioothod/subscriptions", "organizations_url": "https://api.github.com/users/bioothod/orgs", "repos_url": "https://api.github.com/users/bioothod/repos", "events_url": "https://api.github.com/users/bioothod/events{/privacy}", "received_events_url": "https://api.github.com/users/bioothod/received_events", "type": "User", "site_admin": false}, "created_at": "2018-07-11T18:29:05Z", "updated_at": "2018-07-11T18:37:20Z", "author_association": "CONTRIBUTOR", "body_html": "<blockquote>\n<p>Firstly, could you describe the issue you were running into with using the GPU? By default, if linked with the GPU-enabled version of the TensorFlow C library, the Go program should automatically select a GPU for kernels where this is appropriate. If that is not happening, it seems like something we should fix.</p>\n</blockquote>\n<p>It should, but it does not. I have a pretty simple golang application, which uses default session options, and while I can list all gpu devices on the board, session is never being bound to any of them. It changed probably around 1.6, but I can not say for sure. Literally the same code binds to random gpus on 1.4.1 and it does not on 1.6.0 or recent master. Previously I used <code>nvidia-smi</code> for example to monitor GPU load and saw (and now do not) load on one or another card. If I use custom session option with LogDevicePlacement=true, then I see that session is always placed on CPU on 1.6.0.</p>\n<p>But it is only part of the problem, I also want to run particular session on particular GPU device among several available. Previously I could tune VisibleDeviceList in gpu part of session options, and things worked great. But after 1.6.0 you decided that multiple virtual mapping into the same physical device might confuse some operations (do not know how is it ever possible, but still), so golang code panics now if you ever touch VisibleDeviceList with something different than CUDA_VISIBLE_DEVICES (or empty string).</p>\n<p>Hence this patch - now I can create multiple graphs each of them bind to own gpu device and select them when creating new session according to my policies. GraphDef solution is quite heavy for many sessions, and anyway c++ code has ability to access graph nodes, and <code>TF_BindToDevice</code> is just a nice wrapper to allow that same functionality. As long as there is a way to bind graph to device (that's what new golang function <code>ImportWithDevice()</code> does), its ok with me to hide details, but there is no easy way to iterate over graph nodes in go bindings, so there is a wrapper function.</p>", "body_text": "Firstly, could you describe the issue you were running into with using the GPU? By default, if linked with the GPU-enabled version of the TensorFlow C library, the Go program should automatically select a GPU for kernels where this is appropriate. If that is not happening, it seems like something we should fix.\n\nIt should, but it does not. I have a pretty simple golang application, which uses default session options, and while I can list all gpu devices on the board, session is never being bound to any of them. It changed probably around 1.6, but I can not say for sure. Literally the same code binds to random gpus on 1.4.1 and it does not on 1.6.0 or recent master. Previously I used nvidia-smi for example to monitor GPU load and saw (and now do not) load on one or another card. If I use custom session option with LogDevicePlacement=true, then I see that session is always placed on CPU on 1.6.0.\nBut it is only part of the problem, I also want to run particular session on particular GPU device among several available. Previously I could tune VisibleDeviceList in gpu part of session options, and things worked great. But after 1.6.0 you decided that multiple virtual mapping into the same physical device might confuse some operations (do not know how is it ever possible, but still), so golang code panics now if you ever touch VisibleDeviceList with something different than CUDA_VISIBLE_DEVICES (or empty string).\nHence this patch - now I can create multiple graphs each of them bind to own gpu device and select them when creating new session according to my policies. GraphDef solution is quite heavy for many sessions, and anyway c++ code has ability to access graph nodes, and TF_BindToDevice is just a nice wrapper to allow that same functionality. As long as there is a way to bind graph to device (that's what new golang function ImportWithDevice() does), its ok with me to hide details, but there is no easy way to iterate over graph nodes in go bindings, so there is a wrapper function.", "body": "> Firstly, could you describe the issue you were running into with using the GPU? By default, if linked with the GPU-enabled version of the TensorFlow C library, the Go program should automatically select a GPU for kernels where this is appropriate. If that is not happening, it seems like something we should fix.\r\n\r\nIt should, but it does not. I have a pretty simple golang application, which uses default session options, and while I can list all gpu devices on the board, session is never being bound to any of them. It changed probably around 1.6, but I can not say for sure. Literally the same code binds to random gpus on 1.4.1 and it does not on 1.6.0 or recent master. Previously I used `nvidia-smi` for example to monitor GPU load and saw (and now do not) load on one or another card. If I use custom session option with LogDevicePlacement=true, then I see that session is always placed on CPU on 1.6.0.\r\n\r\nBut it is only part of the problem, I also want to run particular session on particular GPU device among several available. Previously I could tune VisibleDeviceList in gpu part of session options, and things worked great. But after 1.6.0 you decided that multiple virtual mapping into the same physical device might confuse some operations (do not know how is it ever possible, but still), so golang code panics now if you ever touch VisibleDeviceList with something different than CUDA_VISIBLE_DEVICES (or empty string).\r\n\r\nHence this patch - now I can create multiple graphs each of them bind to own gpu device and select them when creating new session according to my policies. GraphDef solution is quite heavy for many sessions, and anyway c++ code has ability to access graph nodes, and `TF_BindToDevice` is just a nice wrapper to allow that same functionality. As long as there is a way to bind graph to device (that's what new golang function `ImportWithDevice()` does), its ok with me to hide details, but there is no easy way to iterate over graph nodes in go bindings, so there is a wrapper function."}