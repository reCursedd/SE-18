{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/404258660", "html_url": "https://github.com/tensorflow/tensorflow/pull/20412#issuecomment-404258660", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/20412", "id": 404258660, "node_id": "MDEyOklzc3VlQ29tbWVudDQwNDI1ODY2MA==", "user": {"login": "asimshankar", "id": 16018, "node_id": "MDQ6VXNlcjE2MDE4", "avatar_url": "https://avatars2.githubusercontent.com/u/16018?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asimshankar", "html_url": "https://github.com/asimshankar", "followers_url": "https://api.github.com/users/asimshankar/followers", "following_url": "https://api.github.com/users/asimshankar/following{/other_user}", "gists_url": "https://api.github.com/users/asimshankar/gists{/gist_id}", "starred_url": "https://api.github.com/users/asimshankar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asimshankar/subscriptions", "organizations_url": "https://api.github.com/users/asimshankar/orgs", "repos_url": "https://api.github.com/users/asimshankar/repos", "events_url": "https://api.github.com/users/asimshankar/events{/privacy}", "received_events_url": "https://api.github.com/users/asimshankar/received_events", "type": "User", "site_admin": false}, "created_at": "2018-07-11T18:00:05Z", "updated_at": "2018-07-11T18:00:15Z", "author_association": "MEMBER", "body_html": "<p>Thanks for the PR <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=1847575\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/bioothod\">@bioothod</a> , but I'd like to understand more of your use case first.</p>\n<p>Firstly, could you describe the issue you were running into with using the GPU? By default, if linked with the GPU-enabled version of the TensorFlow C library, the Go program should automatically select a GPU for kernels where this is appropriate. If that is not happening, it seems like something we should fix.</p>\n<p>Secondly, the graph construction API as it stands intentionally does not allow nodes to be mutated after they are added to the graph, as this may lead to confusing behavior (e.g., if two <code>Session</code>s are created on the same graph and the graph is modified between the two). The <code>TF_BindToDevice</code> function added here is a mutation interface, so I'm a little weary of it. You'll notice that the workaround suggested operated on the <code>GraphDef</code> protocol buffer (adding the device name to nodes there) instead of operating on the in-memory representation of the graph.</p>\n<p>Looking forward to your response.</p>", "body_text": "Thanks for the PR @bioothod , but I'd like to understand more of your use case first.\nFirstly, could you describe the issue you were running into with using the GPU? By default, if linked with the GPU-enabled version of the TensorFlow C library, the Go program should automatically select a GPU for kernels where this is appropriate. If that is not happening, it seems like something we should fix.\nSecondly, the graph construction API as it stands intentionally does not allow nodes to be mutated after they are added to the graph, as this may lead to confusing behavior (e.g., if two Sessions are created on the same graph and the graph is modified between the two). The TF_BindToDevice function added here is a mutation interface, so I'm a little weary of it. You'll notice that the workaround suggested operated on the GraphDef protocol buffer (adding the device name to nodes there) instead of operating on the in-memory representation of the graph.\nLooking forward to your response.", "body": "Thanks for the PR @bioothod , but I'd like to understand more of your use case first.\r\n\r\nFirstly, could you describe the issue you were running into with using the GPU? By default, if linked with the GPU-enabled version of the TensorFlow C library, the Go program should automatically select a GPU for kernels where this is appropriate. If that is not happening, it seems like something we should fix.\r\n\r\nSecondly, the graph construction API as it stands intentionally does not allow nodes to be mutated after they are added to the graph, as this may lead to confusing behavior (e.g., if two `Session`s are created on the same graph and the graph is modified between the two). The `TF_BindToDevice` function added here is a mutation interface, so I'm a little weary of it. You'll notice that the workaround suggested operated on the `GraphDef` protocol buffer (adding the device name to nodes there) instead of operating on the in-memory representation of the graph.\r\n\r\nLooking forward to your response."}