{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/413449551", "html_url": "https://github.com/tensorflow/tensorflow/pull/20412#issuecomment-413449551", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/20412", "id": 413449551, "node_id": "MDEyOklzc3VlQ29tbWVudDQxMzQ0OTU1MQ==", "user": {"login": "asimshankar", "id": 16018, "node_id": "MDQ6VXNlcjE2MDE4", "avatar_url": "https://avatars2.githubusercontent.com/u/16018?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asimshankar", "html_url": "https://github.com/asimshankar", "followers_url": "https://api.github.com/users/asimshankar/followers", "following_url": "https://api.github.com/users/asimshankar/following{/other_user}", "gists_url": "https://api.github.com/users/asimshankar/gists{/gist_id}", "starred_url": "https://api.github.com/users/asimshankar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asimshankar/subscriptions", "organizations_url": "https://api.github.com/users/asimshankar/orgs", "repos_url": "https://api.github.com/users/asimshankar/repos", "events_url": "https://api.github.com/users/asimshankar/events{/privacy}", "received_events_url": "https://api.github.com/users/asimshankar/received_events", "type": "User", "site_admin": false}, "created_at": "2018-08-16T07:15:48Z", "updated_at": "2018-08-16T07:15:48Z", "author_association": "MEMBER", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=1847575\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/bioothod\">@bioothod</a> : You say that \"So, basically, currently TF c/c++/go bindings are broken, all graphs are always executed on CPU.\", but this is not true :). One can certainly execute graphs on GPUs from Go, as demonstrated in <a href=\"https://gist.github.com/asimshankar/ef367e4897e248466c42c2dc629814e0\">the gist I previously linked to</a>, and when I change the placeholders to be <code>tf.float32</code> instead of <code>tf.int32</code> in your example (<a href=\"https://github.com/bioothod/golang_gpu_example\">https://github.com/bioothod/golang_gpu_example</a>).</p>\n<p>Regarding <code>TF_BindToDevice</code> - yes we <em>could</em> just add it with documentation trying to explain that it may or may not work. But that seems like a bad API as there is no way for potential callers to know whether or not the call will have an effect. For example, if I write some utility library which invokes <code>TF_BindToDevice</code> - whether or not it has an effect depends on the environment in which the <em>caller</em> of my library function invoked my library function. This will make it very hard to reason about.</p>\n<p>I'm not opposed to adding to <code>TF_GraphToImportGraphDef</code> yet (haven't thought it through). But, the fact that you aren't able to use the GPU without this explicit binding (as you said \"We have a graph which is supposed to be executed on GPU by documentation, and it is not.\") seems like it is some other issue which we should get to the bottom of.</p>\n<p>Can you provide an example of such a graph?</p>", "body_text": "@bioothod : You say that \"So, basically, currently TF c/c++/go bindings are broken, all graphs are always executed on CPU.\", but this is not true :). One can certainly execute graphs on GPUs from Go, as demonstrated in the gist I previously linked to, and when I change the placeholders to be tf.float32 instead of tf.int32 in your example (https://github.com/bioothod/golang_gpu_example).\nRegarding TF_BindToDevice - yes we could just add it with documentation trying to explain that it may or may not work. But that seems like a bad API as there is no way for potential callers to know whether or not the call will have an effect. For example, if I write some utility library which invokes TF_BindToDevice - whether or not it has an effect depends on the environment in which the caller of my library function invoked my library function. This will make it very hard to reason about.\nI'm not opposed to adding to TF_GraphToImportGraphDef yet (haven't thought it through). But, the fact that you aren't able to use the GPU without this explicit binding (as you said \"We have a graph which is supposed to be executed on GPU by documentation, and it is not.\") seems like it is some other issue which we should get to the bottom of.\nCan you provide an example of such a graph?", "body": "@bioothod : You say that \"So, basically, currently TF c/c++/go bindings are broken, all graphs are always executed on CPU.\", but this is not true :). One can certainly execute graphs on GPUs from Go, as demonstrated in [the gist I previously linked to](https://gist.github.com/asimshankar/ef367e4897e248466c42c2dc629814e0), and when I change the placeholders to be `tf.float32` instead of `tf.int32` in your example (https://github.com/bioothod/golang_gpu_example).\r\n\r\nRegarding `TF_BindToDevice` - yes we _could_ just add it with documentation trying to explain that it may or may not work. But that seems like a bad API as there is no way for potential callers to know whether or not the call will have an effect. For example, if I write some utility library which invokes `TF_BindToDevice` - whether or not it has an effect depends on the environment in which the _caller_ of my library function invoked my library function. This will make it very hard to reason about. \r\n\r\nI'm not opposed to adding to `TF_GraphToImportGraphDef` yet (haven't thought it through). But, the fact that you aren't able to use the GPU without this explicit binding (as you said \"We have a graph which is supposed to be executed on GPU by documentation, and it is not.\") seems like it is some other issue which we should get to the bottom of.\r\n\r\nCan you provide an example of such a graph?"}