{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8704", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8704/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8704/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8704/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/8704", "id": 216930713, "node_id": "MDU6SXNzdWUyMTY5MzA3MTM=", "number": 8704, "title": "TensorFlow drops the first batch?", "user": {"login": "derekhh", "id": 1497445, "node_id": "MDQ6VXNlcjE0OTc0NDU=", "avatar_url": "https://avatars2.githubusercontent.com/u/1497445?v=4", "gravatar_id": "", "url": "https://api.github.com/users/derekhh", "html_url": "https://github.com/derekhh", "followers_url": "https://api.github.com/users/derekhh/followers", "following_url": "https://api.github.com/users/derekhh/following{/other_user}", "gists_url": "https://api.github.com/users/derekhh/gists{/gist_id}", "starred_url": "https://api.github.com/users/derekhh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/derekhh/subscriptions", "organizations_url": "https://api.github.com/users/derekhh/orgs", "repos_url": "https://api.github.com/users/derekhh/repos", "events_url": "https://api.github.com/users/derekhh/events{/privacy}", "received_events_url": "https://api.github.com/users/derekhh/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2017-03-24T23:48:44Z", "updated_at": "2017-03-25T02:26:27Z", "closed_at": "2017-03-25T02:26:27Z", "author_association": "NONE", "body_html": "<h3>Description</h3>\n<p>I'm trying to understand how TF generates batches from <code>TFRecord</code> file format, how to implement the basic idea of evaluate the whole validation dataset after a full epoch so I've done a small experiment.</p>\n<p>Basically I've added an <code>image/id</code> key in the <code>TFRecord</code> file that looks like this:</p>\n<pre><code>'image/id': tf.FixedLenFeature(shape=[], dtype=tf.int64)\n'id': slim.tfexample_decoder.Tensor('image/id')\n</code></pre>\n<p>The values of these ids are just numbers increasing from 0 to <code>num_samples - 1</code>. Then I'm reading the data like this:</p>\n<pre><code>...\ndata_provider = slim.dataset_data_provider.DatasetDataProvider(dataset=dataset, shuffle=False)\nraw_image, instance_id, label = data_provider.get(items=['image', 'id', 'label'])\n...\nnum_threads = 1\nimages, instance_ids, labels = tf.train.batch(tensors=[image, instance_id, label],\n                                                      batch_size=batch_size,\n                                                      num_threads=num_threads,\n                                                      capacity = batch_size,\n                                                      allow_smaller_final_batch=False)        \n...\n</code></pre>\n<p>I've used <code>shuffle=False</code>, <code>num_threads=1</code> and <code>capacity=batch_size</code> to ensure we are reading the instances in the validation set in order.</p>\n<p>I've then defined a <code>train_step_fn</code> that evaluates a mini-batch from the validation set after each step. I'm doing this to check and test we are not returning instances with duplicate ids in the same batch. The code looks like this:</p>\n<pre><code>    def train_step_fn(session, *args, **kwargs):\n        total_loss, should_stop = train_step(session, *args, **kwargs)\n        curr_global_step = tf.train.global_step(session, global_step)\n        curr_epoch = curr_global_step / validation_every_n_steps\n        image, val_ids, val_loss, accuracy = session.run([validation_images, validation_ids, total_validation_loss, validation_accuracy])\n        print(val_ids)\n        def float_formatter(x): return \"%.4f\" % x\n        tf.logging.info('after global step {} (epoch {}): validation loss = {}, validation accuracy = {}'\n                            .format(curr_global_step, curr_epoch, float_formatter(val_loss), float_formatter(accuracy)))\n        return [total_loss, should_stop]\n</code></pre>\n<p>Most of the output I'm seeing makes sense but the output from the first batch looks weird.</p>\n<pre><code>INFO:tensorflow:Starting Session.\nINFO:tensorflow:Starting Queues.\nINFO:tensorflow:global_step/sec: 0\nINFO:tensorflow:global step 1: loss = 4.1099 (3.70 sec/step)\n[17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32]\nINFO:tensorflow:after global step 1 (epoch 0): validation loss = 4.6337, validation accuracy = 0.0000\nINFO:tensorflow:global step 2: loss = 4.2118 (0.52 sec/step)\n[33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48]\nINFO:tensorflow:after global step 2 (epoch 0): validation loss = 3.9538, validation accuracy = 0.0625\nINFO:tensorflow:global step 3: loss = 4.0593 (0.75 sec/step)\n[49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64]\nINFO:tensorflow:after global step 3 (epoch 0): validation loss = 4.0773, validation accuracy = 0.0000\nINFO:tensorflow:global step 4: loss = 3.7749 (0.64 sec/step)\n[65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80]\nINFO:tensorflow:after global step 4 (epoch 0): validation loss = 4.0847, validation accuracy = 0.0625\nINFO:tensorflow:global step 5: loss = 3.7973 (0.68 sec/step)\n[81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96]\nINFO:tensorflow:after global step 5 (epoch 0): validation loss = 3.5591, validation accuracy = 0.1875\nINFO:tensorflow:global step 6: loss = 3.5584 (0.72 sec/step)\n[ 97  98  99 100 101 102 103 104 105 106 107 108 109 110 111 112]\nINFO:tensorflow:after global step 6 (epoch 0): validation loss = 3.6849, validation accuracy = 0.1250\nINFO:tensorflow:global step 7: loss = 3.5303 (0.70 sec/step)\n[113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128]\nINFO:tensorflow:after global step 7 (epoch 0): validation loss = 3.7812, validation accuracy = 0.1875\nINFO:tensorflow:global step 8: loss = 3.2698 (0.85 sec/step)\n[129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144]\nINFO:tensorflow:after global step 8 (epoch 0): validation loss = 3.3004, validation accuracy = 0.1875\nINFO:tensorflow:global step 9: loss = 3.4842 (0.94 sec/step)\nINFO:tensorflow:global_step/sec: 0.915008\n[145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160]\nINFO:tensorflow:after global step 9 (epoch 0): validation loss = 4.0377, validation accuracy = 0.1875\nINFO:tensorflow:global step 10: loss = 3.5635 (1.48 sec/step)\n[178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193]\nINFO:tensorflow:after global step 10 (epoch 0): validation loss = 3.7854, validation accuracy = 0.1875\nINFO:tensorflow:global step 11: loss = 3.1773 (0.65 sec/step)\n[194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209]\n</code></pre>\n<p>I'm assuming the first mini-batch returned should be <code>[0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15]</code> instead of <code>[17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32]</code>. Plus the fact that we are starting from 17 instead of 16 also bothers me a bit. It seems for some unknown reason TF is dropping a batch.</p>\n<p>I understand this probably won't affect the model training / validation process at all but I'm still pointing this out in case this is hiding a more serious root cause.</p>", "body_text": "Description\nI'm trying to understand how TF generates batches from TFRecord file format, how to implement the basic idea of evaluate the whole validation dataset after a full epoch so I've done a small experiment.\nBasically I've added an image/id key in the TFRecord file that looks like this:\n'image/id': tf.FixedLenFeature(shape=[], dtype=tf.int64)\n'id': slim.tfexample_decoder.Tensor('image/id')\n\nThe values of these ids are just numbers increasing from 0 to num_samples - 1. Then I'm reading the data like this:\n...\ndata_provider = slim.dataset_data_provider.DatasetDataProvider(dataset=dataset, shuffle=False)\nraw_image, instance_id, label = data_provider.get(items=['image', 'id', 'label'])\n...\nnum_threads = 1\nimages, instance_ids, labels = tf.train.batch(tensors=[image, instance_id, label],\n                                                      batch_size=batch_size,\n                                                      num_threads=num_threads,\n                                                      capacity = batch_size,\n                                                      allow_smaller_final_batch=False)        \n...\n\nI've used shuffle=False, num_threads=1 and capacity=batch_size to ensure we are reading the instances in the validation set in order.\nI've then defined a train_step_fn that evaluates a mini-batch from the validation set after each step. I'm doing this to check and test we are not returning instances with duplicate ids in the same batch. The code looks like this:\n    def train_step_fn(session, *args, **kwargs):\n        total_loss, should_stop = train_step(session, *args, **kwargs)\n        curr_global_step = tf.train.global_step(session, global_step)\n        curr_epoch = curr_global_step / validation_every_n_steps\n        image, val_ids, val_loss, accuracy = session.run([validation_images, validation_ids, total_validation_loss, validation_accuracy])\n        print(val_ids)\n        def float_formatter(x): return \"%.4f\" % x\n        tf.logging.info('after global step {} (epoch {}): validation loss = {}, validation accuracy = {}'\n                            .format(curr_global_step, curr_epoch, float_formatter(val_loss), float_formatter(accuracy)))\n        return [total_loss, should_stop]\n\nMost of the output I'm seeing makes sense but the output from the first batch looks weird.\nINFO:tensorflow:Starting Session.\nINFO:tensorflow:Starting Queues.\nINFO:tensorflow:global_step/sec: 0\nINFO:tensorflow:global step 1: loss = 4.1099 (3.70 sec/step)\n[17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32]\nINFO:tensorflow:after global step 1 (epoch 0): validation loss = 4.6337, validation accuracy = 0.0000\nINFO:tensorflow:global step 2: loss = 4.2118 (0.52 sec/step)\n[33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48]\nINFO:tensorflow:after global step 2 (epoch 0): validation loss = 3.9538, validation accuracy = 0.0625\nINFO:tensorflow:global step 3: loss = 4.0593 (0.75 sec/step)\n[49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64]\nINFO:tensorflow:after global step 3 (epoch 0): validation loss = 4.0773, validation accuracy = 0.0000\nINFO:tensorflow:global step 4: loss = 3.7749 (0.64 sec/step)\n[65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80]\nINFO:tensorflow:after global step 4 (epoch 0): validation loss = 4.0847, validation accuracy = 0.0625\nINFO:tensorflow:global step 5: loss = 3.7973 (0.68 sec/step)\n[81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96]\nINFO:tensorflow:after global step 5 (epoch 0): validation loss = 3.5591, validation accuracy = 0.1875\nINFO:tensorflow:global step 6: loss = 3.5584 (0.72 sec/step)\n[ 97  98  99 100 101 102 103 104 105 106 107 108 109 110 111 112]\nINFO:tensorflow:after global step 6 (epoch 0): validation loss = 3.6849, validation accuracy = 0.1250\nINFO:tensorflow:global step 7: loss = 3.5303 (0.70 sec/step)\n[113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128]\nINFO:tensorflow:after global step 7 (epoch 0): validation loss = 3.7812, validation accuracy = 0.1875\nINFO:tensorflow:global step 8: loss = 3.2698 (0.85 sec/step)\n[129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144]\nINFO:tensorflow:after global step 8 (epoch 0): validation loss = 3.3004, validation accuracy = 0.1875\nINFO:tensorflow:global step 9: loss = 3.4842 (0.94 sec/step)\nINFO:tensorflow:global_step/sec: 0.915008\n[145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160]\nINFO:tensorflow:after global step 9 (epoch 0): validation loss = 4.0377, validation accuracy = 0.1875\nINFO:tensorflow:global step 10: loss = 3.5635 (1.48 sec/step)\n[178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193]\nINFO:tensorflow:after global step 10 (epoch 0): validation loss = 3.7854, validation accuracy = 0.1875\nINFO:tensorflow:global step 11: loss = 3.1773 (0.65 sec/step)\n[194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209]\n\nI'm assuming the first mini-batch returned should be [0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15] instead of [17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32]. Plus the fact that we are starting from 17 instead of 16 also bothers me a bit. It seems for some unknown reason TF is dropping a batch.\nI understand this probably won't affect the model training / validation process at all but I'm still pointing this out in case this is hiding a more serious root cause.", "body": "### Description\r\n\r\nI'm trying to understand how TF generates batches from `TFRecord` file format, how to implement the basic idea of evaluate the whole validation dataset after a full epoch so I've done a small experiment.\r\n\r\nBasically I've added an `image/id` key in the `TFRecord` file that looks like this:\r\n```\r\n'image/id': tf.FixedLenFeature(shape=[], dtype=tf.int64)\r\n'id': slim.tfexample_decoder.Tensor('image/id')\r\n```\r\n\r\nThe values of these ids are just numbers increasing from 0 to `num_samples - 1`. Then I'm reading the data like this:\r\n\r\n```\r\n...\r\ndata_provider = slim.dataset_data_provider.DatasetDataProvider(dataset=dataset, shuffle=False)\r\nraw_image, instance_id, label = data_provider.get(items=['image', 'id', 'label'])\r\n...\r\nnum_threads = 1\r\nimages, instance_ids, labels = tf.train.batch(tensors=[image, instance_id, label],\r\n                                                      batch_size=batch_size,\r\n                                                      num_threads=num_threads,\r\n                                                      capacity = batch_size,\r\n                                                      allow_smaller_final_batch=False)        \r\n...\r\n```\r\n\r\nI've used `shuffle=False`, `num_threads=1` and `capacity=batch_size` to ensure we are reading the instances in the validation set in order.\r\n\r\nI've then defined a `train_step_fn` that evaluates a mini-batch from the validation set after each step. I'm doing this to check and test we are not returning instances with duplicate ids in the same batch. The code looks like this:\r\n\r\n```\r\n    def train_step_fn(session, *args, **kwargs):\r\n        total_loss, should_stop = train_step(session, *args, **kwargs)\r\n        curr_global_step = tf.train.global_step(session, global_step)\r\n        curr_epoch = curr_global_step / validation_every_n_steps\r\n        image, val_ids, val_loss, accuracy = session.run([validation_images, validation_ids, total_validation_loss, validation_accuracy])\r\n        print(val_ids)\r\n        def float_formatter(x): return \"%.4f\" % x\r\n        tf.logging.info('after global step {} (epoch {}): validation loss = {}, validation accuracy = {}'\r\n                            .format(curr_global_step, curr_epoch, float_formatter(val_loss), float_formatter(accuracy)))\r\n        return [total_loss, should_stop]\r\n```\r\n\r\nMost of the output I'm seeing makes sense but the output from the first batch looks weird.\r\n\r\n```\r\nINFO:tensorflow:Starting Session.\r\nINFO:tensorflow:Starting Queues.\r\nINFO:tensorflow:global_step/sec: 0\r\nINFO:tensorflow:global step 1: loss = 4.1099 (3.70 sec/step)\r\n[17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32]\r\nINFO:tensorflow:after global step 1 (epoch 0): validation loss = 4.6337, validation accuracy = 0.0000\r\nINFO:tensorflow:global step 2: loss = 4.2118 (0.52 sec/step)\r\n[33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48]\r\nINFO:tensorflow:after global step 2 (epoch 0): validation loss = 3.9538, validation accuracy = 0.0625\r\nINFO:tensorflow:global step 3: loss = 4.0593 (0.75 sec/step)\r\n[49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64]\r\nINFO:tensorflow:after global step 3 (epoch 0): validation loss = 4.0773, validation accuracy = 0.0000\r\nINFO:tensorflow:global step 4: loss = 3.7749 (0.64 sec/step)\r\n[65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80]\r\nINFO:tensorflow:after global step 4 (epoch 0): validation loss = 4.0847, validation accuracy = 0.0625\r\nINFO:tensorflow:global step 5: loss = 3.7973 (0.68 sec/step)\r\n[81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96]\r\nINFO:tensorflow:after global step 5 (epoch 0): validation loss = 3.5591, validation accuracy = 0.1875\r\nINFO:tensorflow:global step 6: loss = 3.5584 (0.72 sec/step)\r\n[ 97  98  99 100 101 102 103 104 105 106 107 108 109 110 111 112]\r\nINFO:tensorflow:after global step 6 (epoch 0): validation loss = 3.6849, validation accuracy = 0.1250\r\nINFO:tensorflow:global step 7: loss = 3.5303 (0.70 sec/step)\r\n[113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128]\r\nINFO:tensorflow:after global step 7 (epoch 0): validation loss = 3.7812, validation accuracy = 0.1875\r\nINFO:tensorflow:global step 8: loss = 3.2698 (0.85 sec/step)\r\n[129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144]\r\nINFO:tensorflow:after global step 8 (epoch 0): validation loss = 3.3004, validation accuracy = 0.1875\r\nINFO:tensorflow:global step 9: loss = 3.4842 (0.94 sec/step)\r\nINFO:tensorflow:global_step/sec: 0.915008\r\n[145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160]\r\nINFO:tensorflow:after global step 9 (epoch 0): validation loss = 4.0377, validation accuracy = 0.1875\r\nINFO:tensorflow:global step 10: loss = 3.5635 (1.48 sec/step)\r\n[178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193]\r\nINFO:tensorflow:after global step 10 (epoch 0): validation loss = 3.7854, validation accuracy = 0.1875\r\nINFO:tensorflow:global step 11: loss = 3.1773 (0.65 sec/step)\r\n[194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209]\r\n```\r\n\r\nI'm assuming the first mini-batch returned should be `[0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15]` instead of `[17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32]`. Plus the fact that we are starting from 17 instead of 16 also bothers me a bit. It seems for some unknown reason TF is dropping a batch.\r\n\r\nI understand this probably won't affect the model training / validation process at all but I'm still pointing this out in case this is hiding a more serious root cause."}