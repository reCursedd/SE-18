{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/17656", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/17656/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/17656/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/17656/events", "html_url": "https://github.com/tensorflow/tensorflow/pull/17656", "id": 304570554, "node_id": "MDExOlB1bGxSZXF1ZXN0MTc0NTE3NDA1", "number": 17656, "title": "Support NUMA aware CPU device", "user": {"login": "shengfuintel", "id": 3935335, "node_id": "MDQ6VXNlcjM5MzUzMzU=", "avatar_url": "https://avatars2.githubusercontent.com/u/3935335?v=4", "gravatar_id": "", "url": "https://api.github.com/users/shengfuintel", "html_url": "https://github.com/shengfuintel", "followers_url": "https://api.github.com/users/shengfuintel/followers", "following_url": "https://api.github.com/users/shengfuintel/following{/other_user}", "gists_url": "https://api.github.com/users/shengfuintel/gists{/gist_id}", "starred_url": "https://api.github.com/users/shengfuintel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/shengfuintel/subscriptions", "organizations_url": "https://api.github.com/users/shengfuintel/orgs", "repos_url": "https://api.github.com/users/shengfuintel/repos", "events_url": "https://api.github.com/users/shengfuintel/events{/privacy}", "received_events_url": "https://api.github.com/users/shengfuintel/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 300136613, "node_id": "MDU6TGFiZWwzMDAxMzY2MTM=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/cla:%20no", "name": "cla: no", "color": "eb6420", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2018-03-12T22:58:41Z", "updated_at": "2018-03-12T23:29:43Z", "closed_at": "2018-03-12T23:29:43Z", "author_association": "CONTRIBUTOR", "pull_request": {"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/17656", "html_url": "https://github.com/tensorflow/tensorflow/pull/17656", "diff_url": "https://github.com/tensorflow/tensorflow/pull/17656.diff", "patch_url": "https://github.com/tensorflow/tensorflow/pull/17656.patch"}, "body_html": "<p>We noticed TensorFlow does not scale too much from single CPU socket to multiple CPU sockets. From the performance profiling, we found the memory traffic between NUMA nodes are very high. The latency from the remote memory access prevents TensorFlow from scaling to multiple NUMA nodes.</p>\n<p>To fix this performance issue, we did a prototype to use data parallelism to improve the performance. A NumaDevice class has been added, all threads in a NumaDevice are pinned to the cores in one NUMA node, each NumaDevice has its own memory allocator. With the NumaDevice, most of the tensor are created and accessed by the same Numa node, the memory access should be local.</p>\n<p>The input data are evenly distributed to all NUMA nodes, the loss value and the gradient are computed on each Numa node and then the gradients from all Numa nodes are averaged and the variables are updated by these gradients. The variable update is done on all CPU cores.</p>\n<p>This pull request contains a prototype to support NUMA aware CPU device. Some code are hacked to make it run. We want to send this pull request to get the comments about what we are doing.</p>\n<p>From our initial performance test, ResNet 50 inference got <strong>1.4x</strong> speedup than the master branch on two socket Skylake. ResNet 50 training got <strong>1.14x</strong> speedup, which is lower than what we expected, we will continue working on it.</p>\n<p>To make it compile, you need to copy NonBlockingThreadPool.h to compile cache directory/external/eigen_archive/unsupported/Eigen/CXX11/src/ThreadPool/. Also the benchmark script need be modified slightly. I can send you the instructions for changing the benchmark script.</p>", "body_text": "We noticed TensorFlow does not scale too much from single CPU socket to multiple CPU sockets. From the performance profiling, we found the memory traffic between NUMA nodes are very high. The latency from the remote memory access prevents TensorFlow from scaling to multiple NUMA nodes.\nTo fix this performance issue, we did a prototype to use data parallelism to improve the performance. A NumaDevice class has been added, all threads in a NumaDevice are pinned to the cores in one NUMA node, each NumaDevice has its own memory allocator. With the NumaDevice, most of the tensor are created and accessed by the same Numa node, the memory access should be local.\nThe input data are evenly distributed to all NUMA nodes, the loss value and the gradient are computed on each Numa node and then the gradients from all Numa nodes are averaged and the variables are updated by these gradients. The variable update is done on all CPU cores.\nThis pull request contains a prototype to support NUMA aware CPU device. Some code are hacked to make it run. We want to send this pull request to get the comments about what we are doing.\nFrom our initial performance test, ResNet 50 inference got 1.4x speedup than the master branch on two socket Skylake. ResNet 50 training got 1.14x speedup, which is lower than what we expected, we will continue working on it.\nTo make it compile, you need to copy NonBlockingThreadPool.h to compile cache directory/external/eigen_archive/unsupported/Eigen/CXX11/src/ThreadPool/. Also the benchmark script need be modified slightly. I can send you the instructions for changing the benchmark script.", "body": "We noticed TensorFlow does not scale too much from single CPU socket to multiple CPU sockets. From the performance profiling, we found the memory traffic between NUMA nodes are very high. The latency from the remote memory access prevents TensorFlow from scaling to multiple NUMA nodes.\r\n\r\nTo fix this performance issue, we did a prototype to use data parallelism to improve the performance. A NumaDevice class has been added, all threads in a NumaDevice are pinned to the cores in one NUMA node, each NumaDevice has its own memory allocator. With the NumaDevice, most of the tensor are created and accessed by the same Numa node, the memory access should be local. \r\n\r\nThe input data are evenly distributed to all NUMA nodes, the loss value and the gradient are computed on each Numa node and then the gradients from all Numa nodes are averaged and the variables are updated by these gradients. The variable update is done on all CPU cores.\r\n\r\nThis pull request contains a prototype to support NUMA aware CPU device. Some code are hacked to make it run. We want to send this pull request to get the comments about what we are doing.\r\n\r\nFrom our initial performance test, ResNet 50 inference got **1.4x** speedup than the master branch on two socket Skylake. ResNet 50 training got **1.14x** speedup, which is lower than what we expected, we will continue working on it.\r\n\r\nTo make it compile, you need to copy NonBlockingThreadPool.h to compile cache directory/external/eigen_archive/unsupported/Eigen/CXX11/src/ThreadPool/. Also the benchmark script need be modified slightly. I can send you the instructions for changing the benchmark script."}