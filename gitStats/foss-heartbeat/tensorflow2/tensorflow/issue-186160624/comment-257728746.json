{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/257728746", "html_url": "https://github.com/tensorflow/tensorflow/issues/5289#issuecomment-257728746", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5289", "id": 257728746, "node_id": "MDEyOklzc3VlQ29tbWVudDI1NzcyODc0Ng==", "user": {"login": "nroth1", "id": 4693141, "node_id": "MDQ6VXNlcjQ2OTMxNDE=", "avatar_url": "https://avatars0.githubusercontent.com/u/4693141?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nroth1", "html_url": "https://github.com/nroth1", "followers_url": "https://api.github.com/users/nroth1/followers", "following_url": "https://api.github.com/users/nroth1/following{/other_user}", "gists_url": "https://api.github.com/users/nroth1/gists{/gist_id}", "starred_url": "https://api.github.com/users/nroth1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nroth1/subscriptions", "organizations_url": "https://api.github.com/users/nroth1/orgs", "repos_url": "https://api.github.com/users/nroth1/repos", "events_url": "https://api.github.com/users/nroth1/events{/privacy}", "received_events_url": "https://api.github.com/users/nroth1/received_events", "type": "User", "site_admin": false}, "created_at": "2016-11-01T23:22:34Z", "updated_at": "2016-11-01T23:22:57Z", "author_association": "NONE", "body_html": "<p>Hi, thanks for writing back!</p>\n<p>I agree that the partial solution would maybe be a work around, but I was hoping to understand what was happening and maybe get a cleaner fix. I am actually producing my issue without queues, in the strictest sense; I just have some python threads running in parallel (I am aware that I won't get true multithreading in python). In pseudo code this just boils down to:</p>\n<p><code>thread1: my_session.run(some_op) thread2: saver.save(my_session) </code></p>\n<p>In this case, there is no dequeue op or queue set of threads that I explicitly call, so it seems like I ought not get the deadlocking issue as described in <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"182598945\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/tensorflow/tensorflow/issues/4917\" data-hovercard-type=\"issue\" data-hovercard-url=\"/tensorflow/tensorflow/issues/4917/hovercard\" href=\"https://github.com/tensorflow/tensorflow/issues/4917\">#4917</a>? But maybe under the covers tensorflow parallelizes access to this shared session object in a way which still leaves this problem open even if you aren't using tensorflow threads/queues to make your calls?</p>\n<p>Thanks a bunch for your help!!</p>", "body_text": "Hi, thanks for writing back!\nI agree that the partial solution would maybe be a work around, but I was hoping to understand what was happening and maybe get a cleaner fix. I am actually producing my issue without queues, in the strictest sense; I just have some python threads running in parallel (I am aware that I won't get true multithreading in python). In pseudo code this just boils down to:\nthread1: my_session.run(some_op) thread2: saver.save(my_session) \nIn this case, there is no dequeue op or queue set of threads that I explicitly call, so it seems like I ought not get the deadlocking issue as described in #4917? But maybe under the covers tensorflow parallelizes access to this shared session object in a way which still leaves this problem open even if you aren't using tensorflow threads/queues to make your calls?\nThanks a bunch for your help!!", "body": "Hi, thanks for writing back!\n\nI agree that the partial solution would maybe be a work around, but I was hoping to understand what was happening and maybe get a cleaner fix. I am actually producing my issue without queues, in the strictest sense; I just have some python threads running in parallel (I am aware that I won't get true multithreading in python). In pseudo code this just boils down to: \n\n`thread1:\n       my_session.run(some_op)\n  thread2:\n       saver.save(my_session)\n`\n\nIn this case, there is no dequeue op or queue set of threads that I explicitly call, so it seems like I ought not get the deadlocking issue as described in #4917? But maybe under the covers tensorflow parallelizes access to this shared session object in a way which still leaves this problem open even if you aren't using tensorflow threads/queues to make your calls? \n\nThanks a bunch for your help!!\n"}