{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/269842435", "html_url": "https://github.com/tensorflow/tensorflow/issues/6360#issuecomment-269842435", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/6360", "id": 269842435, "node_id": "MDEyOklzc3VlQ29tbWVudDI2OTg0MjQzNQ==", "user": {"login": "mrry", "id": 192142, "node_id": "MDQ6VXNlcjE5MjE0Mg==", "avatar_url": "https://avatars1.githubusercontent.com/u/192142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mrry", "html_url": "https://github.com/mrry", "followers_url": "https://api.github.com/users/mrry/followers", "following_url": "https://api.github.com/users/mrry/following{/other_user}", "gists_url": "https://api.github.com/users/mrry/gists{/gist_id}", "starred_url": "https://api.github.com/users/mrry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mrry/subscriptions", "organizations_url": "https://api.github.com/users/mrry/orgs", "repos_url": "https://api.github.com/users/mrry/repos", "events_url": "https://api.github.com/users/mrry/events{/privacy}", "received_events_url": "https://api.github.com/users/mrry/received_events", "type": "User", "site_admin": false}, "created_at": "2016-12-31T01:38:32Z", "updated_at": "2016-12-31T01:38:32Z", "author_association": "CONTRIBUTOR", "body_html": "<p>At present, all TensorFlow variables (creating using the <code>tf.Variable</code> API) are associated with an <a href=\"https://github.com/tensorflow/tensorflow/blob/2e22f1b20fdfa77b1332c518617391dc32359c5b/tensorflow/core/kernels/variable_ops.h#L33\">individual mutex</a>, which is acquired when that variable is the lvalue input to one of the assignment ops (like <code>\"Assign\"</code>) or one of the training ops that updates a set of related variables (like <code>\"ApplyGradientDesign\"</code>), <strong>and</strong> <code>use_locking = true</code> is set on that op.</p>\n<p>In principle these locks could protect reads as well (e.g. if there were a <code>\"Snapshot\"</code> op that took a copy of the variable under the lock), but this doesn't happen in practice because TensorFlow automatically converts variable \"reference tensors\" to <code>Tensor</code> values, and regular <code>Tensor</code> values don't have a mutex, so the ops that operate on them aren't able to acquire the lock to protect reading.</p>\n<p>Since this is a sad state of affairs, we've been revising the memory model for variables, so that reads are <a href=\"https://github.com/tensorflow/tensorflow/blob/2e22f1b20fdfa77b1332c518617391dc32359c5b/tensorflow/core/ops/resource_variable_ops.cc#L55\">explicit</a> (and safely protected by a mutex), and values don't alias mutable buffers. This is still a work in progress, but <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=5376757\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/michaelisard\">@michaelisard</a> or <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=5061\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/alextp\">@alextp</a> could comment more.</p>", "body_text": "At present, all TensorFlow variables (creating using the tf.Variable API) are associated with an individual mutex, which is acquired when that variable is the lvalue input to one of the assignment ops (like \"Assign\") or one of the training ops that updates a set of related variables (like \"ApplyGradientDesign\"), and use_locking = true is set on that op.\nIn principle these locks could protect reads as well (e.g. if there were a \"Snapshot\" op that took a copy of the variable under the lock), but this doesn't happen in practice because TensorFlow automatically converts variable \"reference tensors\" to Tensor values, and regular Tensor values don't have a mutex, so the ops that operate on them aren't able to acquire the lock to protect reading.\nSince this is a sad state of affairs, we've been revising the memory model for variables, so that reads are explicit (and safely protected by a mutex), and values don't alias mutable buffers. This is still a work in progress, but @michaelisard or @alextp could comment more.", "body": "At present, all TensorFlow variables (creating using the `tf.Variable` API) are associated with an [individual mutex](https://github.com/tensorflow/tensorflow/blob/2e22f1b20fdfa77b1332c518617391dc32359c5b/tensorflow/core/kernels/variable_ops.h#L33), which is acquired when that variable is the lvalue input to one of the assignment ops (like `\"Assign\"`) or one of the training ops that updates a set of related variables (like `\"ApplyGradientDesign\"`), **and** `use_locking = true` is set on that op.\r\n\r\nIn principle these locks could protect reads as well (e.g. if there were a `\"Snapshot\"` op that took a copy of the variable under the lock), but this doesn't happen in practice because TensorFlow automatically converts variable \"reference tensors\" to `Tensor` values, and regular `Tensor` values don't have a mutex, so the ops that operate on them aren't able to acquire the lock to protect reading. \r\n\r\nSince this is a sad state of affairs, we've been revising the memory model for variables, so that reads are [explicit](https://github.com/tensorflow/tensorflow/blob/2e22f1b20fdfa77b1332c518617391dc32359c5b/tensorflow/core/ops/resource_variable_ops.cc#L55) (and safely protected by a mutex), and values don't alias mutable buffers. This is still a work in progress, but @michaelisard or @alextp could comment more."}