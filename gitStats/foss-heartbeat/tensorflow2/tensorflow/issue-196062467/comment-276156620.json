{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/276156620", "html_url": "https://github.com/tensorflow/tensorflow/issues/6360#issuecomment-276156620", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/6360", "id": 276156620, "node_id": "MDEyOklzc3VlQ29tbWVudDI3NjE1NjYyMA==", "user": {"login": "yaroslavvb", "id": 23068, "node_id": "MDQ6VXNlcjIzMDY4", "avatar_url": "https://avatars3.githubusercontent.com/u/23068?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yaroslavvb", "html_url": "https://github.com/yaroslavvb", "followers_url": "https://api.github.com/users/yaroslavvb/followers", "following_url": "https://api.github.com/users/yaroslavvb/following{/other_user}", "gists_url": "https://api.github.com/users/yaroslavvb/gists{/gist_id}", "starred_url": "https://api.github.com/users/yaroslavvb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yaroslavvb/subscriptions", "organizations_url": "https://api.github.com/users/yaroslavvb/orgs", "repos_url": "https://api.github.com/users/yaroslavvb/repos", "events_url": "https://api.github.com/users/yaroslavvb/events{/privacy}", "received_events_url": "https://api.github.com/users/yaroslavvb/received_events", "type": "User", "site_admin": false}, "created_at": "2017-01-30T19:01:26Z", "updated_at": "2017-01-30T19:01:26Z", "author_association": "CONTRIBUTOR", "body_html": "<p>BTW, there's another potential use-case for locking that came up <a href=\"http://stackoverflow.com/questions/41920371/tensorflow-multi-threaded-queuerunner\" rel=\"nofollow\">here</a></p>\n<p>You have two aligned queues of images and labels. Then you have something like <code>f(images.dequeue(), labels.dequeue()</code>. If you run this function in two parallel run calls, the queues can get out of sync. A user-facing interface might be to have <code>f</code> be a Function node, and have a property <code>use_locking</code> which adds a lock on all of its inputs on start of execution, and releases a lock at the end.</p>", "body_text": "BTW, there's another potential use-case for locking that came up here\nYou have two aligned queues of images and labels. Then you have something like f(images.dequeue(), labels.dequeue(). If you run this function in two parallel run calls, the queues can get out of sync. A user-facing interface might be to have f be a Function node, and have a property use_locking which adds a lock on all of its inputs on start of execution, and releases a lock at the end.", "body": "BTW, there's another potential use-case for locking that came up [here](http://stackoverflow.com/questions/41920371/tensorflow-multi-threaded-queuerunner)\r\n\r\nYou have two aligned queues of images and labels. Then you have something like `f(images.dequeue(), labels.dequeue()`. If you run this function in two parallel run calls, the queues can get out of sync. A user-facing interface might be to have `f` be a Function node, and have a property `use_locking` which adds a lock on all of its inputs on start of execution, and releases a lock at the end."}