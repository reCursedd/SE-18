{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/267655749", "html_url": "https://github.com/tensorflow/tensorflow/issues/6360#issuecomment-267655749", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/6360", "id": 267655749, "node_id": "MDEyOklzc3VlQ29tbWVudDI2NzY1NTc0OQ==", "user": {"login": "yaroslavvb", "id": 23068, "node_id": "MDQ6VXNlcjIzMDY4", "avatar_url": "https://avatars3.githubusercontent.com/u/23068?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yaroslavvb", "html_url": "https://github.com/yaroslavvb", "followers_url": "https://api.github.com/users/yaroslavvb/followers", "following_url": "https://api.github.com/users/yaroslavvb/following{/other_user}", "gists_url": "https://api.github.com/users/yaroslavvb/gists{/gist_id}", "starred_url": "https://api.github.com/users/yaroslavvb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yaroslavvb/subscriptions", "organizations_url": "https://api.github.com/users/yaroslavvb/orgs", "repos_url": "https://api.github.com/users/yaroslavvb/repos", "events_url": "https://api.github.com/users/yaroslavvb/events{/privacy}", "received_events_url": "https://api.github.com/users/yaroslavvb/received_events", "type": "User", "site_admin": false}, "created_at": "2016-12-16T17:57:02Z", "updated_at": "2016-12-16T17:57:02Z", "author_association": "CONTRIBUTOR", "body_html": "<div class=\"email-fragment\">Why do you need to use locking? Session is designed to support multiple\n.run calls in parallel. For instance, Supervisor and queue_runners launch\nenqueue ops in parallel with main training loop without locking.\n\nThere are some special cases -- ops like tf.assign_add have \"read\nvariable\"/\"update variable\" parts. If you don't want another thread to\nmodify the value between these two steps, there's\n tf.assign_add(...,use_locking=True) option</div>\n<span class=\"email-hidden-toggle\"><a href=\"#\">\u2026</a></span><div class=\"email-hidden-reply\">\n<div class=\"email-quoted-reply\">On Fri, Dec 16, 2016 at 5:45 AM, Danijar Hafner ***@***.***&gt; wrote:\n Especially when integrating TensorFlow into an exiting multi-threaded\n application, it's not always easy to use queues for synchronization.\n Currently, we must use Python locks to lock the sess.run(...) calls.\n Exposing a TensorFlow lock interface could allow to synchronize access only\n to needed values of the session:\n\n x = tf.placeholder(tf.float32, [None, 784])\n y = tf.placeholder(tf.float32, [None, 10])W = tf.Variable(tf.zeros([784, 10]))\n b = tf.Variable(tf.zeros([10]))\n\n lock = tf.Lock()with lock:\n   pred = tf.nn.softmax(tf.matmul(x, W) + b)\n loss = -tf.reduce_mean(tf.reduce_sum(y * tf.log(pred), 1))with lock:\n   train_step = tf.train.GradientDescentOptimizer(0.5).minimize(loss)\n def inference_thread():\n   while True:\n     # Generate data...\n     sess.run(pred, data)\n def training_thread():\n   while True:\n     # Generate data...\n     sess.run(train_step, data)\n\n Or even simpler:\n\n with tf.Lock():\n   W = tf.Variable(tf.zeros([784, 10]))# ...\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n &lt;<a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"196062467\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/tensorflow/tensorflow/issues/6360\" href=\"https://github.com/tensorflow/tensorflow/issues/6360\">#6360</a>&gt;, or mute the thread\n &lt;<a href=\"https://github.com/notifications/unsubscribe-auth/AABaHHDatqz7ifXWt50kVKAhv3hGhl21ks5rIpXrgaJpZM4LPMvQ\">https://github.com/notifications/unsubscribe-auth/AABaHHDatqz7ifXWt50kVKAhv3hGhl21ks5rIpXrgaJpZM4LPMvQ</a>&gt;\n .\n</div>\n<div class=\"email-fragment\"></div>\n</div>", "body_text": "Why do you need to use locking? Session is designed to support multiple\n.run calls in parallel. For instance, Supervisor and queue_runners launch\nenqueue ops in parallel with main training loop without locking.\n\nThere are some special cases -- ops like tf.assign_add have \"read\nvariable\"/\"update variable\" parts. If you don't want another thread to\nmodify the value between these two steps, there's\n tf.assign_add(...,use_locking=True) option\n\u2026\nOn Fri, Dec 16, 2016 at 5:45 AM, Danijar Hafner ***@***.***> wrote:\n Especially when integrating TensorFlow into an exiting multi-threaded\n application, it's not always easy to use queues for synchronization.\n Currently, we must use Python locks to lock the sess.run(...) calls.\n Exposing a TensorFlow lock interface could allow to synchronize access only\n to needed values of the session:\n\n x = tf.placeholder(tf.float32, [None, 784])\n y = tf.placeholder(tf.float32, [None, 10])W = tf.Variable(tf.zeros([784, 10]))\n b = tf.Variable(tf.zeros([10]))\n\n lock = tf.Lock()with lock:\n   pred = tf.nn.softmax(tf.matmul(x, W) + b)\n loss = -tf.reduce_mean(tf.reduce_sum(y * tf.log(pred), 1))with lock:\n   train_step = tf.train.GradientDescentOptimizer(0.5).minimize(loss)\n def inference_thread():\n   while True:\n     # Generate data...\n     sess.run(pred, data)\n def training_thread():\n   while True:\n     # Generate data...\n     sess.run(train_step, data)\n\n Or even simpler:\n\n with tf.Lock():\n   W = tf.Variable(tf.zeros([784, 10]))# ...\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#6360>, or mute the thread\n <https://github.com/notifications/unsubscribe-auth/AABaHHDatqz7ifXWt50kVKAhv3hGhl21ks5rIpXrgaJpZM4LPMvQ>\n .", "body": "Why do you need to use locking? Session is designed to support multiple\n.run calls in parallel. For instance, Supervisor and queue_runners launch\nenqueue ops in parallel with main training loop without locking.\n\nThere are some special cases -- ops like tf.assign_add have \"read\nvariable\"/\"update variable\" parts. If you don't want another thread to\nmodify the value between these two steps, there's\n tf.assign_add(...,use_locking=True) option\n\nOn Fri, Dec 16, 2016 at 5:45 AM, Danijar Hafner <notifications@github.com>\nwrote:\n\n> Especially when integrating TensorFlow into an exiting multi-threaded\n> application, it's not always easy to use queues for synchronization.\n> Currently, we must use Python locks to lock the sess.run(...) calls.\n> Exposing a TensorFlow lock interface could allow to synchronize access only\n> to needed values of the session:\n>\n> x = tf.placeholder(tf.float32, [None, 784])\n> y = tf.placeholder(tf.float32, [None, 10])W = tf.Variable(tf.zeros([784, 10]))\n> b = tf.Variable(tf.zeros([10]))\n>\n> lock = tf.Lock()with lock:\n>   pred = tf.nn.softmax(tf.matmul(x, W) + b)\n> loss = -tf.reduce_mean(tf.reduce_sum(y * tf.log(pred), 1))with lock:\n>   train_step = tf.train.GradientDescentOptimizer(0.5).minimize(loss)\n> def inference_thread():\n>   while True:\n>     # Generate data...\n>     sess.run(pred, data)\n> def training_thread():\n>   while True:\n>     # Generate data...\n>     sess.run(train_step, data)\n>\n> Or even simpler:\n>\n> with tf.Lock():\n>   W = tf.Variable(tf.zeros([784, 10]))# ...\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tensorflow/tensorflow/issues/6360>, or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AABaHHDatqz7ifXWt50kVKAhv3hGhl21ks5rIpXrgaJpZM4LPMvQ>\n> .\n>\n"}