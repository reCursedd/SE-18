{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/184689231", "html_url": "https://github.com/tensorflow/tensorflow/issues/583#issuecomment-184689231", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/583", "id": 184689231, "node_id": "MDEyOklzc3VlQ29tbWVudDE4NDY4OTIzMQ==", "user": {"login": "jeremybarnes", "id": 112556, "node_id": "MDQ6VXNlcjExMjU1Ng==", "avatar_url": "https://avatars3.githubusercontent.com/u/112556?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jeremybarnes", "html_url": "https://github.com/jeremybarnes", "followers_url": "https://api.github.com/users/jeremybarnes/followers", "following_url": "https://api.github.com/users/jeremybarnes/following{/other_user}", "gists_url": "https://api.github.com/users/jeremybarnes/gists{/gist_id}", "starred_url": "https://api.github.com/users/jeremybarnes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jeremybarnes/subscriptions", "organizations_url": "https://api.github.com/users/jeremybarnes/orgs", "repos_url": "https://api.github.com/users/jeremybarnes/repos", "events_url": "https://api.github.com/users/jeremybarnes/events{/privacy}", "received_events_url": "https://api.github.com/users/jeremybarnes/received_events", "type": "User", "site_admin": false}, "created_at": "2016-02-16T13:49:50Z", "updated_at": "2016-02-16T13:49:50Z", "author_association": "NONE", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=1095328\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/dvyukov\">@dvyukov</a> When I looked at the low CPU occupancy originally, I saw two main reasons:</p>\n<ol>\n<li>Massive contention on the lock for the global work queue.  In order to solve point 2 below, we had structured our work into multiple overlapping and independent jobs, with a reduction at the end, so there were definitely lots of threads simultaneously submitting work.  The lock contention was overwhelming.  Replacing the mutex with a spinlock helped quite a bit.</li>\n<li>Once that was fixed, it appears that there is also quite simply a lack of exploitable parallelism during execution of typical operation graphs.  I didn't look exactly at which ops were running when, but it appears that there are choke points in the computation graph that have either no or little parallelism (eg, a tree based reduction will only be able to occupy ~ 1/2 of the available cores on average).  We attempted to work around by running more than one independent graph, eg by running multiple shards of a minibatch independently in parallel, so that the high occupancy operations like convolutions from one could fill in the holes in the low-occupancy operations in the other.  This gives up some stochasticity for better occupancy, which is not always a tradeoff worth making.</li>\n</ol>\n<p>In any event, the workloads we have for Tensorflow do cause many threads to submit jobs, which is partially what drove the design for the PR that I have open; I'd be open to a simpler global queue but I'm pretty sure it wouldn't solve our problem.</p>", "body_text": "@dvyukov When I looked at the low CPU occupancy originally, I saw two main reasons:\n\nMassive contention on the lock for the global work queue.  In order to solve point 2 below, we had structured our work into multiple overlapping and independent jobs, with a reduction at the end, so there were definitely lots of threads simultaneously submitting work.  The lock contention was overwhelming.  Replacing the mutex with a spinlock helped quite a bit.\nOnce that was fixed, it appears that there is also quite simply a lack of exploitable parallelism during execution of typical operation graphs.  I didn't look exactly at which ops were running when, but it appears that there are choke points in the computation graph that have either no or little parallelism (eg, a tree based reduction will only be able to occupy ~ 1/2 of the available cores on average).  We attempted to work around by running more than one independent graph, eg by running multiple shards of a minibatch independently in parallel, so that the high occupancy operations like convolutions from one could fill in the holes in the low-occupancy operations in the other.  This gives up some stochasticity for better occupancy, which is not always a tradeoff worth making.\n\nIn any event, the workloads we have for Tensorflow do cause many threads to submit jobs, which is partially what drove the design for the PR that I have open; I'd be open to a simpler global queue but I'm pretty sure it wouldn't solve our problem.", "body": "@dvyukov When I looked at the low CPU occupancy originally, I saw two main reasons:\n1.  Massive contention on the lock for the global work queue.  In order to solve point 2 below, we had structured our work into multiple overlapping and independent jobs, with a reduction at the end, so there were definitely lots of threads simultaneously submitting work.  The lock contention was overwhelming.  Replacing the mutex with a spinlock helped quite a bit.\n2.  Once that was fixed, it appears that there is also quite simply a lack of exploitable parallelism during execution of typical operation graphs.  I didn't look exactly at which ops were running when, but it appears that there are choke points in the computation graph that have either no or little parallelism (eg, a tree based reduction will only be able to occupy ~ 1/2 of the available cores on average).  We attempted to work around by running more than one independent graph, eg by running multiple shards of a minibatch independently in parallel, so that the high occupancy operations like convolutions from one could fill in the holes in the low-occupancy operations in the other.  This gives up some stochasticity for better occupancy, which is not always a tradeoff worth making.\n\nIn any event, the workloads we have for Tensorflow do cause many threads to submit jobs, which is partially what drove the design for the PR that I have open; I'd be open to a simpler global queue but I'm pretty sure it wouldn't solve our problem.\n"}