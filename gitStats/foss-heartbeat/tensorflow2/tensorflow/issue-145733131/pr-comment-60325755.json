{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/60325755", "pull_request_review_id": null, "id": 60325755, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzI1NzU1", "diff_hunk": "@@ -0,0 +1,753 @@\n+package tensorflow\n+\n+import (\n+\t\"encoding/binary\"\n+\t\"fmt\"\n+\t\"math\"\n+\t\"reflect\"\n+\t\"runtime\"\n+\t\"unsafe\"\n+\n+\t\"github.com/golang/protobuf/proto\"\n+\n+\tpb \"github.com/tensorflow/tensorflow/tensorflow/contrib/go/proto\"\n+)\n+\n+import \"C\"\n+\n+const (\n+\tcAckByte  = 6\n+\tcBellByte = 7\n+\tcDc1      = 17\n+\n+\tcBytesComplex64 = 8\n+\tcBytesFloat32   = 4\n+\tcBytesFloat64   = 8\n+\tcBytesInt16     = 2\n+\tcBytesInt32     = 4\n+\tcBytesInt64     = 8\n+\tcBytesUint16    = 2\n+)\n+\n+// A DataType represents the type of the data contained in a Tensor\n+type DataType pb.DataType\n+\n+// A Tensor holds a multi-dimensional array of elements of a single data type.\n+type Tensor struct {\n+\tpb.TensorProto\n+\n+\ttensor      TF_Tensor\n+\tdimWeights  []int\n+\tmemReleased bool\n+}\n+\n+// A TensorShape represents the shape of a Tensor.\n+type TensorShape [][]int64\n+\n+var (\n+\t// DTInvalid Invalid tensor DataType.\n+\tDTInvalid = DataType(0)\n+\t// DTBool corresponds to TF_BOOL.\n+\tDTBool = DataType(TF_BOOL)\n+\t// DTFloat corresponds to TF_FLOAT.\n+\tDTFloat = DataType(TF_FLOAT)\n+\t// DTDouble corresponds to TF_DOUBLE.\n+\tDTDouble = DataType(TF_DOUBLE)\n+\t// DTInt8 corresponds to TF_INT8.\n+\tDTInt8 = DataType(TF_INT8)\n+\t// DTInt16 corresponds to TF_INT16.\n+\tDTInt16 = DataType(TF_INT16)\n+\t// DTInt32 corresponds to TF_INT32.\n+\tDTInt32 = DataType(TF_INT32)\n+\t// DTInt64 corresponds to TF_INT64.\n+\tDTInt64 = DataType(TF_INT64)\n+\t// DTString corresponds to TF_STRING.\n+\tDTString = DataType(TF_STRING)\n+\t// DTUint8 corresponds to TF_UINT8.\n+\tDTUint8 = DataType(TF_UINT8)\n+\t// DTUint16 corresponds to TF_UINT16.\n+\tDTUint16 = DataType(TF_UINT16)\n+\n+\t// The next data types are still not supported\n+\t// DTBfloat corresponds to TF_BFLOAT16.\n+\tDTBfloat = DataType(TF_BFLOAT16)\n+\t// DTComplex corresponds to TF_COMPLEX.\n+\tDTComplex = DataType(TF_COMPLEX)\n+\t// DTQint16 corresponds to TF_QINT16.\n+\tDTQint16 = DataType(TF_QINT16)\n+\t// DTQuint16 corresponds to TF_QUINT16.\n+\tDTQuint16 = DataType(TF_QUINT16)\n+\t// DTQuint32 corresponds to TF_QINT32.\n+\tDTQuint32 = DataType(TF_QINT32)\n+\t// DTQint8 corresponds to TF_QINT8.\n+\tDTQint8 = DataType(TF_QINT8)\n+\t// DTQuint8 corresponds to TF_QUINT8.\n+\tDTQuint8 = DataType(TF_QUINT8)\n+)\n+\n+// NewTensorWithShape returns a new tensor with the specified type, shape and data.\n+// The supported  data types are:\n+//  - DTInt8\n+//  - DTInt16\n+//  - DTInt32\n+//  - DTInt64\n+//  - DTUint8\n+//  - DTUint16\n+//  - DTFloat\n+//  - DTDouble\n+func NewTensorWithShape(shape TensorShape, data interface{}) (*Tensor, error) {\n+\tv := reflect.ValueOf(data)\n+\tif v.Kind() != reflect.Slice {\n+\t\treturn nil, &ErrSliceExpected{\n+\t\t\tDataType: v.Kind().String(),\n+\t\t}\n+\t}\n+\n+\tdataType, err := getDataTypeFromReflect(v.Type().Elem().Kind(), int64(v.Type().Elem().Size()))\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tdataSize := int64(v.Len()) * int64(v.Type().Elem().Size())\n+\tdataPtr := v.Pointer()\n+\n+\treturn newTensor(dataType, shape, unsafe.Pointer(dataPtr), dataSize)\n+}\n+\n+// NewTensor creates a new Tensor that contains the specified data. The data type\n+// and shape is deduced from the data parameter.\n+// ex:\n+//  - NewTensor(\"hello\") // Creates scalar Tensor of type DTString\n+//  - NewTensor([]int32{1, 2, 3}) // Creates a 1-D Tensor of type DTInt32\n+//  - NewTensor([][]float32{{1, 2}, {3, 4}}) // Creates a 2-D Tensor of type DTFloat\n+func NewTensor(data interface{}) (*Tensor, error) {\n+\tvar dataPtr uintptr\n+\tvar dataSer []interface{}\n+\tvar dataSize int64\n+\tvar dataType DataType\n+\tvar dims [][]int64\n+\tvar err error\n+\n+\tv := reflect.ValueOf(data)\n+\tif v.Kind() == reflect.Slice {\n+\t\tdataType, _ = getDataTypeFromReflect(v.Type().Elem().Kind(), 1)\n+\t\tif dataType == DTString {\n+\t\t\tstrings := make([]string, v.Len())\n+\t\t\tfor i := 0; i < v.Len(); i++ {\n+\t\t\t\tstrings[i] = v.Index(i).String()\n+\t\t\t}\n+\t\t\tbuf := encodeStrings(strings)\n+\t\t\treturn newTensor(DTString, TensorShape{{int64(len(strings))}},\n+\t\t\t\tunsafe.Pointer(&(buf[0])), int64(len(buf)))\n+\t\t}\n+\n+\t\tdataSer, dims, dataType, dataSize, err = serialize(data, 0, [][]int64{})\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t} else {\n+\t\t// Scalar tensor\n+\t\tdataSer = []interface{}{data}\n+\t\tdims = [][]int64{}\n+\t\tdataSize = int64(v.Type().Size())\n+\t\tif dataType, err = getDataTypeFromReflect(v.Kind(), dataSize); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\tts := TensorShape(dims)\n+\n+\tauxTensor := new(Tensor)\n+\tswitch dataType {\n+\tcase DTFloat:\n+\t\tauxTensor.FloatVal = make([]float32, len(dataSer))\n+\t\tfor i, v := range dataSer {\n+\t\t\tauxTensor.FloatVal[i] = v.(float32)\n+\t\t}\n+\t\tdataPtr = reflect.ValueOf(auxTensor.FloatVal).Pointer()\n+\tcase DTDouble:\n+\t\tauxTensor.DoubleVal = make([]float64, len(dataSer))\n+\t\tfor i, v := range dataSer {\n+\t\t\tauxTensor.DoubleVal[i] = v.(float64)\n+\t\t}\n+\t\tdataPtr = reflect.ValueOf(auxTensor.DoubleVal).Pointer()\n+\tcase DTInt8, DTInt16, DTInt32, DTUint8:\n+\t\tauxTensor.IntVal = make([]int32, len(dataSer))\n+\t\tfor i, v := range dataSer {\n+\t\t\tauxTensor.IntVal[i] = int32(reflect.ValueOf(v).Int())\n+\t\t}\n+\t\tdataPtr = reflect.ValueOf(auxTensor.IntVal).Pointer()\n+\tcase DTInt64:\n+\t\tauxTensor.Int64Val = make([]int64, len(dataSer))\n+\t\tfor i, v := range dataSer {\n+\t\t\tauxTensor.Int64Val[i] = reflect.ValueOf(v).Int()\n+\t\t}\n+\t\tdataPtr = reflect.ValueOf(auxTensor.Int64Val).Pointer()\n+\tcase DTBool:\n+\t\tauxTensor.BoolVal = make([]bool, len(dataSer))\n+\t\tfor i, v := range dataSer {\n+\t\t\tauxTensor.BoolVal[i] = v.(bool)\n+\t\t}\n+\t\tdataPtr = reflect.ValueOf(auxTensor.BoolVal).Pointer()\n+\tcase DTString:\n+\t\tauxTensor.StringVal = make([][]byte, len(dataSer))\n+\t\tfor i, v := range dataSer {\n+\t\t\tauxTensor.StringVal[i] = []byte(v.(string))\n+\t\t}\n+\t\tdataPtr = reflect.ValueOf(auxTensor.StringVal).Pointer()\n+\tdefault:\n+\t\treturn nil, &ErrTensorTypeNotSupported{\n+\t\t\tTensotType: dataType,\n+\t\t}\n+\t}\n+\n+\ttensor, err := newTensor(dataType, ts, unsafe.Pointer(dataPtr), int64(len(dataSer))*dataSize)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\ttensor.FloatVal = auxTensor.FloatVal\n+\ttensor.DoubleVal = auxTensor.DoubleVal\n+\ttensor.IntVal = auxTensor.IntVal\n+\ttensor.StringVal = auxTensor.StringVal\n+\ttensor.ScomplexVal = auxTensor.ScomplexVal\n+\ttensor.Int64Val = auxTensor.Int64Val\n+\ttensor.BoolVal = auxTensor.BoolVal\n+\n+\treturn tensor, nil\n+}\n+\n+// DataType returns the data type of the elements contained in the tensor.\n+func (t *Tensor) DataType() DataType {\n+\treturn DataType(TF_TensorType(t.tensor))\n+}\n+\n+// NumDims returns the number of dimensions in tensor t.\n+func (t *Tensor) NumDims() int {\n+\treturn TF_NumDims(t.tensor)\n+}\n+\n+// Shape returns the shape of the tensor.\n+func (t *Tensor) Shape() TensorShape {\n+\tif t.NumDims() == 0 {\n+\t\t// This is a scalar tensor\n+\t\treturn [][]int64{}\n+\t}\n+\n+\tshape := make([][]int64, t.NumDims())\n+\tfor i := 0; i < t.NumDims(); i++ {\n+\t\tshape[i] = []int64{int64(t.Dim(i))}\n+\t}\n+\n+\treturn shape\n+}\n+\n+// Dim returns the size of the specified dimension.\n+func (t *Tensor) Dim(n int) int {\n+\treturn int(TF_Dim(t.tensor, n))\n+}\n+\n+// DataSize returns the size of the data in bytes contained in a tensor.\n+func (t *Tensor) DataSize() int64 {\n+\treturn TF_TensorByteSize(t.tensor)\n+}\n+\n+// Data returns the data contained in a tensor as bytes slice.\n+func (t *Tensor) Data() []byte {\n+\tlength := t.DataSize()\n+\treturn (*[1 << 40]byte)(unsafe.Pointer(TF_TensorData(t.tensor)))[:length:length]\n+}\n+\n+// String returns a human-readable string description of a Tensor.\n+func (t *Tensor) String() string {\n+\treturn fmt.Sprintf(\"%v: dims:%v size:%v\", t.DataType(), t.NumDims(), t.DataSize())\n+}\n+\n+// ByteSlices returns the Tensor content as strings slice if the tensor\n+// type matches, if not returns a ErrInvalidTensorType error.\n+// The datatypes are:\n+//  - DTString\n+func (t *Tensor) ByteSlices() ([][]byte, error) {\n+\tif DTString != t.DataType() {\n+\t\treturn nil, &ErrInvalidTensorType{\n+\t\t\tTensorType:   t.DataType(),\n+\t\t\tExpectedType: DTString,\n+\t\t}\n+\t}\n+\n+\tif t.StringVal != nil {\n+\t\treturn t.StringVal, nil\n+\t}\n+\n+\tresultBytes := []byte{}\n+\tinStr := false\n+\tt.StringVal = [][]byte{}\n+\tfor _, b := range t.Data() {\n+\t\tif inStr {\n+\t\t\tif b == cBellByte {\n+\t\t\t\tt.StringVal = append(t.StringVal, resultBytes)\n+\t\t\t\tresultBytes = []byte{}\n+\t\t\t} else {\n+\t\t\t\tresultBytes = append(resultBytes, byte(b))\n+\t\t\t}\n+\t\t} else {\n+\t\t\t// TODO: Must be any better way to parse the strings...\n+\t\t\tif b == cAckByte || b == cBellByte || b == cDc1 {\n+\t\t\t\tinStr = true\n+\t\t\t}\n+\t\t}\n+\t}\n+\tif len(resultBytes) > 0 {\n+\t\tt.StringVal = append(t.StringVal, resultBytes)\n+\t}\n+\tt.Dtype = pb.DataType(TF_TensorType(t.tensor))\n+\n+\treturn t.StringVal, nil\n+}\n+\n+// Float32s returns the Tensor content as float32 slice if the tensor\n+// type matches, if not returns a ErrInvalidTensorType error.", "path": "tensorflow/contrib/go/tensor.go", "position": null, "original_position": 308, "commit_id": "942760424141d0f5a930982d5e78aaeb05869488", "original_commit_id": "9907ceeadf7cb12e16815d787f8b8aba16ba26c6", "user": {"login": "alonsovidales", "id": 1468785, "node_id": "MDQ6VXNlcjE0Njg3ODU=", "avatar_url": "https://avatars1.githubusercontent.com/u/1468785?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alonsovidales", "html_url": "https://github.com/alonsovidales", "followers_url": "https://api.github.com/users/alonsovidales/followers", "following_url": "https://api.github.com/users/alonsovidales/following{/other_user}", "gists_url": "https://api.github.com/users/alonsovidales/gists{/gist_id}", "starred_url": "https://api.github.com/users/alonsovidales/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alonsovidales/subscriptions", "organizations_url": "https://api.github.com/users/alonsovidales/orgs", "repos_url": "https://api.github.com/users/alonsovidales/repos", "events_url": "https://api.github.com/users/alonsovidales/events{/privacy}", "received_events_url": "https://api.github.com/users/alonsovidales/received_events", "type": "User", "site_admin": false}, "body": "Ok, I'm going to change that on all the comments.\n", "created_at": "2016-04-19T22:49:16Z", "updated_at": "2016-05-05T08:12:14Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/1771#discussion_r60325755", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/1771", "author_association": "NONE", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/60325755"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/1771#discussion_r60325755"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/1771"}}, "body_html": "<p>Ok, I'm going to change that on all the comments.</p>", "body_text": "Ok, I'm going to change that on all the comments."}