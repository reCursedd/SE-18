{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/60304191", "pull_request_review_id": null, "id": 60304191, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzA0MTkx", "diff_hunk": "@@ -0,0 +1,769 @@\n+package tensorflow\n+\n+import (\n+\t\"encoding/binary\"\n+\t\"fmt\"\n+\t\"math\"\n+\t\"reflect\"\n+\t\"runtime\"\n+\t\"unsafe\"\n+\n+\t\"github.com/golang/protobuf/proto\"\n+\n+\tpb \"github.com/tensorflow/tensorflow/tensorflow/contrib/go/proto\"\n+)\n+\n+import \"C\"\n+\n+const (\n+\tcAckByte  = 6\n+\tcBellByte = 7\n+\tcDc1      = 17\n+\n+\tcBytesComplex64 = 8\n+\tcBytesFloat32   = 4\n+\tcBytesFloat64   = 8\n+\tcBytesInt16     = 2\n+\tcBytesInt32     = 4\n+\tcBytesInt64     = 8\n+\tcBytesUint16    = 2\n+)\n+\n+// A DataType represents the type of the data contained in a Tensor\n+type DataType pb.DataType\n+\n+// A TensorInterface is the interface implemented by Tensors.\n+type TensorInterface interface {\n+\tData() []byte\n+\tDataSize() int64\n+\tDataType() DataType\n+\tGetVal(d ...int) (val interface{}, err error)\n+\n+\tDim(n int) int\n+\tNumDims() int\n+\n+\tBool() (res []bool, err error)\n+\tFloat32() (res []float32, err error)\n+\tFloat64() (res []float64, err error)\n+\tInt32() (res []int32, err error)\n+\tInt64() (res []int64, err error)\n+\tStr() (res [][]byte, err error)\n+\n+\tString() string\n+}\n+\n+// A Tensor holds a multi-dimensional array of elements of a single data type.\n+type Tensor struct {\n+\tpb.TensorProto\n+\n+\ttensor      TF_Tensor\n+\tdimWeights  []int\n+\tmemReleased bool\n+}\n+\n+// A TensorShape represents the shape of a Tensor.\n+type TensorShape [][]int64\n+\n+var (\n+\t// DTInvalid Invalid tensor DataType.\n+\tDTInvalid = DataType(0)\n+\t// DTBfloat corresponds to TF_BFLOAT16.\n+\tDTBfloat = DataType(TF_BFLOAT16)\n+\t// DTBool corresponds to TF_BOOL.\n+\tDTBool = DataType(TF_BOOL)\n+\t// DTComplex corresponds to TF_COMPLEX.\n+\tDTComplex = DataType(TF_COMPLEX)\n+\t// DTFloat corresponds to TF_FLOAT.\n+\tDTFloat = DataType(TF_FLOAT)\n+\t// DTDouble corresponds to TF_DOUBLE.\n+\tDTDouble = DataType(TF_DOUBLE)\n+\t// DTInt8 corresponds to TF_INT8.\n+\tDTInt8 = DataType(TF_INT8)\n+\t// DTInt16 corresponds to TF_INT16.\n+\tDTInt16 = DataType(TF_INT16)\n+\t// DTInt32 corresponds to TF_INT32.\n+\tDTInt32 = DataType(TF_INT32)\n+\t// DTInt64 corresponds to TF_INT64.\n+\tDTInt64 = DataType(TF_INT64)\n+\t// DTQint16 corresponds to TF_QINT16.\n+\tDTQint16 = DataType(TF_QINT16)\n+\t// DTQuint16 corresponds to TF_QUINT16.\n+\tDTQuint16 = DataType(TF_QUINT16)\n+\t// DTQuint32 corresponds to TF_QINT32.\n+\tDTQuint32 = DataType(TF_QINT32)\n+\t// DTQint8 corresponds to TF_QINT8.\n+\tDTQint8 = DataType(TF_QINT8)\n+\t// DTQuint8 corresponds to TF_QUINT8.\n+\tDTQuint8 = DataType(TF_QUINT8)\n+\t// DTString corresponds to TF_STRING.\n+\tDTString = DataType(TF_STRING)\n+\t// DTUint8 corresponds to TF_UINT8.\n+\tDTUint8 = DataType(TF_UINT8)\n+\t// DTUint16 corresponds to TF_UINT16.\n+\tDTUint16 = DataType(TF_UINT16)\n+)\n+\n+// NewTensorWithShape returns a new tensor with the specified type, shape and data.\n+// The supported  data types are:\n+//  - DTInt8\n+//  - DTInt16\n+//  - DTInt32\n+//  - DTInt64\n+//  - DTUint8\n+//  - DTUint16\n+//  - DTFloat\n+//  - DTDouble\n+func NewTensorWithShape(shape TensorShape, data interface{}) (*Tensor, error) {\n+\tv := reflect.ValueOf(data)\n+\tif v.Kind() != reflect.Slice {\n+\t\treturn nil, &ErrSliceExpected{\n+\t\t\tdataType: v.Kind().String(),\n+\t\t}\n+\t}\n+\n+\tdataType, err := getDataTypeFromReflect(v.Type().Elem().Kind(), int64(v.Type().Elem().Size()))\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tdataSize := int64(v.Len()) * int64(v.Type().Elem().Size())\n+\tdataPtr := v.Pointer()\n+\n+\treturn newTensor(dataType, shape, unsafe.Pointer(dataPtr), dataSize)\n+}\n+\n+// NewTensor creates a new Tensor that contains the specified data. The data type\n+// and shape is deduced from the data parameter.\n+// ex:\n+//  - NewTensor(\"hello\") // Creates scalar Tensor of type DTString\n+//  - NewTensor([]int32{1, 2, 3}) // Creates a 1-D Tensor of type DTInt32\n+//  - NewTensor([][]float32{{1, 2}, {3, 4}}) // Creates a 2-D Tensor of type DTFloat\n+func NewTensor(data interface{}) (*Tensor, error) {\n+\tvar dataPtr uintptr\n+\tvar dataSer []interface{}\n+\tvar dataSize int64\n+\tvar dataType DataType\n+\tvar dims [][]int64\n+\tvar err error\n+\n+\tv := reflect.ValueOf(data)\n+\tif v.Kind() == reflect.Slice {\n+\t\tdataType, _ = getDataTypeFromReflect(v.Type().Elem().Kind(), 1)\n+\t\tif dataType == DTString {\n+\t\t\tstrings := make([]string, v.Len())\n+\t\t\tfor i := 0; i < v.Len(); i++ {\n+\t\t\t\tstrings[i] = v.Index(i).String()\n+\t\t\t}\n+\t\t\tbuf := encodeStrings(strings)\n+\t\t\treturn newTensor(DTString, TensorShape{{int64(len(strings))}},\n+\t\t\t\tunsafe.Pointer(&(buf[0])), int64(len(buf)))\n+\t\t}\n+\n+\t\tdataSer, dims, dataType, dataSize, err = serialize(data, 0, [][]int64{})\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t} else {\n+\t\t// Scalar tensor\n+\t\tdataSer = []interface{}{data}\n+\t\tdims = [][]int64{}\n+\t\tdataSize = int64(v.Type().Size())\n+\t\tif dataType, err = getDataTypeFromReflect(v.Kind(), dataSize); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\tts := TensorShape(dims)\n+\n+\tauxTensor := new(Tensor)\n+\tswitch dataType {\n+\tcase DTFloat:\n+\t\tauxTensor.FloatVal = make([]float32, len(dataSer))\n+\t\tfor i, v := range dataSer {\n+\t\t\tauxTensor.FloatVal[i] = v.(float32)\n+\t\t}\n+\t\tdataPtr = reflect.ValueOf(auxTensor.FloatVal).Pointer()\n+\tcase DTDouble:\n+\t\tauxTensor.DoubleVal = make([]float64, len(dataSer))\n+\t\tfor i, v := range dataSer {\n+\t\t\tauxTensor.DoubleVal[i] = v.(float64)\n+\t\t}\n+\t\tdataPtr = reflect.ValueOf(auxTensor.DoubleVal).Pointer()\n+\tcase DTInt8, DTInt16, DTInt32, DTUint8:\n+\t\tauxTensor.IntVal = make([]int32, len(dataSer))\n+\t\tfor i, v := range dataSer {\n+\t\t\tauxTensor.IntVal[i] = int32(reflect.ValueOf(v).Int())\n+\t\t}\n+\t\tdataPtr = reflect.ValueOf(auxTensor.IntVal).Pointer()\n+\tcase DTInt64:\n+\t\tauxTensor.Int64Val = make([]int64, len(dataSer))\n+\t\tfor i, v := range dataSer {\n+\t\t\tauxTensor.Int64Val[i] = reflect.ValueOf(v).Int()\n+\t\t}\n+\t\tdataPtr = reflect.ValueOf(auxTensor.Int64Val).Pointer()\n+\tcase DTBool:\n+\t\tauxTensor.BoolVal = make([]bool, len(dataSer))\n+\t\tfor i, v := range dataSer {\n+\t\t\tauxTensor.BoolVal[i] = v.(bool)\n+\t\t}\n+\t\tdataPtr = reflect.ValueOf(auxTensor.BoolVal).Pointer()\n+\tcase DTString:\n+\t\tauxTensor.StringVal = make([][]byte, len(dataSer))\n+\t\tfor i, v := range dataSer {\n+\t\t\tauxTensor.StringVal[i] = []byte(v.(string))\n+\t\t}\n+\t\tdataPtr = reflect.ValueOf(auxTensor.StringVal).Pointer()\n+\tdefault:\n+\t\treturn nil, &ErrTensorTypeNotSupported{\n+\t\t\ttensotType: dataType,\n+\t\t}\n+\t}\n+\n+\ttensor, err := newTensor(dataType, ts, unsafe.Pointer(dataPtr), int64(len(dataSer))*dataSize)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\ttensor.FloatVal = auxTensor.FloatVal\n+\ttensor.DoubleVal = auxTensor.DoubleVal\n+\ttensor.IntVal = auxTensor.IntVal\n+\ttensor.StringVal = auxTensor.StringVal\n+\ttensor.ScomplexVal = auxTensor.ScomplexVal\n+\ttensor.Int64Val = auxTensor.Int64Val\n+\ttensor.BoolVal = auxTensor.BoolVal\n+\n+\treturn tensor, nil\n+}\n+\n+// DataType returns the data type of the elements contained in the tensor.\n+func (t *Tensor) DataType() DataType {\n+\treturn DataType(TF_TensorType(t.tensor))\n+}\n+\n+// NumDims returns the number of dimensions in tensor t.\n+func (t *Tensor) NumDims() int {\n+\treturn TF_NumDims(t.tensor)\n+}\n+\n+// Shape returns the shape of the tensor.\n+func (t *Tensor) Shape() TensorShape {\n+\tif t.NumDims() == 0 {\n+\t\t// This is a scalar tensor\n+\t\treturn [][]int64{}\n+\t}\n+\n+\tshape := make([][]int64, t.NumDims())\n+\tfor i := 0; i < t.NumDims(); i++ {\n+\t\tshape[i] = []int64{int64(t.Dim(i))}\n+\t}\n+\n+\treturn shape\n+}\n+\n+// Dim returns the size of the specified dimension.\n+func (t *Tensor) Dim(n int) int {\n+\treturn int(TF_Dim(t.tensor, n))\n+}\n+\n+// DataSize returns the size of the data in bytes contained in a tensor.\n+func (t *Tensor) DataSize() int64 {\n+\treturn TF_TensorByteSize(t.tensor)\n+}\n+\n+// Data returns the data contained in a tensor as bytes slice.\n+func (t *Tensor) Data() []byte {\n+\tlength := t.DataSize()\n+\treturn (*[1 << 40]byte)(unsafe.Pointer(TF_TensorData(t.tensor)))[:length:length]\n+}\n+\n+// String returns a human-readable string description of a Tensor.\n+func (t *Tensor) String() string {\n+\treturn fmt.Sprintf(\"%v: dims:%v size:%v\", t.DataType(), t.NumDims(), t.DataSize())\n+}\n+\n+// Str returns the Tensor content as strings slice if the tensor\n+// type matches, if not returns a ErrInvalidTensorType error.\n+// The datatypes are:\n+//  - DTString\n+func (t *Tensor) Str() ([][]byte, error) {\n+\tif DTString != t.DataType() {\n+\t\treturn nil, &ErrInvalidTensorType{\n+\t\t\ttensorType:   t.DataType(),\n+\t\t\texpectedType: DTString,\n+\t\t}\n+\t}\n+\n+\tif t.StringVal != nil {\n+\t\treturn t.StringVal, nil\n+\t}\n+\n+\tresultBytes := []byte{}\n+\tinStr := false\n+\tt.StringVal = [][]byte{}\n+\tfor _, b := range t.Data() {\n+\t\tif inStr {\n+\t\t\tif b == cBellByte {\n+\t\t\t\tt.StringVal = append(t.StringVal, resultBytes)\n+\t\t\t\tresultBytes = []byte{}\n+\t\t\t} else {\n+\t\t\t\tresultBytes = append(resultBytes, byte(b))\n+\t\t\t}\n+\t\t} else {\n+\t\t\t// TODO: Must be any better way to parse the strings...\n+\t\t\tif b == cAckByte || b == cBellByte || b == cDc1 {\n+\t\t\t\tinStr = true\n+\t\t\t}\n+\t\t}\n+\t}\n+\tif len(resultBytes) > 0 {\n+\t\tt.StringVal = append(t.StringVal, resultBytes)\n+\t}\n+\tt.Dtype = pb.DataType(TF_TensorType(t.tensor))\n+\n+\treturn t.StringVal, nil\n+}\n+\n+// Float32 returns the Tensor content as float32 slice if the tensor\n+// type matches, if not returns a ErrInvalidTensorType error.\n+// The datatypes are:\n+//  - DTFloat\n+func (t *Tensor) Float32() ([]float32, error) {\n+\tif DTFloat != t.DataType() {\n+\t\treturn nil, &ErrInvalidTensorType{\n+\t\t\ttensorType:   t.DataType(),\n+\t\t\texpectedType: DTFloat,\n+\t\t}\n+\t}\n+\n+\tif t.FloatVal != nil {\n+\t\treturn t.FloatVal, nil\n+\t}\n+\n+\tdata := t.Data()\n+\tnumElems := len(data) / cBytesFloat32\n+\tt.FloatVal = make([]float32, numElems)\n+\tfor i := 0; i < numElems; i++ {\n+\t\tt.FloatVal[i] = math.Float32frombits(binary.LittleEndian.Uint32(data[i*cBytesFloat32 : (i+1)*cBytesFloat32]))\n+\t}\n+\tt.Dtype = pb.DataType(TF_TensorType(t.tensor))\n+\n+\treturn t.FloatVal, nil\n+}\n+\n+// Float64 returns the Tensor content as float64 slice if the tensor\n+// type matches, if not returns a ErrInvalidTensorType error.\n+// The datatypes are:\n+//  - DTDouble\n+func (t *Tensor) Float64() ([]float64, error) {\n+\tif DTDouble != t.DataType() {\n+\t\treturn nil, &ErrInvalidTensorType{\n+\t\t\ttensorType:   t.DataType(),\n+\t\t\texpectedType: DTDouble,\n+\t\t}\n+\t}\n+\n+\tif t.DoubleVal != nil {\n+\t\treturn t.DoubleVal, nil\n+\t}\n+\n+\tdata := t.Data()\n+\tnumElems := len(data) / cBytesFloat64\n+\tt.DoubleVal = make([]float64, numElems)\n+\tfor i := 0; i < numElems; i++ {\n+\t\tt.DoubleVal[i] = math.Float64frombits(binary.LittleEndian.Uint64(data[i*cBytesFloat64 : (i+1)*cBytesFloat64]))\n+\t}\n+\tt.Dtype = pb.DataType(TF_TensorType(t.tensor))\n+\n+\treturn t.DoubleVal, nil\n+}\n+\n+// Int32 returns the Tensor content as int32 slice if the tensor\n+// type matches, if not returns a ErrInvalidTensorType error.\n+// The datatypes are:\n+//  - DTUint8\n+//  - DTInt8\n+//  - DTInt16\n+//  - DTInt32\n+func (t *Tensor) Int32() ([]int32, error) {\n+\tif t.IntVal != nil {\n+\t\treturn t.IntVal, nil\n+\t}\n+\n+\tdata := t.Data()\n+\tswitch t.DataType() {\n+\tcase DTInt8, DTUint8:\n+\t\tt.IntVal = make([]int32, len(data))\n+\t\tfor i, v := range data {\n+\t\t\tt.IntVal[i] = int32(v)\n+\t\t}\n+\tcase DTInt16:\n+\t\tnumElems := len(data) / cBytesUint16\n+\t\tt.IntVal = make([]int32, numElems)\n+\t\tfor i := 0; i < numElems; i++ {\n+\t\t\tt.IntVal[i] = int32(binary.LittleEndian.Uint16(data[i*cBytesUint16 : (i+1)*cBytesUint16]))\n+\t\t}\n+\tcase DTInt32:\n+\t\tnumElems := len(data) / cBytesInt32\n+\t\tt.IntVal = make([]int32, numElems)\n+\t\tfor i := 0; i < numElems; i++ {\n+\t\t\tt.IntVal[i] = int32(binary.LittleEndian.Uint32(data[i*cBytesInt32 : (i+1)*cBytesInt32]))\n+\t\t}\n+\tdefault:\n+\t\treturn nil, &ErrInvalidTensorType{\n+\t\t\ttensorType:   t.DataType(),\n+\t\t\texpectedType: DTInt32,\n+\t\t}\n+\t}\n+\n+\tt.Dtype = pb.DataType(TF_TensorType(t.tensor))\n+\n+\treturn t.IntVal, nil\n+}\n+\n+// Int64 returns the Tensor content as int64 slice if the tensor\n+// type matches, if not returns a ErrInvalidTensorType error.\n+// The datatypes are:\n+//  - DTInt64\n+func (t *Tensor) Int64() ([]int64, error) {\n+\tif DTInt64 != t.DataType() {\n+\t\treturn nil, &ErrInvalidTensorType{\n+\t\t\ttensorType:   t.DataType(),\n+\t\t\texpectedType: DTInt64,\n+\t\t}\n+\t}\n+\n+\tif t.Int64Val != nil {\n+\t\treturn t.Int64Val, nil\n+\t}\n+\n+\tdata := t.Data()\n+\tnumElems := len(data) / cBytesInt64\n+\tt.Int64Val = make([]int64, numElems)\n+\tfor i := 0; i < numElems; i++ {\n+\t\tt.Int64Val[i] = int64(binary.LittleEndian.Uint64(data[i*cBytesInt64 : (i+1)*cBytesInt64]))\n+\t}\n+\tt.Dtype = pb.DataType(TF_TensorType(t.tensor))\n+\n+\treturn t.Int64Val, nil\n+}\n+\n+// Bool returns the Tensor content as boolean slice if the tensor\n+// type matches, if not returns a ErrInvalidTensorType error.\n+// The datatypes are:\n+//  - DTBool\n+func (t *Tensor) Bool() ([]bool, error) {\n+\tif DTBool != t.DataType() {\n+\t\treturn nil, &ErrInvalidTensorType{\n+\t\t\ttensorType:   t.DataType(),\n+\t\t\texpectedType: DTBool,\n+\t\t}\n+\t}\n+\n+\tif t.BoolVal != nil {\n+\t\treturn t.BoolVal, nil\n+\t}\n+\n+\tdata := t.Data()\n+\tt.BoolVal = make([]bool, len(data))\n+\tfor i, v := range data {\n+\t\tt.BoolVal[i] = (v == 1)\n+\t}\n+\tt.Dtype = pb.DataType(TF_TensorType(t.tensor))\n+\n+\treturn t.BoolVal, nil\n+}\n+\n+// GetVal returns the value of the element contained in the specified position\n+// in the tensor, Ex: GetVal(1, 2, 3) is equivalent to data[1][2][3] on a\n+// multidimensional array.\n+//  This method returns an error if the number of dimensions is incorrect or\n+//  are out of range.\n+func (t *Tensor) GetVal(d ...int) (val interface{}, err error) {\n+\tif len(d) != t.NumDims() {\n+\t\treturn nil, &ErrDimsOutOfTensorRange{\n+\t\t\ttensorDim: t.NumDims(),\n+\t\t\tspecDims:  len(d),\n+\t\t}\n+\t}\n+\n+\tpos := 0\n+\tif t.dimWeights != nil {\n+\t\tfor i, w := range t.dimWeights {\n+\t\t\tpos += d[i] * w\n+\t\t}\n+\t} else {\n+\t\t// Calculate the cumulative weight for each dimension, the\n+\t\t// weight is the number of elements before the first of the\n+\t\t// elements on this dimension\n+\t\tt.dimWeights = make([]int, len(d))\n+\t\tpos = d[len(d)-1]\n+\t\tif pos >= t.Dim(len(d)-1) {\n+\t\t\treturn nil, &ErrIndexOutOfRange{\n+\t\t\t\tdim:       len(d) - 1,\n+\t\t\t\tindex:     pos,\n+\t\t\t\tdimsRange: t.Dim(len(d) - 1),\n+\t\t\t}\n+\t\t}\n+\t\tt.dimWeights[len(d)-1] = 1\n+\n+\t\tlastWeight := 0\n+\t\tfor i := len(d) - 2; i >= 0; i-- {\n+\t\t\tlastWeight += t.Dim(i + 1)\n+\t\t\tt.dimWeights[i] = lastWeight\n+\t\t\tpos += d[i] * lastWeight\n+\n+\t\t\tif d[i] >= t.Dim(i) {\n+\t\t\t\treturn nil, &ErrIndexOutOfRange{\n+\t\t\t\t\tdim:       i,\n+\t\t\t\t\tindex:     pos,\n+\t\t\t\t\tdimsRange: t.Dim(i),\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn t.getValOnPos(pos)\n+}\n+\n+// getValOnPos returns the value of one of the elements of the Tensor on the\n+// specified position\n+func (t *Tensor) getValOnPos(pos int) (val interface{}, err error) {\n+\tswitch t.DataType() {\n+\tcase DTFloat:\n+\t\tvals, _ := t.Float32()\n+\t\treturn vals[pos], nil\n+\tcase DTDouble:\n+\t\tvals, _ := t.Float64()\n+\t\treturn vals[pos], nil\n+\tcase DTInt8, DTInt16, DTInt32, DTUint8:\n+\t\tvals, _ := t.Int32()\n+\t\treturn vals[pos], nil\n+\tcase DTInt64:\n+\t\tvals, _ := t.Int64()\n+\t\treturn vals[pos], nil\n+\tcase DTBool:\n+\t\tvals, _ := t.Bool()\n+\t\treturn vals[pos], nil\n+\tcase DTString:\n+\t\tvals, _ := t.Str()\n+\t\treturn vals[pos], nil\n+\t}\n+\n+\treturn nil, &ErrTensorTypeNotSupported{\n+\t\ttensotType: t.DataType(),\n+\t}\n+}\n+\n+// setCMemAsAlreadyRelease indicates that the C allocated memory was already\n+// released from C.\n+func (t *Tensor) setCMemAsAlreadyRelease() {\n+\tt.memReleased = true\n+}\n+\n+// FreeAllocMem releases the C allocated memory for this tensor.\n+func (t *Tensor) FreeAllocMem() {\n+\t// We can't clean the tensor here in case it had been  used as an\n+\t// input parameter, because in tensorflow/core/client/tensor_c_api.cc the\n+\t// function TF_Run_Helper cleans the input tensors after every\n+\t// execution. This can cause a double free or corruption error in C++\n+\t// since there is no way to determine if a tensor had been previously\n+\t// cleaned.\n+\tif !t.memReleased {\n+\t\tTF_DeleteTensor(t.tensor)\n+\t}\n+}\n+\n+// ErrInvalidTensorType the data type of the tensor is not compatible", "path": "tensorflow/contrib/go/tensor.go", "position": null, "original_position": 575, "commit_id": "942760424141d0f5a930982d5e78aaeb05869488", "original_commit_id": "562a1513b38aa29b222464ae19dd1ccbd0f48bfb", "user": {"login": "rakyll", "id": 108380, "node_id": "MDQ6VXNlcjEwODM4MA==", "avatar_url": "https://avatars0.githubusercontent.com/u/108380?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rakyll", "html_url": "https://github.com/rakyll", "followers_url": "https://api.github.com/users/rakyll/followers", "following_url": "https://api.github.com/users/rakyll/following{/other_user}", "gists_url": "https://api.github.com/users/rakyll/gists{/gist_id}", "starred_url": "https://api.github.com/users/rakyll/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rakyll/subscriptions", "organizations_url": "https://api.github.com/users/rakyll/orgs", "repos_url": "https://api.github.com/users/rakyll/repos", "events_url": "https://api.github.com/users/rakyll/events{/privacy}", "received_events_url": "https://api.github.com/users/rakyll/received_events", "type": "User", "site_admin": false}, "body": "ErrInvalidTensorType is returned when the data type of the tensor is not compatible...\n", "created_at": "2016-04-19T20:23:35Z", "updated_at": "2016-05-05T08:12:14Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/1771#discussion_r60304191", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/1771", "author_association": "NONE", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/60304191"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/1771#discussion_r60304191"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/1771"}}, "body_html": "<p>ErrInvalidTensorType is returned when the data type of the tensor is not compatible...</p>", "body_text": "ErrInvalidTensorType is returned when the data type of the tensor is not compatible..."}