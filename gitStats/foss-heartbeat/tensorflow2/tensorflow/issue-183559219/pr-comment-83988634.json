{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/83988634", "pull_request_review_id": 4794719, "id": 83988634, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDgzOTg4NjM0", "diff_hunk": "@@ -136,131 +226,262 @@ Status WindowsFileSystem::NewRandomAccessFile(\n     const string& fname, std::unique_ptr<RandomAccessFile>* result) {\n   string translated_fname = TranslateName(fname);\n   result->reset();\n-  Status s;\n-  FILE* f = fopen(translated_fname.c_str(), \"r\");\n-  if (f == NULL) {\n-    s = IOError(fname, errno);\n-  } else {\n-    result->reset(new WindowsRandomAccessFile(translated_fname, f));\n+\n+  // Open the file for read-only random access\n+  // Random access is to disable read-ahead as the system reads too much data\n+  // Open in async mode which makes Windows allow more parallelism even\n+  // if we need to do sync I/O on top of it.\n+  DWORD file_flags = FILE_ATTRIBUTE_READONLY | FILE_FLAG_RANDOM_ACCESS |\n+      FILE_FLAG_OVERLAPPED;\n+  // Shared access is necessary for tests to pass\n+  // almost all tests would work with a possible exception of fault_injection.\n+  DWORD share_mode = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;\n+\n+  HANDLE hfile = ::CreateFileA(translated_fname.c_str(), GENERIC_READ,\n+                               share_mode, NULL, OPEN_EXISTING, file_flags,\n+                               NULL);\n+\n+  if (INVALID_HANDLE_VALUE == hfile) {\n+    string context = \"NewRandomAccessFile failed to Create/Open: \" + fname;\n+    return IOErrorFromWindowsError(context, ::GetLastError());\n   }\n-  return s;\n+\n+  UniqueCloseHandlePtr file_guard(hfile, CloseHandleFunc);\n+  result->reset(new WindowsRandomAccessFile(translated_fname, hfile));\n+  file_guard.release();\n+\n+  return Status::OK();\n }\n \n Status WindowsFileSystem::NewWritableFile(\n     const string& fname, std::unique_ptr<WritableFile>* result) {\n   string translated_fname = TranslateName(fname);\n-  Status s;\n-  FILE* f = fopen(translated_fname.c_str(), \"w\");\n-  if (f == NULL) {\n-    result->reset();\n-    s = IOError(fname, errno);\n-  } else {\n-    result->reset(new WindowsWritableFile(translated_fname, f));\n+  result->reset();\n+\n+  DWORD share_mode = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;\n+  HANDLE hfile = ::CreateFileA(translated_fname.c_str(), GENERIC_WRITE,\n+                               share_mode, NULL, CREATE_ALWAYS,\n+                               FILE_ATTRIBUTE_NORMAL, NULL);\n+\n+  if (INVALID_HANDLE_VALUE == hfile) {\n+    string context = \"Failed to create a NewWriteableFile: \" + fname;\n+    return IOErrorFromWindowsError(context, ::GetLastError());\n   }\n-  return s;\n+\n+  UniqueCloseHandlePtr file_guard(hfile, CloseHandleFunc);\n+  result->reset(new WindowsWritableFile(translated_fname, hfile));\n+  file_guard.release();\n+\n+  return Status::OK();\n }\n \n Status WindowsFileSystem::NewAppendableFile(\n     const string& fname, std::unique_ptr<WritableFile>* result) {\n   string translated_fname = TranslateName(fname);\n-  Status s;\n-  FILE* f = fopen(translated_fname.c_str(), \"a\");\n-  if (f == NULL) {\n-    result->reset();\n-    s = IOError(fname, errno);\n-  } else {\n-    result->reset(new WindowsWritableFile(translated_fname, f));\n+  result->reset();\n+\n+  DWORD share_mode = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;\n+  HANDLE hfile = ::CreateFileA(translated_fname.c_str(), GENERIC_WRITE,\n+                               share_mode, NULL, OPEN_ALWAYS,\n+                               FILE_ATTRIBUTE_NORMAL, NULL);\n+\n+  if (INVALID_HANDLE_VALUE == hfile) {\n+    string context = \"Failed to create a NewAppendableFile: \" + fname;\n+    return IOErrorFromWindowsError(context, ::GetLastError());\n   }\n-  return s;\n+\n+  UniqueCloseHandlePtr file_guard(hfile, CloseHandleFunc);\n+\n+  DWORD file_ptr = ::SetFilePointer(hfile, NULL, NULL, FILE_END);\n+  if (INVALID_SET_FILE_POINTER == file_ptr) {\n+    string context = \"Failed to create a NewAppendableFile: \" + fname;\n+    return IOErrorFromWindowsError(context, ::GetLastError());\n+  }\n+\n+  result->reset(new WindowsWritableFile(translated_fname, hfile));\n+  file_guard.release();\n+\n+  return Status::OK();\n }\n \n Status WindowsFileSystem::NewReadOnlyMemoryRegionFromFile(\n     const string& fname, std::unique_ptr<ReadOnlyMemoryRegion>* result) {\n-  return errors::Unimplemented(\n-      \"WindowsFileSystem::NewReadOnlyMemoryRegionFromFile\");\n+  string translated_fname = TranslateName(fname);\n+  result->reset();\n+  Status s = Status::OK();\n+\n+  // Open the file for read-only random access\n+  DWORD file_flags = FILE_ATTRIBUTE_READONLY | FILE_FLAG_RANDOM_ACCESS;\n+\n+  // Open in async mode which makes Windows allow more parallelism even\n+  // if we need to do sync I/O on top of it.\n+  file_flags |= FILE_FLAG_OVERLAPPED;\n+\n+  DWORD share_mode = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;\n+  HANDLE hfile = ::CreateFileA(translated_fname.c_str(), GENERIC_READ,\n+                               share_mode, NULL, OPEN_EXISTING, file_flags,\n+                               NULL);\n+\n+  if (INVALID_HANDLE_VALUE == hfile) {\n+    return IOErrorFromWindowsError(\n+        \"NewReadOnlyMemoryRegionFromFile failed to Create/Open: \" + fname,\n+        ::GetLastError());\n+  }\n+\n+  UniqueCloseHandlePtr file_guard(hfile, CloseHandleFunc);\n+\n+  // Use mmap when virtual address-space is plentiful.\n+  uint64_t file_size;\n+  s = GetFileSize(translated_fname, &file_size);\n+  if (s.ok()) {\n+    // Will not map empty files\n+    if (file_size == 0) {\n+      return IOError(\n+          \"NewReadOnlyMemoryRegionFromFile failed to map empty file: \" + fname,\n+          EINVAL);\n+    }\n+\n+    HANDLE hmap = ::CreateFileMappingA(hfile, NULL, PAGE_READONLY,\n+                                       0,  // Whole file at its present length\n+                                       0,\n+                                       NULL);  // Mapping name\n+\n+    if (!hmap) {\n+      string context = \"Failed to create file mapping for \"\n+                       \"NewReadOnlyMemoryRegionFromFile: \" + fname;\n+      return IOErrorFromWindowsError(context, ::GetLastError());\n+    }\n+\n+    UniqueCloseHandlePtr map_guard(hmap, CloseHandleFunc);\n+\n+    const void* mapped_region = ::MapViewOfFileEx(\n+        hmap, FILE_MAP_READ,\n+        0,  // High DWORD of access start\n+        0,  // Low DWORD\n+        file_size,\n+        NULL);  // Let the OS choose the mapping\n+\n+    if (!mapped_region) {\n+      string context = \"Failed to MapViewOfFile for \"\n+                       \"NewReadOnlyMemoryRegionFromFile: \" + fname;\n+      return IOErrorFromWindowsError(context, ::GetLastError());\n+    }\n+\n+    result->reset(new WinReadOnlyMemoryRegion(fname, hfile, hmap,\n+                                              mapped_region, file_size));\n+\n+    map_guard.release();\n+    file_guard.release();\n+  }\n+\n+  return s;\n }\n \n bool WindowsFileSystem::FileExists(const string& fname) {\n-  return _access(TranslateName(fname).c_str(), 0) == 0;\n+  constexpr int kOk = 0;\n+  return _access(TranslateName(fname).c_str(), kOk) == 0;\n }\n \n Status WindowsFileSystem::GetChildren(const string& dir,\n                                       std::vector<string>* result) {\n   string translated_dir = TranslateName(dir);\n   result->clear();\n \n+  string pattern = translated_dir;\n+  if (!pattern.empty() && pattern.back() != '\\\\' && pattern.back() != '/') {\n+    pattern += '\\\\*';\n+  } else {\n+    pattern += '*';\n+  }\n+\n   WIN32_FIND_DATA find_data;\n-  HANDLE find_handle = FindFirstFile(translated_dir.c_str(), &find_data);\n+  HANDLE find_handle = ::FindFirstFileA(pattern.c_str(), &find_data);\n   if (find_handle == INVALID_HANDLE_VALUE) {\n-    // TODO(mrry): Convert to a more specific error.\n-    return errors::Unknown(\"Error code: \", GetLastError());\n-  }\n-  result->push_back(find_data.cFileName);\n-  while (FindNextFile(find_handle, &find_data)) {\n-    result->push_back(find_data.cFileName);\n+    string context = \"FindFirstFile failed for: \" + translated_dir;\n+    return IOErrorFromWindowsError(context, ::GetLastError());\n   }\n-  if (!FindClose(find_handle)) {\n-    // TODO(mrry): Convert to a more specific error.\n-    return errors::Unknown(\"Error closing find handle: \", GetLastError());\n+\n+  do {\n+    const StringPiece basename = find_data.cFileName;\n+    if (basename != \".\" && basename != \"..\") {\n+      result->push_back(find_data.cFileName);\n+    }\n+  } while (::FindNextFileA(find_handle, &find_data));\n+\n+  if (!::FindClose(find_handle)) {\n+    string context = \"FindClose failed for: \" + translated_dir;\n+    return IOErrorFromWindowsError(context, ::GetLastError());\n   }\n+\n   return Status::OK();\n }\n \n Status WindowsFileSystem::DeleteFile(const string& fname) {\n   Status result;\n   if (unlink(TranslateName(fname).c_str()) != 0) {\n-    result = IOError(fname, errno);\n+    result = IOError(\"Failed to delete a file: \" + fname, errno);\n   }\n   return result;\n }\n \n Status WindowsFileSystem::CreateDir(const string& name) {\n   Status result;\n   if (_mkdir(TranslateName(name).c_str()) != 0) {\n-    result = IOError(name, errno);\n+    result = IOError(\"Failed to create a directory: \" + name, errno);\n   }\n   return result;\n }\n \n Status WindowsFileSystem::DeleteDir(const string& name) {\n   Status result;\n   if (_rmdir(TranslateName(name).c_str()) != 0) {\n-    result = IOError(name, errno);\n+    result = IOError(\"Failed to remove a directory: \" + name, errno);\n   }\n   return result;\n }\n \n Status WindowsFileSystem::GetFileSize(const string& fname, uint64* size) {\n-  Status s;\n-  struct _stat sbuf;\n-  if (_stat(TranslateName(fname).c_str(), &sbuf) != 0) {\n-    *size = 0;\n-    s = IOError(fname, errno);\n-  } else {\n-    *size = sbuf.st_size;\n+  string translated_fname = TranslateName(fname);\n+  Status result;\n+  WIN32_FILE_ATTRIBUTE_DATA attrs;\n+  if (TRUE == ::GetFileAttributesExA(translated_fname.c_str(),\n+                                     GetFileExInfoStandard, &attrs)) {\n+    ULARGE_INTEGER file_size;\n+    file_size.HighPart = attrs.nFileSizeHigh;\n+    file_size.LowPart = attrs.nFileSizeLow;\n+    *size = file_size.QuadPart;\n   }\n-  return s;\n+  else {\n+    string context = \"Can not get size for: \" + fname;\n+    result = IOErrorFromWindowsError(context, ::GetLastError());\n+  }\n+  return result;\n }\n \n Status WindowsFileSystem::RenameFile(const string& src, const string& target) {\n   Status result;\n-  if (rename(TranslateName(src).c_str(), TranslateName(target).c_str()) != 0) {\n-    result = IOError(src, errno);\n+  // rename() is not capable of replacing the existing file as on Linux\n+  // so use OS API directly\n+  if (!::MoveFileExA(TranslateName(src).c_str(), TranslateName(target).c_str(),\n+      MOVEFILE_REPLACE_EXISTING)) {\n+    string context(\"Failed to rename: \");\n+    context.append(src).append(\" to: \").append(target);", "path": "tensorflow/core/platform/windows/windows_file_system.cc", "position": null, "original_position": 506, "commit_id": "5cc57a8bef2efbda5c1dc6e596188d05afcacf25", "original_commit_id": "43c6d1a2377ed7a58a8e19d64b32f0de64aebec8", "user": {"login": "mrry", "id": 192142, "node_id": "MDQ6VXNlcjE5MjE0Mg==", "avatar_url": "https://avatars1.githubusercontent.com/u/192142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mrry", "html_url": "https://github.com/mrry", "followers_url": "https://api.github.com/users/mrry/followers", "following_url": "https://api.github.com/users/mrry/following{/other_user}", "gists_url": "https://api.github.com/users/mrry/gists{/gist_id}", "starred_url": "https://api.github.com/users/mrry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mrry/subscriptions", "organizations_url": "https://api.github.com/users/mrry/orgs", "repos_url": "https://api.github.com/users/mrry/repos", "events_url": "https://api.github.com/users/mrry/events{/privacy}", "received_events_url": "https://api.github.com/users/mrry/received_events", "type": "User", "site_admin": false}, "body": "Prefer `strings::StrCat()` here, e.g.:\n\n``` c++\nstring context(strings::StrCat(\"Failed to rename: \", src, \" to: \", target));\n```\n", "created_at": "2016-10-19T02:35:40Z", "updated_at": "2016-10-19T23:43:56Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/5020#discussion_r83988634", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/5020", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/83988634"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/5020#discussion_r83988634"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/5020"}}, "body_html": "<p>Prefer <code>strings::StrCat()</code> here, e.g.:</p>\n<div class=\"highlight highlight-source-c++\"><pre>string <span class=\"pl-en\">context</span>(strings::StrCat(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Failed to rename: <span class=\"pl-pds\">\"</span></span>, src, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span> to: <span class=\"pl-pds\">\"</span></span>, target));</pre></div>", "body_text": "Prefer strings::StrCat() here, e.g.:\nstring context(strings::StrCat(\"Failed to rename: \", src, \" to: \", target));"}