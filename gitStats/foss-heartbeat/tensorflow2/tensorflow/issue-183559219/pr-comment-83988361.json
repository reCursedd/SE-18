{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/83988361", "pull_request_review_id": 4794719, "id": 83988361, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDgzOTg4MzYx", "diff_hunk": "@@ -136,131 +226,262 @@ Status WindowsFileSystem::NewRandomAccessFile(\n     const string& fname, std::unique_ptr<RandomAccessFile>* result) {\n   string translated_fname = TranslateName(fname);\n   result->reset();\n-  Status s;\n-  FILE* f = fopen(translated_fname.c_str(), \"r\");\n-  if (f == NULL) {\n-    s = IOError(fname, errno);\n-  } else {\n-    result->reset(new WindowsRandomAccessFile(translated_fname, f));\n+\n+  // Open the file for read-only random access\n+  // Random access is to disable read-ahead as the system reads too much data\n+  // Open in async mode which makes Windows allow more parallelism even\n+  // if we need to do sync I/O on top of it.\n+  DWORD file_flags = FILE_ATTRIBUTE_READONLY | FILE_FLAG_RANDOM_ACCESS |\n+      FILE_FLAG_OVERLAPPED;\n+  // Shared access is necessary for tests to pass\n+  // almost all tests would work with a possible exception of fault_injection.\n+  DWORD share_mode = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;\n+\n+  HANDLE hfile = ::CreateFileA(translated_fname.c_str(), GENERIC_READ,\n+                               share_mode, NULL, OPEN_EXISTING, file_flags,\n+                               NULL);\n+\n+  if (INVALID_HANDLE_VALUE == hfile) {\n+    string context = \"NewRandomAccessFile failed to Create/Open: \" + fname;\n+    return IOErrorFromWindowsError(context, ::GetLastError());\n   }\n-  return s;\n+\n+  UniqueCloseHandlePtr file_guard(hfile, CloseHandleFunc);\n+  result->reset(new WindowsRandomAccessFile(translated_fname, hfile));\n+  file_guard.release();\n+\n+  return Status::OK();\n }\n \n Status WindowsFileSystem::NewWritableFile(\n     const string& fname, std::unique_ptr<WritableFile>* result) {\n   string translated_fname = TranslateName(fname);\n-  Status s;\n-  FILE* f = fopen(translated_fname.c_str(), \"w\");\n-  if (f == NULL) {\n-    result->reset();\n-    s = IOError(fname, errno);\n-  } else {\n-    result->reset(new WindowsWritableFile(translated_fname, f));\n+  result->reset();\n+\n+  DWORD share_mode = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;\n+  HANDLE hfile = ::CreateFileA(translated_fname.c_str(), GENERIC_WRITE,\n+                               share_mode, NULL, CREATE_ALWAYS,\n+                               FILE_ATTRIBUTE_NORMAL, NULL);\n+\n+  if (INVALID_HANDLE_VALUE == hfile) {\n+    string context = \"Failed to create a NewWriteableFile: \" + fname;\n+    return IOErrorFromWindowsError(context, ::GetLastError());\n   }\n-  return s;\n+\n+  UniqueCloseHandlePtr file_guard(hfile, CloseHandleFunc);", "path": "tensorflow/core/platform/windows/windows_file_system.cc", "position": 300, "original_position": 275, "commit_id": "5cc57a8bef2efbda5c1dc6e596188d05afcacf25", "original_commit_id": "43c6d1a2377ed7a58a8e19d64b32f0de64aebec8", "user": {"login": "mrry", "id": 192142, "node_id": "MDQ6VXNlcjE5MjE0Mg==", "avatar_url": "https://avatars1.githubusercontent.com/u/192142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mrry", "html_url": "https://github.com/mrry", "followers_url": "https://api.github.com/users/mrry/followers", "following_url": "https://api.github.com/users/mrry/following{/other_user}", "gists_url": "https://api.github.com/users/mrry/gists{/gist_id}", "starred_url": "https://api.github.com/users/mrry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mrry/subscriptions", "organizations_url": "https://api.github.com/users/mrry/orgs", "repos_url": "https://api.github.com/users/mrry/repos", "events_url": "https://api.github.com/users/mrry/events{/privacy}", "received_events_url": "https://api.github.com/users/mrry/received_events", "type": "User", "site_admin": false}, "body": "Does the `UniqueCloseHandlePtr` serve a purpose here? (I would expect it to be used when there is the possibility of returning early, due to an error, but it looks like L272 can't fail, so we are just creating and destroying the guard for no purpose. Perhaps I'm missing something.)\n", "created_at": "2016-10-19T02:31:38Z", "updated_at": "2016-10-19T23:43:56Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/5020#discussion_r83988361", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/5020", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/83988361"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/5020#discussion_r83988361"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/5020"}}, "body_html": "<p>Does the <code>UniqueCloseHandlePtr</code> serve a purpose here? (I would expect it to be used when there is the possibility of returning early, due to an error, but it looks like L272 can't fail, so we are just creating and destroying the guard for no purpose. Perhaps I'm missing something.)</p>", "body_text": "Does the UniqueCloseHandlePtr serve a purpose here? (I would expect it to be used when there is the possibility of returning early, due to an error, but it looks like L272 can't fail, so we are just creating and destroying the guard for no purpose. Perhaps I'm missing something.)"}