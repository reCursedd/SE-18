{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/225399126", "html_url": "https://github.com/tensorflow/tensorflow/issues/2237#issuecomment-225399126", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2237", "id": 225399126, "node_id": "MDEyOklzc3VlQ29tbWVudDIyNTM5OTEyNg==", "user": {"login": "ibab", "id": 890531, "node_id": "MDQ6VXNlcjg5MDUzMQ==", "avatar_url": "https://avatars1.githubusercontent.com/u/890531?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibab", "html_url": "https://github.com/ibab", "followers_url": "https://api.github.com/users/ibab/followers", "following_url": "https://api.github.com/users/ibab/following{/other_user}", "gists_url": "https://api.github.com/users/ibab/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibab/subscriptions", "organizations_url": "https://api.github.com/users/ibab/orgs", "repos_url": "https://api.github.com/users/ibab/repos", "events_url": "https://api.github.com/users/ibab/events{/privacy}", "received_events_url": "https://api.github.com/users/ibab/received_events", "type": "User", "site_admin": false}, "created_at": "2016-06-11T22:59:17Z", "updated_at": "2016-06-11T22:59:17Z", "author_association": "CONTRIBUTOR", "body_html": "<p>I think the hardest part about this is coming up with a nice way of storing tree-shaped entries and passing them to Tensorflow ops.<br>\nThen a monolithic tensorflow op could provide endpoints for a tensor computation, which allows the user to define the network that will be replicated at each node of the tree.<br>\nThe API could be something like this:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">def</span> <span class=\"pl-en\">network</span>(<span class=\"pl-smi\">x</span>, <span class=\"pl-smi\">y</span>):\n  <span class=\"pl-c\"><span class=\"pl-c\">#</span> Define transformation</span>\n  <span class=\"pl-k\">return</span> z\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> Evaluation</span>\ntf.recursive_eval(network, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>tree_data_input<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>tree_data_output<span class=\"pl-pds\">\"</span></span>)\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> Training</span>\nloss <span class=\"pl-k\">=</span> tf.recursive_loss(network, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>tree_data_input<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>tree_data_reference<span class=\"pl-pds\">\"</span></span>)</pre></div>", "body_text": "I think the hardest part about this is coming up with a nice way of storing tree-shaped entries and passing them to Tensorflow ops.\nThen a monolithic tensorflow op could provide endpoints for a tensor computation, which allows the user to define the network that will be replicated at each node of the tree.\nThe API could be something like this:\ndef network(x, y):\n  # Define transformation\n  return z\n\n# Evaluation\ntf.recursive_eval(network, \"tree_data_input\", \"tree_data_output\")\n# Training\nloss = tf.recursive_loss(network, \"tree_data_input\", \"tree_data_reference\")", "body": "I think the hardest part about this is coming up with a nice way of storing tree-shaped entries and passing them to Tensorflow ops.\nThen a monolithic tensorflow op could provide endpoints for a tensor computation, which allows the user to define the network that will be replicated at each node of the tree.\nThe API could be something like this:\n\n``` python\ndef network(x, y):\n  # Define transformation\n  return z\n\n# Evaluation\ntf.recursive_eval(network, \"tree_data_input\", \"tree_data_output\")\n# Training\nloss = tf.recursive_loss(network, \"tree_data_input\", \"tree_data_reference\")\n```\n"}