{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/233439285", "html_url": "https://github.com/tensorflow/tensorflow/issues/2237#issuecomment-233439285", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2237", "id": 233439285, "node_id": "MDEyOklzc3VlQ29tbWVudDIzMzQzOTI4NQ==", "user": {"login": "lukasr0", "id": 20520526, "node_id": "MDQ6VXNlcjIwNTIwNTI2", "avatar_url": "https://avatars1.githubusercontent.com/u/20520526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lukasr0", "html_url": "https://github.com/lukasr0", "followers_url": "https://api.github.com/users/lukasr0/followers", "following_url": "https://api.github.com/users/lukasr0/following{/other_user}", "gists_url": "https://api.github.com/users/lukasr0/gists{/gist_id}", "starred_url": "https://api.github.com/users/lukasr0/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lukasr0/subscriptions", "organizations_url": "https://api.github.com/users/lukasr0/orgs", "repos_url": "https://api.github.com/users/lukasr0/repos", "events_url": "https://api.github.com/users/lukasr0/events{/privacy}", "received_events_url": "https://api.github.com/users/lukasr0/received_events", "type": "User", "site_admin": false}, "created_at": "2016-07-18T19:54:26Z", "updated_at": "2016-07-18T19:54:26Z", "author_association": "NONE", "body_html": "<p>I've been working with tree-structured examples on tensorflow using Control Flow ops.  While I haven't implemented the Socher et al. 2011 paper, I use the indexing structure to represent edges between nodes.  Something like:</p>\n<pre><code>  state = ta.TensorArray( tf.float32, size=1, dynamic_size=True, infer_shape=False, clear_after_read=False)\n\n  # A super-simple tree:\n  #       1   2   3\n  #        \\   \\ /\n  #         \\   -\n  #          \\ /\n  #           -\n  node_features = [1.0, 2, 3]\n  state = state.unpack(node_features)\n  edges = [[1, 2, 3], [0, 3, 4]]\n\n  def body(pos, state):\n    edge = tf.gather(edges, pos)\n    left_idx, right_idx, out_idx = tf.unpack(edge)\n    # In the real-world we'd do something more useful that just tf.sub...\n    out_state = tf.sub(state.read(left_idx), state.read(right_idx))\n    return pos + 1, state.write(out_idx, out_state)\n\n  def cond(pos, _):\n    return tf.less(pos, len(edges))\n\n  _, res = tf.while_loop(cond, body, [tf.constant(0), state])\n  with tf.Session():\n    print(res.pack().eval())\n</code></pre>\n<p>In order to generalize this type of processing and make it scale there is work in progress exploring support for things like:</p>\n<ul>\n<li>efficient batching - processing more than one edge at a time;</li>\n<li>parsing structured examples into edge and vertex tensors (kind of like tf.parse_example where one specifies in what order to traverse the tree etc.); and,</li>\n<li>higher-level ops for traversing/backpropagating structured examples.  (This might well include something in the direction of what <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=890531\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/ibab\">@ibab</a> mentioned with a TensorTree.)</li>\n</ul>", "body_text": "I've been working with tree-structured examples on tensorflow using Control Flow ops.  While I haven't implemented the Socher et al. 2011 paper, I use the indexing structure to represent edges between nodes.  Something like:\n  state = ta.TensorArray( tf.float32, size=1, dynamic_size=True, infer_shape=False, clear_after_read=False)\n\n  # A super-simple tree:\n  #       1   2   3\n  #        \\   \\ /\n  #         \\   -\n  #          \\ /\n  #           -\n  node_features = [1.0, 2, 3]\n  state = state.unpack(node_features)\n  edges = [[1, 2, 3], [0, 3, 4]]\n\n  def body(pos, state):\n    edge = tf.gather(edges, pos)\n    left_idx, right_idx, out_idx = tf.unpack(edge)\n    # In the real-world we'd do something more useful that just tf.sub...\n    out_state = tf.sub(state.read(left_idx), state.read(right_idx))\n    return pos + 1, state.write(out_idx, out_state)\n\n  def cond(pos, _):\n    return tf.less(pos, len(edges))\n\n  _, res = tf.while_loop(cond, body, [tf.constant(0), state])\n  with tf.Session():\n    print(res.pack().eval())\n\nIn order to generalize this type of processing and make it scale there is work in progress exploring support for things like:\n\nefficient batching - processing more than one edge at a time;\nparsing structured examples into edge and vertex tensors (kind of like tf.parse_example where one specifies in what order to traverse the tree etc.); and,\nhigher-level ops for traversing/backpropagating structured examples.  (This might well include something in the direction of what @ibab mentioned with a TensorTree.)", "body": "I've been working with tree-structured examples on tensorflow using Control Flow ops.  While I haven't implemented the Socher et al. 2011 paper, I use the indexing structure to represent edges between nodes.  Something like:\n\n```\n  state = ta.TensorArray( tf.float32, size=1, dynamic_size=True, infer_shape=False, clear_after_read=False)\n\n  # A super-simple tree:\n  #       1   2   3\n  #        \\   \\ /\n  #         \\   -\n  #          \\ /\n  #           -\n  node_features = [1.0, 2, 3]\n  state = state.unpack(node_features)\n  edges = [[1, 2, 3], [0, 3, 4]]\n\n  def body(pos, state):\n    edge = tf.gather(edges, pos)\n    left_idx, right_idx, out_idx = tf.unpack(edge)\n    # In the real-world we'd do something more useful that just tf.sub...\n    out_state = tf.sub(state.read(left_idx), state.read(right_idx))\n    return pos + 1, state.write(out_idx, out_state)\n\n  def cond(pos, _):\n    return tf.less(pos, len(edges))\n\n  _, res = tf.while_loop(cond, body, [tf.constant(0), state])\n  with tf.Session():\n    print(res.pack().eval())\n```\n\nIn order to generalize this type of processing and make it scale there is work in progress exploring support for things like:\n- efficient batching - processing more than one edge at a time;\n- parsing structured examples into edge and vertex tensors (kind of like tf.parse_example where one specifies in what order to traverse the tree etc.); and, \n- higher-level ops for traversing/backpropagating structured examples.  (This might well include something in the direction of what @ibab mentioned with a TensorTree.)\n"}