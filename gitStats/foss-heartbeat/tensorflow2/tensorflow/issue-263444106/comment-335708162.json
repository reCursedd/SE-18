{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/335708162", "html_url": "https://github.com/tensorflow/tensorflow/issues/13522#issuecomment-335708162", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13522", "id": 335708162, "node_id": "MDEyOklzc3VlQ29tbWVudDMzNTcwODE2Mg==", "user": {"login": "asimshankar", "id": 16018, "node_id": "MDQ6VXNlcjE2MDE4", "avatar_url": "https://avatars2.githubusercontent.com/u/16018?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asimshankar", "html_url": "https://github.com/asimshankar", "followers_url": "https://api.github.com/users/asimshankar/followers", "following_url": "https://api.github.com/users/asimshankar/following{/other_user}", "gists_url": "https://api.github.com/users/asimshankar/gists{/gist_id}", "starred_url": "https://api.github.com/users/asimshankar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asimshankar/subscriptions", "organizations_url": "https://api.github.com/users/asimshankar/orgs", "repos_url": "https://api.github.com/users/asimshankar/repos", "events_url": "https://api.github.com/users/asimshankar/events{/privacy}", "received_events_url": "https://api.github.com/users/asimshankar/received_events", "type": "User", "site_admin": false}, "created_at": "2017-10-11T07:18:18Z", "updated_at": "2017-10-11T07:18:18Z", "author_association": "MEMBER", "body_html": "<p>@VladimirRoaming : Can you reduce the problem to linking of a C++ binary? From what you've shared, it's hard for us to comment since there are many layers (including swift code which we're not familiar with) to wade through.</p>\n<p>That said, I think <a href=\"https://github.com/tensorflow/tensorflow/commit/5c7f9e316d8c7735308a217310350d416d7498cc\">the change to split the TensorFlow shared libraries</a> into <code>libtensorflow_framework.so</code> + language API (e.g., <code>libtensorflow.so</code> for C, <code>libtensorflow_cc.so</code> for C++, <code>pywrap_tensorflow.so</code> for Python) is the one that is probably causing you trouble. As a result of this change, most of the framework symbols are in <code>libtensorflow_framework.so</code> now. And from the error messages above, it seems that the linker was having trouble finding <code>tensorflow::Event::Event()</code>, which will be in that library.</p>\n<p>The fix should be simple enough, include <code>-ltensorflow_framework.so</code> in your command-line.<br>\n(This change <a href=\"https://github.com/tensorflow/tensorflow/commit/5c7f9e316d8c7735308a217310350d416d7498cc#diff-4bef2b6f872037e4e6daaf3b93c6f253\">is mentioned in the updated documentation</a>, however the documentation on tensorflow.org is tied to the latest stable release, not the master branch at github).</p>\n<p>As an example, I did the following on Linux which seems to work out well:</p>\n<div class=\"highlight highlight-source-shell\"><pre><span class=\"pl-c\"><span class=\"pl-c\">#</span> Build the C++ library from source</span>\nbazel build -c opt //tensorflow:libtensorflow_cc.so\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> Create the test program</span>\ncat <span class=\"pl-k\">&gt;</span>/tmp/test.cc <span class=\"pl-s\"><span class=\"pl-k\">&lt;&lt;</span><span class=\"pl-k\">EOF</span></span>\n<span class=\"pl-s\">#include \"tensorflow/core/framework/graph.pb.h\"</span>\n<span class=\"pl-s\">#include \"tensorflow/core/util/events_writer.h\"</span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">int main() {</span>\n<span class=\"pl-s\">  tensorflow::EventsWriter writer(\"/tmp/events\");</span>\n<span class=\"pl-s\">  writer.WriteEvent(tensorflow::Event());</span>\n<span class=\"pl-s\">  writer.Close();</span>\n<span class=\"pl-s\">}</span>\n<span class=\"pl-s\"><span class=\"pl-k\">EOF</span></span>\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> Build the test program</span>\nEXTERNAL_DIR=<span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"pl-s\"><span class=\"pl-pds\">$(</span>bazel info output_base<span class=\"pl-pds\">)</span></span>/external<span class=\"pl-pds\">\"</span></span>\ng++ /tmp/test.cc \\\n -std=c++11 \\\n -I. -Ibazel-genfiles \\\n -I <span class=\"pl-smi\">${EXTERNAL_DIR}</span>/protobuf_archive/src \\\n -I <span class=\"pl-smi\">${EXTERNAL_DIR}</span>/nsync/public \\\n -Lbazel-bin/tensorflow -ltensorflow_cc -ltensorflow_framework\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> Run the test program</span>\nLD_LIBRARY_PATH=bazel-bin/tensorflow ./a.out</pre></div>\n<p>As for the questions Todd mentioned above:</p>\n<ol>\n<li>\n<p><code>libtensorflow_cc.so</code> is a strict superset of <code>libtensorflow.so</code> so you shouldn't have to link against both in the same binary. Though, this may change in the future.</p>\n</li>\n<li>\n<p>For now, yes, <code>libtensorflow_cc.so</code> exports all the symbols defined in the C API. Though, this may change in the future.</p>\n</li>\n<li>\n<p>If the analysis above is correct, this issue is not specific to macOS or Linux - in both you'll have to include <code>libtensorflow_framework.so</code> when linking/running, or build with <code>--config=monolithic</code>.</p>\n</li>\n</ol>", "body_text": "@VladimirRoaming : Can you reduce the problem to linking of a C++ binary? From what you've shared, it's hard for us to comment since there are many layers (including swift code which we're not familiar with) to wade through.\nThat said, I think the change to split the TensorFlow shared libraries into libtensorflow_framework.so + language API (e.g., libtensorflow.so for C, libtensorflow_cc.so for C++, pywrap_tensorflow.so for Python) is the one that is probably causing you trouble. As a result of this change, most of the framework symbols are in libtensorflow_framework.so now. And from the error messages above, it seems that the linker was having trouble finding tensorflow::Event::Event(), which will be in that library.\nThe fix should be simple enough, include -ltensorflow_framework.so in your command-line.\n(This change is mentioned in the updated documentation, however the documentation on tensorflow.org is tied to the latest stable release, not the master branch at github).\nAs an example, I did the following on Linux which seems to work out well:\n# Build the C++ library from source\nbazel build -c opt //tensorflow:libtensorflow_cc.so\n\n# Create the test program\ncat >/tmp/test.cc <<EOF\n#include \"tensorflow/core/framework/graph.pb.h\"\n#include \"tensorflow/core/util/events_writer.h\"\n\nint main() {\n  tensorflow::EventsWriter writer(\"/tmp/events\");\n  writer.WriteEvent(tensorflow::Event());\n  writer.Close();\n}\nEOF\n\n# Build the test program\nEXTERNAL_DIR=\"$(bazel info output_base)/external\"\ng++ /tmp/test.cc \\\n -std=c++11 \\\n -I. -Ibazel-genfiles \\\n -I ${EXTERNAL_DIR}/protobuf_archive/src \\\n -I ${EXTERNAL_DIR}/nsync/public \\\n -Lbazel-bin/tensorflow -ltensorflow_cc -ltensorflow_framework\n\n# Run the test program\nLD_LIBRARY_PATH=bazel-bin/tensorflow ./a.out\nAs for the questions Todd mentioned above:\n\n\nlibtensorflow_cc.so is a strict superset of libtensorflow.so so you shouldn't have to link against both in the same binary. Though, this may change in the future.\n\n\nFor now, yes, libtensorflow_cc.so exports all the symbols defined in the C API. Though, this may change in the future.\n\n\nIf the analysis above is correct, this issue is not specific to macOS or Linux - in both you'll have to include libtensorflow_framework.so when linking/running, or build with --config=monolithic.", "body": "@VladimirRoaming : Can you reduce the problem to linking of a C++ binary? From what you've shared, it's hard for us to comment since there are many layers (including swift code which we're not familiar with) to wade through. \r\n\r\nThat said, I think [the change to split the TensorFlow shared libraries](https://github.com/tensorflow/tensorflow/commit/5c7f9e316d8c7735308a217310350d416d7498cc) into `libtensorflow_framework.so` + language API (e.g., `libtensorflow.so` for C, `libtensorflow_cc.so` for C++, `pywrap_tensorflow.so` for Python) is the one that is probably causing you trouble. As a result of this change, most of the framework symbols are in `libtensorflow_framework.so` now. And from the error messages above, it seems that the linker was having trouble finding `tensorflow::Event::Event()`, which will be in that library.\r\n\r\nThe fix should be simple enough, include `-ltensorflow_framework.so` in your command-line.\r\n(This change [is mentioned in the updated documentation](https://github.com/tensorflow/tensorflow/commit/5c7f9e316d8c7735308a217310350d416d7498cc#diff-4bef2b6f872037e4e6daaf3b93c6f253), however the documentation on tensorflow.org is tied to the latest stable release, not the master branch at github).\r\n\r\n\r\nAs an example, I did the following on Linux which seems to work out well:\r\n\r\n```sh\r\n# Build the C++ library from source\r\nbazel build -c opt //tensorflow:libtensorflow_cc.so\r\n\r\n# Create the test program\r\ncat >/tmp/test.cc <<EOF\r\n#include \"tensorflow/core/framework/graph.pb.h\"\r\n#include \"tensorflow/core/util/events_writer.h\"\r\n\r\nint main() {\r\n  tensorflow::EventsWriter writer(\"/tmp/events\");\r\n  writer.WriteEvent(tensorflow::Event());\r\n  writer.Close();\r\n}\r\nEOF\r\n\r\n# Build the test program\r\nEXTERNAL_DIR=\"$(bazel info output_base)/external\"\r\ng++ /tmp/test.cc \\\r\n -std=c++11 \\\r\n -I. -Ibazel-genfiles \\\r\n -I ${EXTERNAL_DIR}/protobuf_archive/src \\\r\n -I ${EXTERNAL_DIR}/nsync/public \\\r\n -Lbazel-bin/tensorflow -ltensorflow_cc -ltensorflow_framework\r\n\r\n# Run the test program\r\nLD_LIBRARY_PATH=bazel-bin/tensorflow ./a.out\r\n```\r\nAs for the questions Todd mentioned above:\r\n\r\n1. `libtensorflow_cc.so` is a strict superset of `libtensorflow.so` so you shouldn't have to link against both in the same binary. Though, this may change in the future.\r\n\r\n2. For now, yes, `libtensorflow_cc.so` exports all the symbols defined in the C API. Though, this may change in the future.\r\n\r\n3. If the analysis above is correct, this issue is not specific to macOS or Linux - in both you'll have to include `libtensorflow_framework.so` when linking/running, or build with `--config=monolithic`.\r\n\r\n"}