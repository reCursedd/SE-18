{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/386401703", "html_url": "https://github.com/tensorflow/tensorflow/issues/18711#issuecomment-386401703", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/18711", "id": 386401703, "node_id": "MDEyOklzc3VlQ29tbWVudDM4NjQwMTcwMw==", "user": {"login": "alexlee-gk", "id": 839426, "node_id": "MDQ6VXNlcjgzOTQyNg==", "avatar_url": "https://avatars1.githubusercontent.com/u/839426?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexlee-gk", "html_url": "https://github.com/alexlee-gk", "followers_url": "https://api.github.com/users/alexlee-gk/followers", "following_url": "https://api.github.com/users/alexlee-gk/following{/other_user}", "gists_url": "https://api.github.com/users/alexlee-gk/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexlee-gk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexlee-gk/subscriptions", "organizations_url": "https://api.github.com/users/alexlee-gk/orgs", "repos_url": "https://api.github.com/users/alexlee-gk/repos", "events_url": "https://api.github.com/users/alexlee-gk/events{/privacy}", "received_events_url": "https://api.github.com/users/alexlee-gk/received_events", "type": "User", "site_admin": false}, "created_at": "2018-05-03T18:59:18Z", "updated_at": "2018-05-03T18:59:18Z", "author_association": "NONE", "body_html": "<p>Just to be clear, tf.nn.conv2d_transpose with stride 2 is as efficient as it can get and it shouldn't be slow. (If it is, you might have really big tensors, and then the problem is not an implementation one but a choice of your architecture.) The downside of strided conv2d_transpose is the checkerboard artifacts (and not its running time). What [1] suggests is to replace every conv2d_transpose layer with a resize_images layer + conv2d layer. The resize_images layer should upsample by a factor equal to the original stride (i.e. 2) and the conv2d layer should have stride 1. However, naively replacing every conv2d_transpose with resize_images + conv2d would slow things down even more.</p>", "body_text": "Just to be clear, tf.nn.conv2d_transpose with stride 2 is as efficient as it can get and it shouldn't be slow. (If it is, you might have really big tensors, and then the problem is not an implementation one but a choice of your architecture.) The downside of strided conv2d_transpose is the checkerboard artifacts (and not its running time). What [1] suggests is to replace every conv2d_transpose layer with a resize_images layer + conv2d layer. The resize_images layer should upsample by a factor equal to the original stride (i.e. 2) and the conv2d layer should have stride 1. However, naively replacing every conv2d_transpose with resize_images + conv2d would slow things down even more.", "body": "Just to be clear, tf.nn.conv2d_transpose with stride 2 is as efficient as it can get and it shouldn't be slow. (If it is, you might have really big tensors, and then the problem is not an implementation one but a choice of your architecture.) The downside of strided conv2d_transpose is the checkerboard artifacts (and not its running time). What [1] suggests is to replace every conv2d_transpose layer with a resize_images layer + conv2d layer. The resize_images layer should upsample by a factor equal to the original stride (i.e. 2) and the conv2d layer should have stride 1. However, naively replacing every conv2d_transpose with resize_images + conv2d would slow things down even more."}