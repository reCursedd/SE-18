{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/342341358", "html_url": "https://github.com/tensorflow/tensorflow/issues/12937#issuecomment-342341358", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/12937", "id": 342341358, "node_id": "MDEyOklzc3VlQ29tbWVudDM0MjM0MTM1OA==", "user": {"login": "georgh", "id": 1831252, "node_id": "MDQ6VXNlcjE4MzEyNTI=", "avatar_url": "https://avatars2.githubusercontent.com/u/1831252?v=4", "gravatar_id": "", "url": "https://api.github.com/users/georgh", "html_url": "https://github.com/georgh", "followers_url": "https://api.github.com/users/georgh/followers", "following_url": "https://api.github.com/users/georgh/following{/other_user}", "gists_url": "https://api.github.com/users/georgh/gists{/gist_id}", "starred_url": "https://api.github.com/users/georgh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/georgh/subscriptions", "organizations_url": "https://api.github.com/users/georgh/orgs", "repos_url": "https://api.github.com/users/georgh/repos", "events_url": "https://api.github.com/users/georgh/events{/privacy}", "received_events_url": "https://api.github.com/users/georgh/received_events", "type": "User", "site_admin": false}, "created_at": "2017-11-07T01:05:54Z", "updated_at": "2017-11-07T01:07:18Z", "author_association": "NONE", "body_html": "<p>Ok now I got what you are suggesting.<br>\nThe following does <strong>not</strong> work:</p>\n<pre><code> def body(ic):\n     updateKernel = calEntry(KernelVariable, ic)\n     return ic + 1\n</code></pre>\n<p>This will never execute calEntry.</p>\n<p>But if you use</p>\n<pre><code>i = tf.constant(0)\nm0 = tf.constant(0)\ncondition = lambda i, m: tf.less(i, N)\ndef body(ic, dontcare):\n     updateKernel = calEntry(KernelVariable, ic)\n     return ic + 1, updateKernel\nreturn tf.while_loop(condition, body, [i,m0], back_prop=False, parallel_iterations=parallelNum)\n</code></pre>\n<p>It works and is as fast as using map or foldl, foldr<br>\nThank you a lot for your help, even though it does not change much because now my code already uses map and fold everywhere.</p>\n<p>You can still gain some speed if you use</p>\n<pre><code>            for ic in range(0, N, parallelNum):\n                  with tf.control_dependencies(ops):\n                        for j in range(parallelNum):\n                              if ic + j &lt; N:\n                                    ops += [calEntry(KernelVariable, ic+j)]\n</code></pre>\n<p>but this may result in a very slow graph creation.<br>\n<a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=88808\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/skye\">@skye</a> is there any plan to add a parallel while_loop with lesser overhead?</p>", "body_text": "Ok now I got what you are suggesting.\nThe following does not work:\n def body(ic):\n     updateKernel = calEntry(KernelVariable, ic)\n     return ic + 1\n\nThis will never execute calEntry.\nBut if you use\ni = tf.constant(0)\nm0 = tf.constant(0)\ncondition = lambda i, m: tf.less(i, N)\ndef body(ic, dontcare):\n     updateKernel = calEntry(KernelVariable, ic)\n     return ic + 1, updateKernel\nreturn tf.while_loop(condition, body, [i,m0], back_prop=False, parallel_iterations=parallelNum)\n\nIt works and is as fast as using map or foldl, foldr\nThank you a lot for your help, even though it does not change much because now my code already uses map and fold everywhere.\nYou can still gain some speed if you use\n            for ic in range(0, N, parallelNum):\n                  with tf.control_dependencies(ops):\n                        for j in range(parallelNum):\n                              if ic + j < N:\n                                    ops += [calEntry(KernelVariable, ic+j)]\n\nbut this may result in a very slow graph creation.\n@skye is there any plan to add a parallel while_loop with lesser overhead?", "body": "Ok now I got what you are suggesting. \r\nThe following does **not** work:\r\n```\r\n def body(ic):\r\n     updateKernel = calEntry(KernelVariable, ic)\r\n     return ic + 1\r\n```\r\nThis will never execute calEntry.\r\n\r\nBut if you use \r\n```\r\ni = tf.constant(0)\r\nm0 = tf.constant(0)\r\ncondition = lambda i, m: tf.less(i, N)\r\ndef body(ic, dontcare):\r\n     updateKernel = calEntry(KernelVariable, ic)\r\n     return ic + 1, updateKernel\r\nreturn tf.while_loop(condition, body, [i,m0], back_prop=False, parallel_iterations=parallelNum)\r\n```\r\nIt works and is as fast as using map or foldl, foldr\r\nThank you a lot for your help, even though it does not change much because now my code already uses map and fold everywhere. \r\n\r\nYou can still gain some speed if you use \r\n```\r\n            for ic in range(0, N, parallelNum):\r\n                  with tf.control_dependencies(ops):\r\n                        for j in range(parallelNum):\r\n                              if ic + j < N:\r\n                                    ops += [calEntry(KernelVariable, ic+j)]\r\n```\r\nbut this may result in a very slow graph creation. \r\n@skye is there any plan to add a parallel while_loop with lesser overhead?  \r\n\r\n\r\n\r\n\r\n"}