{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/315919517", "html_url": "https://github.com/tensorflow/tensorflow/issues/11195#issuecomment-315919517", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11195", "id": 315919517, "node_id": "MDEyOklzc3VlQ29tbWVudDMxNTkxOTUxNw==", "user": {"login": "vrv", "id": 463737, "node_id": "MDQ6VXNlcjQ2MzczNw==", "avatar_url": "https://avatars0.githubusercontent.com/u/463737?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vrv", "html_url": "https://github.com/vrv", "followers_url": "https://api.github.com/users/vrv/followers", "following_url": "https://api.github.com/users/vrv/following{/other_user}", "gists_url": "https://api.github.com/users/vrv/gists{/gist_id}", "starred_url": "https://api.github.com/users/vrv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vrv/subscriptions", "organizations_url": "https://api.github.com/users/vrv/orgs", "repos_url": "https://api.github.com/users/vrv/repos", "events_url": "https://api.github.com/users/vrv/events{/privacy}", "received_events_url": "https://api.github.com/users/vrv/received_events", "type": "User", "site_admin": false}, "created_at": "2017-07-18T00:04:18Z", "updated_at": "2017-07-18T00:04:18Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Okay, it sounds like it will take some time to opensource the internal flags library, so let's endeavor to make it API compatible if we're going to do this.</p>\n<p>If the implementation can be something like:</p>\n<pre><code>def mark_flag_as_required(flag_name):\n  # impl here\n</code></pre>\n<p>and its use looks like:</p>\n<pre><code>if __name__ == '__main__':\n      flags.mark_flag_as_required('your_flag_name')\n      tf.app.run()\n</code></pre>\n<p>then I think we could accept a PR.</p>\n<p>This means that the declaration of it being 'required' cannot be in the FLAGS definition, and so this will require some extra validation code to be run rather than using the 'requires' field of argparse.</p>\n<p>My suggestion would be to add code to the _FlagValues class that keeps track of required flags registered via \"mark_flag_as_required\", and prior to calling parse_known_args(), the code would check to see that 'args' contains all of the required flags, and raises an exception if not true.</p>\n<p>The reason for doing it this way is that the this flags library is for better or worse (I think worse) built in such a way that it allows flags to be defined far from where they are parsed, and that means a flag may be defined in a file that you don't own, but you want to make required.  So decoupling the 'requirement' from the flag definition allows the binary to own the set of required flags.</p>", "body_text": "Okay, it sounds like it will take some time to opensource the internal flags library, so let's endeavor to make it API compatible if we're going to do this.\nIf the implementation can be something like:\ndef mark_flag_as_required(flag_name):\n  # impl here\n\nand its use looks like:\nif __name__ == '__main__':\n      flags.mark_flag_as_required('your_flag_name')\n      tf.app.run()\n\nthen I think we could accept a PR.\nThis means that the declaration of it being 'required' cannot be in the FLAGS definition, and so this will require some extra validation code to be run rather than using the 'requires' field of argparse.\nMy suggestion would be to add code to the _FlagValues class that keeps track of required flags registered via \"mark_flag_as_required\", and prior to calling parse_known_args(), the code would check to see that 'args' contains all of the required flags, and raises an exception if not true.\nThe reason for doing it this way is that the this flags library is for better or worse (I think worse) built in such a way that it allows flags to be defined far from where they are parsed, and that means a flag may be defined in a file that you don't own, but you want to make required.  So decoupling the 'requirement' from the flag definition allows the binary to own the set of required flags.", "body": "Okay, it sounds like it will take some time to opensource the internal flags library, so let's endeavor to make it API compatible if we're going to do this.\r\n\r\nIf the implementation can be something like:\r\n\r\n```\r\ndef mark_flag_as_required(flag_name):\r\n  # impl here\r\n```\r\n\r\nand its use looks like:\r\n\r\n```\r\nif __name__ == '__main__':\r\n      flags.mark_flag_as_required('your_flag_name')\r\n      tf.app.run()\r\n```\r\n\r\nthen I think we could accept a PR.\r\n\r\nThis means that the declaration of it being 'required' cannot be in the FLAGS definition, and so this will require some extra validation code to be run rather than using the 'requires' field of argparse.  \r\n\r\nMy suggestion would be to add code to the _FlagValues class that keeps track of required flags registered via \"mark_flag_as_required\", and prior to calling parse_known_args(), the code would check to see that 'args' contains all of the required flags, and raises an exception if not true.\r\n\r\nThe reason for doing it this way is that the this flags library is for better or worse (I think worse) built in such a way that it allows flags to be defined far from where they are parsed, and that means a flag may be defined in a file that you don't own, but you want to make required.  So decoupling the 'requirement' from the flag definition allows the binary to own the set of required flags."}