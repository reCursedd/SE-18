{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/124865014", "pull_request_review_id": 47197617, "id": 124865014, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEyNDg2NTAxNA==", "diff_hunk": "@@ -0,0 +1,98 @@\n+/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef TENSORFLOW_USE_SYCL\n+#error This file contains SYCL specific code and should only be included when \\\n+building with SYCL support.\n+#endif\n+\n+#ifndef TENSORFLOW_CORE_UTIL_SYCL_UTIL_H_\n+#define TENSORFLOW_CORE_UTIL_SYCL_UTIL_H_\n+\n+namespace tensorflow {\n+\n+// Need an atomic add for the MaxPoolGrad and MaxPool3DGrad kernels.\n+//\n+// For the device, this needs a pointer to global memory which isn't understood\n+// by the host. The host should never be calling this method, but we provide\n+// the header so that the host compiler can compile the functor.\n+#ifdef __SYCL_DEVICE_ONLY__\n+template <typename T>\n+void SyclAtomicAdd(__attribute__((address_space(1))) T* address,\n+                   const T increment);\n+#else\n+template <typename T>\n+void SyclAtomicAdd(T* address, const T increment);\n+#endif  // __SYCL_DEVICE_ONLY__\n+\n+#ifdef __SYCL_DEVICE_ONLY__\n+// Use the OpenCL atomic uint operations to provide a floating point atomic add.\n+// For the device we use the atomic compare-exchange builtin to keep trying to\n+// add to the memory in a thread safe way. The union is needed as these\n+// builtins are not availble for floating point types, only integer types, so\n+// we do the addition on the float and the memory update on the uint.\n+//\n+// TODO(jwlawson): Remove once we have different type accessors for SYCL buffers\n+// Providing a way to cast the types of buffers or accessors has been proposed\n+// as a SYCL extension, so once this is available we can use an atomic\n+// accessor and remove this.", "path": "tensorflow/core/util/sycl_util.h", "position": null, "original_position": 50, "commit_id": "78e898a8bd4a0ed524a7dd317c52df15f889ea32", "original_commit_id": "8178666671966f4f5bc352d59cf063f7727e7cc3", "user": {"login": "DuncanMcBain", "id": 5628152, "node_id": "MDQ6VXNlcjU2MjgxNTI=", "avatar_url": "https://avatars2.githubusercontent.com/u/5628152?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DuncanMcBain", "html_url": "https://github.com/DuncanMcBain", "followers_url": "https://api.github.com/users/DuncanMcBain/followers", "following_url": "https://api.github.com/users/DuncanMcBain/following{/other_user}", "gists_url": "https://api.github.com/users/DuncanMcBain/gists{/gist_id}", "starred_url": "https://api.github.com/users/DuncanMcBain/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DuncanMcBain/subscriptions", "organizations_url": "https://api.github.com/users/DuncanMcBain/orgs", "repos_url": "https://api.github.com/users/DuncanMcBain/repos", "events_url": "https://api.github.com/users/DuncanMcBain/events{/privacy}", "received_events_url": "https://api.github.com/users/DuncanMcBain/received_events", "type": "User", "site_admin": false}, "body": "In particular, you can't turn those into atomic accessors because there is no atomic add for floats in OpenCL 1.2. Even OpenCL 2.0, which expanded the atomic operations available, doesn't have them.\r\n\r\nIn addition, the underlying buffer type is of int8_t, which has no atomic support either. Similarly, the cl::sycl::atomic type is not user-constructible, but even if it were, it would effectively be doing this anyway (or rather would call this SPIR-mangled function on device, and the C++11 version on host). That said, we'll take note of this feedback - seeing real-world usage is always useful.\r\n\r\nPersonally, I'm more of a fan of the less-abstract form of atomics where you simply operate atomically on addresses. though that's somewhat lower-level than SYCL aims for. I liked the atomic_view (later atomic_ref) proposals for C++, but I don't believe they made it into C++17. ", "created_at": "2017-06-29T17:33:52Z", "updated_at": "2017-07-31T21:41:07Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/10978#discussion_r124865014", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/10978", "author_association": "NONE", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/124865014"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/10978#discussion_r124865014"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/10978"}}, "body_html": "<p>In particular, you can't turn those into atomic accessors because there is no atomic add for floats in OpenCL 1.2. Even OpenCL 2.0, which expanded the atomic operations available, doesn't have them.</p>\n<p>In addition, the underlying buffer type is of int8_t, which has no atomic support either. Similarly, the cl::sycl::atomic type is not user-constructible, but even if it were, it would effectively be doing this anyway (or rather would call this SPIR-mangled function on device, and the C++11 version on host). That said, we'll take note of this feedback - seeing real-world usage is always useful.</p>\n<p>Personally, I'm more of a fan of the less-abstract form of atomics where you simply operate atomically on addresses. though that's somewhat lower-level than SYCL aims for. I liked the atomic_view (later atomic_ref) proposals for C++, but I don't believe they made it into C++17.</p>", "body_text": "In particular, you can't turn those into atomic accessors because there is no atomic add for floats in OpenCL 1.2. Even OpenCL 2.0, which expanded the atomic operations available, doesn't have them.\nIn addition, the underlying buffer type is of int8_t, which has no atomic support either. Similarly, the cl::sycl::atomic type is not user-constructible, but even if it were, it would effectively be doing this anyway (or rather would call this SPIR-mangled function on device, and the C++11 version on host). That said, we'll take note of this feedback - seeing real-world usage is always useful.\nPersonally, I'm more of a fan of the less-abstract form of atomics where you simply operate atomically on addresses. though that's somewhat lower-level than SYCL aims for. I liked the atomic_view (later atomic_ref) proposals for C++, but I don't believe they made it into C++17.", "in_reply_to_id": 124588287}