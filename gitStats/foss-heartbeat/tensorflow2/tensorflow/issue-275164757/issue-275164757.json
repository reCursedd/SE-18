{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/14704", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/14704/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/14704/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/14704/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/14704", "id": 275164757, "node_id": "MDU6SXNzdWUyNzUxNjQ3NTc=", "number": 14704, "title": "tf.data.Dataset.padded_batch() doesn't work with nested elements", "user": {"login": "areshytko", "id": 7684174, "node_id": "MDQ6VXNlcjc2ODQxNzQ=", "avatar_url": "https://avatars1.githubusercontent.com/u/7684174?v=4", "gravatar_id": "", "url": "https://api.github.com/users/areshytko", "html_url": "https://github.com/areshytko", "followers_url": "https://api.github.com/users/areshytko/followers", "following_url": "https://api.github.com/users/areshytko/following{/other_user}", "gists_url": "https://api.github.com/users/areshytko/gists{/gist_id}", "starred_url": "https://api.github.com/users/areshytko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/areshytko/subscriptions", "organizations_url": "https://api.github.com/users/areshytko/orgs", "repos_url": "https://api.github.com/users/areshytko/repos", "events_url": "https://api.github.com/users/areshytko/events{/privacy}", "received_events_url": "https://api.github.com/users/areshytko/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2017-11-19T14:53:21Z", "updated_at": "2017-11-20T17:24:50Z", "closed_at": "2017-11-20T17:24:50Z", "author_association": "NONE", "body_html": "<h3>System information</h3>\n<p>TF 1.4 (pip install)<br>\nPython version 3.5.2 (Anaconda)</p>\n<h3>Problem description</h3>\n<p><code>tf.data.Dataset.padded_batch()</code> fails if a dataset element has some nested structure instead of being a tensor. Dataset API is supposed to work with Estimator's input_fn functionality which should return<br>\nfeatures and labels as separate python objects and it is very inconvenient to merge everything into a single tensor, make a batch and then split.</p>\n<h3>Source</h3>\n<pre><code>import tensorflow as tf\nprint(tf.__version__)    \n\ndataset = tf.data.Dataset.range(100)\ndataset = dataset.map(lambda x: {'x': tf.fill([tf.cast(x, tf.int32)], x),\n                                                       'y': tf.fill([tf.cast(x, tf.int32)], x)})\ndataset = dataset.padded_batch(4, padded_shapes=[None])\n\niterator = dataset.make_one_shot_iterator()\nnext_element = iterator.get_next()\n\nwith tf.train.MonitoredSession() as sess:\n    print(sess.run(next_element))\n    print(sess.run(next_element))\n</code></pre>\n<h3>Actual</h3>\n<pre><code>---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n&lt;ipython-input-38-bb9f335976ed&gt; in &lt;module&gt;()\n      2 dataset = dataset.map(lambda x: {'x': tf.fill([tf.cast(x, tf.int32)], x),\n      3                                  'y': tf.fill([tf.cast(x, tf.int32)], x)})\n----&gt; 4 dataset = dataset.padded_batch(4, padded_shapes=[None])\n      5 \n      6 iterator = dataset.make_one_shot_iterator()\n\n~/anaconda3/lib/python3.5/site-packages/tensorflow/python/data/ops/dataset_ops.py in padded_batch(self, batch_size, padded_shapes, padding_values)\n    693       A `Dataset`.\n    694     \"\"\"\n--&gt; 695     return PaddedBatchDataset(self, batch_size, padded_shapes, padding_values)\n    696 \n    697   def map(self, map_func, num_parallel_calls=None):\n\n~/anaconda3/lib/python3.5/site-packages/tensorflow/python/data/ops/dataset_ops.py in __init__(self, input_dataset, batch_size, padded_shapes, padding_values)\n   1290                       self._default_padding(input_dataset))\n   1291     self._padded_shapes = nest.map_structure_up_to(\n-&gt; 1292         input_dataset.output_shapes, _partial_shape_to_tensor, padded_shapes)\n   1293     self._padding_values = nest.map_structure_up_to(\n   1294         input_dataset.output_shapes, _padding_value_to_tensor, padding_values,\n\n~/anaconda3/lib/python3.5/site-packages/tensorflow/python/data/util/nest.py in map_structure_up_to(shallow_tree, func, *inputs)\n    510     raise ValueError(\"Cannot map over no sequences\")\n    511   for input_tree in inputs:\n--&gt; 512     assert_shallow_structure(shallow_tree, input_tree)\n    513 \n    514   # Flatten each input separately, apply the function to corresponding elements,\n\n~/anaconda3/lib/python3.5/site-packages/tensorflow/python/data/util/nest.py in assert_shallow_structure(shallow_tree, input_tree, check_types)\n    354       raise TypeError(\n    355           \"If shallow structure is a sequence, input must also be a sequence. \"\n--&gt; 356           \"Input has type: %s.\" % type(input_tree))\n    357 \n    358     if check_types and not isinstance(input_tree, type(shallow_tree)):\n\nTypeError: If shallow structure is a sequence, input must also be a sequence. Input has type: &lt;class 'list'&gt;.\n</code></pre>\n<h3>Expected</h3>\n<p>It should produce dictionary, where x and y values are batch tensors with proper paddings.</p>", "body_text": "System information\nTF 1.4 (pip install)\nPython version 3.5.2 (Anaconda)\nProblem description\ntf.data.Dataset.padded_batch() fails if a dataset element has some nested structure instead of being a tensor. Dataset API is supposed to work with Estimator's input_fn functionality which should return\nfeatures and labels as separate python objects and it is very inconvenient to merge everything into a single tensor, make a batch and then split.\nSource\nimport tensorflow as tf\nprint(tf.__version__)    \n\ndataset = tf.data.Dataset.range(100)\ndataset = dataset.map(lambda x: {'x': tf.fill([tf.cast(x, tf.int32)], x),\n                                                       'y': tf.fill([tf.cast(x, tf.int32)], x)})\ndataset = dataset.padded_batch(4, padded_shapes=[None])\n\niterator = dataset.make_one_shot_iterator()\nnext_element = iterator.get_next()\n\nwith tf.train.MonitoredSession() as sess:\n    print(sess.run(next_element))\n    print(sess.run(next_element))\n\nActual\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n<ipython-input-38-bb9f335976ed> in <module>()\n      2 dataset = dataset.map(lambda x: {'x': tf.fill([tf.cast(x, tf.int32)], x),\n      3                                  'y': tf.fill([tf.cast(x, tf.int32)], x)})\n----> 4 dataset = dataset.padded_batch(4, padded_shapes=[None])\n      5 \n      6 iterator = dataset.make_one_shot_iterator()\n\n~/anaconda3/lib/python3.5/site-packages/tensorflow/python/data/ops/dataset_ops.py in padded_batch(self, batch_size, padded_shapes, padding_values)\n    693       A `Dataset`.\n    694     \"\"\"\n--> 695     return PaddedBatchDataset(self, batch_size, padded_shapes, padding_values)\n    696 \n    697   def map(self, map_func, num_parallel_calls=None):\n\n~/anaconda3/lib/python3.5/site-packages/tensorflow/python/data/ops/dataset_ops.py in __init__(self, input_dataset, batch_size, padded_shapes, padding_values)\n   1290                       self._default_padding(input_dataset))\n   1291     self._padded_shapes = nest.map_structure_up_to(\n-> 1292         input_dataset.output_shapes, _partial_shape_to_tensor, padded_shapes)\n   1293     self._padding_values = nest.map_structure_up_to(\n   1294         input_dataset.output_shapes, _padding_value_to_tensor, padding_values,\n\n~/anaconda3/lib/python3.5/site-packages/tensorflow/python/data/util/nest.py in map_structure_up_to(shallow_tree, func, *inputs)\n    510     raise ValueError(\"Cannot map over no sequences\")\n    511   for input_tree in inputs:\n--> 512     assert_shallow_structure(shallow_tree, input_tree)\n    513 \n    514   # Flatten each input separately, apply the function to corresponding elements,\n\n~/anaconda3/lib/python3.5/site-packages/tensorflow/python/data/util/nest.py in assert_shallow_structure(shallow_tree, input_tree, check_types)\n    354       raise TypeError(\n    355           \"If shallow structure is a sequence, input must also be a sequence. \"\n--> 356           \"Input has type: %s.\" % type(input_tree))\n    357 \n    358     if check_types and not isinstance(input_tree, type(shallow_tree)):\n\nTypeError: If shallow structure is a sequence, input must also be a sequence. Input has type: <class 'list'>.\n\nExpected\nIt should produce dictionary, where x and y values are batch tensors with proper paddings.", "body": "### System information\r\n\r\nTF 1.4 (pip install)\r\nPython version 3.5.2 (Anaconda)\r\n\r\n### Problem description\r\n\r\n`tf.data.Dataset.padded_batch()` fails if a dataset element has some nested structure instead of being a tensor. Dataset API is supposed to work with Estimator's input_fn functionality which should return\r\nfeatures and labels as separate python objects and it is very inconvenient to merge everything into a single tensor, make a batch and then split.\r\n\r\n### Source\r\n\r\n    import tensorflow as tf\r\n    print(tf.__version__)    \r\n\r\n    dataset = tf.data.Dataset.range(100)\r\n    dataset = dataset.map(lambda x: {'x': tf.fill([tf.cast(x, tf.int32)], x),\r\n                                                           'y': tf.fill([tf.cast(x, tf.int32)], x)})\r\n    dataset = dataset.padded_batch(4, padded_shapes=[None])\r\n\r\n    iterator = dataset.make_one_shot_iterator()\r\n    next_element = iterator.get_next()\r\n\r\n    with tf.train.MonitoredSession() as sess:\r\n        print(sess.run(next_element))\r\n        print(sess.run(next_element))\r\n\r\n### Actual\r\n\r\n    ---------------------------------------------------------------------------\r\n    TypeError                                 Traceback (most recent call last)\r\n    <ipython-input-38-bb9f335976ed> in <module>()\r\n          2 dataset = dataset.map(lambda x: {'x': tf.fill([tf.cast(x, tf.int32)], x),\r\n          3                                  'y': tf.fill([tf.cast(x, tf.int32)], x)})\r\n    ----> 4 dataset = dataset.padded_batch(4, padded_shapes=[None])\r\n          5 \r\n          6 iterator = dataset.make_one_shot_iterator()\r\n\r\n    ~/anaconda3/lib/python3.5/site-packages/tensorflow/python/data/ops/dataset_ops.py in padded_batch(self, batch_size, padded_shapes, padding_values)\r\n        693       A `Dataset`.\r\n        694     \"\"\"\r\n    --> 695     return PaddedBatchDataset(self, batch_size, padded_shapes, padding_values)\r\n        696 \r\n        697   def map(self, map_func, num_parallel_calls=None):\r\n\r\n    ~/anaconda3/lib/python3.5/site-packages/tensorflow/python/data/ops/dataset_ops.py in __init__(self, input_dataset, batch_size, padded_shapes, padding_values)\r\n       1290                       self._default_padding(input_dataset))\r\n       1291     self._padded_shapes = nest.map_structure_up_to(\r\n    -> 1292         input_dataset.output_shapes, _partial_shape_to_tensor, padded_shapes)\r\n       1293     self._padding_values = nest.map_structure_up_to(\r\n       1294         input_dataset.output_shapes, _padding_value_to_tensor, padding_values,\r\n\r\n    ~/anaconda3/lib/python3.5/site-packages/tensorflow/python/data/util/nest.py in map_structure_up_to(shallow_tree, func, *inputs)\r\n        510     raise ValueError(\"Cannot map over no sequences\")\r\n        511   for input_tree in inputs:\r\n    --> 512     assert_shallow_structure(shallow_tree, input_tree)\r\n        513 \r\n        514   # Flatten each input separately, apply the function to corresponding elements,\r\n\r\n    ~/anaconda3/lib/python3.5/site-packages/tensorflow/python/data/util/nest.py in assert_shallow_structure(shallow_tree, input_tree, check_types)\r\n        354       raise TypeError(\r\n        355           \"If shallow structure is a sequence, input must also be a sequence. \"\r\n    --> 356           \"Input has type: %s.\" % type(input_tree))\r\n        357 \r\n        358     if check_types and not isinstance(input_tree, type(shallow_tree)):\r\n\r\n    TypeError: If shallow structure is a sequence, input must also be a sequence. Input has type: <class 'list'>.\r\n\r\n### Expected\r\n\r\nIt should produce dictionary, where x and y values are batch tensors with proper paddings.\r\n"}