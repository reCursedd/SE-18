{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/321528058", "html_url": "https://github.com/tensorflow/tensorflow/issues/11725#issuecomment-321528058", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11725", "id": 321528058, "node_id": "MDEyOklzc3VlQ29tbWVudDMyMTUyODA1OA==", "user": {"login": "shamoya", "id": 22274255, "node_id": "MDQ6VXNlcjIyMjc0MjU1", "avatar_url": "https://avatars2.githubusercontent.com/u/22274255?v=4", "gravatar_id": "", "url": "https://api.github.com/users/shamoya", "html_url": "https://github.com/shamoya", "followers_url": "https://api.github.com/users/shamoya/followers", "following_url": "https://api.github.com/users/shamoya/following{/other_user}", "gists_url": "https://api.github.com/users/shamoya/gists{/gist_id}", "starred_url": "https://api.github.com/users/shamoya/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/shamoya/subscriptions", "organizations_url": "https://api.github.com/users/shamoya/orgs", "repos_url": "https://api.github.com/users/shamoya/repos", "events_url": "https://api.github.com/users/shamoya/events{/privacy}", "received_events_url": "https://api.github.com/users/shamoya/received_events", "type": "User", "site_admin": false}, "created_at": "2017-08-10T11:42:11Z", "updated_at": "2017-08-10T11:42:11Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Wowww <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=12075848\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/junshi15\">@junshi15</a>, looks like this is it !</p>\n<p>I've ran the test with inter/intra_op_parallelism_threads = 500 and it passed (multiple times).<br>\nIt workaround the problem by reducing the probability to have this scenario (Schedule of the threadpool more likely to choose an idle thread).<br>\nIt also explains why it happens when working with real data (queue readers also use the same threads)!</p>\n<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=15676913\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/poxvoculi\">@poxvoculi</a><br>\nReally not clear to me how Schedule is possible on a thread which holds a mutex.<br>\nCan't understand also where the context switch happens in this thread while it performs ThenExecute.</p>\n<p>Thanks <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=12075848\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/junshi15\">@junshi15</a> !</p>", "body_text": "Wowww @junshi15, looks like this is it !\nI've ran the test with inter/intra_op_parallelism_threads = 500 and it passed (multiple times).\nIt workaround the problem by reducing the probability to have this scenario (Schedule of the threadpool more likely to choose an idle thread).\nIt also explains why it happens when working with real data (queue readers also use the same threads)!\n@poxvoculi\nReally not clear to me how Schedule is possible on a thread which holds a mutex.\nCan't understand also where the context switch happens in this thread while it performs ThenExecute.\nThanks @junshi15 !", "body": "Wowww @junshi15, looks like this is it ! \r\n\r\nI've ran the test with inter/intra_op_parallelism_threads = 500 and it passed (multiple times).\r\nIt workaround the problem by reducing the probability to have this scenario (Schedule of the threadpool more likely to choose an idle thread).\r\nIt also explains why it happens when working with real data (queue readers also use the same threads)!\r\n\r\n@poxvoculi\r\nReally not clear to me how Schedule is possible on a thread which holds a mutex.\r\nCan't understand also where the context switch happens in this thread while it performs ThenExecute.\r\n\r\nThanks @junshi15 !\r\n"}