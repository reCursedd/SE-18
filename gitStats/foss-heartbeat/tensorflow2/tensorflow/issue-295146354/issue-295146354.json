{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/16831", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/16831/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/16831/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/16831/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/16831", "id": 295146354, "node_id": "MDU6SXNzdWUyOTUxNDYzNTQ=", "number": 16831, "title": "Feature Request: Dynamic Convolution Kernels", "user": {"login": "mhuen", "id": 23478431, "node_id": "MDQ6VXNlcjIzNDc4NDMx", "avatar_url": "https://avatars1.githubusercontent.com/u/23478431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mhuen", "html_url": "https://github.com/mhuen", "followers_url": "https://api.github.com/users/mhuen/followers", "following_url": "https://api.github.com/users/mhuen/following{/other_user}", "gists_url": "https://api.github.com/users/mhuen/gists{/gist_id}", "starred_url": "https://api.github.com/users/mhuen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mhuen/subscriptions", "organizations_url": "https://api.github.com/users/mhuen/orgs", "repos_url": "https://api.github.com/users/mhuen/repos", "events_url": "https://api.github.com/users/mhuen/events{/privacy}", "received_events_url": "https://api.github.com/users/mhuen/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 473173272, "node_id": "MDU6TGFiZWw0NzMxNzMyNzI=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:feature", "name": "type:feature", "color": "159b2e", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2018-02-07T13:56:05Z", "updated_at": "2018-02-22T23:43:38Z", "closed_at": "2018-02-22T23:43:38Z", "author_association": "NONE", "body_html": "<p>I was wondering if it is possible to allow the kernel in conv2d and conv3d to have an additional batch dimension, e.g. to allow the filter shape to be:<br>\n<code>[batch, filter_depth, filter_height, filter_width, in_channels, out_channels]</code><br>\nHence, the convolution kernel can depend on the input data.</p>\n<p>In doing so, the convolution kernels can be 'dynamic' and use prior information.<br>\nCurrently, the kernels are 'static' and therefore always look for the same patterns in the input data.<br>\nHowever, it would be helpful for the kernel to be a function of some input.<br>\nThat way a local transformation (learned through back propagation) can be applied to the kernels, in order to look for patterns unique for that image/ event/ data sample.</p>\n<p>I implemented a 3d version of this in python, however, all the indexing and slicing make it rather slow. For the conv2d, I guess one could use tf.extract_image_patches to speed things up, but something equivalent does not exist for the 3d case (unless I'm missing something?).<br>\nI tried looking into the code of conv3d and conv2d to see how much effort it would be to implement this. Unfortunately, I'm neither a cuda expert, nor familiar with the way ops and kernels are implemented in tensorflow.</p>\n<p>A feature like this would be greatly appreciated.</p>\n<h3>System information</h3>\n<ul>\n<li><strong>Have I written custom code (as opposed to using a stock example script provided in TensorFlow)</strong>: N/A</li>\n<li><strong>OS Platform and Distribution (e.g., Linux Ubuntu 16.04)</strong>: N/A</li>\n<li><strong>TensorFlow installed from (source or binary)</strong>: N/A</li>\n<li><strong>TensorFlow version (use command below)</strong>: N/A</li>\n<li><strong>Python version</strong>:  N/A</li>\n<li><strong>Bazel version (if compiling from source)</strong>: N/A</li>\n<li><strong>GCC/Compiler version (if compiling from source)</strong>: N/A</li>\n<li><strong>CUDA/cuDNN version</strong>: N/A</li>\n<li><strong>GPU model and memory</strong>: N/A</li>\n<li><strong>Exact command to reproduce</strong>: N/A</li>\n</ul>", "body_text": "I was wondering if it is possible to allow the kernel in conv2d and conv3d to have an additional batch dimension, e.g. to allow the filter shape to be:\n[batch, filter_depth, filter_height, filter_width, in_channels, out_channels]\nHence, the convolution kernel can depend on the input data.\nIn doing so, the convolution kernels can be 'dynamic' and use prior information.\nCurrently, the kernels are 'static' and therefore always look for the same patterns in the input data.\nHowever, it would be helpful for the kernel to be a function of some input.\nThat way a local transformation (learned through back propagation) can be applied to the kernels, in order to look for patterns unique for that image/ event/ data sample.\nI implemented a 3d version of this in python, however, all the indexing and slicing make it rather slow. For the conv2d, I guess one could use tf.extract_image_patches to speed things up, but something equivalent does not exist for the 3d case (unless I'm missing something?).\nI tried looking into the code of conv3d and conv2d to see how much effort it would be to implement this. Unfortunately, I'm neither a cuda expert, nor familiar with the way ops and kernels are implemented in tensorflow.\nA feature like this would be greatly appreciated.\nSystem information\n\nHave I written custom code (as opposed to using a stock example script provided in TensorFlow): N/A\nOS Platform and Distribution (e.g., Linux Ubuntu 16.04): N/A\nTensorFlow installed from (source or binary): N/A\nTensorFlow version (use command below): N/A\nPython version:  N/A\nBazel version (if compiling from source): N/A\nGCC/Compiler version (if compiling from source): N/A\nCUDA/cuDNN version: N/A\nGPU model and memory: N/A\nExact command to reproduce: N/A", "body": "I was wondering if it is possible to allow the kernel in conv2d and conv3d to have an additional batch dimension, e.g. to allow the filter shape to be:\r\n`[batch, filter_depth, filter_height, filter_width, in_channels, out_channels]` \r\nHence, the convolution kernel can depend on the input data.\r\n\r\nIn doing so, the convolution kernels can be 'dynamic' and use prior information. \r\nCurrently, the kernels are 'static' and therefore always look for the same patterns in the input data.\r\nHowever, it would be helpful for the kernel to be a function of some input. \r\nThat way a local transformation (learned through back propagation) can be applied to the kernels, in order to look for patterns unique for that image/ event/ data sample.\r\n\r\nI implemented a 3d version of this in python, however, all the indexing and slicing make it rather slow. For the conv2d, I guess one could use tf.extract_image_patches to speed things up, but something equivalent does not exist for the 3d case (unless I'm missing something?).\r\nI tried looking into the code of conv3d and conv2d to see how much effort it would be to implement this. Unfortunately, I'm neither a cuda expert, nor familiar with the way ops and kernels are implemented in tensorflow.\r\n\r\nA feature like this would be greatly appreciated.\r\n\r\n\r\n### System information\r\n- **Have I written custom code (as opposed to using a stock example script provided in TensorFlow)**: N/A\r\n- **OS Platform and Distribution (e.g., Linux Ubuntu 16.04)**: N/A\r\n- **TensorFlow installed from (source or binary)**: N/A\r\n- **TensorFlow version (use command below)**: N/A\r\n- **Python version**:  N/A\r\n- **Bazel version (if compiling from source)**: N/A\r\n- **GCC/Compiler version (if compiling from source)**: N/A\r\n- **CUDA/cuDNN version**: N/A\r\n- **GPU model and memory**: N/A\r\n- **Exact command to reproduce**: N/A"}