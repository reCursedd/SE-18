{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/12019", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/12019/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/12019/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/12019/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/12019", "id": 247823207, "node_id": "MDU6SXNzdWUyNDc4MjMyMDc=", "number": 12019, "title": "foldr is too restrictive:  dimension 0 in both shapes must be equal", "user": {"login": "edgimar", "id": 393850, "node_id": "MDQ6VXNlcjM5Mzg1MA==", "avatar_url": "https://avatars0.githubusercontent.com/u/393850?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edgimar", "html_url": "https://github.com/edgimar", "followers_url": "https://api.github.com/users/edgimar/followers", "following_url": "https://api.github.com/users/edgimar/following{/other_user}", "gists_url": "https://api.github.com/users/edgimar/gists{/gist_id}", "starred_url": "https://api.github.com/users/edgimar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edgimar/subscriptions", "organizations_url": "https://api.github.com/users/edgimar/orgs", "repos_url": "https://api.github.com/users/edgimar/repos", "events_url": "https://api.github.com/users/edgimar/events{/privacy}", "received_events_url": "https://api.github.com/users/edgimar/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 299643928, "node_id": "MDU6TGFiZWwyOTk2NDM5Mjg=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:contributions%20welcome", "name": "stat:contributions welcome", "color": "f4b400", "default": false}, {"id": 473173272, "node_id": "MDU6TGFiZWw0NzMxNzMyNzI=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:feature", "name": "type:feature", "color": "159b2e", "default": false}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2017-08-03T20:17:42Z", "updated_at": "2017-10-18T14:47:36Z", "closed_at": null, "author_association": "NONE", "body_html": "<p>Using TF 1.2.0-rc1 on Ubuntu 16.04.</p>\n<p>There are cases where <code>tf.foldr</code> should work, but is unable to because of a restriction that the first shape dimensions be identical for all list elements.  Below is a self-contained example that demonstrates the problem:</p>\n<pre><code>import tensorflow as tf\nsess = tf.InteractiveSession()\n\ndef concat2(A, B):\n    return tf.concat([A, B], axis=0)\n\nA = tf.constant([[10,10]])             # A.shape =&gt; (1,2)\nB = tf.constant([[20, 20], [30, 30]])  # B.shape =&gt; (2,2)\n\nprint(concat2(A, B).eval())              # =&gt; [[10, 10], [20, 20], [30, 30]]\nprint(tf.foldr(concat2, [A, B]).eval())  # =&gt; ERROR!\n</code></pre>", "body_text": "Using TF 1.2.0-rc1 on Ubuntu 16.04.\nThere are cases where tf.foldr should work, but is unable to because of a restriction that the first shape dimensions be identical for all list elements.  Below is a self-contained example that demonstrates the problem:\nimport tensorflow as tf\nsess = tf.InteractiveSession()\n\ndef concat2(A, B):\n    return tf.concat([A, B], axis=0)\n\nA = tf.constant([[10,10]])             # A.shape => (1,2)\nB = tf.constant([[20, 20], [30, 30]])  # B.shape => (2,2)\n\nprint(concat2(A, B).eval())              # => [[10, 10], [20, 20], [30, 30]]\nprint(tf.foldr(concat2, [A, B]).eval())  # => ERROR!", "body": "Using TF 1.2.0-rc1 on Ubuntu 16.04.\r\n\r\nThere are cases where `tf.foldr` should work, but is unable to because of a restriction that the first shape dimensions be identical for all list elements.  Below is a self-contained example that demonstrates the problem:\r\n\r\n```\r\nimport tensorflow as tf\r\nsess = tf.InteractiveSession()\r\n\r\ndef concat2(A, B):\r\n    return tf.concat([A, B], axis=0)\r\n\r\nA = tf.constant([[10,10]])             # A.shape => (1,2)\r\nB = tf.constant([[20, 20], [30, 30]])  # B.shape => (2,2)\r\n\r\nprint(concat2(A, B).eval())              # => [[10, 10], [20, 20], [30, 30]]\r\nprint(tf.foldr(concat2, [A, B]).eval())  # => ERROR!\r\n```\r\n"}