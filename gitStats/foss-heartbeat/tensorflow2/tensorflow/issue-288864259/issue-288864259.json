{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/16155", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/16155/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/16155/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/16155/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/16155", "id": 288864259, "node_id": "MDU6SXNzdWUyODg4NjQyNTk=", "number": 16155, "title": "[Bug] slim.tfexample_decoder.TFExampleDecoder() crashes if RAW image with float type is used.", "user": {"login": "Gabriel-Kang", "id": 20576203, "node_id": "MDQ6VXNlcjIwNTc2MjAz", "avatar_url": "https://avatars0.githubusercontent.com/u/20576203?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gabriel-Kang", "html_url": "https://github.com/Gabriel-Kang", "followers_url": "https://api.github.com/users/Gabriel-Kang/followers", "following_url": "https://api.github.com/users/Gabriel-Kang/following{/other_user}", "gists_url": "https://api.github.com/users/Gabriel-Kang/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gabriel-Kang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gabriel-Kang/subscriptions", "organizations_url": "https://api.github.com/users/Gabriel-Kang/orgs", "repos_url": "https://api.github.com/users/Gabriel-Kang/repos", "events_url": "https://api.github.com/users/Gabriel-Kang/events{/privacy}", "received_events_url": "https://api.github.com/users/Gabriel-Kang/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 386191887, "node_id": "MDU6TGFiZWwzODYxOTE4ODc=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:awaiting%20response", "name": "stat:awaiting response", "color": "f4b400", "default": false}, {"id": 473172988, "node_id": "MDU6TGFiZWw0NzMxNzI5ODg=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:bug/performance", "name": "type:bug/performance", "color": "159b2e", "default": false}], "state": "closed", "locked": false, "assignee": {"login": "bignamehyp", "id": 3474655, "node_id": "MDQ6VXNlcjM0NzQ2NTU=", "avatar_url": "https://avatars2.githubusercontent.com/u/3474655?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bignamehyp", "html_url": "https://github.com/bignamehyp", "followers_url": "https://api.github.com/users/bignamehyp/followers", "following_url": "https://api.github.com/users/bignamehyp/following{/other_user}", "gists_url": "https://api.github.com/users/bignamehyp/gists{/gist_id}", "starred_url": "https://api.github.com/users/bignamehyp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bignamehyp/subscriptions", "organizations_url": "https://api.github.com/users/bignamehyp/orgs", "repos_url": "https://api.github.com/users/bignamehyp/repos", "events_url": "https://api.github.com/users/bignamehyp/events{/privacy}", "received_events_url": "https://api.github.com/users/bignamehyp/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "bignamehyp", "id": 3474655, "node_id": "MDQ6VXNlcjM0NzQ2NTU=", "avatar_url": "https://avatars2.githubusercontent.com/u/3474655?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bignamehyp", "html_url": "https://github.com/bignamehyp", "followers_url": "https://api.github.com/users/bignamehyp/followers", "following_url": "https://api.github.com/users/bignamehyp/following{/other_user}", "gists_url": "https://api.github.com/users/bignamehyp/gists{/gist_id}", "starred_url": "https://api.github.com/users/bignamehyp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bignamehyp/subscriptions", "organizations_url": "https://api.github.com/users/bignamehyp/orgs", "repos_url": "https://api.github.com/users/bignamehyp/repos", "events_url": "https://api.github.com/users/bignamehyp/events{/privacy}", "received_events_url": "https://api.github.com/users/bignamehyp/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 12, "created_at": "2018-01-16T10:55:34Z", "updated_at": "2018-06-06T19:00:18Z", "closed_at": "2018-05-02T20:57:46Z", "author_association": "NONE", "body_html": "<h3>System information</h3>\n<ul>\n<li><strong>Have I written custom code (as opposed to using a stock example script provided in TensorFlow)</strong>: No.</li>\n<li><strong>OS Platform and Distribution (e.g., Linux Ubuntu 16.04)</strong>: 16.04</li>\n<li><strong>TensorFlow installed from (source or binary)</strong>: binary</li>\n<li><strong>TensorFlow version (use command below)</strong>: 'unkown', '1.4.0-rc0'</li>\n<li><strong>Python version</strong>: 2.7.13</li>\n<li><strong>Bazel version (if compiling from source)</strong>:</li>\n<li><strong>GCC/Compiler version (if compiling from source)</strong>:</li>\n<li><strong>CUDA/cuDNN version</strong>: 9.0/7.0.3</li>\n<li><strong>GPU model and memory</strong>: Pascal Titan X</li>\n<li><strong>Exact command to reproduce</strong>:</li>\n</ul>\n<h3>Describe the problem</h3>\n<p>To feed raw images with floating type saved in tfrecord, I am using slim.tfexample_decoder.TFExampleDecoder().</p>\n<p>The problem is if I set the dtype of raw image to tf.float32, the function doesn't work with following error messages.</p>\n<pre><code>Traceback (most recent call last):\n  File \"train.py\", line 475, in &lt;module&gt;\n    tf.app.run()\n  File \"/home/jhkang/tools/anaconda3/lib/python3.6/site-packages/tensorflow/python/platform/app.py\", line 48, in run\n    _sys.exit(main(_sys.argv[:1] + flags_passthrough))\n  File \"train.py\", line 304, in main\n    common_queue_min=10 * FLAGS.batch_size)\n  File \"/home/jhkang/tools/anaconda3/lib/python3.6/site-packages/tensorflow/contrib/slim/python/slim/data/dataset_data_provider.py\", line 97, in __init__\n    tensors = dataset.decoder.decode(data, items)\n  File \"/home/jhkang/tools/anaconda3/lib/python3.6/site-packages/tensorflow/contrib/slim/python/slim/data/tfexample_decoder.py\", line 427, in decode\n    outputs.append(handler.tensors_to_item(keys_to_tensors))\n  File \"/home/jhkang/tools/anaconda3/lib/python3.6/site-packages/tensorflow/contrib/slim/python/slim/data/tfexample_decoder.py\", line 324, in tensors_to_item\n    return self._decode(image_buffer, image_format)\n  File \"/home/jhkang/tools/anaconda3/lib/python3.6/site-packages/tensorflow/contrib/slim/python/slim/data/tfexample_decoder.py\", line 353, in _decode\n    pred_fn_pairs, default=decode_image, exclusive=True)\n  File \"/home/jhkang/tools/anaconda3/lib/python3.6/site-packages/tensorflow/python/ops/control_flow_ops.py\", line 3262, in case\n    case_seq = _build_case()\n  File \"/home/jhkang/tools/anaconda3/lib/python3.6/site-packages/tensorflow/python/ops/control_flow_ops.py\", line 3257, in _build_case\n    strict=strict, name=\"If_%d\" % i)\n  File \"/home/jhkang/tools/anaconda3/lib/python3.6/site-packages/tensorflow/python/util/deprecation.py\", line 316, in new_func\n    return func(*args, **kwargs)\n  File \"/home/jhkang/tools/anaconda3/lib/python3.6/site-packages/tensorflow/python/ops/control_flow_ops.py\", line 1902, in cond\n    (val_x.dtype.name, val_y.dtype.name))\nValueError: Outputs of true_fn and false_fn must have the same type: float32, uint8\n\n</code></pre>\n<p>To see what the problem is, I checked the <code>slim/data/tfexample_decoder.py</code>.<br>\nI figured out that there is a <code>case()</code> function in <code> _decode()</code> of <code>class Image</code>, and if I set dtype for the raw image as other than uint8, then, the returning tensors' dtypes from <code>decode_image()</code> and <code>decode_raw()</code> used in <code>case()</code> are always mis-matched. You can check the code in below.</p>\n<pre><code> def _decode(self, image_buffer, image_format):\n    \"\"\"Decodes the image buffer.\n    Args:\n      image_buffer: The tensor representing the encoded image tensor.\n      image_format: The image format for the image in `image_buffer`. If image\n        format is `raw`, all images are expected to be in this format, otherwise\n        this op can decode a mix of `jpg` and `png` formats.\n    Returns:\n      A tensor that represents decoded image of self._shape, or\n      (?, ?, self._channels) if self._shape is not specified.\n    \"\"\"\n    def decode_image():\n      \"\"\"Decodes a png or jpg based on the headers.\"\"\"\n      return image_ops.decode_image(image_buffer, self._channels)\n\n    def decode_raw():\n      \"\"\"Decodes a raw image.\"\"\"\n      return parsing_ops.decode_raw(image_buffer, out_type=self._dtype)\n\n    pred_fn_pairs = {\n        math_ops.logical_or(\n            math_ops.equal(image_format, 'raw'),\n            math_ops.equal(image_format, 'RAW')): decode_raw,\n    }\n    image = control_flow_ops.case(\n        pred_fn_pairs, default=decode_image, exclusive=True)\n\n    image.set_shape([None, None, self._channels])\n    if self._shape is not None:\n      image = array_ops.reshape(image, self._shape)\n\n    return image\n</code></pre>\n<p>The returning tensor of <code> return image_ops.decode_image(image_buffer, self._channels)</code> only supports uint8 type of tensors.<br>\nTo fix this problem, I changed the previous code into the following code.<br>\n<code>return math_ops.cast(image_ops.decode_image(image_buffer, self._channels), self._dtype)</code></p>\n<h3>Source code / logs</h3>\n<p>I am attaching my source code for feeding dataset from tfrecord using slim.</p>\n<pre><code>from __future__ import absolute_import, division, print_function\n\nimport os\n\nimport tensorflow as tf\n\nfrom datasets import dataset_utils\n\nslim = tf.contrib.slim\n\n_FILE_PATTERN = '%s_*.tfrecord'\n\nSPLITS_TO_SIZES = {'train': 24523, 'validation': 6130} # lineGT 20180112\n_NUM_CLASSES = 10\n\n_ITEMS_TO_DESCRIPTIONS = {\n    'intensity': 'an intensity map',\n    'heightmap': 'an heightmap map',\n    'label': 'Ground truth segmentation mask',\n}\n\n\ndef get_split(split_name, dataset_dir, file_pattern=None, reader=None):\n  if split_name not in SPLITS_TO_SIZES:\n    raise ValueError('split name %s was not recognized.' % split_name)\n\n  if not file_pattern:\n    file_pattern = _FILE_PATTERN\n  file_pattern = os.path.join(dataset_dir, file_pattern % split_name)\n  print(file_pattern)\n  # Allowing None in the signature so that dataset_factory can use the\n  # default.\n  if reader is None:\n    reader = tf.TFRecordReader\n\n  keys_to_features = {\n      'image/intensity':\n          tf.FixedLenFeature(\n              (), tf.string, default_value=''),\n      'image/format':\n          tf.FixedLenFeature(\n              (), tf.string, default_value='raw'),\n      'image/height':\n          tf.FixedLenFeature(\n              (), tf.int64, default_value=0),\n      'image/width':\n          tf.FixedLenFeature(\n              (), tf.int64, default_value=0),\n      'image/mask':\n          tf.FixedLenFeature(\n              (), tf.string, default_value=''),\n      'image/mask/format':\n          tf.FixedLenFeature(\n              (), tf.string, default_value='raw'),\n      'image/heightmap':\n          tf.FixedLenFeature(\n              (), tf.string, default_value=''),\n      'image/heightmap/format':\n          tf.FixedLenFeature(\n              (), tf.string, default_value='raw'),\n      'image/filename':\n          tf.FixedLenFeature(\n              (), tf.string, default_value=''),\n  }\n\n  items_to_handlers = {\n      'intensity':\n          slim.tfexample_decoder.Image(\n            'image/intensity', 'image/format', channels=1, dtype=tf.float32),\n      'heightmap':\n          slim.tfexample_decoder.Image(\n            'image/heightmap', 'image/heightmap/format', channels=1, dtype=tf.float32),\n      'label':\n          slim.tfexample_decoder.Image(\n            'image/mask', 'image/mask/format', channels=1),\n      'height':\n          slim.tfexample_decoder.Tensor('image/height'),\n      'width':\n          slim.tfexample_decoder.Tensor('image/width'),\n      'fileid':\n          slim.tfexample_decoder.Tensor('image/filename'),\n  }\n\n  decoder = slim.tfexample_decoder.TFExampleDecoder(keys_to_features,\n                                                    items_to_handlers)\n\n  labels_to_names = None\n\n  return slim.dataset.Dataset(\n      data_sources=file_pattern,\n      reader=reader,\n      decoder=decoder,\n      num_samples=SPLITS_TO_SIZES[split_name],\n      items_to_descriptions=_ITEMS_TO_DESCRIPTIONS,\n      num_classes=_NUM_CLASSES,\n      labels_to_names=labels_to_names)\n</code></pre>", "body_text": "System information\n\nHave I written custom code (as opposed to using a stock example script provided in TensorFlow): No.\nOS Platform and Distribution (e.g., Linux Ubuntu 16.04): 16.04\nTensorFlow installed from (source or binary): binary\nTensorFlow version (use command below): 'unkown', '1.4.0-rc0'\nPython version: 2.7.13\nBazel version (if compiling from source):\nGCC/Compiler version (if compiling from source):\nCUDA/cuDNN version: 9.0/7.0.3\nGPU model and memory: Pascal Titan X\nExact command to reproduce:\n\nDescribe the problem\nTo feed raw images with floating type saved in tfrecord, I am using slim.tfexample_decoder.TFExampleDecoder().\nThe problem is if I set the dtype of raw image to tf.float32, the function doesn't work with following error messages.\nTraceback (most recent call last):\n  File \"train.py\", line 475, in <module>\n    tf.app.run()\n  File \"/home/jhkang/tools/anaconda3/lib/python3.6/site-packages/tensorflow/python/platform/app.py\", line 48, in run\n    _sys.exit(main(_sys.argv[:1] + flags_passthrough))\n  File \"train.py\", line 304, in main\n    common_queue_min=10 * FLAGS.batch_size)\n  File \"/home/jhkang/tools/anaconda3/lib/python3.6/site-packages/tensorflow/contrib/slim/python/slim/data/dataset_data_provider.py\", line 97, in __init__\n    tensors = dataset.decoder.decode(data, items)\n  File \"/home/jhkang/tools/anaconda3/lib/python3.6/site-packages/tensorflow/contrib/slim/python/slim/data/tfexample_decoder.py\", line 427, in decode\n    outputs.append(handler.tensors_to_item(keys_to_tensors))\n  File \"/home/jhkang/tools/anaconda3/lib/python3.6/site-packages/tensorflow/contrib/slim/python/slim/data/tfexample_decoder.py\", line 324, in tensors_to_item\n    return self._decode(image_buffer, image_format)\n  File \"/home/jhkang/tools/anaconda3/lib/python3.6/site-packages/tensorflow/contrib/slim/python/slim/data/tfexample_decoder.py\", line 353, in _decode\n    pred_fn_pairs, default=decode_image, exclusive=True)\n  File \"/home/jhkang/tools/anaconda3/lib/python3.6/site-packages/tensorflow/python/ops/control_flow_ops.py\", line 3262, in case\n    case_seq = _build_case()\n  File \"/home/jhkang/tools/anaconda3/lib/python3.6/site-packages/tensorflow/python/ops/control_flow_ops.py\", line 3257, in _build_case\n    strict=strict, name=\"If_%d\" % i)\n  File \"/home/jhkang/tools/anaconda3/lib/python3.6/site-packages/tensorflow/python/util/deprecation.py\", line 316, in new_func\n    return func(*args, **kwargs)\n  File \"/home/jhkang/tools/anaconda3/lib/python3.6/site-packages/tensorflow/python/ops/control_flow_ops.py\", line 1902, in cond\n    (val_x.dtype.name, val_y.dtype.name))\nValueError: Outputs of true_fn and false_fn must have the same type: float32, uint8\n\n\nTo see what the problem is, I checked the slim/data/tfexample_decoder.py.\nI figured out that there is a case() function in  _decode() of class Image, and if I set dtype for the raw image as other than uint8, then, the returning tensors' dtypes from decode_image() and decode_raw() used in case() are always mis-matched. You can check the code in below.\n def _decode(self, image_buffer, image_format):\n    \"\"\"Decodes the image buffer.\n    Args:\n      image_buffer: The tensor representing the encoded image tensor.\n      image_format: The image format for the image in `image_buffer`. If image\n        format is `raw`, all images are expected to be in this format, otherwise\n        this op can decode a mix of `jpg` and `png` formats.\n    Returns:\n      A tensor that represents decoded image of self._shape, or\n      (?, ?, self._channels) if self._shape is not specified.\n    \"\"\"\n    def decode_image():\n      \"\"\"Decodes a png or jpg based on the headers.\"\"\"\n      return image_ops.decode_image(image_buffer, self._channels)\n\n    def decode_raw():\n      \"\"\"Decodes a raw image.\"\"\"\n      return parsing_ops.decode_raw(image_buffer, out_type=self._dtype)\n\n    pred_fn_pairs = {\n        math_ops.logical_or(\n            math_ops.equal(image_format, 'raw'),\n            math_ops.equal(image_format, 'RAW')): decode_raw,\n    }\n    image = control_flow_ops.case(\n        pred_fn_pairs, default=decode_image, exclusive=True)\n\n    image.set_shape([None, None, self._channels])\n    if self._shape is not None:\n      image = array_ops.reshape(image, self._shape)\n\n    return image\n\nThe returning tensor of  return image_ops.decode_image(image_buffer, self._channels) only supports uint8 type of tensors.\nTo fix this problem, I changed the previous code into the following code.\nreturn math_ops.cast(image_ops.decode_image(image_buffer, self._channels), self._dtype)\nSource code / logs\nI am attaching my source code for feeding dataset from tfrecord using slim.\nfrom __future__ import absolute_import, division, print_function\n\nimport os\n\nimport tensorflow as tf\n\nfrom datasets import dataset_utils\n\nslim = tf.contrib.slim\n\n_FILE_PATTERN = '%s_*.tfrecord'\n\nSPLITS_TO_SIZES = {'train': 24523, 'validation': 6130} # lineGT 20180112\n_NUM_CLASSES = 10\n\n_ITEMS_TO_DESCRIPTIONS = {\n    'intensity': 'an intensity map',\n    'heightmap': 'an heightmap map',\n    'label': 'Ground truth segmentation mask',\n}\n\n\ndef get_split(split_name, dataset_dir, file_pattern=None, reader=None):\n  if split_name not in SPLITS_TO_SIZES:\n    raise ValueError('split name %s was not recognized.' % split_name)\n\n  if not file_pattern:\n    file_pattern = _FILE_PATTERN\n  file_pattern = os.path.join(dataset_dir, file_pattern % split_name)\n  print(file_pattern)\n  # Allowing None in the signature so that dataset_factory can use the\n  # default.\n  if reader is None:\n    reader = tf.TFRecordReader\n\n  keys_to_features = {\n      'image/intensity':\n          tf.FixedLenFeature(\n              (), tf.string, default_value=''),\n      'image/format':\n          tf.FixedLenFeature(\n              (), tf.string, default_value='raw'),\n      'image/height':\n          tf.FixedLenFeature(\n              (), tf.int64, default_value=0),\n      'image/width':\n          tf.FixedLenFeature(\n              (), tf.int64, default_value=0),\n      'image/mask':\n          tf.FixedLenFeature(\n              (), tf.string, default_value=''),\n      'image/mask/format':\n          tf.FixedLenFeature(\n              (), tf.string, default_value='raw'),\n      'image/heightmap':\n          tf.FixedLenFeature(\n              (), tf.string, default_value=''),\n      'image/heightmap/format':\n          tf.FixedLenFeature(\n              (), tf.string, default_value='raw'),\n      'image/filename':\n          tf.FixedLenFeature(\n              (), tf.string, default_value=''),\n  }\n\n  items_to_handlers = {\n      'intensity':\n          slim.tfexample_decoder.Image(\n            'image/intensity', 'image/format', channels=1, dtype=tf.float32),\n      'heightmap':\n          slim.tfexample_decoder.Image(\n            'image/heightmap', 'image/heightmap/format', channels=1, dtype=tf.float32),\n      'label':\n          slim.tfexample_decoder.Image(\n            'image/mask', 'image/mask/format', channels=1),\n      'height':\n          slim.tfexample_decoder.Tensor('image/height'),\n      'width':\n          slim.tfexample_decoder.Tensor('image/width'),\n      'fileid':\n          slim.tfexample_decoder.Tensor('image/filename'),\n  }\n\n  decoder = slim.tfexample_decoder.TFExampleDecoder(keys_to_features,\n                                                    items_to_handlers)\n\n  labels_to_names = None\n\n  return slim.dataset.Dataset(\n      data_sources=file_pattern,\n      reader=reader,\n      decoder=decoder,\n      num_samples=SPLITS_TO_SIZES[split_name],\n      items_to_descriptions=_ITEMS_TO_DESCRIPTIONS,\n      num_classes=_NUM_CLASSES,\n      labels_to_names=labels_to_names)", "body": "### System information\r\n- **Have I written custom code (as opposed to using a stock example script provided in TensorFlow)**: No.\r\n- **OS Platform and Distribution (e.g., Linux Ubuntu 16.04)**: 16.04\r\n- **TensorFlow installed from (source or binary)**: binary\r\n- **TensorFlow version (use command below)**: 'unkown', '1.4.0-rc0'\r\n- **Python version**: 2.7.13\r\n- **Bazel version (if compiling from source)**:\r\n- **GCC/Compiler version (if compiling from source)**:\r\n- **CUDA/cuDNN version**: 9.0/7.0.3\r\n- **GPU model and memory**: Pascal Titan X\r\n- **Exact command to reproduce**:\r\n\r\n### Describe the problem\r\n\r\nTo feed raw images with floating type saved in tfrecord, I am using slim.tfexample_decoder.TFExampleDecoder().\r\n\r\nThe problem is if I set the dtype of raw image to tf.float32, the function doesn't work with following error messages. \r\n\r\n```\r\nTraceback (most recent call last):\r\n  File \"train.py\", line 475, in <module>\r\n    tf.app.run()\r\n  File \"/home/jhkang/tools/anaconda3/lib/python3.6/site-packages/tensorflow/python/platform/app.py\", line 48, in run\r\n    _sys.exit(main(_sys.argv[:1] + flags_passthrough))\r\n  File \"train.py\", line 304, in main\r\n    common_queue_min=10 * FLAGS.batch_size)\r\n  File \"/home/jhkang/tools/anaconda3/lib/python3.6/site-packages/tensorflow/contrib/slim/python/slim/data/dataset_data_provider.py\", line 97, in __init__\r\n    tensors = dataset.decoder.decode(data, items)\r\n  File \"/home/jhkang/tools/anaconda3/lib/python3.6/site-packages/tensorflow/contrib/slim/python/slim/data/tfexample_decoder.py\", line 427, in decode\r\n    outputs.append(handler.tensors_to_item(keys_to_tensors))\r\n  File \"/home/jhkang/tools/anaconda3/lib/python3.6/site-packages/tensorflow/contrib/slim/python/slim/data/tfexample_decoder.py\", line 324, in tensors_to_item\r\n    return self._decode(image_buffer, image_format)\r\n  File \"/home/jhkang/tools/anaconda3/lib/python3.6/site-packages/tensorflow/contrib/slim/python/slim/data/tfexample_decoder.py\", line 353, in _decode\r\n    pred_fn_pairs, default=decode_image, exclusive=True)\r\n  File \"/home/jhkang/tools/anaconda3/lib/python3.6/site-packages/tensorflow/python/ops/control_flow_ops.py\", line 3262, in case\r\n    case_seq = _build_case()\r\n  File \"/home/jhkang/tools/anaconda3/lib/python3.6/site-packages/tensorflow/python/ops/control_flow_ops.py\", line 3257, in _build_case\r\n    strict=strict, name=\"If_%d\" % i)\r\n  File \"/home/jhkang/tools/anaconda3/lib/python3.6/site-packages/tensorflow/python/util/deprecation.py\", line 316, in new_func\r\n    return func(*args, **kwargs)\r\n  File \"/home/jhkang/tools/anaconda3/lib/python3.6/site-packages/tensorflow/python/ops/control_flow_ops.py\", line 1902, in cond\r\n    (val_x.dtype.name, val_y.dtype.name))\r\nValueError: Outputs of true_fn and false_fn must have the same type: float32, uint8\r\n\r\n```\r\n\r\nTo see what the problem is, I checked the ``slim/data/tfexample_decoder.py``.\r\nI figured out that there is a ``case()`` function in `` _decode()`` of ``class Image``, and if I set dtype for the raw image as other than uint8, then, the returning tensors' dtypes from ``decode_image()`` and ``decode_raw()`` used in ``case()`` are always mis-matched. You can check the code in below.\r\n\r\n```\r\n def _decode(self, image_buffer, image_format):\r\n    \"\"\"Decodes the image buffer.\r\n    Args:\r\n      image_buffer: The tensor representing the encoded image tensor.\r\n      image_format: The image format for the image in `image_buffer`. If image\r\n        format is `raw`, all images are expected to be in this format, otherwise\r\n        this op can decode a mix of `jpg` and `png` formats.\r\n    Returns:\r\n      A tensor that represents decoded image of self._shape, or\r\n      (?, ?, self._channels) if self._shape is not specified.\r\n    \"\"\"\r\n    def decode_image():\r\n      \"\"\"Decodes a png or jpg based on the headers.\"\"\"\r\n      return image_ops.decode_image(image_buffer, self._channels)\r\n\r\n    def decode_raw():\r\n      \"\"\"Decodes a raw image.\"\"\"\r\n      return parsing_ops.decode_raw(image_buffer, out_type=self._dtype)\r\n\r\n    pred_fn_pairs = {\r\n        math_ops.logical_or(\r\n            math_ops.equal(image_format, 'raw'),\r\n            math_ops.equal(image_format, 'RAW')): decode_raw,\r\n    }\r\n    image = control_flow_ops.case(\r\n        pred_fn_pairs, default=decode_image, exclusive=True)\r\n\r\n    image.set_shape([None, None, self._channels])\r\n    if self._shape is not None:\r\n      image = array_ops.reshape(image, self._shape)\r\n\r\n    return image\r\n```\r\nThe returning tensor of `` return image_ops.decode_image(image_buffer, self._channels)`` only supports uint8 type of tensors.  \r\nTo fix this problem, I changed the previous code into the following code. \r\n``return math_ops.cast(image_ops.decode_image(image_buffer, self._channels), self._dtype)``\r\n\r\n### Source code / logs\r\nI am attaching my source code for feeding dataset from tfrecord using slim.\r\n\r\n```\r\nfrom __future__ import absolute_import, division, print_function\r\n\r\nimport os\r\n\r\nimport tensorflow as tf\r\n\r\nfrom datasets import dataset_utils\r\n\r\nslim = tf.contrib.slim\r\n\r\n_FILE_PATTERN = '%s_*.tfrecord'\r\n\r\nSPLITS_TO_SIZES = {'train': 24523, 'validation': 6130} # lineGT 20180112\r\n_NUM_CLASSES = 10\r\n\r\n_ITEMS_TO_DESCRIPTIONS = {\r\n    'intensity': 'an intensity map',\r\n    'heightmap': 'an heightmap map',\r\n    'label': 'Ground truth segmentation mask',\r\n}\r\n\r\n\r\ndef get_split(split_name, dataset_dir, file_pattern=None, reader=None):\r\n  if split_name not in SPLITS_TO_SIZES:\r\n    raise ValueError('split name %s was not recognized.' % split_name)\r\n\r\n  if not file_pattern:\r\n    file_pattern = _FILE_PATTERN\r\n  file_pattern = os.path.join(dataset_dir, file_pattern % split_name)\r\n  print(file_pattern)\r\n  # Allowing None in the signature so that dataset_factory can use the\r\n  # default.\r\n  if reader is None:\r\n    reader = tf.TFRecordReader\r\n\r\n  keys_to_features = {\r\n      'image/intensity':\r\n          tf.FixedLenFeature(\r\n              (), tf.string, default_value=''),\r\n      'image/format':\r\n          tf.FixedLenFeature(\r\n              (), tf.string, default_value='raw'),\r\n      'image/height':\r\n          tf.FixedLenFeature(\r\n              (), tf.int64, default_value=0),\r\n      'image/width':\r\n          tf.FixedLenFeature(\r\n              (), tf.int64, default_value=0),\r\n      'image/mask':\r\n          tf.FixedLenFeature(\r\n              (), tf.string, default_value=''),\r\n      'image/mask/format':\r\n          tf.FixedLenFeature(\r\n              (), tf.string, default_value='raw'),\r\n      'image/heightmap':\r\n          tf.FixedLenFeature(\r\n              (), tf.string, default_value=''),\r\n      'image/heightmap/format':\r\n          tf.FixedLenFeature(\r\n              (), tf.string, default_value='raw'),\r\n      'image/filename':\r\n          tf.FixedLenFeature(\r\n              (), tf.string, default_value=''),\r\n  }\r\n\r\n  items_to_handlers = {\r\n      'intensity':\r\n          slim.tfexample_decoder.Image(\r\n            'image/intensity', 'image/format', channels=1, dtype=tf.float32),\r\n      'heightmap':\r\n          slim.tfexample_decoder.Image(\r\n            'image/heightmap', 'image/heightmap/format', channels=1, dtype=tf.float32),\r\n      'label':\r\n          slim.tfexample_decoder.Image(\r\n            'image/mask', 'image/mask/format', channels=1),\r\n      'height':\r\n          slim.tfexample_decoder.Tensor('image/height'),\r\n      'width':\r\n          slim.tfexample_decoder.Tensor('image/width'),\r\n      'fileid':\r\n          slim.tfexample_decoder.Tensor('image/filename'),\r\n  }\r\n\r\n  decoder = slim.tfexample_decoder.TFExampleDecoder(keys_to_features,\r\n                                                    items_to_handlers)\r\n\r\n  labels_to_names = None\r\n\r\n  return slim.dataset.Dataset(\r\n      data_sources=file_pattern,\r\n      reader=reader,\r\n      decoder=decoder,\r\n      num_samples=SPLITS_TO_SIZES[split_name],\r\n      items_to_descriptions=_ITEMS_TO_DESCRIPTIONS,\r\n      num_classes=_NUM_CLASSES,\r\n      labels_to_names=labels_to_names)\r\n```"}