{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13228", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13228/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13228/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13228/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/13228", "id": 259732595, "node_id": "MDU6SXNzdWUyNTk3MzI1OTU=", "number": 13228, "title": "add image gradient op", "user": {"login": "bodokaiser", "id": 1780466, "node_id": "MDQ6VXNlcjE3ODA0NjY=", "avatar_url": "https://avatars0.githubusercontent.com/u/1780466?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bodokaiser", "html_url": "https://github.com/bodokaiser", "followers_url": "https://api.github.com/users/bodokaiser/followers", "following_url": "https://api.github.com/users/bodokaiser/following{/other_user}", "gists_url": "https://api.github.com/users/bodokaiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/bodokaiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bodokaiser/subscriptions", "organizations_url": "https://api.github.com/users/bodokaiser/orgs", "repos_url": "https://api.github.com/users/bodokaiser/repos", "events_url": "https://api.github.com/users/bodokaiser/events{/privacy}", "received_events_url": "https://api.github.com/users/bodokaiser/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 404586594, "node_id": "MDU6TGFiZWw0MDQ1ODY1OTQ=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:awaiting%20tensorflower", "name": "stat:awaiting tensorflower", "color": "f4b400", "default": false}, {"id": 473173272, "node_id": "MDU6TGFiZWw0NzMxNzMyNzI=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:feature", "name": "type:feature", "color": "159b2e", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2017-09-22T07:55:05Z", "updated_at": "2017-12-25T12:21:34Z", "closed_at": "2017-09-23T07:09:22Z", "author_association": "NONE", "body_html": "<p>A <a href=\"https://arxiv.org/abs/1612.05362\" rel=\"nofollow\">paper</a> I am reimplementing recently uses <a href=\"https://en.wikipedia.org/wiki/Image_gradient\" rel=\"nofollow\">image gradient loss</a>. Numpy offers <a href=\"https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.gradient.html\" rel=\"nofollow\">np.gradient</a> to achieve this task i.e. <code>np.gradient(image, axis=0), np.gradient(image, axis=1)</code> however tensorflow lacks this feature or at least documentation about how to use <code>tf.gradients</code> to get this done.</p>\n<p>Therefore I propose to either send a PR where I add a gradient image op which uses fixed 2d convolution, i.e.:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">import</span> numpy <span class=\"pl-k\">as</span> np\n<span class=\"pl-k\">import</span> scipy <span class=\"pl-k\">as</span> sp\n<span class=\"pl-k\">import</span> tensorflow <span class=\"pl-k\">as</span> tf\n\n<span class=\"pl-k\">from</span> skimage <span class=\"pl-k\">import</span> io\n<span class=\"pl-k\">from</span> skimage <span class=\"pl-k\">import</span> color\n\n<span class=\"pl-k\">from</span> matplotlib <span class=\"pl-k\">import</span> pyplot <span class=\"pl-k\">as</span> plt\n\nimage <span class=\"pl-k\">=</span> color.rgb2gray(io.imread(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>image.jpg<span class=\"pl-pds\">'</span></span>))\nimage_rs <span class=\"pl-k\">=</span> image.reshape([<span class=\"pl-c1\">1</span>] <span class=\"pl-k\">+</span> <span class=\"pl-c1\">list</span>(image.shape) <span class=\"pl-k\">+</span> [<span class=\"pl-c1\">1</span>])\n\nxgrad <span class=\"pl-k\">=</span> np.gradient(image, <span class=\"pl-v\">axis</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">0</span>)\nygrad <span class=\"pl-k\">=</span> np.gradient(image, <span class=\"pl-v\">axis</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">1</span>)\n\nimage_ph <span class=\"pl-k\">=</span> tf.placeholder(tf.float32, image_rs.shape)\n\nx_weight <span class=\"pl-k\">=</span> tf.reshape(tf.constant([<span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">0</span>, <span class=\"pl-k\">+</span><span class=\"pl-c1\">1</span>], tf.float32), [<span class=\"pl-c1\">3</span>, <span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">1</span>])\ny_weight <span class=\"pl-k\">=</span> tf.reshape(x_weight, [<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">3</span>, <span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">1</span>])\n\nxgrad_ts <span class=\"pl-k\">=</span> tf.nn.conv2d(image_ph, x_weight, [<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">1</span>], <span class=\"pl-s\"><span class=\"pl-pds\">'</span>SAME<span class=\"pl-pds\">'</span></span>)\nygrad_ts <span class=\"pl-k\">=</span> tf.nn.conv2d(image_ph, y_weight, [<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">1</span>], <span class=\"pl-s\"><span class=\"pl-pds\">'</span>SAME<span class=\"pl-pds\">'</span></span>)\n\n<span class=\"pl-k\">with</span> tf.Session() <span class=\"pl-k\">as</span> sess:\n    xgrad2, ygrad2 <span class=\"pl-k\">=</span> sess.run([xgrad_ts, ygrad_ts], <span class=\"pl-v\">feed_dict</span><span class=\"pl-k\">=</span>{image_ph: image_rs})\n\n    <span class=\"pl-c1\">print</span>(xgrad2.shape)\n    fig, axes <span class=\"pl-k\">=</span> plt.subplots(<span class=\"pl-c1\">2</span>, <span class=\"pl-c1\">3</span>)\n    axes[<span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">0</span>].imshow(image)\n    axes[<span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">1</span>].imshow(xgrad)\n    axes[<span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">2</span>].imshow(ygrad)\n    axes[<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">0</span>].imshow(image)\n    axes[<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">1</span>].imshow(xgrad2[<span class=\"pl-c1\">0</span>,:,:,<span class=\"pl-c1\">0</span>])\n    axes[<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">2</span>].imshow(ygrad2[<span class=\"pl-c1\">0</span>,:,:,<span class=\"pl-c1\">0</span>])\n    plt.show()\n</pre></div>\n<p>or have someone update documentation of <code>tf.gradients</code>.</p>\n<p>For the first I could provide a PR if this is considered interesting for tensorflow and not \"too implementation specific\".</p>", "body_text": "A paper I am reimplementing recently uses image gradient loss. Numpy offers np.gradient to achieve this task i.e. np.gradient(image, axis=0), np.gradient(image, axis=1) however tensorflow lacks this feature or at least documentation about how to use tf.gradients to get this done.\nTherefore I propose to either send a PR where I add a gradient image op which uses fixed 2d convolution, i.e.:\nimport numpy as np\nimport scipy as sp\nimport tensorflow as tf\n\nfrom skimage import io\nfrom skimage import color\n\nfrom matplotlib import pyplot as plt\n\nimage = color.rgb2gray(io.imread('image.jpg'))\nimage_rs = image.reshape([1] + list(image.shape) + [1])\n\nxgrad = np.gradient(image, axis=0)\nygrad = np.gradient(image, axis=1)\n\nimage_ph = tf.placeholder(tf.float32, image_rs.shape)\n\nx_weight = tf.reshape(tf.constant([-1, 0, +1], tf.float32), [3, 1, 1, 1])\ny_weight = tf.reshape(x_weight, [1, 3, 1, 1])\n\nxgrad_ts = tf.nn.conv2d(image_ph, x_weight, [1, 1, 1, 1], 'SAME')\nygrad_ts = tf.nn.conv2d(image_ph, y_weight, [1, 1, 1, 1], 'SAME')\n\nwith tf.Session() as sess:\n    xgrad2, ygrad2 = sess.run([xgrad_ts, ygrad_ts], feed_dict={image_ph: image_rs})\n\n    print(xgrad2.shape)\n    fig, axes = plt.subplots(2, 3)\n    axes[0, 0].imshow(image)\n    axes[0, 1].imshow(xgrad)\n    axes[0, 2].imshow(ygrad)\n    axes[1, 0].imshow(image)\n    axes[1, 1].imshow(xgrad2[0,:,:,0])\n    axes[1, 2].imshow(ygrad2[0,:,:,0])\n    plt.show()\n\nor have someone update documentation of tf.gradients.\nFor the first I could provide a PR if this is considered interesting for tensorflow and not \"too implementation specific\".", "body": "A [paper][1] I am reimplementing recently uses [image gradient loss][2]. Numpy offers [np.gradient][3] to achieve this task i.e. `np.gradient(image, axis=0), np.gradient(image, axis=1)` however tensorflow lacks this feature or at least documentation about how to use `tf.gradients` to get this done.\r\n\r\nTherefore I propose to either send a PR where I add a gradient image op which uses fixed 2d convolution, i.e.:\r\n\r\n```python\r\nimport numpy as np\r\nimport scipy as sp\r\nimport tensorflow as tf\r\n\r\nfrom skimage import io\r\nfrom skimage import color\r\n\r\nfrom matplotlib import pyplot as plt\r\n\r\nimage = color.rgb2gray(io.imread('image.jpg'))\r\nimage_rs = image.reshape([1] + list(image.shape) + [1])\r\n\r\nxgrad = np.gradient(image, axis=0)\r\nygrad = np.gradient(image, axis=1)\r\n\r\nimage_ph = tf.placeholder(tf.float32, image_rs.shape)\r\n\r\nx_weight = tf.reshape(tf.constant([-1, 0, +1], tf.float32), [3, 1, 1, 1])\r\ny_weight = tf.reshape(x_weight, [1, 3, 1, 1])\r\n\r\nxgrad_ts = tf.nn.conv2d(image_ph, x_weight, [1, 1, 1, 1], 'SAME')\r\nygrad_ts = tf.nn.conv2d(image_ph, y_weight, [1, 1, 1, 1], 'SAME')\r\n\r\nwith tf.Session() as sess:\r\n    xgrad2, ygrad2 = sess.run([xgrad_ts, ygrad_ts], feed_dict={image_ph: image_rs})\r\n\r\n    print(xgrad2.shape)\r\n    fig, axes = plt.subplots(2, 3)\r\n    axes[0, 0].imshow(image)\r\n    axes[0, 1].imshow(xgrad)\r\n    axes[0, 2].imshow(ygrad)\r\n    axes[1, 0].imshow(image)\r\n    axes[1, 1].imshow(xgrad2[0,:,:,0])\r\n    axes[1, 2].imshow(ygrad2[0,:,:,0])\r\n    plt.show()\r\n\r\n```\r\n\r\nor have someone update documentation of `tf.gradients`.\r\n\r\nFor the first I could provide a PR if this is considered interesting for tensorflow and not \"too implementation specific\".\r\n\r\n[1]: https://arxiv.org/abs/1612.05362\r\n[2]: https://en.wikipedia.org/wiki/Image_gradient\r\n[3]: https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.gradient.html\r\n"}