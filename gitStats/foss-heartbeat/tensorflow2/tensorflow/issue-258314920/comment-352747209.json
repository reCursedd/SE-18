{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/352747209", "html_url": "https://github.com/tensorflow/tensorflow/issues/13101#issuecomment-352747209", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13101", "id": 352747209, "node_id": "MDEyOklzc3VlQ29tbWVudDM1Mjc0NzIwOQ==", "user": {"login": "boeddeker", "id": 13744128, "node_id": "MDQ6VXNlcjEzNzQ0MTI4", "avatar_url": "https://avatars3.githubusercontent.com/u/13744128?v=4", "gravatar_id": "", "url": "https://api.github.com/users/boeddeker", "html_url": "https://github.com/boeddeker", "followers_url": "https://api.github.com/users/boeddeker/followers", "following_url": "https://api.github.com/users/boeddeker/following{/other_user}", "gists_url": "https://api.github.com/users/boeddeker/gists{/gist_id}", "starred_url": "https://api.github.com/users/boeddeker/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/boeddeker/subscriptions", "organizations_url": "https://api.github.com/users/boeddeker/orgs", "repos_url": "https://api.github.com/users/boeddeker/repos", "events_url": "https://api.github.com/users/boeddeker/events{/privacy}", "received_events_url": "https://api.github.com/users/boeddeker/received_events", "type": "User", "site_admin": false}, "created_at": "2017-12-19T13:23:16Z", "updated_at": "2017-12-19T13:23:16Z", "author_association": "CONTRIBUTOR", "body_html": "<p>I added a print to <code>__getitem__</code> and it printed 12 times for 4 cores with batch size 9. So there are 12 <code>__getitem__</code> calls.</p>\n<p>Further, I changed the sleep to only apply to one entry per <code>num_parallel_calls</code></p>\n<pre><code>        if item in [0, 4, 8]:\n            time.sleep(1)\n</code></pre>\n<p>and the slowest entry defined the runtime (i.e. 3 seconds, ideally it would take 1 second).<br>\nSo my conclusion is that <code>num_parallel_calls</code> follows the fork and join idea. It starts <code>num_parallel_calls</code> and waits until all of them have finished before launch the next <code>num_parallel_calls</code>.</p>\n<p>Maybe <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=192142\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/mrry\">@mrry</a> knows more about the internals, my knowledge is based on toy examples.</p>", "body_text": "I added a print to __getitem__ and it printed 12 times for 4 cores with batch size 9. So there are 12 __getitem__ calls.\nFurther, I changed the sleep to only apply to one entry per num_parallel_calls\n        if item in [0, 4, 8]:\n            time.sleep(1)\n\nand the slowest entry defined the runtime (i.e. 3 seconds, ideally it would take 1 second).\nSo my conclusion is that num_parallel_calls follows the fork and join idea. It starts num_parallel_calls and waits until all of them have finished before launch the next num_parallel_calls.\nMaybe @mrry knows more about the internals, my knowledge is based on toy examples.", "body": "I added a print to `__getitem__` and it printed 12 times for 4 cores with batch size 9. So there are 12 `__getitem__` calls.\r\n\r\nFurther, I changed the sleep to only apply to one entry per `num_parallel_calls`\r\n```\r\n        if item in [0, 4, 8]:\r\n            time.sleep(1)\r\n```\r\nand the slowest entry defined the runtime (i.e. 3 seconds, ideally it would take 1 second).\r\nSo my conclusion is that `num_parallel_calls` follows the fork and join idea. It starts `num_parallel_calls` and waits until all of them have finished before launch the next `num_parallel_calls`.\r\n\r\nMaybe @mrry knows more about the internals, my knowledge is based on toy examples.\r\n"}