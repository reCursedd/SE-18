{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/333042177", "html_url": "https://github.com/tensorflow/tensorflow/issues/7469#issuecomment-333042177", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/7469", "id": 333042177, "node_id": "MDEyOklzc3VlQ29tbWVudDMzMzA0MjE3Nw==", "user": {"login": "balansky", "id": 22044211, "node_id": "MDQ6VXNlcjIyMDQ0MjEx", "avatar_url": "https://avatars0.githubusercontent.com/u/22044211?v=4", "gravatar_id": "", "url": "https://api.github.com/users/balansky", "html_url": "https://github.com/balansky", "followers_url": "https://api.github.com/users/balansky/followers", "following_url": "https://api.github.com/users/balansky/following{/other_user}", "gists_url": "https://api.github.com/users/balansky/gists{/gist_id}", "starred_url": "https://api.github.com/users/balansky/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/balansky/subscriptions", "organizations_url": "https://api.github.com/users/balansky/orgs", "repos_url": "https://api.github.com/users/balansky/repos", "events_url": "https://api.github.com/users/balansky/events{/privacy}", "received_events_url": "https://api.github.com/users/balansky/received_events", "type": "User", "site_admin": false}, "created_at": "2017-09-29T06:28:41Z", "updated_at": "2017-09-29T06:28:41Z", "author_association": "NONE", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=8534653\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/soloice\">@soloice</a><br>\nfrom slim.create_train_op source code, you can see it calls update_ops for you. So, I think you don't really need to call update_op manually by using slim.create_train_op</p>\n<h1>Update ops use GraphKeys.UPDATE_OPS collection if update_ops is None.</h1>\n<p>global_update_ops = set(ops.get_collection(ops.GraphKeys.UPDATE_OPS))<br>\nif update_ops is None:<br>\nupdate_ops = global_update_ops<br>\nelse:<br>\nupdate_ops = set(update_ops)<br>\nif not global_update_ops.issubset(update_ops):<br>\nlogging.warning('update_ops in create_train_op does not contain all the '<br>\n' update_ops in GraphKeys.UPDATE_OPS')</p>\n<h1>Make sure update_ops are computed before total_loss.</h1>\n<p>if update_ops:<br>\nwith ops.control_dependencies(update_ops):<br>\nbarrier = control_flow_ops.no_op(name='update_barrier')<br>\ntotal_loss = control_flow_ops.with_dependencies([barrier], total_loss)</p>", "body_text": "@soloice\nfrom slim.create_train_op source code, you can see it calls update_ops for you. So, I think you don't really need to call update_op manually by using slim.create_train_op\nUpdate ops use GraphKeys.UPDATE_OPS collection if update_ops is None.\nglobal_update_ops = set(ops.get_collection(ops.GraphKeys.UPDATE_OPS))\nif update_ops is None:\nupdate_ops = global_update_ops\nelse:\nupdate_ops = set(update_ops)\nif not global_update_ops.issubset(update_ops):\nlogging.warning('update_ops in create_train_op does not contain all the '\n' update_ops in GraphKeys.UPDATE_OPS')\nMake sure update_ops are computed before total_loss.\nif update_ops:\nwith ops.control_dependencies(update_ops):\nbarrier = control_flow_ops.no_op(name='update_barrier')\ntotal_loss = control_flow_ops.with_dependencies([barrier], total_loss)", "body": "@soloice \r\nfrom slim.create_train_op source code, you can see it calls update_ops for you. So, I think you don't really need to call update_op manually by using slim.create_train_op\r\n\r\n# Update ops use GraphKeys.UPDATE_OPS collection if update_ops is None.\r\n global_update_ops = set(ops.get_collection(ops.GraphKeys.UPDATE_OPS))\r\n if update_ops is None:\r\n    update_ops = global_update_ops\r\n  else:\r\n    update_ops = set(update_ops)\r\n  if not global_update_ops.issubset(update_ops):\r\n    logging.warning('update_ops in create_train_op does not contain all the '\r\n                    ' update_ops in GraphKeys.UPDATE_OPS')\r\n\r\n  # Make sure update_ops are computed before total_loss.\r\n  if update_ops:\r\n    with ops.control_dependencies(update_ops):\r\n      barrier = control_flow_ops.no_op(name='update_barrier')\r\n    total_loss = control_flow_ops.with_dependencies([barrier], total_loss)"}