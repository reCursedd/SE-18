{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/19279", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/19279/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/19279/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/19279/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/19279", "id": 322978214, "node_id": "MDU6SXNzdWUzMjI5NzgyMTQ=", "number": 19279, "title": "Feature Request: serialising checkpoints and models to byte arrays", "user": {"login": "Craigacp", "id": 729696, "node_id": "MDQ6VXNlcjcyOTY5Ng==", "avatar_url": "https://avatars1.githubusercontent.com/u/729696?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Craigacp", "html_url": "https://github.com/Craigacp", "followers_url": "https://api.github.com/users/Craigacp/followers", "following_url": "https://api.github.com/users/Craigacp/following{/other_user}", "gists_url": "https://api.github.com/users/Craigacp/gists{/gist_id}", "starred_url": "https://api.github.com/users/Craigacp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Craigacp/subscriptions", "organizations_url": "https://api.github.com/users/Craigacp/orgs", "repos_url": "https://api.github.com/users/Craigacp/repos", "events_url": "https://api.github.com/users/Craigacp/events{/privacy}", "received_events_url": "https://api.github.com/users/Craigacp/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 386191887, "node_id": "MDU6TGFiZWwzODYxOTE4ODc=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:awaiting%20response", "name": "stat:awaiting response", "color": "f4b400", "default": false}, {"id": 473184161, "node_id": "MDU6TGFiZWw0NzMxODQxNjE=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:support", "name": "type:support", "color": "159b2e", "default": false}], "state": "closed", "locked": false, "assignee": {"login": "tatianashp", "id": 986732, "node_id": "MDQ6VXNlcjk4NjczMg==", "avatar_url": "https://avatars2.githubusercontent.com/u/986732?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tatianashp", "html_url": "https://github.com/tatianashp", "followers_url": "https://api.github.com/users/tatianashp/followers", "following_url": "https://api.github.com/users/tatianashp/following{/other_user}", "gists_url": "https://api.github.com/users/tatianashp/gists{/gist_id}", "starred_url": "https://api.github.com/users/tatianashp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tatianashp/subscriptions", "organizations_url": "https://api.github.com/users/tatianashp/orgs", "repos_url": "https://api.github.com/users/tatianashp/repos", "events_url": "https://api.github.com/users/tatianashp/events{/privacy}", "received_events_url": "https://api.github.com/users/tatianashp/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "tatianashp", "id": 986732, "node_id": "MDQ6VXNlcjk4NjczMg==", "avatar_url": "https://avatars2.githubusercontent.com/u/986732?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tatianashp", "html_url": "https://github.com/tatianashp", "followers_url": "https://api.github.com/users/tatianashp/followers", "following_url": "https://api.github.com/users/tatianashp/following{/other_user}", "gists_url": "https://api.github.com/users/tatianashp/gists{/gist_id}", "starred_url": "https://api.github.com/users/tatianashp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tatianashp/subscriptions", "organizations_url": "https://api.github.com/users/tatianashp/orgs", "repos_url": "https://api.github.com/users/tatianashp/repos", "events_url": "https://api.github.com/users/tatianashp/events{/privacy}", "received_events_url": "https://api.github.com/users/tatianashp/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 3, "created_at": "2018-05-14T20:55:53Z", "updated_at": "2018-05-18T02:33:36Z", "closed_at": "2018-05-18T00:45:53Z", "author_association": "NONE", "body_html": "<h3>System information</h3>\n<ul>\n<li><strong>Have I written custom code</strong>: Yes</li>\n<li><strong>OS Platform and Distribution</strong>: Linux, Oracle Linux 7.4</li>\n<li><strong>TensorFlow installed from</strong>: source</li>\n<li><strong>TensorFlow version</strong>: 1.7 &amp; 1.8</li>\n<li><strong>Python version</strong>: 2.7 &amp; 3.6</li>\n<li><strong>Bazel version</strong>: 0.11.1</li>\n<li><strong>GCC/Compiler version</strong>: 4.8.5</li>\n<li><strong>CUDA/cuDNN version</strong>: CUDA 9.0, cuDNN 7</li>\n<li><strong>GPU model and memory</strong>: Titan X</li>\n<li><strong>Exact command to reproduce</strong>: N/A</li>\n</ul>\n<h3>Describe the problem</h3>\n<p>I'm wrapping Tensorflow in a higher level Java prediction API, using the provided Tensorflow Java API. This higher level API controls the serialisation of models in a uniform way, allowing a user to serialise models to disk, or over the network, and to load models as resources from jar files or non-disk sources.</p>\n<p>I can train and test a model from Java, after creating the graph protobuf in Python, however the checkpointing and saved model functionality is extremely fragile as it requires specific structures in the filesystem. Currently I can either serialise a path to disk which means the model requires both the path to be valid as well as the serialised blob the high level API creates, or I can tar up the checkpoint/model bundle directory and serialise that as a byte array before untar-ing it to a temp directory and loading. Neither of these options are particularly satisfactory.</p>\n<p>I had originally considered adding an extra couple of tensor endpoints to Saver which accepted a byte array wrapped in a tensor, deserialising that into the session, and one which emitted a byte array which was a serialised form of that session, but given how far down the assumption of filesystem access is in a saver I'm not sure that's the right approach.</p>\n<p>I'm now thinking that adding another Saver class which has the byte array operations would be the best way to go. I'd like to contribute this back to tensorflow, so I thought it best to discuss the design first (and even if this kind of contribution is acceptable).</p>\n<p>My ultimate goal is to add a Java implementation of freeze_graph.py, as that operation would make prediction time deployment much simpler, but there would still be a checkpointing issue while a model is training. Given <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"301934772\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/tensorflow/tensorflow/issues/17390\" data-hovercard-type=\"issue\" data-hovercard-url=\"/tensorflow/tensorflow/issues/17390/hovercard\" href=\"https://github.com/tensorflow/tensorflow/issues/17390\">#17390</a> I'm not sure if the Java API has enough operations implemented to freeze a model yet.</p>", "body_text": "System information\n\nHave I written custom code: Yes\nOS Platform and Distribution: Linux, Oracle Linux 7.4\nTensorFlow installed from: source\nTensorFlow version: 1.7 & 1.8\nPython version: 2.7 & 3.6\nBazel version: 0.11.1\nGCC/Compiler version: 4.8.5\nCUDA/cuDNN version: CUDA 9.0, cuDNN 7\nGPU model and memory: Titan X\nExact command to reproduce: N/A\n\nDescribe the problem\nI'm wrapping Tensorflow in a higher level Java prediction API, using the provided Tensorflow Java API. This higher level API controls the serialisation of models in a uniform way, allowing a user to serialise models to disk, or over the network, and to load models as resources from jar files or non-disk sources.\nI can train and test a model from Java, after creating the graph protobuf in Python, however the checkpointing and saved model functionality is extremely fragile as it requires specific structures in the filesystem. Currently I can either serialise a path to disk which means the model requires both the path to be valid as well as the serialised blob the high level API creates, or I can tar up the checkpoint/model bundle directory and serialise that as a byte array before untar-ing it to a temp directory and loading. Neither of these options are particularly satisfactory.\nI had originally considered adding an extra couple of tensor endpoints to Saver which accepted a byte array wrapped in a tensor, deserialising that into the session, and one which emitted a byte array which was a serialised form of that session, but given how far down the assumption of filesystem access is in a saver I'm not sure that's the right approach.\nI'm now thinking that adding another Saver class which has the byte array operations would be the best way to go. I'd like to contribute this back to tensorflow, so I thought it best to discuss the design first (and even if this kind of contribution is acceptable).\nMy ultimate goal is to add a Java implementation of freeze_graph.py, as that operation would make prediction time deployment much simpler, but there would still be a checkpointing issue while a model is training. Given #17390 I'm not sure if the Java API has enough operations implemented to freeze a model yet.", "body": "### System information\r\n- **Have I written custom code**: Yes\r\n- **OS Platform and Distribution**: Linux, Oracle Linux 7.4\r\n- **TensorFlow installed from**: source\r\n- **TensorFlow version**: 1.7 & 1.8\r\n- **Python version**: 2.7 & 3.6\r\n- **Bazel version**: 0.11.1\r\n- **GCC/Compiler version**: 4.8.5\r\n- **CUDA/cuDNN version**: CUDA 9.0, cuDNN 7\r\n- **GPU model and memory**: Titan X\r\n- **Exact command to reproduce**: N/A\r\n\r\n### Describe the problem\r\nI'm wrapping Tensorflow in a higher level Java prediction API, using the provided Tensorflow Java API. This higher level API controls the serialisation of models in a uniform way, allowing a user to serialise models to disk, or over the network, and to load models as resources from jar files or non-disk sources.\r\n\r\nI can train and test a model from Java, after creating the graph protobuf in Python, however the checkpointing and saved model functionality is extremely fragile as it requires specific structures in the filesystem. Currently I can either serialise a path to disk which means the model requires both the path to be valid as well as the serialised blob the high level API creates, or I can tar up the checkpoint/model bundle directory and serialise that as a byte array before untar-ing it to a temp directory and loading. Neither of these options are particularly satisfactory.\r\n\r\nI had originally considered adding an extra couple of tensor endpoints to Saver which accepted a byte array wrapped in a tensor, deserialising that into the session, and one which emitted a byte array which was a serialised form of that session, but given how far down the assumption of filesystem access is in a saver I'm not sure that's the right approach.\r\n\r\nI'm now thinking that adding another Saver class which has the byte array operations would be the best way to go. I'd like to contribute this back to tensorflow, so I thought it best to discuss the design first (and even if this kind of contribution is acceptable).\r\n\r\nMy ultimate goal is to add a Java implementation of freeze_graph.py, as that operation would make prediction time deployment much simpler, but there would still be a checkpointing issue while a model is training. Given #17390 I'm not sure if the Java API has enough operations implemented to freeze a model yet.\r\n"}