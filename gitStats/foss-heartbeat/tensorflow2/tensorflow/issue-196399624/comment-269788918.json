{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/269788918", "html_url": "https://github.com/tensorflow/tensorflow/issues/6397#issuecomment-269788918", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/6397", "id": 269788918, "node_id": "MDEyOklzc3VlQ29tbWVudDI2OTc4ODkxOA==", "user": {"login": "Hvass-Labs", "id": 13588114, "node_id": "MDQ6VXNlcjEzNTg4MTE0", "avatar_url": "https://avatars2.githubusercontent.com/u/13588114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Hvass-Labs", "html_url": "https://github.com/Hvass-Labs", "followers_url": "https://api.github.com/users/Hvass-Labs/followers", "following_url": "https://api.github.com/users/Hvass-Labs/following{/other_user}", "gists_url": "https://api.github.com/users/Hvass-Labs/gists{/gist_id}", "starred_url": "https://api.github.com/users/Hvass-Labs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Hvass-Labs/subscriptions", "organizations_url": "https://api.github.com/users/Hvass-Labs/orgs", "repos_url": "https://api.github.com/users/Hvass-Labs/repos", "events_url": "https://api.github.com/users/Hvass-Labs/events{/privacy}", "received_events_url": "https://api.github.com/users/Hvass-Labs/received_events", "type": "User", "site_admin": false}, "created_at": "2016-12-30T16:10:09Z", "updated_at": "2016-12-30T16:10:09Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Thanks for the comments.</p>\n<p>Here is the function I propose. I have tried to follow the coding style in <code>image_ops_impl.py</code>, except for the indentation which I will fix to 2 spaces in the pull request, and my comments are more verbose because I find that helpful when reading code and quickly trying to grasp what the intention is.</p>\n<p>I did not use <code>_CheckAtLeast3DImage</code> because it requires the shape to be fully defined.</p>\n<p>Please have a look and let me know if this looks fine. Then I will make a pull request.</p>\n<pre><code>def total_variation(images, name=None):\n    \"\"\"Calculate and return the Total Variation for one or more images.\n\n    The total variation is the sum of the absolute differences for neighboring\n    pixel-values in the input images. This measures how much noise is in the images.\n\n    This can be used as a loss-function during optimization so as to suppress noise\n    in images. If you have a batch of images, then you should calculate the scalar\n    loss-value as the sum: `loss = tf.reduce_sum(tf.image.total_variation(images))`\n\n    This implements the anisotropic 2-D version of the formula described here:\n\n    https://en.wikipedia.org/wiki/Total_variation_denoising\n\n    Args:\n        images: 4-D Tensor of shape `[batch, height, width, channels]` or\n                3-D Tensor of shape `[height, width, channels]`.\n\n        name: A name for the operation (optional).\n\n    Raises:\n        ValueError: if images.shape is not a 3-D or 4-D vector.\n\n    Returns:\n        The total variation of `images`.\n\n        If `images` was 4-D, a 1-D float Tensor of shape `[batch]` with the\n        total variation for each image in the batch.\n        If `images` was 3-D, a scalar float with the total variation for that image.\n    \"\"\"\n\n    with ops.name_scope(name, 'total_variation'):\n        ndims = images.get_shape().ndims\n\n        if ndims == 3:\n            # The input is a single image with shape [height, width, channels].\n\n            # Calculate the difference of neighboring pixel-values.\n            # The images are shifted one pixel along the height and width by slicing.\n            pixel_dif1 = images[1:,:,:] - images[:-1,:,:]\n            pixel_dif2 = images[:,1:,:] - images[:,:-1,:]\n\n            # Sum for all axis. (None is an alias for all axis.)\n            sum_axis = None\n        elif ndims == 4:\n            # The input is a batch of images with shape [batch, height, width, channels].\n\n            # Calculate the difference of neighboring pixel-values.\n            # The images are shifted one pixel along the height and width by slicing.\n            pixel_dif1 = images[:,1:,:,:] - images[:,:-1,:,:]\n            pixel_dif2 = images[:,:,1:,:] - images[:,:,:-1,:]\n\n            # Only sum for the last 3 axis.\n            # This results in a 1-D tensor with the total variation for each image.\n            sum_axis = [1, 2, 3]\n        else:\n            raise ValueError('\\'images\\' must be either 3 or 4-dimensional.')\n\n        # Calculate the total variation by taking the absolute value of the\n        # pixel-differences and summing over the appropriate axis.\n        tot_var = tf.reduce_sum(tf.abs(pixel_dif1), axis=sum_axis) + \\\n                  tf.reduce_sum(tf.abs(pixel_dif2), axis=sum_axis)\n\n    return tot_var\n</code></pre>\n<h3>Testing</h3>\n<p>I have tested this in a Python Notebook, but it is messy and undocumented so I have not put it online. If you would like to run these tests yourself then I can cleanup the Notebook and put it online somewhere. (Where?)</p>\n<p>I have tested both single- and multi-image input tensors. I have also tested incorrect inputs such as None, too low and too high dimensions. I have done a basic gradient descent and it produces the same results for a single and multiple input images, provided you use <code>tf.reduce_sum()</code> in the loss-function as described in the comments to the function.</p>\n<p>Here are two example images that were smoothed using this as the loss function. The optimizer performed 100 iterations with a gradient step-size of 1.0.</p>\n<p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://cloud.githubusercontent.com/assets/13588114/21567810/83450792-ceaf-11e6-9222-a1c66207a2f7.png\"><img src=\"https://cloud.githubusercontent.com/assets/13588114/21567810/83450792-ceaf-11e6-9222-a1c66207a2f7.png\" alt=\"image1\" style=\"max-width:100%;\"></a></p>\n<p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://cloud.githubusercontent.com/assets/13588114/21567811/88a82282-ceaf-11e6-93ff-6ce86422bf47.png\"><img src=\"https://cloud.githubusercontent.com/assets/13588114/21567811/88a82282-ceaf-11e6-93ff-6ce86422bf47.png\" alt=\"image1_smoothed\" style=\"max-width:100%;\"></a></p>\n<p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://cloud.githubusercontent.com/assets/13588114/21567816/9304ef62-ceaf-11e6-9d7d-d25ab2c687fc.png\"><img src=\"https://cloud.githubusercontent.com/assets/13588114/21567816/9304ef62-ceaf-11e6-9d7d-d25ab2c687fc.png\" alt=\"image2\" style=\"max-width:100%;\"></a></p>\n<p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://cloud.githubusercontent.com/assets/13588114/21567819/957c7738-ceaf-11e6-9265-4247a84b1732.png\"><img src=\"https://cloud.githubusercontent.com/assets/13588114/21567819/957c7738-ceaf-11e6-9265-4247a84b1732.png\" alt=\"image2_smoothed\" style=\"max-width:100%;\"></a></p>", "body_text": "Thanks for the comments.\nHere is the function I propose. I have tried to follow the coding style in image_ops_impl.py, except for the indentation which I will fix to 2 spaces in the pull request, and my comments are more verbose because I find that helpful when reading code and quickly trying to grasp what the intention is.\nI did not use _CheckAtLeast3DImage because it requires the shape to be fully defined.\nPlease have a look and let me know if this looks fine. Then I will make a pull request.\ndef total_variation(images, name=None):\n    \"\"\"Calculate and return the Total Variation for one or more images.\n\n    The total variation is the sum of the absolute differences for neighboring\n    pixel-values in the input images. This measures how much noise is in the images.\n\n    This can be used as a loss-function during optimization so as to suppress noise\n    in images. If you have a batch of images, then you should calculate the scalar\n    loss-value as the sum: `loss = tf.reduce_sum(tf.image.total_variation(images))`\n\n    This implements the anisotropic 2-D version of the formula described here:\n\n    https://en.wikipedia.org/wiki/Total_variation_denoising\n\n    Args:\n        images: 4-D Tensor of shape `[batch, height, width, channels]` or\n                3-D Tensor of shape `[height, width, channels]`.\n\n        name: A name for the operation (optional).\n\n    Raises:\n        ValueError: if images.shape is not a 3-D or 4-D vector.\n\n    Returns:\n        The total variation of `images`.\n\n        If `images` was 4-D, a 1-D float Tensor of shape `[batch]` with the\n        total variation for each image in the batch.\n        If `images` was 3-D, a scalar float with the total variation for that image.\n    \"\"\"\n\n    with ops.name_scope(name, 'total_variation'):\n        ndims = images.get_shape().ndims\n\n        if ndims == 3:\n            # The input is a single image with shape [height, width, channels].\n\n            # Calculate the difference of neighboring pixel-values.\n            # The images are shifted one pixel along the height and width by slicing.\n            pixel_dif1 = images[1:,:,:] - images[:-1,:,:]\n            pixel_dif2 = images[:,1:,:] - images[:,:-1,:]\n\n            # Sum for all axis. (None is an alias for all axis.)\n            sum_axis = None\n        elif ndims == 4:\n            # The input is a batch of images with shape [batch, height, width, channels].\n\n            # Calculate the difference of neighboring pixel-values.\n            # The images are shifted one pixel along the height and width by slicing.\n            pixel_dif1 = images[:,1:,:,:] - images[:,:-1,:,:]\n            pixel_dif2 = images[:,:,1:,:] - images[:,:,:-1,:]\n\n            # Only sum for the last 3 axis.\n            # This results in a 1-D tensor with the total variation for each image.\n            sum_axis = [1, 2, 3]\n        else:\n            raise ValueError('\\'images\\' must be either 3 or 4-dimensional.')\n\n        # Calculate the total variation by taking the absolute value of the\n        # pixel-differences and summing over the appropriate axis.\n        tot_var = tf.reduce_sum(tf.abs(pixel_dif1), axis=sum_axis) + \\\n                  tf.reduce_sum(tf.abs(pixel_dif2), axis=sum_axis)\n\n    return tot_var\n\nTesting\nI have tested this in a Python Notebook, but it is messy and undocumented so I have not put it online. If you would like to run these tests yourself then I can cleanup the Notebook and put it online somewhere. (Where?)\nI have tested both single- and multi-image input tensors. I have also tested incorrect inputs such as None, too low and too high dimensions. I have done a basic gradient descent and it produces the same results for a single and multiple input images, provided you use tf.reduce_sum() in the loss-function as described in the comments to the function.\nHere are two example images that were smoothed using this as the loss function. The optimizer performed 100 iterations with a gradient step-size of 1.0.", "body": "Thanks for the comments.\r\n\r\nHere is the function I propose. I have tried to follow the coding style in `image_ops_impl.py`, except for the indentation which I will fix to 2 spaces in the pull request, and my comments are more verbose because I find that helpful when reading code and quickly trying to grasp what the intention is.\r\n\r\nI did not use `_CheckAtLeast3DImage` because it requires the shape to be fully defined.\r\n\r\nPlease have a look and let me know if this looks fine. Then I will make a pull request.\r\n\r\n    def total_variation(images, name=None):\r\n        \"\"\"Calculate and return the Total Variation for one or more images.\r\n\r\n        The total variation is the sum of the absolute differences for neighboring\r\n        pixel-values in the input images. This measures how much noise is in the images.\r\n\r\n        This can be used as a loss-function during optimization so as to suppress noise\r\n        in images. If you have a batch of images, then you should calculate the scalar\r\n        loss-value as the sum: `loss = tf.reduce_sum(tf.image.total_variation(images))`\r\n\r\n        This implements the anisotropic 2-D version of the formula described here:\r\n\r\n        https://en.wikipedia.org/wiki/Total_variation_denoising\r\n\r\n        Args:\r\n            images: 4-D Tensor of shape `[batch, height, width, channels]` or\r\n                    3-D Tensor of shape `[height, width, channels]`.\r\n\r\n            name: A name for the operation (optional).\r\n\r\n        Raises:\r\n            ValueError: if images.shape is not a 3-D or 4-D vector.\r\n\r\n        Returns:\r\n            The total variation of `images`.\r\n\r\n            If `images` was 4-D, a 1-D float Tensor of shape `[batch]` with the\r\n            total variation for each image in the batch.\r\n            If `images` was 3-D, a scalar float with the total variation for that image.\r\n        \"\"\"\r\n\r\n        with ops.name_scope(name, 'total_variation'):\r\n            ndims = images.get_shape().ndims\r\n\r\n            if ndims == 3:\r\n                # The input is a single image with shape [height, width, channels].\r\n\r\n                # Calculate the difference of neighboring pixel-values.\r\n                # The images are shifted one pixel along the height and width by slicing.\r\n                pixel_dif1 = images[1:,:,:] - images[:-1,:,:]\r\n                pixel_dif2 = images[:,1:,:] - images[:,:-1,:]\r\n\r\n                # Sum for all axis. (None is an alias for all axis.)\r\n                sum_axis = None\r\n            elif ndims == 4:\r\n                # The input is a batch of images with shape [batch, height, width, channels].\r\n\r\n                # Calculate the difference of neighboring pixel-values.\r\n                # The images are shifted one pixel along the height and width by slicing.\r\n                pixel_dif1 = images[:,1:,:,:] - images[:,:-1,:,:]\r\n                pixel_dif2 = images[:,:,1:,:] - images[:,:,:-1,:]\r\n\r\n                # Only sum for the last 3 axis.\r\n                # This results in a 1-D tensor with the total variation for each image.\r\n                sum_axis = [1, 2, 3]\r\n            else:\r\n                raise ValueError('\\'images\\' must be either 3 or 4-dimensional.')\r\n\r\n            # Calculate the total variation by taking the absolute value of the\r\n            # pixel-differences and summing over the appropriate axis.\r\n            tot_var = tf.reduce_sum(tf.abs(pixel_dif1), axis=sum_axis) + \\\r\n                      tf.reduce_sum(tf.abs(pixel_dif2), axis=sum_axis)\r\n\r\n        return tot_var\r\n\r\n### Testing\r\n\r\nI have tested this in a Python Notebook, but it is messy and undocumented so I have not put it online. If you would like to run these tests yourself then I can cleanup the Notebook and put it online somewhere. (Where?)\r\n\r\nI have tested both single- and multi-image input tensors. I have also tested incorrect inputs such as None, too low and too high dimensions. I have done a basic gradient descent and it produces the same results for a single and multiple input images, provided you use `tf.reduce_sum()` in the loss-function as described in the comments to the function.\r\n\r\nHere are two example images that were smoothed using this as the loss function. The optimizer performed 100 iterations with a gradient step-size of 1.0.\r\n\r\n![image1](https://cloud.githubusercontent.com/assets/13588114/21567810/83450792-ceaf-11e6-9222-a1c66207a2f7.png)\r\n\r\n![image1_smoothed](https://cloud.githubusercontent.com/assets/13588114/21567811/88a82282-ceaf-11e6-93ff-6ce86422bf47.png)\r\n\r\n![image2](https://cloud.githubusercontent.com/assets/13588114/21567816/9304ef62-ceaf-11e6-9d7d-d25ab2c687fc.png)\r\n\r\n![image2_smoothed](https://cloud.githubusercontent.com/assets/13588114/21567819/957c7738-ceaf-11e6-9265-4247a84b1732.png)\r\n"}