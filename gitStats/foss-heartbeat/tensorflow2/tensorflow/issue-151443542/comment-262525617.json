{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/262525617", "html_url": "https://github.com/tensorflow/tensorflow/issues/2134#issuecomment-262525617", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2134", "id": 262525617, "node_id": "MDEyOklzc3VlQ29tbWVudDI2MjUyNTYxNw==", "user": {"login": "CNugteren", "id": 1162108, "node_id": "MDQ6VXNlcjExNjIxMDg=", "avatar_url": "https://avatars3.githubusercontent.com/u/1162108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CNugteren", "html_url": "https://github.com/CNugteren", "followers_url": "https://api.github.com/users/CNugteren/followers", "following_url": "https://api.github.com/users/CNugteren/following{/other_user}", "gists_url": "https://api.github.com/users/CNugteren/gists{/gist_id}", "starred_url": "https://api.github.com/users/CNugteren/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CNugteren/subscriptions", "organizations_url": "https://api.github.com/users/CNugteren/orgs", "repos_url": "https://api.github.com/users/CNugteren/repos", "events_url": "https://api.github.com/users/CNugteren/events{/privacy}", "received_events_url": "https://api.github.com/users/CNugteren/received_events", "type": "User", "site_admin": false}, "created_at": "2016-11-23T14:25:32Z", "updated_at": "2016-11-23T14:34:18Z", "author_association": "NONE", "body_html": "<p>There is a work-around in case <code>centered=True</code> and <code>normalized=False</code>. In that case the offsets range from minus the size to plus the size of the tensor. I therefore wrote a wrapper that is more intuitive to numpy users, using pixel coordinates starting at (0,0):</p>\n<pre><code>import tensorflow as tf\nimport numpy as np\n\ndef extract_glimpse_numpy_like(input, glimpse_size, glimpse_offsets, name=None, uniform_noise=None):\n    \"\"\"\n    Works like in numpy with pixel coordinates starting at (0, 0), returns:\n       input[:, glimpse_offset[0] : glimpse_offset[0] + glimpse_size[0],\n                glimpse_offset[1] : glimpse_offset[1] + glimpse_size[1], :]\n    \"\"\"\n    assert(len(glimpse_size) == 2)\n    assert(len(glimpse_offsets) == 2)\n    input_size = tuple(input.get_shape().as_list())  # includes batch and number of channels\n    corrected_offsets = [2 * glimpse_offsets[0] - input_size[1] + glimpse_size[0],\n                         2 * glimpse_offsets[1] - input_size[2] + glimpse_size[1]]\n    corrected_offsets = np.tile(corrected_offsets, input_size[0])  # repeat it for each batch\n    corrected_offsets_t = tf.reshape(tf.constant(corrected_offsets, dtype=tf.float32), shape=(input_size[0], 2))\n    return tf.image.extract_glimpse(input, glimpse_size, corrected_offsets_t, centered=True, normalized=False,\n                                    uniform_noise=uniform_noise, name=name)\n</code></pre>\n<p>Note that this function assumes that the size of the tensor is known and that the offset is the same for each batch.</p>\n<p>The original example would then return two subsequent glimpses when changed to use the above function:</p>\n<pre><code>input_img = np.arange(25).reshape((1,5,5,1))\ninput_tensor = tf.constant(input_img, dtype=tf.float32)\nfirst_glimpse = extract_glimpse_numpy_like(input_tensor, [3,3], [0,0])\nsecond_glimpse = extract_glimpse_numpy_like(input_tensor, [3,3], [1,0])\n\nsess = tf.Session()\nprint first_glimpse.eval(session=sess)[0,:,:,0]\nprint second_glimpse.eval(session=sess)[0,:,:,0]\n</code></pre>", "body_text": "There is a work-around in case centered=True and normalized=False. In that case the offsets range from minus the size to plus the size of the tensor. I therefore wrote a wrapper that is more intuitive to numpy users, using pixel coordinates starting at (0,0):\nimport tensorflow as tf\nimport numpy as np\n\ndef extract_glimpse_numpy_like(input, glimpse_size, glimpse_offsets, name=None, uniform_noise=None):\n    \"\"\"\n    Works like in numpy with pixel coordinates starting at (0, 0), returns:\n       input[:, glimpse_offset[0] : glimpse_offset[0] + glimpse_size[0],\n                glimpse_offset[1] : glimpse_offset[1] + glimpse_size[1], :]\n    \"\"\"\n    assert(len(glimpse_size) == 2)\n    assert(len(glimpse_offsets) == 2)\n    input_size = tuple(input.get_shape().as_list())  # includes batch and number of channels\n    corrected_offsets = [2 * glimpse_offsets[0] - input_size[1] + glimpse_size[0],\n                         2 * glimpse_offsets[1] - input_size[2] + glimpse_size[1]]\n    corrected_offsets = np.tile(corrected_offsets, input_size[0])  # repeat it for each batch\n    corrected_offsets_t = tf.reshape(tf.constant(corrected_offsets, dtype=tf.float32), shape=(input_size[0], 2))\n    return tf.image.extract_glimpse(input, glimpse_size, corrected_offsets_t, centered=True, normalized=False,\n                                    uniform_noise=uniform_noise, name=name)\n\nNote that this function assumes that the size of the tensor is known and that the offset is the same for each batch.\nThe original example would then return two subsequent glimpses when changed to use the above function:\ninput_img = np.arange(25).reshape((1,5,5,1))\ninput_tensor = tf.constant(input_img, dtype=tf.float32)\nfirst_glimpse = extract_glimpse_numpy_like(input_tensor, [3,3], [0,0])\nsecond_glimpse = extract_glimpse_numpy_like(input_tensor, [3,3], [1,0])\n\nsess = tf.Session()\nprint first_glimpse.eval(session=sess)[0,:,:,0]\nprint second_glimpse.eval(session=sess)[0,:,:,0]", "body": "There is a work-around in case `centered=True` and `normalized=False`. In that case the offsets range from minus the size to plus the size of the tensor. I therefore wrote a wrapper that is more intuitive to numpy users, using pixel coordinates starting at (0,0):\r\n```\r\nimport tensorflow as tf\r\nimport numpy as np\r\n\r\ndef extract_glimpse_numpy_like(input, glimpse_size, glimpse_offsets, name=None, uniform_noise=None):\r\n    \"\"\"\r\n    Works like in numpy with pixel coordinates starting at (0, 0), returns:\r\n       input[:, glimpse_offset[0] : glimpse_offset[0] + glimpse_size[0],\r\n                glimpse_offset[1] : glimpse_offset[1] + glimpse_size[1], :]\r\n    \"\"\"\r\n    assert(len(glimpse_size) == 2)\r\n    assert(len(glimpse_offsets) == 2)\r\n    input_size = tuple(input.get_shape().as_list())  # includes batch and number of channels\r\n    corrected_offsets = [2 * glimpse_offsets[0] - input_size[1] + glimpse_size[0],\r\n                         2 * glimpse_offsets[1] - input_size[2] + glimpse_size[1]]\r\n    corrected_offsets = np.tile(corrected_offsets, input_size[0])  # repeat it for each batch\r\n    corrected_offsets_t = tf.reshape(tf.constant(corrected_offsets, dtype=tf.float32), shape=(input_size[0], 2))\r\n    return tf.image.extract_glimpse(input, glimpse_size, corrected_offsets_t, centered=True, normalized=False,\r\n                                    uniform_noise=uniform_noise, name=name)\r\n```\r\nNote that this function assumes that the size of the tensor is known and that the offset is the same for each batch.\r\n\r\nThe original example would then return two subsequent glimpses when changed to use the above function:\r\n```\r\ninput_img = np.arange(25).reshape((1,5,5,1))\r\ninput_tensor = tf.constant(input_img, dtype=tf.float32)\r\nfirst_glimpse = extract_glimpse_numpy_like(input_tensor, [3,3], [0,0])\r\nsecond_glimpse = extract_glimpse_numpy_like(input_tensor, [3,3], [1,0])\r\n\r\nsess = tf.Session()\r\nprint first_glimpse.eval(session=sess)[0,:,:,0]\r\nprint second_glimpse.eval(session=sess)[0,:,:,0]\r\n```"}