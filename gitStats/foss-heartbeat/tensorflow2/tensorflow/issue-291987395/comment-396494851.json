{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/396494851", "html_url": "https://github.com/tensorflow/tensorflow/issues/16465#issuecomment-396494851", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/16465", "id": 396494851, "node_id": "MDEyOklzc3VlQ29tbWVudDM5NjQ5NDg1MQ==", "user": {"login": "rryan", "id": 26527, "node_id": "MDQ6VXNlcjI2NTI3", "avatar_url": "https://avatars3.githubusercontent.com/u/26527?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rryan", "html_url": "https://github.com/rryan", "followers_url": "https://api.github.com/users/rryan/followers", "following_url": "https://api.github.com/users/rryan/following{/other_user}", "gists_url": "https://api.github.com/users/rryan/gists{/gist_id}", "starred_url": "https://api.github.com/users/rryan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rryan/subscriptions", "organizations_url": "https://api.github.com/users/rryan/orgs", "repos_url": "https://api.github.com/users/rryan/repos", "events_url": "https://api.github.com/users/rryan/events{/privacy}", "received_events_url": "https://api.github.com/users/rryan/received_events", "type": "User", "site_admin": false}, "created_at": "2018-06-12T07:34:48Z", "updated_at": "2018-06-12T07:35:14Z", "author_association": "MEMBER", "body_html": "<p>Thanks a ton <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=16771734\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/nuchi\">@nuchi</a>, <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=144230\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/memo\">@memo</a>, and <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=9143109\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/andimarafioti\">@andimarafioti</a> for your patience and helpful repro code. As you've summarized nicely, this is caused by at least two issues:</p>\n<ul>\n<li>By default, <code>tf.contrib.signal.inverse_stft</code> does not assume that the input STFT was generated from <code>tf.contrib.signal.stft</code>, and therefore does not divide the window by the squared sum of its magnitude as librosa <a href=\"https://github.com/librosa/librosa/blob/0dcd53f462db124ed3f54edf2334f28738d2ecc6/librosa/core/spectrum.py#L302-L311\">does by default</a>. To get this behavior, pass <code>window_fn=tf.contrib.signal.inverse_stft_window_fn(frame_step)</code>, which is designed to compute a reconstruction window given the window and <code>frame_step</code> used in a forward STFT.</li>\n<li><code>tf.contrib.signal.stft</code> does not center the framed windows as librosa does by default with <code>center=True</code>. This option doesn't exist in <code>tf.contrib.signal</code> yet (<a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"279427567\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/tensorflow/tensorflow/issues/15134\" data-hovercard-type=\"issue\" data-hovercard-url=\"/tensorflow/tensorflow/issues/15134/hovercard\" href=\"https://github.com/tensorflow/tensorflow/issues/15134\">#15134</a>) but it's simple to work around, since you just reflect-pad the input to <code>stft</code> and slice the result of <code>inverse_stft</code>as librosa does <a href=\"https://github.com/librosa/librosa/blob/0dcd53f462db124ed3f54edf2334f28738d2ecc6/librosa/core/spectrum.py#L162-L164\">here</a> and <a href=\"https://github.com/librosa/librosa/blob/0dcd53f462db124ed3f54edf2334f28738d2ecc6/librosa/core/spectrum.py#L314-L317\">here</a>.</li>\n</ul>\n<p>Here is a replacement for <code>reconstruct_from_stft</code> that works with <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=144230\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/memo\">@memo</a>'s test case:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">def</span> <span class=\"pl-en\">reconstruct_from_stft</span>(<span class=\"pl-smi\">x</span>, <span class=\"pl-smi\">frame_length</span>, <span class=\"pl-smi\">frame_step</span>):\n    name <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>stft<span class=\"pl-pds\">'</span></span>\n    center <span class=\"pl-k\">=</span> <span class=\"pl-c1\">True</span>\n    <span class=\"pl-k\">if</span> center:\n        <span class=\"pl-c\"><span class=\"pl-c\">#</span> librosa pads by frame_length, which almost works perfectly here, except for with frame_step 256.</span>\n        pad_amount <span class=\"pl-k\">=</span> <span class=\"pl-c1\">2</span> <span class=\"pl-k\">*</span> (frame_length <span class=\"pl-k\">-</span> frame_step)\n        x <span class=\"pl-k\">=</span> tf.pad(x, [[pad_amount <span class=\"pl-k\">//</span> <span class=\"pl-c1\">2</span>, pad_amount <span class=\"pl-k\">//</span> <span class=\"pl-c1\">2</span>]], <span class=\"pl-s\"><span class=\"pl-pds\">'</span>REFLECT<span class=\"pl-pds\">'</span></span>)\n    \n    f <span class=\"pl-k\">=</span> tf.contrib.signal.frame(x, frame_length, frame_step, <span class=\"pl-v\">pad_end</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">False</span>)\n    w <span class=\"pl-k\">=</span> tf.contrib.signal.hann_window(frame_length, <span class=\"pl-v\">periodic</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">True</span>)\n    spectrograms_T <span class=\"pl-k\">=</span> tf.spectral.rfft(f <span class=\"pl-k\">*</span> w, <span class=\"pl-v\">fft_length</span><span class=\"pl-k\">=</span>[frame_length])\n        \n    output_T <span class=\"pl-k\">=</span> tf.contrib.signal.inverse_stft(\n        spectrograms_T, frame_length, frame_step,\n        <span class=\"pl-v\">window_fn</span><span class=\"pl-k\">=</span>tf.contrib.signal.inverse_stft_window_fn(frame_step))\n    <span class=\"pl-k\">if</span> center <span class=\"pl-k\">and</span> pad_amount <span class=\"pl-k\">&gt;</span> <span class=\"pl-c1\">0</span>:\n        output_T <span class=\"pl-k\">=</span> output_T[pad_amount <span class=\"pl-k\">//</span> <span class=\"pl-c1\">2</span>:<span class=\"pl-k\">-</span>pad_amount <span class=\"pl-k\">//</span> <span class=\"pl-c1\">2</span>]\n    <span class=\"pl-k\">return</span> name, output_T</pre></div>\n<p>Here is a <a href=\"https://colab.research.google.com/drive/1zrugaL6wWudcLMHvNQ8OL2lRZJIIeRlB#scrollTo=NL1IBl7JyZOy\" rel=\"nofollow\">Colab notebook</a> demonstrating.</p>", "body_text": "Thanks a ton @nuchi, @memo, and @andimarafioti for your patience and helpful repro code. As you've summarized nicely, this is caused by at least two issues:\n\nBy default, tf.contrib.signal.inverse_stft does not assume that the input STFT was generated from tf.contrib.signal.stft, and therefore does not divide the window by the squared sum of its magnitude as librosa does by default. To get this behavior, pass window_fn=tf.contrib.signal.inverse_stft_window_fn(frame_step), which is designed to compute a reconstruction window given the window and frame_step used in a forward STFT.\ntf.contrib.signal.stft does not center the framed windows as librosa does by default with center=True. This option doesn't exist in tf.contrib.signal yet (#15134) but it's simple to work around, since you just reflect-pad the input to stft and slice the result of inverse_stftas librosa does here and here.\n\nHere is a replacement for reconstruct_from_stft that works with @memo's test case:\ndef reconstruct_from_stft(x, frame_length, frame_step):\n    name = 'stft'\n    center = True\n    if center:\n        # librosa pads by frame_length, which almost works perfectly here, except for with frame_step 256.\n        pad_amount = 2 * (frame_length - frame_step)\n        x = tf.pad(x, [[pad_amount // 2, pad_amount // 2]], 'REFLECT')\n    \n    f = tf.contrib.signal.frame(x, frame_length, frame_step, pad_end=False)\n    w = tf.contrib.signal.hann_window(frame_length, periodic=True)\n    spectrograms_T = tf.spectral.rfft(f * w, fft_length=[frame_length])\n        \n    output_T = tf.contrib.signal.inverse_stft(\n        spectrograms_T, frame_length, frame_step,\n        window_fn=tf.contrib.signal.inverse_stft_window_fn(frame_step))\n    if center and pad_amount > 0:\n        output_T = output_T[pad_amount // 2:-pad_amount // 2]\n    return name, output_T\nHere is a Colab notebook demonstrating.", "body": "Thanks a ton @nuchi, @memo, and @andimarafioti for your patience and helpful repro code. As you've summarized nicely, this is caused by at least two issues:\r\n\r\n* By default, `tf.contrib.signal.inverse_stft` does not assume that the input STFT was generated from `tf.contrib.signal.stft`, and therefore does not divide the window by the squared sum of its magnitude as librosa [does by default](https://github.com/librosa/librosa/blob/0dcd53f462db124ed3f54edf2334f28738d2ecc6/librosa/core/spectrum.py#L302-L311). To get this behavior, pass `window_fn=tf.contrib.signal.inverse_stft_window_fn(frame_step)`, which is designed to compute a reconstruction window given the window and `frame_step` used in a forward STFT.\r\n* `tf.contrib.signal.stft` does not center the framed windows as librosa does by default with `center=True`. This option doesn't exist in `tf.contrib.signal` yet (#15134) but it's simple to work around, since you just reflect-pad the input to `stft` and slice the result of `inverse_stft`as librosa does [here](https://github.com/librosa/librosa/blob/0dcd53f462db124ed3f54edf2334f28738d2ecc6/librosa/core/spectrum.py#L162-L164) and [here](https://github.com/librosa/librosa/blob/0dcd53f462db124ed3f54edf2334f28738d2ecc6/librosa/core/spectrum.py#L314-L317).\r\n\r\nHere is a replacement for `reconstruct_from_stft` that works with @memo's test case:\r\n```python\r\ndef reconstruct_from_stft(x, frame_length, frame_step):\r\n    name = 'stft'\r\n    center = True\r\n    if center:\r\n        # librosa pads by frame_length, which almost works perfectly here, except for with frame_step 256.\r\n        pad_amount = 2 * (frame_length - frame_step)\r\n        x = tf.pad(x, [[pad_amount // 2, pad_amount // 2]], 'REFLECT')\r\n    \r\n    f = tf.contrib.signal.frame(x, frame_length, frame_step, pad_end=False)\r\n    w = tf.contrib.signal.hann_window(frame_length, periodic=True)\r\n    spectrograms_T = tf.spectral.rfft(f * w, fft_length=[frame_length])\r\n        \r\n    output_T = tf.contrib.signal.inverse_stft(\r\n        spectrograms_T, frame_length, frame_step,\r\n        window_fn=tf.contrib.signal.inverse_stft_window_fn(frame_step))\r\n    if center and pad_amount > 0:\r\n        output_T = output_T[pad_amount // 2:-pad_amount // 2]\r\n    return name, output_T\r\n```\r\nHere is a [Colab notebook](https://colab.research.google.com/drive/1zrugaL6wWudcLMHvNQ8OL2lRZJIIeRlB#scrollTo=NL1IBl7JyZOy) demonstrating."}