{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/219940552", "html_url": "https://github.com/tensorflow/tensorflow/issues/2385#issuecomment-219940552", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2385", "id": 219940552, "node_id": "MDEyOklzc3VlQ29tbWVudDIxOTk0MDU1Mg==", "user": {"login": "ushnish", "id": 3603839, "node_id": "MDQ6VXNlcjM2MDM4Mzk=", "avatar_url": "https://avatars2.githubusercontent.com/u/3603839?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ushnish", "html_url": "https://github.com/ushnish", "followers_url": "https://api.github.com/users/ushnish/followers", "following_url": "https://api.github.com/users/ushnish/following{/other_user}", "gists_url": "https://api.github.com/users/ushnish/gists{/gist_id}", "starred_url": "https://api.github.com/users/ushnish/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ushnish/subscriptions", "organizations_url": "https://api.github.com/users/ushnish/orgs", "repos_url": "https://api.github.com/users/ushnish/repos", "events_url": "https://api.github.com/users/ushnish/events{/privacy}", "received_events_url": "https://api.github.com/users/ushnish/received_events", "type": "User", "site_admin": false}, "created_at": "2016-05-18T06:51:18Z", "updated_at": "2016-05-18T06:56:18Z", "author_association": "NONE", "body_html": "<p>Well this is how I am creating the placeholders now.</p>\n<pre><code>x1 = []\nx2 = []\ny1 = []\ny2 = []\nfor _ in xrange(max_sequence_length):\n        with tf.device('/gpu:0'):\n                x = tf.placeholder(tf.float32, shape=[batch_size, input_width])\n                x1.append(x)\n                y = tf.placeholder(tf.float32, shape=[batch_size, input_width])                                                                                                \n                y1.append(y)                                                                                                                                                   \n        with tf.device('/gpu:1'):                                                                                                                                              \n                x = tf.placeholder(tf.float32, shape=[batch_size, input_width])                                                                                                \n                x2.append(x)                                                                                                                                                   \n                y = tf.placeholder(tf.float32, shape=[batch_size, input_width])                                                                                                \n                y2.append(y)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          \nwith tf.device('/gpu:0'):                                                                                                                                                      \n                s1 = tf.placeholder(tf.int32, shape=[batch_size])                                                                                                                                                                                                                                                                                 \n                cell1 = BasicLSTMCell(num_units = hidden_neurons, input_size = [batch_size, input_width])                                                                      \n                initial_state1 = tf.zeros([batch_size, hidden_neurons * 2], name = 'initial_state1')                                                                           \n                with tf.name_scope('/gpu:0') as scope:                                                                                                                         \n                        outputs1, state1 = rnn.rnn(cell=cell1, inputs = x1, initial_state=initial_state1, sequence_length=s1, scope = scope)\netc etc\n\nwith tf.device('/gpu:1'):                                                                                                                                                      \n                s2 = tf.placeholder(tf.int32, shape=[batch_size])                                                                                                              \n                cell2 = BasicLSTMCell(num_units = hidden_neurons, input_size = [batch_size, input_width])                                                                      \n                initial_state2 = tf.zeros([batch_size, hidden_neurons * 2], name = 'initial_state2')                                                                           \n                with tf.name_scope('/gpu:1') as scope:                                                                                                                         \n                        outputs2, state2 = rnn.rnn(cell=cell2, inputs = x2, initial_state=initial_state2, sequence_length=s2, scope = scope)        \n</code></pre>\n<p>I use both <code>output1</code> and <code>output2</code> to create two losses with which to compute gradients twice and then I get the average, similar to <code>cifar10_multi_gpu.py</code>. However this exact same error happens at the line where i call <code>rnn.rnn</code>. I don't think it is because of an invalid tensor in the list.</p>", "body_text": "Well this is how I am creating the placeholders now.\nx1 = []\nx2 = []\ny1 = []\ny2 = []\nfor _ in xrange(max_sequence_length):\n        with tf.device('/gpu:0'):\n                x = tf.placeholder(tf.float32, shape=[batch_size, input_width])\n                x1.append(x)\n                y = tf.placeholder(tf.float32, shape=[batch_size, input_width])                                                                                                \n                y1.append(y)                                                                                                                                                   \n        with tf.device('/gpu:1'):                                                                                                                                              \n                x = tf.placeholder(tf.float32, shape=[batch_size, input_width])                                                                                                \n                x2.append(x)                                                                                                                                                   \n                y = tf.placeholder(tf.float32, shape=[batch_size, input_width])                                                                                                \n                y2.append(y)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          \nwith tf.device('/gpu:0'):                                                                                                                                                      \n                s1 = tf.placeholder(tf.int32, shape=[batch_size])                                                                                                                                                                                                                                                                                 \n                cell1 = BasicLSTMCell(num_units = hidden_neurons, input_size = [batch_size, input_width])                                                                      \n                initial_state1 = tf.zeros([batch_size, hidden_neurons * 2], name = 'initial_state1')                                                                           \n                with tf.name_scope('/gpu:0') as scope:                                                                                                                         \n                        outputs1, state1 = rnn.rnn(cell=cell1, inputs = x1, initial_state=initial_state1, sequence_length=s1, scope = scope)\netc etc\n\nwith tf.device('/gpu:1'):                                                                                                                                                      \n                s2 = tf.placeholder(tf.int32, shape=[batch_size])                                                                                                              \n                cell2 = BasicLSTMCell(num_units = hidden_neurons, input_size = [batch_size, input_width])                                                                      \n                initial_state2 = tf.zeros([batch_size, hidden_neurons * 2], name = 'initial_state2')                                                                           \n                with tf.name_scope('/gpu:1') as scope:                                                                                                                         \n                        outputs2, state2 = rnn.rnn(cell=cell2, inputs = x2, initial_state=initial_state2, sequence_length=s2, scope = scope)        \n\nI use both output1 and output2 to create two losses with which to compute gradients twice and then I get the average, similar to cifar10_multi_gpu.py. However this exact same error happens at the line where i call rnn.rnn. I don't think it is because of an invalid tensor in the list.", "body": "Well this is how I am creating the placeholders now.\n\n```\nx1 = []\nx2 = []\ny1 = []\ny2 = []\nfor _ in xrange(max_sequence_length):\n        with tf.device('/gpu:0'):\n                x = tf.placeholder(tf.float32, shape=[batch_size, input_width])\n                x1.append(x)\n                y = tf.placeholder(tf.float32, shape=[batch_size, input_width])                                                                                                \n                y1.append(y)                                                                                                                                                   \n        with tf.device('/gpu:1'):                                                                                                                                              \n                x = tf.placeholder(tf.float32, shape=[batch_size, input_width])                                                                                                \n                x2.append(x)                                                                                                                                                   \n                y = tf.placeholder(tf.float32, shape=[batch_size, input_width])                                                                                                \n                y2.append(y)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          \nwith tf.device('/gpu:0'):                                                                                                                                                      \n                s1 = tf.placeholder(tf.int32, shape=[batch_size])                                                                                                                                                                                                                                                                                 \n                cell1 = BasicLSTMCell(num_units = hidden_neurons, input_size = [batch_size, input_width])                                                                      \n                initial_state1 = tf.zeros([batch_size, hidden_neurons * 2], name = 'initial_state1')                                                                           \n                with tf.name_scope('/gpu:0') as scope:                                                                                                                         \n                        outputs1, state1 = rnn.rnn(cell=cell1, inputs = x1, initial_state=initial_state1, sequence_length=s1, scope = scope)\netc etc\n\nwith tf.device('/gpu:1'):                                                                                                                                                      \n                s2 = tf.placeholder(tf.int32, shape=[batch_size])                                                                                                              \n                cell2 = BasicLSTMCell(num_units = hidden_neurons, input_size = [batch_size, input_width])                                                                      \n                initial_state2 = tf.zeros([batch_size, hidden_neurons * 2], name = 'initial_state2')                                                                           \n                with tf.name_scope('/gpu:1') as scope:                                                                                                                         \n                        outputs2, state2 = rnn.rnn(cell=cell2, inputs = x2, initial_state=initial_state2, sequence_length=s2, scope = scope)        \n```\n\nI use both `output1` and `output2` to create two losses with which to compute gradients twice and then I get the average, similar to `cifar10_multi_gpu.py`. However this exact same error happens at the line where i call `rnn.rnn`. I don't think it is because of an invalid tensor in the list.\n"}