{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8394", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8394/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8394/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8394/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/8394", "id": 214044373, "node_id": "MDU6SXNzdWUyMTQwNDQzNzM=", "number": 8394, "title": "Protobufs are into multiple shared libraries loaded from python", "user": {"login": "ilya-biryukov", "id": 809452, "node_id": "MDQ6VXNlcjgwOTQ1Mg==", "avatar_url": "https://avatars0.githubusercontent.com/u/809452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ilya-biryukov", "html_url": "https://github.com/ilya-biryukov", "followers_url": "https://api.github.com/users/ilya-biryukov/followers", "following_url": "https://api.github.com/users/ilya-biryukov/following{/other_user}", "gists_url": "https://api.github.com/users/ilya-biryukov/gists{/gist_id}", "starred_url": "https://api.github.com/users/ilya-biryukov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ilya-biryukov/subscriptions", "organizations_url": "https://api.github.com/users/ilya-biryukov/orgs", "repos_url": "https://api.github.com/users/ilya-biryukov/repos", "events_url": "https://api.github.com/users/ilya-biryukov/events{/privacy}", "received_events_url": "https://api.github.com/users/ilya-biryukov/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 473172988, "node_id": "MDU6TGFiZWw0NzMxNzI5ODg=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:bug/performance", "name": "type:bug/performance", "color": "159b2e", "default": false}, {"id": 473173351, "node_id": "MDU6TGFiZWw0NzMxNzMzNTE=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:build/install", "name": "type:build/install", "color": "159b2e", "default": false}], "state": "closed", "locked": false, "assignee": {"login": "gunan", "id": 7946809, "node_id": "MDQ6VXNlcjc5NDY4MDk=", "avatar_url": "https://avatars3.githubusercontent.com/u/7946809?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gunan", "html_url": "https://github.com/gunan", "followers_url": "https://api.github.com/users/gunan/followers", "following_url": "https://api.github.com/users/gunan/following{/other_user}", "gists_url": "https://api.github.com/users/gunan/gists{/gist_id}", "starred_url": "https://api.github.com/users/gunan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gunan/subscriptions", "organizations_url": "https://api.github.com/users/gunan/orgs", "repos_url": "https://api.github.com/users/gunan/repos", "events_url": "https://api.github.com/users/gunan/events{/privacy}", "received_events_url": "https://api.github.com/users/gunan/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "gunan", "id": 7946809, "node_id": "MDQ6VXNlcjc5NDY4MDk=", "avatar_url": "https://avatars3.githubusercontent.com/u/7946809?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gunan", "html_url": "https://github.com/gunan", "followers_url": "https://api.github.com/users/gunan/followers", "following_url": "https://api.github.com/users/gunan/following{/other_user}", "gists_url": "https://api.github.com/users/gunan/gists{/gist_id}", "starred_url": "https://api.github.com/users/gunan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gunan/subscriptions", "organizations_url": "https://api.github.com/users/gunan/orgs", "repos_url": "https://api.github.com/users/gunan/repos", "events_url": "https://api.github.com/users/gunan/events{/privacy}", "received_events_url": "https://api.github.com/users/gunan/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 10, "created_at": "2017-03-14T11:35:04Z", "updated_at": "2018-02-02T15:33:13Z", "closed_at": "2017-06-16T21:00:14Z", "author_association": "CONTRIBUTOR", "body_html": "<h3>Issue description</h3>\n<p>Tensorflow currently fails with the following error if compiled using <code>clang</code> in <code>-c opt</code> mode when trying to import <code>tensorflow.contrib</code> package in Python .</p>\n<p>Python code reproducing the problem is very simple:</p>\n<pre><code>import tensorflow.contrib\n</code></pre>\n<p>Program output:</p>\n<pre><code>[libprotobuf ERROR external/protobuf/src/google/protobuf/descriptor_database.cc:57] File already exists in database: tensorflow/core/example/example.proto\n[libprotobuf FATAL external/protobuf/src/google/protobuf/descriptor.cc:1275] CHECK failed: generated_database_-&gt;Add(encoded_file_descriptor, size): \nterminate called after throwing an instance of 'google::protobuf::FatalException'\n  what():  CHECK failed: generated_database_-&gt;Add(encoded_file_descriptor, size): \n</code></pre>\n<p>The short story is that protobufs are getting statically linked into two shared libraries, both of which get loaded at runtime and that causes the error.</p>\n<p>Here's the full breakdown of what happens:</p>\n<ol>\n<li>Protobufs (<code>//tensorflow/core:protos_all_cc</code>) get compiled as a static library.</li>\n<li>Protobufs (<code>//tensorflow/core:protos_all_cc</code>) get statically linked into two separate shared libraries: <code>_pywrap_tensorflow_internal.so</code> and <code>_pywrap_tensorflow_print_model_analysis_lib.so</code>.</li>\n<li>While compiling those clang inlines the protobuf initialization code(<code>AddDescriptors</code>) inside <code>example.pb.cc</code>(look for it in <code>bazel-genfiles</code>)  to the global initialization code of both shared libraries.</li>\n<li><code>python run.py</code> starts running. While processing python's import statement, dynamic linker gets called to load <code>_pywrap_tensorflow_internal.so</code>. Static initialization code inside <code>example.pb.cc</code> is run, registering it to the protobuf database of <code>_pywrap_tensorflow_internal.so</code></li>\n<li>At a later point <code>_pywrap_tensorflow_print_model_analysis_lib.so</code> gets loaded. Since python calls <code>dlopen</code> with <code>RTLD_GLOBAL</code> dynamic linker finds an existing symbols for <code>AddDescriptorsImpl</code> in <code>_pywrap_tensorflow_internal.so</code> and uses that for all calls to that function later(for calls coming from <code>_pywrap_tensorflow_print_model_analysis_lib.so</code> too).</li>\n<li>Static initialization code inside <code>example.pb.cc</code> is run again (for <code>_pywrap_tensorflow_print_model_analysis_lib.so</code>), it calls <code>AddDescriptorsImpl</code> and gets into the function from <code>_pywrap_tensorflow_internal.so</code>, which tries to registers the same file again in the protobuf database of <code>_pywrap_tensorflow_internal.so</code> leading to the specified error.</li>\n</ol>\n<p>Here are a few observations that may be interesting:</p>\n<ol>\n<li>It works with <code>gcc</code>, because <code>gcc</code> doesn't inline <code>AddDescriptors</code> to the global initialization code of libraries, then dynamic linker merges those two functions into one, and that function has a proper check for being called multiple times(<code>AddDescriptorsImpl</code>, which is getting called after inlining doesn't). But note that it may break too if <code>gcc</code> will start inlining <code>AddDescriptors</code> in a newer version.</li>\n<li>It works on Mac, because dynamic linker there doesn't merge corresponding functions into one. Note that it means we get multiple protobuf databases(one for each loaded shared library that has protobufs in it) and can probably lead to other problems.</li>\n</ol>\n<h3>Environment info</h3>\n<p>Operating System: ubuntu 14.04<br>\nInstalled version of CUDA and cuDNN: none</p>\n<ol>\n<li>The commit hash (<code>git rev-parse HEAD</code>)<br>\n<code>ff9682b5f493ae7ad912da29789668dbf50d5e1f</code></li>\n<li>The output of <code>bazel version</code><br>\n<code>Build label: 0.4.4 Build target: bazel-out/local-fastbuild/bin/src/main/java/com/google/devtools/build/lib/bazel/BazelServer_deploy.jar Build time: Wed Feb 1 18:54:21 2017 (1485975261) Build timestamp: 1485975261 Build timestamp as int: 1485975261 </code></li>\n</ol>\n<h3>Repro</h3>\n<ol>\n<li>Extract <a href=\"https://github.com/tensorflow/tensorflow/files/841040/test.zip\">test.zip</a> to the repository root(it's a sample python target that fails)</li>\n<li>Make sure <code>clang</code> is installed. My version is <code>3.8.0-2ubuntu3~trusty4</code>, but that shouldn't matter.</li>\n<li>Configure with</li>\n</ol>\n<pre><code>export CC=/usr/bin/clang\nTF_NEED_JEMALLOC=1 TF_NEED_GCP=0 TF_NEED_HDFS=0 \\\nTF_ENABLE_XLA=0 TF_NEED_OPENCL=0 TF_NEED_CUDA=0 \\\nyes \"\"  | ./configure\n</code></pre>\n<ol start=\"3\">\n<li>Build and run with opt</li>\n</ol>\n<pre><code>bazel run -c opt //test:run\n</code></pre>", "body_text": "Issue description\nTensorflow currently fails with the following error if compiled using clang in -c opt mode when trying to import tensorflow.contrib package in Python .\nPython code reproducing the problem is very simple:\nimport tensorflow.contrib\n\nProgram output:\n[libprotobuf ERROR external/protobuf/src/google/protobuf/descriptor_database.cc:57] File already exists in database: tensorflow/core/example/example.proto\n[libprotobuf FATAL external/protobuf/src/google/protobuf/descriptor.cc:1275] CHECK failed: generated_database_->Add(encoded_file_descriptor, size): \nterminate called after throwing an instance of 'google::protobuf::FatalException'\n  what():  CHECK failed: generated_database_->Add(encoded_file_descriptor, size): \n\nThe short story is that protobufs are getting statically linked into two shared libraries, both of which get loaded at runtime and that causes the error.\nHere's the full breakdown of what happens:\n\nProtobufs (//tensorflow/core:protos_all_cc) get compiled as a static library.\nProtobufs (//tensorflow/core:protos_all_cc) get statically linked into two separate shared libraries: _pywrap_tensorflow_internal.so and _pywrap_tensorflow_print_model_analysis_lib.so.\nWhile compiling those clang inlines the protobuf initialization code(AddDescriptors) inside example.pb.cc(look for it in bazel-genfiles)  to the global initialization code of both shared libraries.\npython run.py starts running. While processing python's import statement, dynamic linker gets called to load _pywrap_tensorflow_internal.so. Static initialization code inside example.pb.cc is run, registering it to the protobuf database of _pywrap_tensorflow_internal.so\nAt a later point _pywrap_tensorflow_print_model_analysis_lib.so gets loaded. Since python calls dlopen with RTLD_GLOBAL dynamic linker finds an existing symbols for AddDescriptorsImpl in _pywrap_tensorflow_internal.so and uses that for all calls to that function later(for calls coming from _pywrap_tensorflow_print_model_analysis_lib.so too).\nStatic initialization code inside example.pb.cc is run again (for _pywrap_tensorflow_print_model_analysis_lib.so), it calls AddDescriptorsImpl and gets into the function from _pywrap_tensorflow_internal.so, which tries to registers the same file again in the protobuf database of _pywrap_tensorflow_internal.so leading to the specified error.\n\nHere are a few observations that may be interesting:\n\nIt works with gcc, because gcc doesn't inline AddDescriptors to the global initialization code of libraries, then dynamic linker merges those two functions into one, and that function has a proper check for being called multiple times(AddDescriptorsImpl, which is getting called after inlining doesn't). But note that it may break too if gcc will start inlining AddDescriptors in a newer version.\nIt works on Mac, because dynamic linker there doesn't merge corresponding functions into one. Note that it means we get multiple protobuf databases(one for each loaded shared library that has protobufs in it) and can probably lead to other problems.\n\nEnvironment info\nOperating System: ubuntu 14.04\nInstalled version of CUDA and cuDNN: none\n\nThe commit hash (git rev-parse HEAD)\nff9682b5f493ae7ad912da29789668dbf50d5e1f\nThe output of bazel version\nBuild label: 0.4.4 Build target: bazel-out/local-fastbuild/bin/src/main/java/com/google/devtools/build/lib/bazel/BazelServer_deploy.jar Build time: Wed Feb 1 18:54:21 2017 (1485975261) Build timestamp: 1485975261 Build timestamp as int: 1485975261 \n\nRepro\n\nExtract test.zip to the repository root(it's a sample python target that fails)\nMake sure clang is installed. My version is 3.8.0-2ubuntu3~trusty4, but that shouldn't matter.\nConfigure with\n\nexport CC=/usr/bin/clang\nTF_NEED_JEMALLOC=1 TF_NEED_GCP=0 TF_NEED_HDFS=0 \\\nTF_ENABLE_XLA=0 TF_NEED_OPENCL=0 TF_NEED_CUDA=0 \\\nyes \"\"  | ./configure\n\n\nBuild and run with opt\n\nbazel run -c opt //test:run", "body": "### Issue description\r\nTensorflow currently fails with the following error if compiled using `clang` in `-c opt` mode when trying to import `tensorflow.contrib` package in Python .\r\n\r\nPython code reproducing the problem is very simple: \r\n```\r\nimport tensorflow.contrib\r\n```\r\n\r\nProgram output:\r\n```\r\n[libprotobuf ERROR external/protobuf/src/google/protobuf/descriptor_database.cc:57] File already exists in database: tensorflow/core/example/example.proto\r\n[libprotobuf FATAL external/protobuf/src/google/protobuf/descriptor.cc:1275] CHECK failed: generated_database_->Add(encoded_file_descriptor, size): \r\nterminate called after throwing an instance of 'google::protobuf::FatalException'\r\n  what():  CHECK failed: generated_database_->Add(encoded_file_descriptor, size): \r\n```\r\n\r\nThe short story is that protobufs are getting statically linked into two shared libraries, both of which get loaded at runtime and that causes the error.\r\n\r\nHere's the full breakdown of what happens:\r\n1. Protobufs (`//tensorflow/core:protos_all_cc`) get compiled as a static library.\r\n1. Protobufs (`//tensorflow/core:protos_all_cc`) get statically linked into two separate shared libraries: `_pywrap_tensorflow_internal.so` and `_pywrap_tensorflow_print_model_analysis_lib.so`.\r\n2. While compiling those clang inlines the protobuf initialization code(`AddDescriptors`) inside `example.pb.cc`(look for it in `bazel-genfiles`)  to the global initialization code of both shared libraries.\r\n3. `python run.py` starts running. While processing python's import statement, dynamic linker gets called to load `_pywrap_tensorflow_internal.so`. Static initialization code inside `example.pb.cc` is run, registering it to the protobuf database of `_pywrap_tensorflow_internal.so`\r\n4. At a later point `_pywrap_tensorflow_print_model_analysis_lib.so` gets loaded. Since python calls `dlopen` with `RTLD_GLOBAL` dynamic linker finds an existing symbols for `AddDescriptorsImpl` in `_pywrap_tensorflow_internal.so` and uses that for all calls to that function later(for calls coming from `_pywrap_tensorflow_print_model_analysis_lib.so` too). \r\n5. Static initialization code inside `example.pb.cc` is run again (for `_pywrap_tensorflow_print_model_analysis_lib.so`), it calls `AddDescriptorsImpl` and gets into the function from `_pywrap_tensorflow_internal.so`, which tries to registers the same file again in the protobuf database of `_pywrap_tensorflow_internal.so` leading to the specified error.\r\n\r\nHere are a few observations that may be interesting:\r\n1. It works with `gcc`, because `gcc` doesn't inline `AddDescriptors` to the global initialization code of libraries, then dynamic linker merges those two functions into one, and that function has a proper check for being called multiple times(`AddDescriptorsImpl`, which is getting called after inlining doesn't). But note that it may break too if `gcc` will start inlining `AddDescriptors` in a newer version.\r\n2. It works on Mac, because dynamic linker there doesn't merge corresponding functions into one. Note that it means we get multiple protobuf databases(one for each loaded shared library that has protobufs in it) and can probably lead to other problems.\r\n\r\n### Environment info\r\nOperating System: ubuntu 14.04\r\nInstalled version of CUDA and cuDNN: none\r\n1. The commit hash (`git rev-parse HEAD`)\r\n`ff9682b5f493ae7ad912da29789668dbf50d5e1f`\r\n2. The output of `bazel version`\r\n`Build label: 0.4.4\r\nBuild target: bazel-out/local-fastbuild/bin/src/main/java/com/google/devtools/build/lib/bazel/BazelServer_deploy.jar\r\nBuild time: Wed Feb 1 18:54:21 2017 (1485975261)\r\nBuild timestamp: 1485975261\r\nBuild timestamp as int: 1485975261\r\n`\r\n\r\n### Repro\r\n\r\n1. Extract [test.zip](https://github.com/tensorflow/tensorflow/files/841040/test.zip) to the repository root(it's a sample python target that fails)\r\n1. Make sure `clang` is installed. My version is `3.8.0-2ubuntu3~trusty4`, but that shouldn't matter.\r\n2. Configure with \r\n```\r\nexport CC=/usr/bin/clang\r\nTF_NEED_JEMALLOC=1 TF_NEED_GCP=0 TF_NEED_HDFS=0 \\\r\nTF_ENABLE_XLA=0 TF_NEED_OPENCL=0 TF_NEED_CUDA=0 \\\r\nyes \"\"  | ./configure\r\n```\r\n3. Build and run with opt\r\n```\r\nbazel run -c opt //test:run\r\n```\r\n"}