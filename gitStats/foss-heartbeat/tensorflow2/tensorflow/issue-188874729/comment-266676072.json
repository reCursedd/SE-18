{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/266676072", "html_url": "https://github.com/tensorflow/tensorflow/pull/5558#issuecomment-266676072", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5558", "id": 266676072, "node_id": "MDEyOklzc3VlQ29tbWVudDI2NjY3NjA3Mg==", "user": {"login": "thuyen", "id": 4015328, "node_id": "MDQ6VXNlcjQwMTUzMjg=", "avatar_url": "https://avatars1.githubusercontent.com/u/4015328?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thuyen", "html_url": "https://github.com/thuyen", "followers_url": "https://api.github.com/users/thuyen/followers", "following_url": "https://api.github.com/users/thuyen/following{/other_user}", "gists_url": "https://api.github.com/users/thuyen/gists{/gist_id}", "starred_url": "https://api.github.com/users/thuyen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thuyen/subscriptions", "organizations_url": "https://api.github.com/users/thuyen/orgs", "repos_url": "https://api.github.com/users/thuyen/repos", "events_url": "https://api.github.com/users/thuyen/events{/privacy}", "received_events_url": "https://api.github.com/users/thuyen/received_events", "type": "User", "site_admin": false}, "created_at": "2016-12-13T08:26:02Z", "updated_at": "2016-12-13T08:26:02Z", "author_association": "CONTRIBUTOR", "body_html": "<p><code>name_scope</code> couldn't be a <code>string tensor</code>.<br>\nWith the old interface, one can create a single graph for both training and validation (like the following). In the new interface, it's only possible with some new argument <code>prefix</code> (a <code>tensor</code>) because the <code>name</code> argument can only be <code>string</code>. An example:</p>\n<pre><code>is_training = tf.placeholder(tf.bool)\ninputs, labels = data(is_training)\noutputs = model(inputs, is_training)\nloss = tf.reduce_mean(tf.square(output-labels))\ntrain_op = ....\n\nprefix = tf.cond(is_training, lambda: tf.constant('train/'), lambda: tf.constant('valid/'))\ntf.summary.scalar('loss', loss, prefix=prefix)\nsummary_op = tf.summary.merge_all()\n\n# Each training iteration\nsess.run([train_op, summary_op], feed_dict={is_training: True})\n\n# Validation\nsess.run(summary_op, feed_dict={is_training: False})\n</code></pre>", "body_text": "name_scope couldn't be a string tensor.\nWith the old interface, one can create a single graph for both training and validation (like the following). In the new interface, it's only possible with some new argument prefix (a tensor) because the name argument can only be string. An example:\nis_training = tf.placeholder(tf.bool)\ninputs, labels = data(is_training)\noutputs = model(inputs, is_training)\nloss = tf.reduce_mean(tf.square(output-labels))\ntrain_op = ....\n\nprefix = tf.cond(is_training, lambda: tf.constant('train/'), lambda: tf.constant('valid/'))\ntf.summary.scalar('loss', loss, prefix=prefix)\nsummary_op = tf.summary.merge_all()\n\n# Each training iteration\nsess.run([train_op, summary_op], feed_dict={is_training: True})\n\n# Validation\nsess.run(summary_op, feed_dict={is_training: False})", "body": "`name_scope` couldn't be a `string tensor`. \r\nWith the old interface, one can create a single graph for both training and validation (like the following). In the new interface, it's only possible with some new argument `prefix` (a `tensor`) because the `name` argument can only be `string`. An example:\r\n```\r\nis_training = tf.placeholder(tf.bool)\r\ninputs, labels = data(is_training)\r\noutputs = model(inputs, is_training)\r\nloss = tf.reduce_mean(tf.square(output-labels))\r\ntrain_op = ....\r\n\r\nprefix = tf.cond(is_training, lambda: tf.constant('train/'), lambda: tf.constant('valid/'))\r\ntf.summary.scalar('loss', loss, prefix=prefix)\r\nsummary_op = tf.summary.merge_all()\r\n\r\n# Each training iteration\r\nsess.run([train_op, summary_op], feed_dict={is_training: True})\r\n\r\n# Validation\r\nsess.run(summary_op, feed_dict={is_training: False})\r\n```\r\n"}