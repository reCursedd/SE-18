{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/361121411", "html_url": "https://github.com/tensorflow/tensorflow/issues/16279#issuecomment-361121411", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/16279", "id": 361121411, "node_id": "MDEyOklzc3VlQ29tbWVudDM2MTEyMTQxMQ==", "user": {"login": "Aashit-Sharma", "id": 29089622, "node_id": "MDQ6VXNlcjI5MDg5NjIy", "avatar_url": "https://avatars0.githubusercontent.com/u/29089622?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aashit-Sharma", "html_url": "https://github.com/Aashit-Sharma", "followers_url": "https://api.github.com/users/Aashit-Sharma/followers", "following_url": "https://api.github.com/users/Aashit-Sharma/following{/other_user}", "gists_url": "https://api.github.com/users/Aashit-Sharma/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aashit-Sharma/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aashit-Sharma/subscriptions", "organizations_url": "https://api.github.com/users/Aashit-Sharma/orgs", "repos_url": "https://api.github.com/users/Aashit-Sharma/repos", "events_url": "https://api.github.com/users/Aashit-Sharma/events{/privacy}", "received_events_url": "https://api.github.com/users/Aashit-Sharma/received_events", "type": "User", "site_admin": false}, "created_at": "2018-01-29T02:11:49Z", "updated_at": "2018-01-29T02:15:46Z", "author_association": "NONE", "body_html": "<pre><code>def nl_decoder_condition(self,it,outputs,hidden):\n\t\t\treturn it[0] &lt; self.oplen_nl[0]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t# This is the step where we concatenate hidden state with context hidden state \t\t\t\n\ndef nl_decoder_function(self,it,outputs,hidden):\n\t\t\tout,hidden = self.decoder_nl_cell(tf.stack([tf.concat(0,[outputs[-1,:],self.nl_context_concat])]) , tf.stack([hidden]))\n\t\t\t\n\t\t\toutputs = tf.concat(0,[outputs,out])\n\t\t\treturn it+1,outputs,hidden[0,:]\n\n</code></pre>\n<p>Sorry for the delayed response. These are all the functions necessary to run the nl_decoder .</p>\n<p>Placeholders:<br>\n<code>self.oplen_nl = tf.placeholder(tf.int32,[1],name=\"nl_oplen\") </code></p>\n<p>this comes in the graph function<br>\n<code>\t\t\tself.nl_context_concat = tf.concat(0,[self.current_hidden_nl_context,self.encoded_prediction]) </code></p>", "body_text": "def nl_decoder_condition(self,it,outputs,hidden):\n\t\t\treturn it[0] < self.oplen_nl[0]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t# This is the step where we concatenate hidden state with context hidden state \t\t\t\n\ndef nl_decoder_function(self,it,outputs,hidden):\n\t\t\tout,hidden = self.decoder_nl_cell(tf.stack([tf.concat(0,[outputs[-1,:],self.nl_context_concat])]) , tf.stack([hidden]))\n\t\t\t\n\t\t\toutputs = tf.concat(0,[outputs,out])\n\t\t\treturn it+1,outputs,hidden[0,:]\n\n\nSorry for the delayed response. These are all the functions necessary to run the nl_decoder .\nPlaceholders:\nself.oplen_nl = tf.placeholder(tf.int32,[1],name=\"nl_oplen\") \nthis comes in the graph function\n\t\t\tself.nl_context_concat = tf.concat(0,[self.current_hidden_nl_context,self.encoded_prediction])", "body": "```\r\ndef nl_decoder_condition(self,it,outputs,hidden):\r\n\t\t\treturn it[0] < self.oplen_nl[0]\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t# This is the step where we concatenate hidden state with context hidden state \t\t\t\r\n\r\ndef nl_decoder_function(self,it,outputs,hidden):\r\n\t\t\tout,hidden = self.decoder_nl_cell(tf.stack([tf.concat(0,[outputs[-1,:],self.nl_context_concat])]) , tf.stack([hidden]))\r\n\t\t\t\r\n\t\t\toutputs = tf.concat(0,[outputs,out])\r\n\t\t\treturn it+1,outputs,hidden[0,:]\r\n\r\n```\r\n\r\nSorry for the delayed response. These are all the functions necessary to run the nl_decoder . \r\n\r\n\r\nPlaceholders:\r\n`self.oplen_nl = tf.placeholder(tf.int32,[1],name=\"nl_oplen\")\r\n`\r\n\r\nthis comes in the graph function \r\n`\t\t\tself.nl_context_concat = tf.concat(0,[self.current_hidden_nl_context,self.encoded_prediction])\r\n`\r\n"}