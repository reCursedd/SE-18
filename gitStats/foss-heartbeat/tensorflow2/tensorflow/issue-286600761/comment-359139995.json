{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/359139995", "html_url": "https://github.com/tensorflow/tensorflow/issues/15933#issuecomment-359139995", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/15933", "id": 359139995, "node_id": "MDEyOklzc3VlQ29tbWVudDM1OTEzOTk5NQ==", "user": {"login": "Gemesys", "id": 16905336, "node_id": "MDQ6VXNlcjE2OTA1MzM2", "avatar_url": "https://avatars1.githubusercontent.com/u/16905336?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gemesys", "html_url": "https://github.com/Gemesys", "followers_url": "https://api.github.com/users/Gemesys/followers", "following_url": "https://api.github.com/users/Gemesys/following{/other_user}", "gists_url": "https://api.github.com/users/Gemesys/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gemesys/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gemesys/subscriptions", "organizations_url": "https://api.github.com/users/Gemesys/orgs", "repos_url": "https://api.github.com/users/Gemesys/repos", "events_url": "https://api.github.com/users/Gemesys/events{/privacy}", "received_events_url": "https://api.github.com/users/Gemesys/received_events", "type": "User", "site_admin": false}, "created_at": "2018-01-20T03:00:46Z", "updated_at": "2018-01-20T16:39:05Z", "author_association": "NONE", "body_html": "<p>Attached is part of a test suite from Univ. of California Berkeley, which was used to test and verify floating point operations on several machines, from DEC VAX and Sun Microsystems machines to early P/C's. It was originally written for Fortran77.  I've converted the \"pi.F\" program (to \"pi_new.F\") to compile and run in gFortran (GNU Fortran), in DP (double-precision) mode.   What I am seeing, is that the MacOS and CentOS-7.4 Linux produce exactly the same results, up to where the remainder value reaches floating point values where the exponent is near or slightly above 25.  (see the attached single screenshot, which shows the MacOS result on the left, the CentOS-7.4 result on the right.)</p>\n<p>i downloaded and installed \"gfortran\" binary for MacOS (the version 5.2 for Yosemite), and gfortran 4.8.5 (and gcc 4.8.5) are installed with CentOS-7.4.  On the Macbook, I installed macOS gfortran ver. 5.2 (for 10.10 Yosemite), as a .dmg binary.  Fortran binaries for MacOS available here:<br>\n<a href=\"https://gcc.gnu.org/wiki/GFortranBinaries\" rel=\"nofollow\">https://gcc.gnu.org/wiki/GFortranBinaries</a></p>\n<p>The \"pi_new.F\" program can be compiled with the following command line:</p>\n<pre><code>gfortran -cpp -D DP  pi_new.F -o  pi_new\n</code></pre>\n<p>The program calculates pi using progressively larger operands, and reports the results.  It also makes<br>\n<a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://user-images.githubusercontent.com/16905336/35179205-6c4df074-fd63-11e7-831f-5e4695eea65f.png\"><img src=\"https://user-images.githubusercontent.com/16905336/35179205-6c4df074-fd63-11e7-831f-5e4695eea65f.png\" alt=\"screen_shot_pi_new_test_2018_01_19_1\" style=\"max-width:100%;\"></a><br>\ntests for internal consistancy, which both platforms pass.  At iteration 8, the remainders are different. And at iterations 19 to 24 show serious divergence in the remainder values.   The remainder on iteration 23 on the Macbook, is the value for the the remainder for iteration 22 on the CentOS box, but with the sign flipped.   The remainder for iteration 22 on the Macbook (-1.37753244... E-40), is the value for the remainder for iteration 23 on the CentOS box, but again, with the sign flipped to positive.  But by iterations 24, 25 and 26, the results are exactly the same, only to diverge again for iterations 27 and 28.   To me, this seems to indicate a rather serious issue, which appears to be independent of TensorFlow.  The MacBook is giving different results than the 64-bit Linux box.</p>\n<p>So far, I just have this one program converted, but I will try to convert the entire test suite, and run it to see if the MacOS - Linux 64-bit floating-point calculations divergence shows up in other calculations.<br>\nThe \"pi_new.F\" program source is below...</p>\n<pre><code>C \"@(#)pirats.F 1.2 92/05/29 SMI\"\n\n#define STDERR 0\n#define STDOUT 6\n#define STDIN 5\n#ifdef SP\n#define REAL real*4\n#define EXPO e0\n#endif\n#ifdef DP\n#define REAL real*8\n#define EXPO d0\n#endif\n#ifdef QP\n#define REAL real*16\n#define EXPO q0\n#endif\n\n#ifdef TRIGP\n#define SIN sinp\n#define COS cosp\n#define TAN tanp\n#define ASIN asinp\n#define ACOS acosp\n#define ATAN atanp\n#else\n#define SIN sin\n#define COS cos\n#define TAN tan\n#define ASIN asin\n#define ACOS acos\n#define ATAN atan\n#endif\n\n      PROGRAM PIRATS\nC\nC.... PIRATS                     Copyright (C) by W. Kahan, Mar. 8, 1989\nC\nC.... This program finds close rational approximations\nC.... A/B to PI, and computes the differences C = PI-A/B to\nC.... working precision within errors no bigger than E.  Working\nC.... precision arithmetic is presumed to carry no more than about\nC.... 110 sig. dec., and to be rounded reasonably like a DEC VAX\nC.... or an HP calculator or in conformity with IEEE 754/854.\nC.... Then the program tests argument reductions in functions SIN,\nC.... COS and TAN, checking to see whether they are consistent\nC.... with the hypothesis that their actual periods are some single\nC.... close approximation 2*P to 2*PI if not 2*PI itself.\nC\n      INTEGER NPI\n      PARAMETER (NPI = 210)\nC\nC.... The following array of NPI+1 divisors D(J) &gt; 0 in the continued\nC.... fraction PI = D(0)+1/(D(1)+1/(D(2)+1/(D(3)+...))) will incur an\nC.... error in PI no worse than 3.6E-234. Only D(NPI) isn't an integer.\nC.... This data is based upon DJ's computed by Stewart McDonald\nC.... in 1983 from an algorithm due to W. Gosper.  W. K.\nC\n      INTEGER I,J,INC\n      REAL D(0:NPI),EPS,RDX,FL,A,B,C,E,R\n      DATA (D(I),I = 0,99)/\n     1   3. EXPO ,7. EXPO ,15. EXPO ,1. EXPO ,292. EXPO ,1. EXPO ,\n     1\t1. EXPO ,1. EXPO ,2. EXPO ,1. EXPO ,\n     2   3. EXPO ,1. EXPO ,14. EXPO ,2. EXPO ,1. EXPO ,1. EXPO ,\n     1\t2. EXPO ,2. EXPO ,2. EXPO ,2. EXPO ,\n     3   1. EXPO ,84. EXPO ,2. EXPO ,1. EXPO ,1. EXPO ,15. EXPO ,\n     1\t3. EXPO ,13. EXPO ,1. EXPO ,4. EXPO ,\n     4   2. EXPO ,6. EXPO ,6. EXPO ,99. EXPO ,1. EXPO ,2. EXPO ,\n     1\t2. EXPO ,6. EXPO ,3. EXPO ,5. EXPO ,\n     5   1. EXPO ,1. EXPO ,6. EXPO ,8. EXPO ,1. EXPO ,7. EXPO ,1. EXPO,\n     1\t2. EXPO ,3. EXPO ,7. EXPO ,\n     6   1. EXPO ,2. EXPO ,1. EXPO ,1. EXPO ,12. EXPO ,1. EXPO ,\n     1\t1. EXPO ,1. EXPO ,3. EXPO ,1. EXPO ,\n     7   1. EXPO ,8. EXPO ,1. EXPO ,1. EXPO ,2. EXPO ,1. EXPO ,6. EXPO,\n     1\t1. EXPO ,1. EXPO ,5. EXPO ,\n     8   2. EXPO ,2. EXPO ,3. EXPO ,1. EXPO ,2. EXPO ,4. EXPO ,4. EXPO,\n     1 \t16. EXPO ,1. EXPO ,161. EXPO , 45. EXPO ,1. EXPO ,22. EXPO ,\n     1\t1. EXPO ,2. EXPO ,2. EXPO,1. EXPO,4. EXPO ,1. EXPO ,2. EXPO ,\n     2  24. EXPO ,1. EXPO ,2. EXPO ,1. EXPO ,3. EXPO ,1. EXPO ,2. EXPO, \n     1  1. EXPO ,1. EXPO ,10. EXPO /\n\n      DATA (D(I),I = 100,199)/\n     1   2. EXPO ,5. EXPO ,4. EXPO ,1. EXPO ,2. EXPO ,2. EXPO ,8. EXPO ,\n     1\t1. EXPO ,5. EXPO ,2. EXPO ,\n     2   2. EXPO ,26. EXPO ,1. EXPO ,4. EXPO ,1. EXPO ,1. EXPO ,8. EXPO \n     1\t,2. EXPO ,42. EXPO ,2. EXPO ,\n     3   1. EXPO ,7. EXPO ,3. EXPO ,3. EXPO ,1. EXPO ,1. EXPO ,7. EXPO ,\n     1\t2. EXPO ,4. EXPO ,9. EXPO ,\n     4   7. EXPO ,2. EXPO ,3. EXPO ,1. EXPO ,57. EXPO ,1. EXPO ,18. EXPO\n     1\t ,1. EXPO ,9. EXPO ,19. EXPO ,\n     5   1. EXPO ,2. EXPO ,18. EXPO ,1. EXPO ,3. EXPO ,7. EXPO ,30. EXPO\n     1\t ,1. EXPO ,1. EXPO ,1. EXPO ,\n     6   3. EXPO ,3. EXPO ,3. EXPO ,1. EXPO ,2. EXPO ,8. EXPO ,1. EXPO ,\n     1\t1. EXPO ,2. EXPO ,1. EXPO ,\n     7   15. EXPO ,1. EXPO ,2. EXPO ,13. EXPO ,1. EXPO ,2. EXPO ,1. EXPO\n     1\t ,4. EXPO ,1. EXPO ,12. EXPO ,\n     8   1. EXPO ,1. EXPO ,3. EXPO ,3. EXPO ,28. EXPO ,1. EXPO ,10. EXPO\n     1\t ,3. EXPO ,2. EXPO ,20. EXPO ,\n     9   1. EXPO ,1. EXPO ,1. EXPO ,1. EXPO ,4. EXPO ,1. EXPO ,1. EXPO ,\n     1\t1. EXPO ,5. EXPO ,3. EXPO , 2. EXPO ,1. EXPO ,6. EXPO ,1. EXPO ,\n     1\t4. EXPO ,1. EXPO ,120. EXPO ,2. EXPO ,1. EXPO ,1. EXPO /\n      DATA (D(I),I = 200,NPI)/\n     1   3. EXPO ,1. EXPO ,23. EXPO ,1. EXPO ,15. EXPO ,1. EXPO ,3. EXPO\n     1\t ,7. EXPO ,1. EXPO ,16. EXPO ,\n     2   1.338371961073448 EXPO \n     3   /\nC\nC.... Environmental constants EPS, RDX, FL\nC\n      CALL ENVCNS(EPS,RDX,FL)\nC\nC.... for adequate accuracy\nC\n      INC = INT(LOG(FL)/LOG(2.6 EXPO ))\nC\n      PRINT 1000\n1000  FORMAT(1X,'PIRATS: computes  PI = A/B+C and R = PI-P.'/\n     1   /1X,1X,'J',1X,18X,'A',18X,'/',18X,'B'\n     2   /1X,2X,1X,27X,'+',5X,'C'\n     3   /1X,2X,1X,41X,'R',5X,'+/-',5X,'E'\n     4   )\nC\nC.... Initialize A, B\nC\n      A = D(0)\n      B = 1. EXPO \nC\n      DO 100 J = 1,NPI-INC+5\nC\nC.... Get next pair A, B\nC\n         CALL NEXTAB(D(J),A,B)\n         IF (A.GT.FL.OR.B.GT.FL) THEN\n\t    GOTO 110\n\t ENDIF\nC\nC....    Get C = PI-A/B+/-E\nC\n         CALL GETCE(NPI,J,INC,EPS,FL,D,C,E)\nC\nC....    Get R = PI-P+/-E\nC\n         CALL TSTRIG(EPS,A,B,C,E,R)\nC\nC....    Display these numbers\nC\n         CALL DISPLA(J,A,B,C,E,R)\nC\nC....    Test them for consistency\nC\n         CALL COMPAR(E,R)\n100   CONTINUE\n110   CONTINUE\nC\nC.... Normal termination.\nC\n      PRINT *,'Pi.F -- Normal Termination. '\n      PRINT *,'I want to: call ucbpass'\nC      call ucbpass\n      STOP\n      END\nC\n\tREAL function volatilizer(x)\n\tREAL x\n\tvolatilizer=x\n\tend\n\n      SUBROUTINE ENVCNS(EPS,RDX,FL)\n      REAL EPS,RDX,FL\nC\nC.... Environmental constants.  This subroutine computes\nC....    EPS = nextafter(1,2)-1 = 1.000...001-1\nC....    RDX = RaDiX of floating-point arithmetic (2, 10, 16)\nC....    FL = RDX/EPS = last of consecutive floating-point integers\nC....                       among 1, 2, 3, ..., FL-2, FL-1, FL.\nC\nC.... local variables\nC\n\tREAL volatilizer\n      REAL H,X,Y,T,U,V\nC\nC.... First seek EPS\nC\n      T = 4. EXPO /3. EXPO \n      X = T-1. EXPO \n      Y = ABS((X+X-1. EXPO )+X)/64. EXPO \n      EPS = 0. EXPO \n      IF (Y.EQ.0. EXPO ) THEN\n\t PRINT *,'Is 4/3 exact?'\n         GOTO 299\n      ENDIF\n200   IF (EPS.NE.0. EXPO ) GOTO 210\n         U = volatilizer(1. EXPO +Y)\n         EPS = volatilizer(U-1. EXPO) \n         Y = Y+Y\n      GOTO 200\nC\nC     Now seek EPS/RDX = 1-nextafter(1,0) = 1-0.999...999 :\nC\n210   H = 1. EXPO /2. EXPO \n      T = 2. EXPO /3. EXPO \n      X = T-H\n      Y = ABS((X+X-H)+X)/64. EXPO \n      V = 0. EXPO \n      IF (Y.EQ.0. EXPO ) THEN\n\t PRINT *,'Is 2/3 exact?'\n         GOTO 299\n      ENDIF\n220   IF (V.NE.0. EXPO ) GOTO 230\n         U = volatilizer((H-Y)+H)\n         V = volatilizer((H-U)+H)\n         Y = Y+Y\n      GOTO 220\nC\nC.... in case Division is dirty\nC\n230   RDX = AINT(EPS/V+0.0001 EXPO )\n      IF (RDX.LT.2. EXPO ) THEN\n\t PRINT 5000,'Radix =',RDX\n5000     FORMAT(1X,A,F4.0)\n         GOTO 299\n      ENDIF\nC\nC.... Confirm that RDX = Radix of Floating-point arithmetic.\nC\n      T = RDX\n      X = 1. EXPO \nC\nC.... until X.EQ.0 or X.EQ.RDX\nC\n240   IF (X.NE.1. EXPO ) GOTO 250\n         T = T+T\n         U = volatilizer(T+1. EXPO)\n         X = volatilizer(U-T)\n      GOTO 240\n250   IF (X.EQ.0. EXPO ) THEN\n         Y = 1. EXPO \n260      IF (X.NE.0. EXPO ) GOTO 270\n            Y = Y+Y\n            U = volatilizer(T+Y)\n            X = volatilizer(U-T)\n\t GOTO 260\n      ENDIF\n270   IF (X.NE.RDX) THEN\n         PRINT 6000,'Is Radix ',X,' or ',RDX,'?'\n6000     FORMAT(1X,A,F4.0,A,F4.0,A)\n\t GOTO 299\n      ENDIF\nC\nC.... Confirm that FL = RDX/EPS:\nC\n      FL = RDX\n      X = 1. EXPO \n280   IF (X.NE.1. EXPO ) GOTO 290\n         FL = volatilizer(FL*RDX)\n\t U = volatilizer(FL+1. EXPO)\n\t X = volatilizer(U-FL)\n      GOTO 280\n290   IF (FL*V.EQ.1. EXPO ) THEN\n\t RETURN\n      ENDIF\nC\nC.... ENVCNS cannot compute environmental constants correctly:\nC\n      PRINT 3000,'Is FL ',FL,' or ',1. EXPO /V,'?'\n3000  FORMAT(1X,A6,1PE45.37E3/1X,2X,A4,1PE45.37E3,A1)\n299   PRINT *,'Subroutine ENVCNS cannot compute correctly the'\n      PRINT *,'Environmental constants'\n      PRINT *,'EPS = 1.000...001 - 1 , and'\n      PRINT *,'FL = Last consecutive Floating-point integer'\n      PRINT *,'        among 1, 2, 3, ..., FL-2, FL-1, FL.'\n      PRINT *,'Please substitute them for the subroutine.'\n      PRINT *,'I want to: call ucbfail'\nC\tcall ucbfail\n      STOP\n      END\nC\n      SUBROUTINE NEXTAB(DJ,A,B)\n      REAL DJ,A,B\nC\nC.... Get next pair A, B\nC\nC.... local variables\nC\n      REAL T,A0,B0\n      SAVE A0,B0\n      DATA A0,B0/1. EXPO ,0. EXPO /\nC\n      T = DJ*B+B0\n      B0 = B\n      B = T\n      T = DJ*A+A0\n      A0 = A\n      A = T\nC\nC.... Now A/B = D0+1/(D1+1/(D2+...+1/DJ)).\nC\n      RETURN\n      END\nC\n      SUBROUTINE GETCE(NPI,J,INC,EPS,FL,D,C,E)\n      INTEGER NPI,J,INC\n      REAL EPS,FL,D(0:NPI),C,E\nC\nC.... This subroutine computes the continued fraction's tail\nC....    Z = D(J+1)+1/(D(J+2)+1/(D(J+3)+1/(D(J+4)+...)))\nC.... to working accuracy by using INC terms of it, and then\nC.... computes the effect C of cutting it off to get A/B .\nC....\nC.... Get  C = PI-A/B+/-E\nC\nC.... local variables\nC\n      INTEGER I,I9\n      REAL X,Y,Z\nC\n      I9 = MIN(NPI,J+INC)\n      Z = D(I9)\n      DO 400 I = I9-1,J+1,-1\n         Z = D(I)+1. EXPO /Z\n400   CONTINUE\n      X = FL*FL\nC\nC.... C = 1/Z-1/X always\nC\n      C = 1. EXPO /Z-1. EXPO /X\n      DO 410 I = J,1,-1\n\t Y = D(I)\n         Z = Y+1. EXPO /Z\n\t X = Y+1. EXPO /X\n\t C = -C/(X*Z)\n410   CONTINUE\nC\nC.... E &gt; accumulated roundoff (mixed arithmetic)\nC\n      E = 4. EXPO *J*EPS*ABS(C)\n      RETURN\n      END\nC\n      SUBROUTINE TSTRIG(EPS,A,B,C,E,R)\n      REAL EPS,A,B,C,E,R\nC\nC.... Get R = PI-P+/-E\nC\nC     This subroutine tests whether the programs that compute\nC     TRIG(X) = trig(X*PI/P) for TRIG = SIN, COS or TAN\nC     always use the same approximation P to PI during their\nC     argument reduction.  If so, 3 or 4 values R = Q+C\nC     derived from A = B*(PI-C+/-E) ought to agree.\nC\nC.... local variables\nC\n      REAL Q,Q0,S,W,W0,X,Y\n      CHARACTER*11 TS\nC\n      REAL FNODD\n      CHARACTER FNS\nC\n      CHARACTER*10 SI,CO,TA\n      DATA SI,CO,TA/'arcsin(sin','arcsin(cos','arctan(tan'/\nC\nC.... FNODD(floating-point integer X) = (-1)**X\nC\n      FNODD(X) = (AINT(ABS(X)*0.5 EXPO +0.125 EXPO )*2. EXPO -ABS(X))*\n     1\t2. EXPO +1. EXPO \nC\nC.... FNS(1) = '+', FNS(-1) = '-'\nC\n      FNS(X) = CHAR(44-INT(X))\nC\n      Q = ATAN(TAN(A))/B\n      R = Q+C\n      W = 3. EXPO *EPS*ABS(Q)\n      E = E+W\n      S = FNODD(B)\n      X = A\n      Y = B\n      TS = FNS(S)//SI\n      Q0 = ASIN(SIN(X))/Y*S\n      W0 = W+6. EXPO *EPS*ABS(Q0)\n      CALL WHET(Q,Q0,W0,X,Y,A,B,TS,TA)\n      X = A*0.5 EXPO \n      Y = B*0.5 EXPO \n      IF (S.LT.0. EXPO ) THEN\nC\nC....    (B+1) is even\nC\n         S = FNODD((B+1. EXPO )*0.5 EXPO )\n         TS = FNS(S)//CO\n         Q0 = ASIN(COS(X))/Y*S\n         W0 = W+6. EXPO *EPS*ABS(Q0)\n      ELSE\nC\nC....    B = 2y is even\nC\n         TS = ' '//TA\n         Q0 = ATAN(TAN(X))/Y\n         W0 = 3. EXPO *EPS*ABS(Q0)\n\t CALL WHET(Q,Q0,W0,X,Y,A,B,TS,TA)\n         S = FNODD(Y)\n         TS = FNS(S)//SI\n\t Q0 = ASIN(SIN(X))/Y*S\n         W0 = W+6. EXPO *EPS*ABS(Q0)\n      ENDIF\n      CALL WHET(Q,Q0,W0,X,Y,A,B,TS,TA)\n      RETURN\n      END\nC\n      SUBROUTINE WHET(Q,Q0,W0,X,Y,A,B,TS,TA)\n      REAL Q,Q0,W0,X,Y,A,B\n      CHARACTER*(*) TS,TA\nC\nC.... Test whether Q0.EQ.Q within +/- W0 (.GE.-&gt;.GT.)\nC\n      IF (ABS(Q-Q0).GT.W0) THEN\nC\nC....    Difference too big suggests P is not a constant after all.\nC\n         PRINT 4000,TS,X,')/',Y,' =',Q0,' differs from ',\n     1      TA,A,')/',B,' =',Q,' too much.'\n4000  FORMAT(/1X,4X,70('%')\n     1   /1X,4X,A11,0PF38.1,A\n     2   /1X,4X,11X,0PF38.1,A\n     3   /1X,4X,11X,1PE45.37E3,A\n     4   /1X,4X,1X,A10,0PF38.1,A\n     5   /1X,4X,11X,0PF38.1,A\n     6   /1X,4X,11X,1PE45.37E3,A\n     7   /1X,4X,70('%')\n     8   /)\n\n\n      PRINT *,'I want to: call ucbfail'\nC\tcall ucbfail\n      ENDIF\n      RETURN\n      END\nC\n      SUBROUTINE DISPLA(J,A,B,C,E,R)\n      INTEGER J\n      REAL A,B,C,E,R\nC\nC     Display Formatting\nC\nC.... display  J, A, B, C, R, E\nC\n      PRINT 2000,J,A,B,C,R,E\n2000  FORMAT(1X,I2,1X,F37.0,'/',F37.0\n     1   /1X,2X,1X,27X,'+',1X,1PE45.37E3\n     2   /1X,2X,1X,1X,1PE45.37E3,1X,'+/-',1PE16.8E3\n     3   )\n      RETURN\n      END\nC\n      SUBROUTINE COMPAR(E,R)\n      REAL E,R\nC\nC.... test for consistency\nC\nC.... local variables\nC\n      REAL E0,R0\n      SAVE E0,R0\n      DATA E0,R0/0.1416 EXPO ,0. EXPO /\nC\nC.... .LT.-&gt;.LE.\nC\n      IF (ABS(R-R0).LE.E+E0) THEN\n\t E0 = E\n         R0 = R\n      ELSE\n         PRINT *,'Varying R implies defective argument reduction.'\n         PRINT *,'I want to: call ucbfail'\nC\tcall ucbfail\n         STOP\n      ENDIF\n      RETURN\n      END\n</code></pre>\n<p>Will update here with results for full ucb floating point test suite when I get it to compile &amp; run.</p>", "body_text": "Attached is part of a test suite from Univ. of California Berkeley, which was used to test and verify floating point operations on several machines, from DEC VAX and Sun Microsystems machines to early P/C's. It was originally written for Fortran77.  I've converted the \"pi.F\" program (to \"pi_new.F\") to compile and run in gFortran (GNU Fortran), in DP (double-precision) mode.   What I am seeing, is that the MacOS and CentOS-7.4 Linux produce exactly the same results, up to where the remainder value reaches floating point values where the exponent is near or slightly above 25.  (see the attached single screenshot, which shows the MacOS result on the left, the CentOS-7.4 result on the right.)\ni downloaded and installed \"gfortran\" binary for MacOS (the version 5.2 for Yosemite), and gfortran 4.8.5 (and gcc 4.8.5) are installed with CentOS-7.4.  On the Macbook, I installed macOS gfortran ver. 5.2 (for 10.10 Yosemite), as a .dmg binary.  Fortran binaries for MacOS available here:\nhttps://gcc.gnu.org/wiki/GFortranBinaries\nThe \"pi_new.F\" program can be compiled with the following command line:\ngfortran -cpp -D DP  pi_new.F -o  pi_new\n\nThe program calculates pi using progressively larger operands, and reports the results.  It also makes\n\ntests for internal consistancy, which both platforms pass.  At iteration 8, the remainders are different. And at iterations 19 to 24 show serious divergence in the remainder values.   The remainder on iteration 23 on the Macbook, is the value for the the remainder for iteration 22 on the CentOS box, but with the sign flipped.   The remainder for iteration 22 on the Macbook (-1.37753244... E-40), is the value for the remainder for iteration 23 on the CentOS box, but again, with the sign flipped to positive.  But by iterations 24, 25 and 26, the results are exactly the same, only to diverge again for iterations 27 and 28.   To me, this seems to indicate a rather serious issue, which appears to be independent of TensorFlow.  The MacBook is giving different results than the 64-bit Linux box.\nSo far, I just have this one program converted, but I will try to convert the entire test suite, and run it to see if the MacOS - Linux 64-bit floating-point calculations divergence shows up in other calculations.\nThe \"pi_new.F\" program source is below...\nC \"@(#)pirats.F 1.2 92/05/29 SMI\"\n\n#define STDERR 0\n#define STDOUT 6\n#define STDIN 5\n#ifdef SP\n#define REAL real*4\n#define EXPO e0\n#endif\n#ifdef DP\n#define REAL real*8\n#define EXPO d0\n#endif\n#ifdef QP\n#define REAL real*16\n#define EXPO q0\n#endif\n\n#ifdef TRIGP\n#define SIN sinp\n#define COS cosp\n#define TAN tanp\n#define ASIN asinp\n#define ACOS acosp\n#define ATAN atanp\n#else\n#define SIN sin\n#define COS cos\n#define TAN tan\n#define ASIN asin\n#define ACOS acos\n#define ATAN atan\n#endif\n\n      PROGRAM PIRATS\nC\nC.... PIRATS                     Copyright (C) by W. Kahan, Mar. 8, 1989\nC\nC.... This program finds close rational approximations\nC.... A/B to PI, and computes the differences C = PI-A/B to\nC.... working precision within errors no bigger than E.  Working\nC.... precision arithmetic is presumed to carry no more than about\nC.... 110 sig. dec., and to be rounded reasonably like a DEC VAX\nC.... or an HP calculator or in conformity with IEEE 754/854.\nC.... Then the program tests argument reductions in functions SIN,\nC.... COS and TAN, checking to see whether they are consistent\nC.... with the hypothesis that their actual periods are some single\nC.... close approximation 2*P to 2*PI if not 2*PI itself.\nC\n      INTEGER NPI\n      PARAMETER (NPI = 210)\nC\nC.... The following array of NPI+1 divisors D(J) > 0 in the continued\nC.... fraction PI = D(0)+1/(D(1)+1/(D(2)+1/(D(3)+...))) will incur an\nC.... error in PI no worse than 3.6E-234. Only D(NPI) isn't an integer.\nC.... This data is based upon DJ's computed by Stewart McDonald\nC.... in 1983 from an algorithm due to W. Gosper.  W. K.\nC\n      INTEGER I,J,INC\n      REAL D(0:NPI),EPS,RDX,FL,A,B,C,E,R\n      DATA (D(I),I = 0,99)/\n     1   3. EXPO ,7. EXPO ,15. EXPO ,1. EXPO ,292. EXPO ,1. EXPO ,\n     1\t1. EXPO ,1. EXPO ,2. EXPO ,1. EXPO ,\n     2   3. EXPO ,1. EXPO ,14. EXPO ,2. EXPO ,1. EXPO ,1. EXPO ,\n     1\t2. EXPO ,2. EXPO ,2. EXPO ,2. EXPO ,\n     3   1. EXPO ,84. EXPO ,2. EXPO ,1. EXPO ,1. EXPO ,15. EXPO ,\n     1\t3. EXPO ,13. EXPO ,1. EXPO ,4. EXPO ,\n     4   2. EXPO ,6. EXPO ,6. EXPO ,99. EXPO ,1. EXPO ,2. EXPO ,\n     1\t2. EXPO ,6. EXPO ,3. EXPO ,5. EXPO ,\n     5   1. EXPO ,1. EXPO ,6. EXPO ,8. EXPO ,1. EXPO ,7. EXPO ,1. EXPO,\n     1\t2. EXPO ,3. EXPO ,7. EXPO ,\n     6   1. EXPO ,2. EXPO ,1. EXPO ,1. EXPO ,12. EXPO ,1. EXPO ,\n     1\t1. EXPO ,1. EXPO ,3. EXPO ,1. EXPO ,\n     7   1. EXPO ,8. EXPO ,1. EXPO ,1. EXPO ,2. EXPO ,1. EXPO ,6. EXPO,\n     1\t1. EXPO ,1. EXPO ,5. EXPO ,\n     8   2. EXPO ,2. EXPO ,3. EXPO ,1. EXPO ,2. EXPO ,4. EXPO ,4. EXPO,\n     1 \t16. EXPO ,1. EXPO ,161. EXPO , 45. EXPO ,1. EXPO ,22. EXPO ,\n     1\t1. EXPO ,2. EXPO ,2. EXPO,1. EXPO,4. EXPO ,1. EXPO ,2. EXPO ,\n     2  24. EXPO ,1. EXPO ,2. EXPO ,1. EXPO ,3. EXPO ,1. EXPO ,2. EXPO, \n     1  1. EXPO ,1. EXPO ,10. EXPO /\n\n      DATA (D(I),I = 100,199)/\n     1   2. EXPO ,5. EXPO ,4. EXPO ,1. EXPO ,2. EXPO ,2. EXPO ,8. EXPO ,\n     1\t1. EXPO ,5. EXPO ,2. EXPO ,\n     2   2. EXPO ,26. EXPO ,1. EXPO ,4. EXPO ,1. EXPO ,1. EXPO ,8. EXPO \n     1\t,2. EXPO ,42. EXPO ,2. EXPO ,\n     3   1. EXPO ,7. EXPO ,3. EXPO ,3. EXPO ,1. EXPO ,1. EXPO ,7. EXPO ,\n     1\t2. EXPO ,4. EXPO ,9. EXPO ,\n     4   7. EXPO ,2. EXPO ,3. EXPO ,1. EXPO ,57. EXPO ,1. EXPO ,18. EXPO\n     1\t ,1. EXPO ,9. EXPO ,19. EXPO ,\n     5   1. EXPO ,2. EXPO ,18. EXPO ,1. EXPO ,3. EXPO ,7. EXPO ,30. EXPO\n     1\t ,1. EXPO ,1. EXPO ,1. EXPO ,\n     6   3. EXPO ,3. EXPO ,3. EXPO ,1. EXPO ,2. EXPO ,8. EXPO ,1. EXPO ,\n     1\t1. EXPO ,2. EXPO ,1. EXPO ,\n     7   15. EXPO ,1. EXPO ,2. EXPO ,13. EXPO ,1. EXPO ,2. EXPO ,1. EXPO\n     1\t ,4. EXPO ,1. EXPO ,12. EXPO ,\n     8   1. EXPO ,1. EXPO ,3. EXPO ,3. EXPO ,28. EXPO ,1. EXPO ,10. EXPO\n     1\t ,3. EXPO ,2. EXPO ,20. EXPO ,\n     9   1. EXPO ,1. EXPO ,1. EXPO ,1. EXPO ,4. EXPO ,1. EXPO ,1. EXPO ,\n     1\t1. EXPO ,5. EXPO ,3. EXPO , 2. EXPO ,1. EXPO ,6. EXPO ,1. EXPO ,\n     1\t4. EXPO ,1. EXPO ,120. EXPO ,2. EXPO ,1. EXPO ,1. EXPO /\n      DATA (D(I),I = 200,NPI)/\n     1   3. EXPO ,1. EXPO ,23. EXPO ,1. EXPO ,15. EXPO ,1. EXPO ,3. EXPO\n     1\t ,7. EXPO ,1. EXPO ,16. EXPO ,\n     2   1.338371961073448 EXPO \n     3   /\nC\nC.... Environmental constants EPS, RDX, FL\nC\n      CALL ENVCNS(EPS,RDX,FL)\nC\nC.... for adequate accuracy\nC\n      INC = INT(LOG(FL)/LOG(2.6 EXPO ))\nC\n      PRINT 1000\n1000  FORMAT(1X,'PIRATS: computes  PI = A/B+C and R = PI-P.'/\n     1   /1X,1X,'J',1X,18X,'A',18X,'/',18X,'B'\n     2   /1X,2X,1X,27X,'+',5X,'C'\n     3   /1X,2X,1X,41X,'R',5X,'+/-',5X,'E'\n     4   )\nC\nC.... Initialize A, B\nC\n      A = D(0)\n      B = 1. EXPO \nC\n      DO 100 J = 1,NPI-INC+5\nC\nC.... Get next pair A, B\nC\n         CALL NEXTAB(D(J),A,B)\n         IF (A.GT.FL.OR.B.GT.FL) THEN\n\t    GOTO 110\n\t ENDIF\nC\nC....    Get C = PI-A/B+/-E\nC\n         CALL GETCE(NPI,J,INC,EPS,FL,D,C,E)\nC\nC....    Get R = PI-P+/-E\nC\n         CALL TSTRIG(EPS,A,B,C,E,R)\nC\nC....    Display these numbers\nC\n         CALL DISPLA(J,A,B,C,E,R)\nC\nC....    Test them for consistency\nC\n         CALL COMPAR(E,R)\n100   CONTINUE\n110   CONTINUE\nC\nC.... Normal termination.\nC\n      PRINT *,'Pi.F -- Normal Termination. '\n      PRINT *,'I want to: call ucbpass'\nC      call ucbpass\n      STOP\n      END\nC\n\tREAL function volatilizer(x)\n\tREAL x\n\tvolatilizer=x\n\tend\n\n      SUBROUTINE ENVCNS(EPS,RDX,FL)\n      REAL EPS,RDX,FL\nC\nC.... Environmental constants.  This subroutine computes\nC....    EPS = nextafter(1,2)-1 = 1.000...001-1\nC....    RDX = RaDiX of floating-point arithmetic (2, 10, 16)\nC....    FL = RDX/EPS = last of consecutive floating-point integers\nC....                       among 1, 2, 3, ..., FL-2, FL-1, FL.\nC\nC.... local variables\nC\n\tREAL volatilizer\n      REAL H,X,Y,T,U,V\nC\nC.... First seek EPS\nC\n      T = 4. EXPO /3. EXPO \n      X = T-1. EXPO \n      Y = ABS((X+X-1. EXPO )+X)/64. EXPO \n      EPS = 0. EXPO \n      IF (Y.EQ.0. EXPO ) THEN\n\t PRINT *,'Is 4/3 exact?'\n         GOTO 299\n      ENDIF\n200   IF (EPS.NE.0. EXPO ) GOTO 210\n         U = volatilizer(1. EXPO +Y)\n         EPS = volatilizer(U-1. EXPO) \n         Y = Y+Y\n      GOTO 200\nC\nC     Now seek EPS/RDX = 1-nextafter(1,0) = 1-0.999...999 :\nC\n210   H = 1. EXPO /2. EXPO \n      T = 2. EXPO /3. EXPO \n      X = T-H\n      Y = ABS((X+X-H)+X)/64. EXPO \n      V = 0. EXPO \n      IF (Y.EQ.0. EXPO ) THEN\n\t PRINT *,'Is 2/3 exact?'\n         GOTO 299\n      ENDIF\n220   IF (V.NE.0. EXPO ) GOTO 230\n         U = volatilizer((H-Y)+H)\n         V = volatilizer((H-U)+H)\n         Y = Y+Y\n      GOTO 220\nC\nC.... in case Division is dirty\nC\n230   RDX = AINT(EPS/V+0.0001 EXPO )\n      IF (RDX.LT.2. EXPO ) THEN\n\t PRINT 5000,'Radix =',RDX\n5000     FORMAT(1X,A,F4.0)\n         GOTO 299\n      ENDIF\nC\nC.... Confirm that RDX = Radix of Floating-point arithmetic.\nC\n      T = RDX\n      X = 1. EXPO \nC\nC.... until X.EQ.0 or X.EQ.RDX\nC\n240   IF (X.NE.1. EXPO ) GOTO 250\n         T = T+T\n         U = volatilizer(T+1. EXPO)\n         X = volatilizer(U-T)\n      GOTO 240\n250   IF (X.EQ.0. EXPO ) THEN\n         Y = 1. EXPO \n260      IF (X.NE.0. EXPO ) GOTO 270\n            Y = Y+Y\n            U = volatilizer(T+Y)\n            X = volatilizer(U-T)\n\t GOTO 260\n      ENDIF\n270   IF (X.NE.RDX) THEN\n         PRINT 6000,'Is Radix ',X,' or ',RDX,'?'\n6000     FORMAT(1X,A,F4.0,A,F4.0,A)\n\t GOTO 299\n      ENDIF\nC\nC.... Confirm that FL = RDX/EPS:\nC\n      FL = RDX\n      X = 1. EXPO \n280   IF (X.NE.1. EXPO ) GOTO 290\n         FL = volatilizer(FL*RDX)\n\t U = volatilizer(FL+1. EXPO)\n\t X = volatilizer(U-FL)\n      GOTO 280\n290   IF (FL*V.EQ.1. EXPO ) THEN\n\t RETURN\n      ENDIF\nC\nC.... ENVCNS cannot compute environmental constants correctly:\nC\n      PRINT 3000,'Is FL ',FL,' or ',1. EXPO /V,'?'\n3000  FORMAT(1X,A6,1PE45.37E3/1X,2X,A4,1PE45.37E3,A1)\n299   PRINT *,'Subroutine ENVCNS cannot compute correctly the'\n      PRINT *,'Environmental constants'\n      PRINT *,'EPS = 1.000...001 - 1 , and'\n      PRINT *,'FL = Last consecutive Floating-point integer'\n      PRINT *,'        among 1, 2, 3, ..., FL-2, FL-1, FL.'\n      PRINT *,'Please substitute them for the subroutine.'\n      PRINT *,'I want to: call ucbfail'\nC\tcall ucbfail\n      STOP\n      END\nC\n      SUBROUTINE NEXTAB(DJ,A,B)\n      REAL DJ,A,B\nC\nC.... Get next pair A, B\nC\nC.... local variables\nC\n      REAL T,A0,B0\n      SAVE A0,B0\n      DATA A0,B0/1. EXPO ,0. EXPO /\nC\n      T = DJ*B+B0\n      B0 = B\n      B = T\n      T = DJ*A+A0\n      A0 = A\n      A = T\nC\nC.... Now A/B = D0+1/(D1+1/(D2+...+1/DJ)).\nC\n      RETURN\n      END\nC\n      SUBROUTINE GETCE(NPI,J,INC,EPS,FL,D,C,E)\n      INTEGER NPI,J,INC\n      REAL EPS,FL,D(0:NPI),C,E\nC\nC.... This subroutine computes the continued fraction's tail\nC....    Z = D(J+1)+1/(D(J+2)+1/(D(J+3)+1/(D(J+4)+...)))\nC.... to working accuracy by using INC terms of it, and then\nC.... computes the effect C of cutting it off to get A/B .\nC....\nC.... Get  C = PI-A/B+/-E\nC\nC.... local variables\nC\n      INTEGER I,I9\n      REAL X,Y,Z\nC\n      I9 = MIN(NPI,J+INC)\n      Z = D(I9)\n      DO 400 I = I9-1,J+1,-1\n         Z = D(I)+1. EXPO /Z\n400   CONTINUE\n      X = FL*FL\nC\nC.... C = 1/Z-1/X always\nC\n      C = 1. EXPO /Z-1. EXPO /X\n      DO 410 I = J,1,-1\n\t Y = D(I)\n         Z = Y+1. EXPO /Z\n\t X = Y+1. EXPO /X\n\t C = -C/(X*Z)\n410   CONTINUE\nC\nC.... E > accumulated roundoff (mixed arithmetic)\nC\n      E = 4. EXPO *J*EPS*ABS(C)\n      RETURN\n      END\nC\n      SUBROUTINE TSTRIG(EPS,A,B,C,E,R)\n      REAL EPS,A,B,C,E,R\nC\nC.... Get R = PI-P+/-E\nC\nC     This subroutine tests whether the programs that compute\nC     TRIG(X) = trig(X*PI/P) for TRIG = SIN, COS or TAN\nC     always use the same approximation P to PI during their\nC     argument reduction.  If so, 3 or 4 values R = Q+C\nC     derived from A = B*(PI-C+/-E) ought to agree.\nC\nC.... local variables\nC\n      REAL Q,Q0,S,W,W0,X,Y\n      CHARACTER*11 TS\nC\n      REAL FNODD\n      CHARACTER FNS\nC\n      CHARACTER*10 SI,CO,TA\n      DATA SI,CO,TA/'arcsin(sin','arcsin(cos','arctan(tan'/\nC\nC.... FNODD(floating-point integer X) = (-1)**X\nC\n      FNODD(X) = (AINT(ABS(X)*0.5 EXPO +0.125 EXPO )*2. EXPO -ABS(X))*\n     1\t2. EXPO +1. EXPO \nC\nC.... FNS(1) = '+', FNS(-1) = '-'\nC\n      FNS(X) = CHAR(44-INT(X))\nC\n      Q = ATAN(TAN(A))/B\n      R = Q+C\n      W = 3. EXPO *EPS*ABS(Q)\n      E = E+W\n      S = FNODD(B)\n      X = A\n      Y = B\n      TS = FNS(S)//SI\n      Q0 = ASIN(SIN(X))/Y*S\n      W0 = W+6. EXPO *EPS*ABS(Q0)\n      CALL WHET(Q,Q0,W0,X,Y,A,B,TS,TA)\n      X = A*0.5 EXPO \n      Y = B*0.5 EXPO \n      IF (S.LT.0. EXPO ) THEN\nC\nC....    (B+1) is even\nC\n         S = FNODD((B+1. EXPO )*0.5 EXPO )\n         TS = FNS(S)//CO\n         Q0 = ASIN(COS(X))/Y*S\n         W0 = W+6. EXPO *EPS*ABS(Q0)\n      ELSE\nC\nC....    B = 2y is even\nC\n         TS = ' '//TA\n         Q0 = ATAN(TAN(X))/Y\n         W0 = 3. EXPO *EPS*ABS(Q0)\n\t CALL WHET(Q,Q0,W0,X,Y,A,B,TS,TA)\n         S = FNODD(Y)\n         TS = FNS(S)//SI\n\t Q0 = ASIN(SIN(X))/Y*S\n         W0 = W+6. EXPO *EPS*ABS(Q0)\n      ENDIF\n      CALL WHET(Q,Q0,W0,X,Y,A,B,TS,TA)\n      RETURN\n      END\nC\n      SUBROUTINE WHET(Q,Q0,W0,X,Y,A,B,TS,TA)\n      REAL Q,Q0,W0,X,Y,A,B\n      CHARACTER*(*) TS,TA\nC\nC.... Test whether Q0.EQ.Q within +/- W0 (.GE.->.GT.)\nC\n      IF (ABS(Q-Q0).GT.W0) THEN\nC\nC....    Difference too big suggests P is not a constant after all.\nC\n         PRINT 4000,TS,X,')/',Y,' =',Q0,' differs from ',\n     1      TA,A,')/',B,' =',Q,' too much.'\n4000  FORMAT(/1X,4X,70('%')\n     1   /1X,4X,A11,0PF38.1,A\n     2   /1X,4X,11X,0PF38.1,A\n     3   /1X,4X,11X,1PE45.37E3,A\n     4   /1X,4X,1X,A10,0PF38.1,A\n     5   /1X,4X,11X,0PF38.1,A\n     6   /1X,4X,11X,1PE45.37E3,A\n     7   /1X,4X,70('%')\n     8   /)\n\n\n      PRINT *,'I want to: call ucbfail'\nC\tcall ucbfail\n      ENDIF\n      RETURN\n      END\nC\n      SUBROUTINE DISPLA(J,A,B,C,E,R)\n      INTEGER J\n      REAL A,B,C,E,R\nC\nC     Display Formatting\nC\nC.... display  J, A, B, C, R, E\nC\n      PRINT 2000,J,A,B,C,R,E\n2000  FORMAT(1X,I2,1X,F37.0,'/',F37.0\n     1   /1X,2X,1X,27X,'+',1X,1PE45.37E3\n     2   /1X,2X,1X,1X,1PE45.37E3,1X,'+/-',1PE16.8E3\n     3   )\n      RETURN\n      END\nC\n      SUBROUTINE COMPAR(E,R)\n      REAL E,R\nC\nC.... test for consistency\nC\nC.... local variables\nC\n      REAL E0,R0\n      SAVE E0,R0\n      DATA E0,R0/0.1416 EXPO ,0. EXPO /\nC\nC.... .LT.->.LE.\nC\n      IF (ABS(R-R0).LE.E+E0) THEN\n\t E0 = E\n         R0 = R\n      ELSE\n         PRINT *,'Varying R implies defective argument reduction.'\n         PRINT *,'I want to: call ucbfail'\nC\tcall ucbfail\n         STOP\n      ENDIF\n      RETURN\n      END\n\nWill update here with results for full ucb floating point test suite when I get it to compile & run.", "body": "Attached is part of a test suite from Univ. of California Berkeley, which was used to test and verify floating point operations on several machines, from DEC VAX and Sun Microsystems machines to early P/C's. It was originally written for Fortran77.  I've converted the \"pi.F\" program (to \"pi_new.F\") to compile and run in gFortran (GNU Fortran), in DP (double-precision) mode.   What I am seeing, is that the MacOS and CentOS-7.4 Linux produce exactly the same results, up to where the remainder value reaches floating point values where the exponent is near or slightly above 25.  (see the attached single screenshot, which shows the MacOS result on the left, the CentOS-7.4 result on the right.)\r\n\r\ni downloaded and installed \"gfortran\" binary for MacOS (the version 5.2 for Yosemite), and gfortran 4.8.5 (and gcc 4.8.5) are installed with CentOS-7.4.  On the Macbook, I installed macOS gfortran ver. 5.2 (for 10.10 Yosemite), as a .dmg binary.  Fortran binaries for MacOS available here:\r\nhttps://gcc.gnu.org/wiki/GFortranBinaries\r\n\r\nThe \"pi_new.F\" program can be compiled with the following command line:\r\n\r\n```\r\ngfortran -cpp -D DP  pi_new.F -o  pi_new\r\n```\r\n\r\nThe program calculates pi using progressively larger operands, and reports the results.  It also makes \r\n![screen_shot_pi_new_test_2018_01_19_1](https://user-images.githubusercontent.com/16905336/35179205-6c4df074-fd63-11e7-831f-5e4695eea65f.png)\r\ntests for internal consistancy, which both platforms pass.  At iteration 8, the remainders are different. And at iterations 19 to 24 show serious divergence in the remainder values.   The remainder on iteration 23 on the Macbook, is the value for the the remainder for iteration 22 on the CentOS box, but with the sign flipped.   The remainder for iteration 22 on the Macbook (-1.37753244... E-40), is the value for the remainder for iteration 23 on the CentOS box, but again, with the sign flipped to positive.  But by iterations 24, 25 and 26, the results are exactly the same, only to diverge again for iterations 27 and 28.   To me, this seems to indicate a rather serious issue, which appears to be independent of TensorFlow.  The MacBook is giving different results than the 64-bit Linux box. \r\n\r\nSo far, I just have this one program converted, but I will try to convert the entire test suite, and run it to see if the MacOS - Linux 64-bit floating-point calculations divergence shows up in other calculations.\r\nThe \"pi_new.F\" program source is below...\r\n\r\n```\r\nC \"@(#)pirats.F 1.2 92/05/29 SMI\"\r\n\r\n#define STDERR 0\r\n#define STDOUT 6\r\n#define STDIN 5\r\n#ifdef SP\r\n#define REAL real*4\r\n#define EXPO e0\r\n#endif\r\n#ifdef DP\r\n#define REAL real*8\r\n#define EXPO d0\r\n#endif\r\n#ifdef QP\r\n#define REAL real*16\r\n#define EXPO q0\r\n#endif\r\n\r\n#ifdef TRIGP\r\n#define SIN sinp\r\n#define COS cosp\r\n#define TAN tanp\r\n#define ASIN asinp\r\n#define ACOS acosp\r\n#define ATAN atanp\r\n#else\r\n#define SIN sin\r\n#define COS cos\r\n#define TAN tan\r\n#define ASIN asin\r\n#define ACOS acos\r\n#define ATAN atan\r\n#endif\r\n\r\n      PROGRAM PIRATS\r\nC\r\nC.... PIRATS                     Copyright (C) by W. Kahan, Mar. 8, 1989\r\nC\r\nC.... This program finds close rational approximations\r\nC.... A/B to PI, and computes the differences C = PI-A/B to\r\nC.... working precision within errors no bigger than E.  Working\r\nC.... precision arithmetic is presumed to carry no more than about\r\nC.... 110 sig. dec., and to be rounded reasonably like a DEC VAX\r\nC.... or an HP calculator or in conformity with IEEE 754/854.\r\nC.... Then the program tests argument reductions in functions SIN,\r\nC.... COS and TAN, checking to see whether they are consistent\r\nC.... with the hypothesis that their actual periods are some single\r\nC.... close approximation 2*P to 2*PI if not 2*PI itself.\r\nC\r\n      INTEGER NPI\r\n      PARAMETER (NPI = 210)\r\nC\r\nC.... The following array of NPI+1 divisors D(J) > 0 in the continued\r\nC.... fraction PI = D(0)+1/(D(1)+1/(D(2)+1/(D(3)+...))) will incur an\r\nC.... error in PI no worse than 3.6E-234. Only D(NPI) isn't an integer.\r\nC.... This data is based upon DJ's computed by Stewart McDonald\r\nC.... in 1983 from an algorithm due to W. Gosper.  W. K.\r\nC\r\n      INTEGER I,J,INC\r\n      REAL D(0:NPI),EPS,RDX,FL,A,B,C,E,R\r\n      DATA (D(I),I = 0,99)/\r\n     1   3. EXPO ,7. EXPO ,15. EXPO ,1. EXPO ,292. EXPO ,1. EXPO ,\r\n     1\t1. EXPO ,1. EXPO ,2. EXPO ,1. EXPO ,\r\n     2   3. EXPO ,1. EXPO ,14. EXPO ,2. EXPO ,1. EXPO ,1. EXPO ,\r\n     1\t2. EXPO ,2. EXPO ,2. EXPO ,2. EXPO ,\r\n     3   1. EXPO ,84. EXPO ,2. EXPO ,1. EXPO ,1. EXPO ,15. EXPO ,\r\n     1\t3. EXPO ,13. EXPO ,1. EXPO ,4. EXPO ,\r\n     4   2. EXPO ,6. EXPO ,6. EXPO ,99. EXPO ,1. EXPO ,2. EXPO ,\r\n     1\t2. EXPO ,6. EXPO ,3. EXPO ,5. EXPO ,\r\n     5   1. EXPO ,1. EXPO ,6. EXPO ,8. EXPO ,1. EXPO ,7. EXPO ,1. EXPO,\r\n     1\t2. EXPO ,3. EXPO ,7. EXPO ,\r\n     6   1. EXPO ,2. EXPO ,1. EXPO ,1. EXPO ,12. EXPO ,1. EXPO ,\r\n     1\t1. EXPO ,1. EXPO ,3. EXPO ,1. EXPO ,\r\n     7   1. EXPO ,8. EXPO ,1. EXPO ,1. EXPO ,2. EXPO ,1. EXPO ,6. EXPO,\r\n     1\t1. EXPO ,1. EXPO ,5. EXPO ,\r\n     8   2. EXPO ,2. EXPO ,3. EXPO ,1. EXPO ,2. EXPO ,4. EXPO ,4. EXPO,\r\n     1 \t16. EXPO ,1. EXPO ,161. EXPO , 45. EXPO ,1. EXPO ,22. EXPO ,\r\n     1\t1. EXPO ,2. EXPO ,2. EXPO,1. EXPO,4. EXPO ,1. EXPO ,2. EXPO ,\r\n     2  24. EXPO ,1. EXPO ,2. EXPO ,1. EXPO ,3. EXPO ,1. EXPO ,2. EXPO, \r\n     1  1. EXPO ,1. EXPO ,10. EXPO /\r\n\r\n      DATA (D(I),I = 100,199)/\r\n     1   2. EXPO ,5. EXPO ,4. EXPO ,1. EXPO ,2. EXPO ,2. EXPO ,8. EXPO ,\r\n     1\t1. EXPO ,5. EXPO ,2. EXPO ,\r\n     2   2. EXPO ,26. EXPO ,1. EXPO ,4. EXPO ,1. EXPO ,1. EXPO ,8. EXPO \r\n     1\t,2. EXPO ,42. EXPO ,2. EXPO ,\r\n     3   1. EXPO ,7. EXPO ,3. EXPO ,3. EXPO ,1. EXPO ,1. EXPO ,7. EXPO ,\r\n     1\t2. EXPO ,4. EXPO ,9. EXPO ,\r\n     4   7. EXPO ,2. EXPO ,3. EXPO ,1. EXPO ,57. EXPO ,1. EXPO ,18. EXPO\r\n     1\t ,1. EXPO ,9. EXPO ,19. EXPO ,\r\n     5   1. EXPO ,2. EXPO ,18. EXPO ,1. EXPO ,3. EXPO ,7. EXPO ,30. EXPO\r\n     1\t ,1. EXPO ,1. EXPO ,1. EXPO ,\r\n     6   3. EXPO ,3. EXPO ,3. EXPO ,1. EXPO ,2. EXPO ,8. EXPO ,1. EXPO ,\r\n     1\t1. EXPO ,2. EXPO ,1. EXPO ,\r\n     7   15. EXPO ,1. EXPO ,2. EXPO ,13. EXPO ,1. EXPO ,2. EXPO ,1. EXPO\r\n     1\t ,4. EXPO ,1. EXPO ,12. EXPO ,\r\n     8   1. EXPO ,1. EXPO ,3. EXPO ,3. EXPO ,28. EXPO ,1. EXPO ,10. EXPO\r\n     1\t ,3. EXPO ,2. EXPO ,20. EXPO ,\r\n     9   1. EXPO ,1. EXPO ,1. EXPO ,1. EXPO ,4. EXPO ,1. EXPO ,1. EXPO ,\r\n     1\t1. EXPO ,5. EXPO ,3. EXPO , 2. EXPO ,1. EXPO ,6. EXPO ,1. EXPO ,\r\n     1\t4. EXPO ,1. EXPO ,120. EXPO ,2. EXPO ,1. EXPO ,1. EXPO /\r\n      DATA (D(I),I = 200,NPI)/\r\n     1   3. EXPO ,1. EXPO ,23. EXPO ,1. EXPO ,15. EXPO ,1. EXPO ,3. EXPO\r\n     1\t ,7. EXPO ,1. EXPO ,16. EXPO ,\r\n     2   1.338371961073448 EXPO \r\n     3   /\r\nC\r\nC.... Environmental constants EPS, RDX, FL\r\nC\r\n      CALL ENVCNS(EPS,RDX,FL)\r\nC\r\nC.... for adequate accuracy\r\nC\r\n      INC = INT(LOG(FL)/LOG(2.6 EXPO ))\r\nC\r\n      PRINT 1000\r\n1000  FORMAT(1X,'PIRATS: computes  PI = A/B+C and R = PI-P.'/\r\n     1   /1X,1X,'J',1X,18X,'A',18X,'/',18X,'B'\r\n     2   /1X,2X,1X,27X,'+',5X,'C'\r\n     3   /1X,2X,1X,41X,'R',5X,'+/-',5X,'E'\r\n     4   )\r\nC\r\nC.... Initialize A, B\r\nC\r\n      A = D(0)\r\n      B = 1. EXPO \r\nC\r\n      DO 100 J = 1,NPI-INC+5\r\nC\r\nC.... Get next pair A, B\r\nC\r\n         CALL NEXTAB(D(J),A,B)\r\n         IF (A.GT.FL.OR.B.GT.FL) THEN\r\n\t    GOTO 110\r\n\t ENDIF\r\nC\r\nC....    Get C = PI-A/B+/-E\r\nC\r\n         CALL GETCE(NPI,J,INC,EPS,FL,D,C,E)\r\nC\r\nC....    Get R = PI-P+/-E\r\nC\r\n         CALL TSTRIG(EPS,A,B,C,E,R)\r\nC\r\nC....    Display these numbers\r\nC\r\n         CALL DISPLA(J,A,B,C,E,R)\r\nC\r\nC....    Test them for consistency\r\nC\r\n         CALL COMPAR(E,R)\r\n100   CONTINUE\r\n110   CONTINUE\r\nC\r\nC.... Normal termination.\r\nC\r\n      PRINT *,'Pi.F -- Normal Termination. '\r\n      PRINT *,'I want to: call ucbpass'\r\nC      call ucbpass\r\n      STOP\r\n      END\r\nC\r\n\tREAL function volatilizer(x)\r\n\tREAL x\r\n\tvolatilizer=x\r\n\tend\r\n\r\n      SUBROUTINE ENVCNS(EPS,RDX,FL)\r\n      REAL EPS,RDX,FL\r\nC\r\nC.... Environmental constants.  This subroutine computes\r\nC....    EPS = nextafter(1,2)-1 = 1.000...001-1\r\nC....    RDX = RaDiX of floating-point arithmetic (2, 10, 16)\r\nC....    FL = RDX/EPS = last of consecutive floating-point integers\r\nC....                       among 1, 2, 3, ..., FL-2, FL-1, FL.\r\nC\r\nC.... local variables\r\nC\r\n\tREAL volatilizer\r\n      REAL H,X,Y,T,U,V\r\nC\r\nC.... First seek EPS\r\nC\r\n      T = 4. EXPO /3. EXPO \r\n      X = T-1. EXPO \r\n      Y = ABS((X+X-1. EXPO )+X)/64. EXPO \r\n      EPS = 0. EXPO \r\n      IF (Y.EQ.0. EXPO ) THEN\r\n\t PRINT *,'Is 4/3 exact?'\r\n         GOTO 299\r\n      ENDIF\r\n200   IF (EPS.NE.0. EXPO ) GOTO 210\r\n         U = volatilizer(1. EXPO +Y)\r\n         EPS = volatilizer(U-1. EXPO) \r\n         Y = Y+Y\r\n      GOTO 200\r\nC\r\nC     Now seek EPS/RDX = 1-nextafter(1,0) = 1-0.999...999 :\r\nC\r\n210   H = 1. EXPO /2. EXPO \r\n      T = 2. EXPO /3. EXPO \r\n      X = T-H\r\n      Y = ABS((X+X-H)+X)/64. EXPO \r\n      V = 0. EXPO \r\n      IF (Y.EQ.0. EXPO ) THEN\r\n\t PRINT *,'Is 2/3 exact?'\r\n         GOTO 299\r\n      ENDIF\r\n220   IF (V.NE.0. EXPO ) GOTO 230\r\n         U = volatilizer((H-Y)+H)\r\n         V = volatilizer((H-U)+H)\r\n         Y = Y+Y\r\n      GOTO 220\r\nC\r\nC.... in case Division is dirty\r\nC\r\n230   RDX = AINT(EPS/V+0.0001 EXPO )\r\n      IF (RDX.LT.2. EXPO ) THEN\r\n\t PRINT 5000,'Radix =',RDX\r\n5000     FORMAT(1X,A,F4.0)\r\n         GOTO 299\r\n      ENDIF\r\nC\r\nC.... Confirm that RDX = Radix of Floating-point arithmetic.\r\nC\r\n      T = RDX\r\n      X = 1. EXPO \r\nC\r\nC.... until X.EQ.0 or X.EQ.RDX\r\nC\r\n240   IF (X.NE.1. EXPO ) GOTO 250\r\n         T = T+T\r\n         U = volatilizer(T+1. EXPO)\r\n         X = volatilizer(U-T)\r\n      GOTO 240\r\n250   IF (X.EQ.0. EXPO ) THEN\r\n         Y = 1. EXPO \r\n260      IF (X.NE.0. EXPO ) GOTO 270\r\n            Y = Y+Y\r\n            U = volatilizer(T+Y)\r\n            X = volatilizer(U-T)\r\n\t GOTO 260\r\n      ENDIF\r\n270   IF (X.NE.RDX) THEN\r\n         PRINT 6000,'Is Radix ',X,' or ',RDX,'?'\r\n6000     FORMAT(1X,A,F4.0,A,F4.0,A)\r\n\t GOTO 299\r\n      ENDIF\r\nC\r\nC.... Confirm that FL = RDX/EPS:\r\nC\r\n      FL = RDX\r\n      X = 1. EXPO \r\n280   IF (X.NE.1. EXPO ) GOTO 290\r\n         FL = volatilizer(FL*RDX)\r\n\t U = volatilizer(FL+1. EXPO)\r\n\t X = volatilizer(U-FL)\r\n      GOTO 280\r\n290   IF (FL*V.EQ.1. EXPO ) THEN\r\n\t RETURN\r\n      ENDIF\r\nC\r\nC.... ENVCNS cannot compute environmental constants correctly:\r\nC\r\n      PRINT 3000,'Is FL ',FL,' or ',1. EXPO /V,'?'\r\n3000  FORMAT(1X,A6,1PE45.37E3/1X,2X,A4,1PE45.37E3,A1)\r\n299   PRINT *,'Subroutine ENVCNS cannot compute correctly the'\r\n      PRINT *,'Environmental constants'\r\n      PRINT *,'EPS = 1.000...001 - 1 , and'\r\n      PRINT *,'FL = Last consecutive Floating-point integer'\r\n      PRINT *,'        among 1, 2, 3, ..., FL-2, FL-1, FL.'\r\n      PRINT *,'Please substitute them for the subroutine.'\r\n      PRINT *,'I want to: call ucbfail'\r\nC\tcall ucbfail\r\n      STOP\r\n      END\r\nC\r\n      SUBROUTINE NEXTAB(DJ,A,B)\r\n      REAL DJ,A,B\r\nC\r\nC.... Get next pair A, B\r\nC\r\nC.... local variables\r\nC\r\n      REAL T,A0,B0\r\n      SAVE A0,B0\r\n      DATA A0,B0/1. EXPO ,0. EXPO /\r\nC\r\n      T = DJ*B+B0\r\n      B0 = B\r\n      B = T\r\n      T = DJ*A+A0\r\n      A0 = A\r\n      A = T\r\nC\r\nC.... Now A/B = D0+1/(D1+1/(D2+...+1/DJ)).\r\nC\r\n      RETURN\r\n      END\r\nC\r\n      SUBROUTINE GETCE(NPI,J,INC,EPS,FL,D,C,E)\r\n      INTEGER NPI,J,INC\r\n      REAL EPS,FL,D(0:NPI),C,E\r\nC\r\nC.... This subroutine computes the continued fraction's tail\r\nC....    Z = D(J+1)+1/(D(J+2)+1/(D(J+3)+1/(D(J+4)+...)))\r\nC.... to working accuracy by using INC terms of it, and then\r\nC.... computes the effect C of cutting it off to get A/B .\r\nC....\r\nC.... Get  C = PI-A/B+/-E\r\nC\r\nC.... local variables\r\nC\r\n      INTEGER I,I9\r\n      REAL X,Y,Z\r\nC\r\n      I9 = MIN(NPI,J+INC)\r\n      Z = D(I9)\r\n      DO 400 I = I9-1,J+1,-1\r\n         Z = D(I)+1. EXPO /Z\r\n400   CONTINUE\r\n      X = FL*FL\r\nC\r\nC.... C = 1/Z-1/X always\r\nC\r\n      C = 1. EXPO /Z-1. EXPO /X\r\n      DO 410 I = J,1,-1\r\n\t Y = D(I)\r\n         Z = Y+1. EXPO /Z\r\n\t X = Y+1. EXPO /X\r\n\t C = -C/(X*Z)\r\n410   CONTINUE\r\nC\r\nC.... E > accumulated roundoff (mixed arithmetic)\r\nC\r\n      E = 4. EXPO *J*EPS*ABS(C)\r\n      RETURN\r\n      END\r\nC\r\n      SUBROUTINE TSTRIG(EPS,A,B,C,E,R)\r\n      REAL EPS,A,B,C,E,R\r\nC\r\nC.... Get R = PI-P+/-E\r\nC\r\nC     This subroutine tests whether the programs that compute\r\nC     TRIG(X) = trig(X*PI/P) for TRIG = SIN, COS or TAN\r\nC     always use the same approximation P to PI during their\r\nC     argument reduction.  If so, 3 or 4 values R = Q+C\r\nC     derived from A = B*(PI-C+/-E) ought to agree.\r\nC\r\nC.... local variables\r\nC\r\n      REAL Q,Q0,S,W,W0,X,Y\r\n      CHARACTER*11 TS\r\nC\r\n      REAL FNODD\r\n      CHARACTER FNS\r\nC\r\n      CHARACTER*10 SI,CO,TA\r\n      DATA SI,CO,TA/'arcsin(sin','arcsin(cos','arctan(tan'/\r\nC\r\nC.... FNODD(floating-point integer X) = (-1)**X\r\nC\r\n      FNODD(X) = (AINT(ABS(X)*0.5 EXPO +0.125 EXPO )*2. EXPO -ABS(X))*\r\n     1\t2. EXPO +1. EXPO \r\nC\r\nC.... FNS(1) = '+', FNS(-1) = '-'\r\nC\r\n      FNS(X) = CHAR(44-INT(X))\r\nC\r\n      Q = ATAN(TAN(A))/B\r\n      R = Q+C\r\n      W = 3. EXPO *EPS*ABS(Q)\r\n      E = E+W\r\n      S = FNODD(B)\r\n      X = A\r\n      Y = B\r\n      TS = FNS(S)//SI\r\n      Q0 = ASIN(SIN(X))/Y*S\r\n      W0 = W+6. EXPO *EPS*ABS(Q0)\r\n      CALL WHET(Q,Q0,W0,X,Y,A,B,TS,TA)\r\n      X = A*0.5 EXPO \r\n      Y = B*0.5 EXPO \r\n      IF (S.LT.0. EXPO ) THEN\r\nC\r\nC....    (B+1) is even\r\nC\r\n         S = FNODD((B+1. EXPO )*0.5 EXPO )\r\n         TS = FNS(S)//CO\r\n         Q0 = ASIN(COS(X))/Y*S\r\n         W0 = W+6. EXPO *EPS*ABS(Q0)\r\n      ELSE\r\nC\r\nC....    B = 2y is even\r\nC\r\n         TS = ' '//TA\r\n         Q0 = ATAN(TAN(X))/Y\r\n         W0 = 3. EXPO *EPS*ABS(Q0)\r\n\t CALL WHET(Q,Q0,W0,X,Y,A,B,TS,TA)\r\n         S = FNODD(Y)\r\n         TS = FNS(S)//SI\r\n\t Q0 = ASIN(SIN(X))/Y*S\r\n         W0 = W+6. EXPO *EPS*ABS(Q0)\r\n      ENDIF\r\n      CALL WHET(Q,Q0,W0,X,Y,A,B,TS,TA)\r\n      RETURN\r\n      END\r\nC\r\n      SUBROUTINE WHET(Q,Q0,W0,X,Y,A,B,TS,TA)\r\n      REAL Q,Q0,W0,X,Y,A,B\r\n      CHARACTER*(*) TS,TA\r\nC\r\nC.... Test whether Q0.EQ.Q within +/- W0 (.GE.->.GT.)\r\nC\r\n      IF (ABS(Q-Q0).GT.W0) THEN\r\nC\r\nC....    Difference too big suggests P is not a constant after all.\r\nC\r\n         PRINT 4000,TS,X,')/',Y,' =',Q0,' differs from ',\r\n     1      TA,A,')/',B,' =',Q,' too much.'\r\n4000  FORMAT(/1X,4X,70('%')\r\n     1   /1X,4X,A11,0PF38.1,A\r\n     2   /1X,4X,11X,0PF38.1,A\r\n     3   /1X,4X,11X,1PE45.37E3,A\r\n     4   /1X,4X,1X,A10,0PF38.1,A\r\n     5   /1X,4X,11X,0PF38.1,A\r\n     6   /1X,4X,11X,1PE45.37E3,A\r\n     7   /1X,4X,70('%')\r\n     8   /)\r\n\r\n\r\n      PRINT *,'I want to: call ucbfail'\r\nC\tcall ucbfail\r\n      ENDIF\r\n      RETURN\r\n      END\r\nC\r\n      SUBROUTINE DISPLA(J,A,B,C,E,R)\r\n      INTEGER J\r\n      REAL A,B,C,E,R\r\nC\r\nC     Display Formatting\r\nC\r\nC.... display  J, A, B, C, R, E\r\nC\r\n      PRINT 2000,J,A,B,C,R,E\r\n2000  FORMAT(1X,I2,1X,F37.0,'/',F37.0\r\n     1   /1X,2X,1X,27X,'+',1X,1PE45.37E3\r\n     2   /1X,2X,1X,1X,1PE45.37E3,1X,'+/-',1PE16.8E3\r\n     3   )\r\n      RETURN\r\n      END\r\nC\r\n      SUBROUTINE COMPAR(E,R)\r\n      REAL E,R\r\nC\r\nC.... test for consistency\r\nC\r\nC.... local variables\r\nC\r\n      REAL E0,R0\r\n      SAVE E0,R0\r\n      DATA E0,R0/0.1416 EXPO ,0. EXPO /\r\nC\r\nC.... .LT.->.LE.\r\nC\r\n      IF (ABS(R-R0).LE.E+E0) THEN\r\n\t E0 = E\r\n         R0 = R\r\n      ELSE\r\n         PRINT *,'Varying R implies defective argument reduction.'\r\n         PRINT *,'I want to: call ucbfail'\r\nC\tcall ucbfail\r\n         STOP\r\n      ENDIF\r\n      RETURN\r\n      END\r\n```\r\n\r\nWill update here with results for full ucb floating point test suite when I get it to compile & run."}