{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/356992095", "html_url": "https://github.com/tensorflow/tensorflow/issues/15933#issuecomment-356992095", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/15933", "id": 356992095, "node_id": "MDEyOklzc3VlQ29tbWVudDM1Njk5MjA5NQ==", "user": {"login": "Gemesys", "id": 16905336, "node_id": "MDQ6VXNlcjE2OTA1MzM2", "avatar_url": "https://avatars1.githubusercontent.com/u/16905336?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gemesys", "html_url": "https://github.com/Gemesys", "followers_url": "https://api.github.com/users/Gemesys/followers", "following_url": "https://api.github.com/users/Gemesys/following{/other_user}", "gists_url": "https://api.github.com/users/Gemesys/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gemesys/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gemesys/subscriptions", "organizations_url": "https://api.github.com/users/Gemesys/orgs", "repos_url": "https://api.github.com/users/Gemesys/repos", "events_url": "https://api.github.com/users/Gemesys/events{/privacy}", "received_events_url": "https://api.github.com/users/Gemesys/received_events", "type": "User", "site_admin": false}, "created_at": "2018-01-11T16:59:22Z", "updated_at": "2018-01-11T17:00:45Z", "author_association": "NONE", "body_html": "<p>Given what quaeler reported, I uninstalled my built-from-source version of Tensorflow-1.4.1 on the Macbook, and installed the binary version of Tensorflow that quaeler used to get the correct simulation results he shows for Sierra macos.  Then, I edited my .bash_profile to revert to the previous, binary installed Python (2.7.14), which has ucs2 encoding for unicode characters. (Thats the one issue I know is different between the Linux binary Tensorflow and the Mac binary Tensorflow.  The Linux binary is built with unicode=ucs4, and requires a Python built the same way.)</p>\n<p>I ran the LapTest.py program on the Mac with binary Tensorflow and binary Python (2.7.14 from Sept. 2017), and confirmed I still get the blank image.  I've attached a proper screenshot below, which shows the results - all blank white screens, after the simulation runs for just 3000 iterations.  The floating point values in the U.eval() matrix (used to create the display image), for row=20 are provided in the xterm window, showing <strong>all</strong>l high-valued, positive values.  On the Linux machine, these values are a mixture of postive and negative values (and hence an image is produced).</p>\n<p>When run on Linux, the simulation evolves in the fashion quaeler reports for Mac Sierra, and I am seeing for Linux/CentOS-7.4.  The numbers evolve the same way, and a similar image appears,  even with a larger surface area, showing same evidence of moire-style patterns.  The same inspection of the U.eval() matrix at row[20] shows high-valued <strong>positive and negative values</strong>, which are shown in the attached screenshot from the Linux box.</p>\n<p>I thought it might be the CPU vectorization being problematic, but what is interesting is the Macbook compiled-from-source Tensorflow-1.4.1 does not offer the warning messages about cpu vector instructions sse4.1, sse4.2 and avx (\"Your CPU has these, but this version is not compiled to use them: SSE4.1, SSE4.2 AVX\"), but the binary version I just re-installed <em>does</em> offer this warning, so I am guessing that the ./configure and/or Bazel setup sees these CPU options are available, and compiles the code in Tensorflow to use these?  So since the behaviour is the same on the Yosemite (10.10.15) Macbook for both compiled and binary Tensorflow, we can rule out the problem being from the use of the vector instructions?   Or when you compile Tensorflow for CPU, do you have to explicitly set some options to use these instructions, and that assumption is not correct?</p>\n<p>On each screen shot, the table at right is the U.eval() values for row[20].  The image display routine just uses np.clip to clamp the image-pixel values to between 0 and 255, so a large negative number becomes a zero (black), and a large positive number becomes a 255 (white).</p>\n<p>To summarize: The Linux Tensorflow binary for 1.4.1 for both Ubuntu 17 and CentOS-7.4 have the simulation evolve to a big tensor of high-value positive and negative numbers, and pattern in the image is generated.  The same numerical evolution occurs on a Macbook running Sierra  Macos  10.12.6.</p>\n<p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://user-images.githubusercontent.com/16905336/34836495-0e41663a-f6c6-11e7-8084-5a314c7322b7.jpg\"><img src=\"https://user-images.githubusercontent.com/16905336/34836495-0e41663a-f6c6-11e7-8084-5a314c7322b7.jpg\" alt=\"screenshot_laptest_mac_2018-01-11-1\" style=\"max-width:100%;\"></a><br>\n<a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://user-images.githubusercontent.com/16905336/34836507-18505802-f6c6-11e7-9569-c48762f499f3.jpg\"><img src=\"https://user-images.githubusercontent.com/16905336/34836507-18505802-f6c6-11e7-9569-c48762f499f3.jpg\" alt=\"screenshot_laptest_600_2018-01-11_9-25-23\" style=\"max-width:100%;\"></a><br>\nAnd now, what is particularly annoying, is that I cannot re-install my built-from-source version of TensorFlow-1.4.1, despite having pointed to and started the locally-built Python without problem.<br>\nThere is a wrapper file in the /usr/local/lib/python2.7/site-packages/tensorflow/python/_pywrap_tensorflow_internal.so which is failing on a \"Symbol not found: _PyUnicodeUCS_AsASCIIString\"   Arrgh!<br>\nWhat looks to have happened, is that installing the binay Tensorflow (with it's unicode=ucs2 default) has trashed the local-built  Python 2.7 library.  I have the ucs4 Python in the path, any attempt to import my local built TensorFlow in Python is failing.    I will have to resolve this before I can determine what is wrong with the TensorFlow math under Yosemite.</p>", "body_text": "Given what quaeler reported, I uninstalled my built-from-source version of Tensorflow-1.4.1 on the Macbook, and installed the binary version of Tensorflow that quaeler used to get the correct simulation results he shows for Sierra macos.  Then, I edited my .bash_profile to revert to the previous, binary installed Python (2.7.14), which has ucs2 encoding for unicode characters. (Thats the one issue I know is different between the Linux binary Tensorflow and the Mac binary Tensorflow.  The Linux binary is built with unicode=ucs4, and requires a Python built the same way.)\nI ran the LapTest.py program on the Mac with binary Tensorflow and binary Python (2.7.14 from Sept. 2017), and confirmed I still get the blank image.  I've attached a proper screenshot below, which shows the results - all blank white screens, after the simulation runs for just 3000 iterations.  The floating point values in the U.eval() matrix (used to create the display image), for row=20 are provided in the xterm window, showing alll high-valued, positive values.  On the Linux machine, these values are a mixture of postive and negative values (and hence an image is produced).\nWhen run on Linux, the simulation evolves in the fashion quaeler reports for Mac Sierra, and I am seeing for Linux/CentOS-7.4.  The numbers evolve the same way, and a similar image appears,  even with a larger surface area, showing same evidence of moire-style patterns.  The same inspection of the U.eval() matrix at row[20] shows high-valued positive and negative values, which are shown in the attached screenshot from the Linux box.\nI thought it might be the CPU vectorization being problematic, but what is interesting is the Macbook compiled-from-source Tensorflow-1.4.1 does not offer the warning messages about cpu vector instructions sse4.1, sse4.2 and avx (\"Your CPU has these, but this version is not compiled to use them: SSE4.1, SSE4.2 AVX\"), but the binary version I just re-installed does offer this warning, so I am guessing that the ./configure and/or Bazel setup sees these CPU options are available, and compiles the code in Tensorflow to use these?  So since the behaviour is the same on the Yosemite (10.10.15) Macbook for both compiled and binary Tensorflow, we can rule out the problem being from the use of the vector instructions?   Or when you compile Tensorflow for CPU, do you have to explicitly set some options to use these instructions, and that assumption is not correct?\nOn each screen shot, the table at right is the U.eval() values for row[20].  The image display routine just uses np.clip to clamp the image-pixel values to between 0 and 255, so a large negative number becomes a zero (black), and a large positive number becomes a 255 (white).\nTo summarize: The Linux Tensorflow binary for 1.4.1 for both Ubuntu 17 and CentOS-7.4 have the simulation evolve to a big tensor of high-value positive and negative numbers, and pattern in the image is generated.  The same numerical evolution occurs on a Macbook running Sierra  Macos  10.12.6.\n\n\nAnd now, what is particularly annoying, is that I cannot re-install my built-from-source version of TensorFlow-1.4.1, despite having pointed to and started the locally-built Python without problem.\nThere is a wrapper file in the /usr/local/lib/python2.7/site-packages/tensorflow/python/_pywrap_tensorflow_internal.so which is failing on a \"Symbol not found: _PyUnicodeUCS_AsASCIIString\"   Arrgh!\nWhat looks to have happened, is that installing the binay Tensorflow (with it's unicode=ucs2 default) has trashed the local-built  Python 2.7 library.  I have the ucs4 Python in the path, any attempt to import my local built TensorFlow in Python is failing.    I will have to resolve this before I can determine what is wrong with the TensorFlow math under Yosemite.", "body": "Given what quaeler reported, I uninstalled my built-from-source version of Tensorflow-1.4.1 on the Macbook, and installed the binary version of Tensorflow that quaeler used to get the correct simulation results he shows for Sierra macos.  Then, I edited my .bash_profile to revert to the previous, binary installed Python (2.7.14), which has ucs2 encoding for unicode characters. (Thats the one issue I know is different between the Linux binary Tensorflow and the Mac binary Tensorflow.  The Linux binary is built with unicode=ucs4, and requires a Python built the same way.)  \r\n\r\nI ran the LapTest.py program on the Mac with binary Tensorflow and binary Python (2.7.14 from Sept. 2017), and confirmed I still get the blank image.  I've attached a proper screenshot below, which shows the results - all blank white screens, after the simulation runs for just 3000 iterations.  The floating point values in the U.eval() matrix (used to create the display image), for row=20 are provided in the xterm window, showing **all**l high-valued, positive values.  On the Linux machine, these values are a mixture of postive and negative values (and hence an image is produced).\r\n\r\nWhen run on Linux, the simulation evolves in the fashion quaeler reports for Mac Sierra, and I am seeing for Linux/CentOS-7.4.  The numbers evolve the same way, and a similar image appears,  even with a larger surface area, showing same evidence of moire-style patterns.  The same inspection of the U.eval() matrix at row[20] shows high-valued **positive and negative values**, which are shown in the attached screenshot from the Linux box.   \r\n\r\nI thought it might be the CPU vectorization being problematic, but what is interesting is the Macbook compiled-from-source Tensorflow-1.4.1 does not offer the warning messages about cpu vector instructions sse4.1, sse4.2 and avx (\"Your CPU has these, but this version is not compiled to use them: SSE4.1, SSE4.2 AVX\"), but the binary version I just re-installed *does* offer this warning, so I am guessing that the ./configure and/or Bazel setup sees these CPU options are available, and compiles the code in Tensorflow to use these?  So since the behaviour is the same on the Yosemite (10.10.15) Macbook for both compiled and binary Tensorflow, we can rule out the problem being from the use of the vector instructions?   Or when you compile Tensorflow for CPU, do you have to explicitly set some options to use these instructions, and that assumption is not correct?  \r\n\r\nOn each screen shot, the table at right is the U.eval() values for row[20].  The image display routine just uses np.clip to clamp the image-pixel values to between 0 and 255, so a large negative number becomes a zero (black), and a large positive number becomes a 255 (white). \r\n\r\nTo summarize: The Linux Tensorflow binary for 1.4.1 for both Ubuntu 17 and CentOS-7.4 have the simulation evolve to a big tensor of high-value positive and negative numbers, and pattern in the image is generated.  The same numerical evolution occurs on a Macbook running Sierra  Macos  10.12.6.   \r\n\r\n![screenshot_laptest_mac_2018-01-11-1](https://user-images.githubusercontent.com/16905336/34836495-0e41663a-f6c6-11e7-8084-5a314c7322b7.jpg)\r\n![screenshot_laptest_600_2018-01-11_9-25-23](https://user-images.githubusercontent.com/16905336/34836507-18505802-f6c6-11e7-9569-c48762f499f3.jpg)\r\nAnd now, what is particularly annoying, is that I cannot re-install my built-from-source version of TensorFlow-1.4.1, despite having pointed to and started the locally-built Python without problem.\r\nThere is a wrapper file in the /usr/local/lib/python2.7/site-packages/tensorflow/python/_pywrap_tensorflow_internal.so which is failing on a \"Symbol not found: _PyUnicodeUCS_AsASCIIString\"   Arrgh!\r\nWhat looks to have happened, is that installing the binay Tensorflow (with it's unicode=ucs2 default) has trashed the local-built  Python 2.7 library.  I have the ucs4 Python in the path, any attempt to import my local built TensorFlow in Python is failing.    I will have to resolve this before I can determine what is wrong with the TensorFlow math under Yosemite."}