{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/359861868", "html_url": "https://github.com/tensorflow/tensorflow/issues/15933#issuecomment-359861868", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/15933", "id": 359861868, "node_id": "MDEyOklzc3VlQ29tbWVudDM1OTg2MTg2OA==", "user": {"login": "Gemesys", "id": 16905336, "node_id": "MDQ6VXNlcjE2OTA1MzM2", "avatar_url": "https://avatars1.githubusercontent.com/u/16905336?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gemesys", "html_url": "https://github.com/Gemesys", "followers_url": "https://api.github.com/users/Gemesys/followers", "following_url": "https://api.github.com/users/Gemesys/following{/other_user}", "gists_url": "https://api.github.com/users/Gemesys/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gemesys/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gemesys/subscriptions", "organizations_url": "https://api.github.com/users/Gemesys/orgs", "repos_url": "https://api.github.com/users/Gemesys/repos", "events_url": "https://api.github.com/users/Gemesys/events{/privacy}", "received_events_url": "https://api.github.com/users/Gemesys/received_events", "type": "User", "site_admin": false}, "created_at": "2018-01-23T17:11:44Z", "updated_at": "2018-01-23T17:11:44Z", "author_association": "NONE", "body_html": "<p>Thanx quaeler and lewisl for posting your results.  This gets more interesting and surprising the deeper we go.  I had expected an upgrade to MacOS and Xcode+gfortran would probably resolve the divergence issue, but quaeler's results show this not to be the case.  And lewisl's situation seems to confirm my worst fears - that this apparently tiny divergence could result in the failure of a network to train correctly.</p>\n<p>The Fortran test program is part of a suite of tests from Univ. of California Berkeley, which I found on the Utah site, where a collection of floating-point arithmetic tests are located, its url is: <a href=\"http://www.math.utah.edu/~beebe/software/ieee/#other\" rel=\"nofollow\">http://www.math.utah.edu/~beebe/software/ieee/#other</a>.   The UCB test suite looks like it was developed by W. Kahan who worked on (\"invented\" might be the better term) the IEEE 754 arithmetic methods, and it was then extended by Sun Microsystems.  This was a big issue back in 1995, when the first Pentium chip came to market, and was shown to have a critical flaw in it's floating-point hardware, where it would produce wrong results under certain special circumstances.  Test suites were developed to verify floating-point math, and run multiple tests for both accuracy and consistancy of results.</p>\n<p>The Utah software collection refers to the UCB test suite, and it can be downloaded as a tarball from:  <a href=\"http://www.netlib.org/fp/ucbtest.tgz\" rel=\"nofollow\">http://www.netlib.org/fp/ucbtest.tgz</a></p>\n<p>I've downloaded this test suite, and converted enough of it to get it running on both the MacOS and CentOS-7.4.  It is fairly comprehensive, and identifies several \"ulp\" differences - both on each machine, and between the two platforms.  (\"Ulp\" is the term used which means \"unit in the last place\", and is considered a better measure and check of floating-point accuracy than the term \"epsilon\").. (Here is a note about 'ulp':  <a href=\"https://www.jessesquires.com/blog/floating-point-swift-ulp-and-epsilon/\" rel=\"nofollow\">https://www.jessesquires.com/blog/floating-point-swift-ulp-and-epsilon/</a>  )</p>\n<p>The \"UCBTest\" suite is useful in that it runs both C and Fortran programs, in both single-precision and double-precision (53 bit significance).  I've converted it so it now compiles and runs on both 64-bit machines.  (I might have made conversion errors, keep that in mind.  There are compile warnings...)</p>\n<p>For now, running the full test suite on both machines results in 47 out of 56 tests passing on the CentOS/HP box, and 45 out of 56 tests passing on the MacOS/MacBook.  I am still checking details, but there is one program (which compiles into four different executables: cpar_SP, cpar_DP, fpar_SP and fpar_DP =&gt; c = C source, f = Fortran source, SP=single precision, DP=double precision), and the \"par\" refers to \"paranoid\" - implies you run this because you are concerned your numbers are not being calculated correctly! ).  The results of all four \"par\" programs indicated \"UCBPASS\" on both machines, so there does not seem to be anything obviously wrong related to rounding and/or plus/minus infinity and the handling of \"NaN\" (not a number) values.</p>\n<p>Attached screen images show results of the full UCBTest suite, run on each machine.  Note that the \"NME\" and the \"PME\" (Negative Maximum and Postive Maximum ULP error observed) for the last test displayed (the LOG(X) test) is slightly different between each machine.   Also, it took some effort to get the UCBTest suite to compile and run on each machine  (some of the code is quite old), and the tests run directly from the Makefiles that are used to build the programs, which complicates conversion.   Some of the \"fails\" could be due to conversion issues.  But this suite of tests is comprehensive, and is highlighting other divergence issues.   I want continue down this \"rabbit-hole\" until I can get a clearer sense of what is going on, and why the MacOS seems to be generating different results than the Linux platforms.  We now know that both CentOS and Ubuntu - current versions - seem to agree on how they do their math - but the MacOS is producing different results.</p>\n<p>I just want to caution that I might be making a mistake or an error in conversion, here.  In an effort to factor out issues that might be related to the \"gfortran\" compiler, I have been looking at the results generated by the C programs.  There appear to be cases where the divergence is serious.  I want to make sure I am getting proper compile results on each platform.<br>\n<a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://user-images.githubusercontent.com/16905336/35289540-a180f9f6-0035-11e8-8cec-9f46d1b72d9d.png\"><img src=\"https://user-images.githubusercontent.com/16905336/35289540-a180f9f6-0035-11e8-8cec-9f46d1b72d9d.png\" alt=\"screenshot_macos_full_ucbtest_2018-01-23_11d47am\" style=\"max-width:100%;\"></a><br>\n<a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://user-images.githubusercontent.com/16905336/35289565-b1342652-0035-11e8-83dc-ef485944fd47.png\"><img src=\"https://user-images.githubusercontent.com/16905336/35289565-b1342652-0035-11e8-83dc-ef485944fd47.png\" alt=\"screenshot_centos_run_ucbtest_23jan2018\" style=\"max-width:100%;\"></a></p>", "body_text": "Thanx quaeler and lewisl for posting your results.  This gets more interesting and surprising the deeper we go.  I had expected an upgrade to MacOS and Xcode+gfortran would probably resolve the divergence issue, but quaeler's results show this not to be the case.  And lewisl's situation seems to confirm my worst fears - that this apparently tiny divergence could result in the failure of a network to train correctly.\nThe Fortran test program is part of a suite of tests from Univ. of California Berkeley, which I found on the Utah site, where a collection of floating-point arithmetic tests are located, its url is: http://www.math.utah.edu/~beebe/software/ieee/#other.   The UCB test suite looks like it was developed by W. Kahan who worked on (\"invented\" might be the better term) the IEEE 754 arithmetic methods, and it was then extended by Sun Microsystems.  This was a big issue back in 1995, when the first Pentium chip came to market, and was shown to have a critical flaw in it's floating-point hardware, where it would produce wrong results under certain special circumstances.  Test suites were developed to verify floating-point math, and run multiple tests for both accuracy and consistancy of results.\nThe Utah software collection refers to the UCB test suite, and it can be downloaded as a tarball from:  http://www.netlib.org/fp/ucbtest.tgz\nI've downloaded this test suite, and converted enough of it to get it running on both the MacOS and CentOS-7.4.  It is fairly comprehensive, and identifies several \"ulp\" differences - both on each machine, and between the two platforms.  (\"Ulp\" is the term used which means \"unit in the last place\", and is considered a better measure and check of floating-point accuracy than the term \"epsilon\").. (Here is a note about 'ulp':  https://www.jessesquires.com/blog/floating-point-swift-ulp-and-epsilon/  )\nThe \"UCBTest\" suite is useful in that it runs both C and Fortran programs, in both single-precision and double-precision (53 bit significance).  I've converted it so it now compiles and runs on both 64-bit machines.  (I might have made conversion errors, keep that in mind.  There are compile warnings...)\nFor now, running the full test suite on both machines results in 47 out of 56 tests passing on the CentOS/HP box, and 45 out of 56 tests passing on the MacOS/MacBook.  I am still checking details, but there is one program (which compiles into four different executables: cpar_SP, cpar_DP, fpar_SP and fpar_DP => c = C source, f = Fortran source, SP=single precision, DP=double precision), and the \"par\" refers to \"paranoid\" - implies you run this because you are concerned your numbers are not being calculated correctly! ).  The results of all four \"par\" programs indicated \"UCBPASS\" on both machines, so there does not seem to be anything obviously wrong related to rounding and/or plus/minus infinity and the handling of \"NaN\" (not a number) values.\nAttached screen images show results of the full UCBTest suite, run on each machine.  Note that the \"NME\" and the \"PME\" (Negative Maximum and Postive Maximum ULP error observed) for the last test displayed (the LOG(X) test) is slightly different between each machine.   Also, it took some effort to get the UCBTest suite to compile and run on each machine  (some of the code is quite old), and the tests run directly from the Makefiles that are used to build the programs, which complicates conversion.   Some of the \"fails\" could be due to conversion issues.  But this suite of tests is comprehensive, and is highlighting other divergence issues.   I want continue down this \"rabbit-hole\" until I can get a clearer sense of what is going on, and why the MacOS seems to be generating different results than the Linux platforms.  We now know that both CentOS and Ubuntu - current versions - seem to agree on how they do their math - but the MacOS is producing different results.\nI just want to caution that I might be making a mistake or an error in conversion, here.  In an effort to factor out issues that might be related to the \"gfortran\" compiler, I have been looking at the results generated by the C programs.  There appear to be cases where the divergence is serious.  I want to make sure I am getting proper compile results on each platform.", "body": "Thanx quaeler and lewisl for posting your results.  This gets more interesting and surprising the deeper we go.  I had expected an upgrade to MacOS and Xcode+gfortran would probably resolve the divergence issue, but quaeler's results show this not to be the case.  And lewisl's situation seems to confirm my worst fears - that this apparently tiny divergence could result in the failure of a network to train correctly.\r\n\r\nThe Fortran test program is part of a suite of tests from Univ. of California Berkeley, which I found on the Utah site, where a collection of floating-point arithmetic tests are located, its url is: http://www.math.utah.edu/~beebe/software/ieee/#other.   The UCB test suite looks like it was developed by W. Kahan who worked on (\"invented\" might be the better term) the IEEE 754 arithmetic methods, and it was then extended by Sun Microsystems.  This was a big issue back in 1995, when the first Pentium chip came to market, and was shown to have a critical flaw in it's floating-point hardware, where it would produce wrong results under certain special circumstances.  Test suites were developed to verify floating-point math, and run multiple tests for both accuracy and consistancy of results.\r\n\r\nThe Utah software collection refers to the UCB test suite, and it can be downloaded as a tarball from:  http://www.netlib.org/fp/ucbtest.tgz\r\n\r\nI've downloaded this test suite, and converted enough of it to get it running on both the MacOS and CentOS-7.4.  It is fairly comprehensive, and identifies several \"ulp\" differences - both on each machine, and between the two platforms.  (\"Ulp\" is the term used which means \"unit in the last place\", and is considered a better measure and check of floating-point accuracy than the term \"epsilon\").. (Here is a note about 'ulp':  https://www.jessesquires.com/blog/floating-point-swift-ulp-and-epsilon/  )\r\n\r\nThe \"UCBTest\" suite is useful in that it runs both C and Fortran programs, in both single-precision and double-precision (53 bit significance).  I've converted it so it now compiles and runs on both 64-bit machines.  (I might have made conversion errors, keep that in mind.  There are compile warnings...)\r\n\r\nFor now, running the full test suite on both machines results in 47 out of 56 tests passing on the CentOS/HP box, and 45 out of 56 tests passing on the MacOS/MacBook.  I am still checking details, but there is one program (which compiles into four different executables: cpar_SP, cpar_DP, fpar_SP and fpar_DP => c = C source, f = Fortran source, SP=single precision, DP=double precision), and the \"par\" refers to \"paranoid\" - implies you run this because you are concerned your numbers are not being calculated correctly! ).  The results of all four \"par\" programs indicated \"UCBPASS\" on both machines, so there does not seem to be anything obviously wrong related to rounding and/or plus/minus infinity and the handling of \"NaN\" (not a number) values.\r\n\r\nAttached screen images show results of the full UCBTest suite, run on each machine.  Note that the \"NME\" and the \"PME\" (Negative Maximum and Postive Maximum ULP error observed) for the last test displayed (the LOG(X) test) is slightly different between each machine.   Also, it took some effort to get the UCBTest suite to compile and run on each machine  (some of the code is quite old), and the tests run directly from the Makefiles that are used to build the programs, which complicates conversion.   Some of the \"fails\" could be due to conversion issues.  But this suite of tests is comprehensive, and is highlighting other divergence issues.   I want continue down this \"rabbit-hole\" until I can get a clearer sense of what is going on, and why the MacOS seems to be generating different results than the Linux platforms.  We now know that both CentOS and Ubuntu - current versions - seem to agree on how they do their math - but the MacOS is producing different results. \r\n\r\nI just want to caution that I might be making a mistake or an error in conversion, here.  In an effort to factor out issues that might be related to the \"gfortran\" compiler, I have been looking at the results generated by the C programs.  There appear to be cases where the divergence is serious.  I want to make sure I am getting proper compile results on each platform.\r\n![screenshot_macos_full_ucbtest_2018-01-23_11d47am](https://user-images.githubusercontent.com/16905336/35289540-a180f9f6-0035-11e8-8cec-9f46d1b72d9d.png)\r\n![screenshot_centos_run_ucbtest_23jan2018](https://user-images.githubusercontent.com/16905336/35289565-b1342652-0035-11e8-83dc-ef485944fd47.png)\r\n"}