{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/15933", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/15933/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/15933/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/15933/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/15933", "id": 286600761, "node_id": "MDU6SXNzdWUyODY2MDA3NjE=", "number": 15933, "title": "Tensorflow 1.4.1 on Linux (CentOS-7.4) and Tensorflow 1.4.1 on MacOSX producing *very* different results in image creation simulation.", "user": {"login": "Gemesys", "id": 16905336, "node_id": "MDQ6VXNlcjE2OTA1MzM2", "avatar_url": "https://avatars1.githubusercontent.com/u/16905336?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gemesys", "html_url": "https://github.com/Gemesys", "followers_url": "https://api.github.com/users/Gemesys/followers", "following_url": "https://api.github.com/users/Gemesys/following{/other_user}", "gists_url": "https://api.github.com/users/Gemesys/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gemesys/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gemesys/subscriptions", "organizations_url": "https://api.github.com/users/Gemesys/orgs", "repos_url": "https://api.github.com/users/Gemesys/repos", "events_url": "https://api.github.com/users/Gemesys/events{/privacy}", "received_events_url": "https://api.github.com/users/Gemesys/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 386191887, "node_id": "MDU6TGFiZWwzODYxOTE4ODc=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:awaiting%20response", "name": "stat:awaiting response", "color": "f4b400", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 30, "created_at": "2018-01-07T21:27:51Z", "updated_at": "2018-05-25T16:46:03Z", "closed_at": "2018-03-09T14:25:49Z", "author_association": "NONE", "body_html": "<h3>System information</h3>\n<ul>\n<li>\n<p><strong>Have I written custom code (as opposed to using a stock example script provided in TensorFlow)</strong>: No.</p>\n</li>\n<li>\n<p><strong>OS Platform and Distribution (e.g., Linux Ubuntu 16.04)</strong>:<br>\nLinux CentOS-7.4 and MacOSx 10.10.5</p>\n</li>\n<li>\n<p><strong>TensorFlow installed from (source or binary)</strong>: Both; Installed from binary, then, built and installed from source. Same behaviour on each install.</p>\n</li>\n<li>\n<p><strong>TensorFlow version (use command below)</strong>:<br>\nTensorflow 1.4.0 and Tensorflow 1.4.1</p>\n</li>\n<li>\n<p><strong>Python version</strong>:<br>\n2.7.14 (installed from binary, and then built and installed from source</p>\n</li>\n<li>\n<p><strong>Bazel version (if compiling from source)</strong>:<br>\nBazel 0.9.0.  Source built and installed successfully, Python .whl file built &amp; installed successfully.</p>\n</li>\n<li>\n<p><strong>GCC/Compiler version (if compiling from source)</strong>:<br>\nXcode7.2.1 and the Gnu gFortran, 5.2.  (needed gFortran for SciPy install.  All installs OK.)</p>\n</li>\n<li>\n<p><strong>CUDA/cuDNN version</strong>:<br>\nN/A - compiled and running CPU versions only for now.</p>\n</li>\n<li>\n<p><strong>GPU model and memory</strong>:</p>\n</li>\n<li>\n<p><strong>Exact command to reproduce</strong>:<br>\n(See supplied test program - based on the Laplace PDE (\"Raindrops on Pond\") simulation example<br>\nfrom Tensorflow Tutorial)</p>\n</li>\n</ul>\n<p>Description of Problem:<br>\nI've run into a curious situation.  I am getting very different behaviour in Tensorflow 1.4.1 on Linux and Tensorflow 1.4.1 on MacOSX, in straightforward image-generation simulation, based on the \"Raindrops on a Pond\" (Laplace PDE) example from the Tensorflow Tutorial.</p>\n<p>I must stress that <em>both</em> Tensorflow installations seem to be 100% correct, and operate other tests correctly, producing the same numeric results for simple models.</p>\n<p>I have also built Tensorflow 1.4.1 completely from source, and the Python 2.7.14 as well, on the MacOSX (MacBook) machine, in order to build the Python using \"--enable-unicode=ucs4\", since that was one difference I was able to find, between the two version.  But even with the Macbook now running exactly the same Python 2.7.14 as the Linux box, I am still getting wildly divergent evoluationary behaviour as when I iterate the simple simulation.   The numbers just zoom off in very different directions on each machine, and the generated images show this.</p>\n<p>On the MacOSX, the simulation evolves very quickly to a pure white canvas (all \"255\"s), but on the Linux platform, the image grows more complex, with the generated numbers bifurcating between large negative and large positive - and hence when np.clip-ed, to range 0-255, show a complex moire-style pattern.</p>\n<p>I have confirmed all related libraries and packages seem to be the same versions.  The difference seems to be in the operation of Tensorflow.</p>\n<p>This seems pretty serious, as each platform is Intel.  The Linux box (CentOS-7.4) is Core-i3, while the Macbook is Core-i5.  But both are 64-bit, and both Tensorflow installations seem to be correct.  I have tried both the binary version, and then built a complete local version of Tensorflow 1.4.1 for the Macbook from source.  Both seem to be Ok, and operate correctly.  The Linux version of Tensorflow 1.4.0 was installed from binary appears to be operating correctly, albeit differently, but just for this one program.</p>\n<p>When the sample program runs, it will display fourteen 400x400 images, as well as the numeric values of the row-20 of the \"a\" array (400 numbers).   The program can be started from an Xterm shell window, with \"python LapTest.py\".  It does not need Jupyter or IPython.  With SciPy loaded, the images are rendered as .PNG files on both platforms, using Preview on the MacOSX MacBook, and ImageMagick on the CentOS-7.4 Linux box.   Program runs fine to completion, and all looks ok on both machines.</p>\n<p>But the results - even with the simple initial pseudo-random conditions - evolve completely differently, and consistantly.  The Macbook version of Tensorflow 1.4.1 goes to a pure white screen, while the LInux Tensorflow 1.4.1 configuration evolves to a complex, chaotic, moire-pattern.</p>\n<p>Leaving aside the question of even which machine is \"correct\", the expected result is of course that both machines should at least show clear evidence of similar behaviour.</p>\n<p>No change was made to the test program, \"LapTest.py\", from one machine to the other.   The different behaviour is not related to how the images are displayed, which is working fine on both platforms.   A copy of this simple program is provided.   I have removed or commented out the IPython/Jupyter dependent code, so this program can be run on plain vanilla Python 2.7.14, as long the appropriate packages (tensorflow, numpy, scipy, PIL (Pillow version), matplotlib, imageio ...) are available</p>\n<p>Example of Source code to demostrate behaviour:     LapTest.py</p>\n<pre><code>#-------------------------------------------------------------------------------\n# Prgm: LapTest.py\n#\n# --- the Tensorflow LaPlace Image example (Uses PIL(Pillow ver.), and numpy)\n# --- updated for TensorFlow 1.4.1 running on CentOS-7.4 &amp; Python 2.7.14\n#     compiled (configured, actually) with the \"--enable-unicode=ucs4\" option\n#                                             (Python compile default is ucs2)\n#                                             (which caused TensorFlow 1.4 to)\n#                                             (fail to load. Building Python )\n#                                             (with ucs4, =&gt; pip can install )\n#                                             (TensorFlow 1.4.0 successfully.)\n#\n# --- This version of program tested on: MacOSX 10.10.5. (Yosemite)\n# --- LapTest.py on Linux (CentOS-7.4), and LapTest.py on MacOSX, with Tensorflow-1.4.1 and\n#     Python 2.7.14 (with ucs4 enabled on both Python versions), show *very*\n#     different behaviour, and produce very different results.\n#     Note: CentOS-7.4 is using Linux kernel: 4.14.9-1el7.elrepo.x86_64    \n#\n# --- Import various libraries for simulation\nimport tensorflow as tf\nimport numpy as np\nimport scipy.misc\nimport imageio\nimport os\nimport sys\nimport subprocess\nimport PIL\nimport time    \n\n\n# --- Import for visualization and jpeg encoder  \nimport matplotlib\nmatplotlib.rcParams[\"backend\"]= 'TkAgg'\nfrom matplotlib import pyplot as plt\n# from PIL import Image, ImageDraw\nfrom io import BytesIO\n#  from IPython.display import clear_output, Image, display\n\n#--- we need this to get a sane for-loop...\ndef jump_range(start, end, step):\n    while start &lt;= end:\n        yield start\n        start += step\n\n# --- function for displaying state of the pond's surface as an image\ndef DisplayArray(a, fmt='jpeg', rng=[0,1]):\n  global proc\n  # proc.kill() \n  # \"\"\"Display an array as a picture. \"\"\"\n  a = (a - float(rng[0]))/float(rng[1] - rng[0])*37\n  amod = np.clip(a, 0, 255)\n  a = np.uint8(amod)\n#  a = np.clip(a, 0, 255) \n#  a = np.uint8(a) \n#  np.clip(a, 0, 255, out=a )\n#  a = a.astype('uint8')\n  print \" \"\n  print \" ----------- This is a: =&gt; row 20  ------------\"\n  print a[20]\n  print \" ----------------------------------------------\"\n  f = BytesIO()\n  # --- this is the cool, realtime thing that runs in Jupyter-IPython Notebook\n  PIL.Image.fromarray(a).save(f,fmt)\n  # --- clear_output(wait = True)  --- only for IPython\n  # display(Image(data=f.getvalue()))\n  # --- write the image\n  # --- write the simulation images to .jpg files\n  scipy.misc.imsave(\"tensor.jpg\", a)\n  pic = PIL.Image.open(\"tensor.jpg\")\n  # --- new approach... use subprocess, wait for time(2) then kill it\n  # proc = subprocess.Popen([\"display\", \"./tensor.jpg\"])\n  # time.sleep(0.5)\n  pic.show()\n  # clear_output(wait=True)\n  # --- this line below doesn't work outside of the Jupyter environment...\n  # display(Image(data=f.getvalue()))\n  #\n  # pic.close()  &lt;--- does not work to close image.  Just removes the pointer to image in memory\n    \ndef DisplayArrayToFile(a, fmt='jpeg', rng=[0,1]):\n  # \"\"\"Display an array as a picture to a file... \"\"\"\n  a = (a - rng[0])/float(rng[1] - rng[0])*37\n  a = np.uint8(np.clip(a, 0, 255))\n  f = BytesIO()\n  # --- this is the cool, realtime thing that runs in Jupyter-IPython Notebook\n  PIL.Image.fromarray(a).save(f,fmt)\n  # clear_output(wait = True)\n  # display(Image(data=f.getvalue()))\n  # --- write the image\n  # --- this is my stuff to write the simulation images to .jpg files\n  #scipy.misc.imsave (\"tensor_new.jpg\", a)\n  imageio.imwrite(\"tensor_new.jpg\", a)\n  # --- image = PIL.Image.open(\"tensor_new.jpg\")\n  # --- image.show()\n  # clear_output(wait=True)\n  # display(Image(data=f.getvalue()))\n  #\n \n# --- make print stmt print the whole array... (not just part of it...)\nnp.set_printoptions(threshold=np.nan)\n  \n# --- make interactive session for testing - can use regular session also\nsess = tf.InteractiveSession()\n# sess = tf.Session()\n\n# --- computational functions go here... once we get jpeg pic working\ndef make_kernel(a):\n  \"\"\"Transform a 2D array into a convolutional kernel \"\"\"\n  a = np.asarray(a)\n  a = a.reshape(list(a.shape) + [1,1])\n  return tf.constant(a, dtype=1)\n\n\ndef simple_conv(x, k):\n  \"\"\" A simplified 2D convolutional operation \"\"\"\n  x = tf.expand_dims(tf.expand_dims(x, 0), -1)\n  y = tf.nn.depthwise_conv2d(x, k, [1, 1, 1, 1], padding='SAME')\n  return y[0, :, :, 0]\n\n\ndef laplace(x):\n  \"\"\"Compute the 2D laplacian of an array \"\"\"\n  laplace_k = make_kernel([[0.5, 1.0, 0.5],\n                           [1.0, -6., 1.0],\n                           [0.5, 1.0, 0.5]])  \n  return simple_conv(x, laplace_k)\n\n\n\n# --- Define the PDE - the pond surface is a perfect 400x400 square\nN = 400\n\n# --- list of display points...\ndispval = jump_range(0, 12500, 1000)\n# --- dispval has to be a list...\ndispval = list(dispval)\nprint \"We will look at these values: \",dispval\n\n# --- now, we create some \"raindrops\"\n# --- Initial Conditions -- some rain drops hit the pond\n# --- set everything to zero\nu_init = np.zeros([N, N], dtype=np.float32)\nut_init = np.zeros([N, N], dtype=np.float32)\n\n# Some material accretion occurs (raindrops hit pond) at random points\nfor n in range(40):\n  a,b = np.random.randint(0, N, 2)\n  u_init[a,b] = np.random.uniform()\n\n# --- Create and Display the jpeg image...\n# proc = subprocess.Popen([\"display\", \"./tensor.jpg\"])\n# DisplayArray(u_init, rng=[-0.1, 0.1])\n\n# Parameters\n# eps -- time resolution\n# damping -- wave damping\neps = tf.placeholder(tf.float32, shape=())\ndamping = tf.placeholder(tf.float32, shape=())\n\n# --- Create vaiables for simulation state\nU  = tf.Variable(u_init)\nUt = tf.Variable(u_init)\n\n# --- Discretized PDE update rules\nU_  = U + eps * Ut\nUt_ = Ut + eps * (laplace(U) - damping * Ut)\n\n# --- Operation to update the state\nstep = tf.group(\n  U.assign(U_),\n  Ut.assign(Ut_))\n\n# --- Run the simulation forward with a simple FOR loop.\n# --- Initialize state to initial conditions\ntf.global_variables_initializer().run(session=sess)\n\n# --- Run 12701 steps of PDE\nfor i in range(12701):\n  # Step simulation  (damping was 0.04, I made it negative .14)\n   with sess.as_default(): step.run( {eps: 0.03, damping: -0.14})\n# --- to see everything...\n#   with sess.as_default(): print \"U.eval()   .... \", U.eval()[20]  # --- ,\"   \", Ut.eval()\n# ------\n\n   if (i in dispval) :\n       with sess.as_default(): DisplayArray(U.eval(), rng=[-0.1, 0.1])\n       print \"                                ------ For iteration:  \",i\n       sys.stdout.flush()\n       print \"U.eval()   ....... \"\n       with sess.as_default(): print   U.eval()[20]      # --- ,\"   \", Ut.eval()\n       print \"                                --- End of iteration:  \",i\n       sys.stdout.flush()\n       continue\n#\n# --- to show each iteration...\n#  with sess.as_default(): DisplayArray(U.eval(), rng=[-0.1, 0.1])\nprint \"Done at: \",i\n\n# --- Ok, we are done...\nwith sess.as_default(): DisplayArray(U.eval(), rng=[-0.1, 0.1])\n\nwith sess.as_default(): DisplayArrayToFile(U.eval(), rng=[-0.1, 0.1])\nprint \"Last Image Written to file: tensor_new.jpg. Done.\"   \n#--------------- done ------------------\n</code></pre>\n<p>If someone could try this program on a supported version of Linux (ie. the Ubuntu version that TensorFlow officially supports), that would be helpful.  I am running a recent version of the Linux kernel on the CentOS-7.4 box  (uname -a reports: kernel version 4.14.9-1.el7.elrepo.x86_64 ).  Really like to nail down what is happening.  I have attached images of results I am seeing on the two machines, first the Linux box, second is the Macbook.</p>\n<p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://user-images.githubusercontent.com/16905336/34654259-45838fc6-f3c7-11e7-93b1-96751153c3a4.jpg\"><img src=\"https://user-images.githubusercontent.com/16905336/34654259-45838fc6-f3c7-11e7-93b1-96751153c3a4.jpg\" alt=\"laptest_linux_img_20180107_150905_sml\" style=\"max-width:100%;\"></a><br>\n<a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://user-images.githubusercontent.com/16905336/34654263-4c961b44-f3c7-11e7-8998-f3122f6d9e7c.jpg\"><img src=\"https://user-images.githubusercontent.com/16905336/34654263-4c961b44-f3c7-11e7-8998-f3122f6d9e7c.jpg\" alt=\"laptest_mac_img_20180107_151332_sml\" style=\"max-width:100%;\"></a></p>", "body_text": "System information\n\n\nHave I written custom code (as opposed to using a stock example script provided in TensorFlow): No.\n\n\nOS Platform and Distribution (e.g., Linux Ubuntu 16.04):\nLinux CentOS-7.4 and MacOSx 10.10.5\n\n\nTensorFlow installed from (source or binary): Both; Installed from binary, then, built and installed from source. Same behaviour on each install.\n\n\nTensorFlow version (use command below):\nTensorflow 1.4.0 and Tensorflow 1.4.1\n\n\nPython version:\n2.7.14 (installed from binary, and then built and installed from source\n\n\nBazel version (if compiling from source):\nBazel 0.9.0.  Source built and installed successfully, Python .whl file built & installed successfully.\n\n\nGCC/Compiler version (if compiling from source):\nXcode7.2.1 and the Gnu gFortran, 5.2.  (needed gFortran for SciPy install.  All installs OK.)\n\n\nCUDA/cuDNN version:\nN/A - compiled and running CPU versions only for now.\n\n\nGPU model and memory:\n\n\nExact command to reproduce:\n(See supplied test program - based on the Laplace PDE (\"Raindrops on Pond\") simulation example\nfrom Tensorflow Tutorial)\n\n\nDescription of Problem:\nI've run into a curious situation.  I am getting very different behaviour in Tensorflow 1.4.1 on Linux and Tensorflow 1.4.1 on MacOSX, in straightforward image-generation simulation, based on the \"Raindrops on a Pond\" (Laplace PDE) example from the Tensorflow Tutorial.\nI must stress that both Tensorflow installations seem to be 100% correct, and operate other tests correctly, producing the same numeric results for simple models.\nI have also built Tensorflow 1.4.1 completely from source, and the Python 2.7.14 as well, on the MacOSX (MacBook) machine, in order to build the Python using \"--enable-unicode=ucs4\", since that was one difference I was able to find, between the two version.  But even with the Macbook now running exactly the same Python 2.7.14 as the Linux box, I am still getting wildly divergent evoluationary behaviour as when I iterate the simple simulation.   The numbers just zoom off in very different directions on each machine, and the generated images show this.\nOn the MacOSX, the simulation evolves very quickly to a pure white canvas (all \"255\"s), but on the Linux platform, the image grows more complex, with the generated numbers bifurcating between large negative and large positive - and hence when np.clip-ed, to range 0-255, show a complex moire-style pattern.\nI have confirmed all related libraries and packages seem to be the same versions.  The difference seems to be in the operation of Tensorflow.\nThis seems pretty serious, as each platform is Intel.  The Linux box (CentOS-7.4) is Core-i3, while the Macbook is Core-i5.  But both are 64-bit, and both Tensorflow installations seem to be correct.  I have tried both the binary version, and then built a complete local version of Tensorflow 1.4.1 for the Macbook from source.  Both seem to be Ok, and operate correctly.  The Linux version of Tensorflow 1.4.0 was installed from binary appears to be operating correctly, albeit differently, but just for this one program.\nWhen the sample program runs, it will display fourteen 400x400 images, as well as the numeric values of the row-20 of the \"a\" array (400 numbers).   The program can be started from an Xterm shell window, with \"python LapTest.py\".  It does not need Jupyter or IPython.  With SciPy loaded, the images are rendered as .PNG files on both platforms, using Preview on the MacOSX MacBook, and ImageMagick on the CentOS-7.4 Linux box.   Program runs fine to completion, and all looks ok on both machines.\nBut the results - even with the simple initial pseudo-random conditions - evolve completely differently, and consistantly.  The Macbook version of Tensorflow 1.4.1 goes to a pure white screen, while the LInux Tensorflow 1.4.1 configuration evolves to a complex, chaotic, moire-pattern.\nLeaving aside the question of even which machine is \"correct\", the expected result is of course that both machines should at least show clear evidence of similar behaviour.\nNo change was made to the test program, \"LapTest.py\", from one machine to the other.   The different behaviour is not related to how the images are displayed, which is working fine on both platforms.   A copy of this simple program is provided.   I have removed or commented out the IPython/Jupyter dependent code, so this program can be run on plain vanilla Python 2.7.14, as long the appropriate packages (tensorflow, numpy, scipy, PIL (Pillow version), matplotlib, imageio ...) are available\nExample of Source code to demostrate behaviour:     LapTest.py\n#-------------------------------------------------------------------------------\n# Prgm: LapTest.py\n#\n# --- the Tensorflow LaPlace Image example (Uses PIL(Pillow ver.), and numpy)\n# --- updated for TensorFlow 1.4.1 running on CentOS-7.4 & Python 2.7.14\n#     compiled (configured, actually) with the \"--enable-unicode=ucs4\" option\n#                                             (Python compile default is ucs2)\n#                                             (which caused TensorFlow 1.4 to)\n#                                             (fail to load. Building Python )\n#                                             (with ucs4, => pip can install )\n#                                             (TensorFlow 1.4.0 successfully.)\n#\n# --- This version of program tested on: MacOSX 10.10.5. (Yosemite)\n# --- LapTest.py on Linux (CentOS-7.4), and LapTest.py on MacOSX, with Tensorflow-1.4.1 and\n#     Python 2.7.14 (with ucs4 enabled on both Python versions), show *very*\n#     different behaviour, and produce very different results.\n#     Note: CentOS-7.4 is using Linux kernel: 4.14.9-1el7.elrepo.x86_64    \n#\n# --- Import various libraries for simulation\nimport tensorflow as tf\nimport numpy as np\nimport scipy.misc\nimport imageio\nimport os\nimport sys\nimport subprocess\nimport PIL\nimport time    \n\n\n# --- Import for visualization and jpeg encoder  \nimport matplotlib\nmatplotlib.rcParams[\"backend\"]= 'TkAgg'\nfrom matplotlib import pyplot as plt\n# from PIL import Image, ImageDraw\nfrom io import BytesIO\n#  from IPython.display import clear_output, Image, display\n\n#--- we need this to get a sane for-loop...\ndef jump_range(start, end, step):\n    while start <= end:\n        yield start\n        start += step\n\n# --- function for displaying state of the pond's surface as an image\ndef DisplayArray(a, fmt='jpeg', rng=[0,1]):\n  global proc\n  # proc.kill() \n  # \"\"\"Display an array as a picture. \"\"\"\n  a = (a - float(rng[0]))/float(rng[1] - rng[0])*37\n  amod = np.clip(a, 0, 255)\n  a = np.uint8(amod)\n#  a = np.clip(a, 0, 255) \n#  a = np.uint8(a) \n#  np.clip(a, 0, 255, out=a )\n#  a = a.astype('uint8')\n  print \" \"\n  print \" ----------- This is a: => row 20  ------------\"\n  print a[20]\n  print \" ----------------------------------------------\"\n  f = BytesIO()\n  # --- this is the cool, realtime thing that runs in Jupyter-IPython Notebook\n  PIL.Image.fromarray(a).save(f,fmt)\n  # --- clear_output(wait = True)  --- only for IPython\n  # display(Image(data=f.getvalue()))\n  # --- write the image\n  # --- write the simulation images to .jpg files\n  scipy.misc.imsave(\"tensor.jpg\", a)\n  pic = PIL.Image.open(\"tensor.jpg\")\n  # --- new approach... use subprocess, wait for time(2) then kill it\n  # proc = subprocess.Popen([\"display\", \"./tensor.jpg\"])\n  # time.sleep(0.5)\n  pic.show()\n  # clear_output(wait=True)\n  # --- this line below doesn't work outside of the Jupyter environment...\n  # display(Image(data=f.getvalue()))\n  #\n  # pic.close()  <--- does not work to close image.  Just removes the pointer to image in memory\n    \ndef DisplayArrayToFile(a, fmt='jpeg', rng=[0,1]):\n  # \"\"\"Display an array as a picture to a file... \"\"\"\n  a = (a - rng[0])/float(rng[1] - rng[0])*37\n  a = np.uint8(np.clip(a, 0, 255))\n  f = BytesIO()\n  # --- this is the cool, realtime thing that runs in Jupyter-IPython Notebook\n  PIL.Image.fromarray(a).save(f,fmt)\n  # clear_output(wait = True)\n  # display(Image(data=f.getvalue()))\n  # --- write the image\n  # --- this is my stuff to write the simulation images to .jpg files\n  #scipy.misc.imsave (\"tensor_new.jpg\", a)\n  imageio.imwrite(\"tensor_new.jpg\", a)\n  # --- image = PIL.Image.open(\"tensor_new.jpg\")\n  # --- image.show()\n  # clear_output(wait=True)\n  # display(Image(data=f.getvalue()))\n  #\n \n# --- make print stmt print the whole array... (not just part of it...)\nnp.set_printoptions(threshold=np.nan)\n  \n# --- make interactive session for testing - can use regular session also\nsess = tf.InteractiveSession()\n# sess = tf.Session()\n\n# --- computational functions go here... once we get jpeg pic working\ndef make_kernel(a):\n  \"\"\"Transform a 2D array into a convolutional kernel \"\"\"\n  a = np.asarray(a)\n  a = a.reshape(list(a.shape) + [1,1])\n  return tf.constant(a, dtype=1)\n\n\ndef simple_conv(x, k):\n  \"\"\" A simplified 2D convolutional operation \"\"\"\n  x = tf.expand_dims(tf.expand_dims(x, 0), -1)\n  y = tf.nn.depthwise_conv2d(x, k, [1, 1, 1, 1], padding='SAME')\n  return y[0, :, :, 0]\n\n\ndef laplace(x):\n  \"\"\"Compute the 2D laplacian of an array \"\"\"\n  laplace_k = make_kernel([[0.5, 1.0, 0.5],\n                           [1.0, -6., 1.0],\n                           [0.5, 1.0, 0.5]])  \n  return simple_conv(x, laplace_k)\n\n\n\n# --- Define the PDE - the pond surface is a perfect 400x400 square\nN = 400\n\n# --- list of display points...\ndispval = jump_range(0, 12500, 1000)\n# --- dispval has to be a list...\ndispval = list(dispval)\nprint \"We will look at these values: \",dispval\n\n# --- now, we create some \"raindrops\"\n# --- Initial Conditions -- some rain drops hit the pond\n# --- set everything to zero\nu_init = np.zeros([N, N], dtype=np.float32)\nut_init = np.zeros([N, N], dtype=np.float32)\n\n# Some material accretion occurs (raindrops hit pond) at random points\nfor n in range(40):\n  a,b = np.random.randint(0, N, 2)\n  u_init[a,b] = np.random.uniform()\n\n# --- Create and Display the jpeg image...\n# proc = subprocess.Popen([\"display\", \"./tensor.jpg\"])\n# DisplayArray(u_init, rng=[-0.1, 0.1])\n\n# Parameters\n# eps -- time resolution\n# damping -- wave damping\neps = tf.placeholder(tf.float32, shape=())\ndamping = tf.placeholder(tf.float32, shape=())\n\n# --- Create vaiables for simulation state\nU  = tf.Variable(u_init)\nUt = tf.Variable(u_init)\n\n# --- Discretized PDE update rules\nU_  = U + eps * Ut\nUt_ = Ut + eps * (laplace(U) - damping * Ut)\n\n# --- Operation to update the state\nstep = tf.group(\n  U.assign(U_),\n  Ut.assign(Ut_))\n\n# --- Run the simulation forward with a simple FOR loop.\n# --- Initialize state to initial conditions\ntf.global_variables_initializer().run(session=sess)\n\n# --- Run 12701 steps of PDE\nfor i in range(12701):\n  # Step simulation  (damping was 0.04, I made it negative .14)\n   with sess.as_default(): step.run( {eps: 0.03, damping: -0.14})\n# --- to see everything...\n#   with sess.as_default(): print \"U.eval()   .... \", U.eval()[20]  # --- ,\"   \", Ut.eval()\n# ------\n\n   if (i in dispval) :\n       with sess.as_default(): DisplayArray(U.eval(), rng=[-0.1, 0.1])\n       print \"                                ------ For iteration:  \",i\n       sys.stdout.flush()\n       print \"U.eval()   ....... \"\n       with sess.as_default(): print   U.eval()[20]      # --- ,\"   \", Ut.eval()\n       print \"                                --- End of iteration:  \",i\n       sys.stdout.flush()\n       continue\n#\n# --- to show each iteration...\n#  with sess.as_default(): DisplayArray(U.eval(), rng=[-0.1, 0.1])\nprint \"Done at: \",i\n\n# --- Ok, we are done...\nwith sess.as_default(): DisplayArray(U.eval(), rng=[-0.1, 0.1])\n\nwith sess.as_default(): DisplayArrayToFile(U.eval(), rng=[-0.1, 0.1])\nprint \"Last Image Written to file: tensor_new.jpg. Done.\"   \n#--------------- done ------------------\n\nIf someone could try this program on a supported version of Linux (ie. the Ubuntu version that TensorFlow officially supports), that would be helpful.  I am running a recent version of the Linux kernel on the CentOS-7.4 box  (uname -a reports: kernel version 4.14.9-1.el7.elrepo.x86_64 ).  Really like to nail down what is happening.  I have attached images of results I am seeing on the two machines, first the Linux box, second is the Macbook.", "body": " \r\n### System information\r\n- **Have I written custom code (as opposed to using a stock example script provided in TensorFlow)**: No.\r\n\r\n- **OS Platform and Distribution (e.g., Linux Ubuntu 16.04)**:  \r\nLinux CentOS-7.4 and MacOSx 10.10.5\r\n\r\n- **TensorFlow installed from (source or binary)**: Both; Installed from binary, then, built and installed from source. Same behaviour on each install.\r\n\r\n- **TensorFlow version (use command below)**:\r\nTensorflow 1.4.0 and Tensorflow 1.4.1\r\n\r\n- **Python version**: \r\n2.7.14 (installed from binary, and then built and installed from source\r\n\r\n- **Bazel version (if compiling from source)**:\r\nBazel 0.9.0.  Source built and installed successfully, Python .whl file built & installed successfully.\r\n\r\n- **GCC/Compiler version (if compiling from source)**:\r\nXcode7.2.1 and the Gnu gFortran, 5.2.  (needed gFortran for SciPy install.  All installs OK.)\r\n\r\n- **CUDA/cuDNN version**:\r\nN/A - compiled and running CPU versions only for now.\r\n\r\n- **GPU model and memory**:\r\n\r\n- **Exact command to reproduce**:\r\n(See supplied test program - based on the Laplace PDE (\"Raindrops on Pond\") simulation example\r\nfrom Tensorflow Tutorial)\r\n \r\nDescription of Problem:\r\n I've run into a curious situation.  I am getting very different behaviour in Tensorflow 1.4.1 on Linux and Tensorflow 1.4.1 on MacOSX, in straightforward image-generation simulation, based on the \"Raindrops on a Pond\" (Laplace PDE) example from the Tensorflow Tutorial.\r\n\r\nI must stress that *both* Tensorflow installations seem to be 100% correct, and operate other tests correctly, producing the same numeric results for simple models.\r\n\r\nI have also built Tensorflow 1.4.1 completely from source, and the Python 2.7.14 as well, on the MacOSX (MacBook) machine, in order to build the Python using \"--enable-unicode=ucs4\", since that was one difference I was able to find, between the two version.  But even with the Macbook now running exactly the same Python 2.7.14 as the Linux box, I am still getting wildly divergent evoluationary behaviour as when I iterate the simple simulation.   The numbers just zoom off in very different directions on each machine, and the generated images show this.  \r\n\r\nOn the MacOSX, the simulation evolves very quickly to a pure white canvas (all \"255\"s), but on the Linux platform, the image grows more complex, with the generated numbers bifurcating between large negative and large positive - and hence when np.clip-ed, to range 0-255, show a complex moire-style pattern.\r\n\r\nI have confirmed all related libraries and packages seem to be the same versions.  The difference seems to be in the operation of Tensorflow.  \r\n\r\nThis seems pretty serious, as each platform is Intel.  The Linux box (CentOS-7.4) is Core-i3, while the Macbook is Core-i5.  But both are 64-bit, and both Tensorflow installations seem to be correct.  I have tried both the binary version, and then built a complete local version of Tensorflow 1.4.1 for the Macbook from source.  Both seem to be Ok, and operate correctly.  The Linux version of Tensorflow 1.4.0 was installed from binary appears to be operating correctly, albeit differently, but just for this one program.\r\n\r\nWhen the sample program runs, it will display fourteen 400x400 images, as well as the numeric values of the row-20 of the \"a\" array (400 numbers).   The program can be started from an Xterm shell window, with \"python LapTest.py\".  It does not need Jupyter or IPython.  With SciPy loaded, the images are rendered as .PNG files on both platforms, using Preview on the MacOSX MacBook, and ImageMagick on the CentOS-7.4 Linux box.   Program runs fine to completion, and all looks ok on both machines.\r\n\r\nBut the results - even with the simple initial pseudo-random conditions - evolve completely differently, and consistantly.  The Macbook version of Tensorflow 1.4.1 goes to a pure white screen, while the LInux Tensorflow 1.4.1 configuration evolves to a complex, chaotic, moire-pattern.  \r\n\r\nLeaving aside the question of even which machine is \"correct\", the expected result is of course that both machines should at least show clear evidence of similar behaviour.\r\n\r\nNo change was made to the test program, \"LapTest.py\", from one machine to the other.   The different behaviour is not related to how the images are displayed, which is working fine on both platforms.   A copy of this simple program is provided.   I have removed or commented out the IPython/Jupyter dependent code, so this program can be run on plain vanilla Python 2.7.14, as long the appropriate packages (tensorflow, numpy, scipy, PIL (Pillow version), matplotlib, imageio ...) are available\r\n\r\nExample of Source code to demostrate behaviour:     LapTest.py \r\n``` \r\n#-------------------------------------------------------------------------------\r\n# Prgm: LapTest.py\r\n#\r\n# --- the Tensorflow LaPlace Image example (Uses PIL(Pillow ver.), and numpy)\r\n# --- updated for TensorFlow 1.4.1 running on CentOS-7.4 & Python 2.7.14\r\n#     compiled (configured, actually) with the \"--enable-unicode=ucs4\" option\r\n#                                             (Python compile default is ucs2)\r\n#                                             (which caused TensorFlow 1.4 to)\r\n#                                             (fail to load. Building Python )\r\n#                                             (with ucs4, => pip can install )\r\n#                                             (TensorFlow 1.4.0 successfully.)\r\n#\r\n# --- This version of program tested on: MacOSX 10.10.5. (Yosemite)\r\n# --- LapTest.py on Linux (CentOS-7.4), and LapTest.py on MacOSX, with Tensorflow-1.4.1 and\r\n#     Python 2.7.14 (with ucs4 enabled on both Python versions), show *very*\r\n#     different behaviour, and produce very different results.\r\n#     Note: CentOS-7.4 is using Linux kernel: 4.14.9-1el7.elrepo.x86_64    \r\n#\r\n# --- Import various libraries for simulation\r\nimport tensorflow as tf\r\nimport numpy as np\r\nimport scipy.misc\r\nimport imageio\r\nimport os\r\nimport sys\r\nimport subprocess\r\nimport PIL\r\nimport time    \r\n\r\n\r\n# --- Import for visualization and jpeg encoder  \r\nimport matplotlib\r\nmatplotlib.rcParams[\"backend\"]= 'TkAgg'\r\nfrom matplotlib import pyplot as plt\r\n# from PIL import Image, ImageDraw\r\nfrom io import BytesIO\r\n#  from IPython.display import clear_output, Image, display\r\n\r\n#--- we need this to get a sane for-loop...\r\ndef jump_range(start, end, step):\r\n    while start <= end:\r\n        yield start\r\n        start += step\r\n\r\n# --- function for displaying state of the pond's surface as an image\r\ndef DisplayArray(a, fmt='jpeg', rng=[0,1]):\r\n  global proc\r\n  # proc.kill() \r\n  # \"\"\"Display an array as a picture. \"\"\"\r\n  a = (a - float(rng[0]))/float(rng[1] - rng[0])*37\r\n  amod = np.clip(a, 0, 255)\r\n  a = np.uint8(amod)\r\n#  a = np.clip(a, 0, 255) \r\n#  a = np.uint8(a) \r\n#  np.clip(a, 0, 255, out=a )\r\n#  a = a.astype('uint8')\r\n  print \" \"\r\n  print \" ----------- This is a: => row 20  ------------\"\r\n  print a[20]\r\n  print \" ----------------------------------------------\"\r\n  f = BytesIO()\r\n  # --- this is the cool, realtime thing that runs in Jupyter-IPython Notebook\r\n  PIL.Image.fromarray(a).save(f,fmt)\r\n  # --- clear_output(wait = True)  --- only for IPython\r\n  # display(Image(data=f.getvalue()))\r\n  # --- write the image\r\n  # --- write the simulation images to .jpg files\r\n  scipy.misc.imsave(\"tensor.jpg\", a)\r\n  pic = PIL.Image.open(\"tensor.jpg\")\r\n  # --- new approach... use subprocess, wait for time(2) then kill it\r\n  # proc = subprocess.Popen([\"display\", \"./tensor.jpg\"])\r\n  # time.sleep(0.5)\r\n  pic.show()\r\n  # clear_output(wait=True)\r\n  # --- this line below doesn't work outside of the Jupyter environment...\r\n  # display(Image(data=f.getvalue()))\r\n  #\r\n  # pic.close()  <--- does not work to close image.  Just removes the pointer to image in memory\r\n    \r\ndef DisplayArrayToFile(a, fmt='jpeg', rng=[0,1]):\r\n  # \"\"\"Display an array as a picture to a file... \"\"\"\r\n  a = (a - rng[0])/float(rng[1] - rng[0])*37\r\n  a = np.uint8(np.clip(a, 0, 255))\r\n  f = BytesIO()\r\n  # --- this is the cool, realtime thing that runs in Jupyter-IPython Notebook\r\n  PIL.Image.fromarray(a).save(f,fmt)\r\n  # clear_output(wait = True)\r\n  # display(Image(data=f.getvalue()))\r\n  # --- write the image\r\n  # --- this is my stuff to write the simulation images to .jpg files\r\n  #scipy.misc.imsave (\"tensor_new.jpg\", a)\r\n  imageio.imwrite(\"tensor_new.jpg\", a)\r\n  # --- image = PIL.Image.open(\"tensor_new.jpg\")\r\n  # --- image.show()\r\n  # clear_output(wait=True)\r\n  # display(Image(data=f.getvalue()))\r\n  #\r\n \r\n# --- make print stmt print the whole array... (not just part of it...)\r\nnp.set_printoptions(threshold=np.nan)\r\n  \r\n# --- make interactive session for testing - can use regular session also\r\nsess = tf.InteractiveSession()\r\n# sess = tf.Session()\r\n\r\n# --- computational functions go here... once we get jpeg pic working\r\ndef make_kernel(a):\r\n  \"\"\"Transform a 2D array into a convolutional kernel \"\"\"\r\n  a = np.asarray(a)\r\n  a = a.reshape(list(a.shape) + [1,1])\r\n  return tf.constant(a, dtype=1)\r\n\r\n\r\ndef simple_conv(x, k):\r\n  \"\"\" A simplified 2D convolutional operation \"\"\"\r\n  x = tf.expand_dims(tf.expand_dims(x, 0), -1)\r\n  y = tf.nn.depthwise_conv2d(x, k, [1, 1, 1, 1], padding='SAME')\r\n  return y[0, :, :, 0]\r\n\r\n\r\ndef laplace(x):\r\n  \"\"\"Compute the 2D laplacian of an array \"\"\"\r\n  laplace_k = make_kernel([[0.5, 1.0, 0.5],\r\n                           [1.0, -6., 1.0],\r\n                           [0.5, 1.0, 0.5]])  \r\n  return simple_conv(x, laplace_k)\r\n\r\n\r\n\r\n# --- Define the PDE - the pond surface is a perfect 400x400 square\r\nN = 400\r\n\r\n# --- list of display points...\r\ndispval = jump_range(0, 12500, 1000)\r\n# --- dispval has to be a list...\r\ndispval = list(dispval)\r\nprint \"We will look at these values: \",dispval\r\n\r\n# --- now, we create some \"raindrops\"\r\n# --- Initial Conditions -- some rain drops hit the pond\r\n# --- set everything to zero\r\nu_init = np.zeros([N, N], dtype=np.float32)\r\nut_init = np.zeros([N, N], dtype=np.float32)\r\n\r\n# Some material accretion occurs (raindrops hit pond) at random points\r\nfor n in range(40):\r\n  a,b = np.random.randint(0, N, 2)\r\n  u_init[a,b] = np.random.uniform()\r\n\r\n# --- Create and Display the jpeg image...\r\n# proc = subprocess.Popen([\"display\", \"./tensor.jpg\"])\r\n# DisplayArray(u_init, rng=[-0.1, 0.1])\r\n\r\n# Parameters\r\n# eps -- time resolution\r\n# damping -- wave damping\r\neps = tf.placeholder(tf.float32, shape=())\r\ndamping = tf.placeholder(tf.float32, shape=())\r\n\r\n# --- Create vaiables for simulation state\r\nU  = tf.Variable(u_init)\r\nUt = tf.Variable(u_init)\r\n\r\n# --- Discretized PDE update rules\r\nU_  = U + eps * Ut\r\nUt_ = Ut + eps * (laplace(U) - damping * Ut)\r\n\r\n# --- Operation to update the state\r\nstep = tf.group(\r\n  U.assign(U_),\r\n  Ut.assign(Ut_))\r\n\r\n# --- Run the simulation forward with a simple FOR loop.\r\n# --- Initialize state to initial conditions\r\ntf.global_variables_initializer().run(session=sess)\r\n\r\n# --- Run 12701 steps of PDE\r\nfor i in range(12701):\r\n  # Step simulation  (damping was 0.04, I made it negative .14)\r\n   with sess.as_default(): step.run( {eps: 0.03, damping: -0.14})\r\n# --- to see everything...\r\n#   with sess.as_default(): print \"U.eval()   .... \", U.eval()[20]  # --- ,\"   \", Ut.eval()\r\n# ------\r\n\r\n   if (i in dispval) :\r\n       with sess.as_default(): DisplayArray(U.eval(), rng=[-0.1, 0.1])\r\n       print \"                                ------ For iteration:  \",i\r\n       sys.stdout.flush()\r\n       print \"U.eval()   ....... \"\r\n       with sess.as_default(): print   U.eval()[20]      # --- ,\"   \", Ut.eval()\r\n       print \"                                --- End of iteration:  \",i\r\n       sys.stdout.flush()\r\n       continue\r\n#\r\n# --- to show each iteration...\r\n#  with sess.as_default(): DisplayArray(U.eval(), rng=[-0.1, 0.1])\r\nprint \"Done at: \",i\r\n\r\n# --- Ok, we are done...\r\nwith sess.as_default(): DisplayArray(U.eval(), rng=[-0.1, 0.1])\r\n\r\nwith sess.as_default(): DisplayArrayToFile(U.eval(), rng=[-0.1, 0.1])\r\nprint \"Last Image Written to file: tensor_new.jpg. Done.\"   \r\n#--------------- done ------------------\r\n```\r\n\r\nIf someone could try this program on a supported version of Linux (ie. the Ubuntu version that TensorFlow officially supports), that would be helpful.  I am running a recent version of the Linux kernel on the CentOS-7.4 box  (uname -a reports: kernel version 4.14.9-1.el7.elrepo.x86_64 ).  Really like to nail down what is happening.  I have attached images of results I am seeing on the two machines, first the Linux box, second is the Macbook.   \r\n\r\n![laptest_linux_img_20180107_150905_sml](https://user-images.githubusercontent.com/16905336/34654259-45838fc6-f3c7-11e7-93b1-96751153c3a4.jpg)\r\n![laptest_mac_img_20180107_151332_sml](https://user-images.githubusercontent.com/16905336/34654263-4c961b44-f3c7-11e7-8998-f3122f6d9e7c.jpg)\r\n"}