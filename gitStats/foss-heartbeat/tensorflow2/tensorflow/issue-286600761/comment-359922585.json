{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/359922585", "html_url": "https://github.com/tensorflow/tensorflow/issues/15933#issuecomment-359922585", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/15933", "id": 359922585, "node_id": "MDEyOklzc3VlQ29tbWVudDM1OTkyMjU4NQ==", "user": {"login": "Gemesys", "id": 16905336, "node_id": "MDQ6VXNlcjE2OTA1MzM2", "avatar_url": "https://avatars1.githubusercontent.com/u/16905336?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gemesys", "html_url": "https://github.com/Gemesys", "followers_url": "https://api.github.com/users/Gemesys/followers", "following_url": "https://api.github.com/users/Gemesys/following{/other_user}", "gists_url": "https://api.github.com/users/Gemesys/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gemesys/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gemesys/subscriptions", "organizations_url": "https://api.github.com/users/Gemesys/orgs", "repos_url": "https://api.github.com/users/Gemesys/repos", "events_url": "https://api.github.com/users/Gemesys/events{/privacy}", "received_events_url": "https://api.github.com/users/Gemesys/received_events", "type": "User", "site_admin": false}, "created_at": "2018-01-23T20:38:22Z", "updated_at": "2018-01-23T20:38:22Z", "author_association": "NONE", "body_html": "<p>It was possible that the gfortran compiler might be responsible for the divergence in results between MacOS and Linux, so here is the C version of Kahan's PIRATS test program.  I basically just hacked it out of the UCBTest suite, and made a stand-alone version of it.  It can be compiled and run on MacOS under Apple's gcc (on Macbook: \"gcc --version\" reports: LLVM 7.0.2 (clang-700.1.81)) and CentOS-7.4 Linux (Same results seen on  Ubuntu also, as per what quaeler has reported). (My version of CentOS's gcc reports for \"gcc --version\":  4.8.5  20150623 (Red Hat 4.8.5-16)).</p>\n<p>This C version of PIRATS shows the same divergence as the gFortran version does.  I've provided it here, because it make it easier to run this on different machines to see what results are reported - i.e. no need to download and install a version of gfortran.   Interestingly, the \"single precision\" versions of PIRATS generate results that are exactly the same across both machines.  And the gfortran versions on both machines match exactly the C version results obtained on each machine.  So, regardless of using C or gFortran, the same divergence is evident between MacOS and Linux.  And based on quaeler's results, the divergence that PIRATS demostrates is evident across old and new versions of MacOS, versus current CentOS and Ubuntu Linux.</p>\n<pre><code>/*\nC.... PIRATS                     Copyright (C) by W. Kahan, Mar. 8, 1989\nC\nC.... This program finds close rational approximations\nC.... A/B to PI, and computes the differences C = PI-A/B to\nC.... working precision within errors no bigger than E.  Working\nC.... precision arithmetic is presumed to carry no more than about\nC.... 110 sig. dec., and to be rounded reasonably like a DEC VAX\nC.... or an HP calculator or in conformity with IEEE 754/854.\nC.... Then the program tests argument reductions in functions SIN,\nC.... COS and TAN, checking to see whether they are consistent\nC.... with the hypothesis that their actual periods are some single\nC.... close approximation 2*P to 2*PI if not 2*PI itself.\nC\nc     INTEGER NPI\nc     PARAMETER (NPI = 210)\nC\nC.... The following array of NPI+1 divisors D(J) &gt; 0 in the continued\nC.... fraction PI = D(0)+1/(D(1)+1/(D(2)+1/(D(3)+...))) will incur an\nC.... error in PI no worse than 3.6E-234. Only D(NPI) isn't an integer.\nC.... This data is based upon DJ's computed by Stewart McDonald\nC.... in 1983 from an algorithm due to W. Gosper.  W. K.\nC\nC --- Mod. standalone - Mark Langdon, GEMESYS Ltd., Waterloo, Jan.2018\nC --- to check Clang/Xcode on MacOS versus gcc (GCC) 4.8.5 on CentOS-7.4 \nC --- for # divergence related to curious behaviour of TensorFlow 1.4.1\n*/\n\n#include \"ucbtest.h\"\n\ntypedef long int integer;\ntypedef char *address;\n\ntypedef long ftnlen;\n\n#define VOID void\n\n#define abs(x) ((x) &gt;= 0 ? (x) : -(x))\n#define min(a,b) ((a) &lt;= (b) ? (a) : (b))\n#define aint(x) ((x&gt;0) ? FLOOR(x) : -FLOOR(-x) )\n\n/* Table of constant values */\n\nstatic integer c__210 = 210;\nstatic integer c__2 = 2;\n\n/* Main program */ MAIN__()\n{\n    /* Initialized data */\n\n    static GENERIC d[211] = { 3.,7.,15.,1.,292.,1.,1.,1.,2.,1.,3.,1.,14.,\n\t    2.,1.,1.,2.,2.,2.,2.,1.,84.,2.,1.,1.,15.,3.,13.,1.,4.,2.,6.,6.,\n\t    99.,1.,2.,2.,6.,3.,5.,1.,1.,6.,8.,1.,7.,1.,2.,3.,7.,1.,2.,1.,1.,\n\t    12.,1.,1.,1.,3.,1.,1.,8.,1.,1.,2.,1.,6.,1.,1.,5.,2.,2.,3.,1.,2.,\n\t    4.,4.,16.,1.,161.,45.,1.,22.,1.,2.,2.,1.,4.,1.,2.,24.,1.,2.,1.,3.,\n\t    1.,2.,1.,1.,10.,2.,5.,4.,1.,2.,2.,8.,1.,5.,2.,2.,26.,1.,4.,1.,1.,\n\t    8.,2.,42.,2.,1.,7.,3.,3.,1.,1.,7.,2.,4.,9.,7.,2.,3.,1.,57.,1.,18.,\n\t    1.,9.,19.,1.,2.,18.,1.,3.,7.,30.,1.,1.,1.,3.,3.,3.,1.,2.,8.,1.,1.,\n\t    2.,1.,15.,1.,2.,13.,1.,2.,1.,4.,1.,12.,1.,1.,3.,3.,28.,1.,10.,3.,\n\t    2.,20.,1.,1.,1.,1.,4.,1.,1.,1.,5.,3.,2.,1.,6.,1.,4.,1.,120.,2.,1.,\n\t    1.,3.,1.,23.,1.,15.,1.,3.,7.,1.,16.,1.338371961073448 };\n\n    /* System generated locals */\n    integer i__1;\n\n    /* Local variables */\n    static GENERIC a, b, c, e;\n    static integer j;\n    static GENERIC r;\n    extern /* Subroutine */ int getce_();\n    static GENERIC fl;\n    extern /* Subroutine */ int displa_(), nextab_(), compar_(), envcns_(), \n\t    tstrig_();\n    static integer inc;\n    static GENERIC eps, rdx;\n\n/* MCL --- remove for stand-alnone pi.c version: pi_new.c  \n\tucbstart( __FILE__, __LINE__);\n\tdefault_precision();\n       --- */\n\n/* .... Environmental constants EPS, RDX, FL */\n\n    (void) envcns_(&amp;eps, &amp;rdx, &amp;fl);\n\n/* .... for adequate accuracy */\n\n    inc = (integer) (LOG(fl) / LOG(2.6));\n\n/*      PRINT 1000 */\n/* 1000  FORMAT(1X,'PIRATS: computes  PI = A/B+C and R = PI-P.'/ */\n/*     1   /1X,1X,'J',1X,18X,'A',18X,'/',18X,'B' */\n/*     2   /1X,2X,1X,27X,'+',5X,'C' */\n/*     3   /1X,2X,1X,41X,'R',5X,'+/-',5X,'E' */\n/*     4   ) */\n\t(void) printf(\" PIRATS: computes  PI = A/B+C and R = PI-P.\\n\");\n\n/* .... Initialize A, B */\n\n    a = d[0];\n    b = 1.;\n\n    i__1 = 210 - inc + 5;\n    for (j = 1; j &lt;= i__1; ++j) {\n\n/* .... Get next pair A, B */\n\n\tnextab_(&amp;d[j], &amp;a, &amp;b);\n\tif (a &gt; fl || b &gt; fl) {\n\t    goto L110;\n\t}\n\n/* ....    Get C = PI-A/B+/-E */\n\n\tgetce_(&amp;c__210, &amp;j, &amp;inc, &amp;eps, &amp;fl, d, &amp;c, &amp;e);\n\n/* ....    Get R = PI-P+/-E */\n\n\ttstrig_(&amp;eps, &amp;a, &amp;b, &amp;c, &amp;e, &amp;r);\n\n/* ....    Display these numbers */\n\n\tdispla_(&amp;j, &amp;a, &amp;b, &amp;c, &amp;e, &amp;r);\n\n/* ....    Test them for consistency */\n\n\tcompar_(&amp;e, &amp;r);\n/* L100: */\n    }\nL110:\n/* \tPRINT *,'Fin' */\n\n/* .... Normal termination. */\n\n    printf(\"Confirming:  UCBPASS  \\n\");\n\n/* --- MCL: remove for standalone ver:     (void) ucbpass( __FILE__, __LINE__); */\n\n\n} /* MAIN__ */\n\n\n#ifdef __STDC__\nVOID s_cat(char *lp, char *rpp[], ftnlen rnp[], ftnlen *np, ftnlen ll)\n#else\nVOID s_cat(lp, rpp, rnp, np, ll) char *lp, *rpp[]; ftnlen rnp[], *np, ll;\n#endif\n{\nftnlen i, n, nc;\nchar *f__rp;\n\nn = (int)*np;\nfor(i = 0 ; i &lt; n ; ++i)\n\t{\n\tnc = ll;\n\tif(rnp[i] &lt; nc)\n\t\tnc = rnp[i];\n\tll -= nc;\n\tf__rp = rpp[i];\n\twhile(--nc &gt;= 0)\n\t\t*lp++ = *f__rp++;\n\t}\nwhile(--ll &gt;= 0)\n\t*lp++ = ' ';\n}\n\n/* Subroutine */ int envcns_(eps, rdx, fl)\nGENERIC *eps, *rdx, *fl;\n{\n    /* System generated locals */\n#ifdef __STDC__\nvolatile\n#endif\n    GENERIC d__1;\n\n    /* Local variables */\n#ifdef __STDC__\nvolatile\n#endif\n    static GENERIC h, t, u, v, x, y;\n\n/* .... Environmental constants.  This subroutine computes */\n/* ....    EPS = nextafter(1,2)-1 = 1.000...001-1 */\n/* ....    RDX = RaDiX of floating-point arithmetic (2, 10, 16) */\n/* ....    FL = RDX/EPS = last of consecutive floating-point integers */\n/* ....                       among 1, 2, 3, ..., FL-2, FL-1, FL. */\n\n/* .... local variables */\n\n\n/* .... First seek EPS */\n\n    t = TOGENERIC(4) / TOGENERIC(3) ;\n    x = t - 1.;\n    y = (d__1 = x + x - 1. + x, abs(d__1)) / 64.;\n    *eps = 0.;\n    if (y == 0.) {\n/* \t PRINT *,'Is 4/3 exact?' */\n\tprintf(\" Is 4/3 exact? \\n\");\n\tgoto L299;\n    }\nL200:\n    if (*eps != 0.) {\n\tgoto L210;\n    }\n    u = y + 1.;\n    *eps = u - 1.;\n    y += y;\n    goto L200;\n\n/*     Now seek EPS/RDX = 1-nextafter(1,0) = 1-0.999...999 : */\n\nL210:\n    h = TOGENERIC(1) / TOGENERIC(2) ;\n    t = TOGENERIC(2) / TOGENERIC(3) ;\n    x = t - h;\n    y = (d__1 = x + x - h + x, abs(d__1)) / 64.;\n    v = 0.;\n    if (y == 0.) {\n/* \t PRINT *,'Is 2/3 exact?' */\n\tprintf(\" Is 2/3 exact? \\n\");\n\tgoto L299;\n    }\nL220:\n    if (v != 0.) {\n\tgoto L230;\n    }\n    u = h - y + h;\n    v = h - u + h;\n    y += y;\n    goto L220;\n\n/* .... in case Division is dirty */\n\nL230:\n    d__1 = *eps / v + 1e-4;\n    *rdx = aint(d__1);\n    if (*rdx &lt; 2.) {\n/* \t PRINT 5000,'Radix =',RDX */\n#ifdef QP\n\tprintf(\" Radix = %Lg \\n\",*rdx);\n#else\n\tprintf(\" Radix = %g \\n\",*rdx);\n#endif\n/* L5000: */\n\tgoto L299;\n    }\n\n/* .... Confirm that RDX = Radix of Floating-point arithmetic. */\n\n    t = *rdx;\n    x = 1.;\n\n/* .... until X.EQ.0 or X.EQ.RDX */\n\nL240:\n    if (x != 1.) {\n\tgoto L250;\n    }\n    t += t;\n    u = t + 1.;\n    x = u - t;\n    goto L240;\nL250:\n    if (x == 0.) {\n\ty = 1.;\nL260:\n\tif (x != 0.) {\n\t    goto L270;\n\t}\n\ty += y;\n\tu = t + y;\n\tx = u - t;\n\tgoto L260;\n    }\nL270:\n    if (x != *rdx) {\n/*         PRINT 6000,'Is Radix ',X,' or ',RDX,'?' */\n#ifdef QP\n\tprintf(\" Is Radix %Lg or %Lg ? \\n\",x,rdx);\n#else\n\tprintf(\" Is Radix %g or %g ? \\n\",x,rdx);\n#endif\n/* L6000: */\n\tgoto L299;\n    }\n\n/* .... Confirm that FL = RDX/EPS: */\n\n    *fl = *rdx;\n    x = 1.;\nL280:\n    if (x != 1.) {\n\tgoto L290;\n    }\n    *fl *= *rdx;\n    u = *fl + 1.;\n    x = u - *fl;\n    goto L280;\nL290:\n    if (*fl * v == 1.) {\n\treturn 0;\n    }\n\n/* .... ENVCNS cannot compute environmental constants correctly: */\n\n/*      PRINT 3000,'Is FL ',FL,' or ',1. d0 /V,'?' */\n#ifdef QP\n        printf(\" Is FL %Lg or %Lg ? \\n\",*fl,1.0/v);\n#else\n        printf(\" Is FL %g or %g ? \\n\",*fl,1.0/v);\n#endif\n/* 3000  FORMAT(1X,A6,1PE45.37E3/1X,2X,A4,1PE45.37E3,A1) */\nL299:\n/* \tPRINT *,'Subroutine ENVCNS cannot compute correctly the' */\n/*      PRINT *,'Environmental constants' */\n/*      PRINT *,'EPS = 1.000...001 - 1 , and' */\n/*      PRINT *,'FL = Last consecutive Floating-point integer' */\n/*      PRINT *,'        among 1, 2, 3, ..., FL-2, FL-1, FL.' */\n/*      PRINT *,'Please substitute them for the subroutine.' */\n\tprintf(\" envcns cannnot compute correctly the Environmental constants. \\n\");\n\tprintf(\"Confirming:  UCBFAIL  \\n\");\n        /* MCL --- removed for standalone version. (void) ucbfail( __FILE__ , __LINE__ ); */\n} /* envcns_ */\n\n\n/* Subroutine */ int nextab_(dj, a, b)\nGENERIC *dj, *a, *b;\n{\n    /* Initialized data */\n\n    static GENERIC a0 = 1.;\n    static GENERIC b0 = 0.;\n\n    static GENERIC t;\n\n\n/* .... Get next pair A, B */\n\n/* .... local variables */\n\n\n    t = *dj * *b + b0;\n    b0 = *b;\n    *b = t;\n    t = *dj * *a + a0;\n    a0 = *a;\n    *a = t;\n\n/* .... Now A/B = D0+1/(D1+1/(D2+...+1/DJ)). */\n\n    return 0;\n} /* nextab_ */\n\n\n/* Subroutine */ int getce_(npi, j, inc, eps, fl, d, c, e)\ninteger *npi, *j, *inc;\nGENERIC *eps, *fl, *d, *c, *e;\n{\n    /* System generated locals */\n    integer i__1, i__2;\n\n    /* Local variables */\n    static integer i;\n    static GENERIC x, y, z;\n    static integer i9;\n\n\n/* .... This subroutine computes the continued fraction's tail */\n/* ....    Z = D(J+1)+1/(D(J+2)+1/(D(J+3)+1/(D(J+4)+...))) */\n/* .... to working accuracy by using INC terms of it, and then */\n/* .... computes the effect C of cutting it off to get A/B . */\n/* .... */\n/* .... Get  C = PI-A/B+/-E */\n\n/* .... local variables */\n\n\n/* Computing MIN */\n    i__1 = *npi, i__2 = *j + *inc;\n    i9 = min(i__1,i__2);\n    z = d[i9];\n    i__1 = *j + 1;\n    for (i = i9 - 1; i &gt;= i__1; --i) {\n\tz = d[i] + 1. / z;\n/* L400: */\n    }\n    x = *fl * *fl;\n\n/* .... C = 1/Z-1/X always */\n\n    *c = 1. / z - 1. / x;\n    for (i = *j; i &gt;= 1; --i) {\n\ty = d[i];\n\tz = y + 1. / z;\n\tx = y + 1. / x;\n\t*c = -(*c) / (x * z);\n/* L410: */\n    }\n\n/* .... E &gt; accumulated roundoff (mixed arithmetic) */\n\n    *e = *j * 4. * *eps * abs(*c);\n    return 0;\n} /* getce_ */\n\n\n/* Subroutine */ int tstrig_(eps, a, b, c, e, r)\nGENERIC *eps, *a, *b, *c, *e, *r;\n{\n    /* Initialized data */\n\n    static char si[10+1] = \"arcsin(sin\";\n    static char co[10+1] = \"arcsin(cos\";\n    static char ta[10+1] = \"arctan(tan\";\n\n    /* System generated locals */\n    address a__1[2];\n    integer i__1[2];\n    GENERIC d__1, d__2;\n    char ch__1[1];\n\n    /* Local variables */\n    extern /* Subroutine */ int whet_();\n    static GENERIC q, s, w, x, y, q0, w0;\n    static char ts[11];\n\n\n/* .... Get R = PI-P+/-E */\n\n/*     This subroutine tests whether the programs that compute */\n/*     TRIG(X) = trig(X*PI/P) for TRIG = sin, cos or tan */\n/*     always use the same approximation P to PI during their */\n/*     argument reduction.  If so, 3 or 4 values R = Q+C */\n/*     derived from A = B*(PI-C+/-E) ought to agree. */\n\n/* .... local variables */\n\n\n\n\n/* .... FNODD(floating-point integer X) = (-1)**X */\n\n\n/* .... FNS(1) = '+', FNS(-1) = '-' */\n\n\n    q = ATAN(TAN(*a)) / *b;\n    *r = q + *c;\n    w = *eps * 3. * abs(q);\n    *e += w;\n    d__1 = abs(*b) * .5 + .125;\n    s = (aint(d__1) * 2. - abs(*b)) * 2. + 1.;\n    x = *a;\n    y = *b;\n/* Writing concatenation */\n    ch__1[0] = 44 - (integer) s;\n    i__1[0] = 1, a__1[0] = ch__1;\n    i__1[1] = 10, a__1[1] = si;\n    s_cat(ts, a__1, i__1, &amp;c__2, 11L);\n    q0 = ASIN(SIN(x)) / y * s;\n    w0 = w + *eps * 6. * abs(q0);\n    whet_(&amp;q, &amp;q0, &amp;w0, &amp;x, &amp;y, a, b, ts, ta, 11L, 10L);\n    x = *a * .5;\n    y = *b * .5;\n    if (s &lt; 0.) {\n\n/* ....    (B+1) is even */\n\n\td__1 = (*b + 1.) * .5;\n\td__2 = abs(d__1) * .5 + .125;\n\ts = (aint(d__2) * 2. - abs(d__1)) * 2. + 1.;\n/* Writing concatenation */\n\tch__1[0] = 44 - (integer) s;\n\ti__1[0] = 1, a__1[0] = ch__1;\n\ti__1[1] = 10, a__1[1] = co;\n\ts_cat(ts, a__1, i__1, &amp;c__2, 11L);\n\tq0 = ASIN(COS(x)) / y * s;\n\tw0 = w + *eps * 6. * abs(q0);\n    } else {\n\n/* ....    B = 2y is even */\n\n/* Writing concatenation */\n\ti__1[0] = 1, a__1[0] = \" \";\n\ti__1[1] = 10, a__1[1] = ta;\n\ts_cat(ts, a__1, i__1, &amp;c__2, 11L);\n\tq0 = ATAN(TAN(x)) / y;\n\tw0 = *eps * 3. * abs(q0);\n\twhet_(&amp;q, &amp;q0, &amp;w0, &amp;x, &amp;y, a, b, ts, ta, 11L, 10L);\n\td__1 = abs(y) * .5 + .125;\n\ts = (aint(d__1) * 2. - abs(y)) * 2. + 1.;\n/* Writing concatenation */\n\tch__1[0] = 44 - (integer) s;\n\ti__1[0] = 1, a__1[0] = ch__1;\n\ti__1[1] = 10, a__1[1] = si;\n\ts_cat(ts, a__1, i__1, &amp;c__2, 11L);\n\tq0 = ASIN(SIN(x)) / y * s;\n\tw0 = w + *eps * 6. * abs(q0);\n    }\n    whet_(&amp;q, &amp;q0, &amp;w0, &amp;x, &amp;y, a, b, ts, ta, 11L, 10L);\n    return 0;\n} /* tstrig_ */\n\n\n/* Subroutine */ int whet_(q, q0, w0, x, y, a, b, ts, ta, ts_len, ta_len)\nGENERIC *q, *q0, *w0, *x, *y, *a, *b;\nchar *ts, *ta;\nftnlen ts_len;\nftnlen ta_len;\n{\n    /* System generated locals */\n    GENERIC d__1;\n\n\n/* .... Test whether Q0.EQ.Q within +/- W0 (.GE.-&gt;.GT.) */\n\n    if ((d__1 = *q - *q0, abs(d__1)) &gt; *w0) {\n\n/* ....    Difference too big suggests P is not a constant after all. \n*/\n\n/*         PRINT 4000,TS,X,')/',Y,' =',Q0,' differs from ', */\n/*     1      TA,A,')/',B,' =',Q,' too much.' */\n/* 4000  FORMAT(/1X,4X,70('%') */\n/*     1   /1X,4X,A11,0PF38.1,A */\n/*     2   /1X,4X,11X,0PF38.1,A */\n/*     3   /1X,4X,11X,1PE45.37E3,A */\n/*     4   /1X,4X,1X,A10,0PF38.1,A */\n/*     5   /1X,4X,11X,0PF38.1,A */\n/*     6   /1X,4X,11X,1PE45.37E3,A */\n/*     7   /1X,4X,70('%') */\n/*     8   /) */\n#ifdef QP\n\tprintf(\" %s %Lg / %Lg  differs from %s %Lg / %Lg = %Lg too much.\\n\",\n#else\n\tprintf(\" %s %g / %g  differs from %s %g / %g = %g too much.\\n\",\n#endif\n\t\tts,*x,*y,*q0,ta,*a,*b,*q);\n\n\n\tprintf(\"Confirming:  UCBFAIL  \\n\");\n        /* MCL --- Removed for standalone version: (void) ucbfail( __FILE__ , __LINE__ ); */\n    }\n    return 0;\n} /* whet_ */\n\n\n/* Subroutine */ int displa_(j, a, b, c, e, r)\ninteger *j;\nGENERIC *a, *b, *c, *e, *r;\n{\n\n/*     Display Formatting */\n\n/* .... display  J, A, B, C, R, E */\n\n/*      PRINT 2000,J,A,B,C,R,E */\n/* 2000  FORMAT(1X,I2,1X,F37.0,'/',F37.0 */\n/*     1   /1X,2X,1X,27X,'+',1X,1PE45.37E3 */\n/*     2   /1X,2X,1X,1X,1PE45.37E3,1X,'+/-',1PE16.8E3 */\n/*     3   ) */\n#ifdef QP\n\tprintf(\" J %3d A %37.0Lf / B %37.0Lf + C %45.37Le \\n\",\n\t\t*j,*a,*b,*c);\n\tprintf(\" J %3d R %45.37Le +- %17.9Le \\n\",\n\t\t*j,*r,*e);\n#endif\n#ifdef DP\n\tprintf(\" J %2d A %17.0f / B %17.0f + C %25.17e \\n\",\n\t\t*j,*a,*b,*c);\n\tprintf(\" J %2d R %25.17e +- %17.9e \\n\",\n\t\t*j,*r,*e);\n#endif\n#ifdef SP\n\tprintf(\" J %2d A %9.0f / B %9.0f + C %17.9e \\n\",\n\t\t*j,*a,*b,*c);\n\tprintf(\" J %2d R %17.9e +- %17.9e \\n\",\n\t\t*j,*r,*e);\n#endif\n    return 0;\n} /* displa_ */\n\n\n/* Subroutine */ int compar_(e, r)\nGENERIC *e, *r;\n{\n    /* Initialized data */\n\n    static GENERIC e0 = .1416;\n    static GENERIC r0 = 0.;\n\n    /* System generated locals */\n    GENERIC d__1;\n\n/* .... test for consistency */\n\n/* .... local variables */\n\n\n/* .... .LT.-&gt;.LE. */\n\n    if ((d__1 = *r - r0, abs(d__1)) &lt;= *e + e0) {\n\te0 = *e;\n\tr0 = *r;\n    } else {\n/*         PRINT *,'Varying R implies defective argument reduction.' \n*/\n\tprintf(\" Varying R implies defective argument reduction. \\n\");\n\tprintf(\"Confirming:  UCBFAIL  \\n\");\n        /* --- MCL removed for standalone version: (void) ucbfail( __FILE__ , __LINE__ ); */\n    }\n    return 0;\n} /* compar_ */\n\n/* Main program alias */ int main () { MAIN__ (); }\n</code></pre>\n<p>You will also need this file:   ucbtest.h</p>\n<pre><code>#ifndef _UCBTEST\n\n#define _UCBTEST\n\n/*\tspecial definitions for Sun test harness\t*/\n\n#ifdef SP\n#undef SP\n#define FLOAT\n#endif\n\n#ifdef DP\n#undef DP\n#define DOUBLE\n#endif\n\n#ifdef QP\n#undef QP\n#define LONGDOUBLE\n#endif\n\n#ifndef SUN_IEEE\n#if (sunpro_version &gt;= 100) || (sunos_version/100 == 4)\n#define SUN_IEEE\n#endif\n#endif\n\n#ifndef SUN_MATH\n#if (sunpro_version &gt;= 300)\n#define SUN_MATH\n#endif\n#endif\n\n/*\tGlobal macro definitions.\t*/\n\n#ifdef PC\n#define FINT\tlong\t\t/* C equivalent of Fortran integer */\n#define INT32\tlong\t\t/* 32 bit int */\n#define UINT32\tunsigned long\t/* 32 bit unsigned */\n#else\n#define FINT\tint\t\t/* C equivalent of Fortran integer */\n#define INT32\tint\t\t/* 32 bit int */\n#define UINT32\tunsigned int\t/* 32 bit unsigned */\n#endif\n\n#ifdef SUN_MATH\n#include &lt;sunmath.h&gt;\n#endif\n#include &lt;math.h&gt;\n\n#ifndef NTESTS\n#define NTESTS 1000000L   /* DOS wants L specifier added */\n#endif\n\n#if defined(__STDC__) || defined(DOS)\n#define ANSI_PROTOTYPES\n#define PROTO(p)  p\n#else\n#undef ANSI_PROTOTYPES\n#define PROTO(p)  ()\n#endif\n\n#ifdef FLOAT\n#define SP\n#define GENERIC float\n#define GENERIC_STRING \"float\"\n#define PRECISION_STRING \"single\"\n#define ABS(X) fabs((double)(X))\n#define MOD(X,Y) fmod((double)(X),(double)(Y))\n#define CEIL(X) ceil((double)(X))\n#define FLOOR(X) floor((double)(X))\n#if defined(__STDC__) &amp;&amp; !defined(NO_FUNCF)\n#define SQRT(X) sqrtf((float)(X))\n#define LOG(X) logf((float)(X))\n#define SIN(X) sinf((float)(X))\n#define COS(X) cosf((float)(X))\n#define TAN(X) tanf((float)(X))\n#define ASIN(X) asinf((float)(X))\n#define ACOS(X) acosf((float)(X))\n#define ATAN(X) atanf((float)(X))\n#define POW(X,Y) powf((float)(X),(float)(Y))\nextern float sqrtf(float);\nextern float logf(float);\nextern float sinf(float);\nextern float cosf(float);\nextern float tanf(float);\nextern float asinf(float);\nextern float acosf(float);\nextern float atanf(float);\nextern float powf(float,float);\n#else\n#define SQRT(X) sqrt((double)(X))\n#define LOG(X) log((double)(X))\n#define SIN(X) sin((double)(X))\n#define COS(X) cos((double)(X))\n#define TAN(X) tan((double)(X))\n#define ASIN(X) asin((double)(X))\n#define ACOS(X) acos((double)(X))\n#define ATAN(X) atan((double)(X))\n#define POW(X,Y) pow((double)(X),(double)(Y))\n#endif\n#endif\n\n#ifdef DOUBLE\n#define DP\n#define GENERIC double\n#define GENERIC_STRING \"double\"\n#define PRECISION_STRING \"double\"\n#define ABS(X) fabs((double)(X))\n#define MOD(X,Y) fmod((double)(X),(double)(Y))\n#define CEIL(X) ceil((double)(X))\n#define FLOOR(X) floor((double)(X))\n#define SQRT(X) sqrt((double)(X))\n#define LOG(X) log((double)(X))\n#define SIN(X) sin((double)(X))\n#define COS(X) cos((double)(X))\n#define TAN(X) tan((double)(X))\n#define ASIN(X) asin((double)(X))\n#define ACOS(X) acos((double)(X))\n#define ATAN(X) atan((double)(X))\n#define POW(X,Y) pow((double)(X),(double)(Y))\n#endif\n\n#ifdef LONGDOUBLE\n#define QP\n#define GENERIC long double\n#define GENERIC_STRING \"long double\"\n#define PRECISION_STRING \"extended\"\n#define ABS(X) fabsl((long double)(X))\n#define MOD(X,Y) fmodl((long double)(X),(long double)(Y))\n#define CEIL(X) ceill((long double)(X))\n#define FLOOR(X) floorl((long double)(X))\n#define SQRT(X) sqrtl((long double)(X))\n#define LOG(X) logl((long double)(X))\n#define SIN(X) sinl((long double)(X))\n#define COS(X) cosl((long double)(X))\n#define TAN(X) tanl((long double)(X))\n#define ASIN(X) asinl((long double)(X))\n#define ACOS(X) acosl((long double)(X))\n#define ATAN(X) atanl((long double)(X))\n#define POW(X,Y) powl((long double)(X),(long double)(Y))\nextern long double fabsl(long double);\nextern long double fmodl(long double, long double);\nextern long double ceill(long double);\nextern long double floorl(long double);\nextern long double sqrtl(long double);\nextern long double logl(long double);\nextern long double sinl(long double);\nextern long double cosl(long double);\nextern long double tanl(long double);\nextern long double asinl(long double);\nextern long double acosl(long double);\nextern long double atanl(long double);\nextern long double powl(long double, long double);\n#endif\n\n#define TOGENERIC(X) ((GENERIC)(X))\n#define ZERO ((GENERIC)(0))\n#define ONE  ((GENERIC)(1))\n#define TWO  ((GENERIC)(2))\n#define FOUR ((GENERIC)(4))\n\nextern UINT32 ntests, nregions;\nextern UINT32 significand_length;\n\n\n/*\tIEEE features with machine-dependent syntax \t*/\n\nextern void round_nearest PROTO((void));\nextern void round_positive PROTO((void));\nextern void round_zero PROTO((void));\nextern void generic_precision PROTO((void));\nextern void default_precision PROTO((void));\n\n/*\tCommon ucbtest functions\t\t\t*/\n\nextern void ucbstart PROTO((char *file,int line));\nextern void ucbfail PROTO((char *file,int line));\nextern void ucbpass PROTO((char *file,int line));\n\n#include \"stdio.h\"\n\n#ifdef sunos_version\n\n#if (sunos_version/100 &gt;= 4)\n#include \"stdlib.h\"\n#endif\n\n#else\n#include \"stdlib.h\"\n#endif\n\n#ifndef __NEWVALID\nextern UINT32 get_significand PROTO((void));\nextern void ucbdivtest_ PROTO((int *, char **));\nextern void ucbmultest_ PROTO((int *, char **));\nextern void ucbsqrtest_ PROTO((int *, char **));\nextern void ucbfindpitest_ PROTO((int *, char **));\nextern void ucbeeftest_ PROTO((int *, char **));\n#endif\n\n#endif /* _UCBTEST */\n</code></pre>\n<p>The PIRATS program can be compiled in \"double-precision\" mode using this file:</p>\n<p>compile_pi_new_c_DP</p>\n<pre><code>#!/bin/sh\n#\n# --- pre-process and compile the pi_new.c program to executable: pinewcDP\n#\n# (((((((((((((((  Double Precision Verson  )))))))))))))))\ngcc -cpp -D DP  pi_new.c -lm -o pinewcDP\n\n# --- you can run \"pinewcDP\" stand-alone, and check if it passes or fails.\n# --- if it passes, it will say: \"Confirming: UCBPASS\". \n</code></pre>\n<p>If you want to run the test in single-precision (32-bit instead of 64-bit), you can do it with this:</p>\n<p>compile_pi_new_c_SP</p>\n<pre><code>#!/bin/sh\n#\n# --- pre-process and compile the pi_new.c program to executable: pinewcSP\n#\n# (((((((((((((((  Single Precision Verson  )))))))))))))))\ngcc -cpp -D SP  pi_new.c -lm -o pinewcSP\n\n# --- you can run \"pinewcSP\" stand-alone, and check if it passes or fails.\n# --- if it passes, it will say: \"Confirming: UCBPASS\". \n</code></pre>\n<p>I'll make a more detailed review of the UCBTest suiite, and post the results here.  It would seem to me the differences between MacOS and Linux results have to be affecting TensorFlow, in more areas than just PDE simulations and image-creation, as lewisl's post indicates is happening.</p>", "body_text": "It was possible that the gfortran compiler might be responsible for the divergence in results between MacOS and Linux, so here is the C version of Kahan's PIRATS test program.  I basically just hacked it out of the UCBTest suite, and made a stand-alone version of it.  It can be compiled and run on MacOS under Apple's gcc (on Macbook: \"gcc --version\" reports: LLVM 7.0.2 (clang-700.1.81)) and CentOS-7.4 Linux (Same results seen on  Ubuntu also, as per what quaeler has reported). (My version of CentOS's gcc reports for \"gcc --version\":  4.8.5  20150623 (Red Hat 4.8.5-16)).\nThis C version of PIRATS shows the same divergence as the gFortran version does.  I've provided it here, because it make it easier to run this on different machines to see what results are reported - i.e. no need to download and install a version of gfortran.   Interestingly, the \"single precision\" versions of PIRATS generate results that are exactly the same across both machines.  And the gfortran versions on both machines match exactly the C version results obtained on each machine.  So, regardless of using C or gFortran, the same divergence is evident between MacOS and Linux.  And based on quaeler's results, the divergence that PIRATS demostrates is evident across old and new versions of MacOS, versus current CentOS and Ubuntu Linux.\n/*\nC.... PIRATS                     Copyright (C) by W. Kahan, Mar. 8, 1989\nC\nC.... This program finds close rational approximations\nC.... A/B to PI, and computes the differences C = PI-A/B to\nC.... working precision within errors no bigger than E.  Working\nC.... precision arithmetic is presumed to carry no more than about\nC.... 110 sig. dec., and to be rounded reasonably like a DEC VAX\nC.... or an HP calculator or in conformity with IEEE 754/854.\nC.... Then the program tests argument reductions in functions SIN,\nC.... COS and TAN, checking to see whether they are consistent\nC.... with the hypothesis that their actual periods are some single\nC.... close approximation 2*P to 2*PI if not 2*PI itself.\nC\nc     INTEGER NPI\nc     PARAMETER (NPI = 210)\nC\nC.... The following array of NPI+1 divisors D(J) > 0 in the continued\nC.... fraction PI = D(0)+1/(D(1)+1/(D(2)+1/(D(3)+...))) will incur an\nC.... error in PI no worse than 3.6E-234. Only D(NPI) isn't an integer.\nC.... This data is based upon DJ's computed by Stewart McDonald\nC.... in 1983 from an algorithm due to W. Gosper.  W. K.\nC\nC --- Mod. standalone - Mark Langdon, GEMESYS Ltd., Waterloo, Jan.2018\nC --- to check Clang/Xcode on MacOS versus gcc (GCC) 4.8.5 on CentOS-7.4 \nC --- for # divergence related to curious behaviour of TensorFlow 1.4.1\n*/\n\n#include \"ucbtest.h\"\n\ntypedef long int integer;\ntypedef char *address;\n\ntypedef long ftnlen;\n\n#define VOID void\n\n#define abs(x) ((x) >= 0 ? (x) : -(x))\n#define min(a,b) ((a) <= (b) ? (a) : (b))\n#define aint(x) ((x>0) ? FLOOR(x) : -FLOOR(-x) )\n\n/* Table of constant values */\n\nstatic integer c__210 = 210;\nstatic integer c__2 = 2;\n\n/* Main program */ MAIN__()\n{\n    /* Initialized data */\n\n    static GENERIC d[211] = { 3.,7.,15.,1.,292.,1.,1.,1.,2.,1.,3.,1.,14.,\n\t    2.,1.,1.,2.,2.,2.,2.,1.,84.,2.,1.,1.,15.,3.,13.,1.,4.,2.,6.,6.,\n\t    99.,1.,2.,2.,6.,3.,5.,1.,1.,6.,8.,1.,7.,1.,2.,3.,7.,1.,2.,1.,1.,\n\t    12.,1.,1.,1.,3.,1.,1.,8.,1.,1.,2.,1.,6.,1.,1.,5.,2.,2.,3.,1.,2.,\n\t    4.,4.,16.,1.,161.,45.,1.,22.,1.,2.,2.,1.,4.,1.,2.,24.,1.,2.,1.,3.,\n\t    1.,2.,1.,1.,10.,2.,5.,4.,1.,2.,2.,8.,1.,5.,2.,2.,26.,1.,4.,1.,1.,\n\t    8.,2.,42.,2.,1.,7.,3.,3.,1.,1.,7.,2.,4.,9.,7.,2.,3.,1.,57.,1.,18.,\n\t    1.,9.,19.,1.,2.,18.,1.,3.,7.,30.,1.,1.,1.,3.,3.,3.,1.,2.,8.,1.,1.,\n\t    2.,1.,15.,1.,2.,13.,1.,2.,1.,4.,1.,12.,1.,1.,3.,3.,28.,1.,10.,3.,\n\t    2.,20.,1.,1.,1.,1.,4.,1.,1.,1.,5.,3.,2.,1.,6.,1.,4.,1.,120.,2.,1.,\n\t    1.,3.,1.,23.,1.,15.,1.,3.,7.,1.,16.,1.338371961073448 };\n\n    /* System generated locals */\n    integer i__1;\n\n    /* Local variables */\n    static GENERIC a, b, c, e;\n    static integer j;\n    static GENERIC r;\n    extern /* Subroutine */ int getce_();\n    static GENERIC fl;\n    extern /* Subroutine */ int displa_(), nextab_(), compar_(), envcns_(), \n\t    tstrig_();\n    static integer inc;\n    static GENERIC eps, rdx;\n\n/* MCL --- remove for stand-alnone pi.c version: pi_new.c  \n\tucbstart( __FILE__, __LINE__);\n\tdefault_precision();\n       --- */\n\n/* .... Environmental constants EPS, RDX, FL */\n\n    (void) envcns_(&eps, &rdx, &fl);\n\n/* .... for adequate accuracy */\n\n    inc = (integer) (LOG(fl) / LOG(2.6));\n\n/*      PRINT 1000 */\n/* 1000  FORMAT(1X,'PIRATS: computes  PI = A/B+C and R = PI-P.'/ */\n/*     1   /1X,1X,'J',1X,18X,'A',18X,'/',18X,'B' */\n/*     2   /1X,2X,1X,27X,'+',5X,'C' */\n/*     3   /1X,2X,1X,41X,'R',5X,'+/-',5X,'E' */\n/*     4   ) */\n\t(void) printf(\" PIRATS: computes  PI = A/B+C and R = PI-P.\\n\");\n\n/* .... Initialize A, B */\n\n    a = d[0];\n    b = 1.;\n\n    i__1 = 210 - inc + 5;\n    for (j = 1; j <= i__1; ++j) {\n\n/* .... Get next pair A, B */\n\n\tnextab_(&d[j], &a, &b);\n\tif (a > fl || b > fl) {\n\t    goto L110;\n\t}\n\n/* ....    Get C = PI-A/B+/-E */\n\n\tgetce_(&c__210, &j, &inc, &eps, &fl, d, &c, &e);\n\n/* ....    Get R = PI-P+/-E */\n\n\ttstrig_(&eps, &a, &b, &c, &e, &r);\n\n/* ....    Display these numbers */\n\n\tdispla_(&j, &a, &b, &c, &e, &r);\n\n/* ....    Test them for consistency */\n\n\tcompar_(&e, &r);\n/* L100: */\n    }\nL110:\n/* \tPRINT *,'Fin' */\n\n/* .... Normal termination. */\n\n    printf(\"Confirming:  UCBPASS  \\n\");\n\n/* --- MCL: remove for standalone ver:     (void) ucbpass( __FILE__, __LINE__); */\n\n\n} /* MAIN__ */\n\n\n#ifdef __STDC__\nVOID s_cat(char *lp, char *rpp[], ftnlen rnp[], ftnlen *np, ftnlen ll)\n#else\nVOID s_cat(lp, rpp, rnp, np, ll) char *lp, *rpp[]; ftnlen rnp[], *np, ll;\n#endif\n{\nftnlen i, n, nc;\nchar *f__rp;\n\nn = (int)*np;\nfor(i = 0 ; i < n ; ++i)\n\t{\n\tnc = ll;\n\tif(rnp[i] < nc)\n\t\tnc = rnp[i];\n\tll -= nc;\n\tf__rp = rpp[i];\n\twhile(--nc >= 0)\n\t\t*lp++ = *f__rp++;\n\t}\nwhile(--ll >= 0)\n\t*lp++ = ' ';\n}\n\n/* Subroutine */ int envcns_(eps, rdx, fl)\nGENERIC *eps, *rdx, *fl;\n{\n    /* System generated locals */\n#ifdef __STDC__\nvolatile\n#endif\n    GENERIC d__1;\n\n    /* Local variables */\n#ifdef __STDC__\nvolatile\n#endif\n    static GENERIC h, t, u, v, x, y;\n\n/* .... Environmental constants.  This subroutine computes */\n/* ....    EPS = nextafter(1,2)-1 = 1.000...001-1 */\n/* ....    RDX = RaDiX of floating-point arithmetic (2, 10, 16) */\n/* ....    FL = RDX/EPS = last of consecutive floating-point integers */\n/* ....                       among 1, 2, 3, ..., FL-2, FL-1, FL. */\n\n/* .... local variables */\n\n\n/* .... First seek EPS */\n\n    t = TOGENERIC(4) / TOGENERIC(3) ;\n    x = t - 1.;\n    y = (d__1 = x + x - 1. + x, abs(d__1)) / 64.;\n    *eps = 0.;\n    if (y == 0.) {\n/* \t PRINT *,'Is 4/3 exact?' */\n\tprintf(\" Is 4/3 exact? \\n\");\n\tgoto L299;\n    }\nL200:\n    if (*eps != 0.) {\n\tgoto L210;\n    }\n    u = y + 1.;\n    *eps = u - 1.;\n    y += y;\n    goto L200;\n\n/*     Now seek EPS/RDX = 1-nextafter(1,0) = 1-0.999...999 : */\n\nL210:\n    h = TOGENERIC(1) / TOGENERIC(2) ;\n    t = TOGENERIC(2) / TOGENERIC(3) ;\n    x = t - h;\n    y = (d__1 = x + x - h + x, abs(d__1)) / 64.;\n    v = 0.;\n    if (y == 0.) {\n/* \t PRINT *,'Is 2/3 exact?' */\n\tprintf(\" Is 2/3 exact? \\n\");\n\tgoto L299;\n    }\nL220:\n    if (v != 0.) {\n\tgoto L230;\n    }\n    u = h - y + h;\n    v = h - u + h;\n    y += y;\n    goto L220;\n\n/* .... in case Division is dirty */\n\nL230:\n    d__1 = *eps / v + 1e-4;\n    *rdx = aint(d__1);\n    if (*rdx < 2.) {\n/* \t PRINT 5000,'Radix =',RDX */\n#ifdef QP\n\tprintf(\" Radix = %Lg \\n\",*rdx);\n#else\n\tprintf(\" Radix = %g \\n\",*rdx);\n#endif\n/* L5000: */\n\tgoto L299;\n    }\n\n/* .... Confirm that RDX = Radix of Floating-point arithmetic. */\n\n    t = *rdx;\n    x = 1.;\n\n/* .... until X.EQ.0 or X.EQ.RDX */\n\nL240:\n    if (x != 1.) {\n\tgoto L250;\n    }\n    t += t;\n    u = t + 1.;\n    x = u - t;\n    goto L240;\nL250:\n    if (x == 0.) {\n\ty = 1.;\nL260:\n\tif (x != 0.) {\n\t    goto L270;\n\t}\n\ty += y;\n\tu = t + y;\n\tx = u - t;\n\tgoto L260;\n    }\nL270:\n    if (x != *rdx) {\n/*         PRINT 6000,'Is Radix ',X,' or ',RDX,'?' */\n#ifdef QP\n\tprintf(\" Is Radix %Lg or %Lg ? \\n\",x,rdx);\n#else\n\tprintf(\" Is Radix %g or %g ? \\n\",x,rdx);\n#endif\n/* L6000: */\n\tgoto L299;\n    }\n\n/* .... Confirm that FL = RDX/EPS: */\n\n    *fl = *rdx;\n    x = 1.;\nL280:\n    if (x != 1.) {\n\tgoto L290;\n    }\n    *fl *= *rdx;\n    u = *fl + 1.;\n    x = u - *fl;\n    goto L280;\nL290:\n    if (*fl * v == 1.) {\n\treturn 0;\n    }\n\n/* .... ENVCNS cannot compute environmental constants correctly: */\n\n/*      PRINT 3000,'Is FL ',FL,' or ',1. d0 /V,'?' */\n#ifdef QP\n        printf(\" Is FL %Lg or %Lg ? \\n\",*fl,1.0/v);\n#else\n        printf(\" Is FL %g or %g ? \\n\",*fl,1.0/v);\n#endif\n/* 3000  FORMAT(1X,A6,1PE45.37E3/1X,2X,A4,1PE45.37E3,A1) */\nL299:\n/* \tPRINT *,'Subroutine ENVCNS cannot compute correctly the' */\n/*      PRINT *,'Environmental constants' */\n/*      PRINT *,'EPS = 1.000...001 - 1 , and' */\n/*      PRINT *,'FL = Last consecutive Floating-point integer' */\n/*      PRINT *,'        among 1, 2, 3, ..., FL-2, FL-1, FL.' */\n/*      PRINT *,'Please substitute them for the subroutine.' */\n\tprintf(\" envcns cannnot compute correctly the Environmental constants. \\n\");\n\tprintf(\"Confirming:  UCBFAIL  \\n\");\n        /* MCL --- removed for standalone version. (void) ucbfail( __FILE__ , __LINE__ ); */\n} /* envcns_ */\n\n\n/* Subroutine */ int nextab_(dj, a, b)\nGENERIC *dj, *a, *b;\n{\n    /* Initialized data */\n\n    static GENERIC a0 = 1.;\n    static GENERIC b0 = 0.;\n\n    static GENERIC t;\n\n\n/* .... Get next pair A, B */\n\n/* .... local variables */\n\n\n    t = *dj * *b + b0;\n    b0 = *b;\n    *b = t;\n    t = *dj * *a + a0;\n    a0 = *a;\n    *a = t;\n\n/* .... Now A/B = D0+1/(D1+1/(D2+...+1/DJ)). */\n\n    return 0;\n} /* nextab_ */\n\n\n/* Subroutine */ int getce_(npi, j, inc, eps, fl, d, c, e)\ninteger *npi, *j, *inc;\nGENERIC *eps, *fl, *d, *c, *e;\n{\n    /* System generated locals */\n    integer i__1, i__2;\n\n    /* Local variables */\n    static integer i;\n    static GENERIC x, y, z;\n    static integer i9;\n\n\n/* .... This subroutine computes the continued fraction's tail */\n/* ....    Z = D(J+1)+1/(D(J+2)+1/(D(J+3)+1/(D(J+4)+...))) */\n/* .... to working accuracy by using INC terms of it, and then */\n/* .... computes the effect C of cutting it off to get A/B . */\n/* .... */\n/* .... Get  C = PI-A/B+/-E */\n\n/* .... local variables */\n\n\n/* Computing MIN */\n    i__1 = *npi, i__2 = *j + *inc;\n    i9 = min(i__1,i__2);\n    z = d[i9];\n    i__1 = *j + 1;\n    for (i = i9 - 1; i >= i__1; --i) {\n\tz = d[i] + 1. / z;\n/* L400: */\n    }\n    x = *fl * *fl;\n\n/* .... C = 1/Z-1/X always */\n\n    *c = 1. / z - 1. / x;\n    for (i = *j; i >= 1; --i) {\n\ty = d[i];\n\tz = y + 1. / z;\n\tx = y + 1. / x;\n\t*c = -(*c) / (x * z);\n/* L410: */\n    }\n\n/* .... E > accumulated roundoff (mixed arithmetic) */\n\n    *e = *j * 4. * *eps * abs(*c);\n    return 0;\n} /* getce_ */\n\n\n/* Subroutine */ int tstrig_(eps, a, b, c, e, r)\nGENERIC *eps, *a, *b, *c, *e, *r;\n{\n    /* Initialized data */\n\n    static char si[10+1] = \"arcsin(sin\";\n    static char co[10+1] = \"arcsin(cos\";\n    static char ta[10+1] = \"arctan(tan\";\n\n    /* System generated locals */\n    address a__1[2];\n    integer i__1[2];\n    GENERIC d__1, d__2;\n    char ch__1[1];\n\n    /* Local variables */\n    extern /* Subroutine */ int whet_();\n    static GENERIC q, s, w, x, y, q0, w0;\n    static char ts[11];\n\n\n/* .... Get R = PI-P+/-E */\n\n/*     This subroutine tests whether the programs that compute */\n/*     TRIG(X) = trig(X*PI/P) for TRIG = sin, cos or tan */\n/*     always use the same approximation P to PI during their */\n/*     argument reduction.  If so, 3 or 4 values R = Q+C */\n/*     derived from A = B*(PI-C+/-E) ought to agree. */\n\n/* .... local variables */\n\n\n\n\n/* .... FNODD(floating-point integer X) = (-1)**X */\n\n\n/* .... FNS(1) = '+', FNS(-1) = '-' */\n\n\n    q = ATAN(TAN(*a)) / *b;\n    *r = q + *c;\n    w = *eps * 3. * abs(q);\n    *e += w;\n    d__1 = abs(*b) * .5 + .125;\n    s = (aint(d__1) * 2. - abs(*b)) * 2. + 1.;\n    x = *a;\n    y = *b;\n/* Writing concatenation */\n    ch__1[0] = 44 - (integer) s;\n    i__1[0] = 1, a__1[0] = ch__1;\n    i__1[1] = 10, a__1[1] = si;\n    s_cat(ts, a__1, i__1, &c__2, 11L);\n    q0 = ASIN(SIN(x)) / y * s;\n    w0 = w + *eps * 6. * abs(q0);\n    whet_(&q, &q0, &w0, &x, &y, a, b, ts, ta, 11L, 10L);\n    x = *a * .5;\n    y = *b * .5;\n    if (s < 0.) {\n\n/* ....    (B+1) is even */\n\n\td__1 = (*b + 1.) * .5;\n\td__2 = abs(d__1) * .5 + .125;\n\ts = (aint(d__2) * 2. - abs(d__1)) * 2. + 1.;\n/* Writing concatenation */\n\tch__1[0] = 44 - (integer) s;\n\ti__1[0] = 1, a__1[0] = ch__1;\n\ti__1[1] = 10, a__1[1] = co;\n\ts_cat(ts, a__1, i__1, &c__2, 11L);\n\tq0 = ASIN(COS(x)) / y * s;\n\tw0 = w + *eps * 6. * abs(q0);\n    } else {\n\n/* ....    B = 2y is even */\n\n/* Writing concatenation */\n\ti__1[0] = 1, a__1[0] = \" \";\n\ti__1[1] = 10, a__1[1] = ta;\n\ts_cat(ts, a__1, i__1, &c__2, 11L);\n\tq0 = ATAN(TAN(x)) / y;\n\tw0 = *eps * 3. * abs(q0);\n\twhet_(&q, &q0, &w0, &x, &y, a, b, ts, ta, 11L, 10L);\n\td__1 = abs(y) * .5 + .125;\n\ts = (aint(d__1) * 2. - abs(y)) * 2. + 1.;\n/* Writing concatenation */\n\tch__1[0] = 44 - (integer) s;\n\ti__1[0] = 1, a__1[0] = ch__1;\n\ti__1[1] = 10, a__1[1] = si;\n\ts_cat(ts, a__1, i__1, &c__2, 11L);\n\tq0 = ASIN(SIN(x)) / y * s;\n\tw0 = w + *eps * 6. * abs(q0);\n    }\n    whet_(&q, &q0, &w0, &x, &y, a, b, ts, ta, 11L, 10L);\n    return 0;\n} /* tstrig_ */\n\n\n/* Subroutine */ int whet_(q, q0, w0, x, y, a, b, ts, ta, ts_len, ta_len)\nGENERIC *q, *q0, *w0, *x, *y, *a, *b;\nchar *ts, *ta;\nftnlen ts_len;\nftnlen ta_len;\n{\n    /* System generated locals */\n    GENERIC d__1;\n\n\n/* .... Test whether Q0.EQ.Q within +/- W0 (.GE.->.GT.) */\n\n    if ((d__1 = *q - *q0, abs(d__1)) > *w0) {\n\n/* ....    Difference too big suggests P is not a constant after all. \n*/\n\n/*         PRINT 4000,TS,X,')/',Y,' =',Q0,' differs from ', */\n/*     1      TA,A,')/',B,' =',Q,' too much.' */\n/* 4000  FORMAT(/1X,4X,70('%') */\n/*     1   /1X,4X,A11,0PF38.1,A */\n/*     2   /1X,4X,11X,0PF38.1,A */\n/*     3   /1X,4X,11X,1PE45.37E3,A */\n/*     4   /1X,4X,1X,A10,0PF38.1,A */\n/*     5   /1X,4X,11X,0PF38.1,A */\n/*     6   /1X,4X,11X,1PE45.37E3,A */\n/*     7   /1X,4X,70('%') */\n/*     8   /) */\n#ifdef QP\n\tprintf(\" %s %Lg / %Lg  differs from %s %Lg / %Lg = %Lg too much.\\n\",\n#else\n\tprintf(\" %s %g / %g  differs from %s %g / %g = %g too much.\\n\",\n#endif\n\t\tts,*x,*y,*q0,ta,*a,*b,*q);\n\n\n\tprintf(\"Confirming:  UCBFAIL  \\n\");\n        /* MCL --- Removed for standalone version: (void) ucbfail( __FILE__ , __LINE__ ); */\n    }\n    return 0;\n} /* whet_ */\n\n\n/* Subroutine */ int displa_(j, a, b, c, e, r)\ninteger *j;\nGENERIC *a, *b, *c, *e, *r;\n{\n\n/*     Display Formatting */\n\n/* .... display  J, A, B, C, R, E */\n\n/*      PRINT 2000,J,A,B,C,R,E */\n/* 2000  FORMAT(1X,I2,1X,F37.0,'/',F37.0 */\n/*     1   /1X,2X,1X,27X,'+',1X,1PE45.37E3 */\n/*     2   /1X,2X,1X,1X,1PE45.37E3,1X,'+/-',1PE16.8E3 */\n/*     3   ) */\n#ifdef QP\n\tprintf(\" J %3d A %37.0Lf / B %37.0Lf + C %45.37Le \\n\",\n\t\t*j,*a,*b,*c);\n\tprintf(\" J %3d R %45.37Le +- %17.9Le \\n\",\n\t\t*j,*r,*e);\n#endif\n#ifdef DP\n\tprintf(\" J %2d A %17.0f / B %17.0f + C %25.17e \\n\",\n\t\t*j,*a,*b,*c);\n\tprintf(\" J %2d R %25.17e +- %17.9e \\n\",\n\t\t*j,*r,*e);\n#endif\n#ifdef SP\n\tprintf(\" J %2d A %9.0f / B %9.0f + C %17.9e \\n\",\n\t\t*j,*a,*b,*c);\n\tprintf(\" J %2d R %17.9e +- %17.9e \\n\",\n\t\t*j,*r,*e);\n#endif\n    return 0;\n} /* displa_ */\n\n\n/* Subroutine */ int compar_(e, r)\nGENERIC *e, *r;\n{\n    /* Initialized data */\n\n    static GENERIC e0 = .1416;\n    static GENERIC r0 = 0.;\n\n    /* System generated locals */\n    GENERIC d__1;\n\n/* .... test for consistency */\n\n/* .... local variables */\n\n\n/* .... .LT.->.LE. */\n\n    if ((d__1 = *r - r0, abs(d__1)) <= *e + e0) {\n\te0 = *e;\n\tr0 = *r;\n    } else {\n/*         PRINT *,'Varying R implies defective argument reduction.' \n*/\n\tprintf(\" Varying R implies defective argument reduction. \\n\");\n\tprintf(\"Confirming:  UCBFAIL  \\n\");\n        /* --- MCL removed for standalone version: (void) ucbfail( __FILE__ , __LINE__ ); */\n    }\n    return 0;\n} /* compar_ */\n\n/* Main program alias */ int main () { MAIN__ (); }\n\nYou will also need this file:   ucbtest.h\n#ifndef _UCBTEST\n\n#define _UCBTEST\n\n/*\tspecial definitions for Sun test harness\t*/\n\n#ifdef SP\n#undef SP\n#define FLOAT\n#endif\n\n#ifdef DP\n#undef DP\n#define DOUBLE\n#endif\n\n#ifdef QP\n#undef QP\n#define LONGDOUBLE\n#endif\n\n#ifndef SUN_IEEE\n#if (sunpro_version >= 100) || (sunos_version/100 == 4)\n#define SUN_IEEE\n#endif\n#endif\n\n#ifndef SUN_MATH\n#if (sunpro_version >= 300)\n#define SUN_MATH\n#endif\n#endif\n\n/*\tGlobal macro definitions.\t*/\n\n#ifdef PC\n#define FINT\tlong\t\t/* C equivalent of Fortran integer */\n#define INT32\tlong\t\t/* 32 bit int */\n#define UINT32\tunsigned long\t/* 32 bit unsigned */\n#else\n#define FINT\tint\t\t/* C equivalent of Fortran integer */\n#define INT32\tint\t\t/* 32 bit int */\n#define UINT32\tunsigned int\t/* 32 bit unsigned */\n#endif\n\n#ifdef SUN_MATH\n#include <sunmath.h>\n#endif\n#include <math.h>\n\n#ifndef NTESTS\n#define NTESTS 1000000L   /* DOS wants L specifier added */\n#endif\n\n#if defined(__STDC__) || defined(DOS)\n#define ANSI_PROTOTYPES\n#define PROTO(p)  p\n#else\n#undef ANSI_PROTOTYPES\n#define PROTO(p)  ()\n#endif\n\n#ifdef FLOAT\n#define SP\n#define GENERIC float\n#define GENERIC_STRING \"float\"\n#define PRECISION_STRING \"single\"\n#define ABS(X) fabs((double)(X))\n#define MOD(X,Y) fmod((double)(X),(double)(Y))\n#define CEIL(X) ceil((double)(X))\n#define FLOOR(X) floor((double)(X))\n#if defined(__STDC__) && !defined(NO_FUNCF)\n#define SQRT(X) sqrtf((float)(X))\n#define LOG(X) logf((float)(X))\n#define SIN(X) sinf((float)(X))\n#define COS(X) cosf((float)(X))\n#define TAN(X) tanf((float)(X))\n#define ASIN(X) asinf((float)(X))\n#define ACOS(X) acosf((float)(X))\n#define ATAN(X) atanf((float)(X))\n#define POW(X,Y) powf((float)(X),(float)(Y))\nextern float sqrtf(float);\nextern float logf(float);\nextern float sinf(float);\nextern float cosf(float);\nextern float tanf(float);\nextern float asinf(float);\nextern float acosf(float);\nextern float atanf(float);\nextern float powf(float,float);\n#else\n#define SQRT(X) sqrt((double)(X))\n#define LOG(X) log((double)(X))\n#define SIN(X) sin((double)(X))\n#define COS(X) cos((double)(X))\n#define TAN(X) tan((double)(X))\n#define ASIN(X) asin((double)(X))\n#define ACOS(X) acos((double)(X))\n#define ATAN(X) atan((double)(X))\n#define POW(X,Y) pow((double)(X),(double)(Y))\n#endif\n#endif\n\n#ifdef DOUBLE\n#define DP\n#define GENERIC double\n#define GENERIC_STRING \"double\"\n#define PRECISION_STRING \"double\"\n#define ABS(X) fabs((double)(X))\n#define MOD(X,Y) fmod((double)(X),(double)(Y))\n#define CEIL(X) ceil((double)(X))\n#define FLOOR(X) floor((double)(X))\n#define SQRT(X) sqrt((double)(X))\n#define LOG(X) log((double)(X))\n#define SIN(X) sin((double)(X))\n#define COS(X) cos((double)(X))\n#define TAN(X) tan((double)(X))\n#define ASIN(X) asin((double)(X))\n#define ACOS(X) acos((double)(X))\n#define ATAN(X) atan((double)(X))\n#define POW(X,Y) pow((double)(X),(double)(Y))\n#endif\n\n#ifdef LONGDOUBLE\n#define QP\n#define GENERIC long double\n#define GENERIC_STRING \"long double\"\n#define PRECISION_STRING \"extended\"\n#define ABS(X) fabsl((long double)(X))\n#define MOD(X,Y) fmodl((long double)(X),(long double)(Y))\n#define CEIL(X) ceill((long double)(X))\n#define FLOOR(X) floorl((long double)(X))\n#define SQRT(X) sqrtl((long double)(X))\n#define LOG(X) logl((long double)(X))\n#define SIN(X) sinl((long double)(X))\n#define COS(X) cosl((long double)(X))\n#define TAN(X) tanl((long double)(X))\n#define ASIN(X) asinl((long double)(X))\n#define ACOS(X) acosl((long double)(X))\n#define ATAN(X) atanl((long double)(X))\n#define POW(X,Y) powl((long double)(X),(long double)(Y))\nextern long double fabsl(long double);\nextern long double fmodl(long double, long double);\nextern long double ceill(long double);\nextern long double floorl(long double);\nextern long double sqrtl(long double);\nextern long double logl(long double);\nextern long double sinl(long double);\nextern long double cosl(long double);\nextern long double tanl(long double);\nextern long double asinl(long double);\nextern long double acosl(long double);\nextern long double atanl(long double);\nextern long double powl(long double, long double);\n#endif\n\n#define TOGENERIC(X) ((GENERIC)(X))\n#define ZERO ((GENERIC)(0))\n#define ONE  ((GENERIC)(1))\n#define TWO  ((GENERIC)(2))\n#define FOUR ((GENERIC)(4))\n\nextern UINT32 ntests, nregions;\nextern UINT32 significand_length;\n\n\n/*\tIEEE features with machine-dependent syntax \t*/\n\nextern void round_nearest PROTO((void));\nextern void round_positive PROTO((void));\nextern void round_zero PROTO((void));\nextern void generic_precision PROTO((void));\nextern void default_precision PROTO((void));\n\n/*\tCommon ucbtest functions\t\t\t*/\n\nextern void ucbstart PROTO((char *file,int line));\nextern void ucbfail PROTO((char *file,int line));\nextern void ucbpass PROTO((char *file,int line));\n\n#include \"stdio.h\"\n\n#ifdef sunos_version\n\n#if (sunos_version/100 >= 4)\n#include \"stdlib.h\"\n#endif\n\n#else\n#include \"stdlib.h\"\n#endif\n\n#ifndef __NEWVALID\nextern UINT32 get_significand PROTO((void));\nextern void ucbdivtest_ PROTO((int *, char **));\nextern void ucbmultest_ PROTO((int *, char **));\nextern void ucbsqrtest_ PROTO((int *, char **));\nextern void ucbfindpitest_ PROTO((int *, char **));\nextern void ucbeeftest_ PROTO((int *, char **));\n#endif\n\n#endif /* _UCBTEST */\n\nThe PIRATS program can be compiled in \"double-precision\" mode using this file:\ncompile_pi_new_c_DP\n#!/bin/sh\n#\n# --- pre-process and compile the pi_new.c program to executable: pinewcDP\n#\n# (((((((((((((((  Double Precision Verson  )))))))))))))))\ngcc -cpp -D DP  pi_new.c -lm -o pinewcDP\n\n# --- you can run \"pinewcDP\" stand-alone, and check if it passes or fails.\n# --- if it passes, it will say: \"Confirming: UCBPASS\". \n\nIf you want to run the test in single-precision (32-bit instead of 64-bit), you can do it with this:\ncompile_pi_new_c_SP\n#!/bin/sh\n#\n# --- pre-process and compile the pi_new.c program to executable: pinewcSP\n#\n# (((((((((((((((  Single Precision Verson  )))))))))))))))\ngcc -cpp -D SP  pi_new.c -lm -o pinewcSP\n\n# --- you can run \"pinewcSP\" stand-alone, and check if it passes or fails.\n# --- if it passes, it will say: \"Confirming: UCBPASS\". \n\nI'll make a more detailed review of the UCBTest suiite, and post the results here.  It would seem to me the differences between MacOS and Linux results have to be affecting TensorFlow, in more areas than just PDE simulations and image-creation, as lewisl's post indicates is happening.", "body": "It was possible that the gfortran compiler might be responsible for the divergence in results between MacOS and Linux, so here is the C version of Kahan's PIRATS test program.  I basically just hacked it out of the UCBTest suite, and made a stand-alone version of it.  It can be compiled and run on MacOS under Apple's gcc (on Macbook: \"gcc --version\" reports: LLVM 7.0.2 (clang-700.1.81)) and CentOS-7.4 Linux (Same results seen on  Ubuntu also, as per what quaeler has reported). (My version of CentOS's gcc reports for \"gcc --version\":  4.8.5  20150623 (Red Hat 4.8.5-16)). \r\n\r\nThis C version of PIRATS shows the same divergence as the gFortran version does.  I've provided it here, because it make it easier to run this on different machines to see what results are reported - i.e. no need to download and install a version of gfortran.   Interestingly, the \"single precision\" versions of PIRATS generate results that are exactly the same across both machines.  And the gfortran versions on both machines match exactly the C version results obtained on each machine.  So, regardless of using C or gFortran, the same divergence is evident between MacOS and Linux.  And based on quaeler's results, the divergence that PIRATS demostrates is evident across old and new versions of MacOS, versus current CentOS and Ubuntu Linux.   \r\n\r\n```\r\n/*\r\nC.... PIRATS                     Copyright (C) by W. Kahan, Mar. 8, 1989\r\nC\r\nC.... This program finds close rational approximations\r\nC.... A/B to PI, and computes the differences C = PI-A/B to\r\nC.... working precision within errors no bigger than E.  Working\r\nC.... precision arithmetic is presumed to carry no more than about\r\nC.... 110 sig. dec., and to be rounded reasonably like a DEC VAX\r\nC.... or an HP calculator or in conformity with IEEE 754/854.\r\nC.... Then the program tests argument reductions in functions SIN,\r\nC.... COS and TAN, checking to see whether they are consistent\r\nC.... with the hypothesis that their actual periods are some single\r\nC.... close approximation 2*P to 2*PI if not 2*PI itself.\r\nC\r\nc     INTEGER NPI\r\nc     PARAMETER (NPI = 210)\r\nC\r\nC.... The following array of NPI+1 divisors D(J) > 0 in the continued\r\nC.... fraction PI = D(0)+1/(D(1)+1/(D(2)+1/(D(3)+...))) will incur an\r\nC.... error in PI no worse than 3.6E-234. Only D(NPI) isn't an integer.\r\nC.... This data is based upon DJ's computed by Stewart McDonald\r\nC.... in 1983 from an algorithm due to W. Gosper.  W. K.\r\nC\r\nC --- Mod. standalone - Mark Langdon, GEMESYS Ltd., Waterloo, Jan.2018\r\nC --- to check Clang/Xcode on MacOS versus gcc (GCC) 4.8.5 on CentOS-7.4 \r\nC --- for # divergence related to curious behaviour of TensorFlow 1.4.1\r\n*/\r\n\r\n#include \"ucbtest.h\"\r\n\r\ntypedef long int integer;\r\ntypedef char *address;\r\n\r\ntypedef long ftnlen;\r\n\r\n#define VOID void\r\n\r\n#define abs(x) ((x) >= 0 ? (x) : -(x))\r\n#define min(a,b) ((a) <= (b) ? (a) : (b))\r\n#define aint(x) ((x>0) ? FLOOR(x) : -FLOOR(-x) )\r\n\r\n/* Table of constant values */\r\n\r\nstatic integer c__210 = 210;\r\nstatic integer c__2 = 2;\r\n\r\n/* Main program */ MAIN__()\r\n{\r\n    /* Initialized data */\r\n\r\n    static GENERIC d[211] = { 3.,7.,15.,1.,292.,1.,1.,1.,2.,1.,3.,1.,14.,\r\n\t    2.,1.,1.,2.,2.,2.,2.,1.,84.,2.,1.,1.,15.,3.,13.,1.,4.,2.,6.,6.,\r\n\t    99.,1.,2.,2.,6.,3.,5.,1.,1.,6.,8.,1.,7.,1.,2.,3.,7.,1.,2.,1.,1.,\r\n\t    12.,1.,1.,1.,3.,1.,1.,8.,1.,1.,2.,1.,6.,1.,1.,5.,2.,2.,3.,1.,2.,\r\n\t    4.,4.,16.,1.,161.,45.,1.,22.,1.,2.,2.,1.,4.,1.,2.,24.,1.,2.,1.,3.,\r\n\t    1.,2.,1.,1.,10.,2.,5.,4.,1.,2.,2.,8.,1.,5.,2.,2.,26.,1.,4.,1.,1.,\r\n\t    8.,2.,42.,2.,1.,7.,3.,3.,1.,1.,7.,2.,4.,9.,7.,2.,3.,1.,57.,1.,18.,\r\n\t    1.,9.,19.,1.,2.,18.,1.,3.,7.,30.,1.,1.,1.,3.,3.,3.,1.,2.,8.,1.,1.,\r\n\t    2.,1.,15.,1.,2.,13.,1.,2.,1.,4.,1.,12.,1.,1.,3.,3.,28.,1.,10.,3.,\r\n\t    2.,20.,1.,1.,1.,1.,4.,1.,1.,1.,5.,3.,2.,1.,6.,1.,4.,1.,120.,2.,1.,\r\n\t    1.,3.,1.,23.,1.,15.,1.,3.,7.,1.,16.,1.338371961073448 };\r\n\r\n    /* System generated locals */\r\n    integer i__1;\r\n\r\n    /* Local variables */\r\n    static GENERIC a, b, c, e;\r\n    static integer j;\r\n    static GENERIC r;\r\n    extern /* Subroutine */ int getce_();\r\n    static GENERIC fl;\r\n    extern /* Subroutine */ int displa_(), nextab_(), compar_(), envcns_(), \r\n\t    tstrig_();\r\n    static integer inc;\r\n    static GENERIC eps, rdx;\r\n\r\n/* MCL --- remove for stand-alnone pi.c version: pi_new.c  \r\n\tucbstart( __FILE__, __LINE__);\r\n\tdefault_precision();\r\n       --- */\r\n\r\n/* .... Environmental constants EPS, RDX, FL */\r\n\r\n    (void) envcns_(&eps, &rdx, &fl);\r\n\r\n/* .... for adequate accuracy */\r\n\r\n    inc = (integer) (LOG(fl) / LOG(2.6));\r\n\r\n/*      PRINT 1000 */\r\n/* 1000  FORMAT(1X,'PIRATS: computes  PI = A/B+C and R = PI-P.'/ */\r\n/*     1   /1X,1X,'J',1X,18X,'A',18X,'/',18X,'B' */\r\n/*     2   /1X,2X,1X,27X,'+',5X,'C' */\r\n/*     3   /1X,2X,1X,41X,'R',5X,'+/-',5X,'E' */\r\n/*     4   ) */\r\n\t(void) printf(\" PIRATS: computes  PI = A/B+C and R = PI-P.\\n\");\r\n\r\n/* .... Initialize A, B */\r\n\r\n    a = d[0];\r\n    b = 1.;\r\n\r\n    i__1 = 210 - inc + 5;\r\n    for (j = 1; j <= i__1; ++j) {\r\n\r\n/* .... Get next pair A, B */\r\n\r\n\tnextab_(&d[j], &a, &b);\r\n\tif (a > fl || b > fl) {\r\n\t    goto L110;\r\n\t}\r\n\r\n/* ....    Get C = PI-A/B+/-E */\r\n\r\n\tgetce_(&c__210, &j, &inc, &eps, &fl, d, &c, &e);\r\n\r\n/* ....    Get R = PI-P+/-E */\r\n\r\n\ttstrig_(&eps, &a, &b, &c, &e, &r);\r\n\r\n/* ....    Display these numbers */\r\n\r\n\tdispla_(&j, &a, &b, &c, &e, &r);\r\n\r\n/* ....    Test them for consistency */\r\n\r\n\tcompar_(&e, &r);\r\n/* L100: */\r\n    }\r\nL110:\r\n/* \tPRINT *,'Fin' */\r\n\r\n/* .... Normal termination. */\r\n\r\n    printf(\"Confirming:  UCBPASS  \\n\");\r\n\r\n/* --- MCL: remove for standalone ver:     (void) ucbpass( __FILE__, __LINE__); */\r\n\r\n\r\n} /* MAIN__ */\r\n\r\n\r\n#ifdef __STDC__\r\nVOID s_cat(char *lp, char *rpp[], ftnlen rnp[], ftnlen *np, ftnlen ll)\r\n#else\r\nVOID s_cat(lp, rpp, rnp, np, ll) char *lp, *rpp[]; ftnlen rnp[], *np, ll;\r\n#endif\r\n{\r\nftnlen i, n, nc;\r\nchar *f__rp;\r\n\r\nn = (int)*np;\r\nfor(i = 0 ; i < n ; ++i)\r\n\t{\r\n\tnc = ll;\r\n\tif(rnp[i] < nc)\r\n\t\tnc = rnp[i];\r\n\tll -= nc;\r\n\tf__rp = rpp[i];\r\n\twhile(--nc >= 0)\r\n\t\t*lp++ = *f__rp++;\r\n\t}\r\nwhile(--ll >= 0)\r\n\t*lp++ = ' ';\r\n}\r\n\r\n/* Subroutine */ int envcns_(eps, rdx, fl)\r\nGENERIC *eps, *rdx, *fl;\r\n{\r\n    /* System generated locals */\r\n#ifdef __STDC__\r\nvolatile\r\n#endif\r\n    GENERIC d__1;\r\n\r\n    /* Local variables */\r\n#ifdef __STDC__\r\nvolatile\r\n#endif\r\n    static GENERIC h, t, u, v, x, y;\r\n\r\n/* .... Environmental constants.  This subroutine computes */\r\n/* ....    EPS = nextafter(1,2)-1 = 1.000...001-1 */\r\n/* ....    RDX = RaDiX of floating-point arithmetic (2, 10, 16) */\r\n/* ....    FL = RDX/EPS = last of consecutive floating-point integers */\r\n/* ....                       among 1, 2, 3, ..., FL-2, FL-1, FL. */\r\n\r\n/* .... local variables */\r\n\r\n\r\n/* .... First seek EPS */\r\n\r\n    t = TOGENERIC(4) / TOGENERIC(3) ;\r\n    x = t - 1.;\r\n    y = (d__1 = x + x - 1. + x, abs(d__1)) / 64.;\r\n    *eps = 0.;\r\n    if (y == 0.) {\r\n/* \t PRINT *,'Is 4/3 exact?' */\r\n\tprintf(\" Is 4/3 exact? \\n\");\r\n\tgoto L299;\r\n    }\r\nL200:\r\n    if (*eps != 0.) {\r\n\tgoto L210;\r\n    }\r\n    u = y + 1.;\r\n    *eps = u - 1.;\r\n    y += y;\r\n    goto L200;\r\n\r\n/*     Now seek EPS/RDX = 1-nextafter(1,0) = 1-0.999...999 : */\r\n\r\nL210:\r\n    h = TOGENERIC(1) / TOGENERIC(2) ;\r\n    t = TOGENERIC(2) / TOGENERIC(3) ;\r\n    x = t - h;\r\n    y = (d__1 = x + x - h + x, abs(d__1)) / 64.;\r\n    v = 0.;\r\n    if (y == 0.) {\r\n/* \t PRINT *,'Is 2/3 exact?' */\r\n\tprintf(\" Is 2/3 exact? \\n\");\r\n\tgoto L299;\r\n    }\r\nL220:\r\n    if (v != 0.) {\r\n\tgoto L230;\r\n    }\r\n    u = h - y + h;\r\n    v = h - u + h;\r\n    y += y;\r\n    goto L220;\r\n\r\n/* .... in case Division is dirty */\r\n\r\nL230:\r\n    d__1 = *eps / v + 1e-4;\r\n    *rdx = aint(d__1);\r\n    if (*rdx < 2.) {\r\n/* \t PRINT 5000,'Radix =',RDX */\r\n#ifdef QP\r\n\tprintf(\" Radix = %Lg \\n\",*rdx);\r\n#else\r\n\tprintf(\" Radix = %g \\n\",*rdx);\r\n#endif\r\n/* L5000: */\r\n\tgoto L299;\r\n    }\r\n\r\n/* .... Confirm that RDX = Radix of Floating-point arithmetic. */\r\n\r\n    t = *rdx;\r\n    x = 1.;\r\n\r\n/* .... until X.EQ.0 or X.EQ.RDX */\r\n\r\nL240:\r\n    if (x != 1.) {\r\n\tgoto L250;\r\n    }\r\n    t += t;\r\n    u = t + 1.;\r\n    x = u - t;\r\n    goto L240;\r\nL250:\r\n    if (x == 0.) {\r\n\ty = 1.;\r\nL260:\r\n\tif (x != 0.) {\r\n\t    goto L270;\r\n\t}\r\n\ty += y;\r\n\tu = t + y;\r\n\tx = u - t;\r\n\tgoto L260;\r\n    }\r\nL270:\r\n    if (x != *rdx) {\r\n/*         PRINT 6000,'Is Radix ',X,' or ',RDX,'?' */\r\n#ifdef QP\r\n\tprintf(\" Is Radix %Lg or %Lg ? \\n\",x,rdx);\r\n#else\r\n\tprintf(\" Is Radix %g or %g ? \\n\",x,rdx);\r\n#endif\r\n/* L6000: */\r\n\tgoto L299;\r\n    }\r\n\r\n/* .... Confirm that FL = RDX/EPS: */\r\n\r\n    *fl = *rdx;\r\n    x = 1.;\r\nL280:\r\n    if (x != 1.) {\r\n\tgoto L290;\r\n    }\r\n    *fl *= *rdx;\r\n    u = *fl + 1.;\r\n    x = u - *fl;\r\n    goto L280;\r\nL290:\r\n    if (*fl * v == 1.) {\r\n\treturn 0;\r\n    }\r\n\r\n/* .... ENVCNS cannot compute environmental constants correctly: */\r\n\r\n/*      PRINT 3000,'Is FL ',FL,' or ',1. d0 /V,'?' */\r\n#ifdef QP\r\n        printf(\" Is FL %Lg or %Lg ? \\n\",*fl,1.0/v);\r\n#else\r\n        printf(\" Is FL %g or %g ? \\n\",*fl,1.0/v);\r\n#endif\r\n/* 3000  FORMAT(1X,A6,1PE45.37E3/1X,2X,A4,1PE45.37E3,A1) */\r\nL299:\r\n/* \tPRINT *,'Subroutine ENVCNS cannot compute correctly the' */\r\n/*      PRINT *,'Environmental constants' */\r\n/*      PRINT *,'EPS = 1.000...001 - 1 , and' */\r\n/*      PRINT *,'FL = Last consecutive Floating-point integer' */\r\n/*      PRINT *,'        among 1, 2, 3, ..., FL-2, FL-1, FL.' */\r\n/*      PRINT *,'Please substitute them for the subroutine.' */\r\n\tprintf(\" envcns cannnot compute correctly the Environmental constants. \\n\");\r\n\tprintf(\"Confirming:  UCBFAIL  \\n\");\r\n        /* MCL --- removed for standalone version. (void) ucbfail( __FILE__ , __LINE__ ); */\r\n} /* envcns_ */\r\n\r\n\r\n/* Subroutine */ int nextab_(dj, a, b)\r\nGENERIC *dj, *a, *b;\r\n{\r\n    /* Initialized data */\r\n\r\n    static GENERIC a0 = 1.;\r\n    static GENERIC b0 = 0.;\r\n\r\n    static GENERIC t;\r\n\r\n\r\n/* .... Get next pair A, B */\r\n\r\n/* .... local variables */\r\n\r\n\r\n    t = *dj * *b + b0;\r\n    b0 = *b;\r\n    *b = t;\r\n    t = *dj * *a + a0;\r\n    a0 = *a;\r\n    *a = t;\r\n\r\n/* .... Now A/B = D0+1/(D1+1/(D2+...+1/DJ)). */\r\n\r\n    return 0;\r\n} /* nextab_ */\r\n\r\n\r\n/* Subroutine */ int getce_(npi, j, inc, eps, fl, d, c, e)\r\ninteger *npi, *j, *inc;\r\nGENERIC *eps, *fl, *d, *c, *e;\r\n{\r\n    /* System generated locals */\r\n    integer i__1, i__2;\r\n\r\n    /* Local variables */\r\n    static integer i;\r\n    static GENERIC x, y, z;\r\n    static integer i9;\r\n\r\n\r\n/* .... This subroutine computes the continued fraction's tail */\r\n/* ....    Z = D(J+1)+1/(D(J+2)+1/(D(J+3)+1/(D(J+4)+...))) */\r\n/* .... to working accuracy by using INC terms of it, and then */\r\n/* .... computes the effect C of cutting it off to get A/B . */\r\n/* .... */\r\n/* .... Get  C = PI-A/B+/-E */\r\n\r\n/* .... local variables */\r\n\r\n\r\n/* Computing MIN */\r\n    i__1 = *npi, i__2 = *j + *inc;\r\n    i9 = min(i__1,i__2);\r\n    z = d[i9];\r\n    i__1 = *j + 1;\r\n    for (i = i9 - 1; i >= i__1; --i) {\r\n\tz = d[i] + 1. / z;\r\n/* L400: */\r\n    }\r\n    x = *fl * *fl;\r\n\r\n/* .... C = 1/Z-1/X always */\r\n\r\n    *c = 1. / z - 1. / x;\r\n    for (i = *j; i >= 1; --i) {\r\n\ty = d[i];\r\n\tz = y + 1. / z;\r\n\tx = y + 1. / x;\r\n\t*c = -(*c) / (x * z);\r\n/* L410: */\r\n    }\r\n\r\n/* .... E > accumulated roundoff (mixed arithmetic) */\r\n\r\n    *e = *j * 4. * *eps * abs(*c);\r\n    return 0;\r\n} /* getce_ */\r\n\r\n\r\n/* Subroutine */ int tstrig_(eps, a, b, c, e, r)\r\nGENERIC *eps, *a, *b, *c, *e, *r;\r\n{\r\n    /* Initialized data */\r\n\r\n    static char si[10+1] = \"arcsin(sin\";\r\n    static char co[10+1] = \"arcsin(cos\";\r\n    static char ta[10+1] = \"arctan(tan\";\r\n\r\n    /* System generated locals */\r\n    address a__1[2];\r\n    integer i__1[2];\r\n    GENERIC d__1, d__2;\r\n    char ch__1[1];\r\n\r\n    /* Local variables */\r\n    extern /* Subroutine */ int whet_();\r\n    static GENERIC q, s, w, x, y, q0, w0;\r\n    static char ts[11];\r\n\r\n\r\n/* .... Get R = PI-P+/-E */\r\n\r\n/*     This subroutine tests whether the programs that compute */\r\n/*     TRIG(X) = trig(X*PI/P) for TRIG = sin, cos or tan */\r\n/*     always use the same approximation P to PI during their */\r\n/*     argument reduction.  If so, 3 or 4 values R = Q+C */\r\n/*     derived from A = B*(PI-C+/-E) ought to agree. */\r\n\r\n/* .... local variables */\r\n\r\n\r\n\r\n\r\n/* .... FNODD(floating-point integer X) = (-1)**X */\r\n\r\n\r\n/* .... FNS(1) = '+', FNS(-1) = '-' */\r\n\r\n\r\n    q = ATAN(TAN(*a)) / *b;\r\n    *r = q + *c;\r\n    w = *eps * 3. * abs(q);\r\n    *e += w;\r\n    d__1 = abs(*b) * .5 + .125;\r\n    s = (aint(d__1) * 2. - abs(*b)) * 2. + 1.;\r\n    x = *a;\r\n    y = *b;\r\n/* Writing concatenation */\r\n    ch__1[0] = 44 - (integer) s;\r\n    i__1[0] = 1, a__1[0] = ch__1;\r\n    i__1[1] = 10, a__1[1] = si;\r\n    s_cat(ts, a__1, i__1, &c__2, 11L);\r\n    q0 = ASIN(SIN(x)) / y * s;\r\n    w0 = w + *eps * 6. * abs(q0);\r\n    whet_(&q, &q0, &w0, &x, &y, a, b, ts, ta, 11L, 10L);\r\n    x = *a * .5;\r\n    y = *b * .5;\r\n    if (s < 0.) {\r\n\r\n/* ....    (B+1) is even */\r\n\r\n\td__1 = (*b + 1.) * .5;\r\n\td__2 = abs(d__1) * .5 + .125;\r\n\ts = (aint(d__2) * 2. - abs(d__1)) * 2. + 1.;\r\n/* Writing concatenation */\r\n\tch__1[0] = 44 - (integer) s;\r\n\ti__1[0] = 1, a__1[0] = ch__1;\r\n\ti__1[1] = 10, a__1[1] = co;\r\n\ts_cat(ts, a__1, i__1, &c__2, 11L);\r\n\tq0 = ASIN(COS(x)) / y * s;\r\n\tw0 = w + *eps * 6. * abs(q0);\r\n    } else {\r\n\r\n/* ....    B = 2y is even */\r\n\r\n/* Writing concatenation */\r\n\ti__1[0] = 1, a__1[0] = \" \";\r\n\ti__1[1] = 10, a__1[1] = ta;\r\n\ts_cat(ts, a__1, i__1, &c__2, 11L);\r\n\tq0 = ATAN(TAN(x)) / y;\r\n\tw0 = *eps * 3. * abs(q0);\r\n\twhet_(&q, &q0, &w0, &x, &y, a, b, ts, ta, 11L, 10L);\r\n\td__1 = abs(y) * .5 + .125;\r\n\ts = (aint(d__1) * 2. - abs(y)) * 2. + 1.;\r\n/* Writing concatenation */\r\n\tch__1[0] = 44 - (integer) s;\r\n\ti__1[0] = 1, a__1[0] = ch__1;\r\n\ti__1[1] = 10, a__1[1] = si;\r\n\ts_cat(ts, a__1, i__1, &c__2, 11L);\r\n\tq0 = ASIN(SIN(x)) / y * s;\r\n\tw0 = w + *eps * 6. * abs(q0);\r\n    }\r\n    whet_(&q, &q0, &w0, &x, &y, a, b, ts, ta, 11L, 10L);\r\n    return 0;\r\n} /* tstrig_ */\r\n\r\n\r\n/* Subroutine */ int whet_(q, q0, w0, x, y, a, b, ts, ta, ts_len, ta_len)\r\nGENERIC *q, *q0, *w0, *x, *y, *a, *b;\r\nchar *ts, *ta;\r\nftnlen ts_len;\r\nftnlen ta_len;\r\n{\r\n    /* System generated locals */\r\n    GENERIC d__1;\r\n\r\n\r\n/* .... Test whether Q0.EQ.Q within +/- W0 (.GE.->.GT.) */\r\n\r\n    if ((d__1 = *q - *q0, abs(d__1)) > *w0) {\r\n\r\n/* ....    Difference too big suggests P is not a constant after all. \r\n*/\r\n\r\n/*         PRINT 4000,TS,X,')/',Y,' =',Q0,' differs from ', */\r\n/*     1      TA,A,')/',B,' =',Q,' too much.' */\r\n/* 4000  FORMAT(/1X,4X,70('%') */\r\n/*     1   /1X,4X,A11,0PF38.1,A */\r\n/*     2   /1X,4X,11X,0PF38.1,A */\r\n/*     3   /1X,4X,11X,1PE45.37E3,A */\r\n/*     4   /1X,4X,1X,A10,0PF38.1,A */\r\n/*     5   /1X,4X,11X,0PF38.1,A */\r\n/*     6   /1X,4X,11X,1PE45.37E3,A */\r\n/*     7   /1X,4X,70('%') */\r\n/*     8   /) */\r\n#ifdef QP\r\n\tprintf(\" %s %Lg / %Lg  differs from %s %Lg / %Lg = %Lg too much.\\n\",\r\n#else\r\n\tprintf(\" %s %g / %g  differs from %s %g / %g = %g too much.\\n\",\r\n#endif\r\n\t\tts,*x,*y,*q0,ta,*a,*b,*q);\r\n\r\n\r\n\tprintf(\"Confirming:  UCBFAIL  \\n\");\r\n        /* MCL --- Removed for standalone version: (void) ucbfail( __FILE__ , __LINE__ ); */\r\n    }\r\n    return 0;\r\n} /* whet_ */\r\n\r\n\r\n/* Subroutine */ int displa_(j, a, b, c, e, r)\r\ninteger *j;\r\nGENERIC *a, *b, *c, *e, *r;\r\n{\r\n\r\n/*     Display Formatting */\r\n\r\n/* .... display  J, A, B, C, R, E */\r\n\r\n/*      PRINT 2000,J,A,B,C,R,E */\r\n/* 2000  FORMAT(1X,I2,1X,F37.0,'/',F37.0 */\r\n/*     1   /1X,2X,1X,27X,'+',1X,1PE45.37E3 */\r\n/*     2   /1X,2X,1X,1X,1PE45.37E3,1X,'+/-',1PE16.8E3 */\r\n/*     3   ) */\r\n#ifdef QP\r\n\tprintf(\" J %3d A %37.0Lf / B %37.0Lf + C %45.37Le \\n\",\r\n\t\t*j,*a,*b,*c);\r\n\tprintf(\" J %3d R %45.37Le +- %17.9Le \\n\",\r\n\t\t*j,*r,*e);\r\n#endif\r\n#ifdef DP\r\n\tprintf(\" J %2d A %17.0f / B %17.0f + C %25.17e \\n\",\r\n\t\t*j,*a,*b,*c);\r\n\tprintf(\" J %2d R %25.17e +- %17.9e \\n\",\r\n\t\t*j,*r,*e);\r\n#endif\r\n#ifdef SP\r\n\tprintf(\" J %2d A %9.0f / B %9.0f + C %17.9e \\n\",\r\n\t\t*j,*a,*b,*c);\r\n\tprintf(\" J %2d R %17.9e +- %17.9e \\n\",\r\n\t\t*j,*r,*e);\r\n#endif\r\n    return 0;\r\n} /* displa_ */\r\n\r\n\r\n/* Subroutine */ int compar_(e, r)\r\nGENERIC *e, *r;\r\n{\r\n    /* Initialized data */\r\n\r\n    static GENERIC e0 = .1416;\r\n    static GENERIC r0 = 0.;\r\n\r\n    /* System generated locals */\r\n    GENERIC d__1;\r\n\r\n/* .... test for consistency */\r\n\r\n/* .... local variables */\r\n\r\n\r\n/* .... .LT.->.LE. */\r\n\r\n    if ((d__1 = *r - r0, abs(d__1)) <= *e + e0) {\r\n\te0 = *e;\r\n\tr0 = *r;\r\n    } else {\r\n/*         PRINT *,'Varying R implies defective argument reduction.' \r\n*/\r\n\tprintf(\" Varying R implies defective argument reduction. \\n\");\r\n\tprintf(\"Confirming:  UCBFAIL  \\n\");\r\n        /* --- MCL removed for standalone version: (void) ucbfail( __FILE__ , __LINE__ ); */\r\n    }\r\n    return 0;\r\n} /* compar_ */\r\n\r\n/* Main program alias */ int main () { MAIN__ (); }\r\n```\r\n\r\nYou will also need this file:   ucbtest.h\r\n\r\n```\r\n#ifndef _UCBTEST\r\n\r\n#define _UCBTEST\r\n\r\n/*\tspecial definitions for Sun test harness\t*/\r\n\r\n#ifdef SP\r\n#undef SP\r\n#define FLOAT\r\n#endif\r\n\r\n#ifdef DP\r\n#undef DP\r\n#define DOUBLE\r\n#endif\r\n\r\n#ifdef QP\r\n#undef QP\r\n#define LONGDOUBLE\r\n#endif\r\n\r\n#ifndef SUN_IEEE\r\n#if (sunpro_version >= 100) || (sunos_version/100 == 4)\r\n#define SUN_IEEE\r\n#endif\r\n#endif\r\n\r\n#ifndef SUN_MATH\r\n#if (sunpro_version >= 300)\r\n#define SUN_MATH\r\n#endif\r\n#endif\r\n\r\n/*\tGlobal macro definitions.\t*/\r\n\r\n#ifdef PC\r\n#define FINT\tlong\t\t/* C equivalent of Fortran integer */\r\n#define INT32\tlong\t\t/* 32 bit int */\r\n#define UINT32\tunsigned long\t/* 32 bit unsigned */\r\n#else\r\n#define FINT\tint\t\t/* C equivalent of Fortran integer */\r\n#define INT32\tint\t\t/* 32 bit int */\r\n#define UINT32\tunsigned int\t/* 32 bit unsigned */\r\n#endif\r\n\r\n#ifdef SUN_MATH\r\n#include <sunmath.h>\r\n#endif\r\n#include <math.h>\r\n\r\n#ifndef NTESTS\r\n#define NTESTS 1000000L   /* DOS wants L specifier added */\r\n#endif\r\n\r\n#if defined(__STDC__) || defined(DOS)\r\n#define ANSI_PROTOTYPES\r\n#define PROTO(p)  p\r\n#else\r\n#undef ANSI_PROTOTYPES\r\n#define PROTO(p)  ()\r\n#endif\r\n\r\n#ifdef FLOAT\r\n#define SP\r\n#define GENERIC float\r\n#define GENERIC_STRING \"float\"\r\n#define PRECISION_STRING \"single\"\r\n#define ABS(X) fabs((double)(X))\r\n#define MOD(X,Y) fmod((double)(X),(double)(Y))\r\n#define CEIL(X) ceil((double)(X))\r\n#define FLOOR(X) floor((double)(X))\r\n#if defined(__STDC__) && !defined(NO_FUNCF)\r\n#define SQRT(X) sqrtf((float)(X))\r\n#define LOG(X) logf((float)(X))\r\n#define SIN(X) sinf((float)(X))\r\n#define COS(X) cosf((float)(X))\r\n#define TAN(X) tanf((float)(X))\r\n#define ASIN(X) asinf((float)(X))\r\n#define ACOS(X) acosf((float)(X))\r\n#define ATAN(X) atanf((float)(X))\r\n#define POW(X,Y) powf((float)(X),(float)(Y))\r\nextern float sqrtf(float);\r\nextern float logf(float);\r\nextern float sinf(float);\r\nextern float cosf(float);\r\nextern float tanf(float);\r\nextern float asinf(float);\r\nextern float acosf(float);\r\nextern float atanf(float);\r\nextern float powf(float,float);\r\n#else\r\n#define SQRT(X) sqrt((double)(X))\r\n#define LOG(X) log((double)(X))\r\n#define SIN(X) sin((double)(X))\r\n#define COS(X) cos((double)(X))\r\n#define TAN(X) tan((double)(X))\r\n#define ASIN(X) asin((double)(X))\r\n#define ACOS(X) acos((double)(X))\r\n#define ATAN(X) atan((double)(X))\r\n#define POW(X,Y) pow((double)(X),(double)(Y))\r\n#endif\r\n#endif\r\n\r\n#ifdef DOUBLE\r\n#define DP\r\n#define GENERIC double\r\n#define GENERIC_STRING \"double\"\r\n#define PRECISION_STRING \"double\"\r\n#define ABS(X) fabs((double)(X))\r\n#define MOD(X,Y) fmod((double)(X),(double)(Y))\r\n#define CEIL(X) ceil((double)(X))\r\n#define FLOOR(X) floor((double)(X))\r\n#define SQRT(X) sqrt((double)(X))\r\n#define LOG(X) log((double)(X))\r\n#define SIN(X) sin((double)(X))\r\n#define COS(X) cos((double)(X))\r\n#define TAN(X) tan((double)(X))\r\n#define ASIN(X) asin((double)(X))\r\n#define ACOS(X) acos((double)(X))\r\n#define ATAN(X) atan((double)(X))\r\n#define POW(X,Y) pow((double)(X),(double)(Y))\r\n#endif\r\n\r\n#ifdef LONGDOUBLE\r\n#define QP\r\n#define GENERIC long double\r\n#define GENERIC_STRING \"long double\"\r\n#define PRECISION_STRING \"extended\"\r\n#define ABS(X) fabsl((long double)(X))\r\n#define MOD(X,Y) fmodl((long double)(X),(long double)(Y))\r\n#define CEIL(X) ceill((long double)(X))\r\n#define FLOOR(X) floorl((long double)(X))\r\n#define SQRT(X) sqrtl((long double)(X))\r\n#define LOG(X) logl((long double)(X))\r\n#define SIN(X) sinl((long double)(X))\r\n#define COS(X) cosl((long double)(X))\r\n#define TAN(X) tanl((long double)(X))\r\n#define ASIN(X) asinl((long double)(X))\r\n#define ACOS(X) acosl((long double)(X))\r\n#define ATAN(X) atanl((long double)(X))\r\n#define POW(X,Y) powl((long double)(X),(long double)(Y))\r\nextern long double fabsl(long double);\r\nextern long double fmodl(long double, long double);\r\nextern long double ceill(long double);\r\nextern long double floorl(long double);\r\nextern long double sqrtl(long double);\r\nextern long double logl(long double);\r\nextern long double sinl(long double);\r\nextern long double cosl(long double);\r\nextern long double tanl(long double);\r\nextern long double asinl(long double);\r\nextern long double acosl(long double);\r\nextern long double atanl(long double);\r\nextern long double powl(long double, long double);\r\n#endif\r\n\r\n#define TOGENERIC(X) ((GENERIC)(X))\r\n#define ZERO ((GENERIC)(0))\r\n#define ONE  ((GENERIC)(1))\r\n#define TWO  ((GENERIC)(2))\r\n#define FOUR ((GENERIC)(4))\r\n\r\nextern UINT32 ntests, nregions;\r\nextern UINT32 significand_length;\r\n\r\n\r\n/*\tIEEE features with machine-dependent syntax \t*/\r\n\r\nextern void round_nearest PROTO((void));\r\nextern void round_positive PROTO((void));\r\nextern void round_zero PROTO((void));\r\nextern void generic_precision PROTO((void));\r\nextern void default_precision PROTO((void));\r\n\r\n/*\tCommon ucbtest functions\t\t\t*/\r\n\r\nextern void ucbstart PROTO((char *file,int line));\r\nextern void ucbfail PROTO((char *file,int line));\r\nextern void ucbpass PROTO((char *file,int line));\r\n\r\n#include \"stdio.h\"\r\n\r\n#ifdef sunos_version\r\n\r\n#if (sunos_version/100 >= 4)\r\n#include \"stdlib.h\"\r\n#endif\r\n\r\n#else\r\n#include \"stdlib.h\"\r\n#endif\r\n\r\n#ifndef __NEWVALID\r\nextern UINT32 get_significand PROTO((void));\r\nextern void ucbdivtest_ PROTO((int *, char **));\r\nextern void ucbmultest_ PROTO((int *, char **));\r\nextern void ucbsqrtest_ PROTO((int *, char **));\r\nextern void ucbfindpitest_ PROTO((int *, char **));\r\nextern void ucbeeftest_ PROTO((int *, char **));\r\n#endif\r\n\r\n#endif /* _UCBTEST */\r\n```\r\nThe PIRATS program can be compiled in \"double-precision\" mode using this file:\r\n\r\ncompile_pi_new_c_DP\r\n```\r\n#!/bin/sh\r\n#\r\n# --- pre-process and compile the pi_new.c program to executable: pinewcDP\r\n#\r\n# (((((((((((((((  Double Precision Verson  )))))))))))))))\r\ngcc -cpp -D DP  pi_new.c -lm -o pinewcDP\r\n\r\n# --- you can run \"pinewcDP\" stand-alone, and check if it passes or fails.\r\n# --- if it passes, it will say: \"Confirming: UCBPASS\". \r\n```\r\n\r\nIf you want to run the test in single-precision (32-bit instead of 64-bit), you can do it with this:\r\n\r\ncompile_pi_new_c_SP\r\n```\r\n#!/bin/sh\r\n#\r\n# --- pre-process and compile the pi_new.c program to executable: pinewcSP\r\n#\r\n# (((((((((((((((  Single Precision Verson  )))))))))))))))\r\ngcc -cpp -D SP  pi_new.c -lm -o pinewcSP\r\n\r\n# --- you can run \"pinewcSP\" stand-alone, and check if it passes or fails.\r\n# --- if it passes, it will say: \"Confirming: UCBPASS\". \r\n```\r\n\r\nI'll make a more detailed review of the UCBTest suiite, and post the results here.  It would seem to me the differences between MacOS and Linux results have to be affecting TensorFlow, in more areas than just PDE simulations and image-creation, as lewisl's post indicates is happening.\r\n"}