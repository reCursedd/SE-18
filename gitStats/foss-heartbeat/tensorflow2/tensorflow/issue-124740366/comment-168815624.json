{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/168815624", "html_url": "https://github.com/tensorflow/tensorflow/issues/675#issuecomment-168815624", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/675", "id": 168815624, "node_id": "MDEyOklzc3VlQ29tbWVudDE2ODgxNTYyNA==", "user": {"login": "girving", "id": 70511, "node_id": "MDQ6VXNlcjcwNTEx", "avatar_url": "https://avatars1.githubusercontent.com/u/70511?v=4", "gravatar_id": "", "url": "https://api.github.com/users/girving", "html_url": "https://github.com/girving", "followers_url": "https://api.github.com/users/girving/followers", "following_url": "https://api.github.com/users/girving/following{/other_user}", "gists_url": "https://api.github.com/users/girving/gists{/gist_id}", "starred_url": "https://api.github.com/users/girving/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/girving/subscriptions", "organizations_url": "https://api.github.com/users/girving/orgs", "repos_url": "https://api.github.com/users/girving/repos", "events_url": "https://api.github.com/users/girving/events{/privacy}", "received_events_url": "https://api.github.com/users/girving/received_events", "type": "User", "site_admin": false}, "created_at": "2016-01-04T21:30:03Z", "updated_at": "2016-01-04T21:30:03Z", "author_association": "CONTRIBUTOR", "body_html": "<p>It'd be pretty hard to support gradients of non-scalars with our current setup, since it would require every gradient function to handle extra rank input.  The one possibility I could see would be if we add some sort of map facility to register how to add extra ranks to ops, then compute gradients with respect to extra rank by computing lower rank and calling the registered map transformations.</p>\n<p>Someone asked for map a while back, so if anyone wanted to tackle this task that might be the way to go.  Handling it at the gradient function level is probably bad, since it would add required complexity to an existing feature.  Warning: This is a pretty large change, so a good deal of discussion would be in order before starting.</p>", "body_text": "It'd be pretty hard to support gradients of non-scalars with our current setup, since it would require every gradient function to handle extra rank input.  The one possibility I could see would be if we add some sort of map facility to register how to add extra ranks to ops, then compute gradients with respect to extra rank by computing lower rank and calling the registered map transformations.\nSomeone asked for map a while back, so if anyone wanted to tackle this task that might be the way to go.  Handling it at the gradient function level is probably bad, since it would add required complexity to an existing feature.  Warning: This is a pretty large change, so a good deal of discussion would be in order before starting.", "body": "It'd be pretty hard to support gradients of non-scalars with our current setup, since it would require every gradient function to handle extra rank input.  The one possibility I could see would be if we add some sort of map facility to register how to add extra ranks to ops, then compute gradients with respect to extra rank by computing lower rank and calling the registered map transformations.\n\nSomeone asked for map a while back, so if anyone wanted to tackle this task that might be the way to go.  Handling it at the gradient function level is probably bad, since it would add required complexity to an existing feature.  Warning: This is a pretty large change, so a good deal of discussion would be in order before starting.\n"}