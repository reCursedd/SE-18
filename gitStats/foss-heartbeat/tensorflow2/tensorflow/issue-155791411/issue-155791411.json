{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2432", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2432/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2432/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2432/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/2432", "id": 155791411, "node_id": "MDU6SXNzdWUxNTU3OTE0MTE=", "number": 2432, "title": "Feature Request: Staircase function", "user": {"login": "rdipietro", "id": 5150559, "node_id": "MDQ6VXNlcjUxNTA1NTk=", "avatar_url": "https://avatars1.githubusercontent.com/u/5150559?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rdipietro", "html_url": "https://github.com/rdipietro", "followers_url": "https://api.github.com/users/rdipietro/followers", "following_url": "https://api.github.com/users/rdipietro/following{/other_user}", "gists_url": "https://api.github.com/users/rdipietro/gists{/gist_id}", "starred_url": "https://api.github.com/users/rdipietro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rdipietro/subscriptions", "organizations_url": "https://api.github.com/users/rdipietro/orgs", "repos_url": "https://api.github.com/users/rdipietro/repos", "events_url": "https://api.github.com/users/rdipietro/events{/privacy}", "received_events_url": "https://api.github.com/users/rdipietro/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 299643928, "node_id": "MDU6TGFiZWwyOTk2NDM5Mjg=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:contributions%20welcome", "name": "stat:contributions welcome", "color": "f4b400", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2016-05-19T17:25:55Z", "updated_at": "2016-05-24T19:23:23Z", "closed_at": "2016-05-24T19:23:23Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Right now for learning rates we have <code>exponential_decay</code>, which is useful but doesn't handle fine-tuned scheduling. For example, regardless of whether we did this manually or with <code>exponential_decay</code>, there'd be boilerplate code to use a learning rate of 1.0 for 100000 steps, 0.5 for the next 10000 steps, and 0.1 for all remaining steps.</p>\n<p>This could be handled with a staircase function, maybe with usage like this:</p>\n<pre><code>boundaries = [100000, 110000]\nvalues = [1.0, 0.5, 0.1]\nlearning_rate = staircase(global_step, boundaries, values)\n</code></pre>\n<p>This would create a <code>Tensor</code> that evaluates to 1.0 when <code>x &lt;= 100000</code>, 0.5 when <code>x &gt; 100000</code> and <code>x &lt;= 110000</code>, and 0.1 when <code>x &gt; 110000</code>.</p>\n<p>Shouldn't be hard to build using <code>tf.case</code>.</p>\n<p>Is this of interest or too specific?</p>", "body_text": "Right now for learning rates we have exponential_decay, which is useful but doesn't handle fine-tuned scheduling. For example, regardless of whether we did this manually or with exponential_decay, there'd be boilerplate code to use a learning rate of 1.0 for 100000 steps, 0.5 for the next 10000 steps, and 0.1 for all remaining steps.\nThis could be handled with a staircase function, maybe with usage like this:\nboundaries = [100000, 110000]\nvalues = [1.0, 0.5, 0.1]\nlearning_rate = staircase(global_step, boundaries, values)\n\nThis would create a Tensor that evaluates to 1.0 when x <= 100000, 0.5 when x > 100000 and x <= 110000, and 0.1 when x > 110000.\nShouldn't be hard to build using tf.case.\nIs this of interest or too specific?", "body": "Right now for learning rates we have `exponential_decay`, which is useful but doesn't handle fine-tuned scheduling. For example, regardless of whether we did this manually or with `exponential_decay`, there'd be boilerplate code to use a learning rate of 1.0 for 100000 steps, 0.5 for the next 10000 steps, and 0.1 for all remaining steps.\n\nThis could be handled with a staircase function, maybe with usage like this:\n\n```\nboundaries = [100000, 110000]\nvalues = [1.0, 0.5, 0.1]\nlearning_rate = staircase(global_step, boundaries, values)\n```\n\nThis would create a `Tensor` that evaluates to 1.0 when `x <= 100000`, 0.5 when `x > 100000` and `x <= 110000`, and 0.1 when `x > 110000`.\n\nShouldn't be hard to build using `tf.case`.\n\nIs this of interest or too specific?\n"}