{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/249021613", "html_url": "https://github.com/tensorflow/tensorflow/issues/4526#issuecomment-249021613", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/4526", "id": 249021613, "node_id": "MDEyOklzc3VlQ29tbWVudDI0OTAyMTYxMw==", "user": {"login": "yaroslavvb", "id": 23068, "node_id": "MDQ6VXNlcjIzMDY4", "avatar_url": "https://avatars3.githubusercontent.com/u/23068?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yaroslavvb", "html_url": "https://github.com/yaroslavvb", "followers_url": "https://api.github.com/users/yaroslavvb/followers", "following_url": "https://api.github.com/users/yaroslavvb/following{/other_user}", "gists_url": "https://api.github.com/users/yaroslavvb/gists{/gist_id}", "starred_url": "https://api.github.com/users/yaroslavvb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yaroslavvb/subscriptions", "organizations_url": "https://api.github.com/users/yaroslavvb/orgs", "repos_url": "https://api.github.com/users/yaroslavvb/repos", "events_url": "https://api.github.com/users/yaroslavvb/events{/privacy}", "received_events_url": "https://api.github.com/users/yaroslavvb/received_events", "type": "User", "site_admin": false}, "created_at": "2016-09-22T20:40:58Z", "updated_at": "2016-09-22T20:43:43Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Here's what I meant when I said that GPU-resident queue could be doing using existing ops:</p>\n<ul>\n<li>Keep a buffer of examples on GPU in several variables</li>\n<li>Regular FIFO queue is enqueued with example indices, while actual example data lies on GPU</li>\n<li>A global counter keeps track of number of examples that have been consumed</li>\n<li>A separate thread periodically checks the counter, and replaces stale variables with new example data using <code>tf.assign</code></li>\n</ul>\n<p>Essentially you would have a rotating buffer of examples on GPU, and load that data asynchronously</p>", "body_text": "Here's what I meant when I said that GPU-resident queue could be doing using existing ops:\n\nKeep a buffer of examples on GPU in several variables\nRegular FIFO queue is enqueued with example indices, while actual example data lies on GPU\nA global counter keeps track of number of examples that have been consumed\nA separate thread periodically checks the counter, and replaces stale variables with new example data using tf.assign\n\nEssentially you would have a rotating buffer of examples on GPU, and load that data asynchronously", "body": "Here's what I meant when I said that GPU-resident queue could be doing using existing ops:\n- Keep a buffer of examples on GPU in several variables\n- Regular FIFO queue is enqueued with example indices, while actual example data lies on GPU\n- A global counter keeps track of number of examples that have been consumed\n- A separate thread periodically checks the counter, and replaces stale variables with new example data using `tf.assign`\n\nEssentially you would have a rotating buffer of examples on GPU, and load that data asynchronously\n"}