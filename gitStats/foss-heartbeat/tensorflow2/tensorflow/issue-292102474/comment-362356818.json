{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/362356818", "html_url": "https://github.com/tensorflow/tensorflow/issues/16481#issuecomment-362356818", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/16481", "id": 362356818, "node_id": "MDEyOklzc3VlQ29tbWVudDM2MjM1NjgxOA==", "user": {"login": "mrry", "id": 192142, "node_id": "MDQ6VXNlcjE5MjE0Mg==", "avatar_url": "https://avatars1.githubusercontent.com/u/192142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mrry", "html_url": "https://github.com/mrry", "followers_url": "https://api.github.com/users/mrry/followers", "following_url": "https://api.github.com/users/mrry/following{/other_user}", "gists_url": "https://api.github.com/users/mrry/gists{/gist_id}", "starred_url": "https://api.github.com/users/mrry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mrry/subscriptions", "organizations_url": "https://api.github.com/users/mrry/orgs", "repos_url": "https://api.github.com/users/mrry/repos", "events_url": "https://api.github.com/users/mrry/events{/privacy}", "received_events_url": "https://api.github.com/users/mrry/received_events", "type": "User", "site_admin": false}, "created_at": "2018-02-01T18:24:07Z", "updated_at": "2018-02-01T18:24:07Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Thanks for tracking that down! I think this is a legitimate bug, introduced in <a class=\"commit-link\" data-hovercard-type=\"commit\" data-hovercard-url=\"https://github.com/tensorflow/tensorflow/commit/9f4118d00fa9eb85f81a4eb3f96a5583ae5afcdc/hovercard\" href=\"https://github.com/tensorflow/tensorflow/commit/9f4118d00fa9eb85f81a4eb3f96a5583ae5afcdc\"><tt>9f4118d</tt></a>. That change modifies most iterators to use the same <code>Device</code>, <code>FunctionLibraryRuntime</code>, and <code>ResourceMgr</code> as the op that created them, which enables the resource-capturing logic to be simplified, because handles are valid in both the caller and the callee.</p>\n<p>However, when the <code>shared_name</code> is set, the iterator might outlive the <code>FunctionLibraryRuntime</code> used by the op that created it. The new code identifies this case and creates its own private <code>FunctionLibrary</code>, <code>Device</code>, and <code>ResourceMgr</code> that will outlive the caller. Unfortunately, this means that the handles from the caller and no longer valid in the callee, which manifests as a <code>NotFoundError</code>.</p>\n<p>Thanks for the promising lead on this bug! We'll try to get a fix in soon.</p>", "body_text": "Thanks for tracking that down! I think this is a legitimate bug, introduced in 9f4118d. That change modifies most iterators to use the same Device, FunctionLibraryRuntime, and ResourceMgr as the op that created them, which enables the resource-capturing logic to be simplified, because handles are valid in both the caller and the callee.\nHowever, when the shared_name is set, the iterator might outlive the FunctionLibraryRuntime used by the op that created it. The new code identifies this case and creates its own private FunctionLibrary, Device, and ResourceMgr that will outlive the caller. Unfortunately, this means that the handles from the caller and no longer valid in the callee, which manifests as a NotFoundError.\nThanks for the promising lead on this bug! We'll try to get a fix in soon.", "body": "Thanks for tracking that down! I think this is a legitimate bug, introduced in https://github.com/tensorflow/tensorflow/commit/9f4118d00fa9eb85f81a4eb3f96a5583ae5afcdc. That change modifies most iterators to use the same `Device`, `FunctionLibraryRuntime`, and `ResourceMgr` as the op that created them, which enables the resource-capturing logic to be simplified, because handles are valid in both the caller and the callee.\r\n\r\nHowever, when the `shared_name` is set, the iterator might outlive the `FunctionLibraryRuntime` used by the op that created it. The new code identifies this case and creates its own private `FunctionLibrary`, `Device`, and `ResourceMgr` that will outlive the caller. Unfortunately, this means that the handles from the caller and no longer valid in the callee, which manifests as a `NotFoundError`. \r\n\r\nThanks for the promising lead on this bug! We'll try to get a fix in soon."}