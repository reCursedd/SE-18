{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5377", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5377/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5377/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5377/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/5377", "id": 187046790, "node_id": "MDU6SXNzdWUxODcwNDY3OTA=", "number": 5377, "title": "How to slice a tensor for custom loss?", "user": {"login": "CCXD", "id": 12113428, "node_id": "MDQ6VXNlcjEyMTEzNDI4", "avatar_url": "https://avatars1.githubusercontent.com/u/12113428?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CCXD", "html_url": "https://github.com/CCXD", "followers_url": "https://api.github.com/users/CCXD/followers", "following_url": "https://api.github.com/users/CCXD/following{/other_user}", "gists_url": "https://api.github.com/users/CCXD/gists{/gist_id}", "starred_url": "https://api.github.com/users/CCXD/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CCXD/subscriptions", "organizations_url": "https://api.github.com/users/CCXD/orgs", "repos_url": "https://api.github.com/users/CCXD/repos", "events_url": "https://api.github.com/users/CCXD/events{/privacy}", "received_events_url": "https://api.github.com/users/CCXD/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 473184161, "node_id": "MDU6TGFiZWw0NzMxODQxNjE=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:support", "name": "type:support", "color": "159b2e", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2016-11-03T12:30:27Z", "updated_at": "2016-11-03T17:37:38Z", "closed_at": "2016-11-03T17:37:32Z", "author_association": "NONE", "body_html": "<p>Trying to implement a custom loss function that works as following in Theano:</p>\n<pre><code>        def sparse_sqe(y_true, y_pred):\n            ix = y_true.nonzero()\n            return (y_pred[ix] - y_true[ix]) ** 2\n</code></pre>\n<p>e.g. y_true = [[0, 0, 0, 0, 5], [9, 0, 0, 0, 0]]<br>\ny_pred = [[0.2, 0.1, 0.2, 0, 4.8], [9.5, 0.3, 0.1, 0, 0]]</p>\n<p>would return ([4.8, 9.5] - [5, 9]) ** 2 = 0.29<br>\nThe loss should only be calculated for the y_pred values at the index of the nonzero y_true values.</p>\n<p>I tried</p>\n<pre><code>z = tf.constant(0, tf.float32)\nix = tf.where(tf.not_equal(y_true, z))\n(y_pred[ix] - y_true[ix]) ** 2\n</code></pre>\n<p>but you cannot slice like a numpy array. I also tried tf.gather, but this applies to a collection of tensors, and it will slice the vectors, instead of the elements of those vectors.</p>\n<p>Any help would be greatly appreciated.</p>", "body_text": "Trying to implement a custom loss function that works as following in Theano:\n        def sparse_sqe(y_true, y_pred):\n            ix = y_true.nonzero()\n            return (y_pred[ix] - y_true[ix]) ** 2\n\ne.g. y_true = [[0, 0, 0, 0, 5], [9, 0, 0, 0, 0]]\ny_pred = [[0.2, 0.1, 0.2, 0, 4.8], [9.5, 0.3, 0.1, 0, 0]]\nwould return ([4.8, 9.5] - [5, 9]) ** 2 = 0.29\nThe loss should only be calculated for the y_pred values at the index of the nonzero y_true values.\nI tried\nz = tf.constant(0, tf.float32)\nix = tf.where(tf.not_equal(y_true, z))\n(y_pred[ix] - y_true[ix]) ** 2\n\nbut you cannot slice like a numpy array. I also tried tf.gather, but this applies to a collection of tensors, and it will slice the vectors, instead of the elements of those vectors.\nAny help would be greatly appreciated.", "body": "Trying to implement a custom loss function that works as following in Theano:\r\n```\r\n        def sparse_sqe(y_true, y_pred):\r\n            ix = y_true.nonzero()\r\n            return (y_pred[ix] - y_true[ix]) ** 2\r\n```\r\ne.g. y_true = [[0, 0, 0, 0, 5], [9, 0, 0, 0, 0]]\r\ny_pred = [[0.2, 0.1, 0.2, 0, 4.8], [9.5, 0.3, 0.1, 0, 0]]\r\n\r\nwould return ([4.8, 9.5] - [5, 9]) ** 2 = 0.29\r\nThe loss should only be calculated for the y_pred values at the index of the nonzero y_true values.\r\n\r\nI tried\r\n\r\n```\r\nz = tf.constant(0, tf.float32)\r\nix = tf.where(tf.not_equal(y_true, z))\r\n(y_pred[ix] - y_true[ix]) ** 2\r\n```\r\nbut you cannot slice like a numpy array. I also tried tf.gather, but this applies to a collection of tensors, and it will slice the vectors, instead of the elements of those vectors.\r\n\r\n\r\n\r\nAny help would be greatly appreciated."}