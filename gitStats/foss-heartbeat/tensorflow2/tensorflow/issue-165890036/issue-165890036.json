{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/3334", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/3334/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/3334/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/3334/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/3334", "id": 165890036, "node_id": "MDU6SXNzdWUxNjU4OTAwMzY=", "number": 3334, "title": "tf.case doesn't preserve shape information", "user": {"login": "alexatknit", "id": 15474222, "node_id": "MDQ6VXNlcjE1NDc0MjIy", "avatar_url": "https://avatars2.githubusercontent.com/u/15474222?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexatknit", "html_url": "https://github.com/alexatknit", "followers_url": "https://api.github.com/users/alexatknit/followers", "following_url": "https://api.github.com/users/alexatknit/following{/other_user}", "gists_url": "https://api.github.com/users/alexatknit/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexatknit/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexatknit/subscriptions", "organizations_url": "https://api.github.com/users/alexatknit/orgs", "repos_url": "https://api.github.com/users/alexatknit/repos", "events_url": "https://api.github.com/users/alexatknit/events{/privacy}", "received_events_url": "https://api.github.com/users/alexatknit/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 404586594, "node_id": "MDU6TGFiZWw0MDQ1ODY1OTQ=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:awaiting%20tensorflower", "name": "stat:awaiting tensorflower", "color": "f4b400", "default": false}], "state": "closed", "locked": false, "assignee": {"login": "ebrevdo", "id": 1794715, "node_id": "MDQ6VXNlcjE3OTQ3MTU=", "avatar_url": "https://avatars0.githubusercontent.com/u/1794715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebrevdo", "html_url": "https://github.com/ebrevdo", "followers_url": "https://api.github.com/users/ebrevdo/followers", "following_url": "https://api.github.com/users/ebrevdo/following{/other_user}", "gists_url": "https://api.github.com/users/ebrevdo/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebrevdo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebrevdo/subscriptions", "organizations_url": "https://api.github.com/users/ebrevdo/orgs", "repos_url": "https://api.github.com/users/ebrevdo/repos", "events_url": "https://api.github.com/users/ebrevdo/events{/privacy}", "received_events_url": "https://api.github.com/users/ebrevdo/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "ebrevdo", "id": 1794715, "node_id": "MDQ6VXNlcjE3OTQ3MTU=", "avatar_url": "https://avatars0.githubusercontent.com/u/1794715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebrevdo", "html_url": "https://github.com/ebrevdo", "followers_url": "https://api.github.com/users/ebrevdo/followers", "following_url": "https://api.github.com/users/ebrevdo/following{/other_user}", "gists_url": "https://api.github.com/users/ebrevdo/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebrevdo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebrevdo/subscriptions", "organizations_url": "https://api.github.com/users/ebrevdo/orgs", "repos_url": "https://api.github.com/users/ebrevdo/repos", "events_url": "https://api.github.com/users/ebrevdo/events{/privacy}", "received_events_url": "https://api.github.com/users/ebrevdo/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 11, "created_at": "2016-07-15T22:36:01Z", "updated_at": "2018-02-07T23:45:04Z", "closed_at": "2018-02-07T23:45:04Z", "author_association": "NONE", "body_html": "<p>tf.case is a python implementation of a case statement using tf.cond, but unlike cond it doesn't preserve shape information when executing. This is because of this little snippet:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-c1\">...</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> preds = [p1, p2, p3]</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> fns = [f1, f2, f3]</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> not_preds = [~p1, ~p2, ~p3]</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> and_not_preds = [True, ~p1, ~p1 &amp; ~p2, ~p1 &amp; ~p2 &amp; ~p3]</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> case_preds = [p1,</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span>               p2 &amp; ~p1,</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span>               p3 &amp; ~p2 &amp; ~p1,</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span>              ~p3 &amp; ~p2 &amp; ~p1]</span>\n\n    case_preds <span class=\"pl-k\">=</span> []\n    <span class=\"pl-k\">for</span> i, (p, and_not_p_prev) <span class=\"pl-k\">in</span> <span class=\"pl-c1\">enumerate</span>(<span class=\"pl-c1\">zip</span>(preds, and_not_preds[:<span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>])):\n      <span class=\"pl-k\">with</span> ops.name_scope(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>case_<span class=\"pl-c1\">%d</span><span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">%</span> i):\n        case_preds.append(math_ops.logical_and(p, and_not_p_prev))\n    <span class=\"pl-k\">with</span> ops.name_scope(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>case_none_are_true<span class=\"pl-pds\">\"</span></span>):\n      case_preds.append(and_not_preds[<span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>])\n\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> Create an empty tensor, or list, with the right type and shape</span>\n    <span class=\"pl-k\">with</span> ops.name_scope(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>case_create_empty<span class=\"pl-pds\">\"</span></span>):\n      dummy_value <span class=\"pl-k\">=</span> default()\n      <span class=\"pl-k\">def</span> <span class=\"pl-en\">_correct_empty</span>(<span class=\"pl-smi\">v</span>):\n        <span class=\"pl-k\">if</span> <span class=\"pl-c1\">isinstance</span>(v, ops.Operation):\n          <span class=\"pl-k\">return</span> no_op()\n        <span class=\"pl-k\">elif</span> v.dtype <span class=\"pl-k\">==</span> dtypes.string:\n          <span class=\"pl-k\">return</span> array_ops.constant(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"pl-pds\">\"</span></span>)\n        <span class=\"pl-k\">else</span>:\n          <span class=\"pl-k\">return</span> array_ops.constant(v.dtype.as_numpy_dtype())\n\n      <span class=\"pl-k\">if</span> <span class=\"pl-c1\">isinstance</span>(dummy_value, collections.Sequence):\n        dummy_type <span class=\"pl-k\">=</span> <span class=\"pl-c1\">type</span>(dummy_value)\n        empty <span class=\"pl-k\">=</span> <span class=\"pl-k\">lambda</span>: dummy_type(_correct_empty(v) <span class=\"pl-k\">for</span> v <span class=\"pl-k\">in</span> dummy_value)\n      <span class=\"pl-k\">else</span>:\n        empty <span class=\"pl-k\">=</span> <span class=\"pl-k\">lambda</span>: _correct_empty(dummy_value)\n\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> case_sequence = [</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span>   cond(~p3 &amp; ~p2 &amp; ~p1, default, empty),</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span>   cond(p3 &amp; ~p2 &amp; ~p1, f3, lambda: case_sequence[0]),</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span>   cond(p2 &amp; ~p1, f2, lambda: case_sequence[1]),</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span>   cond(p1, f1, lambda: case_sequence[2])</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> ]</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span></span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> And the return value will be case_sequence[-1]</span>\n    <span class=\"pl-k\">def</span> <span class=\"pl-en\">_build_case</span>():\n      all_fns <span class=\"pl-k\">=</span> [fn <span class=\"pl-k\">for</span> fn <span class=\"pl-k\">in</span> fns]\n      all_fns.append(default)\n      prev_case <span class=\"pl-k\">=</span> <span class=\"pl-c1\">None</span>\n      <span class=\"pl-k\">for</span> i, (cp, fn) <span class=\"pl-k\">in</span> <span class=\"pl-c1\">enumerate</span>(<span class=\"pl-c1\">list</span>(<span class=\"pl-c1\">zip</span>(case_preds, all_fns))[::<span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>]):\n        prev_case <span class=\"pl-k\">=</span> cond(\n            cp, fn,\n            empty <span class=\"pl-k\">if</span> i <span class=\"pl-k\">==</span> <span class=\"pl-c1\">0</span> <span class=\"pl-k\">else</span> <span class=\"pl-k\">lambda</span>: prev_case,\n            <span class=\"pl-v\">name</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span>If_<span class=\"pl-c1\">%d</span><span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">%</span> i)\n      <span class=\"pl-k\">return</span> prev_case\n<span class=\"pl-c1\">...</span></pre></div>\n<p>The op works by evaluating a series of predicates (including a predicate for the default value) but it starts off with an empty object. The empty object seems to be designed to pass on correct shape and type information but it fails to do so in my use case. I recommend changing this code to read:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-c1\">...</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> preds = [p1, p2, p3]</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> fns = [f1, f2, f3]</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> not_preds = [~p1, ~p2, ~p3]</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> and_not_preds = [True, ~p1, ~p1 &amp; ~p2, ~p1 &amp; ~p2 &amp; ~p3]</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> case_preds = [p1,</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span>               p2 &amp; ~p1,</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span>               p3 &amp; ~p2 &amp; ~p1]</span>\n\n    case_preds <span class=\"pl-k\">=</span> []\n    <span class=\"pl-k\">for</span> i, (p, and_not_p_prev) <span class=\"pl-k\">in</span> <span class=\"pl-c1\">enumerate</span>(<span class=\"pl-c1\">zip</span>(preds, and_not_preds[:<span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>])):\n      <span class=\"pl-k\">with</span> ops.name_scope(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>case_<span class=\"pl-c1\">%d</span><span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">%</span> i):\n        case_preds.append(math_ops.logical_and(p, and_not_p_prev))\n\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> case_sequence = [</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span>   cond(p3 &amp; ~p2 &amp; ~p1, f3, default),</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span>   cond(p2 &amp; ~p1, f2, lambda: case_sequence[0]),</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span>   cond(p1, f1, lambda: case_sequence[1])</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> ]</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span></span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> And the return value will be case_sequence[-1]</span>\n    <span class=\"pl-k\">def</span> <span class=\"pl-en\">_build_case</span>():\n      all_fns <span class=\"pl-k\">=</span> [fn <span class=\"pl-k\">for</span> fn <span class=\"pl-k\">in</span> fns]\n      prev_case <span class=\"pl-k\">=</span> <span class=\"pl-c1\">None</span>\n      <span class=\"pl-k\">for</span> i, (cp, fn) <span class=\"pl-k\">in</span> <span class=\"pl-c1\">enumerate</span>(<span class=\"pl-c1\">list</span>(<span class=\"pl-c1\">zip</span>(case_preds, all_fns))[::<span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>]):\n        prev_case <span class=\"pl-k\">=</span> cond(\n            cp, fn,\n            default <span class=\"pl-k\">if</span> prev_case <span class=\"pl-k\">is</span> <span class=\"pl-c1\">None</span> <span class=\"pl-k\">else</span> <span class=\"pl-k\">lambda</span>: prev_case,\n            <span class=\"pl-v\">name</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span>If_<span class=\"pl-c1\">%d</span><span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">%</span> i)\n      <span class=\"pl-k\">return</span> prev_case\n<span class=\"pl-c1\">...</span></pre></div>\n<p>This removes the need not only for creating a dummy empty op, but also removes the need to create a separate predicate for the default op, simplifying the whole op by about 18 lines of code.</p>", "body_text": "tf.case is a python implementation of a case statement using tf.cond, but unlike cond it doesn't preserve shape information when executing. This is because of this little snippet:\n...\n    # preds = [p1, p2, p3]\n    # fns = [f1, f2, f3]\n    # not_preds = [~p1, ~p2, ~p3]\n    # and_not_preds = [True, ~p1, ~p1 & ~p2, ~p1 & ~p2 & ~p3]\n    # case_preds = [p1,\n    #               p2 & ~p1,\n    #               p3 & ~p2 & ~p1,\n    #              ~p3 & ~p2 & ~p1]\n\n    case_preds = []\n    for i, (p, and_not_p_prev) in enumerate(zip(preds, and_not_preds[:-1])):\n      with ops.name_scope(\"case_%d\" % i):\n        case_preds.append(math_ops.logical_and(p, and_not_p_prev))\n    with ops.name_scope(\"case_none_are_true\"):\n      case_preds.append(and_not_preds[-1])\n\n    # Create an empty tensor, or list, with the right type and shape\n    with ops.name_scope(\"case_create_empty\"):\n      dummy_value = default()\n      def _correct_empty(v):\n        if isinstance(v, ops.Operation):\n          return no_op()\n        elif v.dtype == dtypes.string:\n          return array_ops.constant(\"\")\n        else:\n          return array_ops.constant(v.dtype.as_numpy_dtype())\n\n      if isinstance(dummy_value, collections.Sequence):\n        dummy_type = type(dummy_value)\n        empty = lambda: dummy_type(_correct_empty(v) for v in dummy_value)\n      else:\n        empty = lambda: _correct_empty(dummy_value)\n\n    # case_sequence = [\n    #   cond(~p3 & ~p2 & ~p1, default, empty),\n    #   cond(p3 & ~p2 & ~p1, f3, lambda: case_sequence[0]),\n    #   cond(p2 & ~p1, f2, lambda: case_sequence[1]),\n    #   cond(p1, f1, lambda: case_sequence[2])\n    # ]\n    #\n    # And the return value will be case_sequence[-1]\n    def _build_case():\n      all_fns = [fn for fn in fns]\n      all_fns.append(default)\n      prev_case = None\n      for i, (cp, fn) in enumerate(list(zip(case_preds, all_fns))[::-1]):\n        prev_case = cond(\n            cp, fn,\n            empty if i == 0 else lambda: prev_case,\n            name=\"If_%d\" % i)\n      return prev_case\n...\nThe op works by evaluating a series of predicates (including a predicate for the default value) but it starts off with an empty object. The empty object seems to be designed to pass on correct shape and type information but it fails to do so in my use case. I recommend changing this code to read:\n...\n    # preds = [p1, p2, p3]\n    # fns = [f1, f2, f3]\n    # not_preds = [~p1, ~p2, ~p3]\n    # and_not_preds = [True, ~p1, ~p1 & ~p2, ~p1 & ~p2 & ~p3]\n    # case_preds = [p1,\n    #               p2 & ~p1,\n    #               p3 & ~p2 & ~p1]\n\n    case_preds = []\n    for i, (p, and_not_p_prev) in enumerate(zip(preds, and_not_preds[:-1])):\n      with ops.name_scope(\"case_%d\" % i):\n        case_preds.append(math_ops.logical_and(p, and_not_p_prev))\n\n    # case_sequence = [\n    #   cond(p3 & ~p2 & ~p1, f3, default),\n    #   cond(p2 & ~p1, f2, lambda: case_sequence[0]),\n    #   cond(p1, f1, lambda: case_sequence[1])\n    # ]\n    #\n    # And the return value will be case_sequence[-1]\n    def _build_case():\n      all_fns = [fn for fn in fns]\n      prev_case = None\n      for i, (cp, fn) in enumerate(list(zip(case_preds, all_fns))[::-1]):\n        prev_case = cond(\n            cp, fn,\n            default if prev_case is None else lambda: prev_case,\n            name=\"If_%d\" % i)\n      return prev_case\n...\nThis removes the need not only for creating a dummy empty op, but also removes the need to create a separate predicate for the default op, simplifying the whole op by about 18 lines of code.", "body": "tf.case is a python implementation of a case statement using tf.cond, but unlike cond it doesn't preserve shape information when executing. This is because of this little snippet:\n\n``` python\n...\n    # preds = [p1, p2, p3]\n    # fns = [f1, f2, f3]\n    # not_preds = [~p1, ~p2, ~p3]\n    # and_not_preds = [True, ~p1, ~p1 & ~p2, ~p1 & ~p2 & ~p3]\n    # case_preds = [p1,\n    #               p2 & ~p1,\n    #               p3 & ~p2 & ~p1,\n    #              ~p3 & ~p2 & ~p1]\n\n    case_preds = []\n    for i, (p, and_not_p_prev) in enumerate(zip(preds, and_not_preds[:-1])):\n      with ops.name_scope(\"case_%d\" % i):\n        case_preds.append(math_ops.logical_and(p, and_not_p_prev))\n    with ops.name_scope(\"case_none_are_true\"):\n      case_preds.append(and_not_preds[-1])\n\n    # Create an empty tensor, or list, with the right type and shape\n    with ops.name_scope(\"case_create_empty\"):\n      dummy_value = default()\n      def _correct_empty(v):\n        if isinstance(v, ops.Operation):\n          return no_op()\n        elif v.dtype == dtypes.string:\n          return array_ops.constant(\"\")\n        else:\n          return array_ops.constant(v.dtype.as_numpy_dtype())\n\n      if isinstance(dummy_value, collections.Sequence):\n        dummy_type = type(dummy_value)\n        empty = lambda: dummy_type(_correct_empty(v) for v in dummy_value)\n      else:\n        empty = lambda: _correct_empty(dummy_value)\n\n    # case_sequence = [\n    #   cond(~p3 & ~p2 & ~p1, default, empty),\n    #   cond(p3 & ~p2 & ~p1, f3, lambda: case_sequence[0]),\n    #   cond(p2 & ~p1, f2, lambda: case_sequence[1]),\n    #   cond(p1, f1, lambda: case_sequence[2])\n    # ]\n    #\n    # And the return value will be case_sequence[-1]\n    def _build_case():\n      all_fns = [fn for fn in fns]\n      all_fns.append(default)\n      prev_case = None\n      for i, (cp, fn) in enumerate(list(zip(case_preds, all_fns))[::-1]):\n        prev_case = cond(\n            cp, fn,\n            empty if i == 0 else lambda: prev_case,\n            name=\"If_%d\" % i)\n      return prev_case\n...\n```\n\nThe op works by evaluating a series of predicates (including a predicate for the default value) but it starts off with an empty object. The empty object seems to be designed to pass on correct shape and type information but it fails to do so in my use case. I recommend changing this code to read:\n\n``` python\n...\n    # preds = [p1, p2, p3]\n    # fns = [f1, f2, f3]\n    # not_preds = [~p1, ~p2, ~p3]\n    # and_not_preds = [True, ~p1, ~p1 & ~p2, ~p1 & ~p2 & ~p3]\n    # case_preds = [p1,\n    #               p2 & ~p1,\n    #               p3 & ~p2 & ~p1]\n\n    case_preds = []\n    for i, (p, and_not_p_prev) in enumerate(zip(preds, and_not_preds[:-1])):\n      with ops.name_scope(\"case_%d\" % i):\n        case_preds.append(math_ops.logical_and(p, and_not_p_prev))\n\n    # case_sequence = [\n    #   cond(p3 & ~p2 & ~p1, f3, default),\n    #   cond(p2 & ~p1, f2, lambda: case_sequence[0]),\n    #   cond(p1, f1, lambda: case_sequence[1])\n    # ]\n    #\n    # And the return value will be case_sequence[-1]\n    def _build_case():\n      all_fns = [fn for fn in fns]\n      prev_case = None\n      for i, (cp, fn) in enumerate(list(zip(case_preds, all_fns))[::-1]):\n        prev_case = cond(\n            cp, fn,\n            default if prev_case is None else lambda: prev_case,\n            name=\"If_%d\" % i)\n      return prev_case\n...\n```\n\nThis removes the need not only for creating a dummy empty op, but also removes the need to create a separate predicate for the default op, simplifying the whole op by about 18 lines of code.\n"}