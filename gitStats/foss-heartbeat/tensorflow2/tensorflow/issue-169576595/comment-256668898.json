{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/256668898", "html_url": "https://github.com/tensorflow/tensorflow/issues/3663#issuecomment-256668898", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/3663", "id": 256668898, "node_id": "MDEyOklzc3VlQ29tbWVudDI1NjY2ODg5OA==", "user": {"login": "davidbuniat", "id": 7069390, "node_id": "MDQ6VXNlcjcwNjkzOTA=", "avatar_url": "https://avatars0.githubusercontent.com/u/7069390?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidbuniat", "html_url": "https://github.com/davidbuniat", "followers_url": "https://api.github.com/users/davidbuniat/followers", "following_url": "https://api.github.com/users/davidbuniat/following{/other_user}", "gists_url": "https://api.github.com/users/davidbuniat/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidbuniat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidbuniat/subscriptions", "organizations_url": "https://api.github.com/users/davidbuniat/orgs", "repos_url": "https://api.github.com/users/davidbuniat/repos", "events_url": "https://api.github.com/users/davidbuniat/events{/privacy}", "received_events_url": "https://api.github.com/users/davidbuniat/received_events", "type": "User", "site_admin": false}, "created_at": "2016-10-27T15:07:21Z", "updated_at": "2016-10-27T15:38:46Z", "author_association": "NONE", "body_html": "<p>I simplified the case as much as I could</p>\n<pre><code>inputs_ta = tf.TensorArray(dtype=tf.float32, size=args.width*args.height)\ninputs_ta = inputs_ta.unpack(inputs)\n</code></pre>\n<pre><code>def loop_fn(time, cell_output, cell_state, loop_state):\n    emit_output = cell_output\n    if loop_state == None:\n        loop_state = tf.TensorArray(dtype=tf.float32, size=args.width*args.height)\n        for i in xrange(args.width*args.height):\n            loop_state.write(i, cell.zero_state(args.batch_size, tf.float32))\n\n    elements_finished = True\n    next_input = inputs_ta.read(time)\n\n    next_cell_state = loop_state.read(time)\n    next_loop_state = loop_state\n    return (elements_finished, next_input, next_cell_state,\n            emit_output, next_loop_state)\n</code></pre>\n<p>and this produces the following error</p>\n<pre><code>...\nInvalidArgumentError (see above for traceback): TensorArray content_vgg/gridrnn_1/RNN/TensorArray_0: Could not read from TensorArray index 0 because it has not yet been written to.\n     [[Node: content_vgg/gridrnn_1/RNN/TensorArrayRead_1 = TensorArrayRead[_class=[\"loc:@content_vgg/gridrnn_1/RNN/TensorArray\"], dtype=DT_FLOAT, _device=\"/job:localhost/replica:0/task:0/cpu:0\"](content_vgg/gridrnn_1/RNN/TensorArray, content_vgg/gridrnn_1/RNN/Const, content_vgg/gridrnn_1/RNN/TensorArray/Const)]]\n\n</code></pre>", "body_text": "I simplified the case as much as I could\ninputs_ta = tf.TensorArray(dtype=tf.float32, size=args.width*args.height)\ninputs_ta = inputs_ta.unpack(inputs)\n\ndef loop_fn(time, cell_output, cell_state, loop_state):\n    emit_output = cell_output\n    if loop_state == None:\n        loop_state = tf.TensorArray(dtype=tf.float32, size=args.width*args.height)\n        for i in xrange(args.width*args.height):\n            loop_state.write(i, cell.zero_state(args.batch_size, tf.float32))\n\n    elements_finished = True\n    next_input = inputs_ta.read(time)\n\n    next_cell_state = loop_state.read(time)\n    next_loop_state = loop_state\n    return (elements_finished, next_input, next_cell_state,\n            emit_output, next_loop_state)\n\nand this produces the following error\n...\nInvalidArgumentError (see above for traceback): TensorArray content_vgg/gridrnn_1/RNN/TensorArray_0: Could not read from TensorArray index 0 because it has not yet been written to.\n     [[Node: content_vgg/gridrnn_1/RNN/TensorArrayRead_1 = TensorArrayRead[_class=[\"loc:@content_vgg/gridrnn_1/RNN/TensorArray\"], dtype=DT_FLOAT, _device=\"/job:localhost/replica:0/task:0/cpu:0\"](content_vgg/gridrnn_1/RNN/TensorArray, content_vgg/gridrnn_1/RNN/Const, content_vgg/gridrnn_1/RNN/TensorArray/Const)]]", "body": "I simplified the case as much as I could\n\n```\ninputs_ta = tf.TensorArray(dtype=tf.float32, size=args.width*args.height)\ninputs_ta = inputs_ta.unpack(inputs)\n```\n\n```\ndef loop_fn(time, cell_output, cell_state, loop_state):\n    emit_output = cell_output\n    if loop_state == None:\n        loop_state = tf.TensorArray(dtype=tf.float32, size=args.width*args.height)\n        for i in xrange(args.width*args.height):\n            loop_state.write(i, cell.zero_state(args.batch_size, tf.float32))\n\n    elements_finished = True\n    next_input = inputs_ta.read(time)\n\n    next_cell_state = loop_state.read(time)\n    next_loop_state = loop_state\n    return (elements_finished, next_input, next_cell_state,\n            emit_output, next_loop_state)\n```\n\nand this produces the following error\n\n```\n...\nInvalidArgumentError (see above for traceback): TensorArray content_vgg/gridrnn_1/RNN/TensorArray_0: Could not read from TensorArray index 0 because it has not yet been written to.\n     [[Node: content_vgg/gridrnn_1/RNN/TensorArrayRead_1 = TensorArrayRead[_class=[\"loc:@content_vgg/gridrnn_1/RNN/TensorArray\"], dtype=DT_FLOAT, _device=\"/job:localhost/replica:0/task:0/cpu:0\"](content_vgg/gridrnn_1/RNN/TensorArray, content_vgg/gridrnn_1/RNN/Const, content_vgg/gridrnn_1/RNN/TensorArray/Const)]]\n\n```\n"}