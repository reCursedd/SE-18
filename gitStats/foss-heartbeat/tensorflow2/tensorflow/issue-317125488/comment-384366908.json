{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/384366908", "html_url": "https://github.com/tensorflow/tensorflow/issues/18823#issuecomment-384366908", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/18823", "id": 384366908, "node_id": "MDEyOklzc3VlQ29tbWVudDM4NDM2NjkwOA==", "user": {"login": "michaelschaarschmidt", "id": 22558112, "node_id": "MDQ6VXNlcjIyNTU4MTEy", "avatar_url": "https://avatars1.githubusercontent.com/u/22558112?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelschaarschmidt", "html_url": "https://github.com/michaelschaarschmidt", "followers_url": "https://api.github.com/users/michaelschaarschmidt/followers", "following_url": "https://api.github.com/users/michaelschaarschmidt/following{/other_user}", "gists_url": "https://api.github.com/users/michaelschaarschmidt/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelschaarschmidt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelschaarschmidt/subscriptions", "organizations_url": "https://api.github.com/users/michaelschaarschmidt/orgs", "repos_url": "https://api.github.com/users/michaelschaarschmidt/repos", "events_url": "https://api.github.com/users/michaelschaarschmidt/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelschaarschmidt/received_events", "type": "User", "site_admin": false}, "created_at": "2018-04-25T17:23:07Z", "updated_at": "2018-04-25T17:23:07Z", "author_association": "NONE", "body_html": "<p>Yes, this is exactly what I am referring to, thank you very much!</p>\n<p>Just to help you understand the types of use cases I am thinking about, this is a (rather messy) pure TensorFlow prioritized replay implementation with two buffers and sampling logic:</p>\n<p><a href=\"https://github.com/reinforceio/tensorforce/blob/master/tensorforce/core/memories/prioritized_replay.py\">https://github.com/reinforceio/tensorforce/blob/master/tensorforce/core/memories/prioritized_replay.py</a></p>\n<p>So there is  fair number of variables, elements arriving into an initial buffer, being moved into a memory once their losses are available, sampling from them, and resorting according to priorities.<br>\nYou can see that the implementation is rather bloated by the assigns and scatter updates which makes it difficult to read.</p>\n<p>Ultimately it would be great if features like these could be done with autograph, so the main issue is reading and writing back to various variables with features such as the variable-to-list read you suggested.</p>", "body_text": "Yes, this is exactly what I am referring to, thank you very much!\nJust to help you understand the types of use cases I am thinking about, this is a (rather messy) pure TensorFlow prioritized replay implementation with two buffers and sampling logic:\nhttps://github.com/reinforceio/tensorforce/blob/master/tensorforce/core/memories/prioritized_replay.py\nSo there is  fair number of variables, elements arriving into an initial buffer, being moved into a memory once their losses are available, sampling from them, and resorting according to priorities.\nYou can see that the implementation is rather bloated by the assigns and scatter updates which makes it difficult to read.\nUltimately it would be great if features like these could be done with autograph, so the main issue is reading and writing back to various variables with features such as the variable-to-list read you suggested.", "body": "Yes, this is exactly what I am referring to, thank you very much!\r\n\r\nJust to help you understand the types of use cases I am thinking about, this is a (rather messy) pure TensorFlow prioritized replay implementation with two buffers and sampling logic: \r\n\r\nhttps://github.com/reinforceio/tensorforce/blob/master/tensorforce/core/memories/prioritized_replay.py\r\n\r\nSo there is  fair number of variables, elements arriving into an initial buffer, being moved into a memory once their losses are available, sampling from them, and resorting according to priorities. \r\nYou can see that the implementation is rather bloated by the assigns and scatter updates which makes it difficult to read.\r\n\r\nUltimately it would be great if features like these could be done with autograph, so the main issue is reading and writing back to various variables with features such as the variable-to-list read you suggested.\r\n\r\n"}