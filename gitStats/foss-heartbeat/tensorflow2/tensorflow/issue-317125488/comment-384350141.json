{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/384350141", "html_url": "https://github.com/tensorflow/tensorflow/issues/18823#issuecomment-384350141", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/18823", "id": 384350141, "node_id": "MDEyOklzc3VlQ29tbWVudDM4NDM1MDE0MQ==", "user": {"login": "mdanatg", "id": 26628547, "node_id": "MDQ6VXNlcjI2NjI4NTQ3", "avatar_url": "https://avatars1.githubusercontent.com/u/26628547?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mdanatg", "html_url": "https://github.com/mdanatg", "followers_url": "https://api.github.com/users/mdanatg/followers", "following_url": "https://api.github.com/users/mdanatg/following{/other_user}", "gists_url": "https://api.github.com/users/mdanatg/gists{/gist_id}", "starred_url": "https://api.github.com/users/mdanatg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mdanatg/subscriptions", "organizations_url": "https://api.github.com/users/mdanatg/orgs", "repos_url": "https://api.github.com/users/mdanatg/repos", "events_url": "https://api.github.com/users/mdanatg/events{/privacy}", "received_events_url": "https://api.github.com/users/mdanatg/received_events", "type": "User", "site_admin": false}, "created_at": "2018-04-25T16:31:07Z", "updated_at": "2018-04-25T16:31:07Z", "author_association": "CONTRIBUTOR", "body_html": "<p>I see. Do you mean something in these lines perhaps?</p>\n<p>(currently we've been focusing on Tensor lists, e.g. TensorArray, but we definitely intend to support Variables, so this discussion is useful for us to make sure we understand the use case well)</p>\n<pre><code># Note: the prints below use py_func. Remove them if py_func is not available.\ndef insert(buffer, buffer_head, element):\n  print('Buffer before:', buffer)\n  tf.scatter_update(buffer, [buffer_head], [element])\n  tf.assign_add(buffer_head, 1)\n  # Need tf.identity because Variables are not subject to control dependencies.\n  print('Buffer after:', tf.identity(buffer))\n  # We just need an op to group together the assigns done in this body.\n  return tf.no_op()\n\ninsert_fn = autograph.to_graph(insert, verbose=True)\n\nwith tf.Graph().as_default():\n  capacity = 5\n  buffer = tf.get_variable('buffer', shape=(capacity,), initializer=tf.zeros_initializer(), dtype=tf.float32)\n  buffer_head = tf.get_variable('buffer_head', shape=(), dtype=tf.int32)\n  \n  make_an_insert = insert_fn(buffer, buffer_head, 3.0)\n\n  with tf.Session() as sess:\n    sess.run(tf.global_variables_initializer())\n    sess.run(make_an_insert)\n    sess.run(make_an_insert)\n</code></pre>\n<p>Assuming my understanding is correct, we could envision letting you do something in these lines:</p>\n<pre><code>def insert(buffer, buffer_head, element):\n  magic_list = autograph.util.variable_backed_list(buffer, buffer_head)\n  # AutoGraph would generate all the necessary variable assigns and scatter updates.\n  magic_list.append(element)\n</code></pre>", "body_text": "I see. Do you mean something in these lines perhaps?\n(currently we've been focusing on Tensor lists, e.g. TensorArray, but we definitely intend to support Variables, so this discussion is useful for us to make sure we understand the use case well)\n# Note: the prints below use py_func. Remove them if py_func is not available.\ndef insert(buffer, buffer_head, element):\n  print('Buffer before:', buffer)\n  tf.scatter_update(buffer, [buffer_head], [element])\n  tf.assign_add(buffer_head, 1)\n  # Need tf.identity because Variables are not subject to control dependencies.\n  print('Buffer after:', tf.identity(buffer))\n  # We just need an op to group together the assigns done in this body.\n  return tf.no_op()\n\ninsert_fn = autograph.to_graph(insert, verbose=True)\n\nwith tf.Graph().as_default():\n  capacity = 5\n  buffer = tf.get_variable('buffer', shape=(capacity,), initializer=tf.zeros_initializer(), dtype=tf.float32)\n  buffer_head = tf.get_variable('buffer_head', shape=(), dtype=tf.int32)\n  \n  make_an_insert = insert_fn(buffer, buffer_head, 3.0)\n\n  with tf.Session() as sess:\n    sess.run(tf.global_variables_initializer())\n    sess.run(make_an_insert)\n    sess.run(make_an_insert)\n\nAssuming my understanding is correct, we could envision letting you do something in these lines:\ndef insert(buffer, buffer_head, element):\n  magic_list = autograph.util.variable_backed_list(buffer, buffer_head)\n  # AutoGraph would generate all the necessary variable assigns and scatter updates.\n  magic_list.append(element)", "body": "I see. Do you mean something in these lines perhaps?\r\n\r\n(currently we've been focusing on Tensor lists, e.g. TensorArray, but we definitely intend to support Variables, so this discussion is useful for us to make sure we understand the use case well)\r\n\r\n```\r\n# Note: the prints below use py_func. Remove them if py_func is not available.\r\ndef insert(buffer, buffer_head, element):\r\n  print('Buffer before:', buffer)\r\n  tf.scatter_update(buffer, [buffer_head], [element])\r\n  tf.assign_add(buffer_head, 1)\r\n  # Need tf.identity because Variables are not subject to control dependencies.\r\n  print('Buffer after:', tf.identity(buffer))\r\n  # We just need an op to group together the assigns done in this body.\r\n  return tf.no_op()\r\n\r\ninsert_fn = autograph.to_graph(insert, verbose=True)\r\n\r\nwith tf.Graph().as_default():\r\n  capacity = 5\r\n  buffer = tf.get_variable('buffer', shape=(capacity,), initializer=tf.zeros_initializer(), dtype=tf.float32)\r\n  buffer_head = tf.get_variable('buffer_head', shape=(), dtype=tf.int32)\r\n  \r\n  make_an_insert = insert_fn(buffer, buffer_head, 3.0)\r\n\r\n  with tf.Session() as sess:\r\n    sess.run(tf.global_variables_initializer())\r\n    sess.run(make_an_insert)\r\n    sess.run(make_an_insert)\r\n```\r\n\r\nAssuming my understanding is correct, we could envision letting you do something in these lines:\r\n\r\n```\r\ndef insert(buffer, buffer_head, element):\r\n  magic_list = autograph.util.variable_backed_list(buffer, buffer_head)\r\n  # AutoGraph would generate all the necessary variable assigns and scatter updates.\r\n  magic_list.append(element)\r\n```"}