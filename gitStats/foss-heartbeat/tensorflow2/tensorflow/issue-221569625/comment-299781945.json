{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/299781945", "html_url": "https://github.com/tensorflow/tensorflow/pull/9189#issuecomment-299781945", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9189", "id": 299781945, "node_id": "MDEyOklzc3VlQ29tbWVudDI5OTc4MTk0NQ==", "user": {"login": "gaohuazuo", "id": 10446514, "node_id": "MDQ6VXNlcjEwNDQ2NTE0", "avatar_url": "https://avatars0.githubusercontent.com/u/10446514?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gaohuazuo", "html_url": "https://github.com/gaohuazuo", "followers_url": "https://api.github.com/users/gaohuazuo/followers", "following_url": "https://api.github.com/users/gaohuazuo/following{/other_user}", "gists_url": "https://api.github.com/users/gaohuazuo/gists{/gist_id}", "starred_url": "https://api.github.com/users/gaohuazuo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gaohuazuo/subscriptions", "organizations_url": "https://api.github.com/users/gaohuazuo/orgs", "repos_url": "https://api.github.com/users/gaohuazuo/repos", "events_url": "https://api.github.com/users/gaohuazuo/events{/privacy}", "received_events_url": "https://api.github.com/users/gaohuazuo/received_events", "type": "User", "site_admin": false}, "created_at": "2017-05-08T06:15:37Z", "updated_at": "2017-05-09T13:05:04Z", "author_association": "CONTRIBUTOR", "body_html": "<h2><code>control_flow_ops_py_test</code> Result</h2>\n<p><code>bazel test -c dbg --config cuda //tensorflow/python/kernel_tests:control_flow_ops_py_test</code></p>\n<ul>\n<li>\n<p><del>testCondGrad_1</del><br>\n<del><code>LookupError: No gradient defined for operation 'select/Mux' (op type: Mux)</code></del></p>\n</li>\n<li>\n<p><del>testCondGrad_2</del><br>\n<del><code>LookupError: No gradient defined for operation 'select/Mux' (op type: Mux)</code></del></p>\n</li>\n<li>\n<p><del>testCondGrad_Gather</del><br>\n<del><code>LookupError: No gradient defined for operation 'select/Mux' (op type: Mux)</code></del></p>\n</li>\n<li>\n<p><del>testCondIndexedSlices</del><br>\n<del><code>ValueError: Tensor conversion requested for IndexedSlices without dense_shape: IndexedSlices(indices=Tensor(\"Const_1:0\", shape=(), dtype=int32, device=/device:CPU:0), values=Tensor(\"Add:0\", shape=(), dtype=int32, device=/device:CPU:0))</code></del></p>\n</li>\n<li>\n<p>testCondIndexedSlicesDifferentTypes<br>\n<del><code>ValueError: Tensor conversion requested for IndexedSlices without dense_shape: IndexedSlices(indices=Tensor(\"one:0\", shape=(), dtype=int32, device=/device:CPU:0), values=Tensor(\"Add:0\", shape=(), dtype=int32, device=/device:CPU:0))</code></del></p>\n<p><code>TypeError: Tensors in list passed to 'inputs' of 'Mux' Op have types [int64, int32] that don't all match.</code></p>\n</li>\n<li>\n<p><del>testCondRef</del><br>\n<del><code>ValueError: Input tensors must have the same dtype.</code></del></p>\n</li>\n<li>\n<p><del>testCondSparseTensor</del><br>\n<del><code>TypeError: Expected binary or unicode string, got &lt;tensorflow.python.framework.sparse_tensor.SparseTensor object at 0x7fa52815a898&gt;</code></del></p>\n</li>\n<li>\n<p><del>testCondWhile_3</del><br>\n<del><code>LookupError: No gradient defined for operation 'select/Mux' (op type: Mux)</code></del></p>\n</li>\n<li>\n<p><del>testNestedCond_Simple</del><br>\n<del><code>LookupError: No gradient defined for operation 'select_1/Mux' (op type: Mux)</code></del></p>\n</li>\n<li>\n<p><del>testNestedWhileCondWhileGrad</del><br>\n<del><code>LookupError: No gradient defined for operation 'while/select/Mux' (op type: Mux)</code></del></p>\n</li>\n<li>\n<p><del>testWhileCondGrad_Simple</del><br>\n<del><code>LookupError: No gradient defined for operation 'while/select/Mux' (op type: Mux)</code></del></p>\n</li>\n<li>\n<p><del>testWhileCondGrad_UnknownShape</del><br>\n<del><code>LookupError: No gradient defined for operation 'while/select/Mux' (op type: Mux)</code></del></p>\n</li>\n<li>\n<p><del>testWhileGrad_Square</del><br>\n<del><code>LookupError: No gradient defined for operation 'select/Mux' (op type: Mux)</code></del></p>\n</li>\n<li>\n<p>testCond_4</p>\n<pre><code>AssertionError: Tuples differ: () != (0,)\n\nSecond tuple contains 1 additional elements.\nFirst extra element 0:\n0\n\n- ()\n+ (0,) : Shape mismatch: expected (), got (0,).\n</code></pre>\n</li>\n</ul>\n<h3>Summary</h3>\n<ul>\n<li>\n<p><del><code>tf.select</code> and <code>tf.cond_v2</code> does not handle <code>IndexedSlice</code> and <code>SparseTensor</code> properly.</del><br>\n<del>Accounts for <code>testCondIndexedSlices</code>,<code>testCondIndexedSlicesDifferentTypes</code> and <code>testCondSparseTensor</code>.</del><br>\n<del>I am not very familiar with <code>IndexedSlice</code> and <code>SparseTensor</code>, so I need to study further to provide a fix.</del></p>\n</li>\n<li>\n<p><del><code>tf.select</code> does not handle ref dtypes properly.</del><br>\n<del>Accounts for <code>testCondRef</code>.</del><br>\n<del>Possible fix would be adding a <code>RefMux</code> op and some handling in python <code>select</code> function.</del></p>\n</li>\n<li>\n<p>When an input is an <code>tf.Operation</code>, <code>tf.cond</code> produces a scalar bool tensor whereas <code>tf.cond_v2</code> produces an empty float tensor. This is just a minor change and any sane application should not rely on it.<br>\nAccounts for <code>testCond_4</code>.</p>\n</li>\n<li>\n<p><del><code>Mux</code> op has no gradient.</del><br>\n<del>Accounts for other failed tests.</del><br>\n<del>Possible fix would be adding a gradient function or modifying <code>tf.gradients</code>. Simply registering a gradient function should work, but is less efficient.</del></p>\n</li>\n</ul>\n<h3>Some questions</h3>\n<ul>\n<li>\n<p>Some op kernels, <code>Merge</code> for example, require that all int32 inputs reside in host memory. Why? Should I do the same?</p>\n</li>\n<li>\n<p>Which contrib module should I add <code>select</code> and <code>cond</code> to? Or should I create a new contrib module?</p>\n</li>\n</ul>", "body_text": "control_flow_ops_py_test Result\nbazel test -c dbg --config cuda //tensorflow/python/kernel_tests:control_flow_ops_py_test\n\n\ntestCondGrad_1\nLookupError: No gradient defined for operation 'select/Mux' (op type: Mux)\n\n\ntestCondGrad_2\nLookupError: No gradient defined for operation 'select/Mux' (op type: Mux)\n\n\ntestCondGrad_Gather\nLookupError: No gradient defined for operation 'select/Mux' (op type: Mux)\n\n\ntestCondIndexedSlices\nValueError: Tensor conversion requested for IndexedSlices without dense_shape: IndexedSlices(indices=Tensor(\"Const_1:0\", shape=(), dtype=int32, device=/device:CPU:0), values=Tensor(\"Add:0\", shape=(), dtype=int32, device=/device:CPU:0))\n\n\ntestCondIndexedSlicesDifferentTypes\nValueError: Tensor conversion requested for IndexedSlices without dense_shape: IndexedSlices(indices=Tensor(\"one:0\", shape=(), dtype=int32, device=/device:CPU:0), values=Tensor(\"Add:0\", shape=(), dtype=int32, device=/device:CPU:0))\nTypeError: Tensors in list passed to 'inputs' of 'Mux' Op have types [int64, int32] that don't all match.\n\n\ntestCondRef\nValueError: Input tensors must have the same dtype.\n\n\ntestCondSparseTensor\nTypeError: Expected binary or unicode string, got <tensorflow.python.framework.sparse_tensor.SparseTensor object at 0x7fa52815a898>\n\n\ntestCondWhile_3\nLookupError: No gradient defined for operation 'select/Mux' (op type: Mux)\n\n\ntestNestedCond_Simple\nLookupError: No gradient defined for operation 'select_1/Mux' (op type: Mux)\n\n\ntestNestedWhileCondWhileGrad\nLookupError: No gradient defined for operation 'while/select/Mux' (op type: Mux)\n\n\ntestWhileCondGrad_Simple\nLookupError: No gradient defined for operation 'while/select/Mux' (op type: Mux)\n\n\ntestWhileCondGrad_UnknownShape\nLookupError: No gradient defined for operation 'while/select/Mux' (op type: Mux)\n\n\ntestWhileGrad_Square\nLookupError: No gradient defined for operation 'select/Mux' (op type: Mux)\n\n\ntestCond_4\nAssertionError: Tuples differ: () != (0,)\n\nSecond tuple contains 1 additional elements.\nFirst extra element 0:\n0\n\n- ()\n+ (0,) : Shape mismatch: expected (), got (0,).\n\n\n\nSummary\n\n\ntf.select and tf.cond_v2 does not handle IndexedSlice and SparseTensor properly.\nAccounts for testCondIndexedSlices,testCondIndexedSlicesDifferentTypes and testCondSparseTensor.\nI am not very familiar with IndexedSlice and SparseTensor, so I need to study further to provide a fix.\n\n\ntf.select does not handle ref dtypes properly.\nAccounts for testCondRef.\nPossible fix would be adding a RefMux op and some handling in python select function.\n\n\nWhen an input is an tf.Operation, tf.cond produces a scalar bool tensor whereas tf.cond_v2 produces an empty float tensor. This is just a minor change and any sane application should not rely on it.\nAccounts for testCond_4.\n\n\nMux op has no gradient.\nAccounts for other failed tests.\nPossible fix would be adding a gradient function or modifying tf.gradients. Simply registering a gradient function should work, but is less efficient.\n\n\nSome questions\n\n\nSome op kernels, Merge for example, require that all int32 inputs reside in host memory. Why? Should I do the same?\n\n\nWhich contrib module should I add select and cond to? Or should I create a new contrib module?", "body": "## `control_flow_ops_py_test` Result\r\n\r\n`bazel test -c dbg --config cuda //tensorflow/python/kernel_tests:control_flow_ops_py_test`\r\n\r\n* <del>testCondGrad_1</del>\r\n    <del>`LookupError: No gradient defined for operation 'select/Mux' (op type: Mux)`</del>\r\n\r\n* <del>testCondGrad_2</del>\r\n    <del>`LookupError: No gradient defined for operation 'select/Mux' (op type: Mux)`</del>\r\n\r\n* <del>testCondGrad_Gather</del>\r\n    <del>`LookupError: No gradient defined for operation 'select/Mux' (op type: Mux)`</del>\r\n\r\n* <del>testCondIndexedSlices</del>\r\n    <del>`ValueError: Tensor conversion requested for IndexedSlices without dense_shape: IndexedSlices(indices=Tensor(\"Const_1:0\", shape=(), dtype=int32, device=/device:CPU:0), values=Tensor(\"Add:0\", shape=(), dtype=int32, device=/device:CPU:0))`</del>\r\n\r\n* testCondIndexedSlicesDifferentTypes\r\n    <del>`ValueError: Tensor conversion requested for IndexedSlices without dense_shape: IndexedSlices(indices=Tensor(\"one:0\", shape=(), dtype=int32, device=/device:CPU:0), values=Tensor(\"Add:0\", shape=(), dtype=int32, device=/device:CPU:0))`</del>\r\n\r\n    `TypeError: Tensors in list passed to 'inputs' of 'Mux' Op have types [int64, int32] that don't all match.`\r\n\r\n* <del>testCondRef</del>\r\n    <del>`ValueError: Input tensors must have the same dtype.`</del>\r\n\r\n* <del>testCondSparseTensor</del>\r\n    <del>`TypeError: Expected binary or unicode string, got <tensorflow.python.framework.sparse_tensor.SparseTensor object at 0x7fa52815a898>`</del>\r\n\r\n* <del>testCondWhile_3</del>\r\n    <del>`LookupError: No gradient defined for operation 'select/Mux' (op type: Mux)`</del>\r\n\r\n* <del>testNestedCond_Simple</del>\r\n    <del>`LookupError: No gradient defined for operation 'select_1/Mux' (op type: Mux)`</del>\r\n\r\n* <del>testNestedWhileCondWhileGrad</del>\r\n    <del>`LookupError: No gradient defined for operation 'while/select/Mux' (op type: Mux)`</del>\r\n\r\n* <del>testWhileCondGrad_Simple</del>\r\n    <del>`LookupError: No gradient defined for operation 'while/select/Mux' (op type: Mux)`</del>\r\n\r\n* <del>testWhileCondGrad_UnknownShape</del>\r\n    <del>`LookupError: No gradient defined for operation 'while/select/Mux' (op type: Mux)`</del>\r\n\r\n* <del>testWhileGrad_Square</del>\r\n    <del>`LookupError: No gradient defined for operation 'select/Mux' (op type: Mux)`</del>\r\n\r\n* testCond_4\r\n    ```\r\n    AssertionError: Tuples differ: () != (0,)\r\n\r\n    Second tuple contains 1 additional elements.\r\n    First extra element 0:\r\n    0\r\n\r\n    - ()\r\n    + (0,) : Shape mismatch: expected (), got (0,).\r\n    ```\r\n\r\n### Summary\r\n\r\n* <del>`tf.select` and `tf.cond_v2` does not handle `IndexedSlice` and `SparseTensor` properly.</del>\r\n    <del>Accounts for `testCondIndexedSlices`,`testCondIndexedSlicesDifferentTypes` and `testCondSparseTensor`.</del>\r\n   <del>I am not very familiar with `IndexedSlice` and `SparseTensor`, so I need to study further to provide a fix.</del>\r\n\r\n* <del>`tf.select` does not handle ref dtypes properly.</del>\r\n   <del>Accounts for `testCondRef`.</del>\r\n   <del>Possible fix would be adding a `RefMux` op and some handling in python `select` function.</del>\r\n\r\n* When an input is an `tf.Operation`, `tf.cond` produces a scalar bool tensor whereas `tf.cond_v2` produces an empty float tensor. This is just a minor change and any sane application should not rely on it.\r\n    Accounts for `testCond_4`.\r\n\r\n* <del>`Mux` op has no gradient.</del>\r\n    <del>Accounts for other failed tests.</del>\r\n   <del>Possible fix would be adding a gradient function or modifying `tf.gradients`. Simply registering a gradient function should work, but is less efficient.</del>\r\n\r\n### Some questions\r\n\r\n* Some op kernels, `Merge` for example, require that all int32 inputs reside in host memory. Why? Should I do the same?\r\n\r\n* Which contrib module should I add `select` and `cond` to? Or should I create a new contrib module?"}