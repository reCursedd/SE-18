{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/389018675", "html_url": "https://github.com/tensorflow/tensorflow/issues/19269#issuecomment-389018675", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/19269", "id": 389018675, "node_id": "MDEyOklzc3VlQ29tbWVudDM4OTAxODY3NQ==", "user": {"login": "mrry", "id": 192142, "node_id": "MDQ6VXNlcjE5MjE0Mg==", "avatar_url": "https://avatars1.githubusercontent.com/u/192142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mrry", "html_url": "https://github.com/mrry", "followers_url": "https://api.github.com/users/mrry/followers", "following_url": "https://api.github.com/users/mrry/following{/other_user}", "gists_url": "https://api.github.com/users/mrry/gists{/gist_id}", "starred_url": "https://api.github.com/users/mrry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mrry/subscriptions", "organizations_url": "https://api.github.com/users/mrry/orgs", "repos_url": "https://api.github.com/users/mrry/repos", "events_url": "https://api.github.com/users/mrry/events{/privacy}", "received_events_url": "https://api.github.com/users/mrry/received_events", "type": "User", "site_admin": false}, "created_at": "2018-05-15T02:01:06Z", "updated_at": "2018-05-15T02:01:06Z", "author_association": "CONTRIBUTOR", "body_html": "<p>The implementation has been submitted and will become available in the next sync. To work around the problem using <code>tf.py_func()</code> in a <code>Dataset.map()</code>, you'd have to maintain a list of Python iterator objects, then write a Python function that takes an integer, looks up the corresponding Python iterator in the list, and then returns the result of calling <code>next()</code> on it. (This is essentially all that <code>Dataset.from_generator()</code> does, although there's some additional nuance to ensuring that the iterators are properly disposed of at the end of the computation.)</p>", "body_text": "The implementation has been submitted and will become available in the next sync. To work around the problem using tf.py_func() in a Dataset.map(), you'd have to maintain a list of Python iterator objects, then write a Python function that takes an integer, looks up the corresponding Python iterator in the list, and then returns the result of calling next() on it. (This is essentially all that Dataset.from_generator() does, although there's some additional nuance to ensuring that the iterators are properly disposed of at the end of the computation.)", "body": "The implementation has been submitted and will become available in the next sync. To work around the problem using `tf.py_func()` in a `Dataset.map()`, you'd have to maintain a list of Python iterator objects, then write a Python function that takes an integer, looks up the corresponding Python iterator in the list, and then returns the result of calling `next()` on it. (This is essentially all that `Dataset.from_generator()` does, although there's some additional nuance to ensuring that the iterators are properly disposed of at the end of the computation.)"}