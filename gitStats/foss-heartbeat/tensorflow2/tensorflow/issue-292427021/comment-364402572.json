{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/364402572", "html_url": "https://github.com/tensorflow/tensorflow/pull/16543#issuecomment-364402572", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/16543", "id": 364402572, "node_id": "MDEyOklzc3VlQ29tbWVudDM2NDQwMjU3Mg==", "user": {"login": "chrert", "id": 1387661, "node_id": "MDQ6VXNlcjEzODc2NjE=", "avatar_url": "https://avatars2.githubusercontent.com/u/1387661?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chrert", "html_url": "https://github.com/chrert", "followers_url": "https://api.github.com/users/chrert/followers", "following_url": "https://api.github.com/users/chrert/following{/other_user}", "gists_url": "https://api.github.com/users/chrert/gists{/gist_id}", "starred_url": "https://api.github.com/users/chrert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chrert/subscriptions", "organizations_url": "https://api.github.com/users/chrert/orgs", "repos_url": "https://api.github.com/users/chrert/repos", "events_url": "https://api.github.com/users/chrert/events{/privacy}", "received_events_url": "https://api.github.com/users/chrert/received_events", "type": "User", "site_admin": false}, "created_at": "2018-02-09T10:56:40Z", "updated_at": "2018-02-09T10:56:40Z", "author_association": "CONTRIBUTOR", "body_html": "<p>I use the following script to measure the average runtime with &gt; 1000000 boxes:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">import</span> tensorflow <span class=\"pl-k\">as</span> tf\n<span class=\"pl-k\">import</span> numpy <span class=\"pl-k\">as</span> np\n<span class=\"pl-k\">import</span> timeit\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">create_boxgrid</span>():\n    coord_linspace <span class=\"pl-k\">=</span> np.linspace(<span class=\"pl-v\">start</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">0.0</span>, <span class=\"pl-v\">stop</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">1.0</span>, <span class=\"pl-v\">num</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">600</span>)\n    x_grid, y_grid <span class=\"pl-k\">=</span> np.meshgrid(coord_linspace, coord_linspace)\n    box_centers <span class=\"pl-k\">=</span> np.stack((x_grid, y_grid), <span class=\"pl-v\">axis</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">2</span>).reshape((<span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>,<span class=\"pl-c1\">2</span>))\n    \n    <span class=\"pl-k\">def</span> <span class=\"pl-en\">create_boxes</span>(<span class=\"pl-smi\">width</span>, <span class=\"pl-smi\">height</span>):\n        xmin <span class=\"pl-k\">=</span> box_centers[:, <span class=\"pl-c1\">0</span>] <span class=\"pl-k\">-</span> width<span class=\"pl-k\">/</span><span class=\"pl-c1\">2</span>\n        xmax <span class=\"pl-k\">=</span> box_centers[:, <span class=\"pl-c1\">0</span>] <span class=\"pl-k\">+</span> width<span class=\"pl-k\">/</span><span class=\"pl-c1\">2</span>\n        ymin <span class=\"pl-k\">=</span> box_centers[:, <span class=\"pl-c1\">1</span>] <span class=\"pl-k\">-</span> height<span class=\"pl-k\">/</span><span class=\"pl-c1\">2</span>\n        ymax <span class=\"pl-k\">=</span> box_centers[:, <span class=\"pl-c1\">1</span>] <span class=\"pl-k\">+</span> height<span class=\"pl-k\">/</span><span class=\"pl-c1\">2</span>\n        <span class=\"pl-k\">return</span> np.stack((ymin, xmin, ymax, xmax), <span class=\"pl-v\">axis</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">1</span>)\n    \n    <span class=\"pl-k\">return</span> np.concatenate((create_boxes(<span class=\"pl-c1\">0.2</span>, <span class=\"pl-c1\">0.2</span>), create_boxes(<span class=\"pl-c1\">0.5</span>, <span class=\"pl-c1\">0.3</span>), create_boxes(<span class=\"pl-c1\">0.3</span>, <span class=\"pl-c1\">0.5</span>)))\n\n<span class=\"pl-k\">if</span> <span class=\"pl-c1\">__name__</span> <span class=\"pl-k\">==</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>__main__<span class=\"pl-pds\">'</span></span>:\n    boxes <span class=\"pl-k\">=</span> create_boxgrid()\n    num_boxes <span class=\"pl-k\">=</span> <span class=\"pl-c1\">len</span>(boxes)\n    scores <span class=\"pl-k\">=</span> np.ones(<span class=\"pl-v\">shape</span><span class=\"pl-k\">=</span>(num_boxes,), <span class=\"pl-v\">dtype</span><span class=\"pl-k\">=</span>np.float32)\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>Number of boxes: <span class=\"pl-c1\">{<span class=\"pl-k\">:d</span>}</span><span class=\"pl-pds\">'</span></span>.format(num_boxes))\n\n    keep_idx <span class=\"pl-k\">=</span> tf.image.non_max_suppression(boxes, scores, num_boxes)\n    <span class=\"pl-k\">with</span> tf.Session() <span class=\"pl-k\">as</span> sess:\n        <span class=\"pl-k\">def</span> <span class=\"pl-en\">run</span>():\n            <span class=\"pl-k\">return</span> sess.run(keep_idx)\n        \n        <span class=\"pl-c\"><span class=\"pl-c\">#</span> warmup</span>\n        <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>Warming up...<span class=\"pl-pds\">'</span></span>)\n        <span class=\"pl-k\">for</span> _ <span class=\"pl-k\">in</span> <span class=\"pl-c1\">range</span>(<span class=\"pl-c1\">1000</span>):\n            np_keep_idx <span class=\"pl-k\">=</span> run()\n        \n        num_runs <span class=\"pl-k\">=</span> <span class=\"pl-c1\">100000</span>\n        <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>Measuring time for <span class=\"pl-c1\">{<span class=\"pl-k\">:d</span>}</span> runs...<span class=\"pl-pds\">'</span></span>.format(num_runs))\n        elapsed_time <span class=\"pl-k\">=</span> timeit.timeit(run, <span class=\"pl-v\">number</span><span class=\"pl-k\">=</span>num_runs)\n        avg_time <span class=\"pl-k\">=</span> elapsed_time <span class=\"pl-k\">/</span> num_runs\n        <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>Elapsed time: <span class=\"pl-c1\">{<span class=\"pl-k\">:f</span>}</span> seconds<span class=\"pl-pds\">'</span></span>.format(elapsed_time))\n        <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>Average time: <span class=\"pl-c1\">{<span class=\"pl-k\">:f</span>}</span> seconds<span class=\"pl-pds\">'</span></span>.format(avg_time))\n        <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>Keep <span class=\"pl-c1\">{<span class=\"pl-k\">:d</span>}</span> boxes<span class=\"pl-pds\">'</span></span>.format(<span class=\"pl-c1\">len</span>(np_keep_idx)))</pre></div>\n<p>Version in master:</p>\n<pre><code>Number of boxes: 1080000\nWarming up...\nMeasuring time for 100000 runs...\nElapsed time: 5.595638 seconds\nAverage time: 0.000056 seconds\nKeep 410 boxes\n</code></pre>\n<p>New version:</p>\n<pre><code>Number of boxes: 1080000\nWarming up...\nMeasuring time for 100000 runs...\nElapsed time: 5.595950 seconds\nAverage time: 0.000056 seconds\nKeep 410 boxes\n</code></pre>\n<p>Looks like the performance is pretty much the same!</p>", "body_text": "I use the following script to measure the average runtime with > 1000000 boxes:\nimport tensorflow as tf\nimport numpy as np\nimport timeit\n\ndef create_boxgrid():\n    coord_linspace = np.linspace(start=0.0, stop=1.0, num=600)\n    x_grid, y_grid = np.meshgrid(coord_linspace, coord_linspace)\n    box_centers = np.stack((x_grid, y_grid), axis=2).reshape((-1,2))\n    \n    def create_boxes(width, height):\n        xmin = box_centers[:, 0] - width/2\n        xmax = box_centers[:, 0] + width/2\n        ymin = box_centers[:, 1] - height/2\n        ymax = box_centers[:, 1] + height/2\n        return np.stack((ymin, xmin, ymax, xmax), axis=1)\n    \n    return np.concatenate((create_boxes(0.2, 0.2), create_boxes(0.5, 0.3), create_boxes(0.3, 0.5)))\n\nif __name__ == '__main__':\n    boxes = create_boxgrid()\n    num_boxes = len(boxes)\n    scores = np.ones(shape=(num_boxes,), dtype=np.float32)\n    print('Number of boxes: {:d}'.format(num_boxes))\n\n    keep_idx = tf.image.non_max_suppression(boxes, scores, num_boxes)\n    with tf.Session() as sess:\n        def run():\n            return sess.run(keep_idx)\n        \n        # warmup\n        print('Warming up...')\n        for _ in range(1000):\n            np_keep_idx = run()\n        \n        num_runs = 100000\n        print('Measuring time for {:d} runs...'.format(num_runs))\n        elapsed_time = timeit.timeit(run, number=num_runs)\n        avg_time = elapsed_time / num_runs\n        print('Elapsed time: {:f} seconds'.format(elapsed_time))\n        print('Average time: {:f} seconds'.format(avg_time))\n        print('Keep {:d} boxes'.format(len(np_keep_idx)))\nVersion in master:\nNumber of boxes: 1080000\nWarming up...\nMeasuring time for 100000 runs...\nElapsed time: 5.595638 seconds\nAverage time: 0.000056 seconds\nKeep 410 boxes\n\nNew version:\nNumber of boxes: 1080000\nWarming up...\nMeasuring time for 100000 runs...\nElapsed time: 5.595950 seconds\nAverage time: 0.000056 seconds\nKeep 410 boxes\n\nLooks like the performance is pretty much the same!", "body": "I use the following script to measure the average runtime with > 1000000 boxes:\r\n\r\n```python\r\nimport tensorflow as tf\r\nimport numpy as np\r\nimport timeit\r\n\r\ndef create_boxgrid():\r\n    coord_linspace = np.linspace(start=0.0, stop=1.0, num=600)\r\n    x_grid, y_grid = np.meshgrid(coord_linspace, coord_linspace)\r\n    box_centers = np.stack((x_grid, y_grid), axis=2).reshape((-1,2))\r\n    \r\n    def create_boxes(width, height):\r\n        xmin = box_centers[:, 0] - width/2\r\n        xmax = box_centers[:, 0] + width/2\r\n        ymin = box_centers[:, 1] - height/2\r\n        ymax = box_centers[:, 1] + height/2\r\n        return np.stack((ymin, xmin, ymax, xmax), axis=1)\r\n    \r\n    return np.concatenate((create_boxes(0.2, 0.2), create_boxes(0.5, 0.3), create_boxes(0.3, 0.5)))\r\n\r\nif __name__ == '__main__':\r\n    boxes = create_boxgrid()\r\n    num_boxes = len(boxes)\r\n    scores = np.ones(shape=(num_boxes,), dtype=np.float32)\r\n    print('Number of boxes: {:d}'.format(num_boxes))\r\n\r\n    keep_idx = tf.image.non_max_suppression(boxes, scores, num_boxes)\r\n    with tf.Session() as sess:\r\n        def run():\r\n            return sess.run(keep_idx)\r\n        \r\n        # warmup\r\n        print('Warming up...')\r\n        for _ in range(1000):\r\n            np_keep_idx = run()\r\n        \r\n        num_runs = 100000\r\n        print('Measuring time for {:d} runs...'.format(num_runs))\r\n        elapsed_time = timeit.timeit(run, number=num_runs)\r\n        avg_time = elapsed_time / num_runs\r\n        print('Elapsed time: {:f} seconds'.format(elapsed_time))\r\n        print('Average time: {:f} seconds'.format(avg_time))\r\n        print('Keep {:d} boxes'.format(len(np_keep_idx)))\r\n```\r\n\r\nVersion in master:\r\n```\r\nNumber of boxes: 1080000\r\nWarming up...\r\nMeasuring time for 100000 runs...\r\nElapsed time: 5.595638 seconds\r\nAverage time: 0.000056 seconds\r\nKeep 410 boxes\r\n```\r\n\r\nNew version:\r\n```\r\nNumber of boxes: 1080000\r\nWarming up...\r\nMeasuring time for 100000 runs...\r\nElapsed time: 5.595950 seconds\r\nAverage time: 0.000056 seconds\r\nKeep 410 boxes\r\n```\r\n\r\nLooks like the performance is pretty much the same!"}