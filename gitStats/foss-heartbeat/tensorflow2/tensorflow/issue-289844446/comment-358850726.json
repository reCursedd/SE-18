{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/358850726", "html_url": "https://github.com/tensorflow/tensorflow/issues/16235#issuecomment-358850726", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/16235", "id": 358850726, "node_id": "MDEyOklzc3VlQ29tbWVudDM1ODg1MDcyNg==", "user": {"login": "selcouthlyBlue", "id": 13268675, "node_id": "MDQ6VXNlcjEzMjY4Njc1", "avatar_url": "https://avatars2.githubusercontent.com/u/13268675?v=4", "gravatar_id": "", "url": "https://api.github.com/users/selcouthlyBlue", "html_url": "https://github.com/selcouthlyBlue", "followers_url": "https://api.github.com/users/selcouthlyBlue/followers", "following_url": "https://api.github.com/users/selcouthlyBlue/following{/other_user}", "gists_url": "https://api.github.com/users/selcouthlyBlue/gists{/gist_id}", "starred_url": "https://api.github.com/users/selcouthlyBlue/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/selcouthlyBlue/subscriptions", "organizations_url": "https://api.github.com/users/selcouthlyBlue/orgs", "repos_url": "https://api.github.com/users/selcouthlyBlue/repos", "events_url": "https://api.github.com/users/selcouthlyBlue/events{/privacy}", "received_events_url": "https://api.github.com/users/selcouthlyBlue/received_events", "type": "User", "site_admin": false}, "created_at": "2018-01-19T02:45:25Z", "updated_at": "2018-01-19T02:45:25Z", "author_association": "CONTRIBUTOR", "body_html": "<p>I have also created a few sample uses:</p>\n<pre><code>class MultidimensionalRNNTest(tf.test.TestCase):\n    def setUp(self):\n        self.num_classes = 26\n        self.num_features = 32\n        self.time_steps = 64\n        self.batch_size = 1 # Can't be dynamic, apparently.\n        self.num_channels = 1\n        self.num_filters = 16\n        self.input_layer = tf.placeholder(tf.float32, [self.batch_size, self.time_steps, self.num_features, self.num_channels])\n        self.labels = tf.sparse_placeholder(tf.int32)\n\n    def test_simple_mdrnn(self):\n        net = lstm2d.separable_lstm(self.input_layer, self.num_filters)\n\n    def test_image_to_sequence(self):\n        net = lstm2d.separable_lstm(self.input_layer, self.num_filters)\n        net = lstm2d.images_to_sequence(net)\n\n    def test_convert_to_ctc_dims(self):\n        net = lstm2d.separable_lstm(self.input_layer, self.num_filters)\n        net = lstm2d.images_to_sequence(net)\n\n        net = tf.reshape(inputs, [-1, self.num_filters])\n\n         W = tf.Variable(tf.truncated_normal([self.num_filters,\n                                     self.num_classes],\n                                    stddev=0.1, dtype=tf.float32), name='W')\n         b = tf.Variable(tf.constant(0., dtype=tf.float32, shape=[self.num_classes], name='b'))\n\n         net = tf.matmul(net, W) + b\n         net = tf.reshape(net, [self.batch_size, -1, self.num_classes])\n\n         net = tf.transpose(net, (1, 0, 2))\n\n         loss = tf.nn.ctc_loss(inputs=net, labels=self.labels, sequence_length=[2])\n\n    def test_stack_ndlstms(self):\n         net = lstm2d.separable_lstm(self.input_layer, self.num_filters)\n         net = lstm2d.separable_lstm(net, self.num_filters)\n\n\nif __name__ == '__main__':\n    tf.test.main()\n</code></pre>", "body_text": "I have also created a few sample uses:\nclass MultidimensionalRNNTest(tf.test.TestCase):\n    def setUp(self):\n        self.num_classes = 26\n        self.num_features = 32\n        self.time_steps = 64\n        self.batch_size = 1 # Can't be dynamic, apparently.\n        self.num_channels = 1\n        self.num_filters = 16\n        self.input_layer = tf.placeholder(tf.float32, [self.batch_size, self.time_steps, self.num_features, self.num_channels])\n        self.labels = tf.sparse_placeholder(tf.int32)\n\n    def test_simple_mdrnn(self):\n        net = lstm2d.separable_lstm(self.input_layer, self.num_filters)\n\n    def test_image_to_sequence(self):\n        net = lstm2d.separable_lstm(self.input_layer, self.num_filters)\n        net = lstm2d.images_to_sequence(net)\n\n    def test_convert_to_ctc_dims(self):\n        net = lstm2d.separable_lstm(self.input_layer, self.num_filters)\n        net = lstm2d.images_to_sequence(net)\n\n        net = tf.reshape(inputs, [-1, self.num_filters])\n\n         W = tf.Variable(tf.truncated_normal([self.num_filters,\n                                     self.num_classes],\n                                    stddev=0.1, dtype=tf.float32), name='W')\n         b = tf.Variable(tf.constant(0., dtype=tf.float32, shape=[self.num_classes], name='b'))\n\n         net = tf.matmul(net, W) + b\n         net = tf.reshape(net, [self.batch_size, -1, self.num_classes])\n\n         net = tf.transpose(net, (1, 0, 2))\n\n         loss = tf.nn.ctc_loss(inputs=net, labels=self.labels, sequence_length=[2])\n\n    def test_stack_ndlstms(self):\n         net = lstm2d.separable_lstm(self.input_layer, self.num_filters)\n         net = lstm2d.separable_lstm(net, self.num_filters)\n\n\nif __name__ == '__main__':\n    tf.test.main()", "body": "I have also created a few sample uses:\r\n\r\n```\r\nclass MultidimensionalRNNTest(tf.test.TestCase):\r\n    def setUp(self):\r\n        self.num_classes = 26\r\n        self.num_features = 32\r\n        self.time_steps = 64\r\n        self.batch_size = 1 # Can't be dynamic, apparently.\r\n        self.num_channels = 1\r\n        self.num_filters = 16\r\n        self.input_layer = tf.placeholder(tf.float32, [self.batch_size, self.time_steps, self.num_features, self.num_channels])\r\n        self.labels = tf.sparse_placeholder(tf.int32)\r\n\r\n    def test_simple_mdrnn(self):\r\n        net = lstm2d.separable_lstm(self.input_layer, self.num_filters)\r\n\r\n    def test_image_to_sequence(self):\r\n        net = lstm2d.separable_lstm(self.input_layer, self.num_filters)\r\n        net = lstm2d.images_to_sequence(net)\r\n\r\n    def test_convert_to_ctc_dims(self):\r\n        net = lstm2d.separable_lstm(self.input_layer, self.num_filters)\r\n        net = lstm2d.images_to_sequence(net)\r\n\r\n        net = tf.reshape(inputs, [-1, self.num_filters])\r\n\r\n         W = tf.Variable(tf.truncated_normal([self.num_filters,\r\n                                     self.num_classes],\r\n                                    stddev=0.1, dtype=tf.float32), name='W')\r\n         b = tf.Variable(tf.constant(0., dtype=tf.float32, shape=[self.num_classes], name='b'))\r\n\r\n         net = tf.matmul(net, W) + b\r\n         net = tf.reshape(net, [self.batch_size, -1, self.num_classes])\r\n\r\n         net = tf.transpose(net, (1, 0, 2))\r\n\r\n         loss = tf.nn.ctc_loss(inputs=net, labels=self.labels, sequence_length=[2])\r\n\r\n    def test_stack_ndlstms(self):\r\n         net = lstm2d.separable_lstm(self.input_layer, self.num_filters)\r\n         net = lstm2d.separable_lstm(net, self.num_filters)\r\n\r\n\r\nif __name__ == '__main__':\r\n    tf.test.main()\r\n```"}