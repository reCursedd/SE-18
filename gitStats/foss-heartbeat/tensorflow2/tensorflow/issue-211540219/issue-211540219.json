{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8033", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8033/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8033/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8033/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/8033", "id": 211540219, "node_id": "MDU6SXNzdWUyMTE1NDAyMTk=", "number": 8033, "title": "Direct access to Tensor Buffers in C++ interface", "user": {"login": "pdrews", "id": 506166, "node_id": "MDQ6VXNlcjUwNjE2Ng==", "avatar_url": "https://avatars1.githubusercontent.com/u/506166?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pdrews", "html_url": "https://github.com/pdrews", "followers_url": "https://api.github.com/users/pdrews/followers", "following_url": "https://api.github.com/users/pdrews/following{/other_user}", "gists_url": "https://api.github.com/users/pdrews/gists{/gist_id}", "starred_url": "https://api.github.com/users/pdrews/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pdrews/subscriptions", "organizations_url": "https://api.github.com/users/pdrews/orgs", "repos_url": "https://api.github.com/users/pdrews/repos", "events_url": "https://api.github.com/users/pdrews/events{/privacy}", "received_events_url": "https://api.github.com/users/pdrews/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 404586594, "node_id": "MDU6TGFiZWw0MDQ1ODY1OTQ=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:awaiting%20tensorflower", "name": "stat:awaiting tensorflower", "color": "f4b400", "default": false}], "state": "closed", "locked": false, "assignee": {"login": "skye", "id": 88808, "node_id": "MDQ6VXNlcjg4ODA4", "avatar_url": "https://avatars1.githubusercontent.com/u/88808?v=4", "gravatar_id": "", "url": "https://api.github.com/users/skye", "html_url": "https://github.com/skye", "followers_url": "https://api.github.com/users/skye/followers", "following_url": "https://api.github.com/users/skye/following{/other_user}", "gists_url": "https://api.github.com/users/skye/gists{/gist_id}", "starred_url": "https://api.github.com/users/skye/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/skye/subscriptions", "organizations_url": "https://api.github.com/users/skye/orgs", "repos_url": "https://api.github.com/users/skye/repos", "events_url": "https://api.github.com/users/skye/events{/privacy}", "received_events_url": "https://api.github.com/users/skye/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "skye", "id": 88808, "node_id": "MDQ6VXNlcjg4ODA4", "avatar_url": "https://avatars1.githubusercontent.com/u/88808?v=4", "gravatar_id": "", "url": "https://api.github.com/users/skye", "html_url": "https://github.com/skye", "followers_url": "https://api.github.com/users/skye/followers", "following_url": "https://api.github.com/users/skye/following{/other_user}", "gists_url": "https://api.github.com/users/skye/gists{/gist_id}", "starred_url": "https://api.github.com/users/skye/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/skye/subscriptions", "organizations_url": "https://api.github.com/users/skye/orgs", "repos_url": "https://api.github.com/users/skye/repos", "events_url": "https://api.github.com/users/skye/events{/privacy}", "received_events_url": "https://api.github.com/users/skye/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 22, "created_at": "2017-03-02T22:37:59Z", "updated_at": "2018-01-03T15:58:37Z", "closed_at": "2018-01-02T18:19:07Z", "author_association": "NONE", "body_html": "<p>I would like to request direct access to the tensorflow buffers through the C++ interface.  I have commented previously about this on <a href=\"http://stackoverflow.com/questions/39379747/import-opencv-mat-into-c-tensorflow-without-copying\" rel=\"nofollow\">StackOverflow</a>, and have gotten it to work by exposing the <code>TensorCApi</code> class.  This required some fiddling around with the source code.</p>\n<p>My specific use case is using tensorflow from a <a href=\"http://www.ros.org/\" rel=\"nofollow\">ROS</a> (robot operating system) node.  ROS has its own build system, so I have to link to the tensorflow library (libtensorflow.so) externally.  The C++ interface is much more convenient than the C interface, as I only load and do forward inference on static graphs.</p>\n<p>Because I get an OpenCV array as input, my only other option is to iterate the entire array and copy it to a newly allocated tensor buffer as suggested in <a href=\"http://stackoverflow.com/questions/36044197/how-do-i-pass-an-opencv-mat-into-a-c-tensorflow-graph\" rel=\"nofollow\">this post</a>.  In my case, copying the buffer by iterating it can take 25-75ms, whereas simply pointing to the memory already allocated by OpenCV incurs almost no overhead.  I am doing all of this in real time as part of a tight control loop, so this extra time is absolutely critical.</p>\n<p>I realize this patch is probably not the right way to expose the interface, and my example code provides no memory checking or safeguards, but it is an example (diff against the r1.0 tensorflow tag):</p>\n<pre><code>diff --git a/tensorflow/c/c_api.cc b/tensorflow/c/c_api.cc\nindex 83ce3e2..34ae2b4 100644\n--- a/tensorflow/c/c_api.cc\n+++ b/tensorflow/c/c_api.cc\n@@ -464,14 +464,11 @@ TF_Tensor* TF_Tensor_EncodeStrings(const Tensor&amp; src) {\n                       dimvec.size(), base, size, DeleteArray, base);\n }\n \n-class TensorCApi {\n- public:\n-  static TensorBuffer* Buffer(const Tensor&amp; tensor) { return tensor.buf_; }\n-  static Tensor MakeTensor(TF_DataType type, const TensorShape&amp; shape,\n-                           TensorBuffer* buf) {\n-    return Tensor(static_cast&lt;DataType&gt;(type), shape, buf);\n-  }\n-};\n+TensorBuffer* TensorCApi::Buffer(const Tensor&amp; tensor) { return tensor.buf_; }\n+Tensor TensorCApi::MakeTensor(TF_DataType type, const TensorShape&amp; shape,\n+                         TensorBuffer* buf) {\n+  return Tensor(static_cast&lt;DataType&gt;(type), shape, buf);\n+}\n \n // Create an empty tensor of type 'dtype'. 'shape' can be arbitrary, but has to\n // result in a zero-sized tensor.\ndiff --git a/tensorflow/c/c_api.h b/tensorflow/c/c_api.h\nindex e625d65..7479a1f 100644\n--- a/tensorflow/c/c_api.h\n+++ b/tensorflow/c/c_api.h\n@@ -18,6 +18,7 @@ limitations under the License.\n \n #include &lt;stddef.h&gt;\n #include &lt;stdint.h&gt;\n+#include \"tensorflow/core/framework/tensor.h\"\n \n // --------------------------------------------------------------------------\n // C API for TensorFlow.\n@@ -64,6 +65,10 @@ limitations under the License.\n //   and the API just provides high level controls over the number of\n //   devices of each type.\n \n+using tensorflow::Tensor;\n+using tensorflow::TensorBuffer;\n+using tensorflow::TensorShape;\n+\n #ifdef __cplusplus\n extern \"C\" {\n #endif\n@@ -1030,6 +1035,15 @@ extern void TF_DeleteLibraryHandle(TF_Library* lib_handle);\n // in this address space.\n extern TF_Buffer* TF_GetAllOpList();\n \n+namespace tensorflow{\n+class TensorCApi {\n+public:\n+ static TensorBuffer* Buffer(const Tensor&amp; tensor);\n+ static Tensor MakeTensor(TF_DataType type, const TensorShape&amp; shape,\n+                          TensorBuffer* buf);\n+};\n+};\n+\n #ifdef __cplusplus\n } /* end extern \"C\" */\n #endif\ndiff --git a/tensorflow/core/framework/tensor.h b/tensorflow/core/framework/tensor.h\nindex c2a1c3d..14e9881 100644\n--- a/tensorflow/core/framework/tensor.h\n+++ b/tensorflow/core/framework/tensor.h\n@@ -36,7 +36,7 @@ limitations under the License.\n namespace tensorflow {\n \n class TensorBuffer;  // Forward declaration.\n-class TensorCApi;\n+// class TensorCApi;\n \n /// @ingroup core\n /// Represents an n-dimensional array of values.\n</code></pre>\n<p>and a small snippet of code to use it:</p>\n<pre><code>// Put an image in the cameraImg mat\ncv::resize(image-&gt;image, cameraImg, cv::Size(inputwidth, inputheight), 0, 0, cv::INTER_AREA);\n// Create a new tensor pointing to that memory:\nconst int64_t tensorDims[4] = {1,inputheight,inputwidth,3};\nint *imNumPt = new int(1);\nTF_Tensor* tftensor = TF_NewTensor(TF_DataType::TF_UINT8, tensorDims, 4,\n                           cameraImg.data, inputheight * inputwidth * 3,\n                           NULL, imNumPt);\nTensor inputImg = tensorflow::TensorCApi::MakeTensor(tftensor-&gt;dtype, tftensor-&gt;shape, tftensor-&gt;buffer);\n</code></pre>", "body_text": "I would like to request direct access to the tensorflow buffers through the C++ interface.  I have commented previously about this on StackOverflow, and have gotten it to work by exposing the TensorCApi class.  This required some fiddling around with the source code.\nMy specific use case is using tensorflow from a ROS (robot operating system) node.  ROS has its own build system, so I have to link to the tensorflow library (libtensorflow.so) externally.  The C++ interface is much more convenient than the C interface, as I only load and do forward inference on static graphs.\nBecause I get an OpenCV array as input, my only other option is to iterate the entire array and copy it to a newly allocated tensor buffer as suggested in this post.  In my case, copying the buffer by iterating it can take 25-75ms, whereas simply pointing to the memory already allocated by OpenCV incurs almost no overhead.  I am doing all of this in real time as part of a tight control loop, so this extra time is absolutely critical.\nI realize this patch is probably not the right way to expose the interface, and my example code provides no memory checking or safeguards, but it is an example (diff against the r1.0 tensorflow tag):\ndiff --git a/tensorflow/c/c_api.cc b/tensorflow/c/c_api.cc\nindex 83ce3e2..34ae2b4 100644\n--- a/tensorflow/c/c_api.cc\n+++ b/tensorflow/c/c_api.cc\n@@ -464,14 +464,11 @@ TF_Tensor* TF_Tensor_EncodeStrings(const Tensor& src) {\n                       dimvec.size(), base, size, DeleteArray, base);\n }\n \n-class TensorCApi {\n- public:\n-  static TensorBuffer* Buffer(const Tensor& tensor) { return tensor.buf_; }\n-  static Tensor MakeTensor(TF_DataType type, const TensorShape& shape,\n-                           TensorBuffer* buf) {\n-    return Tensor(static_cast<DataType>(type), shape, buf);\n-  }\n-};\n+TensorBuffer* TensorCApi::Buffer(const Tensor& tensor) { return tensor.buf_; }\n+Tensor TensorCApi::MakeTensor(TF_DataType type, const TensorShape& shape,\n+                         TensorBuffer* buf) {\n+  return Tensor(static_cast<DataType>(type), shape, buf);\n+}\n \n // Create an empty tensor of type 'dtype'. 'shape' can be arbitrary, but has to\n // result in a zero-sized tensor.\ndiff --git a/tensorflow/c/c_api.h b/tensorflow/c/c_api.h\nindex e625d65..7479a1f 100644\n--- a/tensorflow/c/c_api.h\n+++ b/tensorflow/c/c_api.h\n@@ -18,6 +18,7 @@ limitations under the License.\n \n #include <stddef.h>\n #include <stdint.h>\n+#include \"tensorflow/core/framework/tensor.h\"\n \n // --------------------------------------------------------------------------\n // C API for TensorFlow.\n@@ -64,6 +65,10 @@ limitations under the License.\n //   and the API just provides high level controls over the number of\n //   devices of each type.\n \n+using tensorflow::Tensor;\n+using tensorflow::TensorBuffer;\n+using tensorflow::TensorShape;\n+\n #ifdef __cplusplus\n extern \"C\" {\n #endif\n@@ -1030,6 +1035,15 @@ extern void TF_DeleteLibraryHandle(TF_Library* lib_handle);\n // in this address space.\n extern TF_Buffer* TF_GetAllOpList();\n \n+namespace tensorflow{\n+class TensorCApi {\n+public:\n+ static TensorBuffer* Buffer(const Tensor& tensor);\n+ static Tensor MakeTensor(TF_DataType type, const TensorShape& shape,\n+                          TensorBuffer* buf);\n+};\n+};\n+\n #ifdef __cplusplus\n } /* end extern \"C\" */\n #endif\ndiff --git a/tensorflow/core/framework/tensor.h b/tensorflow/core/framework/tensor.h\nindex c2a1c3d..14e9881 100644\n--- a/tensorflow/core/framework/tensor.h\n+++ b/tensorflow/core/framework/tensor.h\n@@ -36,7 +36,7 @@ limitations under the License.\n namespace tensorflow {\n \n class TensorBuffer;  // Forward declaration.\n-class TensorCApi;\n+// class TensorCApi;\n \n /// @ingroup core\n /// Represents an n-dimensional array of values.\n\nand a small snippet of code to use it:\n// Put an image in the cameraImg mat\ncv::resize(image->image, cameraImg, cv::Size(inputwidth, inputheight), 0, 0, cv::INTER_AREA);\n// Create a new tensor pointing to that memory:\nconst int64_t tensorDims[4] = {1,inputheight,inputwidth,3};\nint *imNumPt = new int(1);\nTF_Tensor* tftensor = TF_NewTensor(TF_DataType::TF_UINT8, tensorDims, 4,\n                           cameraImg.data, inputheight * inputwidth * 3,\n                           NULL, imNumPt);\nTensor inputImg = tensorflow::TensorCApi::MakeTensor(tftensor->dtype, tftensor->shape, tftensor->buffer);", "body": "I would like to request direct access to the tensorflow buffers through the C++ interface.  I have commented previously about this on [StackOverflow](http://stackoverflow.com/questions/39379747/import-opencv-mat-into-c-tensorflow-without-copying), and have gotten it to work by exposing the `TensorCApi` class.  This required some fiddling around with the source code.\r\n\r\nMy specific use case is using tensorflow from a [ROS](http://www.ros.org/) (robot operating system) node.  ROS has its own build system, so I have to link to the tensorflow library (libtensorflow.so) externally.  The C++ interface is much more convenient than the C interface, as I only load and do forward inference on static graphs.\r\n\r\nBecause I get an OpenCV array as input, my only other option is to iterate the entire array and copy it to a newly allocated tensor buffer as suggested in [this post](http://stackoverflow.com/questions/36044197/how-do-i-pass-an-opencv-mat-into-a-c-tensorflow-graph).  In my case, copying the buffer by iterating it can take 25-75ms, whereas simply pointing to the memory already allocated by OpenCV incurs almost no overhead.  I am doing all of this in real time as part of a tight control loop, so this extra time is absolutely critical.\r\n\r\nI realize this patch is probably not the right way to expose the interface, and my example code provides no memory checking or safeguards, but it is an example (diff against the r1.0 tensorflow tag):\r\n\r\n```\r\ndiff --git a/tensorflow/c/c_api.cc b/tensorflow/c/c_api.cc\r\nindex 83ce3e2..34ae2b4 100644\r\n--- a/tensorflow/c/c_api.cc\r\n+++ b/tensorflow/c/c_api.cc\r\n@@ -464,14 +464,11 @@ TF_Tensor* TF_Tensor_EncodeStrings(const Tensor& src) {\r\n                       dimvec.size(), base, size, DeleteArray, base);\r\n }\r\n \r\n-class TensorCApi {\r\n- public:\r\n-  static TensorBuffer* Buffer(const Tensor& tensor) { return tensor.buf_; }\r\n-  static Tensor MakeTensor(TF_DataType type, const TensorShape& shape,\r\n-                           TensorBuffer* buf) {\r\n-    return Tensor(static_cast<DataType>(type), shape, buf);\r\n-  }\r\n-};\r\n+TensorBuffer* TensorCApi::Buffer(const Tensor& tensor) { return tensor.buf_; }\r\n+Tensor TensorCApi::MakeTensor(TF_DataType type, const TensorShape& shape,\r\n+                         TensorBuffer* buf) {\r\n+  return Tensor(static_cast<DataType>(type), shape, buf);\r\n+}\r\n \r\n // Create an empty tensor of type 'dtype'. 'shape' can be arbitrary, but has to\r\n // result in a zero-sized tensor.\r\ndiff --git a/tensorflow/c/c_api.h b/tensorflow/c/c_api.h\r\nindex e625d65..7479a1f 100644\r\n--- a/tensorflow/c/c_api.h\r\n+++ b/tensorflow/c/c_api.h\r\n@@ -18,6 +18,7 @@ limitations under the License.\r\n \r\n #include <stddef.h>\r\n #include <stdint.h>\r\n+#include \"tensorflow/core/framework/tensor.h\"\r\n \r\n // --------------------------------------------------------------------------\r\n // C API for TensorFlow.\r\n@@ -64,6 +65,10 @@ limitations under the License.\r\n //   and the API just provides high level controls over the number of\r\n //   devices of each type.\r\n \r\n+using tensorflow::Tensor;\r\n+using tensorflow::TensorBuffer;\r\n+using tensorflow::TensorShape;\r\n+\r\n #ifdef __cplusplus\r\n extern \"C\" {\r\n #endif\r\n@@ -1030,6 +1035,15 @@ extern void TF_DeleteLibraryHandle(TF_Library* lib_handle);\r\n // in this address space.\r\n extern TF_Buffer* TF_GetAllOpList();\r\n \r\n+namespace tensorflow{\r\n+class TensorCApi {\r\n+public:\r\n+ static TensorBuffer* Buffer(const Tensor& tensor);\r\n+ static Tensor MakeTensor(TF_DataType type, const TensorShape& shape,\r\n+                          TensorBuffer* buf);\r\n+};\r\n+};\r\n+\r\n #ifdef __cplusplus\r\n } /* end extern \"C\" */\r\n #endif\r\ndiff --git a/tensorflow/core/framework/tensor.h b/tensorflow/core/framework/tensor.h\r\nindex c2a1c3d..14e9881 100644\r\n--- a/tensorflow/core/framework/tensor.h\r\n+++ b/tensorflow/core/framework/tensor.h\r\n@@ -36,7 +36,7 @@ limitations under the License.\r\n namespace tensorflow {\r\n \r\n class TensorBuffer;  // Forward declaration.\r\n-class TensorCApi;\r\n+// class TensorCApi;\r\n \r\n /// @ingroup core\r\n /// Represents an n-dimensional array of values.\r\n```\r\n\r\nand a small snippet of code to use it:\r\n```\r\n// Put an image in the cameraImg mat\r\ncv::resize(image->image, cameraImg, cv::Size(inputwidth, inputheight), 0, 0, cv::INTER_AREA);\r\n// Create a new tensor pointing to that memory:\r\nconst int64_t tensorDims[4] = {1,inputheight,inputwidth,3};\r\nint *imNumPt = new int(1);\r\nTF_Tensor* tftensor = TF_NewTensor(TF_DataType::TF_UINT8, tensorDims, 4,\r\n                           cameraImg.data, inputheight * inputwidth * 3,\r\n                           NULL, imNumPt);\r\nTensor inputImg = tensorflow::TensorCApi::MakeTensor(tftensor->dtype, tftensor->shape, tftensor->buffer);\r\n```"}