{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/284499639", "html_url": "https://github.com/tensorflow/tensorflow/issues/8033#issuecomment-284499639", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8033", "id": 284499639, "node_id": "MDEyOklzc3VlQ29tbWVudDI4NDQ5OTYzOQ==", "user": {"login": "skye", "id": 88808, "node_id": "MDQ6VXNlcjg4ODA4", "avatar_url": "https://avatars1.githubusercontent.com/u/88808?v=4", "gravatar_id": "", "url": "https://api.github.com/users/skye", "html_url": "https://github.com/skye", "followers_url": "https://api.github.com/users/skye/followers", "following_url": "https://api.github.com/users/skye/following{/other_user}", "gists_url": "https://api.github.com/users/skye/gists{/gist_id}", "starred_url": "https://api.github.com/users/skye/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/skye/subscriptions", "organizations_url": "https://api.github.com/users/skye/orgs", "repos_url": "https://api.github.com/users/skye/repos", "events_url": "https://api.github.com/users/skye/events{/privacy}", "received_events_url": "https://api.github.com/users/skye/received_events", "type": "User", "site_admin": false}, "created_at": "2017-03-06T19:10:50Z", "updated_at": "2017-03-06T19:10:50Z", "author_association": "MEMBER", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=506166\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/pdrews\">@pdrews</a> I would recommend using the C API for now. As you mentioned, it's more verbose but might make your project build simpler, and most importantly it already exposes the functionality you need :) Unfortunately we lack documentation on it so here's some info to get you started:</p>\n<p><em>Building:</em> <a href=\"https://storage.googleapis.com/tensorflow/libtensorflow/libtensorflow-cpu-linux-x86_64-1.0.0.tar.gz\" rel=\"nofollow\">https://storage.googleapis.com/tensorflow/libtensorflow/libtensorflow-cpu-linux-x86_64-1.0.0.tar.gz</a> is a pre-built Linux binary (CPU-only, I'm assuming your robot doesn't have a GPU). I believe this should work if ROS is built on top of a standard Linux distro. Otherwise it sounds like you have already figured out how to build from source.</p>\n<p><em>Usage</em>: Here's an example on how to load and run a graph:</p>\n<div class=\"highlight highlight-source-c++\"><pre>TF_Status* s = TF_NewStatus();\nTF_Graph* graph = TF_NewGraph();\n\n<span class=\"pl-k\">const</span> <span class=\"pl-k\">char</span>* graph_def_data; <span class=\"pl-c\"><span class=\"pl-c\">//</span> &lt;-- your serialized GraphDef here</span>\nTF_Buffer graph_def = {graph_def_data, <span class=\"pl-c1\">strlen</span>(graph_def_data), <span class=\"pl-c1\">nullptr</span>};\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> Import `graph_def` into `graph`</span>\nTF_ImportGraphDefOptions* import_opts = TF_NewImportGraphDefOptions();\n<span class=\"pl-en\">TF_ImportGraphDefOptionsSetPrefix</span>(import_opts, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>import<span class=\"pl-pds\">\"</span></span>);\n<span class=\"pl-en\">TF_GraphImportGraphDef</span>(graph, &amp;graph_def, import_opts, s);\n<span class=\"pl-en\">assert</span>(TF_GetCode(s) == TF_OK);\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> Setup graph inputs</span>\nstd::vector&lt;TF_Output&gt; inputs;\nstd::vector&lt;TF_Tensor*&gt; input_values;\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> Add the placeholders you would like to feed, e.g.:</span>\nTF_Operation* placeholder = TF_GraphOperationByName(graph, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>import/my_placeholder<span class=\"pl-pds\">\"</span></span>);\ninputs.push_back({placeholder, <span class=\"pl-c1\">0</span>});\nTF_Tensor* tensor = TF_NewTensor(<span class=\"pl-c\"><span class=\"pl-c\">/*</span>...<span class=\"pl-c\">*/</span></span>);\ninput_values.push_back(tensor);\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> Setup graph outputs</span>\nstd::vector&lt;TF_Output&gt; outputs;\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> Add the node outputs you would like to fetch, e.g.:</span>\nTF_Operation* output_op = TF_GraphOperationByName(graph, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>import/my_output<span class=\"pl-pds\">\"</span></span>);\noutputs.push_back({output_op, <span class=\"pl-c1\">0</span>});\nstd::vector&lt;TF_Tensor*&gt; <span class=\"pl-en\">output_values</span>(outputs.size(), nullptr);\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> Run `graph`</span>\nTF_SessionOptions* sess_opts = TF_NewSessionOptions();\nTF_Session* session = TF_NewSession(graph, sess_opts, s);\n<span class=\"pl-en\">assert</span>(TF_GetCode(s) == TF_OK);\n<span class=\"pl-en\">TF_SessionRun</span>(session, <span class=\"pl-c1\">nullptr</span>,\n              &amp;inputs[<span class=\"pl-c1\">0</span>], &amp;input_values[<span class=\"pl-c1\">0</span>], inputs.size(),\n              &amp;outputs[0], &amp;output_values[0], outputs.size(),\n              nullptr, 0, nullptr, s);\n\n<span class=\"pl-k\">void</span>* output_data = TF_TensorData(output_values[<span class=\"pl-c1\">0</span>]);\n<span class=\"pl-en\">assert</span>(TF_GetCode(s) == TF_OK);\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> If you have a more complicated workflow, I suggest making scoped wrapper</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> classes that call these in their destructors</span>\n<span class=\"pl-k\">for</span> (<span class=\"pl-k\">int</span> i = <span class=\"pl-c1\">0</span>; i &lt; inputs.size(); ++i) TF_DeleteTensor(input_values[i]);\n<span class=\"pl-k\">for</span> (<span class=\"pl-k\">int</span> i = <span class=\"pl-c1\">0</span>; i &lt; outputs.size(); ++i) TF_DeleteTensor(output_values[i]);\n<span class=\"pl-en\">TF_CloseSession</span>(session, s);\n<span class=\"pl-en\">TF_DeleteSession</span>(session, s);\n<span class=\"pl-en\">TF_DeleteSessionOptions</span>(sess_opts);\n<span class=\"pl-en\">TF_DeleteImportGraphDefOptions</span>(import_opts);\n<span class=\"pl-en\">TF_DeleteGraph</span>(graph);\n<span class=\"pl-en\">TF_DeleteStatus</span>(s);</pre></div>\n<p>Full disclosure, I didn't actually run this code, so please let me know if you run into problems. For details please refer to the <a href=\"https://github.com/tensorflow/tensorflow/blob/r1.0/tensorflow/c/c_api.h\">C API header</a>. The <a href=\"https://github.com/tensorflow/tensorflow/blob/r1.0/tensorflow/c/c_api_test.cc\">C API test</a> has more examples for how to use the code.</p>\n<p>If using the C API doesn't work for you, using the C++ API is still an option. I'm currently working on making the C++ API more user-friendly (e.g. distributing binaries so you don't have to build from source), and I'll be sure to include this feature request, but it might not be available for a while.</p>", "body_text": "@pdrews I would recommend using the C API for now. As you mentioned, it's more verbose but might make your project build simpler, and most importantly it already exposes the functionality you need :) Unfortunately we lack documentation on it so here's some info to get you started:\nBuilding: https://storage.googleapis.com/tensorflow/libtensorflow/libtensorflow-cpu-linux-x86_64-1.0.0.tar.gz is a pre-built Linux binary (CPU-only, I'm assuming your robot doesn't have a GPU). I believe this should work if ROS is built on top of a standard Linux distro. Otherwise it sounds like you have already figured out how to build from source.\nUsage: Here's an example on how to load and run a graph:\nTF_Status* s = TF_NewStatus();\nTF_Graph* graph = TF_NewGraph();\n\nconst char* graph_def_data; // <-- your serialized GraphDef here\nTF_Buffer graph_def = {graph_def_data, strlen(graph_def_data), nullptr};\n\n// Import `graph_def` into `graph`\nTF_ImportGraphDefOptions* import_opts = TF_NewImportGraphDefOptions();\nTF_ImportGraphDefOptionsSetPrefix(import_opts, \"import\");\nTF_GraphImportGraphDef(graph, &graph_def, import_opts, s);\nassert(TF_GetCode(s) == TF_OK);\n\n// Setup graph inputs\nstd::vector<TF_Output> inputs;\nstd::vector<TF_Tensor*> input_values;\n// Add the placeholders you would like to feed, e.g.:\nTF_Operation* placeholder = TF_GraphOperationByName(graph, \"import/my_placeholder\");\ninputs.push_back({placeholder, 0});\nTF_Tensor* tensor = TF_NewTensor(/*...*/);\ninput_values.push_back(tensor);\n\n// Setup graph outputs\nstd::vector<TF_Output> outputs;\n// Add the node outputs you would like to fetch, e.g.:\nTF_Operation* output_op = TF_GraphOperationByName(graph, \"import/my_output\");\noutputs.push_back({output_op, 0});\nstd::vector<TF_Tensor*> output_values(outputs.size(), nullptr);\n\n// Run `graph`\nTF_SessionOptions* sess_opts = TF_NewSessionOptions();\nTF_Session* session = TF_NewSession(graph, sess_opts, s);\nassert(TF_GetCode(s) == TF_OK);\nTF_SessionRun(session, nullptr,\n              &inputs[0], &input_values[0], inputs.size(),\n              &outputs[0], &output_values[0], outputs.size(),\n              nullptr, 0, nullptr, s);\n\nvoid* output_data = TF_TensorData(output_values[0]);\nassert(TF_GetCode(s) == TF_OK);\n\n// If you have a more complicated workflow, I suggest making scoped wrapper\n// classes that call these in their destructors\nfor (int i = 0; i < inputs.size(); ++i) TF_DeleteTensor(input_values[i]);\nfor (int i = 0; i < outputs.size(); ++i) TF_DeleteTensor(output_values[i]);\nTF_CloseSession(session, s);\nTF_DeleteSession(session, s);\nTF_DeleteSessionOptions(sess_opts);\nTF_DeleteImportGraphDefOptions(import_opts);\nTF_DeleteGraph(graph);\nTF_DeleteStatus(s);\nFull disclosure, I didn't actually run this code, so please let me know if you run into problems. For details please refer to the C API header. The C API test has more examples for how to use the code.\nIf using the C API doesn't work for you, using the C++ API is still an option. I'm currently working on making the C++ API more user-friendly (e.g. distributing binaries so you don't have to build from source), and I'll be sure to include this feature request, but it might not be available for a while.", "body": "@pdrews I would recommend using the C API for now. As you mentioned, it's more verbose but might make your project build simpler, and most importantly it already exposes the functionality you need :) Unfortunately we lack documentation on it so here's some info to get you started:\r\n\r\n_Building:_ https://storage.googleapis.com/tensorflow/libtensorflow/libtensorflow-cpu-linux-x86_64-1.0.0.tar.gz is a pre-built Linux binary (CPU-only, I'm assuming your robot doesn't have a GPU). I believe this should work if ROS is built on top of a standard Linux distro. Otherwise it sounds like you have already figured out how to build from source.\r\n\r\n_Usage_: Here's an example on how to load and run a graph:\r\n```c++\r\nTF_Status* s = TF_NewStatus();\r\nTF_Graph* graph = TF_NewGraph();\r\n\r\nconst char* graph_def_data; // <-- your serialized GraphDef here\r\nTF_Buffer graph_def = {graph_def_data, strlen(graph_def_data), nullptr};\r\n\r\n// Import `graph_def` into `graph`\r\nTF_ImportGraphDefOptions* import_opts = TF_NewImportGraphDefOptions();\r\nTF_ImportGraphDefOptionsSetPrefix(import_opts, \"import\");\r\nTF_GraphImportGraphDef(graph, &graph_def, import_opts, s);\r\nassert(TF_GetCode(s) == TF_OK);\r\n\r\n// Setup graph inputs\r\nstd::vector<TF_Output> inputs;\r\nstd::vector<TF_Tensor*> input_values;\r\n// Add the placeholders you would like to feed, e.g.:\r\nTF_Operation* placeholder = TF_GraphOperationByName(graph, \"import/my_placeholder\");\r\ninputs.push_back({placeholder, 0});\r\nTF_Tensor* tensor = TF_NewTensor(/*...*/);\r\ninput_values.push_back(tensor);\r\n\r\n// Setup graph outputs\r\nstd::vector<TF_Output> outputs;\r\n// Add the node outputs you would like to fetch, e.g.:\r\nTF_Operation* output_op = TF_GraphOperationByName(graph, \"import/my_output\");\r\noutputs.push_back({output_op, 0});\r\nstd::vector<TF_Tensor*> output_values(outputs.size(), nullptr);\r\n\r\n// Run `graph`\r\nTF_SessionOptions* sess_opts = TF_NewSessionOptions();\r\nTF_Session* session = TF_NewSession(graph, sess_opts, s);\r\nassert(TF_GetCode(s) == TF_OK);\r\nTF_SessionRun(session, nullptr,\r\n              &inputs[0], &input_values[0], inputs.size(),\r\n              &outputs[0], &output_values[0], outputs.size(),\r\n              nullptr, 0, nullptr, s);\r\n\r\nvoid* output_data = TF_TensorData(output_values[0]);\r\nassert(TF_GetCode(s) == TF_OK);\r\n\r\n// If you have a more complicated workflow, I suggest making scoped wrapper\r\n// classes that call these in their destructors\r\nfor (int i = 0; i < inputs.size(); ++i) TF_DeleteTensor(input_values[i]);\r\nfor (int i = 0; i < outputs.size(); ++i) TF_DeleteTensor(output_values[i]);\r\nTF_CloseSession(session, s);\r\nTF_DeleteSession(session, s);\r\nTF_DeleteSessionOptions(sess_opts);\r\nTF_DeleteImportGraphDefOptions(import_opts);\r\nTF_DeleteGraph(graph);\r\nTF_DeleteStatus(s);\r\n```\r\nFull disclosure, I didn't actually run this code, so please let me know if you run into problems. For details please refer to the [C API header](https://github.com/tensorflow/tensorflow/blob/r1.0/tensorflow/c/c_api.h). The [C API test](https://github.com/tensorflow/tensorflow/blob/r1.0/tensorflow/c/c_api_test.cc) has more examples for how to use the code.\r\n\r\nIf using the C API doesn't work for you, using the C++ API is still an option. I'm currently working on making the C++ API more user-friendly (e.g. distributing binaries so you don't have to build from source), and I'll be sure to include this feature request, but it might not be available for a while."}