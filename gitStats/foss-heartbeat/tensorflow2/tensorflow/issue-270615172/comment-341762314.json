{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/341762314", "html_url": "https://github.com/tensorflow/tensorflow/issues/14181#issuecomment-341762314", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/14181", "id": 341762314, "node_id": "MDEyOklzc3VlQ29tbWVudDM0MTc2MjMxNA==", "user": {"login": "allenlavoie", "id": 3731025, "node_id": "MDQ6VXNlcjM3MzEwMjU=", "avatar_url": "https://avatars3.githubusercontent.com/u/3731025?v=4", "gravatar_id": "", "url": "https://api.github.com/users/allenlavoie", "html_url": "https://github.com/allenlavoie", "followers_url": "https://api.github.com/users/allenlavoie/followers", "following_url": "https://api.github.com/users/allenlavoie/following{/other_user}", "gists_url": "https://api.github.com/users/allenlavoie/gists{/gist_id}", "starred_url": "https://api.github.com/users/allenlavoie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/allenlavoie/subscriptions", "organizations_url": "https://api.github.com/users/allenlavoie/orgs", "repos_url": "https://api.github.com/users/allenlavoie/repos", "events_url": "https://api.github.com/users/allenlavoie/events{/privacy}", "received_events_url": "https://api.github.com/users/allenlavoie/received_events", "type": "User", "site_admin": false}, "created_at": "2017-11-03T16:50:45Z", "updated_at": "2017-11-03T16:50:45Z", "author_association": "MEMBER", "body_html": "<p>As long as we have reference cycles we're at the mercy of Python's garbage collection strategy. We could add some explicit <code>gc.collect()</code> calls in places (when popping the graph stack?), but for graph mode in TF 1.x I think that's the best we can do.</p>\n<p><code>graph.get_operations()[0].graph</code> is one definite reference cycle. I don't think this is something we can solve with weakref for graph mode while maintaining API compatibility; we're pretty explicit about holding on to an operation being enough to execute it (needs the graph) and holding on to the graph being enough to execute it (needs the operation).</p>\n<p>So eager mode may help, where we will (eventually) try to avoid most reference cycles and so will hopefully not need the garbage collector much. But there are definitely reference cycles there too at the moment.</p>", "body_text": "As long as we have reference cycles we're at the mercy of Python's garbage collection strategy. We could add some explicit gc.collect() calls in places (when popping the graph stack?), but for graph mode in TF 1.x I think that's the best we can do.\ngraph.get_operations()[0].graph is one definite reference cycle. I don't think this is something we can solve with weakref for graph mode while maintaining API compatibility; we're pretty explicit about holding on to an operation being enough to execute it (needs the graph) and holding on to the graph being enough to execute it (needs the operation).\nSo eager mode may help, where we will (eventually) try to avoid most reference cycles and so will hopefully not need the garbage collector much. But there are definitely reference cycles there too at the moment.", "body": "As long as we have reference cycles we're at the mercy of Python's garbage collection strategy. We could add some explicit `gc.collect()` calls in places (when popping the graph stack?), but for graph mode in TF 1.x I think that's the best we can do.\r\n\r\n`graph.get_operations()[0].graph` is one definite reference cycle. I don't think this is something we can solve with weakref for graph mode while maintaining API compatibility; we're pretty explicit about holding on to an operation being enough to execute it (needs the graph) and holding on to the graph being enough to execute it (needs the operation).\r\n\r\nSo eager mode may help, where we will (eventually) try to avoid most reference cycles and so will hopefully not need the garbage collector much. But there are definitely reference cycles there too at the moment."}