{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/387701185", "html_url": "https://github.com/tensorflow/tensorflow/issues/19069#issuecomment-387701185", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/19069", "id": 387701185, "node_id": "MDEyOklzc3VlQ29tbWVudDM4NzcwMTE4NQ==", "user": {"login": "marhlder", "id": 2690031, "node_id": "MDQ6VXNlcjI2OTAwMzE=", "avatar_url": "https://avatars0.githubusercontent.com/u/2690031?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marhlder", "html_url": "https://github.com/marhlder", "followers_url": "https://api.github.com/users/marhlder/followers", "following_url": "https://api.github.com/users/marhlder/following{/other_user}", "gists_url": "https://api.github.com/users/marhlder/gists{/gist_id}", "starred_url": "https://api.github.com/users/marhlder/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marhlder/subscriptions", "organizations_url": "https://api.github.com/users/marhlder/orgs", "repos_url": "https://api.github.com/users/marhlder/repos", "events_url": "https://api.github.com/users/marhlder/events{/privacy}", "received_events_url": "https://api.github.com/users/marhlder/received_events", "type": "User", "site_admin": false}, "created_at": "2018-05-09T10:53:38Z", "updated_at": "2018-05-09T12:06:48Z", "author_association": "NONE", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=15258583\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/josh11b\">@josh11b</a> Simply delaying the initialization in MirroredStrategy seems to work for the above given code snippet:</p>\n<pre><code>with tape.stop_recording():\n  index = {}\n  for i, d in enumerate(devices):\n    with ops.device(d):\n      if i &gt; 0:\n        # Give replicas meaningful distinct names:\n        var0name = index[devices[0]].name.split(\":\")[0]\n        kwargs[\"name\"] = \"%s/replica_%d\" % (var0name, i)\n        # Initialize replicas with the same value:\n        if context.executing_eagerly():\n          initial_value = array_ops.identity(index[devices[0]].value())\n        else:\n          def initial_value_fn():\n            with ops.device(d):\n              initial_value = index[devices[0]].initial_value\n              return array_ops.identity(initial_value)\n\n          initial_value = initial_value_fn\n\n        kwargs[\"initial_value\"] = initial_value\n      with context.context().device_policy(context.DEVICE_PLACEMENT_SILENT):\n        v = next_creator(*args, **kwargs)\n      assert not isinstance(v, values.DistributedVariable)\n      index[d] = v\n</code></pre>\n<p>It did however expose another problem. The default accumulation method (tf.add_n) does not seem to support sparse gradients (i.e. IndexedSlices), which I guess is the product of me using tf.nn.sparse_softmax_cross_entropy_with_logits as my error function or my tf.gather operations. Will investigate further.</p>", "body_text": "@josh11b Simply delaying the initialization in MirroredStrategy seems to work for the above given code snippet:\nwith tape.stop_recording():\n  index = {}\n  for i, d in enumerate(devices):\n    with ops.device(d):\n      if i > 0:\n        # Give replicas meaningful distinct names:\n        var0name = index[devices[0]].name.split(\":\")[0]\n        kwargs[\"name\"] = \"%s/replica_%d\" % (var0name, i)\n        # Initialize replicas with the same value:\n        if context.executing_eagerly():\n          initial_value = array_ops.identity(index[devices[0]].value())\n        else:\n          def initial_value_fn():\n            with ops.device(d):\n              initial_value = index[devices[0]].initial_value\n              return array_ops.identity(initial_value)\n\n          initial_value = initial_value_fn\n\n        kwargs[\"initial_value\"] = initial_value\n      with context.context().device_policy(context.DEVICE_PLACEMENT_SILENT):\n        v = next_creator(*args, **kwargs)\n      assert not isinstance(v, values.DistributedVariable)\n      index[d] = v\n\nIt did however expose another problem. The default accumulation method (tf.add_n) does not seem to support sparse gradients (i.e. IndexedSlices), which I guess is the product of me using tf.nn.sparse_softmax_cross_entropy_with_logits as my error function or my tf.gather operations. Will investigate further.", "body": "@josh11b Simply delaying the initialization in MirroredStrategy seems to work for the above given code snippet:\r\n\r\n```\r\nwith tape.stop_recording():\r\n  index = {}\r\n  for i, d in enumerate(devices):\r\n    with ops.device(d):\r\n      if i > 0:\r\n        # Give replicas meaningful distinct names:\r\n        var0name = index[devices[0]].name.split(\":\")[0]\r\n        kwargs[\"name\"] = \"%s/replica_%d\" % (var0name, i)\r\n        # Initialize replicas with the same value:\r\n        if context.executing_eagerly():\r\n          initial_value = array_ops.identity(index[devices[0]].value())\r\n        else:\r\n          def initial_value_fn():\r\n            with ops.device(d):\r\n              initial_value = index[devices[0]].initial_value\r\n              return array_ops.identity(initial_value)\r\n\r\n          initial_value = initial_value_fn\r\n\r\n        kwargs[\"initial_value\"] = initial_value\r\n      with context.context().device_policy(context.DEVICE_PLACEMENT_SILENT):\r\n        v = next_creator(*args, **kwargs)\r\n      assert not isinstance(v, values.DistributedVariable)\r\n      index[d] = v\r\n```\r\nIt did however expose another problem. The default accumulation method (tf.add_n) does not seem to support sparse gradients (i.e. IndexedSlices), which I guess is the product of me using tf.nn.sparse_softmax_cross_entropy_with_logits as my error function or my tf.gather operations. Will investigate further."}