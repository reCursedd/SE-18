{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9188", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9188/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9188/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9188/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/9188", "id": 221560933, "node_id": "MDU6SXNzdWUyMjE1NjA5MzM=", "number": 9188, "title": "Improving tf.cond", "user": {"login": "gaohuazuo", "id": 10446514, "node_id": "MDQ6VXNlcjEwNDQ2NTE0", "avatar_url": "https://avatars0.githubusercontent.com/u/10446514?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gaohuazuo", "html_url": "https://github.com/gaohuazuo", "followers_url": "https://api.github.com/users/gaohuazuo/followers", "following_url": "https://api.github.com/users/gaohuazuo/following{/other_user}", "gists_url": "https://api.github.com/users/gaohuazuo/gists{/gist_id}", "starred_url": "https://api.github.com/users/gaohuazuo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gaohuazuo/subscriptions", "organizations_url": "https://api.github.com/users/gaohuazuo/orgs", "repos_url": "https://api.github.com/users/gaohuazuo/repos", "events_url": "https://api.github.com/users/gaohuazuo/events{/privacy}", "received_events_url": "https://api.github.com/users/gaohuazuo/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 390482148, "node_id": "MDU6TGFiZWwzOTA0ODIxNDg=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/awaiting%20review", "name": "awaiting review", "color": "fef2c0", "default": false}], "state": "closed", "locked": false, "assignee": {"login": "yuanbyu", "id": 2342391, "node_id": "MDQ6VXNlcjIzNDIzOTE=", "avatar_url": "https://avatars1.githubusercontent.com/u/2342391?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yuanbyu", "html_url": "https://github.com/yuanbyu", "followers_url": "https://api.github.com/users/yuanbyu/followers", "following_url": "https://api.github.com/users/yuanbyu/following{/other_user}", "gists_url": "https://api.github.com/users/yuanbyu/gists{/gist_id}", "starred_url": "https://api.github.com/users/yuanbyu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yuanbyu/subscriptions", "organizations_url": "https://api.github.com/users/yuanbyu/orgs", "repos_url": "https://api.github.com/users/yuanbyu/repos", "events_url": "https://api.github.com/users/yuanbyu/events{/privacy}", "received_events_url": "https://api.github.com/users/yuanbyu/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "yuanbyu", "id": 2342391, "node_id": "MDQ6VXNlcjIzNDIzOTE=", "avatar_url": "https://avatars1.githubusercontent.com/u/2342391?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yuanbyu", "html_url": "https://github.com/yuanbyu", "followers_url": "https://api.github.com/users/yuanbyu/followers", "following_url": "https://api.github.com/users/yuanbyu/following{/other_user}", "gists_url": "https://api.github.com/users/yuanbyu/gists{/gist_id}", "starred_url": "https://api.github.com/users/yuanbyu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yuanbyu/subscriptions", "organizations_url": "https://api.github.com/users/yuanbyu/orgs", "repos_url": "https://api.github.com/users/yuanbyu/repos", "events_url": "https://api.github.com/users/yuanbyu/events{/privacy}", "received_events_url": "https://api.github.com/users/yuanbyu/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 1, "created_at": "2017-04-13T13:19:20Z", "updated_at": "2017-06-16T21:10:43Z", "closed_at": "2017-06-16T21:10:43Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Currently <code>tf.cond</code> requires a function for each branch, which makes no difference semantically but serves as an optimization hint. Such requirement becomes quite inconvenient in some cases, for example,</p>\n<pre><code>def build_graph(p1, p2):\n    a = a_fn() # Redundant when p1 and p2 are both false.\n    b1 = tf.cond(p1, lambda: a, b1_fn)\n    b2 = tf.cond(p2, lambda: a, b2_fn)\n    return b1, b2\n\n# An alternative\ndef build_graph(p1, p2):\n    # Redundant computation when p1 and p2 are both true.\n    b1 = tf.cond(p1, a_fn, b1_fn)\n    b2 = tf.cond(p2, a_fn, b2_fn)\n    return b1, b2\n</code></pre>\n<p>Though possible, it is not so straightforward to transform the above graph into an efficient one. In fact, we don't really need the optimization hint. Once target nodes are known, the exact execution condition for each node can be readily calculated. Furthermore, these conditions can be implemented using existing <code>Switch</code> and <code>Merge</code> ops. I have made a prototype to illustrate the idea at <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"221569625\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/tensorflow/tensorflow/issues/9189\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/tensorflow/tensorflow/pull/9189/hovercard\" href=\"https://github.com/tensorflow/tensorflow/pull/9189\">#9189</a>.</p>", "body_text": "Currently tf.cond requires a function for each branch, which makes no difference semantically but serves as an optimization hint. Such requirement becomes quite inconvenient in some cases, for example,\ndef build_graph(p1, p2):\n    a = a_fn() # Redundant when p1 and p2 are both false.\n    b1 = tf.cond(p1, lambda: a, b1_fn)\n    b2 = tf.cond(p2, lambda: a, b2_fn)\n    return b1, b2\n\n# An alternative\ndef build_graph(p1, p2):\n    # Redundant computation when p1 and p2 are both true.\n    b1 = tf.cond(p1, a_fn, b1_fn)\n    b2 = tf.cond(p2, a_fn, b2_fn)\n    return b1, b2\n\nThough possible, it is not so straightforward to transform the above graph into an efficient one. In fact, we don't really need the optimization hint. Once target nodes are known, the exact execution condition for each node can be readily calculated. Furthermore, these conditions can be implemented using existing Switch and Merge ops. I have made a prototype to illustrate the idea at #9189.", "body": "Currently `tf.cond` requires a function for each branch, which makes no difference semantically but serves as an optimization hint. Such requirement becomes quite inconvenient in some cases, for example,\r\n\r\n```\r\ndef build_graph(p1, p2):\r\n    a = a_fn() # Redundant when p1 and p2 are both false.\r\n    b1 = tf.cond(p1, lambda: a, b1_fn)\r\n    b2 = tf.cond(p2, lambda: a, b2_fn)\r\n    return b1, b2\r\n\r\n# An alternative\r\ndef build_graph(p1, p2):\r\n    # Redundant computation when p1 and p2 are both true.\r\n    b1 = tf.cond(p1, a_fn, b1_fn)\r\n    b2 = tf.cond(p2, a_fn, b2_fn)\r\n    return b1, b2\r\n```\r\n\r\nThough possible, it is not so straightforward to transform the above graph into an efficient one. In fact, we don't really need the optimization hint. Once target nodes are known, the exact execution condition for each node can be readily calculated. Furthermore, these conditions can be implemented using existing `Switch` and `Merge` ops. I have made a prototype to illustrate the idea at https://github.com/tensorflow/tensorflow/pull/9189."}