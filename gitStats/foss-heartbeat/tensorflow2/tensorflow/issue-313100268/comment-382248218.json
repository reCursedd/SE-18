{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/382248218", "html_url": "https://github.com/tensorflow/tensorflow/issues/18397#issuecomment-382248218", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/18397", "id": 382248218, "node_id": "MDEyOklzc3VlQ29tbWVudDM4MjI0ODIxOA==", "user": {"login": "saudet", "id": 3328023, "node_id": "MDQ6VXNlcjMzMjgwMjM=", "avatar_url": "https://avatars1.githubusercontent.com/u/3328023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saudet", "html_url": "https://github.com/saudet", "followers_url": "https://api.github.com/users/saudet/followers", "following_url": "https://api.github.com/users/saudet/following{/other_user}", "gists_url": "https://api.github.com/users/saudet/gists{/gist_id}", "starred_url": "https://api.github.com/users/saudet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saudet/subscriptions", "organizations_url": "https://api.github.com/users/saudet/orgs", "repos_url": "https://api.github.com/users/saudet/repos", "events_url": "https://api.github.com/users/saudet/events{/privacy}", "received_events_url": "https://api.github.com/users/saudet/received_events", "type": "User", "site_admin": false}, "created_at": "2018-04-18T03:46:55Z", "updated_at": "2018-04-18T03:46:55Z", "author_association": "NONE", "body_html": "<p>Yes, there needs to be some kind of system for that. JavaCPP doesn't use directly Maven coordinates because they are not available when running from an uber JAR, for example, as required by Spark, or just for a standalone application. Instead, it uses the filename of the JAR file itself plus of the path to the files inside it, which happen to contain the Maven coordinates when loaded with it.</p>\n<p>BTW, including additional resources such as header files in the JAR file and extracting them to a cache like this also allows C++ libraries to link with it, not just Java libraries. That's what is happening with, for example, Caffe depending on OpenCV, OpenBLAS, and HDF5 here: <a href=\"https://github.com/bytedeco/javacpp-presets/blob/master/caffe/pom.xml#L17-L37\">https://github.com/bytedeco/javacpp-presets/blob/master/caffe/pom.xml#L17-L37</a>  Though, in the case of TensorFlow, I'm assuming everything can be managed with Bazel...</p>", "body_text": "Yes, there needs to be some kind of system for that. JavaCPP doesn't use directly Maven coordinates because they are not available when running from an uber JAR, for example, as required by Spark, or just for a standalone application. Instead, it uses the filename of the JAR file itself plus of the path to the files inside it, which happen to contain the Maven coordinates when loaded with it.\nBTW, including additional resources such as header files in the JAR file and extracting them to a cache like this also allows C++ libraries to link with it, not just Java libraries. That's what is happening with, for example, Caffe depending on OpenCV, OpenBLAS, and HDF5 here: https://github.com/bytedeco/javacpp-presets/blob/master/caffe/pom.xml#L17-L37  Though, in the case of TensorFlow, I'm assuming everything can be managed with Bazel...", "body": "Yes, there needs to be some kind of system for that. JavaCPP doesn't use directly Maven coordinates because they are not available when running from an uber JAR, for example, as required by Spark, or just for a standalone application. Instead, it uses the filename of the JAR file itself plus of the path to the files inside it, which happen to contain the Maven coordinates when loaded with it.\r\n\r\nBTW, including additional resources such as header files in the JAR file and extracting them to a cache like this also allows C++ libraries to link with it, not just Java libraries. That's what is happening with, for example, Caffe depending on OpenCV, OpenBLAS, and HDF5 here: https://github.com/bytedeco/javacpp-presets/blob/master/caffe/pom.xml#L17-L37  Though, in the case of TensorFlow, I'm assuming everything can be managed with Bazel..."}