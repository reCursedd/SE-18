{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/18397", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/18397/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/18397/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/18397/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/18397", "id": 313100268, "node_id": "MDU6SXNzdWUzMTMxMDAyNjg=", "number": 18397, "title": "Java wrapper floods temp dir with copies of extracted native library", "user": {"login": "sabi0", "id": 11509875, "node_id": "MDQ6VXNlcjExNTA5ODc1", "avatar_url": "https://avatars3.githubusercontent.com/u/11509875?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sabi0", "html_url": "https://github.com/sabi0", "followers_url": "https://api.github.com/users/sabi0/followers", "following_url": "https://api.github.com/users/sabi0/following{/other_user}", "gists_url": "https://api.github.com/users/sabi0/gists{/gist_id}", "starred_url": "https://api.github.com/users/sabi0/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sabi0/subscriptions", "organizations_url": "https://api.github.com/users/sabi0/orgs", "repos_url": "https://api.github.com/users/sabi0/repos", "events_url": "https://api.github.com/users/sabi0/events{/privacy}", "received_events_url": "https://api.github.com/users/sabi0/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 299643928, "node_id": "MDU6TGFiZWwyOTk2NDM5Mjg=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:contributions%20welcome", "name": "stat:contributions welcome", "color": "f4b400", "default": false}, {"id": 473172988, "node_id": "MDU6TGFiZWw0NzMxNzI5ODg=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:bug/performance", "name": "type:bug/performance", "color": "159b2e", "default": false}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 9, "created_at": "2018-04-10T21:44:15Z", "updated_at": "2018-04-18T03:46:55Z", "closed_at": null, "author_association": "NONE", "body_html": "<h3>System information</h3>\n<ul>\n<li><strong>Have I written custom code (as opposed to using a stock example script provided in TensorFlow)</strong>: No</li>\n<li><strong>OS Platform and Distribution (e.g., Linux Ubuntu 16.04)</strong>: Windows 7 x64</li>\n<li><strong>TensorFlow installed from (source or binary)</strong>: Binary</li>\n<li><strong>TensorFlow version (use command below)</strong>: 1.5.0</li>\n<li><strong>Python version</strong>: N/A</li>\n<li><strong>Bazel version (if compiling from source)</strong>: N/A</li>\n<li><strong>GCC/Compiler version (if compiling from source)</strong>: N/A</li>\n<li><strong>CUDA/cuDNN version</strong>: N/A</li>\n<li><strong>GPU model and memory</strong>: N/A</li>\n<li><strong>Exact command to reproduce</strong>: None</li>\n</ul>\n<h3>Describe the problem</h3>\n<p>I've been working on a Java application that uses TensorFlow. I launched it thousand times - unit tests, debugging sessions, etc. And at some point I discovered I had 8 GB of tensorflow_jni.dll copies in my Temp directory.</p>\n<p>Apparently <code>deleteOnExit()</code> is not enough to cleanup the extracted native library (<a href=\"https://github.com/tensorflow/tensorflow/blob/master/tensorflow/java/src/main/java/org/tensorflow/NativeLibrary.java#L150\">NativeLibrary.java:150</a>). Not on Windows at least. It appears DLL is still loaded when the deletion is attempted. So the deletion fails and the DLL is left behind.</p>\n<p>A better approach would be to use semi-static path for library extraction rather than fully random.<br>\nIn such case the library could be deleted or re-used upon the next application run.</p>\n<p>I would suggest to use a target folder name like this:</p>\n<pre><code>File tmp = new File(System.getProperty(\"java.io.tmpdir\"));\nFile dir = new File(tmp, \"tensorflow-\" + TF_VERSION + '-' + System.getProperty(\"user.name\").hashCode());\n</code></pre>\n<p>And then check if the folder and files exist already upon startup. And either delete them and extract again (better security) or just call <code>System.loadLibrary()</code> directly.</p>\n<p>You could still keep using <code>deleteOnExit()</code>. When it works properly the only copy of the library will not be left laying on the disk after JVM shutdown.</p>\n<p>A similar approach is used by other native libraries handling frameworks. For example, in JNA project.<br>\nSee <a href=\"https://github.com/java-native-access/jna/blob/master/src/com/sun/jna/Native.java\">https://github.com/java-native-access/jna/blob/master/src/com/sun/jna/Native.java</a></p>", "body_text": "System information\n\nHave I written custom code (as opposed to using a stock example script provided in TensorFlow): No\nOS Platform and Distribution (e.g., Linux Ubuntu 16.04): Windows 7 x64\nTensorFlow installed from (source or binary): Binary\nTensorFlow version (use command below): 1.5.0\nPython version: N/A\nBazel version (if compiling from source): N/A\nGCC/Compiler version (if compiling from source): N/A\nCUDA/cuDNN version: N/A\nGPU model and memory: N/A\nExact command to reproduce: None\n\nDescribe the problem\nI've been working on a Java application that uses TensorFlow. I launched it thousand times - unit tests, debugging sessions, etc. And at some point I discovered I had 8 GB of tensorflow_jni.dll copies in my Temp directory.\nApparently deleteOnExit() is not enough to cleanup the extracted native library (NativeLibrary.java:150). Not on Windows at least. It appears DLL is still loaded when the deletion is attempted. So the deletion fails and the DLL is left behind.\nA better approach would be to use semi-static path for library extraction rather than fully random.\nIn such case the library could be deleted or re-used upon the next application run.\nI would suggest to use a target folder name like this:\nFile tmp = new File(System.getProperty(\"java.io.tmpdir\"));\nFile dir = new File(tmp, \"tensorflow-\" + TF_VERSION + '-' + System.getProperty(\"user.name\").hashCode());\n\nAnd then check if the folder and files exist already upon startup. And either delete them and extract again (better security) or just call System.loadLibrary() directly.\nYou could still keep using deleteOnExit(). When it works properly the only copy of the library will not be left laying on the disk after JVM shutdown.\nA similar approach is used by other native libraries handling frameworks. For example, in JNA project.\nSee https://github.com/java-native-access/jna/blob/master/src/com/sun/jna/Native.java", "body": "### System information\r\n- **Have I written custom code (as opposed to using a stock example script provided in TensorFlow)**: No\r\n- **OS Platform and Distribution (e.g., Linux Ubuntu 16.04)**: Windows 7 x64\r\n- **TensorFlow installed from (source or binary)**: Binary\r\n- **TensorFlow version (use command below)**: 1.5.0\r\n- **Python version**: N/A\r\n- **Bazel version (if compiling from source)**: N/A\r\n- **GCC/Compiler version (if compiling from source)**: N/A\r\n- **CUDA/cuDNN version**: N/A\r\n- **GPU model and memory**: N/A\r\n- **Exact command to reproduce**: None\r\n\r\n### Describe the problem\r\n\r\nI've been working on a Java application that uses TensorFlow. I launched it thousand times - unit tests, debugging sessions, etc. And at some point I discovered I had 8 GB of tensorflow_jni.dll copies in my Temp directory.\r\n\r\nApparently `deleteOnExit()` is not enough to cleanup the extracted native library ([NativeLibrary.java:150](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/java/src/main/java/org/tensorflow/NativeLibrary.java#L150)). Not on Windows at least. It appears DLL is still loaded when the deletion is attempted. So the deletion fails and the DLL is left behind.\r\n\r\nA better approach would be to use semi-static path for library extraction rather than fully random.\r\nIn such case the library could be deleted or re-used upon the next application run.\r\n\r\nI would suggest to use a target folder name like this:\r\n```\r\nFile tmp = new File(System.getProperty(\"java.io.tmpdir\"));\r\nFile dir = new File(tmp, \"tensorflow-\" + TF_VERSION + '-' + System.getProperty(\"user.name\").hashCode());\r\n```\r\n\r\nAnd then check if the folder and files exist already upon startup. And either delete them and extract again (better security) or just call `System.loadLibrary()` directly.\r\n\r\nYou could still keep using `deleteOnExit()`. When it works properly the only copy of the library will not be left laying on the disk after JVM shutdown.\r\n\r\nA similar approach is used by other native libraries handling frameworks. For example, in JNA project.\r\nSee https://github.com/java-native-access/jna/blob/master/src/com/sun/jna/Native.java"}