{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/381556411", "html_url": "https://github.com/tensorflow/tensorflow/issues/18397#issuecomment-381556411", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/18397", "id": 381556411, "node_id": "MDEyOklzc3VlQ29tbWVudDM4MTU1NjQxMQ==", "user": {"login": "saudet", "id": 3328023, "node_id": "MDQ6VXNlcjMzMjgwMjM=", "avatar_url": "https://avatars1.githubusercontent.com/u/3328023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saudet", "html_url": "https://github.com/saudet", "followers_url": "https://api.github.com/users/saudet/followers", "following_url": "https://api.github.com/users/saudet/following{/other_user}", "gists_url": "https://api.github.com/users/saudet/gists{/gist_id}", "starred_url": "https://api.github.com/users/saudet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saudet/subscriptions", "organizations_url": "https://api.github.com/users/saudet/orgs", "repos_url": "https://api.github.com/users/saudet/repos", "events_url": "https://api.github.com/users/saudet/events{/privacy}", "received_events_url": "https://api.github.com/users/saudet/received_events", "type": "User", "site_admin": false}, "created_at": "2018-04-16T10:38:12Z", "updated_at": "2018-04-16T10:38:12Z", "author_association": "NONE", "body_html": "<div class=\"email-fragment\">Extracting DLLs every time a new JVM is launched is inefficient though. For\nsomething as big as TensorFlow it takes a few seconds. Consider also that\nframeworks like Hadoop or Spark tend to launch multiple JVMs during\nexecution. That's another reason JavaCPP uses a cache. BTW, JNA is not\nperformance conscious so it's not a good reference if one is interested in\nefficiency.</div>", "body_text": "Extracting DLLs every time a new JVM is launched is inefficient though. For\nsomething as big as TensorFlow it takes a few seconds. Consider also that\nframeworks like Hadoop or Spark tend to launch multiple JVMs during\nexecution. That's another reason JavaCPP uses a cache. BTW, JNA is not\nperformance conscious so it's not a good reference if one is interested in\nefficiency.", "body": "Extracting DLLs every time a new JVM is launched is inefficient though. For\nsomething as big as TensorFlow it takes a few seconds. Consider also that\nframeworks like Hadoop or Spark tend to launch multiple JVMs during\nexecution. That's another reason JavaCPP uses a cache. BTW, JNA is not\nperformance conscious so it's not a good reference if one is interested in\nefficiency.\n"}