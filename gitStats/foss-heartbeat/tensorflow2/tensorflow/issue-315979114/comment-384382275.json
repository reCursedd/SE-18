{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/384382275", "html_url": "https://github.com/tensorflow/tensorflow/pull/18704#issuecomment-384382275", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/18704", "id": 384382275, "node_id": "MDEyOklzc3VlQ29tbWVudDM4NDM4MjI3NQ==", "user": {"login": "m3bm3b", "id": 10168793, "node_id": "MDQ6VXNlcjEwMTY4Nzkz", "avatar_url": "https://avatars0.githubusercontent.com/u/10168793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m3bm3b", "html_url": "https://github.com/m3bm3b", "followers_url": "https://api.github.com/users/m3bm3b/followers", "following_url": "https://api.github.com/users/m3bm3b/following{/other_user}", "gists_url": "https://api.github.com/users/m3bm3b/gists{/gist_id}", "starred_url": "https://api.github.com/users/m3bm3b/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m3bm3b/subscriptions", "organizations_url": "https://api.github.com/users/m3bm3b/orgs", "repos_url": "https://api.github.com/users/m3bm3b/repos", "events_url": "https://api.github.com/users/m3bm3b/events{/privacy}", "received_events_url": "https://api.github.com/users/m3bm3b/received_events", "type": "User", "site_admin": false}, "created_at": "2018-04-25T18:11:09Z", "updated_at": "2018-04-25T18:11:09Z", "author_association": "NONE", "body_html": "<p>Perhaps I am missing something, but<br>\nI'm struggling to see how using NoDestructor is better than writing:<br>\nT* Get() {<br>\nstatic T* t = new T;<br>\nreturn t;<br>\n}</p>\n<p>I see two issues:   1. readability and 2. resource usage.</p>\n<ol>\n<li>\n<p>From the readability point of view, NoDestructor seems to be worse:<br>\nThe example above is shorter and easier for<br>\nreaders to understand than the examples of using NoDestructor given<br>\nin the comments at the top of its header file.   This is especially so because NoDestructorreaders will<br>\nhave to look up the unfamiliar NoDestructor and understand why it's being used.<br>\n(It took me quite a while to understand what its technical advantage<br>\nmight be; see below.)</p>\n</li>\n<li>\n<p>The concrete advantage of NoDestructor mentioned in its description<br>\nis that it avoids a call to malloc().   However, tthe advantage is not<br>\nclear, because there is a trade off between space and time that the comments do not discuss.<br>\nNoDestructor avoids the malloc() by allocating the memory unconditionally<br>\nin the bss segment (and that memory will probably get faulted in by accesses<br>\nto nearby variables).   To avoid the malloc() is already of uncertain value,<br>\nbecause there are so few calls at stake.<br>\nIt's even more dubious because TensorFlow is a complex library, and we would not expect every<br>\nsuch static variable to be initialized in a given run.   Thus, some fraction of the memory<br>\nallocated in bss by NoDestructor will be wasted, while the malloc() approach<br>\nwould have saved that memory.  Given the small number of cycles involved,<br>\nmy bet is that few users will care.  But I suspect that the few that do care will prefer<br>\nthe dynamic allocation, because the memory is likely to be more precious than the cycles.</p>\n</li>\n</ol>\n<p>So unless there's another technical argument to be made,<br>\nI think the main effect of NoDestructor would be to make the code more complicated,<br>\nand I recommend against adopting it.</p>", "body_text": "Perhaps I am missing something, but\nI'm struggling to see how using NoDestructor is better than writing:\nT* Get() {\nstatic T* t = new T;\nreturn t;\n}\nI see two issues:   1. readability and 2. resource usage.\n\n\nFrom the readability point of view, NoDestructor seems to be worse:\nThe example above is shorter and easier for\nreaders to understand than the examples of using NoDestructor given\nin the comments at the top of its header file.   This is especially so because NoDestructorreaders will\nhave to look up the unfamiliar NoDestructor and understand why it's being used.\n(It took me quite a while to understand what its technical advantage\nmight be; see below.)\n\n\nThe concrete advantage of NoDestructor mentioned in its description\nis that it avoids a call to malloc().   However, tthe advantage is not\nclear, because there is a trade off between space and time that the comments do not discuss.\nNoDestructor avoids the malloc() by allocating the memory unconditionally\nin the bss segment (and that memory will probably get faulted in by accesses\nto nearby variables).   To avoid the malloc() is already of uncertain value,\nbecause there are so few calls at stake.\nIt's even more dubious because TensorFlow is a complex library, and we would not expect every\nsuch static variable to be initialized in a given run.   Thus, some fraction of the memory\nallocated in bss by NoDestructor will be wasted, while the malloc() approach\nwould have saved that memory.  Given the small number of cycles involved,\nmy bet is that few users will care.  But I suspect that the few that do care will prefer\nthe dynamic allocation, because the memory is likely to be more precious than the cycles.\n\n\nSo unless there's another technical argument to be made,\nI think the main effect of NoDestructor would be to make the code more complicated,\nand I recommend against adopting it.", "body": "Perhaps I am missing something, but \r\nI'm struggling to see how using NoDestructor is better than writing:\r\n   T* Get() {\r\n      static T* t = new T;\r\n      return t;\r\n   }\r\n\r\nI see two issues:   1. readability and 2. resource usage.\r\n\r\n1. From the readability point of view, NoDestructor seems to be worse:\r\nThe example above is shorter and easier for\r\nreaders to understand than the examples of using NoDestructor given \r\nin the comments at the top of its header file.   This is especially so because NoDestructorreaders will\r\nhave to look up the unfamiliar NoDestructor and understand why it's being used.   \r\n(It took me quite a while to understand what its technical advantage \r\nmight be; see below.)\r\n\r\n2. The concrete advantage of NoDestructor mentioned in its description\r\nis that it avoids a call to malloc().   However, tthe advantage is not\r\nclear, because there is a trade off between space and time that the comments do not discuss.\r\nNoDestructor avoids the malloc() by allocating the memory unconditionally\r\nin the bss segment (and that memory will probably get faulted in by accesses\r\nto nearby variables).   To avoid the malloc() is already of uncertain value, \r\nbecause there are so few calls at stake.\r\nIt's even more dubious because TensorFlow is a complex library, and we would not expect every \r\nsuch static variable to be initialized in a given run.   Thus, some fraction of the memory\r\nallocated in bss by NoDestructor will be wasted, while the malloc() approach \r\nwould have saved that memory.  Given the small number of cycles involved,\r\nmy bet is that few users will care.  But I suspect that the few that do care will prefer\r\nthe dynamic allocation, because the memory is likely to be more precious than the cycles.\r\n\r\nSo unless there's another technical argument to be made,\r\nI think the main effect of NoDestructor would be to make the code more complicated,\r\nand I recommend against adopting it.\r\n"}