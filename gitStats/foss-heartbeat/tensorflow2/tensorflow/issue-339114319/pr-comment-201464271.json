{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/201464271", "pull_request_review_id": 135971135, "id": 201464271, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTQ2NDI3MQ==", "diff_hunk": "@@ -1137,14 +1146,18 @@ TF_CAPI_EXPORT extern void TF_AbortWhile(const TF_WhileParams* params);\n // shapes in `y`.\n // The partial derivatives are returned in `dy`. `dy` should be allocated to\n // size `nx`.\n+// `prefix` names the scope into which all gradients operations are being added.\n+// If `prefix` is nullptr, \"gradients\" is used by default.", "path": "tensorflow/c/c_api.h", "position": null, "original_position": 21, "commit_id": "c01cfe7ced91dabc19b2392696cf0598a5df70f9", "original_commit_id": "f76c545c96f44bbcb753eb01aad45f519b974797", "user": {"login": "asimshankar", "id": 16018, "node_id": "MDQ6VXNlcjE2MDE4", "avatar_url": "https://avatars2.githubusercontent.com/u/16018?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asimshankar", "html_url": "https://github.com/asimshankar", "followers_url": "https://api.github.com/users/asimshankar/followers", "following_url": "https://api.github.com/users/asimshankar/following{/other_user}", "gists_url": "https://api.github.com/users/asimshankar/gists{/gist_id}", "starred_url": "https://api.github.com/users/asimshankar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asimshankar/subscriptions", "organizations_url": "https://api.github.com/users/asimshankar/orgs", "repos_url": "https://api.github.com/users/asimshankar/repos", "events_url": "https://api.github.com/users/asimshankar/events{/privacy}", "received_events_url": "https://api.github.com/users/asimshankar/received_events", "type": "User", "site_admin": false}, "body": "We may not use `prefix/` exactly, right? We might end up using `<prefix>_1/` etc.\r\nThough, I guess that still means that operations are prefixed with `prefix` :)\r\n\r\nI fear that this behavior may be confusing (e.g., one calls `TF_AddGradientsWithPrefix` with prefix `foo` and expects to analyze nodes added to the graph by looking for `foo/` as a prefix of the operation names, but doesn't find anything because the prefix is actually `foo_1`.\r\n\r\nI think if it would be clearer/better for `TF_AddGradientsWithPrefix` to:\r\n\r\n1. Fail on a NULL `prefix`.\r\n2. Fail if `prefix` clashes with an existing prefix.\r\n\r\nWhile `TF_AddGradients` retains its behavior (since it doesn't make any promises on the names of nodes added).\r\n\r\nWithout this behavior, I feel things may get hard to reason about (for example, in Java, one could create two `Scope` objects on the same `Graph` and easily mess up names). This will also be consistent with the behavior of other C API methods that add a node to the graph (`TF_FinishOperation` will fail if the name isn't unique).", "created_at": "2018-07-10T19:22:02Z", "updated_at": "2018-07-27T22:06:32Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/20609#discussion_r201464271", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/20609", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/201464271"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/20609#discussion_r201464271"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/20609"}}, "body_html": "<p>We may not use <code>prefix/</code> exactly, right? We might end up using <code>&lt;prefix&gt;_1/</code> etc.<br>\nThough, I guess that still means that operations are prefixed with <code>prefix</code> :)</p>\n<p>I fear that this behavior may be confusing (e.g., one calls <code>TF_AddGradientsWithPrefix</code> with prefix <code>foo</code> and expects to analyze nodes added to the graph by looking for <code>foo/</code> as a prefix of the operation names, but doesn't find anything because the prefix is actually <code>foo_1</code>.</p>\n<p>I think if it would be clearer/better for <code>TF_AddGradientsWithPrefix</code> to:</p>\n<ol>\n<li>Fail on a NULL <code>prefix</code>.</li>\n<li>Fail if <code>prefix</code> clashes with an existing prefix.</li>\n</ol>\n<p>While <code>TF_AddGradients</code> retains its behavior (since it doesn't make any promises on the names of nodes added).</p>\n<p>Without this behavior, I feel things may get hard to reason about (for example, in Java, one could create two <code>Scope</code> objects on the same <code>Graph</code> and easily mess up names). This will also be consistent with the behavior of other C API methods that add a node to the graph (<code>TF_FinishOperation</code> will fail if the name isn't unique).</p>", "body_text": "We may not use prefix/ exactly, right? We might end up using <prefix>_1/ etc.\nThough, I guess that still means that operations are prefixed with prefix :)\nI fear that this behavior may be confusing (e.g., one calls TF_AddGradientsWithPrefix with prefix foo and expects to analyze nodes added to the graph by looking for foo/ as a prefix of the operation names, but doesn't find anything because the prefix is actually foo_1.\nI think if it would be clearer/better for TF_AddGradientsWithPrefix to:\n\nFail on a NULL prefix.\nFail if prefix clashes with an existing prefix.\n\nWhile TF_AddGradients retains its behavior (since it doesn't make any promises on the names of nodes added).\nWithout this behavior, I feel things may get hard to reason about (for example, in Java, one could create two Scope objects on the same Graph and easily mess up names). This will also be consistent with the behavior of other C API methods that add a node to the graph (TF_FinishOperation will fail if the name isn't unique)."}