{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/233986385", "html_url": "https://github.com/tensorflow/tensorflow/issues/3311#issuecomment-233986385", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/3311", "id": 233986385, "node_id": "MDEyOklzc3VlQ29tbWVudDIzMzk4NjM4NQ==", "user": {"login": "cwhipkey", "id": 17578177, "node_id": "MDQ6VXNlcjE3NTc4MTc3", "avatar_url": "https://avatars0.githubusercontent.com/u/17578177?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cwhipkey", "html_url": "https://github.com/cwhipkey", "followers_url": "https://api.github.com/users/cwhipkey/followers", "following_url": "https://api.github.com/users/cwhipkey/following{/other_user}", "gists_url": "https://api.github.com/users/cwhipkey/gists{/gist_id}", "starred_url": "https://api.github.com/users/cwhipkey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cwhipkey/subscriptions", "organizations_url": "https://api.github.com/users/cwhipkey/orgs", "repos_url": "https://api.github.com/users/cwhipkey/repos", "events_url": "https://api.github.com/users/cwhipkey/events{/privacy}", "received_events_url": "https://api.github.com/users/cwhipkey/received_events", "type": "User", "site_admin": false}, "created_at": "2016-07-20T15:31:24Z", "updated_at": "2016-07-20T15:31:24Z", "author_association": "MEMBER", "body_html": "<p>I used the test body below and get noise always as (?, ?, ?), regardless of n.  xtilde is (?, ?, ?) when n = 1, and (?, ?, 2) when n = 2.</p>\n<p>This is because x + noise might broadcast x onto noise, and when the dim's value is 1 then the output dim could be 1 or the other side.  A fix is to use tf.add_n([x, noise]) - this ends up giving the right shape.   Does this workaround work for you?</p>\n<p>It seems that \"random_normal\" does not infer the output shape no matter what the final dim value.  I think it's because of tensor_util.py's _ConstantValue, where tensor.op.type == \"Shape\" is handled.</p>\n<pre><code>n = 1\nx = tf.placeholder(tf.float32, shape=(None, None, n), name='x')\nshp = tf.shape(x)\nnoise = tf.random_normal(shp, mean=0, stddev=1)\nprint(\"noise: \", noise.get_shape())\nxtilde = x + noise  # tf.add_n([x, noise])\nprint(\"xtilde: \", xtilde.get_shape())\n</code></pre>\n<p>Output:</p>\n<pre><code># Output when n = 1\nnoise:  (?, ?, ?)\nxtilde:  (?, ?, ?)\n\n# Output when n = 2\nnoise:  (?, ?, ?)\nxtilde:  (?, ?, 2)\n</code></pre>", "body_text": "I used the test body below and get noise always as (?, ?, ?), regardless of n.  xtilde is (?, ?, ?) when n = 1, and (?, ?, 2) when n = 2.\nThis is because x + noise might broadcast x onto noise, and when the dim's value is 1 then the output dim could be 1 or the other side.  A fix is to use tf.add_n([x, noise]) - this ends up giving the right shape.   Does this workaround work for you?\nIt seems that \"random_normal\" does not infer the output shape no matter what the final dim value.  I think it's because of tensor_util.py's _ConstantValue, where tensor.op.type == \"Shape\" is handled.\nn = 1\nx = tf.placeholder(tf.float32, shape=(None, None, n), name='x')\nshp = tf.shape(x)\nnoise = tf.random_normal(shp, mean=0, stddev=1)\nprint(\"noise: \", noise.get_shape())\nxtilde = x + noise  # tf.add_n([x, noise])\nprint(\"xtilde: \", xtilde.get_shape())\n\nOutput:\n# Output when n = 1\nnoise:  (?, ?, ?)\nxtilde:  (?, ?, ?)\n\n# Output when n = 2\nnoise:  (?, ?, ?)\nxtilde:  (?, ?, 2)", "body": "I used the test body below and get noise always as (?, ?, ?), regardless of n.  xtilde is (?, ?, ?) when n = 1, and (?, ?, 2) when n = 2.\n\nThis is because x + noise might broadcast x onto noise, and when the dim's value is 1 then the output dim could be 1 or the other side.  A fix is to use tf.add_n([x, noise]) - this ends up giving the right shape.   Does this workaround work for you?\n\nIt seems that \"random_normal\" does not infer the output shape no matter what the final dim value.  I think it's because of tensor_util.py's _ConstantValue, where tensor.op.type == \"Shape\" is handled.\n\n```\nn = 1\nx = tf.placeholder(tf.float32, shape=(None, None, n), name='x')\nshp = tf.shape(x)\nnoise = tf.random_normal(shp, mean=0, stddev=1)\nprint(\"noise: \", noise.get_shape())\nxtilde = x + noise  # tf.add_n([x, noise])\nprint(\"xtilde: \", xtilde.get_shape())\n```\n\nOutput:\n\n```\n# Output when n = 1\nnoise:  (?, ?, ?)\nxtilde:  (?, ?, ?)\n\n# Output when n = 2\nnoise:  (?, ?, ?)\nxtilde:  (?, ?, 2)\n```\n"}