{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/271206084", "html_url": "https://github.com/tensorflow/tensorflow/issues/6730#issuecomment-271206084", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/6730", "id": 271206084, "node_id": "MDEyOklzc3VlQ29tbWVudDI3MTIwNjA4NA==", "user": {"login": "usmcamp0811", "id": 17965629, "node_id": "MDQ6VXNlcjE3OTY1NjI5", "avatar_url": "https://avatars0.githubusercontent.com/u/17965629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/usmcamp0811", "html_url": "https://github.com/usmcamp0811", "followers_url": "https://api.github.com/users/usmcamp0811/followers", "following_url": "https://api.github.com/users/usmcamp0811/following{/other_user}", "gists_url": "https://api.github.com/users/usmcamp0811/gists{/gist_id}", "starred_url": "https://api.github.com/users/usmcamp0811/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/usmcamp0811/subscriptions", "organizations_url": "https://api.github.com/users/usmcamp0811/orgs", "repos_url": "https://api.github.com/users/usmcamp0811/repos", "events_url": "https://api.github.com/users/usmcamp0811/events{/privacy}", "received_events_url": "https://api.github.com/users/usmcamp0811/received_events", "type": "User", "site_admin": false}, "created_at": "2017-01-09T03:35:44Z", "updated_at": "2017-01-09T03:38:34Z", "author_association": "NONE", "body_html": "<p>More or less thats the code.. sorry to throw a ton of code on here.. I'm still pretty much a novice and if I did something wrong elsewhere didn't want to send anyone on a wild goose hunt. But like I said it runs about a quarter of the time no problem.. so I don't think its entirely me..</p>\n<pre><code>def read_and_decode(filename_queue,imshape=160*160*3):\n    reader = tf.TFRecordReader()\n    _, serialized_example = reader.read(filename_queue)\n    features = tf.parse_single_example(\n        serialized_example,\n        features={\n            'image_raw': tf.FixedLenFeature([], tf.string),\n            'label': tf.FixedLenFeature([], tf.int64),\n            'height': tf.FixedLenFeature([], tf.int64),\n            'width': tf.FixedLenFeature([], tf.int64),\n            'depth': tf.FixedLenFeature([], tf.int64)\n        })\n\n    image = tf.decode_raw(features['image_raw'], tf.uint8)\n    image.set_shape([imshape])\n    image = tf.cast(image, tf.float32)\n\n    label = tf.cast(features['label'], tf.int32)\n\n    return image, label\n\n\ndef inputs(train_dir, file, batch_size, num_epochs, n_classes, one_hot_labels=False, imshape=160*160*3):\n\n    if not num_epochs: num_epochs = None\n    filename = os.path.join(train_dir, file)\n\n    # with tf.name_scope('input'):\n    filename_queue = tf.train.string_input_producer(\n        [filename], num_epochs=num_epochs)\n\n    image, label = read_and_decode(filename_queue, imshape)\n\n    if one_hot_labels:\n        label = tf.one_hot(label, n_classes, dtype=tf.int32)\n\n    example_batch, label_batch = tf.train.shuffle_batch(\n        [image, label], batch_size=batch_size, num_threads=2,\n        capacity=1000, enqueue_many=False,\n        # Ensures a minimum amount of shuffling of examples.\n        min_after_dequeue=10, name=file)\n\n    return example_batch, label_batch\n\n def random_distorer(self, image):\n        image = tf.image.random_brightness(image, max_delta=32. / 255.)\n        image = tf.image.random_saturation(image, lower=0.5, upper=1.5)\n        image = tf.image.random_hue(image, max_delta=0.2)\n        image = tf.image.random_contrast(image, lower=0.5, upper=1.5)\n        image = tf.image.random_flip_up_down(image)\n        image = tf.image.random_flip_left_right(image)\n        return image`\n\n`    def train(self, training_data_dict, epochs=500, distort=True):\n        self.training_data_dict = training_data_dict # a dictionary of image batch queues\n        distorted_image = tf.reshape(training_data_dict['X_train_batch'], [-1, 160, 160, 3]) #1\n        if distort is True:\n            distorted_image = tf.map_fn(lambda img: self.random_distorer(img), distorted_image) #2\n        distorted_image = tf.reshape(distorted_image, [-1, 76800])  # 3\n        for epoch in range(epochs):\n            x_test, y_test = self.sess.run([training_data_dict['X_test_batch'], training_data_dict['y_test_batch']])\n            distortedX, x_train, y_train = self.sess.run([distorted_image, training_data_dict['X_train_batch'],\n                                                          training_data_dict['y_train_batch']]) #4\n            if epoch%300 == 0:\n                if self.distort is True:\n                    print('Distorting color in training images...')\n                distortedX, x_train, y_train = self.sess.run([distorted_image, training_data_dict['X_train_batch'],\n                                                              training_data_dict['y_train_batch']])\n                summary, loss, train_accuracy = self.sess.run([self.merged, self.train_step, self.accuracy], feed_dict={\n                    self.x: distortedX, self.y_: y_train, self.keep_prob: self.dropout})\n                print(\"Step %d, Distorted Training accuracy %g\" % (epoch, train_accuracy))\n            else:\n                summary, loss, train_accuracy = self.sess.run([self.merged, self.train_step, self.accuracy], feed_dict={\n                    self.x: x_train, self.y_: y_train, self.keep_prob: self.dropout})\n                if epoch%100 == 0:\n                    print(\"Step %d, Training accuracy %g\" % (epoch, train_accuracy))\n                self.train_writer.add_summary(summary, epoch)\n            if epoch%100 == 0:\n                summary, test_accuracy = self.sess.run([self.merged, self.accuracy], feed_dict={\n                    self.x: x_test, self.y_: y_test, self.keep_prob: 1.0})\n                print(\"Test Accuracy %g\"% test_accuracy)\n                self.test_writer.add_summary(summary, epoch)\n            if epoch%500 == 0:\n                print('Saving model...')\n                self.saver.save(self.sess, self.model_dir+'model.ckpt', epoch)\n            if epoch == epochs:\n                print('Saving model...')\n                self.saver.save(self.sess, self.model_dir+'model.ckpt', epoch)\n\n\ntraining_data = dict()\ntraining_data['X_train_batch'], training_data['y_train_batch'] = inputs(FLAGS.train_dir,\n                                                                  FLAGS.train_file,\n                                                                  FLAGS.batch_size,\n                                                                  FLAGS.n_epochs,\n                                                                  FLAGS.n_classes,\n                                                                  one_hot_labels=True,\n                                                                  imshape=76800)\n\n\ntraining_data['X_test_batch'], training_data['y_test_batch'] = inputs(FLAGS.train_dir,\n                                                                FLAGS.test_file,\n                                                                FLAGS.batch_size,\n                                                                FLAGS.n_epochs,\n                                                                FLAGS.n_classes,\n                                                                one_hot_labels=True,\n                                                                imshape=76800)\n\nnetwork_architecture = dict(W_conv1=[5, 5, 3, 25],\n                            W_conv2=[5, 5, 25, 50],\n                            W_fc1=[40 * 40 * 50, 1024],\n                            W_fc2=[1024, 2])\n\nmodel = BasicConvNet(76800, 2, network_architecture, batch_size=30,\n                     imshape=(160,160,3), dropout=0.5, model_dir='./modeltest/', histograms=False)\nmodel.train(training_data, epochs=FLAGS.n_epochs, distort=True)`\n</code></pre>", "body_text": "More or less thats the code.. sorry to throw a ton of code on here.. I'm still pretty much a novice and if I did something wrong elsewhere didn't want to send anyone on a wild goose hunt. But like I said it runs about a quarter of the time no problem.. so I don't think its entirely me..\ndef read_and_decode(filename_queue,imshape=160*160*3):\n    reader = tf.TFRecordReader()\n    _, serialized_example = reader.read(filename_queue)\n    features = tf.parse_single_example(\n        serialized_example,\n        features={\n            'image_raw': tf.FixedLenFeature([], tf.string),\n            'label': tf.FixedLenFeature([], tf.int64),\n            'height': tf.FixedLenFeature([], tf.int64),\n            'width': tf.FixedLenFeature([], tf.int64),\n            'depth': tf.FixedLenFeature([], tf.int64)\n        })\n\n    image = tf.decode_raw(features['image_raw'], tf.uint8)\n    image.set_shape([imshape])\n    image = tf.cast(image, tf.float32)\n\n    label = tf.cast(features['label'], tf.int32)\n\n    return image, label\n\n\ndef inputs(train_dir, file, batch_size, num_epochs, n_classes, one_hot_labels=False, imshape=160*160*3):\n\n    if not num_epochs: num_epochs = None\n    filename = os.path.join(train_dir, file)\n\n    # with tf.name_scope('input'):\n    filename_queue = tf.train.string_input_producer(\n        [filename], num_epochs=num_epochs)\n\n    image, label = read_and_decode(filename_queue, imshape)\n\n    if one_hot_labels:\n        label = tf.one_hot(label, n_classes, dtype=tf.int32)\n\n    example_batch, label_batch = tf.train.shuffle_batch(\n        [image, label], batch_size=batch_size, num_threads=2,\n        capacity=1000, enqueue_many=False,\n        # Ensures a minimum amount of shuffling of examples.\n        min_after_dequeue=10, name=file)\n\n    return example_batch, label_batch\n\n def random_distorer(self, image):\n        image = tf.image.random_brightness(image, max_delta=32. / 255.)\n        image = tf.image.random_saturation(image, lower=0.5, upper=1.5)\n        image = tf.image.random_hue(image, max_delta=0.2)\n        image = tf.image.random_contrast(image, lower=0.5, upper=1.5)\n        image = tf.image.random_flip_up_down(image)\n        image = tf.image.random_flip_left_right(image)\n        return image`\n\n`    def train(self, training_data_dict, epochs=500, distort=True):\n        self.training_data_dict = training_data_dict # a dictionary of image batch queues\n        distorted_image = tf.reshape(training_data_dict['X_train_batch'], [-1, 160, 160, 3]) #1\n        if distort is True:\n            distorted_image = tf.map_fn(lambda img: self.random_distorer(img), distorted_image) #2\n        distorted_image = tf.reshape(distorted_image, [-1, 76800])  # 3\n        for epoch in range(epochs):\n            x_test, y_test = self.sess.run([training_data_dict['X_test_batch'], training_data_dict['y_test_batch']])\n            distortedX, x_train, y_train = self.sess.run([distorted_image, training_data_dict['X_train_batch'],\n                                                          training_data_dict['y_train_batch']]) #4\n            if epoch%300 == 0:\n                if self.distort is True:\n                    print('Distorting color in training images...')\n                distortedX, x_train, y_train = self.sess.run([distorted_image, training_data_dict['X_train_batch'],\n                                                              training_data_dict['y_train_batch']])\n                summary, loss, train_accuracy = self.sess.run([self.merged, self.train_step, self.accuracy], feed_dict={\n                    self.x: distortedX, self.y_: y_train, self.keep_prob: self.dropout})\n                print(\"Step %d, Distorted Training accuracy %g\" % (epoch, train_accuracy))\n            else:\n                summary, loss, train_accuracy = self.sess.run([self.merged, self.train_step, self.accuracy], feed_dict={\n                    self.x: x_train, self.y_: y_train, self.keep_prob: self.dropout})\n                if epoch%100 == 0:\n                    print(\"Step %d, Training accuracy %g\" % (epoch, train_accuracy))\n                self.train_writer.add_summary(summary, epoch)\n            if epoch%100 == 0:\n                summary, test_accuracy = self.sess.run([self.merged, self.accuracy], feed_dict={\n                    self.x: x_test, self.y_: y_test, self.keep_prob: 1.0})\n                print(\"Test Accuracy %g\"% test_accuracy)\n                self.test_writer.add_summary(summary, epoch)\n            if epoch%500 == 0:\n                print('Saving model...')\n                self.saver.save(self.sess, self.model_dir+'model.ckpt', epoch)\n            if epoch == epochs:\n                print('Saving model...')\n                self.saver.save(self.sess, self.model_dir+'model.ckpt', epoch)\n\n\ntraining_data = dict()\ntraining_data['X_train_batch'], training_data['y_train_batch'] = inputs(FLAGS.train_dir,\n                                                                  FLAGS.train_file,\n                                                                  FLAGS.batch_size,\n                                                                  FLAGS.n_epochs,\n                                                                  FLAGS.n_classes,\n                                                                  one_hot_labels=True,\n                                                                  imshape=76800)\n\n\ntraining_data['X_test_batch'], training_data['y_test_batch'] = inputs(FLAGS.train_dir,\n                                                                FLAGS.test_file,\n                                                                FLAGS.batch_size,\n                                                                FLAGS.n_epochs,\n                                                                FLAGS.n_classes,\n                                                                one_hot_labels=True,\n                                                                imshape=76800)\n\nnetwork_architecture = dict(W_conv1=[5, 5, 3, 25],\n                            W_conv2=[5, 5, 25, 50],\n                            W_fc1=[40 * 40 * 50, 1024],\n                            W_fc2=[1024, 2])\n\nmodel = BasicConvNet(76800, 2, network_architecture, batch_size=30,\n                     imshape=(160,160,3), dropout=0.5, model_dir='./modeltest/', histograms=False)\nmodel.train(training_data, epochs=FLAGS.n_epochs, distort=True)`", "body": "\r\nMore or less thats the code.. sorry to throw a ton of code on here.. I'm still pretty much a novice and if I did something wrong elsewhere didn't want to send anyone on a wild goose hunt. But like I said it runs about a quarter of the time no problem.. so I don't think its entirely me.. \r\n\r\n````\r\ndef read_and_decode(filename_queue,imshape=160*160*3):\r\n    reader = tf.TFRecordReader()\r\n    _, serialized_example = reader.read(filename_queue)\r\n    features = tf.parse_single_example(\r\n        serialized_example,\r\n        features={\r\n            'image_raw': tf.FixedLenFeature([], tf.string),\r\n            'label': tf.FixedLenFeature([], tf.int64),\r\n            'height': tf.FixedLenFeature([], tf.int64),\r\n            'width': tf.FixedLenFeature([], tf.int64),\r\n            'depth': tf.FixedLenFeature([], tf.int64)\r\n        })\r\n\r\n    image = tf.decode_raw(features['image_raw'], tf.uint8)\r\n    image.set_shape([imshape])\r\n    image = tf.cast(image, tf.float32)\r\n\r\n    label = tf.cast(features['label'], tf.int32)\r\n\r\n    return image, label\r\n\r\n\r\ndef inputs(train_dir, file, batch_size, num_epochs, n_classes, one_hot_labels=False, imshape=160*160*3):\r\n\r\n    if not num_epochs: num_epochs = None\r\n    filename = os.path.join(train_dir, file)\r\n\r\n    # with tf.name_scope('input'):\r\n    filename_queue = tf.train.string_input_producer(\r\n        [filename], num_epochs=num_epochs)\r\n\r\n    image, label = read_and_decode(filename_queue, imshape)\r\n\r\n    if one_hot_labels:\r\n        label = tf.one_hot(label, n_classes, dtype=tf.int32)\r\n\r\n    example_batch, label_batch = tf.train.shuffle_batch(\r\n        [image, label], batch_size=batch_size, num_threads=2,\r\n        capacity=1000, enqueue_many=False,\r\n        # Ensures a minimum amount of shuffling of examples.\r\n        min_after_dequeue=10, name=file)\r\n\r\n    return example_batch, label_batch\r\n\r\n def random_distorer(self, image):\r\n        image = tf.image.random_brightness(image, max_delta=32. / 255.)\r\n        image = tf.image.random_saturation(image, lower=0.5, upper=1.5)\r\n        image = tf.image.random_hue(image, max_delta=0.2)\r\n        image = tf.image.random_contrast(image, lower=0.5, upper=1.5)\r\n        image = tf.image.random_flip_up_down(image)\r\n        image = tf.image.random_flip_left_right(image)\r\n        return image`\r\n\r\n`    def train(self, training_data_dict, epochs=500, distort=True):\r\n        self.training_data_dict = training_data_dict # a dictionary of image batch queues\r\n        distorted_image = tf.reshape(training_data_dict['X_train_batch'], [-1, 160, 160, 3]) #1\r\n        if distort is True:\r\n            distorted_image = tf.map_fn(lambda img: self.random_distorer(img), distorted_image) #2\r\n        distorted_image = tf.reshape(distorted_image, [-1, 76800])  # 3\r\n        for epoch in range(epochs):\r\n            x_test, y_test = self.sess.run([training_data_dict['X_test_batch'], training_data_dict['y_test_batch']])\r\n            distortedX, x_train, y_train = self.sess.run([distorted_image, training_data_dict['X_train_batch'],\r\n                                                          training_data_dict['y_train_batch']]) #4\r\n            if epoch%300 == 0:\r\n                if self.distort is True:\r\n                    print('Distorting color in training images...')\r\n                distortedX, x_train, y_train = self.sess.run([distorted_image, training_data_dict['X_train_batch'],\r\n                                                              training_data_dict['y_train_batch']])\r\n                summary, loss, train_accuracy = self.sess.run([self.merged, self.train_step, self.accuracy], feed_dict={\r\n                    self.x: distortedX, self.y_: y_train, self.keep_prob: self.dropout})\r\n                print(\"Step %d, Distorted Training accuracy %g\" % (epoch, train_accuracy))\r\n            else:\r\n                summary, loss, train_accuracy = self.sess.run([self.merged, self.train_step, self.accuracy], feed_dict={\r\n                    self.x: x_train, self.y_: y_train, self.keep_prob: self.dropout})\r\n                if epoch%100 == 0:\r\n                    print(\"Step %d, Training accuracy %g\" % (epoch, train_accuracy))\r\n                self.train_writer.add_summary(summary, epoch)\r\n            if epoch%100 == 0:\r\n                summary, test_accuracy = self.sess.run([self.merged, self.accuracy], feed_dict={\r\n                    self.x: x_test, self.y_: y_test, self.keep_prob: 1.0})\r\n                print(\"Test Accuracy %g\"% test_accuracy)\r\n                self.test_writer.add_summary(summary, epoch)\r\n            if epoch%500 == 0:\r\n                print('Saving model...')\r\n                self.saver.save(self.sess, self.model_dir+'model.ckpt', epoch)\r\n            if epoch == epochs:\r\n                print('Saving model...')\r\n                self.saver.save(self.sess, self.model_dir+'model.ckpt', epoch)\r\n\r\n\r\ntraining_data = dict()\r\ntraining_data['X_train_batch'], training_data['y_train_batch'] = inputs(FLAGS.train_dir,\r\n                                                                  FLAGS.train_file,\r\n                                                                  FLAGS.batch_size,\r\n                                                                  FLAGS.n_epochs,\r\n                                                                  FLAGS.n_classes,\r\n                                                                  one_hot_labels=True,\r\n                                                                  imshape=76800)\r\n\r\n\r\ntraining_data['X_test_batch'], training_data['y_test_batch'] = inputs(FLAGS.train_dir,\r\n                                                                FLAGS.test_file,\r\n                                                                FLAGS.batch_size,\r\n                                                                FLAGS.n_epochs,\r\n                                                                FLAGS.n_classes,\r\n                                                                one_hot_labels=True,\r\n                                                                imshape=76800)\r\n\r\nnetwork_architecture = dict(W_conv1=[5, 5, 3, 25],\r\n                            W_conv2=[5, 5, 25, 50],\r\n                            W_fc1=[40 * 40 * 50, 1024],\r\n                            W_fc2=[1024, 2])\r\n\r\nmodel = BasicConvNet(76800, 2, network_architecture, batch_size=30,\r\n                     imshape=(160,160,3), dropout=0.5, model_dir='./modeltest/', histograms=False)\r\nmodel.train(training_data, epochs=FLAGS.n_epochs, distort=True)`\r\n"}