{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/372711229", "html_url": "https://github.com/tensorflow/tensorflow/issues/17533#issuecomment-372711229", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/17533", "id": 372711229, "node_id": "MDEyOklzc3VlQ29tbWVudDM3MjcxMTIyOQ==", "user": {"login": "siekkine", "id": 37175349, "node_id": "MDQ6VXNlcjM3MTc1MzQ5", "avatar_url": "https://avatars2.githubusercontent.com/u/37175349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/siekkine", "html_url": "https://github.com/siekkine", "followers_url": "https://api.github.com/users/siekkine/followers", "following_url": "https://api.github.com/users/siekkine/following{/other_user}", "gists_url": "https://api.github.com/users/siekkine/gists{/gist_id}", "starred_url": "https://api.github.com/users/siekkine/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/siekkine/subscriptions", "organizations_url": "https://api.github.com/users/siekkine/orgs", "repos_url": "https://api.github.com/users/siekkine/repos", "events_url": "https://api.github.com/users/siekkine/events{/privacy}", "received_events_url": "https://api.github.com/users/siekkine/received_events", "type": "User", "site_admin": false}, "created_at": "2018-03-13T15:42:34Z", "updated_at": "2018-03-13T15:42:34Z", "author_association": "NONE", "body_html": "<p>Unfortunately, I cannot check the ffmpeg version at the moment, but if I remember correctly, I pulled it recently from github and compiled it myself to enable CUDA support. Here are the parsing issues I met in my case:</p>\n<ul>\n<li>\n<p>The aspect ratios ([SAR 1:1 DAR 16:9] above) outputted after the resolution confuses the code that parses height dimension.</p>\n</li>\n<li>\n<p>Ordering of the output appears to differ between ffmpeg versions and, consequently, the parser code under \"in_mapping\" conditional may miss the \"frame=  \".</p>\n</li>\n<li>\n<p>With sufficiently long video, ffmpeg may output the line with \"frame= \" to stderr multiple times overwriting the previous output (using carriage return). The parser will find the first one whereas it should extract the last one (e.g., use rfind instead of find).</p>\n</li>\n</ul>\n<p>I gave ffprobe a try and replaced the parsing functionality with it. It turns out that the frame count may sometimes be off (by one) unless one tells ffprobe explicitly to count them (-count_frames) but that slows down the whole thing because it requires an extra pass over the video file. So, that's not a perfect solution either. I also replaced the use of temp files with pipes to avoid extra I/O operations and implemented a way to sample every nth frame (pass select filter option to ffmpeg). My code is messy but I can share it with you if you want.</p>", "body_text": "Unfortunately, I cannot check the ffmpeg version at the moment, but if I remember correctly, I pulled it recently from github and compiled it myself to enable CUDA support. Here are the parsing issues I met in my case:\n\n\nThe aspect ratios ([SAR 1:1 DAR 16:9] above) outputted after the resolution confuses the code that parses height dimension.\n\n\nOrdering of the output appears to differ between ffmpeg versions and, consequently, the parser code under \"in_mapping\" conditional may miss the \"frame=  \".\n\n\nWith sufficiently long video, ffmpeg may output the line with \"frame= \" to stderr multiple times overwriting the previous output (using carriage return). The parser will find the first one whereas it should extract the last one (e.g., use rfind instead of find).\n\n\nI gave ffprobe a try and replaced the parsing functionality with it. It turns out that the frame count may sometimes be off (by one) unless one tells ffprobe explicitly to count them (-count_frames) but that slows down the whole thing because it requires an extra pass over the video file. So, that's not a perfect solution either. I also replaced the use of temp files with pipes to avoid extra I/O operations and implemented a way to sample every nth frame (pass select filter option to ffmpeg). My code is messy but I can share it with you if you want.", "body": "Unfortunately, I cannot check the ffmpeg version at the moment, but if I remember correctly, I pulled it recently from github and compiled it myself to enable CUDA support. Here are the parsing issues I met in my case:\r\n\r\n- The aspect ratios ([SAR 1:1 DAR 16:9] above) outputted after the resolution confuses the code that parses height dimension. \r\n\r\n- Ordering of the output appears to differ between ffmpeg versions and, consequently, the parser code under \"in_mapping\" conditional may miss the \"frame=  \". \r\n\r\n- With sufficiently long video, ffmpeg may output the line with \"frame= \" to stderr multiple times overwriting the previous output (using carriage return). The parser will find the first one whereas it should extract the last one (e.g., use rfind instead of find). \r\n\r\nI gave ffprobe a try and replaced the parsing functionality with it. It turns out that the frame count may sometimes be off (by one) unless one tells ffprobe explicitly to count them (-count_frames) but that slows down the whole thing because it requires an extra pass over the video file. So, that's not a perfect solution either. I also replaced the use of temp files with pipes to avoid extra I/O operations and implemented a way to sample every nth frame (pass select filter option to ffmpeg). My code is messy but I can share it with you if you want."}