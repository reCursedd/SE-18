{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/257843182", "html_url": "https://github.com/tensorflow/tensorflow/issues/5277#issuecomment-257843182", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5277", "id": 257843182, "node_id": "MDEyOklzc3VlQ29tbWVudDI1Nzg0MzE4Mg==", "user": {"login": "sjperkins", "id": 3530212, "node_id": "MDQ6VXNlcjM1MzAyMTI=", "avatar_url": "https://avatars3.githubusercontent.com/u/3530212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sjperkins", "html_url": "https://github.com/sjperkins", "followers_url": "https://api.github.com/users/sjperkins/followers", "following_url": "https://api.github.com/users/sjperkins/following{/other_user}", "gists_url": "https://api.github.com/users/sjperkins/gists{/gist_id}", "starred_url": "https://api.github.com/users/sjperkins/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sjperkins/subscriptions", "organizations_url": "https://api.github.com/users/sjperkins/orgs", "repos_url": "https://api.github.com/users/sjperkins/repos", "events_url": "https://api.github.com/users/sjperkins/events{/privacy}", "received_events_url": "https://api.github.com/users/sjperkins/received_events", "type": "User", "site_admin": false}, "created_at": "2016-11-02T11:50:32Z", "updated_at": "2016-11-02T11:50:32Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=6969686\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/benoitsteiner\">@benoitsteiner</a> OK, with <code>IndexList</code> and early evaluation of the <code>phase</code> sub-expressions Eigen now takes <code>2.9</code> seconds vs OpenMP's <code>0.41</code> seconds. Did this in <a class=\"commit-link\" data-hovercard-type=\"commit\" data-hovercard-url=\"https://github.com/ska-sa/montblanc/commit/7b7a43aff8f1ad537d23e44051ecb51d507d8ccf/hovercard\" href=\"https://github.com/ska-sa/montblanc/commit/7b7a43aff8f1ad537d23e44051ecb51d507d8ccf\">ska-sa/montblanc@<tt>7b7a43a</tt></a>.</p>\n<p>Relevant code is here:</p>\n<div class=\"highlight highlight-source-c++\"><pre><span class=\"pl-c\"><span class=\"pl-c\">//</span> Doing it this way might give us SIMD's and threading automatically...</span>\n<span class=\"pl-k\">const</span> CPUDevice &amp; device = context-&gt;eigen_device&lt;CPUDevice&gt;();\n\n<span class=\"pl-k\">using</span> idx0 = Eigen::type2index&lt;<span class=\"pl-c1\">0</span>&gt;;\n<span class=\"pl-k\">using</span> idx1 = Eigen::type2index&lt;<span class=\"pl-c1\">1</span>&gt;;\n<span class=\"pl-k\">using</span> idx2 = Eigen::type2index&lt;<span class=\"pl-c1\">2</span>&gt;;\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> Shapes for reshaping and broadcasting</span>\nEigen::IndexList&lt;<span class=\"pl-k\">int</span>, idx1, idx1, idx1&gt; lm_shape;\nlm_shape.set(<span class=\"pl-c1\">0</span>, nsrc);\n\nEigen::IndexList&lt;idx1, <span class=\"pl-k\">int</span>, <span class=\"pl-k\">int</span>, idx1&gt; uvw_shape;\nuvw_shape.set(<span class=\"pl-c1\">1</span>, ntime);\nuvw_shape.set(<span class=\"pl-c1\">2</span>, na);\n\nEigen::IndexList&lt;idx1, idx1, idx1, <span class=\"pl-k\">int</span>&gt; freq_shape;\nfreq_shape.set(<span class=\"pl-c1\">3</span>, nchan);\n\nEigen::IndexList&lt;idx0, idx0&gt; l_slice_offset;\nEigen::IndexList&lt;idx0, idx1&gt; m_slice_offset;\n\nEigen::IndexList&lt;<span class=\"pl-k\">int</span>, idx1&gt; lm_slice_size;\nlm_slice_size.set(<span class=\"pl-c1\">0</span>, nsrc);\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> Slice lm to get l and m arrays</span>\n<span class=\"pl-k\">auto</span> l = lm.slice(l_slice_offset, lm_slice_size)\n    .reshape(lm_shape);\n<span class=\"pl-k\">auto</span> m = lm.slice(m_slice_offset, lm_slice_size)\n    .reshape(lm_shape);\n\nEigen::IndexList&lt;idx0, idx0, idx0&gt; u_slice_offset;\nEigen::IndexList&lt;idx0, idx0, idx1&gt; v_slice_offset;\nEigen::IndexList&lt;idx0, idx0, idx2&gt; w_slice_offset;\nEigen::IndexList&lt;<span class=\"pl-k\">int</span>, <span class=\"pl-k\">int</span>, idx1&gt; uvw_slice_size;\nuvw_slice_size.set(<span class=\"pl-c1\">0</span>, ntime);\nuvw_slice_size.set(<span class=\"pl-c1\">1</span>,  na);\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> Slice uvw to get u, v and w arrays</span>\n<span class=\"pl-k\">auto</span> u = uvw.slice(u_slice_offset, uvw_slice_size)\n    .reshape(uvw_shape);\n\n<span class=\"pl-k\">auto</span> v = uvw.slice(v_slice_offset, uvw_slice_size)\n    .reshape(uvw_shape);\n\n<span class=\"pl-k\">auto</span> w = uvw.slice(w_slice_offset, uvw_slice_size)\n    .reshape(uvw_shape);\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> Compute n</span>\n<span class=\"pl-k\">auto</span> n = (l.constant(<span class=\"pl-c1\">1.0</span>) - l*l - m*m).sqrt() - l.constant(<span class=\"pl-c1\">1.0</span>);\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> Compute the real phase</span>\n<span class=\"pl-k\">auto</span> real_phase = (\n    l.broadcast(uvw_shape)*u.broadcast(lm_shape) +\n    m.broadcast(uvw_shape)*v.broadcast(lm_shape) +\n    n.broadcast(uvw_shape)*w.broadcast(lm_shape))\n        .broadcast(freq_shape);\n\nEigen::IndexList&lt;<span class=\"pl-k\">int</span>, <span class=\"pl-k\">int</span>, <span class=\"pl-k\">int</span>, idx1&gt; freq_broad;\nfreq_broad.set(<span class=\"pl-c1\">0</span>, nsrc);\nfreq_broad.set(<span class=\"pl-c1\">1</span>, ntime);\nfreq_broad.set(<span class=\"pl-c1\">2</span>, na);\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> Reshape and broadcast frequency to match real_phase</span>\n<span class=\"pl-k\">auto</span> f = frequency.reshape(freq_shape).broadcast(freq_broad);\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> Evaluate common sub-expression early so that its</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> not recomputed twice for sin and cosine.</span>\nEigen::Tensor&lt;FT, <span class=\"pl-c1\">4</span>, Eigen::RowMajor&gt; <span class=\"pl-en\">phase</span>(nsrc, ntime, na, nchan);\nphase.device(device) = real_phase*f*real_phase.constant(minus_two_pi_over_c);\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> Calculate the phase</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>auto phase = real_phase*f*real_phase.constant(minus_two_pi_over_c);</span>\n<span class=\"pl-k\">auto</span> sinp = phase.unaryExpr(Eigen::internal::scalar_sin_op&lt;FT&gt;());\n<span class=\"pl-k\">auto</span> cosp = phase.unaryExpr(Eigen::internal::scalar_cos_op&lt;FT&gt;());\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> Now compute the complex phase by combining the cosine</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> and sine of the phase to from a complex number</span>\ncomplex_phase.device(device) = cosp.binaryExpr(\n    sinp, make_complex_functor&lt;FT&gt;());\n</pre></div>", "body_text": "@benoitsteiner OK, with IndexList and early evaluation of the phase sub-expressions Eigen now takes 2.9 seconds vs OpenMP's 0.41 seconds. Did this in ska-sa/montblanc@7b7a43a.\nRelevant code is here:\n// Doing it this way might give us SIMD's and threading automatically...\nconst CPUDevice & device = context->eigen_device<CPUDevice>();\n\nusing idx0 = Eigen::type2index<0>;\nusing idx1 = Eigen::type2index<1>;\nusing idx2 = Eigen::type2index<2>;\n\n// Shapes for reshaping and broadcasting\nEigen::IndexList<int, idx1, idx1, idx1> lm_shape;\nlm_shape.set(0, nsrc);\n\nEigen::IndexList<idx1, int, int, idx1> uvw_shape;\nuvw_shape.set(1, ntime);\nuvw_shape.set(2, na);\n\nEigen::IndexList<idx1, idx1, idx1, int> freq_shape;\nfreq_shape.set(3, nchan);\n\nEigen::IndexList<idx0, idx0> l_slice_offset;\nEigen::IndexList<idx0, idx1> m_slice_offset;\n\nEigen::IndexList<int, idx1> lm_slice_size;\nlm_slice_size.set(0, nsrc);\n\n// Slice lm to get l and m arrays\nauto l = lm.slice(l_slice_offset, lm_slice_size)\n    .reshape(lm_shape);\nauto m = lm.slice(m_slice_offset, lm_slice_size)\n    .reshape(lm_shape);\n\nEigen::IndexList<idx0, idx0, idx0> u_slice_offset;\nEigen::IndexList<idx0, idx0, idx1> v_slice_offset;\nEigen::IndexList<idx0, idx0, idx2> w_slice_offset;\nEigen::IndexList<int, int, idx1> uvw_slice_size;\nuvw_slice_size.set(0, ntime);\nuvw_slice_size.set(1,  na);\n\n// Slice uvw to get u, v and w arrays\nauto u = uvw.slice(u_slice_offset, uvw_slice_size)\n    .reshape(uvw_shape);\n\nauto v = uvw.slice(v_slice_offset, uvw_slice_size)\n    .reshape(uvw_shape);\n\nauto w = uvw.slice(w_slice_offset, uvw_slice_size)\n    .reshape(uvw_shape);\n\n// Compute n\nauto n = (l.constant(1.0) - l*l - m*m).sqrt() - l.constant(1.0);\n\n// Compute the real phase\nauto real_phase = (\n    l.broadcast(uvw_shape)*u.broadcast(lm_shape) +\n    m.broadcast(uvw_shape)*v.broadcast(lm_shape) +\n    n.broadcast(uvw_shape)*w.broadcast(lm_shape))\n        .broadcast(freq_shape);\n\nEigen::IndexList<int, int, int, idx1> freq_broad;\nfreq_broad.set(0, nsrc);\nfreq_broad.set(1, ntime);\nfreq_broad.set(2, na);\n\n// Reshape and broadcast frequency to match real_phase\nauto f = frequency.reshape(freq_shape).broadcast(freq_broad);\n\n// Evaluate common sub-expression early so that its\n// not recomputed twice for sin and cosine.\nEigen::Tensor<FT, 4, Eigen::RowMajor> phase(nsrc, ntime, na, nchan);\nphase.device(device) = real_phase*f*real_phase.constant(minus_two_pi_over_c);\n// Calculate the phase\n//auto phase = real_phase*f*real_phase.constant(minus_two_pi_over_c);\nauto sinp = phase.unaryExpr(Eigen::internal::scalar_sin_op<FT>());\nauto cosp = phase.unaryExpr(Eigen::internal::scalar_cos_op<FT>());\n\n// Now compute the complex phase by combining the cosine\n// and sine of the phase to from a complex number\ncomplex_phase.device(device) = cosp.binaryExpr(\n    sinp, make_complex_functor<FT>());", "body": "@benoitsteiner OK, with `IndexList` and early evaluation of the `phase` sub-expressions Eigen now takes `2.9` seconds vs OpenMP's `0.41` seconds. Did this in https://github.com/ska-sa/montblanc/commit/7b7a43aff8f1ad537d23e44051ecb51d507d8ccf.\n\nRelevant code is here:\n\n``` cpp\n// Doing it this way might give us SIMD's and threading automatically...\nconst CPUDevice & device = context->eigen_device<CPUDevice>();\n\nusing idx0 = Eigen::type2index<0>;\nusing idx1 = Eigen::type2index<1>;\nusing idx2 = Eigen::type2index<2>;\n\n// Shapes for reshaping and broadcasting\nEigen::IndexList<int, idx1, idx1, idx1> lm_shape;\nlm_shape.set(0, nsrc);\n\nEigen::IndexList<idx1, int, int, idx1> uvw_shape;\nuvw_shape.set(1, ntime);\nuvw_shape.set(2, na);\n\nEigen::IndexList<idx1, idx1, idx1, int> freq_shape;\nfreq_shape.set(3, nchan);\n\nEigen::IndexList<idx0, idx0> l_slice_offset;\nEigen::IndexList<idx0, idx1> m_slice_offset;\n\nEigen::IndexList<int, idx1> lm_slice_size;\nlm_slice_size.set(0, nsrc);\n\n// Slice lm to get l and m arrays\nauto l = lm.slice(l_slice_offset, lm_slice_size)\n    .reshape(lm_shape);\nauto m = lm.slice(m_slice_offset, lm_slice_size)\n    .reshape(lm_shape);\n\nEigen::IndexList<idx0, idx0, idx0> u_slice_offset;\nEigen::IndexList<idx0, idx0, idx1> v_slice_offset;\nEigen::IndexList<idx0, idx0, idx2> w_slice_offset;\nEigen::IndexList<int, int, idx1> uvw_slice_size;\nuvw_slice_size.set(0, ntime);\nuvw_slice_size.set(1,  na);\n\n// Slice uvw to get u, v and w arrays\nauto u = uvw.slice(u_slice_offset, uvw_slice_size)\n    .reshape(uvw_shape);\n\nauto v = uvw.slice(v_slice_offset, uvw_slice_size)\n    .reshape(uvw_shape);\n\nauto w = uvw.slice(w_slice_offset, uvw_slice_size)\n    .reshape(uvw_shape);\n\n// Compute n\nauto n = (l.constant(1.0) - l*l - m*m).sqrt() - l.constant(1.0);\n\n// Compute the real phase\nauto real_phase = (\n    l.broadcast(uvw_shape)*u.broadcast(lm_shape) +\n    m.broadcast(uvw_shape)*v.broadcast(lm_shape) +\n    n.broadcast(uvw_shape)*w.broadcast(lm_shape))\n        .broadcast(freq_shape);\n\nEigen::IndexList<int, int, int, idx1> freq_broad;\nfreq_broad.set(0, nsrc);\nfreq_broad.set(1, ntime);\nfreq_broad.set(2, na);\n\n// Reshape and broadcast frequency to match real_phase\nauto f = frequency.reshape(freq_shape).broadcast(freq_broad);\n\n// Evaluate common sub-expression early so that its\n// not recomputed twice for sin and cosine.\nEigen::Tensor<FT, 4, Eigen::RowMajor> phase(nsrc, ntime, na, nchan);\nphase.device(device) = real_phase*f*real_phase.constant(minus_two_pi_over_c);\n// Calculate the phase\n//auto phase = real_phase*f*real_phase.constant(minus_two_pi_over_c);\nauto sinp = phase.unaryExpr(Eigen::internal::scalar_sin_op<FT>());\nauto cosp = phase.unaryExpr(Eigen::internal::scalar_cos_op<FT>());\n\n// Now compute the complex phase by combining the cosine\n// and sine of the phase to from a complex number\ncomplex_phase.device(device) = cosp.binaryExpr(\n    sinp, make_complex_functor<FT>());\n\n```\n"}