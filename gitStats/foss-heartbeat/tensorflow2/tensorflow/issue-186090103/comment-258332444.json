{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/258332444", "html_url": "https://github.com/tensorflow/tensorflow/issues/5277#issuecomment-258332444", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5277", "id": 258332444, "node_id": "MDEyOklzc3VlQ29tbWVudDI1ODMzMjQ0NA==", "user": {"login": "benoitsteiner", "id": 6969686, "node_id": "MDQ6VXNlcjY5Njk2ODY=", "avatar_url": "https://avatars0.githubusercontent.com/u/6969686?v=4", "gravatar_id": "", "url": "https://api.github.com/users/benoitsteiner", "html_url": "https://github.com/benoitsteiner", "followers_url": "https://api.github.com/users/benoitsteiner/followers", "following_url": "https://api.github.com/users/benoitsteiner/following{/other_user}", "gists_url": "https://api.github.com/users/benoitsteiner/gists{/gist_id}", "starred_url": "https://api.github.com/users/benoitsteiner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/benoitsteiner/subscriptions", "organizations_url": "https://api.github.com/users/benoitsteiner/orgs", "repos_url": "https://api.github.com/users/benoitsteiner/repos", "events_url": "https://api.github.com/users/benoitsteiner/events{/privacy}", "received_events_url": "https://api.github.com/users/benoitsteiner/received_events", "type": "User", "site_admin": false}, "created_at": "2016-11-04T02:51:06Z", "updated_at": "2016-11-04T02:51:06Z", "author_association": "CONTRIBUTOR", "body_html": "<p>There are 2 simple things you can do to speed things up:<br>\nl_l -&gt; l.square()<br>\nm_m -&gt; m.square()</p>\n<p>Also, you're using l and m both to compute real_phase and n: you could force their evaluation (like you've done for phase) to avoid their recomputation.</p>\n<p>Last but not least, try to add an eval() before the broadcasts. For example, u.broadcast(lm_shape) will probably evaluate faster if you write it as u.eval().broadcast(lm_shape)</p>", "body_text": "There are 2 simple things you can do to speed things up:\nl_l -> l.square()\nm_m -> m.square()\nAlso, you're using l and m both to compute real_phase and n: you could force their evaluation (like you've done for phase) to avoid their recomputation.\nLast but not least, try to add an eval() before the broadcasts. For example, u.broadcast(lm_shape) will probably evaluate faster if you write it as u.eval().broadcast(lm_shape)", "body": "There are 2 simple things you can do to speed things up:\n   l_l -> l.square()\n   m_m -> m.square()\n\nAlso, you're using l and m both to compute real_phase and n: you could force their evaluation (like you've done for phase) to avoid their recomputation.\n\nLast but not least, try to add an eval() before the broadcasts. For example, u.broadcast(lm_shape) will probably evaluate faster if you write it as u.eval().broadcast(lm_shape)\n"}