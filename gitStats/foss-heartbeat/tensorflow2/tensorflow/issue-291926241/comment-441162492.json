{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/441162492", "html_url": "https://github.com/tensorflow/tensorflow/issues/16455#issuecomment-441162492", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/16455", "id": 441162492, "node_id": "MDEyOklzc3VlQ29tbWVudDQ0MTE2MjQ5Mg==", "user": {"login": "kielnino", "id": 15856124, "node_id": "MDQ6VXNlcjE1ODU2MTI0", "avatar_url": "https://avatars2.githubusercontent.com/u/15856124?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kielnino", "html_url": "https://github.com/kielnino", "followers_url": "https://api.github.com/users/kielnino/followers", "following_url": "https://api.github.com/users/kielnino/following{/other_user}", "gists_url": "https://api.github.com/users/kielnino/gists{/gist_id}", "starred_url": "https://api.github.com/users/kielnino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kielnino/subscriptions", "organizations_url": "https://api.github.com/users/kielnino/orgs", "repos_url": "https://api.github.com/users/kielnino/repos", "events_url": "https://api.github.com/users/kielnino/events{/privacy}", "received_events_url": "https://api.github.com/users/kielnino/received_events", "type": "User", "site_admin": false}, "created_at": "2018-11-23T06:14:31Z", "updated_at": "2018-11-23T06:14:31Z", "author_association": "NONE", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=14118476\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/awerdich\">@awerdich</a> That would be</p>\n<pre><code>def model_fn(features, labels, mode):\n\n    model = KerasModel()\n\n    training = (mode == tf.estimator.ModeKeys.TRAIN)\n    y = model(features, training)\n\n    predictions = {\n        # Generate predictions (for PREDICT mode)\n        \"prob\": y,\n    }\n    if mode == tf.estimator.ModeKeys.PREDICT:\n        return tf.estimator.EstimatorSpec(mode=mode, predictions=predictions)\n\n    # Calculate Loss (for both TRAIN and EVAL modes)\n\n    loss = tf.reduce_mean(tf.keras.backend.binary_crossentropy(labels['y_true'], y))\n    # Configure the Training Op (for TRAIN mode)\n    if mode == tf.estimator.ModeKeys.TRAIN:\n        optimizer = tf.train.MomentumOptimizer(learning_rate=1e-4, momentum=0.9)\n\n        with tf.control_dependencies(model.get_updates_for(features)):\n            train_op = optimizer.minimize(loss, global_step=tf.train.get_global_step())\n\n        return tf.estimator.EstimatorSpec(mode=mode, loss=loss, train_op=train_op)\n\n    # Add evaluation metrics (for EVAL mode)\n    return tf.estimator.EstimatorSpec(mode=mode, loss=loss)\n</code></pre>", "body_text": "@awerdich That would be\ndef model_fn(features, labels, mode):\n\n    model = KerasModel()\n\n    training = (mode == tf.estimator.ModeKeys.TRAIN)\n    y = model(features, training)\n\n    predictions = {\n        # Generate predictions (for PREDICT mode)\n        \"prob\": y,\n    }\n    if mode == tf.estimator.ModeKeys.PREDICT:\n        return tf.estimator.EstimatorSpec(mode=mode, predictions=predictions)\n\n    # Calculate Loss (for both TRAIN and EVAL modes)\n\n    loss = tf.reduce_mean(tf.keras.backend.binary_crossentropy(labels['y_true'], y))\n    # Configure the Training Op (for TRAIN mode)\n    if mode == tf.estimator.ModeKeys.TRAIN:\n        optimizer = tf.train.MomentumOptimizer(learning_rate=1e-4, momentum=0.9)\n\n        with tf.control_dependencies(model.get_updates_for(features)):\n            train_op = optimizer.minimize(loss, global_step=tf.train.get_global_step())\n\n        return tf.estimator.EstimatorSpec(mode=mode, loss=loss, train_op=train_op)\n\n    # Add evaluation metrics (for EVAL mode)\n    return tf.estimator.EstimatorSpec(mode=mode, loss=loss)", "body": "@awerdich That would be\r\n\r\n```\r\ndef model_fn(features, labels, mode):\r\n\r\n    model = KerasModel()\r\n\r\n    training = (mode == tf.estimator.ModeKeys.TRAIN)\r\n    y = model(features, training)\r\n\r\n    predictions = {\r\n        # Generate predictions (for PREDICT mode)\r\n        \"prob\": y,\r\n    }\r\n    if mode == tf.estimator.ModeKeys.PREDICT:\r\n        return tf.estimator.EstimatorSpec(mode=mode, predictions=predictions)\r\n\r\n    # Calculate Loss (for both TRAIN and EVAL modes)\r\n\r\n    loss = tf.reduce_mean(tf.keras.backend.binary_crossentropy(labels['y_true'], y))\r\n    # Configure the Training Op (for TRAIN mode)\r\n    if mode == tf.estimator.ModeKeys.TRAIN:\r\n        optimizer = tf.train.MomentumOptimizer(learning_rate=1e-4, momentum=0.9)\r\n\r\n        with tf.control_dependencies(model.get_updates_for(features)):\r\n            train_op = optimizer.minimize(loss, global_step=tf.train.get_global_step())\r\n\r\n        return tf.estimator.EstimatorSpec(mode=mode, loss=loss, train_op=train_op)\r\n\r\n    # Add evaluation metrics (for EVAL mode)\r\n    return tf.estimator.EstimatorSpec(mode=mode, loss=loss)\r\n```"}