{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/302594409", "html_url": "https://github.com/tensorflow/tensorflow/pull/9994#issuecomment-302594409", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9994", "id": 302594409, "node_id": "MDEyOklzc3VlQ29tbWVudDMwMjU5NDQwOQ==", "user": {"login": "snnn", "id": 856316, "node_id": "MDQ6VXNlcjg1NjMxNg==", "avatar_url": "https://avatars3.githubusercontent.com/u/856316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/snnn", "html_url": "https://github.com/snnn", "followers_url": "https://api.github.com/users/snnn/followers", "following_url": "https://api.github.com/users/snnn/following{/other_user}", "gists_url": "https://api.github.com/users/snnn/gists{/gist_id}", "starred_url": "https://api.github.com/users/snnn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/snnn/subscriptions", "organizations_url": "https://api.github.com/users/snnn/orgs", "repos_url": "https://api.github.com/users/snnn/repos", "events_url": "https://api.github.com/users/snnn/events{/privacy}", "received_events_url": "https://api.github.com/users/snnn/received_events", "type": "User", "site_admin": false}, "created_at": "2017-05-19T02:46:50Z", "updated_at": "2017-05-19T04:28:50Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Hi <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=5061\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/alextp\">@alextp</a></p>\n<p>Assume we have a custom OP like this:</p>\n<pre><code>template &lt;typename T&gt;\nclass NumericResource : public tensorflow::ResourceBase\n{\nprivate:\n\tstd::atomic&lt;T&gt; value;\n\npublic:\n\tNumericResource() : value(0) {}\n\tT get() const { return value; }\n\tvoid inc() { ++value; }\n\tvirtual std::string DebugString()\n\t{\n\t\tstd::ostringstream oss;\n\t\toss &lt;&lt; value;\n\t\treturn oss.str();\n\t}\n};\ntypedef NumericResource&lt;int&gt; IntResource;\n\nclass IntVarOp : public tensorflow::ResourceOpKernel&lt;IntResource&gt;\n{\npublic:\n\texplicit IntVarOp(OpKernelConstruction* context) : tensorflow::ResourceOpKernel&lt;IntResource&gt;(context) {}\nprivate:\n\tvirtual tensorflow::Status CreateResource(IntResource** resource)\n\t{\n\t\t*resource = new IntResource();\n\t\treturn tensorflow::Status::OK();\n\t}\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"IntVar\").Device(\"CPU\"), IntVarOp);\n</code></pre>\n<p>And we want to compile this OP into a \"dll\" or \u201cso\u201d. Because ResourceOpKernel  is a template class,  the code in that class is generated in user ops' dll, not tensorflow's dll. So ResourceOpKernel shouldn't call any function that internal to tensorflow, otherwise user will get a \"unresolved external symbol\" error in linking stage.</p>\n<p>Before this change, user's dll will contain a call to MakeResourceHandle&lt;T&gt; function, which will generate protobuf related code, and allocate a protobuf object in user's dll, pass it to tensorflow's dll. This is dangerous because each dll may have its own protobuf memory pool. By any chance, if you allocate an object in one pool but free it in another pool, it will crash. That's why protobuf's document prohibit you expose protocol buffer objects in your library's public interface.</p>\n<p>After this change, the protobuf object's construction is done in tensorflow's dll (MakeResourceHandleToOutput function).</p>", "body_text": "Hi @alextp\nAssume we have a custom OP like this:\ntemplate <typename T>\nclass NumericResource : public tensorflow::ResourceBase\n{\nprivate:\n\tstd::atomic<T> value;\n\npublic:\n\tNumericResource() : value(0) {}\n\tT get() const { return value; }\n\tvoid inc() { ++value; }\n\tvirtual std::string DebugString()\n\t{\n\t\tstd::ostringstream oss;\n\t\toss << value;\n\t\treturn oss.str();\n\t}\n};\ntypedef NumericResource<int> IntResource;\n\nclass IntVarOp : public tensorflow::ResourceOpKernel<IntResource>\n{\npublic:\n\texplicit IntVarOp(OpKernelConstruction* context) : tensorflow::ResourceOpKernel<IntResource>(context) {}\nprivate:\n\tvirtual tensorflow::Status CreateResource(IntResource** resource)\n\t{\n\t\t*resource = new IntResource();\n\t\treturn tensorflow::Status::OK();\n\t}\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"IntVar\").Device(\"CPU\"), IntVarOp);\n\nAnd we want to compile this OP into a \"dll\" or \u201cso\u201d. Because ResourceOpKernel  is a template class,  the code in that class is generated in user ops' dll, not tensorflow's dll. So ResourceOpKernel shouldn't call any function that internal to tensorflow, otherwise user will get a \"unresolved external symbol\" error in linking stage.\nBefore this change, user's dll will contain a call to MakeResourceHandle<T> function, which will generate protobuf related code, and allocate a protobuf object in user's dll, pass it to tensorflow's dll. This is dangerous because each dll may have its own protobuf memory pool. By any chance, if you allocate an object in one pool but free it in another pool, it will crash. That's why protobuf's document prohibit you expose protocol buffer objects in your library's public interface.\nAfter this change, the protobuf object's construction is done in tensorflow's dll (MakeResourceHandleToOutput function).", "body": "Hi @alextp  \r\n\r\nAssume we have a custom OP like this:\r\n\r\n\ttemplate <typename T>\r\n\tclass NumericResource : public tensorflow::ResourceBase\r\n\t{\r\n\tprivate:\r\n\t\tstd::atomic<T> value;\r\n\r\n\tpublic:\r\n\t\tNumericResource() : value(0) {}\r\n\t\tT get() const { return value; }\r\n\t\tvoid inc() { ++value; }\r\n\t\tvirtual std::string DebugString()\r\n\t\t{\r\n\t\t\tstd::ostringstream oss;\r\n\t\t\toss << value;\r\n\t\t\treturn oss.str();\r\n\t\t}\r\n\t};\r\n\ttypedef NumericResource<int> IntResource;\r\n\r\n\tclass IntVarOp : public tensorflow::ResourceOpKernel<IntResource>\r\n\t{\r\n\tpublic:\r\n\t\texplicit IntVarOp(OpKernelConstruction* context) : tensorflow::ResourceOpKernel<IntResource>(context) {}\r\n\tprivate:\r\n\t\tvirtual tensorflow::Status CreateResource(IntResource** resource)\r\n\t\t{\r\n\t\t\t*resource = new IntResource();\r\n\t\t\treturn tensorflow::Status::OK();\r\n\t\t}\r\n\t};\r\n\r\n\tREGISTER_KERNEL_BUILDER(Name(\"IntVar\").Device(\"CPU\"), IntVarOp);\r\n\r\nAnd we want to compile this OP into a \"dll\" or \u201cso\u201d. Because ResourceOpKernel  is a template class,  the code in that class is generated in user ops' dll, not tensorflow's dll. So ResourceOpKernel shouldn't call any function that internal to tensorflow, otherwise user will get a \"unresolved external symbol\" error in linking stage.\r\n\r\nBefore this change, user's dll will contain a call to MakeResourceHandle\\<T\\> function, which will generate protobuf related code, and allocate a protobuf object in user's dll, pass it to tensorflow's dll. This is dangerous because each dll may have its own protobuf memory pool. By any chance, if you allocate an object in one pool but free it in another pool, it will crash. That's why protobuf's document prohibit you expose protocol buffer objects in your library's public interface.\r\n\r\nAfter this change, the protobuf object's construction is done in tensorflow's dll (MakeResourceHandleToOutput function). "}