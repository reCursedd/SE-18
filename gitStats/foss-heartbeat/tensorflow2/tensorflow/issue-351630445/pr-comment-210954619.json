{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/210954619", "pull_request_review_id": 147281571, "id": 210954619, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDk1NDYxOQ==", "diff_hunk": "@@ -0,0 +1,5651 @@\n+/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef TENSORFLOW_CORE_KERNELS_CROP_RESIZE_BILINEAR_CORE_H_\n+#define TENSORFLOW_CORE_KERNELS_CROP_RESIZE_BILINEAR_CORE_H_\n+\n+#include <emmintrin.h>\n+#include <immintrin.h>\n+#include <smmintrin.h>\n+#include <xmmintrin.h>\n+#include <cassert>\n+#include <cstdio>\n+#include <cstdlib>\n+#include <list>\n+#include <string>\n+\n+namespace tensorflow {\n+namespace {\n+\n+template <typename T>\n+std::string sprint_bits(const T& val, bool msb_left = true) {\n+  std::string str;\n+  if (sizeof(T) == 1) {\n+    unsigned char* p = (unsigned char*)&val;\n+    const int num_bits = sizeof(T) * 8;\n+    for (int i = 0; i < num_bits; ++i) {\n+      int bit_idx = msb_left ? num_bits - i - 1 : i;\n+      str = str + std::string((*p) & (1 << bit_idx) ? \"1\" : \"0\");\n+    }\n+  } else if (sizeof(T) == 2) {\n+    unsigned short* p = (unsigned short*)&val;\n+    const int num_bits = sizeof(T) * 8;\n+    for (int i = 0; i < num_bits; ++i) {\n+      int bit_idx = msb_left ? num_bits - i - 1 : i;\n+      str = str + std::string((*p) & (1 << bit_idx) ? \"1\" : \"0\");\n+    }\n+  } else if (sizeof(T) == 4) {\n+    unsigned int* p = (unsigned int*)&val;\n+    const int num_bits = sizeof(T) * 8;\n+    for (int i = 0; i < num_bits; ++i) {\n+      int bit_idx = msb_left ? num_bits - i - 1 : i;\n+      str = str + std::string((*p) & (1 << bit_idx) ? \"1\" : \"0\");\n+    }\n+  } else if (sizeof(T) == 8) {\n+    unsigned long long* p = (unsigned long long*)&val;\n+    const int num_bits = sizeof(T) * 8;\n+    for (int i = 0; i < num_bits; ++i) {\n+      int bit_idx = msb_left ? num_bits - i - 1 : i;\n+      str = str + std::string((*p) & (1 << bit_idx) ? \"1\" : \"0\");\n+    }\n+  } else {\n+    assert(false);\n+  }\n+  return str;\n+}\n+\n+template <typename T>\n+std::string format(const T& val) {\n+  return sprint_bits(val);\n+}\n+template <>\n+std::string format(const Eigen::half& val) {\n+  std::string str = sprint_bits(val);\n+  return str.substr(0, 1) + \" \" + str.substr(1, 1) + \"...\" + str.substr(2, 4) +\n+         \" \" + str.substr(6, 10);\n+}\n+template <>\n+std::string format(const float& val) {\n+  std::string str = sprint_bits(val);\n+  return str.substr(0, 1) + \" \" + str.substr(1, 8) + \" \" + str.substr(9, 23);\n+}\n+\n+//\n+// Useful debugging class\n+//\n+\n+template <class T>\n+class SSEPrinter {\n+ public:\n+  static void print(__m128i* vals, int n) {\n+    const int els_per_vec = 16 / sizeof(T);\n+    printf(\"%s v[%d] = {\", get_typename(), n * els_per_vec);\n+    for (int i = 0; i < n * els_per_vec; ++i) {\n+      if (i == 0)\n+        printf(\"%.2f\", (float)((T*)vals)[i]);\n+      else\n+        printf(\", %.2f\", (float)((T*)vals)[i]);\n+    }\n+    printf(\"}\\n\");\n+  }\n+\n+  static void print_bits(const char* label, __m128i& val) {\n+    printf(\"%s\\n\", label);\n+    const int els_per_vec = 16 / sizeof(T);\n+    for (int i = 0; i < els_per_vec; ++i) {\n+      T* tp = ((T*)&val) + i;\n+      printf(\"  %-2d = %s\\n\", i, format(*tp).c_str());\n+    }\n+  }\n+\n+ private:\n+  static const char* get_typename();\n+};\n+\n+template <>\n+const char* SSEPrinter<uint8>::get_typename() {\n+  return \"uint8\";\n+}\n+template <>\n+const char* SSEPrinter<int8>::get_typename() {\n+  return \"int8\";\n+}\n+template <>\n+const char* SSEPrinter<uint16>::get_typename() {\n+  return \"uint16\";\n+}\n+template <>\n+const char* SSEPrinter<int16>::get_typename() {\n+  return \"int16\";\n+}\n+template <>\n+const char* SSEPrinter<int32>::get_typename() {\n+  return \"int32\";\n+}\n+template <>\n+const char* SSEPrinter<Eigen::half>::get_typename() {\n+  return \"Eigen::half\";\n+}\n+template <>\n+const char* SSEPrinter<bfloat16>::get_typename() {\n+  return \"bfloat16\";\n+}\n+template <>\n+const char* SSEPrinter<float>::get_typename() {\n+  return \"float\";\n+}\n+\n+// Compute the interpolation indices only once.\n+struct CachedInterpolation {\n+  int lower;  // Lower source index used in the interpolation\n+  int upper;  // Upper source index used in the interpolation\n+  // 1-D linear iterpolation scale (see:\n+  // https://en.wikipedia.org/wiki/Bilinear_interpolation)\n+  float lerp;\n+};\n+\n+bool compute_single_interpolation_weight(const int in_size,\n+                                         const float out2in_scale,\n+                                         const float out2in_start,\n+                                         const bool clip, const int i,\n+                                         int* lower, int* upper, float* lerp) {\n+  const float in = i * out2in_scale + out2in_start;\n+  *lower = (int)floor(in);\n+  *upper = (int)ceil(in);\n+  *lerp = (float)(in - (float)*lower);\n+  if (clip) {\n+    if (*lower < 0)\n+      *lower = 0;\n+    else if (*lower >= in_size)\n+      *lower = in_size - 1;\n+    if (*upper < 0)\n+      *upper = 0;\n+    else if (*upper >= in_size)\n+      *upper = in_size - 1;\n+    return true;\n+  } else {\n+    return (*lower >= 0 && *upper < in_size) ? true : false;\n+  }\n+}\n+/**\n+ * Compute interpolation values for output indexes in range\n+ * [out_start,out_start+out_size-1].\n+ * Returns true if all output indexes have lower and upper (input) indexes\n+ * within range [0,in_size-1].\n+ */\n+bool compute_interpolation_weights(const int min_i, const int max_i,\n+                                   const int in_size, const float out2in_scale,\n+                                   const float out2in_start, const bool clip,\n+                                   CachedInterpolation* interpolation) {\n+  bool rval = true;\n+  int num_i = max_i - min_i + 1;\n+  for (int i = 0; i < num_i; ++i) {\n+    if (!compute_single_interpolation_weight(\n+            in_size, out2in_scale, out2in_start, clip, i + min_i,\n+            &interpolation[i].lower, &interpolation[i].upper,\n+            &interpolation[i].lerp)) {\n+      rval = false;\n+    }\n+  }\n+  return rval;\n+}\n+/**\n+ * Compatibility method for resize_bilinear_op.cc\n+ */\n+void compute_interpolation_weights(const int out_size, const int in_size,\n+                                   const float out2in_scale,\n+                                   CachedInterpolation* interpolation) {\n+  interpolation[out_size].lower = 0;\n+  interpolation[out_size].upper = 0;\n+  const bool clip = true;\n+  if (!compute_interpolation_weights(0, out_size - 1, in_size, out2in_scale,\n+                                     0.0f, clip, interpolation)) {\n+    // Should never happen, check for it anyway\n+    printf(\n+        \"Warning! Interpolation values have lower,upper indexes outside of \"\n+        \"range [0,in_size-1]\\n\");\n+  }\n+}\n+/**\n+ * Compute minimum and maximum (output) i where both lower and upper (input) is\n+ * in range [0,in_size-1]\n+ * If no values of i satisfy condition, min_i = in_size, max_i = -1 and method\n+ * returns false.\n+ * Returns true if min_i >= max_i.\n+ */\n+bool compute_minmax_indexes(const int out_size, const int in_size,\n+                            const float out2in_scale, const float out2in_start,\n+                            int& min_i, int& max_i) {\n+  min_i = out_size;\n+  max_i = -1;\n+  int lower, upper;\n+  float lerp;\n+  for (int i = 0; i < out_size; ++i) {\n+    if (compute_single_interpolation_weight(in_size, out2in_scale, out2in_start,\n+                                            false, i, &lower, &upper, &lerp)) {\n+      if (i < min_i) min_i = i;\n+      if (i > max_i) max_i = i;\n+    }\n+  }\n+  return (min_i <= max_i) ? true : false;\n+}\n+/**\n+ * Compute interpolation weights for crop_and_resize_op.cc\n+ * Also computes extrapolation areas.\n+ * Returns true if at least one point requires interpolation, false otherwise.\n+ */\n+bool compute_interpolation_weights(\n+    const int out_size, const int in_size,\n+    const float x1,  // lower bounding box, crop region starts at in_size*x1\n+    const float x2,  // upper bounding box, crop region ends at in_size*x2\n+    int& min_i, int& max_i, CachedInterpolation*& interpolation) {", "path": "tensorflow/core/kernels/crop_resize_bilinear_core.h", "position": null, "original_position": 253, "commit_id": "2bef68f68bb6dbbefee151ea853b92ac17bb5acc", "original_commit_id": "eecaed98a7b2b28cef76f6de55e173f490cb70f3", "user": {"login": "alextp", "id": 5061, "node_id": "MDQ6VXNlcjUwNjE=", "avatar_url": "https://avatars0.githubusercontent.com/u/5061?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alextp", "html_url": "https://github.com/alextp", "followers_url": "https://api.github.com/users/alextp/followers", "following_url": "https://api.github.com/users/alextp/following{/other_user}", "gists_url": "https://api.github.com/users/alextp/gists{/gist_id}", "starred_url": "https://api.github.com/users/alextp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alextp/subscriptions", "organizations_url": "https://api.github.com/users/alextp/orgs", "repos_url": "https://api.github.com/users/alextp/repos", "events_url": "https://api.github.com/users/alextp/events{/privacy}", "received_events_url": "https://api.github.com/users/alextp/received_events", "type": "User", "site_admin": false}, "body": "Same here about pointers vs references", "created_at": "2018-08-17T15:52:22Z", "updated_at": "2018-11-05T16:08:34Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/21681#discussion_r210954619", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/21681", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/210954619"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/21681#discussion_r210954619"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/21681"}}, "body_html": "<p>Same here about pointers vs references</p>", "body_text": "Same here about pointers vs references"}