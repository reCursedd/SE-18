{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/194968530", "html_url": "https://github.com/tensorflow/tensorflow/issues/1454#issuecomment-194968530", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/1454", "id": 194968530, "node_id": "MDEyOklzc3VlQ29tbWVudDE5NDk2ODUzMA==", "user": {"login": "mrry", "id": 192142, "node_id": "MDQ6VXNlcjE5MjE0Mg==", "avatar_url": "https://avatars1.githubusercontent.com/u/192142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mrry", "html_url": "https://github.com/mrry", "followers_url": "https://api.github.com/users/mrry/followers", "following_url": "https://api.github.com/users/mrry/following{/other_user}", "gists_url": "https://api.github.com/users/mrry/gists{/gist_id}", "starred_url": "https://api.github.com/users/mrry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mrry/subscriptions", "organizations_url": "https://api.github.com/users/mrry/orgs", "repos_url": "https://api.github.com/users/mrry/repos", "events_url": "https://api.github.com/users/mrry/events{/privacy}", "received_events_url": "https://api.github.com/users/mrry/received_events", "type": "User", "site_admin": false}, "created_at": "2016-03-10T17:33:04Z", "updated_at": "2016-03-10T17:33:04Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Is there a particular library or language on which you're basing your expectation (other than mathematics, where obviously the expression is well defined :)...)?</p>\n<p>Generally speaking, we've been trying to maintain consistency between the TensorFlow Python API and NumPy. If I try to compute <code>multiple_inequality</code> using NumPy, I get the following:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> <span class=\"pl-k\">import</span> numpy <span class=\"pl-k\">as</span> np\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> lower_bound <span class=\"pl-k\">=</span> np.array(\n<span class=\"pl-c1\">...</span>         [[ <span class=\"pl-c1\">0</span>.,   <span class=\"pl-c1\">0</span>.,   <span class=\"pl-c1\">0</span>. ],\n<span class=\"pl-c1\">...</span>          [ <span class=\"pl-c1\">0</span>.,   <span class=\"pl-c1\">0</span>.,   <span class=\"pl-c1\">0</span>. ],\n<span class=\"pl-c1\">...</span>          [ <span class=\"pl-c1\">0.5</span>,  <span class=\"pl-c1\">0.5</span>,  <span class=\"pl-c1\">0.5</span>],\n<span class=\"pl-c1\">...</span>          [ <span class=\"pl-c1\">0.5</span>,  <span class=\"pl-c1\">0.5</span>,  <span class=\"pl-c1\">0.5</span>],])\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> upper_bound <span class=\"pl-k\">=</span> np.array(\n<span class=\"pl-c1\">...</span>         [[ <span class=\"pl-c1\">0.5</span>,  <span class=\"pl-c1\">0.5</span>,  <span class=\"pl-c1\">0.5</span>],\n<span class=\"pl-c1\">...</span>          [ <span class=\"pl-c1\">0.5</span>,  <span class=\"pl-c1\">0.5</span>,  <span class=\"pl-c1\">0.5</span>],\n<span class=\"pl-c1\">...</span>          [ <span class=\"pl-c1\">1</span>.,   <span class=\"pl-c1\">1</span>.,   <span class=\"pl-c1\">1</span>. ],\n<span class=\"pl-c1\">...</span>          [ <span class=\"pl-c1\">1</span>.,   <span class=\"pl-c1\">1</span>.,   <span class=\"pl-c1\">1</span>. ],])\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> test <span class=\"pl-k\">=</span> np.array(\n<span class=\"pl-c1\">...</span>         [[ <span class=\"pl-c1\">0.30000001</span>,  <span class=\"pl-c1\">0.2</span>,  <span class=\"pl-c1\">0.82</span>],\n<span class=\"pl-c1\">...</span>          [ <span class=\"pl-c1\">0.30000001</span>,  <span class=\"pl-c1\">0.2</span>,  <span class=\"pl-c1\">0.82</span>],\n<span class=\"pl-c1\">...</span>          [ <span class=\"pl-c1\">0.30000001</span>,  <span class=\"pl-c1\">0.2</span>,  <span class=\"pl-c1\">0.82</span>],\n<span class=\"pl-c1\">...</span>          [ <span class=\"pl-c1\">0.30000001</span>,  <span class=\"pl-c1\">0.2</span>,  <span class=\"pl-c1\">0.82</span>],])\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> lower_bound <span class=\"pl-k\">&lt;=</span> test <span class=\"pl-k\">&lt;</span> upper_bound\nTraceback (most recent call last):\n  File <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>&lt;stdin&gt;<span class=\"pl-pds\">\"</span></span>, line <span class=\"pl-c1\">1</span>, <span class=\"pl-k\">in</span> <span class=\"pl-k\">&lt;</span>module<span class=\"pl-k\">&gt;</span>\n<span class=\"pl-c1\">ValueError</span>: The truth value of an array <span class=\"pl-k\">with</span> more than one element <span class=\"pl-k\">is</span> ambiguous. Use a.any() <span class=\"pl-k\">or</span> a.all()</pre></div>\n<p>My intuition would be that this expression would be evaluated as one of the following (depending on the associativity of Python's comparison operators... I think it's the first of the two):</p>\n<div class=\"highlight highlight-source-python\"><pre>x <span class=\"pl-k\">=</span> lower_bound <span class=\"pl-k\">&lt;=</span> test  <span class=\"pl-c\"><span class=\"pl-c\">#</span> a bool array</span>\nmultiple_inequality <span class=\"pl-k\">=</span> x <span class=\"pl-k\">&lt;</span> upper_bound  <span class=\"pl-c\"><span class=\"pl-c\">#</span> bool vs. float</span>\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> or</span>\nx <span class=\"pl-k\">=</span> test <span class=\"pl-k\">&lt;</span> upper_bound  <span class=\"pl-c\"><span class=\"pl-c\">#</span> a bool array</span>\nmultiple_inequality <span class=\"pl-k\">=</span> lower_bound <span class=\"pl-k\">&lt;=</span> x  <span class=\"pl-c\"><span class=\"pl-c\">#</span> bool vs. float</span></pre></div>\n<p>...however, either of these examples seems to work in NumPy (albeit with potentially wacky results, since NumPy converts <code>False</code> to <code>0.0</code> and <code>True</code> to <code>1.0</code>), so I'm not quite sure of the types.</p>\n<hr>\n<p><strong>EDIT:</strong> TIL that Python has <a href=\"https://docs.python.org/2/reference/expressions.html#not-in\" rel=\"nofollow\">special syntax for chained comparisons</a>! However, its functionality seems to be predicated on interpreting the result of a comparison as a boolean. Unfortunately, the result of TensorFlow comparisons\u2014like NumPy comparisons\u2014is <em>not</em> a simple <code>bool</code> but rather a <code>tf.Tensor</code> object. We don't currently override <code>Tensor.__nonzero__()</code> (Python 2) or <code>Tensor.__bool__()</code> (Python 3), so a <code>tf.Tensor</code> is always considered to be \"<code>True</code>\" in comparisons etc.</p>\n<p>Since this is a common error, I'm going to submit a quick fix that prevents this comparison. Unfortunately it isn't feasible to make the chained comparison syntax work, because Python's <a href=\"http://stackoverflow.com/a/12675160/3574081\" rel=\"nofollow\">bytecode translation for such comparisons</a> relies on the value of the <code>Tensor</code> which isn't available when you construct the graph. However, we can at least provide a better error message.</p>", "body_text": "Is there a particular library or language on which you're basing your expectation (other than mathematics, where obviously the expression is well defined :)...)?\nGenerally speaking, we've been trying to maintain consistency between the TensorFlow Python API and NumPy. If I try to compute multiple_inequality using NumPy, I get the following:\n>>> import numpy as np\n>>> lower_bound = np.array(\n...         [[ 0.,   0.,   0. ],\n...          [ 0.,   0.,   0. ],\n...          [ 0.5,  0.5,  0.5],\n...          [ 0.5,  0.5,  0.5],])\n>>> upper_bound = np.array(\n...         [[ 0.5,  0.5,  0.5],\n...          [ 0.5,  0.5,  0.5],\n...          [ 1.,   1.,   1. ],\n...          [ 1.,   1.,   1. ],])\n>>> test = np.array(\n...         [[ 0.30000001,  0.2,  0.82],\n...          [ 0.30000001,  0.2,  0.82],\n...          [ 0.30000001,  0.2,  0.82],\n...          [ 0.30000001,  0.2,  0.82],])\n>>> lower_bound <= test < upper_bound\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()\nMy intuition would be that this expression would be evaluated as one of the following (depending on the associativity of Python's comparison operators... I think it's the first of the two):\nx = lower_bound <= test  # a bool array\nmultiple_inequality = x < upper_bound  # bool vs. float\n# or\nx = test < upper_bound  # a bool array\nmultiple_inequality = lower_bound <= x  # bool vs. float\n...however, either of these examples seems to work in NumPy (albeit with potentially wacky results, since NumPy converts False to 0.0 and True to 1.0), so I'm not quite sure of the types.\n\nEDIT: TIL that Python has special syntax for chained comparisons! However, its functionality seems to be predicated on interpreting the result of a comparison as a boolean. Unfortunately, the result of TensorFlow comparisons\u2014like NumPy comparisons\u2014is not a simple bool but rather a tf.Tensor object. We don't currently override Tensor.__nonzero__() (Python 2) or Tensor.__bool__() (Python 3), so a tf.Tensor is always considered to be \"True\" in comparisons etc.\nSince this is a common error, I'm going to submit a quick fix that prevents this comparison. Unfortunately it isn't feasible to make the chained comparison syntax work, because Python's bytecode translation for such comparisons relies on the value of the Tensor which isn't available when you construct the graph. However, we can at least provide a better error message.", "body": "Is there a particular library or language on which you're basing your expectation (other than mathematics, where obviously the expression is well defined :)...)?\n\nGenerally speaking, we've been trying to maintain consistency between the TensorFlow Python API and NumPy. If I try to compute `multiple_inequality` using NumPy, I get the following:\n\n``` python\n>>> import numpy as np\n>>> lower_bound = np.array(\n...         [[ 0.,   0.,   0. ],\n...          [ 0.,   0.,   0. ],\n...          [ 0.5,  0.5,  0.5],\n...          [ 0.5,  0.5,  0.5],])\n>>> upper_bound = np.array(\n...         [[ 0.5,  0.5,  0.5],\n...          [ 0.5,  0.5,  0.5],\n...          [ 1.,   1.,   1. ],\n...          [ 1.,   1.,   1. ],])\n>>> test = np.array(\n...         [[ 0.30000001,  0.2,  0.82],\n...          [ 0.30000001,  0.2,  0.82],\n...          [ 0.30000001,  0.2,  0.82],\n...          [ 0.30000001,  0.2,  0.82],])\n>>> lower_bound <= test < upper_bound\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()\n```\n\nMy intuition would be that this expression would be evaluated as one of the following (depending on the associativity of Python's comparison operators... I think it's the first of the two):\n\n``` python\nx = lower_bound <= test  # a bool array\nmultiple_inequality = x < upper_bound  # bool vs. float\n# or\nx = test < upper_bound  # a bool array\nmultiple_inequality = lower_bound <= x  # bool vs. float\n```\n\n...however, either of these examples seems to work in NumPy (albeit with potentially wacky results, since NumPy converts `False` to `0.0` and `True` to `1.0`), so I'm not quite sure of the types.\n\n---\n\n**EDIT:** TIL that Python has [special syntax for chained comparisons](https://docs.python.org/2/reference/expressions.html#not-in)! However, its functionality seems to be predicated on interpreting the result of a comparison as a boolean. Unfortunately, the result of TensorFlow comparisons&mdash;like NumPy comparisons&mdash;is _not_ a simple `bool` but rather a `tf.Tensor` object. We don't currently override `Tensor.__nonzero__()` (Python 2) or `Tensor.__bool__()` (Python 3), so a `tf.Tensor` is always considered to be \"`True`\" in comparisons etc.\n\nSince this is a common error, I'm going to submit a quick fix that prevents this comparison. Unfortunately it isn't feasible to make the chained comparison syntax work, because Python's [bytecode translation for such comparisons](http://stackoverflow.com/a/12675160/3574081) relies on the value of the `Tensor` which isn't available when you construct the graph. However, we can at least provide a better error message.\n"}