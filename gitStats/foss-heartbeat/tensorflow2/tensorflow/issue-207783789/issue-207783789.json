{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/7525", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/7525/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/7525/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/7525/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/7525", "id": 207783789, "node_id": "MDU6SXNzdWUyMDc3ODM3ODk=", "number": 7525, "title": "OutOfRangeError: RandomShuffleQueue '_22_shuffle_batch_3/random_shuffle_queue' is closed and has insufficient elements (requested 32, current size 0)", "user": {"login": "Prakashvanapalli", "id": 11383400, "node_id": "MDQ6VXNlcjExMzgzNDAw", "avatar_url": "https://avatars0.githubusercontent.com/u/11383400?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Prakashvanapalli", "html_url": "https://github.com/Prakashvanapalli", "followers_url": "https://api.github.com/users/Prakashvanapalli/followers", "following_url": "https://api.github.com/users/Prakashvanapalli/following{/other_user}", "gists_url": "https://api.github.com/users/Prakashvanapalli/gists{/gist_id}", "starred_url": "https://api.github.com/users/Prakashvanapalli/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Prakashvanapalli/subscriptions", "organizations_url": "https://api.github.com/users/Prakashvanapalli/orgs", "repos_url": "https://api.github.com/users/Prakashvanapalli/repos", "events_url": "https://api.github.com/users/Prakashvanapalli/events{/privacy}", "received_events_url": "https://api.github.com/users/Prakashvanapalli/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 473184161, "node_id": "MDU6TGFiZWw0NzMxODQxNjE=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:support", "name": "type:support", "color": "159b2e", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2017-02-15T11:55:58Z", "updated_at": "2017-02-16T02:43:45Z", "closed_at": "2017-02-15T19:28:12Z", "author_association": "NONE", "body_html": "<p>I m trying to read images using tensorflow tf.train function but have been getting the following issue. please help me</p>\n<pre><code>import tensorflow as tf\nimport glob\nfilelist = glob.glob(\"../train/*.png\")\n\ndef read_my_file_format(filename_queue):\n    reader = tf.WholeFileReader()\n    key, record_string = reader.read(filename_queue)\n    example = tf.image.decode_png(record_string)\n    label = tf.reshape(key, [1], name=None)\n    return example, label\n\ndef input_pipeline(filenames, batch_size, num_epochs = None):\n    filename_queue = tf.train.string_input_producer(\n    filenames, num_epochs= num_epochs, shuffle = True)\n    example, label = read_my_file_format(filename_queue)\n    min_after_dequeue = 10000\n    capacity = min_after_dequeue+3*batch_size\n   example.set_shape([28, 28, 3])\n   label.set_shape([1,])\n   example_batch, label_batch = tf.train.shuffle_batch(\n   [example, label], batch_size = batch_size, capacity = capacity,\n   min_after_dequeue = min_after_dequeue)\n   return example_batch, label_batch\n\nexample_batch, label_batch = input_pipeline(filelist, 32)\n\n\nwith tf.Session() as sess:\n   # Required to get the filename matching to run.\n   tf.initialize_all_variables().run()\n\n  # Coordinate the loading of image files.\n  coord = tf.train.Coordinator()\n  threads = tf.train.start_queue_runners(coord=coord)\n\n  # Get an image tensor and print its value.\n  x = sess.run(example_batch)\n  print (x.shape)\n\n # Finish off the filename queue coordinator.\n  coord.request_stop()\n  coord.join(threads)\n\n\nOutOfRangeError: RandomShuffleQueue '_22_shuffle_batch_3/random_shuffle_queue' is closed and has insufficient elements (requested 32, current size 0)\n [[Node: shuffle_batch_3 = QueueDequeueMany[_class=[\"loc:@shuffle_batch_3/random_shuffle_queue\"], component_types=[DT_UINT8, DT_STRING], timeout_ms=-1, _device=\"/job:localhost/replica:0/task:0/cpu:0\"](shuffle_batch_3/random_shuffle_queue, shuffle_batch_3/n)]]\n\nOutOfRangeError (see above for traceback): RandomShuffleQueue '_22_shuffle_batch_3/random_shuffle_queue' is closed and has insufficient elements (requested 32, current size 0)\n [[Node: shuffle_batch_3 = QueueDequeueMany[_class=[\"loc:@shuffle_batch_3/random_shuffle_queue\"], component_types=[DT_UINT8, DT_STRING], timeout_ms=-1, _device=\"/job:localhost/replica:0/task:0/cpu:0\"](shuffle_batch_3/random_shuffle_queue, shuffle_batch_3/n)]]\n</code></pre>", "body_text": "I m trying to read images using tensorflow tf.train function but have been getting the following issue. please help me\nimport tensorflow as tf\nimport glob\nfilelist = glob.glob(\"../train/*.png\")\n\ndef read_my_file_format(filename_queue):\n    reader = tf.WholeFileReader()\n    key, record_string = reader.read(filename_queue)\n    example = tf.image.decode_png(record_string)\n    label = tf.reshape(key, [1], name=None)\n    return example, label\n\ndef input_pipeline(filenames, batch_size, num_epochs = None):\n    filename_queue = tf.train.string_input_producer(\n    filenames, num_epochs= num_epochs, shuffle = True)\n    example, label = read_my_file_format(filename_queue)\n    min_after_dequeue = 10000\n    capacity = min_after_dequeue+3*batch_size\n   example.set_shape([28, 28, 3])\n   label.set_shape([1,])\n   example_batch, label_batch = tf.train.shuffle_batch(\n   [example, label], batch_size = batch_size, capacity = capacity,\n   min_after_dequeue = min_after_dequeue)\n   return example_batch, label_batch\n\nexample_batch, label_batch = input_pipeline(filelist, 32)\n\n\nwith tf.Session() as sess:\n   # Required to get the filename matching to run.\n   tf.initialize_all_variables().run()\n\n  # Coordinate the loading of image files.\n  coord = tf.train.Coordinator()\n  threads = tf.train.start_queue_runners(coord=coord)\n\n  # Get an image tensor and print its value.\n  x = sess.run(example_batch)\n  print (x.shape)\n\n # Finish off the filename queue coordinator.\n  coord.request_stop()\n  coord.join(threads)\n\n\nOutOfRangeError: RandomShuffleQueue '_22_shuffle_batch_3/random_shuffle_queue' is closed and has insufficient elements (requested 32, current size 0)\n [[Node: shuffle_batch_3 = QueueDequeueMany[_class=[\"loc:@shuffle_batch_3/random_shuffle_queue\"], component_types=[DT_UINT8, DT_STRING], timeout_ms=-1, _device=\"/job:localhost/replica:0/task:0/cpu:0\"](shuffle_batch_3/random_shuffle_queue, shuffle_batch_3/n)]]\n\nOutOfRangeError (see above for traceback): RandomShuffleQueue '_22_shuffle_batch_3/random_shuffle_queue' is closed and has insufficient elements (requested 32, current size 0)\n [[Node: shuffle_batch_3 = QueueDequeueMany[_class=[\"loc:@shuffle_batch_3/random_shuffle_queue\"], component_types=[DT_UINT8, DT_STRING], timeout_ms=-1, _device=\"/job:localhost/replica:0/task:0/cpu:0\"](shuffle_batch_3/random_shuffle_queue, shuffle_batch_3/n)]]", "body": "I m trying to read images using tensorflow tf.train function but have been getting the following issue. please help me \r\n\r\n\r\n    import tensorflow as tf\r\n    import glob\r\n    filelist = glob.glob(\"../train/*.png\")\r\n\r\n    def read_my_file_format(filename_queue):\r\n        reader = tf.WholeFileReader()\r\n        key, record_string = reader.read(filename_queue)\r\n        example = tf.image.decode_png(record_string)\r\n        label = tf.reshape(key, [1], name=None)\r\n        return example, label\r\n\r\n    def input_pipeline(filenames, batch_size, num_epochs = None):\r\n        filename_queue = tf.train.string_input_producer(\r\n        filenames, num_epochs= num_epochs, shuffle = True)\r\n        example, label = read_my_file_format(filename_queue)\r\n        min_after_dequeue = 10000\r\n        capacity = min_after_dequeue+3*batch_size\r\n       example.set_shape([28, 28, 3])\r\n       label.set_shape([1,])\r\n       example_batch, label_batch = tf.train.shuffle_batch(\r\n       [example, label], batch_size = batch_size, capacity = capacity,\r\n       min_after_dequeue = min_after_dequeue)\r\n       return example_batch, label_batch\r\n\r\n    example_batch, label_batch = input_pipeline(filelist, 32)\r\n\r\n\r\n    with tf.Session() as sess:\r\n       # Required to get the filename matching to run.\r\n       tf.initialize_all_variables().run()\r\n\r\n      # Coordinate the loading of image files.\r\n      coord = tf.train.Coordinator()\r\n      threads = tf.train.start_queue_runners(coord=coord)\r\n\r\n      # Get an image tensor and print its value.\r\n      x = sess.run(example_batch)\r\n      print (x.shape)\r\n\r\n     # Finish off the filename queue coordinator.\r\n      coord.request_stop()\r\n      coord.join(threads)\r\n\r\n\r\n    OutOfRangeError: RandomShuffleQueue '_22_shuffle_batch_3/random_shuffle_queue' is closed and has insufficient elements (requested 32, current size 0)\r\n\t [[Node: shuffle_batch_3 = QueueDequeueMany[_class=[\"loc:@shuffle_batch_3/random_shuffle_queue\"], component_types=[DT_UINT8, DT_STRING], timeout_ms=-1, _device=\"/job:localhost/replica:0/task:0/cpu:0\"](shuffle_batch_3/random_shuffle_queue, shuffle_batch_3/n)]]\r\n\r\n    OutOfRangeError (see above for traceback): RandomShuffleQueue '_22_shuffle_batch_3/random_shuffle_queue' is closed and has insufficient elements (requested 32, current size 0)\r\n\t [[Node: shuffle_batch_3 = QueueDequeueMany[_class=[\"loc:@shuffle_batch_3/random_shuffle_queue\"], component_types=[DT_UINT8, DT_STRING], timeout_ms=-1, _device=\"/job:localhost/replica:0/task:0/cpu:0\"](shuffle_batch_3/random_shuffle_queue, shuffle_batch_3/n)]]\r\n\r\n\r\n"}