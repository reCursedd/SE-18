{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/312321622", "html_url": "https://github.com/tensorflow/tensorflow/issues/10800#issuecomment-312321622", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/10800", "id": 312321622, "node_id": "MDEyOklzc3VlQ29tbWVudDMxMjMyMTYyMg==", "user": {"login": "yaroslavvb", "id": 23068, "node_id": "MDQ6VXNlcjIzMDY4", "avatar_url": "https://avatars3.githubusercontent.com/u/23068?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yaroslavvb", "html_url": "https://github.com/yaroslavvb", "followers_url": "https://api.github.com/users/yaroslavvb/followers", "following_url": "https://api.github.com/users/yaroslavvb/following{/other_user}", "gists_url": "https://api.github.com/users/yaroslavvb/gists{/gist_id}", "starred_url": "https://api.github.com/users/yaroslavvb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yaroslavvb/subscriptions", "organizations_url": "https://api.github.com/users/yaroslavvb/orgs", "repos_url": "https://api.github.com/users/yaroslavvb/repos", "events_url": "https://api.github.com/users/yaroslavvb/events{/privacy}", "received_events_url": "https://api.github.com/users/yaroslavvb/received_events", "type": "User", "site_admin": false}, "created_at": "2017-06-30T17:05:05Z", "updated_at": "2017-06-30T17:05:05Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=2372391\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/3rd3\">@3rd3</a></p>\n<p>Note that reason for current semantics is that it matches what you would expect from other programming languages:</p>\n<p>IE consider</p>\n<pre><code>1+2 if False else 2+3\n</code></pre>\n<p>vs</p>\n<pre><code>a=1+2\na if False else b\n</code></pre>\n<p>Like in your case with <code>tf.cond</code>, computation <code>a</code> is getting evaluated despite <code>if</code> being lazy. The way to make it truely lazy both in Python and TensorFlow case, is to move the actual computation inside <code>if</code>.</p>\n<p>Changing existing <code>tf.cond</code> to work lazily on computation previously defined, would change the semantics. IE, suppose you have <code>tf.cond(a,b,c)</code>. Tensors <code>b</code> and <code>c</code> may have side-effects such as triggering variable assignments, and if you optimize it out, it'll change behavior/break existing TF scripts.</p>\n<p>It might be useful to have something like <code>lazycond(a,b,c)</code> construct which has semantics you want. It could be done purely on Python level by analyzing graph and inserting appropriate switch/merge statements.</p>", "body_text": "@3rd3\nNote that reason for current semantics is that it matches what you would expect from other programming languages:\nIE consider\n1+2 if False else 2+3\n\nvs\na=1+2\na if False else b\n\nLike in your case with tf.cond, computation a is getting evaluated despite if being lazy. The way to make it truely lazy both in Python and TensorFlow case, is to move the actual computation inside if.\nChanging existing tf.cond to work lazily on computation previously defined, would change the semantics. IE, suppose you have tf.cond(a,b,c). Tensors b and c may have side-effects such as triggering variable assignments, and if you optimize it out, it'll change behavior/break existing TF scripts.\nIt might be useful to have something like lazycond(a,b,c) construct which has semantics you want. It could be done purely on Python level by analyzing graph and inserting appropriate switch/merge statements.", "body": "@3rd3\r\n\r\nNote that reason for current semantics is that it matches what you would expect from other programming languages:\r\n\r\nIE consider\r\n\r\n```\r\n1+2 if False else 2+3\r\n```\r\nvs\r\n\r\n```\r\na=1+2\r\na if False else b\r\n```\r\n\r\nLike in your case with `tf.cond`, computation `a` is getting evaluated despite `if` being lazy. The way to make it truely lazy both in Python and TensorFlow case, is to move the actual computation inside `if`.\r\n\r\nChanging existing `tf.cond` to work lazily on computation previously defined, would change the semantics. IE, suppose you have `tf.cond(a,b,c)`. Tensors `b` and `c` may have side-effects such as triggering variable assignments, and if you optimize it out, it'll change behavior/break existing TF scripts.\r\n\r\nIt might be useful to have something like `lazycond(a,b,c)` construct which has semantics you want. It could be done purely on Python level by analyzing graph and inserting appropriate switch/merge statements."}