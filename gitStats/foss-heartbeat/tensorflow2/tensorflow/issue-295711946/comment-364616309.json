{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/364616309", "html_url": "https://github.com/tensorflow/tensorflow/issues/16882#issuecomment-364616309", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/16882", "id": 364616309, "node_id": "MDEyOklzc3VlQ29tbWVudDM2NDYxNjMwOQ==", "user": {"login": "rongjiecomputer", "id": 13115060, "node_id": "MDQ6VXNlcjEzMTE1MDYw", "avatar_url": "https://avatars2.githubusercontent.com/u/13115060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rongjiecomputer", "html_url": "https://github.com/rongjiecomputer", "followers_url": "https://api.github.com/users/rongjiecomputer/followers", "following_url": "https://api.github.com/users/rongjiecomputer/following{/other_user}", "gists_url": "https://api.github.com/users/rongjiecomputer/gists{/gist_id}", "starred_url": "https://api.github.com/users/rongjiecomputer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rongjiecomputer/subscriptions", "organizations_url": "https://api.github.com/users/rongjiecomputer/orgs", "repos_url": "https://api.github.com/users/rongjiecomputer/repos", "events_url": "https://api.github.com/users/rongjiecomputer/events{/privacy}", "received_events_url": "https://api.github.com/users/rongjiecomputer/received_events", "type": "User", "site_admin": false}, "created_at": "2018-02-10T01:50:55Z", "updated_at": "2018-02-10T01:50:55Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Simple test case:</p>\n<div class=\"highlight highlight-source-c++\"><pre>#<span class=\"pl-k\">include</span> <span class=\"pl-s\"><span class=\"pl-pds\">&lt;</span>cstdio<span class=\"pl-pds\">&gt;</span></span>\n\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>&gt;\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">A</span> {\n  T x;\n};\n\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>&gt;\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">B</span> {\n  T x;\n};\n\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">C</span> {\n  <span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>&gt;\n  A&lt;T&gt; <span class=\"pl-en\">f</span>() {\n    <span class=\"pl-c1\">puts</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>A C::f() called<span class=\"pl-pds\">\"</span></span>);\n    <span class=\"pl-k\">return</span> A&lt;T&gt;{<span class=\"pl-c1\">1</span>};\n  }\n  <span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>&gt;\n  B&lt;T&gt; <span class=\"pl-en\">f</span>() <span class=\"pl-k\">const</span> {\n    <span class=\"pl-c1\">puts</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>B C::f const() called<span class=\"pl-pds\">\"</span></span>);\n    <span class=\"pl-k\">return</span> B&lt;T&gt;{<span class=\"pl-c1\">1</span>};\n  }\n  <span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>&gt;\n  <span class=\"pl-k\">void</span> <span class=\"pl-en\">test</span>() {\n    <span class=\"pl-k\">auto</span> lambda = [&amp;]() {\n      <span class=\"pl-c1\">acceptA</span>(f&lt;T&gt;());\n    };\n    <span class=\"pl-c1\">lambda</span>();\n  }\n};\n\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">class</span> <span class=\"pl-en\">T</span>&gt;\nT <span class=\"pl-en\">acceptA</span>(<span class=\"pl-k\">const</span> A&lt;T&gt;&amp; a) {\n  <span class=\"pl-k\">return</span> a.<span class=\"pl-smi\">x</span>;\n}\n\n<span class=\"pl-k\">int</span> <span class=\"pl-en\">main</span>() {\n  C c1;\n  c1.<span class=\"pl-smi\">test</span>&lt;<span class=\"pl-k\">int</span>&gt;();\n}</pre></div>\n<p>Due to MSVC's buggy template parsing, <code>acceptA(f&lt;T&gt;())</code> will fail. Changing it to <code>acceptA(this-&gt;f&lt;T&gt;())</code> will make it work for MSVC. GCC and Clang will happily accept the extra <code>this-&gt;</code>. PR coming soon.</p>", "body_text": "Simple test case:\n#include <cstdio>\n\ntemplate <class T>\nstruct A {\n  T x;\n};\n\ntemplate <class T>\nstruct B {\n  T x;\n};\n\nstruct C {\n  template <class T>\n  A<T> f() {\n    puts(\"A C::f() called\");\n    return A<T>{1};\n  }\n  template <class T>\n  B<T> f() const {\n    puts(\"B C::f const() called\");\n    return B<T>{1};\n  }\n  template <class T>\n  void test() {\n    auto lambda = [&]() {\n      acceptA(f<T>());\n    };\n    lambda();\n  }\n};\n\ntemplate <class T>\nT acceptA(const A<T>& a) {\n  return a.x;\n}\n\nint main() {\n  C c1;\n  c1.test<int>();\n}\nDue to MSVC's buggy template parsing, acceptA(f<T>()) will fail. Changing it to acceptA(this->f<T>()) will make it work for MSVC. GCC and Clang will happily accept the extra this->. PR coming soon.", "body": "Simple test case:\r\n\r\n```cpp\r\n#include <cstdio>\r\n\r\ntemplate <class T>\r\nstruct A {\r\n  T x;\r\n};\r\n\r\ntemplate <class T>\r\nstruct B {\r\n  T x;\r\n};\r\n\r\nstruct C {\r\n  template <class T>\r\n  A<T> f() {\r\n    puts(\"A C::f() called\");\r\n    return A<T>{1};\r\n  }\r\n  template <class T>\r\n  B<T> f() const {\r\n    puts(\"B C::f const() called\");\r\n    return B<T>{1};\r\n  }\r\n  template <class T>\r\n  void test() {\r\n    auto lambda = [&]() {\r\n      acceptA(f<T>());\r\n    };\r\n    lambda();\r\n  }\r\n};\r\n\r\ntemplate <class T>\r\nT acceptA(const A<T>& a) {\r\n  return a.x;\r\n}\r\n\r\nint main() {\r\n  C c1;\r\n  c1.test<int>();\r\n}\r\n```\r\n\r\nDue to MSVC's buggy template parsing, `acceptA(f<T>())` will fail. Changing it to `acceptA(this->f<T>())` will make it work for MSVC. GCC and Clang will happily accept the extra `this->`. PR coming soon."}