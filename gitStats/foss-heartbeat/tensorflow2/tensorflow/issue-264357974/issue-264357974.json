{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13614", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13614/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13614/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13614/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/13614", "id": 264357974, "node_id": "MDU6SXNzdWUyNjQzNTc5NzQ=", "number": 13614, "title": "SSD mobilenet trained model with custom data only recognize images in short distances", "user": {"login": "oldschool69", "id": 8898915, "node_id": "MDQ6VXNlcjg4OTg5MTU=", "avatar_url": "https://avatars2.githubusercontent.com/u/8898915?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oldschool69", "html_url": "https://github.com/oldschool69", "followers_url": "https://api.github.com/users/oldschool69/followers", "following_url": "https://api.github.com/users/oldschool69/following{/other_user}", "gists_url": "https://api.github.com/users/oldschool69/gists{/gist_id}", "starred_url": "https://api.github.com/users/oldschool69/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oldschool69/subscriptions", "organizations_url": "https://api.github.com/users/oldschool69/orgs", "repos_url": "https://api.github.com/users/oldschool69/repos", "events_url": "https://api.github.com/users/oldschool69/events{/privacy}", "received_events_url": "https://api.github.com/users/oldschool69/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2017-10-10T20:04:10Z", "updated_at": "2017-10-11T01:00:41Z", "closed_at": "2017-10-11T01:00:41Z", "author_association": "NONE", "body_html": "<p>System information</p>\n<ul>\n<li>\n<p><strong>Have I written custom code (as opposed to using a stock example script provided in TensorFlow)</strong>:<br>\nNo</p>\n</li>\n<li>\n<p><strong>OS Platform and Distribution (e.g., Linux Ubuntu 16.04)</strong>:<br>\nUbuntu 14.04</p>\n</li>\n<li>\n<p><strong>TensorFlow installed from (source or binary)</strong>:<br>\nbinary</p>\n</li>\n<li>\n<p><strong>TensorFlow version (use command below)</strong>:<br>\n'v1.2.0-rc2-21-g12f033d', '1.2.0'</p>\n</li>\n<li>\n<p><strong>Python version</strong>:<br>\n2.7</p>\n</li>\n<li>\n<p><strong>Bazel version (if compiling from source)</strong>:<br>\nna</p>\n</li>\n<li>\n<p><strong>CUDA/cuDNN version</strong>:<br>\nCUDA Version 8.0.61</p>\n</li>\n<li>\n<p><strong>GPU model and memory</strong>:<br>\nname: GeForce GTX 1080 Ti<br>\nmajor: 6 minor: 1 memoryClockRate (GHz) 1.683<br>\npciBusID 0000:01:00.0<br>\nTotal memory: 10.91GiB<br>\nFree memory: 10.75GiB</p>\n</li>\n<li>\n<p><strong>Exact command to reproduce</strong>:</p>\n</li>\n</ul>\n<h3>Describe the problem</h3>\n<p>I've trained a model with a custom dataset (Garfield images) with Tensorflow Object Detection API (ssd_mobilenet_v1 model) and referring it in the android sample application available on Tensorflow repository. The application can only detected the images in distances less or equal 20cm approximately.</p>\n<p>Do you have any clue about I can improve the model to perform recognitions in longer distances (about 30cm or more) ?</p>\n<p>I don't know with this limitation is related with input size I'm using (tested with images with 300x300 and 68x68) or any custom data augmentation is needed to improve that.</p>\n<h3>Source code / logs</h3>\n<h1>SSD with Mobilenet v1, configured for Oxford-IIIT Pets Dataset.</h1>\n<h1>Users should configure the fine_tune_checkpoint field in the train config as</h1>\n<h1>well as the label_map_path and input_path fields in the train_input_reader and</h1>\n<h1>eval_input_reader. Search for \"PATH_TO_BE_CONFIGURED\" to find the fields that</h1>\n<h1>should be configured.</h1>\n<p>model {<br>\nssd {<br>\nnum_classes: 1<br>\nbox_coder {<br>\nfaster_rcnn_box_coder {<br>\ny_scale: 10.0<br>\nx_scale: 10.0<br>\nheight_scale: 5.0<br>\nwidth_scale: 5.0<br>\n}<br>\n}<br>\nmatcher {<br>\nargmax_matcher {<br>\nmatched_threshold: 0.5<br>\nunmatched_threshold: 0.5<br>\nignore_thresholds: false<br>\nnegatives_lower_than_unmatched: true<br>\nforce_match_for_each_row: true<br>\n}<br>\n}<br>\nsimilarity_calculator {<br>\niou_similarity {<br>\n}<br>\n}<br>\nanchor_generator {<br>\nssd_anchor_generator {<br>\nnum_layers: 6<br>\nmin_scale: 0.2<br>\nmax_scale: 0.95<br>\naspect_ratios: 1.0<br>\naspect_ratios: 2.0<br>\naspect_ratios: 0.5<br>\naspect_ratios: 3.0<br>\naspect_ratios: 0.3333<br>\n}<br>\n}<br>\nimage_resizer {<br>\nfixed_shape_resizer {<br>\nheight: 68<br>\nwidth: 68<br>\n}<br>\n}<br>\nbox_predictor {<br>\nconvolutional_box_predictor {<br>\nmin_depth: 0<br>\nmax_depth: 0<br>\nnum_layers_before_predictor: 0<br>\nuse_dropout: false<br>\ndropout_keep_probability: 0.8<br>\nkernel_size: 1<br>\nbox_code_size: 4<br>\napply_sigmoid_to_scores: false<br>\nconv_hyperparams {<br>\nactivation: RELU_6,<br>\nregularizer {<br>\nl2_regularizer {<br>\nweight: 0.00004<br>\n}<br>\n}<br>\ninitializer {<br>\ntruncated_normal_initializer {<br>\nstddev: 0.03<br>\nmean: 0.0<br>\n}<br>\n}<br>\nbatch_norm {<br>\ntrain: true,<br>\nscale: true,<br>\ncenter: true,<br>\ndecay: 0.9997,<br>\nepsilon: 0.001,<br>\n}<br>\n}<br>\n}<br>\n}<br>\nfeature_extractor {<br>\ntype: 'ssd_mobilenet_v1'<br>\nmin_depth: 16<br>\ndepth_multiplier: 1.0<br>\nconv_hyperparams {<br>\nactivation: RELU_6,<br>\nregularizer {<br>\nl2_regularizer {<br>\nweight: 0.00004<br>\n}<br>\n}<br>\ninitializer {<br>\ntruncated_normal_initializer {<br>\nstddev: 0.03<br>\nmean: 0.0<br>\n}<br>\n}<br>\nbatch_norm {<br>\ntrain: true,<br>\nscale: true,<br>\ncenter: true,<br>\ndecay: 0.9997,<br>\nepsilon: 0.001,<br>\n}<br>\n}<br>\n}<br>\nloss {<br>\nclassification_loss {<br>\nweighted_sigmoid {<br>\nanchorwise_output: true<br>\n}<br>\n}<br>\nlocalization_loss {<br>\nweighted_smooth_l1 {<br>\nanchorwise_output: true<br>\n}<br>\n}<br>\nhard_example_miner {<br>\nnum_hard_examples: 3000<br>\niou_threshold: 0.99<br>\nloss_type: CLASSIFICATION<br>\nmax_negatives_per_positive: 3<br>\nmin_negatives_per_image: 0<br>\n}<br>\nclassification_weight: 1.0<br>\nlocalization_weight: 1.0<br>\n}<br>\nnormalize_loss_by_num_matches: true<br>\npost_processing {<br>\nbatch_non_max_suppression {<br>\nscore_threshold: 1e-8<br>\niou_threshold: 0.6<br>\nmax_detections_per_class: 100<br>\nmax_total_detections: 100<br>\n}<br>\nscore_converter: SIGMOID<br>\n}<br>\n}<br>\n}<br>\ntrain_config: {<br>\nbatch_size: 24<br>\noptimizer {<br>\nrms_prop_optimizer: {<br>\nlearning_rate: {<br>\nexponential_decay_learning_rate {<br>\ninitial_learning_rate: 0.004<br>\ndecay_steps: 800720<br>\ndecay_factor: 0.95<br>\n}<br>\n}<br>\nmomentum_optimizer_value: 0.9<br>\ndecay: 0.9<br>\nepsilon: 1.0<br>\n}<br>\n}<br>\n#fine_tune_checkpoint: \"/home/oliveira/tf_oda/checkpoints/ssd_mobilenet_v1_coco_11_06_2017/model.ckpt\"<br>\nfrom_detection_checkpoint: true</p>\n<h1>Note: The below line limits the training process to 200K steps, which we</h1>\n<h1>empirically found to be sufficient enough to train the pets dataset. This</h1>\n<h1>effectively bypasses the learning rate schedule (the learning rate will</h1>\n<h1>never decay). Remove the below line to train indefinitely.</h1>\n<p>num_steps: 200000<br>\ndata_augmentation_options {<br>\nrandom_horizontal_flip {<br>\n}<br>\n}<br>\ndata_augmentation_options {<br>\nssd_random_crop {<br>\n}<br>\n}<br>\n}</p>\n<p>train_input_reader: {<br>\ntf_record_input_reader {<br>\ninput_path: \"/data/tf_oda/garfield/dataset/pascal_train_garfield_68.record\"<br>\n}<br>\nlabel_map_path: \"/data/tf_oda/garfield/data/pascal_label_map_garfield.pbtxt\"<br>\n}</p>\n<p>eval_config: {<br>\nnum_examples: 2000</p>\n<h1>Note: The below line limits the evaluation process to 10 evaluations.</h1>\n<h1>Remove the below line to evaluate indefinitely.</h1>\n<p>max_evals: 10<br>\n}</p>\n<p>eval_input_reader: {<br>\ntf_record_input_reader {<br>\ninput_path: \"/data/tf_oda/garfield/dataset/pascal_val_garfield_68.record\"<br>\n}<br>\nlabel_map_path: \"/data/tf_oda/garfield/data/pascal_label_map_garfield.pbtxt\"<br>\nshuffle: false<br>\nnum_readers: 1<br>\n}</p>", "body_text": "System information\n\n\nHave I written custom code (as opposed to using a stock example script provided in TensorFlow):\nNo\n\n\nOS Platform and Distribution (e.g., Linux Ubuntu 16.04):\nUbuntu 14.04\n\n\nTensorFlow installed from (source or binary):\nbinary\n\n\nTensorFlow version (use command below):\n'v1.2.0-rc2-21-g12f033d', '1.2.0'\n\n\nPython version:\n2.7\n\n\nBazel version (if compiling from source):\nna\n\n\nCUDA/cuDNN version:\nCUDA Version 8.0.61\n\n\nGPU model and memory:\nname: GeForce GTX 1080 Ti\nmajor: 6 minor: 1 memoryClockRate (GHz) 1.683\npciBusID 0000:01:00.0\nTotal memory: 10.91GiB\nFree memory: 10.75GiB\n\n\nExact command to reproduce:\n\n\nDescribe the problem\nI've trained a model with a custom dataset (Garfield images) with Tensorflow Object Detection API (ssd_mobilenet_v1 model) and referring it in the android sample application available on Tensorflow repository. The application can only detected the images in distances less or equal 20cm approximately.\nDo you have any clue about I can improve the model to perform recognitions in longer distances (about 30cm or more) ?\nI don't know with this limitation is related with input size I'm using (tested with images with 300x300 and 68x68) or any custom data augmentation is needed to improve that.\nSource code / logs\nSSD with Mobilenet v1, configured for Oxford-IIIT Pets Dataset.\nUsers should configure the fine_tune_checkpoint field in the train config as\nwell as the label_map_path and input_path fields in the train_input_reader and\neval_input_reader. Search for \"PATH_TO_BE_CONFIGURED\" to find the fields that\nshould be configured.\nmodel {\nssd {\nnum_classes: 1\nbox_coder {\nfaster_rcnn_box_coder {\ny_scale: 10.0\nx_scale: 10.0\nheight_scale: 5.0\nwidth_scale: 5.0\n}\n}\nmatcher {\nargmax_matcher {\nmatched_threshold: 0.5\nunmatched_threshold: 0.5\nignore_thresholds: false\nnegatives_lower_than_unmatched: true\nforce_match_for_each_row: true\n}\n}\nsimilarity_calculator {\niou_similarity {\n}\n}\nanchor_generator {\nssd_anchor_generator {\nnum_layers: 6\nmin_scale: 0.2\nmax_scale: 0.95\naspect_ratios: 1.0\naspect_ratios: 2.0\naspect_ratios: 0.5\naspect_ratios: 3.0\naspect_ratios: 0.3333\n}\n}\nimage_resizer {\nfixed_shape_resizer {\nheight: 68\nwidth: 68\n}\n}\nbox_predictor {\nconvolutional_box_predictor {\nmin_depth: 0\nmax_depth: 0\nnum_layers_before_predictor: 0\nuse_dropout: false\ndropout_keep_probability: 0.8\nkernel_size: 1\nbox_code_size: 4\napply_sigmoid_to_scores: false\nconv_hyperparams {\nactivation: RELU_6,\nregularizer {\nl2_regularizer {\nweight: 0.00004\n}\n}\ninitializer {\ntruncated_normal_initializer {\nstddev: 0.03\nmean: 0.0\n}\n}\nbatch_norm {\ntrain: true,\nscale: true,\ncenter: true,\ndecay: 0.9997,\nepsilon: 0.001,\n}\n}\n}\n}\nfeature_extractor {\ntype: 'ssd_mobilenet_v1'\nmin_depth: 16\ndepth_multiplier: 1.0\nconv_hyperparams {\nactivation: RELU_6,\nregularizer {\nl2_regularizer {\nweight: 0.00004\n}\n}\ninitializer {\ntruncated_normal_initializer {\nstddev: 0.03\nmean: 0.0\n}\n}\nbatch_norm {\ntrain: true,\nscale: true,\ncenter: true,\ndecay: 0.9997,\nepsilon: 0.001,\n}\n}\n}\nloss {\nclassification_loss {\nweighted_sigmoid {\nanchorwise_output: true\n}\n}\nlocalization_loss {\nweighted_smooth_l1 {\nanchorwise_output: true\n}\n}\nhard_example_miner {\nnum_hard_examples: 3000\niou_threshold: 0.99\nloss_type: CLASSIFICATION\nmax_negatives_per_positive: 3\nmin_negatives_per_image: 0\n}\nclassification_weight: 1.0\nlocalization_weight: 1.0\n}\nnormalize_loss_by_num_matches: true\npost_processing {\nbatch_non_max_suppression {\nscore_threshold: 1e-8\niou_threshold: 0.6\nmax_detections_per_class: 100\nmax_total_detections: 100\n}\nscore_converter: SIGMOID\n}\n}\n}\ntrain_config: {\nbatch_size: 24\noptimizer {\nrms_prop_optimizer: {\nlearning_rate: {\nexponential_decay_learning_rate {\ninitial_learning_rate: 0.004\ndecay_steps: 800720\ndecay_factor: 0.95\n}\n}\nmomentum_optimizer_value: 0.9\ndecay: 0.9\nepsilon: 1.0\n}\n}\n#fine_tune_checkpoint: \"/home/oliveira/tf_oda/checkpoints/ssd_mobilenet_v1_coco_11_06_2017/model.ckpt\"\nfrom_detection_checkpoint: true\nNote: The below line limits the training process to 200K steps, which we\nempirically found to be sufficient enough to train the pets dataset. This\neffectively bypasses the learning rate schedule (the learning rate will\nnever decay). Remove the below line to train indefinitely.\nnum_steps: 200000\ndata_augmentation_options {\nrandom_horizontal_flip {\n}\n}\ndata_augmentation_options {\nssd_random_crop {\n}\n}\n}\ntrain_input_reader: {\ntf_record_input_reader {\ninput_path: \"/data/tf_oda/garfield/dataset/pascal_train_garfield_68.record\"\n}\nlabel_map_path: \"/data/tf_oda/garfield/data/pascal_label_map_garfield.pbtxt\"\n}\neval_config: {\nnum_examples: 2000\nNote: The below line limits the evaluation process to 10 evaluations.\nRemove the below line to evaluate indefinitely.\nmax_evals: 10\n}\neval_input_reader: {\ntf_record_input_reader {\ninput_path: \"/data/tf_oda/garfield/dataset/pascal_val_garfield_68.record\"\n}\nlabel_map_path: \"/data/tf_oda/garfield/data/pascal_label_map_garfield.pbtxt\"\nshuffle: false\nnum_readers: 1\n}", "body": " System information\r\n- **Have I written custom code (as opposed to using a stock example script provided in TensorFlow)**:\r\n     No\r\n- **OS Platform and Distribution (e.g., Linux Ubuntu 16.04)**:\r\n     Ubuntu 14.04\r\n- **TensorFlow installed from (source or binary)**:\r\n     binary\r\n- **TensorFlow version (use command below)**:\r\n     'v1.2.0-rc2-21-g12f033d', '1.2.0'\r\n- **Python version**: \r\n     2.7\r\n- **Bazel version (if compiling from source)**:\r\n     na\r\n- **CUDA/cuDNN version**:\r\n     CUDA Version 8.0.61\r\n     \r\n- **GPU model and memory**:\r\nname: GeForce GTX 1080 Ti\r\nmajor: 6 minor: 1 memoryClockRate (GHz) 1.683\r\npciBusID 0000:01:00.0\r\nTotal memory: 10.91GiB\r\nFree memory: 10.75GiB\r\n\r\n- **Exact command to reproduce**:\r\n\r\n\r\n### Describe the problem\r\n\r\nI've trained a model with a custom dataset (Garfield images) with Tensorflow Object Detection API (ssd_mobilenet_v1 model) and referring it in the android sample application available on Tensorflow repository. The application can only detected the images in distances less or equal 20cm approximately.\r\n\r\nDo you have any clue about I can improve the model to perform recognitions in longer distances (about 30cm or more) ?\r\n\r\nI don't know with this limitation is related with input size I'm using (tested with images with 300x300 and 68x68) or any custom data augmentation is needed to improve that.\r\n\r\n\r\n### Source code / logs\r\n# SSD with Mobilenet v1, configured for Oxford-IIIT Pets Dataset.\r\n# Users should configure the fine_tune_checkpoint field in the train config as\r\n# well as the label_map_path and input_path fields in the train_input_reader and\r\n# eval_input_reader. Search for \"PATH_TO_BE_CONFIGURED\" to find the fields that\r\n# should be configured.\r\n\r\nmodel {\r\n  ssd {\r\n    num_classes: 1\r\n    box_coder {\r\n      faster_rcnn_box_coder {\r\n        y_scale: 10.0\r\n        x_scale: 10.0\r\n        height_scale: 5.0\r\n        width_scale: 5.0\r\n      }\r\n    }\r\n    matcher {\r\n      argmax_matcher {\r\n        matched_threshold: 0.5\r\n        unmatched_threshold: 0.5\r\n        ignore_thresholds: false\r\n        negatives_lower_than_unmatched: true\r\n        force_match_for_each_row: true\r\n      }\r\n    }\r\n    similarity_calculator {\r\n      iou_similarity {\r\n      }\r\n    }\r\n    anchor_generator {\r\n      ssd_anchor_generator {\r\n        num_layers: 6\r\n        min_scale: 0.2\r\n        max_scale: 0.95\r\n        aspect_ratios: 1.0\r\n        aspect_ratios: 2.0\r\n        aspect_ratios: 0.5\r\n        aspect_ratios: 3.0\r\n        aspect_ratios: 0.3333\r\n      }\r\n    }\r\n    image_resizer {\r\n      fixed_shape_resizer {\r\n        height: 68\r\n        width: 68\r\n      }\r\n    }\r\n    box_predictor {\r\n      convolutional_box_predictor {\r\n        min_depth: 0\r\n        max_depth: 0\r\n        num_layers_before_predictor: 0\r\n        use_dropout: false\r\n        dropout_keep_probability: 0.8\r\n        kernel_size: 1\r\n        box_code_size: 4\r\n        apply_sigmoid_to_scores: false\r\n        conv_hyperparams {\r\n          activation: RELU_6,\r\n          regularizer {\r\n            l2_regularizer {\r\n              weight: 0.00004\r\n            }\r\n          }\r\n          initializer {\r\n            truncated_normal_initializer {\r\n              stddev: 0.03\r\n              mean: 0.0\r\n            }\r\n          }\r\n          batch_norm {\r\n            train: true,\r\n            scale: true,\r\n            center: true,\r\n            decay: 0.9997,\r\n            epsilon: 0.001,\r\n          }\r\n        }\r\n      }\r\n    }\r\n    feature_extractor {\r\n      type: 'ssd_mobilenet_v1'\r\n      min_depth: 16\r\n      depth_multiplier: 1.0\r\n      conv_hyperparams {\r\n        activation: RELU_6,\r\n        regularizer {\r\n          l2_regularizer {\r\n            weight: 0.00004\r\n          }\r\n        }\r\n        initializer {\r\n          truncated_normal_initializer {\r\n            stddev: 0.03\r\n            mean: 0.0\r\n          }\r\n        }\r\n        batch_norm {\r\n          train: true,\r\n          scale: true,\r\n          center: true,\r\n          decay: 0.9997,\r\n          epsilon: 0.001,\r\n        }\r\n      }\r\n    }\r\n    loss {\r\n      classification_loss {\r\n        weighted_sigmoid {\r\n          anchorwise_output: true\r\n        }\r\n      }\r\n      localization_loss {\r\n        weighted_smooth_l1 {\r\n          anchorwise_output: true\r\n        }\r\n      }\r\n      hard_example_miner {\r\n        num_hard_examples: 3000\r\n        iou_threshold: 0.99\r\n        loss_type: CLASSIFICATION\r\n        max_negatives_per_positive: 3\r\n        min_negatives_per_image: 0\r\n      }\r\n      classification_weight: 1.0\r\n      localization_weight: 1.0\r\n    }\r\n    normalize_loss_by_num_matches: true\r\n    post_processing {\r\n      batch_non_max_suppression {\r\n        score_threshold: 1e-8\r\n        iou_threshold: 0.6\r\n        max_detections_per_class: 100\r\n        max_total_detections: 100\r\n      }\r\n      score_converter: SIGMOID\r\n    }\r\n  }\r\n}\t\r\ntrain_config: {\r\n  batch_size: 24\r\n  optimizer {\r\n    rms_prop_optimizer: {\r\n      learning_rate: {\r\n        exponential_decay_learning_rate {\r\n          initial_learning_rate: 0.004\r\n          decay_steps: 800720\r\n          decay_factor: 0.95\r\n        }\r\n      }\r\n      momentum_optimizer_value: 0.9\r\n      decay: 0.9\r\n      epsilon: 1.0\r\n    }\r\n  }\r\n  #fine_tune_checkpoint: \"/home/oliveira/tf_oda/checkpoints/ssd_mobilenet_v1_coco_11_06_2017/model.ckpt\"\r\n  from_detection_checkpoint: true\r\n  # Note: The below line limits the training process to 200K steps, which we\r\n  # empirically found to be sufficient enough to train the pets dataset. This\r\n  # effectively bypasses the learning rate schedule (the learning rate will\r\n  # never decay). Remove the below line to train indefinitely.\r\n  num_steps: 200000\r\n  data_augmentation_options {\r\n    random_horizontal_flip {\r\n    }\r\n  }\r\n  data_augmentation_options {\r\n    ssd_random_crop {\r\n    }\r\n  }\r\n}\r\n\r\ntrain_input_reader: {\r\n  tf_record_input_reader {\r\n    input_path: \"/data/tf_oda/garfield/dataset/pascal_train_garfield_68.record\"\r\n  }\r\n  label_map_path: \"/data/tf_oda/garfield/data/pascal_label_map_garfield.pbtxt\"\r\n}\r\n\r\neval_config: {\r\n  num_examples: 2000\r\n  # Note: The below line limits the evaluation process to 10 evaluations.\r\n  # Remove the below line to evaluate indefinitely.\r\n  max_evals: 10\r\n}\r\n\r\neval_input_reader: {\r\n  tf_record_input_reader {\r\n    input_path: \"/data/tf_oda/garfield/dataset/pascal_val_garfield_68.record\"\r\n  }\r\n  label_map_path: \"/data/tf_oda/garfield/data/pascal_label_map_garfield.pbtxt\"\r\n  shuffle: false\r\n  num_readers: 1\r\n}"}