{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/317804140", "html_url": "https://github.com/tensorflow/tensorflow/issues/11696#issuecomment-317804140", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11696", "id": 317804140, "node_id": "MDEyOklzc3VlQ29tbWVudDMxNzgwNDE0MA==", "user": {"login": "aselle", "id": 326106, "node_id": "MDQ6VXNlcjMyNjEwNg==", "avatar_url": "https://avatars1.githubusercontent.com/u/326106?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aselle", "html_url": "https://github.com/aselle", "followers_url": "https://api.github.com/users/aselle/followers", "following_url": "https://api.github.com/users/aselle/following{/other_user}", "gists_url": "https://api.github.com/users/aselle/gists{/gist_id}", "starred_url": "https://api.github.com/users/aselle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aselle/subscriptions", "organizations_url": "https://api.github.com/users/aselle/orgs", "repos_url": "https://api.github.com/users/aselle/repos", "events_url": "https://api.github.com/users/aselle/events{/privacy}", "received_events_url": "https://api.github.com/users/aselle/received_events", "type": "User", "site_admin": false}, "created_at": "2017-07-25T17:06:25Z", "updated_at": "2017-07-25T17:06:25Z", "author_association": "MEMBER", "body_html": "<p>Every op operand that expects a tensor implicitly runs convert_to_tensor... this is why<br>\ntf.constant([1,2,3]) works and stuff.  Even identity works like this i.e.</p>\n<pre><code>sess.run(tf.identity([tf.constant(3),tf.constant(4)]))\narray([3, 4], dtype=int32)\n</code></pre>\n<p>The identity op returns a single tensor and takes a single tensor. There are ops that return multiple tensors but they would need to explicitly be designed to do that. The print op is exactly the same. It doesn't take a list of tensors, it takes a single tensor and returns a single tensor. The Python bindings are trying to be helpful by implcitly making a single tensor out of what you provide. Perhaps convert_to_tensor should not be quite that helpful in the presence of a list of tensor objects vs a pure numpy array or a nested list of lists (where this behavior is expected), but that is how it works now.</p>", "body_text": "Every op operand that expects a tensor implicitly runs convert_to_tensor... this is why\ntf.constant([1,2,3]) works and stuff.  Even identity works like this i.e.\nsess.run(tf.identity([tf.constant(3),tf.constant(4)]))\narray([3, 4], dtype=int32)\n\nThe identity op returns a single tensor and takes a single tensor. There are ops that return multiple tensors but they would need to explicitly be designed to do that. The print op is exactly the same. It doesn't take a list of tensors, it takes a single tensor and returns a single tensor. The Python bindings are trying to be helpful by implcitly making a single tensor out of what you provide. Perhaps convert_to_tensor should not be quite that helpful in the presence of a list of tensor objects vs a pure numpy array or a nested list of lists (where this behavior is expected), but that is how it works now.", "body": "Every op operand that expects a tensor implicitly runs convert_to_tensor... this is why\r\ntf.constant([1,2,3]) works and stuff.  Even identity works like this i.e.\r\n\r\n```\r\nsess.run(tf.identity([tf.constant(3),tf.constant(4)]))\r\narray([3, 4], dtype=int32)\r\n```\r\nThe identity op returns a single tensor and takes a single tensor. There are ops that return multiple tensors but they would need to explicitly be designed to do that. The print op is exactly the same. It doesn't take a list of tensors, it takes a single tensor and returns a single tensor. The Python bindings are trying to be helpful by implcitly making a single tensor out of what you provide. Perhaps convert_to_tensor should not be quite that helpful in the presence of a list of tensor objects vs a pure numpy array or a nested list of lists (where this behavior is expected), but that is how it works now.\r\n"}