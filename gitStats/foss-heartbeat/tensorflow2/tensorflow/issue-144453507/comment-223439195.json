{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/223439195", "html_url": "https://github.com/tensorflow/tensorflow/issues/1704#issuecomment-223439195", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/1704", "id": 223439195, "node_id": "MDEyOklzc3VlQ29tbWVudDIyMzQzOTE5NQ==", "user": {"login": "rdadolf", "id": 6673605, "node_id": "MDQ6VXNlcjY2NzM2MDU=", "avatar_url": "https://avatars3.githubusercontent.com/u/6673605?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rdadolf", "html_url": "https://github.com/rdadolf", "followers_url": "https://api.github.com/users/rdadolf/followers", "following_url": "https://api.github.com/users/rdadolf/following{/other_user}", "gists_url": "https://api.github.com/users/rdadolf/gists{/gist_id}", "starred_url": "https://api.github.com/users/rdadolf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rdadolf/subscriptions", "organizations_url": "https://api.github.com/users/rdadolf/orgs", "repos_url": "https://api.github.com/users/rdadolf/repos", "events_url": "https://api.github.com/users/rdadolf/events{/privacy}", "received_events_url": "https://api.github.com/users/rdadolf/received_events", "type": "User", "site_admin": false}, "created_at": "2016-06-02T22:16:33Z", "updated_at": "2016-06-02T22:16:33Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Yep. That's the ultimate goal here: place tensorflow in directory X, and point <code>PYTHONPATH</code> to it, and write <code>import tensorflow</code>, where X is a directory of my choosing. Each one of these examples actually sets <code>PYTHONPATH</code> to <code>TF_INSTALL_DIR</code> before running, just like you mention. It certainly <em>seemed</em> like it should be that easy. Unfortunately, it seems that either due some combination of the packaging tools and the way the TensorFlow and/or protobuf packages are written, it's not.</p>\n<p>I do understand the virtualenv perspective. Without getting into too much of a holy war, virtualenv takes a very different approach to solving the problem, one that is pretty narrow in scope. Part of my hope was that I would only have to have one solution for dealing with versioning, environment, and consistency. virtualenv can only handle a small piece of the python-only part of that. For instance, there's a collection of training data and preprocessing which needs similar solutions: externally managed, place it in directory X, point Y to it, etc. Virtualenv isn't much help there. Same with some low-level instrumentation code which we use. And this is compounded by running on a variety of machines and platforms. So while I'll admit I'm a little biased because I don't much like virtualenv's approach to the world, I'd also really like to avoid adding more complexity in a lot of places just because of idiosyncrasies in the way tensorflow's package is written. (Especially since it was working two weeks ago!)</p>", "body_text": "Yep. That's the ultimate goal here: place tensorflow in directory X, and point PYTHONPATH to it, and write import tensorflow, where X is a directory of my choosing. Each one of these examples actually sets PYTHONPATH to TF_INSTALL_DIR before running, just like you mention. It certainly seemed like it should be that easy. Unfortunately, it seems that either due some combination of the packaging tools and the way the TensorFlow and/or protobuf packages are written, it's not.\nI do understand the virtualenv perspective. Without getting into too much of a holy war, virtualenv takes a very different approach to solving the problem, one that is pretty narrow in scope. Part of my hope was that I would only have to have one solution for dealing with versioning, environment, and consistency. virtualenv can only handle a small piece of the python-only part of that. For instance, there's a collection of training data and preprocessing which needs similar solutions: externally managed, place it in directory X, point Y to it, etc. Virtualenv isn't much help there. Same with some low-level instrumentation code which we use. And this is compounded by running on a variety of machines and platforms. So while I'll admit I'm a little biased because I don't much like virtualenv's approach to the world, I'd also really like to avoid adding more complexity in a lot of places just because of idiosyncrasies in the way tensorflow's package is written. (Especially since it was working two weeks ago!)", "body": "Yep. That's the ultimate goal here: place tensorflow in directory X, and point `PYTHONPATH` to it, and write `import tensorflow`, where X is a directory of my choosing. Each one of these examples actually sets `PYTHONPATH` to `TF_INSTALL_DIR` before running, just like you mention. It certainly _seemed_ like it should be that easy. Unfortunately, it seems that either due some combination of the packaging tools and the way the TensorFlow and/or protobuf packages are written, it's not.\n\nI do understand the virtualenv perspective. Without getting into too much of a holy war, virtualenv takes a very different approach to solving the problem, one that is pretty narrow in scope. Part of my hope was that I would only have to have one solution for dealing with versioning, environment, and consistency. virtualenv can only handle a small piece of the python-only part of that. For instance, there's a collection of training data and preprocessing which needs similar solutions: externally managed, place it in directory X, point Y to it, etc. Virtualenv isn't much help there. Same with some low-level instrumentation code which we use. And this is compounded by running on a variety of machines and platforms. So while I'll admit I'm a little biased because I don't much like virtualenv's approach to the world, I'd also really like to avoid adding more complexity in a lot of places just because of idiosyncrasies in the way tensorflow's package is written. (Especially since it was working two weeks ago!)\n"}