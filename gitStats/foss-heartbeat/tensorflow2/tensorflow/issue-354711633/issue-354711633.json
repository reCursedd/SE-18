{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/21922", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/21922/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/21922/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/21922/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/21922", "id": 354711633, "node_id": "MDU6SXNzdWUzNTQ3MTE2MzM=", "number": 21922, "title": "TF_GraphImportGraphDef fails with no input mapping on existing nodes", "user": {"login": "gil-cohen", "id": 34191292, "node_id": "MDQ6VXNlcjM0MTkxMjky", "avatar_url": "https://avatars0.githubusercontent.com/u/34191292?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gil-cohen", "html_url": "https://github.com/gil-cohen", "followers_url": "https://api.github.com/users/gil-cohen/followers", "following_url": "https://api.github.com/users/gil-cohen/following{/other_user}", "gists_url": "https://api.github.com/users/gil-cohen/gists{/gist_id}", "starred_url": "https://api.github.com/users/gil-cohen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gil-cohen/subscriptions", "organizations_url": "https://api.github.com/users/gil-cohen/orgs", "repos_url": "https://api.github.com/users/gil-cohen/repos", "events_url": "https://api.github.com/users/gil-cohen/events{/privacy}", "received_events_url": "https://api.github.com/users/gil-cohen/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 404586594, "node_id": "MDU6TGFiZWw0MDQ1ODY1OTQ=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:awaiting%20tensorflower", "name": "stat:awaiting tensorflower", "color": "f4b400", "default": false}], "state": "open", "locked": false, "assignee": {"login": "skye", "id": 88808, "node_id": "MDQ6VXNlcjg4ODA4", "avatar_url": "https://avatars1.githubusercontent.com/u/88808?v=4", "gravatar_id": "", "url": "https://api.github.com/users/skye", "html_url": "https://github.com/skye", "followers_url": "https://api.github.com/users/skye/followers", "following_url": "https://api.github.com/users/skye/following{/other_user}", "gists_url": "https://api.github.com/users/skye/gists{/gist_id}", "starred_url": "https://api.github.com/users/skye/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/skye/subscriptions", "organizations_url": "https://api.github.com/users/skye/orgs", "repos_url": "https://api.github.com/users/skye/repos", "events_url": "https://api.github.com/users/skye/events{/privacy}", "received_events_url": "https://api.github.com/users/skye/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "skye", "id": 88808, "node_id": "MDQ6VXNlcjg4ODA4", "avatar_url": "https://avatars1.githubusercontent.com/u/88808?v=4", "gravatar_id": "", "url": "https://api.github.com/users/skye", "html_url": "https://github.com/skye", "followers_url": "https://api.github.com/users/skye/followers", "following_url": "https://api.github.com/users/skye/following{/other_user}", "gists_url": "https://api.github.com/users/skye/gists{/gist_id}", "starred_url": "https://api.github.com/users/skye/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/skye/subscriptions", "organizations_url": "https://api.github.com/users/skye/orgs", "repos_url": "https://api.github.com/users/skye/repos", "events_url": "https://api.github.com/users/skye/events{/privacy}", "received_events_url": "https://api.github.com/users/skye/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 1, "created_at": "2018-08-28T12:37:06Z", "updated_at": "2018-11-14T19:26:00Z", "closed_at": null, "author_association": "NONE", "body_html": "<h3>System information</h3>\n<ul>\n<li><strong>Have I written custom code (as opposed to using a stock example script provided in TensorFlow)</strong>: yes</li>\n<li><strong>OS Platform and Distribution (e.g., Linux Ubuntu 16.04)</strong>: linux, ubuntu 16.04</li>\n<li><strong>Mobile device (e.g. iPhone 8, Pixel 2, Samsung Galaxy) if the issue happens on mobile device</strong>: N/A</li>\n<li><strong>TensorFlow installed from (source or binary)</strong>: binary</li>\n<li><strong>TensorFlow version (use command below)</strong>: 1.10</li>\n<li><strong>Python version</strong>:  3.5.2</li>\n<li><strong>Bazel version (if compiling from source)</strong>: N/A</li>\n<li><strong>GCC/Compiler version (if compiling from source)</strong>: N/A</li>\n<li><strong>CUDA/cuDNN version</strong>: N/A</li>\n<li><strong>GPU model and memory</strong>: N/A</li>\n<li><strong>Exact command to reproduce</strong>: N/A</li>\n</ul>\n<h3>Describe the problem</h3>\n<p>Using <code>TF_GraphImportGraphDef</code> to incrementally build a graph (using NodeDefs instead of the extensive <code>TF_OperationDescription* </code> API) returns a <code>TF_Status</code> error code (3) with message  <strong>Unknown input node</strong> when a node currently being imported has an input node who is  not in the current import call, but already in the graph.</p>\n<h3>Source code / logs</h3>\n<p>I would assume that it would be okay to import a node whose inputs are already in the graph.</p>\n<p>If this assumption is correct the problem arises from line 529 In <a href=\"https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/graph/graph_constructor.cc\">graph_constructor.cc</a>:</p>\n<pre><code>for (int i = 0; i &lt; node_def.input_size(); ++i) {\n      StringPiece input_name = node_def.input(i);\n      TensorId id(ParseTensorName(input_name));\n      if (opts_.input_map.count(id) == 0) {\n        // If an input is not mapped, then the input should appear in the graph\n        // being imported.\n        auto iter = gdef_nodes_.find(id.first);\n        if (iter == gdef_nodes_.end()) {\n          return errors::InvalidArgument(\"Node '\", node_def.name(),\n                                         \"': Unknown input node '\",\n                                         node_def.input(i), \"'\");\n        }\n        outputs_[iter-&gt;second.gdef_index].push_back(n);\n      } else {\n        // This input is mapped to an existing edge. Therefore this input is\n        // as good as being already processed.\n        --pending_count;\n        DCHECK_GE(pending_count, 0);\n      }\n    }\n</code></pre>\n<p>Where if no mapping was supplied using <code>TF_ImportGraphDefOptionsAddInputMapping</code>, the validation check assumes the input nodes exist in the current import call, along side the node being imported itself, without bothering to check if the graph might already contain these nodes (which is the assumption when a mapping IS supplied).</p>\n<p>This means that when importing a graph, unnecessary input mappings have to be supplied.</p>", "body_text": "System information\n\nHave I written custom code (as opposed to using a stock example script provided in TensorFlow): yes\nOS Platform and Distribution (e.g., Linux Ubuntu 16.04): linux, ubuntu 16.04\nMobile device (e.g. iPhone 8, Pixel 2, Samsung Galaxy) if the issue happens on mobile device: N/A\nTensorFlow installed from (source or binary): binary\nTensorFlow version (use command below): 1.10\nPython version:  3.5.2\nBazel version (if compiling from source): N/A\nGCC/Compiler version (if compiling from source): N/A\nCUDA/cuDNN version: N/A\nGPU model and memory: N/A\nExact command to reproduce: N/A\n\nDescribe the problem\nUsing TF_GraphImportGraphDef to incrementally build a graph (using NodeDefs instead of the extensive TF_OperationDescription*  API) returns a TF_Status error code (3) with message  Unknown input node when a node currently being imported has an input node who is  not in the current import call, but already in the graph.\nSource code / logs\nI would assume that it would be okay to import a node whose inputs are already in the graph.\nIf this assumption is correct the problem arises from line 529 In graph_constructor.cc:\nfor (int i = 0; i < node_def.input_size(); ++i) {\n      StringPiece input_name = node_def.input(i);\n      TensorId id(ParseTensorName(input_name));\n      if (opts_.input_map.count(id) == 0) {\n        // If an input is not mapped, then the input should appear in the graph\n        // being imported.\n        auto iter = gdef_nodes_.find(id.first);\n        if (iter == gdef_nodes_.end()) {\n          return errors::InvalidArgument(\"Node '\", node_def.name(),\n                                         \"': Unknown input node '\",\n                                         node_def.input(i), \"'\");\n        }\n        outputs_[iter->second.gdef_index].push_back(n);\n      } else {\n        // This input is mapped to an existing edge. Therefore this input is\n        // as good as being already processed.\n        --pending_count;\n        DCHECK_GE(pending_count, 0);\n      }\n    }\n\nWhere if no mapping was supplied using TF_ImportGraphDefOptionsAddInputMapping, the validation check assumes the input nodes exist in the current import call, along side the node being imported itself, without bothering to check if the graph might already contain these nodes (which is the assumption when a mapping IS supplied).\nThis means that when importing a graph, unnecessary input mappings have to be supplied.", "body": "### System information\r\n\r\n- **Have I written custom code (as opposed to using a stock example script provided in TensorFlow)**: yes\r\n- **OS Platform and Distribution (e.g., Linux Ubuntu 16.04)**: linux, ubuntu 16.04\r\n- **Mobile device (e.g. iPhone 8, Pixel 2, Samsung Galaxy) if the issue happens on mobile device**: N/A\r\n- **TensorFlow installed from (source or binary)**: binary\r\n- **TensorFlow version (use command below)**: 1.10\r\n- **Python version**:  3.5.2\r\n- **Bazel version (if compiling from source)**: N/A\r\n- **GCC/Compiler version (if compiling from source)**: N/A\r\n- **CUDA/cuDNN version**: N/A\r\n- **GPU model and memory**: N/A\r\n- **Exact command to reproduce**: N/A\r\n\r\n\r\n### Describe the problem\r\n\r\nUsing `TF_GraphImportGraphDef` to incrementally build a graph (using NodeDefs instead of the extensive `TF_OperationDescription* ` API) returns a `TF_Status` error code (3) with message  **Unknown input node** when a node currently being imported has an input node who is  not in the current import call, but already in the graph.\r\n\r\n\r\n### Source code / logs\r\n\r\nI would assume that it would be okay to import a node whose inputs are already in the graph.\r\n\r\nIf this assumption is correct the problem arises from line 529 In [graph_constructor.cc](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/graph/graph_constructor.cc):\r\n\r\n```\r\nfor (int i = 0; i < node_def.input_size(); ++i) {\r\n      StringPiece input_name = node_def.input(i);\r\n      TensorId id(ParseTensorName(input_name));\r\n      if (opts_.input_map.count(id) == 0) {\r\n        // If an input is not mapped, then the input should appear in the graph\r\n        // being imported.\r\n        auto iter = gdef_nodes_.find(id.first);\r\n        if (iter == gdef_nodes_.end()) {\r\n          return errors::InvalidArgument(\"Node '\", node_def.name(),\r\n                                         \"': Unknown input node '\",\r\n                                         node_def.input(i), \"'\");\r\n        }\r\n        outputs_[iter->second.gdef_index].push_back(n);\r\n      } else {\r\n        // This input is mapped to an existing edge. Therefore this input is\r\n        // as good as being already processed.\r\n        --pending_count;\r\n        DCHECK_GE(pending_count, 0);\r\n      }\r\n    }\r\n```\r\n\r\nWhere if no mapping was supplied using `TF_ImportGraphDefOptionsAddInputMapping`, the validation check assumes the input nodes exist in the current import call, along side the node being imported itself, without bothering to check if the graph might already contain these nodes (which is the assumption when a mapping IS supplied).\r\n\r\nThis means that when importing a graph, unnecessary input mappings have to be supplied.\r\n\r\n"}