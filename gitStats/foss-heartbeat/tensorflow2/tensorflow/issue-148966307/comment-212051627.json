{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/212051627", "html_url": "https://github.com/tensorflow/tensorflow/pull/2002#issuecomment-212051627", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2002", "id": 212051627, "node_id": "MDEyOklzc3VlQ29tbWVudDIxMjA1MTYyNw==", "user": {"login": "wchan", "id": 1131892, "node_id": "MDQ6VXNlcjExMzE4OTI=", "avatar_url": "https://avatars1.githubusercontent.com/u/1131892?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wchan", "html_url": "https://github.com/wchan", "followers_url": "https://api.github.com/users/wchan/followers", "following_url": "https://api.github.com/users/wchan/following{/other_user}", "gists_url": "https://api.github.com/users/wchan/gists{/gist_id}", "starred_url": "https://api.github.com/users/wchan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wchan/subscriptions", "organizations_url": "https://api.github.com/users/wchan/orgs", "repos_url": "https://api.github.com/users/wchan/repos", "events_url": "https://api.github.com/users/wchan/events{/privacy}", "received_events_url": "https://api.github.com/users/wchan/received_events", "type": "User", "site_admin": false}, "created_at": "2016-04-19T18:14:34Z", "updated_at": "2016-04-19T18:14:34Z", "author_association": "NONE", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=463737\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/vrv\">@vrv</a> , <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=577277\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/martinwicke\">@martinwicke</a> warning: i only looked at cuDNN once so i could be wrong, but iirc, cuDNN requires a workspace scratch for the fprop and bprop, meaning u need to allocate memory in the fprop to pass back thru in the backprop:<br>\ncudnnGetRNNWorkspaceSize<br>\nwhich i presume we can just treat it a state.</p>\n<p>however, im not familiar enuf w the TF infrastructure on how to pass the state/scratch back during the backward pass, since we don't know the function behind cudnnGetRNNWorkspaceSize and thus we can't guarantee the python side will know how much memory to allocate for the state_size?</p>", "body_text": "@vrv , @martinwicke warning: i only looked at cuDNN once so i could be wrong, but iirc, cuDNN requires a workspace scratch for the fprop and bprop, meaning u need to allocate memory in the fprop to pass back thru in the backprop:\ncudnnGetRNNWorkspaceSize\nwhich i presume we can just treat it a state.\nhowever, im not familiar enuf w the TF infrastructure on how to pass the state/scratch back during the backward pass, since we don't know the function behind cudnnGetRNNWorkspaceSize and thus we can't guarantee the python side will know how much memory to allocate for the state_size?", "body": "@vrv , @martinwicke warning: i only looked at cuDNN once so i could be wrong, but iirc, cuDNN requires a workspace scratch for the fprop and bprop, meaning u need to allocate memory in the fprop to pass back thru in the backprop:\ncudnnGetRNNWorkspaceSize\nwhich i presume we can just treat it a state.\n\nhowever, im not familiar enuf w the TF infrastructure on how to pass the state/scratch back during the backward pass, since we don't know the function behind cudnnGetRNNWorkspaceSize and thus we can't guarantee the python side will know how much memory to allocate for the state_size?\n"}