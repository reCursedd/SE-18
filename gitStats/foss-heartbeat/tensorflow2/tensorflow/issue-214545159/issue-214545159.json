{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8448", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8448/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8448/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8448/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/8448", "id": 214545159, "node_id": "MDU6SXNzdWUyMTQ1NDUxNTk=", "number": 8448, "title": "For loop over 'NoneType' TensorFlow Dimensions", "user": {"login": "cmertin", "id": 4504364, "node_id": "MDQ6VXNlcjQ1MDQzNjQ=", "avatar_url": "https://avatars3.githubusercontent.com/u/4504364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cmertin", "html_url": "https://github.com/cmertin", "followers_url": "https://api.github.com/users/cmertin/followers", "following_url": "https://api.github.com/users/cmertin/following{/other_user}", "gists_url": "https://api.github.com/users/cmertin/gists{/gist_id}", "starred_url": "https://api.github.com/users/cmertin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cmertin/subscriptions", "organizations_url": "https://api.github.com/users/cmertin/orgs", "repos_url": "https://api.github.com/users/cmertin/repos", "events_url": "https://api.github.com/users/cmertin/events{/privacy}", "received_events_url": "https://api.github.com/users/cmertin/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 386191887, "node_id": "MDU6TGFiZWwzODYxOTE4ODc=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:awaiting%20response", "name": "stat:awaiting response", "color": "f4b400", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 15, "created_at": "2017-03-15T22:27:08Z", "updated_at": "2018-11-13T16:07:02Z", "closed_at": "2017-06-16T20:32:57Z", "author_association": "NONE", "body_html": "<p>I'm implementing a new type of NN in TensorFlow. The difference is in the evaluation function, so instead of calling <code>tf.matmul()</code>, I call my own function, which we'll call <code>My_Function(A)</code>.</p>\n<p>A snippet of the code can be seen below, where <code>A</code> is the tensor on the left being multiplied by this new NN implementation, which is on the right. The equivalent tensorflow code would be <code>tf.matmul(A, this_new_NN)</code>.</p>\n<pre><code>def My_Function(self, A):\n    dims = A.get_shape().as_list()\n    shape = [dims[0], self.m] # Defining shape of resulting tensor\n    X = tf.placeholder(tf.float32, shape=[shape[0], shape[1]])\n    result = tf.zeros(tf.shape(X), dtype=tf.float32)\n    for xyz in self.property:\n        # Do some computation between A and xyz, xyz is a property of this_new_NN\n        # resulting to temp_H with dimension [shape[0], xyz.m] of type tf.tensor\n        dims_H = temp_H.get_shape().as_list()\n        indices = [[i,j] for i in range(0, dims_H[0]) for j in range(xyz.k, xyz.k+dims_H[1])]\n        # indices is a list of indices to update in \"result\"\n        values = tf.reshape(temp_H, [-1]) # Values in temp_H as 1D list\n        delta = tf.SparseTensor(indices, values, shape)\n        result += tf.sparse_tensor_to_dense(delta)\n    return result\n</code></pre>\n<p>Now the problem I'm having is in the line where I calculate the <code>indices</code>, where I'm getting the error</p>\n<p><code>TypeError: 'NoneType' object cannot be interpreted as an integer</code></p>\n<p>Now, I understand that this error means that you cannot iterate a for loop over a type of <code>None</code>, but the problem I have is the test set and the training set have different values for <code>batch_size</code>. This means that when I go to create <code>result</code>, the first dimension is unknown which is why it is of type <code>None</code>.</p>\n<p>But, to get the indices that I have to update in <code>result</code>, I have to use a for loop to generate those values as a list to feed into <code>delta</code> which I'm creating as a <code>tf.SparseTensor</code> so it can be added to <code>result</code>.</p>\n<p>My question is, what is the best way to get the indices? I have tried replacing <code>dims_H[0]</code> in the for loop with a <code>tf.placeholder(tf.int32)</code> object instead, where I would then just pass the size when I run the session, but I get the error of</p>\n<p><code>TypeError: 'Tensor' object cannot be interpreted as an integer</code></p>\n<p>Any help would be greatly appreciated.</p>\n<p>Edit:</p>\n<p>Just for reference, this code is called in the following way, where <code>M</code> is the pre-built new NN composed with <code>tf.Variable</code> values.</p>\n<p><code>Y1 = tf.nn.relu(M.My_Function(A) + B1)</code></p>\n<p>where <code>B1</code> is the offset for this layer, and <code>A</code> is the input layer.</p>\n<p>Edit2:</p>\n<p><code>result</code> should be a zero tensor <em>every time</em> <code>My_Function</code> is called. However, I have a suspicion that it is preserving the values of <code>result</code> with each function call. If this is right, please let me know what I need to do to change that.</p>\n<p>Edit3:</p>\n<p>When defining <code>A</code> it is defined as</p>\n<pre><code>X1 = tf.placeholder(tf.float32, [None, 28, 28, 1])\nA = tf.reshape(X1, [-1, 28*28])\n</code></pre>\n<p>As the dimensions of <code>A</code> change between the training data and test data.</p>", "body_text": "I'm implementing a new type of NN in TensorFlow. The difference is in the evaluation function, so instead of calling tf.matmul(), I call my own function, which we'll call My_Function(A).\nA snippet of the code can be seen below, where A is the tensor on the left being multiplied by this new NN implementation, which is on the right. The equivalent tensorflow code would be tf.matmul(A, this_new_NN).\ndef My_Function(self, A):\n    dims = A.get_shape().as_list()\n    shape = [dims[0], self.m] # Defining shape of resulting tensor\n    X = tf.placeholder(tf.float32, shape=[shape[0], shape[1]])\n    result = tf.zeros(tf.shape(X), dtype=tf.float32)\n    for xyz in self.property:\n        # Do some computation between A and xyz, xyz is a property of this_new_NN\n        # resulting to temp_H with dimension [shape[0], xyz.m] of type tf.tensor\n        dims_H = temp_H.get_shape().as_list()\n        indices = [[i,j] for i in range(0, dims_H[0]) for j in range(xyz.k, xyz.k+dims_H[1])]\n        # indices is a list of indices to update in \"result\"\n        values = tf.reshape(temp_H, [-1]) # Values in temp_H as 1D list\n        delta = tf.SparseTensor(indices, values, shape)\n        result += tf.sparse_tensor_to_dense(delta)\n    return result\n\nNow the problem I'm having is in the line where I calculate the indices, where I'm getting the error\nTypeError: 'NoneType' object cannot be interpreted as an integer\nNow, I understand that this error means that you cannot iterate a for loop over a type of None, but the problem I have is the test set and the training set have different values for batch_size. This means that when I go to create result, the first dimension is unknown which is why it is of type None.\nBut, to get the indices that I have to update in result, I have to use a for loop to generate those values as a list to feed into delta which I'm creating as a tf.SparseTensor so it can be added to result.\nMy question is, what is the best way to get the indices? I have tried replacing dims_H[0] in the for loop with a tf.placeholder(tf.int32) object instead, where I would then just pass the size when I run the session, but I get the error of\nTypeError: 'Tensor' object cannot be interpreted as an integer\nAny help would be greatly appreciated.\nEdit:\nJust for reference, this code is called in the following way, where M is the pre-built new NN composed with tf.Variable values.\nY1 = tf.nn.relu(M.My_Function(A) + B1)\nwhere B1 is the offset for this layer, and A is the input layer.\nEdit2:\nresult should be a zero tensor every time My_Function is called. However, I have a suspicion that it is preserving the values of result with each function call. If this is right, please let me know what I need to do to change that.\nEdit3:\nWhen defining A it is defined as\nX1 = tf.placeholder(tf.float32, [None, 28, 28, 1])\nA = tf.reshape(X1, [-1, 28*28])\n\nAs the dimensions of A change between the training data and test data.", "body": "I'm implementing a new type of NN in TensorFlow. The difference is in the evaluation function, so instead of calling `tf.matmul()`, I call my own function, which we'll call `My_Function(A)`.\r\n\r\nA snippet of the code can be seen below, where `A` is the tensor on the left being multiplied by this new NN implementation, which is on the right. The equivalent tensorflow code would be `tf.matmul(A, this_new_NN)`.\r\n\r\n    def My_Function(self, A):\r\n        dims = A.get_shape().as_list()\r\n        shape = [dims[0], self.m] # Defining shape of resulting tensor\r\n        X = tf.placeholder(tf.float32, shape=[shape[0], shape[1]])\r\n        result = tf.zeros(tf.shape(X), dtype=tf.float32)\r\n        for xyz in self.property:\r\n            # Do some computation between A and xyz, xyz is a property of this_new_NN\r\n            # resulting to temp_H with dimension [shape[0], xyz.m] of type tf.tensor\r\n            dims_H = temp_H.get_shape().as_list()\r\n            indices = [[i,j] for i in range(0, dims_H[0]) for j in range(xyz.k, xyz.k+dims_H[1])]\r\n            # indices is a list of indices to update in \"result\"\r\n            values = tf.reshape(temp_H, [-1]) # Values in temp_H as 1D list\r\n            delta = tf.SparseTensor(indices, values, shape)\r\n            result += tf.sparse_tensor_to_dense(delta)\r\n        return result\r\n\r\nNow the problem I'm having is in the line where I calculate the `indices`, where I'm getting the error\r\n\r\n`TypeError: 'NoneType' object cannot be interpreted as an integer`\r\n\r\nNow, I understand that this error means that you cannot iterate a for loop over a type of `None`, but the problem I have is the test set and the training set have different values for `batch_size`. This means that when I go to create `result`, the first dimension is unknown which is why it is of type `None`. \r\n\r\nBut, to get the indices that I have to update in `result`, I have to use a for loop to generate those values as a list to feed into `delta` which I'm creating as a `tf.SparseTensor` so it can be added to `result`. \r\n\r\nMy question is, what is the best way to get the indices? I have tried replacing `dims_H[0]` in the for loop with a `tf.placeholder(tf.int32)` object instead, where I would then just pass the size when I run the session, but I get the error of\r\n\r\n`TypeError: 'Tensor' object cannot be interpreted as an integer`\r\n\r\nAny help would be greatly appreciated.\r\n\r\nEdit:\r\n\r\nJust for reference, this code is called in the following way, where `M` is the pre-built new NN composed with `tf.Variable` values.\r\n\r\n`Y1 = tf.nn.relu(M.My_Function(A) + B1)`\r\n\r\nwhere `B1` is the offset for this layer, and `A` is the input layer.\r\n\r\nEdit2:\r\n\r\n`result` should be a zero tensor *every time* `My_Function` is called. However, I have a suspicion that it is preserving the values of `result` with each function call. If this is right, please let me know what I need to do to change that.\r\n\r\nEdit3:\r\n\r\nWhen defining `A` it is defined as\r\n\r\n    X1 = tf.placeholder(tf.float32, [None, 28, 28, 1])\r\n    A = tf.reshape(X1, [-1, 28*28])\r\n\r\nAs the dimensions of `A` change between the training data and test data."}