{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/416529135", "html_url": "https://github.com/tensorflow/tensorflow/issues/3270#issuecomment-416529135", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/3270", "id": 416529135, "node_id": "MDEyOklzc3VlQ29tbWVudDQxNjUyOTEzNQ==", "user": {"login": "Raj-08", "id": 15856029, "node_id": "MDQ6VXNlcjE1ODU2MDI5", "avatar_url": "https://avatars3.githubusercontent.com/u/15856029?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Raj-08", "html_url": "https://github.com/Raj-08", "followers_url": "https://api.github.com/users/Raj-08/followers", "following_url": "https://api.github.com/users/Raj-08/following{/other_user}", "gists_url": "https://api.github.com/users/Raj-08/gists{/gist_id}", "starred_url": "https://api.github.com/users/Raj-08/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Raj-08/subscriptions", "organizations_url": "https://api.github.com/users/Raj-08/orgs", "repos_url": "https://api.github.com/users/Raj-08/repos", "events_url": "https://api.github.com/users/Raj-08/events{/privacy}", "received_events_url": "https://api.github.com/users/Raj-08/received_events", "type": "User", "site_admin": false}, "created_at": "2018-08-28T10:13:16Z", "updated_at": "2018-08-28T10:13:16Z", "author_association": "NONE", "body_html": "<p>`  with tf.Graph().as_default():</p>\n<pre><code>C = tf.constant([0],shape=[30,30,1])\n\nD = tf.constant([0],shape=[40,40,1])\ninput_image = tf.placeholder(tf.uint8, [1, None, None, 3], name=_INPUT_NAME)\nimage_size = tf.shape(input_image)[1:3]\nimage = tf.squeeze(input_image, axis=0)\nimage = tf.expand_dims(image, 0)\nmodel_options = common.ModelOptions(\n    outputs_to_num_classes={common.OUTPUT_TYPE: FLAGS.num_classes},\n    crop_size=[481,481],\n    atrous_rates=FLAGS.atrous_rates,\n    output_stride=FLAGS.output_stride)\nwith tf.variable_scope('segmentation'):\n    if tuple(FLAGS.inference_scales) == (1.0,):\n      tf.logging.info('Exported model performs single-scale inference.')\n      predictions = model_deeplab.predict_labels(\n          image,\n          model_options=model_options,\n          image_pyramid=FLAGS.image_pyramid)\n    else:\n      tf.logging.info('Exported model performs multi-scale inference.')\n      predictions = model_deeplab.predict_labels_multi_scale(\n          image,\n          model_options=model_options,\n          eval_scales=FLAGS.inference_scales,\n          add_flipped_images=FLAGS.add_flipped_images)\n\n\n    predictions = predictions['semantic']\n\n    logits_deeplab = tf.scalar_mul(255,predictions)\n    logits_deeplab = tf.squeeze(logits_deeplab)\n    logits_deeplab = tf.expand_dims(logits_deeplab, axis=0)\n    logits_deeplab = tf.expand_dims(logits_deeplab, axis=3)\n    eroded = tf.nn.erosion2d(tf.cast(logits_deeplab,dtype=tf.int32),C,[1,1,1,1],[1,1,1,1],'SAME')\n\n    dilated = tf.nn.dilation2d(tf.cast(logits_deeplab,dtype=tf.int32),D,[1,1,1,1],[1,1,1,1],'SAME')\n\n\n\n    dilated =  tf.where(tf.equal(dilated,255),tf.fill([1,481,481,1],127),dilated)\n\n    trimap =  tf.where(tf.equal(eroded,255),tf.fill([1,481,481,1],255),dilated)\n    trimap_inp = tf.concat([tf.cast(image,dtype=tf.float32),tf.cast(trimap,dtype=tf.float32)],axis=3,name='new')\n    model_options = common.ModelOptions(\n    outputs_to_num_classes={common.OUTPUT_TYPE: 64},\n    crop_size=[481,481],\n    atrous_rates=[12,24,36],\n    output_stride=FLAGS.output_stride)\nmod_vars = tf.model_variables()\nprint('l1',len(mod_vars))\nwith tf.variable_scope('matting'):\n    logits= model.multi_scale_logits(\n          trimap_inp,\n          model_options=model_options,\n          image_pyramid = [1.0])\n    \n    mod_vars = tf.model_variables()\n    print('l2',len(mod_vars))\n    all_trainables = tf.trainable_variables()\n    logits=logits['semantic']\n    logits_p=logits['merged_logits_matting'] \n    upsample_logits=True\n    logits_p=upsample_layer(logits_p,64,'up_matting',upscale_factor=4)\n    print('LP',logits_p)\n    logits_p = create_new_conv_layer(logits_p,64,1,'pred')\n    deeplab_op_255 = tf.scalar_mul(255.0,logits_p)\n    concat_inp = tf.concat([tf.cast(image,dtype=tf.float32),deeplab_op_255],axis=3)\n    conv1 = create_new_conv_layer(concat_inp,4,64,'conv1')\n    conv2 = create_new_conv_layer(conv1,64,64,'conv2')\n    conv3 = create_new_conv_layer(conv2,64,64,'conv3')\n    logits_al = create_new_conv_layer(conv3,64,1,'pred1')\n    logits_al = tf.nn.sigmoid(logits_al)\nvariables_to_restore = tf.get_collection(\n        tf.GraphKeys.MODEL_VARIABLES)\nprint(len(variables_to_restore))\n\nloc_varlist = {v.name[13:][:-2]: v \n                    for v in variables_to_restore if v.name[:12]=='segmentation'}\nrec_varlist = {v.name[8:][:-2]: v \n                    for v in variables_to_restore if v.name[:7]=='matting'}\nprint('L1',len(loc_varlist))\nprint('L2',len(rec_varlist))\nf = open('/home/ubuntu/all_data_seg/train_mat_25_08.txt')\nmessage = f.read()\nlines = message.split('\\n')\n\nsaver_restore_1 = tf.train.Saver(loc_varlist)   \nsaver_restore_2 = tf.train.Saver(rec_varlist)`\n</code></pre>", "body_text": "`  with tf.Graph().as_default():\nC = tf.constant([0],shape=[30,30,1])\n\nD = tf.constant([0],shape=[40,40,1])\ninput_image = tf.placeholder(tf.uint8, [1, None, None, 3], name=_INPUT_NAME)\nimage_size = tf.shape(input_image)[1:3]\nimage = tf.squeeze(input_image, axis=0)\nimage = tf.expand_dims(image, 0)\nmodel_options = common.ModelOptions(\n    outputs_to_num_classes={common.OUTPUT_TYPE: FLAGS.num_classes},\n    crop_size=[481,481],\n    atrous_rates=FLAGS.atrous_rates,\n    output_stride=FLAGS.output_stride)\nwith tf.variable_scope('segmentation'):\n    if tuple(FLAGS.inference_scales) == (1.0,):\n      tf.logging.info('Exported model performs single-scale inference.')\n      predictions = model_deeplab.predict_labels(\n          image,\n          model_options=model_options,\n          image_pyramid=FLAGS.image_pyramid)\n    else:\n      tf.logging.info('Exported model performs multi-scale inference.')\n      predictions = model_deeplab.predict_labels_multi_scale(\n          image,\n          model_options=model_options,\n          eval_scales=FLAGS.inference_scales,\n          add_flipped_images=FLAGS.add_flipped_images)\n\n\n    predictions = predictions['semantic']\n\n    logits_deeplab = tf.scalar_mul(255,predictions)\n    logits_deeplab = tf.squeeze(logits_deeplab)\n    logits_deeplab = tf.expand_dims(logits_deeplab, axis=0)\n    logits_deeplab = tf.expand_dims(logits_deeplab, axis=3)\n    eroded = tf.nn.erosion2d(tf.cast(logits_deeplab,dtype=tf.int32),C,[1,1,1,1],[1,1,1,1],'SAME')\n\n    dilated = tf.nn.dilation2d(tf.cast(logits_deeplab,dtype=tf.int32),D,[1,1,1,1],[1,1,1,1],'SAME')\n\n\n\n    dilated =  tf.where(tf.equal(dilated,255),tf.fill([1,481,481,1],127),dilated)\n\n    trimap =  tf.where(tf.equal(eroded,255),tf.fill([1,481,481,1],255),dilated)\n    trimap_inp = tf.concat([tf.cast(image,dtype=tf.float32),tf.cast(trimap,dtype=tf.float32)],axis=3,name='new')\n    model_options = common.ModelOptions(\n    outputs_to_num_classes={common.OUTPUT_TYPE: 64},\n    crop_size=[481,481],\n    atrous_rates=[12,24,36],\n    output_stride=FLAGS.output_stride)\nmod_vars = tf.model_variables()\nprint('l1',len(mod_vars))\nwith tf.variable_scope('matting'):\n    logits= model.multi_scale_logits(\n          trimap_inp,\n          model_options=model_options,\n          image_pyramid = [1.0])\n    \n    mod_vars = tf.model_variables()\n    print('l2',len(mod_vars))\n    all_trainables = tf.trainable_variables()\n    logits=logits['semantic']\n    logits_p=logits['merged_logits_matting'] \n    upsample_logits=True\n    logits_p=upsample_layer(logits_p,64,'up_matting',upscale_factor=4)\n    print('LP',logits_p)\n    logits_p = create_new_conv_layer(logits_p,64,1,'pred')\n    deeplab_op_255 = tf.scalar_mul(255.0,logits_p)\n    concat_inp = tf.concat([tf.cast(image,dtype=tf.float32),deeplab_op_255],axis=3)\n    conv1 = create_new_conv_layer(concat_inp,4,64,'conv1')\n    conv2 = create_new_conv_layer(conv1,64,64,'conv2')\n    conv3 = create_new_conv_layer(conv2,64,64,'conv3')\n    logits_al = create_new_conv_layer(conv3,64,1,'pred1')\n    logits_al = tf.nn.sigmoid(logits_al)\nvariables_to_restore = tf.get_collection(\n        tf.GraphKeys.MODEL_VARIABLES)\nprint(len(variables_to_restore))\n\nloc_varlist = {v.name[13:][:-2]: v \n                    for v in variables_to_restore if v.name[:12]=='segmentation'}\nrec_varlist = {v.name[8:][:-2]: v \n                    for v in variables_to_restore if v.name[:7]=='matting'}\nprint('L1',len(loc_varlist))\nprint('L2',len(rec_varlist))\nf = open('/home/ubuntu/all_data_seg/train_mat_25_08.txt')\nmessage = f.read()\nlines = message.split('\\n')\n\nsaver_restore_1 = tf.train.Saver(loc_varlist)   \nsaver_restore_2 = tf.train.Saver(rec_varlist)`", "body": "`  with tf.Graph().as_default():\r\n\r\n    C = tf.constant([0],shape=[30,30,1])\r\n\r\n    D = tf.constant([0],shape=[40,40,1])\r\n    input_image = tf.placeholder(tf.uint8, [1, None, None, 3], name=_INPUT_NAME)\r\n    image_size = tf.shape(input_image)[1:3]\r\n    image = tf.squeeze(input_image, axis=0)\r\n    image = tf.expand_dims(image, 0)\r\n    model_options = common.ModelOptions(\r\n        outputs_to_num_classes={common.OUTPUT_TYPE: FLAGS.num_classes},\r\n        crop_size=[481,481],\r\n        atrous_rates=FLAGS.atrous_rates,\r\n        output_stride=FLAGS.output_stride)\r\n    with tf.variable_scope('segmentation'):\r\n        if tuple(FLAGS.inference_scales) == (1.0,):\r\n          tf.logging.info('Exported model performs single-scale inference.')\r\n          predictions = model_deeplab.predict_labels(\r\n              image,\r\n              model_options=model_options,\r\n              image_pyramid=FLAGS.image_pyramid)\r\n        else:\r\n          tf.logging.info('Exported model performs multi-scale inference.')\r\n          predictions = model_deeplab.predict_labels_multi_scale(\r\n              image,\r\n              model_options=model_options,\r\n              eval_scales=FLAGS.inference_scales,\r\n              add_flipped_images=FLAGS.add_flipped_images)\r\n   \r\n    \r\n        predictions = predictions['semantic']\r\n\r\n        logits_deeplab = tf.scalar_mul(255,predictions)\r\n        logits_deeplab = tf.squeeze(logits_deeplab)\r\n        logits_deeplab = tf.expand_dims(logits_deeplab, axis=0)\r\n        logits_deeplab = tf.expand_dims(logits_deeplab, axis=3)\r\n        eroded = tf.nn.erosion2d(tf.cast(logits_deeplab,dtype=tf.int32),C,[1,1,1,1],[1,1,1,1],'SAME')\r\n\r\n        dilated = tf.nn.dilation2d(tf.cast(logits_deeplab,dtype=tf.int32),D,[1,1,1,1],[1,1,1,1],'SAME')\r\n\r\n\r\n\r\n        dilated =  tf.where(tf.equal(dilated,255),tf.fill([1,481,481,1],127),dilated)\r\n\r\n        trimap =  tf.where(tf.equal(eroded,255),tf.fill([1,481,481,1],255),dilated)\r\n        trimap_inp = tf.concat([tf.cast(image,dtype=tf.float32),tf.cast(trimap,dtype=tf.float32)],axis=3,name='new')\r\n        model_options = common.ModelOptions(\r\n        outputs_to_num_classes={common.OUTPUT_TYPE: 64},\r\n        crop_size=[481,481],\r\n        atrous_rates=[12,24,36],\r\n        output_stride=FLAGS.output_stride)\r\n    mod_vars = tf.model_variables()\r\n    print('l1',len(mod_vars))\r\n    with tf.variable_scope('matting'):\r\n        logits= model.multi_scale_logits(\r\n              trimap_inp,\r\n              model_options=model_options,\r\n              image_pyramid = [1.0])\r\n        \r\n        mod_vars = tf.model_variables()\r\n        print('l2',len(mod_vars))\r\n        all_trainables = tf.trainable_variables()\r\n        logits=logits['semantic']\r\n        logits_p=logits['merged_logits_matting'] \r\n        upsample_logits=True\r\n        logits_p=upsample_layer(logits_p,64,'up_matting',upscale_factor=4)\r\n        print('LP',logits_p)\r\n        logits_p = create_new_conv_layer(logits_p,64,1,'pred')\r\n        deeplab_op_255 = tf.scalar_mul(255.0,logits_p)\r\n        concat_inp = tf.concat([tf.cast(image,dtype=tf.float32),deeplab_op_255],axis=3)\r\n        conv1 = create_new_conv_layer(concat_inp,4,64,'conv1')\r\n        conv2 = create_new_conv_layer(conv1,64,64,'conv2')\r\n        conv3 = create_new_conv_layer(conv2,64,64,'conv3')\r\n        logits_al = create_new_conv_layer(conv3,64,1,'pred1')\r\n        logits_al = tf.nn.sigmoid(logits_al)\r\n    variables_to_restore = tf.get_collection(\r\n            tf.GraphKeys.MODEL_VARIABLES)\r\n    print(len(variables_to_restore))\r\n\r\n    loc_varlist = {v.name[13:][:-2]: v \r\n                        for v in variables_to_restore if v.name[:12]=='segmentation'}\r\n    rec_varlist = {v.name[8:][:-2]: v \r\n                        for v in variables_to_restore if v.name[:7]=='matting'}\r\n    print('L1',len(loc_varlist))\r\n    print('L2',len(rec_varlist))\r\n    f = open('/home/ubuntu/all_data_seg/train_mat_25_08.txt')\r\n    message = f.read()\r\n    lines = message.split('\\n')\r\n\r\n    saver_restore_1 = tf.train.Saver(loc_varlist)   \r\n    saver_restore_2 = tf.train.Saver(rec_varlist)`"}