{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/336196542", "html_url": "https://github.com/tensorflow/tensorflow/issues/13616#issuecomment-336196542", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13616", "id": 336196542, "node_id": "MDEyOklzc3VlQ29tbWVudDMzNjE5NjU0Mg==", "user": {"login": "ebrevdo", "id": 1794715, "node_id": "MDQ6VXNlcjE3OTQ3MTU=", "avatar_url": "https://avatars0.githubusercontent.com/u/1794715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebrevdo", "html_url": "https://github.com/ebrevdo", "followers_url": "https://api.github.com/users/ebrevdo/followers", "following_url": "https://api.github.com/users/ebrevdo/following{/other_user}", "gists_url": "https://api.github.com/users/ebrevdo/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebrevdo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebrevdo/subscriptions", "organizations_url": "https://api.github.com/users/ebrevdo/orgs", "repos_url": "https://api.github.com/users/ebrevdo/repos", "events_url": "https://api.github.com/users/ebrevdo/events{/privacy}", "received_events_url": "https://api.github.com/users/ebrevdo/received_events", "type": "User", "site_admin": false}, "created_at": "2017-10-12T16:47:32Z", "updated_at": "2017-10-12T16:47:32Z", "author_association": "CONTRIBUTOR", "body_html": "<p>After playing with this for a bit, I reached two conclusions:</p>\n<ol>\n<li><code>ResourceVariable</code> has the same problem as <code>Variable</code>.</li>\n<li><code>Variable.ref</code> has been hidden from view; but you can access it using a hidden API (wherein your code will break in the future) via <code>Variable._ref()</code> or <code>Variable._variable</code>.</li>\n</ol>\n<p>Here's code that does what I think you want it to do:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">def</span> <span class=\"pl-en\">cond</span>(<span class=\"pl-smi\">i</span>, <span class=\"pl-smi\">_x</span>, <span class=\"pl-smi\">_sq</span>):\n  <span class=\"pl-k\">return</span> i <span class=\"pl-k\">&lt;</span> <span class=\"pl-c1\">5</span>\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">gen_body</span>(<span class=\"pl-smi\">v</span>):\n  <span class=\"pl-k\">def</span> <span class=\"pl-en\">body</span>(<span class=\"pl-smi\">i</span>, <span class=\"pl-smi\">x</span>, <span class=\"pl-smi\">sq</span>):\n    x <span class=\"pl-k\">=</span> tf.Print(x, [x, sq], <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>x and sq: <span class=\"pl-pds\">\"</span></span>)\n    <span class=\"pl-k\">with</span> tf.control_dependencies([v.assign(x <span class=\"pl-k\">+</span> <span class=\"pl-c1\">1</span>)]):\n      v_assign <span class=\"pl-k\">=</span> v._ref()\n    v_assign <span class=\"pl-k\">=</span> tf.Print(v_assign, [v_assign], <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>v_assign: <span class=\"pl-pds\">\"</span></span>)\n    <span class=\"pl-k\">with</span> tf.control_dependencies([v_assign]):\n      sq_neg <span class=\"pl-k\">=</span> tf.negative(sq)\n      sq_neg <span class=\"pl-k\">=</span> tf.Print(sq_neg, [i, sq_neg], <span class=\"pl-v\">message</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>i and sq_neg:<span class=\"pl-pds\">'</span></span>)\n      <span class=\"pl-k\">return</span> tf.add(i, <span class=\"pl-c1\">1</span>), sq_neg, sq\n  <span class=\"pl-k\">return</span> body\n\nsess <span class=\"pl-k\">=</span> tf.InteractiveSession()\n\n\ni <span class=\"pl-k\">=</span> tf.get_variable(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>i<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-v\">initializer</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">0</span>)\nv <span class=\"pl-k\">=</span> tf.get_variable(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>v<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-v\">initializer</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">2</span>)\nsq <span class=\"pl-k\">=</span> tf.square(v)\nl <span class=\"pl-k\">=</span> tf.while_loop(cond, gen_body(v), (i, v, sq))\nsess.run(tf.global_variables_initializer())\nsess.run((l, v))</pre></div>\n<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=5061\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/alextp\">@alextp</a> any suggestions on how one would force accessing the updated value of a <code>ResourceVariable</code> within a calculation?  This has implications not only for while loops but also other distributed computations where one wants to access a new value from another machine after waiting for a bit.</p>", "body_text": "After playing with this for a bit, I reached two conclusions:\n\nResourceVariable has the same problem as Variable.\nVariable.ref has been hidden from view; but you can access it using a hidden API (wherein your code will break in the future) via Variable._ref() or Variable._variable.\n\nHere's code that does what I think you want it to do:\ndef cond(i, _x, _sq):\n  return i < 5\n\ndef gen_body(v):\n  def body(i, x, sq):\n    x = tf.Print(x, [x, sq], \"x and sq: \")\n    with tf.control_dependencies([v.assign(x + 1)]):\n      v_assign = v._ref()\n    v_assign = tf.Print(v_assign, [v_assign], \"v_assign: \")\n    with tf.control_dependencies([v_assign]):\n      sq_neg = tf.negative(sq)\n      sq_neg = tf.Print(sq_neg, [i, sq_neg], message='i and sq_neg:')\n      return tf.add(i, 1), sq_neg, sq\n  return body\n\nsess = tf.InteractiveSession()\n\n\ni = tf.get_variable(\"i\", initializer=0)\nv = tf.get_variable(\"v\", initializer=2)\nsq = tf.square(v)\nl = tf.while_loop(cond, gen_body(v), (i, v, sq))\nsess.run(tf.global_variables_initializer())\nsess.run((l, v))\n@alextp any suggestions on how one would force accessing the updated value of a ResourceVariable within a calculation?  This has implications not only for while loops but also other distributed computations where one wants to access a new value from another machine after waiting for a bit.", "body": "After playing with this for a bit, I reached two conclusions:\r\n\r\n1. `ResourceVariable` has the same problem as `Variable`.\r\n2. `Variable.ref` has been hidden from view; but you can access it using a hidden API (wherein your code will break in the future) via `Variable._ref()` or `Variable._variable`.\r\n\r\nHere's code that does what I think you want it to do:\r\n\r\n```python\r\ndef cond(i, _x, _sq):\r\n  return i < 5\r\n\r\ndef gen_body(v):\r\n  def body(i, x, sq):\r\n    x = tf.Print(x, [x, sq], \"x and sq: \")\r\n    with tf.control_dependencies([v.assign(x + 1)]):\r\n      v_assign = v._ref()\r\n    v_assign = tf.Print(v_assign, [v_assign], \"v_assign: \")\r\n    with tf.control_dependencies([v_assign]):\r\n      sq_neg = tf.negative(sq)\r\n      sq_neg = tf.Print(sq_neg, [i, sq_neg], message='i and sq_neg:')\r\n      return tf.add(i, 1), sq_neg, sq\r\n  return body\r\n\r\nsess = tf.InteractiveSession()\r\n\r\n\r\ni = tf.get_variable(\"i\", initializer=0)\r\nv = tf.get_variable(\"v\", initializer=2)\r\nsq = tf.square(v)\r\nl = tf.while_loop(cond, gen_body(v), (i, v, sq))\r\nsess.run(tf.global_variables_initializer())\r\nsess.run((l, v))\r\n```\r\n\r\n@alextp any suggestions on how one would force accessing the updated value of a `ResourceVariable` within a calculation?  This has implications not only for while loops but also other distributed computations where one wants to access a new value from another machine after waiting for a bit."}