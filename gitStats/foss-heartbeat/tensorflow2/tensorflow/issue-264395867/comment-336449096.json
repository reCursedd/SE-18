{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/336449096", "html_url": "https://github.com/tensorflow/tensorflow/issues/13616#issuecomment-336449096", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13616", "id": 336449096, "node_id": "MDEyOklzc3VlQ29tbWVudDMzNjQ0OTA5Ng==", "user": {"login": "alextp", "id": 5061, "node_id": "MDQ6VXNlcjUwNjE=", "avatar_url": "https://avatars0.githubusercontent.com/u/5061?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alextp", "html_url": "https://github.com/alextp", "followers_url": "https://api.github.com/users/alextp/followers", "following_url": "https://api.github.com/users/alextp/following{/other_user}", "gists_url": "https://api.github.com/users/alextp/gists{/gist_id}", "starred_url": "https://api.github.com/users/alextp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alextp/subscriptions", "organizations_url": "https://api.github.com/users/alextp/orgs", "repos_url": "https://api.github.com/users/alextp/repos", "events_url": "https://api.github.com/users/alextp/events{/privacy}", "received_events_url": "https://api.github.com/users/alextp/received_events", "type": "User", "site_admin": false}, "created_at": "2017-10-13T13:15:05Z", "updated_at": "2017-10-13T13:15:05Z", "author_association": "MEMBER", "body_html": "<p>Right. If you want the function to be computed inside the while loop you need to call it inside the while loop. Something like</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">def</span> <span class=\"pl-en\">cond</span>(<span class=\"pl-smi\">i</span>, <span class=\"pl-smi\">_x_prev</span>, <span class=\"pl-smi\">_f_prev</span>):\n  <span class=\"pl-k\">return</span> i <span class=\"pl-k\">&lt;</span> <span class=\"pl-c1\">3</span>\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">gen_body</span>(<span class=\"pl-smi\">x</span>, <span class=\"pl-smi\">f</span>):\n  <span class=\"pl-k\">def</span> <span class=\"pl-en\">body</span>(<span class=\"pl-smi\">i</span>, <span class=\"pl-smi\">_x_prev</span>, <span class=\"pl-smi\">_f_prev</span>):\n    x_assign <span class=\"pl-k\">=</span> x.assign(x <span class=\"pl-k\">+</span> <span class=\"pl-c1\">1</span>)\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> with tf.control_dependencies([x.assign(x + 1)]):</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span>   x_assign = x._ref()</span>\n    <span class=\"pl-k\">with</span> tf.control_dependencies([x_assign]):\n      f_neg <span class=\"pl-k\">=</span> tf.negative(f(x_assign))\n      i <span class=\"pl-k\">=</span> tf.add(i, <span class=\"pl-c1\">1</span>)\n      i <span class=\"pl-k\">=</span> tf.Print(i, [i], <span class=\"pl-v\">message</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>&gt;&gt;&gt; Iteration <span class=\"pl-pds\">'</span></span>)\n      i <span class=\"pl-k\">=</span> tf.Print(i, [x], <span class=\"pl-v\">message</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>x = <span class=\"pl-pds\">'</span></span>)\n      i <span class=\"pl-k\">=</span> tf.Print(i, [f(x_assign)], <span class=\"pl-v\">message</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>x_assign = <span class=\"pl-pds\">'</span></span>)\n      i <span class=\"pl-k\">=</span> tf.Print(i, [f(v)], <span class=\"pl-v\">message</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>f = <span class=\"pl-pds\">'</span></span>)\n      i <span class=\"pl-k\">=</span> tf.Print(i, [f_neg], <span class=\"pl-v\">message</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>f_neg = <span class=\"pl-pds\">'</span></span>)\n      <span class=\"pl-k\">return</span> i, x_assign, f_neg\n  <span class=\"pl-k\">return</span> body\n\ntf.reset_default_graph()\nsess <span class=\"pl-k\">=</span> tf.InteractiveSession()\ni <span class=\"pl-k\">=</span> tf.get_variable(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>i<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-v\">initializer</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">0</span>)\nv <span class=\"pl-k\">=</span> tf.get_variable(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>v<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-v\">initializer</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">0</span>)\nfunc_v <span class=\"pl-k\">=</span> <span class=\"pl-k\">lambda</span> <span class=\"pl-smi\">v</span>: tf.square(v)\nl <span class=\"pl-k\">=</span> tf.while_loop(cond, gen_body(v, func_v), (i, v, func_v(v)))\nsess.run(tf.global_variables_initializer())\nsess.run((l, v))</pre></div>\n<p>When you define func_v as a tensor outside the loop it has a fixed value which will stay fixed forever. If you want it to be recomputed you need to actually recompute it.</p>", "body_text": "Right. If you want the function to be computed inside the while loop you need to call it inside the while loop. Something like\ndef cond(i, _x_prev, _f_prev):\n  return i < 3\n\ndef gen_body(x, f):\n  def body(i, _x_prev, _f_prev):\n    x_assign = x.assign(x + 1)\n    # with tf.control_dependencies([x.assign(x + 1)]):\n    #   x_assign = x._ref()\n    with tf.control_dependencies([x_assign]):\n      f_neg = tf.negative(f(x_assign))\n      i = tf.add(i, 1)\n      i = tf.Print(i, [i], message='>>> Iteration ')\n      i = tf.Print(i, [x], message='x = ')\n      i = tf.Print(i, [f(x_assign)], message='x_assign = ')\n      i = tf.Print(i, [f(v)], message='f = ')\n      i = tf.Print(i, [f_neg], message='f_neg = ')\n      return i, x_assign, f_neg\n  return body\n\ntf.reset_default_graph()\nsess = tf.InteractiveSession()\ni = tf.get_variable(\"i\", initializer=0)\nv = tf.get_variable(\"v\", initializer=0)\nfunc_v = lambda v: tf.square(v)\nl = tf.while_loop(cond, gen_body(v, func_v), (i, v, func_v(v)))\nsess.run(tf.global_variables_initializer())\nsess.run((l, v))\nWhen you define func_v as a tensor outside the loop it has a fixed value which will stay fixed forever. If you want it to be recomputed you need to actually recompute it.", "body": "Right. If you want the function to be computed inside the while loop you need to call it inside the while loop. Something like\r\n\r\n```python\r\ndef cond(i, _x_prev, _f_prev):\r\n  return i < 3\r\n\r\ndef gen_body(x, f):\r\n  def body(i, _x_prev, _f_prev):\r\n    x_assign = x.assign(x + 1)\r\n    # with tf.control_dependencies([x.assign(x + 1)]):\r\n    #   x_assign = x._ref()\r\n    with tf.control_dependencies([x_assign]):\r\n      f_neg = tf.negative(f(x_assign))\r\n      i = tf.add(i, 1)\r\n      i = tf.Print(i, [i], message='>>> Iteration ')\r\n      i = tf.Print(i, [x], message='x = ')\r\n      i = tf.Print(i, [f(x_assign)], message='x_assign = ')\r\n      i = tf.Print(i, [f(v)], message='f = ')\r\n      i = tf.Print(i, [f_neg], message='f_neg = ')\r\n      return i, x_assign, f_neg\r\n  return body\r\n\r\ntf.reset_default_graph()\r\nsess = tf.InteractiveSession()\r\ni = tf.get_variable(\"i\", initializer=0)\r\nv = tf.get_variable(\"v\", initializer=0)\r\nfunc_v = lambda v: tf.square(v)\r\nl = tf.while_loop(cond, gen_body(v, func_v), (i, v, func_v(v)))\r\nsess.run(tf.global_variables_initializer())\r\nsess.run((l, v))\r\n```\r\n\r\nWhen you define func_v as a tensor outside the loop it has a fixed value which will stay fixed forever. If you want it to be recomputed you need to actually recompute it. "}