{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/285433935", "html_url": "https://github.com/tensorflow/tensorflow/pull/8232#issuecomment-285433935", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8232", "id": 285433935, "node_id": "MDEyOklzc3VlQ29tbWVudDI4NTQzMzkzNQ==", "user": {"login": "conqerAtapple", "id": 1635173, "node_id": "MDQ6VXNlcjE2MzUxNzM=", "avatar_url": "https://avatars1.githubusercontent.com/u/1635173?v=4", "gravatar_id": "", "url": "https://api.github.com/users/conqerAtapple", "html_url": "https://github.com/conqerAtapple", "followers_url": "https://api.github.com/users/conqerAtapple/followers", "following_url": "https://api.github.com/users/conqerAtapple/following{/other_user}", "gists_url": "https://api.github.com/users/conqerAtapple/gists{/gist_id}", "starred_url": "https://api.github.com/users/conqerAtapple/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/conqerAtapple/subscriptions", "organizations_url": "https://api.github.com/users/conqerAtapple/orgs", "repos_url": "https://api.github.com/users/conqerAtapple/repos", "events_url": "https://api.github.com/users/conqerAtapple/events{/privacy}", "received_events_url": "https://api.github.com/users/conqerAtapple/received_events", "type": "User", "site_admin": false}, "created_at": "2017-03-09T18:15:49Z", "updated_at": "2017-03-09T18:16:59Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=348932\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/hawkinsp\">@hawkinsp</a> Thanks for the review. When we \"reserve\" a capacity for vector, we avoid creating the elements. On the other hand, the \"resize\" option or the \"vector constructor + copy \" option, the elements are created in the vector. So when we call the \"[]\"  operator to get a reference to the object at that index, we again copy the element to the already default constructed element.  So we have a creation + copy cost. In the reserve case, we incur just the creation cost. Also, emplace_back wont resize the vector every time because of the 'reserve'.</p>", "body_text": "@hawkinsp Thanks for the review. When we \"reserve\" a capacity for vector, we avoid creating the elements. On the other hand, the \"resize\" option or the \"vector constructor + copy \" option, the elements are created in the vector. So when we call the \"[]\"  operator to get a reference to the object at that index, we again copy the element to the already default constructed element.  So we have a creation + copy cost. In the reserve case, we incur just the creation cost. Also, emplace_back wont resize the vector every time because of the 'reserve'.", "body": "@hawkinsp Thanks for the review. When we \"reserve\" a capacity for vector, we avoid creating the elements. On the other hand, the \"resize\" option or the \"vector constructor + copy \" option, the elements are created in the vector. So when we call the \"[]\"  operator to get a reference to the object at that index, we again copy the element to the already default constructed element.  So we have a creation + copy cost. In the reserve case, we incur just the creation cost. Also, emplace_back wont resize the vector every time because of the 'reserve'."}