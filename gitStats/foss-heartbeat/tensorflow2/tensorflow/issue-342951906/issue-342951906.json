{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/20986", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/20986/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/20986/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/20986/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/20986", "id": 342951906, "node_id": "MDU6SXNzdWUzNDI5NTE5MDY=", "number": 20986, "title": "tf.data.Iterator has_next(), next(), feature request", "user": {"login": "jackshi0912", "id": 10685803, "node_id": "MDQ6VXNlcjEwNjg1ODAz", "avatar_url": "https://avatars3.githubusercontent.com/u/10685803?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackshi0912", "html_url": "https://github.com/jackshi0912", "followers_url": "https://api.github.com/users/jackshi0912/followers", "following_url": "https://api.github.com/users/jackshi0912/following{/other_user}", "gists_url": "https://api.github.com/users/jackshi0912/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackshi0912/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackshi0912/subscriptions", "organizations_url": "https://api.github.com/users/jackshi0912/orgs", "repos_url": "https://api.github.com/users/jackshi0912/repos", "events_url": "https://api.github.com/users/jackshi0912/events{/privacy}", "received_events_url": "https://api.github.com/users/jackshi0912/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 386191887, "node_id": "MDU6TGFiZWwzODYxOTE4ODc=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:awaiting%20response", "name": "stat:awaiting response", "color": "f4b400", "default": false}, {"id": 473173272, "node_id": "MDU6TGFiZWw0NzMxNzMyNzI=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:feature", "name": "type:feature", "color": "159b2e", "default": false}], "state": "closed", "locked": false, "assignee": {"login": "mrry", "id": 192142, "node_id": "MDQ6VXNlcjE5MjE0Mg==", "avatar_url": "https://avatars1.githubusercontent.com/u/192142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mrry", "html_url": "https://github.com/mrry", "followers_url": "https://api.github.com/users/mrry/followers", "following_url": "https://api.github.com/users/mrry/following{/other_user}", "gists_url": "https://api.github.com/users/mrry/gists{/gist_id}", "starred_url": "https://api.github.com/users/mrry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mrry/subscriptions", "organizations_url": "https://api.github.com/users/mrry/orgs", "repos_url": "https://api.github.com/users/mrry/repos", "events_url": "https://api.github.com/users/mrry/events{/privacy}", "received_events_url": "https://api.github.com/users/mrry/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "mrry", "id": 192142, "node_id": "MDQ6VXNlcjE5MjE0Mg==", "avatar_url": "https://avatars1.githubusercontent.com/u/192142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mrry", "html_url": "https://github.com/mrry", "followers_url": "https://api.github.com/users/mrry/followers", "following_url": "https://api.github.com/users/mrry/following{/other_user}", "gists_url": "https://api.github.com/users/mrry/gists{/gist_id}", "starred_url": "https://api.github.com/users/mrry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mrry/subscriptions", "organizations_url": "https://api.github.com/users/mrry/orgs", "repos_url": "https://api.github.com/users/mrry/repos", "events_url": "https://api.github.com/users/mrry/events{/privacy}", "received_events_url": "https://api.github.com/users/mrry/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 3, "created_at": "2018-07-20T02:32:52Z", "updated_at": "2018-08-08T00:40:15Z", "closed_at": "2018-08-08T00:40:15Z", "author_association": "NONE", "body_html": "<p>Request:<br>\nhas_next()  // opt that check if next data is present at graph execution time without resorting to python try/except<br>\nnext()  // op that advance the iterator by one at graph execution time</p>\n<p>Reason:<br>\nhas_next():<br>\nIterator seems to be designed for supervised learning. Data is fed from one end, OutOfRangeError occurs when all the data has been used and training stops (if repeat is not set).</p>\n<p>In reinforcement learning, the end of episode (last example in file) can be a significant source of information during graph execution time. Catch the exception and run an additional ad-hoc training cycle for the last example is aweful.</p>\n<p>next():<br>\nIn RL, the data can be sequential and has specific time stamps. During graph execution time, the environment written in tensorflow should be able to advance the Iterator using tf.while_loop with iterator.next() until some condition is met</p>\n<p>for example, advance Iterator in a tf.while_loop until time stamp associated with that example is greater than some internal state (variable).</p>\n<p>Perhaps the get_next() method should be parameter such that the node can be optionally required to re-executed after every visit. or just have a next() method and let us figure out the appropriate dependency control.</p>\n<p>Have I written custom code: Yes<br>\nOS Platform and Distribution: Ubuntu 16.04 LTS<br>\nTensorFlow installed from: pip<br>\nTensorFlow version: 1.8<br>\nBazel version: 0.15.2<br>\nCUDA/cuDNN version: Cuda 9.0, cuDNN v7<br>\nGPU model and memory: GTX 1070 8GB<br>\nExact command to reproduce: N/A<br>\nMobile device: N/A</p>", "body_text": "Request:\nhas_next()  // opt that check if next data is present at graph execution time without resorting to python try/except\nnext()  // op that advance the iterator by one at graph execution time\nReason:\nhas_next():\nIterator seems to be designed for supervised learning. Data is fed from one end, OutOfRangeError occurs when all the data has been used and training stops (if repeat is not set).\nIn reinforcement learning, the end of episode (last example in file) can be a significant source of information during graph execution time. Catch the exception and run an additional ad-hoc training cycle for the last example is aweful.\nnext():\nIn RL, the data can be sequential and has specific time stamps. During graph execution time, the environment written in tensorflow should be able to advance the Iterator using tf.while_loop with iterator.next() until some condition is met\nfor example, advance Iterator in a tf.while_loop until time stamp associated with that example is greater than some internal state (variable).\nPerhaps the get_next() method should be parameter such that the node can be optionally required to re-executed after every visit. or just have a next() method and let us figure out the appropriate dependency control.\nHave I written custom code: Yes\nOS Platform and Distribution: Ubuntu 16.04 LTS\nTensorFlow installed from: pip\nTensorFlow version: 1.8\nBazel version: 0.15.2\nCUDA/cuDNN version: Cuda 9.0, cuDNN v7\nGPU model and memory: GTX 1070 8GB\nExact command to reproduce: N/A\nMobile device: N/A", "body": "Request:\r\nhas_next()  // opt that check if next data is present at graph execution time without resorting to python try/except\r\nnext()  // op that advance the iterator by one at graph execution time\r\n\r\nReason:\r\nhas_next():\r\nIterator seems to be designed for supervised learning. Data is fed from one end, OutOfRangeError occurs when all the data has been used and training stops (if repeat is not set).\r\n\r\nIn reinforcement learning, the end of episode (last example in file) can be a significant source of information during graph execution time. Catch the exception and run an additional ad-hoc training cycle for the last example is aweful.\r\n\r\nnext():\r\nIn RL, the data can be sequential and has specific time stamps. During graph execution time, the environment written in tensorflow should be able to advance the Iterator using tf.while_loop with iterator.next() until some condition is met \r\n\r\nfor example, advance Iterator in a tf.while_loop until time stamp associated with that example is greater than some internal state (variable).\r\n\r\nPerhaps the get_next() method should be parameter such that the node can be optionally required to re-executed after every visit. or just have a next() method and let us figure out the appropriate dependency control.\r\n\r\nHave I written custom code: Yes\r\nOS Platform and Distribution: Ubuntu 16.04 LTS\r\nTensorFlow installed from: pip\r\nTensorFlow version: 1.8\r\nBazel version: 0.15.2\r\nCUDA/cuDNN version: Cuda 9.0, cuDNN v7\r\nGPU model and memory: GTX 1070 8GB\r\nExact command to reproduce: N/A\r\nMobile device: N/A"}