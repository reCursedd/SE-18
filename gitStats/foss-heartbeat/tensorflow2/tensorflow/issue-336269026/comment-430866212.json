{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/430866212", "html_url": "https://github.com/tensorflow/tensorflow/issues/20345#issuecomment-430866212", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/20345", "id": 430866212, "node_id": "MDEyOklzc3VlQ29tbWVudDQzMDg2NjIxMg==", "user": {"login": "Flowerfan", "id": 7525070, "node_id": "MDQ6VXNlcjc1MjUwNzA=", "avatar_url": "https://avatars2.githubusercontent.com/u/7525070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Flowerfan", "html_url": "https://github.com/Flowerfan", "followers_url": "https://api.github.com/users/Flowerfan/followers", "following_url": "https://api.github.com/users/Flowerfan/following{/other_user}", "gists_url": "https://api.github.com/users/Flowerfan/gists{/gist_id}", "starred_url": "https://api.github.com/users/Flowerfan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Flowerfan/subscriptions", "organizations_url": "https://api.github.com/users/Flowerfan/orgs", "repos_url": "https://api.github.com/users/Flowerfan/repos", "events_url": "https://api.github.com/users/Flowerfan/events{/privacy}", "received_events_url": "https://api.github.com/users/Flowerfan/received_events", "type": "User", "site_admin": false}, "created_at": "2018-10-18T03:49:20Z", "updated_at": "2018-10-18T03:59:23Z", "author_association": "NONE", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=6483642\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/AVCarreiro\">@AVCarreiro</a>  I used scaffold and tf.train.Saver to deal with it. First create a scaffold object for initialization, and then pass it to EstimatorSpec.<br>\nHere is my solution:</p>\n<pre><code>saver = tf.train.Saver(var_list=varlist, reshape=True)`\ndef init_fn(scaffold, session):\n   saver.restore(session, model_pth)\nscaffold = tf.train.Scaffold(init_fn=init_fn)\nreturn tf.estimator.EstimatorSpec(mode, loss=loss, train_op=train_op, scaffold=scaffold)\n</code></pre>", "body_text": "@AVCarreiro  I used scaffold and tf.train.Saver to deal with it. First create a scaffold object for initialization, and then pass it to EstimatorSpec.\nHere is my solution:\nsaver = tf.train.Saver(var_list=varlist, reshape=True)`\ndef init_fn(scaffold, session):\n   saver.restore(session, model_pth)\nscaffold = tf.train.Scaffold(init_fn=init_fn)\nreturn tf.estimator.EstimatorSpec(mode, loss=loss, train_op=train_op, scaffold=scaffold)", "body": "@AVCarreiro  I used scaffold and tf.train.Saver to deal with it. First create a scaffold object for initialization, and then pass it to EstimatorSpec.\r\nHere is my solution: \r\n```\r\nsaver = tf.train.Saver(var_list=varlist, reshape=True)`\r\ndef init_fn(scaffold, session):\r\n   saver.restore(session, model_pth)\r\nscaffold = tf.train.Scaffold(init_fn=init_fn)\r\nreturn tf.estimator.EstimatorSpec(mode, loss=loss, train_op=train_op, scaffold=scaffold)\r\n```\r\n"}