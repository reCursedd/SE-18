{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/294929507", "html_url": "https://github.com/tensorflow/tensorflow/issues/97#issuecomment-294929507", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/97", "id": 294929507, "node_id": "MDEyOklzc3VlQ29tbWVudDI5NDkyOTUwNw==", "user": {"login": "rohitchopra32", "id": 17051320, "node_id": "MDQ6VXNlcjE3MDUxMzIw", "avatar_url": "https://avatars3.githubusercontent.com/u/17051320?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rohitchopra32", "html_url": "https://github.com/rohitchopra32", "followers_url": "https://api.github.com/users/rohitchopra32/followers", "following_url": "https://api.github.com/users/rohitchopra32/following{/other_user}", "gists_url": "https://api.github.com/users/rohitchopra32/gists{/gist_id}", "starred_url": "https://api.github.com/users/rohitchopra32/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rohitchopra32/subscriptions", "organizations_url": "https://api.github.com/users/rohitchopra32/orgs", "repos_url": "https://api.github.com/users/rohitchopra32/repos", "events_url": "https://api.github.com/users/rohitchopra32/events{/privacy}", "received_events_url": "https://api.github.com/users/rohitchopra32/received_events", "type": "User", "site_admin": false}, "created_at": "2017-04-18T17:58:11Z", "updated_at": "2017-04-18T17:58:11Z", "author_association": "NONE", "body_html": "<p>i have some code like this</p>\n<blockquote>\n<p>run_fc.py</p>\n</blockquote>\n<pre><code># Define input placeholders\nimages_placeholder = tf.placeholder(tf.float32, shape=[None, IMAGE_PIXELS],  name='images')\nlabels_placeholder = tf.placeholder(tf.int64, shape=[None], name='image-labels')\n\n# Operation for the classifier's result\nlogits = two_layer_fc.inference(images_placeholder, IMAGE_PIXELS,\n  FLAGS.hidden1, CLASSES, reg_constant=FLAGS.reg_constant)\n\n# Operation for the loss function\nloss = two_layer_fc.loss(logits, labels_placeholder)\n\n# Operation for the training step\ntrain_step = two_layer_fc.training(loss, FLAGS.learning_rate)\n\n# Operation calculating the accuracy of our predictions\naccuracy = two_layer_fc.evaluation(logits, labels_placeholder)\n\n</code></pre>\n<blockquote>\n<p>two_layer_fc.py:</p>\n</blockquote>\n<pre><code>def evaluation(logits, labels):\n  '''Evaluates the quality of the logits at predicting the label.\n\n  Args:\n    logits: Logits tensor, float - [batch size, number of classes].\n    labels: Labels tensor, int64 - [batch size].\n\n  Returns:\n    accuracy: the percentage of images where the class was correctly predicted.\n  '''\n\n  with tf.name_scope('Accuracy'):\n    # Operation comparing prediction with true label\n    correct_prediction = tf.equal(tf.argmax(logits,1), labels)\n\n    # Operation calculating the accuracy of the predictions\n    accuracy =  tf.reduce_mean(tf.cast(correct_prediction, tf.float32))\n\n    # Summary operation for the accuracy\n    tf.summary.scalar('train_accuracy', accuracy)\n\n  return accuracy\n\n</code></pre>\n<p>i want when evaluation funtion that is in</p>\n<blockquote>\n<p>two_layer_fc.py file</p>\n</blockquote>\n<p>find out correct_prediction  after that it will show the predicted label and label that is in labels (original label)</p>\n<p>i tried this adding this:</p>\n<blockquote>\n<p>prediction=tf.argmax(y,1)<br>\nprint prediction.eval(feed_dict={x: mnist.test.images})</p>\n</blockquote>\n<p>it only gives me error.</p>", "body_text": "i have some code like this\n\nrun_fc.py\n\n# Define input placeholders\nimages_placeholder = tf.placeholder(tf.float32, shape=[None, IMAGE_PIXELS],  name='images')\nlabels_placeholder = tf.placeholder(tf.int64, shape=[None], name='image-labels')\n\n# Operation for the classifier's result\nlogits = two_layer_fc.inference(images_placeholder, IMAGE_PIXELS,\n  FLAGS.hidden1, CLASSES, reg_constant=FLAGS.reg_constant)\n\n# Operation for the loss function\nloss = two_layer_fc.loss(logits, labels_placeholder)\n\n# Operation for the training step\ntrain_step = two_layer_fc.training(loss, FLAGS.learning_rate)\n\n# Operation calculating the accuracy of our predictions\naccuracy = two_layer_fc.evaluation(logits, labels_placeholder)\n\n\n\ntwo_layer_fc.py:\n\ndef evaluation(logits, labels):\n  '''Evaluates the quality of the logits at predicting the label.\n\n  Args:\n    logits: Logits tensor, float - [batch size, number of classes].\n    labels: Labels tensor, int64 - [batch size].\n\n  Returns:\n    accuracy: the percentage of images where the class was correctly predicted.\n  '''\n\n  with tf.name_scope('Accuracy'):\n    # Operation comparing prediction with true label\n    correct_prediction = tf.equal(tf.argmax(logits,1), labels)\n\n    # Operation calculating the accuracy of the predictions\n    accuracy =  tf.reduce_mean(tf.cast(correct_prediction, tf.float32))\n\n    # Summary operation for the accuracy\n    tf.summary.scalar('train_accuracy', accuracy)\n\n  return accuracy\n\n\ni want when evaluation funtion that is in\n\ntwo_layer_fc.py file\n\nfind out correct_prediction  after that it will show the predicted label and label that is in labels (original label)\ni tried this adding this:\n\nprediction=tf.argmax(y,1)\nprint prediction.eval(feed_dict={x: mnist.test.images})\n\nit only gives me error.", "body": "i have some code like this\r\n> run_fc.py\r\n\r\n```\r\n# Define input placeholders\r\nimages_placeholder = tf.placeholder(tf.float32, shape=[None, IMAGE_PIXELS],  name='images')\r\nlabels_placeholder = tf.placeholder(tf.int64, shape=[None], name='image-labels')\r\n\r\n# Operation for the classifier's result\r\nlogits = two_layer_fc.inference(images_placeholder, IMAGE_PIXELS,\r\n  FLAGS.hidden1, CLASSES, reg_constant=FLAGS.reg_constant)\r\n\r\n# Operation for the loss function\r\nloss = two_layer_fc.loss(logits, labels_placeholder)\r\n\r\n# Operation for the training step\r\ntrain_step = two_layer_fc.training(loss, FLAGS.learning_rate)\r\n\r\n# Operation calculating the accuracy of our predictions\r\naccuracy = two_layer_fc.evaluation(logits, labels_placeholder)\r\n\r\n```\r\n\r\n> two_layer_fc.py:\r\n\r\n\r\n```\r\ndef evaluation(logits, labels):\r\n  '''Evaluates the quality of the logits at predicting the label.\r\n\r\n  Args:\r\n    logits: Logits tensor, float - [batch size, number of classes].\r\n    labels: Labels tensor, int64 - [batch size].\r\n\r\n  Returns:\r\n    accuracy: the percentage of images where the class was correctly predicted.\r\n  '''\r\n\r\n  with tf.name_scope('Accuracy'):\r\n    # Operation comparing prediction with true label\r\n    correct_prediction = tf.equal(tf.argmax(logits,1), labels)\r\n\r\n    # Operation calculating the accuracy of the predictions\r\n    accuracy =  tf.reduce_mean(tf.cast(correct_prediction, tf.float32))\r\n\r\n    # Summary operation for the accuracy\r\n    tf.summary.scalar('train_accuracy', accuracy)\r\n\r\n  return accuracy\r\n\r\n```\r\ni want when evaluation funtion that is in \r\n\r\n> two_layer_fc.py file\r\n\r\n find out correct_prediction  after that it will show the predicted label and label that is in labels (original label)\r\n\r\ni tried this adding this:\r\n\r\n> prediction=tf.argmax(y,1)\r\n> print prediction.eval(feed_dict={x: mnist.test.images})\r\n\r\nit only gives me error.\r\n\r\n"}