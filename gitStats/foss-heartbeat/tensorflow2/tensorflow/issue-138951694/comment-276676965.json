{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/276676965", "html_url": "https://github.com/tensorflow/tensorflow/issues/1419#issuecomment-276676965", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/1419", "id": 276676965, "node_id": "MDEyOklzc3VlQ29tbWVudDI3NjY3Njk2NQ==", "user": {"login": "sbyma", "id": 15868135, "node_id": "MDQ6VXNlcjE1ODY4MTM1", "avatar_url": "https://avatars0.githubusercontent.com/u/15868135?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sbyma", "html_url": "https://github.com/sbyma", "followers_url": "https://api.github.com/users/sbyma/followers", "following_url": "https://api.github.com/users/sbyma/following{/other_user}", "gists_url": "https://api.github.com/users/sbyma/gists{/gist_id}", "starred_url": "https://api.github.com/users/sbyma/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sbyma/subscriptions", "organizations_url": "https://api.github.com/users/sbyma/orgs", "repos_url": "https://api.github.com/users/sbyma/repos", "events_url": "https://api.github.com/users/sbyma/events{/privacy}", "received_events_url": "https://api.github.com/users/sbyma/received_events", "type": "User", "site_admin": false}, "created_at": "2017-02-01T14:52:31Z", "updated_at": "2017-02-01T14:52:31Z", "author_association": "NONE", "body_html": "<p>To be honest, we actually gave up on inheriting from the <code>reader_base</code> framework. It was too much hassle, and the overheads were quite high.</p>\n<p>Another thing you can do is create a vanilla Op that takes a <code>string</code> type tensor filename, that when executed reads your file from disk into a <code>Tensor</code> of whatever type/shape you need and output it. However, if you need to read pieces of a file every step, as the <code>reader_base</code> stuff does, then it's probably better to wait for a solution from a googler.</p>\n<p>On the other hand, if you are comfortable enough with the code, you can add a <code>resource</code> tensor as an input that references a <code>QueueInterface</code>, which you use to get new filenames if you need them that step (this is what the reader_base stuff does).</p>", "body_text": "To be honest, we actually gave up on inheriting from the reader_base framework. It was too much hassle, and the overheads were quite high.\nAnother thing you can do is create a vanilla Op that takes a string type tensor filename, that when executed reads your file from disk into a Tensor of whatever type/shape you need and output it. However, if you need to read pieces of a file every step, as the reader_base stuff does, then it's probably better to wait for a solution from a googler.\nOn the other hand, if you are comfortable enough with the code, you can add a resource tensor as an input that references a QueueInterface, which you use to get new filenames if you need them that step (this is what the reader_base stuff does).", "body": "To be honest, we actually gave up on inheriting from the `reader_base` framework. It was too much hassle, and the overheads were quite high. \r\n\r\nAnother thing you can do is create a vanilla Op that takes a `string` type tensor filename, that when executed reads your file from disk into a `Tensor` of whatever type/shape you need and output it. However, if you need to read pieces of a file every step, as the `reader_base` stuff does, then it's probably better to wait for a solution from a googler. \r\n\r\nOn the other hand, if you are comfortable enough with the code, you can add a `resource` tensor as an input that references a `QueueInterface`, which you use to get new filenames if you need them that step (this is what the reader_base stuff does). "}