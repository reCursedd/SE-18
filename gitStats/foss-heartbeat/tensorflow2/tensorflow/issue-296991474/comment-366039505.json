{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/366039505", "html_url": "https://github.com/tensorflow/tensorflow/issues/17002#issuecomment-366039505", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/17002", "id": 366039505, "node_id": "MDEyOklzc3VlQ29tbWVudDM2NjAzOTUwNQ==", "user": {"login": "ccolby", "id": 15960281, "node_id": "MDQ6VXNlcjE1OTYwMjgx", "avatar_url": "https://avatars1.githubusercontent.com/u/15960281?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ccolby", "html_url": "https://github.com/ccolby", "followers_url": "https://api.github.com/users/ccolby/followers", "following_url": "https://api.github.com/users/ccolby/following{/other_user}", "gists_url": "https://api.github.com/users/ccolby/gists{/gist_id}", "starred_url": "https://api.github.com/users/ccolby/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ccolby/subscriptions", "organizations_url": "https://api.github.com/users/ccolby/orgs", "repos_url": "https://api.github.com/users/ccolby/repos", "events_url": "https://api.github.com/users/ccolby/events{/privacy}", "received_events_url": "https://api.github.com/users/ccolby/received_events", "type": "User", "site_admin": false}, "created_at": "2018-02-15T19:42:54Z", "updated_at": "2018-02-15T19:42:54Z", "author_association": "NONE", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=13407698\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/sandeepkumar8713\">@sandeepkumar8713</a> The error is because your input Tensor (X) was created outside the graph that the Estimator code creates during the kmeans.train() invocation. The solution is to delay the creation of that Tensor by putting it inside the input_fn lambda, which will be invoked within train().</p>\n<p>Below is a complete example. Let me know if you encounter difficulties.</p>\n<pre><code>k = 5\nn = 100\nvariables = 2\npoints = np.random.uniform(0, 1000, [n, variables])\ninput_fn=lambda: tf.train.limit_epochs(tf.convert_to_tensor(points, dtype=tf.float32), num_epochs=1)\nkmeans=tf.contrib.factorization.KMeansClustering(num_clusters=k, use_mini_batch=False)\nprevious_centers = None\nfor _ in xrange(10):\n  kmeans.train(input_fn)\n  centers = kmeans.cluster_centers()\n  if previous_centers is not None:\n    print 'delta:', centers - previous_centers\n  previous_centers = centers\n  print 'score:', kmeans.score(input_fn)\nprint 'centers:', centers\ncluster_indices = list(kmeans.predict_cluster_index(input_fn))\nfor i, point in enumerate(points):\n  cluster_index = cluster_indices[i]\n  print 'point:', point, 'is in cluster', cluster_index, 'centered at', centers[cluster_index]\n</code></pre>", "body_text": "@sandeepkumar8713 The error is because your input Tensor (X) was created outside the graph that the Estimator code creates during the kmeans.train() invocation. The solution is to delay the creation of that Tensor by putting it inside the input_fn lambda, which will be invoked within train().\nBelow is a complete example. Let me know if you encounter difficulties.\nk = 5\nn = 100\nvariables = 2\npoints = np.random.uniform(0, 1000, [n, variables])\ninput_fn=lambda: tf.train.limit_epochs(tf.convert_to_tensor(points, dtype=tf.float32), num_epochs=1)\nkmeans=tf.contrib.factorization.KMeansClustering(num_clusters=k, use_mini_batch=False)\nprevious_centers = None\nfor _ in xrange(10):\n  kmeans.train(input_fn)\n  centers = kmeans.cluster_centers()\n  if previous_centers is not None:\n    print 'delta:', centers - previous_centers\n  previous_centers = centers\n  print 'score:', kmeans.score(input_fn)\nprint 'centers:', centers\ncluster_indices = list(kmeans.predict_cluster_index(input_fn))\nfor i, point in enumerate(points):\n  cluster_index = cluster_indices[i]\n  print 'point:', point, 'is in cluster', cluster_index, 'centered at', centers[cluster_index]", "body": "@sandeepkumar8713 The error is because your input Tensor (X) was created outside the graph that the Estimator code creates during the kmeans.train() invocation. The solution is to delay the creation of that Tensor by putting it inside the input_fn lambda, which will be invoked within train().\r\n\r\nBelow is a complete example. Let me know if you encounter difficulties.\r\n\r\n```\r\nk = 5\r\nn = 100\r\nvariables = 2\r\npoints = np.random.uniform(0, 1000, [n, variables])\r\ninput_fn=lambda: tf.train.limit_epochs(tf.convert_to_tensor(points, dtype=tf.float32), num_epochs=1)\r\nkmeans=tf.contrib.factorization.KMeansClustering(num_clusters=k, use_mini_batch=False)\r\nprevious_centers = None\r\nfor _ in xrange(10):\r\n  kmeans.train(input_fn)\r\n  centers = kmeans.cluster_centers()\r\n  if previous_centers is not None:\r\n    print 'delta:', centers - previous_centers\r\n  previous_centers = centers\r\n  print 'score:', kmeans.score(input_fn)\r\nprint 'centers:', centers\r\ncluster_indices = list(kmeans.predict_cluster_index(input_fn))\r\nfor i, point in enumerate(points):\r\n  cluster_index = cluster_indices[i]\r\n  print 'point:', point, 'is in cluster', cluster_index, 'centered at', centers[cluster_index]\r\n```"}