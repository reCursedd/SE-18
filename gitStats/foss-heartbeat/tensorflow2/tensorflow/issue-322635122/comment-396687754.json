{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/396687754", "html_url": "https://github.com/tensorflow/tensorflow/issues/19260#issuecomment-396687754", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/19260", "id": 396687754, "node_id": "MDEyOklzc3VlQ29tbWVudDM5NjY4Nzc1NA==", "user": {"login": "mjmatthews", "id": 29803654, "node_id": "MDQ6VXNlcjI5ODAzNjU0", "avatar_url": "https://avatars0.githubusercontent.com/u/29803654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mjmatthews", "html_url": "https://github.com/mjmatthews", "followers_url": "https://api.github.com/users/mjmatthews/followers", "following_url": "https://api.github.com/users/mjmatthews/following{/other_user}", "gists_url": "https://api.github.com/users/mjmatthews/gists{/gist_id}", "starred_url": "https://api.github.com/users/mjmatthews/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mjmatthews/subscriptions", "organizations_url": "https://api.github.com/users/mjmatthews/orgs", "repos_url": "https://api.github.com/users/mjmatthews/repos", "events_url": "https://api.github.com/users/mjmatthews/events{/privacy}", "received_events_url": "https://api.github.com/users/mjmatthews/received_events", "type": "User", "site_admin": false}, "created_at": "2018-06-12T18:24:43Z", "updated_at": "2018-06-12T18:24:43Z", "author_association": "NONE", "body_html": "<p>rryan@<br>\nAgreed, that 's unfortunate.</p>\n<p>aselle@<br>\nWouldn't it be more consistent to change <a href=\"https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/ops/array_ops.py#L488\">https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/ops/array_ops.py#L488</a> to something like:</p>\n<pre><code>    else:\n      begin.append(s)\n      if s is -1:\n        # User is requesting the last element. (s + 1) will result in a\n        # degenerate interval, so we must use the end mask instead.\n        end.append(s)\n        end_mask |= (1 &lt;&lt; index)\n      else:\n        end.append(s + 1)\n      strides.append(1)\n      shrink_axis_mask |= (1 &lt;&lt; index)\n</code></pre>\n<p>Rather than the workaround in the CC op? The argument being that the CC interface appears to be attempting to be as faithful to python's slicing semantics as possible. The limitation with it is that an end index must be given, unlike in python. To maintain the semantics, we could just use the end mask, which would be equivalent to</p>\n<pre><code>print sess.run(tf.constant([1,2,3,4])[-1: :1])\n[4]\n</code></pre>\n<p>vs</p>\n<pre><code>print sess.run(tf.constant([1,2,3,4])[-1:0:1])\n[]\n</code></pre>\n<p>I'd also be in favor in changing the CC strided_slice inputs to only accept canonical indices altogether. But that might lead to some difficult migration and backward compatibility issues.</p>\n<p>At the very least if we leave this as is and change the TOCO code to reflect TF's workaround, we should update the documentation to say that the end index and strides are ignored when the shrink axis bit is set.</p>", "body_text": "rryan@\nAgreed, that 's unfortunate.\naselle@\nWouldn't it be more consistent to change https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/ops/array_ops.py#L488 to something like:\n    else:\n      begin.append(s)\n      if s is -1:\n        # User is requesting the last element. (s + 1) will result in a\n        # degenerate interval, so we must use the end mask instead.\n        end.append(s)\n        end_mask |= (1 << index)\n      else:\n        end.append(s + 1)\n      strides.append(1)\n      shrink_axis_mask |= (1 << index)\n\nRather than the workaround in the CC op? The argument being that the CC interface appears to be attempting to be as faithful to python's slicing semantics as possible. The limitation with it is that an end index must be given, unlike in python. To maintain the semantics, we could just use the end mask, which would be equivalent to\nprint sess.run(tf.constant([1,2,3,4])[-1: :1])\n[4]\n\nvs\nprint sess.run(tf.constant([1,2,3,4])[-1:0:1])\n[]\n\nI'd also be in favor in changing the CC strided_slice inputs to only accept canonical indices altogether. But that might lead to some difficult migration and backward compatibility issues.\nAt the very least if we leave this as is and change the TOCO code to reflect TF's workaround, we should update the documentation to say that the end index and strides are ignored when the shrink axis bit is set.", "body": "rryan@\r\nAgreed, that 's unfortunate. \r\n\r\naselle@\r\nWouldn't it be more consistent to change https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/ops/array_ops.py#L488 to something like:\r\n```\r\n    else:\r\n      begin.append(s)\r\n      if s is -1:\r\n        # User is requesting the last element. (s + 1) will result in a\r\n        # degenerate interval, so we must use the end mask instead.\r\n        end.append(s)\r\n        end_mask |= (1 << index)\r\n      else:\r\n        end.append(s + 1)\r\n      strides.append(1)\r\n      shrink_axis_mask |= (1 << index)\r\n```\r\nRather than the workaround in the CC op? The argument being that the CC interface appears to be attempting to be as faithful to python's slicing semantics as possible. The limitation with it is that an end index must be given, unlike in python. To maintain the semantics, we could just use the end mask, which would be equivalent to\r\n```\r\nprint sess.run(tf.constant([1,2,3,4])[-1: :1])\r\n[4]\r\n```\r\nvs\r\n```\r\nprint sess.run(tf.constant([1,2,3,4])[-1:0:1])\r\n[]\r\n```\r\nI'd also be in favor in changing the CC strided_slice inputs to only accept canonical indices altogether. But that might lead to some difficult migration and backward compatibility issues.\r\n\r\nAt the very least if we leave this as is and change the TOCO code to reflect TF's workaround, we should update the documentation to say that the end index and strides are ignored when the shrink axis bit is set. \r\n"}