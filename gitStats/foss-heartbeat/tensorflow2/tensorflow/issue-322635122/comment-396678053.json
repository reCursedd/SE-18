{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/396678053", "html_url": "https://github.com/tensorflow/tensorflow/issues/19260#issuecomment-396678053", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/19260", "id": 396678053, "node_id": "MDEyOklzc3VlQ29tbWVudDM5NjY3ODA1Mw==", "user": {"login": "aselle", "id": 326106, "node_id": "MDQ6VXNlcjMyNjEwNg==", "avatar_url": "https://avatars1.githubusercontent.com/u/326106?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aselle", "html_url": "https://github.com/aselle", "followers_url": "https://api.github.com/users/aselle/followers", "following_url": "https://api.github.com/users/aselle/following{/other_user}", "gists_url": "https://api.github.com/users/aselle/gists{/gist_id}", "starred_url": "https://api.github.com/users/aselle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aselle/subscriptions", "organizations_url": "https://api.github.com/users/aselle/orgs", "repos_url": "https://api.github.com/users/aselle/repos", "events_url": "https://api.github.com/users/aselle/events{/privacy}", "received_events_url": "https://api.github.com/users/aselle/received_events", "type": "User", "site_admin": false}, "created_at": "2018-06-12T17:53:40Z", "updated_at": "2018-06-12T17:53:40Z", "author_association": "MEMBER", "body_html": "<div class=\"email-fragment\">Hm one could have the fft return a buffer where the last last dimension of\nthe tenosor is 2-dimensional so...\nreal = foo[..., 0]\nim = foo[..., 1]\nThen you wouldnmt' strictly need complex numbers. Then you could add\ntensors using the existing add, but you'd have to be careful using\noperations that weren't  decoupled  in real and imaginary behavior like *,\nbut you could do real part by doing then\n\ntf.sqrt(tf.reduce_add(foo * foo, axis=-1))\n-A</div>\n<span class=\"email-hidden-toggle\"><a href=\"#\">\u2026</a></span><div class=\"email-hidden-reply\">\n<div class=\"email-quoted-reply\">On Tue, Jun 12, 2018 at 10:18 AM RJ Skerry-Ryan ***@***.***&gt; wrote:\n Slightly off topic: I'm actually using tf.abs( tf.contrib.signal.stft( x )\n ).\n Since complex numbers are a combination of absolute value and \"argument\":\n Can this be rewritten as a single op which doesn't require complex numbers?\n Maybe this would also be somewhat more battery efficient?\n\n Hm, you always have to compute both the real and imaginary parts of the\n DFT in order to get the magnitude so I think even if there are no\n complex-valued tensors the op would be calculating it internally. You can\n factor the calculation into a real and imaginary part to avoid needing a\n complex type in tf.lite itself, but this will probably be less efficient\n than computing them jointly because the real and imaginary parts share the\n same memory access patterns when they're being computed.\n\n One thing that might help is doing a fixed-point FFT instead of floating\n point. I haven't thought much about how to support that with TensorFlow's\n RFFT op, but it should be do-able.\n\n If you're building a mobile algorithm that operates in a streaming fashion\n you probably want to pass in frames of audio at a time to your tf.lite\n model. In this situation, tf.contrib.signal.stft isn't going to be\n appropriate because it's going to frame the audio you pass in for you, and\n it doesn't support being run in a stateful manner where you're feeding it\n chunks of audio at a time. You may want to fall back on\n tf.contrib.signal.hann_window (or any window) and tf.spectral.rfft to\n window and compute the RFFT on the incoming frame you're processing in this\n scenario.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n &lt;<a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"322635122\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/tensorflow/tensorflow/issues/19260\" href=\"https://github.com/tensorflow/tensorflow/issues/19260#issuecomment-396667159\">#19260 (comment)</a>&gt;,\n or mute the thread\n &lt;<a href=\"https://github.com/notifications/unsubscribe-auth/AAT52t5k10pIYP9JE65lp3IpVxlt0Hkoks5t7_fUgaJpZM4T8_nX\">https://github.com/notifications/unsubscribe-auth/AAT52t5k10pIYP9JE65lp3IpVxlt0Hkoks5t7_fUgaJpZM4T8_nX</a>&gt;\n .\n</div>\n<div class=\"email-fragment\"></div>\n</div>", "body_text": "Hm one could have the fft return a buffer where the last last dimension of\nthe tenosor is 2-dimensional so...\nreal = foo[..., 0]\nim = foo[..., 1]\nThen you wouldnmt' strictly need complex numbers. Then you could add\ntensors using the existing add, but you'd have to be careful using\noperations that weren't  decoupled  in real and imaginary behavior like *,\nbut you could do real part by doing then\n\ntf.sqrt(tf.reduce_add(foo * foo, axis=-1))\n-A\n\u2026\nOn Tue, Jun 12, 2018 at 10:18 AM RJ Skerry-Ryan ***@***.***> wrote:\n Slightly off topic: I'm actually using tf.abs( tf.contrib.signal.stft( x )\n ).\n Since complex numbers are a combination of absolute value and \"argument\":\n Can this be rewritten as a single op which doesn't require complex numbers?\n Maybe this would also be somewhat more battery efficient?\n\n Hm, you always have to compute both the real and imaginary parts of the\n DFT in order to get the magnitude so I think even if there are no\n complex-valued tensors the op would be calculating it internally. You can\n factor the calculation into a real and imaginary part to avoid needing a\n complex type in tf.lite itself, but this will probably be less efficient\n than computing them jointly because the real and imaginary parts share the\n same memory access patterns when they're being computed.\n\n One thing that might help is doing a fixed-point FFT instead of floating\n point. I haven't thought much about how to support that with TensorFlow's\n RFFT op, but it should be do-able.\n\n If you're building a mobile algorithm that operates in a streaming fashion\n you probably want to pass in frames of audio at a time to your tf.lite\n model. In this situation, tf.contrib.signal.stft isn't going to be\n appropriate because it's going to frame the audio you pass in for you, and\n it doesn't support being run in a stateful manner where you're feeding it\n chunks of audio at a time. You may want to fall back on\n tf.contrib.signal.hann_window (or any window) and tf.spectral.rfft to\n window and compute the RFFT on the incoming frame you're processing in this\n scenario.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#19260 (comment)>,\n or mute the thread\n <https://github.com/notifications/unsubscribe-auth/AAT52t5k10pIYP9JE65lp3IpVxlt0Hkoks5t7_fUgaJpZM4T8_nX>\n .", "body": "Hm one could have the fft return a buffer where the last last dimension of\nthe tenosor is 2-dimensional so...\nreal = foo[..., 0]\nim = foo[..., 1]\nThen you wouldnmt' strictly need complex numbers. Then you could add\ntensors using the existing add, but you'd have to be careful using\noperations that weren't  decoupled  in real and imaginary behavior like *,\nbut you could do real part by doing then\n\ntf.sqrt(tf.reduce_add(foo * foo, axis=-1))\n-A\n\n\n\n\nOn Tue, Jun 12, 2018 at 10:18 AM RJ Skerry-Ryan <notifications@github.com>\nwrote:\n\n> Slightly off topic: I'm actually using tf.abs( tf.contrib.signal.stft( x )\n> ).\n> Since complex numbers are a combination of absolute value and \"argument\":\n> Can this be rewritten as a single op which doesn't require complex numbers?\n> Maybe this would also be somewhat more battery efficient?\n>\n> Hm, you always have to compute both the real and imaginary parts of the\n> DFT in order to get the magnitude so I think even if there are no\n> complex-valued tensors the op would be calculating it internally. You can\n> factor the calculation into a real and imaginary part to avoid needing a\n> complex type in tf.lite itself, but this will probably be less efficient\n> than computing them jointly because the real and imaginary parts share the\n> same memory access patterns when they're being computed.\n>\n> One thing that might help is doing a fixed-point FFT instead of floating\n> point. I haven't thought much about how to support that with TensorFlow's\n> RFFT op, but it should be do-able.\n>\n> If you're building a mobile algorithm that operates in a streaming fashion\n> you probably want to pass in frames of audio at a time to your tf.lite\n> model. In this situation, tf.contrib.signal.stft isn't going to be\n> appropriate because it's going to frame the audio you pass in for you, and\n> it doesn't support being run in a stateful manner where you're feeding it\n> chunks of audio at a time. You may want to fall back on\n> tf.contrib.signal.hann_window (or any window) and tf.spectral.rfft to\n> window and compute the RFFT on the incoming frame you're processing in this\n> scenario.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tensorflow/tensorflow/issues/19260#issuecomment-396667159>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAT52t5k10pIYP9JE65lp3IpVxlt0Hkoks5t7_fUgaJpZM4T8_nX>\n> .\n>\n"}