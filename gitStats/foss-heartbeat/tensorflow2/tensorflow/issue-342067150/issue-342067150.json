{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/20891", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/20891/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/20891/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/20891/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/20891", "id": 342067150, "node_id": "MDU6SXNzdWUzNDIwNjcxNTA=", "number": 20891, "title": "Feature Request: tf.Session().as_default() should have a flag to keep the session alive", "user": {"login": "phizaz", "id": 451667, "node_id": "MDQ6VXNlcjQ1MTY2Nw==", "avatar_url": "https://avatars3.githubusercontent.com/u/451667?v=4", "gravatar_id": "", "url": "https://api.github.com/users/phizaz", "html_url": "https://github.com/phizaz", "followers_url": "https://api.github.com/users/phizaz/followers", "following_url": "https://api.github.com/users/phizaz/following{/other_user}", "gists_url": "https://api.github.com/users/phizaz/gists{/gist_id}", "starred_url": "https://api.github.com/users/phizaz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/phizaz/subscriptions", "organizations_url": "https://api.github.com/users/phizaz/orgs", "repos_url": "https://api.github.com/users/phizaz/repos", "events_url": "https://api.github.com/users/phizaz/events{/privacy}", "received_events_url": "https://api.github.com/users/phizaz/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2018-07-17T20:12:24Z", "updated_at": "2018-07-18T06:16:05Z", "closed_at": "2018-07-17T23:59:08Z", "author_association": "NONE", "body_html": "<h3>Describe the problem</h3>\n<p>I find a scenario in which keeping a session alive (even after closing the context manager) is useful. Let's say that I have a method <code>train(steps)</code> that will train a model for the next <code>steps</code> iterations. Given the current API r1.9, I could think of no other way than to save and restore the session between method calls. That would incur a huge overhead indeed!</p>\n<p>I could think of two possible ways out:</p>\n<ul>\n<li>providing an API to set a default session at will without automatically closing the session. It could come in a form of a context manager.</li>\n<li>adding a flag to the <code>.as_default()</code> method in <code>tf.Session()</code> to keep it alive after the context manager is closed.</li>\n</ul>\n<h3>Source code / logs</h3>\n<p>The following code shows the hypothetical scenario.</p>\n<pre><code>model = # some model\nmodel.train(100) # train for 100 iterations\n# default session should be None here (this rules out the usage of InteractiveSession)\nmodel.train(100) # train for another 100 iterations\n</code></pre>\n<p>The following code shows the two possible solutions:</p>\n<pre><code># a new context mananger to set default session\nsess = tf.Session()\nwith tf.session_as_default(sess):\n    ...\nsess.close()\n\n# adding a flag to the as_default method\nsess = tf.Session()\nwith sess.as_default(keep_session=True):\n    ...\nwith sess.as_default():\n    ...\n# session closed\n</code></pre>", "body_text": "Describe the problem\nI find a scenario in which keeping a session alive (even after closing the context manager) is useful. Let's say that I have a method train(steps) that will train a model for the next steps iterations. Given the current API r1.9, I could think of no other way than to save and restore the session between method calls. That would incur a huge overhead indeed!\nI could think of two possible ways out:\n\nproviding an API to set a default session at will without automatically closing the session. It could come in a form of a context manager.\nadding a flag to the .as_default() method in tf.Session() to keep it alive after the context manager is closed.\n\nSource code / logs\nThe following code shows the hypothetical scenario.\nmodel = # some model\nmodel.train(100) # train for 100 iterations\n# default session should be None here (this rules out the usage of InteractiveSession)\nmodel.train(100) # train for another 100 iterations\n\nThe following code shows the two possible solutions:\n# a new context mananger to set default session\nsess = tf.Session()\nwith tf.session_as_default(sess):\n    ...\nsess.close()\n\n# adding a flag to the as_default method\nsess = tf.Session()\nwith sess.as_default(keep_session=True):\n    ...\nwith sess.as_default():\n    ...\n# session closed", "body": "### Describe the problem\r\nI find a scenario in which keeping a session alive (even after closing the context manager) is useful. Let's say that I have a method `train(steps)` that will train a model for the next `steps` iterations. Given the current API r1.9, I could think of no other way than to save and restore the session between method calls. That would incur a huge overhead indeed! \r\n\r\nI could think of two possible ways out:\r\n- providing an API to set a default session at will without automatically closing the session. It could come in a form of a context manager.\r\n- adding a flag to the `.as_default()` method in `tf.Session()` to keep it alive after the context manager is closed.\r\n\r\n### Source code / logs\r\nThe following code shows the hypothetical scenario.\r\n\r\n```\r\nmodel = # some model\r\nmodel.train(100) # train for 100 iterations\r\n# default session should be None here (this rules out the usage of InteractiveSession)\r\nmodel.train(100) # train for another 100 iterations\r\n```\r\n\r\nThe following code shows the two possible solutions:\r\n\r\n```\r\n# a new context mananger to set default session\r\nsess = tf.Session()\r\nwith tf.session_as_default(sess):\r\n    ...\r\nsess.close()\r\n\r\n# adding a flag to the as_default method\r\nsess = tf.Session()\r\nwith sess.as_default(keep_session=True):\r\n    ...\r\nwith sess.as_default():\r\n    ...\r\n# session closed\r\n```"}