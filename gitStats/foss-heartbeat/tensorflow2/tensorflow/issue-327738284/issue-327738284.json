{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/19647", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/19647/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/19647/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/19647/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/19647", "id": 327738284, "node_id": "MDU6SXNzdWUzMjc3MzgyODQ=", "number": 19647, "title": "TensorFlowInferenceInterface(\u00a0)\u00a0 in TensorFlowInferenceInterface\u00a0cannot be applied to (android.content.res.AssetManager, java", "user": {"login": "anjaanaadmi", "id": 16667847, "node_id": "MDQ6VXNlcjE2NjY3ODQ3", "avatar_url": "https://avatars1.githubusercontent.com/u/16667847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/anjaanaadmi", "html_url": "https://github.com/anjaanaadmi", "followers_url": "https://api.github.com/users/anjaanaadmi/followers", "following_url": "https://api.github.com/users/anjaanaadmi/following{/other_user}", "gists_url": "https://api.github.com/users/anjaanaadmi/gists{/gist_id}", "starred_url": "https://api.github.com/users/anjaanaadmi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/anjaanaadmi/subscriptions", "organizations_url": "https://api.github.com/users/anjaanaadmi/orgs", "repos_url": "https://api.github.com/users/anjaanaadmi/repos", "events_url": "https://api.github.com/users/anjaanaadmi/events{/privacy}", "received_events_url": "https://api.github.com/users/anjaanaadmi/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 386191887, "node_id": "MDU6TGFiZWwzODYxOTE4ODc=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:awaiting%20response", "name": "stat:awaiting response", "color": "f4b400", "default": false}], "state": "closed", "locked": false, "assignee": {"login": "robieta", "id": 13089297, "node_id": "MDQ6VXNlcjEzMDg5Mjk3", "avatar_url": "https://avatars0.githubusercontent.com/u/13089297?v=4", "gravatar_id": "", "url": "https://api.github.com/users/robieta", "html_url": "https://github.com/robieta", "followers_url": "https://api.github.com/users/robieta/followers", "following_url": "https://api.github.com/users/robieta/following{/other_user}", "gists_url": "https://api.github.com/users/robieta/gists{/gist_id}", "starred_url": "https://api.github.com/users/robieta/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/robieta/subscriptions", "organizations_url": "https://api.github.com/users/robieta/orgs", "repos_url": "https://api.github.com/users/robieta/repos", "events_url": "https://api.github.com/users/robieta/events{/privacy}", "received_events_url": "https://api.github.com/users/robieta/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "robieta", "id": 13089297, "node_id": "MDQ6VXNlcjEzMDg5Mjk3", "avatar_url": "https://avatars0.githubusercontent.com/u/13089297?v=4", "gravatar_id": "", "url": "https://api.github.com/users/robieta", "html_url": "https://github.com/robieta", "followers_url": "https://api.github.com/users/robieta/followers", "following_url": "https://api.github.com/users/robieta/following{/other_user}", "gists_url": "https://api.github.com/users/robieta/gists{/gist_id}", "starred_url": "https://api.github.com/users/robieta/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/robieta/subscriptions", "organizations_url": "https://api.github.com/users/robieta/orgs", "repos_url": "https://api.github.com/users/robieta/repos", "events_url": "https://api.github.com/users/robieta/events{/privacy}", "received_events_url": "https://api.github.com/users/robieta/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 4, "created_at": "2018-05-30T13:45:40Z", "updated_at": "2018-07-17T19:27:36Z", "closed_at": "2018-07-17T19:21:47Z", "author_association": "NONE", "body_html": "<p>package com.technicalshow.siraj.models;</p>\n<p>//Provides access to an application's raw asset files;<br>\nimport android.content.res.AssetManager;<br>\n//Reads text from a character-input stream, buffering characters so as to provide for the efficient reading of characters, arrays, and lines.<br>\nimport java.io.BufferedReader;<br>\n//for erros<br>\nimport java.io.IOException;<br>\n//An InputStreamReader is a bridge from byte streams to character streams:<br>\n// //It reads bytes and decodes them into characters using a specified charset.<br>\n// //The charset that it uses may be specified by name or may be given explicitly, or the platform's default charset may be accepted.<br>\nimport java.io.InputStreamReader;<br>\nimport java.util.ArrayList;<br>\nimport java.util.List;<br>\nimport java.lang.String;<br>\n//made by google, used as the window between android and tensorflow native C++<br>\nimport org.tensorflow.contrib.android.TensorFlowInferenceInterface;</p>\n<p>/**</p>\n<ul>\n<li>Changed from <a href=\"https://github.com/MindorksOpenSource/AndroidTensorFlowMNISTExample/blob/master\">https://github.com/MindorksOpenSource/AndroidTensorFlowMNISTExample/blob/master</a></li>\n<li>/app/src/main/java/com/mindorks/tensorflowexample/TensorFlowImageClassifier.java</li>\n<li>Created by marianne-linhares on 20/04/17.<br>\n*/</li>\n</ul>\n<p>//lets create this classifer<br>\npublic class TensorFlowClassifier implements Classifier {</p>\n<pre><code>// Only returns if at least this confidence\n//must be a classification percetnage greater than this\nprivate static final float THRESHOLD = 0.1f;\n\nprivate TensorFlowInferenceInterface tfHelper;\n\nprivate String name;\nprivate String inputName;\nprivate String outputName;\nprivate int inputSize;\nprivate boolean feedKeepProb;\n\nprivate List&lt;String&gt; labels;\nprivate float[] output;\nprivate String[] outputNames;\n\n//given a saved drawn model, lets read all the classification labels that are\n//stored and write them to our in memory labels list\nprivate static List&lt;String&gt; readLabels(AssetManager am, String fileName) throws IOException {\n    BufferedReader br = new BufferedReader(new InputStreamReader(am.open(fileName)));\n\n    String line;\n    List&lt;String&gt; labels = new ArrayList&lt;&gt;();\n    while ((line = br.readLine()) != null) {\n        labels.add(line);\n    }\n\n    br.close();\n    return labels;\n}\n</code></pre>\n<p>//given a model, its label file, and its metadata<br>\n//fill out a classifier object with all the necessary<br>\n//metadata including output prediction<br>\npublic static TensorFlowClassifier create(AssetManager assetManager, String name,<br>\nString modelPath, String labelFile, int inputSize, String inputName, String outputName,<br>\nboolean feedKeepProb) throws IOException {<br>\n//intialize a classifier<br>\nTensorFlowClassifier c = new TensorFlowClassifier();</p>\n<pre><code>    //store its name, input and output labels\n    c.name = name;\n\n    c.inputName = inputName;\n    c.outputName = outputName;\n\n    //read labels for label file\n    c.labels = readLabels(assetManager, labelFile);\n\n    //set its model path and where the raw asset files are\n    c.tfHelper = new TensorFlowInferenceInterface( assetManager, modelPath);\n    int numClasses = 10;\n\n    //how big is the input?\n    c.inputSize = inputSize;\n\n    // Pre-allocate buffer.\n    c.outputNames = new String[] { outputName };\n\n    c.outputName = outputName;\n    c.output = new float[numClasses];\n\n    c.feedKeepProb = feedKeepProb;\n\n    return c;\n}\n\n@Override\npublic String name() {\n    return name;\n}\n\n@Override\npublic Classification recognize(final float[] pixels) {\n\n    //using the interface\n    //give it the input name, raw pixels from the drawing,\n    //input size\n    tfHelper.addFeed(inputName, pixels, 1, inputSize, inputSize, 1);\n\n    //probabilities\n    if (feedKeepProb) {\n        tfHelper.addFeed(\"keep_prob\", new float[] { 1 });\n    }\n    //get the possible outputs\n    tfHelper.run(outputNames);\n\n    //get the output\n    tfHelper.fetch(outputName, output);\n\n    // Find the best classification\n    //for each output prediction\n    //if its above the threshold for accuracy we predefined\n    //write it out to the view\n    Classification ans = new Classification();\n    for (int i = 0; i &lt; output.length; ++i) {\n        System.out.println(output[i]);\n        System.out.println(labels.get(i));\n        if (output[i] &gt; THRESHOLD &amp;&amp; output[i] &gt; ans.getConf()) {\n            ans.update(output[i], labels.get(i));\n        }\n    }\n\n    return ans;\n}\n</code></pre>\n<p>}</p>", "body_text": "package com.technicalshow.siraj.models;\n//Provides access to an application's raw asset files;\nimport android.content.res.AssetManager;\n//Reads text from a character-input stream, buffering characters so as to provide for the efficient reading of characters, arrays, and lines.\nimport java.io.BufferedReader;\n//for erros\nimport java.io.IOException;\n//An InputStreamReader is a bridge from byte streams to character streams:\n// //It reads bytes and decodes them into characters using a specified charset.\n// //The charset that it uses may be specified by name or may be given explicitly, or the platform's default charset may be accepted.\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.lang.String;\n//made by google, used as the window between android and tensorflow native C++\nimport org.tensorflow.contrib.android.TensorFlowInferenceInterface;\n/**\n\nChanged from https://github.com/MindorksOpenSource/AndroidTensorFlowMNISTExample/blob/master\n/app/src/main/java/com/mindorks/tensorflowexample/TensorFlowImageClassifier.java\nCreated by marianne-linhares on 20/04/17.\n*/\n\n//lets create this classifer\npublic class TensorFlowClassifier implements Classifier {\n// Only returns if at least this confidence\n//must be a classification percetnage greater than this\nprivate static final float THRESHOLD = 0.1f;\n\nprivate TensorFlowInferenceInterface tfHelper;\n\nprivate String name;\nprivate String inputName;\nprivate String outputName;\nprivate int inputSize;\nprivate boolean feedKeepProb;\n\nprivate List<String> labels;\nprivate float[] output;\nprivate String[] outputNames;\n\n//given a saved drawn model, lets read all the classification labels that are\n//stored and write them to our in memory labels list\nprivate static List<String> readLabels(AssetManager am, String fileName) throws IOException {\n    BufferedReader br = new BufferedReader(new InputStreamReader(am.open(fileName)));\n\n    String line;\n    List<String> labels = new ArrayList<>();\n    while ((line = br.readLine()) != null) {\n        labels.add(line);\n    }\n\n    br.close();\n    return labels;\n}\n\n//given a model, its label file, and its metadata\n//fill out a classifier object with all the necessary\n//metadata including output prediction\npublic static TensorFlowClassifier create(AssetManager assetManager, String name,\nString modelPath, String labelFile, int inputSize, String inputName, String outputName,\nboolean feedKeepProb) throws IOException {\n//intialize a classifier\nTensorFlowClassifier c = new TensorFlowClassifier();\n    //store its name, input and output labels\n    c.name = name;\n\n    c.inputName = inputName;\n    c.outputName = outputName;\n\n    //read labels for label file\n    c.labels = readLabels(assetManager, labelFile);\n\n    //set its model path and where the raw asset files are\n    c.tfHelper = new TensorFlowInferenceInterface( assetManager, modelPath);\n    int numClasses = 10;\n\n    //how big is the input?\n    c.inputSize = inputSize;\n\n    // Pre-allocate buffer.\n    c.outputNames = new String[] { outputName };\n\n    c.outputName = outputName;\n    c.output = new float[numClasses];\n\n    c.feedKeepProb = feedKeepProb;\n\n    return c;\n}\n\n@Override\npublic String name() {\n    return name;\n}\n\n@Override\npublic Classification recognize(final float[] pixels) {\n\n    //using the interface\n    //give it the input name, raw pixels from the drawing,\n    //input size\n    tfHelper.addFeed(inputName, pixels, 1, inputSize, inputSize, 1);\n\n    //probabilities\n    if (feedKeepProb) {\n        tfHelper.addFeed(\"keep_prob\", new float[] { 1 });\n    }\n    //get the possible outputs\n    tfHelper.run(outputNames);\n\n    //get the output\n    tfHelper.fetch(outputName, output);\n\n    // Find the best classification\n    //for each output prediction\n    //if its above the threshold for accuracy we predefined\n    //write it out to the view\n    Classification ans = new Classification();\n    for (int i = 0; i < output.length; ++i) {\n        System.out.println(output[i]);\n        System.out.println(labels.get(i));\n        if (output[i] > THRESHOLD && output[i] > ans.getConf()) {\n            ans.update(output[i], labels.get(i));\n        }\n    }\n\n    return ans;\n}\n\n}", "body": "package com.technicalshow.siraj.models;\r\n\r\n\r\n//Provides access to an application's raw asset files;\r\nimport android.content.res.AssetManager;\r\n//Reads text from a character-input stream, buffering characters so as to provide for the efficient reading of characters, arrays, and lines.\r\nimport java.io.BufferedReader;\r\n//for erros\r\nimport java.io.IOException;\r\n//An InputStreamReader is a bridge from byte streams to character streams:\r\n// //It reads bytes and decodes them into characters using a specified charset.\r\n// //The charset that it uses may be specified by name or may be given explicitly, or the platform's default charset may be accepted.\r\nimport java.io.InputStreamReader;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.lang.String;\r\n//made by google, used as the window between android and tensorflow native C++\r\nimport org.tensorflow.contrib.android.TensorFlowInferenceInterface;\r\n\r\n/**\r\n * Changed from https://github.com/MindorksOpenSource/AndroidTensorFlowMNISTExample/blob/master\r\n * /app/src/main/java/com/mindorks/tensorflowexample/TensorFlowImageClassifier.java\r\n * Created by marianne-linhares on 20/04/17.\r\n */\r\n\r\n//lets create this classifer\r\npublic class TensorFlowClassifier implements Classifier {\r\n\r\n    // Only returns if at least this confidence\r\n    //must be a classification percetnage greater than this\r\n    private static final float THRESHOLD = 0.1f;\r\n\r\n    private TensorFlowInferenceInterface tfHelper;\r\n\r\n    private String name;\r\n    private String inputName;\r\n    private String outputName;\r\n    private int inputSize;\r\n    private boolean feedKeepProb;\r\n\r\n    private List<String> labels;\r\n    private float[] output;\r\n    private String[] outputNames;\r\n\r\n    //given a saved drawn model, lets read all the classification labels that are\r\n    //stored and write them to our in memory labels list\r\n    private static List<String> readLabels(AssetManager am, String fileName) throws IOException {\r\n        BufferedReader br = new BufferedReader(new InputStreamReader(am.open(fileName)));\r\n\r\n        String line;\r\n        List<String> labels = new ArrayList<>();\r\n        while ((line = br.readLine()) != null) {\r\n            labels.add(line);\r\n        }\r\n\r\n        br.close();\r\n        return labels;\r\n    }\r\n\r\n   //given a model, its label file, and its metadata\r\n    //fill out a classifier object with all the necessary\r\n    //metadata including output prediction\r\n    public static TensorFlowClassifier create(AssetManager assetManager, String name,\r\n            String modelPath, String labelFile, int inputSize, String inputName, String outputName,\r\n            boolean feedKeepProb) throws IOException {\r\n        //intialize a classifier\r\n        TensorFlowClassifier c = new TensorFlowClassifier();\r\n\r\n        //store its name, input and output labels\r\n        c.name = name;\r\n\r\n        c.inputName = inputName;\r\n        c.outputName = outputName;\r\n\r\n        //read labels for label file\r\n        c.labels = readLabels(assetManager, labelFile);\r\n\r\n        //set its model path and where the raw asset files are\r\n        c.tfHelper = new TensorFlowInferenceInterface( assetManager, modelPath);\r\n        int numClasses = 10;\r\n\r\n        //how big is the input?\r\n        c.inputSize = inputSize;\r\n\r\n        // Pre-allocate buffer.\r\n        c.outputNames = new String[] { outputName };\r\n\r\n        c.outputName = outputName;\r\n        c.output = new float[numClasses];\r\n\r\n        c.feedKeepProb = feedKeepProb;\r\n\r\n        return c;\r\n    }\r\n\r\n    @Override\r\n    public String name() {\r\n        return name;\r\n    }\r\n\r\n    @Override\r\n    public Classification recognize(final float[] pixels) {\r\n\r\n        //using the interface\r\n        //give it the input name, raw pixels from the drawing,\r\n        //input size\r\n        tfHelper.addFeed(inputName, pixels, 1, inputSize, inputSize, 1);\r\n\r\n        //probabilities\r\n        if (feedKeepProb) {\r\n            tfHelper.addFeed(\"keep_prob\", new float[] { 1 });\r\n        }\r\n        //get the possible outputs\r\n        tfHelper.run(outputNames);\r\n\r\n        //get the output\r\n        tfHelper.fetch(outputName, output);\r\n\r\n        // Find the best classification\r\n        //for each output prediction\r\n        //if its above the threshold for accuracy we predefined\r\n        //write it out to the view\r\n        Classification ans = new Classification();\r\n        for (int i = 0; i < output.length; ++i) {\r\n            System.out.println(output[i]);\r\n            System.out.println(labels.get(i));\r\n            if (output[i] > THRESHOLD && output[i] > ans.getConf()) {\r\n                ans.update(output[i], labels.get(i));\r\n            }\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n"}