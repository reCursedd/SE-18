{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13184", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13184/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13184/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13184/events", "html_url": "https://github.com/tensorflow/tensorflow/pull/13184", "id": 259190682, "node_id": "MDExOlB1bGxSZXF1ZXN0MTQyMTE5NTU5", "number": 13184, "title": "A fix for https://github.com/tensorflow/tensorflow/issues/13129", "user": {"login": "anight", "id": 1214641, "node_id": "MDQ6VXNlcjEyMTQ2NDE=", "avatar_url": "https://avatars3.githubusercontent.com/u/1214641?v=4", "gravatar_id": "", "url": "https://api.github.com/users/anight", "html_url": "https://github.com/anight", "followers_url": "https://api.github.com/users/anight/followers", "following_url": "https://api.github.com/users/anight/following{/other_user}", "gists_url": "https://api.github.com/users/anight/gists{/gist_id}", "starred_url": "https://api.github.com/users/anight/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/anight/subscriptions", "organizations_url": "https://api.github.com/users/anight/orgs", "repos_url": "https://api.github.com/users/anight/repos", "events_url": "https://api.github.com/users/anight/events{/privacy}", "received_events_url": "https://api.github.com/users/anight/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 300136587, "node_id": "MDU6TGFiZWwzMDAxMzY1ODc=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/cla:%20yes", "name": "cla: yes", "color": "009800", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2017-09-20T14:46:13Z", "updated_at": "2017-09-20T14:48:30Z", "closed_at": "2017-09-20T14:47:17Z", "author_association": "CONTRIBUTOR", "pull_request": {"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/13184", "html_url": "https://github.com/tensorflow/tensorflow/pull/13184", "diff_url": "https://github.com/tensorflow/tensorflow/pull/13184.diff", "patch_url": "https://github.com/tensorflow/tensorflow/pull/13184.patch"}, "body_html": "<p>The problem was with usage of runtime.SetFinalizer() in golang bindings. When a variable become unreferenced GC can harvest it any moment after. According to this <a href=\"https://tip.golang.org/pkg/runtime/#SetFinalizer\" rel=\"nofollow\">https://tip.golang.org/pkg/runtime/#SetFinalizer</a>:</p>\n<blockquote>\n<p>For example, if p points to a struct that contains a file descriptor d, and p has a finalizer that closes that file descriptor, and if the last use of p in a function is a call to syscall.Write(p.d, buf, size), then p may be unreachable as soon as the program enters syscall.Write. The finalizer may run at that moment, closing p.d, causing syscall.Write to fail because it is writing to a closed file descriptor (or, worse, to an entirely different file descriptor opened by a different goroutine). To avoid this problem, call runtime.KeepAlive(p) after the call to syscall.Write.</p>\n</blockquote>\n<p>In our case unreferenced variable was \"feeds\", i.e. input tensors. After investigations I found out that func (t *Tensor) finalize() was called a way before SessionRun() was finished and that was the cause of crash.</p>", "body_text": "The problem was with usage of runtime.SetFinalizer() in golang bindings. When a variable become unreferenced GC can harvest it any moment after. According to this https://tip.golang.org/pkg/runtime/#SetFinalizer:\n\nFor example, if p points to a struct that contains a file descriptor d, and p has a finalizer that closes that file descriptor, and if the last use of p in a function is a call to syscall.Write(p.d, buf, size), then p may be unreachable as soon as the program enters syscall.Write. The finalizer may run at that moment, closing p.d, causing syscall.Write to fail because it is writing to a closed file descriptor (or, worse, to an entirely different file descriptor opened by a different goroutine). To avoid this problem, call runtime.KeepAlive(p) after the call to syscall.Write.\n\nIn our case unreferenced variable was \"feeds\", i.e. input tensors. After investigations I found out that func (t *Tensor) finalize() was called a way before SessionRun() was finished and that was the cause of crash.", "body": "The problem was with usage of runtime.SetFinalizer() in golang bindings. When a variable become unreferenced GC can harvest it any moment after. According to this https://tip.golang.org/pkg/runtime/#SetFinalizer:\r\n\r\n> For example, if p points to a struct that contains a file descriptor d, and p has a finalizer that closes that file descriptor, and if the last use of p in a function is a call to syscall.Write(p.d, buf, size), then p may be unreachable as soon as the program enters syscall.Write. The finalizer may run at that moment, closing p.d, causing syscall.Write to fail because it is writing to a closed file descriptor (or, worse, to an entirely different file descriptor opened by a different goroutine). To avoid this problem, call runtime.KeepAlive(p) after the call to syscall.Write.\r\n\r\nIn our case unreferenced variable was \"feeds\", i.e. input tensors. After investigations I found out that func (t *Tensor) finalize() was called a way before SessionRun() was finished and that was the cause of crash.\r\n\r\n\r\n"}