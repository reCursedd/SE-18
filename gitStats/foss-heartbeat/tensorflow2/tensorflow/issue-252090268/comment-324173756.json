{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/324173756", "html_url": "https://github.com/tensorflow/tensorflow/issues/12501#issuecomment-324173756", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/12501", "id": 324173756, "node_id": "MDEyOklzc3VlQ29tbWVudDMyNDE3Mzc1Ng==", "user": {"login": "rasitsimsek", "id": 30691148, "node_id": "MDQ6VXNlcjMwNjkxMTQ4", "avatar_url": "https://avatars1.githubusercontent.com/u/30691148?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rasitsimsek", "html_url": "https://github.com/rasitsimsek", "followers_url": "https://api.github.com/users/rasitsimsek/followers", "following_url": "https://api.github.com/users/rasitsimsek/following{/other_user}", "gists_url": "https://api.github.com/users/rasitsimsek/gists{/gist_id}", "starred_url": "https://api.github.com/users/rasitsimsek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rasitsimsek/subscriptions", "organizations_url": "https://api.github.com/users/rasitsimsek/orgs", "repos_url": "https://api.github.com/users/rasitsimsek/repos", "events_url": "https://api.github.com/users/rasitsimsek/events{/privacy}", "received_events_url": "https://api.github.com/users/rasitsimsek/received_events", "type": "User", "site_admin": false}, "created_at": "2017-08-22T22:54:07Z", "updated_at": "2017-08-22T22:54:07Z", "author_association": "NONE", "body_html": "<p>I have figured out that the crash occurs  in ClientSessionRun::Run() method. The reason is the Output object in fetch_outputs vector is not correctly installed. The Node member of Output is null. This causes an exception at <strong>output_tensor_names.push_back(output.name());</strong></p>\n<pre><code>Status ClientSession::Run(const RunOptions&amp; run_options, const FeedType&amp; inputs,\n                          const std::vector&lt;Output&gt;&amp; fetch_outputs,\n                          const std::vector&lt;Operation&gt;&amp; run_outputs,\n                          std::vector&lt;Tensor&gt;* outputs,\n                          RunMetadata* run_metadata) const {\n  std::vector&lt;std::pair&lt;string, Tensor&gt;&gt; feeds;\n  for (auto const&amp; feed : inputs) {\n    TF_RETURN_IF_ERROR(feed.second.status);\n    feeds.emplace_back(feed.first.name(), feed.second.tensor);\n  }\n  std::vector&lt;string&gt; output_tensor_names;\n  output_tensor_names.reserve(fetch_outputs.size());\n  for (auto const&amp; output : fetch_outputs) {\n    output_tensor_names.push_back(output.name());\n  }\n  std::vector&lt;string&gt; target_node_names;\n  target_node_names.reserve(run_outputs.size());\n  for (auto const&amp; output : run_outputs) {\n    target_node_names.push_back(output.node()-&gt;name());\n  }\n  TF_RETURN_IF_ERROR(impl()-&gt;MaybeExtendGraph());\n  return impl()-&gt;session_-&gt;Run(run_options, feeds, output_tensor_names,\n                               target_node_names, outputs, run_metadata);\n}\n</code></pre>\n<p>As I see the default Output object initializes the node member <strong>op_</strong> with null. The question is how the Output should be initialized? The documentation says it will be filled automatically. Is this not a discrepancy?</p>\n<pre><code>\n/// Represents a tensor value produced by an Operation.\nclass Output {\n public:\n  Output() = default;\n  explicit Output(Node* n) : op_(n) {}\n  Output(Node* n, int32 index) : op_(n), index_(index) {}\n  Output(const Operation&amp; op, int32 index) : op_(op), index_(index) {}\n\n  Operation op() const { return op_; }\n  Node* node() const { return op().node(); }\n  int32 index() const { return index_; }\n  DataType type() const { return op_.output_type(index_); }\n  string name() const { return strings::StrCat(node()-&gt;name(), \":\", index()); }\n  bool operator==(const Output&amp; other) const {\n    return op_ == other.op_ &amp;&amp; index_ == other.index_;\n  }\n\n  uint64 hash() const { return op_.hash(index_); }\n\n private:\n  Operation op_ = Operation(nullptr);\n  int32 index_ = 0;\n};\n\n</code></pre>", "body_text": "I have figured out that the crash occurs  in ClientSessionRun::Run() method. The reason is the Output object in fetch_outputs vector is not correctly installed. The Node member of Output is null. This causes an exception at output_tensor_names.push_back(output.name());\nStatus ClientSession::Run(const RunOptions& run_options, const FeedType& inputs,\n                          const std::vector<Output>& fetch_outputs,\n                          const std::vector<Operation>& run_outputs,\n                          std::vector<Tensor>* outputs,\n                          RunMetadata* run_metadata) const {\n  std::vector<std::pair<string, Tensor>> feeds;\n  for (auto const& feed : inputs) {\n    TF_RETURN_IF_ERROR(feed.second.status);\n    feeds.emplace_back(feed.first.name(), feed.second.tensor);\n  }\n  std::vector<string> output_tensor_names;\n  output_tensor_names.reserve(fetch_outputs.size());\n  for (auto const& output : fetch_outputs) {\n    output_tensor_names.push_back(output.name());\n  }\n  std::vector<string> target_node_names;\n  target_node_names.reserve(run_outputs.size());\n  for (auto const& output : run_outputs) {\n    target_node_names.push_back(output.node()->name());\n  }\n  TF_RETURN_IF_ERROR(impl()->MaybeExtendGraph());\n  return impl()->session_->Run(run_options, feeds, output_tensor_names,\n                               target_node_names, outputs, run_metadata);\n}\n\nAs I see the default Output object initializes the node member op_ with null. The question is how the Output should be initialized? The documentation says it will be filled automatically. Is this not a discrepancy?\n\n/// Represents a tensor value produced by an Operation.\nclass Output {\n public:\n  Output() = default;\n  explicit Output(Node* n) : op_(n) {}\n  Output(Node* n, int32 index) : op_(n), index_(index) {}\n  Output(const Operation& op, int32 index) : op_(op), index_(index) {}\n\n  Operation op() const { return op_; }\n  Node* node() const { return op().node(); }\n  int32 index() const { return index_; }\n  DataType type() const { return op_.output_type(index_); }\n  string name() const { return strings::StrCat(node()->name(), \":\", index()); }\n  bool operator==(const Output& other) const {\n    return op_ == other.op_ && index_ == other.index_;\n  }\n\n  uint64 hash() const { return op_.hash(index_); }\n\n private:\n  Operation op_ = Operation(nullptr);\n  int32 index_ = 0;\n};", "body": "I have figured out that the crash occurs  in ClientSessionRun::Run() method. The reason is the Output object in fetch_outputs vector is not correctly installed. The Node member of Output is null. This causes an exception at **output_tensor_names.push_back(output.name());**\r\n\r\n```\r\nStatus ClientSession::Run(const RunOptions& run_options, const FeedType& inputs,\r\n                          const std::vector<Output>& fetch_outputs,\r\n                          const std::vector<Operation>& run_outputs,\r\n                          std::vector<Tensor>* outputs,\r\n                          RunMetadata* run_metadata) const {\r\n  std::vector<std::pair<string, Tensor>> feeds;\r\n  for (auto const& feed : inputs) {\r\n    TF_RETURN_IF_ERROR(feed.second.status);\r\n    feeds.emplace_back(feed.first.name(), feed.second.tensor);\r\n  }\r\n  std::vector<string> output_tensor_names;\r\n  output_tensor_names.reserve(fetch_outputs.size());\r\n  for (auto const& output : fetch_outputs) {\r\n    output_tensor_names.push_back(output.name());\r\n  }\r\n  std::vector<string> target_node_names;\r\n  target_node_names.reserve(run_outputs.size());\r\n  for (auto const& output : run_outputs) {\r\n    target_node_names.push_back(output.node()->name());\r\n  }\r\n  TF_RETURN_IF_ERROR(impl()->MaybeExtendGraph());\r\n  return impl()->session_->Run(run_options, feeds, output_tensor_names,\r\n                               target_node_names, outputs, run_metadata);\r\n}\r\n```\r\n\r\nAs I see the default Output object initializes the node member **op_** with null. The question is how the Output should be initialized? The documentation says it will be filled automatically. Is this not a discrepancy? \r\n\r\n```\r\n\r\n/// Represents a tensor value produced by an Operation.\r\nclass Output {\r\n public:\r\n  Output() = default;\r\n  explicit Output(Node* n) : op_(n) {}\r\n  Output(Node* n, int32 index) : op_(n), index_(index) {}\r\n  Output(const Operation& op, int32 index) : op_(op), index_(index) {}\r\n\r\n  Operation op() const { return op_; }\r\n  Node* node() const { return op().node(); }\r\n  int32 index() const { return index_; }\r\n  DataType type() const { return op_.output_type(index_); }\r\n  string name() const { return strings::StrCat(node()->name(), \":\", index()); }\r\n  bool operator==(const Output& other) const {\r\n    return op_ == other.op_ && index_ == other.index_;\r\n  }\r\n\r\n  uint64 hash() const { return op_.hash(index_); }\r\n\r\n private:\r\n  Operation op_ = Operation(nullptr);\r\n  int32 index_ = 0;\r\n};\r\n\r\n```"}