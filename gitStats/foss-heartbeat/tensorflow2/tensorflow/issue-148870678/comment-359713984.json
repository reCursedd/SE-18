{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/359713984", "html_url": "https://github.com/tensorflow/tensorflow/issues/1984#issuecomment-359713984", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/1984", "id": 359713984, "node_id": "MDEyOklzc3VlQ29tbWVudDM1OTcxMzk4NA==", "user": {"login": "mholzel", "id": 7227349, "node_id": "MDQ6VXNlcjcyMjczNDk=", "avatar_url": "https://avatars0.githubusercontent.com/u/7227349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mholzel", "html_url": "https://github.com/mholzel", "followers_url": "https://api.github.com/users/mholzel/followers", "following_url": "https://api.github.com/users/mholzel/following{/other_user}", "gists_url": "https://api.github.com/users/mholzel/gists{/gist_id}", "starred_url": "https://api.github.com/users/mholzel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mholzel/subscriptions", "organizations_url": "https://api.github.com/users/mholzel/orgs", "repos_url": "https://api.github.com/users/mholzel/repos", "events_url": "https://api.github.com/users/mholzel/events{/privacy}", "received_events_url": "https://api.github.com/users/mholzel/received_events", "type": "User", "site_admin": false}, "created_at": "2018-01-23T08:27:58Z", "updated_at": "2018-01-23T08:31:48Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=2342391\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/yuanbyu\">@yuanbyu</a> I believe your comment should be directly put into the documentation. Specifically, the following should be added:</p>\n<blockquote>\n<p>while_loop implements non-strict semantics. An iteration can start as soon as one of the ops for this iteration is ready (i.e., all its inputs are available.) for execution. So a while_loop can easily have multiple iterations running in parallel.</p>\n</blockquote>\n<p>However, I think you meant to say \"(i.e., NOT all its inputs are available.)\".</p>\n<p>Also, it would be useful to know if these semantics depend on the order of the inputs or not.  For instance, suppose we want to run some function <code>f(x)</code> 10 times. If the argument order is important for  non-strict semantics, then the first example cannot run in parallel because the iteration counter is holding everything up, while the second version should indeed run in parallel:</p>\n<pre><code>i = tf.constant(0) \nx = ... \ncond1 = lambda i, x: tf.less(i, 10) \ndef body1(i, x):\n       y = f(x)\n       return i+1, y  \ntf.while_loop(cond1, body1, [i, x])\n\ncond2 = lambda x,i: tf.less(i, 10) \ndef body2(x,i):\n       y = f(x)\n       return y, i+1\ntf.while_loop(cond2, body2, [x,i])\n\n</code></pre>\n<p>In any event, I feel that such a discussion should definitely be included in the docs since there is no real discussion around the canonical \"for loop\" implementation that is provided:</p>\n<blockquote>\n<p>python i = tf.constant(0) c = lambda i: tf.less(i, 10) b = lambda i: tf.add(i, 1) r = tf.while_loop(c, b, [i])</p>\n</blockquote>", "body_text": "@yuanbyu I believe your comment should be directly put into the documentation. Specifically, the following should be added:\n\nwhile_loop implements non-strict semantics. An iteration can start as soon as one of the ops for this iteration is ready (i.e., all its inputs are available.) for execution. So a while_loop can easily have multiple iterations running in parallel.\n\nHowever, I think you meant to say \"(i.e., NOT all its inputs are available.)\".\nAlso, it would be useful to know if these semantics depend on the order of the inputs or not.  For instance, suppose we want to run some function f(x) 10 times. If the argument order is important for  non-strict semantics, then the first example cannot run in parallel because the iteration counter is holding everything up, while the second version should indeed run in parallel:\ni = tf.constant(0) \nx = ... \ncond1 = lambda i, x: tf.less(i, 10) \ndef body1(i, x):\n       y = f(x)\n       return i+1, y  \ntf.while_loop(cond1, body1, [i, x])\n\ncond2 = lambda x,i: tf.less(i, 10) \ndef body2(x,i):\n       y = f(x)\n       return y, i+1\ntf.while_loop(cond2, body2, [x,i])\n\n\nIn any event, I feel that such a discussion should definitely be included in the docs since there is no real discussion around the canonical \"for loop\" implementation that is provided:\n\npython i = tf.constant(0) c = lambda i: tf.less(i, 10) b = lambda i: tf.add(i, 1) r = tf.while_loop(c, b, [i])", "body": "@yuanbyu I believe your comment should be directly put into the documentation. Specifically, the following should be added:\r\n\r\n> while_loop implements non-strict semantics. An iteration can start as soon as one of the ops for this iteration is ready (i.e., all its inputs are available.) for execution. So a while_loop can easily have multiple iterations running in parallel.  \r\n\r\nHowever, I think you meant to say \"(i.e., NOT all its inputs are available.)\". \r\n\r\nAlso, it would be useful to know if these semantics depend on the order of the inputs or not.  For instance, suppose we want to run some function `f(x)` 10 times. If the argument order is important for  non-strict semantics, then the first example cannot run in parallel because the iteration counter is holding everything up, while the second version should indeed run in parallel:\r\n\r\n```\r\ni = tf.constant(0) \r\nx = ... \r\ncond1 = lambda i, x: tf.less(i, 10) \r\ndef body1(i, x):\r\n       y = f(x)\r\n       return i+1, y  \r\ntf.while_loop(cond1, body1, [i, x])\r\n\r\ncond2 = lambda x,i: tf.less(i, 10) \r\ndef body2(x,i):\r\n       y = f(x)\r\n       return y, i+1\r\ntf.while_loop(cond2, body2, [x,i])\r\n\r\n```\r\n\r\nIn any event, I feel that such a discussion should definitely be included in the docs since there is no real discussion around the canonical \"for loop\" implementation that is provided:\r\n\r\n> python i = tf.constant(0) c = lambda i: tf.less(i, 10) b = lambda i: tf.add(i, 1) r = tf.while_loop(c, b, [i])\r\n"}