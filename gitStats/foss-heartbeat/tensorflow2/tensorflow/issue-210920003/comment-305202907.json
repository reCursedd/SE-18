{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/305202907", "html_url": "https://github.com/tensorflow/tensorflow/issues/7951#issuecomment-305202907", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/7951", "id": 305202907, "node_id": "MDEyOklzc3VlQ29tbWVudDMwNTIwMjkwNw==", "user": {"login": "maxfiedler", "id": 4192637, "node_id": "MDQ6VXNlcjQxOTI2Mzc=", "avatar_url": "https://avatars1.githubusercontent.com/u/4192637?v=4", "gravatar_id": "", "url": "https://api.github.com/users/maxfiedler", "html_url": "https://github.com/maxfiedler", "followers_url": "https://api.github.com/users/maxfiedler/followers", "following_url": "https://api.github.com/users/maxfiedler/following{/other_user}", "gists_url": "https://api.github.com/users/maxfiedler/gists{/gist_id}", "starred_url": "https://api.github.com/users/maxfiedler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/maxfiedler/subscriptions", "organizations_url": "https://api.github.com/users/maxfiedler/orgs", "repos_url": "https://api.github.com/users/maxfiedler/repos", "events_url": "https://api.github.com/users/maxfiedler/events{/privacy}", "received_events_url": "https://api.github.com/users/maxfiedler/received_events", "type": "User", "site_admin": false}, "created_at": "2017-05-31T14:24:59Z", "updated_at": "2017-05-31T14:30:38Z", "author_association": "NONE", "body_html": "<p>I am only starting to read into the new API, but I want to share two problems that I had with the old Input Queues in concurrence with using MonitoredSession with SessionRunHooks.<br>\nWe also used two separate queues, one handling input data_files as string names and the other one the resulting input data with preprocessing being done in between those two.<br>\nWe needed to make sure that the enqueue operations fills at least a certain multiple of the batch size into the first queue for our code to run without problems (otherwise the second input queue stalled)<br>\nLooking something like this</p>\n<pre><code>queue_size_train = sess.run([ipc.train.rsq_pre_size)\n            while queue_size_train &lt;= batch_size * 5:\n                sess.run([ipc.train.rsq_pre_enq],\n                         feed_dict={ipc.train.ph_in: dataset.train.inputs,\n                                    ipc.train.ph_tgt: dataset.train.targets})\n                queue_size_train = sess.run([ipc.train.rsq_pre_size])[0]\n</code></pre>\n<p>Now when I switched from a normal Session to using MonitoredSession and added a logging hook and told it to log the 'accuracy' tensor, it tried in vain to evaluate the first session run call as the hook had added that tensor to the fetch list, but with the queue being still empty there was no way to evaluate accuracy yet.<br>\nProblematic was that the program just stopped and waited for some process to begin filling the queue, but there was non, so it just did nothing, but also didn't throw an exception or give any kind of warning, which made understanding what was happening a bit difficult.<br>\nThe problem was eventually easily solved just executing one enqueue operation as the very first sess.run() call within the <code>with MonitoredSession(...) as sess:</code> block, but it would be nice if e.g. the input queues could be pre-filled with some initial values upon creation, so that this issue doesn't arise.</p>\n<p>Aside from that, we use two different input pipelines for training and validation data that we connect to the network part of our graph alternating through a switch implemented through <code>tf.QueueBase.from_list</code>.<br>\nNow in the <code>with ... as sess:</code> block you can easily implement an if block which pipeline to choose based on <code>global_step % interval == 0</code> but that means copy pasting the same code (sess.run() and add_summary() calls) times the number of different input pipelines you use (e.g. train, validation_1, validation_2, ...)<br>\nIt would be nice to integrate this directly into MonitoredSession using Hooks somehow (i.e. every 10th step create and save summaries using validation_1 input pipeline, every 25th step ...)</p>", "body_text": "I am only starting to read into the new API, but I want to share two problems that I had with the old Input Queues in concurrence with using MonitoredSession with SessionRunHooks.\nWe also used two separate queues, one handling input data_files as string names and the other one the resulting input data with preprocessing being done in between those two.\nWe needed to make sure that the enqueue operations fills at least a certain multiple of the batch size into the first queue for our code to run without problems (otherwise the second input queue stalled)\nLooking something like this\nqueue_size_train = sess.run([ipc.train.rsq_pre_size)\n            while queue_size_train <= batch_size * 5:\n                sess.run([ipc.train.rsq_pre_enq],\n                         feed_dict={ipc.train.ph_in: dataset.train.inputs,\n                                    ipc.train.ph_tgt: dataset.train.targets})\n                queue_size_train = sess.run([ipc.train.rsq_pre_size])[0]\n\nNow when I switched from a normal Session to using MonitoredSession and added a logging hook and told it to log the 'accuracy' tensor, it tried in vain to evaluate the first session run call as the hook had added that tensor to the fetch list, but with the queue being still empty there was no way to evaluate accuracy yet.\nProblematic was that the program just stopped and waited for some process to begin filling the queue, but there was non, so it just did nothing, but also didn't throw an exception or give any kind of warning, which made understanding what was happening a bit difficult.\nThe problem was eventually easily solved just executing one enqueue operation as the very first sess.run() call within the with MonitoredSession(...) as sess: block, but it would be nice if e.g. the input queues could be pre-filled with some initial values upon creation, so that this issue doesn't arise.\nAside from that, we use two different input pipelines for training and validation data that we connect to the network part of our graph alternating through a switch implemented through tf.QueueBase.from_list.\nNow in the with ... as sess: block you can easily implement an if block which pipeline to choose based on global_step % interval == 0 but that means copy pasting the same code (sess.run() and add_summary() calls) times the number of different input pipelines you use (e.g. train, validation_1, validation_2, ...)\nIt would be nice to integrate this directly into MonitoredSession using Hooks somehow (i.e. every 10th step create and save summaries using validation_1 input pipeline, every 25th step ...)", "body": "I am only starting to read into the new API, but I want to share two problems that I had with the old Input Queues in concurrence with using MonitoredSession with SessionRunHooks. \r\nWe also used two separate queues, one handling input data_files as string names and the other one the resulting input data with preprocessing being done in between those two. \r\nWe needed to make sure that the enqueue operations fills at least a certain multiple of the batch size into the first queue for our code to run without problems (otherwise the second input queue stalled)\r\nLooking something like this \r\n```\r\nqueue_size_train = sess.run([ipc.train.rsq_pre_size)\r\n            while queue_size_train <= batch_size * 5:\r\n                sess.run([ipc.train.rsq_pre_enq],\r\n                         feed_dict={ipc.train.ph_in: dataset.train.inputs,\r\n                                    ipc.train.ph_tgt: dataset.train.targets})\r\n                queue_size_train = sess.run([ipc.train.rsq_pre_size])[0]\r\n```\r\n\r\nNow when I switched from a normal Session to using MonitoredSession and added a logging hook and told it to log the 'accuracy' tensor, it tried in vain to evaluate the first session run call as the hook had added that tensor to the fetch list, but with the queue being still empty there was no way to evaluate accuracy yet. \r\nProblematic was that the program just stopped and waited for some process to begin filling the queue, but there was non, so it just did nothing, but also didn't throw an exception or give any kind of warning, which made understanding what was happening a bit difficult. \r\nThe problem was eventually easily solved just executing one enqueue operation as the very first sess.run() call within the `with MonitoredSession(...) as sess:` block, but it would be nice if e.g. the input queues could be pre-filled with some initial values upon creation, so that this issue doesn't arise. \r\n\r\nAside from that, we use two different input pipelines for training and validation data that we connect to the network part of our graph alternating through a switch implemented through `tf.QueueBase.from_list`.\r\nNow in the `with ... as sess:` block you can easily implement an if block which pipeline to choose based on `global_step % interval == 0` but that means copy pasting the same code (sess.run() and add_summary() calls) times the number of different input pipelines you use (e.g. train, validation_1, validation_2, ...) \r\nIt would be nice to integrate this directly into MonitoredSession using Hooks somehow (i.e. every 10th step create and save summaries using validation_1 input pipeline, every 25th step ...)"}