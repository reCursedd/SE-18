{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/264720493", "html_url": "https://github.com/tensorflow/tensorflow/issues/781#issuecomment-264720493", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/781", "id": 264720493, "node_id": "MDEyOklzc3VlQ29tbWVudDI2NDcyMDQ5Mw==", "user": {"login": "ringw", "id": 1391644, "node_id": "MDQ6VXNlcjEzOTE2NDQ=", "avatar_url": "https://avatars1.githubusercontent.com/u/1391644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ringw", "html_url": "https://github.com/ringw", "followers_url": "https://api.github.com/users/ringw/followers", "following_url": "https://api.github.com/users/ringw/following{/other_user}", "gists_url": "https://api.github.com/users/ringw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ringw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ringw/subscriptions", "organizations_url": "https://api.github.com/users/ringw/orgs", "repos_url": "https://api.github.com/users/ringw/repos", "events_url": "https://api.github.com/users/ringw/events{/privacy}", "received_events_url": "https://api.github.com/users/ringw/received_events", "type": "User", "site_admin": false}, "created_at": "2016-12-04T18:19:22Z", "updated_at": "2016-12-04T18:19:22Z", "author_association": "MEMBER", "body_html": "<p>I think a 3x3 projective matrix will allow for translation (x, y translation are in the third column). The image tensor will always have to be 4D to disambiguate between multiple batches or multiple channels, but you can have 1 or more channels and the transformation will be applied to just the x, y coordinates, not the channels (the channels in each image have the same transform applied to them).</p>\n<p>Here's the documentation for the new op (it will support interpolation and custom output sizes in a follow-up):</p>\n<blockquote>\n<p>Applies the given transform to each of the images.</p>\n<p>Input <code>image</code> is a <code>Tensor</code> of rank 4, where the axes are image number, rows,<br>\ncolumns, and channels. Input <code>transforms</code> is a num_images x 8 or 1 x 8 matrix,<br>\nwhere each row corresponds to a 3 x 3 projective transformation matrix, with the<br>\nlast entry assumed to be 1. If there is one row, the same transformation will be<br>\napplied to all images.</p>\n<p>If the passed-in transform is <code>(a0, a1, a2, b0, b1, b2, c0, c1)</code>, then it maps<br>\nthe <em>output</em> point <code>(x, y)</code> to a transformed <em>input</em> point<br>\n<code>(x', y') = ((a0 x + a1 y + a2) / k, (b0 x + b1 y + b2) / k)</code>, where<br>\n<code>k = c0 x + c1 y + 1</code>. If the transformed point lays outside of the input<br>\nimage, the output pixel is set to 0.</p>\n<p>images: 4D <code>Tensor</code>, input image(s).</p>\n<p>transforms: 2D <code>Tensor</code>, projective transform(s) to apply to the image(s).</p>\n</blockquote>\n<p>tf.contrib.image.rotate will be a convenience wrapper that takes a 1D tensor of angles, and passes the corresponding rotation matrices to the op.</p>", "body_text": "I think a 3x3 projective matrix will allow for translation (x, y translation are in the third column). The image tensor will always have to be 4D to disambiguate between multiple batches or multiple channels, but you can have 1 or more channels and the transformation will be applied to just the x, y coordinates, not the channels (the channels in each image have the same transform applied to them).\nHere's the documentation for the new op (it will support interpolation and custom output sizes in a follow-up):\n\nApplies the given transform to each of the images.\nInput image is a Tensor of rank 4, where the axes are image number, rows,\ncolumns, and channels. Input transforms is a num_images x 8 or 1 x 8 matrix,\nwhere each row corresponds to a 3 x 3 projective transformation matrix, with the\nlast entry assumed to be 1. If there is one row, the same transformation will be\napplied to all images.\nIf the passed-in transform is (a0, a1, a2, b0, b1, b2, c0, c1), then it maps\nthe output point (x, y) to a transformed input point\n(x', y') = ((a0 x + a1 y + a2) / k, (b0 x + b1 y + b2) / k), where\nk = c0 x + c1 y + 1. If the transformed point lays outside of the input\nimage, the output pixel is set to 0.\nimages: 4D Tensor, input image(s).\ntransforms: 2D Tensor, projective transform(s) to apply to the image(s).\n\ntf.contrib.image.rotate will be a convenience wrapper that takes a 1D tensor of angles, and passes the corresponding rotation matrices to the op.", "body": "I think a 3x3 projective matrix will allow for translation (x, y translation are in the third column). The image tensor will always have to be 4D to disambiguate between multiple batches or multiple channels, but you can have 1 or more channels and the transformation will be applied to just the x, y coordinates, not the channels (the channels in each image have the same transform applied to them).\r\n\r\nHere's the documentation for the new op (it will support interpolation and custom output sizes in a follow-up):\r\n\r\n> Applies the given transform to each of the images.\r\n>\r\n> Input `image` is a `Tensor` of rank 4, where the axes are image number, rows,\r\ncolumns, and channels. Input `transforms` is a num_images x 8 or 1 x 8 matrix,\r\nwhere each row corresponds to a 3 x 3 projective transformation matrix, with the\r\nlast entry assumed to be 1. If there is one row, the same transformation will be\r\napplied to all images.\r\n>\r\n> If the passed-in transform is `(a0, a1, a2, b0, b1, b2, c0, c1)`, then it maps\r\nthe *output* point `(x, y)` to a transformed *input* point\r\n`(x', y') = ((a0 x + a1 y + a2) / k, (b0 x + b1 y + b2) / k)`, where\r\n`k = c0 x + c1 y + 1`. If the transformed point lays outside of the input\r\nimage, the output pixel is set to 0.\r\n>\r\n> images: 4D `Tensor`, input image(s).\r\n>\r\n> transforms: 2D `Tensor`, projective transform(s) to apply to the image(s).\r\n\r\ntf.contrib.image.rotate will be a convenience wrapper that takes a 1D tensor of angles, and passes the corresponding rotation matrices to the op."}