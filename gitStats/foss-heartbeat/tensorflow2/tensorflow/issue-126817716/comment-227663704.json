{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/227663704", "html_url": "https://github.com/tensorflow/tensorflow/issues/781#issuecomment-227663704", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/781", "id": 227663704, "node_id": "MDEyOklzc3VlQ29tbWVudDIyNzY2MzcwNA==", "user": {"login": "alexatknit", "id": 15474222, "node_id": "MDQ6VXNlcjE1NDc0MjIy", "avatar_url": "https://avatars2.githubusercontent.com/u/15474222?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexatknit", "html_url": "https://github.com/alexatknit", "followers_url": "https://api.github.com/users/alexatknit/followers", "following_url": "https://api.github.com/users/alexatknit/following{/other_user}", "gists_url": "https://api.github.com/users/alexatknit/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexatknit/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexatknit/subscriptions", "organizations_url": "https://api.github.com/users/alexatknit/orgs", "repos_url": "https://api.github.com/users/alexatknit/repos", "events_url": "https://api.github.com/users/alexatknit/events{/privacy}", "received_events_url": "https://api.github.com/users/alexatknit/received_events", "type": "User", "site_admin": false}, "created_at": "2016-06-22T07:23:00Z", "updated_at": "2016-06-23T18:05:56Z", "author_association": "NONE", "body_html": "<p>I haven't written C++ code in a few years but I threw this together because this is the op I need, it should do the trick. I might throw together a cuda kernel at some point if I have the time.</p>\n<div class=\"highlight highlight-source-c++\"><pre>#<span class=\"pl-k\">define</span> <span class=\"pl-en\">EIGEN_USE_THREADS</span>\n\n#<span class=\"pl-k\">include</span> <span class=\"pl-s\"><span class=\"pl-pds\">&lt;</span>algorithm<span class=\"pl-pds\">&gt;</span></span>\n#<span class=\"pl-k\">include</span> <span class=\"pl-s\"><span class=\"pl-pds\">&lt;</span>memory<span class=\"pl-pds\">&gt;</span></span>\n#<span class=\"pl-k\">include</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>third_party/eigen3/unsupported/Eigen/CXX11/Tensor<span class=\"pl-pds\">\"</span></span>\n#<span class=\"pl-k\">include</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>tensorflow/core/framework/op.h<span class=\"pl-pds\">\"</span></span>\n#<span class=\"pl-k\">include</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>tensorflow/core/framework/op_kernel.h<span class=\"pl-pds\">\"</span></span>\n#<span class=\"pl-k\">include</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>tensorflow/core/framework/register_types.h<span class=\"pl-pds\">\"</span></span>\n#<span class=\"pl-k\">include</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>tensorflow/core/framework/tensor.h<span class=\"pl-pds\">\"</span></span>\n#<span class=\"pl-k\">include</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>tensorflow/core/framework/tensor_shape.h<span class=\"pl-pds\">\"</span></span>\n#<span class=\"pl-k\">include</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>tensorflow/core/framework/types.h<span class=\"pl-pds\">\"</span></span>\n#<span class=\"pl-k\">include</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>tensorflow/core/kernels/bounds_check.h<span class=\"pl-pds\">\"</span></span>\n#<span class=\"pl-k\">include</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>tensorflow/core/lib/core/status.h<span class=\"pl-pds\">\"</span></span>\n#<span class=\"pl-k\">include</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>tensorflow/core/platform/logging.h<span class=\"pl-pds\">\"</span></span>\n\n\n<span class=\"pl-k\">namespace</span> <span class=\"pl-en\">tensorflow</span> {\n\n<span class=\"pl-en\">REGISTER_OP</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>CropRotatedRectangleOp<span class=\"pl-pds\">\"</span></span>)\n    .Input(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>image: T<span class=\"pl-pds\">\"</span></span>)\n    .Input(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>size: int32<span class=\"pl-pds\">\"</span></span>)\n    .Input(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>center: float<span class=\"pl-pds\">\"</span></span>)\n    .Input(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>angle: float<span class=\"pl-pds\">\"</span></span>)\n    .Attr(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>T: {uint8, int8, int16, int32, int64, half, float, double}<span class=\"pl-pds\">\"</span></span>)\n    .Output(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>rotated_image: float<span class=\"pl-pds\">\"</span></span>)\n    .Doc(<span class=\"pl-s\"><span class=\"pl-pds\">R\"doc(</span></span>\n<span class=\"pl-s\">Crops a rotated rectangle from an image.</span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">image: 3-D with shape `[height, width, channels]`.</span>\n<span class=\"pl-s\">size: A 1-D int32 Tensor of 2 elements: `new_height, new_width`. The</span>\n<span class=\"pl-s\">  size of the rectangles to be cropped.</span>\n<span class=\"pl-s\">center: A 1-D float Tensor of 2 elements: `center_x, center_y`. The center</span>\n<span class=\"pl-s\">  of the rectangles to be cropped.</span>\n<span class=\"pl-s\">angle: A 0-D float Tensor representing the angle that the rectangles are</span>\n<span class=\"pl-s\">  rotated.</span>\n<span class=\"pl-s\">rotated_image: 3-D with shape `[new_height, new_width, channels]`.</span>\n<span class=\"pl-s\"><span class=\"pl-pds\">)doc\"</span></span>);\n\n\n<span class=\"pl-k\">typedef</span> Eigen::ThreadPoolDevice CPUDevice;\n\n<span class=\"pl-k\">template </span>&lt;<span class=\"pl-k\">typename</span> Device, <span class=\"pl-k\">typename</span> T&gt;\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">CropRotatedRectangleOp</span> : <span class=\"pl-k\">public</span> <span class=\"pl-en\">OpKernel</span> {\n <span class=\"pl-k\">public:</span>\n  <span class=\"pl-k\">explicit</span> <span class=\"pl-en\">CropRotatedRectangleOp</span>(OpKernelConstruction* context) :\n      OpKernel(context) {}\n\n  <span class=\"pl-k\">void</span> <span class=\"pl-en\">Compute</span>(OpKernelContext* context) <span class=\"pl-k\">override</span> {\n    <span class=\"pl-k\">const</span> Tensor&amp; input_tensor = context-&gt;<span class=\"pl-c1\">input</span>(<span class=\"pl-c1\">0</span>);\n    <span class=\"pl-c1\">OP_REQUIRES</span>(context, input_tensor.<span class=\"pl-c1\">dims</span>() == <span class=\"pl-c1\">3</span>,\n                <span class=\"pl-c1\">errors::InvalidArgument</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>image must be 3-dimensional<span class=\"pl-pds\">\"</span></span>,\n                                        input_tensor.<span class=\"pl-c1\">shape</span>().<span class=\"pl-c1\">DebugString</span>()));\n\n    <span class=\"pl-k\">const</span> Tensor&amp; <span class=\"pl-c1\">shape_t</span> = context-&gt;<span class=\"pl-c1\">input</span>(<span class=\"pl-c1\">1</span>);\n    <span class=\"pl-c1\">OP_REQUIRES</span>(context, <span class=\"pl-c1\">shape_t</span>.<span class=\"pl-c1\">dims</span>() == <span class=\"pl-c1\">1</span>,\n                <span class=\"pl-c1\">errors::InvalidArgument</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>shape_t must be 1-dimensional<span class=\"pl-pds\">\"</span></span>,\n                                        <span class=\"pl-c1\">shape_t</span>.<span class=\"pl-c1\">shape</span>().<span class=\"pl-c1\">DebugString</span>()));\n    <span class=\"pl-c1\">OP_REQUIRES</span>(context, <span class=\"pl-c1\">shape_t</span>.<span class=\"pl-c1\">NumElements</span>() == <span class=\"pl-c1\">2</span>,\n                <span class=\"pl-c1\">errors::InvalidArgument</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>shape_t must have two elements<span class=\"pl-pds\">\"</span></span>,\n                                        <span class=\"pl-c1\">shape_t</span>.<span class=\"pl-c1\">shape</span>().<span class=\"pl-c1\">DebugString</span>()));\n\n    <span class=\"pl-k\">const</span> Tensor&amp; <span class=\"pl-c1\">center_t</span> = context-&gt;<span class=\"pl-c1\">input</span>(<span class=\"pl-c1\">2</span>);\n    <span class=\"pl-c1\">OP_REQUIRES</span>(context, <span class=\"pl-c1\">center_t</span>.<span class=\"pl-c1\">dims</span>() == <span class=\"pl-c1\">1</span>,\n                <span class=\"pl-c1\">errors::InvalidArgument</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>center_t must be 1-dimensional<span class=\"pl-pds\">\"</span></span>,\n                                        <span class=\"pl-c1\">center_t</span>.<span class=\"pl-c1\">shape</span>().<span class=\"pl-c1\">DebugString</span>()));\n    <span class=\"pl-c1\">OP_REQUIRES</span>(context, <span class=\"pl-c1\">center_t</span>.<span class=\"pl-c1\">NumElements</span>() == <span class=\"pl-c1\">2</span>,\n                <span class=\"pl-c1\">errors::InvalidArgument</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>center_t must have two elements<span class=\"pl-pds\">\"</span></span>,\n                                        <span class=\"pl-c1\">center_t</span>.<span class=\"pl-c1\">shape</span>().<span class=\"pl-c1\">DebugString</span>()));\n\n    <span class=\"pl-k\">const</span> Tensor&amp; <span class=\"pl-c1\">angle_t</span> = context-&gt;<span class=\"pl-c1\">input</span>(<span class=\"pl-c1\">3</span>);\n\n    <span class=\"pl-k\">auto</span> Svec = <span class=\"pl-c1\">shape_t</span>.<span class=\"pl-smi\">vec</span>&lt;int32&gt;();\n    <span class=\"pl-k\">const</span> int64 out_height = <span class=\"pl-c1\">internal::SubtleMustCopy</span>(<span class=\"pl-c1\">Svec</span>(<span class=\"pl-c1\">0</span>));\n    <span class=\"pl-k\">const</span> int64 out_width = <span class=\"pl-c1\">internal::SubtleMustCopy</span>(<span class=\"pl-c1\">Svec</span>(<span class=\"pl-c1\">1</span>));\n    <span class=\"pl-k\">const</span> int64 channels = input_tensor.<span class=\"pl-c1\">dim_size</span>(<span class=\"pl-c1\">2</span>);\n    <span class=\"pl-c1\">OP_REQUIRES</span>(context, out_height &gt; <span class=\"pl-c1\">0</span> &amp;&amp; out_width &gt; <span class=\"pl-c1\">0</span>,\n                <span class=\"pl-c1\">errors::InvalidArgument</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>output dimensions must be positive<span class=\"pl-pds\">\"</span></span>));\n    <span class=\"pl-c1\">OP_REQUIRES</span>(context, channels &gt; <span class=\"pl-c1\">0</span>,\n                <span class=\"pl-c1\">errors::InvalidArgument</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>image must have at least 1 channel<span class=\"pl-pds\">\"</span></span>));\n    <span class=\"pl-c1\">OP_REQUIRES</span>(context,\n                input_tensor.<span class=\"pl-c1\">dim_size</span>(<span class=\"pl-c1\">0</span>) &gt; <span class=\"pl-c1\">0</span> &amp;&amp; input_tensor.<span class=\"pl-c1\">dim_size</span>(<span class=\"pl-c1\">1</span>) &gt; <span class=\"pl-c1\">0</span>,\n                <span class=\"pl-c1\">errors::InvalidArgument</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>input must be of non-zero size<span class=\"pl-pds\">\"</span></span>));\n\n    <span class=\"pl-k\">typename</span> TTypes&lt;T, <span class=\"pl-c1\">3</span>&gt;::ConstTensor input_data = input_tensor.<span class=\"pl-smi\">tensor</span>&lt;T, <span class=\"pl-c1\">3</span>&gt;();\n    <span class=\"pl-k\">const</span> int64 in_height = <span class=\"pl-k\">static_cast</span>&lt;int32&gt;(input_tensor.<span class=\"pl-c1\">dim_size</span>(<span class=\"pl-c1\">0</span>));\n    <span class=\"pl-k\">const</span> int64 in_width = <span class=\"pl-k\">static_cast</span>&lt;int32&gt;(input_tensor.<span class=\"pl-c1\">dim_size</span>(<span class=\"pl-c1\">1</span>));\n\n    <span class=\"pl-k\">const</span> <span class=\"pl-k\">float</span> angle = <span class=\"pl-c1\">angle_t</span>.<span class=\"pl-smi\">scalar</span>&lt;<span class=\"pl-k\">float</span>&gt;()();\n    <span class=\"pl-k\">const</span> <span class=\"pl-k\">float</span> cosa = <span class=\"pl-c1\">cos</span>(angle);\n    <span class=\"pl-k\">const</span> <span class=\"pl-k\">float</span> sina = <span class=\"pl-c1\">sin</span>(angle);\n\n    <span class=\"pl-k\">auto</span> Cvec = <span class=\"pl-c1\">center_t</span>.<span class=\"pl-smi\">vec</span>&lt;<span class=\"pl-k\">float</span>&gt;();\n    <span class=\"pl-k\">const</span> <span class=\"pl-k\">float</span> center_x = <span class=\"pl-c1\">Cvec</span>(<span class=\"pl-c1\">0</span>);\n    <span class=\"pl-k\">const</span> <span class=\"pl-k\">float</span> center_y = <span class=\"pl-c1\">Cvec</span>(<span class=\"pl-c1\">1</span>);\n    <span class=\"pl-k\">const</span> <span class=\"pl-k\">float</span> offset_x =\n      center_x - (out_width * cosa - out_height * sina) / <span class=\"pl-c1\">2</span>.<span class=\"pl-c1\">0f</span>;\n    <span class=\"pl-k\">const</span> <span class=\"pl-k\">float</span> offset_y =\n      center_y - (out_width * sina + out_height * cosa) / <span class=\"pl-c1\">2</span>.<span class=\"pl-c1\">0f</span>;\n\n    Tensor* output_tensor = <span class=\"pl-c1\">NULL</span>;\n    <span class=\"pl-c1\">OP_REQUIRES_OK</span>(context, context-&gt;<span class=\"pl-c1\">allocate_output</span>(<span class=\"pl-c1\">0</span>,\n      <span class=\"pl-c1\">TensorShape</span>({out_height, out_width, channels}), &amp;output_tensor));\n    <span class=\"pl-k\">typename</span> TTypes&lt;<span class=\"pl-k\">float</span>, <span class=\"pl-c1\">3</span>&gt;::Tensor output_data =\n      output_tensor-&gt;<span class=\"pl-smi\">tensor</span>&lt;<span class=\"pl-k\">float</span>, <span class=\"pl-c1\">3</span>&gt;();\n\n    <span class=\"pl-k\">for</span> (int64 y = <span class=\"pl-c1\">0</span>; y &lt; out_height; ++y) {\n      <span class=\"pl-k\">float</span> ysina = y * sina;\n      <span class=\"pl-k\">float</span> ycosa = y * cosa;\n\n      <span class=\"pl-k\">for</span> (int64 x = <span class=\"pl-c1\">0</span>; x &lt; out_width; ++x) {\n        <span class=\"pl-k\">float</span> src_x = x * cosa - ysina + offset_x;\n        <span class=\"pl-k\">float</span> src_y = x * sina + ycosa + offset_y;\n\n        <span class=\"pl-k\">if</span> (src_x &gt;= <span class=\"pl-c1\">0</span>.<span class=\"pl-c1\">0f</span> &amp;&amp; src_x &lt; in_width-<span class=\"pl-c1\">1</span> &amp;&amp;\n            src_y &gt;= <span class=\"pl-c1\">0</span>.<span class=\"pl-c1\">0f</span> &amp;&amp; src_y &lt; in_height-<span class=\"pl-c1\">1</span>) {\n          int64 src_x0 = <span class=\"pl-c1\">floor</span>(src_x);\n          int64 src_x1 = src_x0 + <span class=\"pl-c1\">1</span>;\n          int64 src_y0 = <span class=\"pl-c1\">floor</span>(src_y);\n          int64 src_y1 = src_y0 + <span class=\"pl-c1\">1</span>;\n\n          <span class=\"pl-k\">float</span> sx = src_x - src_x0;\n          <span class=\"pl-k\">float</span> sy = src_y - src_y0;\n          <span class=\"pl-k\">float</span> s00 = (<span class=\"pl-c1\">1</span>.<span class=\"pl-c1\">0f</span>-sx) * (<span class=\"pl-c1\">1</span>.<span class=\"pl-c1\">0f</span>-sy);\n          <span class=\"pl-k\">float</span> s10 = sx * (<span class=\"pl-c1\">1</span>.<span class=\"pl-c1\">0f</span>-sy);\n          <span class=\"pl-k\">float</span> s01 = (<span class=\"pl-c1\">1</span>.<span class=\"pl-c1\">0f</span>-sx) * sy;\n          <span class=\"pl-k\">float</span> s11 = sx * sy;\n\n          <span class=\"pl-k\">for</span> (int64 c = <span class=\"pl-c1\">0</span>; c &lt; channels; ++c) {\n            <span class=\"pl-c1\">output_data</span>(y, x, c) =\n              s00 * <span class=\"pl-c1\">float</span>(<span class=\"pl-c1\">input_data</span>(src_y0, src_x0, c)) +\n              s10 * <span class=\"pl-c1\">float</span>(<span class=\"pl-c1\">input_data</span>(src_y0, src_x1, c)) +\n              s01 * <span class=\"pl-c1\">float</span>(<span class=\"pl-c1\">input_data</span>(src_y1, src_x0, c)) +\n              s11 * <span class=\"pl-c1\">float</span>(<span class=\"pl-c1\">input_data</span>(src_y1, src_x1, c));\n          }\n        } <span class=\"pl-k\">else</span> {\n          <span class=\"pl-k\">for</span> (int64 c = <span class=\"pl-c1\">0</span>; c &lt; channels; ++c) {\n            <span class=\"pl-c1\">output_data</span>(y, x, c) = <span class=\"pl-c1\">0</span>.<span class=\"pl-c1\">0f</span>;\n          }\n        }\n      }\n    }\n  }\n};\n\n#<span class=\"pl-k\">define</span> <span class=\"pl-en\">REGISTER_KERNEL</span>(<span class=\"pl-v\">T</span>)                            \\\n  <span class=\"pl-en\">REGISTER_KERNEL_BUILDER</span>(Name(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>CropRotatedRectangle<span class=\"pl-pds\">\"</span></span>)\\\n                              .Device(DEVICE_CPU)     \\\n                              .TypeConstraint&lt;T&gt;(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>T<span class=\"pl-pds\">\"</span></span>) \\\n                              .HostMemory(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>size<span class=\"pl-pds\">\"</span></span>),    \\\n                          CropRotatedRectangleOp&lt;CPUDevice, T&gt;);\n\n<span class=\"pl-en\">TF_CALL_REAL_NUMBER_TYPES</span>(REGISTER_KERNEL);\n\n#<span class=\"pl-k\">undef</span> REGISTER_KERNEL\n\n}  <span class=\"pl-c\"><span class=\"pl-c\">//</span> namespace tensorflow</span></pre></div>", "body_text": "I haven't written C++ code in a few years but I threw this together because this is the op I need, it should do the trick. I might throw together a cuda kernel at some point if I have the time.\n#define EIGEN_USE_THREADS\n\n#include <algorithm>\n#include <memory>\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"tensorflow/core/framework/op.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/kernels/bounds_check.h\"\n#include \"tensorflow/core/lib/core/status.h\"\n#include \"tensorflow/core/platform/logging.h\"\n\n\nnamespace tensorflow {\n\nREGISTER_OP(\"CropRotatedRectangleOp\")\n    .Input(\"image: T\")\n    .Input(\"size: int32\")\n    .Input(\"center: float\")\n    .Input(\"angle: float\")\n    .Attr(\"T: {uint8, int8, int16, int32, int64, half, float, double}\")\n    .Output(\"rotated_image: float\")\n    .Doc(R\"doc(\nCrops a rotated rectangle from an image.\n\nimage: 3-D with shape `[height, width, channels]`.\nsize: A 1-D int32 Tensor of 2 elements: `new_height, new_width`. The\n  size of the rectangles to be cropped.\ncenter: A 1-D float Tensor of 2 elements: `center_x, center_y`. The center\n  of the rectangles to be cropped.\nangle: A 0-D float Tensor representing the angle that the rectangles are\n  rotated.\nrotated_image: 3-D with shape `[new_height, new_width, channels]`.\n)doc\");\n\n\ntypedef Eigen::ThreadPoolDevice CPUDevice;\n\ntemplate <typename Device, typename T>\nclass CropRotatedRectangleOp : public OpKernel {\n public:\n  explicit CropRotatedRectangleOp(OpKernelConstruction* context) :\n      OpKernel(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& input_tensor = context->input(0);\n    OP_REQUIRES(context, input_tensor.dims() == 3,\n                errors::InvalidArgument(\"image must be 3-dimensional\",\n                                        input_tensor.shape().DebugString()));\n\n    const Tensor& shape_t = context->input(1);\n    OP_REQUIRES(context, shape_t.dims() == 1,\n                errors::InvalidArgument(\"shape_t must be 1-dimensional\",\n                                        shape_t.shape().DebugString()));\n    OP_REQUIRES(context, shape_t.NumElements() == 2,\n                errors::InvalidArgument(\"shape_t must have two elements\",\n                                        shape_t.shape().DebugString()));\n\n    const Tensor& center_t = context->input(2);\n    OP_REQUIRES(context, center_t.dims() == 1,\n                errors::InvalidArgument(\"center_t must be 1-dimensional\",\n                                        center_t.shape().DebugString()));\n    OP_REQUIRES(context, center_t.NumElements() == 2,\n                errors::InvalidArgument(\"center_t must have two elements\",\n                                        center_t.shape().DebugString()));\n\n    const Tensor& angle_t = context->input(3);\n\n    auto Svec = shape_t.vec<int32>();\n    const int64 out_height = internal::SubtleMustCopy(Svec(0));\n    const int64 out_width = internal::SubtleMustCopy(Svec(1));\n    const int64 channels = input_tensor.dim_size(2);\n    OP_REQUIRES(context, out_height > 0 && out_width > 0,\n                errors::InvalidArgument(\"output dimensions must be positive\"));\n    OP_REQUIRES(context, channels > 0,\n                errors::InvalidArgument(\"image must have at least 1 channel\"));\n    OP_REQUIRES(context,\n                input_tensor.dim_size(0) > 0 && input_tensor.dim_size(1) > 0,\n                errors::InvalidArgument(\"input must be of non-zero size\"));\n\n    typename TTypes<T, 3>::ConstTensor input_data = input_tensor.tensor<T, 3>();\n    const int64 in_height = static_cast<int32>(input_tensor.dim_size(0));\n    const int64 in_width = static_cast<int32>(input_tensor.dim_size(1));\n\n    const float angle = angle_t.scalar<float>()();\n    const float cosa = cos(angle);\n    const float sina = sin(angle);\n\n    auto Cvec = center_t.vec<float>();\n    const float center_x = Cvec(0);\n    const float center_y = Cvec(1);\n    const float offset_x =\n      center_x - (out_width * cosa - out_height * sina) / 2.0f;\n    const float offset_y =\n      center_y - (out_width * sina + out_height * cosa) / 2.0f;\n\n    Tensor* output_tensor = NULL;\n    OP_REQUIRES_OK(context, context->allocate_output(0,\n      TensorShape({out_height, out_width, channels}), &output_tensor));\n    typename TTypes<float, 3>::Tensor output_data =\n      output_tensor->tensor<float, 3>();\n\n    for (int64 y = 0; y < out_height; ++y) {\n      float ysina = y * sina;\n      float ycosa = y * cosa;\n\n      for (int64 x = 0; x < out_width; ++x) {\n        float src_x = x * cosa - ysina + offset_x;\n        float src_y = x * sina + ycosa + offset_y;\n\n        if (src_x >= 0.0f && src_x < in_width-1 &&\n            src_y >= 0.0f && src_y < in_height-1) {\n          int64 src_x0 = floor(src_x);\n          int64 src_x1 = src_x0 + 1;\n          int64 src_y0 = floor(src_y);\n          int64 src_y1 = src_y0 + 1;\n\n          float sx = src_x - src_x0;\n          float sy = src_y - src_y0;\n          float s00 = (1.0f-sx) * (1.0f-sy);\n          float s10 = sx * (1.0f-sy);\n          float s01 = (1.0f-sx) * sy;\n          float s11 = sx * sy;\n\n          for (int64 c = 0; c < channels; ++c) {\n            output_data(y, x, c) =\n              s00 * float(input_data(src_y0, src_x0, c)) +\n              s10 * float(input_data(src_y0, src_x1, c)) +\n              s01 * float(input_data(src_y1, src_x0, c)) +\n              s11 * float(input_data(src_y1, src_x1, c));\n          }\n        } else {\n          for (int64 c = 0; c < channels; ++c) {\n            output_data(y, x, c) = 0.0f;\n          }\n        }\n      }\n    }\n  }\n};\n\n#define REGISTER_KERNEL(T)                            \\\n  REGISTER_KERNEL_BUILDER(Name(\"CropRotatedRectangle\")\\\n                              .Device(DEVICE_CPU)     \\\n                              .TypeConstraint<T>(\"T\") \\\n                              .HostMemory(\"size\"),    \\\n                          CropRotatedRectangleOp<CPUDevice, T>);\n\nTF_CALL_REAL_NUMBER_TYPES(REGISTER_KERNEL);\n\n#undef REGISTER_KERNEL\n\n}  // namespace tensorflow", "body": "I haven't written C++ code in a few years but I threw this together because this is the op I need, it should do the trick. I might throw together a cuda kernel at some point if I have the time.\n\n``` c++\n#define EIGEN_USE_THREADS\n\n#include <algorithm>\n#include <memory>\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"tensorflow/core/framework/op.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/kernels/bounds_check.h\"\n#include \"tensorflow/core/lib/core/status.h\"\n#include \"tensorflow/core/platform/logging.h\"\n\n\nnamespace tensorflow {\n\nREGISTER_OP(\"CropRotatedRectangleOp\")\n    .Input(\"image: T\")\n    .Input(\"size: int32\")\n    .Input(\"center: float\")\n    .Input(\"angle: float\")\n    .Attr(\"T: {uint8, int8, int16, int32, int64, half, float, double}\")\n    .Output(\"rotated_image: float\")\n    .Doc(R\"doc(\nCrops a rotated rectangle from an image.\n\nimage: 3-D with shape `[height, width, channels]`.\nsize: A 1-D int32 Tensor of 2 elements: `new_height, new_width`. The\n  size of the rectangles to be cropped.\ncenter: A 1-D float Tensor of 2 elements: `center_x, center_y`. The center\n  of the rectangles to be cropped.\nangle: A 0-D float Tensor representing the angle that the rectangles are\n  rotated.\nrotated_image: 3-D with shape `[new_height, new_width, channels]`.\n)doc\");\n\n\ntypedef Eigen::ThreadPoolDevice CPUDevice;\n\ntemplate <typename Device, typename T>\nclass CropRotatedRectangleOp : public OpKernel {\n public:\n  explicit CropRotatedRectangleOp(OpKernelConstruction* context) :\n      OpKernel(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& input_tensor = context->input(0);\n    OP_REQUIRES(context, input_tensor.dims() == 3,\n                errors::InvalidArgument(\"image must be 3-dimensional\",\n                                        input_tensor.shape().DebugString()));\n\n    const Tensor& shape_t = context->input(1);\n    OP_REQUIRES(context, shape_t.dims() == 1,\n                errors::InvalidArgument(\"shape_t must be 1-dimensional\",\n                                        shape_t.shape().DebugString()));\n    OP_REQUIRES(context, shape_t.NumElements() == 2,\n                errors::InvalidArgument(\"shape_t must have two elements\",\n                                        shape_t.shape().DebugString()));\n\n    const Tensor& center_t = context->input(2);\n    OP_REQUIRES(context, center_t.dims() == 1,\n                errors::InvalidArgument(\"center_t must be 1-dimensional\",\n                                        center_t.shape().DebugString()));\n    OP_REQUIRES(context, center_t.NumElements() == 2,\n                errors::InvalidArgument(\"center_t must have two elements\",\n                                        center_t.shape().DebugString()));\n\n    const Tensor& angle_t = context->input(3);\n\n    auto Svec = shape_t.vec<int32>();\n    const int64 out_height = internal::SubtleMustCopy(Svec(0));\n    const int64 out_width = internal::SubtleMustCopy(Svec(1));\n    const int64 channels = input_tensor.dim_size(2);\n    OP_REQUIRES(context, out_height > 0 && out_width > 0,\n                errors::InvalidArgument(\"output dimensions must be positive\"));\n    OP_REQUIRES(context, channels > 0,\n                errors::InvalidArgument(\"image must have at least 1 channel\"));\n    OP_REQUIRES(context,\n                input_tensor.dim_size(0) > 0 && input_tensor.dim_size(1) > 0,\n                errors::InvalidArgument(\"input must be of non-zero size\"));\n\n    typename TTypes<T, 3>::ConstTensor input_data = input_tensor.tensor<T, 3>();\n    const int64 in_height = static_cast<int32>(input_tensor.dim_size(0));\n    const int64 in_width = static_cast<int32>(input_tensor.dim_size(1));\n\n    const float angle = angle_t.scalar<float>()();\n    const float cosa = cos(angle);\n    const float sina = sin(angle);\n\n    auto Cvec = center_t.vec<float>();\n    const float center_x = Cvec(0);\n    const float center_y = Cvec(1);\n    const float offset_x =\n      center_x - (out_width * cosa - out_height * sina) / 2.0f;\n    const float offset_y =\n      center_y - (out_width * sina + out_height * cosa) / 2.0f;\n\n    Tensor* output_tensor = NULL;\n    OP_REQUIRES_OK(context, context->allocate_output(0,\n      TensorShape({out_height, out_width, channels}), &output_tensor));\n    typename TTypes<float, 3>::Tensor output_data =\n      output_tensor->tensor<float, 3>();\n\n    for (int64 y = 0; y < out_height; ++y) {\n      float ysina = y * sina;\n      float ycosa = y * cosa;\n\n      for (int64 x = 0; x < out_width; ++x) {\n        float src_x = x * cosa - ysina + offset_x;\n        float src_y = x * sina + ycosa + offset_y;\n\n        if (src_x >= 0.0f && src_x < in_width-1 &&\n            src_y >= 0.0f && src_y < in_height-1) {\n          int64 src_x0 = floor(src_x);\n          int64 src_x1 = src_x0 + 1;\n          int64 src_y0 = floor(src_y);\n          int64 src_y1 = src_y0 + 1;\n\n          float sx = src_x - src_x0;\n          float sy = src_y - src_y0;\n          float s00 = (1.0f-sx) * (1.0f-sy);\n          float s10 = sx * (1.0f-sy);\n          float s01 = (1.0f-sx) * sy;\n          float s11 = sx * sy;\n\n          for (int64 c = 0; c < channels; ++c) {\n            output_data(y, x, c) =\n              s00 * float(input_data(src_y0, src_x0, c)) +\n              s10 * float(input_data(src_y0, src_x1, c)) +\n              s01 * float(input_data(src_y1, src_x0, c)) +\n              s11 * float(input_data(src_y1, src_x1, c));\n          }\n        } else {\n          for (int64 c = 0; c < channels; ++c) {\n            output_data(y, x, c) = 0.0f;\n          }\n        }\n      }\n    }\n  }\n};\n\n#define REGISTER_KERNEL(T)                            \\\n  REGISTER_KERNEL_BUILDER(Name(\"CropRotatedRectangle\")\\\n                              .Device(DEVICE_CPU)     \\\n                              .TypeConstraint<T>(\"T\") \\\n                              .HostMemory(\"size\"),    \\\n                          CropRotatedRectangleOp<CPUDevice, T>);\n\nTF_CALL_REAL_NUMBER_TYPES(REGISTER_KERNEL);\n\n#undef REGISTER_KERNEL\n\n}  // namespace tensorflow\n```\n"}