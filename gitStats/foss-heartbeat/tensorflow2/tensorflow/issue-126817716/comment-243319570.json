{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/243319570", "html_url": "https://github.com/tensorflow/tensorflow/issues/781#issuecomment-243319570", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/781", "id": 243319570, "node_id": "MDEyOklzc3VlQ29tbWVudDI0MzMxOTU3MA==", "user": {"login": "sdemyanov", "id": 2918706, "node_id": "MDQ6VXNlcjI5MTg3MDY=", "avatar_url": "https://avatars0.githubusercontent.com/u/2918706?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sdemyanov", "html_url": "https://github.com/sdemyanov", "followers_url": "https://api.github.com/users/sdemyanov/followers", "following_url": "https://api.github.com/users/sdemyanov/following{/other_user}", "gists_url": "https://api.github.com/users/sdemyanov/gists{/gist_id}", "starred_url": "https://api.github.com/users/sdemyanov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sdemyanov/subscriptions", "organizations_url": "https://api.github.com/users/sdemyanov/orgs", "repos_url": "https://api.github.com/users/sdemyanov/repos", "events_url": "https://api.github.com/users/sdemyanov/events{/privacy}", "received_events_url": "https://api.github.com/users/sdemyanov/received_events", "type": "User", "site_admin": false}, "created_at": "2016-08-30T02:59:52Z", "updated_at": "2016-09-07T12:28:16Z", "author_association": "NONE", "body_html": "<p>This is my implementation. Images and Targets should be in NCHW layout, shift_mat, scale_mat and mirror_mat are (N, 2) arrays with the transformation parameters for each image, angle_mat is (N, 1) array, defval is the value to fill when the source pixel is outside the original image.</p>\n<pre><code>#define THREADS_PER_DIM_1                  16\n#define THREADS_PER_DIM_2                  16\n#define IMAGES_PER_THREAD                  32\n#define CHANNELS_PER_THREAD                32\n\n__global__\nvoid kTransform(float* imgs, float* targets,\n  int imgSize1, int imgSize2, int trgSize1, int trgSize2,\n  int numChannels, int numImages, int channelBlocks,\n  float *shift_mat, float *scale_mat, float *mirror_mat, float *angle_mat, float defval) {\n\n  const int targetIdx1 = blockIdx.x * blockDim.x + threadIdx.x;\n  const int targetIdx2 = blockIdx.y * blockDim.y + threadIdx.y;\n  const int channelBlockIdx = blockIdx.z % channelBlocks;\n  const int imageBlockIdx = blockIdx.z / channelBlocks;\n  // HW layout\n  const int targetIdx = targetIdx1 * trgSize2 + targetIdx2;\n\n  if (targetIdx1 &gt;= trgSize1 || targetIdx2 &gt;= trgSize2) {\n    return;\n  }\n\n  const int imgPixels = imgSize1 * imgSize2;\n  const int trgPixels = trgSize1 * trgSize2;\n\n  float buffer[IMAGES_PER_THREAD][CHANNELS_PER_THREAD];\n\n  const float imgHalf1 = (float) imgSize1 / 2 - 0.5;\n  const float imgHalf2 = (float) imgSize2 / 2 - 0.5;\n  const float trgHalf1 = (float) trgSize1 / 2 - 0.5;\n  const float trgHalf2 = (float) trgSize2 / 2 - 0.5;\n\n  // #pragma unroll\n  const int first_im = imageBlockIdx * IMAGES_PER_THREAD;\n  const int last_im = MIN(first_im + IMAGES_PER_THREAD, numImages);\n  const int first_ch = channelBlockIdx * CHANNELS_PER_THREAD;\n  const int last_ch = MIN(first_ch + CHANNELS_PER_THREAD, numChannels);\n  for (int i = first_im; i &lt; last_im; ++i) {\n    // indices for (n, 2) param arrays\n    const int i0 = 2*i, i1 = 2*i+1;\n    const float angcos = (float) cos(angle_mat[i]);\n    const float angsin = (float) sin(angle_mat[i]);\n    const float xi1 = (targetIdx1 - trgHalf1) * scale_mat[i0]; // scale[0];\n    const float xi2 = (targetIdx2 - trgHalf2) * scale_mat[i1]; //scale[1];\n    float x1 = xi1 * angcos - xi2 * angsin + imgHalf1 + shift_mat[i0]; //shift[0];\n    float x2 = xi1 * angsin + xi2 * angcos + imgHalf2 + shift_mat[i1]; //shift[1];\n    if (mirror_mat[i0] &gt; 0.5) x1 = imgSize1 - 1 - x1;\n    if (mirror_mat[i1] &gt; 0.5) x2 = imgSize2 - 1 - x2;\n    if (0 &lt;= x1 &amp;&amp; x1 &lt;= imgSize1 - 1 &amp;&amp;\n        0 &lt;= x2 &amp;&amp; x2 &lt;= imgSize2 - 1) {\n      const int xu1 = (int) (x1 + 0.5);\n      const int xu2 = (int) (x2 + 0.5);\n      const int xp1 = MIN(xu1 + 1, imgSize1 - 1);\n      const int xp2 = MIN(xu2 + 1, imgSize2 - 1);\n      // HW layout\n      const int imgPx11 = xu1 * imgSize2 + xu2;\n      const int imgPx21 = xu1 * imgSize2 + xp2;\n      const int imgPx12 = xp1 * imgSize2 + xu2;\n      const int imgPx22 = xp1 * imgSize2 + xp2;\n      for (int c = first_ch; c &lt; last_ch; ++c) {\n        // NCHW or NCWH layout\n        const int cur_shift = (i * numChannels + c) * imgPixels;\n        const int imgInd11 = cur_shift + imgPx11;\n        const int imgInd21 = cur_shift + imgPx21;\n        const int imgInd12 = cur_shift + imgPx12;\n        const int imgInd22 = cur_shift + imgPx22;\n        const float vl = (x1 - (float) xu1) * imgs[imgInd21] + ((float) xu1 + 1 - x1) * imgs[imgInd11];\n        const float vh = (x1 - (float) xu1) * imgs[imgInd22] + ((float) xu1 + 1 - x1) * imgs[imgInd12];\n        buffer[i-first_im][c-first_ch] = (x2 - (float) xu2) * vh + ((float) xu2 + 1 - x2) * vl;\n      }\n    } else {\n      for (int c = 0; c &lt; numChannels; ++c) {\n        buffer[i-first_im][c-first_ch] = defval;\n      }\n    }\n  }\n\n  // shift to the current pixel\n  targets += targetIdx;\n   #pragma unroll\n  for (int i = first_im; i &lt; last_im; ++i) {\n     #pragma unroll\n    for (int c = first_ch; c &lt; last_ch; ++c) {\n      targets[(i * numChannels + c) * trgPixels] = buffer[i-first_im][c-first_ch];\n    }\n  }\n}\n\nvoid _transformActs(const MatGPU &amp;images, MatGPU &amp;targets,\n                    int imgSize1, int imgSize2,\n                    int trgSize1, int trgSize2,\n                    const MatGPU &amp;shift_mat, const MatGPU &amp;scale_mat,\n                    const MatGPU &amp;mirror_mat, const MatGPU &amp;angle_mat, float defval) {\n\n\n  int numImages = images.size1_;\n\n  int imgPixels = imgSize1 * imgSize2;\n  mexAssert(images.size2_ % imgPixels == 0, \"ta2\");\n  int numChannels = images.size2_ / imgPixels;\n\n  mexAssert(targets.size1_ == numImages, \"ta1\");\n  mexAssert(targets.size2_ == trgSize1 * trgSize2 * numChannels, \"ta3\");\n\n  cudaStream_t stream = MatGPU::_defaultStream;\n\n  dim3 threads(THREADS_PER_DIM_1, THREADS_PER_DIM_2);\n\n  int imageBlocks = DIVUP(numImages, IMAGES_PER_THREAD);\n  int channelBlocks = DIVUP(numChannels, CHANNELS_PER_THREAD);\n  dim3 blocks(DIVUP(trgSize1, THREADS_PER_DIM_1),\n              DIVUP(trgSize2, THREADS_PER_DIM_2),\n              imageBlocks * channelBlocks);\n\n  kTransform&lt;&lt;&lt;blocks, threads, 0, stream&gt;&gt;&gt;\n    (images.data_, targets.data_, imgSize1, imgSize2, trgSize1, trgSize2,\n     numChannels, numImages, channelBlocks,\n     shift_mat.data_, scale_mat.data_, mirror_mat.data_, angle_mat.data_, defval);\n\n  mexAssert(cudaGetLastError() == cudaSuccess, \"_transformActs: kernel execution failed\");\n}\n</code></pre>", "body_text": "This is my implementation. Images and Targets should be in NCHW layout, shift_mat, scale_mat and mirror_mat are (N, 2) arrays with the transformation parameters for each image, angle_mat is (N, 1) array, defval is the value to fill when the source pixel is outside the original image.\n#define THREADS_PER_DIM_1                  16\n#define THREADS_PER_DIM_2                  16\n#define IMAGES_PER_THREAD                  32\n#define CHANNELS_PER_THREAD                32\n\n__global__\nvoid kTransform(float* imgs, float* targets,\n  int imgSize1, int imgSize2, int trgSize1, int trgSize2,\n  int numChannels, int numImages, int channelBlocks,\n  float *shift_mat, float *scale_mat, float *mirror_mat, float *angle_mat, float defval) {\n\n  const int targetIdx1 = blockIdx.x * blockDim.x + threadIdx.x;\n  const int targetIdx2 = blockIdx.y * blockDim.y + threadIdx.y;\n  const int channelBlockIdx = blockIdx.z % channelBlocks;\n  const int imageBlockIdx = blockIdx.z / channelBlocks;\n  // HW layout\n  const int targetIdx = targetIdx1 * trgSize2 + targetIdx2;\n\n  if (targetIdx1 >= trgSize1 || targetIdx2 >= trgSize2) {\n    return;\n  }\n\n  const int imgPixels = imgSize1 * imgSize2;\n  const int trgPixels = trgSize1 * trgSize2;\n\n  float buffer[IMAGES_PER_THREAD][CHANNELS_PER_THREAD];\n\n  const float imgHalf1 = (float) imgSize1 / 2 - 0.5;\n  const float imgHalf2 = (float) imgSize2 / 2 - 0.5;\n  const float trgHalf1 = (float) trgSize1 / 2 - 0.5;\n  const float trgHalf2 = (float) trgSize2 / 2 - 0.5;\n\n  // #pragma unroll\n  const int first_im = imageBlockIdx * IMAGES_PER_THREAD;\n  const int last_im = MIN(first_im + IMAGES_PER_THREAD, numImages);\n  const int first_ch = channelBlockIdx * CHANNELS_PER_THREAD;\n  const int last_ch = MIN(first_ch + CHANNELS_PER_THREAD, numChannels);\n  for (int i = first_im; i < last_im; ++i) {\n    // indices for (n, 2) param arrays\n    const int i0 = 2*i, i1 = 2*i+1;\n    const float angcos = (float) cos(angle_mat[i]);\n    const float angsin = (float) sin(angle_mat[i]);\n    const float xi1 = (targetIdx1 - trgHalf1) * scale_mat[i0]; // scale[0];\n    const float xi2 = (targetIdx2 - trgHalf2) * scale_mat[i1]; //scale[1];\n    float x1 = xi1 * angcos - xi2 * angsin + imgHalf1 + shift_mat[i0]; //shift[0];\n    float x2 = xi1 * angsin + xi2 * angcos + imgHalf2 + shift_mat[i1]; //shift[1];\n    if (mirror_mat[i0] > 0.5) x1 = imgSize1 - 1 - x1;\n    if (mirror_mat[i1] > 0.5) x2 = imgSize2 - 1 - x2;\n    if (0 <= x1 && x1 <= imgSize1 - 1 &&\n        0 <= x2 && x2 <= imgSize2 - 1) {\n      const int xu1 = (int) (x1 + 0.5);\n      const int xu2 = (int) (x2 + 0.5);\n      const int xp1 = MIN(xu1 + 1, imgSize1 - 1);\n      const int xp2 = MIN(xu2 + 1, imgSize2 - 1);\n      // HW layout\n      const int imgPx11 = xu1 * imgSize2 + xu2;\n      const int imgPx21 = xu1 * imgSize2 + xp2;\n      const int imgPx12 = xp1 * imgSize2 + xu2;\n      const int imgPx22 = xp1 * imgSize2 + xp2;\n      for (int c = first_ch; c < last_ch; ++c) {\n        // NCHW or NCWH layout\n        const int cur_shift = (i * numChannels + c) * imgPixels;\n        const int imgInd11 = cur_shift + imgPx11;\n        const int imgInd21 = cur_shift + imgPx21;\n        const int imgInd12 = cur_shift + imgPx12;\n        const int imgInd22 = cur_shift + imgPx22;\n        const float vl = (x1 - (float) xu1) * imgs[imgInd21] + ((float) xu1 + 1 - x1) * imgs[imgInd11];\n        const float vh = (x1 - (float) xu1) * imgs[imgInd22] + ((float) xu1 + 1 - x1) * imgs[imgInd12];\n        buffer[i-first_im][c-first_ch] = (x2 - (float) xu2) * vh + ((float) xu2 + 1 - x2) * vl;\n      }\n    } else {\n      for (int c = 0; c < numChannels; ++c) {\n        buffer[i-first_im][c-first_ch] = defval;\n      }\n    }\n  }\n\n  // shift to the current pixel\n  targets += targetIdx;\n   #pragma unroll\n  for (int i = first_im; i < last_im; ++i) {\n     #pragma unroll\n    for (int c = first_ch; c < last_ch; ++c) {\n      targets[(i * numChannels + c) * trgPixels] = buffer[i-first_im][c-first_ch];\n    }\n  }\n}\n\nvoid _transformActs(const MatGPU &images, MatGPU &targets,\n                    int imgSize1, int imgSize2,\n                    int trgSize1, int trgSize2,\n                    const MatGPU &shift_mat, const MatGPU &scale_mat,\n                    const MatGPU &mirror_mat, const MatGPU &angle_mat, float defval) {\n\n\n  int numImages = images.size1_;\n\n  int imgPixels = imgSize1 * imgSize2;\n  mexAssert(images.size2_ % imgPixels == 0, \"ta2\");\n  int numChannels = images.size2_ / imgPixels;\n\n  mexAssert(targets.size1_ == numImages, \"ta1\");\n  mexAssert(targets.size2_ == trgSize1 * trgSize2 * numChannels, \"ta3\");\n\n  cudaStream_t stream = MatGPU::_defaultStream;\n\n  dim3 threads(THREADS_PER_DIM_1, THREADS_PER_DIM_2);\n\n  int imageBlocks = DIVUP(numImages, IMAGES_PER_THREAD);\n  int channelBlocks = DIVUP(numChannels, CHANNELS_PER_THREAD);\n  dim3 blocks(DIVUP(trgSize1, THREADS_PER_DIM_1),\n              DIVUP(trgSize2, THREADS_PER_DIM_2),\n              imageBlocks * channelBlocks);\n\n  kTransform<<<blocks, threads, 0, stream>>>\n    (images.data_, targets.data_, imgSize1, imgSize2, trgSize1, trgSize2,\n     numChannels, numImages, channelBlocks,\n     shift_mat.data_, scale_mat.data_, mirror_mat.data_, angle_mat.data_, defval);\n\n  mexAssert(cudaGetLastError() == cudaSuccess, \"_transformActs: kernel execution failed\");\n}", "body": "This is my implementation. Images and Targets should be in NCHW layout, shift_mat, scale_mat and mirror_mat are (N, 2) arrays with the transformation parameters for each image, angle_mat is (N, 1) array, defval is the value to fill when the source pixel is outside the original image.\n\n```\n#define THREADS_PER_DIM_1                  16\n#define THREADS_PER_DIM_2                  16\n#define IMAGES_PER_THREAD                  32\n#define CHANNELS_PER_THREAD                32\n\n__global__\nvoid kTransform(float* imgs, float* targets,\n  int imgSize1, int imgSize2, int trgSize1, int trgSize2,\n  int numChannels, int numImages, int channelBlocks,\n  float *shift_mat, float *scale_mat, float *mirror_mat, float *angle_mat, float defval) {\n\n  const int targetIdx1 = blockIdx.x * blockDim.x + threadIdx.x;\n  const int targetIdx2 = blockIdx.y * blockDim.y + threadIdx.y;\n  const int channelBlockIdx = blockIdx.z % channelBlocks;\n  const int imageBlockIdx = blockIdx.z / channelBlocks;\n  // HW layout\n  const int targetIdx = targetIdx1 * trgSize2 + targetIdx2;\n\n  if (targetIdx1 >= trgSize1 || targetIdx2 >= trgSize2) {\n    return;\n  }\n\n  const int imgPixels = imgSize1 * imgSize2;\n  const int trgPixels = trgSize1 * trgSize2;\n\n  float buffer[IMAGES_PER_THREAD][CHANNELS_PER_THREAD];\n\n  const float imgHalf1 = (float) imgSize1 / 2 - 0.5;\n  const float imgHalf2 = (float) imgSize2 / 2 - 0.5;\n  const float trgHalf1 = (float) trgSize1 / 2 - 0.5;\n  const float trgHalf2 = (float) trgSize2 / 2 - 0.5;\n\n  // #pragma unroll\n  const int first_im = imageBlockIdx * IMAGES_PER_THREAD;\n  const int last_im = MIN(first_im + IMAGES_PER_THREAD, numImages);\n  const int first_ch = channelBlockIdx * CHANNELS_PER_THREAD;\n  const int last_ch = MIN(first_ch + CHANNELS_PER_THREAD, numChannels);\n  for (int i = first_im; i < last_im; ++i) {\n    // indices for (n, 2) param arrays\n    const int i0 = 2*i, i1 = 2*i+1;\n    const float angcos = (float) cos(angle_mat[i]);\n    const float angsin = (float) sin(angle_mat[i]);\n    const float xi1 = (targetIdx1 - trgHalf1) * scale_mat[i0]; // scale[0];\n    const float xi2 = (targetIdx2 - trgHalf2) * scale_mat[i1]; //scale[1];\n    float x1 = xi1 * angcos - xi2 * angsin + imgHalf1 + shift_mat[i0]; //shift[0];\n    float x2 = xi1 * angsin + xi2 * angcos + imgHalf2 + shift_mat[i1]; //shift[1];\n    if (mirror_mat[i0] > 0.5) x1 = imgSize1 - 1 - x1;\n    if (mirror_mat[i1] > 0.5) x2 = imgSize2 - 1 - x2;\n    if (0 <= x1 && x1 <= imgSize1 - 1 &&\n        0 <= x2 && x2 <= imgSize2 - 1) {\n      const int xu1 = (int) (x1 + 0.5);\n      const int xu2 = (int) (x2 + 0.5);\n      const int xp1 = MIN(xu1 + 1, imgSize1 - 1);\n      const int xp2 = MIN(xu2 + 1, imgSize2 - 1);\n      // HW layout\n      const int imgPx11 = xu1 * imgSize2 + xu2;\n      const int imgPx21 = xu1 * imgSize2 + xp2;\n      const int imgPx12 = xp1 * imgSize2 + xu2;\n      const int imgPx22 = xp1 * imgSize2 + xp2;\n      for (int c = first_ch; c < last_ch; ++c) {\n        // NCHW or NCWH layout\n        const int cur_shift = (i * numChannels + c) * imgPixels;\n        const int imgInd11 = cur_shift + imgPx11;\n        const int imgInd21 = cur_shift + imgPx21;\n        const int imgInd12 = cur_shift + imgPx12;\n        const int imgInd22 = cur_shift + imgPx22;\n        const float vl = (x1 - (float) xu1) * imgs[imgInd21] + ((float) xu1 + 1 - x1) * imgs[imgInd11];\n        const float vh = (x1 - (float) xu1) * imgs[imgInd22] + ((float) xu1 + 1 - x1) * imgs[imgInd12];\n        buffer[i-first_im][c-first_ch] = (x2 - (float) xu2) * vh + ((float) xu2 + 1 - x2) * vl;\n      }\n    } else {\n      for (int c = 0; c < numChannels; ++c) {\n        buffer[i-first_im][c-first_ch] = defval;\n      }\n    }\n  }\n\n  // shift to the current pixel\n  targets += targetIdx;\n   #pragma unroll\n  for (int i = first_im; i < last_im; ++i) {\n     #pragma unroll\n    for (int c = first_ch; c < last_ch; ++c) {\n      targets[(i * numChannels + c) * trgPixels] = buffer[i-first_im][c-first_ch];\n    }\n  }\n}\n\nvoid _transformActs(const MatGPU &images, MatGPU &targets,\n                    int imgSize1, int imgSize2,\n                    int trgSize1, int trgSize2,\n                    const MatGPU &shift_mat, const MatGPU &scale_mat,\n                    const MatGPU &mirror_mat, const MatGPU &angle_mat, float defval) {\n\n\n  int numImages = images.size1_;\n\n  int imgPixels = imgSize1 * imgSize2;\n  mexAssert(images.size2_ % imgPixels == 0, \"ta2\");\n  int numChannels = images.size2_ / imgPixels;\n\n  mexAssert(targets.size1_ == numImages, \"ta1\");\n  mexAssert(targets.size2_ == trgSize1 * trgSize2 * numChannels, \"ta3\");\n\n  cudaStream_t stream = MatGPU::_defaultStream;\n\n  dim3 threads(THREADS_PER_DIM_1, THREADS_PER_DIM_2);\n\n  int imageBlocks = DIVUP(numImages, IMAGES_PER_THREAD);\n  int channelBlocks = DIVUP(numChannels, CHANNELS_PER_THREAD);\n  dim3 blocks(DIVUP(trgSize1, THREADS_PER_DIM_1),\n              DIVUP(trgSize2, THREADS_PER_DIM_2),\n              imageBlocks * channelBlocks);\n\n  kTransform<<<blocks, threads, 0, stream>>>\n    (images.data_, targets.data_, imgSize1, imgSize2, trgSize1, trgSize2,\n     numChannels, numImages, channelBlocks,\n     shift_mat.data_, scale_mat.data_, mirror_mat.data_, angle_mat.data_, defval);\n\n  mexAssert(cudaGetLastError() == cudaSuccess, \"_transformActs: kernel execution failed\");\n}\n```\n"}