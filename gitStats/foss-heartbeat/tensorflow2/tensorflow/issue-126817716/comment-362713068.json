{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/362713068", "html_url": "https://github.com/tensorflow/tensorflow/issues/781#issuecomment-362713068", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/781", "id": 362713068, "node_id": "MDEyOklzc3VlQ29tbWVudDM2MjcxMzA2OA==", "user": {"login": "ringw", "id": 1391644, "node_id": "MDQ6VXNlcjEzOTE2NDQ=", "avatar_url": "https://avatars1.githubusercontent.com/u/1391644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ringw", "html_url": "https://github.com/ringw", "followers_url": "https://api.github.com/users/ringw/followers", "following_url": "https://api.github.com/users/ringw/following{/other_user}", "gists_url": "https://api.github.com/users/ringw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ringw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ringw/subscriptions", "organizations_url": "https://api.github.com/users/ringw/orgs", "repos_url": "https://api.github.com/users/ringw/repos", "events_url": "https://api.github.com/users/ringw/events{/privacy}", "received_events_url": "https://api.github.com/users/ringw/received_events", "type": "User", "site_admin": false}, "created_at": "2018-02-02T21:29:11Z", "updated_at": "2018-02-02T21:29:11Z", "author_association": "MEMBER", "body_html": "<p>Thanks Andrew!</p>\n<p>Yes, the identity in our representation is [1, 0, 0, 0, 1, 0, 0, 0] which corresponds to the 3x3 identity matrix. Makes sense to add an <code>identity_projective_transform</code> helper!</p>\n<p>I think we can make <code>_flat_transforms_to_matrices</code>, etc, public too. The catch is that the matrix transforms output coordinates to input coordinates, because at each output pixel, we compute the input pixel to read from. So you would probably need to call <code>tf.linalg.inv</code> on the <code>projection</code> matrix.</p>\n<p>I think tf.transpose doesn't do anything to 1D tensors, and <code>*</code> does elementwise multiplication, so I would recommend:</p>\n<pre><code>        # transform_matrix is an\n        # 8 element projective transform matrix\n        t = transform_matrix\n        # Always creates batches of matrices\n        reverse_transform = tf.contrib.image.flat_transforms_to_matrices(t)[0, :, :]\n        forward_transform = tf.linalg.inv(reverse_transform)\n        coordinate = tf.transpose([[coordinate[0], coordinate[1], 1]])\n        output_coordinate = tf.matmul(forward_transform, coordinate)\n        output_coordinate = coordinate[:2, 0]\n</code></pre>", "body_text": "Thanks Andrew!\nYes, the identity in our representation is [1, 0, 0, 0, 1, 0, 0, 0] which corresponds to the 3x3 identity matrix. Makes sense to add an identity_projective_transform helper!\nI think we can make _flat_transforms_to_matrices, etc, public too. The catch is that the matrix transforms output coordinates to input coordinates, because at each output pixel, we compute the input pixel to read from. So you would probably need to call tf.linalg.inv on the projection matrix.\nI think tf.transpose doesn't do anything to 1D tensors, and * does elementwise multiplication, so I would recommend:\n        # transform_matrix is an\n        # 8 element projective transform matrix\n        t = transform_matrix\n        # Always creates batches of matrices\n        reverse_transform = tf.contrib.image.flat_transforms_to_matrices(t)[0, :, :]\n        forward_transform = tf.linalg.inv(reverse_transform)\n        coordinate = tf.transpose([[coordinate[0], coordinate[1], 1]])\n        output_coordinate = tf.matmul(forward_transform, coordinate)\n        output_coordinate = coordinate[:2, 0]", "body": "Thanks Andrew!\r\n\r\nYes, the identity in our representation is [1, 0, 0, 0, 1, 0, 0, 0] which corresponds to the 3x3 identity matrix. Makes sense to add an `identity_projective_transform` helper!\r\n\r\nI think we can make `_flat_transforms_to_matrices`, etc, public too. The catch is that the matrix transforms output coordinates to input coordinates, because at each output pixel, we compute the input pixel to read from. So you would probably need to call `tf.linalg.inv` on the `projection` matrix.\r\n\r\nI think tf.transpose doesn't do anything to 1D tensors, and `*` does elementwise multiplication, so I would recommend:\r\n\r\n```\r\n        # transform_matrix is an\r\n        # 8 element projective transform matrix\r\n        t = transform_matrix\r\n        # Always creates batches of matrices\r\n        reverse_transform = tf.contrib.image.flat_transforms_to_matrices(t)[0, :, :]\r\n        forward_transform = tf.linalg.inv(reverse_transform)\r\n        coordinate = tf.transpose([[coordinate[0], coordinate[1], 1]])\r\n        output_coordinate = tf.matmul(forward_transform, coordinate)\r\n        output_coordinate = coordinate[:2, 0]\r\n```"}