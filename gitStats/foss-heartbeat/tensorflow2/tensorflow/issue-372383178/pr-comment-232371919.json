{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/232371919", "pull_request_review_id": 172678283, "id": 232371919, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMjM3MTkxOQ==", "diff_hunk": "@@ -2735,12 +2736,13 @@ MklLayoutRewritePass::CheckForNodeFusion(Node* a) const {\n     //\n \n     std::stack<Node *, std::vector<Node *>> work_stack;", "path": "tensorflow/core/graph/mkl_layout_pass.cc", "position": null, "original_position": 39, "commit_id": "88b2369fe7c4451c63ff0599f7477897dabff2e0", "original_commit_id": "81f02368365e096c27f37adc7c9af08905855ed1", "user": {"login": "penpornk", "id": 38085909, "node_id": "MDQ6VXNlcjM4MDg1OTA5", "avatar_url": "https://avatars3.githubusercontent.com/u/38085909?v=4", "gravatar_id": "", "url": "https://api.github.com/users/penpornk", "html_url": "https://github.com/penpornk", "followers_url": "https://api.github.com/users/penpornk/followers", "following_url": "https://api.github.com/users/penpornk/following{/other_user}", "gists_url": "https://api.github.com/users/penpornk/gists{/gist_id}", "starred_url": "https://api.github.com/users/penpornk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/penpornk/subscriptions", "organizations_url": "https://api.github.com/users/penpornk/orgs", "repos_url": "https://api.github.com/users/penpornk/repos", "events_url": "https://api.github.com/users/penpornk/events{/privacy}", "received_events_url": "https://api.github.com/users/penpornk/received_events", "type": "User", "site_admin": false}, "body": "I modified your code to 1) check for match before push, 2) get rid of `work_stack` and store the nodes directly in `nodes` to avoid copying at the end, 3) get rid of `fi_ptr`, and 4) do minor formattings for readability. Please take a look if this is okay. (This might have syntax errors since I didn't try compiling it.)\r\n\r\n```c++\r\nstd::tuple<bool, std::vector<Node*>, const MklLayoutRewritePass::FusionInfo>\r\nMklLayoutRewritePass::CheckForNodeFusion(Node* a) const {\r\n  // Stores matched nodes, in the same order as node_checkers.\r\n  std::vector<Node*> nodes;\r\n\r\n  // Makes sure node \"a\" and its succeding nodes (b, c ...) match the pattern\r\n  // defined in fusion info (ops[0], ops[1], ...),\r\n  // a.k.a., \"a->b->c\" matches \"op1->op2->op3\"\r\n  for (const auto& fi : finfo_) {\r\n    // Stores the first unvisited outgoing edge of each matched node in 'nodes'.\r\n    std::stack<EdgeSet::const_iterator> current_neighbor_stack();\r\n    nodes.clear();\r\n\r\n    auto node_checker = fi.node_checkers.begin();\r\n    if (a != nullptr && node_checker(a)) {\r\n      nodes.push_back(a);\r\n      current_neighbor_stack.push(a->out_edges().begin());\r\n      ++node_checker;  // Length of node_checkers is at least 3 so a match can't\r\n                       // happen yet.\r\n    }\r\n\r\n    while (!nodes.empty()) {\r\n      auto& current_neighbor_iter = current_neighbor_stack.top();\r\n      if (current_neighbor_iter != nodes.back()->out_edges().end()) {\r\n        // Found an unvisited edge. Goes through the edge to get the neighbor.\r\n        Node* neighbor_node = (*current_neighbor_iter)->dst();\r\n        ++current_neighbor_stack.top();  // Retrieves the next unvisited edge.\r\n\r\n        if (node_checker(neighbor_node)) {\r\n          // Found a match. Stores the node and moves to the next checker.\r\n          nodes.push_back(neighbor_node);\r\n          current_neighbor_stack.push(neighbor_node->out_edges().begin());\r\n          if (++node_checker == fi.node_checkers.end()) {\r\n            return make_tuple(true, nodes, fi);\r\n          }\r\n        }\r\n      } else {\r\n        // Removes the current node since none of its neighbor leads to a\r\n        // further match.\r\n        nodes.pop_back();\r\n        current_neighbor_stack.pop();\r\n        --node_checker;\r\n      }\r\n    }\r\n  }\r\n  return make_tuple(false, nodes, finfo_.back());\r\n}\r\n```", "created_at": "2018-11-09T19:43:39Z", "updated_at": "2018-11-14T06:34:27Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/23152#discussion_r232371919", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/23152", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/232371919"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/23152#discussion_r232371919"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/23152"}}, "body_html": "<p>I modified your code to 1) check for match before push, 2) get rid of <code>work_stack</code> and store the nodes directly in <code>nodes</code> to avoid copying at the end, 3) get rid of <code>fi_ptr</code>, and 4) do minor formattings for readability. Please take a look if this is okay. (This might have syntax errors since I didn't try compiling it.)</p>\n<div class=\"highlight highlight-source-c++\"><pre>std::tuple&lt;<span class=\"pl-k\">bool</span>, std::vector&lt;Node*&gt;, <span class=\"pl-k\">const</span> MklLayoutRewritePass::FusionInfo&gt;\n<span class=\"pl-en\">MklLayoutRewritePass::CheckForNodeFusion</span>(Node* a) <span class=\"pl-k\">const</span> {\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span> Stores matched nodes, in the same order as node_checkers.</span>\n  std::vector&lt;Node*&gt; nodes;\n\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span> Makes sure node \"a\" and its succeding nodes (b, c ...) match the pattern</span>\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span> defined in fusion info (ops[0], ops[1], ...),</span>\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span> a.k.a., \"a-&gt;b-&gt;c\" matches \"op1-&gt;op2-&gt;op3\"</span>\n  <span class=\"pl-k\">for</span> (<span class=\"pl-k\">const</span> <span class=\"pl-k\">auto</span>&amp; fi : finfo_) {\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span> Stores the first unvisited outgoing edge of each matched node in 'nodes'.</span>\n    std::stack&lt;EdgeSet::const_iterator&gt; <span class=\"pl-c1\">current_neighbor_stack</span>();\n    nodes.<span class=\"pl-c1\">clear</span>();\n\n    <span class=\"pl-k\">auto</span> node_checker = fi.<span class=\"pl-smi\">node_checkers</span>.<span class=\"pl-c1\">begin</span>();\n    <span class=\"pl-k\">if</span> (a != <span class=\"pl-c1\">nullptr</span> &amp;&amp; <span class=\"pl-c1\">node_checker</span>(a)) {\n      nodes.<span class=\"pl-c1\">push_back</span>(a);\n      current_neighbor_stack.<span class=\"pl-c1\">push</span>(a-&gt;<span class=\"pl-c1\">out_edges</span>().<span class=\"pl-c1\">begin</span>());\n      ++node_checker;  <span class=\"pl-c\"><span class=\"pl-c\">//</span> Length of node_checkers is at least 3 so a match can't</span>\n                       <span class=\"pl-c\"><span class=\"pl-c\">//</span> happen yet.</span>\n    }\n\n    <span class=\"pl-k\">while</span> (!nodes.<span class=\"pl-c1\">empty</span>()) {\n      <span class=\"pl-k\">auto</span>&amp; current_neighbor_iter = current_neighbor_stack.<span class=\"pl-c1\">top</span>();\n      <span class=\"pl-k\">if</span> (current_neighbor_iter != nodes.<span class=\"pl-c1\">back</span>()-&gt;<span class=\"pl-c1\">out_edges</span>().<span class=\"pl-c1\">end</span>()) {\n        <span class=\"pl-c\"><span class=\"pl-c\">//</span> Found an unvisited edge. Goes through the edge to get the neighbor.</span>\n        Node* neighbor_node = (*current_neighbor_iter)-&gt;<span class=\"pl-c1\">dst</span>();\n        ++current_neighbor_stack.<span class=\"pl-c1\">top</span>();  <span class=\"pl-c\"><span class=\"pl-c\">//</span> Retrieves the next unvisited edge.</span>\n\n        <span class=\"pl-k\">if</span> (<span class=\"pl-c1\">node_checker</span>(neighbor_node)) {\n          <span class=\"pl-c\"><span class=\"pl-c\">//</span> Found a match. Stores the node and moves to the next checker.</span>\n          nodes.<span class=\"pl-c1\">push_back</span>(neighbor_node);\n          current_neighbor_stack.<span class=\"pl-c1\">push</span>(neighbor_node-&gt;<span class=\"pl-c1\">out_edges</span>().<span class=\"pl-c1\">begin</span>());\n          <span class=\"pl-k\">if</span> (++node_checker == fi.<span class=\"pl-smi\">node_checkers</span>.<span class=\"pl-c1\">end</span>()) {\n            <span class=\"pl-k\">return</span> <span class=\"pl-c1\">make_tuple</span>(<span class=\"pl-c1\">true</span>, nodes, fi);\n          }\n        }\n      } <span class=\"pl-k\">else</span> {\n        <span class=\"pl-c\"><span class=\"pl-c\">//</span> Removes the current node since none of its neighbor leads to a</span>\n        <span class=\"pl-c\"><span class=\"pl-c\">//</span> further match.</span>\n        nodes.<span class=\"pl-c1\">pop_back</span>();\n        current_neighbor_stack.<span class=\"pl-c1\">pop</span>();\n        --node_checker;\n      }\n    }\n  }\n  <span class=\"pl-k\">return</span> <span class=\"pl-c1\">make_tuple</span>(<span class=\"pl-c1\">false</span>, nodes, finfo_.<span class=\"pl-c1\">back</span>());\n}</pre></div>", "body_text": "I modified your code to 1) check for match before push, 2) get rid of work_stack and store the nodes directly in nodes to avoid copying at the end, 3) get rid of fi_ptr, and 4) do minor formattings for readability. Please take a look if this is okay. (This might have syntax errors since I didn't try compiling it.)\nstd::tuple<bool, std::vector<Node*>, const MklLayoutRewritePass::FusionInfo>\nMklLayoutRewritePass::CheckForNodeFusion(Node* a) const {\n  // Stores matched nodes, in the same order as node_checkers.\n  std::vector<Node*> nodes;\n\n  // Makes sure node \"a\" and its succeding nodes (b, c ...) match the pattern\n  // defined in fusion info (ops[0], ops[1], ...),\n  // a.k.a., \"a->b->c\" matches \"op1->op2->op3\"\n  for (const auto& fi : finfo_) {\n    // Stores the first unvisited outgoing edge of each matched node in 'nodes'.\n    std::stack<EdgeSet::const_iterator> current_neighbor_stack();\n    nodes.clear();\n\n    auto node_checker = fi.node_checkers.begin();\n    if (a != nullptr && node_checker(a)) {\n      nodes.push_back(a);\n      current_neighbor_stack.push(a->out_edges().begin());\n      ++node_checker;  // Length of node_checkers is at least 3 so a match can't\n                       // happen yet.\n    }\n\n    while (!nodes.empty()) {\n      auto& current_neighbor_iter = current_neighbor_stack.top();\n      if (current_neighbor_iter != nodes.back()->out_edges().end()) {\n        // Found an unvisited edge. Goes through the edge to get the neighbor.\n        Node* neighbor_node = (*current_neighbor_iter)->dst();\n        ++current_neighbor_stack.top();  // Retrieves the next unvisited edge.\n\n        if (node_checker(neighbor_node)) {\n          // Found a match. Stores the node and moves to the next checker.\n          nodes.push_back(neighbor_node);\n          current_neighbor_stack.push(neighbor_node->out_edges().begin());\n          if (++node_checker == fi.node_checkers.end()) {\n            return make_tuple(true, nodes, fi);\n          }\n        }\n      } else {\n        // Removes the current node since none of its neighbor leads to a\n        // further match.\n        nodes.pop_back();\n        current_neighbor_stack.pop();\n        --node_checker;\n      }\n    }\n  }\n  return make_tuple(false, nodes, finfo_.back());\n}"}