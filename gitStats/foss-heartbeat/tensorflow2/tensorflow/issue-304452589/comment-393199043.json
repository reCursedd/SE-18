{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/393199043", "html_url": "https://github.com/tensorflow/tensorflow/issues/17650#issuecomment-393199043", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/17650", "id": 393199043, "node_id": "MDEyOklzc3VlQ29tbWVudDM5MzE5OTA0Mw==", "user": {"login": "mrezak", "id": 4903456, "node_id": "MDQ6VXNlcjQ5MDM0NTY=", "avatar_url": "https://avatars0.githubusercontent.com/u/4903456?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mrezak", "html_url": "https://github.com/mrezak", "followers_url": "https://api.github.com/users/mrezak/followers", "following_url": "https://api.github.com/users/mrezak/following{/other_user}", "gists_url": "https://api.github.com/users/mrezak/gists{/gist_id}", "starred_url": "https://api.github.com/users/mrezak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mrezak/subscriptions", "organizations_url": "https://api.github.com/users/mrezak/orgs", "repos_url": "https://api.github.com/users/mrezak/repos", "events_url": "https://api.github.com/users/mrezak/events{/privacy}", "received_events_url": "https://api.github.com/users/mrezak/received_events", "type": "User", "site_admin": false}, "created_at": "2018-05-30T15:08:34Z", "updated_at": "2018-05-30T15:13:35Z", "author_association": "NONE", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=8099614\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/skycoop\">@skycoop</a> I think I have found a workaround to be able to evaluate after certain number of <em>epochs</em>.</p>\n<p>If you return a <em>finite</em> <code>tf.data</code> iterator with certain number of repeated epochs such as:<br>\n<code>dataset= dataset.shuffle(buffer_size=1000).repeat(num_epochs).batch(batch_size)</code><br>\nand set the <code>max_steps</code> in the <code>TrainSpec</code> as:<br>\n<code>train_spec = tf.estimator.TrainSpec(train_input_fn, max_steps=max_train_steps)</code><br>\nwith <code>max_train_steps</code> being large enough to allow multiple training epochs,<br>\nthen <code>tf.estimator.train_and_evaluate</code> will evaluate after each <code>num_epochs</code> and return to training after evaluation until reaching <code>max_train_steps</code>. This will set a fixed frequency of evaluation based on the number of epochs (and not the seconds passed).</p>\n<p>Anyway, +1 for having a <code>throttle_steps</code> in <code>EvalSpec</code>.</p>", "body_text": "@skycoop I think I have found a workaround to be able to evaluate after certain number of epochs.\nIf you return a finite tf.data iterator with certain number of repeated epochs such as:\ndataset= dataset.shuffle(buffer_size=1000).repeat(num_epochs).batch(batch_size)\nand set the max_steps in the TrainSpec as:\ntrain_spec = tf.estimator.TrainSpec(train_input_fn, max_steps=max_train_steps)\nwith max_train_steps being large enough to allow multiple training epochs,\nthen tf.estimator.train_and_evaluate will evaluate after each num_epochs and return to training after evaluation until reaching max_train_steps. This will set a fixed frequency of evaluation based on the number of epochs (and not the seconds passed).\nAnyway, +1 for having a throttle_steps in EvalSpec.", "body": "@skycoop I think I have found a workaround to be able to evaluate after certain number of _epochs_. \r\n\r\nIf you return a _finite_ `tf.data` iterator with certain number of repeated epochs such as:\r\n`dataset= dataset.shuffle(buffer_size=1000).repeat(num_epochs).batch(batch_size)`\r\nand set the `max_steps` in the `TrainSpec` as:\r\n`train_spec = tf.estimator.TrainSpec(train_input_fn, max_steps=max_train_steps)`\r\nwith `max_train_steps` being large enough to allow multiple training epochs, \r\nthen `tf.estimator.train_and_evaluate` will evaluate after each `num_epochs` and return to training after evaluation until reaching `max_train_steps`. This will set a fixed frequency of evaluation based on the number of epochs (and not the seconds passed). \r\n\r\nAnyway, +1 for having a `throttle_steps` in `EvalSpec`."}