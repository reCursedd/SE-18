{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/167004931", "html_url": "https://github.com/tensorflow/tensorflow/issues/608#issuecomment-167004931", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/608", "id": 167004931, "node_id": "MDEyOklzc3VlQ29tbWVudDE2NzAwNDkzMQ==", "user": {"login": "vrv", "id": 463737, "node_id": "MDQ6VXNlcjQ2MzczNw==", "avatar_url": "https://avatars0.githubusercontent.com/u/463737?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vrv", "html_url": "https://github.com/vrv", "followers_url": "https://api.github.com/users/vrv/followers", "following_url": "https://api.github.com/users/vrv/following{/other_user}", "gists_url": "https://api.github.com/users/vrv/gists{/gist_id}", "starred_url": "https://api.github.com/users/vrv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vrv/subscriptions", "organizations_url": "https://api.github.com/users/vrv/orgs", "repos_url": "https://api.github.com/users/vrv/repos", "events_url": "https://api.github.com/users/vrv/events{/privacy}", "received_events_url": "https://api.github.com/users/vrv/received_events", "type": "User", "site_admin": false}, "created_at": "2015-12-23T22:53:27Z", "updated_at": "2015-12-23T22:53:27Z", "author_association": "CONTRIBUTOR", "body_html": "<p>There may be a better way to do it, but if I understand correctly, you may be able to use tf.select to do what you want (may not be the most efficient thing to do memory wise).</p>\n<p>Assuming:<br>\nw_gradient is the matrix representing the gradients of shape [m, n]<br>\nw_gradient_column is whatever reduction function along the column dimension (shape [1, n])<br>\nw_tensor is the original weight matrix<br>\nw_scaled_tensor is w_tensor with the normalization applied for all columns</p>\n<p>First you compute which columns to apply the rescaling to<br>\ncondition_per_column = tf.greater(w_gradient_column, threshold)</p>\n<p>Next you replicate that value along every row to make a boolean tensor of the same shape as w_tensor<br>\ncondition_tiled = tf.tile(condition_per_column, [m, 1])</p>\n<p>Lastly, you create a resulting tensor that applies a mask to select the right value from each tensor.<br>\nresult = tf.select(condition_tiled, w_scaled_tensor, w_tensor)</p>\n<p>Maybe this still isn't what you want, but hopefully you get the point: you can use tf.select and comparison operators to select/mask results conditionally.</p>", "body_text": "There may be a better way to do it, but if I understand correctly, you may be able to use tf.select to do what you want (may not be the most efficient thing to do memory wise).\nAssuming:\nw_gradient is the matrix representing the gradients of shape [m, n]\nw_gradient_column is whatever reduction function along the column dimension (shape [1, n])\nw_tensor is the original weight matrix\nw_scaled_tensor is w_tensor with the normalization applied for all columns\nFirst you compute which columns to apply the rescaling to\ncondition_per_column = tf.greater(w_gradient_column, threshold)\nNext you replicate that value along every row to make a boolean tensor of the same shape as w_tensor\ncondition_tiled = tf.tile(condition_per_column, [m, 1])\nLastly, you create a resulting tensor that applies a mask to select the right value from each tensor.\nresult = tf.select(condition_tiled, w_scaled_tensor, w_tensor)\nMaybe this still isn't what you want, but hopefully you get the point: you can use tf.select and comparison operators to select/mask results conditionally.", "body": "There may be a better way to do it, but if I understand correctly, you may be able to use tf.select to do what you want (may not be the most efficient thing to do memory wise).\n\nAssuming:\nw_gradient is the matrix representing the gradients of shape [m, n]\nw_gradient_column is whatever reduction function along the column dimension (shape [1, n])\nw_tensor is the original weight matrix\nw_scaled_tensor is w_tensor with the normalization applied for all columns\n\nFirst you compute which columns to apply the rescaling to\ncondition_per_column = tf.greater(w_gradient_column, threshold)\n\nNext you replicate that value along every row to make a boolean tensor of the same shape as w_tensor\ncondition_tiled = tf.tile(condition_per_column, [m, 1])\n\nLastly, you create a resulting tensor that applies a mask to select the right value from each tensor.\nresult = tf.select(condition_tiled, w_scaled_tensor, w_tensor)\n\nMaybe this still isn't what you want, but hopefully you get the point: you can use tf.select and comparison operators to select/mask results conditionally.\n"}