{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/407222423", "html_url": "https://github.com/tensorflow/tensorflow/issues/15644#issuecomment-407222423", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/15644", "id": 407222423, "node_id": "MDEyOklzc3VlQ29tbWVudDQwNzIyMjQyMw==", "user": {"login": "aseem-hegshetye", "id": 5171444, "node_id": "MDQ6VXNlcjUxNzE0NDQ=", "avatar_url": "https://avatars1.githubusercontent.com/u/5171444?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aseem-hegshetye", "html_url": "https://github.com/aseem-hegshetye", "followers_url": "https://api.github.com/users/aseem-hegshetye/followers", "following_url": "https://api.github.com/users/aseem-hegshetye/following{/other_user}", "gists_url": "https://api.github.com/users/aseem-hegshetye/gists{/gist_id}", "starred_url": "https://api.github.com/users/aseem-hegshetye/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aseem-hegshetye/subscriptions", "organizations_url": "https://api.github.com/users/aseem-hegshetye/orgs", "repos_url": "https://api.github.com/users/aseem-hegshetye/repos", "events_url": "https://api.github.com/users/aseem-hegshetye/events{/privacy}", "received_events_url": "https://api.github.com/users/aseem-hegshetye/received_events", "type": "User", "site_admin": false}, "created_at": "2018-07-23T22:33:35Z", "updated_at": "2018-07-23T22:33:35Z", "author_association": "NONE", "body_html": "<p>I have created a workaround for tf.unique(2D_tensor). Pass any 2D tensor to the below function and it will return a unique 2D tensor.</p>\n<pre><code>def tf_unique_2d(x):\n    x_shape=x.get_shape() #(3,2)\n    x1=tf.tile(x,[1,x_shape[0]]) #[[1,2],[1,2],[1,2],[3,4],[3,4],[3,4]..]\n    x2=tf.tile(x,[x_shape[0],1]) #[[1,2],[1,2],[1,2],[3,4],[3,4],[3,4]..]\n\n    x1_2=tf.reshape(x1,[x_shape[0]*x_shape[0],x_shape[1]])\n    x2_2=tf.reshape(x2,[x_shape[0]*x_shape[0],x_shape[1]])\n    cond=tf.reduce_all(tf.equal(x1_2,x2_2),axis=1)\n    cond=tf.reshape(cond,[x_shape[0],x_shape[0]]) #reshaping cond to match x1_2 &amp; x2_2\n    cond_shape=cond.get_shape()\n    cond_cast=tf.cast(cond,tf.int32) #convertin condition boolean to int\n    cond_zeros=tf.zeros(cond_shape,tf.int32) #replicating condition tensor into all 0's\n\n    #CREATING RANGE TENSOR\n    r=tf.range(x_shape[0])\n    r=tf.add(tf.tile(r,[x_shape[0]]),1)\n    r=tf.reshape(r,[x_shape[0],x_shape[0]])\n\n    #converting TRUE=1 FALSE=MAX(index)+1 (which is invalid by default) so when we take min it wont get selected &amp; in end we will only take values &lt;max(indx).\n    f1 = tf.multiply(tf.ones(cond_shape,tf.int32),x_shape[0]+1)\n    f2 =tf.ones(cond_shape,tf.int32)\n    cond_cast2 = tf.where(tf.equal(cond_cast,cond_zeros),f1,f2) #if false make it max_index+1 else keep it 1\n\n    #multiply range with new int boolean mask\n    r_cond_mul=tf.multiply(r,cond_cast2)\n    r_cond_mul2=tf.reduce_min(r_cond_mul,axis=1)\n    r_cond_mul3,unique_idx=tf.unique(r_cond_mul2)\n    r_cond_mul4=tf.subtract(r_cond_mul3,1)\n\n    #get actual values from unique indexes\n    op=tf.gather(x,r_cond_mul4)\n\n    sess=tf.Session()\n    return (op)\n</code></pre>\n<pre><code>import tensorflow as tf\nip=tf.constant([[1,2,1],[3,4,1],[5,6,1],[1,2,1]])\nop=tf_unique_2d(ip)\nprint(sess.run(op))\n#op = [[1,2,1],[3,4,1],[5,6,1]]\n</code></pre>", "body_text": "I have created a workaround for tf.unique(2D_tensor). Pass any 2D tensor to the below function and it will return a unique 2D tensor.\ndef tf_unique_2d(x):\n    x_shape=x.get_shape() #(3,2)\n    x1=tf.tile(x,[1,x_shape[0]]) #[[1,2],[1,2],[1,2],[3,4],[3,4],[3,4]..]\n    x2=tf.tile(x,[x_shape[0],1]) #[[1,2],[1,2],[1,2],[3,4],[3,4],[3,4]..]\n\n    x1_2=tf.reshape(x1,[x_shape[0]*x_shape[0],x_shape[1]])\n    x2_2=tf.reshape(x2,[x_shape[0]*x_shape[0],x_shape[1]])\n    cond=tf.reduce_all(tf.equal(x1_2,x2_2),axis=1)\n    cond=tf.reshape(cond,[x_shape[0],x_shape[0]]) #reshaping cond to match x1_2 & x2_2\n    cond_shape=cond.get_shape()\n    cond_cast=tf.cast(cond,tf.int32) #convertin condition boolean to int\n    cond_zeros=tf.zeros(cond_shape,tf.int32) #replicating condition tensor into all 0's\n\n    #CREATING RANGE TENSOR\n    r=tf.range(x_shape[0])\n    r=tf.add(tf.tile(r,[x_shape[0]]),1)\n    r=tf.reshape(r,[x_shape[0],x_shape[0]])\n\n    #converting TRUE=1 FALSE=MAX(index)+1 (which is invalid by default) so when we take min it wont get selected & in end we will only take values <max(indx).\n    f1 = tf.multiply(tf.ones(cond_shape,tf.int32),x_shape[0]+1)\n    f2 =tf.ones(cond_shape,tf.int32)\n    cond_cast2 = tf.where(tf.equal(cond_cast,cond_zeros),f1,f2) #if false make it max_index+1 else keep it 1\n\n    #multiply range with new int boolean mask\n    r_cond_mul=tf.multiply(r,cond_cast2)\n    r_cond_mul2=tf.reduce_min(r_cond_mul,axis=1)\n    r_cond_mul3,unique_idx=tf.unique(r_cond_mul2)\n    r_cond_mul4=tf.subtract(r_cond_mul3,1)\n\n    #get actual values from unique indexes\n    op=tf.gather(x,r_cond_mul4)\n\n    sess=tf.Session()\n    return (op)\n\nimport tensorflow as tf\nip=tf.constant([[1,2,1],[3,4,1],[5,6,1],[1,2,1]])\nop=tf_unique_2d(ip)\nprint(sess.run(op))\n#op = [[1,2,1],[3,4,1],[5,6,1]]", "body": "I have created a workaround for tf.unique(2D_tensor). Pass any 2D tensor to the below function and it will return a unique 2D tensor.\r\n\r\n```\r\ndef tf_unique_2d(x):\r\n    x_shape=x.get_shape() #(3,2)\r\n    x1=tf.tile(x,[1,x_shape[0]]) #[[1,2],[1,2],[1,2],[3,4],[3,4],[3,4]..]\r\n    x2=tf.tile(x,[x_shape[0],1]) #[[1,2],[1,2],[1,2],[3,4],[3,4],[3,4]..]\r\n\r\n    x1_2=tf.reshape(x1,[x_shape[0]*x_shape[0],x_shape[1]])\r\n    x2_2=tf.reshape(x2,[x_shape[0]*x_shape[0],x_shape[1]])\r\n    cond=tf.reduce_all(tf.equal(x1_2,x2_2),axis=1)\r\n    cond=tf.reshape(cond,[x_shape[0],x_shape[0]]) #reshaping cond to match x1_2 & x2_2\r\n    cond_shape=cond.get_shape()\r\n    cond_cast=tf.cast(cond,tf.int32) #convertin condition boolean to int\r\n    cond_zeros=tf.zeros(cond_shape,tf.int32) #replicating condition tensor into all 0's\r\n\r\n    #CREATING RANGE TENSOR\r\n    r=tf.range(x_shape[0])\r\n    r=tf.add(tf.tile(r,[x_shape[0]]),1)\r\n    r=tf.reshape(r,[x_shape[0],x_shape[0]])\r\n\r\n    #converting TRUE=1 FALSE=MAX(index)+1 (which is invalid by default) so when we take min it wont get selected & in end we will only take values <max(indx).\r\n    f1 = tf.multiply(tf.ones(cond_shape,tf.int32),x_shape[0]+1)\r\n    f2 =tf.ones(cond_shape,tf.int32)\r\n    cond_cast2 = tf.where(tf.equal(cond_cast,cond_zeros),f1,f2) #if false make it max_index+1 else keep it 1\r\n\r\n    #multiply range with new int boolean mask\r\n    r_cond_mul=tf.multiply(r,cond_cast2)\r\n    r_cond_mul2=tf.reduce_min(r_cond_mul,axis=1)\r\n    r_cond_mul3,unique_idx=tf.unique(r_cond_mul2)\r\n    r_cond_mul4=tf.subtract(r_cond_mul3,1)\r\n\r\n    #get actual values from unique indexes\r\n    op=tf.gather(x,r_cond_mul4)\r\n\r\n    sess=tf.Session()\r\n    return (op)\r\n```\r\n\r\n```\r\nimport tensorflow as tf\r\nip=tf.constant([[1,2,1],[3,4,1],[5,6,1],[1,2,1]])\r\nop=tf_unique_2d(ip)\r\nprint(sess.run(op))\r\n#op = [[1,2,1],[3,4,1],[5,6,1]]\r\n```"}