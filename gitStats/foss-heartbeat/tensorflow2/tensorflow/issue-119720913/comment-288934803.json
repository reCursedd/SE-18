{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/288934803", "html_url": "https://github.com/tensorflow/tensorflow/issues/386#issuecomment-288934803", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/386", "id": 288934803, "node_id": "MDEyOklzc3VlQ29tbWVudDI4ODkzNDgwMw==", "user": {"login": "rryan", "id": 26527, "node_id": "MDQ6VXNlcjI2NTI3", "avatar_url": "https://avatars3.githubusercontent.com/u/26527?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rryan", "html_url": "https://github.com/rryan", "followers_url": "https://api.github.com/users/rryan/followers", "following_url": "https://api.github.com/users/rryan/following{/other_user}", "gists_url": "https://api.github.com/users/rryan/gists{/gist_id}", "starred_url": "https://api.github.com/users/rryan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rryan/subscriptions", "organizations_url": "https://api.github.com/users/rryan/orgs", "repos_url": "https://api.github.com/users/rryan/repos", "events_url": "https://api.github.com/users/rryan/events{/privacy}", "received_events_url": "https://api.github.com/users/rryan/received_events", "type": "User", "site_admin": false}, "created_at": "2017-03-24T05:09:24Z", "updated_at": "2017-03-24T05:09:24Z", "author_association": "MEMBER", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=568733\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/Timeroot\">@Timeroot</a> as a workaround until we get CPU FFT kernels added you can compute a 1D Fourier transform on CPUs with a matrix multiply:</p>\n<div class=\"highlight highlight-source-python\"><pre>complex_signal <span class=\"pl-k\">=</span> <span class=\"pl-c1\">...</span>\nft_length <span class=\"pl-k\">=</span> <span class=\"pl-c1\">1024</span>\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> Compute the DFT matrix for a given length. scipy has a built-in for this.</span>\ndft_matrix <span class=\"pl-k\">=</span> tf.constant(scipy.linalg.dft(ft_length).astype(np.complex64))\nc2c_result <span class=\"pl-k\">=</span> tf.matmul(complex_signal, dft_matrix)</pre></div>\n<p>If you want the r2c, just slice the <code>fft_length / 2 + 1</code> unique components.</p>\n<div class=\"highlight highlight-source-python\"><pre>complex_signal <span class=\"pl-k\">=</span> tf.complex(real_signal, tf.zeros_like(real_signal))\n<span class=\"pl-c1\">...</span> example <span class=\"pl-k\">as</span> above <span class=\"pl-c1\">...</span>\nunique <span class=\"pl-k\">=</span> ft_length <span class=\"pl-k\">/</span> <span class=\"pl-c1\">2</span> <span class=\"pl-k\">+</span> <span class=\"pl-c1\">1</span>\nr2c_result <span class=\"pl-k\">=</span> c2c_result[<span class=\"pl-c1\">...</span>, :unique]</pre></div>", "body_text": "@Timeroot as a workaround until we get CPU FFT kernels added you can compute a 1D Fourier transform on CPUs with a matrix multiply:\ncomplex_signal = ...\nft_length = 1024\n# Compute the DFT matrix for a given length. scipy has a built-in for this.\ndft_matrix = tf.constant(scipy.linalg.dft(ft_length).astype(np.complex64))\nc2c_result = tf.matmul(complex_signal, dft_matrix)\nIf you want the r2c, just slice the fft_length / 2 + 1 unique components.\ncomplex_signal = tf.complex(real_signal, tf.zeros_like(real_signal))\n... example as above ...\nunique = ft_length / 2 + 1\nr2c_result = c2c_result[..., :unique]", "body": "@Timeroot as a workaround until we get CPU FFT kernels added you can compute a 1D Fourier transform on CPUs with a matrix multiply:\r\n```python\r\ncomplex_signal = ...\r\nft_length = 1024\r\n# Compute the DFT matrix for a given length. scipy has a built-in for this.\r\ndft_matrix = tf.constant(scipy.linalg.dft(ft_length).astype(np.complex64))\r\nc2c_result = tf.matmul(complex_signal, dft_matrix)\r\n```\r\n\r\nIf you want the r2c, just slice the `fft_length / 2 + 1` unique components.\r\n\r\n```python\r\ncomplex_signal = tf.complex(real_signal, tf.zeros_like(real_signal))\r\n... example as above ...\r\nunique = ft_length / 2 + 1\r\nr2c_result = c2c_result[..., :unique]\r\n```"}