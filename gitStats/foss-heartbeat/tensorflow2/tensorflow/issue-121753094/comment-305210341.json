{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/305210341", "html_url": "https://github.com/tensorflow/tensorflow/issues/483#issuecomment-305210341", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/483", "id": 305210341, "node_id": "MDEyOklzc3VlQ29tbWVudDMwNTIxMDM0MQ==", "user": {"login": "fbcotter", "id": 10693074, "node_id": "MDQ6VXNlcjEwNjkzMDc0", "avatar_url": "https://avatars0.githubusercontent.com/u/10693074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fbcotter", "html_url": "https://github.com/fbcotter", "followers_url": "https://api.github.com/users/fbcotter/followers", "following_url": "https://api.github.com/users/fbcotter/following{/other_user}", "gists_url": "https://api.github.com/users/fbcotter/gists{/gist_id}", "starred_url": "https://api.github.com/users/fbcotter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fbcotter/subscriptions", "organizations_url": "https://api.github.com/users/fbcotter/orgs", "repos_url": "https://api.github.com/users/fbcotter/repos", "events_url": "https://api.github.com/users/fbcotter/events{/privacy}", "received_events_url": "https://api.github.com/users/fbcotter/received_events", "type": "User", "site_admin": false}, "created_at": "2017-05-31T14:48:59Z", "updated_at": "2017-05-31T14:48:59Z", "author_association": "CONTRIBUTOR", "body_html": "<p>(This is obviously only a temporary fix for those that find themselves at this thread before the official tf.arg is added). You can do it with existing tensorflow operations, like:</p>\n<pre><code>def angle(z):\n    \"\"\"\n    Returns the elementwise arctan of z, choosing the quadrant correctly.\n\n    Quadrant I: arctan(y/x)\n    Qaudrant II: \u03c0 + arctan(y/x) (phase of x&lt;0, y=0 is \u03c0)\n    Quadrant III: -\u03c0 + arctan(y/x)\n    Quadrant IV: arctan(y/x)\n\n    Inputs:\n        z: tf.complex64 or tf.complex128 tensor\n    Retunrs:\n        Angle of z\n    \"\"\"\n    if z.dtype == tf.complex128:\n        dtype = tf.float64\n    else:\n        dtype = tf.float32\n    x = tf.real(z)\n    y = tf.imag(z)\n    xneg = tf.cast(x &lt; 0.0, dtype)\n    yneg = tf.cast(y &lt; 0.0, dtype)\n    ypos = tf.cast(y &gt;= 0.0, dtype)\n\n    offset = xneg * (ypos - yneg) * np.pi\n\n    return tf.atan(y / x) + offset\n</code></pre>", "body_text": "(This is obviously only a temporary fix for those that find themselves at this thread before the official tf.arg is added). You can do it with existing tensorflow operations, like:\ndef angle(z):\n    \"\"\"\n    Returns the elementwise arctan of z, choosing the quadrant correctly.\n\n    Quadrant I: arctan(y/x)\n    Qaudrant II: \u03c0 + arctan(y/x) (phase of x<0, y=0 is \u03c0)\n    Quadrant III: -\u03c0 + arctan(y/x)\n    Quadrant IV: arctan(y/x)\n\n    Inputs:\n        z: tf.complex64 or tf.complex128 tensor\n    Retunrs:\n        Angle of z\n    \"\"\"\n    if z.dtype == tf.complex128:\n        dtype = tf.float64\n    else:\n        dtype = tf.float32\n    x = tf.real(z)\n    y = tf.imag(z)\n    xneg = tf.cast(x < 0.0, dtype)\n    yneg = tf.cast(y < 0.0, dtype)\n    ypos = tf.cast(y >= 0.0, dtype)\n\n    offset = xneg * (ypos - yneg) * np.pi\n\n    return tf.atan(y / x) + offset", "body": "(This is obviously only a temporary fix for those that find themselves at this thread before the official tf.arg is added). You can do it with existing tensorflow operations, like:\r\n\r\n    def angle(z):\r\n        \"\"\"\r\n        Returns the elementwise arctan of z, choosing the quadrant correctly.\r\n\r\n        Quadrant I: arctan(y/x)\r\n        Qaudrant II: \u03c0 + arctan(y/x) (phase of x<0, y=0 is \u03c0)\r\n        Quadrant III: -\u03c0 + arctan(y/x)\r\n        Quadrant IV: arctan(y/x)\r\n\r\n        Inputs:\r\n            z: tf.complex64 or tf.complex128 tensor\r\n        Retunrs:\r\n            Angle of z\r\n        \"\"\"\r\n        if z.dtype == tf.complex128:\r\n            dtype = tf.float64\r\n        else:\r\n            dtype = tf.float32\r\n        x = tf.real(z)\r\n        y = tf.imag(z)\r\n        xneg = tf.cast(x < 0.0, dtype)\r\n        yneg = tf.cast(y < 0.0, dtype)\r\n        ypos = tf.cast(y >= 0.0, dtype)\r\n\r\n        offset = xneg * (ypos - yneg) * np.pi\r\n\r\n        return tf.atan(y / x) + offset"}