{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/192443653", "html_url": "https://github.com/tensorflow/tensorflow/issues/483#issuecomment-192443653", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/483", "id": 192443653, "node_id": "MDEyOklzc3VlQ29tbWVudDE5MjQ0MzY1Mw==", "user": {"login": "RyanYoung25", "id": 3376419, "node_id": "MDQ6VXNlcjMzNzY0MTk=", "avatar_url": "https://avatars0.githubusercontent.com/u/3376419?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RyanYoung25", "html_url": "https://github.com/RyanYoung25", "followers_url": "https://api.github.com/users/RyanYoung25/followers", "following_url": "https://api.github.com/users/RyanYoung25/following{/other_user}", "gists_url": "https://api.github.com/users/RyanYoung25/gists{/gist_id}", "starred_url": "https://api.github.com/users/RyanYoung25/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RyanYoung25/subscriptions", "organizations_url": "https://api.github.com/users/RyanYoung25/orgs", "repos_url": "https://api.github.com/users/RyanYoung25/repos", "events_url": "https://api.github.com/users/RyanYoung25/events{/privacy}", "received_events_url": "https://api.github.com/users/RyanYoung25/received_events", "type": "User", "site_admin": false}, "created_at": "2016-03-04T20:05:32Z", "updated_at": "2016-03-04T20:05:32Z", "author_association": "NONE", "body_html": "<p>We were able to get arctan implemented and working great with complex64 numbers. We're running into an issue with registering the scalar_arg_op with the complex64 data type. We can get arg to compile when we register it only with floats and double without errors, but when we call it in python it fails when passed a complex64 as expected. We think the error we are getting stems from:</p>\n<pre><code>no known conversion for argument 1 from \n'Eigen::TensorEvaluator&lt;Eigen::TensorMap&lt;Eigen::Tensor&lt;std::complex&lt;float&gt;, 1, 1, long int&gt;, 16&gt;, \nEigen::ThreadPoolDevice&gt;::Scalar* {aka std::complex&lt;float&gt;*}' to 'Eigen::TensorEvaluator&lt;const \nEigen::TensorCwiseUnaryOp&lt;Eigen::internal::scalar_arg_op&lt;std::complex&lt;float&gt; &gt;, const \nEigen::TensorMap&lt;Eigen::Tensor&lt;const std::complex&lt;float&gt;, 1, 1, long int&gt;, 16&gt; &gt;, \nEigen::ThreadPoolDevice&gt;::Scalar* {aka float*}\n</code></pre>\n<p>does this look familiar to anyone that could point us in the right direction? If not we will use arctan to implement arg.</p>", "body_text": "We were able to get arctan implemented and working great with complex64 numbers. We're running into an issue with registering the scalar_arg_op with the complex64 data type. We can get arg to compile when we register it only with floats and double without errors, but when we call it in python it fails when passed a complex64 as expected. We think the error we are getting stems from:\nno known conversion for argument 1 from \n'Eigen::TensorEvaluator<Eigen::TensorMap<Eigen::Tensor<std::complex<float>, 1, 1, long int>, 16>, \nEigen::ThreadPoolDevice>::Scalar* {aka std::complex<float>*}' to 'Eigen::TensorEvaluator<const \nEigen::TensorCwiseUnaryOp<Eigen::internal::scalar_arg_op<std::complex<float> >, const \nEigen::TensorMap<Eigen::Tensor<const std::complex<float>, 1, 1, long int>, 16> >, \nEigen::ThreadPoolDevice>::Scalar* {aka float*}\n\ndoes this look familiar to anyone that could point us in the right direction? If not we will use arctan to implement arg.", "body": "We were able to get arctan implemented and working great with complex64 numbers. We're running into an issue with registering the scalar_arg_op with the complex64 data type. We can get arg to compile when we register it only with floats and double without errors, but when we call it in python it fails when passed a complex64 as expected. We think the error we are getting stems from: \n\n```\nno known conversion for argument 1 from \n'Eigen::TensorEvaluator<Eigen::TensorMap<Eigen::Tensor<std::complex<float>, 1, 1, long int>, 16>, \nEigen::ThreadPoolDevice>::Scalar* {aka std::complex<float>*}' to 'Eigen::TensorEvaluator<const \nEigen::TensorCwiseUnaryOp<Eigen::internal::scalar_arg_op<std::complex<float> >, const \nEigen::TensorMap<Eigen::Tensor<const std::complex<float>, 1, 1, long int>, 16> >, \nEigen::ThreadPoolDevice>::Scalar* {aka float*}\n```\n\ndoes this look familiar to anyone that could point us in the right direction? If not we will use arctan to implement arg.  \n"}