{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11701", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11701/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11701/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11701/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/11701", "id": 244956043, "node_id": "MDU6SXNzdWUyNDQ5NTYwNDM=", "number": 11701, "title": "tf.contrib.learn.KMeansClustering squeeze problem when using predict()", "user": {"login": "ddurham2", "id": 4805134, "node_id": "MDQ6VXNlcjQ4MDUxMzQ=", "avatar_url": "https://avatars3.githubusercontent.com/u/4805134?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ddurham2", "html_url": "https://github.com/ddurham2", "followers_url": "https://api.github.com/users/ddurham2/followers", "following_url": "https://api.github.com/users/ddurham2/following{/other_user}", "gists_url": "https://api.github.com/users/ddurham2/gists{/gist_id}", "starred_url": "https://api.github.com/users/ddurham2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ddurham2/subscriptions", "organizations_url": "https://api.github.com/users/ddurham2/orgs", "repos_url": "https://api.github.com/users/ddurham2/repos", "events_url": "https://api.github.com/users/ddurham2/events{/privacy}", "received_events_url": "https://api.github.com/users/ddurham2/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 404586594, "node_id": "MDU6TGFiZWw0MDQ1ODY1OTQ=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:awaiting%20tensorflower", "name": "stat:awaiting tensorflower", "color": "f4b400", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2017-07-24T02:17:40Z", "updated_at": "2017-12-22T22:27:10Z", "closed_at": "2017-12-22T22:27:10Z", "author_association": "CONTRIBUTOR", "body_html": "<p>This is a problem with every version of tensorflow I've tried (1.1, 1.2, 1.3).</p>\n<p>After using the fit() method train a KMeansClustering model, if the predict() method is used to predict a <em>single</em> data point's cluster then there is an internal error (predicting two data points works fine)...</p>\n<p>In ./tensorflow/contrib/learn/python/learn/estimators/estimator.py in _predict_generator() the batch_length is rightly determined by asking for the first dimension of the shape, but the problem is (at least for KMeansClustering) ./tensorflow/contrib/factorization/python/ops/clustering_ops.py _infer_graph() uses tf.squeeze to remove all dimensions with size of 1 for the distances and indices.  An error occurs when computing batch_size because the value will have rank 0 after the squeeze.  This appears to have been there since gardener@ originally imported that code for computing kmeans.</p>\n<p>A) This certainly does not need to squeeze the first dimension as, in my case, if predict() is called for a single value, then the distances and indices are both just one element.<br>\nB) I cannot really see why a squeeze should be done there in the first place.  Perhaps flatten? (that doesn't make sense either)</p>\n<p>I have a pull request ready which just removes the squeeze.  But I wanted to file an issue to which the original developer might be able to comment.</p>\n<p>Or I can try to make it squeeze all but the first dimension, though the shape of those tensors are unknown when the graph is built. I'll have to figure out how to do that. I'd prefer to just not squeeze if it's not necessary.</p>\n<p>Here is a script that demonstrates the problem:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-c\"><span class=\"pl-c\">#</span>/usr/bin/python3</span>\n\n<span class=\"pl-k\">import</span> tensorflow <span class=\"pl-k\">as</span> tf\n\nK <span class=\"pl-k\">=</span> <span class=\"pl-c1\">4</span>    <span class=\"pl-c\"><span class=\"pl-c\">#</span> K classes</span>\nkm <span class=\"pl-k\">=</span> tf.contrib.learn.KMeansClustering(K, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>/tmp/test-kmeans-tf-model<span class=\"pl-pds\">'</span></span>)\n\nX <span class=\"pl-k\">=</span> [[<span class=\"pl-c1\">1.1</span>, <span class=\"pl-c1\">1.2</span>],\n     [<span class=\"pl-c1\">2.2</span>, <span class=\"pl-c1\">2.5</span>],\n     [<span class=\"pl-c1\">3.3</span>, <span class=\"pl-c1\">3.6</span>],\n     [<span class=\"pl-c1\">2.4</span>, <span class=\"pl-c1\">2.7</span>],\n     [<span class=\"pl-c1\">14.1</span>, <span class=\"pl-c1\">3.2</span>],\n     [<span class=\"pl-c1\">4.12</span>, <span class=\"pl-c1\">15.2</span>],\n     [<span class=\"pl-c1\">3.14</span>, <span class=\"pl-c1\">3.6</span>],\n     [<span class=\"pl-c1\">2.4</span>, <span class=\"pl-c1\">13.7</span>],\n     [<span class=\"pl-c1\">3.1</span>, <span class=\"pl-c1\">3.2</span>],\n     [<span class=\"pl-c1\">4.1</span>, <span class=\"pl-c1\">4.2</span>],\n     [<span class=\"pl-c1\">13.1</span>, <span class=\"pl-c1\">13.2</span>],\n     [<span class=\"pl-c1\">4.11</span>, <span class=\"pl-c1\">14.2</span>],\n     [<span class=\"pl-c1\">5.1</span>, <span class=\"pl-c1\">15.2</span>]]\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">train_input_fn</span>():\n    data <span class=\"pl-k\">=</span> tf.constant(X, tf.float32)\n    <span class=\"pl-k\">return</span> (data, <span class=\"pl-c1\">None</span>)\n\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> train</span>\nkm.fit(<span class=\"pl-v\">input_fn</span><span class=\"pl-k\">=</span>train_input_fn, <span class=\"pl-v\">steps</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">1000</span>)\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">predict_input_fn</span>():\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span>## WORKS FINE</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span>data = tf.constant([[2.1, 3.1], [1.1, 1.2]])</span>\n\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span>## FAILS TO PREDICT</span>\n    data <span class=\"pl-k\">=</span> tf.constant([[<span class=\"pl-c1\">1.1</span>, <span class=\"pl-c1\">1.2</span>]])\n    <span class=\"pl-k\">return</span> data\n\ngen <span class=\"pl-k\">=</span> km.predict(<span class=\"pl-v\">input_fn</span><span class=\"pl-k\">=</span>predict_input_fn, <span class=\"pl-v\">as_iterable</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">True</span>)\n<span class=\"pl-k\">for</span> t <span class=\"pl-k\">in</span> gen:\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>predict returned: <span class=\"pl-c1\">%s</span><span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">%</span> t[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>cluster_idx<span class=\"pl-pds\">'</span></span>])\n\n</pre></div>\n<p>Removing the squeeze in clustering_ops.py fixes this script's problem (or give it two data points to predict).</p>", "body_text": "This is a problem with every version of tensorflow I've tried (1.1, 1.2, 1.3).\nAfter using the fit() method train a KMeansClustering model, if the predict() method is used to predict a single data point's cluster then there is an internal error (predicting two data points works fine)...\nIn ./tensorflow/contrib/learn/python/learn/estimators/estimator.py in _predict_generator() the batch_length is rightly determined by asking for the first dimension of the shape, but the problem is (at least for KMeansClustering) ./tensorflow/contrib/factorization/python/ops/clustering_ops.py _infer_graph() uses tf.squeeze to remove all dimensions with size of 1 for the distances and indices.  An error occurs when computing batch_size because the value will have rank 0 after the squeeze.  This appears to have been there since gardener@ originally imported that code for computing kmeans.\nA) This certainly does not need to squeeze the first dimension as, in my case, if predict() is called for a single value, then the distances and indices are both just one element.\nB) I cannot really see why a squeeze should be done there in the first place.  Perhaps flatten? (that doesn't make sense either)\nI have a pull request ready which just removes the squeeze.  But I wanted to file an issue to which the original developer might be able to comment.\nOr I can try to make it squeeze all but the first dimension, though the shape of those tensors are unknown when the graph is built. I'll have to figure out how to do that. I'd prefer to just not squeeze if it's not necessary.\nHere is a script that demonstrates the problem:\n#/usr/bin/python3\n\nimport tensorflow as tf\n\nK = 4    # K classes\nkm = tf.contrib.learn.KMeansClustering(K, '/tmp/test-kmeans-tf-model')\n\nX = [[1.1, 1.2],\n     [2.2, 2.5],\n     [3.3, 3.6],\n     [2.4, 2.7],\n     [14.1, 3.2],\n     [4.12, 15.2],\n     [3.14, 3.6],\n     [2.4, 13.7],\n     [3.1, 3.2],\n     [4.1, 4.2],\n     [13.1, 13.2],\n     [4.11, 14.2],\n     [5.1, 15.2]]\n\ndef train_input_fn():\n    data = tf.constant(X, tf.float32)\n    return (data, None)\n\n\n# train\nkm.fit(input_fn=train_input_fn, steps=1000)\n\ndef predict_input_fn():\n    ### WORKS FINE\n    #data = tf.constant([[2.1, 3.1], [1.1, 1.2]])\n\n    ### FAILS TO PREDICT\n    data = tf.constant([[1.1, 1.2]])\n    return data\n\ngen = km.predict(input_fn=predict_input_fn, as_iterable=True)\nfor t in gen:\n    print(\"predict returned: %s\" % t['cluster_idx'])\n\n\nRemoving the squeeze in clustering_ops.py fixes this script's problem (or give it two data points to predict).", "body": "This is a problem with every version of tensorflow I've tried (1.1, 1.2, 1.3).\r\n\r\nAfter using the fit() method train a KMeansClustering model, if the predict() method is used to predict a *single* data point's cluster then there is an internal error (predicting two data points works fine)...\r\n\r\nIn ./tensorflow/contrib/learn/python/learn/estimators/estimator.py in _predict_generator() the batch_length is rightly determined by asking for the first dimension of the shape, but the problem is (at least for KMeansClustering) ./tensorflow/contrib/factorization/python/ops/clustering_ops.py _infer_graph() uses tf.squeeze to remove all dimensions with size of 1 for the distances and indices.  An error occurs when computing batch_size because the value will have rank 0 after the squeeze.  This appears to have been there since gardener@ originally imported that code for computing kmeans.\r\n\r\nA) This certainly does not need to squeeze the first dimension as, in my case, if predict() is called for a single value, then the distances and indices are both just one element.\r\nB) I cannot really see why a squeeze should be done there in the first place.  Perhaps flatten? (that doesn't make sense either)\r\n\r\nI have a pull request ready which just removes the squeeze.  But I wanted to file an issue to which the original developer might be able to comment.\r\n\r\nOr I can try to make it squeeze all but the first dimension, though the shape of those tensors are unknown when the graph is built. I'll have to figure out how to do that. I'd prefer to just not squeeze if it's not necessary.\r\n\r\nHere is a script that demonstrates the problem:\r\n```python\r\n#/usr/bin/python3\r\n\r\nimport tensorflow as tf\r\n\r\nK = 4    # K classes\r\nkm = tf.contrib.learn.KMeansClustering(K, '/tmp/test-kmeans-tf-model')\r\n\r\nX = [[1.1, 1.2],\r\n     [2.2, 2.5],\r\n     [3.3, 3.6],\r\n     [2.4, 2.7],\r\n     [14.1, 3.2],\r\n     [4.12, 15.2],\r\n     [3.14, 3.6],\r\n     [2.4, 13.7],\r\n     [3.1, 3.2],\r\n     [4.1, 4.2],\r\n     [13.1, 13.2],\r\n     [4.11, 14.2],\r\n     [5.1, 15.2]]\r\n\r\ndef train_input_fn():\r\n    data = tf.constant(X, tf.float32)\r\n    return (data, None)\r\n\r\n\r\n# train\r\nkm.fit(input_fn=train_input_fn, steps=1000)\r\n\r\ndef predict_input_fn():\r\n    ### WORKS FINE\r\n    #data = tf.constant([[2.1, 3.1], [1.1, 1.2]])\r\n\r\n    ### FAILS TO PREDICT\r\n    data = tf.constant([[1.1, 1.2]])\r\n    return data\r\n\r\ngen = km.predict(input_fn=predict_input_fn, as_iterable=True)\r\nfor t in gen:\r\n    print(\"predict returned: %s\" % t['cluster_idx'])\r\n\r\n\r\n```\r\nRemoving the squeeze in clustering_ops.py fixes this script's problem (or give it two data points to predict).\r\n"}