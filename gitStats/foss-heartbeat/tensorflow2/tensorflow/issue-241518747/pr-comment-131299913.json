{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/131299913", "pull_request_review_id": 54267070, "id": 131299913, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEzMTI5OTkxMw==", "diff_hunk": "@@ -0,0 +1,182 @@\n+#include \"tensorflow/contrib/gdr/gdr_rendezvous_mgr.h\"\n+\n+#include \"tensorflow/contrib/gdr/gdr_memory_manager.h\"\n+#include \"tensorflow/core/common_runtime/device.h\"\n+#include \"tensorflow/core/common_runtime/device_mgr.h\"\n+#include \"tensorflow/core/common_runtime/process_util.h\"\n+#include \"tensorflow/core/distributed_runtime/tensor_coding.h\"\n+#include \"tensorflow/core/distributed_runtime/worker_cache.h\"\n+#include \"tensorflow/core/distributed_runtime/worker_interface.h\"\n+#include \"tensorflow/core/framework/types.h\"\n+#include \"tensorflow/core/lib/core/errors.h\"\n+#include \"tensorflow/core/lib/strings/numbers.h\"\n+#include \"tensorflow/core/lib/strings/str_util.h\"\n+#include \"tensorflow/core/platform/logging.h\"\n+#include \"tensorflow/core/platform/macros.h\"\n+#include \"tensorflow/core/platform/types.h\"\n+\n+namespace tensorflow {\n+\n+namespace {\n+\n+class GdrRecvTensorCall : public BaseRecvTensorCall {\n+ public:\n+  GdrRecvTensorCall(WorkerInterface* wi, Device* dst_device,\n+                    RemoteMemoryManager* remote_memory_manager,\n+                    const Rendezvous::Args& recv_args, int64 step_id,\n+                    StringPiece key)\n+      : wi_(wi),\n+        dst_device_(dst_device),\n+        remote_memory_manager_(remote_memory_manager),\n+        recv_args_(recv_args) {\n+    req_.set_step_id(step_id);\n+    req_.set_rendezvous_key(key.data(), key.size());\n+  }\n+\n+  ~GdrRecvTensorCall() override {}\n+\n+  void Start(std::function<void()> recv_done) override {\n+    req_.set_dma_ok(true);\n+    resp_.InitAlloc(dst_device_, recv_args_.alloc_attrs);\n+    StatusCallback cb = [this, recv_done](const Status& s) {\n+      bool dma_ok = resp_.metadata().has_transport_options();\n+      if (s.ok() && tensor().TotalBytes() > 0 && (!is_dead()) && dma_ok) {\n+        auto transport_options = resp_.metadata().transport_options();\n+        Status s = remote_memory_manager_->TensorFromTransportOptions(\n+            const_cast<Tensor*>(&tensor()), transport_options, dst_device_,\n+            recv_args_.device_context, recv_args_.alloc_attrs.on_host());", "path": "tensorflow/contrib/gdr/gdr_rendezvous_mgr.cc", "position": null, "original_position": 47, "commit_id": "241c020c64410ca16683a7a7f42b223f422e5dae", "original_commit_id": "955764316dd9c796db874ae2034e336a48b1fb46", "user": {"login": "byronyi", "id": 2613663, "node_id": "MDQ6VXNlcjI2MTM2NjM=", "avatar_url": "https://avatars2.githubusercontent.com/u/2613663?v=4", "gravatar_id": "", "url": "https://api.github.com/users/byronyi", "html_url": "https://github.com/byronyi", "followers_url": "https://api.github.com/users/byronyi/followers", "following_url": "https://api.github.com/users/byronyi/following{/other_user}", "gists_url": "https://api.github.com/users/byronyi/gists{/gist_id}", "starred_url": "https://api.github.com/users/byronyi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/byronyi/subscriptions", "organizations_url": "https://api.github.com/users/byronyi/orgs", "repos_url": "https://api.github.com/users/byronyi/repos", "events_url": "https://api.github.com/users/byronyi/events{/privacy}", "received_events_url": "https://api.github.com/users/byronyi/received_events", "type": "User", "site_admin": false}, "body": "The `on_host` parameter is only used [here](https://github.com/red-bird/tensorflow/blob/955764316dd9c796db874ae2034e336a48b1fb46/tensorflow/contrib/gdr/gdr_memory_manager.cc#L390) and [there](https://github.com/red-bird/tensorflow/blob/955764316dd9c796db874ae2034e336a48b1fb46/tensorflow/contrib/gdr/gdr_memory_manager.cc#L448) when the passed tensor cannot be found in the NIC-registered regions. And if we register ordinary CPU tensors to NIC, they could be transferred by RDMA directly.\r\n\r\nBeing said that, I agree that we could use a more accurate flag than `alloc_attrs.on_host`. Any suggestions?", "created_at": "2017-08-04T02:19:38Z", "updated_at": "2017-08-08T01:02:01Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/11392#discussion_r131299913", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/11392", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/131299913"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/11392#discussion_r131299913"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/11392"}}, "body_html": "<p>The <code>on_host</code> parameter is only used <a href=\"https://github.com/red-bird/tensorflow/blob/955764316dd9c796db874ae2034e336a48b1fb46/tensorflow/contrib/gdr/gdr_memory_manager.cc#L390\">here</a> and <a href=\"https://github.com/red-bird/tensorflow/blob/955764316dd9c796db874ae2034e336a48b1fb46/tensorflow/contrib/gdr/gdr_memory_manager.cc#L448\">there</a> when the passed tensor cannot be found in the NIC-registered regions. And if we register ordinary CPU tensors to NIC, they could be transferred by RDMA directly.</p>\n<p>Being said that, I agree that we could use a more accurate flag than <code>alloc_attrs.on_host</code>. Any suggestions?</p>", "body_text": "The on_host parameter is only used here and there when the passed tensor cannot be found in the NIC-registered regions. And if we register ordinary CPU tensors to NIC, they could be transferred by RDMA directly.\nBeing said that, I agree that we could use a more accurate flag than alloc_attrs.on_host. Any suggestions?", "in_reply_to_id": 131219237}