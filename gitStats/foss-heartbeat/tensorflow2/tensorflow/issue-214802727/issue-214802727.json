{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8478", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8478/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8478/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8478/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/8478", "id": 214802727, "node_id": "MDU6SXNzdWUyMTQ4MDI3Mjc=", "number": 8478, "title": "synchronous posix file mmap", "user": {"login": "samwhitlock", "id": 433170, "node_id": "MDQ6VXNlcjQzMzE3MA==", "avatar_url": "https://avatars3.githubusercontent.com/u/433170?v=4", "gravatar_id": "", "url": "https://api.github.com/users/samwhitlock", "html_url": "https://github.com/samwhitlock", "followers_url": "https://api.github.com/users/samwhitlock/followers", "following_url": "https://api.github.com/users/samwhitlock/following{/other_user}", "gists_url": "https://api.github.com/users/samwhitlock/gists{/gist_id}", "starred_url": "https://api.github.com/users/samwhitlock/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/samwhitlock/subscriptions", "organizations_url": "https://api.github.com/users/samwhitlock/orgs", "repos_url": "https://api.github.com/users/samwhitlock/repos", "events_url": "https://api.github.com/users/samwhitlock/events{/privacy}", "received_events_url": "https://api.github.com/users/samwhitlock/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 404586594, "node_id": "MDU6TGFiZWw0MDQ1ODY1OTQ=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:awaiting%20tensorflower", "name": "stat:awaiting tensorflower", "color": "f4b400", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 9, "created_at": "2017-03-16T18:47:02Z", "updated_at": "2017-03-20T15:38:29Z", "closed_at": "2017-03-20T15:38:29Z", "author_association": "NONE", "body_html": "<p>TensorFlow's <a href=\"https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/platform/posix/posix_file_system.cc#L172\">PosixFileSystem::NewReadOnlyMemoryRegionFromFile method</a> calls <code>mmap</code> with <a href=\"https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/platform/posix/posix_file_system.cc#L183\">only the <code>MAP_PRIVATE</code> flag specified</a>.</p>\n<p>Having the ability to specify that flag, at least to specify <code>MAP_POPULATE</code> would be very useful for many applications with high disk I/O throughput. For the <code>MAP_POPULATE</code> case, I sped up one of my graphs by ~4x by adding that flag because I have a pipeline that:</p>\n<ol>\n<li>reads in a file of N chunks in size</li>\n<li>enqueues a pointer to each of those N chunks in an output queue</li>\n<li>downstream nodes process one chunk at a time</li>\n</ol>\n<p>Because of the lack of coordination between the downstream nodes (each being independent), they would take page faults in an uncoordinated manner. When I added <code>MAP_POPULATE</code> this went away.</p>\n<p>I have a patch to add this feature where I change the <a href=\"https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/platform/file_system.h#L102\">base method</a> to look like this:</p>\n<pre><code>virtual Status NewReadOnlyMemoryRegionFromFile(\n  const string&amp; fname, std::unique_ptr&lt;ReadOnlyMemoryRegion&gt;* result, bool synchronous = false) = 0;\n</code></pre>\n<p>and then changed each corresponding subclass method signature. For the Posix subclass, I added <code>MAP_POPULATE</code> to the flags if <code>synchronous == true</code>.</p>\n<p>I can submit a pull request for this, but I find this approach hacky (e.g. that flag might not have the same meaning in non-Posix contexts). If there is a better approach to do this, I'm happy to work on it.</p>", "body_text": "TensorFlow's PosixFileSystem::NewReadOnlyMemoryRegionFromFile method calls mmap with only the MAP_PRIVATE flag specified.\nHaving the ability to specify that flag, at least to specify MAP_POPULATE would be very useful for many applications with high disk I/O throughput. For the MAP_POPULATE case, I sped up one of my graphs by ~4x by adding that flag because I have a pipeline that:\n\nreads in a file of N chunks in size\nenqueues a pointer to each of those N chunks in an output queue\ndownstream nodes process one chunk at a time\n\nBecause of the lack of coordination between the downstream nodes (each being independent), they would take page faults in an uncoordinated manner. When I added MAP_POPULATE this went away.\nI have a patch to add this feature where I change the base method to look like this:\nvirtual Status NewReadOnlyMemoryRegionFromFile(\n  const string& fname, std::unique_ptr<ReadOnlyMemoryRegion>* result, bool synchronous = false) = 0;\n\nand then changed each corresponding subclass method signature. For the Posix subclass, I added MAP_POPULATE to the flags if synchronous == true.\nI can submit a pull request for this, but I find this approach hacky (e.g. that flag might not have the same meaning in non-Posix contexts). If there is a better approach to do this, I'm happy to work on it.", "body": "TensorFlow's [PosixFileSystem::NewReadOnlyMemoryRegionFromFile method](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/platform/posix/posix_file_system.cc#L172) calls `mmap` with [only the `MAP_PRIVATE` flag specified](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/platform/posix/posix_file_system.cc#L183).\r\n\r\nHaving the ability to specify that flag, at least to specify `MAP_POPULATE` would be very useful for many applications with high disk I/O throughput. For the `MAP_POPULATE` case, I sped up one of my graphs by ~4x by adding that flag because I have a pipeline that:\r\n\r\n1. reads in a file of N chunks in size\r\n2. enqueues a pointer to each of those N chunks in an output queue\r\n3. downstream nodes process one chunk at a time\r\n\r\nBecause of the lack of coordination between the downstream nodes (each being independent), they would take page faults in an uncoordinated manner. When I added `MAP_POPULATE` this went away.\r\n\r\nI have a patch to add this feature where I change the [base method](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/platform/file_system.h#L102) to look like this:\r\n\r\n    virtual Status NewReadOnlyMemoryRegionFromFile(\r\n      const string& fname, std::unique_ptr<ReadOnlyMemoryRegion>* result, bool synchronous = false) = 0;\r\n\r\nand then changed each corresponding subclass method signature. For the Posix subclass, I added `MAP_POPULATE` to the flags if `synchronous == true`.\r\n\r\nI can submit a pull request for this, but I find this approach hacky (e.g. that flag might not have the same meaning in non-Posix contexts). If there is a better approach to do this, I'm happy to work on it."}