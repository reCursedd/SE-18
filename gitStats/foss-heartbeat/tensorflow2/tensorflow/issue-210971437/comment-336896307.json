{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/336896307", "html_url": "https://github.com/tensorflow/tensorflow/issues/7958#issuecomment-336896307", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/7958", "id": 336896307, "node_id": "MDEyOklzc3VlQ29tbWVudDMzNjg5NjMwNw==", "user": {"login": "ofirbb", "id": 633447, "node_id": "MDQ6VXNlcjYzMzQ0Nw==", "avatar_url": "https://avatars3.githubusercontent.com/u/633447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ofirbb", "html_url": "https://github.com/ofirbb", "followers_url": "https://api.github.com/users/ofirbb/followers", "following_url": "https://api.github.com/users/ofirbb/following{/other_user}", "gists_url": "https://api.github.com/users/ofirbb/gists{/gist_id}", "starred_url": "https://api.github.com/users/ofirbb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ofirbb/subscriptions", "organizations_url": "https://api.github.com/users/ofirbb/orgs", "repos_url": "https://api.github.com/users/ofirbb/repos", "events_url": "https://api.github.com/users/ofirbb/events{/privacy}", "received_events_url": "https://api.github.com/users/ofirbb/received_events", "type": "User", "site_admin": false}, "created_at": "2017-10-16T14:01:37Z", "updated_at": "2017-10-16T14:01:37Z", "author_association": "NONE", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=229914\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/keveman\">@keveman</a> <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=1121581\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/ajtulloch\">@ajtulloch</a><br>\nContinuing your discussion from June <g-emoji class=\"g-emoji\" alias=\"smile_cat\" fallback-src=\"https://assets-cdn.github.com/images/icons/emoji/unicode/1f638.png\">\ud83d\ude38</g-emoji></p>\n<ul>\n<li><a href=\"https://developer.apple.com/documentation/metalperformanceshaders/mpstemporaryimage/2097544-prefetchstoragewithcommandbuffer?language=objc\" rel=\"nofollow\">prefetchStorageWithCommandBuffer:imageDescriptorList:</a> Seems to give a small win when calling the same pipeline more than once. While counter intuitive being linked to a single <code>commandBuffer</code> calling the prefetch method on each new buffer with the same set of descriptors results in faster run times for me.</li>\n<li>preencoding - <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=1121581\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/ajtulloch\">@ajtulloch</a> Did you actually manage to make this work? preencoding the whole buffer and then just copying the data into the <strong>input</strong> <code>MPSImage</code> and committing?</li>\n<li>Double buffering - I did not try it yet, but I believe that for large enough graphs you can switch an <code>MPSTemporaryImage</code> in the middle for an <code>MPSImage</code> in order to encode a buffer up to that point, then while that buffer is commited, use the CPU to encode a new buffer to run from that point all the way to the output. Also, did not try it yet, but if any of you did, I would love to hear about it.</li>\n<li><code>texture2d</code> vs. <code>texture2d_array</code> - Since the code for C2 is already out there, I will open a PR for that in a couple of days. The essence is the fact that Metal is based on C++14 which fully supports templating, namespacing and other tools that allow you to create common code called by several kernels.</li>\n</ul>\n<p>Last but not least, while being Swift based, <a href=\"https://github.com/hollance/Forge\">Forge</a> has some nice ideas in it too for building a framework on top of MPS.</p>", "body_text": "@keveman @ajtulloch\nContinuing your discussion from June \ud83d\ude38\n\nprefetchStorageWithCommandBuffer:imageDescriptorList: Seems to give a small win when calling the same pipeline more than once. While counter intuitive being linked to a single commandBuffer calling the prefetch method on each new buffer with the same set of descriptors results in faster run times for me.\npreencoding - @ajtulloch Did you actually manage to make this work? preencoding the whole buffer and then just copying the data into the input MPSImage and committing?\nDouble buffering - I did not try it yet, but I believe that for large enough graphs you can switch an MPSTemporaryImage in the middle for an MPSImage in order to encode a buffer up to that point, then while that buffer is commited, use the CPU to encode a new buffer to run from that point all the way to the output. Also, did not try it yet, but if any of you did, I would love to hear about it.\ntexture2d vs. texture2d_array - Since the code for C2 is already out there, I will open a PR for that in a couple of days. The essence is the fact that Metal is based on C++14 which fully supports templating, namespacing and other tools that allow you to create common code called by several kernels.\n\nLast but not least, while being Swift based, Forge has some nice ideas in it too for building a framework on top of MPS.", "body": "@keveman @ajtulloch \r\nContinuing your discussion from June \ud83d\ude38 \r\n\r\n* [prefetchStorageWithCommandBuffer:imageDescriptorList:](https://developer.apple.com/documentation/metalperformanceshaders/mpstemporaryimage/2097544-prefetchstoragewithcommandbuffer?language=objc) Seems to give a small win when calling the same pipeline more than once. While counter intuitive being linked to a single `commandBuffer` calling the prefetch method on each new buffer with the same set of descriptors results in faster run times for me.\r\n* preencoding - @ajtulloch Did you actually manage to make this work? preencoding the whole buffer and then just copying the data into the **input** `MPSImage` and committing?\r\n* Double buffering - I did not try it yet, but I believe that for large enough graphs you can switch an `MPSTemporaryImage` in the middle for an `MPSImage` in order to encode a buffer up to that point, then while that buffer is commited, use the CPU to encode a new buffer to run from that point all the way to the output. Also, did not try it yet, but if any of you did, I would love to hear about it.\r\n* `texture2d` vs. `texture2d_array` - Since the code for C2 is already out there, I will open a PR for that in a couple of days. The essence is the fact that Metal is based on C++14 which fully supports templating, namespacing and other tools that allow you to create common code called by several kernels.\r\n\r\nLast but not least, while being Swift based, [Forge](https://github.com/hollance/Forge) has some nice ideas in it too for building a framework on top of MPS."}