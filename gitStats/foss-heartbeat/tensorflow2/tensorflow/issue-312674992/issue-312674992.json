{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/18360", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/18360/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/18360/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/18360/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/18360", "id": 312674992, "node_id": "MDU6SXNzdWUzMTI2NzQ5OTI=", "number": 18360, "title": "Include C and C++ APIs with binary distributions", "user": {"login": "peastman", "id": 4379786, "node_id": "MDQ6VXNlcjQzNzk3ODY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4379786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/peastman", "html_url": "https://github.com/peastman", "followers_url": "https://api.github.com/users/peastman/followers", "following_url": "https://api.github.com/users/peastman/following{/other_user}", "gists_url": "https://api.github.com/users/peastman/gists{/gist_id}", "starred_url": "https://api.github.com/users/peastman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/peastman/subscriptions", "organizations_url": "https://api.github.com/users/peastman/orgs", "repos_url": "https://api.github.com/users/peastman/repos", "events_url": "https://api.github.com/users/peastman/events{/privacy}", "received_events_url": "https://api.github.com/users/peastman/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 404586558, "node_id": "MDU6TGFiZWw0MDQ1ODY1NTg=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:community%20support", "name": "stat:community support", "color": "f4b400", "default": false}, {"id": 473173272, "node_id": "MDU6TGFiZWw0NzMxNzMyNzI=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:feature", "name": "type:feature", "color": "159b2e", "default": false}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 12, "created_at": "2018-04-09T20:26:44Z", "updated_at": "2018-11-20T10:33:53Z", "closed_at": null, "author_association": "NONE", "body_html": "<h3>System information</h3>\n<ul>\n<li><strong>Have I written custom code (as opposed to using a stock example script provided in TensorFlow)</strong>: Yes</li>\n<li><strong>OS Platform and Distribution (e.g., Linux Ubuntu 16.04)</strong>: Any</li>\n<li><strong>TensorFlow installed from (source or binary)</strong>: see below</li>\n<li><strong>TensorFlow version (use command below)</strong>: Any</li>\n<li><strong>Python version</strong>:  Any</li>\n<li><strong>Bazel version (if compiling from source)</strong>:</li>\n<li><strong>GCC/Compiler version (if compiling from source)</strong>:</li>\n<li><strong>CUDA/cuDNN version</strong>:</li>\n<li><strong>GPU model and memory</strong>:</li>\n<li><strong>Exact command to reproduce</strong>:</li>\n</ul>\n<p>When you install a precompiled Tensorflow binary with pip or conda, it doesn't include the C and C++ interfaces.  To use it from those languages, you need to compile Tensorflow for source and build a special version of it that includes the needed API (see <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"155404750\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/tensorflow/tensorflow/issues/2412\" data-hovercard-type=\"issue\" data-hovercard-url=\"/tensorflow/tensorflow/issues/2412/hovercard\" href=\"https://github.com/tensorflow/tensorflow/issues/2412\">#2412</a>).  I suggest including them in the standard binaries.  This would have multiple benefits.</p>\n<p>First, it would make development in other languages much easier.  You could just <code>pip install tensorflow</code> and link against the library it installed.  Having to build a special version of Tensorflow from source adds an unnecessary barrier to getting started.</p>\n<p>Second, it would eliminate a problem that so far I've been unable to resolve.  I want to create a C++ library that uses Tensorflow.  That library will be usable directly from C++, but I'll also use SWIG to create a Python wrapper for it.  For example, a user should be able to write Python code to build a Graph, then pass it directly to my library.</p>\n<p>That won't work right now, because there are two separate versions of Tensorflow involved, one that Python is linked against and a different one that my library is linked against.  When the user is building a Graph in Python, they're working with one Tensorflow library.  But when they try to pass it to my library, they're suddenly switching to a completely different copy of Tensorflow, so it doesn't have access to memory allocated by the first copy.  I haven't found any solution to this problem.</p>", "body_text": "System information\n\nHave I written custom code (as opposed to using a stock example script provided in TensorFlow): Yes\nOS Platform and Distribution (e.g., Linux Ubuntu 16.04): Any\nTensorFlow installed from (source or binary): see below\nTensorFlow version (use command below): Any\nPython version:  Any\nBazel version (if compiling from source):\nGCC/Compiler version (if compiling from source):\nCUDA/cuDNN version:\nGPU model and memory:\nExact command to reproduce:\n\nWhen you install a precompiled Tensorflow binary with pip or conda, it doesn't include the C and C++ interfaces.  To use it from those languages, you need to compile Tensorflow for source and build a special version of it that includes the needed API (see #2412).  I suggest including them in the standard binaries.  This would have multiple benefits.\nFirst, it would make development in other languages much easier.  You could just pip install tensorflow and link against the library it installed.  Having to build a special version of Tensorflow from source adds an unnecessary barrier to getting started.\nSecond, it would eliminate a problem that so far I've been unable to resolve.  I want to create a C++ library that uses Tensorflow.  That library will be usable directly from C++, but I'll also use SWIG to create a Python wrapper for it.  For example, a user should be able to write Python code to build a Graph, then pass it directly to my library.\nThat won't work right now, because there are two separate versions of Tensorflow involved, one that Python is linked against and a different one that my library is linked against.  When the user is building a Graph in Python, they're working with one Tensorflow library.  But when they try to pass it to my library, they're suddenly switching to a completely different copy of Tensorflow, so it doesn't have access to memory allocated by the first copy.  I haven't found any solution to this problem.", "body": "### System information\r\n- **Have I written custom code (as opposed to using a stock example script provided in TensorFlow)**: Yes\r\n- **OS Platform and Distribution (e.g., Linux Ubuntu 16.04)**: Any\r\n- **TensorFlow installed from (source or binary)**: see below\r\n- **TensorFlow version (use command below)**: Any\r\n- **Python version**:  Any\r\n- **Bazel version (if compiling from source)**:\r\n- **GCC/Compiler version (if compiling from source)**:\r\n- **CUDA/cuDNN version**:\r\n- **GPU model and memory**:\r\n- **Exact command to reproduce**:\r\n\r\nWhen you install a precompiled Tensorflow binary with pip or conda, it doesn't include the C and C++ interfaces.  To use it from those languages, you need to compile Tensorflow for source and build a special version of it that includes the needed API (see #2412).  I suggest including them in the standard binaries.  This would have multiple benefits.\r\n\r\nFirst, it would make development in other languages much easier.  You could just `pip install tensorflow` and link against the library it installed.  Having to build a special version of Tensorflow from source adds an unnecessary barrier to getting started.\r\n\r\nSecond, it would eliminate a problem that so far I've been unable to resolve.  I want to create a C++ library that uses Tensorflow.  That library will be usable directly from C++, but I'll also use SWIG to create a Python wrapper for it.  For example, a user should be able to write Python code to build a Graph, then pass it directly to my library.\r\n\r\nThat won't work right now, because there are two separate versions of Tensorflow involved, one that Python is linked against and a different one that my library is linked against.  When the user is building a Graph in Python, they're working with one Tensorflow library.  But when they try to pass it to my library, they're suddenly switching to a completely different copy of Tensorflow, so it doesn't have access to memory allocated by the first copy.  I haven't found any solution to this problem."}