{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/409618969", "html_url": "https://github.com/tensorflow/tensorflow/issues/21277#issuecomment-409618969", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/21277", "id": 409618969, "node_id": "MDEyOklzc3VlQ29tbWVudDQwOTYxODk2OQ==", "user": {"login": "nfergu", "id": 1291583, "node_id": "MDQ6VXNlcjEyOTE1ODM=", "avatar_url": "https://avatars1.githubusercontent.com/u/1291583?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nfergu", "html_url": "https://github.com/nfergu", "followers_url": "https://api.github.com/users/nfergu/followers", "following_url": "https://api.github.com/users/nfergu/following{/other_user}", "gists_url": "https://api.github.com/users/nfergu/gists{/gist_id}", "starred_url": "https://api.github.com/users/nfergu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nfergu/subscriptions", "organizations_url": "https://api.github.com/users/nfergu/orgs", "repos_url": "https://api.github.com/users/nfergu/repos", "events_url": "https://api.github.com/users/nfergu/events{/privacy}", "received_events_url": "https://api.github.com/users/nfergu/received_events", "type": "User", "site_admin": false}, "created_at": "2018-08-01T15:37:48Z", "updated_at": "2018-08-01T15:38:09Z", "author_association": "NONE", "body_html": "<p>I've logged the thread that is executing the PyFunc op. Here's the output:</p>\n<pre><code>2018-08-01 15:37:06.264162: E tensorflow/python/lib/core/py_func.cc:473] About to ensure GIL in thread: 0x700011a15000\n2018-08-01 15:37:06.264168: E tensorflow/python/lib/core/py_func.cc:476] Native thread ID is : 4923929\n</code></pre>\n<p>The native thread ID is the one we're interested in (4923929). This corresponds to <strong>0x4B2219</strong> in hex.</p>\n<p>Here's what lldb tells us about our threads:</p>\n<pre><code>(lldb) thread info all\nthread #1: tid = 0x4b1ea2, 0x0000000101855e7e libsystem_kernel.dylib`__psynch_cvwait + 10, queue = 'com.apple.main-thread', stop reason = signal SIGSTOP\n\nthread #5: tid = 0x4b1f91, 0x00000001018566da libsystem_kernel.dylib`__workq_kernreturn + 10\n\nthread #7: tid = 0x4b21c4, 0x0000000101855e7e libsystem_kernel.dylib`__psynch_cvwait + 10\n\nthread #8: tid = 0x4b21c6, 0x0000000101855e7e libsystem_kernel.dylib`__psynch_cvwait + 10\n\nthread #9: tid = 0x4b2214, 0x0000000101857592 libsystem_kernel.dylib`read + 10\n\nthread #10: tid = 0x4b2218, 0x0000000101855e7e libsystem_kernel.dylib`__psynch_cvwait + 10\n\nthread #12: tid = 0x4b232d, 0x0000000101855e7e libsystem_kernel.dylib`__psynch_cvwait + 10\n</code></pre>\n<p>However, 0x4B2219 is not there! However, if we look at our threads just before the session is destroyed we can see that this thread did <em>previously</em> exist:</p>\n<p><code>thread #11: tid = 0x4b2219, 0x0000000101855e7e libsystem_kernel.dylib</code>__psynch_cvwait + 10`</p>\n<p>As might be expected, this is one of the Eigen threads:</p>\n<pre><code>thread #11\n    frame #0: 0x0000000101855e7e libsystem_kernel.dylib`__psynch_cvwait + 10\n    frame #1: 0x000000010188d662 libsystem_pthread.dylib`_pthread_cond_wait + 732\n    frame #2: 0x00000001019b6cb0 libc++.1.dylib`std::__1::condition_variable::wait(std::__1::unique_lock&lt;std::__1::mutex&gt;&amp;) + 18\n    frame #3: 0x0000000111b605f6 libtensorflow_framework.so`Eigen::EventCount::CommitWait(Eigen::EventCount::Waiter*) + 278\n    frame #4: 0x0000000111b6026c libtensorflow_framework.so`Eigen::NonBlockingThreadPoolTempl&lt;tensorflow::thread::EigenEnvironment&gt;::WaitForWork(Eigen::EventCount::Waiter*, tensorflow::thread::EigenEnvironment::Task*) + 828\n    frame #5: 0x0000000111b5f898 libtensorflow_framework.so`Eigen::NonBlockingThreadPoolTempl&lt;tensorflow::thread::EigenEnvironment&gt;::WorkerLoop(int) + 568\n    frame #6: 0x0000000111b5f55f libtensorflow_framework.so`std::__1::__function::__func&lt;tensorflow::thread::EigenEnvironment::CreateThread(std::__1::function&lt;void ()&gt;)::'lambda'(), std::__1::allocator&lt;tensorflow::thread::EigenEnvironment::CreateThread(std::__1::function&lt;void ()&gt;)::'lambda'()&gt;, void ()&gt;::operator()() + 47\n</code></pre>\n<p>So it looks like this thread has tried to get the GIL, hasn't managed, and then has stopped or been killed.</p>\n<p>Is it possible that the thread encounters an error when getting the GIL (which is not logged for some reason), and then is killed?</p>\n<p>Regarding the multiprocessing stuff, we are using Python's \"spawn\" multiprocessing context (<code>multiprocessing.get_context('spawn')</code>), so as I understand it the limitations around spawning processes after sessions have been created do not apply (but in any case we don't spawn any processes after session creation anyway). Having said that, both of the scenarios where this happens in our application <em>do</em> use multiprocessing, so I'm not able to rule this out as a cause.</p>\n<p>I was also wondering why there are 4 Eigen threads (in fact there are 6 before session destruction time), so just to double-check our config I dumped it out. Here it is:</p>\n<pre><code>intra_op_parallelism_threads: 1\ninter_op_parallelism_threads: 1\ngpu_options {\n  per_process_gpu_memory_fraction: 1.0\n  allow_growth: true\n}\nallow_soft_placement: true\n\n</code></pre>", "body_text": "I've logged the thread that is executing the PyFunc op. Here's the output:\n2018-08-01 15:37:06.264162: E tensorflow/python/lib/core/py_func.cc:473] About to ensure GIL in thread: 0x700011a15000\n2018-08-01 15:37:06.264168: E tensorflow/python/lib/core/py_func.cc:476] Native thread ID is : 4923929\n\nThe native thread ID is the one we're interested in (4923929). This corresponds to 0x4B2219 in hex.\nHere's what lldb tells us about our threads:\n(lldb) thread info all\nthread #1: tid = 0x4b1ea2, 0x0000000101855e7e libsystem_kernel.dylib`__psynch_cvwait + 10, queue = 'com.apple.main-thread', stop reason = signal SIGSTOP\n\nthread #5: tid = 0x4b1f91, 0x00000001018566da libsystem_kernel.dylib`__workq_kernreturn + 10\n\nthread #7: tid = 0x4b21c4, 0x0000000101855e7e libsystem_kernel.dylib`__psynch_cvwait + 10\n\nthread #8: tid = 0x4b21c6, 0x0000000101855e7e libsystem_kernel.dylib`__psynch_cvwait + 10\n\nthread #9: tid = 0x4b2214, 0x0000000101857592 libsystem_kernel.dylib`read + 10\n\nthread #10: tid = 0x4b2218, 0x0000000101855e7e libsystem_kernel.dylib`__psynch_cvwait + 10\n\nthread #12: tid = 0x4b232d, 0x0000000101855e7e libsystem_kernel.dylib`__psynch_cvwait + 10\n\nHowever, 0x4B2219 is not there! However, if we look at our threads just before the session is destroyed we can see that this thread did previously exist:\nthread #11: tid = 0x4b2219, 0x0000000101855e7e libsystem_kernel.dylib__psynch_cvwait + 10`\nAs might be expected, this is one of the Eigen threads:\nthread #11\n    frame #0: 0x0000000101855e7e libsystem_kernel.dylib`__psynch_cvwait + 10\n    frame #1: 0x000000010188d662 libsystem_pthread.dylib`_pthread_cond_wait + 732\n    frame #2: 0x00000001019b6cb0 libc++.1.dylib`std::__1::condition_variable::wait(std::__1::unique_lock<std::__1::mutex>&) + 18\n    frame #3: 0x0000000111b605f6 libtensorflow_framework.so`Eigen::EventCount::CommitWait(Eigen::EventCount::Waiter*) + 278\n    frame #4: 0x0000000111b6026c libtensorflow_framework.so`Eigen::NonBlockingThreadPoolTempl<tensorflow::thread::EigenEnvironment>::WaitForWork(Eigen::EventCount::Waiter*, tensorflow::thread::EigenEnvironment::Task*) + 828\n    frame #5: 0x0000000111b5f898 libtensorflow_framework.so`Eigen::NonBlockingThreadPoolTempl<tensorflow::thread::EigenEnvironment>::WorkerLoop(int) + 568\n    frame #6: 0x0000000111b5f55f libtensorflow_framework.so`std::__1::__function::__func<tensorflow::thread::EigenEnvironment::CreateThread(std::__1::function<void ()>)::'lambda'(), std::__1::allocator<tensorflow::thread::EigenEnvironment::CreateThread(std::__1::function<void ()>)::'lambda'()>, void ()>::operator()() + 47\n\nSo it looks like this thread has tried to get the GIL, hasn't managed, and then has stopped or been killed.\nIs it possible that the thread encounters an error when getting the GIL (which is not logged for some reason), and then is killed?\nRegarding the multiprocessing stuff, we are using Python's \"spawn\" multiprocessing context (multiprocessing.get_context('spawn')), so as I understand it the limitations around spawning processes after sessions have been created do not apply (but in any case we don't spawn any processes after session creation anyway). Having said that, both of the scenarios where this happens in our application do use multiprocessing, so I'm not able to rule this out as a cause.\nI was also wondering why there are 4 Eigen threads (in fact there are 6 before session destruction time), so just to double-check our config I dumped it out. Here it is:\nintra_op_parallelism_threads: 1\ninter_op_parallelism_threads: 1\ngpu_options {\n  per_process_gpu_memory_fraction: 1.0\n  allow_growth: true\n}\nallow_soft_placement: true", "body": "I've logged the thread that is executing the PyFunc op. Here's the output:\r\n\r\n```\r\n2018-08-01 15:37:06.264162: E tensorflow/python/lib/core/py_func.cc:473] About to ensure GIL in thread: 0x700011a15000\r\n2018-08-01 15:37:06.264168: E tensorflow/python/lib/core/py_func.cc:476] Native thread ID is : 4923929\r\n```\r\n\r\nThe native thread ID is the one we're interested in (4923929). This corresponds to **0x4B2219** in hex.\r\n\r\nHere's what lldb tells us about our threads:\r\n\r\n```\r\n(lldb) thread info all\r\nthread #1: tid = 0x4b1ea2, 0x0000000101855e7e libsystem_kernel.dylib`__psynch_cvwait + 10, queue = 'com.apple.main-thread', stop reason = signal SIGSTOP\r\n\r\nthread #5: tid = 0x4b1f91, 0x00000001018566da libsystem_kernel.dylib`__workq_kernreturn + 10\r\n\r\nthread #7: tid = 0x4b21c4, 0x0000000101855e7e libsystem_kernel.dylib`__psynch_cvwait + 10\r\n\r\nthread #8: tid = 0x4b21c6, 0x0000000101855e7e libsystem_kernel.dylib`__psynch_cvwait + 10\r\n\r\nthread #9: tid = 0x4b2214, 0x0000000101857592 libsystem_kernel.dylib`read + 10\r\n\r\nthread #10: tid = 0x4b2218, 0x0000000101855e7e libsystem_kernel.dylib`__psynch_cvwait + 10\r\n\r\nthread #12: tid = 0x4b232d, 0x0000000101855e7e libsystem_kernel.dylib`__psynch_cvwait + 10\r\n```\r\n\r\nHowever, 0x4B2219 is not there! However, if we look at our threads just before the session is destroyed we can see that this thread did _previously_ exist:\r\n\r\n`thread #11: tid = 0x4b2219, 0x0000000101855e7e libsystem_kernel.dylib`__psynch_cvwait + 10`\r\n\r\nAs might be expected, this is one of the Eigen threads:\r\n\r\n```\r\nthread #11\r\n    frame #0: 0x0000000101855e7e libsystem_kernel.dylib`__psynch_cvwait + 10\r\n    frame #1: 0x000000010188d662 libsystem_pthread.dylib`_pthread_cond_wait + 732\r\n    frame #2: 0x00000001019b6cb0 libc++.1.dylib`std::__1::condition_variable::wait(std::__1::unique_lock<std::__1::mutex>&) + 18\r\n    frame #3: 0x0000000111b605f6 libtensorflow_framework.so`Eigen::EventCount::CommitWait(Eigen::EventCount::Waiter*) + 278\r\n    frame #4: 0x0000000111b6026c libtensorflow_framework.so`Eigen::NonBlockingThreadPoolTempl<tensorflow::thread::EigenEnvironment>::WaitForWork(Eigen::EventCount::Waiter*, tensorflow::thread::EigenEnvironment::Task*) + 828\r\n    frame #5: 0x0000000111b5f898 libtensorflow_framework.so`Eigen::NonBlockingThreadPoolTempl<tensorflow::thread::EigenEnvironment>::WorkerLoop(int) + 568\r\n    frame #6: 0x0000000111b5f55f libtensorflow_framework.so`std::__1::__function::__func<tensorflow::thread::EigenEnvironment::CreateThread(std::__1::function<void ()>)::'lambda'(), std::__1::allocator<tensorflow::thread::EigenEnvironment::CreateThread(std::__1::function<void ()>)::'lambda'()>, void ()>::operator()() + 47\r\n```\r\n\r\nSo it looks like this thread has tried to get the GIL, hasn't managed, and then has stopped or been killed.\r\n\r\nIs it possible that the thread encounters an error when getting the GIL (which is not logged for some reason), and then is killed?\r\n\r\nRegarding the multiprocessing stuff, we are using Python's \"spawn\" multiprocessing context (`multiprocessing.get_context('spawn')`), so as I understand it the limitations around spawning processes after sessions have been created do not apply (but in any case we don't spawn any processes after session creation anyway). Having said that, both of the scenarios where this happens in our application _do_ use multiprocessing, so I'm not able to rule this out as a cause.\r\n\r\nI was also wondering why there are 4 Eigen threads (in fact there are 6 before session destruction time), so just to double-check our config I dumped it out. Here it is:\r\n\r\n```\r\nintra_op_parallelism_threads: 1\r\ninter_op_parallelism_threads: 1\r\ngpu_options {\r\n  per_process_gpu_memory_fraction: 1.0\r\n  allow_growth: true\r\n}\r\nallow_soft_placement: true\r\n\r\n```"}