{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/409350361", "html_url": "https://github.com/tensorflow/tensorflow/issues/21277#issuecomment-409350361", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/21277", "id": 409350361, "node_id": "MDEyOklzc3VlQ29tbWVudDQwOTM1MDM2MQ==", "user": {"login": "mrry", "id": 192142, "node_id": "MDQ6VXNlcjE5MjE0Mg==", "avatar_url": "https://avatars1.githubusercontent.com/u/192142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mrry", "html_url": "https://github.com/mrry", "followers_url": "https://api.github.com/users/mrry/followers", "following_url": "https://api.github.com/users/mrry/following{/other_user}", "gists_url": "https://api.github.com/users/mrry/gists{/gist_id}", "starred_url": "https://api.github.com/users/mrry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mrry/subscriptions", "organizations_url": "https://api.github.com/users/mrry/orgs", "repos_url": "https://api.github.com/users/mrry/repos", "events_url": "https://api.github.com/users/mrry/events{/privacy}", "received_events_url": "https://api.github.com/users/mrry/received_events", "type": "User", "site_admin": false}, "created_at": "2018-07-31T20:05:46Z", "updated_at": "2018-07-31T20:05:46Z", "author_association": "CONTRIBUTOR", "body_html": "<p>It definitely looks like it's failing to acquire the lock :). Is there some way you could log the thread ID on which the PyFunc op is trying to acquire the GIL so we can associate it with the stack trace?</p>\n<p>Also, the presence of <code>multiprocessing</code> is slightly suspicious, because depending on when things are forked the TensorFlow runtime might end up in an illegal state (essentially, the process isn't forkable once a <code>tf.Session</code> has been created). Is it possible to reproduce the problem in a process that doesn't use <code>multiprocessing</code>?</p>", "body_text": "It definitely looks like it's failing to acquire the lock :). Is there some way you could log the thread ID on which the PyFunc op is trying to acquire the GIL so we can associate it with the stack trace?\nAlso, the presence of multiprocessing is slightly suspicious, because depending on when things are forked the TensorFlow runtime might end up in an illegal state (essentially, the process isn't forkable once a tf.Session has been created). Is it possible to reproduce the problem in a process that doesn't use multiprocessing?", "body": "It definitely looks like it's failing to acquire the lock :). Is there some way you could log the thread ID on which the PyFunc op is trying to acquire the GIL so we can associate it with the stack trace?\r\n\r\nAlso, the presence of `multiprocessing` is slightly suspicious, because depending on when things are forked the TensorFlow runtime might end up in an illegal state (essentially, the process isn't forkable once a `tf.Session` has been created). Is it possible to reproduce the problem in a process that doesn't use `multiprocessing`?"}