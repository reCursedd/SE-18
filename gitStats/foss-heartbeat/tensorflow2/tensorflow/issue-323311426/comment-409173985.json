{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/409173985", "html_url": "https://github.com/tensorflow/tensorflow/issues/19298#issuecomment-409173985", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/19298", "id": 409173985, "node_id": "MDEyOklzc3VlQ29tbWVudDQwOTE3Mzk4NQ==", "user": {"login": "kamei86i", "id": 7414714, "node_id": "MDQ6VXNlcjc0MTQ3MTQ=", "avatar_url": "https://avatars0.githubusercontent.com/u/7414714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kamei86i", "html_url": "https://github.com/kamei86i", "followers_url": "https://api.github.com/users/kamei86i/followers", "following_url": "https://api.github.com/users/kamei86i/following{/other_user}", "gists_url": "https://api.github.com/users/kamei86i/gists{/gist_id}", "starred_url": "https://api.github.com/users/kamei86i/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kamei86i/subscriptions", "organizations_url": "https://api.github.com/users/kamei86i/orgs", "repos_url": "https://api.github.com/users/kamei86i/repos", "events_url": "https://api.github.com/users/kamei86i/events{/privacy}", "received_events_url": "https://api.github.com/users/kamei86i/received_events", "type": "User", "site_admin": false}, "created_at": "2018-07-31T10:30:33Z", "updated_at": "2018-07-31T10:32:27Z", "author_association": "NONE", "body_html": "<p>I'm facing the <strong>Cannot register 2 metrics with the same name: /tensorflow/cc/saved_model/load_attempt_count</strong> problem both in JUnit tests and in the context of application servers where different applications (i.e., different classloaders) try to load a tensorflow model (tf version 1.6.0).<br>\nI'm trying to reproduce the issue programmatically, and what I experimented is:<br>\nWhen I load a TF model in Java in a simple main class with SavedModelBundle.load() (as in the following code snippet) all is working, and in <em>/tmp</em> only one <em>tensorflow_jni</em> directory is created.</p>\n<pre><code>public static void main(String[] args) throws InterruptedException {\n\tSavedModelBundle b = SavedModelBundle.load(mymodel_path, \"serve\");\n\tThread.sleep(10000);\t\n}\n</code></pre>\n<p>When using classloaders, i experience the Fatal error that is causing the JVM to crash, and in <em>/tmp</em> i can find two different <em>tensorflow_jni</em> directories.</p>\n<p>This is the code:</p>\n<pre><code>public class MyClassLoader extends ClassLoader {\n\n\tpublic MyClassLoader() {\n\t}\n\n\t@Override\n\tpublic Class&lt;?&gt; findClass(String name) {\n\t\tbyte[] bt = loadClassData(name);\n\t\treturn defineClass(name, bt, 0, bt.length);\n\t}\n\n\tprivate byte[] loadClassData(String className) {\n\t\t// read class\n\t\tInputStream is = getClass().getClassLoader().getResourceAsStream(className.replace(\".\", \"/\") + \".class\");\n\t\tByteArrayOutputStream byteSt = new ByteArrayOutputStream();\n\t\t// write into byte\n\t\tint len = 0;\n\t\ttry {\n\t\t\twhile ((len = is.read()) != -1) {\n\t\t\t\tbyteSt.write(len);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\t// convert into byte array\n\t\treturn byteSt.toByteArray();\n\t}\n}\n</code></pre>\n<p>and the main:</p>\n<pre><code>public class MultipleClassLoaderTest {\n\tpublic static void main(String[] args) throws NoSuchMethodException, SecurityException, IllegalArgumentException,\n\t\t\tInvocationTargetException, IllegalAccessException {\n\t\tMyClassLoader l1 = new MyClassLoader();\n\t\t\n\t\tString[] classesToLoad = new  String[] { \"org.tensorflow.NativeLibrary\", \"org.tensorflow.TensorFlow\" };\n\t\tfor (String cl : classesToLoad) {\n\t\t\tl1.findClass(cl);\t\t\t\n\t\t}\n\n\t\tClass&lt;?&gt; smb = l1.findClass(\"org.tensorflow.SavedModelBundle\");\n\t\tMethod loadModelMethod = smb.getMethod(\"load\", new Class&lt;?&gt;[] { String.class, String[].class });\n\t\tObject loadedModel = loadModelMethod.invoke(null, new Object[] { \"mymodel_path\", new String[] {\"serve\"}});\n\n\t\tSystem.out.println(\"Done.\");\n\t}\n\n}\n</code></pre>\n<p>The strange thing is that in this last example I was expecting the fatal error when instantiating two MyClassLoader instances. Instead, the error is going to appear with only one instance of MyClassLoader. Is the \"system\" class loader also trying to load the library?<br>\nHas anyone addressed this issue in the context of application servers?</p>", "body_text": "I'm facing the Cannot register 2 metrics with the same name: /tensorflow/cc/saved_model/load_attempt_count problem both in JUnit tests and in the context of application servers where different applications (i.e., different classloaders) try to load a tensorflow model (tf version 1.6.0).\nI'm trying to reproduce the issue programmatically, and what I experimented is:\nWhen I load a TF model in Java in a simple main class with SavedModelBundle.load() (as in the following code snippet) all is working, and in /tmp only one tensorflow_jni directory is created.\npublic static void main(String[] args) throws InterruptedException {\n\tSavedModelBundle b = SavedModelBundle.load(mymodel_path, \"serve\");\n\tThread.sleep(10000);\t\n}\n\nWhen using classloaders, i experience the Fatal error that is causing the JVM to crash, and in /tmp i can find two different tensorflow_jni directories.\nThis is the code:\npublic class MyClassLoader extends ClassLoader {\n\n\tpublic MyClassLoader() {\n\t}\n\n\t@Override\n\tpublic Class<?> findClass(String name) {\n\t\tbyte[] bt = loadClassData(name);\n\t\treturn defineClass(name, bt, 0, bt.length);\n\t}\n\n\tprivate byte[] loadClassData(String className) {\n\t\t// read class\n\t\tInputStream is = getClass().getClassLoader().getResourceAsStream(className.replace(\".\", \"/\") + \".class\");\n\t\tByteArrayOutputStream byteSt = new ByteArrayOutputStream();\n\t\t// write into byte\n\t\tint len = 0;\n\t\ttry {\n\t\t\twhile ((len = is.read()) != -1) {\n\t\t\t\tbyteSt.write(len);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\t// convert into byte array\n\t\treturn byteSt.toByteArray();\n\t}\n}\n\nand the main:\npublic class MultipleClassLoaderTest {\n\tpublic static void main(String[] args) throws NoSuchMethodException, SecurityException, IllegalArgumentException,\n\t\t\tInvocationTargetException, IllegalAccessException {\n\t\tMyClassLoader l1 = new MyClassLoader();\n\t\t\n\t\tString[] classesToLoad = new  String[] { \"org.tensorflow.NativeLibrary\", \"org.tensorflow.TensorFlow\" };\n\t\tfor (String cl : classesToLoad) {\n\t\t\tl1.findClass(cl);\t\t\t\n\t\t}\n\n\t\tClass<?> smb = l1.findClass(\"org.tensorflow.SavedModelBundle\");\n\t\tMethod loadModelMethod = smb.getMethod(\"load\", new Class<?>[] { String.class, String[].class });\n\t\tObject loadedModel = loadModelMethod.invoke(null, new Object[] { \"mymodel_path\", new String[] {\"serve\"}});\n\n\t\tSystem.out.println(\"Done.\");\n\t}\n\n}\n\nThe strange thing is that in this last example I was expecting the fatal error when instantiating two MyClassLoader instances. Instead, the error is going to appear with only one instance of MyClassLoader. Is the \"system\" class loader also trying to load the library?\nHas anyone addressed this issue in the context of application servers?", "body": "I'm facing the **Cannot register 2 metrics with the same name: /tensorflow/cc/saved_model/load_attempt_count** problem both in JUnit tests and in the context of application servers where different applications (i.e., different classloaders) try to load a tensorflow model (tf version 1.6.0).\r\nI'm trying to reproduce the issue programmatically, and what I experimented is:\r\nWhen I load a TF model in Java in a simple main class with SavedModelBundle.load() (as in the following code snippet) all is working, and in _/tmp_ only one _tensorflow_jni_ directory is created.\r\n\r\n```\r\npublic static void main(String[] args) throws InterruptedException {\r\n\tSavedModelBundle b = SavedModelBundle.load(mymodel_path, \"serve\");\r\n\tThread.sleep(10000);\t\r\n}\r\n```\r\nWhen using classloaders, i experience the Fatal error that is causing the JVM to crash, and in _/tmp_ i can find two different _tensorflow_jni_ directories.\r\n\r\nThis is the code:\r\n\r\n```\r\npublic class MyClassLoader extends ClassLoader {\r\n\r\n\tpublic MyClassLoader() {\r\n\t}\r\n\r\n\t@Override\r\n\tpublic Class<?> findClass(String name) {\r\n\t\tbyte[] bt = loadClassData(name);\r\n\t\treturn defineClass(name, bt, 0, bt.length);\r\n\t}\r\n\r\n\tprivate byte[] loadClassData(String className) {\r\n\t\t// read class\r\n\t\tInputStream is = getClass().getClassLoader().getResourceAsStream(className.replace(\".\", \"/\") + \".class\");\r\n\t\tByteArrayOutputStream byteSt = new ByteArrayOutputStream();\r\n\t\t// write into byte\r\n\t\tint len = 0;\r\n\t\ttry {\r\n\t\t\twhile ((len = is.read()) != -1) {\r\n\t\t\t\tbyteSt.write(len);\r\n\t\t\t}\r\n\t\t} catch (IOException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t\t// convert into byte array\r\n\t\treturn byteSt.toByteArray();\r\n\t}\r\n}\r\n```\r\n\r\nand the main:\r\n\r\n```\r\npublic class MultipleClassLoaderTest {\r\n\tpublic static void main(String[] args) throws NoSuchMethodException, SecurityException, IllegalArgumentException,\r\n\t\t\tInvocationTargetException, IllegalAccessException {\r\n\t\tMyClassLoader l1 = new MyClassLoader();\r\n\t\t\r\n\t\tString[] classesToLoad = new  String[] { \"org.tensorflow.NativeLibrary\", \"org.tensorflow.TensorFlow\" };\r\n\t\tfor (String cl : classesToLoad) {\r\n\t\t\tl1.findClass(cl);\t\t\t\r\n\t\t}\r\n\r\n\t\tClass<?> smb = l1.findClass(\"org.tensorflow.SavedModelBundle\");\r\n\t\tMethod loadModelMethod = smb.getMethod(\"load\", new Class<?>[] { String.class, String[].class });\r\n\t\tObject loadedModel = loadModelMethod.invoke(null, new Object[] { \"mymodel_path\", new String[] {\"serve\"}});\r\n\r\n\t\tSystem.out.println(\"Done.\");\r\n\t}\r\n\r\n}\r\n```\r\n\r\nThe strange thing is that in this last example I was expecting the fatal error when instantiating two MyClassLoader instances. Instead, the error is going to appear with only one instance of MyClassLoader. Is the \"system\" class loader also trying to load the library?\r\nHas anyone addressed this issue in the context of application servers?"}