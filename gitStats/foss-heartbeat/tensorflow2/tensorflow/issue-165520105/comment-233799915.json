{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/233799915", "html_url": "https://github.com/tensorflow/tensorflow/issues/3308#issuecomment-233799915", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/3308", "id": 233799915, "node_id": "MDEyOklzc3VlQ29tbWVudDIzMzc5OTkxNQ==", "user": {"login": "petewarden", "id": 161459, "node_id": "MDQ6VXNlcjE2MTQ1OQ==", "avatar_url": "https://avatars0.githubusercontent.com/u/161459?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petewarden", "html_url": "https://github.com/petewarden", "followers_url": "https://api.github.com/users/petewarden/followers", "following_url": "https://api.github.com/users/petewarden/following{/other_user}", "gists_url": "https://api.github.com/users/petewarden/gists{/gist_id}", "starred_url": "https://api.github.com/users/petewarden/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petewarden/subscriptions", "organizations_url": "https://api.github.com/users/petewarden/orgs", "repos_url": "https://api.github.com/users/petewarden/repos", "events_url": "https://api.github.com/users/petewarden/events{/privacy}", "received_events_url": "https://api.github.com/users/petewarden/received_events", "type": "User", "site_admin": false}, "created_at": "2016-07-19T23:47:09Z", "updated_at": "2016-07-19T23:47:49Z", "author_association": "MEMBER", "body_html": "<p>This is usually a sign that the global constructors that TensorFlow uses to register things like session factories and kernels have been stripped out. The short answer is that you should make sure you build with the right linker options to stop them being stripped. On Linux you will add <code>-Wl,--allow-multiple-definition -Wl,--whole-archive</code>, and on OS X <code>-all_load</code>. The benchmark binary works because it does this, and it should pick the right combination for your platform.</p>\n<p>The longer explanation is that TensorFlow uses a C++ pattern like this for registering classes (all in pseudo-code):</p>\n<div class=\"highlight highlight-source-c++\"><pre>--- <span class=\"pl-k\">register</span>.h ---\n...\n<span class=\"pl-k\">template</span>&lt;T&gt; Register&lt;T&gt; {\n <span class=\"pl-k\">public:</span>\n    Register&lt;T&gt;(string name) {\n      g_registry[name] = <span class=\"pl-c1\">T::Factory</span>();\n    }\n};\n...\n---                   ---\n\n--- some_class.cc ---\n...\nRegister&lt;SomeObject&gt; <span class=\"pl-en\">g_some_register_object</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>SomeObject<span class=\"pl-pds\">\"</span></span>);\n---                         ---</pre></div>\n<p>The idea is that the g_some_register_object global will be created when the library is loaded, which will call the constructor, which adds the factory function to the list of registered classes. That allows subsequent code to ask for a \"SomeClass\" by name from the registry, and get back an object created by the factory function.</p>\n<p>The advantage of this approach is that the registration of objects is distributed, so you only have to register a class in the file that it's implemented rather than editing a global list of factories somewhere else. When it works, it's pretty magical.</p>\n<p>Unfortunately many linkers see the g_some_register_object global, notice that no other code ever reads or writes it, and so it can be removed without affecting the program at all. What they don't realize is that its constructor has an important side-effect, registering the factory function.</p>\n<p>This is a common problem, so most linkers have some way of turning off this stripping optimization, but it's usually a pretty indiscriminate switch and so may cause your binary size to be larger than it needs to be.</p>\n<p>Does that help?</p>", "body_text": "This is usually a sign that the global constructors that TensorFlow uses to register things like session factories and kernels have been stripped out. The short answer is that you should make sure you build with the right linker options to stop them being stripped. On Linux you will add -Wl,--allow-multiple-definition -Wl,--whole-archive, and on OS X -all_load. The benchmark binary works because it does this, and it should pick the right combination for your platform.\nThe longer explanation is that TensorFlow uses a C++ pattern like this for registering classes (all in pseudo-code):\n--- register.h ---\n...\ntemplate<T> Register<T> {\n public:\n    Register<T>(string name) {\n      g_registry[name] = T::Factory();\n    }\n};\n...\n---                   ---\n\n--- some_class.cc ---\n...\nRegister<SomeObject> g_some_register_object(\"SomeObject\");\n---                         ---\nThe idea is that the g_some_register_object global will be created when the library is loaded, which will call the constructor, which adds the factory function to the list of registered classes. That allows subsequent code to ask for a \"SomeClass\" by name from the registry, and get back an object created by the factory function.\nThe advantage of this approach is that the registration of objects is distributed, so you only have to register a class in the file that it's implemented rather than editing a global list of factories somewhere else. When it works, it's pretty magical.\nUnfortunately many linkers see the g_some_register_object global, notice that no other code ever reads or writes it, and so it can be removed without affecting the program at all. What they don't realize is that its constructor has an important side-effect, registering the factory function.\nThis is a common problem, so most linkers have some way of turning off this stripping optimization, but it's usually a pretty indiscriminate switch and so may cause your binary size to be larger than it needs to be.\nDoes that help?", "body": "This is usually a sign that the global constructors that TensorFlow uses to register things like session factories and kernels have been stripped out. The short answer is that you should make sure you build with the right linker options to stop them being stripped. On Linux you will add `-Wl,--allow-multiple-definition -Wl,--whole-archive`, and on OS X `-all_load`. The benchmark binary works because it does this, and it should pick the right combination for your platform.\n\nThe longer explanation is that TensorFlow uses a C++ pattern like this for registering classes (all in pseudo-code):\n\n``` c++\n--- register.h ---\n...\ntemplate<T> Register<T> {\n public:\n    Register<T>(string name) {\n      g_registry[name] = T::Factory();\n    }\n};\n...\n---                   ---\n\n--- some_class.cc ---\n...\nRegister<SomeObject> g_some_register_object(\"SomeObject\");\n---                         ---\n```\n\nThe idea is that the g_some_register_object global will be created when the library is loaded, which will call the constructor, which adds the factory function to the list of registered classes. That allows subsequent code to ask for a \"SomeClass\" by name from the registry, and get back an object created by the factory function.\n\nThe advantage of this approach is that the registration of objects is distributed, so you only have to register a class in the file that it's implemented rather than editing a global list of factories somewhere else. When it works, it's pretty magical.\n\nUnfortunately many linkers see the g_some_register_object global, notice that no other code ever reads or writes it, and so it can be removed without affecting the program at all. What they don't realize is that its constructor has an important side-effect, registering the factory function.\n\nThis is a common problem, so most linkers have some way of turning off this stripping optimization, but it's usually a pretty indiscriminate switch and so may cause your binary size to be larger than it needs to be.\n\nDoes that help?\n"}