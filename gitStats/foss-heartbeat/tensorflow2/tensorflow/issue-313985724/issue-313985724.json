{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/18484", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/18484/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/18484/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/18484/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/18484", "id": 313985724, "node_id": "MDU6SXNzdWUzMTM5ODU3MjQ=", "number": 18484, "title": "cannot add op with name conv2d/convolution as that name is already used", "user": {"login": "pranto00250", "id": 20562497, "node_id": "MDQ6VXNlcjIwNTYyNDk3", "avatar_url": "https://avatars3.githubusercontent.com/u/20562497?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pranto00250", "html_url": "https://github.com/pranto00250", "followers_url": "https://api.github.com/users/pranto00250/followers", "following_url": "https://api.github.com/users/pranto00250/following{/other_user}", "gists_url": "https://api.github.com/users/pranto00250/gists{/gist_id}", "starred_url": "https://api.github.com/users/pranto00250/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pranto00250/subscriptions", "organizations_url": "https://api.github.com/users/pranto00250/orgs", "repos_url": "https://api.github.com/users/pranto00250/repos", "events_url": "https://api.github.com/users/pranto00250/events{/privacy}", "received_events_url": "https://api.github.com/users/pranto00250/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 386191887, "node_id": "MDU6TGFiZWwzODYxOTE4ODc=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:awaiting%20response", "name": "stat:awaiting response", "color": "f4b400", "default": false}], "state": "closed", "locked": false, "assignee": {"login": "cy89", "id": 29663194, "node_id": "MDQ6VXNlcjI5NjYzMTk0", "avatar_url": "https://avatars0.githubusercontent.com/u/29663194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cy89", "html_url": "https://github.com/cy89", "followers_url": "https://api.github.com/users/cy89/followers", "following_url": "https://api.github.com/users/cy89/following{/other_user}", "gists_url": "https://api.github.com/users/cy89/gists{/gist_id}", "starred_url": "https://api.github.com/users/cy89/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cy89/subscriptions", "organizations_url": "https://api.github.com/users/cy89/orgs", "repos_url": "https://api.github.com/users/cy89/repos", "events_url": "https://api.github.com/users/cy89/events{/privacy}", "received_events_url": "https://api.github.com/users/cy89/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "cy89", "id": 29663194, "node_id": "MDQ6VXNlcjI5NjYzMTk0", "avatar_url": "https://avatars0.githubusercontent.com/u/29663194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cy89", "html_url": "https://github.com/cy89", "followers_url": "https://api.github.com/users/cy89/followers", "following_url": "https://api.github.com/users/cy89/following{/other_user}", "gists_url": "https://api.github.com/users/cy89/gists{/gist_id}", "starred_url": "https://api.github.com/users/cy89/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cy89/subscriptions", "organizations_url": "https://api.github.com/users/cy89/orgs", "repos_url": "https://api.github.com/users/cy89/repos", "events_url": "https://api.github.com/users/cy89/events{/privacy}", "received_events_url": "https://api.github.com/users/cy89/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 5, "created_at": "2018-04-13T06:39:38Z", "updated_at": "2018-09-15T18:37:59Z", "closed_at": "2018-09-15T18:29:39Z", "author_association": "NONE", "body_html": "<p>Here is my code :</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">class</span> <span class=\"pl-en\">final_model</span>:\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> CNN encoder</span>\n    encoder, preprocess_for_model <span class=\"pl-k\">=</span> get_cnn_encoder()\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span>saver.restore(s, os.path.abspath(\"weights\"))  # keras applications corrupt our graph, so we restore trained weights</span>\n    \n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> containers for current lstm state</span>\n    lstm_c <span class=\"pl-k\">=</span> tf.Variable(tf.zeros([<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">LSTM_UNITS</span>]), <span class=\"pl-v\">name</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span>cell<span class=\"pl-pds\">\"</span></span>)\n    lstm_h <span class=\"pl-k\">=</span> tf.Variable(tf.zeros([<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">LSTM_UNITS</span>]), <span class=\"pl-v\">name</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span>hidden<span class=\"pl-pds\">\"</span></span>)\n\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> input images</span>\n    input_images <span class=\"pl-k\">=</span> tf.placeholder(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>float32<span class=\"pl-pds\">'</span></span>, [<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">IMG_SIZE</span>, <span class=\"pl-c1\">IMG_SIZE</span>, <span class=\"pl-c1\">3</span>], <span class=\"pl-v\">name</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>images<span class=\"pl-pds\">'</span></span>)\n\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> get image embeddings</span>\n    img_embeds <span class=\"pl-k\">=</span> encoder(input_images)\n\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> initialize lstm state conditioned on image</span>\n    init_c <span class=\"pl-k\">=</span> init_h <span class=\"pl-k\">=</span> decoder.img_embed_bottleneck_to_h0(decoder.img_embed_to_bottleneck(img_embeds))\n    init_lstm <span class=\"pl-k\">=</span> tf.assign(lstm_c, init_c), tf.assign(lstm_h, init_h)\n    \n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> current word index</span>\n    current_word <span class=\"pl-k\">=</span> tf.placeholder(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>int32<span class=\"pl-pds\">'</span></span>, [<span class=\"pl-c1\">1</span>], <span class=\"pl-v\">name</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>current_input<span class=\"pl-pds\">'</span></span>)\n\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> embedding for current word</span>\n    word_embed <span class=\"pl-k\">=</span> decoder.word_embed(current_word)\n\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> apply lstm cell, get new lstm states</span>\n    new_c, new_h <span class=\"pl-k\">=</span> decoder.lstm(word_embed, tf.nn.rnn_cell.LSTMStateTuple(lstm_c, lstm_h))[<span class=\"pl-c1\">1</span>]\n\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> compute logits for next token</span>\n    new_logits <span class=\"pl-k\">=</span> decoder.token_logits(decoder.token_logits_bottleneck(new_h))\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> compute probabilities for next token</span>\n    new_probs <span class=\"pl-k\">=</span> tf.nn.softmax(new_logits)\n\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> `one_step` outputs probabilities of next token and updates lstm hidden state</span>\n    one_step <span class=\"pl-k\">=</span> new_probs, tf.assign(lstm_c, new_c), tf.assign(lstm_h, new_h)</pre></div>\n<p>And I am getting following error :</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-ii\">--------------------------------------------------------------------------</span><span class=\"pl-k\">-</span>\n<span class=\"pl-c1\">ValueError</span>                                Traceback (most recent call last)\n<span class=\"pl-k\">&lt;</span>ipython<span class=\"pl-k\">-</span><span class=\"pl-c1\">input</span><span class=\"pl-k\">-</span><span class=\"pl-c1\">42</span><span class=\"pl-k\">-</span><span class=\"pl-ii\">73f88badc13d</span><span class=\"pl-k\">&gt;</span> <span class=\"pl-k\">in</span> <span class=\"pl-k\">&lt;</span>module<span class=\"pl-k\">&gt;</span>()\n<span class=\"pl-ii\">----</span><span class=\"pl-k\">&gt;</span> <span class=\"pl-c1\">1</span> <span class=\"pl-k\">class</span> <span class=\"pl-en\">final_model</span>:\n      <span class=\"pl-c1\">2</span>     <span class=\"pl-c\"><span class=\"pl-c\">#</span> CNN encoder</span>\n      <span class=\"pl-c1\">3</span>     encoder, preprocess_for_model <span class=\"pl-k\">=</span> get_cnn_encoder()\n      <span class=\"pl-c1\">4</span>     <span class=\"pl-c\"><span class=\"pl-c\">#</span>saver.restore(s, os.path.abspath(\"weights\"))  # keras applications corrupt our graph, so we restore trained weights</span>\n      <span class=\"pl-c1\">5</span> \n\n<span class=\"pl-k\">&lt;</span>ipython<span class=\"pl-k\">-</span><span class=\"pl-c1\">input</span><span class=\"pl-k\">-</span><span class=\"pl-c1\">42</span><span class=\"pl-k\">-</span><span class=\"pl-ii\">73f88badc13d</span><span class=\"pl-k\">&gt;</span> <span class=\"pl-k\">in</span> final_model()\n     <span class=\"pl-c1\">12</span> \n     <span class=\"pl-c1\">13</span>     <span class=\"pl-c\"><span class=\"pl-c\">#</span> get image embeddings</span>\n<span class=\"pl-ii\">--</span><span class=\"pl-ii\">-&gt;</span> <span class=\"pl-c1\">14</span>     img_embeds <span class=\"pl-k\">=</span> encoder(input_images)\n     <span class=\"pl-c1\">15</span> \n     <span class=\"pl-c1\">16</span>     <span class=\"pl-c\"><span class=\"pl-c\">#</span> initialize lstm state conditioned on image</span>\n\nC:\\<span class=\"pl-ii\">Program Files\\Anaconda3\\envs\\tensorflow\\lib\\site-packages\\tensorflow\\python\\keras\\_impl\\keras\\engine\\topology.py in __call__(self, inputs, **kwargs)</span>\n    <span class=\"pl-c1\">250</span>     <span class=\"pl-s\"><span class=\"pl-pds\">\"\"\"</span></span>\n<span class=\"pl-s\">    251     # Actually call the layer (optionally building it).</span>\n<span class=\"pl-s\">--&gt; 252     output = super(Layer, self).__call__(inputs, **kwargs)</span>\n<span class=\"pl-s\">    253 </span>\n<span class=\"pl-s\">    254     # Update learning phase info.</span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">C:\\Program Files\\Anaconda3\\envs<span class=\"pl-cce\">\\t</span>ensorflow\\lib\\site-packages<span class=\"pl-cce\">\\t</span>ensorflow\\python\\layers<span class=\"pl-cce\">\\b</span>ase.py in __call__(self, inputs, *args, **kwargs)</span>\n<span class=\"pl-s\">    573         if in_graph_mode:</span>\n<span class=\"pl-s\">    574           self._assert_input_compatibility(inputs)</span>\n<span class=\"pl-s\">--&gt; 575         outputs = self.call(inputs, *args, **kwargs)</span>\n<span class=\"pl-s\">    576 </span>\n<span class=\"pl-s\">    577         if outputs is None:</span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">C:\\Program Files\\Anaconda3\\envs<span class=\"pl-cce\">\\t</span>ensorflow\\lib\\site-packages<span class=\"pl-cce\">\\t</span>ensorflow\\python\\layers<span class=\"pl-cce\">\\b</span>ase.py in call(self, inputs, mask)</span>\n<span class=\"pl-s\">   1918     else:</span>\n<span class=\"pl-s\">   1919       # Cache miss: actually apply the network graph to the new inputs.</span>\n<span class=\"pl-s\">-&gt; 1920       output_tensors, _, _ = self._run_internal_graph(inputs, masks)</span>\n<span class=\"pl-s\">   1921       return output_tensors</span>\n<span class=\"pl-s\">   1922 </span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">C:\\Program Files\\Anaconda3\\envs<span class=\"pl-cce\">\\t</span>ensorflow\\lib\\site-packages<span class=\"pl-cce\">\\t</span>ensorflow\\python\\layers<span class=\"pl-cce\">\\b</span>ase.py in _run_internal_graph(self, inputs, masks)</span>\n<span class=\"pl-s\">   2082                 if 'mask' not in kwargs:</span>\n<span class=\"pl-s\">   2083                   kwargs['mask'] = computed_mask</span>\n<span class=\"pl-s\">-&gt; 2084               output_tensors = _to_list(layer.call(computed_tensor, **kwargs))</span>\n<span class=\"pl-s\">   2085               if hasattr(layer, 'compute_mask'):</span>\n<span class=\"pl-s\">   2086                 output_masks = _to_list(</span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">C:\\Program Files\\Anaconda3\\envs<span class=\"pl-cce\">\\t</span>ensorflow\\lib\\site-packages<span class=\"pl-cce\">\\t</span>ensorflow\\python\\layers\\convolutional.py in call(self, inputs)</span>\n<span class=\"pl-s\">    169     # TODO(agarwal): do we need this name_scope ?</span>\n<span class=\"pl-s\">    170     with ops.name_scope(None, 'convolution', [inputs, self.kernel]):</span>\n<span class=\"pl-s\">--&gt; 171       outputs = self._convolution_op(inputs, self.kernel)</span>\n<span class=\"pl-s\">    172 </span>\n<span class=\"pl-s\">    173     if self.use_bias:</span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">C:\\Program Files\\Anaconda3\\envs<span class=\"pl-cce\">\\t</span>ensorflow\\lib\\site-packages<span class=\"pl-cce\">\\t</span>ensorflow\\python\\ops<span class=\"pl-cce\">\\n</span>n_ops.py in __call__(self, inp, filter)</span>\n<span class=\"pl-s\">    833 </span>\n<span class=\"pl-s\">    834   def __call__(self, inp, filter):  # pylint: disable=redefined-builtin</span>\n<span class=\"pl-s\">--&gt; 835     return self.conv_op(inp, filter)</span>\n<span class=\"pl-s\">    836 </span>\n<span class=\"pl-s\">    837 </span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">C:\\Program Files\\Anaconda3\\envs<span class=\"pl-cce\">\\t</span>ensorflow\\lib\\site-packages<span class=\"pl-cce\">\\t</span>ensorflow\\python\\ops<span class=\"pl-cce\">\\n</span>n_ops.py in __call__(self, inp, filter)</span>\n<span class=\"pl-s\">    497 </span>\n<span class=\"pl-s\">    498   def __call__(self, inp, filter):  # pylint: disable=redefined-builtin</span>\n<span class=\"pl-s\">--&gt; 499     return self.call(inp, filter)</span>\n<span class=\"pl-s\">    500 </span>\n<span class=\"pl-s\">    501 </span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">C:\\Program Files\\Anaconda3\\envs<span class=\"pl-cce\">\\t</span>ensorflow\\lib\\site-packages<span class=\"pl-cce\">\\t</span>ensorflow\\python\\ops<span class=\"pl-cce\">\\n</span>n_ops.py in __call__(self, inp, filter)</span>\n<span class=\"pl-s\">    185         padding=self.padding,</span>\n<span class=\"pl-s\">    186         data_format=self.data_format,</span>\n<span class=\"pl-s\">--&gt; 187         name=self.name)</span>\n<span class=\"pl-s\">    188 </span>\n<span class=\"pl-s\">    189 </span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">C:\\Program Files\\Anaconda3\\envs<span class=\"pl-cce\">\\t</span>ensorflow\\lib\\site-packages<span class=\"pl-cce\">\\t</span>ensorflow\\python\\ops\\gen_nn_ops.py in conv2d(input, filter, strides, padding, use_cudnn_on_gpu, data_format, name)</span>\n<span class=\"pl-s\">    628         \"Conv2D\", input=input, filter=filter, strides=strides,</span>\n<span class=\"pl-s\">    629         padding=padding, use_cudnn_on_gpu=use_cudnn_on_gpu,</span>\n<span class=\"pl-s\">--&gt; 630         data_format=data_format, name=name)</span>\n<span class=\"pl-s\">    631     _result = _op.outputs[:]</span>\n<span class=\"pl-s\">    632     _inputs_flat = _op.inputs</span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">C:\\Program Files\\Anaconda3\\envs<span class=\"pl-cce\">\\t</span>ensorflow\\lib\\site-packages<span class=\"pl-cce\">\\t</span>ensorflow\\python<span class=\"pl-cce\">\\f</span>ramework\\op_def_library.py in _apply_op_helper(self, op_type_name, name, **keywords)</span>\n<span class=\"pl-s\">    785         op = g.create_op(op_type_name, inputs, output_types, name=scope,</span>\n<span class=\"pl-s\">    786                          input_types=input_types, attrs=attr_protos,</span>\n<span class=\"pl-s\">--&gt; 787                          op_def=op_def)</span>\n<span class=\"pl-s\">    788       return output_structure, op_def.is_stateful, op</span>\n<span class=\"pl-s\">    789 </span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">C:\\Program Files\\Anaconda3\\envs<span class=\"pl-cce\">\\t</span>ensorflow\\lib\\site-packages<span class=\"pl-cce\">\\t</span>ensorflow\\python<span class=\"pl-cce\">\\f</span>ramework\\ops.py in create_op(self, op_type, inputs, dtypes, input_types, name, attrs, op_def, compute_shapes, compute_device)</span>\n<span class=\"pl-s\">   2957     if compute_shapes:</span>\n<span class=\"pl-s\">   2958       set_shapes_for_outputs(ret)</span>\n<span class=\"pl-s\">-&gt; 2959     self._add_op(ret)</span>\n<span class=\"pl-s\">   2960     self._record_op_seen_by_control_dependencies(ret)</span>\n<span class=\"pl-s\">   2961 </span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">C:\\Program Files\\Anaconda3\\envs<span class=\"pl-cce\">\\t</span>ensorflow\\lib\\site-packages<span class=\"pl-cce\">\\t</span>ensorflow\\python<span class=\"pl-cce\">\\f</span>ramework\\ops.py in _add_op(self, op)</span>\n<span class=\"pl-s\">   2597       if op.name in self._nodes_by_name:</span>\n<span class=\"pl-s\">   2598         raise ValueError(\"cannot add op with name <span class=\"pl-c1\">%s</span> as that name \"</span>\n<span class=\"pl-s\">-&gt; 2599                          \"is already used\" <span class=\"pl-c1\">% o</span>p.name)</span>\n<span class=\"pl-s\">   2600       self._nodes_by_id[op._id] = op</span>\n<span class=\"pl-s\">   2601       self._nodes_by_name[op.name] = op</span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">ValueError: cannot add op with name conv2d/convolution as that name is already used</span></pre></div>\n<p>How can solve this issue ? Please help . THANKS.</p>", "body_text": "Here is my code :\nclass final_model:\n    # CNN encoder\n    encoder, preprocess_for_model = get_cnn_encoder()\n    #saver.restore(s, os.path.abspath(\"weights\"))  # keras applications corrupt our graph, so we restore trained weights\n    \n    # containers for current lstm state\n    lstm_c = tf.Variable(tf.zeros([1, LSTM_UNITS]), name=\"cell\")\n    lstm_h = tf.Variable(tf.zeros([1, LSTM_UNITS]), name=\"hidden\")\n\n    # input images\n    input_images = tf.placeholder('float32', [1, IMG_SIZE, IMG_SIZE, 3], name='images')\n\n    # get image embeddings\n    img_embeds = encoder(input_images)\n\n    # initialize lstm state conditioned on image\n    init_c = init_h = decoder.img_embed_bottleneck_to_h0(decoder.img_embed_to_bottleneck(img_embeds))\n    init_lstm = tf.assign(lstm_c, init_c), tf.assign(lstm_h, init_h)\n    \n    # current word index\n    current_word = tf.placeholder('int32', [1], name='current_input')\n\n    # embedding for current word\n    word_embed = decoder.word_embed(current_word)\n\n    # apply lstm cell, get new lstm states\n    new_c, new_h = decoder.lstm(word_embed, tf.nn.rnn_cell.LSTMStateTuple(lstm_c, lstm_h))[1]\n\n    # compute logits for next token\n    new_logits = decoder.token_logits(decoder.token_logits_bottleneck(new_h))\n    # compute probabilities for next token\n    new_probs = tf.nn.softmax(new_logits)\n\n    # `one_step` outputs probabilities of next token and updates lstm hidden state\n    one_step = new_probs, tf.assign(lstm_c, new_c), tf.assign(lstm_h, new_h)\nAnd I am getting following error :\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\n<ipython-input-42-73f88badc13d> in <module>()\n----> 1 class final_model:\n      2     # CNN encoder\n      3     encoder, preprocess_for_model = get_cnn_encoder()\n      4     #saver.restore(s, os.path.abspath(\"weights\"))  # keras applications corrupt our graph, so we restore trained weights\n      5 \n\n<ipython-input-42-73f88badc13d> in final_model()\n     12 \n     13     # get image embeddings\n---> 14     img_embeds = encoder(input_images)\n     15 \n     16     # initialize lstm state conditioned on image\n\nC:\\Program Files\\Anaconda3\\envs\\tensorflow\\lib\\site-packages\\tensorflow\\python\\keras\\_impl\\keras\\engine\\topology.py in __call__(self, inputs, **kwargs)\n    250     \"\"\"\n    251     # Actually call the layer (optionally building it).\n--> 252     output = super(Layer, self).__call__(inputs, **kwargs)\n    253 \n    254     # Update learning phase info.\n\nC:\\Program Files\\Anaconda3\\envs\\tensorflow\\lib\\site-packages\\tensorflow\\python\\layers\\base.py in __call__(self, inputs, *args, **kwargs)\n    573         if in_graph_mode:\n    574           self._assert_input_compatibility(inputs)\n--> 575         outputs = self.call(inputs, *args, **kwargs)\n    576 \n    577         if outputs is None:\n\nC:\\Program Files\\Anaconda3\\envs\\tensorflow\\lib\\site-packages\\tensorflow\\python\\layers\\base.py in call(self, inputs, mask)\n   1918     else:\n   1919       # Cache miss: actually apply the network graph to the new inputs.\n-> 1920       output_tensors, _, _ = self._run_internal_graph(inputs, masks)\n   1921       return output_tensors\n   1922 \n\nC:\\Program Files\\Anaconda3\\envs\\tensorflow\\lib\\site-packages\\tensorflow\\python\\layers\\base.py in _run_internal_graph(self, inputs, masks)\n   2082                 if 'mask' not in kwargs:\n   2083                   kwargs['mask'] = computed_mask\n-> 2084               output_tensors = _to_list(layer.call(computed_tensor, **kwargs))\n   2085               if hasattr(layer, 'compute_mask'):\n   2086                 output_masks = _to_list(\n\nC:\\Program Files\\Anaconda3\\envs\\tensorflow\\lib\\site-packages\\tensorflow\\python\\layers\\convolutional.py in call(self, inputs)\n    169     # TODO(agarwal): do we need this name_scope ?\n    170     with ops.name_scope(None, 'convolution', [inputs, self.kernel]):\n--> 171       outputs = self._convolution_op(inputs, self.kernel)\n    172 \n    173     if self.use_bias:\n\nC:\\Program Files\\Anaconda3\\envs\\tensorflow\\lib\\site-packages\\tensorflow\\python\\ops\\nn_ops.py in __call__(self, inp, filter)\n    833 \n    834   def __call__(self, inp, filter):  # pylint: disable=redefined-builtin\n--> 835     return self.conv_op(inp, filter)\n    836 \n    837 \n\nC:\\Program Files\\Anaconda3\\envs\\tensorflow\\lib\\site-packages\\tensorflow\\python\\ops\\nn_ops.py in __call__(self, inp, filter)\n    497 \n    498   def __call__(self, inp, filter):  # pylint: disable=redefined-builtin\n--> 499     return self.call(inp, filter)\n    500 \n    501 \n\nC:\\Program Files\\Anaconda3\\envs\\tensorflow\\lib\\site-packages\\tensorflow\\python\\ops\\nn_ops.py in __call__(self, inp, filter)\n    185         padding=self.padding,\n    186         data_format=self.data_format,\n--> 187         name=self.name)\n    188 \n    189 \n\nC:\\Program Files\\Anaconda3\\envs\\tensorflow\\lib\\site-packages\\tensorflow\\python\\ops\\gen_nn_ops.py in conv2d(input, filter, strides, padding, use_cudnn_on_gpu, data_format, name)\n    628         \"Conv2D\", input=input, filter=filter, strides=strides,\n    629         padding=padding, use_cudnn_on_gpu=use_cudnn_on_gpu,\n--> 630         data_format=data_format, name=name)\n    631     _result = _op.outputs[:]\n    632     _inputs_flat = _op.inputs\n\nC:\\Program Files\\Anaconda3\\envs\\tensorflow\\lib\\site-packages\\tensorflow\\python\\framework\\op_def_library.py in _apply_op_helper(self, op_type_name, name, **keywords)\n    785         op = g.create_op(op_type_name, inputs, output_types, name=scope,\n    786                          input_types=input_types, attrs=attr_protos,\n--> 787                          op_def=op_def)\n    788       return output_structure, op_def.is_stateful, op\n    789 \n\nC:\\Program Files\\Anaconda3\\envs\\tensorflow\\lib\\site-packages\\tensorflow\\python\\framework\\ops.py in create_op(self, op_type, inputs, dtypes, input_types, name, attrs, op_def, compute_shapes, compute_device)\n   2957     if compute_shapes:\n   2958       set_shapes_for_outputs(ret)\n-> 2959     self._add_op(ret)\n   2960     self._record_op_seen_by_control_dependencies(ret)\n   2961 \n\nC:\\Program Files\\Anaconda3\\envs\\tensorflow\\lib\\site-packages\\tensorflow\\python\\framework\\ops.py in _add_op(self, op)\n   2597       if op.name in self._nodes_by_name:\n   2598         raise ValueError(\"cannot add op with name %s as that name \"\n-> 2599                          \"is already used\" % op.name)\n   2600       self._nodes_by_id[op._id] = op\n   2601       self._nodes_by_name[op.name] = op\n\nValueError: cannot add op with name conv2d/convolution as that name is already used\nHow can solve this issue ? Please help . THANKS.", "body": "Here is my code : \r\n```python\r\nclass final_model:\r\n    # CNN encoder\r\n    encoder, preprocess_for_model = get_cnn_encoder()\r\n    #saver.restore(s, os.path.abspath(\"weights\"))  # keras applications corrupt our graph, so we restore trained weights\r\n    \r\n    # containers for current lstm state\r\n    lstm_c = tf.Variable(tf.zeros([1, LSTM_UNITS]), name=\"cell\")\r\n    lstm_h = tf.Variable(tf.zeros([1, LSTM_UNITS]), name=\"hidden\")\r\n\r\n    # input images\r\n    input_images = tf.placeholder('float32', [1, IMG_SIZE, IMG_SIZE, 3], name='images')\r\n\r\n    # get image embeddings\r\n    img_embeds = encoder(input_images)\r\n\r\n    # initialize lstm state conditioned on image\r\n    init_c = init_h = decoder.img_embed_bottleneck_to_h0(decoder.img_embed_to_bottleneck(img_embeds))\r\n    init_lstm = tf.assign(lstm_c, init_c), tf.assign(lstm_h, init_h)\r\n    \r\n    # current word index\r\n    current_word = tf.placeholder('int32', [1], name='current_input')\r\n\r\n    # embedding for current word\r\n    word_embed = decoder.word_embed(current_word)\r\n\r\n    # apply lstm cell, get new lstm states\r\n    new_c, new_h = decoder.lstm(word_embed, tf.nn.rnn_cell.LSTMStateTuple(lstm_c, lstm_h))[1]\r\n\r\n    # compute logits for next token\r\n    new_logits = decoder.token_logits(decoder.token_logits_bottleneck(new_h))\r\n    # compute probabilities for next token\r\n    new_probs = tf.nn.softmax(new_logits)\r\n\r\n    # `one_step` outputs probabilities of next token and updates lstm hidden state\r\n    one_step = new_probs, tf.assign(lstm_c, new_c), tf.assign(lstm_h, new_h)\r\n```\r\n\r\nAnd I am getting following error : \r\n\r\n```python\r\n---------------------------------------------------------------------------\r\nValueError                                Traceback (most recent call last)\r\n<ipython-input-42-73f88badc13d> in <module>()\r\n----> 1 class final_model:\r\n      2     # CNN encoder\r\n      3     encoder, preprocess_for_model = get_cnn_encoder()\r\n      4     #saver.restore(s, os.path.abspath(\"weights\"))  # keras applications corrupt our graph, so we restore trained weights\r\n      5 \r\n\r\n<ipython-input-42-73f88badc13d> in final_model()\r\n     12 \r\n     13     # get image embeddings\r\n---> 14     img_embeds = encoder(input_images)\r\n     15 \r\n     16     # initialize lstm state conditioned on image\r\n\r\nC:\\Program Files\\Anaconda3\\envs\\tensorflow\\lib\\site-packages\\tensorflow\\python\\keras\\_impl\\keras\\engine\\topology.py in __call__(self, inputs, **kwargs)\r\n    250     \"\"\"\r\n    251     # Actually call the layer (optionally building it).\r\n--> 252     output = super(Layer, self).__call__(inputs, **kwargs)\r\n    253 \r\n    254     # Update learning phase info.\r\n\r\nC:\\Program Files\\Anaconda3\\envs\\tensorflow\\lib\\site-packages\\tensorflow\\python\\layers\\base.py in __call__(self, inputs, *args, **kwargs)\r\n    573         if in_graph_mode:\r\n    574           self._assert_input_compatibility(inputs)\r\n--> 575         outputs = self.call(inputs, *args, **kwargs)\r\n    576 \r\n    577         if outputs is None:\r\n\r\nC:\\Program Files\\Anaconda3\\envs\\tensorflow\\lib\\site-packages\\tensorflow\\python\\layers\\base.py in call(self, inputs, mask)\r\n   1918     else:\r\n   1919       # Cache miss: actually apply the network graph to the new inputs.\r\n-> 1920       output_tensors, _, _ = self._run_internal_graph(inputs, masks)\r\n   1921       return output_tensors\r\n   1922 \r\n\r\nC:\\Program Files\\Anaconda3\\envs\\tensorflow\\lib\\site-packages\\tensorflow\\python\\layers\\base.py in _run_internal_graph(self, inputs, masks)\r\n   2082                 if 'mask' not in kwargs:\r\n   2083                   kwargs['mask'] = computed_mask\r\n-> 2084               output_tensors = _to_list(layer.call(computed_tensor, **kwargs))\r\n   2085               if hasattr(layer, 'compute_mask'):\r\n   2086                 output_masks = _to_list(\r\n\r\nC:\\Program Files\\Anaconda3\\envs\\tensorflow\\lib\\site-packages\\tensorflow\\python\\layers\\convolutional.py in call(self, inputs)\r\n    169     # TODO(agarwal): do we need this name_scope ?\r\n    170     with ops.name_scope(None, 'convolution', [inputs, self.kernel]):\r\n--> 171       outputs = self._convolution_op(inputs, self.kernel)\r\n    172 \r\n    173     if self.use_bias:\r\n\r\nC:\\Program Files\\Anaconda3\\envs\\tensorflow\\lib\\site-packages\\tensorflow\\python\\ops\\nn_ops.py in __call__(self, inp, filter)\r\n    833 \r\n    834   def __call__(self, inp, filter):  # pylint: disable=redefined-builtin\r\n--> 835     return self.conv_op(inp, filter)\r\n    836 \r\n    837 \r\n\r\nC:\\Program Files\\Anaconda3\\envs\\tensorflow\\lib\\site-packages\\tensorflow\\python\\ops\\nn_ops.py in __call__(self, inp, filter)\r\n    497 \r\n    498   def __call__(self, inp, filter):  # pylint: disable=redefined-builtin\r\n--> 499     return self.call(inp, filter)\r\n    500 \r\n    501 \r\n\r\nC:\\Program Files\\Anaconda3\\envs\\tensorflow\\lib\\site-packages\\tensorflow\\python\\ops\\nn_ops.py in __call__(self, inp, filter)\r\n    185         padding=self.padding,\r\n    186         data_format=self.data_format,\r\n--> 187         name=self.name)\r\n    188 \r\n    189 \r\n\r\nC:\\Program Files\\Anaconda3\\envs\\tensorflow\\lib\\site-packages\\tensorflow\\python\\ops\\gen_nn_ops.py in conv2d(input, filter, strides, padding, use_cudnn_on_gpu, data_format, name)\r\n    628         \"Conv2D\", input=input, filter=filter, strides=strides,\r\n    629         padding=padding, use_cudnn_on_gpu=use_cudnn_on_gpu,\r\n--> 630         data_format=data_format, name=name)\r\n    631     _result = _op.outputs[:]\r\n    632     _inputs_flat = _op.inputs\r\n\r\nC:\\Program Files\\Anaconda3\\envs\\tensorflow\\lib\\site-packages\\tensorflow\\python\\framework\\op_def_library.py in _apply_op_helper(self, op_type_name, name, **keywords)\r\n    785         op = g.create_op(op_type_name, inputs, output_types, name=scope,\r\n    786                          input_types=input_types, attrs=attr_protos,\r\n--> 787                          op_def=op_def)\r\n    788       return output_structure, op_def.is_stateful, op\r\n    789 \r\n\r\nC:\\Program Files\\Anaconda3\\envs\\tensorflow\\lib\\site-packages\\tensorflow\\python\\framework\\ops.py in create_op(self, op_type, inputs, dtypes, input_types, name, attrs, op_def, compute_shapes, compute_device)\r\n   2957     if compute_shapes:\r\n   2958       set_shapes_for_outputs(ret)\r\n-> 2959     self._add_op(ret)\r\n   2960     self._record_op_seen_by_control_dependencies(ret)\r\n   2961 \r\n\r\nC:\\Program Files\\Anaconda3\\envs\\tensorflow\\lib\\site-packages\\tensorflow\\python\\framework\\ops.py in _add_op(self, op)\r\n   2597       if op.name in self._nodes_by_name:\r\n   2598         raise ValueError(\"cannot add op with name %s as that name \"\r\n-> 2599                          \"is already used\" % op.name)\r\n   2600       self._nodes_by_id[op._id] = op\r\n   2601       self._nodes_by_name[op.name] = op\r\n\r\nValueError: cannot add op with name conv2d/convolution as that name is already used\r\n```\r\n\r\nHow can solve this issue ? Please help . THANKS."}