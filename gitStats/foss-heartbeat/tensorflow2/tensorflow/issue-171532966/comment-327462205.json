{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/327462205", "html_url": "https://github.com/tensorflow/tensorflow/issues/3862#issuecomment-327462205", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/3862", "id": 327462205, "node_id": "MDEyOklzc3VlQ29tbWVudDMyNzQ2MjIwNQ==", "user": {"login": "akosiorek", "id": 5015641, "node_id": "MDQ6VXNlcjUwMTU2NDE=", "avatar_url": "https://avatars2.githubusercontent.com/u/5015641?v=4", "gravatar_id": "", "url": "https://api.github.com/users/akosiorek", "html_url": "https://github.com/akosiorek", "followers_url": "https://api.github.com/users/akosiorek/followers", "following_url": "https://api.github.com/users/akosiorek/following{/other_user}", "gists_url": "https://api.github.com/users/akosiorek/gists{/gist_id}", "starred_url": "https://api.github.com/users/akosiorek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/akosiorek/subscriptions", "organizations_url": "https://api.github.com/users/akosiorek/orgs", "repos_url": "https://api.github.com/users/akosiorek/repos", "events_url": "https://api.github.com/users/akosiorek/events{/privacy}", "received_events_url": "https://api.github.com/users/akosiorek/received_events", "type": "User", "site_admin": false}, "created_at": "2017-09-06T12:03:36Z", "updated_at": "2017-09-06T12:07:27Z", "author_association": "NONE", "body_html": "<p>The following workaround helps to avoid the NaN gradient issue (it lacks the <code>exclusive</code> or <code>reverse</code> flags but they're easy enough to implement):</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">def</span> <span class=\"pl-en\">cumprod</span>(<span class=\"pl-smi\">tensor</span>, <span class=\"pl-smi\">axis</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">0</span>):\n    transpose_permutation <span class=\"pl-k\">=</span> <span class=\"pl-c1\">None</span>\n    n_dim <span class=\"pl-k\">=</span> <span class=\"pl-c1\">len</span>(tensor.get_shape())\n    <span class=\"pl-k\">if</span> n_dim <span class=\"pl-k\">&gt;</span> <span class=\"pl-c1\">1</span> <span class=\"pl-k\">and</span> axis <span class=\"pl-k\">!=</span> <span class=\"pl-c1\">0</span>:\n\n        <span class=\"pl-k\">if</span> axis <span class=\"pl-k\">&lt;</span> <span class=\"pl-c1\">0</span>:\n            axis <span class=\"pl-k\">=</span> n_dim <span class=\"pl-k\">+</span> axis\n\n        transpose_permutation <span class=\"pl-k\">=</span> np.arange(n_dim)\n        transpose_permutation[<span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>], transpose_permutation[<span class=\"pl-c1\">0</span>] <span class=\"pl-k\">=</span> <span class=\"pl-c1\">0</span>, axis\n\n    tensor <span class=\"pl-k\">=</span> tf.transpose(tensor, transpose_permutation)\n\n    <span class=\"pl-k\">def</span> <span class=\"pl-en\">prod</span>(<span class=\"pl-smi\">acc</span>, <span class=\"pl-smi\">x</span>):\n        <span class=\"pl-k\">return</span> acc <span class=\"pl-k\">*</span> x\n\n    prob <span class=\"pl-k\">=</span> tf.scan(prod, tensor)\n    tensor <span class=\"pl-k\">=</span> tf.transpose(prob, transpose_permutation)\n    <span class=\"pl-k\">return</span> tensor</pre></div>\n<p>Can anyone comment on efficiency of this approach?</p>", "body_text": "The following workaround helps to avoid the NaN gradient issue (it lacks the exclusive or reverse flags but they're easy enough to implement):\ndef cumprod(tensor, axis=0):\n    transpose_permutation = None\n    n_dim = len(tensor.get_shape())\n    if n_dim > 1 and axis != 0:\n\n        if axis < 0:\n            axis = n_dim + axis\n\n        transpose_permutation = np.arange(n_dim)\n        transpose_permutation[-1], transpose_permutation[0] = 0, axis\n\n    tensor = tf.transpose(tensor, transpose_permutation)\n\n    def prod(acc, x):\n        return acc * x\n\n    prob = tf.scan(prod, tensor)\n    tensor = tf.transpose(prob, transpose_permutation)\n    return tensor\nCan anyone comment on efficiency of this approach?", "body": "The following workaround helps to avoid the NaN gradient issue (it lacks the `exclusive` or `reverse` flags but they're easy enough to implement):\r\n```python\r\ndef cumprod(tensor, axis=0):\r\n    transpose_permutation = None\r\n    n_dim = len(tensor.get_shape())\r\n    if n_dim > 1 and axis != 0:\r\n\r\n        if axis < 0:\r\n            axis = n_dim + axis\r\n\r\n        transpose_permutation = np.arange(n_dim)\r\n        transpose_permutation[-1], transpose_permutation[0] = 0, axis\r\n\r\n    tensor = tf.transpose(tensor, transpose_permutation)\r\n\r\n    def prod(acc, x):\r\n        return acc * x\r\n\r\n    prob = tf.scan(prod, tensor)\r\n    tensor = tf.transpose(prob, transpose_permutation)\r\n    return tensor\r\n```\r\n\r\nCan anyone comment on efficiency of this approach?"}