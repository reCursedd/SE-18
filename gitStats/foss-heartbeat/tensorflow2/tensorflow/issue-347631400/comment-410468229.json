{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/410468229", "html_url": "https://github.com/tensorflow/tensorflow/issues/21384#issuecomment-410468229", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/21384", "id": 410468229, "node_id": "MDEyOklzc3VlQ29tbWVudDQxMDQ2ODIyOQ==", "user": {"login": "ageron", "id": 76661, "node_id": "MDQ6VXNlcjc2NjYx", "avatar_url": "https://avatars3.githubusercontent.com/u/76661?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ageron", "html_url": "https://github.com/ageron", "followers_url": "https://api.github.com/users/ageron/followers", "following_url": "https://api.github.com/users/ageron/following{/other_user}", "gists_url": "https://api.github.com/users/ageron/gists{/gist_id}", "starred_url": "https://api.github.com/users/ageron/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ageron/subscriptions", "organizations_url": "https://api.github.com/users/ageron/orgs", "repos_url": "https://api.github.com/users/ageron/repos", "events_url": "https://api.github.com/users/ageron/events{/privacy}", "received_events_url": "https://api.github.com/users/ageron/received_events", "type": "User", "site_admin": false}, "created_at": "2018-08-04T18:21:28Z", "updated_at": "2018-08-04T18:39:05Z", "author_association": "CONTRIBUTOR", "body_html": "<p>After further investigation, it seems that the issue comes from the fact that the <code>assign()</code> method calls <code>gen_resource_variable_ops.assign_variable_op()</code> which returns an assignment operation in graph mode, but it returns <code>None</code> in eager mode. Then the <code>assign()</code> method returns <code>self._lazy_read(assign_op)</code>, which in eager mode is equivalent to <code>self._lazy_read(op=None)</code>.  Here is the <code>_lazy_read()</code> method:</p>\n<div class=\"highlight highlight-source-python\"><pre>  <span class=\"pl-k\">def</span> <span class=\"pl-en\">_lazy_read</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>, <span class=\"pl-smi\">op</span>):\n    <span class=\"pl-k\">if</span> <span class=\"pl-c1\">self</span>.trainable:\n      tape.watch_variable(<span class=\"pl-c1\">self</span>)\n    <span class=\"pl-k\">return</span> _UnreadVariable(\n        <span class=\"pl-c1\">self</span>._handle, <span class=\"pl-c1\">self</span>.dtype, <span class=\"pl-c1\">self</span>._shape, <span class=\"pl-c1\">self</span>._in_graph_mode,\n        <span class=\"pl-c1\">self</span>._handle_deleter <span class=\"pl-k\">if</span> <span class=\"pl-k\">not</span> <span class=\"pl-c1\">self</span>._in_graph_mode <span class=\"pl-k\">else</span> <span class=\"pl-c1\">None</span>, op,\n        <span class=\"pl-c1\">self</span>._unique_id)</pre></div>\n<p>This method creates an <code>_UnreadVariable</code> with its <code>parent_op=op</code>, which in this case is <code>None</code>. So of course <code>self.parent_op.name</code> will fail.</p>", "body_text": "After further investigation, it seems that the issue comes from the fact that the assign() method calls gen_resource_variable_ops.assign_variable_op() which returns an assignment operation in graph mode, but it returns None in eager mode. Then the assign() method returns self._lazy_read(assign_op), which in eager mode is equivalent to self._lazy_read(op=None).  Here is the _lazy_read() method:\n  def _lazy_read(self, op):\n    if self.trainable:\n      tape.watch_variable(self)\n    return _UnreadVariable(\n        self._handle, self.dtype, self._shape, self._in_graph_mode,\n        self._handle_deleter if not self._in_graph_mode else None, op,\n        self._unique_id)\nThis method creates an _UnreadVariable with its parent_op=op, which in this case is None. So of course self.parent_op.name will fail.", "body": "After further investigation, it seems that the issue comes from the fact that the `assign()` method calls `gen_resource_variable_ops.assign_variable_op()` which returns an assignment operation in graph mode, but it returns `None` in eager mode. Then the `assign()` method returns `self._lazy_read(assign_op)`, which in eager mode is equivalent to `self._lazy_read(op=None)`.  Here is the `_lazy_read()` method:\r\n\r\n```python\r\n  def _lazy_read(self, op):\r\n    if self.trainable:\r\n      tape.watch_variable(self)\r\n    return _UnreadVariable(\r\n        self._handle, self.dtype, self._shape, self._in_graph_mode,\r\n        self._handle_deleter if not self._in_graph_mode else None, op,\r\n        self._unique_id)\r\n```\r\n\r\nThis method creates an `_UnreadVariable` with its `parent_op=op`, which in this case is `None`. So of course `self.parent_op.name` will fail."}