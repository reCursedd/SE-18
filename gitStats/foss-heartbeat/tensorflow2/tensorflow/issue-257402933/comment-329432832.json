{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/329432832", "html_url": "https://github.com/tensorflow/tensorflow/issues/13017#issuecomment-329432832", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13017", "id": 329432832, "node_id": "MDEyOklzc3VlQ29tbWVudDMyOTQzMjgzMg==", "user": {"login": "ahoereth", "id": 3015996, "node_id": "MDQ6VXNlcjMwMTU5OTY=", "avatar_url": "https://avatars2.githubusercontent.com/u/3015996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ahoereth", "html_url": "https://github.com/ahoereth", "followers_url": "https://api.github.com/users/ahoereth/followers", "following_url": "https://api.github.com/users/ahoereth/following{/other_user}", "gists_url": "https://api.github.com/users/ahoereth/gists{/gist_id}", "starred_url": "https://api.github.com/users/ahoereth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ahoereth/subscriptions", "organizations_url": "https://api.github.com/users/ahoereth/orgs", "repos_url": "https://api.github.com/users/ahoereth/repos", "events_url": "https://api.github.com/users/ahoereth/events{/privacy}", "received_events_url": "https://api.github.com/users/ahoereth/received_events", "type": "User", "site_admin": false}, "created_at": "2017-09-14T09:51:45Z", "updated_at": "2017-09-14T10:01:37Z", "author_association": "NONE", "body_html": "<p>You are correct, it only occurs when the input grows over a specific size.</p>\n<p>Here a code example with some random computations:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">import</span> tensorflow <span class=\"pl-k\">as</span> tf\n<span class=\"pl-k\">from</span> tensorflow.python.client <span class=\"pl-k\">import</span> timeline\n\nsize <span class=\"pl-k\">=</span> <span class=\"pl-c1\">21</span>\nchannels <span class=\"pl-k\">=</span> <span class=\"pl-c1\">64</span>\n\nx <span class=\"pl-k\">=</span> tf.random_uniform((<span class=\"pl-c1\">100</span>, <span class=\"pl-c1\">20</span>))\nw0 <span class=\"pl-k\">=</span> tf.get_variable(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>w<span class=\"pl-pds\">'</span></span>, (<span class=\"pl-c1\">20</span>, size <span class=\"pl-k\">*</span> size <span class=\"pl-k\">*</span> channels))\nh <span class=\"pl-k\">=</span> tf.reshape(tf.matmul(x, w0), (<span class=\"pl-c1\">100</span>, size, size, channels))\nout <span class=\"pl-k\">=</span> tf.extract_image_patches(<span class=\"pl-v\">images</span><span class=\"pl-k\">=</span>h,\n                               <span class=\"pl-v\">ksizes</span><span class=\"pl-k\">=</span>(<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">5</span>, <span class=\"pl-c1\">5</span>, <span class=\"pl-c1\">1</span>),\n                               <span class=\"pl-v\">strides</span><span class=\"pl-k\">=</span>(<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">1</span>),\n                               <span class=\"pl-v\">rates</span><span class=\"pl-k\">=</span>(<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">1</span>),\n                               <span class=\"pl-v\">padding</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>VALID<span class=\"pl-pds\">'</span></span>)\n\nloss <span class=\"pl-k\">=</span> tf.reduce_mean(out)\nop <span class=\"pl-k\">=</span> tf.train.AdamOptimizer().minimize(out)\n\noptions <span class=\"pl-k\">=</span> tf.RunOptions(<span class=\"pl-v\">trace_level</span><span class=\"pl-k\">=</span>tf.RunOptions.<span class=\"pl-c1\">FULL_TRACE</span>)\nrun_metadata <span class=\"pl-k\">=</span> tf.RunMetadata()\n<span class=\"pl-k\">with</span> tf.Session() <span class=\"pl-k\">as</span> sess:\n    sess.run(tf.global_variables_initializer())\n    sess.run(op, <span class=\"pl-v\">run_metadata</span><span class=\"pl-k\">=</span>run_metadata, <span class=\"pl-v\">options</span><span class=\"pl-k\">=</span>options)\n    tl <span class=\"pl-k\">=</span> timeline.Timeline(run_metadata.step_stats)\n    ctf <span class=\"pl-k\">=</span> tl.generate_chrome_trace_format()\n    <span class=\"pl-k\">with</span> <span class=\"pl-c1\">open</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>timeline.json<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>w<span class=\"pl-pds\">'</span></span>) <span class=\"pl-k\">as</span> f:\n        f.write(ctf)</pre></div>\n<p>Running this as above with  <code>size = 21</code> gives me the following timeline, note the time (3000ms+):<br>\n<a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://user-images.githubusercontent.com/3015996/30422734-1f798f8c-9941-11e7-872f-497f05fc1d80.png\"><img width=\"1337\" alt=\"screen shot 2017-09-14 at 11 36 02\" src=\"https://user-images.githubusercontent.com/3015996/30422734-1f798f8c-9941-11e7-872f-497f05fc1d80.png\" style=\"max-width:100%;\"></a></p>\n<p>Running it with <code>size = 20</code> instead, results in this timeline (~8ms):<br>\n<a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://user-images.githubusercontent.com/3015996/30422785-3c849c2a-9941-11e7-8beb-55f240cd83d6.png\"><img width=\"1306\" alt=\"screen shot 2017-09-14 at 11 36 28\" src=\"https://user-images.githubusercontent.com/3015996/30422785-3c849c2a-9941-11e7-8beb-55f240cd83d6.png\" style=\"max-width:100%;\"></a></p>\n<p>We just ran this test on multiple MacBooks (mid 2015, TensorFlow 1.3, both with Python 3.5 and 3.6) and an Ubuntu 16.04 desktop (TensorFlow 1.2.1, i7 with 4ghz, 31gb memory), all with very similar results (thanks <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=1836815\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/shoeffner\">@shoeffner</a>).</p>", "body_text": "You are correct, it only occurs when the input grows over a specific size.\nHere a code example with some random computations:\nimport tensorflow as tf\nfrom tensorflow.python.client import timeline\n\nsize = 21\nchannels = 64\n\nx = tf.random_uniform((100, 20))\nw0 = tf.get_variable('w', (20, size * size * channels))\nh = tf.reshape(tf.matmul(x, w0), (100, size, size, channels))\nout = tf.extract_image_patches(images=h,\n                               ksizes=(1, 5, 5, 1),\n                               strides=(1, 1, 1, 1),\n                               rates=(1, 1, 1, 1),\n                               padding='VALID')\n\nloss = tf.reduce_mean(out)\nop = tf.train.AdamOptimizer().minimize(out)\n\noptions = tf.RunOptions(trace_level=tf.RunOptions.FULL_TRACE)\nrun_metadata = tf.RunMetadata()\nwith tf.Session() as sess:\n    sess.run(tf.global_variables_initializer())\n    sess.run(op, run_metadata=run_metadata, options=options)\n    tl = timeline.Timeline(run_metadata.step_stats)\n    ctf = tl.generate_chrome_trace_format()\n    with open('timeline.json', 'w') as f:\n        f.write(ctf)\nRunning this as above with  size = 21 gives me the following timeline, note the time (3000ms+):\n\nRunning it with size = 20 instead, results in this timeline (~8ms):\n\nWe just ran this test on multiple MacBooks (mid 2015, TensorFlow 1.3, both with Python 3.5 and 3.6) and an Ubuntu 16.04 desktop (TensorFlow 1.2.1, i7 with 4ghz, 31gb memory), all with very similar results (thanks @shoeffner).", "body": "You are correct, it only occurs when the input grows over a specific size.\r\n\r\nHere a code example with some random computations:\r\n\r\n```python\r\nimport tensorflow as tf\r\nfrom tensorflow.python.client import timeline\r\n\r\nsize = 21\r\nchannels = 64\r\n\r\nx = tf.random_uniform((100, 20))\r\nw0 = tf.get_variable('w', (20, size * size * channels))\r\nh = tf.reshape(tf.matmul(x, w0), (100, size, size, channels))\r\nout = tf.extract_image_patches(images=h,\r\n                               ksizes=(1, 5, 5, 1),\r\n                               strides=(1, 1, 1, 1),\r\n                               rates=(1, 1, 1, 1),\r\n                               padding='VALID')\r\n\r\nloss = tf.reduce_mean(out)\r\nop = tf.train.AdamOptimizer().minimize(out)\r\n\r\noptions = tf.RunOptions(trace_level=tf.RunOptions.FULL_TRACE)\r\nrun_metadata = tf.RunMetadata()\r\nwith tf.Session() as sess:\r\n    sess.run(tf.global_variables_initializer())\r\n    sess.run(op, run_metadata=run_metadata, options=options)\r\n    tl = timeline.Timeline(run_metadata.step_stats)\r\n    ctf = tl.generate_chrome_trace_format()\r\n    with open('timeline.json', 'w') as f:\r\n        f.write(ctf)\r\n```\r\n\r\nRunning this as above with  `size = 21` gives me the following timeline, note the time (3000ms+):\r\n<img width=\"1337\" alt=\"screen shot 2017-09-14 at 11 36 02\" src=\"https://user-images.githubusercontent.com/3015996/30422734-1f798f8c-9941-11e7-872f-497f05fc1d80.png\">\r\n\r\nRunning it with `size = 20` instead, results in this timeline (~8ms):\r\n<img width=\"1306\" alt=\"screen shot 2017-09-14 at 11 36 28\" src=\"https://user-images.githubusercontent.com/3015996/30422785-3c849c2a-9941-11e7-8beb-55f240cd83d6.png\">\r\n\r\nWe just ran this test on multiple MacBooks (mid 2015, TensorFlow 1.3, both with Python 3.5 and 3.6) and an Ubuntu 16.04 desktop (TensorFlow 1.2.1, i7 with 4ghz, 31gb memory), all with very similar results (thanks @shoeffner)."}