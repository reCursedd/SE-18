{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/320003207", "html_url": "https://github.com/tensorflow/tensorflow/issues/11638#issuecomment-320003207", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11638", "id": 320003207, "node_id": "MDEyOklzc3VlQ29tbWVudDMyMDAwMzIwNw==", "user": {"login": "ZekunZh", "id": 16140400, "node_id": "MDQ6VXNlcjE2MTQwNDAw", "avatar_url": "https://avatars1.githubusercontent.com/u/16140400?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ZekunZh", "html_url": "https://github.com/ZekunZh", "followers_url": "https://api.github.com/users/ZekunZh/followers", "following_url": "https://api.github.com/users/ZekunZh/following{/other_user}", "gists_url": "https://api.github.com/users/ZekunZh/gists{/gist_id}", "starred_url": "https://api.github.com/users/ZekunZh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ZekunZh/subscriptions", "organizations_url": "https://api.github.com/users/ZekunZh/orgs", "repos_url": "https://api.github.com/users/ZekunZh/repos", "events_url": "https://api.github.com/users/ZekunZh/events{/privacy}", "received_events_url": "https://api.github.com/users/ZekunZh/received_events", "type": "User", "site_admin": false}, "created_at": "2017-08-03T15:26:40Z", "updated_at": "2017-08-03T15:28:27Z", "author_association": "NONE", "body_html": "<p>Thanks for your invitation ! <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=4445535\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/taehoonlee\">@taehoonlee</a><br>\nI have proposed my solution in my first post. To be clearer, my suggestion of code for <code>call</code> function of <code>_Pooling1D</code> class :</p>\n<pre><code>  def call(self, inputs):\n    # There is no TF op for 1D pooling, hence we make the inputs 4D.\n    if self.data_format == 'channels_last':\n      ...\n    else:\n      inputs = array_ops.expand_dims(inputs, -1)\n      pool_shape = (1, 1) + self.pool_size + (1,)\n      strides = (1, 1) + self.strides + (1,)\n      data_format = 'NCHW'\n\n    outputs = ...\n\n    if self.data_format == 'channels_last':\n      ...\n    else:\n      return array_ops.squeeze(outputs, -1)\n</code></pre>\n<p>I will make my pull request very soon.</p>", "body_text": "Thanks for your invitation ! @taehoonlee\nI have proposed my solution in my first post. To be clearer, my suggestion of code for call function of _Pooling1D class :\n  def call(self, inputs):\n    # There is no TF op for 1D pooling, hence we make the inputs 4D.\n    if self.data_format == 'channels_last':\n      ...\n    else:\n      inputs = array_ops.expand_dims(inputs, -1)\n      pool_shape = (1, 1) + self.pool_size + (1,)\n      strides = (1, 1) + self.strides + (1,)\n      data_format = 'NCHW'\n\n    outputs = ...\n\n    if self.data_format == 'channels_last':\n      ...\n    else:\n      return array_ops.squeeze(outputs, -1)\n\nI will make my pull request very soon.", "body": "Thanks for your invitation ! @taehoonlee \r\nI have proposed my solution in my first post. To be clearer, my suggestion of code for ``call`` function of ``_Pooling1D`` class :\r\n````\r\n  def call(self, inputs):\r\n    # There is no TF op for 1D pooling, hence we make the inputs 4D.\r\n    if self.data_format == 'channels_last':\r\n      ...\r\n    else:\r\n      inputs = array_ops.expand_dims(inputs, -1)\r\n      pool_shape = (1, 1) + self.pool_size + (1,)\r\n      strides = (1, 1) + self.strides + (1,)\r\n      data_format = 'NCHW'\r\n\r\n    outputs = ...\r\n\r\n    if self.data_format == 'channels_last':\r\n      ...\r\n    else:\r\n      return array_ops.squeeze(outputs, -1)\r\n````\r\nI will make my pull request very soon."}