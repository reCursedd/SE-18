{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/321173391", "html_url": "https://github.com/tensorflow/tensorflow/issues/11974#issuecomment-321173391", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11974", "id": 321173391, "node_id": "MDEyOklzc3VlQ29tbWVudDMyMTE3MzM5MQ==", "user": {"login": "facaiy", "id": 1112263, "node_id": "MDQ6VXNlcjExMTIyNjM=", "avatar_url": "https://avatars3.githubusercontent.com/u/1112263?v=4", "gravatar_id": "", "url": "https://api.github.com/users/facaiy", "html_url": "https://github.com/facaiy", "followers_url": "https://api.github.com/users/facaiy/followers", "following_url": "https://api.github.com/users/facaiy/following{/other_user}", "gists_url": "https://api.github.com/users/facaiy/gists{/gist_id}", "starred_url": "https://api.github.com/users/facaiy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/facaiy/subscriptions", "organizations_url": "https://api.github.com/users/facaiy/orgs", "repos_url": "https://api.github.com/users/facaiy/repos", "events_url": "https://api.github.com/users/facaiy/events{/privacy}", "received_events_url": "https://api.github.com/users/facaiy/received_events", "type": "User", "site_admin": false}, "created_at": "2017-08-09T07:13:44Z", "updated_at": "2017-08-09T07:16:52Z", "author_association": "MEMBER", "body_html": "<p>Hi, <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=23068\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/yaroslavvb\">@yaroslavvb</a> .</p>\n<p>If I understand correctly, <code>[1, Dimension(1)]</code> doesn't go <code>np.asarray</code> route,</p>\n<div class=\"highlight highlight-source-python\"><pre>  <span class=\"pl-k\">if</span> <span class=\"pl-c1\">isinstance</span>(values, (np.ndarray, np.generic)):\n    <span class=\"pl-k\">if</span> dtype:\n      nparray <span class=\"pl-k\">=</span> values.astype(dtype.as_numpy_dtype)\n    <span class=\"pl-k\">else</span>:\n      nparray <span class=\"pl-k\">=</span> values\n  <span class=\"pl-k\">elif</span> <span class=\"pl-c1\">callable</span>(<span class=\"pl-c1\">getattr</span>(values, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>__array__<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-c1\">None</span>)):\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> If a class has the __array__ method, then it is possible to convert</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> to numpy array.</span>\n    nparray <span class=\"pl-k\">=</span> np.asarray(values, <span class=\"pl-v\">dtype</span><span class=\"pl-k\">=</span>dtype)\n  <span class=\"pl-k\">else</span>:</pre></div>\n<p>In fact, it goes the last branch. In the route, <code>[1, Dimension(1)]</code> is treated as a list of objects. Then each object is treated as string, see:</p>\n<div class=\"highlight highlight-source-python\"><pre>  <span class=\"pl-k\">if</span> numpy_dtype <span class=\"pl-k\">==</span> dtypes.string <span class=\"pl-k\">and</span> <span class=\"pl-k\">not</span> <span class=\"pl-c1\">isinstance</span>(values, np.ndarray):\n    proto_values <span class=\"pl-k\">=</span> _FlattenToStrings(values)\n\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> At this point, values may be a list of objects that we could not</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> identify a common type for (hence it was inferred as</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> np.object/dtypes.string).  If we are unable to convert it to a</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> string, we raise a more helpful error message.</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span></span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> Ideally, we'd be able to convert the elements of the list to a</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> common type, but this type inference requires some thinking and</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> so we defer it for now.</span>\n    <span class=\"pl-k\">try</span>:\n      str_values <span class=\"pl-k\">=</span> [compat.as_bytes(x) <span class=\"pl-k\">for</span> x <span class=\"pl-k\">in</span> proto_values]\n    <span class=\"pl-k\">except</span> <span class=\"pl-c1\">TypeError</span>:\n      <span class=\"pl-k\">raise</span> <span class=\"pl-c1\">TypeError</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Failed to convert object of type <span class=\"pl-c1\">%s</span> to Tensor. <span class=\"pl-pds\">\"</span></span>\n                      <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Contents: <span class=\"pl-c1\">%s</span>. Consider casting elements to a <span class=\"pl-pds\">\"</span></span>\n                      <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>supported type.<span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">%</span> (<span class=\"pl-c1\">type</span>(values), values))\n    tensor_proto.string_val.extend(str_values)\n    <span class=\"pl-k\">return</span> tensor_proto</pre></div>\n<p>That's why I think obj.str() might fix the issue. However, the solution is worse in performance. Do you have a better suggestion? Thanks.</p>", "body_text": "Hi, @yaroslavvb .\nIf I understand correctly, [1, Dimension(1)] doesn't go np.asarray route,\n  if isinstance(values, (np.ndarray, np.generic)):\n    if dtype:\n      nparray = values.astype(dtype.as_numpy_dtype)\n    else:\n      nparray = values\n  elif callable(getattr(values, \"__array__\", None)):\n    # If a class has the __array__ method, then it is possible to convert\n    # to numpy array.\n    nparray = np.asarray(values, dtype=dtype)\n  else:\nIn fact, it goes the last branch. In the route, [1, Dimension(1)] is treated as a list of objects. Then each object is treated as string, see:\n  if numpy_dtype == dtypes.string and not isinstance(values, np.ndarray):\n    proto_values = _FlattenToStrings(values)\n\n    # At this point, values may be a list of objects that we could not\n    # identify a common type for (hence it was inferred as\n    # np.object/dtypes.string).  If we are unable to convert it to a\n    # string, we raise a more helpful error message.\n    #\n    # Ideally, we'd be able to convert the elements of the list to a\n    # common type, but this type inference requires some thinking and\n    # so we defer it for now.\n    try:\n      str_values = [compat.as_bytes(x) for x in proto_values]\n    except TypeError:\n      raise TypeError(\"Failed to convert object of type %s to Tensor. \"\n                      \"Contents: %s. Consider casting elements to a \"\n                      \"supported type.\" % (type(values), values))\n    tensor_proto.string_val.extend(str_values)\n    return tensor_proto\nThat's why I think obj.str() might fix the issue. However, the solution is worse in performance. Do you have a better suggestion? Thanks.", "body": "Hi, @yaroslavvb . \r\n\r\nIf I understand correctly, `[1, Dimension(1)]` doesn't go `np.asarray` route, \r\n\r\n```python\r\n  if isinstance(values, (np.ndarray, np.generic)):\r\n    if dtype:\r\n      nparray = values.astype(dtype.as_numpy_dtype)\r\n    else:\r\n      nparray = values\r\n  elif callable(getattr(values, \"__array__\", None)):\r\n    # If a class has the __array__ method, then it is possible to convert\r\n    # to numpy array.\r\n    nparray = np.asarray(values, dtype=dtype)\r\n  else:\r\n```\r\n\r\nIn fact, it goes the last branch. In the route, `[1, Dimension(1)]` is treated as a list of objects. Then each object is treated as string, see:\r\n\r\n```python\r\n  if numpy_dtype == dtypes.string and not isinstance(values, np.ndarray):\r\n    proto_values = _FlattenToStrings(values)\r\n\r\n    # At this point, values may be a list of objects that we could not\r\n    # identify a common type for (hence it was inferred as\r\n    # np.object/dtypes.string).  If we are unable to convert it to a\r\n    # string, we raise a more helpful error message.\r\n    #\r\n    # Ideally, we'd be able to convert the elements of the list to a\r\n    # common type, but this type inference requires some thinking and\r\n    # so we defer it for now.\r\n    try:\r\n      str_values = [compat.as_bytes(x) for x in proto_values]\r\n    except TypeError:\r\n      raise TypeError(\"Failed to convert object of type %s to Tensor. \"\r\n                      \"Contents: %s. Consider casting elements to a \"\r\n                      \"supported type.\" % (type(values), values))\r\n    tensor_proto.string_val.extend(str_values)\r\n    return tensor_proto\r\n```\r\n\r\nThat's why I think obj.str() might fix the issue. However, the solution is worse in performance. Do you have a better suggestion? Thanks."}