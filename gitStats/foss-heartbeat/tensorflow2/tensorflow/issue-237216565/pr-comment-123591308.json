{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/123591308", "pull_request_review_id": 45810619, "id": 123591308, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEyMzU5MTMwOA==", "diff_hunk": "@@ -97,6 +99,46 @@ public Output output(int idx) {\n     return new Output(this, idx);\n   }\n \n+  @Override\n+  public int hashCode() {\n+    Graph.Reference r = graph.ref();\n+    try {\n+      // xor the first and last 32 bits of the underlying 64-bit pointer value.\n+      return (int) (unsafeNativeHandle ^ (unsafeNativeHandle >>> 32));", "path": "tensorflow/java/src/main/java/org/tensorflow/Operation.java", "position": null, "original_position": 48, "commit_id": "b43a96b1b611206a6c743892c9d25c515771a416", "original_commit_id": "2e4e4263be8ae371f066078cb7e957a33af39ab8", "user": {"login": "kbsriram", "id": 1495065, "node_id": "MDQ6VXNlcjE0OTUwNjU=", "avatar_url": "https://avatars3.githubusercontent.com/u/1495065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kbsriram", "html_url": "https://github.com/kbsriram", "followers_url": "https://api.github.com/users/kbsriram/followers", "following_url": "https://api.github.com/users/kbsriram/following{/other_user}", "gists_url": "https://api.github.com/users/kbsriram/gists{/gist_id}", "starred_url": "https://api.github.com/users/kbsriram/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kbsriram/subscriptions", "organizations_url": "https://api.github.com/users/kbsriram/orgs", "repos_url": "https://api.github.com/users/kbsriram/repos", "events_url": "https://api.github.com/users/kbsriram/events{/privacy}", "received_events_url": "https://api.github.com/users/kbsriram/received_events", "type": "User", "site_admin": false}, "body": "One sequence is `hashset.add(stale_object)` -- it can succeed if `stale_object.hashCode()` happens to select an empty bucket, but cause a later `hashset.add(good_object)` to fail if `good_object.hashCode()` picks the same bucket and so triggers a `.equals()` comparison.\r\n\r\nPragmatically, raising exceptions on both hashCode() and equals() will generally fail quicker for stale objects within collections. But this is also an internal detail that can be changed if needed - happy to start the way you suggest and revisit if needed.\r\n\r\n(The new object comment was just about the difference between Long.valueOf() and primitive longs, separate from whether or not we use Graph.ref(). I think here and in the other hashcode implementation trading-off this micro-optimization in favor of core hashcode calculations works for me as well.)", "created_at": "2017-06-22T18:40:33Z", "updated_at": "2017-06-22T18:55:48Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/10849#discussion_r123591308", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/10849", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/123591308"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/10849#discussion_r123591308"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/10849"}}, "body_html": "<p>One sequence is <code>hashset.add(stale_object)</code> -- it can succeed if <code>stale_object.hashCode()</code> happens to select an empty bucket, but cause a later <code>hashset.add(good_object)</code> to fail if <code>good_object.hashCode()</code> picks the same bucket and so triggers a <code>.equals()</code> comparison.</p>\n<p>Pragmatically, raising exceptions on both hashCode() and equals() will generally fail quicker for stale objects within collections. But this is also an internal detail that can be changed if needed - happy to start the way you suggest and revisit if needed.</p>\n<p>(The new object comment was just about the difference between Long.valueOf() and primitive longs, separate from whether or not we use Graph.ref(). I think here and in the other hashcode implementation trading-off this micro-optimization in favor of core hashcode calculations works for me as well.)</p>", "body_text": "One sequence is hashset.add(stale_object) -- it can succeed if stale_object.hashCode() happens to select an empty bucket, but cause a later hashset.add(good_object) to fail if good_object.hashCode() picks the same bucket and so triggers a .equals() comparison.\nPragmatically, raising exceptions on both hashCode() and equals() will generally fail quicker for stale objects within collections. But this is also an internal detail that can be changed if needed - happy to start the way you suggest and revisit if needed.\n(The new object comment was just about the difference between Long.valueOf() and primitive longs, separate from whether or not we use Graph.ref(). I think here and in the other hashcode implementation trading-off this micro-optimization in favor of core hashcode calculations works for me as well.)", "in_reply_to_id": 123535105}