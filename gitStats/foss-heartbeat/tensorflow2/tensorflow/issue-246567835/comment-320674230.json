{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/320674230", "html_url": "https://github.com/tensorflow/tensorflow/pull/11878#issuecomment-320674230", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11878", "id": 320674230, "node_id": "MDEyOklzc3VlQ29tbWVudDMyMDY3NDIzMA==", "user": {"login": "shamanDevel", "id": 1770337, "node_id": "MDQ6VXNlcjE3NzAzMzc=", "avatar_url": "https://avatars0.githubusercontent.com/u/1770337?v=4", "gravatar_id": "", "url": "https://api.github.com/users/shamanDevel", "html_url": "https://github.com/shamanDevel", "followers_url": "https://api.github.com/users/shamanDevel/followers", "following_url": "https://api.github.com/users/shamanDevel/following{/other_user}", "gists_url": "https://api.github.com/users/shamanDevel/gists{/gist_id}", "starred_url": "https://api.github.com/users/shamanDevel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/shamanDevel/subscriptions", "organizations_url": "https://api.github.com/users/shamanDevel/orgs", "repos_url": "https://api.github.com/users/shamanDevel/repos", "events_url": "https://api.github.com/users/shamanDevel/events{/privacy}", "received_events_url": "https://api.github.com/users/shamanDevel/received_events", "type": "User", "site_admin": false}, "created_at": "2017-08-07T14:10:27Z", "updated_at": "2017-08-07T14:10:27Z", "author_association": "CONTRIBUTOR", "body_html": "<p>It took me a while to find a way how to deal with all the needed matrix transpositions when also supporting matrices of shape m&lt;n. The result included a lot of refactoring, but I think that it is now also clearer to understand.</p>\n<p>Note: don't merge yet!<br>\nNot all python tests pass.<br>\nFirst, the GPU version is numerically much less precise. Even after explicitly increasing the tolerance by a factor of 1000 when the GPU version is running, I sometimes get errors that 0.014% (or so) of the matrices don't match.<br>\nSecond: The GPU version fails if one dimension of the input matrix is one. Then the SVD returns zeros for U or V instead of 1. I have to investigate that more.</p>", "body_text": "It took me a while to find a way how to deal with all the needed matrix transpositions when also supporting matrices of shape m<n. The result included a lot of refactoring, but I think that it is now also clearer to understand.\nNote: don't merge yet!\nNot all python tests pass.\nFirst, the GPU version is numerically much less precise. Even after explicitly increasing the tolerance by a factor of 1000 when the GPU version is running, I sometimes get errors that 0.014% (or so) of the matrices don't match.\nSecond: The GPU version fails if one dimension of the input matrix is one. Then the SVD returns zeros for U or V instead of 1. I have to investigate that more.", "body": "It took me a while to find a way how to deal with all the needed matrix transpositions when also supporting matrices of shape m<n. The result included a lot of refactoring, but I think that it is now also clearer to understand.\r\n\r\nNote: don't merge yet!\r\nNot all python tests pass. \r\nFirst, the GPU version is numerically much less precise. Even after explicitly increasing the tolerance by a factor of 1000 when the GPU version is running, I sometimes get errors that 0.014% (or so) of the matrices don't match.\r\nSecond: The GPU version fails if one dimension of the input matrix is one. Then the SVD returns zeros for U or V instead of 1. I have to investigate that more."}