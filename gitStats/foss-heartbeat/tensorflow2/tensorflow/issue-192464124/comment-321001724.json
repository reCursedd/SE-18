{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/321001724", "html_url": "https://github.com/tensorflow/tensorflow/issues/5965#issuecomment-321001724", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5965", "id": 321001724, "node_id": "MDEyOklzc3VlQ29tbWVudDMyMTAwMTcyNA==", "user": {"login": "ekelsen", "id": 2533174, "node_id": "MDQ6VXNlcjI1MzMxNzQ=", "avatar_url": "https://avatars0.githubusercontent.com/u/2533174?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ekelsen", "html_url": "https://github.com/ekelsen", "followers_url": "https://api.github.com/users/ekelsen/followers", "following_url": "https://api.github.com/users/ekelsen/following{/other_user}", "gists_url": "https://api.github.com/users/ekelsen/gists{/gist_id}", "starred_url": "https://api.github.com/users/ekelsen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ekelsen/subscriptions", "organizations_url": "https://api.github.com/users/ekelsen/orgs", "repos_url": "https://api.github.com/users/ekelsen/repos", "events_url": "https://api.github.com/users/ekelsen/events{/privacy}", "received_events_url": "https://api.github.com/users/ekelsen/received_events", "type": "User", "site_admin": false}, "created_at": "2017-08-08T16:01:03Z", "updated_at": "2017-08-08T16:01:03Z", "author_association": "CONTRIBUTOR", "body_html": "<p>tf.where is done.</p>\n<p>tf.unique probably cannot be done - it is already registered as a GPU op, but the calculation happens on the CPU - moving this to the GPU would probably slow down some tiny use cases.  It would be best to create a new op in contrib - unique_gpu or something.</p>\n<p>tf.dynamic_partition is not implemented yet.  The easiest way to do it would be to use CUB's radix sort, then scan, then gather.  You could also try to implement the calculation of the output indices as one scan if the total number of partitions was not too large with a custom fancy iterator.</p>", "body_text": "tf.where is done.\ntf.unique probably cannot be done - it is already registered as a GPU op, but the calculation happens on the CPU - moving this to the GPU would probably slow down some tiny use cases.  It would be best to create a new op in contrib - unique_gpu or something.\ntf.dynamic_partition is not implemented yet.  The easiest way to do it would be to use CUB's radix sort, then scan, then gather.  You could also try to implement the calculation of the output indices as one scan if the total number of partitions was not too large with a custom fancy iterator.", "body": "tf.where is done.\r\n\r\ntf.unique probably cannot be done - it is already registered as a GPU op, but the calculation happens on the CPU - moving this to the GPU would probably slow down some tiny use cases.  It would be best to create a new op in contrib - unique_gpu or something.\r\n\r\ntf.dynamic_partition is not implemented yet.  The easiest way to do it would be to use CUB's radix sort, then scan, then gather.  You could also try to implement the calculation of the output indices as one scan if the total number of partitions was not too large with a custom fancy iterator."}