{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/344022007", "html_url": "https://github.com/tensorflow/tensorflow/issues/14518#issuecomment-344022007", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/14518", "id": 344022007, "node_id": "MDEyOklzc3VlQ29tbWVudDM0NDAyMjAwNw==", "user": {"login": "YoelShoshan", "id": 7043815, "node_id": "MDQ6VXNlcjcwNDM4MTU=", "avatar_url": "https://avatars1.githubusercontent.com/u/7043815?v=4", "gravatar_id": "", "url": "https://api.github.com/users/YoelShoshan", "html_url": "https://github.com/YoelShoshan", "followers_url": "https://api.github.com/users/YoelShoshan/followers", "following_url": "https://api.github.com/users/YoelShoshan/following{/other_user}", "gists_url": "https://api.github.com/users/YoelShoshan/gists{/gist_id}", "starred_url": "https://api.github.com/users/YoelShoshan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/YoelShoshan/subscriptions", "organizations_url": "https://api.github.com/users/YoelShoshan/orgs", "repos_url": "https://api.github.com/users/YoelShoshan/repos", "events_url": "https://api.github.com/users/YoelShoshan/events{/privacy}", "received_events_url": "https://api.github.com/users/YoelShoshan/received_events", "type": "User", "site_admin": false}, "created_at": "2017-11-13T19:01:07Z", "updated_at": "2017-11-13T19:11:52Z", "author_association": "NONE", "body_html": "<p>Thanks for the quick response!<br>\nI do not assume a dataset that fits entirely in memory, actually, my main usage scenario is datasets which are far from that.</p>\n<p>In the current syntax, to shuffle your elements, you can do something like:</p>\n<div class=\"highlight highlight-source-python\"><pre>ds <span class=\"pl-k\">=</span> TFRecordDataset([filename])\nds <span class=\"pl-k\">=</span> ds.Shuffle(<span class=\"pl-c1\">...</span>)</pre></div>\n<p>But that's not useful for unbalanced samples classes scenarios.</p>\n<p>My thought was adding something like this:</p>\n<div class=\"highlight highlight-source-python\"><pre>ds <span class=\"pl-k\">=</span> TFRecordDataset([filename])\nexamples_order <span class=\"pl-k\">=</span> [<span class=\"pl-c1\">0</span>,<span class=\"pl-c1\">1</span>,<span class=\"pl-c1\">2</span>,<span class=\"pl-c1\">4</span>,<span class=\"pl-c1\">5</span>,<span class=\"pl-c1\">0</span>,<span class=\"pl-c1\">3</span>,<span class=\"pl-c1\">2</span>,<span class=\"pl-c1\">0</span>,<span class=\"pl-c1\">3</span>,<span class=\"pl-c1\">4</span>,<span class=\"pl-c1\">2</span>,<span class=\"pl-c1\">0</span>,<span class=\"pl-c1\">...............</span>.] <span class=\"pl-c\"><span class=\"pl-c\">#</span>this was calculated by the user as the desired order (notice the repetition of examples)</span>\nds <span class=\"pl-k\">=</span> ds.SetExamplesOrder(examples_order)</pre></div>\n<p>An example of a common scenario where this is useful:<br>\nIn total in your dataset, you have 100m samples of class A, 10k of class B, 10k of class C and 10k of class D.<br>\nLet's say that while training, you want minibatches to be balanced.<br>\nSo let's say that your minibatch is of size 10, and you want 2 samples of each class.</p>\n<p>Using this syntax, you can manually use whatever logic you prefer, and all that needs to be passed is the indices list.</p>\n<p>Another option is to (also?) allow the user to provide custom shuffling python function. This function can be activated before every new epoch if requested.</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">def</span> <span class=\"pl-en\">my_foo</span>(<span class=\"pl-smi\">seed</span>):\n    <span class=\"pl-c1\">...</span> <span class=\"pl-c1\">any</span> user logic that returns a <span class=\"pl-c1\">list</span> of indices <span class=\"pl-c1\">...</span>\n    <span class=\"pl-k\">return</span> examples_order\n\nds <span class=\"pl-k\">=</span> TFRecordDataset([filename])\nds <span class=\"pl-k\">=</span> ds.CustomShuffling(my_foo)</pre></div>\n<p>Now, as I mentioned previously, you might say that this is achievable by creating few DataSet instances and zip-ing them together, however, I feel that it complicates things a bit too much, especially since it's comfortable to have all data in a single TFRecords file, and I don't see why not give the user the ability to provide whatever custom indices order he/she wants.</p>\n<p>I believe that this would make the API much more useful especially for people who are outside the \"natural images\" domain. For example - the medical domain which is in its nature highly unbalanced.</p>", "body_text": "Thanks for the quick response!\nI do not assume a dataset that fits entirely in memory, actually, my main usage scenario is datasets which are far from that.\nIn the current syntax, to shuffle your elements, you can do something like:\nds = TFRecordDataset([filename])\nds = ds.Shuffle(...)\nBut that's not useful for unbalanced samples classes scenarios.\nMy thought was adding something like this:\nds = TFRecordDataset([filename])\nexamples_order = [0,1,2,4,5,0,3,2,0,3,4,2,0,................] #this was calculated by the user as the desired order (notice the repetition of examples)\nds = ds.SetExamplesOrder(examples_order)\nAn example of a common scenario where this is useful:\nIn total in your dataset, you have 100m samples of class A, 10k of class B, 10k of class C and 10k of class D.\nLet's say that while training, you want minibatches to be balanced.\nSo let's say that your minibatch is of size 10, and you want 2 samples of each class.\nUsing this syntax, you can manually use whatever logic you prefer, and all that needs to be passed is the indices list.\nAnother option is to (also?) allow the user to provide custom shuffling python function. This function can be activated before every new epoch if requested.\ndef my_foo(seed):\n    ... any user logic that returns a list of indices ...\n    return examples_order\n\nds = TFRecordDataset([filename])\nds = ds.CustomShuffling(my_foo)\nNow, as I mentioned previously, you might say that this is achievable by creating few DataSet instances and zip-ing them together, however, I feel that it complicates things a bit too much, especially since it's comfortable to have all data in a single TFRecords file, and I don't see why not give the user the ability to provide whatever custom indices order he/she wants.\nI believe that this would make the API much more useful especially for people who are outside the \"natural images\" domain. For example - the medical domain which is in its nature highly unbalanced.", "body": "Thanks for the quick response!\r\nI do not assume a dataset that fits entirely in memory, actually, my main usage scenario is datasets which are far from that.\r\n\r\nIn the current syntax, to shuffle your elements, you can do something like:\r\n\r\n```python\r\nds = TFRecordDataset([filename])\r\nds = ds.Shuffle(...)\r\n```\r\nBut that's not useful for unbalanced samples classes scenarios.\r\n\r\n\r\nMy thought was adding something like this:\r\n```python\r\nds = TFRecordDataset([filename])\r\nexamples_order = [0,1,2,4,5,0,3,2,0,3,4,2,0,................] #this was calculated by the user as the desired order (notice the repetition of examples)\r\nds = ds.SetExamplesOrder(examples_order)\r\n```\r\nAn example of a common scenario where this is useful:\r\nIn total in your dataset, you have 100m samples of class A, 10k of class B, 10k of class C and 10k of class D. \r\nLet's say that while training, you want minibatches to be balanced.\r\nSo let's say that your minibatch is of size 10, and you want 2 samples of each class.\r\n\r\nUsing this syntax, you can manually use whatever logic you prefer, and all that needs to be passed is the indices list.\r\n\r\nAnother option is to (also?) allow the user to provide custom shuffling python function. This function can be activated before every new epoch if requested.\r\n```python\r\ndef my_foo(seed):\r\n    ... any user logic that returns a list of indices ...\r\n    return examples_order\r\n\r\nds = TFRecordDataset([filename])\r\nds = ds.CustomShuffling(my_foo)\r\n```\r\n\r\nNow, as I mentioned previously, you might say that this is achievable by creating few DataSet instances and zip-ing them together, however, I feel that it complicates things a bit too much, especially since it's comfortable to have all data in a single TFRecords file, and I don't see why not give the user the ability to provide whatever custom indices order he/she wants.\r\n\r\nI believe that this would make the API much more useful especially for people who are outside the \"natural images\" domain. For example - the medical domain which is in its nature highly unbalanced.\r\n\r\n\r\n\r\n\r\n\r\n"}