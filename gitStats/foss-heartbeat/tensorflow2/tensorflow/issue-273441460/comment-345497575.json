{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/345497575", "html_url": "https://github.com/tensorflow/tensorflow/issues/14518#issuecomment-345497575", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/14518", "id": 345497575, "node_id": "MDEyOklzc3VlQ29tbWVudDM0NTQ5NzU3NQ==", "user": {"login": "YoelShoshan", "id": 7043815, "node_id": "MDQ6VXNlcjcwNDM4MTU=", "avatar_url": "https://avatars1.githubusercontent.com/u/7043815?v=4", "gravatar_id": "", "url": "https://api.github.com/users/YoelShoshan", "html_url": "https://github.com/YoelShoshan", "followers_url": "https://api.github.com/users/YoelShoshan/followers", "following_url": "https://api.github.com/users/YoelShoshan/following{/other_user}", "gists_url": "https://api.github.com/users/YoelShoshan/gists{/gist_id}", "starred_url": "https://api.github.com/users/YoelShoshan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/YoelShoshan/subscriptions", "organizations_url": "https://api.github.com/users/YoelShoshan/orgs", "repos_url": "https://api.github.com/users/YoelShoshan/repos", "events_url": "https://api.github.com/users/YoelShoshan/events{/privacy}", "received_events_url": "https://api.github.com/users/YoelShoshan/received_events", "type": "User", "site_admin": false}, "created_at": "2017-11-19T07:24:59Z", "updated_at": "2017-11-19T11:41:39Z", "author_association": "NONE", "body_html": "<p>Thanks <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=2109115\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/jmaye\">@jmaye</a>  !<br>\nActually, in my case I can't really do that (without bloating the storage), because classes are a bit more complicated.<br>\nA class can be a combination of multiple traits - for the sake of example, a single class that I want to detect can be (shape=round AND color=red AND margin=clear)<br>\nOn different experiment I may use different combinations and class definitions.<br>\nThat's why I strongly prefer to work at the indices level, while having the data stored in a single place.</p>\n<p>For now I went with something a bit similar to your suggestion, I'm storing the data on a single directory, in raw format (all inputs and outputs are numpy tensors serialized and stored as raw files).<br>\nI create a single big filenames list, which already has the oversampling and in general the sampling proportions that I need.<br>\nI store one tf.constant() of the input list and one tf.constant() per output.<br>\nThen I use Dataset.from_tensor_slices() and use the dataset.map() api to shuffle them, actually read the raw tensors, augment etc.</p>\n<p>The down side of my approach is that:</p>\n<ol>\n<li>I don't guarantee minibatch exact balance, just that the overall samples sampled during 1 epoch are balanced (but could theoretically get extreme cases like one minibatch containing only one class)</li>\n<li>I didn't find a tensorflow operation to load compressed raw files (WITHOUT using tfrecords) so this is probably slower and takes more disk space than needed</li>\n</ol>\n<p>To solve <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"115886302\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/tensorflow/tensorflow/issues/1\" data-hovercard-type=\"issue\" data-hovercard-url=\"/tensorflow/tensorflow/issues/1/hovercard\" href=\"https://github.com/tensorflow/tensorflow/issues/1\">#1</a> I can probably switch to zip-ing datasets.<br>\nI don't know yet how to solve <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"115894138\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/tensorflow/tensorflow/issues/2\" data-hovercard-type=\"issue\" data-hovercard-url=\"/tensorflow/tensorflow/issues/2/hovercard\" href=\"https://github.com/tensorflow/tensorflow/issues/2\">#2</a> - I could probably write a tensorflow C++ operation for it but currently have too many things prioritized before that.</p>\n<p>Thanks again for the assistance! :)</p>", "body_text": "Thanks @jmaye  !\nActually, in my case I can't really do that (without bloating the storage), because classes are a bit more complicated.\nA class can be a combination of multiple traits - for the sake of example, a single class that I want to detect can be (shape=round AND color=red AND margin=clear)\nOn different experiment I may use different combinations and class definitions.\nThat's why I strongly prefer to work at the indices level, while having the data stored in a single place.\nFor now I went with something a bit similar to your suggestion, I'm storing the data on a single directory, in raw format (all inputs and outputs are numpy tensors serialized and stored as raw files).\nI create a single big filenames list, which already has the oversampling and in general the sampling proportions that I need.\nI store one tf.constant() of the input list and one tf.constant() per output.\nThen I use Dataset.from_tensor_slices() and use the dataset.map() api to shuffle them, actually read the raw tensors, augment etc.\nThe down side of my approach is that:\n\nI don't guarantee minibatch exact balance, just that the overall samples sampled during 1 epoch are balanced (but could theoretically get extreme cases like one minibatch containing only one class)\nI didn't find a tensorflow operation to load compressed raw files (WITHOUT using tfrecords) so this is probably slower and takes more disk space than needed\n\nTo solve #1 I can probably switch to zip-ing datasets.\nI don't know yet how to solve #2 - I could probably write a tensorflow C++ operation for it but currently have too many things prioritized before that.\nThanks again for the assistance! :)", "body": "Thanks @jmaye  !\r\nActually, in my case I can't really do that (without bloating the storage), because classes are a bit more complicated.\r\nA class can be a combination of multiple traits - for the sake of example, a single class that I want to detect can be (shape=round AND color=red AND margin=clear)\r\nOn different experiment I may use different combinations and class definitions.\r\nThat's why I strongly prefer to work at the indices level, while having the data stored in a single place.\r\n\r\nFor now I went with something a bit similar to your suggestion, I'm storing the data on a single directory, in raw format (all inputs and outputs are numpy tensors serialized and stored as raw files).\r\nI create a single big filenames list, which already has the oversampling and in general the sampling proportions that I need. \r\nI store one tf.constant() of the input list and one tf.constant() per output.\r\nThen I use Dataset.from_tensor_slices() and use the dataset.map() api to shuffle them, actually read the raw tensors, augment etc.\r\n\r\nThe down side of my approach is that:\r\n1. I don't guarantee minibatch exact balance, just that the overall samples sampled during 1 epoch are balanced (but could theoretically get extreme cases like one minibatch containing only one class)\r\n2. I didn't find a tensorflow operation to load compressed raw files (WITHOUT using tfrecords) so this is probably slower and takes more disk space than needed\r\n\r\nTo solve #1 I can probably switch to zip-ing datasets.\r\nI don't know yet how to solve #2 - I could probably write a tensorflow C++ operation for it but currently have too many things prioritized before that.\r\n\r\nThanks again for the assistance! :)\r\n\r\n\r\n"}