{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/224858129", "pull_request_review_id": 164327566, "id": 224858129, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNDg1ODEyOQ==", "diff_hunk": "@@ -0,0 +1,319 @@\n+/* Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"tensorflow/core/lib/io/path.h\"\n+#include \"tensorflow/core/platform/env.h\"\n+#include \"tensorflow/core/platform/file_system.h\"\n+#include \"tensorflow/core/platform/file_system_helper.h\"\n+\n+#include \"tensorflow/contrib/igfs/kernels/igfs.h\"\n+#include \"tensorflow/contrib/igfs/kernels/igfs_client.h\"\n+#include \"tensorflow/contrib/igfs/kernels/igfs_random_access_file.h\"\n+#include \"tensorflow/contrib/igfs/kernels/igfs_writable_file.h\"\n+\n+namespace tensorflow {\n+\n+string GetEnvOrElse(const string &env, string default_value) {\n+  const char *env_c_str = env.c_str();\n+  return getenv(env_c_str) != nullptr ? getenv(env_c_str) : default_value;\n+}\n+\n+string IGFS::TranslateName(const string &name) const {\n+  StringPiece scheme, namenode, path;\n+  io::ParseURI(name, &scheme, &namenode, &path);\n+  return string(path.data(), path.length());\n+}\n+\n+string MakeRelative(const string &a, const string &b) {\n+  string max = a;\n+  string min = b;\n+  bool first = b.size() > a.size();\n+\n+  if (first) {\n+    max = b;\n+    min = a;\n+  }\n+\n+  auto r = mismatch(min.begin(), min.end(), max.begin());\n+  return string((first ? r.first : r.second), first ? min.end() : max.end());\n+}\n+\n+IGFS::IGFS()\n+    : host_(GetEnvOrElse(\"IGFS_HOST\", \"localhost\")),\n+      port_(atoi(GetEnvOrElse(\"IGFS_PORT\", \"10500\").c_str())),\n+      fs_name_(GetEnvOrElse(\"IGFS_FS_NAME\", \"default_fs\")) {\n+  LOG(INFO) << \"IGFS created [host=\" << host_ << \", port=\" << port_\n+            << \", fs_name=\" << fs_name_ << \"]\";\n+};\n+\n+IGFS::~IGFS() {\n+  LOG(INFO) << \"IGFS destroyed [host=\" << host_ << \", port=\" << port_\n+            << \", fs_name=\" << fs_name_ << \"]\";\n+};\n+\n+Status IGFS::NewRandomAccessFile(const string &file_name,\n+                                 std::unique_ptr<RandomAccessFile> *result) {\n+  std::shared_ptr<IGFSClient> client = CreateClient();\n+  string path = TranslateName(file_name);\n+\n+  CtrlResponse<HandshakeResponse> handshake_response(true);\n+  TF_RETURN_IF_ERROR(client->Handshake(&handshake_response));\n+\n+  CtrlResponse<OpenReadResponse> open_read_response(true);\n+  TF_RETURN_IF_ERROR(client->OpenRead(&open_read_response, path));\n+\n+  long resource_id = open_read_response.res.stream_id;\n+  result->reset(new IGFSRandomAccessFile(path, resource_id, client));\n+\n+  LOG(INFO) << \"New random access file completed successfully [file_name=\"\n+            << file_name << \"]\";\n+\n+  return Status::OK();\n+}\n+\n+Status IGFS::NewWritableFile(const string &file_name,\n+                             std::unique_ptr<WritableFile> *result) {\n+  std::shared_ptr<IGFSClient> client = CreateClient();\n+  string path = TranslateName(file_name);\n+\n+  CtrlResponse<HandshakeResponse> handshake_response(true);\n+  TF_RETURN_IF_ERROR(client->Handshake(&handshake_response));\n+\n+  CtrlResponse<ExistsResponse> exists_response(false);\n+  TF_RETURN_IF_ERROR(client->Exists(&exists_response, path));\n+\n+  if (exists_response.res.exists) {\n+    CtrlResponse<DeleteResponse> del_response(false);\n+    TF_RETURN_IF_ERROR(client->Delete(&del_response, path, false));\n+  }\n+\n+  CtrlResponse<OpenCreateResponse> open_create_resp(false);\n+  TF_RETURN_IF_ERROR(client->OpenCreate(&open_create_resp, path));\n+\n+  long resource_id = open_create_resp.res.stream_id;\n+  result->reset(new IGFSWritableFile(path, resource_id, client));\n+\n+  LOG(INFO) << \"New writable file completed successfully [file_name=\"\n+            << file_name << \"]\";\n+\n+  return Status::OK();\n+}\n+\n+Status IGFS::NewAppendableFile(const string &file_name,\n+                               std::unique_ptr<WritableFile> *result) {\n+  std::shared_ptr<IGFSClient> client = CreateClient();\n+\n+  CtrlResponse<HandshakeResponse> handshake_response(true);\n+  TF_RETURN_IF_ERROR(client->Handshake(&handshake_response));\n+\n+  CtrlResponse<ExistsResponse> exists_response(false);\n+  TF_RETURN_IF_ERROR(client->Exists(&exists_response, file_name));\n+\n+  if (exists_response.res.exists) {\n+    CtrlResponse<DeleteResponse> del_response(false);\n+    TF_RETURN_IF_ERROR(client->Delete(&del_response, file_name, false));\n+  }\n+\n+  CtrlResponse<OpenAppendResponse> open_append_resp(false);\n+  TF_RETURN_IF_ERROR(client->OpenAppend(&open_append_resp, file_name));\n+\n+  result->reset(new IGFSWritableFile(TranslateName(file_name),\n+                                     open_append_resp.res.stream_id, client));\n+\n+  LOG(INFO) << \"New appendable file completed successfully [file_name=\"\n+            << file_name << \"]\";\n+\n+  return Status::OK();\n+}\n+\n+Status IGFS::NewReadOnlyMemoryRegionFromFile(\n+    const string &file_name, std::unique_ptr<ReadOnlyMemoryRegion> *result) {\n+  return errors::Unimplemented(\"IGFS does not support ReadOnlyMemoryRegion\");\n+}\n+\n+Status IGFS::FileExists(const string &file_name) {\n+  std::shared_ptr<IGFSClient> client = CreateClient();\n+  const string path = TranslateName(file_name);\n+\n+  CtrlResponse<HandshakeResponse> handshake_response(true);\n+  TF_RETURN_IF_ERROR(client->Handshake(&handshake_response));\n+\n+  CtrlResponse<ExistsResponse> exists_response(false);\n+  TF_RETURN_IF_ERROR(client->Exists(&exists_response, path));\n+\n+  if (!exists_response.res.exists)\n+    return errors::NotFound(\"File \", path, \" not found\");\n+\n+  LOG(INFO) << \"File exists completed successfully [file_name=\" << file_name\n+            << \"]\";\n+\n+  return Status::OK();\n+}\n+\n+Status IGFS::GetChildren(const string &file_name, std::vector<string> *result) {\n+  std::shared_ptr<IGFSClient> client = CreateClient();\n+  string path = TranslateName(file_name);\n+  path = path + \"/\";\n+\n+  CtrlResponse<HandshakeResponse> handshake_response(true);\n+  TF_RETURN_IF_ERROR(client->Handshake(&handshake_response));\n+\n+  CtrlResponse<ListPathsResponse> list_paths_response(false);\n+  TF_RETURN_IF_ERROR(client->ListPaths(&list_paths_response, path));\n+\n+  *result = std::vector<string>();\n+  std::vector<IGFSPath> entries = list_paths_response.res.entries;\n+\n+  for (IGFSPath &value : entries)\n+    result->push_back(MakeRelative(value.path, path));\n+\n+  LOG(INFO) << \"Get children completed successfully [file_name=\" << file_name\n+            << \"]\";\n+\n+  return Status::OK();\n+}\n+\n+Status IGFS::GetMatchingPaths(const string &pattern,\n+                              std::vector<string> *results) {\n+  return internal::GetMatchingPaths(this, Env::Default(), pattern, results);\n+}\n+\n+Status IGFS::DeleteFile(const string &file_name) {\n+  std::shared_ptr<IGFSClient> client = CreateClient();\n+  string path = TranslateName(file_name);\n+\n+  CtrlResponse<HandshakeResponse> handshake_response(true);\n+  TF_RETURN_IF_ERROR(client->Handshake(&handshake_response));\n+\n+  CtrlResponse<DeleteResponse> del_response(false);\n+  TF_RETURN_IF_ERROR(client->Delete(&del_response, path, false));\n+\n+  if (!del_response.res.exists)\n+    return errors::NotFound(\"File \", path, \" not found\");\n+\n+  LOG(INFO) << \"Delete file completed successfully [file_name=\" << file_name\n+            << \"]\";\n+\n+  return Status::OK();\n+}\n+\n+Status IGFS::CreateDir(const string &file_name) {\n+  std::shared_ptr<IGFSClient> client = CreateClient();\n+  const string path = TranslateName(file_name);\n+\n+  CtrlResponse<HandshakeResponse> handshake_response(true);\n+  TF_RETURN_IF_ERROR(client->Handshake(&handshake_response));\n+\n+  CtrlResponse<MakeDirectoriesResponse> mkdir_response(false);\n+  TF_RETURN_IF_ERROR(client->MkDir(&mkdir_response, path));\n+\n+  if (!mkdir_response.res.successful)\n+    return errors::Unknown(\"Can't create directory \", path);\n+\n+  LOG(INFO) << \"Create dir completed successful [file_name=\" << file_name\n+            << \"]\";\n+\n+  return Status::OK();\n+}\n+\n+Status IGFS::DeleteDir(const string &file_name) {\n+  std::shared_ptr<IGFSClient> client = CreateClient();\n+  string path = TranslateName(file_name);\n+\n+  CtrlResponse<HandshakeResponse> handshake_response(true);\n+  TF_RETURN_IF_ERROR(client->Handshake(&handshake_response));\n+\n+  CtrlResponse<ListFilesResponse> list_files_response(false);\n+  TF_RETURN_IF_ERROR(client->ListFiles(&list_files_response, path));\n+\n+  if (!list_files_response.res.entries.empty()) {\n+    return errors::FailedPrecondition(\"Can't delete a non-empty directory\");\n+  } else {\n+    CtrlResponse<DeleteResponse> del_response(false);\n+    TF_RETURN_IF_ERROR(client->Delete(&del_response, path, true));\n+  }\n+\n+  LOG(INFO) << \"Delete dir completed successful [file_name=\" << file_name\n+            << \"]\";\n+\n+  return Status::OK();\n+}\n+\n+Status IGFS::GetFileSize(const string &file_name, uint64 *size) {\n+  std::shared_ptr<IGFSClient> client = CreateClient();\n+  string path = TranslateName(file_name);\n+\n+  CtrlResponse<HandshakeResponse> handshake_response(true);\n+  TF_RETURN_IF_ERROR(client->Handshake(&handshake_response));\n+\n+  CtrlResponse<InfoResponse> info_response(false);\n+  TF_RETURN_IF_ERROR(client->Info(&info_response, path));\n+\n+  *size = info_response.res.file_info.length;\n+\n+  LOG(INFO) << \"Get file size completed successful [file_name=\" << file_name\n+            << \"]\";\n+\n+  return Status::OK();\n+}\n+\n+Status IGFS::RenameFile(const string &src, const string &dst) {\n+  std::shared_ptr<IGFSClient> client = CreateClient();\n+  string src_path = TranslateName(src);\n+  string dst_path = TranslateName(dst);\n+\n+  if (FileExists(dst).ok()) DeleteFile(dst);\n+\n+  CtrlResponse<HandshakeResponse> handshake_response(true);\n+  TF_RETURN_IF_ERROR(client->Handshake(&handshake_response));\n+\n+  CtrlResponse<RenameResponse> rename_response(false);\n+  TF_RETURN_IF_ERROR(client->Rename(&rename_response, src_path, dst_path));\n+\n+  if (!rename_response.res.successful)\n+    return errors::NotFound(\"File \", src_path, \" not found\");\n+\n+  LOG(INFO) << \"Rename file completed successful [src=\" << src\n+            << \", dst=\" << dst << \"]\";\n+\n+  return Status::OK();\n+}\n+\n+Status IGFS::Stat(const string &file_name, FileStatistics *stats) {\n+  std::shared_ptr<IGFSClient> client = CreateClient();\n+  string path = TranslateName(file_name);\n+\n+  CtrlResponse<HandshakeResponse> handshake_response(true);\n+  TF_RETURN_IF_ERROR(client->Handshake(&handshake_response));\n+\n+  CtrlResponse<InfoResponse> info_response(false);\n+  TF_RETURN_IF_ERROR(client->Info(&info_response, path));\n+\n+  IGFSFile info = info_response.res.file_info;\n+\n+  *stats = FileStatistics(info.length, info.modification_time * 1000000,\n+                          (info.flags & 0x1) != 0);\n+\n+  LOG(INFO) << \"Stat completed successful [file_name=\" << file_name << \"]\";\n+\n+  return Status::OK();\n+}\n+\n+std::shared_ptr<IGFSClient> IGFS::CreateClient() const {", "path": "tensorflow/contrib/igfs/kernels/igfs.cc", "position": null, "original_position": 314, "commit_id": "24579bc55c379ea1d43b3d3b9d319038aa12f091", "original_commit_id": "273abe3bd46ce505b610b0bcf88d9c6afc472fce", "user": {"login": "mrry", "id": 192142, "node_id": "MDQ6VXNlcjE5MjE0Mg==", "avatar_url": "https://avatars1.githubusercontent.com/u/192142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mrry", "html_url": "https://github.com/mrry", "followers_url": "https://api.github.com/users/mrry/followers", "following_url": "https://api.github.com/users/mrry/following{/other_user}", "gists_url": "https://api.github.com/users/mrry/gists{/gist_id}", "starred_url": "https://api.github.com/users/mrry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mrry/subscriptions", "organizations_url": "https://api.github.com/users/mrry/orgs", "repos_url": "https://api.github.com/users/mrry/repos", "events_url": "https://api.github.com/users/mrry/events{/privacy}", "received_events_url": "https://api.github.com/users/mrry/received_events", "type": "User", "site_admin": false}, "body": "Is the \"shared\"-ness ever used here? It looks like this could return a `unique_ptr`.", "created_at": "2018-10-12T17:18:15Z", "updated_at": "2018-11-07T11:35:25Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/22194#discussion_r224858129", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/22194", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/224858129"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/22194#discussion_r224858129"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/22194"}}, "body_html": "<p>Is the \"shared\"-ness ever used here? It looks like this could return a <code>unique_ptr</code>.</p>", "body_text": "Is the \"shared\"-ness ever used here? It looks like this could return a unique_ptr."}