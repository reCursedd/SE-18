{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/368480460", "html_url": "https://github.com/tensorflow/tensorflow/issues/6035#issuecomment-368480460", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/6035", "id": 368480460, "node_id": "MDEyOklzc3VlQ29tbWVudDM2ODQ4MDQ2MA==", "user": {"login": "mmpinso", "id": 1001128, "node_id": "MDQ6VXNlcjEwMDExMjg=", "avatar_url": "https://avatars3.githubusercontent.com/u/1001128?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mmpinso", "html_url": "https://github.com/mmpinso", "followers_url": "https://api.github.com/users/mmpinso/followers", "following_url": "https://api.github.com/users/mmpinso/following{/other_user}", "gists_url": "https://api.github.com/users/mmpinso/gists{/gist_id}", "starred_url": "https://api.github.com/users/mmpinso/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mmpinso/subscriptions", "organizations_url": "https://api.github.com/users/mmpinso/orgs", "repos_url": "https://api.github.com/users/mmpinso/repos", "events_url": "https://api.github.com/users/mmpinso/events{/privacy}", "received_events_url": "https://api.github.com/users/mmpinso/received_events", "type": "User", "site_admin": false}, "created_at": "2018-02-26T12:09:36Z", "updated_at": "2018-02-26T12:12:00Z", "author_association": "NONE", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=33678100\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/DenisN03\">@DenisN03</a> yes, we did it with TF itself. FYI, in our project we do binary segmentation, so we replaced the softmax by sigmoid. Then:</p>\n<p>`<br>\npredictions = tf.cast(tf.round(probabilities), tf.int32, name='output')</p>\n<pre><code>        #=============PAINTED OUTPUT=============\n        #Compute an inverse of the output mask\n        predictions_inverse = tf.cast(tf.subtract(tf.ones([inputs_shape[1], inputs_shape[2], inputs_shape[3]], tf.int32), predictions), tf.float32)\n\n        #Remove the original object to detect from the images by applying the mask\n        holes = tf.multiply(images, predictions_inverse) * 255\n\n        #Transform the output mask into a color mask with 3 channels, according to the rgb input value.\n        color_mask = tf.concat([predictions * color[0], predictions * color[1], predictions * color[2]], axis=3)\n\n        #Fill the holes with the color mask\n        painted_output = tf.add(color_mask, holes, name='painted_output')`\n</code></pre>\n<p>FYI, the entire system came out to be too slow to run on CPU in real time. We are exploring other nets now...</p>", "body_text": "@DenisN03 yes, we did it with TF itself. FYI, in our project we do binary segmentation, so we replaced the softmax by sigmoid. Then:\n`\npredictions = tf.cast(tf.round(probabilities), tf.int32, name='output')\n        #=============PAINTED OUTPUT=============\n        #Compute an inverse of the output mask\n        predictions_inverse = tf.cast(tf.subtract(tf.ones([inputs_shape[1], inputs_shape[2], inputs_shape[3]], tf.int32), predictions), tf.float32)\n\n        #Remove the original object to detect from the images by applying the mask\n        holes = tf.multiply(images, predictions_inverse) * 255\n\n        #Transform the output mask into a color mask with 3 channels, according to the rgb input value.\n        color_mask = tf.concat([predictions * color[0], predictions * color[1], predictions * color[2]], axis=3)\n\n        #Fill the holes with the color mask\n        painted_output = tf.add(color_mask, holes, name='painted_output')`\n\nFYI, the entire system came out to be too slow to run on CPU in real time. We are exploring other nets now...", "body": "@DenisN03 yes, we did it with TF itself. FYI, in our project we do binary segmentation, so we replaced the softmax by sigmoid. Then:\r\n\r\n`\r\n            predictions = tf.cast(tf.round(probabilities), tf.int32, name='output')\r\n\r\n\r\n            #=============PAINTED OUTPUT=============\r\n            #Compute an inverse of the output mask\r\n            predictions_inverse = tf.cast(tf.subtract(tf.ones([inputs_shape[1], inputs_shape[2], inputs_shape[3]], tf.int32), predictions), tf.float32)\r\n\r\n            #Remove the original object to detect from the images by applying the mask\r\n            holes = tf.multiply(images, predictions_inverse) * 255\r\n\r\n            #Transform the output mask into a color mask with 3 channels, according to the rgb input value.\r\n            color_mask = tf.concat([predictions * color[0], predictions * color[1], predictions * color[2]], axis=3)\r\n\r\n            #Fill the holes with the color mask\r\n            painted_output = tf.add(color_mask, holes, name='painted_output')`\r\n\r\nFYI, the entire system came out to be too slow to run on CPU in real time. We are exploring other nets now..."}