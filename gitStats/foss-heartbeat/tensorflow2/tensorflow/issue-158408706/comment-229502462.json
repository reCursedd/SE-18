{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/229502462", "html_url": "https://github.com/tensorflow/tensorflow/issues/2641#issuecomment-229502462", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2641", "id": 229502462, "node_id": "MDEyOklzc3VlQ29tbWVudDIyOTUwMjQ2Mg==", "user": {"login": "ibab", "id": 890531, "node_id": "MDQ6VXNlcjg5MDUzMQ==", "avatar_url": "https://avatars1.githubusercontent.com/u/890531?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibab", "html_url": "https://github.com/ibab", "followers_url": "https://api.github.com/users/ibab/followers", "following_url": "https://api.github.com/users/ibab/following{/other_user}", "gists_url": "https://api.github.com/users/ibab/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibab/subscriptions", "organizations_url": "https://api.github.com/users/ibab/orgs", "repos_url": "https://api.github.com/users/ibab/repos", "events_url": "https://api.github.com/users/ibab/events{/privacy}", "received_events_url": "https://api.github.com/users/ibab/received_events", "type": "User", "site_admin": false}, "created_at": "2016-06-29T22:00:53Z", "updated_at": "2016-06-29T22:04:36Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=6969686\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/benoitsteiner\">@benoitsteiner</a>: That's a good idea!<br>\nI just realized that I could make use of <code>tensor.shuffle</code> from Eigen to do the same operations as described above (permute the axes so that the scan axes are in the front, and then reshape).<br>\nThis would also avoid copying the tensor, as shuffle is implemented through <code>.coeff</code>.<br>\n<a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=70511\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/girving\">@girving</a>: My first impression was also that it would be awkward, but now I'm thinking that it could make sense: The list of indices identifies the sequence in which <code>cumsum</code> should traverse each sub-tensor. It also plays well with the existing <code>exclusive</code> and <code>reverse</code> options.</p>\n<p>I'm open to using either solution (making the gradient more complicated, or making cumsum/prod more complicated)</p>", "body_text": "@benoitsteiner: That's a good idea!\nI just realized that I could make use of tensor.shuffle from Eigen to do the same operations as described above (permute the axes so that the scan axes are in the front, and then reshape).\nThis would also avoid copying the tensor, as shuffle is implemented through .coeff.\n@girving: My first impression was also that it would be awkward, but now I'm thinking that it could make sense: The list of indices identifies the sequence in which cumsum should traverse each sub-tensor. It also plays well with the existing exclusive and reverse options.\nI'm open to using either solution (making the gradient more complicated, or making cumsum/prod more complicated)", "body": "@benoitsteiner: That's a good idea!\nI just realized that I could make use of `tensor.shuffle` from Eigen to do the same operations as described above (permute the axes so that the scan axes are in the front, and then reshape).\nThis would also avoid copying the tensor, as shuffle is implemented through `.coeff`.\n@girving: My first impression was also that it would be awkward, but now I'm thinking that it could make sense: The list of indices identifies the sequence in which `cumsum` should traverse each sub-tensor. It also plays well with the existing `exclusive` and `reverse` options.\n\nI'm open to using either solution (making the gradient more complicated, or making cumsum/prod more complicated)\n"}