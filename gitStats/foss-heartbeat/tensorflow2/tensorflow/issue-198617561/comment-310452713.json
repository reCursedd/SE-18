{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/310452713", "html_url": "https://github.com/tensorflow/tensorflow/issues/6624#issuecomment-310452713", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/6624", "id": 310452713, "node_id": "MDEyOklzc3VlQ29tbWVudDMxMDQ1MjcxMw==", "user": {"login": "elibixby", "id": 6596957, "node_id": "MDQ6VXNlcjY1OTY5NTc=", "avatar_url": "https://avatars0.githubusercontent.com/u/6596957?v=4", "gravatar_id": "", "url": "https://api.github.com/users/elibixby", "html_url": "https://github.com/elibixby", "followers_url": "https://api.github.com/users/elibixby/followers", "following_url": "https://api.github.com/users/elibixby/following{/other_user}", "gists_url": "https://api.github.com/users/elibixby/gists{/gist_id}", "starred_url": "https://api.github.com/users/elibixby/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/elibixby/subscriptions", "organizations_url": "https://api.github.com/users/elibixby/orgs", "repos_url": "https://api.github.com/users/elibixby/repos", "events_url": "https://api.github.com/users/elibixby/events{/privacy}", "received_events_url": "https://api.github.com/users/elibixby/received_events", "type": "User", "site_admin": false}, "created_at": "2017-06-22T17:46:30Z", "updated_at": "2017-06-22T17:47:20Z", "author_association": "NONE", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=70511\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/girving\">@girving</a> Yep! Good catch! This use case is now possible, if you remember to start queue runners, <em>however</em>, it still hangs indefinitely if you do not start queue runners. It should be possible for evaluation of graph nodes to determine if there are upstream queue nodes, and queues have not been started, which would help immensely in debugging this common error (whether it's worth the effort given <code>tf.contrib.data</code> is coming, is another question).</p>\n<p>To be clear with the following graph:</p>\n<pre><code>import tensorflow as tf\n\ngraph = tf.Graph()\nwith graph.as_default():\n   queue = tf.train.string_input_producer(['foo', 'bar', 'baz'])\n   var = tf.Variable(queue.dequeue_many(3))\n</code></pre>\n<p>The following code works:</p>\n<pre><code>with tf.Session(graph=graph) as sess:\n   tf.train.start_queue_runners(sess=sess)\n   tf.global_variables_initializer().run()\n   print(sess.run(var))\n</code></pre>\n<p>But the easy mistake of reversing two lines:</p>\n<pre><code>with tf.Session(graph=graph) as sess:\n   tf.global_variables_initializer().run()\n   tf.train.start_queue_runners(sess=sess)\n   print(sess.run(var))\n</code></pre>\n<p>Results in a program that hangs indefinitely</p>\n<p>EDIT: This is in TF 1.2</p>", "body_text": "@girving Yep! Good catch! This use case is now possible, if you remember to start queue runners, however, it still hangs indefinitely if you do not start queue runners. It should be possible for evaluation of graph nodes to determine if there are upstream queue nodes, and queues have not been started, which would help immensely in debugging this common error (whether it's worth the effort given tf.contrib.data is coming, is another question).\nTo be clear with the following graph:\nimport tensorflow as tf\n\ngraph = tf.Graph()\nwith graph.as_default():\n   queue = tf.train.string_input_producer(['foo', 'bar', 'baz'])\n   var = tf.Variable(queue.dequeue_many(3))\n\nThe following code works:\nwith tf.Session(graph=graph) as sess:\n   tf.train.start_queue_runners(sess=sess)\n   tf.global_variables_initializer().run()\n   print(sess.run(var))\n\nBut the easy mistake of reversing two lines:\nwith tf.Session(graph=graph) as sess:\n   tf.global_variables_initializer().run()\n   tf.train.start_queue_runners(sess=sess)\n   print(sess.run(var))\n\nResults in a program that hangs indefinitely\nEDIT: This is in TF 1.2", "body": "@girving Yep! Good catch! This use case is now possible, if you remember to start queue runners, *however*, it still hangs indefinitely if you do not start queue runners. It should be possible for evaluation of graph nodes to determine if there are upstream queue nodes, and queues have not been started, which would help immensely in debugging this common error (whether it's worth the effort given `tf.contrib.data` is coming, is another question).\r\n\r\nTo be clear with the following graph:\r\n\r\n```\r\nimport tensorflow as tf\r\n\r\ngraph = tf.Graph()\r\nwith graph.as_default():\r\n   queue = tf.train.string_input_producer(['foo', 'bar', 'baz'])\r\n   var = tf.Variable(queue.dequeue_many(3))\r\n```\r\n\r\nThe following code works:\r\n\r\n```\r\nwith tf.Session(graph=graph) as sess:\r\n   tf.train.start_queue_runners(sess=sess)\r\n   tf.global_variables_initializer().run()\r\n   print(sess.run(var))\r\n```\r\n\r\nBut the easy mistake of reversing two lines:\r\n\r\n```\r\nwith tf.Session(graph=graph) as sess:\r\n   tf.global_variables_initializer().run()\r\n   tf.train.start_queue_runners(sess=sess)\r\n   print(sess.run(var))\r\n```\r\n\r\nResults in a program that hangs indefinitely\r\n\r\nEDIT: This is in TF 1.2\r\n"}