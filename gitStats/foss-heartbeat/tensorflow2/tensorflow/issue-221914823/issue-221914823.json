{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9230", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9230/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9230/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9230/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/9230", "id": 221914823, "node_id": "MDU6SXNzdWUyMjE5MTQ4MjM=", "number": 9230, "title": "random ops across iterations of while loops execute in nondeterministic order", "user": {"login": "jwise", "id": 87427, "node_id": "MDQ6VXNlcjg3NDI3", "avatar_url": "https://avatars3.githubusercontent.com/u/87427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwise", "html_url": "https://github.com/jwise", "followers_url": "https://api.github.com/users/jwise/followers", "following_url": "https://api.github.com/users/jwise/following{/other_user}", "gists_url": "https://api.github.com/users/jwise/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwise/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwise/subscriptions", "organizations_url": "https://api.github.com/users/jwise/orgs", "repos_url": "https://api.github.com/users/jwise/repos", "events_url": "https://api.github.com/users/jwise/events{/privacy}", "received_events_url": "https://api.github.com/users/jwise/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 404586594, "node_id": "MDU6TGFiZWw0MDQ1ODY1OTQ=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:awaiting%20tensorflower", "name": "stat:awaiting tensorflower", "color": "f4b400", "default": false}], "state": "closed", "locked": false, "assignee": {"login": "josh11b", "id": 15258583, "node_id": "MDQ6VXNlcjE1MjU4NTgz", "avatar_url": "https://avatars0.githubusercontent.com/u/15258583?v=4", "gravatar_id": "", "url": "https://api.github.com/users/josh11b", "html_url": "https://github.com/josh11b", "followers_url": "https://api.github.com/users/josh11b/followers", "following_url": "https://api.github.com/users/josh11b/following{/other_user}", "gists_url": "https://api.github.com/users/josh11b/gists{/gist_id}", "starred_url": "https://api.github.com/users/josh11b/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/josh11b/subscriptions", "organizations_url": "https://api.github.com/users/josh11b/orgs", "repos_url": "https://api.github.com/users/josh11b/repos", "events_url": "https://api.github.com/users/josh11b/events{/privacy}", "received_events_url": "https://api.github.com/users/josh11b/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "josh11b", "id": 15258583, "node_id": "MDQ6VXNlcjE1MjU4NTgz", "avatar_url": "https://avatars0.githubusercontent.com/u/15258583?v=4", "gravatar_id": "", "url": "https://api.github.com/users/josh11b", "html_url": "https://github.com/josh11b", "followers_url": "https://api.github.com/users/josh11b/followers", "following_url": "https://api.github.com/users/josh11b/following{/other_user}", "gists_url": "https://api.github.com/users/josh11b/gists{/gist_id}", "starred_url": "https://api.github.com/users/josh11b/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/josh11b/subscriptions", "organizations_url": "https://api.github.com/users/josh11b/orgs", "repos_url": "https://api.github.com/users/josh11b/repos", "events_url": "https://api.github.com/users/josh11b/events{/privacy}", "received_events_url": "https://api.github.com/users/josh11b/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 18, "created_at": "2017-04-15T00:27:38Z", "updated_at": "2017-12-24T04:53:15Z", "closed_at": "2017-12-22T21:26:58Z", "author_association": "NONE", "body_html": "<h3>System information</h3>\n<ul>\n<li><strong>Have I written custom code (as opposed to using a stock example script provided in TensorFlow)</strong>: yes.  See below.</li>\n<li><strong>OS Platform and Distribution (e.g., Linux Ubuntu 16.04)</strong>:</li>\n<li><strong>TensorFlow installed from (source or binary)</strong>: source</li>\n<li><strong>TensorFlow version (use command below)</strong>: <code>('0.12.1-2106-gf7d07f5-dirty', '0.12.head')</code></li>\n<li><strong>Bazel version (if compiling from source)</strong>: (not a build issue)</li>\n<li><strong>CUDA/cuDNN version</strong>: CuDNN5, CUDA8 (though this runs on CPU)</li>\n<li><strong>GPU model and memory</strong>: 1x Titan X Pascal, 1x Titan X (though this runs on CPU)</li>\n<li><strong>Exact command to reproduce</strong>: <code>../virtualenv/bin/python nnrandom.py --broken; ../virtualenv/bin/python nnrandom.py --broken</code></li>\n</ul>\n<h3>Describe the problem, source code, and logs</h3>\n<p>When using augmentation primitives, sometimes, they create run-to-run non-determinism by ignoring the system random seed.  This makes reproducing a run impossible, even when using <code>tf.set_random_seed</code>.  One case in which they seem to do this is inside a <code>tf.device()</code> block.  Consider the following snippet:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">import</span> tensorflow <span class=\"pl-k\">as</span> tf\n<span class=\"pl-k\">import</span> numpy <span class=\"pl-k\">as</span> np\n\ntf.app.flags.DEFINE_integer(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>seed<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-c1\">1</span>, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>RNG seed<span class=\"pl-pds\">\"</span></span>)\n<span class=\"pl-c1\">FLAGS</span> <span class=\"pl-k\">=</span> tf.app.flags.<span class=\"pl-c1\">FLAGS</span>\n\ntf.app.flags.DEFINE_float(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>augment_hue<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-c1\">0.5</span>, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>hue augment factor<span class=\"pl-pds\">\"</span></span>)\ntf.app.flags.DEFINE_boolean(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>no_augment<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-c1\">False</span>, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>whether to disable augmentation entirely<span class=\"pl-pds\">\"</span></span>)\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">mk_input</span>():\n  np.random.seed(<span class=\"pl-c1\">0</span>)\n  a1s <span class=\"pl-k\">=</span> np.random.uniform(<span class=\"pl-v\">size</span> <span class=\"pl-k\">=</span> [<span class=\"pl-c1\">32</span>, <span class=\"pl-c1\">128</span>, <span class=\"pl-c1\">128</span>, <span class=\"pl-c1\">3</span>]).astype(np.float32)\n\n  <span class=\"pl-k\">if</span> <span class=\"pl-k\">not</span> <span class=\"pl-c1\">FLAGS</span>.no_augment:\n    <span class=\"pl-k\">def</span> <span class=\"pl-en\">aug</span>(<span class=\"pl-smi\">img</span>):\n      img <span class=\"pl-k\">=</span> tf.image.random_hue(img, <span class=\"pl-c1\">FLAGS</span>.augment_hue, <span class=\"pl-v\">seed</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">50001</span>)\n\n      <span class=\"pl-k\">return</span> img\n    a1s <span class=\"pl-k\">=</span> tf.map_fn(aug, a1s)\n\n  <span class=\"pl-k\">return</span> a1s\n\ntf.app.flags.DEFINE_boolean(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>broken<span class=\"pl-pds\">'</span></span>, <span class=\"pl-c1\">False</span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span><span class=\"pl-pds\">'</span></span>)\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">main</span>(<span class=\"pl-smi\">argv</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">None</span>):\n  <span class=\"pl-k\">if</span> <span class=\"pl-c1\">len</span>(argv) <span class=\"pl-k\">!=</span> <span class=\"pl-c1\">1</span>:\n    <span class=\"pl-c1\">print</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>argv was<span class=\"pl-pds\">\"</span></span>,argv\n    <span class=\"pl-k\">raise</span> <span class=\"pl-c1\">RuntimeError</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>unknown argument<span class=\"pl-pds\">'</span></span>)\n  <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>nn: building graph<span class=\"pl-pds\">'</span></span>)\n\n  tf.set_random_seed(<span class=\"pl-c1\">FLAGS</span>.seed)\n\n  <span class=\"pl-k\">with</span> tf.Session(<span class=\"pl-v\">config</span><span class=\"pl-k\">=</span>tf.ConfigProto(<span class=\"pl-v\">allow_soft_placement</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">True</span>)) <span class=\"pl-k\">as</span> sess:\n    <span class=\"pl-k\">if</span> <span class=\"pl-c1\">FLAGS</span>.broken:\n      <span class=\"pl-k\">with</span> tf.device(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>/cpu:0<span class=\"pl-pds\">'</span></span>):\n        <span class=\"pl-c1\">input</span> <span class=\"pl-k\">=</span> mk_input()\n    <span class=\"pl-k\">else</span>:\n      <span class=\"pl-c1\">input</span> <span class=\"pl-k\">=</span> mk_input()\n\n    a <span class=\"pl-k\">=</span> tf.reduce_mean(<span class=\"pl-c1\">input</span>)\n\n    tf.global_variables_initializer().run()\n    tf.train.start_queue_runners(<span class=\"pl-v\">sess</span> <span class=\"pl-k\">=</span> sess)\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>nn: TF session initialized<span class=\"pl-pds\">'</span></span>)\n\n    <span class=\"pl-k\">for</span> step <span class=\"pl-k\">in</span> <span class=\"pl-v\">xrange</span>(<span class=\"pl-c1\">10</span>):\n      res <span class=\"pl-k\">=</span> sess.run(a)\n      <span class=\"pl-c1\">print</span>(res)\n\n<span class=\"pl-k\">if</span> <span class=\"pl-c1\">__name__</span> <span class=\"pl-k\">==</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>__main__<span class=\"pl-pds\">'</span></span>:\n  tf.app.run()</pre></div>\n<p>If you run this without <code>--broken</code>, then you'll get the same result every time.  On my machine, the result without <code>--broken</code> starts 0.500045.  But if you run this with <code>--broken</code>, then you'll get a different result each time.  For instance:</p>\n<pre><code>jwise@jwise-dt:/home/scratch.jwise_dl$ ../virtualenv/bin/python nnrandom.py  --broken 2&gt;&amp;1 | tail -n5\n0.500318\n0.500236\n0.500246\n0.500185\n0.500303\njwise@jwise-dt:/home/scratch.jwise_dl$ ../virtualenv/bin/python nnrandom.py  --broken 2&gt;&amp;1 | tail -n5\n0.500279\n0.500218\n0.500164\n0.500178\n0.500106\n</code></pre>\n<p>I have not dug any deeper yet as to where, exactly, the nondeterminism is coming from, but I figured that this is pretty close to a minimal repro case based on TF primitives.</p>\n<p>Thanks,<br>\njoshua</p>", "body_text": "System information\n\nHave I written custom code (as opposed to using a stock example script provided in TensorFlow): yes.  See below.\nOS Platform and Distribution (e.g., Linux Ubuntu 16.04):\nTensorFlow installed from (source or binary): source\nTensorFlow version (use command below): ('0.12.1-2106-gf7d07f5-dirty', '0.12.head')\nBazel version (if compiling from source): (not a build issue)\nCUDA/cuDNN version: CuDNN5, CUDA8 (though this runs on CPU)\nGPU model and memory: 1x Titan X Pascal, 1x Titan X (though this runs on CPU)\nExact command to reproduce: ../virtualenv/bin/python nnrandom.py --broken; ../virtualenv/bin/python nnrandom.py --broken\n\nDescribe the problem, source code, and logs\nWhen using augmentation primitives, sometimes, they create run-to-run non-determinism by ignoring the system random seed.  This makes reproducing a run impossible, even when using tf.set_random_seed.  One case in which they seem to do this is inside a tf.device() block.  Consider the following snippet:\nimport tensorflow as tf\nimport numpy as np\n\ntf.app.flags.DEFINE_integer(\"seed\", 1, \"RNG seed\")\nFLAGS = tf.app.flags.FLAGS\n\ntf.app.flags.DEFINE_float(\"augment_hue\", 0.5, \"hue augment factor\")\ntf.app.flags.DEFINE_boolean(\"no_augment\", False, \"whether to disable augmentation entirely\")\ndef mk_input():\n  np.random.seed(0)\n  a1s = np.random.uniform(size = [32, 128, 128, 3]).astype(np.float32)\n\n  if not FLAGS.no_augment:\n    def aug(img):\n      img = tf.image.random_hue(img, FLAGS.augment_hue, seed = 50001)\n\n      return img\n    a1s = tf.map_fn(aug, a1s)\n\n  return a1s\n\ntf.app.flags.DEFINE_boolean('broken', False, '')\ndef main(argv=None):\n  if len(argv) != 1:\n    print \"argv was\",argv\n    raise RuntimeError('unknown argument')\n  print('nn: building graph')\n\n  tf.set_random_seed(FLAGS.seed)\n\n  with tf.Session(config=tf.ConfigProto(allow_soft_placement = True)) as sess:\n    if FLAGS.broken:\n      with tf.device('/cpu:0'):\n        input = mk_input()\n    else:\n      input = mk_input()\n\n    a = tf.reduce_mean(input)\n\n    tf.global_variables_initializer().run()\n    tf.train.start_queue_runners(sess = sess)\n    print('nn: TF session initialized')\n\n    for step in xrange(10):\n      res = sess.run(a)\n      print(res)\n\nif __name__ == '__main__':\n  tf.app.run()\nIf you run this without --broken, then you'll get the same result every time.  On my machine, the result without --broken starts 0.500045.  But if you run this with --broken, then you'll get a different result each time.  For instance:\njwise@jwise-dt:/home/scratch.jwise_dl$ ../virtualenv/bin/python nnrandom.py  --broken 2>&1 | tail -n5\n0.500318\n0.500236\n0.500246\n0.500185\n0.500303\njwise@jwise-dt:/home/scratch.jwise_dl$ ../virtualenv/bin/python nnrandom.py  --broken 2>&1 | tail -n5\n0.500279\n0.500218\n0.500164\n0.500178\n0.500106\n\nI have not dug any deeper yet as to where, exactly, the nondeterminism is coming from, but I figured that this is pretty close to a minimal repro case based on TF primitives.\nThanks,\njoshua", "body": "### System information\r\n- **Have I written custom code (as opposed to using a stock example script provided in TensorFlow)**: yes.  See below.\r\n- **OS Platform and Distribution (e.g., Linux Ubuntu 16.04)**: \r\n- **TensorFlow installed from (source or binary)**: source\r\n- **TensorFlow version (use command below)**: `('0.12.1-2106-gf7d07f5-dirty', '0.12.head')`\r\n- **Bazel version (if compiling from source)**: (not a build issue)\r\n- **CUDA/cuDNN version**: CuDNN5, CUDA8 (though this runs on CPU)\r\n- **GPU model and memory**: 1x Titan X Pascal, 1x Titan X (though this runs on CPU)\r\n- **Exact command to reproduce**: `../virtualenv/bin/python nnrandom.py --broken; ../virtualenv/bin/python nnrandom.py --broken`\r\n\r\n### Describe the problem, source code, and logs\r\n\r\nWhen using augmentation primitives, sometimes, they create run-to-run non-determinism by ignoring the system random seed.  This makes reproducing a run impossible, even when using `tf.set_random_seed`.  One case in which they seem to do this is inside a `tf.device()` block.  Consider the following snippet:\r\n\r\n```python\r\nimport tensorflow as tf\r\nimport numpy as np\r\n\r\ntf.app.flags.DEFINE_integer(\"seed\", 1, \"RNG seed\")\r\nFLAGS = tf.app.flags.FLAGS\r\n\r\ntf.app.flags.DEFINE_float(\"augment_hue\", 0.5, \"hue augment factor\")\r\ntf.app.flags.DEFINE_boolean(\"no_augment\", False, \"whether to disable augmentation entirely\")\r\ndef mk_input():\r\n  np.random.seed(0)\r\n  a1s = np.random.uniform(size = [32, 128, 128, 3]).astype(np.float32)\r\n\r\n  if not FLAGS.no_augment:\r\n    def aug(img):\r\n      img = tf.image.random_hue(img, FLAGS.augment_hue, seed = 50001)\r\n\r\n      return img\r\n    a1s = tf.map_fn(aug, a1s)\r\n\r\n  return a1s\r\n\r\ntf.app.flags.DEFINE_boolean('broken', False, '')\r\ndef main(argv=None):\r\n  if len(argv) != 1:\r\n    print \"argv was\",argv\r\n    raise RuntimeError('unknown argument')\r\n  print('nn: building graph')\r\n\r\n  tf.set_random_seed(FLAGS.seed)\r\n\r\n  with tf.Session(config=tf.ConfigProto(allow_soft_placement = True)) as sess:\r\n    if FLAGS.broken:\r\n      with tf.device('/cpu:0'):\r\n        input = mk_input()\r\n    else:\r\n      input = mk_input()\r\n\r\n    a = tf.reduce_mean(input)\r\n\r\n    tf.global_variables_initializer().run()\r\n    tf.train.start_queue_runners(sess = sess)\r\n    print('nn: TF session initialized')\r\n\r\n    for step in xrange(10):\r\n      res = sess.run(a)\r\n      print(res)\r\n\r\nif __name__ == '__main__':\r\n  tf.app.run()\r\n```\r\n\r\nIf you run this without `--broken`, then you'll get the same result every time.  On my machine, the result without `--broken` starts 0.500045.  But if you run this with `--broken`, then you'll get a different result each time.  For instance:\r\n\r\n```\r\njwise@jwise-dt:/home/scratch.jwise_dl$ ../virtualenv/bin/python nnrandom.py  --broken 2>&1 | tail -n5\r\n0.500318\r\n0.500236\r\n0.500246\r\n0.500185\r\n0.500303\r\njwise@jwise-dt:/home/scratch.jwise_dl$ ../virtualenv/bin/python nnrandom.py  --broken 2>&1 | tail -n5\r\n0.500279\r\n0.500218\r\n0.500164\r\n0.500178\r\n0.500106\r\n```\r\n\r\nI have not dug any deeper yet as to where, exactly, the nondeterminism is coming from, but I figured that this is pretty close to a minimal repro case based on TF primitives.\r\n\r\nThanks,\r\njoshua"}