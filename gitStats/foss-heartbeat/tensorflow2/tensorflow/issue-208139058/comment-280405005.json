{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/280405005", "html_url": "https://github.com/tensorflow/tensorflow/issues/7579#issuecomment-280405005", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/7579", "id": 280405005, "node_id": "MDEyOklzc3VlQ29tbWVudDI4MDQwNTAwNQ==", "user": {"login": "aselle", "id": 326106, "node_id": "MDQ6VXNlcjMyNjEwNg==", "avatar_url": "https://avatars1.githubusercontent.com/u/326106?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aselle", "html_url": "https://github.com/aselle", "followers_url": "https://api.github.com/users/aselle/followers", "following_url": "https://api.github.com/users/aselle/following{/other_user}", "gists_url": "https://api.github.com/users/aselle/gists{/gist_id}", "starred_url": "https://api.github.com/users/aselle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aselle/subscriptions", "organizations_url": "https://api.github.com/users/aselle/orgs", "repos_url": "https://api.github.com/users/aselle/repos", "events_url": "https://api.github.com/users/aselle/events{/privacy}", "received_events_url": "https://api.github.com/users/aselle/received_events", "type": "User", "site_admin": false}, "created_at": "2017-02-16T17:47:50Z", "updated_at": "2017-02-16T17:57:00Z", "author_association": "MEMBER", "body_html": "<p>Thank you for reporting this. We apologize for that. We had tested the tutorial on RC2, where that worked, but in the final TensorFlow we need to replace <code>tf.contrib.learn.estimators.model_fn.ModelFnOps</code> to be<code>tf.contrib.learn.ModelFnOps</code>. numpy_input_fn also moved. So try the following block ...</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">import</span> numpy <span class=\"pl-k\">as</span> np\n<span class=\"pl-k\">import</span> tensorflow <span class=\"pl-k\">as</span> tf\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> Declare list of features, we only have one real-valued feature</span>\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">model</span>(<span class=\"pl-smi\">features</span>, <span class=\"pl-smi\">labels</span>, <span class=\"pl-smi\">mode</span>):\n  <span class=\"pl-c\"><span class=\"pl-c\">#</span> Build a linear model and predict values</span>\n  W <span class=\"pl-k\">=</span> tf.get_variable(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>W<span class=\"pl-pds\">\"</span></span>, [<span class=\"pl-c1\">1</span>], <span class=\"pl-v\">dtype</span><span class=\"pl-k\">=</span>tf.float64)\n  b <span class=\"pl-k\">=</span> tf.get_variable(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>b<span class=\"pl-pds\">\"</span></span>, [<span class=\"pl-c1\">1</span>], <span class=\"pl-v\">dtype</span><span class=\"pl-k\">=</span>tf.float64)\n  y <span class=\"pl-k\">=</span> W<span class=\"pl-k\">*</span>features[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>x<span class=\"pl-pds\">'</span></span>] <span class=\"pl-k\">+</span> b\n  <span class=\"pl-c\"><span class=\"pl-c\">#</span> Loss sub-graph</span>\n  loss <span class=\"pl-k\">=</span> tf.reduce_sum(tf.square(y <span class=\"pl-k\">-</span> labels))\n  <span class=\"pl-c\"><span class=\"pl-c\">#</span> Training sub-graph</span>\n  global_step <span class=\"pl-k\">=</span> tf.train.get_global_step()\n  optimizer <span class=\"pl-k\">=</span> tf.train.GradientDescentOptimizer(<span class=\"pl-c1\">0.01</span>)\n  train <span class=\"pl-k\">=</span> tf.group(optimizer.minimize(loss),\n                   tf.assign_add(global_step, <span class=\"pl-c1\">1</span>))\n  <span class=\"pl-c\"><span class=\"pl-c\">#</span> ModelFnOps connects subgraphs we built to the</span>\n  <span class=\"pl-c\"><span class=\"pl-c\">#</span> appropriate functionality.Try that and it should work fine (I verified it). I'll update the docs as well.</span>\n  <span class=\"pl-k\">return</span> tf.contrib.learn.ModelFnOps(\n      <span class=\"pl-v\">mode</span><span class=\"pl-k\">=</span>mode, <span class=\"pl-v\">predictions</span><span class=\"pl-k\">=</span>y,\n      <span class=\"pl-v\">loss</span><span class=\"pl-k\">=</span> loss,\n      <span class=\"pl-v\">train_op</span><span class=\"pl-k\">=</span>train)\n\nestimator <span class=\"pl-k\">=</span> tf.contrib.learn.Estimator(<span class=\"pl-v\">model_fn</span><span class=\"pl-k\">=</span>model)\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> define our data set</span>\nx<span class=\"pl-k\">=</span>np.array([<span class=\"pl-c1\">1</span>., <span class=\"pl-c1\">2</span>., <span class=\"pl-c1\">3</span>., <span class=\"pl-c1\">4</span>.])\ny<span class=\"pl-k\">=</span>np.array([<span class=\"pl-c1\">0</span>., <span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>., <span class=\"pl-k\">-</span><span class=\"pl-c1\">2</span>., <span class=\"pl-k\">-</span><span class=\"pl-c1\">3</span>.])\ninput_fn <span class=\"pl-k\">=</span> tf.contrib.learn.io.numpy_input_fn({<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>x<span class=\"pl-pds\">\"</span></span>: x}, y, <span class=\"pl-c1\">4</span>, <span class=\"pl-v\">num_epochs</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">1000</span>)\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> train</span>\nestimator.fit(<span class=\"pl-v\">input_fn</span><span class=\"pl-k\">=</span>input_fn, <span class=\"pl-v\">steps</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">1000</span>)\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> evaluate our model</span>\n<span class=\"pl-c1\">print</span>(estimator.evaluate(<span class=\"pl-v\">input_fn</span><span class=\"pl-k\">=</span>input_fn, <span class=\"pl-v\">steps</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">10</span>))</pre></div>", "body_text": "Thank you for reporting this. We apologize for that. We had tested the tutorial on RC2, where that worked, but in the final TensorFlow we need to replace tf.contrib.learn.estimators.model_fn.ModelFnOps to betf.contrib.learn.ModelFnOps. numpy_input_fn also moved. So try the following block ...\nimport numpy as np\nimport tensorflow as tf\n# Declare list of features, we only have one real-valued feature\ndef model(features, labels, mode):\n  # Build a linear model and predict values\n  W = tf.get_variable(\"W\", [1], dtype=tf.float64)\n  b = tf.get_variable(\"b\", [1], dtype=tf.float64)\n  y = W*features['x'] + b\n  # Loss sub-graph\n  loss = tf.reduce_sum(tf.square(y - labels))\n  # Training sub-graph\n  global_step = tf.train.get_global_step()\n  optimizer = tf.train.GradientDescentOptimizer(0.01)\n  train = tf.group(optimizer.minimize(loss),\n                   tf.assign_add(global_step, 1))\n  # ModelFnOps connects subgraphs we built to the\n  # appropriate functionality.Try that and it should work fine (I verified it). I'll update the docs as well.\n  return tf.contrib.learn.ModelFnOps(\n      mode=mode, predictions=y,\n      loss= loss,\n      train_op=train)\n\nestimator = tf.contrib.learn.Estimator(model_fn=model)\n# define our data set\nx=np.array([1., 2., 3., 4.])\ny=np.array([0., -1., -2., -3.])\ninput_fn = tf.contrib.learn.io.numpy_input_fn({\"x\": x}, y, 4, num_epochs=1000)\n\n# train\nestimator.fit(input_fn=input_fn, steps=1000)\n# evaluate our model\nprint(estimator.evaluate(input_fn=input_fn, steps=10))", "body": "Thank you for reporting this. We apologize for that. We had tested the tutorial on RC2, where that worked, but in the final TensorFlow we need to replace `tf.contrib.learn.estimators.model_fn.ModelFnOps` to be`tf.contrib.learn.ModelFnOps`. numpy_input_fn also moved. So try the following block ...\r\n\r\n```python\r\nimport numpy as np\r\nimport tensorflow as tf\r\n# Declare list of features, we only have one real-valued feature\r\ndef model(features, labels, mode):\r\n  # Build a linear model and predict values\r\n  W = tf.get_variable(\"W\", [1], dtype=tf.float64)\r\n  b = tf.get_variable(\"b\", [1], dtype=tf.float64)\r\n  y = W*features['x'] + b\r\n  # Loss sub-graph\r\n  loss = tf.reduce_sum(tf.square(y - labels))\r\n  # Training sub-graph\r\n  global_step = tf.train.get_global_step()\r\n  optimizer = tf.train.GradientDescentOptimizer(0.01)\r\n  train = tf.group(optimizer.minimize(loss),\r\n                   tf.assign_add(global_step, 1))\r\n  # ModelFnOps connects subgraphs we built to the\r\n  # appropriate functionality.Try that and it should work fine (I verified it). I'll update the docs as well.\r\n  return tf.contrib.learn.ModelFnOps(\r\n      mode=mode, predictions=y,\r\n      loss= loss,\r\n      train_op=train)\r\n\r\nestimator = tf.contrib.learn.Estimator(model_fn=model)\r\n# define our data set\r\nx=np.array([1., 2., 3., 4.])\r\ny=np.array([0., -1., -2., -3.])\r\ninput_fn = tf.contrib.learn.io.numpy_input_fn({\"x\": x}, y, 4, num_epochs=1000)\r\n\r\n# train\r\nestimator.fit(input_fn=input_fn, steps=1000)\r\n# evaluate our model\r\nprint(estimator.evaluate(input_fn=input_fn, steps=10))\r\n```\r\n"}