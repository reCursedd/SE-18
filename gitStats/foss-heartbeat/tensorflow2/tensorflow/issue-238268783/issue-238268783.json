{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11022", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11022/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11022/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11022/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/11022", "id": 238268783, "node_id": "MDU6SXNzdWUyMzgyNjg3ODM=", "number": 11022, "title": "Major performance hit when running two processes on same GPU.", "user": {"login": "amelius15", "id": 7035002, "node_id": "MDQ6VXNlcjcwMzUwMDI=", "avatar_url": "https://avatars1.githubusercontent.com/u/7035002?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amelius15", "html_url": "https://github.com/amelius15", "followers_url": "https://api.github.com/users/amelius15/followers", "following_url": "https://api.github.com/users/amelius15/following{/other_user}", "gists_url": "https://api.github.com/users/amelius15/gists{/gist_id}", "starred_url": "https://api.github.com/users/amelius15/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amelius15/subscriptions", "organizations_url": "https://api.github.com/users/amelius15/orgs", "repos_url": "https://api.github.com/users/amelius15/repos", "events_url": "https://api.github.com/users/amelius15/events{/privacy}", "received_events_url": "https://api.github.com/users/amelius15/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 473172988, "node_id": "MDU6TGFiZWw0NzMxNzI5ODg=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:bug/performance", "name": "type:bug/performance", "color": "159b2e", "default": false}], "state": "closed", "locked": false, "assignee": {"login": "yzhwang", "id": 1002405, "node_id": "MDQ6VXNlcjEwMDI0MDU=", "avatar_url": "https://avatars1.githubusercontent.com/u/1002405?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yzhwang", "html_url": "https://github.com/yzhwang", "followers_url": "https://api.github.com/users/yzhwang/followers", "following_url": "https://api.github.com/users/yzhwang/following{/other_user}", "gists_url": "https://api.github.com/users/yzhwang/gists{/gist_id}", "starred_url": "https://api.github.com/users/yzhwang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yzhwang/subscriptions", "organizations_url": "https://api.github.com/users/yzhwang/orgs", "repos_url": "https://api.github.com/users/yzhwang/repos", "events_url": "https://api.github.com/users/yzhwang/events{/privacy}", "received_events_url": "https://api.github.com/users/yzhwang/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "yzhwang", "id": 1002405, "node_id": "MDQ6VXNlcjEwMDI0MDU=", "avatar_url": "https://avatars1.githubusercontent.com/u/1002405?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yzhwang", "html_url": "https://github.com/yzhwang", "followers_url": "https://api.github.com/users/yzhwang/followers", "following_url": "https://api.github.com/users/yzhwang/following{/other_user}", "gists_url": "https://api.github.com/users/yzhwang/gists{/gist_id}", "starred_url": "https://api.github.com/users/yzhwang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yzhwang/subscriptions", "organizations_url": "https://api.github.com/users/yzhwang/orgs", "repos_url": "https://api.github.com/users/yzhwang/repos", "events_url": "https://api.github.com/users/yzhwang/events{/privacy}", "received_events_url": "https://api.github.com/users/yzhwang/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 5, "created_at": "2017-06-23T22:35:57Z", "updated_at": "2018-01-05T19:22:25Z", "closed_at": "2018-01-05T19:22:25Z", "author_association": "NONE", "body_html": "<p>I've observed a major performance hit when running two identical models on the same GPU, with allow_growth set to True, so that each process, which only needs a small fraction of the GPU memory (~1gb/11gb are used when allow_growth is set to true). When running a single model on a single process, it consistently finished going through the data I have available in approximately 170-174 seconds, and never exceeds 50% Volatile GPU-Utilization according to nvidia-smi . However, when running with two separate, concurrent processes, (each identical to the first), they both finish in approximately 320-340 seconds, which is unexpected, since GPU utilization was not even half in the first scenario, and running two concurrently effectively slows them down to running them sequentially, despite the seemingly available processing power and memory.</p>\n<p>Is this intentional, or is there a better way to do this? (Currently launching two workers via Celery, each of which create their own TF session and load the model into it separately, and run the data through it). I would love to make maximal use of available hardware, and this seems like a very counter-intuitive outcome.</p>\n<p>I can observe each process allocate roughly 1GiB GPU memory, and each adds approximately 45-50% GPU utilization. For testing purposes, data and model used in both parallel runs is completely identical.</p>\n<p>Any thoughts? Am I misusing TF?</p>\n<h3>System information</h3>\n<ul>\n<li>Using Keras to load model</li>\n<li>Ubuntu 16.04</li>\n<li>CUDA/CUDNN 8.0/5.1</li>\n<li>TF version 1.0.1</li>\n<li>GTX 1080 ti (not being used to render screen, second 1080 ti is doing that)</li>\n<li>Running in nvidia-docker with a single GPU available to worker process (the one not rendering the screen).</li>\n<li>Running two separate sessions initiated via Celery which both create their own session, set allow_growth=True, each load the model into memory separately, and each run with data separately.</li>\n</ul>", "body_text": "I've observed a major performance hit when running two identical models on the same GPU, with allow_growth set to True, so that each process, which only needs a small fraction of the GPU memory (~1gb/11gb are used when allow_growth is set to true). When running a single model on a single process, it consistently finished going through the data I have available in approximately 170-174 seconds, and never exceeds 50% Volatile GPU-Utilization according to nvidia-smi . However, when running with two separate, concurrent processes, (each identical to the first), they both finish in approximately 320-340 seconds, which is unexpected, since GPU utilization was not even half in the first scenario, and running two concurrently effectively slows them down to running them sequentially, despite the seemingly available processing power and memory.\nIs this intentional, or is there a better way to do this? (Currently launching two workers via Celery, each of which create their own TF session and load the model into it separately, and run the data through it). I would love to make maximal use of available hardware, and this seems like a very counter-intuitive outcome.\nI can observe each process allocate roughly 1GiB GPU memory, and each adds approximately 45-50% GPU utilization. For testing purposes, data and model used in both parallel runs is completely identical.\nAny thoughts? Am I misusing TF?\nSystem information\n\nUsing Keras to load model\nUbuntu 16.04\nCUDA/CUDNN 8.0/5.1\nTF version 1.0.1\nGTX 1080 ti (not being used to render screen, second 1080 ti is doing that)\nRunning in nvidia-docker with a single GPU available to worker process (the one not rendering the screen).\nRunning two separate sessions initiated via Celery which both create their own session, set allow_growth=True, each load the model into memory separately, and each run with data separately.", "body": "I've observed a major performance hit when running two identical models on the same GPU, with allow_growth set to True, so that each process, which only needs a small fraction of the GPU memory (~1gb/11gb are used when allow_growth is set to true). When running a single model on a single process, it consistently finished going through the data I have available in approximately 170-174 seconds, and never exceeds 50% Volatile GPU-Utilization according to nvidia-smi . However, when running with two separate, concurrent processes, (each identical to the first), they both finish in approximately 320-340 seconds, which is unexpected, since GPU utilization was not even half in the first scenario, and running two concurrently effectively slows them down to running them sequentially, despite the seemingly available processing power and memory. \r\n\r\nIs this intentional, or is there a better way to do this? (Currently launching two workers via Celery, each of which create their own TF session and load the model into it separately, and run the data through it). I would love to make maximal use of available hardware, and this seems like a very counter-intuitive outcome. \r\n\r\nI can observe each process allocate roughly 1GiB GPU memory, and each adds approximately 45-50% GPU utilization. For testing purposes, data and model used in both parallel runs is completely identical.\r\n\r\nAny thoughts? Am I misusing TF? \r\n\r\n### System information\r\n- Using Keras to load model\r\n- Ubuntu 16.04\r\n- CUDA/CUDNN 8.0/5.1\r\n- TF version 1.0.1\r\n- GTX 1080 ti (not being used to render screen, second 1080 ti is doing that)\r\n- Running in nvidia-docker with a single GPU available to worker process (the one not rendering the screen).\r\n- Running two separate sessions initiated via Celery which both create their own session, set allow_growth=True, each load the model into memory separately, and each run with data separately. \r\n\r\n"}