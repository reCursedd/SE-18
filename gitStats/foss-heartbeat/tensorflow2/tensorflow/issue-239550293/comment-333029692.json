{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/333029692", "html_url": "https://github.com/tensorflow/tensorflow/issues/11144#issuecomment-333029692", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11144", "id": 333029692, "node_id": "MDEyOklzc3VlQ29tbWVudDMzMzAyOTY5Mg==", "user": {"login": "bingo619", "id": 1096590, "node_id": "MDQ6VXNlcjEwOTY1OTA=", "avatar_url": "https://avatars0.githubusercontent.com/u/1096590?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bingo619", "html_url": "https://github.com/bingo619", "followers_url": "https://api.github.com/users/bingo619/followers", "following_url": "https://api.github.com/users/bingo619/following{/other_user}", "gists_url": "https://api.github.com/users/bingo619/gists{/gist_id}", "starred_url": "https://api.github.com/users/bingo619/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bingo619/subscriptions", "organizations_url": "https://api.github.com/users/bingo619/orgs", "repos_url": "https://api.github.com/users/bingo619/repos", "events_url": "https://api.github.com/users/bingo619/events{/privacy}", "received_events_url": "https://api.github.com/users/bingo619/received_events", "type": "User", "site_admin": false}, "created_at": "2017-09-29T04:44:39Z", "updated_at": "2017-09-29T04:44:39Z", "author_association": "NONE", "body_html": "<pre><code>//MultiRNNCell\ndef call(self, inputs, state):\n    \"\"\"Run this multi-layer cell on inputs, starting from state.\"\"\"\n    cur_state_pos = 0\n    cur_inp = inputs\n    new_states = []\n    for i, cell in enumerate(self._cells):\n      with vs.variable_scope(\"cell_%d\" % i):\n        if self._state_is_tuple:\n          if not nest.is_sequence(state):\n            raise ValueError(\n                \"Expected state to be a tuple of length %d, but received: %s\" %\n                (len(self.state_size), state))\n          cur_state = state[i]\n        else:\n          cur_state = array_ops.slice(state, [0, cur_state_pos],\n                                      [-1, cell.state_size])\n          cur_state_pos += cell.state_size\n        cur_inp, new_state = cell(cur_inp, cur_state)\n        new_states.append(new_state)\n\n    new_states = (tuple(new_states) if self._state_is_tuple else\n                  array_ops.concat(new_states, 1))\n\n    return cur_inp, new_states\n</code></pre>\n<p>from 2nd layer the time bit is missing, can we feed that?</p>\n<p>I think your solution will work, it is just that the time delta is not always the same.</p>\n<p>Sorry if I understand it wrong.</p>", "body_text": "//MultiRNNCell\ndef call(self, inputs, state):\n    \"\"\"Run this multi-layer cell on inputs, starting from state.\"\"\"\n    cur_state_pos = 0\n    cur_inp = inputs\n    new_states = []\n    for i, cell in enumerate(self._cells):\n      with vs.variable_scope(\"cell_%d\" % i):\n        if self._state_is_tuple:\n          if not nest.is_sequence(state):\n            raise ValueError(\n                \"Expected state to be a tuple of length %d, but received: %s\" %\n                (len(self.state_size), state))\n          cur_state = state[i]\n        else:\n          cur_state = array_ops.slice(state, [0, cur_state_pos],\n                                      [-1, cell.state_size])\n          cur_state_pos += cell.state_size\n        cur_inp, new_state = cell(cur_inp, cur_state)\n        new_states.append(new_state)\n\n    new_states = (tuple(new_states) if self._state_is_tuple else\n                  array_ops.concat(new_states, 1))\n\n    return cur_inp, new_states\n\nfrom 2nd layer the time bit is missing, can we feed that?\nI think your solution will work, it is just that the time delta is not always the same.\nSorry if I understand it wrong.", "body": "```\r\n//MultiRNNCell\r\ndef call(self, inputs, state):\r\n    \"\"\"Run this multi-layer cell on inputs, starting from state.\"\"\"\r\n    cur_state_pos = 0\r\n    cur_inp = inputs\r\n    new_states = []\r\n    for i, cell in enumerate(self._cells):\r\n      with vs.variable_scope(\"cell_%d\" % i):\r\n        if self._state_is_tuple:\r\n          if not nest.is_sequence(state):\r\n            raise ValueError(\r\n                \"Expected state to be a tuple of length %d, but received: %s\" %\r\n                (len(self.state_size), state))\r\n          cur_state = state[i]\r\n        else:\r\n          cur_state = array_ops.slice(state, [0, cur_state_pos],\r\n                                      [-1, cell.state_size])\r\n          cur_state_pos += cell.state_size\r\n        cur_inp, new_state = cell(cur_inp, cur_state)\r\n        new_states.append(new_state)\r\n\r\n    new_states = (tuple(new_states) if self._state_is_tuple else\r\n                  array_ops.concat(new_states, 1))\r\n\r\n    return cur_inp, new_states\r\n```\r\n\r\nfrom 2nd layer the time bit is missing, can we feed that?\r\n\r\nI think your solution will work, it is just that the time delta is not always the same.\r\n\r\nSorry if I understand it wrong."}