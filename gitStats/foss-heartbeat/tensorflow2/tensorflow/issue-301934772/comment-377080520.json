{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/377080520", "html_url": "https://github.com/tensorflow/tensorflow/issues/17390#issuecomment-377080520", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/17390", "id": 377080520, "node_id": "MDEyOklzc3VlQ29tbWVudDM3NzA4MDUyMA==", "user": {"login": "asimshankar", "id": 16018, "node_id": "MDQ6VXNlcjE2MDE4", "avatar_url": "https://avatars2.githubusercontent.com/u/16018?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asimshankar", "html_url": "https://github.com/asimshankar", "followers_url": "https://api.github.com/users/asimshankar/followers", "following_url": "https://api.github.com/users/asimshankar/following{/other_user}", "gists_url": "https://api.github.com/users/asimshankar/gists{/gist_id}", "starred_url": "https://api.github.com/users/asimshankar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asimshankar/subscriptions", "organizations_url": "https://api.github.com/users/asimshankar/orgs", "repos_url": "https://api.github.com/users/asimshankar/repos", "events_url": "https://api.github.com/users/asimshankar/events{/privacy}", "received_events_url": "https://api.github.com/users/asimshankar/received_events", "type": "User", "site_admin": false}, "created_at": "2018-03-29T00:19:12Z", "updated_at": "2018-03-29T00:19:12Z", "author_association": "MEMBER", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=3328023\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/saudet\">@saudet</a>: Regarding <a href=\"https://github.com/tensorflow/tensorflow/issues/17390#issuecomment-375837293\" data-hovercard-type=\"issue\" data-hovercard-url=\"/tensorflow/tensorflow/issues/17390/hovercard\">\"I'm still looking for an explanation as to why that is\"</a>, I didn't know that you had ever asked for one :). My apologies if I missed some previous comment asking about this.</p>\n<p>First some background:</p>\n<ul>\n<li>TensorFlow has a runtime implemented in C++, but for \"frontends\" we provide a smaller C API surface in <a href=\"https://www.github.com/tensorflow/tensorflow/blob/master/tensorflow/c/c_api.h\">c_api.h</a>. Unlike the C++ interfaces used in the runtime's implementation, we do provide API stability guarantees for the C API.</li>\n<li>This stable C API surface makes it suitable for implementing most language bindings. The Python frontend connects to the runtime via this C API, as do the other languages like Go, Haskell, Rust, Ruby etc. (In Python's case, this C API is what is SWIGed)</li>\n</ul>\n<p>The Java API implementation in this repository has a relatively small hand-written JNI wrapper over the C API for the lowest level constructs (Graph, Operation, Session). The work by <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=10109534\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/karllessard\">@karllessard</a> and others is not adding any additional JNI, but generating idiomatic pure-Java wrappers for all the TensorFlow operations by  composing the lower level Java constructs. This is again very similar to how the Python API wrappers (<code>tf.add</code>, <code>tf.gather</code> etc.) are generated to use the Python constructs built on top of the C API. The same for Go. These language-specific generation tools make it easier to generate code that follow idioms of the target language. For example, in Java, generics are used to indicate the element-type of <code>Tensor</code> objects. It's a small amount of JNI to build the lowest level constructs and then a generator of pure Java code on top of that. It's not that \"everything\" is being written in JNI manually.</p>\n<p>Long story short, there were a few options we had:</p>\n<ul>\n<li>Write a small amount of JNI over a stable C API and generators for higher level APIs on top of it.</li>\n<li>Use tools like JavaCPP or SWIG or  <a href=\"https://github.com/google/clif/blob/master/clif/python/faq.md#q-what-about-interfacing-c-with-languages-other-than-python-such-as-java-and-go\">CLIF</a> to generate a Java interface from the C++ API.</li>\n<li>Use tools like jyni to generate from the Python API.</li>\n</ul>\n<p>Each of them is attractive and has pros and cons. It was useful for us to have a Java API, particularly for executing models. In our judgement - given needs, the resources we have, and the fact that the API in this repository is something we (the TensorFlow team) support and maintain, the simplicity of the first approach - with fewer layers of abstraction, a small set of core constructs (backed by native code) upon which richer idiomatic APIs can be generated or built (in pure Java)  made it appropriate.</p>\n<p>I appreciate that there is some subjectivity involved in such a choice and that reasonable people can differ. However, I hope this at least provides a sense of where we were coming from. Looking ahead, we're figuring out the best way to get more community involvement in Java development, I'll be sure to reach out once we've figured out an appropriate forum for that. At that point, we can have a more detailed discussion (and possibly revisit these choices).</p>\n<p>Also, your point about the C++ API not being user-friendly enough is well taken. Making graph construction APIs in C++ easier to use/navigate would be great, but is not currently on the top of our priority list.</p>", "body_text": "@saudet: Regarding \"I'm still looking for an explanation as to why that is\", I didn't know that you had ever asked for one :). My apologies if I missed some previous comment asking about this.\nFirst some background:\n\nTensorFlow has a runtime implemented in C++, but for \"frontends\" we provide a smaller C API surface in c_api.h. Unlike the C++ interfaces used in the runtime's implementation, we do provide API stability guarantees for the C API.\nThis stable C API surface makes it suitable for implementing most language bindings. The Python frontend connects to the runtime via this C API, as do the other languages like Go, Haskell, Rust, Ruby etc. (In Python's case, this C API is what is SWIGed)\n\nThe Java API implementation in this repository has a relatively small hand-written JNI wrapper over the C API for the lowest level constructs (Graph, Operation, Session). The work by @karllessard and others is not adding any additional JNI, but generating idiomatic pure-Java wrappers for all the TensorFlow operations by  composing the lower level Java constructs. This is again very similar to how the Python API wrappers (tf.add, tf.gather etc.) are generated to use the Python constructs built on top of the C API. The same for Go. These language-specific generation tools make it easier to generate code that follow idioms of the target language. For example, in Java, generics are used to indicate the element-type of Tensor objects. It's a small amount of JNI to build the lowest level constructs and then a generator of pure Java code on top of that. It's not that \"everything\" is being written in JNI manually.\nLong story short, there were a few options we had:\n\nWrite a small amount of JNI over a stable C API and generators for higher level APIs on top of it.\nUse tools like JavaCPP or SWIG or  CLIF to generate a Java interface from the C++ API.\nUse tools like jyni to generate from the Python API.\n\nEach of them is attractive and has pros and cons. It was useful for us to have a Java API, particularly for executing models. In our judgement - given needs, the resources we have, and the fact that the API in this repository is something we (the TensorFlow team) support and maintain, the simplicity of the first approach - with fewer layers of abstraction, a small set of core constructs (backed by native code) upon which richer idiomatic APIs can be generated or built (in pure Java)  made it appropriate.\nI appreciate that there is some subjectivity involved in such a choice and that reasonable people can differ. However, I hope this at least provides a sense of where we were coming from. Looking ahead, we're figuring out the best way to get more community involvement in Java development, I'll be sure to reach out once we've figured out an appropriate forum for that. At that point, we can have a more detailed discussion (and possibly revisit these choices).\nAlso, your point about the C++ API not being user-friendly enough is well taken. Making graph construction APIs in C++ easier to use/navigate would be great, but is not currently on the top of our priority list.", "body": "@saudet: Regarding [\"I'm still looking for an explanation as to why that is\"](https://github.com/tensorflow/tensorflow/issues/17390#issuecomment-375837293), I didn't know that you had ever asked for one :). My apologies if I missed some previous comment asking about this.\r\n\r\nFirst some background:\r\n- TensorFlow has a runtime implemented in C++, but for \"frontends\" we provide a smaller C API surface in [c_api.h](https://www.github.com/tensorflow/tensorflow/blob/master/tensorflow/c/c_api.h). Unlike the C++ interfaces used in the runtime's implementation, we do provide API stability guarantees for the C API.\r\n- This stable C API surface makes it suitable for implementing most language bindings. The Python frontend connects to the runtime via this C API, as do the other languages like Go, Haskell, Rust, Ruby etc. (In Python's case, this C API is what is SWIGed)\r\n\r\nThe Java API implementation in this repository has a relatively small hand-written JNI wrapper over the C API for the lowest level constructs (Graph, Operation, Session). The work by @karllessard and others is not adding any additional JNI, but generating idiomatic pure-Java wrappers for all the TensorFlow operations by  composing the lower level Java constructs. This is again very similar to how the Python API wrappers (`tf.add`, `tf.gather` etc.) are generated to use the Python constructs built on top of the C API. The same for Go. These language-specific generation tools make it easier to generate code that follow idioms of the target language. For example, in Java, generics are used to indicate the element-type of `Tensor` objects. It's a small amount of JNI to build the lowest level constructs and then a generator of pure Java code on top of that. It's not that \"everything\" is being written in JNI manually.\r\n\r\nLong story short, there were a few options we had:\r\n- Write a small amount of JNI over a stable C API and generators for higher level APIs on top of it.\r\n- Use tools like JavaCPP or SWIG or  [CLIF](https://github.com/google/clif/blob/master/clif/python/faq.md#q-what-about-interfacing-c-with-languages-other-than-python-such-as-java-and-go) to generate a Java interface from the C++ API.\r\n- Use tools like jyni to generate from the Python API.\r\n\r\nEach of them is attractive and has pros and cons. It was useful for us to have a Java API, particularly for executing models. In our judgement - given needs, the resources we have, and the fact that the API in this repository is something we (the TensorFlow team) support and maintain, the simplicity of the first approach - with fewer layers of abstraction, a small set of core constructs (backed by native code) upon which richer idiomatic APIs can be generated or built (in pure Java)  made it appropriate.\r\n\r\nI appreciate that there is some subjectivity involved in such a choice and that reasonable people can differ. However, I hope this at least provides a sense of where we were coming from. Looking ahead, we're figuring out the best way to get more community involvement in Java development, I'll be sure to reach out once we've figured out an appropriate forum for that. At that point, we can have a more detailed discussion (and possibly revisit these choices).\r\n\r\nAlso, your point about the C++ API not being user-friendly enough is well taken. Making graph construction APIs in C++ easier to use/navigate would be great, but is not currently on the top of our priority list.\r\n"}