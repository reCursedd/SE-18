{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/395756716", "html_url": "https://github.com/tensorflow/tensorflow/issues/17390#issuecomment-395756716", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/17390", "id": 395756716, "node_id": "MDEyOklzc3VlQ29tbWVudDM5NTc1NjcxNg==", "user": {"login": "asimshankar", "id": 16018, "node_id": "MDQ6VXNlcjE2MDE4", "avatar_url": "https://avatars2.githubusercontent.com/u/16018?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asimshankar", "html_url": "https://github.com/asimshankar", "followers_url": "https://api.github.com/users/asimshankar/followers", "following_url": "https://api.github.com/users/asimshankar/following{/other_user}", "gists_url": "https://api.github.com/users/asimshankar/gists{/gist_id}", "starred_url": "https://api.github.com/users/asimshankar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asimshankar/subscriptions", "organizations_url": "https://api.github.com/users/asimshankar/orgs", "repos_url": "https://api.github.com/users/asimshankar/repos", "events_url": "https://api.github.com/users/asimshankar/events{/privacy}", "received_events_url": "https://api.github.com/users/asimshankar/received_events", "type": "User", "site_admin": false}, "created_at": "2018-06-08T13:13:43Z", "updated_at": "2018-06-08T13:14:43Z", "author_association": "MEMBER", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=3328023\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/saudet\">@saudet</a> : At a high level, I feel that the <strong>primary focus</strong> should be on creating the right API to <strong>use</strong> TensorFlow from Java. The details of how that API is <em>implemented</em> (JavaCPP, manual JNI, C++ or Java code generator etc.) is secondary, and changeable. The \"right\" API is characterized by appropriate abstractions that are easy to understand for a Java developer, a thoughtful exposure of features, and performance.</p>\n<p>If we agree on that (that the experience of the API user is paramount) then we can have a productive conversation on the implementation details. I don't believe we should be working the other way around (i.e., being driven by what's easy to implement).</p>\n<p>With regards to what's missing in JavaCPP - I don't have a list handy, and maybe nothing is missing. Honestly, I haven't devoted enough time to thinking through the details of what switching to JavaCPP would entail. Which is where contributions can help. Since you're passionate about this, perhaps you could do that? Some things to think about in a concrete proposal would be:</p>\n<ul>\n<li>\n<p>What does the end-user Java API look like? Would it make sense to implement the current Java API (with generics etc.) using JavaCPP for the native-call redirection, or would it make sense to define a smaller C++ class and generate its interface? For example, compare the <code>Tensor</code> class in <a href=\"http://bytedeco.org/javacpp-presets/tensorflow/apidocs/org/tensorflow/Tensor.html\" rel=\"nofollow\">current Java API</a> vs. <a href=\"http://bytedeco.org/javacpp-presets/tensorflow/apidocs/org/bytedeco/javacpp/tensorflow.Tensor.html\" rel=\"nofollow\">JavaCPP wrapped over the C++ Tensor class</a>. Along the same lines, since so far the primary interest in the Java API has been in deploying trained models in an application - the APIs for that should be succinct and easy to comprehend (<a href=\"https://github.com/tensorflow/models/tree/master/samples/languages/java\">examples</a>).</p>\n</li>\n<li>\n<p>How would we scope the effort required and benefits of it? For example, assuming we stick with the existing <code>org.tensorflow.Tensor</code> API, what does it take to back it with JavaCPP? Can we quantify the benefits (e.g., improved performance in some cases, like perhaps creating large tensors on Android or something)? Or if the proposal is to have a different API for the Java user, how do we evaluate? For example, can we evaluate the change in APIs by writing examples including \"load a model and serve for inference\" and \"fine tune a previously trained model\" and \"construct a trained model\".</p>\n</li>\n<li>\n<p>Once this is scoped out, who is going to drive the changes?</p>\n</li>\n<li>\n<p>Is it possible to break this down into small sets of changes/projects? For example, the code generator that Karl is working on could just as well be done in Java (no JNI) and doing that may be a reasonable project (Karl has ideas on switching to that, but wanted to get his C++ version in first just because he has that almost working and again, most <em>users</em> of the API won't care whether the Java code was generated one way or another).</p>\n</li>\n</ul>\n<p>I'm not at all suggesting that I'm convinced that JavaCPP isn't the appropriate choice here. However, I haven't had the opportunity to think through all these details, and probably won't have much time to devote to that in the near future. So if someone wants to think this through and write it up and come up with concrete proposals (that can be <a href=\"https://github.com/tensorflow/community\">shared as an RFC</a> (<a href=\"https://groups.google.com/a/tensorflow.org/d/msg/developers/6Irde5yjUBc/SRool5ghAgAJ\" rel=\"nofollow\">example</a>)), we're open to that. Perhaps there is some precedence here? For example, I noticed that there are <a href=\"https://github.com/bytedeco/javacpp-presets/tree/master/mxnet\">JavaCPP presets of MXNet</a> as well, while MXNet also has <a href=\"https://github.com/apache/incubator-mxnet/tree/master/scala-package/core/src/main/scala/org/apache/mxnet\">handwritten scala bindings</a> instead of generating them from the C++ (though admittedly I know nothing about Scala or the implementation/design choices in MXNet). Perhaps you've been through similar thinking there as well?</p>\n<p>Long story short, I'd say that the barrier to \"use JavaCPP\" isn't anyone's \"mindset\", it's simply a person putting the effort to dig into the details of what that means. Or perhaps I'm misunderstanding you and there is a concrete proposal you're suggesting?</p>", "body_text": "@saudet : At a high level, I feel that the primary focus should be on creating the right API to use TensorFlow from Java. The details of how that API is implemented (JavaCPP, manual JNI, C++ or Java code generator etc.) is secondary, and changeable. The \"right\" API is characterized by appropriate abstractions that are easy to understand for a Java developer, a thoughtful exposure of features, and performance.\nIf we agree on that (that the experience of the API user is paramount) then we can have a productive conversation on the implementation details. I don't believe we should be working the other way around (i.e., being driven by what's easy to implement).\nWith regards to what's missing in JavaCPP - I don't have a list handy, and maybe nothing is missing. Honestly, I haven't devoted enough time to thinking through the details of what switching to JavaCPP would entail. Which is where contributions can help. Since you're passionate about this, perhaps you could do that? Some things to think about in a concrete proposal would be:\n\n\nWhat does the end-user Java API look like? Would it make sense to implement the current Java API (with generics etc.) using JavaCPP for the native-call redirection, or would it make sense to define a smaller C++ class and generate its interface? For example, compare the Tensor class in current Java API vs. JavaCPP wrapped over the C++ Tensor class. Along the same lines, since so far the primary interest in the Java API has been in deploying trained models in an application - the APIs for that should be succinct and easy to comprehend (examples).\n\n\nHow would we scope the effort required and benefits of it? For example, assuming we stick with the existing org.tensorflow.Tensor API, what does it take to back it with JavaCPP? Can we quantify the benefits (e.g., improved performance in some cases, like perhaps creating large tensors on Android or something)? Or if the proposal is to have a different API for the Java user, how do we evaluate? For example, can we evaluate the change in APIs by writing examples including \"load a model and serve for inference\" and \"fine tune a previously trained model\" and \"construct a trained model\".\n\n\nOnce this is scoped out, who is going to drive the changes?\n\n\nIs it possible to break this down into small sets of changes/projects? For example, the code generator that Karl is working on could just as well be done in Java (no JNI) and doing that may be a reasonable project (Karl has ideas on switching to that, but wanted to get his C++ version in first just because he has that almost working and again, most users of the API won't care whether the Java code was generated one way or another).\n\n\nI'm not at all suggesting that I'm convinced that JavaCPP isn't the appropriate choice here. However, I haven't had the opportunity to think through all these details, and probably won't have much time to devote to that in the near future. So if someone wants to think this through and write it up and come up with concrete proposals (that can be shared as an RFC (example)), we're open to that. Perhaps there is some precedence here? For example, I noticed that there are JavaCPP presets of MXNet as well, while MXNet also has handwritten scala bindings instead of generating them from the C++ (though admittedly I know nothing about Scala or the implementation/design choices in MXNet). Perhaps you've been through similar thinking there as well?\nLong story short, I'd say that the barrier to \"use JavaCPP\" isn't anyone's \"mindset\", it's simply a person putting the effort to dig into the details of what that means. Or perhaps I'm misunderstanding you and there is a concrete proposal you're suggesting?", "body": "@saudet : At a high level, I feel that the **primary focus** should be on creating the right API to **use** TensorFlow from Java. The details of how that API is _implemented_ (JavaCPP, manual JNI, C++ or Java code generator etc.) is secondary, and changeable. The \"right\" API is characterized by appropriate abstractions that are easy to understand for a Java developer, a thoughtful exposure of features, and performance.\r\n\r\nIf we agree on that (that the experience of the API user is paramount) then we can have a productive conversation on the implementation details. I don't believe we should be working the other way around (i.e., being driven by what's easy to implement). \r\n\r\nWith regards to what's missing in JavaCPP - I don't have a list handy, and maybe nothing is missing. Honestly, I haven't devoted enough time to thinking through the details of what switching to JavaCPP would entail. Which is where contributions can help. Since you're passionate about this, perhaps you could do that? Some things to think about in a concrete proposal would be:\r\n\r\n- What does the end-user Java API look like? Would it make sense to implement the current Java API (with generics etc.) using JavaCPP for the native-call redirection, or would it make sense to define a smaller C++ class and generate its interface? For example, compare the `Tensor` class in [current Java API](http://bytedeco.org/javacpp-presets/tensorflow/apidocs/org/tensorflow/Tensor.html) vs. [JavaCPP wrapped over the C++ Tensor class](http://bytedeco.org/javacpp-presets/tensorflow/apidocs/org/bytedeco/javacpp/tensorflow.Tensor.html). Along the same lines, since so far the primary interest in the Java API has been in deploying trained models in an application - the APIs for that should be succinct and easy to comprehend ([examples](https://github.com/tensorflow/models/tree/master/samples/languages/java)).\r\n\r\n- How would we scope the effort required and benefits of it? For example, assuming we stick with the existing `org.tensorflow.Tensor` API, what does it take to back it with JavaCPP? Can we quantify the benefits (e.g., improved performance in some cases, like perhaps creating large tensors on Android or something)? Or if the proposal is to have a different API for the Java user, how do we evaluate? For example, can we evaluate the change in APIs by writing examples including \"load a model and serve for inference\" and \"fine tune a previously trained model\" and \"construct a trained model\".\r\n\r\n- Once this is scoped out, who is going to drive the changes? \r\n\r\n- Is it possible to break this down into small sets of changes/projects? For example, the code generator that Karl is working on could just as well be done in Java (no JNI) and doing that may be a reasonable project (Karl has ideas on switching to that, but wanted to get his C++ version in first just because he has that almost working and again, most _users_ of the API won't care whether the Java code was generated one way or another).\r\n\r\nI'm not at all suggesting that I'm convinced that JavaCPP isn't the appropriate choice here. However, I haven't had the opportunity to think through all these details, and probably won't have much time to devote to that in the near future. So if someone wants to think this through and write it up and come up with concrete proposals (that can be [shared as an RFC](https://github.com/tensorflow/community) ([example](https://groups.google.com/a/tensorflow.org/d/msg/developers/6Irde5yjUBc/SRool5ghAgAJ))), we're open to that. Perhaps there is some precedence here? For example, I noticed that there are [JavaCPP presets of MXNet](https://github.com/bytedeco/javacpp-presets/tree/master/mxnet) as well, while MXNet also has [handwritten scala bindings](https://github.com/apache/incubator-mxnet/tree/master/scala-package/core/src/main/scala/org/apache/mxnet) instead of generating them from the C++ (though admittedly I know nothing about Scala or the implementation/design choices in MXNet). Perhaps you've been through similar thinking there as well?\r\n\r\nLong story short, I'd say that the barrier to \"use JavaCPP\" isn't anyone's \"mindset\", it's simply a person putting the effort to dig into the details of what that means. Or perhaps I'm misunderstanding you and there is a concrete proposal you're suggesting?"}