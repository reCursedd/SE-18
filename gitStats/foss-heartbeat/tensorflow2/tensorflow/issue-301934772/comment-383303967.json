{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/383303967", "html_url": "https://github.com/tensorflow/tensorflow/issues/17390#issuecomment-383303967", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/17390", "id": 383303967, "node_id": "MDEyOklzc3VlQ29tbWVudDM4MzMwMzk2Nw==", "user": {"login": "karllessard", "id": 10109534, "node_id": "MDQ6VXNlcjEwMTA5NTM0", "avatar_url": "https://avatars3.githubusercontent.com/u/10109534?v=4", "gravatar_id": "", "url": "https://api.github.com/users/karllessard", "html_url": "https://github.com/karllessard", "followers_url": "https://api.github.com/users/karllessard/followers", "following_url": "https://api.github.com/users/karllessard/following{/other_user}", "gists_url": "https://api.github.com/users/karllessard/gists{/gist_id}", "starred_url": "https://api.github.com/users/karllessard/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/karllessard/subscriptions", "organizations_url": "https://api.github.com/users/karllessard/orgs", "repos_url": "https://api.github.com/users/karllessard/repos", "events_url": "https://api.github.com/users/karllessard/events{/privacy}", "received_events_url": "https://api.github.com/users/karllessard/received_events", "type": "User", "site_admin": false}, "created_at": "2018-04-21T15:09:38Z", "updated_at": "2018-04-21T23:05:07Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Hi <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=3328023\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/saudet\">@saudet</a>, sorry for the delay. I feel that there might be a little bit of misunderstanding here, please let me explain more in details. Sorry for the novel ;)</p>\n<blockquote>\n<p>Had you been given the chance to do it in Java instead of C++, do you think it would have made things easier for you</p>\n</blockquote>\n<p>Definitely, a challenge I had in C++ was to output Java source code efficiently, which could have been provided out-of-the-box from Java frameworks, such as JavaPoet.</p>\n<p>The main reason why I had to go with C++ the generator the operation wrappers, as I told <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=15925882\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/Nicholas-Schaub\">@Nicholas-Schaub</a> previously in this thread, is to benefit from operation classification which, at that time, could only be achieved by only linking one core op library at a time to the generator binary and use that library as a package delimiter.  Otherwise you'll end up having all 700+ ops in the same package, which is not convenient. That's the approach the C++ client was taking too. It was a bit hacky, in my opinion, but I'm not sure to see how JavaCPP would have help me doing otherwise here.</p>\n<p>On this topic though, there have been some updates to this issue. Lately, the TF community has introduced a new layer of abstraction over the core ops definitions, called <code>Api defs</code>, which not only exposes classification information in proto buffers but also allows variation of the API per language for fine-tuning. With this new API framework, the wrapper generator could have been written in Java from the start. Now that there is only <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"310686537\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/tensorflow/tensorflow/issues/18192\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/tensorflow/tensorflow/pull/18192/hovercard\" href=\"https://github.com/tensorflow/tensorflow/pull/18192\">#18192</a> remaining to generator those wrappers, I guess we should continue in the current direction and maybe migrate that code to Java later.</p>\n<blockquote>\n<p>if we could offer developers the option of contributing code in Java instead of having them write most of the plumbing in C++</p>\n</blockquote>\n<p>And that is actually already the case. Once the wrappers are available, any addition or \"plumbing\" to the Java client could be written directly in Java. There might be a bit of JNI code to do here and there I guess, but features I can think so far shouldn't require it.</p>\n<p>From what I understand, JavaCPP goal is to simplify access to native libraries without the need of writing JNI code by ourself or interfacing with proto buffers, is that right? So your idea is to have a fully-compliant C++ client that could be \"wrapped\" in Java as a replacement of the actual client or is it just to replace the JNI bridge? I have no doubt JavaCPP is more convenient that writing JNI code. Proto buffers, on the other hand, is easy to support. Also, how JavaCPP would it handle features that are unique to the Java, such as generics, Javadoc, etc.? IMHO, what really matters in the end is the quality of the interface exposed to the user and not how it was developed.</p>", "body_text": "Hi @saudet, sorry for the delay. I feel that there might be a little bit of misunderstanding here, please let me explain more in details. Sorry for the novel ;)\n\nHad you been given the chance to do it in Java instead of C++, do you think it would have made things easier for you\n\nDefinitely, a challenge I had in C++ was to output Java source code efficiently, which could have been provided out-of-the-box from Java frameworks, such as JavaPoet.\nThe main reason why I had to go with C++ the generator the operation wrappers, as I told @Nicholas-Schaub previously in this thread, is to benefit from operation classification which, at that time, could only be achieved by only linking one core op library at a time to the generator binary and use that library as a package delimiter.  Otherwise you'll end up having all 700+ ops in the same package, which is not convenient. That's the approach the C++ client was taking too. It was a bit hacky, in my opinion, but I'm not sure to see how JavaCPP would have help me doing otherwise here.\nOn this topic though, there have been some updates to this issue. Lately, the TF community has introduced a new layer of abstraction over the core ops definitions, called Api defs, which not only exposes classification information in proto buffers but also allows variation of the API per language for fine-tuning. With this new API framework, the wrapper generator could have been written in Java from the start. Now that there is only #18192 remaining to generator those wrappers, I guess we should continue in the current direction and maybe migrate that code to Java later.\n\nif we could offer developers the option of contributing code in Java instead of having them write most of the plumbing in C++\n\nAnd that is actually already the case. Once the wrappers are available, any addition or \"plumbing\" to the Java client could be written directly in Java. There might be a bit of JNI code to do here and there I guess, but features I can think so far shouldn't require it.\nFrom what I understand, JavaCPP goal is to simplify access to native libraries without the need of writing JNI code by ourself or interfacing with proto buffers, is that right? So your idea is to have a fully-compliant C++ client that could be \"wrapped\" in Java as a replacement of the actual client or is it just to replace the JNI bridge? I have no doubt JavaCPP is more convenient that writing JNI code. Proto buffers, on the other hand, is easy to support. Also, how JavaCPP would it handle features that are unique to the Java, such as generics, Javadoc, etc.? IMHO, what really matters in the end is the quality of the interface exposed to the user and not how it was developed.", "body": "Hi @saudet, sorry for the delay. I feel that there might be a little bit of misunderstanding here, please let me explain more in details. Sorry for the novel ;)\r\n\r\n> Had you been given the chance to do it in Java instead of C++, do you think it would have made things easier for you\r\n\r\nDefinitely, a challenge I had in C++ was to output Java source code efficiently, which could have been provided out-of-the-box from Java frameworks, such as JavaPoet.\r\n\r\nThe main reason why I had to go with C++ the generator the operation wrappers, as I told @Nicholas-Schaub previously in this thread, is to benefit from operation classification which, at that time, could only be achieved by only linking one core op library at a time to the generator binary and use that library as a package delimiter.  Otherwise you'll end up having all 700+ ops in the same package, which is not convenient. That's the approach the C++ client was taking too. It was a bit hacky, in my opinion, but I'm not sure to see how JavaCPP would have help me doing otherwise here. \r\n\r\nOn this topic though, there have been some updates to this issue. Lately, the TF community has introduced a new layer of abstraction over the core ops definitions, called `Api defs`, which not only exposes classification information in proto buffers but also allows variation of the API per language for fine-tuning. With this new API framework, the wrapper generator could have been written in Java from the start. Now that there is only #18192 remaining to generator those wrappers, I guess we should continue in the current direction and maybe migrate that code to Java later.\r\n\r\n > if we could offer developers the option of contributing code in Java instead of having them write most of the plumbing in C++\r\n\r\nAnd that is actually already the case. Once the wrappers are available, any addition or \"plumbing\" to the Java client could be written directly in Java. There might be a bit of JNI code to do here and there I guess, but features I can think so far shouldn't require it.\r\n\r\nFrom what I understand, JavaCPP goal is to simplify access to native libraries without the need of writing JNI code by ourself or interfacing with proto buffers, is that right? So your idea is to have a fully-compliant C++ client that could be \"wrapped\" in Java as a replacement of the actual client or is it just to replace the JNI bridge? I have no doubt JavaCPP is more convenient that writing JNI code. Proto buffers, on the other hand, is easy to support. Also, how JavaCPP would it handle features that are unique to the Java, such as generics, Javadoc, etc.? IMHO, what really matters in the end is the quality of the interface exposed to the user and not how it was developed."}