{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/395722710", "html_url": "https://github.com/tensorflow/tensorflow/issues/11679#issuecomment-395722710", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11679", "id": 395722710, "node_id": "MDEyOklzc3VlQ29tbWVudDM5NTcyMjcxMA==", "user": {"login": "annarailton", "id": 4105011, "node_id": "MDQ6VXNlcjQxMDUwMTE=", "avatar_url": "https://avatars2.githubusercontent.com/u/4105011?v=4", "gravatar_id": "", "url": "https://api.github.com/users/annarailton", "html_url": "https://github.com/annarailton", "followers_url": "https://api.github.com/users/annarailton/followers", "following_url": "https://api.github.com/users/annarailton/following{/other_user}", "gists_url": "https://api.github.com/users/annarailton/gists{/gist_id}", "starred_url": "https://api.github.com/users/annarailton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/annarailton/subscriptions", "organizations_url": "https://api.github.com/users/annarailton/orgs", "repos_url": "https://api.github.com/users/annarailton/repos", "events_url": "https://api.github.com/users/annarailton/events{/privacy}", "received_events_url": "https://api.github.com/users/annarailton/received_events", "type": "User", "site_admin": false}, "created_at": "2018-06-08T10:39:43Z", "updated_at": "2018-06-08T10:39:43Z", "author_association": "NONE", "body_html": "<p>Here's another example with initialisable iterators.</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-c\"><span class=\"pl-c\">#</span> Tensorflow 1.8.0</span>\n<span class=\"pl-k\">import</span> tensorflow <span class=\"pl-k\">as</span> tf\n<span class=\"pl-k\">import</span> numpy <span class=\"pl-k\">as</span> np\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">train</span>(<span class=\"pl-smi\">train_dataset</span>, <span class=\"pl-smi\">test_dataset</span>):\n    <span class=\"pl-s\"><span class=\"pl-pds\">\"\"\"</span></span>\n<span class=\"pl-s\">    Create graph with an Dataset and Iterator and save the model.</span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">    There is some op that is applied to the data from the iterator.</span>\n<span class=\"pl-s\">    <span class=\"pl-pds\">\"\"\"</span></span>\n    iterator_handle <span class=\"pl-k\">=</span> tf.placeholder(tf.string, <span class=\"pl-v\">shape</span><span class=\"pl-k\">=</span>[])\n    tf.add_to_collection(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>iterator_handle<span class=\"pl-pds\">'</span></span>, iterator_handle)\n\n    iterator <span class=\"pl-k\">=</span> tf.data.Iterator.from_string_handle(\n        iterator_handle,\n        train_dataset.output_types,\n        train_dataset.output_shapes)\n    train_iter <span class=\"pl-k\">=</span> train_dataset.make_initializable_iterator()\n    test_iter <span class=\"pl-k\">=</span> test_dataset.make_initializable_iterator()\n    element <span class=\"pl-k\">=</span> iterator.get_next()\n\n    some_op <span class=\"pl-k\">=</span> tf.multiply(element, <span class=\"pl-c1\">0.5</span>)\n    tf.add_to_collection(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>some_op<span class=\"pl-pds\">'</span></span>, some_op)\n    v <span class=\"pl-k\">=</span> tf.get_variable(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>v<span class=\"pl-pds\">'</span></span>, <span class=\"pl-v\">initializer</span><span class=\"pl-k\">=</span>tf.zeros([]))\n\n    saver <span class=\"pl-k\">=</span> tf.train.Saver()\n\n    <span class=\"pl-k\">with</span> tf.Session() <span class=\"pl-k\">as</span> sess:\n        sess.run(tf.global_variables_initializer())\n\n        train_handle <span class=\"pl-k\">=</span> sess.run(train_iter.string_handle())\n        test_handle <span class=\"pl-k\">=</span> sess.run(test_iter.string_handle())\n\n        <span class=\"pl-c\"><span class=\"pl-c\">#</span> Run data iterator initialisation</span>\n        sess.run(train_iter.initializer)\n        sess.run(test_iter.initializer)\n\n        <span class=\"pl-c\"><span class=\"pl-c\">#</span> \"Training\"</span>\n        <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Training<span class=\"pl-pds\">\"</span></span>)\n        <span class=\"pl-k\">while</span> <span class=\"pl-c1\">True</span>:\n            <span class=\"pl-k\">try</span>:\n                <span class=\"pl-c1\">print</span>(sess.run(some_op,\n                    <span class=\"pl-v\">feed_dict</span><span class=\"pl-k\">=</span>{iterator_handle: train_handle}))\n            <span class=\"pl-k\">except</span> tf.errors.OutOfRangeError:\n                <span class=\"pl-k\">break</span>\n\n        <span class=\"pl-c\"><span class=\"pl-c\">#</span> \"Test evaluation\"</span>\n        <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Testing<span class=\"pl-pds\">\"</span></span>)\n        <span class=\"pl-k\">while</span> <span class=\"pl-c1\">True</span>:\n            <span class=\"pl-k\">try</span>:\n                <span class=\"pl-c1\">print</span>(sess.run(some_op,\n                    <span class=\"pl-v\">feed_dict</span><span class=\"pl-k\">=</span>{iterator_handle: test_handle}))\n            <span class=\"pl-k\">except</span> tf.errors.OutOfRangeError:\n                <span class=\"pl-k\">break</span>\n\n        saver.save(sess, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>checkpoints/fufu<span class=\"pl-pds\">'</span></span>)\n\n<span class=\"pl-k\">def</span> <span class=\"pl-c1\">eval</span>(<span class=\"pl-smi\">dataset</span>):\n    <span class=\"pl-s\"><span class=\"pl-pds\">\"\"\"</span>Restore the model from file and pass some new data through it<span class=\"pl-pds\">\"\"\"</span></span>\n    <span class=\"pl-k\">with</span> tf.Session() <span class=\"pl-k\">as</span> sess:\n        saver <span class=\"pl-k\">=</span> tf.train.import_meta_graph(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>checkpoints/fufu.meta<span class=\"pl-pds\">'</span></span>)\n        saver.restore(sess, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>checkpoints/fufu<span class=\"pl-pds\">'</span></span>)\n        iterator_handle <span class=\"pl-k\">=</span> tf.get_collection(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>iterator_handle<span class=\"pl-pds\">'</span></span>)[<span class=\"pl-c1\">0</span>]\n        <span class=\"pl-c\"><span class=\"pl-c\">#</span> Make new iterator</span>\n        iterator <span class=\"pl-k\">=</span> dataset.make_one_shot_iterator()\n        new_handle <span class=\"pl-k\">=</span> sess.run(iterator.string_handle())\n        <span class=\"pl-c\"><span class=\"pl-c\">#</span> Don't need to call iterator.get_next() again as `some_op` will use</span>\n        <span class=\"pl-c\"><span class=\"pl-c\">#</span> restored `element` </span>\n        some_op <span class=\"pl-k\">=</span> tf.get_collection(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>some_op<span class=\"pl-pds\">'</span></span>)[<span class=\"pl-c1\">0</span>]\n\n        <span class=\"pl-c\"><span class=\"pl-c\">#</span> \"Further evaluation\"</span>\n        <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>More testing<span class=\"pl-pds\">\"</span></span>)\n        <span class=\"pl-k\">while</span> <span class=\"pl-c1\">True</span>:\n            <span class=\"pl-k\">try</span>:\n                <span class=\"pl-c1\">print</span>(sess.run(some_op,\n                    <span class=\"pl-v\">feed_dict</span><span class=\"pl-k\">=</span>{iterator_handle: new_handle}))\n            <span class=\"pl-k\">except</span> tf.errors.OutOfRangeError:\n                <span class=\"pl-k\">break</span>\n\n<span class=\"pl-k\">if</span> <span class=\"pl-c1\">__name__</span> <span class=\"pl-k\">==</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>__main__<span class=\"pl-pds\">'</span></span>:\n\n    train_dataset <span class=\"pl-k\">=</span> tf.data.Dataset.from_tensor_slices(\n        tf.constant(np.random.randint(<span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">100</span>, (<span class=\"pl-c1\">5</span>, <span class=\"pl-c1\">2</span>)), <span class=\"pl-v\">dtype</span><span class=\"pl-k\">=</span>tf.float32))\n    test_dataset <span class=\"pl-k\">=</span> tf.data.Dataset.from_tensor_slices(\n        tf.constant(np.random.randint(<span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">100</span>, (<span class=\"pl-c1\">2</span>, <span class=\"pl-c1\">2</span>)), <span class=\"pl-v\">dtype</span><span class=\"pl-k\">=</span>tf.float32))\n\n    train(train_dataset, test_dataset)\n\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> Now want to evaluate the results of another test dataset</span>\n    another_test_dataset <span class=\"pl-k\">=</span> tf.data.Dataset.from_tensor_slices(\n        tf.constant(np.random.randint(<span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">100</span>, (<span class=\"pl-c1\">4</span>, <span class=\"pl-c1\">2</span>)), <span class=\"pl-v\">dtype</span><span class=\"pl-k\">=</span>tf.float32))\n    <span class=\"pl-c1\">eval</span>(another_test_dataset)</pre></div>", "body_text": "Here's another example with initialisable iterators.\n# Tensorflow 1.8.0\nimport tensorflow as tf\nimport numpy as np\n\ndef train(train_dataset, test_dataset):\n    \"\"\"\n    Create graph with an Dataset and Iterator and save the model.\n\n    There is some op that is applied to the data from the iterator.\n    \"\"\"\n    iterator_handle = tf.placeholder(tf.string, shape=[])\n    tf.add_to_collection('iterator_handle', iterator_handle)\n\n    iterator = tf.data.Iterator.from_string_handle(\n        iterator_handle,\n        train_dataset.output_types,\n        train_dataset.output_shapes)\n    train_iter = train_dataset.make_initializable_iterator()\n    test_iter = test_dataset.make_initializable_iterator()\n    element = iterator.get_next()\n\n    some_op = tf.multiply(element, 0.5)\n    tf.add_to_collection('some_op', some_op)\n    v = tf.get_variable('v', initializer=tf.zeros([]))\n\n    saver = tf.train.Saver()\n\n    with tf.Session() as sess:\n        sess.run(tf.global_variables_initializer())\n\n        train_handle = sess.run(train_iter.string_handle())\n        test_handle = sess.run(test_iter.string_handle())\n\n        # Run data iterator initialisation\n        sess.run(train_iter.initializer)\n        sess.run(test_iter.initializer)\n\n        # \"Training\"\n        print(\"Training\")\n        while True:\n            try:\n                print(sess.run(some_op,\n                    feed_dict={iterator_handle: train_handle}))\n            except tf.errors.OutOfRangeError:\n                break\n\n        # \"Test evaluation\"\n        print(\"Testing\")\n        while True:\n            try:\n                print(sess.run(some_op,\n                    feed_dict={iterator_handle: test_handle}))\n            except tf.errors.OutOfRangeError:\n                break\n\n        saver.save(sess, 'checkpoints/fufu')\n\ndef eval(dataset):\n    \"\"\"Restore the model from file and pass some new data through it\"\"\"\n    with tf.Session() as sess:\n        saver = tf.train.import_meta_graph('checkpoints/fufu.meta')\n        saver.restore(sess, 'checkpoints/fufu')\n        iterator_handle = tf.get_collection('iterator_handle')[0]\n        # Make new iterator\n        iterator = dataset.make_one_shot_iterator()\n        new_handle = sess.run(iterator.string_handle())\n        # Don't need to call iterator.get_next() again as `some_op` will use\n        # restored `element` \n        some_op = tf.get_collection('some_op')[0]\n\n        # \"Further evaluation\"\n        print(\"More testing\")\n        while True:\n            try:\n                print(sess.run(some_op,\n                    feed_dict={iterator_handle: new_handle}))\n            except tf.errors.OutOfRangeError:\n                break\n\nif __name__ == '__main__':\n\n    train_dataset = tf.data.Dataset.from_tensor_slices(\n        tf.constant(np.random.randint(0, 100, (5, 2)), dtype=tf.float32))\n    test_dataset = tf.data.Dataset.from_tensor_slices(\n        tf.constant(np.random.randint(0, 100, (2, 2)), dtype=tf.float32))\n\n    train(train_dataset, test_dataset)\n\n    # Now want to evaluate the results of another test dataset\n    another_test_dataset = tf.data.Dataset.from_tensor_slices(\n        tf.constant(np.random.randint(0, 100, (4, 2)), dtype=tf.float32))\n    eval(another_test_dataset)", "body": "Here's another example with initialisable iterators.\r\n\r\n```python\r\n# Tensorflow 1.8.0\r\nimport tensorflow as tf\r\nimport numpy as np\r\n\r\ndef train(train_dataset, test_dataset):\r\n    \"\"\"\r\n    Create graph with an Dataset and Iterator and save the model.\r\n\r\n    There is some op that is applied to the data from the iterator.\r\n    \"\"\"\r\n    iterator_handle = tf.placeholder(tf.string, shape=[])\r\n    tf.add_to_collection('iterator_handle', iterator_handle)\r\n\r\n    iterator = tf.data.Iterator.from_string_handle(\r\n        iterator_handle,\r\n        train_dataset.output_types,\r\n        train_dataset.output_shapes)\r\n    train_iter = train_dataset.make_initializable_iterator()\r\n    test_iter = test_dataset.make_initializable_iterator()\r\n    element = iterator.get_next()\r\n\r\n    some_op = tf.multiply(element, 0.5)\r\n    tf.add_to_collection('some_op', some_op)\r\n    v = tf.get_variable('v', initializer=tf.zeros([]))\r\n\r\n    saver = tf.train.Saver()\r\n\r\n    with tf.Session() as sess:\r\n        sess.run(tf.global_variables_initializer())\r\n\r\n        train_handle = sess.run(train_iter.string_handle())\r\n        test_handle = sess.run(test_iter.string_handle())\r\n\r\n        # Run data iterator initialisation\r\n        sess.run(train_iter.initializer)\r\n        sess.run(test_iter.initializer)\r\n\r\n        # \"Training\"\r\n        print(\"Training\")\r\n        while True:\r\n            try:\r\n                print(sess.run(some_op,\r\n                    feed_dict={iterator_handle: train_handle}))\r\n            except tf.errors.OutOfRangeError:\r\n                break\r\n\r\n        # \"Test evaluation\"\r\n        print(\"Testing\")\r\n        while True:\r\n            try:\r\n                print(sess.run(some_op,\r\n                    feed_dict={iterator_handle: test_handle}))\r\n            except tf.errors.OutOfRangeError:\r\n                break\r\n\r\n        saver.save(sess, 'checkpoints/fufu')\r\n\r\ndef eval(dataset):\r\n    \"\"\"Restore the model from file and pass some new data through it\"\"\"\r\n    with tf.Session() as sess:\r\n        saver = tf.train.import_meta_graph('checkpoints/fufu.meta')\r\n        saver.restore(sess, 'checkpoints/fufu')\r\n        iterator_handle = tf.get_collection('iterator_handle')[0]\r\n        # Make new iterator\r\n        iterator = dataset.make_one_shot_iterator()\r\n        new_handle = sess.run(iterator.string_handle())\r\n        # Don't need to call iterator.get_next() again as `some_op` will use\r\n        # restored `element` \r\n        some_op = tf.get_collection('some_op')[0]\r\n\r\n        # \"Further evaluation\"\r\n        print(\"More testing\")\r\n        while True:\r\n            try:\r\n                print(sess.run(some_op,\r\n                    feed_dict={iterator_handle: new_handle}))\r\n            except tf.errors.OutOfRangeError:\r\n                break\r\n\r\nif __name__ == '__main__':\r\n\r\n    train_dataset = tf.data.Dataset.from_tensor_slices(\r\n        tf.constant(np.random.randint(0, 100, (5, 2)), dtype=tf.float32))\r\n    test_dataset = tf.data.Dataset.from_tensor_slices(\r\n        tf.constant(np.random.randint(0, 100, (2, 2)), dtype=tf.float32))\r\n\r\n    train(train_dataset, test_dataset)\r\n\r\n    # Now want to evaluate the results of another test dataset\r\n    another_test_dataset = tf.data.Dataset.from_tensor_slices(\r\n        tf.constant(np.random.randint(0, 100, (4, 2)), dtype=tf.float32))\r\n    eval(another_test_dataset)\r\n```"}