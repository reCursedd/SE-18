{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11727", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11727/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11727/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11727/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/11727", "id": 245249629, "node_id": "MDU6SXNzdWUyNDUyNDk2Mjk=", "number": 11727, "title": "tf.one_hot indices out of bound", "user": {"login": "TimZaman", "id": 7721540, "node_id": "MDQ6VXNlcjc3MjE1NDA=", "avatar_url": "https://avatars0.githubusercontent.com/u/7721540?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimZaman", "html_url": "https://github.com/TimZaman", "followers_url": "https://api.github.com/users/TimZaman/followers", "following_url": "https://api.github.com/users/TimZaman/following{/other_user}", "gists_url": "https://api.github.com/users/TimZaman/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimZaman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimZaman/subscriptions", "organizations_url": "https://api.github.com/users/TimZaman/orgs", "repos_url": "https://api.github.com/users/TimZaman/repos", "events_url": "https://api.github.com/users/TimZaman/events{/privacy}", "received_events_url": "https://api.github.com/users/TimZaman/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2017-07-25T00:09:14Z", "updated_at": "2017-07-25T00:25:03Z", "closed_at": "2017-07-25T00:25:03Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Hi.</p>\n<p>I have ran into some nasty indexing bugs, which weren't caught by TF. I investigated and found the following behaviour:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> sess<span class=\"pl-k\">=</span>tf.Session()\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> sess.run(tf.one_hot(tf.constant(<span class=\"pl-c1\">3</span>), <span class=\"pl-c1\">4</span>))\narray([ <span class=\"pl-c1\">0</span>.,  <span class=\"pl-c1\">0</span>.,  <span class=\"pl-c1\">0</span>.,  <span class=\"pl-c1\">1</span>.], <span class=\"pl-v\">dtype</span><span class=\"pl-k\">=</span>float32)\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> sess.run(tf.one_hot(tf.constant(<span class=\"pl-c1\">0</span>), <span class=\"pl-c1\">4</span>))\narray([ <span class=\"pl-c1\">1</span>.,  <span class=\"pl-c1\">0</span>.,  <span class=\"pl-c1\">0</span>.,  <span class=\"pl-c1\">0</span>.], <span class=\"pl-v\">dtype</span><span class=\"pl-k\">=</span>float32)\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> sess.run(tf.one_hot(tf.constant(<span class=\"pl-c1\">4</span>), <span class=\"pl-c1\">4</span>))\narray([ <span class=\"pl-c1\">0</span>.,  <span class=\"pl-c1\">0</span>.,  <span class=\"pl-c1\">0</span>.,  <span class=\"pl-c1\">0</span>.], <span class=\"pl-v\">dtype</span><span class=\"pl-k\">=</span>float32)\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> sess.run(tf.one_hot(tf.constant(<span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>), <span class=\"pl-c1\">4</span>))\narray([ <span class=\"pl-c1\">0</span>.,  <span class=\"pl-c1\">0</span>.,  <span class=\"pl-c1\">0</span>.,  <span class=\"pl-c1\">0</span>.], <span class=\"pl-v\">dtype</span><span class=\"pl-k\">=</span>float32)</pre></div>\n<p>Both overflow and underflow result in a zeroed array. Should this be caught, and errors be thrown? If not, why and when would this zeroed behaviour make sense? Or is it costly to check and throw assertions?</p>", "body_text": "Hi.\nI have ran into some nasty indexing bugs, which weren't caught by TF. I investigated and found the following behaviour:\n>>> sess=tf.Session()\n>>> sess.run(tf.one_hot(tf.constant(3), 4))\narray([ 0.,  0.,  0.,  1.], dtype=float32)\n>>> sess.run(tf.one_hot(tf.constant(0), 4))\narray([ 1.,  0.,  0.,  0.], dtype=float32)\n>>> sess.run(tf.one_hot(tf.constant(4), 4))\narray([ 0.,  0.,  0.,  0.], dtype=float32)\n>>> sess.run(tf.one_hot(tf.constant(-1), 4))\narray([ 0.,  0.,  0.,  0.], dtype=float32)\nBoth overflow and underflow result in a zeroed array. Should this be caught, and errors be thrown? If not, why and when would this zeroed behaviour make sense? Or is it costly to check and throw assertions?", "body": "Hi.\r\n\r\nI have ran into some nasty indexing bugs, which weren't caught by TF. I investigated and found the following behaviour:\r\n\r\n```python\r\n>>> sess=tf.Session()\r\n>>> sess.run(tf.one_hot(tf.constant(3), 4))\r\narray([ 0.,  0.,  0.,  1.], dtype=float32)\r\n>>> sess.run(tf.one_hot(tf.constant(0), 4))\r\narray([ 1.,  0.,  0.,  0.], dtype=float32)\r\n>>> sess.run(tf.one_hot(tf.constant(4), 4))\r\narray([ 0.,  0.,  0.,  0.], dtype=float32)\r\n>>> sess.run(tf.one_hot(tf.constant(-1), 4))\r\narray([ 0.,  0.,  0.,  0.], dtype=float32)\r\n```\r\n\r\nBoth overflow and underflow result in a zeroed array. Should this be caught, and errors be thrown? If not, why and when would this zeroed behaviour make sense? Or is it costly to check and throw assertions?\r\n"}