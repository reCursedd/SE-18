{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/1388", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/1388/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/1388/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/1388/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/1388", "id": 138512276, "node_id": "MDU6SXNzdWUxMzg1MTIyNzY=", "number": 1388, "title": "Potential bug: Gradients currently flow through variables that are fed", "user": {"login": "rdipietro", "id": 5150559, "node_id": "MDQ6VXNlcjUxNTA1NTk=", "avatar_url": "https://avatars1.githubusercontent.com/u/5150559?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rdipietro", "html_url": "https://github.com/rdipietro", "followers_url": "https://api.github.com/users/rdipietro/followers", "following_url": "https://api.github.com/users/rdipietro/following{/other_user}", "gists_url": "https://api.github.com/users/rdipietro/gists{/gist_id}", "starred_url": "https://api.github.com/users/rdipietro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rdipietro/subscriptions", "organizations_url": "https://api.github.com/users/rdipietro/orgs", "repos_url": "https://api.github.com/users/rdipietro/repos", "events_url": "https://api.github.com/users/rdipietro/events{/privacy}", "received_events_url": "https://api.github.com/users/rdipietro/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2016-03-04T16:08:34Z", "updated_at": "2016-03-04T18:11:11Z", "closed_at": "2016-03-04T16:27:14Z", "author_association": "CONTRIBUTOR", "body_html": "<pre><code>x = tf.Variable(1.0)\ny = 2*x\nz = 3*y\ndzdx, = tf.gradients(z, x)\n\nsess.run(tf.initialize_all_variables())\nprint(sess.run([z, dzdx], feed_dict={y: 10.0}))\n\n# Result: z = 30.0, dzdx = 6.0\n</code></pre>\n<p>To me this seems like a bug: the only reasonable behavior here seems to be to treat <code>y</code> as constant, so that <code>dzdx</code> is 0.0. This would let us feed parts of models when needed, in turn automatically shutting off all gradient updates with respect to the parameters that would have been responsible for generating these fed values.</p>\n<p>This would be a nice thing to have in my current use case. If we want to perform iterative optimization with respect to two parameter sets, we would like to feed results from set 1 and optimize set 2; feed results from set 2 and optimize set 1; etc.</p>\n<p>Is the current behavior intended and/or useful in some use cases? If not, can we fix this?</p>", "body_text": "x = tf.Variable(1.0)\ny = 2*x\nz = 3*y\ndzdx, = tf.gradients(z, x)\n\nsess.run(tf.initialize_all_variables())\nprint(sess.run([z, dzdx], feed_dict={y: 10.0}))\n\n# Result: z = 30.0, dzdx = 6.0\n\nTo me this seems like a bug: the only reasonable behavior here seems to be to treat y as constant, so that dzdx is 0.0. This would let us feed parts of models when needed, in turn automatically shutting off all gradient updates with respect to the parameters that would have been responsible for generating these fed values.\nThis would be a nice thing to have in my current use case. If we want to perform iterative optimization with respect to two parameter sets, we would like to feed results from set 1 and optimize set 2; feed results from set 2 and optimize set 1; etc.\nIs the current behavior intended and/or useful in some use cases? If not, can we fix this?", "body": "```\nx = tf.Variable(1.0)\ny = 2*x\nz = 3*y\ndzdx, = tf.gradients(z, x)\n\nsess.run(tf.initialize_all_variables())\nprint(sess.run([z, dzdx], feed_dict={y: 10.0}))\n\n# Result: z = 30.0, dzdx = 6.0\n```\n\nTo me this seems like a bug: the only reasonable behavior here seems to be to treat `y` as constant, so that `dzdx` is 0.0. This would let us feed parts of models when needed, in turn automatically shutting off all gradient updates with respect to the parameters that would have been responsible for generating these fed values.\n\nThis would be a nice thing to have in my current use case. If we want to perform iterative optimization with respect to two parameter sets, we would like to feed results from set 1 and optimize set 2; feed results from set 2 and optimize set 1; etc.\n\nIs the current behavior intended and/or useful in some use cases? If not, can we fix this?\n"}