{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/390769192", "html_url": "https://github.com/tensorflow/tensorflow/pull/19423#issuecomment-390769192", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/19423", "id": 390769192, "node_id": "MDEyOklzc3VlQ29tbWVudDM5MDc2OTE5Mg==", "user": {"login": "m3bm3b", "id": 10168793, "node_id": "MDQ6VXNlcjEwMTY4Nzkz", "avatar_url": "https://avatars0.githubusercontent.com/u/10168793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m3bm3b", "html_url": "https://github.com/m3bm3b", "followers_url": "https://api.github.com/users/m3bm3b/followers", "following_url": "https://api.github.com/users/m3bm3b/following{/other_user}", "gists_url": "https://api.github.com/users/m3bm3b/gists{/gist_id}", "starred_url": "https://api.github.com/users/m3bm3b/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m3bm3b/subscriptions", "organizations_url": "https://api.github.com/users/m3bm3b/orgs", "repos_url": "https://api.github.com/users/m3bm3b/repos", "events_url": "https://api.github.com/users/m3bm3b/events{/privacy}", "received_events_url": "https://api.github.com/users/m3bm3b/received_events", "type": "User", "site_admin": false}, "created_at": "2018-05-21T20:16:21Z", "updated_at": "2018-05-21T20:16:21Z", "author_association": "NONE", "body_html": "<p>I haven't looked deeply at the code, but here are a few intial comments on the<br>\nchange description and the interface.</p>\n<hr>\n<p>You don't give any rationale or justification in the change description.<br>\nBecause it's so hard to remove things, I recommend not adding something new<br>\nuntil you can point to where you'd use it and explain why this is the mechanism<br>\nthat best fits the task.  Ideally, there would be more than one place<br>\nwhere the new thing could be applied usefully.</p>\n<hr>\n<p>Some of the comments say \"critical section\" where you probably mean the name of<br>\nthe new type.  Examples:<br>\ntensorflow/contrib/framework/python/ops/condition_variable_ops.py, line 35<br>\ntensorflow/contrib/framework/python/ops/condition_variable_test.py, line 15<br>\nI don't know whether there are others.</p>\n<hr>\n<p>You say:</p>\n<blockquote>\n<p>the Wait on the CV doesn't release a lock on a mutex or CriticalSection<br>\nobject (the way a condition_variable does does in c++)</p>\n</blockquote>\n<p>In that case, I think ConditionVariable is a confusing name for this type.<br>\nGiven what I suspect it does, I recommend something like \"Notification\".</p>\n<p>Rationale:</p>\n<p>The phrase \"condition variable\" is not just the name of a type in C++.  It's a<br>\ntechnical term, in use since the 1960s, and widely known by programmers.<br>\n(They appear in the APIs for POSIX, Win32, Java, and C++.)  The term refers to a<br>\nparticular mechanism that allows the client to wait for an arbitrary predicate<br>\nto become true, provided the predicate is a function of state modified only<br>\nwith an associated critical section (implemented by a monitor or mutex).  They<br>\nmake no sense without that connection to a critical section.</p>\n<p>\"ConditionVariable\" is particularly confusing in this context because you have<br>\n\"CriticalSection\", and yet this new mechanism doesn't seem to interact with it<br>\nin the expected way.</p>\n<p>To get an idea for how confusing this feels, imagine<br>\nsomeone had created a SuffixTree that was merely a tree that contained<br>\nsuffixes, or a SkipList that was merely a list that contained skip distances,<br>\nor a HashTable that was merely a vector of hash values.   You might be able to<br>\njustify such names but they would still create confusion.</p>\n<hr>\n<p>It seems odd to have a routine called \"notify\" that does not itself<br>\nnotify anything, but instead returns something that does.<br>\nIt's especially odd to have a spec that says:<br>\nNotify all waiters on this ConditionVariable.<br>\nwhen the return value is specified as<br>\nAn <code>Operation</code> that, when executed, notifies all waiters.</p>\n<p>Shouldn't the spec be, instead:<br>\nReturn an Operation that, when executed, notifies all waiters.</p>\n<hr>\n<p>From the comments in<br>\ntensorflow/contrib/framework/python/ops/condition_variable_ops.py<br>\nI can't tell what it means to \"wait\" on this resource, or to \"notify\" it.</p>\n<p>For example:</p>\n<ul>\n<li>Does the resource have (predicate-related) state (like a Notification in<br>\ntensorflow/core/platform/default/notification.h) or not (like a traditional<br>\ncondition variable)?</li>\n<li>If there's state, can it be reset (like a binary sempaphore),<br>\nor not (like a Notification)?</li>\n<li>If there's no (predicate-related) state, what substitutes for the atomicity<br>\nguarantee of the wait operation of a traditional condition variable?  (That<br>\nis the key part of the spec that allows a condition variable to work even<br>\nthough it has no predicate-related state.)</li>\n</ul>\n<p>If there's no state, I would make the spec of notify say:<br>\nall current waiters<br>\nIf there's state and it can be reset, I would say:<br>\nall current and future waiters until the state is reset<br>\nIf there's state and it cannot be reset, I would say:<br>\nall current and future waiters</p>", "body_text": "I haven't looked deeply at the code, but here are a few intial comments on the\nchange description and the interface.\n\nYou don't give any rationale or justification in the change description.\nBecause it's so hard to remove things, I recommend not adding something new\nuntil you can point to where you'd use it and explain why this is the mechanism\nthat best fits the task.  Ideally, there would be more than one place\nwhere the new thing could be applied usefully.\n\nSome of the comments say \"critical section\" where you probably mean the name of\nthe new type.  Examples:\ntensorflow/contrib/framework/python/ops/condition_variable_ops.py, line 35\ntensorflow/contrib/framework/python/ops/condition_variable_test.py, line 15\nI don't know whether there are others.\n\nYou say:\n\nthe Wait on the CV doesn't release a lock on a mutex or CriticalSection\nobject (the way a condition_variable does does in c++)\n\nIn that case, I think ConditionVariable is a confusing name for this type.\nGiven what I suspect it does, I recommend something like \"Notification\".\nRationale:\nThe phrase \"condition variable\" is not just the name of a type in C++.  It's a\ntechnical term, in use since the 1960s, and widely known by programmers.\n(They appear in the APIs for POSIX, Win32, Java, and C++.)  The term refers to a\nparticular mechanism that allows the client to wait for an arbitrary predicate\nto become true, provided the predicate is a function of state modified only\nwith an associated critical section (implemented by a monitor or mutex).  They\nmake no sense without that connection to a critical section.\n\"ConditionVariable\" is particularly confusing in this context because you have\n\"CriticalSection\", and yet this new mechanism doesn't seem to interact with it\nin the expected way.\nTo get an idea for how confusing this feels, imagine\nsomeone had created a SuffixTree that was merely a tree that contained\nsuffixes, or a SkipList that was merely a list that contained skip distances,\nor a HashTable that was merely a vector of hash values.   You might be able to\njustify such names but they would still create confusion.\n\nIt seems odd to have a routine called \"notify\" that does not itself\nnotify anything, but instead returns something that does.\nIt's especially odd to have a spec that says:\nNotify all waiters on this ConditionVariable.\nwhen the return value is specified as\nAn Operation that, when executed, notifies all waiters.\nShouldn't the spec be, instead:\nReturn an Operation that, when executed, notifies all waiters.\n\nFrom the comments in\ntensorflow/contrib/framework/python/ops/condition_variable_ops.py\nI can't tell what it means to \"wait\" on this resource, or to \"notify\" it.\nFor example:\n\nDoes the resource have (predicate-related) state (like a Notification in\ntensorflow/core/platform/default/notification.h) or not (like a traditional\ncondition variable)?\nIf there's state, can it be reset (like a binary sempaphore),\nor not (like a Notification)?\nIf there's no (predicate-related) state, what substitutes for the atomicity\nguarantee of the wait operation of a traditional condition variable?  (That\nis the key part of the spec that allows a condition variable to work even\nthough it has no predicate-related state.)\n\nIf there's no state, I would make the spec of notify say:\nall current waiters\nIf there's state and it can be reset, I would say:\nall current and future waiters until the state is reset\nIf there's state and it cannot be reset, I would say:\nall current and future waiters", "body": "I haven't looked deeply at the code, but here are a few intial comments on the\r\nchange description and the interface.\r\n\r\n\r\n---\r\n\r\nYou don't give any rationale or justification in the change description.   \r\nBecause it's so hard to remove things, I recommend not adding something new\r\nuntil you can point to where you'd use it and explain why this is the mechanism \r\nthat best fits the task.  Ideally, there would be more than one place \r\nwhere the new thing could be applied usefully.\r\n\r\n---\r\n\r\nSome of the comments say \"critical section\" where you probably mean the name of \r\nthe new type.  Examples:\r\n  tensorflow/contrib/framework/python/ops/condition_variable_ops.py, line 35 \r\n  tensorflow/contrib/framework/python/ops/condition_variable_test.py, line 15 \r\nI don't know whether there are others.\r\n\r\n---\r\n\r\nYou say:\r\n\r\n> the Wait on the CV doesn't release a lock on a mutex or CriticalSection \r\n> object (the way a condition_variable does does in c++)\r\n   \r\nIn that case, I think ConditionVariable is a confusing name for this type.\r\nGiven what I suspect it does, I recommend something like \"Notification\".\r\n\r\nRationale:\r\n\r\nThe phrase \"condition variable\" is not just the name of a type in C++.  It's a\r\ntechnical term, in use since the 1960s, and widely known by programmers.  \r\n(They appear in the APIs for POSIX, Win32, Java, and C++.)  The term refers to a\r\nparticular mechanism that allows the client to wait for an arbitrary predicate\r\nto become true, provided the predicate is a function of state modified only\r\nwith an associated critical section (implemented by a monitor or mutex).  They \r\nmake no sense without that connection to a critical section.\r\n\r\n\"ConditionVariable\" is particularly confusing in this context because you have\r\n\"CriticalSection\", and yet this new mechanism doesn't seem to interact with it\r\nin the expected way.\r\n\r\nTo get an idea for how confusing this feels, imagine\r\nsomeone had created a SuffixTree that was merely a tree that contained\r\nsuffixes, or a SkipList that was merely a list that contained skip distances,\r\nor a HashTable that was merely a vector of hash values.   You might be able to \r\njustify such names but they would still create confusion.\r\n\r\n---\r\n\r\nIt seems odd to have a routine called \"notify\" that does not itself\r\nnotify anything, but instead returns something that does.\r\nIt's especially odd to have a spec that says:\r\n   Notify all waiters on this ConditionVariable.\r\nwhen the return value is specified as\r\n   An `Operation` that, when executed, notifies all waiters.\r\n\r\nShouldn't the spec be, instead:\r\n  Return an Operation that, when executed, notifies all waiters.\r\n\r\n---\r\n\r\nFrom the comments in\r\n  tensorflow/contrib/framework/python/ops/condition_variable_ops.py\r\nI can't tell what it means to \"wait\" on this resource, or to \"notify\" it.\r\n\r\nFor example: \r\n- Does the resource have (predicate-related) state (like a Notification in\r\n  tensorflow/core/platform/default/notification.h) or not (like a traditional\r\n  condition variable)?\r\n- If there's state, can it be reset (like a binary sempaphore),\r\n  or not (like a Notification)?\r\n- If there's no (predicate-related) state, what substitutes for the atomicity\r\n  guarantee of the wait operation of a traditional condition variable?  (That\r\n  is the key part of the spec that allows a condition variable to work even  \r\n  though it has no predicate-related state.)\r\n\r\nIf there's no state, I would make the spec of notify say:\r\n   all current waiters\r\nIf there's state and it can be reset, I would say:\r\n   all current and future waiters until the state is reset\r\nIf there's state and it cannot be reset, I would say:\r\n   all current and future waiters\r\n"}