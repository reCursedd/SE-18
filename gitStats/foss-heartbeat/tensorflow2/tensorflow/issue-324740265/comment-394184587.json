{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/394184587", "html_url": "https://github.com/tensorflow/tensorflow/pull/19423#issuecomment-394184587", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/19423", "id": 394184587, "node_id": "MDEyOklzc3VlQ29tbWVudDM5NDE4NDU4Nw==", "user": {"login": "ebrevdo", "id": 1794715, "node_id": "MDQ6VXNlcjE3OTQ3MTU=", "avatar_url": "https://avatars0.githubusercontent.com/u/1794715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebrevdo", "html_url": "https://github.com/ebrevdo", "followers_url": "https://api.github.com/users/ebrevdo/followers", "following_url": "https://api.github.com/users/ebrevdo/following{/other_user}", "gists_url": "https://api.github.com/users/ebrevdo/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebrevdo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebrevdo/subscriptions", "organizations_url": "https://api.github.com/users/ebrevdo/orgs", "repos_url": "https://api.github.com/users/ebrevdo/repos", "events_url": "https://api.github.com/users/ebrevdo/events{/privacy}", "received_events_url": "https://api.github.com/users/ebrevdo/received_events", "type": "User", "site_admin": false}, "created_at": "2018-06-03T19:17:00Z", "updated_at": "2018-06-03T19:17:00Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=10168793\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/m3bm3b\">@m3bm3b</a> I think this will require waiting until I return before we continue.  Workers are unlikely to deadlock here because the object exists across multiple session.run calls, so even if one worker is waiting while others are allowed to run -- it'll be allowed to run the next time the master notifies.  i.e., this approach allows stragglers to exist, and these stragglers will wait until a later notification.  For now I'll close this PR as I think there are some additional cleanups possible (notably: statefulness can rely on a scalar bool ResourceVariable which provides a notification mechanism).</p>", "body_text": "@m3bm3b I think this will require waiting until I return before we continue.  Workers are unlikely to deadlock here because the object exists across multiple session.run calls, so even if one worker is waiting while others are allowed to run -- it'll be allowed to run the next time the master notifies.  i.e., this approach allows stragglers to exist, and these stragglers will wait until a later notification.  For now I'll close this PR as I think there are some additional cleanups possible (notably: statefulness can rely on a scalar bool ResourceVariable which provides a notification mechanism).", "body": "@m3bm3b I think this will require waiting until I return before we continue.  Workers are unlikely to deadlock here because the object exists across multiple session.run calls, so even if one worker is waiting while others are allowed to run -- it'll be allowed to run the next time the master notifies.  i.e., this approach allows stragglers to exist, and these stragglers will wait until a later notification.  For now I'll close this PR as I think there are some additional cleanups possible (notably: statefulness can rely on a scalar bool ResourceVariable which provides a notification mechanism)."}