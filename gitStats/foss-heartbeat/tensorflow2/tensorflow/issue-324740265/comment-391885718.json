{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/391885718", "html_url": "https://github.com/tensorflow/tensorflow/pull/19423#issuecomment-391885718", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/19423", "id": 391885718, "node_id": "MDEyOklzc3VlQ29tbWVudDM5MTg4NTcxOA==", "user": {"login": "m3bm3b", "id": 10168793, "node_id": "MDQ6VXNlcjEwMTY4Nzkz", "avatar_url": "https://avatars0.githubusercontent.com/u/10168793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m3bm3b", "html_url": "https://github.com/m3bm3b", "followers_url": "https://api.github.com/users/m3bm3b/followers", "following_url": "https://api.github.com/users/m3bm3b/following{/other_user}", "gists_url": "https://api.github.com/users/m3bm3b/gists{/gist_id}", "starred_url": "https://api.github.com/users/m3bm3b/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m3bm3b/subscriptions", "organizations_url": "https://api.github.com/users/m3bm3b/orgs", "repos_url": "https://api.github.com/users/m3bm3b/repos", "events_url": "https://api.github.com/users/m3bm3b/events{/privacy}", "received_events_url": "https://api.github.com/users/m3bm3b/received_events", "type": "User", "site_admin": false}, "created_at": "2018-05-24T22:30:02Z", "updated_at": "2018-05-24T22:30:02Z", "author_association": "NONE", "body_html": "<p>You say that your usage examples are experimental.  Wouldn't it be<br>\nbetter to keep this change in an experimental fork until there's a<br>\nnon-experimental need?</p>\n<p>You mention that others want cancellable timing.  If those are the only<br>\nconfirmed requirements, then I recommend giving a few examples, and for the<br>\nmoment providing <em>just</em> cancellable timing.  It's trivial to add to an<br>\nAPI later.  It's almost impossible to remove anything.<br>\nEach addition of functionality is one more this we must<br>\nmaintain indefinitely.  That's proved crippling over the years in our other<br>\nAPIs.</p>\n<hr>\n<p>I'm quite surprised by the description of Notification.</p>\n<p>You say first:</p>\n<blockquote>\n<p>The object is stateful.  Waiters will pause (or time out) until the<br>\nNotification object is notified via the result of <code>notifier()</code>.  By default,<br>\nnotifying the object atomically releases all waiters, and resets the state.<br>\nAny new <code>wait</code> operations executing after this will go into a waiting state.</p>\n</blockquote>\n<p>This first says the object is <em>stateful</em>, but then goes on to describe a<br>\nwait/notification that is <em>stateless</em>.  It's stateless because the<br>\nNotification doesn't \"remember\" that it has been notified, which is why<br>\nsubsequent attempts to wait will block until another notification event, rather<br>\nthan waking immediately.</p>\n<p>Then you  describes stateful waits, where the fact that the object has been<br>\nnotified is remembered by the object:</p>\n<blockquote>\n<p>Alternatively, executing <code>notifier(immediately_reset=False)</code> will also set the<br>\nstate of the Notification object.  Any <code>wait</code> operations executing after this<br>\nwill immediately continue and will not time out.</p>\n</blockquote>\n<p>So the object seems provides both stateless and stateful synchronization.<br>\nMoreover, the stateful mode can be reset explicitly using resetter().</p>\n<p>That's a lot different semantics.  Not only is it odd not to have a single usage<br>\nmodel that would dictate just one style of use, but to have an object that can<br>\nbe used in multiple different ways makes things harder for future readers to<br>\nunderstand even if any given developer is trying to use it in only one way.<br>\nFor example, suppose you're maintaining someone else's programme, and want to<br>\nknow whether it's possible for the \"notified\" status of some Notification to be<br>\nreset.  The only way to do that is to examine the entire programme (or the<br>\nentire scope where the Notification can be accessed, at least) to verify that no<br>\none ever uses the \"resetter()\" operation.  So sometimes it's better to separate<br>\ndifferent functionality into completely different types, so you can get this<br>\nsort of guarantee with just a glance.</p>\n<p>I was expecting the object to be stateful, and not resettable.  I<br>\nexpected that because it's safer and easier to use, given the other aspects of<br>\nthe design:</p>\n<ul>\n<li>\n<p>Stateless waits are tricky to use correctly unless the synchronization object<br>\ninteracts in special ways with other sycnhronization primitives.  For<br>\nexample, a traditional condition variable is stateless, and the reason<br>\nit's still easy to use is that it interacts in special ways with critical<br>\nsections (mutexes, monitors).  This interaction allows the \"state\" (the wakeup predicate)<br>\nto be held as arbitrary state within the monitor, rather than within the condition variable.<br>\nBut you don't describe any interaction analogous to this for your Notification, so<br>\nI'm confused about how the default, stateless mode of your Notification can be used<br>\nstraightforwardly.</p>\n<p>Consider the example you give on lines 57-77 of notification_ops.py.  In that<br>\nexample, I think the workers wait on n, and the controller notifies n.  But<br>\nif workers and controller run asychronously, I don't see what guarantees that<br>\nthe workers have all gone to sleep on n before the controller runs the<br>\nnotifier.  At least from a naive reading, if a worker performs its<br>\nwait operation after the notification has happened, it would never be woken,<br>\nand thus would deadlock.  Maybe I'm missing something about the setup<br>\nthat guarantees that can't happen, but if so if might be wise to<br>\npoint out why it works.  If instead this example had used<br>\n\"immediatelty_reset=False\", it would be clearer, and I suspect that will<br>\nbe true of most examples.</p>\n</li>\n<li>\n<p>Explicitly resettable waits are hard to use correctly for similar reasons.<br>\nThat's because it's not obvious in general when it's safe to reset the state.<br>\nSynchronization is needed for that, which means you need extra sychronization<br>\nobjects to use your synchronization objects, which is usually sign that your synchronization<br>\nobjects aren't doing what you wanted.<br>\nWhen you really need to reset the \"woken\" state, it's usually better to use a new,<br>\nnon-resettable Notification object, as the machinery for doing that makes it clear<br>\nthat you're waiting for something new.<br>\nThat's why absl's Notification object is stateful and does not have<br>\na reset operation.</p>\n</li>\n</ul>\n<hr>\n<p>You still have a reference to \"critical section tests\" at line 15 of  notification_test.py.<br>\nI suspect you mean \"Motification tests\".</p>", "body_text": "You say that your usage examples are experimental.  Wouldn't it be\nbetter to keep this change in an experimental fork until there's a\nnon-experimental need?\nYou mention that others want cancellable timing.  If those are the only\nconfirmed requirements, then I recommend giving a few examples, and for the\nmoment providing just cancellable timing.  It's trivial to add to an\nAPI later.  It's almost impossible to remove anything.\nEach addition of functionality is one more this we must\nmaintain indefinitely.  That's proved crippling over the years in our other\nAPIs.\n\nI'm quite surprised by the description of Notification.\nYou say first:\n\nThe object is stateful.  Waiters will pause (or time out) until the\nNotification object is notified via the result of notifier().  By default,\nnotifying the object atomically releases all waiters, and resets the state.\nAny new wait operations executing after this will go into a waiting state.\n\nThis first says the object is stateful, but then goes on to describe a\nwait/notification that is stateless.  It's stateless because the\nNotification doesn't \"remember\" that it has been notified, which is why\nsubsequent attempts to wait will block until another notification event, rather\nthan waking immediately.\nThen you  describes stateful waits, where the fact that the object has been\nnotified is remembered by the object:\n\nAlternatively, executing notifier(immediately_reset=False) will also set the\nstate of the Notification object.  Any wait operations executing after this\nwill immediately continue and will not time out.\n\nSo the object seems provides both stateless and stateful synchronization.\nMoreover, the stateful mode can be reset explicitly using resetter().\nThat's a lot different semantics.  Not only is it odd not to have a single usage\nmodel that would dictate just one style of use, but to have an object that can\nbe used in multiple different ways makes things harder for future readers to\nunderstand even if any given developer is trying to use it in only one way.\nFor example, suppose you're maintaining someone else's programme, and want to\nknow whether it's possible for the \"notified\" status of some Notification to be\nreset.  The only way to do that is to examine the entire programme (or the\nentire scope where the Notification can be accessed, at least) to verify that no\none ever uses the \"resetter()\" operation.  So sometimes it's better to separate\ndifferent functionality into completely different types, so you can get this\nsort of guarantee with just a glance.\nI was expecting the object to be stateful, and not resettable.  I\nexpected that because it's safer and easier to use, given the other aspects of\nthe design:\n\n\nStateless waits are tricky to use correctly unless the synchronization object\ninteracts in special ways with other sycnhronization primitives.  For\nexample, a traditional condition variable is stateless, and the reason\nit's still easy to use is that it interacts in special ways with critical\nsections (mutexes, monitors).  This interaction allows the \"state\" (the wakeup predicate)\nto be held as arbitrary state within the monitor, rather than within the condition variable.\nBut you don't describe any interaction analogous to this for your Notification, so\nI'm confused about how the default, stateless mode of your Notification can be used\nstraightforwardly.\nConsider the example you give on lines 57-77 of notification_ops.py.  In that\nexample, I think the workers wait on n, and the controller notifies n.  But\nif workers and controller run asychronously, I don't see what guarantees that\nthe workers have all gone to sleep on n before the controller runs the\nnotifier.  At least from a naive reading, if a worker performs its\nwait operation after the notification has happened, it would never be woken,\nand thus would deadlock.  Maybe I'm missing something about the setup\nthat guarantees that can't happen, but if so if might be wise to\npoint out why it works.  If instead this example had used\n\"immediatelty_reset=False\", it would be clearer, and I suspect that will\nbe true of most examples.\n\n\nExplicitly resettable waits are hard to use correctly for similar reasons.\nThat's because it's not obvious in general when it's safe to reset the state.\nSynchronization is needed for that, which means you need extra sychronization\nobjects to use your synchronization objects, which is usually sign that your synchronization\nobjects aren't doing what you wanted.\nWhen you really need to reset the \"woken\" state, it's usually better to use a new,\nnon-resettable Notification object, as the machinery for doing that makes it clear\nthat you're waiting for something new.\nThat's why absl's Notification object is stateful and does not have\na reset operation.\n\n\n\nYou still have a reference to \"critical section tests\" at line 15 of  notification_test.py.\nI suspect you mean \"Motification tests\".", "body": "You say that your usage examples are experimental.  Wouldn't it be\r\nbetter to keep this change in an experimental fork until there's a\r\nnon-experimental need?  \r\n\r\nYou mention that others want cancellable timing.  If those are the only\r\nconfirmed requirements, then I recommend giving a few examples, and for the \r\nmoment providing _just_ cancellable timing.  It's trivial to add to an\r\nAPI later.  It's almost impossible to remove anything.  \r\nEach addition of functionality is one more this we must \r\nmaintain indefinitely.  That's proved crippling over the years in our other\r\nAPIs.\r\n\r\n------\r\n\r\nI'm quite surprised by the description of Notification.\r\n\r\nYou say first:\r\n> The object is stateful.  Waiters will pause (or time out) until the\r\n> Notification object is notified via the result of `notifier()`.  By default,\r\n> notifying the object atomically releases all waiters, and resets the state.\r\n> Any new `wait` operations executing after this will go into a waiting state.\r\n\r\nThis first says the object is _stateful_, but then goes on to describe a\r\nwait/notification that is _stateless_.  It's stateless because the\r\nNotification doesn't \"remember\" that it has been notified, which is why\r\nsubsequent attempts to wait will block until another notification event, rather\r\nthan waking immediately. \r\n\r\n\r\nThen you  describes stateful waits, where the fact that the object has been\r\nnotified is remembered by the object:\r\n\r\n> Alternatively, executing `notifier(immediately_reset=False)` will also set the\r\n> state of the Notification object.  Any `wait` operations executing after this\r\n> will immediately continue and will not time out.\r\n\r\n\r\nSo the object seems provides both stateless and stateful synchronization.\r\nMoreover, the stateful mode can be reset explicitly using resetter().\r\n\r\nThat's a lot different semantics.  Not only is it odd not to have a single usage\r\nmodel that would dictate just one style of use, but to have an object that can \r\nbe used in multiple different ways makes things harder for future readers to   \r\nunderstand even if any given developer is trying to use it in only one way.\r\nFor example, suppose you're maintaining someone else's programme, and want to\r\nknow whether it's possible for the \"notified\" status of some Notification to be \r\nreset.  The only way to do that is to examine the entire programme (or the\r\nentire scope where the Notification can be accessed, at least) to verify that no\r\none ever uses the \"resetter()\" operation.  So sometimes it's better to separate\r\ndifferent functionality into completely different types, so you can get this\r\nsort of guarantee with just a glance.\r\n\r\n\r\nI was expecting the object to be stateful, and not resettable.  I   \r\nexpected that because it's safer and easier to use, given the other aspects of\r\nthe design:\r\n\r\n- Stateless waits are tricky to use correctly unless the synchronization object\r\n  interacts in special ways with other sycnhronization primitives.  For\r\n  example, a traditional condition variable is stateless, and the reason\r\n  it's still easy to use is that it interacts in special ways with critical \r\n  sections (mutexes, monitors).  This interaction allows the \"state\" (the wakeup predicate)\r\n  to be held as arbitrary state within the monitor, rather than within the condition variable.  \r\n  But you don't describe any interaction analogous to this for your Notification, so\r\n  I'm confused about how the default, stateless mode of your Notification can be used\r\n  straightforwardly.\r\n\r\n  Consider the example you give on lines 57-77 of notification_ops.py.  In that\r\n  example, I think the workers wait on n, and the controller notifies n.  But\r\n  if workers and controller run asychronously, I don't see what guarantees that\r\n  the workers have all gone to sleep on n before the controller runs the\r\n  notifier.  At least from a naive reading, if a worker performs its\r\n  wait operation after the notification has happened, it would never be woken,\r\n  and thus would deadlock.  Maybe I'm missing something about the setup\r\n  that guarantees that can't happen, but if so if might be wise to\r\n  point out why it works.  If instead this example had used\r\n  \"immediatelty_reset=False\", it would be clearer, and I suspect that will\r\n  be true of most examples.\r\n\r\n- Explicitly resettable waits are hard to use correctly for similar reasons.  \r\n  That's because it's not obvious in general when it's safe to reset the state.\r\n  Synchronization is needed for that, which means you need extra sychronization\r\n  objects to use your synchronization objects, which is usually sign that your synchronization\r\n  objects aren't doing what you wanted.\r\n  When you really need to reset the \"woken\" state, it's usually better to use a new, \r\n  non-resettable Notification object, as the machinery for doing that makes it clear \r\n  that you're waiting for something new.\r\nThat's why absl's Notification object is stateful and does not have\r\na reset operation.\r\n\r\n------\r\n\r\nYou still have a reference to \"critical section tests\" at line 15 of  notification_test.py.\r\nI suspect you mean \"Motification tests\".\r\n"}