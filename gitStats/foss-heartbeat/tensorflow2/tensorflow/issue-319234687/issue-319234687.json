{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/19002", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/19002/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/19002/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/19002/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/19002", "id": 319234687, "node_id": "MDU6SXNzdWUzMTkyMzQ2ODc=", "number": 19002, "title": "Could anybody help check this problem? I've been stuck in two days and didn't find the solution.", "user": {"login": "glhfgg1024", "id": 30264480, "node_id": "MDQ6VXNlcjMwMjY0NDgw", "avatar_url": "https://avatars3.githubusercontent.com/u/30264480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/glhfgg1024", "html_url": "https://github.com/glhfgg1024", "followers_url": "https://api.github.com/users/glhfgg1024/followers", "following_url": "https://api.github.com/users/glhfgg1024/following{/other_user}", "gists_url": "https://api.github.com/users/glhfgg1024/gists{/gist_id}", "starred_url": "https://api.github.com/users/glhfgg1024/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/glhfgg1024/subscriptions", "organizations_url": "https://api.github.com/users/glhfgg1024/orgs", "repos_url": "https://api.github.com/users/glhfgg1024/repos", "events_url": "https://api.github.com/users/glhfgg1024/events{/privacy}", "received_events_url": "https://api.github.com/users/glhfgg1024/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 8, "created_at": "2018-05-01T15:39:52Z", "updated_at": "2018-05-01T20:03:08Z", "closed_at": "2018-05-01T18:49:10Z", "author_association": "NONE", "body_html": "<p>I'm using the tf.Dataset API as follows: Suppose I have 10 <code>*.tfrecords</code> files (named <code>trn-001.tfrecords</code>,<code>trn-002.tfrecords</code>,etc.). There are 128 samples in each of these tfrecords. Suppose the samples in the first 5 tfrecords belong to class 0 and the remaining 5 tfrecords belong to class 1. In my case, the data provider should first random select 2 tfrecords for each class from those 5 tfrecords, then select fixed number of samples from each of the selected tfrecords and combine them to generate one balanced batch data to feed into the network for training. For example, for class 0, select <code>trn-000.tfrecords</code> and <code>trn-001.tfrecords</code>; for class 1, select <code>trn-006.tfrecords</code> and <code>trn-009.tfrecords</code>; then for each of the four selected tfrecords, randomly select 1 sample from each of them and combine the <code>1+1+1+1</code> samples to generate one batch data. My script to initialize the dataset operations is like this:</p>\n<pre><code>trn0_filenames = ['trn-000.tfrecords','trn-001.tfrecords','trn-002.tfrecords','trn-003.tfrecords','trn-004.tfrecords']\ntrn1_filenames = ['trn-005.tfrecords','trn-006.tfrecords','trn-007.tfrecords','trn-008.tfrecords','trn-009.tfrecords']\n\nhalf_batch_size = int(BATCH_SIZE / 2)\ntrn0_count = len(trn0_filenames)\ntrn1_count = len(trn1_filenames)\nfeatures0_ops = []\nlabels0_ops = []\nfor trn0_filename in trn0_filenames:\n    feature_op, label_op, = dataset_input_from_tfrecords([trn0_filename], batch_size=1, num_epochs=50000, shuffle=True, image_mean=None)\n    features0_ops.append(feature_op)\n    labels0_ops.append(label_op)\n\nfeatures1_ops = []\nlabels1_ops = []\nfor trn1_filename in trn1_filenames:\n    feature_op, label_op = dataset_input_from_tfrecords([trn1_filename], batch_size=1, num_epochs=50000, shuffle=True, image_mean=None)\n    features1_ops.append(feature_op)\n    label_ops.append(label_op)\n</code></pre>\n<p>Then during training, the script to generate the batch data is like this:</p>\n<pre><code>features = np.zeros((BATCH_SIZE, HEIGHT, WIDTH, 3), dtype=np.float32)\nlabels = np.zeros((BATCH_SIZE,), dtype=np.int64)\n\nwhile not coord.should_stop():\n    ind0 = np.random.choice(trn0_count, half_batch_size)\n    ind1 = np.random.choice(trn1_count, half_batch_size)\n    batch_idx = 0\n    for idx in ind0:\n        temp1,temp2 = sess.run([features0_ops[idx],\n                                            labels0_ops[idx]])\n        features[batch_idx] = temp1[0]\n        labels[batch_idx] = temp2[0]\n        batch_idx+=1\n    for idx in ind1:\n        temp1,temp2 = sess.run([features1_ops[idx],\n                                labels1_ops[idx]])\n        features[batch_idx] = temp1[0]\n        labels[batch_idx] = temp2[0]\n        batch_idx+=1\n</code></pre>\n<p>and then feed the batch data into network for training:</p>\n<pre><code>summary,_,loss_total,loss,loss_reg = sess.run([summary_op, train_op, \n                               loss_total_op,loss_op,loss_reg_op], \n                              feed_dict={x_tensor: features, y_tensor: labels})\n</code></pre>\n<p>The problem is: during training, I found that the memory usage of the process is consistently increasing. Please check the following screenshot. The process 3208 is the running process. At first, the memory usage is about <code>10%</code>, but at the moment when I taken this picture, the memory usage has increased to <code>41.6%</code>. So my question is: is this a memory problem? What's wrong? I cannot find the problem. If the memory usage is increasing to some certain amount, the computer will be halt down then I need to restart.</p>\n<p><a href=\"https://i.stack.imgur.com/WaPkI.png\" rel=\"nofollow\"><img src=\"https://camo.githubusercontent.com/48ab58dca522d13b76ff48ae6c1404e791d236e6/68747470733a2f2f692e737461636b2e696d6775722e636f6d2f5761506b492e706e67\" alt=\"memory usage\" data-canonical-src=\"https://i.stack.imgur.com/WaPkI.png\" style=\"max-width:100%;\"></a></p>", "body_text": "I'm using the tf.Dataset API as follows: Suppose I have 10 *.tfrecords files (named trn-001.tfrecords,trn-002.tfrecords,etc.). There are 128 samples in each of these tfrecords. Suppose the samples in the first 5 tfrecords belong to class 0 and the remaining 5 tfrecords belong to class 1. In my case, the data provider should first random select 2 tfrecords for each class from those 5 tfrecords, then select fixed number of samples from each of the selected tfrecords and combine them to generate one balanced batch data to feed into the network for training. For example, for class 0, select trn-000.tfrecords and trn-001.tfrecords; for class 1, select trn-006.tfrecords and trn-009.tfrecords; then for each of the four selected tfrecords, randomly select 1 sample from each of them and combine the 1+1+1+1 samples to generate one batch data. My script to initialize the dataset operations is like this:\ntrn0_filenames = ['trn-000.tfrecords','trn-001.tfrecords','trn-002.tfrecords','trn-003.tfrecords','trn-004.tfrecords']\ntrn1_filenames = ['trn-005.tfrecords','trn-006.tfrecords','trn-007.tfrecords','trn-008.tfrecords','trn-009.tfrecords']\n\nhalf_batch_size = int(BATCH_SIZE / 2)\ntrn0_count = len(trn0_filenames)\ntrn1_count = len(trn1_filenames)\nfeatures0_ops = []\nlabels0_ops = []\nfor trn0_filename in trn0_filenames:\n    feature_op, label_op, = dataset_input_from_tfrecords([trn0_filename], batch_size=1, num_epochs=50000, shuffle=True, image_mean=None)\n    features0_ops.append(feature_op)\n    labels0_ops.append(label_op)\n\nfeatures1_ops = []\nlabels1_ops = []\nfor trn1_filename in trn1_filenames:\n    feature_op, label_op = dataset_input_from_tfrecords([trn1_filename], batch_size=1, num_epochs=50000, shuffle=True, image_mean=None)\n    features1_ops.append(feature_op)\n    label_ops.append(label_op)\n\nThen during training, the script to generate the batch data is like this:\nfeatures = np.zeros((BATCH_SIZE, HEIGHT, WIDTH, 3), dtype=np.float32)\nlabels = np.zeros((BATCH_SIZE,), dtype=np.int64)\n\nwhile not coord.should_stop():\n    ind0 = np.random.choice(trn0_count, half_batch_size)\n    ind1 = np.random.choice(trn1_count, half_batch_size)\n    batch_idx = 0\n    for idx in ind0:\n        temp1,temp2 = sess.run([features0_ops[idx],\n                                            labels0_ops[idx]])\n        features[batch_idx] = temp1[0]\n        labels[batch_idx] = temp2[0]\n        batch_idx+=1\n    for idx in ind1:\n        temp1,temp2 = sess.run([features1_ops[idx],\n                                labels1_ops[idx]])\n        features[batch_idx] = temp1[0]\n        labels[batch_idx] = temp2[0]\n        batch_idx+=1\n\nand then feed the batch data into network for training:\nsummary,_,loss_total,loss,loss_reg = sess.run([summary_op, train_op, \n                               loss_total_op,loss_op,loss_reg_op], \n                              feed_dict={x_tensor: features, y_tensor: labels})\n\nThe problem is: during training, I found that the memory usage of the process is consistently increasing. Please check the following screenshot. The process 3208 is the running process. At first, the memory usage is about 10%, but at the moment when I taken this picture, the memory usage has increased to 41.6%. So my question is: is this a memory problem? What's wrong? I cannot find the problem. If the memory usage is increasing to some certain amount, the computer will be halt down then I need to restart.", "body": "I'm using the tf.Dataset API as follows: Suppose I have 10 `*.tfrecords` files (named `trn-001.tfrecords`,`trn-002.tfrecords`,etc.). There are 128 samples in each of these tfrecords. Suppose the samples in the first 5 tfrecords belong to class 0 and the remaining 5 tfrecords belong to class 1. In my case, the data provider should first random select 2 tfrecords for each class from those 5 tfrecords, then select fixed number of samples from each of the selected tfrecords and combine them to generate one balanced batch data to feed into the network for training. For example, for class 0, select `trn-000.tfrecords` and `trn-001.tfrecords`; for class 1, select `trn-006.tfrecords` and `trn-009.tfrecords`; then for each of the four selected tfrecords, randomly select 1 sample from each of them and combine the `1+1+1+1` samples to generate one batch data. My script to initialize the dataset operations is like this:\r\n\r\n    trn0_filenames = ['trn-000.tfrecords','trn-001.tfrecords','trn-002.tfrecords','trn-003.tfrecords','trn-004.tfrecords']\r\n    trn1_filenames = ['trn-005.tfrecords','trn-006.tfrecords','trn-007.tfrecords','trn-008.tfrecords','trn-009.tfrecords']\r\n\r\n    half_batch_size = int(BATCH_SIZE / 2)\r\n    trn0_count = len(trn0_filenames)\r\n    trn1_count = len(trn1_filenames)\r\n    features0_ops = []\r\n    labels0_ops = []\r\n    for trn0_filename in trn0_filenames:\r\n        feature_op, label_op, = dataset_input_from_tfrecords([trn0_filename], batch_size=1, num_epochs=50000, shuffle=True, image_mean=None)\r\n        features0_ops.append(feature_op)\r\n        labels0_ops.append(label_op)\r\n    \r\n    features1_ops = []\r\n    labels1_ops = []\r\n    for trn1_filename in trn1_filenames:\r\n        feature_op, label_op = dataset_input_from_tfrecords([trn1_filename], batch_size=1, num_epochs=50000, shuffle=True, image_mean=None)\r\n        features1_ops.append(feature_op)\r\n        label_ops.append(label_op)\r\n\r\nThen during training, the script to generate the batch data is like this:\r\n\r\n    features = np.zeros((BATCH_SIZE, HEIGHT, WIDTH, 3), dtype=np.float32)\r\n    labels = np.zeros((BATCH_SIZE,), dtype=np.int64)\r\n    \r\n    while not coord.should_stop():\r\n        ind0 = np.random.choice(trn0_count, half_batch_size)\r\n        ind1 = np.random.choice(trn1_count, half_batch_size)\r\n        batch_idx = 0\r\n        for idx in ind0:\r\n            temp1,temp2 = sess.run([features0_ops[idx],\r\n                                                labels0_ops[idx]])\r\n            features[batch_idx] = temp1[0]\r\n            labels[batch_idx] = temp2[0]\r\n            batch_idx+=1\r\n        for idx in ind1:\r\n            temp1,temp2 = sess.run([features1_ops[idx],\r\n                                    labels1_ops[idx]])\r\n            features[batch_idx] = temp1[0]\r\n            labels[batch_idx] = temp2[0]\r\n            batch_idx+=1\r\n\r\nand then feed the batch data into network for training:\r\n\r\n    summary,_,loss_total,loss,loss_reg = sess.run([summary_op, train_op, \r\n                                   loss_total_op,loss_op,loss_reg_op], \r\n                                  feed_dict={x_tensor: features, y_tensor: labels})\r\n\r\n\r\nThe problem is: during training, I found that the memory usage of the process is consistently increasing. Please check the following screenshot. The process 3208 is the running process. At first, the memory usage is about `10%`, but at the moment when I taken this picture, the memory usage has increased to `41.6%`. So my question is: is this a memory problem? What's wrong? I cannot find the problem. If the memory usage is increasing to some certain amount, the computer will be halt down then I need to restart.\r\n\r\n[![memory usage][1]][1]\r\n\r\n\r\n\r\n  [1]: https://i.stack.imgur.com/WaPkI.png"}