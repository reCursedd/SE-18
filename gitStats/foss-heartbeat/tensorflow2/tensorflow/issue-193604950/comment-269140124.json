{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/269140124", "html_url": "https://github.com/tensorflow/tensorflow/issues/6095#issuecomment-269140124", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/6095", "id": 269140124, "node_id": "MDEyOklzc3VlQ29tbWVudDI2OTE0MDEyNA==", "user": {"login": "tesfaldet", "id": 5014902, "node_id": "MDQ6VXNlcjUwMTQ5MDI=", "avatar_url": "https://avatars3.githubusercontent.com/u/5014902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesfaldet", "html_url": "https://github.com/tesfaldet", "followers_url": "https://api.github.com/users/tesfaldet/followers", "following_url": "https://api.github.com/users/tesfaldet/following{/other_user}", "gists_url": "https://api.github.com/users/tesfaldet/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesfaldet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesfaldet/subscriptions", "organizations_url": "https://api.github.com/users/tesfaldet/orgs", "repos_url": "https://api.github.com/users/tesfaldet/repos", "events_url": "https://api.github.com/users/tesfaldet/events{/privacy}", "received_events_url": "https://api.github.com/users/tesfaldet/received_events", "type": "User", "site_admin": false}, "created_at": "2016-12-25T22:34:43Z", "updated_at": "2016-12-25T22:38:24Z", "author_association": "NONE", "body_html": "<p>For what it's worth, I managed to implement two versions of atan2. One that follows the opencv style (returns degrees), and another that uses tensorflow's atan function (returns rads).</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">def</span> <span class=\"pl-en\">atan2</span>(<span class=\"pl-smi\">y</span>, <span class=\"pl-smi\">x</span>):\n    angle <span class=\"pl-k\">=</span> tf.select(tf.greater(x, <span class=\"pl-c1\">0.0</span>), tf.atan(y <span class=\"pl-k\">/</span> x), tf.zeros_like(x))\n    angle <span class=\"pl-k\">=</span> tf.select(tf.greater(y, <span class=\"pl-c1\">0.0</span>), <span class=\"pl-c1\">0.5</span> <span class=\"pl-k\">*</span> np.pi <span class=\"pl-k\">-</span> tf.atan(x <span class=\"pl-k\">/</span> y), angle)\n    angle <span class=\"pl-k\">=</span> tf.select(tf.less(y, <span class=\"pl-c1\">0.0</span>), <span class=\"pl-k\">-</span><span class=\"pl-c1\">0.5</span> <span class=\"pl-k\">*</span> np.pi <span class=\"pl-k\">-</span> tf.atan(x <span class=\"pl-k\">/</span> y), angle)\n    angle <span class=\"pl-k\">=</span> tf.select(tf.less(x, <span class=\"pl-c1\">0.0</span>), tf.atan(y <span class=\"pl-k\">/</span> x) <span class=\"pl-k\">+</span> np.pi, angle)\n    angle <span class=\"pl-k\">=</span> tf.select(tf.logical_and(tf.equal(x, <span class=\"pl-c1\">0.0</span>), tf.equal(y, <span class=\"pl-c1\">0.0</span>)),\n                      np.nan <span class=\"pl-k\">*</span> tf.zeros_like(x), angle)\n\n    indices <span class=\"pl-k\">=</span> tf.where(tf.less(angle, <span class=\"pl-c1\">0.0</span>))\n    updated_values <span class=\"pl-k\">=</span> tf.gather_nd(angle, indices) <span class=\"pl-k\">+</span> (<span class=\"pl-c1\">2</span> <span class=\"pl-k\">*</span> np.pi)\n    update <span class=\"pl-k\">=</span> tf.SparseTensor(indices, updated_values, angle.get_shape())\n    update_dense <span class=\"pl-k\">=</span> tf.sparse_tensor_to_dense(update)\n\n    <span class=\"pl-k\">return</span> angle <span class=\"pl-k\">+</span> update_dense\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">atan2_ocv</span>(<span class=\"pl-smi\">y</span>, <span class=\"pl-smi\">x</span>):\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> constants</span>\n    <span class=\"pl-c1\">DBL_EPSILON</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">2.2204460492503131e-16</span>\n    atan2_p1 <span class=\"pl-k\">=</span> <span class=\"pl-c1\">0.9997878412794807</span> <span class=\"pl-k\">*</span> (<span class=\"pl-c1\">180</span> <span class=\"pl-k\">/</span> np.pi)\n    atan2_p3 <span class=\"pl-k\">=</span> <span class=\"pl-k\">-</span><span class=\"pl-c1\">0.3258083974640975</span> <span class=\"pl-k\">*</span> (<span class=\"pl-c1\">180</span> <span class=\"pl-k\">/</span> np.pi)\n    atan2_p5 <span class=\"pl-k\">=</span> <span class=\"pl-c1\">0.1555786518463281</span> <span class=\"pl-k\">*</span> (<span class=\"pl-c1\">180</span> <span class=\"pl-k\">/</span> np.pi)\n    atan2_p7 <span class=\"pl-k\">=</span> <span class=\"pl-k\">-</span><span class=\"pl-c1\">0.04432655554792128</span> <span class=\"pl-k\">*</span> (<span class=\"pl-c1\">180</span> <span class=\"pl-k\">/</span> np.pi)\n\n    ax, ay <span class=\"pl-k\">=</span> tf.abs(x), tf.abs(y)\n    c <span class=\"pl-k\">=</span> tf.select(tf.greater_equal(ax, ay), tf.div(ay, ax <span class=\"pl-k\">+</span> <span class=\"pl-c1\">DBL_EPSILON</span>),\n                  tf.div(ax, ay <span class=\"pl-k\">+</span> <span class=\"pl-c1\">DBL_EPSILON</span>))\n    c2 <span class=\"pl-k\">=</span> tf.square(c)\n    angle <span class=\"pl-k\">=</span> (((atan2_p7 <span class=\"pl-k\">*</span> c2 <span class=\"pl-k\">+</span> atan2_p5) <span class=\"pl-k\">*</span> c2 <span class=\"pl-k\">+</span> atan2_p3) <span class=\"pl-k\">*</span> c2 <span class=\"pl-k\">+</span> atan2_p1) <span class=\"pl-k\">*</span> c\n    angle <span class=\"pl-k\">=</span> tf.select(tf.greater_equal(ax, ay), angle, <span class=\"pl-c1\">90.0</span> <span class=\"pl-k\">-</span> angle)\n    angle <span class=\"pl-k\">=</span> tf.select(tf.less(x, <span class=\"pl-c1\">0.0</span>), <span class=\"pl-c1\">180.0</span> <span class=\"pl-k\">-</span> angle, angle)\n    angle <span class=\"pl-k\">=</span> tf.select(tf.less(y, <span class=\"pl-c1\">0.0</span>), <span class=\"pl-c1\">360.0</span> <span class=\"pl-k\">-</span> angle, angle)\n    <span class=\"pl-k\">return</span> angle</pre></div>\n<p>I'm not sure if I should add or subtract np.pi when x &lt; 0.0 for my atan2 function, since it seems to be a platform dependent thing, so I left it at adding np.pi. I validated the output of my atan2_ocv by using it for visualizing optical flow, and comparing that with opencv's flow visualization implementation which uses cv2.cartToPolar (which in turn uses its own implementation of atan2).</p>\n<p>opencv's flow visualization function:<br>\n<a href=\"https://github.com/opencv/opencv/blob/master/samples/python/opt_flow.py#L37\">https://github.com/opencv/opencv/blob/master/samples/python/opt_flow.py#L37</a></p>\n<p>opencv's cartToPolar: <a href=\"https://github.com/opencv/opencv/blob/master/modules/core/src/mathfuncs.cpp#L266\">https://github.com/opencv/opencv/blob/master/modules/core/src/mathfuncs.cpp#L266</a></p>\n<p>opencv's atan2:<br>\n<a href=\"https://github.com/opencv/opencv/blob/cb1d4e692bd13ff413273baf6d3b22fabdde6e74/modules/core/src/mathfuncs_core.cpp#L159\">https://github.com/opencv/opencv/blob/cb1d4e692bd13ff413273baf6d3b22fabdde6e74/modules/core/src/mathfuncs_core.cpp#L159</a></p>", "body_text": "For what it's worth, I managed to implement two versions of atan2. One that follows the opencv style (returns degrees), and another that uses tensorflow's atan function (returns rads).\ndef atan2(y, x):\n    angle = tf.select(tf.greater(x, 0.0), tf.atan(y / x), tf.zeros_like(x))\n    angle = tf.select(tf.greater(y, 0.0), 0.5 * np.pi - tf.atan(x / y), angle)\n    angle = tf.select(tf.less(y, 0.0), -0.5 * np.pi - tf.atan(x / y), angle)\n    angle = tf.select(tf.less(x, 0.0), tf.atan(y / x) + np.pi, angle)\n    angle = tf.select(tf.logical_and(tf.equal(x, 0.0), tf.equal(y, 0.0)),\n                      np.nan * tf.zeros_like(x), angle)\n\n    indices = tf.where(tf.less(angle, 0.0))\n    updated_values = tf.gather_nd(angle, indices) + (2 * np.pi)\n    update = tf.SparseTensor(indices, updated_values, angle.get_shape())\n    update_dense = tf.sparse_tensor_to_dense(update)\n\n    return angle + update_dense\n\ndef atan2_ocv(y, x):\n    # constants\n    DBL_EPSILON = 2.2204460492503131e-16\n    atan2_p1 = 0.9997878412794807 * (180 / np.pi)\n    atan2_p3 = -0.3258083974640975 * (180 / np.pi)\n    atan2_p5 = 0.1555786518463281 * (180 / np.pi)\n    atan2_p7 = -0.04432655554792128 * (180 / np.pi)\n\n    ax, ay = tf.abs(x), tf.abs(y)\n    c = tf.select(tf.greater_equal(ax, ay), tf.div(ay, ax + DBL_EPSILON),\n                  tf.div(ax, ay + DBL_EPSILON))\n    c2 = tf.square(c)\n    angle = (((atan2_p7 * c2 + atan2_p5) * c2 + atan2_p3) * c2 + atan2_p1) * c\n    angle = tf.select(tf.greater_equal(ax, ay), angle, 90.0 - angle)\n    angle = tf.select(tf.less(x, 0.0), 180.0 - angle, angle)\n    angle = tf.select(tf.less(y, 0.0), 360.0 - angle, angle)\n    return angle\nI'm not sure if I should add or subtract np.pi when x < 0.0 for my atan2 function, since it seems to be a platform dependent thing, so I left it at adding np.pi. I validated the output of my atan2_ocv by using it for visualizing optical flow, and comparing that with opencv's flow visualization implementation which uses cv2.cartToPolar (which in turn uses its own implementation of atan2).\nopencv's flow visualization function:\nhttps://github.com/opencv/opencv/blob/master/samples/python/opt_flow.py#L37\nopencv's cartToPolar: https://github.com/opencv/opencv/blob/master/modules/core/src/mathfuncs.cpp#L266\nopencv's atan2:\nhttps://github.com/opencv/opencv/blob/cb1d4e692bd13ff413273baf6d3b22fabdde6e74/modules/core/src/mathfuncs_core.cpp#L159", "body": "For what it's worth, I managed to implement two versions of atan2. One that follows the opencv style (returns degrees), and another that uses tensorflow's atan function (returns rads).\r\n\r\n```python\r\ndef atan2(y, x):\r\n    angle = tf.select(tf.greater(x, 0.0), tf.atan(y / x), tf.zeros_like(x))\r\n    angle = tf.select(tf.greater(y, 0.0), 0.5 * np.pi - tf.atan(x / y), angle)\r\n    angle = tf.select(tf.less(y, 0.0), -0.5 * np.pi - tf.atan(x / y), angle)\r\n    angle = tf.select(tf.less(x, 0.0), tf.atan(y / x) + np.pi, angle)\r\n    angle = tf.select(tf.logical_and(tf.equal(x, 0.0), tf.equal(y, 0.0)),\r\n                      np.nan * tf.zeros_like(x), angle)\r\n\r\n    indices = tf.where(tf.less(angle, 0.0))\r\n    updated_values = tf.gather_nd(angle, indices) + (2 * np.pi)\r\n    update = tf.SparseTensor(indices, updated_values, angle.get_shape())\r\n    update_dense = tf.sparse_tensor_to_dense(update)\r\n\r\n    return angle + update_dense\r\n\r\ndef atan2_ocv(y, x):\r\n    # constants\r\n    DBL_EPSILON = 2.2204460492503131e-16\r\n    atan2_p1 = 0.9997878412794807 * (180 / np.pi)\r\n    atan2_p3 = -0.3258083974640975 * (180 / np.pi)\r\n    atan2_p5 = 0.1555786518463281 * (180 / np.pi)\r\n    atan2_p7 = -0.04432655554792128 * (180 / np.pi)\r\n\r\n    ax, ay = tf.abs(x), tf.abs(y)\r\n    c = tf.select(tf.greater_equal(ax, ay), tf.div(ay, ax + DBL_EPSILON),\r\n                  tf.div(ax, ay + DBL_EPSILON))\r\n    c2 = tf.square(c)\r\n    angle = (((atan2_p7 * c2 + atan2_p5) * c2 + atan2_p3) * c2 + atan2_p1) * c\r\n    angle = tf.select(tf.greater_equal(ax, ay), angle, 90.0 - angle)\r\n    angle = tf.select(tf.less(x, 0.0), 180.0 - angle, angle)\r\n    angle = tf.select(tf.less(y, 0.0), 360.0 - angle, angle)\r\n    return angle\r\n```\r\n\r\nI'm not sure if I should add or subtract np.pi when x < 0.0 for my atan2 function, since it seems to be a platform dependent thing, so I left it at adding np.pi. I validated the output of my atan2_ocv by using it for visualizing optical flow, and comparing that with opencv's flow visualization implementation which uses cv2.cartToPolar (which in turn uses its own implementation of atan2).\r\n\r\nopencv's flow visualization function:\r\nhttps://github.com/opencv/opencv/blob/master/samples/python/opt_flow.py#L37\r\n\r\nopencv's cartToPolar: https://github.com/opencv/opencv/blob/master/modules/core/src/mathfuncs.cpp#L266\r\n\r\nopencv's atan2:\r\nhttps://github.com/opencv/opencv/blob/cb1d4e692bd13ff413273baf6d3b22fabdde6e74/modules/core/src/mathfuncs_core.cpp#L159"}