{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/274167673", "html_url": "https://github.com/tensorflow/tensorflow/issues/6095#issuecomment-274167673", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/6095", "id": 274167673, "node_id": "MDEyOklzc3VlQ29tbWVudDI3NDE2NzY3Mw==", "user": {"login": "mjlm", "id": 5418069, "node_id": "MDQ6VXNlcjU0MTgwNjk=", "avatar_url": "https://avatars1.githubusercontent.com/u/5418069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mjlm", "html_url": "https://github.com/mjlm", "followers_url": "https://api.github.com/users/mjlm/followers", "following_url": "https://api.github.com/users/mjlm/following{/other_user}", "gists_url": "https://api.github.com/users/mjlm/gists{/gist_id}", "starred_url": "https://api.github.com/users/mjlm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mjlm/subscriptions", "organizations_url": "https://api.github.com/users/mjlm/orgs", "repos_url": "https://api.github.com/users/mjlm/repos", "events_url": "https://api.github.com/users/mjlm/events{/privacy}", "received_events_url": "https://api.github.com/users/mjlm/received_events", "type": "User", "site_admin": false}, "created_at": "2017-01-20T20:08:36Z", "updated_at": "2017-01-20T20:08:36Z", "author_association": "NONE", "body_html": "<p>As far as I can tell, the implementation mentioned in the first post will suffer from division-by-zero if x or y contain any zeros, which leads to NaN gradients. This fixes the issue for me:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">def</span> <span class=\"pl-en\">atan2</span>(<span class=\"pl-smi\">y</span>, <span class=\"pl-smi\">x</span>, <span class=\"pl-smi\">epsilon</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">1.0e-12</span>):\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> Add a small number to all zeros, to avoid division by zero:</span>\n    x <span class=\"pl-k\">=</span> tf.select(tf.equal(x, <span class=\"pl-c1\">0.0</span>), x<span class=\"pl-k\">+</span>epsilon, x)\n    y <span class=\"pl-k\">=</span> tf.select(tf.equal(y, <span class=\"pl-c1\">0.0</span>), y<span class=\"pl-k\">+</span>epsilon, y)\n\n    angle <span class=\"pl-k\">=</span> tf.select(tf.greater(x,<span class=\"pl-c1\">0.0</span>), tf.atan(y<span class=\"pl-k\">/</span>x), tf.zeros_like(x))\n    angle <span class=\"pl-k\">=</span> tf.select(tf.logical_and(tf.less(x,<span class=\"pl-c1\">0.0</span>),  tf.greater_equal(y,<span class=\"pl-c1\">0.0</span>)), tf.atan(y<span class=\"pl-k\">/</span>x) <span class=\"pl-k\">+</span> np.pi, angle)\n    angle <span class=\"pl-k\">=</span> tf.select(tf.logical_and(tf.less(x,<span class=\"pl-c1\">0.0</span>),  tf.less(y,<span class=\"pl-c1\">0.0</span>)), tf.atan(y<span class=\"pl-k\">/</span>x) <span class=\"pl-k\">-</span> np.pi, angle)\n    angle <span class=\"pl-k\">=</span> tf.select(tf.logical_and(tf.equal(x,<span class=\"pl-c1\">0.0</span>), tf.greater(y,<span class=\"pl-c1\">0.0</span>)), <span class=\"pl-c1\">0.5</span><span class=\"pl-k\">*</span>np.pi <span class=\"pl-k\">*</span> tf.ones_like(x), angle)\n    angle <span class=\"pl-k\">=</span> tf.select(tf.logical_and(tf.equal(x,<span class=\"pl-c1\">0.0</span>), tf.less(y,<span class=\"pl-c1\">0.0</span>)), <span class=\"pl-k\">-</span><span class=\"pl-c1\">0.5</span><span class=\"pl-k\">*</span>np.pi <span class=\"pl-k\">*</span> tf.ones_like(x), angle)\n    angle <span class=\"pl-k\">=</span> tf.select(tf.logical_and(tf.equal(x,<span class=\"pl-c1\">0.0</span>), tf.equal(y,<span class=\"pl-c1\">0.0</span>)), tf.zeros_like(x), angle)\n    <span class=\"pl-k\">return</span> angle</pre></div>", "body_text": "As far as I can tell, the implementation mentioned in the first post will suffer from division-by-zero if x or y contain any zeros, which leads to NaN gradients. This fixes the issue for me:\ndef atan2(y, x, epsilon=1.0e-12):\n    # Add a small number to all zeros, to avoid division by zero:\n    x = tf.select(tf.equal(x, 0.0), x+epsilon, x)\n    y = tf.select(tf.equal(y, 0.0), y+epsilon, y)\n\n    angle = tf.select(tf.greater(x,0.0), tf.atan(y/x), tf.zeros_like(x))\n    angle = tf.select(tf.logical_and(tf.less(x,0.0),  tf.greater_equal(y,0.0)), tf.atan(y/x) + np.pi, angle)\n    angle = tf.select(tf.logical_and(tf.less(x,0.0),  tf.less(y,0.0)), tf.atan(y/x) - np.pi, angle)\n    angle = tf.select(tf.logical_and(tf.equal(x,0.0), tf.greater(y,0.0)), 0.5*np.pi * tf.ones_like(x), angle)\n    angle = tf.select(tf.logical_and(tf.equal(x,0.0), tf.less(y,0.0)), -0.5*np.pi * tf.ones_like(x), angle)\n    angle = tf.select(tf.logical_and(tf.equal(x,0.0), tf.equal(y,0.0)), tf.zeros_like(x), angle)\n    return angle", "body": "As far as I can tell, the implementation mentioned in the first post will suffer from division-by-zero if x or y contain any zeros, which leads to NaN gradients. This fixes the issue for me:\r\n\r\n```python\r\ndef atan2(y, x, epsilon=1.0e-12):\r\n    # Add a small number to all zeros, to avoid division by zero:\r\n    x = tf.select(tf.equal(x, 0.0), x+epsilon, x)\r\n    y = tf.select(tf.equal(y, 0.0), y+epsilon, y)\r\n\r\n    angle = tf.select(tf.greater(x,0.0), tf.atan(y/x), tf.zeros_like(x))\r\n    angle = tf.select(tf.logical_and(tf.less(x,0.0),  tf.greater_equal(y,0.0)), tf.atan(y/x) + np.pi, angle)\r\n    angle = tf.select(tf.logical_and(tf.less(x,0.0),  tf.less(y,0.0)), tf.atan(y/x) - np.pi, angle)\r\n    angle = tf.select(tf.logical_and(tf.equal(x,0.0), tf.greater(y,0.0)), 0.5*np.pi * tf.ones_like(x), angle)\r\n    angle = tf.select(tf.logical_and(tf.equal(x,0.0), tf.less(y,0.0)), -0.5*np.pi * tf.ones_like(x), angle)\r\n    angle = tf.select(tf.logical_and(tf.equal(x,0.0), tf.equal(y,0.0)), tf.zeros_like(x), angle)\r\n    return angle\r\n``` "}