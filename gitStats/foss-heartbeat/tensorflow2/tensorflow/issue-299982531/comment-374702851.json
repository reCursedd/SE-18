{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/374702851", "html_url": "https://github.com/tensorflow/tensorflow/issues/17246#issuecomment-374702851", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/17246", "id": 374702851, "node_id": "MDEyOklzc3VlQ29tbWVudDM3NDcwMjg1MQ==", "user": {"login": "ekelsen", "id": 2533174, "node_id": "MDQ6VXNlcjI1MzMxNzQ=", "avatar_url": "https://avatars0.githubusercontent.com/u/2533174?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ekelsen", "html_url": "https://github.com/ekelsen", "followers_url": "https://api.github.com/users/ekelsen/followers", "following_url": "https://api.github.com/users/ekelsen/following{/other_user}", "gists_url": "https://api.github.com/users/ekelsen/gists{/gist_id}", "starred_url": "https://api.github.com/users/ekelsen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ekelsen/subscriptions", "organizations_url": "https://api.github.com/users/ekelsen/orgs", "repos_url": "https://api.github.com/users/ekelsen/repos", "events_url": "https://api.github.com/users/ekelsen/events{/privacy}", "received_events_url": "https://api.github.com/users/ekelsen/received_events", "type": "User", "site_admin": false}, "created_at": "2018-03-20T18:14:53Z", "updated_at": "2018-03-20T18:24:18Z", "author_association": "CONTRIBUTOR", "body_html": "<p>A single threaded call to the system memcpy should be able to hit the memory bandwidth of the system except in two cases:</p>\n<ol>\n<li>\n<p>there are many small copies (not the case here)</p>\n</li>\n<li>\n<p>A single large copy will normally hit the memcpy path that avoids polluting the cache (the copies will be done using streaming memory instructions), this is known to decrease absolute performance but avoids cache pollution on multiprocessor machines.  This is hardcoded behavior of glibc.  The latest versions of glibc should expose this parameter as a tunable value (I put them there, see <a href=\"https://www.gnu.org/software/libc/manual/html_node/Hardware-Capability-Tunables.html#Hardware-Capability-Tunables\" rel=\"nofollow\">https://www.gnu.org/software/libc/manual/html_node/Hardware-Capability-Tunables.html#Hardware-Capability-Tunables</a>).   Can you try making the non-temporal threshold larger than your copy size?</p>\n</li>\n</ol>\n<p>I suspect what's happening is that when you shard the copy 32 times it drops below the hard-coded non temporal threshold and you're hitting the faster path (but blowing out the caches).</p>", "body_text": "A single threaded call to the system memcpy should be able to hit the memory bandwidth of the system except in two cases:\n\n\nthere are many small copies (not the case here)\n\n\nA single large copy will normally hit the memcpy path that avoids polluting the cache (the copies will be done using streaming memory instructions), this is known to decrease absolute performance but avoids cache pollution on multiprocessor machines.  This is hardcoded behavior of glibc.  The latest versions of glibc should expose this parameter as a tunable value (I put them there, see https://www.gnu.org/software/libc/manual/html_node/Hardware-Capability-Tunables.html#Hardware-Capability-Tunables).   Can you try making the non-temporal threshold larger than your copy size?\n\n\nI suspect what's happening is that when you shard the copy 32 times it drops below the hard-coded non temporal threshold and you're hitting the faster path (but blowing out the caches).", "body": "A single threaded call to the system memcpy should be able to hit the memory bandwidth of the system except in two cases:\r\n\r\n1) there are many small copies (not the case here)\r\n\r\n2) A single large copy will normally hit the memcpy path that avoids polluting the cache (the copies will be done using streaming memory instructions), this is known to decrease absolute performance but avoids cache pollution on multiprocessor machines.  This is hardcoded behavior of glibc.  The latest versions of glibc should expose this parameter as a tunable value (I put them there, see https://www.gnu.org/software/libc/manual/html_node/Hardware-Capability-Tunables.html#Hardware-Capability-Tunables).   Can you try making the non-temporal threshold larger than your copy size?\r\n\r\nI suspect what's happening is that when you shard the copy 32 times it drops below the hard-coded non temporal threshold and you're hitting the faster path (but blowing out the caches)."}