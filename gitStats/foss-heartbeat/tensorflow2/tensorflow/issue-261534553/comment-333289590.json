{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/333289590", "html_url": "https://github.com/tensorflow/tensorflow/issues/13375#issuecomment-333289590", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13375", "id": 333289590, "node_id": "MDEyOklzc3VlQ29tbWVudDMzMzI4OTU5MA==", "user": {"login": "tongda", "id": 653425, "node_id": "MDQ6VXNlcjY1MzQyNQ==", "avatar_url": "https://avatars0.githubusercontent.com/u/653425?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tongda", "html_url": "https://github.com/tongda", "followers_url": "https://api.github.com/users/tongda/followers", "following_url": "https://api.github.com/users/tongda/following{/other_user}", "gists_url": "https://api.github.com/users/tongda/gists{/gist_id}", "starred_url": "https://api.github.com/users/tongda/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tongda/subscriptions", "organizations_url": "https://api.github.com/users/tongda/orgs", "repos_url": "https://api.github.com/users/tongda/repos", "events_url": "https://api.github.com/users/tongda/events{/privacy}", "received_events_url": "https://api.github.com/users/tongda/received_events", "type": "User", "site_admin": false}, "created_at": "2017-09-30T07:10:03Z", "updated_at": "2017-09-30T07:10:03Z", "author_association": "NONE", "body_html": "<p>Inside of the implementation of <code>tf.conver_to_tensor</code>, there is a <code>_tensor_conversion_func_registry</code> which includes the supported type and its conversion function. I am thinking of adding some <code>(type, conversion function)</code> pair to this registry, where the <code>type</code> is the specific name of the iterators, such as <code>zip</code>, <code>map</code>, <code>dict_keys</code>, etc.</p>\n<p>Additionally, to avoid incidental false invoke, we can set the priority to be low. They will be called after the previous <code>Tensor</code>, <code>ndarray</code> check.</p>\n<p>We can first call <code>numpy.fromiter</code> on the iterators to generate a <code>ndarray</code>, then call the existed conversion function on the <code>ndarray</code> to convert to <code>Tensor</code>. I guess TF will reuse the memory of numpy, so this could save memory and time from avoiding copy memory from Python VM to TF runtime.</p>", "body_text": "Inside of the implementation of tf.conver_to_tensor, there is a _tensor_conversion_func_registry which includes the supported type and its conversion function. I am thinking of adding some (type, conversion function) pair to this registry, where the type is the specific name of the iterators, such as zip, map, dict_keys, etc.\nAdditionally, to avoid incidental false invoke, we can set the priority to be low. They will be called after the previous Tensor, ndarray check.\nWe can first call numpy.fromiter on the iterators to generate a ndarray, then call the existed conversion function on the ndarray to convert to Tensor. I guess TF will reuse the memory of numpy, so this could save memory and time from avoiding copy memory from Python VM to TF runtime.", "body": "Inside of the implementation of `tf.conver_to_tensor`, there is a `_tensor_conversion_func_registry` which includes the supported type and its conversion function. I am thinking of adding some `(type, conversion function)` pair to this registry, where the `type` is the specific name of the iterators, such as `zip`, `map`, `dict_keys`, etc.\r\n\r\nAdditionally, to avoid incidental false invoke, we can set the priority to be low. They will be called after the previous `Tensor`, `ndarray` check.\r\n\r\nWe can first call `numpy.fromiter` on the iterators to generate a `ndarray`, then call the existed conversion function on the `ndarray` to convert to `Tensor`. I guess TF will reuse the memory of numpy, so this could save memory and time from avoiding copy memory from Python VM to TF runtime."}