{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/824", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/824/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/824/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/824/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/824", "id": 127789162, "node_id": "MDU6SXNzdWUxMjc3ODkxNjI=", "number": 824, "title": "Feature parity of tf.diag with np.diag", "user": {"login": "yaroslavvb", "id": 23068, "node_id": "MDQ6VXNlcjIzMDY4", "avatar_url": "https://avatars3.githubusercontent.com/u/23068?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yaroslavvb", "html_url": "https://github.com/yaroslavvb", "followers_url": "https://api.github.com/users/yaroslavvb/followers", "following_url": "https://api.github.com/users/yaroslavvb/following{/other_user}", "gists_url": "https://api.github.com/users/yaroslavvb/gists{/gist_id}", "starred_url": "https://api.github.com/users/yaroslavvb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yaroslavvb/subscriptions", "organizations_url": "https://api.github.com/users/yaroslavvb/orgs", "repos_url": "https://api.github.com/users/yaroslavvb/repos", "events_url": "https://api.github.com/users/yaroslavvb/events{/privacy}", "received_events_url": "https://api.github.com/users/yaroslavvb/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 299643928, "node_id": "MDU6TGFiZWwyOTk2NDM5Mjg=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:contributions%20welcome", "name": "stat:contributions welcome", "color": "f4b400", "default": false}, {"id": 473173272, "node_id": "MDU6TGFiZWw0NzMxNzMyNzI=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:feature", "name": "type:feature", "color": "159b2e", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 7, "created_at": "2016-01-20T21:35:41Z", "updated_at": "2017-02-09T22:37:37Z", "closed_at": "2016-03-09T22:19:44Z", "author_association": "CONTRIBUTOR", "body_html": "<p>np.diag can</p>\n<ol>\n<li>take 2d array and produce 1d vector of diagonal entries</li>\n<li>take 1d array and produce diagonal 2d array (inverse of case 1)</li>\n</ol>\n<p>tf.diag only supports 2) and the behavior for case 1) is undocumented</p>\n<p>Currently to do 1) you need to do something like this:</p>\n<pre><code>def identity_matrix(n):\n  \"\"\"Returns nxn identity matrix.\"\"\"\n  # note, if n is a constant node,\u00a0this assert node won't be executed,\n  # this error will be caught during shape analysis \n  assert_op = tf.Assert(tf.greater(n, 0), [\"Matrix size must be positive\"])\n  with tf.control_dependencies([assert_op]):\n    ones = tf.fill(n, 1)\n    diag = tf.diag(ones)\n  return diag\n\ndef extract_diagonal(tensor):\n  \"\"\"Extract diagonal of a square matrix.\"\"\"\n\n  shape = tf.shape(tensor)\n  n = shape[0]\n  assert_op = tf.Assert(tf.equal(shape[0], shape[1]), [\"Can't get diagonal of \"\n                                                       \"a non-square matrix\"])\n\n  with tf.control_dependencies([assert_op]):\n  return tf.reduce_sum(tf.mul(tensor, identity_matrix(n)), [0])\n</code></pre>", "body_text": "np.diag can\n\ntake 2d array and produce 1d vector of diagonal entries\ntake 1d array and produce diagonal 2d array (inverse of case 1)\n\ntf.diag only supports 2) and the behavior for case 1) is undocumented\nCurrently to do 1) you need to do something like this:\ndef identity_matrix(n):\n  \"\"\"Returns nxn identity matrix.\"\"\"\n  # note, if n is a constant node,\u00a0this assert node won't be executed,\n  # this error will be caught during shape analysis \n  assert_op = tf.Assert(tf.greater(n, 0), [\"Matrix size must be positive\"])\n  with tf.control_dependencies([assert_op]):\n    ones = tf.fill(n, 1)\n    diag = tf.diag(ones)\n  return diag\n\ndef extract_diagonal(tensor):\n  \"\"\"Extract diagonal of a square matrix.\"\"\"\n\n  shape = tf.shape(tensor)\n  n = shape[0]\n  assert_op = tf.Assert(tf.equal(shape[0], shape[1]), [\"Can't get diagonal of \"\n                                                       \"a non-square matrix\"])\n\n  with tf.control_dependencies([assert_op]):\n  return tf.reduce_sum(tf.mul(tensor, identity_matrix(n)), [0])", "body": "np.diag can\n\n1) take 2d array and produce 1d vector of diagonal entries\n2) take 1d array and produce diagonal 2d array (inverse of case 1)\n\ntf.diag only supports 2) and the behavior for case 1) is undocumented\n\nCurrently to do 1) you need to do something like this:\n\n```\ndef identity_matrix(n):\n  \"\"\"Returns nxn identity matrix.\"\"\"\n  # note, if n is a constant node,\u00a0this assert node won't be executed,\n  # this error will be caught during shape analysis \n  assert_op = tf.Assert(tf.greater(n, 0), [\"Matrix size must be positive\"])\n  with tf.control_dependencies([assert_op]):\n    ones = tf.fill(n, 1)\n    diag = tf.diag(ones)\n  return diag\n\ndef extract_diagonal(tensor):\n  \"\"\"Extract diagonal of a square matrix.\"\"\"\n\n  shape = tf.shape(tensor)\n  n = shape[0]\n  assert_op = tf.Assert(tf.equal(shape[0], shape[1]), [\"Can't get diagonal of \"\n                                                       \"a non-square matrix\"])\n\n  with tf.control_dependencies([assert_op]):\n  return tf.reduce_sum(tf.mul(tensor, identity_matrix(n)), [0])\n```\n"}