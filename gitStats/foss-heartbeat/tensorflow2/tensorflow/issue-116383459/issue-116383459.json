{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/143", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/143/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/143/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/143/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/143", "id": 116383459, "node_id": "MDU6SXNzdWUxMTYzODM0NTk=", "number": 143, "title": "Truncated backdrop with max pooling over time", "user": {"login": "allentran", "id": 6768556, "node_id": "MDQ6VXNlcjY3Njg1NTY=", "avatar_url": "https://avatars2.githubusercontent.com/u/6768556?v=4", "gravatar_id": "", "url": "https://api.github.com/users/allentran", "html_url": "https://github.com/allentran", "followers_url": "https://api.github.com/users/allentran/followers", "following_url": "https://api.github.com/users/allentran/following{/other_user}", "gists_url": "https://api.github.com/users/allentran/gists{/gist_id}", "starred_url": "https://api.github.com/users/allentran/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/allentran/subscriptions", "organizations_url": "https://api.github.com/users/allentran/orgs", "repos_url": "https://api.github.com/users/allentran/repos", "events_url": "https://api.github.com/users/allentran/events{/privacy}", "received_events_url": "https://api.github.com/users/allentran/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2015-11-11T17:31:38Z", "updated_at": "2015-11-11T21:45:14Z", "closed_at": "2015-11-11T21:45:13Z", "author_association": "NONE", "body_html": "<p>It seems like the way truncated backprop is done, at least in the tutorial on RNNs, is to</p>\n<ul>\n<li>set up the data in batches where the time dimension is capped at the max <code>num_steps</code></li>\n<li>run forward/backward passes making sure to use the correct initial state (e.g final state of the previous batch if was part of the same observation but prior in time or the true initial state if the current batch starts at true <code>t=0</code>)</li>\n</ul>\n<p>This works fine if each hidden state contributes directly to the loss but this approach fails if you want to do something like max pooling across time.  You can carry around the current max (like the correct initial state for truncated backprop) but it seems like the gradient won't flow from the loss, to the max'd elements.</p>\n<p>To summarize, truncated backprop won't work in situations when a given hidden state at time <code>t</code>'s contribution to the loss is unknown without knowing the hidden states for all <code>t</code>.</p>\n<p>Would love to be wrong.</p>", "body_text": "It seems like the way truncated backprop is done, at least in the tutorial on RNNs, is to\n\nset up the data in batches where the time dimension is capped at the max num_steps\nrun forward/backward passes making sure to use the correct initial state (e.g final state of the previous batch if was part of the same observation but prior in time or the true initial state if the current batch starts at true t=0)\n\nThis works fine if each hidden state contributes directly to the loss but this approach fails if you want to do something like max pooling across time.  You can carry around the current max (like the correct initial state for truncated backprop) but it seems like the gradient won't flow from the loss, to the max'd elements.\nTo summarize, truncated backprop won't work in situations when a given hidden state at time t's contribution to the loss is unknown without knowing the hidden states for all t.\nWould love to be wrong.", "body": "It seems like the way truncated backprop is done, at least in the tutorial on RNNs, is to \n- set up the data in batches where the time dimension is capped at the max `num_steps` \n- run forward/backward passes making sure to use the correct initial state (e.g final state of the previous batch if was part of the same observation but prior in time or the true initial state if the current batch starts at true `t=0`)\n\nThis works fine if each hidden state contributes directly to the loss but this approach fails if you want to do something like max pooling across time.  You can carry around the current max (like the correct initial state for truncated backprop) but it seems like the gradient won't flow from the loss, to the max'd elements.  \n\nTo summarize, truncated backprop won't work in situations when a given hidden state at time `t`'s contribution to the loss is unknown without knowing the hidden states for all `t`.  \n\nWould love to be wrong.  \n"}