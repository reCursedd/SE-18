{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/268043853", "html_url": "https://github.com/tensorflow/tensorflow/issues/6267#issuecomment-268043853", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/6267", "id": 268043853, "node_id": "MDEyOklzc3VlQ29tbWVudDI2ODA0Mzg1Mw==", "user": {"login": "kmalakoff", "id": 756520, "node_id": "MDQ6VXNlcjc1NjUyMA==", "avatar_url": "https://avatars2.githubusercontent.com/u/756520?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmalakoff", "html_url": "https://github.com/kmalakoff", "followers_url": "https://api.github.com/users/kmalakoff/followers", "following_url": "https://api.github.com/users/kmalakoff/following{/other_user}", "gists_url": "https://api.github.com/users/kmalakoff/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmalakoff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmalakoff/subscriptions", "organizations_url": "https://api.github.com/users/kmalakoff/orgs", "repos_url": "https://api.github.com/users/kmalakoff/repos", "events_url": "https://api.github.com/users/kmalakoff/events{/privacy}", "received_events_url": "https://api.github.com/users/kmalakoff/received_events", "type": "User", "site_admin": false}, "created_at": "2016-12-19T18:44:10Z", "updated_at": "2016-12-19T18:44:10Z", "author_association": "NONE", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=16018\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/asimshankar\">@asimshankar</a> sounds good. If both could be distributed, I would use the C++ API.</p>\n<p>I have performed some basic steps of implementing a port to Node.js with both the <a href=\"https://github.com/kmalakoff/tensorflow-node/tree/master/src/native/c\">C</a> and <a href=\"https://github.com/kmalakoff/tensorflow-node/tree/master/src/native/cc\">C++</a> APIs. Definitely, C++ is a much better API when you can use it (I could when using Nan for Node.js, but probably more of an exception in porting approaches) and it looks like the team might be <a href=\"https://github.com/tensorflow/tensorflow/issues/6268\" data-hovercard-type=\"issue\" data-hovercard-url=\"/tensorflow/tensorflow/issues/6268/hovercard\">starting with C++ and then porting back to C</a> so it might be more complete sooner, but since we are talking about official headers and libraries distributed for official releases, C++ and C feature sets should hopefully be in sync at each release.</p>\n<p>I'm not sure how header and library dependencies for eigen, protobuf, etc would be provided, but I would need a way to ensure I was using the same versions as tensorflow was built with.</p>\n<p>I did raise an issue to <a href=\"https://github.com/bazelbuild/bazel/issues/2206\" data-hovercard-type=\"issue\" data-hovercard-url=\"/bazelbuild/bazel/issues/2206/hovercard\">bazel</a> and am a bit surprised about coming back to C / C++ after 15+ years away that there isn't a common package manager for this ecosystem. However you decide to distribute these, it would be great to be as low friction as possible to use including setting up build environments and managing external library dependencies.</p>\n<p>I'm really looking forward to this!</p>", "body_text": "@asimshankar sounds good. If both could be distributed, I would use the C++ API.\nI have performed some basic steps of implementing a port to Node.js with both the C and C++ APIs. Definitely, C++ is a much better API when you can use it (I could when using Nan for Node.js, but probably more of an exception in porting approaches) and it looks like the team might be starting with C++ and then porting back to C so it might be more complete sooner, but since we are talking about official headers and libraries distributed for official releases, C++ and C feature sets should hopefully be in sync at each release.\nI'm not sure how header and library dependencies for eigen, protobuf, etc would be provided, but I would need a way to ensure I was using the same versions as tensorflow was built with.\nI did raise an issue to bazel and am a bit surprised about coming back to C / C++ after 15+ years away that there isn't a common package manager for this ecosystem. However you decide to distribute these, it would be great to be as low friction as possible to use including setting up build environments and managing external library dependencies.\nI'm really looking forward to this!", "body": "@asimshankar sounds good. If both could be distributed, I would use the C++ API.\r\n\r\nI have performed some basic steps of implementing a port to Node.js with both the [C](https://github.com/kmalakoff/tensorflow-node/tree/master/src/native/c) and [C++](https://github.com/kmalakoff/tensorflow-node/tree/master/src/native/cc) APIs. Definitely, C++ is a much better API when you can use it (I could when using Nan for Node.js, but probably more of an exception in porting approaches) and it looks like the team might be [starting with C++ and then porting back to C](https://github.com/tensorflow/tensorflow/issues/6268) so it might be more complete sooner, but since we are talking about official headers and libraries distributed for official releases, C++ and C feature sets should hopefully be in sync at each release. \r\n\r\nI'm not sure how header and library dependencies for eigen, protobuf, etc would be provided, but I would need a way to ensure I was using the same versions as tensorflow was built with.\r\n\r\nI did raise an issue to [bazel](https://github.com/bazelbuild/bazel/issues/2206) and am a bit surprised about coming back to C / C++ after 15+ years away that there isn't a common package manager for this ecosystem. However you decide to distribute these, it would be great to be as low friction as possible to use including setting up build environments and managing external library dependencies.\r\n\r\nI'm really looking forward to this!\r\n"}