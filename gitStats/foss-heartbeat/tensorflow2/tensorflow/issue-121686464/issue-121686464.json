{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/480", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/480/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/480/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/480/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/480", "id": 121686464, "node_id": "MDU6SXNzdWUxMjE2ODY0NjQ=", "number": 480, "title": "2 bugs in training/input.py", "user": {"login": "oliverfunk", "id": 3520445, "node_id": "MDQ6VXNlcjM1MjA0NDU=", "avatar_url": "https://avatars1.githubusercontent.com/u/3520445?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oliverfunk", "html_url": "https://github.com/oliverfunk", "followers_url": "https://api.github.com/users/oliverfunk/followers", "following_url": "https://api.github.com/users/oliverfunk/following{/other_user}", "gists_url": "https://api.github.com/users/oliverfunk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oliverfunk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oliverfunk/subscriptions", "organizations_url": "https://api.github.com/users/oliverfunk/orgs", "repos_url": "https://api.github.com/users/oliverfunk/repos", "events_url": "https://api.github.com/users/oliverfunk/events{/privacy}", "received_events_url": "https://api.github.com/users/oliverfunk/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": {"login": "josh11b", "id": 15258583, "node_id": "MDQ6VXNlcjE1MjU4NTgz", "avatar_url": "https://avatars0.githubusercontent.com/u/15258583?v=4", "gravatar_id": "", "url": "https://api.github.com/users/josh11b", "html_url": "https://github.com/josh11b", "followers_url": "https://api.github.com/users/josh11b/followers", "following_url": "https://api.github.com/users/josh11b/following{/other_user}", "gists_url": "https://api.github.com/users/josh11b/gists{/gist_id}", "starred_url": "https://api.github.com/users/josh11b/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/josh11b/subscriptions", "organizations_url": "https://api.github.com/users/josh11b/orgs", "repos_url": "https://api.github.com/users/josh11b/repos", "events_url": "https://api.github.com/users/josh11b/events{/privacy}", "received_events_url": "https://api.github.com/users/josh11b/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "josh11b", "id": 15258583, "node_id": "MDQ6VXNlcjE1MjU4NTgz", "avatar_url": "https://avatars0.githubusercontent.com/u/15258583?v=4", "gravatar_id": "", "url": "https://api.github.com/users/josh11b", "html_url": "https://github.com/josh11b", "followers_url": "https://api.github.com/users/josh11b/followers", "following_url": "https://api.github.com/users/josh11b/following{/other_user}", "gists_url": "https://api.github.com/users/josh11b/gists{/gist_id}", "starred_url": "https://api.github.com/users/josh11b/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/josh11b/subscriptions", "organizations_url": "https://api.github.com/users/josh11b/orgs", "repos_url": "https://api.github.com/users/josh11b/repos", "events_url": "https://api.github.com/users/josh11b/events{/privacy}", "received_events_url": "https://api.github.com/users/josh11b/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 4, "created_at": "2015-12-11T11:04:05Z", "updated_at": "2016-11-28T11:08:14Z", "closed_at": "2016-03-08T19:38:03Z", "author_association": "NONE", "body_html": "<p>In the <code>_dtype()</code> method in the training/input.py file, the following code for TypeError:</p>\n<pre><code>  raise TypeError(\"Expected types to be consistent: %s vs. %s.\" %\n                  \", \".join(x.name for x in types),\n                  \", \".join(x.name for x in other_types))\n</code></pre>\n<p>should be:</p>\n<pre><code>  raise TypeError(\"Expected types to be consistent: %s vs. %s.\" %\n                  (\", \".join(x.name for x in types),\n                  \", \".join(x.name for x in other_types)))\n</code></pre>\n<p>Also, when using the <code>tf.train.shuffle_batch_join()</code> method, you are suppose to pass a list of tuples of tensors, but if you pass a list of tuple and each tuple <em>only contains one item</em>, python will ignore the tuples and simply make it into a list. Thus, when the _flatten method in training/inputs.py is called, a <code>TypeError: 'Tensor' object is not iterable</code> is thrown. I suppose it's not necessarily a bug as one should know if you want to pass a tuple containing just one item, you must put a comma at the end of the tuple, but it may still may cause confusion.</p>\n<p>Instead, _flatten could be:</p>\n<pre><code>def _flatten(tensor_list_list):\n        for elm in tensor_list_list:\n            if not isinstance(elm, tuple):\n                raise TypeError(\"tensor_list_list must contain tuples.\")\n        return [tensor for tensor_list in tensor_list_list for tensor in tensor_list]\n</code></pre>", "body_text": "In the _dtype() method in the training/input.py file, the following code for TypeError:\n  raise TypeError(\"Expected types to be consistent: %s vs. %s.\" %\n                  \", \".join(x.name for x in types),\n                  \", \".join(x.name for x in other_types))\n\nshould be:\n  raise TypeError(\"Expected types to be consistent: %s vs. %s.\" %\n                  (\", \".join(x.name for x in types),\n                  \", \".join(x.name for x in other_types)))\n\nAlso, when using the tf.train.shuffle_batch_join() method, you are suppose to pass a list of tuples of tensors, but if you pass a list of tuple and each tuple only contains one item, python will ignore the tuples and simply make it into a list. Thus, when the _flatten method in training/inputs.py is called, a TypeError: 'Tensor' object is not iterable is thrown. I suppose it's not necessarily a bug as one should know if you want to pass a tuple containing just one item, you must put a comma at the end of the tuple, but it may still may cause confusion.\nInstead, _flatten could be:\ndef _flatten(tensor_list_list):\n        for elm in tensor_list_list:\n            if not isinstance(elm, tuple):\n                raise TypeError(\"tensor_list_list must contain tuples.\")\n        return [tensor for tensor_list in tensor_list_list for tensor in tensor_list]", "body": "In the `_dtype()` method in the training/input.py file, the following code for TypeError:\n\n```\n  raise TypeError(\"Expected types to be consistent: %s vs. %s.\" %\n                  \", \".join(x.name for x in types),\n                  \", \".join(x.name for x in other_types))\n```\n\nshould be:\n\n```\n  raise TypeError(\"Expected types to be consistent: %s vs. %s.\" %\n                  (\", \".join(x.name for x in types),\n                  \", \".join(x.name for x in other_types)))\n```\n\nAlso, when using the `tf.train.shuffle_batch_join()` method, you are suppose to pass a list of tuples of tensors, but if you pass a list of tuple and each tuple _only contains one item_, python will ignore the tuples and simply make it into a list. Thus, when the _flatten method in training/inputs.py is called, a `TypeError: 'Tensor' object is not iterable` is thrown. I suppose it's not necessarily a bug as one should know if you want to pass a tuple containing just one item, you must put a comma at the end of the tuple, but it may still may cause confusion.\n\nInstead, _flatten could be:\n\n```\ndef _flatten(tensor_list_list):\n        for elm in tensor_list_list:\n            if not isinstance(elm, tuple):\n                raise TypeError(\"tensor_list_list must contain tuples.\")\n        return [tensor for tensor_list in tensor_list_list for tensor in tensor_list]\n```\n"}