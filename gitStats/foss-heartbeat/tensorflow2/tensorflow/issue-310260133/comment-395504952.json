{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/395504952", "html_url": "https://github.com/tensorflow/tensorflow/issues/18149#issuecomment-395504952", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/18149", "id": 395504952, "node_id": "MDEyOklzc3VlQ29tbWVudDM5NTUwNDk1Mg==", "user": {"login": "davidscherer", "id": 859772, "node_id": "MDQ6VXNlcjg1OTc3Mg==", "avatar_url": "https://avatars1.githubusercontent.com/u/859772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidscherer", "html_url": "https://github.com/davidscherer", "followers_url": "https://api.github.com/users/davidscherer/followers", "following_url": "https://api.github.com/users/davidscherer/following{/other_user}", "gists_url": "https://api.github.com/users/davidscherer/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidscherer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidscherer/subscriptions", "organizations_url": "https://api.github.com/users/davidscherer/orgs", "repos_url": "https://api.github.com/users/davidscherer/repos", "events_url": "https://api.github.com/users/davidscherer/events{/privacy}", "received_events_url": "https://api.github.com/users/davidscherer/received_events", "type": "User", "site_admin": false}, "created_at": "2018-06-07T17:39:48Z", "updated_at": "2018-06-07T17:41:41Z", "author_association": "NONE", "body_html": "<p>If, before the call to session.Run(), you do something like this:</p>\n<pre><code>    if (!scope.ok()) {\n        LOG(FATAL) &lt;&lt; scope.status().ToString();\n        abort();\n    }\n</code></pre>\n<p>then you will get a more helpful error message:</p>\n<blockquote>\n<p>Invalid argument: Inconsistent values for attr 'T' DT_FLOAT vs. DT_DOUBLE while building NodeDef 'Model/init_v' using Op&lt;name=Assign; signature=ref:Ref(T), value:T -&gt; output_ref:Ref(T); attr=T:type; attr=validate_shape:bool,default=true; attr=use_locking:bool,default=true; allows_uninitialized_input=true&gt;</p>\n</blockquote>\n<p>But frankly I am more concerned about the SIGSEGV and lack of diagnostics.  What I have discovered in trying to use the Tensorflow C++ API is that as soon as you construct an operation with a shape or type error, scope.ok() becomes false.  Any subsequent operations added to the graph bail out of their constructors immediately, leaving them with node()==nullptr.  Then any call to Run() using these operations results in a segfault, as does Output::name() and probably other things that depend on a valid node.</p>\n<p>If it's intended that the user always check explicitly for scope errors before calling Run(), on penalty of undefined behavior, it seems to me that that should be reflected in the documentation and examples for the C++ API.  For example, in the first example at <a href=\"https://www.tensorflow.org/api_guides/cc/guide\" rel=\"nofollow\">https://www.tensorflow.org/api_guides/cc/guide</a> if you modify the matrix A to not be rectangular (like <code>auto A = Const(root, { {3.f, 2.f}, {-1.f} });</code>) you will get a segfault rather than the error message \"Invalid argument: Initializer list components should all have the same shape\".</p>\n<p>Ideally I think calling Run() in this scenario should result in an error status rather than a segfault!  Surely it would be simple to check session.ok() there.  I hesitate to offer architectural advice on a project I'm so new to, but it might be better not to initialize Operations to having a NULL node at all.</p>", "body_text": "If, before the call to session.Run(), you do something like this:\n    if (!scope.ok()) {\n        LOG(FATAL) << scope.status().ToString();\n        abort();\n    }\n\nthen you will get a more helpful error message:\n\nInvalid argument: Inconsistent values for attr 'T' DT_FLOAT vs. DT_DOUBLE while building NodeDef 'Model/init_v' using Op<name=Assign; signature=ref:Ref(T), value:T -> output_ref:Ref(T); attr=T:type; attr=validate_shape:bool,default=true; attr=use_locking:bool,default=true; allows_uninitialized_input=true>\n\nBut frankly I am more concerned about the SIGSEGV and lack of diagnostics.  What I have discovered in trying to use the Tensorflow C++ API is that as soon as you construct an operation with a shape or type error, scope.ok() becomes false.  Any subsequent operations added to the graph bail out of their constructors immediately, leaving them with node()==nullptr.  Then any call to Run() using these operations results in a segfault, as does Output::name() and probably other things that depend on a valid node.\nIf it's intended that the user always check explicitly for scope errors before calling Run(), on penalty of undefined behavior, it seems to me that that should be reflected in the documentation and examples for the C++ API.  For example, in the first example at https://www.tensorflow.org/api_guides/cc/guide if you modify the matrix A to not be rectangular (like auto A = Const(root, { {3.f, 2.f}, {-1.f} });) you will get a segfault rather than the error message \"Invalid argument: Initializer list components should all have the same shape\".\nIdeally I think calling Run() in this scenario should result in an error status rather than a segfault!  Surely it would be simple to check session.ok() there.  I hesitate to offer architectural advice on a project I'm so new to, but it might be better not to initialize Operations to having a NULL node at all.", "body": "If, before the call to session.Run(), you do something like this:\r\n\r\n        if (!scope.ok()) {\r\n            LOG(FATAL) << scope.status().ToString();\r\n            abort();\r\n        }\r\n\r\nthen you will get a more helpful error message:\r\n\r\n> Invalid argument: Inconsistent values for attr 'T' DT_FLOAT vs. DT_DOUBLE while building NodeDef 'Model/init_v' using Op<name=Assign; signature=ref:Ref(T), value:T -> output_ref:Ref(T); attr=T:type; attr=validate_shape:bool,default=true; attr=use_locking:bool,default=true; allows_uninitialized_input=true>\r\n\r\nBut frankly I am more concerned about the SIGSEGV and lack of diagnostics.  What I have discovered in trying to use the Tensorflow C++ API is that as soon as you construct an operation with a shape or type error, scope.ok() becomes false.  Any subsequent operations added to the graph bail out of their constructors immediately, leaving them with node()==nullptr.  Then any call to Run() using these operations results in a segfault, as does Output::name() and probably other things that depend on a valid node.\r\n\r\nIf it's intended that the user always check explicitly for scope errors before calling Run(), on penalty of undefined behavior, it seems to me that that should be reflected in the documentation and examples for the C++ API.  For example, in the first example at https://www.tensorflow.org/api_guides/cc/guide if you modify the matrix A to not be rectangular (like `auto A = Const(root, { {3.f, 2.f}, {-1.f} });`) you will get a segfault rather than the error message \"Invalid argument: Initializer list components should all have the same shape\".\r\n\r\nIdeally I think calling Run() in this scenario should result in an error status rather than a segfault!  Surely it would be simple to check session.ok() there.  I hesitate to offer architectural advice on a project I'm so new to, but it might be better not to initialize Operations to having a NULL node at all."}