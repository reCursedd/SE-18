{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/399559756", "html_url": "https://github.com/tensorflow/tensorflow/issues/18149#issuecomment-399559756", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/18149", "id": 399559756, "node_id": "MDEyOklzc3VlQ29tbWVudDM5OTU1OTc1Ng==", "user": {"login": "rajha-korithrien", "id": 8145476, "node_id": "MDQ6VXNlcjgxNDU0NzY=", "avatar_url": "https://avatars3.githubusercontent.com/u/8145476?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rajha-korithrien", "html_url": "https://github.com/rajha-korithrien", "followers_url": "https://api.github.com/users/rajha-korithrien/followers", "following_url": "https://api.github.com/users/rajha-korithrien/following{/other_user}", "gists_url": "https://api.github.com/users/rajha-korithrien/gists{/gist_id}", "starred_url": "https://api.github.com/users/rajha-korithrien/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rajha-korithrien/subscriptions", "organizations_url": "https://api.github.com/users/rajha-korithrien/orgs", "repos_url": "https://api.github.com/users/rajha-korithrien/repos", "events_url": "https://api.github.com/users/rajha-korithrien/events{/privacy}", "received_events_url": "https://api.github.com/users/rajha-korithrien/received_events", "type": "User", "site_admin": false}, "created_at": "2018-06-22T19:37:57Z", "updated_at": "2018-06-22T19:38:40Z", "author_association": "NONE", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=859772\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/davidscherer\">@davidscherer</a> Thanks for your explanation! My apologies for my late response. With your added information I know what is going on now.</p>\n<div class=\"highlight highlight-source-c++\"><pre>std::vector&lt;<span class=\"pl-k\">float</span>&gt; initConstData = {<span class=\"pl-c1\">1.0</span>, <span class=\"pl-c1\">2.0</span>, <span class=\"pl-c1\">3.0</span>, <span class=\"pl-c1\">4.0</span>, <span class=\"pl-c1\">5.0</span>, <span class=\"pl-c1\">6.0</span>, <span class=\"pl-c1\">7.0</span>, <span class=\"pl-c1\">8.0</span>, <span class=\"pl-c1\">9.0</span>};</pre></div>\n<p>Forces C++ to hold the numbers as floats rather than doubles. So when the following is executed:</p>\n<div class=\"highlight highlight-source-c++\"><pre>Tensor <span class=\"pl-en\">initConstT</span>(DT_FLOAT, TensorShape({<span class=\"pl-c1\">3</span>,<span class=\"pl-c1\">3</span>}));\n<span class=\"pl-en\">std::copy_n</span>(initConstData.begin(), initConstData.size(), initConstT.flat&lt;float&gt;().data());\n<span class=\"pl-k\">auto</span> c = Const(scope.WithOpName(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>const_c<span class=\"pl-pds\">\"</span></span>), initConstT);</pre></div>\n<p>The underlying data held in initConstT is float data. However when we use the implicit initialization code:</p>\n<div class=\"highlight highlight-source-c++\"><pre><span class=\"pl-k\">auto</span> c = Const(scope.WithOpName(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>const_c<span class=\"pl-pds\">\"</span></span>), {<span class=\"pl-c1\">1.0</span>, <span class=\"pl-c1\">2.0</span>, <span class=\"pl-c1\">3.0</span>, <span class=\"pl-c1\">4.0</span>, <span class=\"pl-c1\">5.0</span>, <span class=\"pl-c1\">6.0</span>, <span class=\"pl-c1\">7.0</span>, <span class=\"pl-c1\">8.0</span>, <span class=\"pl-c1\">9.0</span>}, {<span class=\"pl-c1\">3</span>,<span class=\"pl-c1\">3</span>});</pre></div>\n<p>The complier creates the initializer array as doubles instead of floats, which in turn means that 'c' holds double data. This causes a problem here:</p>\n<div class=\"highlight highlight-source-c++\"><pre><span class=\"pl-k\">auto</span> v = Variable(scope.WithOpName(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>var1<span class=\"pl-pds\">\"</span></span>), {<span class=\"pl-c1\">3</span>, <span class=\"pl-c1\">3</span>}, DT_FLOAT);\n<span class=\"pl-k\">auto</span> init_v = Assign(scope.WithOpName(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>init_v<span class=\"pl-pds\">\"</span></span>), v, c);</pre></div>\n<p>Because the tensorflow variable 'v' is defined to hold DT_FLOAT, but 'c' is holding DT_DOUBLE due to the implicit initializer array.</p>\n<p>Thank you for your help in figuring it out!</p>\n<p>I agree completely that the error was caused and known at the time of creating the init_v operation and the C++ API could raise an exception then and there much like the Java API does.<br>\nIf the API designers do not want to use the exception feature of C++, then I also agree with your approach of having session.Run() check the scope object for the user, rather than allowing a segfault occur.</p>", "body_text": "@davidscherer Thanks for your explanation! My apologies for my late response. With your added information I know what is going on now.\nstd::vector<float> initConstData = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0};\nForces C++ to hold the numbers as floats rather than doubles. So when the following is executed:\nTensor initConstT(DT_FLOAT, TensorShape({3,3}));\nstd::copy_n(initConstData.begin(), initConstData.size(), initConstT.flat<float>().data());\nauto c = Const(scope.WithOpName(\"const_c\"), initConstT);\nThe underlying data held in initConstT is float data. However when we use the implicit initialization code:\nauto c = Const(scope.WithOpName(\"const_c\"), {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0}, {3,3});\nThe complier creates the initializer array as doubles instead of floats, which in turn means that 'c' holds double data. This causes a problem here:\nauto v = Variable(scope.WithOpName(\"var1\"), {3, 3}, DT_FLOAT);\nauto init_v = Assign(scope.WithOpName(\"init_v\"), v, c);\nBecause the tensorflow variable 'v' is defined to hold DT_FLOAT, but 'c' is holding DT_DOUBLE due to the implicit initializer array.\nThank you for your help in figuring it out!\nI agree completely that the error was caused and known at the time of creating the init_v operation and the C++ API could raise an exception then and there much like the Java API does.\nIf the API designers do not want to use the exception feature of C++, then I also agree with your approach of having session.Run() check the scope object for the user, rather than allowing a segfault occur.", "body": "@davidscherer Thanks for your explanation! My apologies for my late response. With your added information I know what is going on now.\r\n```c++\r\nstd::vector<float> initConstData = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0};\r\n````\r\nForces C++ to hold the numbers as floats rather than doubles. So when the following is executed:\r\n```c++\r\nTensor initConstT(DT_FLOAT, TensorShape({3,3}));\r\nstd::copy_n(initConstData.begin(), initConstData.size(), initConstT.flat<float>().data());\r\nauto c = Const(scope.WithOpName(\"const_c\"), initConstT);\r\n```\r\nThe underlying data held in initConstT is float data. However when we use the implicit initialization code:\r\n```c++\r\nauto c = Const(scope.WithOpName(\"const_c\"), {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0}, {3,3});\r\n```\r\nThe complier creates the initializer array as doubles instead of floats, which in turn means that 'c' holds double data. This causes a problem here:\r\n```c++\r\nauto v = Variable(scope.WithOpName(\"var1\"), {3, 3}, DT_FLOAT);\r\nauto init_v = Assign(scope.WithOpName(\"init_v\"), v, c);\r\n```\r\nBecause the tensorflow variable 'v' is defined to hold DT_FLOAT, but 'c' is holding DT_DOUBLE due to the implicit initializer array.\r\n\r\nThank you for your help in figuring it out!\r\n\r\nI agree completely that the error was caused and known at the time of creating the init_v operation and the C++ API could raise an exception then and there much like the Java API does.\r\nIf the API designers do not want to use the exception feature of C++, then I also agree with your approach of having session.Run() check the scope object for the user, rather than allowing a segfault occur."}