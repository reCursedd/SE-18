{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/81859990", "pull_request_review_id": 2634755, "id": 81859990, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDgxODU5OTkw", "diff_hunk": "@@ -20,14 +20,17 @@\n from __future__ import print_function\n \n import tensorflow as tf\n-\n+import sys\n \n class DecodeRawOpTest(tf.test.TestCase):\n \n   def testToUint8(self):\n     with self.test_session():\n       in_bytes = tf.placeholder(tf.string, shape=[2])\n-      decode = tf.decode_raw(in_bytes, out_type=tf.uint8)\n+      if sys.byteorder == \"big\":\n+        decode = tf.decode_raw(in_bytes, out_type=tf.uint8, little_endian=False)", "path": "tensorflow/python/kernel_tests/decode_raw_op_test.py", "position": 14, "original_position": 14, "commit_id": "488d34c359ac031082e34b8a2834e5d0c03b22b6", "original_commit_id": "488d34c359ac031082e34b8a2834e5d0c03b22b6", "user": {"login": "aselle", "id": 326106, "node_id": "MDQ6VXNlcjMyNjEwNg==", "avatar_url": "https://avatars1.githubusercontent.com/u/326106?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aselle", "html_url": "https://github.com/aselle", "followers_url": "https://api.github.com/users/aselle/followers", "following_url": "https://api.github.com/users/aselle/following{/other_user}", "gists_url": "https://api.github.com/users/aselle/gists{/gist_id}", "starred_url": "https://api.github.com/users/aselle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aselle/subscriptions", "organizations_url": "https://api.github.com/users/aselle/orgs", "repos_url": "https://api.github.com/users/aselle/repos", "events_url": "https://api.github.com/users/aselle/events{/privacy}", "received_events_url": "https://api.github.com/users/aselle/received_events", "type": "User", "site_admin": false}, "body": "i.e. suppose we have a byte string that is encoded little endian\n`const* foo_little[]=\"Aa\";`\nthen it will be encoded as big-endian as\n`const* foo_big[]=\"aA\";`\nThen on a big-endian or little-endian machine big-endian data can be converted to uint16 array as\n\n``` c++\nstd::vector<uint16> vals;\nfor(char* p=foo_little; *p != 0; p+=2)\n   vals.push_back((p[0]<<8)  | (p[1]));\n}\n```\n\nLittle endian data can be converted to a big-endian or ltitle-endian machine with\n\n``` c++\nstd::vector<uint16> vals;\nfor(char* p=foo_big; *p != 0; p+=2)\n   vals.push_back((p[0])  | (p[1]<<8));\n}\n```\n\nSo, when you construct the string in python you are saying it is little endian or big endian... so the test should look like\n\n``` python\nbig_endian_data = \"aA\"\nlittle_endian_data = \"Aa\"\na=tf.decode_raw(little_endian_data, little_endian=None);\nb=tf.decode_raw(little_endian_data, little_endian=True);\nc=tf.decode_raw(big_endian_data, little_endian=False);\nassertEqual(a,b)\nassertEqual(a,c)\nmanual_decode =  little_endian_data[0] | (little_endian_data[1]<<8)\nassertEqual(a, manual_decode) # this verifies that endianness is correct\n```\n\n(note this is for unsigned data, since the number encode is less than 1<<15 we can use this conversion routine for these numbers, but you need to adapt this for signed values.\n", "created_at": "2016-10-04T21:39:28Z", "updated_at": "2016-10-04T21:39:43Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/4508#discussion_r81859990", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/4508", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/81859990"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/4508#discussion_r81859990"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/4508"}}, "body_html": "<p>i.e. suppose we have a byte string that is encoded little endian<br>\n<code>const* foo_little[]=\"Aa\";</code><br>\nthen it will be encoded as big-endian as<br>\n<code>const* foo_big[]=\"aA\";</code><br>\nThen on a big-endian or little-endian machine big-endian data can be converted to uint16 array as</p>\n<div class=\"highlight highlight-source-c++\"><pre>std::vector&lt;uint16&gt; vals;\n<span class=\"pl-k\">for</span>(<span class=\"pl-k\">char</span>* p=foo_little; *p != <span class=\"pl-c1\">0</span>; p+=<span class=\"pl-c1\">2</span>)\n   vals.push_back((p[<span class=\"pl-c1\">0</span>]&lt;&lt;<span class=\"pl-c1\">8</span>)  | (p[<span class=\"pl-c1\">1</span>]));\n}</pre></div>\n<p>Little endian data can be converted to a big-endian or ltitle-endian machine with</p>\n<div class=\"highlight highlight-source-c++\"><pre>std::vector&lt;uint16&gt; vals;\n<span class=\"pl-k\">for</span>(<span class=\"pl-k\">char</span>* p=foo_big; *p != <span class=\"pl-c1\">0</span>; p+=<span class=\"pl-c1\">2</span>)\n   vals.push_back((p[<span class=\"pl-c1\">0</span>])  | (p[<span class=\"pl-c1\">1</span>]&lt;&lt;<span class=\"pl-c1\">8</span>));\n}</pre></div>\n<p>So, when you construct the string in python you are saying it is little endian or big endian... so the test should look like</p>\n<div class=\"highlight highlight-source-python\"><pre>big_endian_data <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>aA<span class=\"pl-pds\">\"</span></span>\nlittle_endian_data <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Aa<span class=\"pl-pds\">\"</span></span>\na<span class=\"pl-k\">=</span>tf.decode_raw(little_endian_data, <span class=\"pl-v\">little_endian</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">None</span>)<span class=\"pl-bu\">;</span>\nb<span class=\"pl-k\">=</span>tf.decode_raw(little_endian_data, <span class=\"pl-v\">little_endian</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">True</span>)<span class=\"pl-bu\">;</span>\nc<span class=\"pl-k\">=</span>tf.decode_raw(big_endian_data, <span class=\"pl-v\">little_endian</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">False</span>)<span class=\"pl-bu\">;</span>\nassertEqual(a,b)\nassertEqual(a,c)\nmanual_decode <span class=\"pl-k\">=</span>  little_endian_data[<span class=\"pl-c1\">0</span>] <span class=\"pl-k\">|</span> (little_endian_data[<span class=\"pl-c1\">1</span>]<span class=\"pl-k\">&lt;&lt;</span><span class=\"pl-c1\">8</span>)\nassertEqual(a, manual_decode) <span class=\"pl-c\"><span class=\"pl-c\">#</span> this verifies that endianness is correct</span></pre></div>\n<p>(note this is for unsigned data, since the number encode is less than 1&lt;&lt;15 we can use this conversion routine for these numbers, but you need to adapt this for signed values.</p>", "body_text": "i.e. suppose we have a byte string that is encoded little endian\nconst* foo_little[]=\"Aa\";\nthen it will be encoded as big-endian as\nconst* foo_big[]=\"aA\";\nThen on a big-endian or little-endian machine big-endian data can be converted to uint16 array as\nstd::vector<uint16> vals;\nfor(char* p=foo_little; *p != 0; p+=2)\n   vals.push_back((p[0]<<8)  | (p[1]));\n}\nLittle endian data can be converted to a big-endian or ltitle-endian machine with\nstd::vector<uint16> vals;\nfor(char* p=foo_big; *p != 0; p+=2)\n   vals.push_back((p[0])  | (p[1]<<8));\n}\nSo, when you construct the string in python you are saying it is little endian or big endian... so the test should look like\nbig_endian_data = \"aA\"\nlittle_endian_data = \"Aa\"\na=tf.decode_raw(little_endian_data, little_endian=None);\nb=tf.decode_raw(little_endian_data, little_endian=True);\nc=tf.decode_raw(big_endian_data, little_endian=False);\nassertEqual(a,b)\nassertEqual(a,c)\nmanual_decode =  little_endian_data[0] | (little_endian_data[1]<<8)\nassertEqual(a, manual_decode) # this verifies that endianness is correct\n(note this is for unsigned data, since the number encode is less than 1<<15 we can use this conversion routine for these numbers, but you need to adapt this for signed values.", "in_reply_to_id": 81856232}