{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13897", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13897/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13897/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13897/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/13897", "id": 267434415, "node_id": "MDU6SXNzdWUyNjc0MzQ0MTU=", "number": 13897, "title": "No OpKernel was registered to support Op 'SegmentSum'", "user": {"login": "formath", "id": 6040127, "node_id": "MDQ6VXNlcjYwNDAxMjc=", "avatar_url": "https://avatars3.githubusercontent.com/u/6040127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/formath", "html_url": "https://github.com/formath", "followers_url": "https://api.github.com/users/formath/followers", "following_url": "https://api.github.com/users/formath/following{/other_user}", "gists_url": "https://api.github.com/users/formath/gists{/gist_id}", "starred_url": "https://api.github.com/users/formath/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/formath/subscriptions", "organizations_url": "https://api.github.com/users/formath/orgs", "repos_url": "https://api.github.com/users/formath/repos", "events_url": "https://api.github.com/users/formath/events{/privacy}", "received_events_url": "https://api.github.com/users/formath/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2017-10-22T04:16:17Z", "updated_at": "2017-10-22T12:59:55Z", "closed_at": "2017-10-22T12:59:55Z", "author_association": "CONTRIBUTOR", "body_html": "<h3>ENV</h3>\n<ul>\n<li>OSX 10.12.6</li>\n<li>No GPU</li>\n<li>Tensorflow master. Built from source by <code>tensorflow/contrib/makefile/build_all_linux.sh</code></li>\n</ul>\n<h3>Error info</h3>\n<pre><code>Invalid argument: No OpKernel was registered to support Op 'SegmentSum' with these attrs.  Registered devices: [CPU], Registered kernels:\n  &lt;no registered kernels&gt;\n\n\t [[Node: emb_179/embedding_lookup_sparse = SegmentSum[T=DT_FLOAT, Tindices=DT_INT32](emb_179/embedding_lookup_sparse/mul, emb_179/embedding_lookup_sparse/Cast)]]\n</code></pre>\n<h3>My usage</h3>\n<p>I use python to train model and freeze the graph with checkpoint. Then I use c++ to load freeze graph protobuf and to predict for some inputs.</p>\n<h4>python core part</h4>\n<pre><code>with tf.variable_scope('input/sparse_field'):\n  with tf.variable_scope('index'):\n    sparse_index = tf.placeholder(tf.int64)\n  with tf.variable_scope('id'):\n   sparse_id = tf.placeholder(tf.int64)\n   with tf.variable_scope('value'):\n    sparse_val = tf.placeholder(tf.float32)\n  with tf.variable_scope('shape'):\n    sparse_shape = tf.placeholder(tf.int64)\nwith tf.variable_scope('label'):\n  label = tf.placeholder(tf.float32)\nsparse_ids = tf.SparseTensor(sparse_index, sparse_id, sparse_shape)\nsparse_vals = tf.SparseTensor(sparse_index, sparse_val, sparse_shape)\n\ninput_size = 100\nembedding_size = 50\nwith tf.variable_scope(\"emb_179\"):\n  embedding_variable = tf.Variable(tf.truncated_normal([input_size, embedding_size], stddev=0.05), name='emb' + str(field_id))\n  embedding = tf.nn.embedding_lookup_sparse(embedding_variable, sparse_ids, sparse_vals, \"mod\", combiner=\"sum\")\n...\n</code></pre>\n<h4>C++ prediction core part</h4>\n<pre><code>auto id_indice_tensor =\ntest::AsTensor&lt;int64&gt;(indice, {static_cast&lt;int64&gt;(indice.size()/2), 2});\ninputs.push_back(std::pair&lt;std::string, Tensor&gt;(\"input/sparse_field/index/Placeholder\", id_indice_tensor));\nauto id_list_tensor = test::AsTensor&lt;int64&gt;(fid_list);\ninputs.push_back(std::pair&lt;std::string, Tensor&gt;(\"input/sparse_field/id/Placeholder\", id_list_tensor));\nauto val_list_tensor = test::AsTensor&lt;float&gt;(fval_list);\ninputs.push_back(std::pair&lt;std::string, Tensor&gt;(\"input/sparse_field/value/Placeholder\", val_list_tensor));\n\nstd::vector&lt;tensorflow::Tensor&gt; outputs;\nStatus status = session-&gt;Run(inputs, {\"predict/add\"}, {}, &amp;outputs);\n</code></pre>\n<h3>Have checked</h3>\n<p>I have checked it has registered all real type and complex type in cpu mode.<br>\n<div class=\"border rounded-1 my-2\">\n  <div class=\"f6 px-3 py-2 lh-condensed border-bottom bg-gray-light\">\n    <p class=\"mb-0 text-bold\">\n      <a href=\"https://github.com/tensorflow/tensorflow/blob/d1183ca6a245cd0b498c46fd1079909ebc4abc3a/tensorflow/core/kernels/segment_reduction_ops.cc#L333\">tensorflow/tensorflow/core/kernels/segment_reduction_ops.cc</a>\n    </p>\n    <p class=\"mb-0 text-gray-light\">\n         Line 333\n      in\n      <a data-pjax=\"true\" class=\"commit-tease-sha\" href=\"/tensorflow/tensorflow/commit/d1183ca6a245cd0b498c46fd1079909ebc4abc3a\">d1183ca</a>\n    </p>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper blob-wrapper-embedded data\">\n    <table class=\"highlight tab-size mb-0 js-file-line-container\" data-tab-size=\"8\">\n\n        <tbody><tr class=\"border-0\">\n          <td id=\"L333\" class=\"blob-num border-0 px-3 py-0 bg-white js-line-number\" data-line-number=\"333\"></td>\n          <td id=\"LC333\" class=\"blob-code border-0 px-3 py-0 bg-white blob-code-inner js-file-line\"> TF_CALL_REAL_NUMBER_TYPES(REGISTER_REAL_CPU_KERNELS_ALL); </td>\n        </tr>\n    </tbody></table>\n  </div>\n</div>\n</p>\n<pre><code>TF_CALL_REAL_NUMBER_TYPES(REGISTER_REAL_CPU_KERNELS_ALL);\nREGISTER_COMPLEX_CPU_KERNELS_ALL(complex64);\nREGISTER_COMPLEX_CPU_KERNELS_ALL(complex128);\n</code></pre>", "body_text": "ENV\n\nOSX 10.12.6\nNo GPU\nTensorflow master. Built from source by tensorflow/contrib/makefile/build_all_linux.sh\n\nError info\nInvalid argument: No OpKernel was registered to support Op 'SegmentSum' with these attrs.  Registered devices: [CPU], Registered kernels:\n  <no registered kernels>\n\n\t [[Node: emb_179/embedding_lookup_sparse = SegmentSum[T=DT_FLOAT, Tindices=DT_INT32](emb_179/embedding_lookup_sparse/mul, emb_179/embedding_lookup_sparse/Cast)]]\n\nMy usage\nI use python to train model and freeze the graph with checkpoint. Then I use c++ to load freeze graph protobuf and to predict for some inputs.\npython core part\nwith tf.variable_scope('input/sparse_field'):\n  with tf.variable_scope('index'):\n    sparse_index = tf.placeholder(tf.int64)\n  with tf.variable_scope('id'):\n   sparse_id = tf.placeholder(tf.int64)\n   with tf.variable_scope('value'):\n    sparse_val = tf.placeholder(tf.float32)\n  with tf.variable_scope('shape'):\n    sparse_shape = tf.placeholder(tf.int64)\nwith tf.variable_scope('label'):\n  label = tf.placeholder(tf.float32)\nsparse_ids = tf.SparseTensor(sparse_index, sparse_id, sparse_shape)\nsparse_vals = tf.SparseTensor(sparse_index, sparse_val, sparse_shape)\n\ninput_size = 100\nembedding_size = 50\nwith tf.variable_scope(\"emb_179\"):\n  embedding_variable = tf.Variable(tf.truncated_normal([input_size, embedding_size], stddev=0.05), name='emb' + str(field_id))\n  embedding = tf.nn.embedding_lookup_sparse(embedding_variable, sparse_ids, sparse_vals, \"mod\", combiner=\"sum\")\n...\n\nC++ prediction core part\nauto id_indice_tensor =\ntest::AsTensor<int64>(indice, {static_cast<int64>(indice.size()/2), 2});\ninputs.push_back(std::pair<std::string, Tensor>(\"input/sparse_field/index/Placeholder\", id_indice_tensor));\nauto id_list_tensor = test::AsTensor<int64>(fid_list);\ninputs.push_back(std::pair<std::string, Tensor>(\"input/sparse_field/id/Placeholder\", id_list_tensor));\nauto val_list_tensor = test::AsTensor<float>(fval_list);\ninputs.push_back(std::pair<std::string, Tensor>(\"input/sparse_field/value/Placeholder\", val_list_tensor));\n\nstd::vector<tensorflow::Tensor> outputs;\nStatus status = session->Run(inputs, {\"predict/add\"}, {}, &outputs);\n\nHave checked\nI have checked it has registered all real type and complex type in cpu mode.\n\n  \n    \n      tensorflow/tensorflow/core/kernels/segment_reduction_ops.cc\n    \n    \n         Line 333\n      in\n      d1183ca\n    \n    \n    \n    \n\n        \n          \n           TF_CALL_REAL_NUMBER_TYPES(REGISTER_REAL_CPU_KERNELS_ALL); \n        \n    \n  \n\n\nTF_CALL_REAL_NUMBER_TYPES(REGISTER_REAL_CPU_KERNELS_ALL);\nREGISTER_COMPLEX_CPU_KERNELS_ALL(complex64);\nREGISTER_COMPLEX_CPU_KERNELS_ALL(complex128);", "body": "### ENV\r\n* OSX 10.12.6\r\n* No GPU\r\n* Tensorflow master. Built from source by `tensorflow/contrib/makefile/build_all_linux.sh`\r\n\r\n### Error info\r\n```\r\nInvalid argument: No OpKernel was registered to support Op 'SegmentSum' with these attrs.  Registered devices: [CPU], Registered kernels:\r\n  <no registered kernels>\r\n\r\n\t [[Node: emb_179/embedding_lookup_sparse = SegmentSum[T=DT_FLOAT, Tindices=DT_INT32](emb_179/embedding_lookup_sparse/mul, emb_179/embedding_lookup_sparse/Cast)]]\r\n``` \r\n\r\n### My usage\r\nI use python to train model and freeze the graph with checkpoint. Then I use c++ to load freeze graph protobuf and to predict for some inputs.\r\n#### python core part\r\n```\r\nwith tf.variable_scope('input/sparse_field'):\r\n  with tf.variable_scope('index'):\r\n    sparse_index = tf.placeholder(tf.int64)\r\n  with tf.variable_scope('id'):\r\n   sparse_id = tf.placeholder(tf.int64)\r\n   with tf.variable_scope('value'):\r\n    sparse_val = tf.placeholder(tf.float32)\r\n  with tf.variable_scope('shape'):\r\n    sparse_shape = tf.placeholder(tf.int64)\r\nwith tf.variable_scope('label'):\r\n  label = tf.placeholder(tf.float32)\r\nsparse_ids = tf.SparseTensor(sparse_index, sparse_id, sparse_shape)\r\nsparse_vals = tf.SparseTensor(sparse_index, sparse_val, sparse_shape)\r\n\r\ninput_size = 100\r\nembedding_size = 50\r\nwith tf.variable_scope(\"emb_179\"):\r\n  embedding_variable = tf.Variable(tf.truncated_normal([input_size, embedding_size], stddev=0.05), name='emb' + str(field_id))\r\n  embedding = tf.nn.embedding_lookup_sparse(embedding_variable, sparse_ids, sparse_vals, \"mod\", combiner=\"sum\")\r\n...\r\n``` \r\n#### C++ prediction core part\r\n```\r\nauto id_indice_tensor =\r\ntest::AsTensor<int64>(indice, {static_cast<int64>(indice.size()/2), 2});\r\ninputs.push_back(std::pair<std::string, Tensor>(\"input/sparse_field/index/Placeholder\", id_indice_tensor));\r\nauto id_list_tensor = test::AsTensor<int64>(fid_list);\r\ninputs.push_back(std::pair<std::string, Tensor>(\"input/sparse_field/id/Placeholder\", id_list_tensor));\r\nauto val_list_tensor = test::AsTensor<float>(fval_list);\r\ninputs.push_back(std::pair<std::string, Tensor>(\"input/sparse_field/value/Placeholder\", val_list_tensor));\r\n\r\nstd::vector<tensorflow::Tensor> outputs;\r\nStatus status = session->Run(inputs, {\"predict/add\"}, {}, &outputs);\r\n```\r\n\r\n### Have checked\r\nI have checked it has registered all real type and complex type in cpu mode. \r\nhttps://github.com/tensorflow/tensorflow/blob/d1183ca6a245cd0b498c46fd1079909ebc4abc3a/tensorflow/core/kernels/segment_reduction_ops.cc#L333\r\n```\r\nTF_CALL_REAL_NUMBER_TYPES(REGISTER_REAL_CPU_KERNELS_ALL);\r\nREGISTER_COMPLEX_CPU_KERNELS_ALL(complex64);\r\nREGISTER_COMPLEX_CPU_KERNELS_ALL(complex128);\r\n```"}