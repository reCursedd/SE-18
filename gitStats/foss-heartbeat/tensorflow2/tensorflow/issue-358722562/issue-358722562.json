{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/22197", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/22197/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/22197/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/22197/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/22197", "id": 358722562, "node_id": "MDU6SXNzdWUzNTg3MjI1NjI=", "number": 22197, "title": "KeyError u'ImageProjectiveTransform' when loading Tensorflow model", "user": {"login": "sadimanna", "id": 21175586, "node_id": "MDQ6VXNlcjIxMTc1NTg2", "avatar_url": "https://avatars2.githubusercontent.com/u/21175586?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sadimanna", "html_url": "https://github.com/sadimanna", "followers_url": "https://api.github.com/users/sadimanna/followers", "following_url": "https://api.github.com/users/sadimanna/following{/other_user}", "gists_url": "https://api.github.com/users/sadimanna/gists{/gist_id}", "starred_url": "https://api.github.com/users/sadimanna/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sadimanna/subscriptions", "organizations_url": "https://api.github.com/users/sadimanna/orgs", "repos_url": "https://api.github.com/users/sadimanna/repos", "events_url": "https://api.github.com/users/sadimanna/events{/privacy}", "received_events_url": "https://api.github.com/users/sadimanna/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 386191887, "node_id": "MDU6TGFiZWwzODYxOTE4ODc=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:awaiting%20response", "name": "stat:awaiting response", "color": "f4b400", "default": false}], "state": "closed", "locked": false, "assignee": {"login": "asimshankar", "id": 16018, "node_id": "MDQ6VXNlcjE2MDE4", "avatar_url": "https://avatars2.githubusercontent.com/u/16018?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asimshankar", "html_url": "https://github.com/asimshankar", "followers_url": "https://api.github.com/users/asimshankar/followers", "following_url": "https://api.github.com/users/asimshankar/following{/other_user}", "gists_url": "https://api.github.com/users/asimshankar/gists{/gist_id}", "starred_url": "https://api.github.com/users/asimshankar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asimshankar/subscriptions", "organizations_url": "https://api.github.com/users/asimshankar/orgs", "repos_url": "https://api.github.com/users/asimshankar/repos", "events_url": "https://api.github.com/users/asimshankar/events{/privacy}", "received_events_url": "https://api.github.com/users/asimshankar/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "asimshankar", "id": 16018, "node_id": "MDQ6VXNlcjE2MDE4", "avatar_url": "https://avatars2.githubusercontent.com/u/16018?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asimshankar", "html_url": "https://github.com/asimshankar", "followers_url": "https://api.github.com/users/asimshankar/followers", "following_url": "https://api.github.com/users/asimshankar/following{/other_user}", "gists_url": "https://api.github.com/users/asimshankar/gists{/gist_id}", "starred_url": "https://api.github.com/users/asimshankar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asimshankar/subscriptions", "organizations_url": "https://api.github.com/users/asimshankar/orgs", "repos_url": "https://api.github.com/users/asimshankar/repos", "events_url": "https://api.github.com/users/asimshankar/events{/privacy}", "received_events_url": "https://api.github.com/users/asimshankar/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 5, "created_at": "2018-09-10T17:36:19Z", "updated_at": "2018-11-08T09:49:36Z", "closed_at": "2018-10-31T18:21:31Z", "author_association": "NONE", "body_html": "<h3>System information</h3>\n<ul>\n<li><strong>Have I written custom code (as opposed to using a stock example script provided in TensorFlow)</strong>: Yes</li>\n<li><strong>OS Platform and Distribution</strong>: Linux Ubuntu 16.04</li>\n<li><strong>Mobile device (e.g. iPhone 8, Pixel 2, Samsung Galaxy) if the issue happens on mobile device</strong>: NA</li>\n<li><strong>TensorFlow installed from (source or binary)</strong>: using pip</li>\n<li><strong>TensorFlow version (use command below)</strong>:1.10.0</li>\n<li><strong>Python version</strong>: 2.7.12</li>\n<li><strong>Bazel version (if compiling from source)</strong>: NA</li>\n<li><strong>GCC/Compiler version (if compiling from source)</strong>: NA</li>\n<li><strong>CUDA/cuDNN version</strong>:</li>\n<li><strong>GPU model and memory</strong>: Tesla K80 on Google Colab</li>\n<li><strong>Exact command to reproduce</strong>:</li>\n</ul>\n<h3>Describe the problem</h3>\n<p>I trained a ConvNet on MNIST, and saved the model using simple_save.</p>\n<p>When loading the saved model, using<br>\n<code>tf.saved_model.loader.load(sess,[tag_constants.SERVING],'/save_folder')</code></p>\n<p>I get this error <code>KeyError: u'ImageProjectiveTransform'</code></p>\n<p>Code for saving my ConvNet model</p>\n<pre><code>graph = tf.get_default_graph()\n\nfrom tensorflow.python.saved_model import tag_constants\nwith graph.as_default():\n  input_dict = {\"x\":x,\"y\":y,\"keep_prob\":keep_prob,\"aug_img\":aug_img}\n  output_dict = {\"logits\":fc3}\n  tf.saved_model.simple_save(sess,'/saved_model/',input_dict,output_dict)\n</code></pre>\n<p>I used tf.contrib.image.rotate as a augmentation technique, but didn't add that to any of the dicts while saving the model.</p>\n<h3>Source code / logs</h3>\n<p>This is the code for the model and the training part</p>\n<pre><code>x = tf.placeholder(tf.float32,shape=[None,28,28])\ny = tf.placeholder(tf.int64,shape=[None])\nkeep_prob = tf.placeholder(tf.float32,shape=())\nlr = tf.placeholder(tf.float32,shape=())\n\naug_img = tf.placeholder(tf.float32,shape=[28,28])\n\nimg_rotate = tf.contrib.image.rotate(aug_img,-0.5+np.random.random(),interpolation='BILINEAR')\nimg_affine = tf.contrib.image.transform(aug_img,[np.random.random() for i in xrange(8)])\n\nwith tf.device('/gpu:0'):\n  conv1 = tf.layers.conv2d(tf.reshape(x,shape=[-1,28,28,1]),filters=64,kernel_size=3,strides=1,padding='same',activation=tf.nn.leaky_relu)\n  conv2 = tf.layers.conv2d(conv1,filters=64,kernel_size=3,strides=2,padding='same',activation=tf.nn.leaky_relu) #NX14X14\n  conv3 = tf.layers.conv2d(conv2,filters=128,kernel_size=3,strides=1,padding='same',activation=tf.nn.leaky_relu)\n  conv4 = tf.layers.conv2d(conv3,filters=64,kernel_size=1,strides=1,padding='same',activation=tf.nn.leaky_relu)\n  conv5 = tf.layers.conv2d(conv4,filters=128,kernel_size=3,strides=2,padding='same',activation=tf.nn.leaky_relu) #NX7X7\n  conv6 = tf.layers.conv2d(conv5,filters=64,kernel_size=1,strides=1,padding='same',activation=tf.nn.leaky_relu)\n  conv7 = tf.layers.conv2d(conv6,filters=128,kernel_size=3,strides=2,padding='same',activation=tf.nn.leaky_relu) #NX3X3\n  conv8 = tf.layers.conv2d(conv7,filters=128,kernel_size=3,strides=1,padding='same',activation=tf.nn.leaky_relu) #NX1X1\n  flat = tf.contrib.layers.flatten(conv7)\n  fc1 = tf.layers.dense(flat,units=256,activation=tf.nn.leaky_relu)\n  do1 = tf.nn.dropout(fc1,keep_prob)\n  fc2 = tf.layers.dense(do1,units=256,activation=tf.nn.leaky_relu)\n  do2 = tf.nn.dropout(fc2,keep_prob)\n  fc3 = tf.layers.dense(do2,units=10)\n  \n  cost = loss(fc3,y)\n  opt = tf.train.AdamOptimizer(learning_rate=0.0001)\n  opt_op = opt.minimize(cost)\n  \n  top1_acc = accuracy(fc3,y)\n\nepochs = 25\nne=0\nbatchsize = 50\nnumiter = 400\nwhile(ne&lt;epochs):\n    print 'Epoch:: ',ne+1,'--&gt;'\n    stime = time.time()\n    if ne != 0:\n       np.random.shuffle(index)\n       images = images[index]\n       labels = labels[index]\n    for niter in xrange(numiter):\n      offset = niter*batch_size\n      x_iter, y_iter = np.array(images[offset:offset+batch_size,:,:]), np.array(labels[offset:offset+batch_size])\n      for n in xrange(batch_size):\n        augs = np.random.choice([True,False])\n        if augs==True:\n          x_iter[n] = sess.run(img_rotate,feed_dict={aug_img:x_iter[n]})\n      feed_trdict={x:x_iter,y:y_iter,keep_prob:0.6}\n      sess.run(opt_op,feed_dict=feed_trdict)\n    ne+=1\n\n</code></pre>", "body_text": "System information\n\nHave I written custom code (as opposed to using a stock example script provided in TensorFlow): Yes\nOS Platform and Distribution: Linux Ubuntu 16.04\nMobile device (e.g. iPhone 8, Pixel 2, Samsung Galaxy) if the issue happens on mobile device: NA\nTensorFlow installed from (source or binary): using pip\nTensorFlow version (use command below):1.10.0\nPython version: 2.7.12\nBazel version (if compiling from source): NA\nGCC/Compiler version (if compiling from source): NA\nCUDA/cuDNN version:\nGPU model and memory: Tesla K80 on Google Colab\nExact command to reproduce:\n\nDescribe the problem\nI trained a ConvNet on MNIST, and saved the model using simple_save.\nWhen loading the saved model, using\ntf.saved_model.loader.load(sess,[tag_constants.SERVING],'/save_folder')\nI get this error KeyError: u'ImageProjectiveTransform'\nCode for saving my ConvNet model\ngraph = tf.get_default_graph()\n\nfrom tensorflow.python.saved_model import tag_constants\nwith graph.as_default():\n  input_dict = {\"x\":x,\"y\":y,\"keep_prob\":keep_prob,\"aug_img\":aug_img}\n  output_dict = {\"logits\":fc3}\n  tf.saved_model.simple_save(sess,'/saved_model/',input_dict,output_dict)\n\nI used tf.contrib.image.rotate as a augmentation technique, but didn't add that to any of the dicts while saving the model.\nSource code / logs\nThis is the code for the model and the training part\nx = tf.placeholder(tf.float32,shape=[None,28,28])\ny = tf.placeholder(tf.int64,shape=[None])\nkeep_prob = tf.placeholder(tf.float32,shape=())\nlr = tf.placeholder(tf.float32,shape=())\n\naug_img = tf.placeholder(tf.float32,shape=[28,28])\n\nimg_rotate = tf.contrib.image.rotate(aug_img,-0.5+np.random.random(),interpolation='BILINEAR')\nimg_affine = tf.contrib.image.transform(aug_img,[np.random.random() for i in xrange(8)])\n\nwith tf.device('/gpu:0'):\n  conv1 = tf.layers.conv2d(tf.reshape(x,shape=[-1,28,28,1]),filters=64,kernel_size=3,strides=1,padding='same',activation=tf.nn.leaky_relu)\n  conv2 = tf.layers.conv2d(conv1,filters=64,kernel_size=3,strides=2,padding='same',activation=tf.nn.leaky_relu) #NX14X14\n  conv3 = tf.layers.conv2d(conv2,filters=128,kernel_size=3,strides=1,padding='same',activation=tf.nn.leaky_relu)\n  conv4 = tf.layers.conv2d(conv3,filters=64,kernel_size=1,strides=1,padding='same',activation=tf.nn.leaky_relu)\n  conv5 = tf.layers.conv2d(conv4,filters=128,kernel_size=3,strides=2,padding='same',activation=tf.nn.leaky_relu) #NX7X7\n  conv6 = tf.layers.conv2d(conv5,filters=64,kernel_size=1,strides=1,padding='same',activation=tf.nn.leaky_relu)\n  conv7 = tf.layers.conv2d(conv6,filters=128,kernel_size=3,strides=2,padding='same',activation=tf.nn.leaky_relu) #NX3X3\n  conv8 = tf.layers.conv2d(conv7,filters=128,kernel_size=3,strides=1,padding='same',activation=tf.nn.leaky_relu) #NX1X1\n  flat = tf.contrib.layers.flatten(conv7)\n  fc1 = tf.layers.dense(flat,units=256,activation=tf.nn.leaky_relu)\n  do1 = tf.nn.dropout(fc1,keep_prob)\n  fc2 = tf.layers.dense(do1,units=256,activation=tf.nn.leaky_relu)\n  do2 = tf.nn.dropout(fc2,keep_prob)\n  fc3 = tf.layers.dense(do2,units=10)\n  \n  cost = loss(fc3,y)\n  opt = tf.train.AdamOptimizer(learning_rate=0.0001)\n  opt_op = opt.minimize(cost)\n  \n  top1_acc = accuracy(fc3,y)\n\nepochs = 25\nne=0\nbatchsize = 50\nnumiter = 400\nwhile(ne<epochs):\n    print 'Epoch:: ',ne+1,'-->'\n    stime = time.time()\n    if ne != 0:\n       np.random.shuffle(index)\n       images = images[index]\n       labels = labels[index]\n    for niter in xrange(numiter):\n      offset = niter*batch_size\n      x_iter, y_iter = np.array(images[offset:offset+batch_size,:,:]), np.array(labels[offset:offset+batch_size])\n      for n in xrange(batch_size):\n        augs = np.random.choice([True,False])\n        if augs==True:\n          x_iter[n] = sess.run(img_rotate,feed_dict={aug_img:x_iter[n]})\n      feed_trdict={x:x_iter,y:y_iter,keep_prob:0.6}\n      sess.run(opt_op,feed_dict=feed_trdict)\n    ne+=1", "body": "### System information\r\n- **Have I written custom code (as opposed to using a stock example script provided in TensorFlow)**: Yes\r\n- **OS Platform and Distribution**: Linux Ubuntu 16.04\r\n- **Mobile device (e.g. iPhone 8, Pixel 2, Samsung Galaxy) if the issue happens on mobile device**: NA\r\n- **TensorFlow installed from (source or binary)**: using pip\r\n- **TensorFlow version (use command below)**:1.10.0\r\n- **Python version**: 2.7.12\r\n- **Bazel version (if compiling from source)**: NA\r\n- **GCC/Compiler version (if compiling from source)**: NA\r\n- **CUDA/cuDNN version**: \r\n- **GPU model and memory**: Tesla K80 on Google Colab\r\n- **Exact command to reproduce**: \r\n\r\n### Describe the problem\r\n\r\nI trained a ConvNet on MNIST, and saved the model using simple_save.\r\n\r\nWhen loading the saved model, using \r\n`tf.saved_model.loader.load(sess,[tag_constants.SERVING],'/save_folder')`\r\n\r\nI get this error `KeyError: u'ImageProjectiveTransform'`\r\n\r\nCode for saving my ConvNet model\r\n\r\n```\r\ngraph = tf.get_default_graph()\r\n\r\nfrom tensorflow.python.saved_model import tag_constants\r\nwith graph.as_default():\r\n  input_dict = {\"x\":x,\"y\":y,\"keep_prob\":keep_prob,\"aug_img\":aug_img}\r\n  output_dict = {\"logits\":fc3}\r\n  tf.saved_model.simple_save(sess,'/saved_model/',input_dict,output_dict)\r\n```\r\n\r\nI used tf.contrib.image.rotate as a augmentation technique, but didn't add that to any of the dicts while saving the model.\r\n\r\n### Source code / logs\r\n\r\nThis is the code for the model and the training part\r\n```\r\nx = tf.placeholder(tf.float32,shape=[None,28,28])\r\ny = tf.placeholder(tf.int64,shape=[None])\r\nkeep_prob = tf.placeholder(tf.float32,shape=())\r\nlr = tf.placeholder(tf.float32,shape=())\r\n\r\naug_img = tf.placeholder(tf.float32,shape=[28,28])\r\n\r\nimg_rotate = tf.contrib.image.rotate(aug_img,-0.5+np.random.random(),interpolation='BILINEAR')\r\nimg_affine = tf.contrib.image.transform(aug_img,[np.random.random() for i in xrange(8)])\r\n\r\nwith tf.device('/gpu:0'):\r\n  conv1 = tf.layers.conv2d(tf.reshape(x,shape=[-1,28,28,1]),filters=64,kernel_size=3,strides=1,padding='same',activation=tf.nn.leaky_relu)\r\n  conv2 = tf.layers.conv2d(conv1,filters=64,kernel_size=3,strides=2,padding='same',activation=tf.nn.leaky_relu) #NX14X14\r\n  conv3 = tf.layers.conv2d(conv2,filters=128,kernel_size=3,strides=1,padding='same',activation=tf.nn.leaky_relu)\r\n  conv4 = tf.layers.conv2d(conv3,filters=64,kernel_size=1,strides=1,padding='same',activation=tf.nn.leaky_relu)\r\n  conv5 = tf.layers.conv2d(conv4,filters=128,kernel_size=3,strides=2,padding='same',activation=tf.nn.leaky_relu) #NX7X7\r\n  conv6 = tf.layers.conv2d(conv5,filters=64,kernel_size=1,strides=1,padding='same',activation=tf.nn.leaky_relu)\r\n  conv7 = tf.layers.conv2d(conv6,filters=128,kernel_size=3,strides=2,padding='same',activation=tf.nn.leaky_relu) #NX3X3\r\n  conv8 = tf.layers.conv2d(conv7,filters=128,kernel_size=3,strides=1,padding='same',activation=tf.nn.leaky_relu) #NX1X1\r\n  flat = tf.contrib.layers.flatten(conv7)\r\n  fc1 = tf.layers.dense(flat,units=256,activation=tf.nn.leaky_relu)\r\n  do1 = tf.nn.dropout(fc1,keep_prob)\r\n  fc2 = tf.layers.dense(do1,units=256,activation=tf.nn.leaky_relu)\r\n  do2 = tf.nn.dropout(fc2,keep_prob)\r\n  fc3 = tf.layers.dense(do2,units=10)\r\n  \r\n  cost = loss(fc3,y)\r\n  opt = tf.train.AdamOptimizer(learning_rate=0.0001)\r\n  opt_op = opt.minimize(cost)\r\n  \r\n  top1_acc = accuracy(fc3,y)\r\n\r\nepochs = 25\r\nne=0\r\nbatchsize = 50\r\nnumiter = 400\r\nwhile(ne<epochs):\r\n    print 'Epoch:: ',ne+1,'-->'\r\n    stime = time.time()\r\n    if ne != 0:\r\n       np.random.shuffle(index)\r\n       images = images[index]\r\n       labels = labels[index]\r\n    for niter in xrange(numiter):\r\n      offset = niter*batch_size\r\n      x_iter, y_iter = np.array(images[offset:offset+batch_size,:,:]), np.array(labels[offset:offset+batch_size])\r\n      for n in xrange(batch_size):\r\n        augs = np.random.choice([True,False])\r\n        if augs==True:\r\n          x_iter[n] = sess.run(img_rotate,feed_dict={aug_img:x_iter[n]})\r\n      feed_trdict={x:x_iter,y:y_iter,keep_prob:0.6}\r\n      sess.run(opt_op,feed_dict=feed_trdict)\r\n    ne+=1\r\n\r\n```"}