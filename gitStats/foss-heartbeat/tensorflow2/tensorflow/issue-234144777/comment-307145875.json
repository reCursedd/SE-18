{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/307145875", "html_url": "https://github.com/tensorflow/tensorflow/issues/10486#issuecomment-307145875", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/10486", "id": 307145875, "node_id": "MDEyOklzc3VlQ29tbWVudDMwNzE0NTg3NQ==", "user": {"login": "michaelisard", "id": 5376757, "node_id": "MDQ6VXNlcjUzNzY3NTc=", "avatar_url": "https://avatars1.githubusercontent.com/u/5376757?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelisard", "html_url": "https://github.com/michaelisard", "followers_url": "https://api.github.com/users/michaelisard/followers", "following_url": "https://api.github.com/users/michaelisard/following{/other_user}", "gists_url": "https://api.github.com/users/michaelisard/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelisard/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelisard/subscriptions", "organizations_url": "https://api.github.com/users/michaelisard/orgs", "repos_url": "https://api.github.com/users/michaelisard/repos", "events_url": "https://api.github.com/users/michaelisard/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelisard/received_events", "type": "User", "site_admin": false}, "created_at": "2017-06-08T15:51:48Z", "updated_at": "2017-06-08T15:51:48Z", "author_association": "MEMBER", "body_html": "<p>I think the problem is that control dependencies and variable initializers are confusing. When you run the variable initializers, you only tell TensorFlow to run those initialization ops (i.e. compute zeros_like(Qs_t) and assign it to Ns_t), and it doesn't end up executing the precursors to the control dependency.</p>\n<p>The more common use case would be something like:</p>\n<pre><code>with tf.Graph().as_default():\n    Qs_t = tf.ones([3, 2], dtype=tf.float32)\n    timestep = tf.Variable(0, dtype=tf.int32, trainable=False, name=\"timestep\")\n    inc_t = tf.assign_add(timestep, 1)\n    with tf.control_dependencies([inc_t]):\n        Ns_t = tf.Variable(0., dtype=tf.float32, name=\"N\", trainable=False)\n        tf.Assign(Ns_t, inc_t)\n</code></pre>\n<p>where the control dependency was intended to apply to the Assign Op. In that case you probably want to be able to call the variable initializer outside the control dependency along with any other variable initializer. You should maybe think of variable initializers more like initializers for static variables in C++: the initializers are run once \"before any other code\".</p>\n<p>A judgment call was made in the TF design that more often than not, when you define the variable inside the control dependency you don't want to guard the initializer. In your case, you should just initialize based on the static shape of Qs_t, not zeros_like.</p>\n<p>I'm closing this for now, but if you have any followup questions, please post them on stackoverflow since github issues are only for TF bugs and feature requests. Thanks!</p>", "body_text": "I think the problem is that control dependencies and variable initializers are confusing. When you run the variable initializers, you only tell TensorFlow to run those initialization ops (i.e. compute zeros_like(Qs_t) and assign it to Ns_t), and it doesn't end up executing the precursors to the control dependency.\nThe more common use case would be something like:\nwith tf.Graph().as_default():\n    Qs_t = tf.ones([3, 2], dtype=tf.float32)\n    timestep = tf.Variable(0, dtype=tf.int32, trainable=False, name=\"timestep\")\n    inc_t = tf.assign_add(timestep, 1)\n    with tf.control_dependencies([inc_t]):\n        Ns_t = tf.Variable(0., dtype=tf.float32, name=\"N\", trainable=False)\n        tf.Assign(Ns_t, inc_t)\n\nwhere the control dependency was intended to apply to the Assign Op. In that case you probably want to be able to call the variable initializer outside the control dependency along with any other variable initializer. You should maybe think of variable initializers more like initializers for static variables in C++: the initializers are run once \"before any other code\".\nA judgment call was made in the TF design that more often than not, when you define the variable inside the control dependency you don't want to guard the initializer. In your case, you should just initialize based on the static shape of Qs_t, not zeros_like.\nI'm closing this for now, but if you have any followup questions, please post them on stackoverflow since github issues are only for TF bugs and feature requests. Thanks!", "body": "I think the problem is that control dependencies and variable initializers are confusing. When you run the variable initializers, you only tell TensorFlow to run those initialization ops (i.e. compute zeros_like(Qs_t) and assign it to Ns_t), and it doesn't end up executing the precursors to the control dependency.\r\n\r\nThe more common use case would be something like:\r\n\r\n```\r\nwith tf.Graph().as_default():\r\n    Qs_t = tf.ones([3, 2], dtype=tf.float32)\r\n    timestep = tf.Variable(0, dtype=tf.int32, trainable=False, name=\"timestep\")\r\n    inc_t = tf.assign_add(timestep, 1)\r\n    with tf.control_dependencies([inc_t]):\r\n        Ns_t = tf.Variable(0., dtype=tf.float32, name=\"N\", trainable=False)\r\n        tf.Assign(Ns_t, inc_t)\r\n```\r\nwhere the control dependency was intended to apply to the Assign Op. In that case you probably want to be able to call the variable initializer outside the control dependency along with any other variable initializer. You should maybe think of variable initializers more like initializers for static variables in C++: the initializers are run once \"before any other code\".\r\n\r\nA judgment call was made in the TF design that more often than not, when you define the variable inside the control dependency you don't want to guard the initializer. In your case, you should just initialize based on the static shape of Qs_t, not zeros_like.\r\n\r\nI'm closing this for now, but if you have any followup questions, please post them on stackoverflow since github issues are only for TF bugs and feature requests. Thanks!"}