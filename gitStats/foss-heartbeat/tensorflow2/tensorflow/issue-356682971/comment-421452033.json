{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/421452033", "html_url": "https://github.com/tensorflow/tensorflow/issues/22047#issuecomment-421452033", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/22047", "id": 421452033, "node_id": "MDEyOklzc3VlQ29tbWVudDQyMTQ1MjAzMw==", "user": {"login": "gittyupagain", "id": 2817768, "node_id": "MDQ6VXNlcjI4MTc3Njg=", "avatar_url": "https://avatars2.githubusercontent.com/u/2817768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gittyupagain", "html_url": "https://github.com/gittyupagain", "followers_url": "https://api.github.com/users/gittyupagain/followers", "following_url": "https://api.github.com/users/gittyupagain/following{/other_user}", "gists_url": "https://api.github.com/users/gittyupagain/gists{/gist_id}", "starred_url": "https://api.github.com/users/gittyupagain/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gittyupagain/subscriptions", "organizations_url": "https://api.github.com/users/gittyupagain/orgs", "repos_url": "https://api.github.com/users/gittyupagain/repos", "events_url": "https://api.github.com/users/gittyupagain/events{/privacy}", "received_events_url": "https://api.github.com/users/gittyupagain/received_events", "type": "User", "site_admin": false}, "created_at": "2018-09-14T18:52:41Z", "updated_at": "2018-09-14T18:52:41Z", "author_association": "NONE", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=25133849\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/PinkySan\">@PinkySan</a> I was able to successfully build the TensorFlow C++ library by building <code>//tensorflow:libtensorflow_cc.so</code> from the <code>v1.11.0-rc0</code> tag. Without any changes, this built a version of <code>libtensorflow_cc.so</code> that only had the <code>TF_*</code> and <code>TFE_*</code> symbols in it. After closer examination, those are the only explicitly exported symbols, so it was expected. In order to get the necessary C++ symbols, I modified <code>tensorflow/BUILD</code> as follows:</p>\n<pre><code>--- a/tensorflow/BUILD\n+++ b/tensorflow/BUILD\n@@ -562,7 +562,10 @@ tf_cc_shared_object(\n             \"-Wl,-exported_symbols_list\",  # This line must be directly followed by the exported_symbols.lds file\n             \"$(location //tensorflow:tf_exported_symbols.lds)\",\n         ],\n-        \"//tensorflow:windows\": [],\n+        \"//tensorflow:windows\": [\n+           \"-def:\" +  # This line must be directly followed by the exported_symbols_msvc.lds file\n+            \"$(location //tensorflow:tf_exported_symbols_msvc.lds)\",\n+       ],\n         \"//conditions:default\": [\n             \"-z defs\",\n             \"-Wl,--version-script\",  #  This line must be directly followed by the version_script.lds file\n@@ -571,6 +574,7 @@ tf_cc_shared_object(\n     }),\n     deps = [\n         \"//tensorflow:tf_exported_symbols.lds\",\n+        \"//tensorflow:tf_exported_symbols_msvc.lds\",\n         \"//tensorflow:tf_version_script.lds\",\n         \"//tensorflow/c:c_api\",\n         \"//tensorflow/c/eager:c_api\",\n@@ -586,6 +590,7 @@ exports_files(\n     [\n         \"tf_version_script.lds\",\n         \"tf_exported_symbols.lds\",\n+        \"tf_exported_symbols_msvc.lds\",\n     ],\n )\n\n</code></pre>\n<p>I then had to provide a DEF file that contained the symbols. I called it <code>tf_exported_symbols_msvc.lds</code>, but that was really just an arbitrary decision. Luckily there is already a script for extracting the symbols that may be found in the <code>tensorflow/contrib/cmake/tools</code> directory called <code>create_def_file.py</code>. The trick was finding the .lib files to include as inputs to the script. Due to the limitations of number of symbols (65535) that may be exported in a DLL, I had to pare down the symbols. It took some trial and error to find a suitable list that fell under the limit. It is nice that <code>create_def_file.py</code> shows the number of symbols as the second output value, making iteration of the list easier.</p>\n<p>As for parameters to that script, you need a semicolon separated list of the files for the inputs, the <code>--output</code> parameter should be <code>tensorflow/tf_exported_symbols_msvc.lds</code>, the <code>--bitness</code> should be <code>64</code> or <code>32</code> (based one whether you are building for x64 or x86), and the <code>--target</code> should be either <code>tensorflow</code> or <code>tensorflow_cc</code> (use the former to match the name from the cmake builds). After running the script, the appropriate <code>tf_exported_symbols_msvc.lds</code> file should be created. You can now build the C++ target. If all is successful, you will need to rename <code>libtensorflow_cc.so</code> to <code>tensorflow.dll</code> (or <code>tensorflow_cc.dll</code> if you specified that when creating the DEF file). Likewise, rename <code>libtensorflow_cc.so.if.lib</code> to <code>tensorflow.lib</code> (or <code>tensorflow_cc.lib</code>). You may not know for sure if you have all of the symbols you need until you link against your own executable.</p>\n<p>I could provide the list of libraries that I ended up using, but you may have other required symbols an my list is probably not the best. The libraries come from the <code>c</code>, <code>cc</code>, and <code>core</code> directories. You could also probably get the list of .lib file names by running through the cmake process, then seeing which .lib files it uses. Ideally someone with more knowledge of TensorFlow could automate this process.</p>", "body_text": "@PinkySan I was able to successfully build the TensorFlow C++ library by building //tensorflow:libtensorflow_cc.so from the v1.11.0-rc0 tag. Without any changes, this built a version of libtensorflow_cc.so that only had the TF_* and TFE_* symbols in it. After closer examination, those are the only explicitly exported symbols, so it was expected. In order to get the necessary C++ symbols, I modified tensorflow/BUILD as follows:\n--- a/tensorflow/BUILD\n+++ b/tensorflow/BUILD\n@@ -562,7 +562,10 @@ tf_cc_shared_object(\n             \"-Wl,-exported_symbols_list\",  # This line must be directly followed by the exported_symbols.lds file\n             \"$(location //tensorflow:tf_exported_symbols.lds)\",\n         ],\n-        \"//tensorflow:windows\": [],\n+        \"//tensorflow:windows\": [\n+           \"-def:\" +  # This line must be directly followed by the exported_symbols_msvc.lds file\n+            \"$(location //tensorflow:tf_exported_symbols_msvc.lds)\",\n+       ],\n         \"//conditions:default\": [\n             \"-z defs\",\n             \"-Wl,--version-script\",  #  This line must be directly followed by the version_script.lds file\n@@ -571,6 +574,7 @@ tf_cc_shared_object(\n     }),\n     deps = [\n         \"//tensorflow:tf_exported_symbols.lds\",\n+        \"//tensorflow:tf_exported_symbols_msvc.lds\",\n         \"//tensorflow:tf_version_script.lds\",\n         \"//tensorflow/c:c_api\",\n         \"//tensorflow/c/eager:c_api\",\n@@ -586,6 +590,7 @@ exports_files(\n     [\n         \"tf_version_script.lds\",\n         \"tf_exported_symbols.lds\",\n+        \"tf_exported_symbols_msvc.lds\",\n     ],\n )\n\n\nI then had to provide a DEF file that contained the symbols. I called it tf_exported_symbols_msvc.lds, but that was really just an arbitrary decision. Luckily there is already a script for extracting the symbols that may be found in the tensorflow/contrib/cmake/tools directory called create_def_file.py. The trick was finding the .lib files to include as inputs to the script. Due to the limitations of number of symbols (65535) that may be exported in a DLL, I had to pare down the symbols. It took some trial and error to find a suitable list that fell under the limit. It is nice that create_def_file.py shows the number of symbols as the second output value, making iteration of the list easier.\nAs for parameters to that script, you need a semicolon separated list of the files for the inputs, the --output parameter should be tensorflow/tf_exported_symbols_msvc.lds, the --bitness should be 64 or 32 (based one whether you are building for x64 or x86), and the --target should be either tensorflow or tensorflow_cc (use the former to match the name from the cmake builds). After running the script, the appropriate tf_exported_symbols_msvc.lds file should be created. You can now build the C++ target. If all is successful, you will need to rename libtensorflow_cc.so to tensorflow.dll (or tensorflow_cc.dll if you specified that when creating the DEF file). Likewise, rename libtensorflow_cc.so.if.lib to tensorflow.lib (or tensorflow_cc.lib). You may not know for sure if you have all of the symbols you need until you link against your own executable.\nI could provide the list of libraries that I ended up using, but you may have other required symbols an my list is probably not the best. The libraries come from the c, cc, and core directories. You could also probably get the list of .lib file names by running through the cmake process, then seeing which .lib files it uses. Ideally someone with more knowledge of TensorFlow could automate this process.", "body": "@PinkySan I was able to successfully build the TensorFlow C++ library by building `//tensorflow:libtensorflow_cc.so` from the `v1.11.0-rc0` tag. Without any changes, this built a version of `libtensorflow_cc.so` that only had the `TF_*` and `TFE_*` symbols in it. After closer examination, those are the only explicitly exported symbols, so it was expected. In order to get the necessary C++ symbols, I modified `tensorflow/BUILD` as follows:\r\n```\r\n--- a/tensorflow/BUILD\r\n+++ b/tensorflow/BUILD\r\n@@ -562,7 +562,10 @@ tf_cc_shared_object(\r\n             \"-Wl,-exported_symbols_list\",  # This line must be directly followed by the exported_symbols.lds file\r\n             \"$(location //tensorflow:tf_exported_symbols.lds)\",\r\n         ],\r\n-        \"//tensorflow:windows\": [],\r\n+        \"//tensorflow:windows\": [\r\n+           \"-def:\" +  # This line must be directly followed by the exported_symbols_msvc.lds file\r\n+            \"$(location //tensorflow:tf_exported_symbols_msvc.lds)\",\r\n+       ],\r\n         \"//conditions:default\": [\r\n             \"-z defs\",\r\n             \"-Wl,--version-script\",  #  This line must be directly followed by the version_script.lds file\r\n@@ -571,6 +574,7 @@ tf_cc_shared_object(\r\n     }),\r\n     deps = [\r\n         \"//tensorflow:tf_exported_symbols.lds\",\r\n+        \"//tensorflow:tf_exported_symbols_msvc.lds\",\r\n         \"//tensorflow:tf_version_script.lds\",\r\n         \"//tensorflow/c:c_api\",\r\n         \"//tensorflow/c/eager:c_api\",\r\n@@ -586,6 +590,7 @@ exports_files(\r\n     [\r\n         \"tf_version_script.lds\",\r\n         \"tf_exported_symbols.lds\",\r\n+        \"tf_exported_symbols_msvc.lds\",\r\n     ],\r\n )\r\n\r\n```\r\nI then had to provide a DEF file that contained the symbols. I called it `tf_exported_symbols_msvc.lds`, but that was really just an arbitrary decision. Luckily there is already a script for extracting the symbols that may be found in the `tensorflow/contrib/cmake/tools` directory called `create_def_file.py`. The trick was finding the .lib files to include as inputs to the script. Due to the limitations of number of symbols (65535) that may be exported in a DLL, I had to pare down the symbols. It took some trial and error to find a suitable list that fell under the limit. It is nice that `create_def_file.py` shows the number of symbols as the second output value, making iteration of the list easier.\r\n\r\nAs for parameters to that script, you need a semicolon separated list of the files for the inputs, the `--output` parameter should be `tensorflow/tf_exported_symbols_msvc.lds`, the `--bitness` should be `64` or `32` (based one whether you are building for x64 or x86), and the `--target` should be either `tensorflow` or `tensorflow_cc` (use the former to match the name from the cmake builds). After running the script, the appropriate `tf_exported_symbols_msvc.lds` file should be created. You can now build the C++ target. If all is successful, you will need to rename `libtensorflow_cc.so` to `tensorflow.dll` (or `tensorflow_cc.dll` if you specified that when creating the DEF file). Likewise, rename `libtensorflow_cc.so.if.lib` to `tensorflow.lib` (or `tensorflow_cc.lib`). You may not know for sure if you have all of the symbols you need until you link against your own executable.\r\n\r\nI could provide the list of libraries that I ended up using, but you may have other required symbols an my list is probably not the best. The libraries come from the `c`, `cc`, and `core` directories. You could also probably get the list of .lib file names by running through the cmake process, then seeing which .lib files it uses. Ideally someone with more knowledge of TensorFlow could automate this process."}