{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/289836115", "html_url": "https://github.com/tensorflow/tensorflow/issues/8587#issuecomment-289836115", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8587", "id": 289836115, "node_id": "MDEyOklzc3VlQ29tbWVudDI4OTgzNjExNQ==", "user": {"login": "andrewharp", "id": 3376817, "node_id": "MDQ6VXNlcjMzNzY4MTc=", "avatar_url": "https://avatars1.githubusercontent.com/u/3376817?v=4", "gravatar_id": "", "url": "https://api.github.com/users/andrewharp", "html_url": "https://github.com/andrewharp", "followers_url": "https://api.github.com/users/andrewharp/followers", "following_url": "https://api.github.com/users/andrewharp/following{/other_user}", "gists_url": "https://api.github.com/users/andrewharp/gists{/gist_id}", "starred_url": "https://api.github.com/users/andrewharp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/andrewharp/subscriptions", "organizations_url": "https://api.github.com/users/andrewharp/orgs", "repos_url": "https://api.github.com/users/andrewharp/repos", "events_url": "https://api.github.com/users/andrewharp/events{/privacy}", "received_events_url": "https://api.github.com/users/andrewharp/received_events", "type": "User", "site_admin": false}, "created_at": "2017-03-28T17:00:08Z", "updated_at": "2017-03-28T17:06:47Z", "author_association": "MEMBER", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=25011496\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/jubjamie\">@jubjamie</a> The bazel-built APK from android_full.sh will work on all 4 of those architectures.</p>\n<p>If you want to simulate this with the Gradle+bazel build, you can manually change the <code>cpuType</code> variable in build.gradle to each in turn and hit build. The built native libraries will accumulate in the <code>jniLibs</code> directory, and Gradle will package them in the resulting APK. You can see what libraries actually get packaged with <code>unzip -v tensorflow/examples/android/gradleBuild/outputs/apk/android-debug.apk</code></p>\n<p>However be aware that making any changes to the native code will require a full repeat of the entire process, as otherwise your native libraries will become out of sync with each other. This is why it would be good to have build.gradle itself automate the process of building for all desired ABIs in one go (it would call bazel multiple times internally).</p>\n<p>edit: We're not yet able to get everything fully building with cmake -- the current cmake Android build uses the Makefile internally, so for now we just recommend the 100% Makefile build over the cmake+Makefile build as it has less moving parts. Eventually we want to have a 100% cmake build as well.</p>", "body_text": "@jubjamie The bazel-built APK from android_full.sh will work on all 4 of those architectures.\nIf you want to simulate this with the Gradle+bazel build, you can manually change the cpuType variable in build.gradle to each in turn and hit build. The built native libraries will accumulate in the jniLibs directory, and Gradle will package them in the resulting APK. You can see what libraries actually get packaged with unzip -v tensorflow/examples/android/gradleBuild/outputs/apk/android-debug.apk\nHowever be aware that making any changes to the native code will require a full repeat of the entire process, as otherwise your native libraries will become out of sync with each other. This is why it would be good to have build.gradle itself automate the process of building for all desired ABIs in one go (it would call bazel multiple times internally).\nedit: We're not yet able to get everything fully building with cmake -- the current cmake Android build uses the Makefile internally, so for now we just recommend the 100% Makefile build over the cmake+Makefile build as it has less moving parts. Eventually we want to have a 100% cmake build as well.", "body": "@jubjamie The bazel-built APK from android_full.sh will work on all 4 of those architectures.\r\n\r\nIf you want to simulate this with the Gradle+bazel build, you can manually change the `cpuType` variable in build.gradle to each in turn and hit build. The built native libraries will accumulate in the `jniLibs` directory, and Gradle will package them in the resulting APK. You can see what libraries actually get packaged with `unzip -v tensorflow/examples/android/gradleBuild/outputs/apk/android-debug.apk`\r\n\r\nHowever be aware that making any changes to the native code will require a full repeat of the entire process, as otherwise your native libraries will become out of sync with each other. This is why it would be good to have build.gradle itself automate the process of building for all desired ABIs in one go (it would call bazel multiple times internally).\r\n\r\nedit: We're not yet able to get everything fully building with cmake -- the current cmake Android build uses the Makefile internally, so for now we just recommend the 100% Makefile build over the cmake+Makefile build as it has less moving parts. Eventually we want to have a 100% cmake build as well."}