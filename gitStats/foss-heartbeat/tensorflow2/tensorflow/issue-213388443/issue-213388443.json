{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8275", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8275/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8275/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8275/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/8275", "id": 213388443, "node_id": "MDU6SXNzdWUyMTMzODg0NDM=", "number": 8275, "title": "make sparse_tensor (SparseTensor) serializable in meta graph", "user": {"login": "ariejdl", "id": 220554, "node_id": "MDQ6VXNlcjIyMDU1NA==", "avatar_url": "https://avatars0.githubusercontent.com/u/220554?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ariejdl", "html_url": "https://github.com/ariejdl", "followers_url": "https://api.github.com/users/ariejdl/followers", "following_url": "https://api.github.com/users/ariejdl/following{/other_user}", "gists_url": "https://api.github.com/users/ariejdl/gists{/gist_id}", "starred_url": "https://api.github.com/users/ariejdl/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ariejdl/subscriptions", "organizations_url": "https://api.github.com/users/ariejdl/orgs", "repos_url": "https://api.github.com/users/ariejdl/repos", "events_url": "https://api.github.com/users/ariejdl/events{/privacy}", "received_events_url": "https://api.github.com/users/ariejdl/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 404586594, "node_id": "MDU6TGFiZWw0MDQ1ODY1OTQ=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:awaiting%20tensorflower", "name": "stat:awaiting tensorflower", "color": "f4b400", "default": false}, {"id": 473173272, "node_id": "MDU6TGFiZWw0NzMxNzMyNzI=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:feature", "name": "type:feature", "color": "159b2e", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 7, "created_at": "2017-03-10T16:32:30Z", "updated_at": "2018-08-17T16:13:18Z", "closed_at": "2017-06-16T19:14:38Z", "author_association": "CONTRIBUTOR", "body_html": "<p><code>tf.sparse_placeholder</code> Sparse tensors aren't serialized in meta graphs, one has to serialize tf.placeholder tensors for the indices and values individually.</p>\n<p>At present <code>add_collection_def</code> (called by <code>create_meta_graph_def</code>, which is typically called by <code>export_scoped_meta_graph</code>, found in <a href=\"https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/framework/meta_graph.py\">/tensorflow/python/framework/meta_graph.py</a>, ) <strong>fails</strong> when a <code>key</code> resolves to a <code>SparseTensor</code> as <code>SparseTensor</code>s do not have <code>name</code> attribute: here is the specific <a href=\"https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/framework/meta_graph.py#L290\">line</a>.</p>\n<h2>Suggested solutions:</h2>\n<ul>\n<li>give <code>SparseTensor</code> a <code>name</code> attribute and any other methods and properties necessary</li>\n</ul>\n<p>or</p>\n<ul>\n<li>Enable <code>SparseTensor</code> or <code>sparse_placeholder</code> to be added to <code>_proto_function_registry</code> so that <a href=\"https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/framework/meta_graph.py#L275\">ops.get_to_proto_function</a> works in <code>add_collection_def</code>, perhaps using the <code>SAVEABLE_OBJECTS</code> key, something like the following being found in the SparseTensor file:</li>\n</ul>\n<pre><code>ops.register_proto_function(\n    ops.GraphKeys.SAVERS,\n    proto_type=saver_pb2.SaverDef,\n    to_proto=Saver.to_proto,\n    from_proto=Saver.from_proto)\n</code></pre>\n<p>speculative, I don't know the best implementation:</p>\n<p>Could do something similar to the <a href=\"https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/framework/ops.py#L2114\"><code>_as_graph_def</code></a> method of <code>Graph</code> and loop through <code>graph._nodes_by_id</code>, compare the <code>SparseTensor</code>'s <code>_indices</code> to an <code>op</code> (node) <code>_outputs</code> from <code>_nodes_by_id</code>.</p>\n<h2>Small Test</h2>\n<div class=\"highlight highlight-source-python\"><pre>g <span class=\"pl-k\">=</span> tf.Graph()\n<span class=\"pl-k\">with</span> g.as_default(), tf.Session(<span class=\"pl-v\">graph</span><span class=\"pl-k\">=</span>g).as_default() <span class=\"pl-k\">as</span> sess:\n  st <span class=\"pl-k\">=</span> tf.sparse_placeholder(tf.string)\n  ops.add_to_collection(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>_sparse_test<span class=\"pl-pds\">'</span></span>, st)\n  ops.add_to_collection(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>_test<span class=\"pl-pds\">'</span></span>, tf.placeholder(tf.string))\n  <span class=\"pl-c\"><span class=\"pl-c\">#</span> FORMERLY GAVE A WARNING WHEN EXCEPTION THROWN</span>\n  tf.train.export_meta_graph(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>tmp_model/test-model.meta<span class=\"pl-pds\">'</span></span>, <span class=\"pl-v\">as_text</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">True</span>, <span class=\"pl-v\">graph</span><span class=\"pl-k\">=</span>g,\n                             <span class=\"pl-v\">collection_list</span><span class=\"pl-k\">=</span>[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>_sparse_test<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>_test<span class=\"pl-pds\">'</span></span>]) \n  <span class=\"pl-c\"><span class=\"pl-c\">#</span> WORKS</span>\n  <span class=\"pl-c1\">print</span>(sess.run(st, <span class=\"pl-v\">feed_dict</span><span class=\"pl-k\">=</span>{ st: ([[i,<span class=\"pl-c1\">0</span>] <span class=\"pl-k\">for</span> i <span class=\"pl-k\">in</span> <span class=\"pl-c1\">range</span>(<span class=\"pl-c1\">10</span>)],\n                                      <span class=\"pl-c1\">list</span>(<span class=\"pl-c1\">map</span>(<span class=\"pl-c1\">str</span>,<span class=\"pl-c1\">range</span>(<span class=\"pl-c1\">10</span>))),\n                                      [<span class=\"pl-c1\">10</span>,<span class=\"pl-c1\">1</span>]) }))\n    \ng2 <span class=\"pl-k\">=</span> tf.Graph()\n<span class=\"pl-k\">with</span> g2.as_default(), tf.Session(<span class=\"pl-v\">graph</span><span class=\"pl-k\">=</span>g2).as_default() <span class=\"pl-k\">as</span> sess2:\n  tf.train.import_meta_graph(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>tmp_model/test-model.meta<span class=\"pl-pds\">'</span></span>)\n  t <span class=\"pl-k\">=</span> tf.get_collection(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>_test<span class=\"pl-pds\">'</span></span>)[<span class=\"pl-c1\">0</span>]\n  <span class=\"pl-c\"><span class=\"pl-c\">#</span> FAILS</span>\n  st <span class=\"pl-k\">=</span> tf.get_collection(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>_sparse_test<span class=\"pl-pds\">'</span></span>)[<span class=\"pl-c1\">0</span>]\n  <span class=\"pl-c1\">print</span>(sess2.run(st, <span class=\"pl-v\">feed_dict</span><span class=\"pl-k\">=</span>{ st: ([[i,<span class=\"pl-c1\">0</span>] <span class=\"pl-k\">for</span> i <span class=\"pl-k\">in</span> <span class=\"pl-c1\">range</span>(<span class=\"pl-c1\">10</span>)],\n                                      <span class=\"pl-c1\">list</span>(<span class=\"pl-c1\">map</span>(<span class=\"pl-c1\">str</span>,<span class=\"pl-c1\">range</span>(<span class=\"pl-c1\">20</span>,<span class=\"pl-c1\">30</span>))),\n                                      [<span class=\"pl-c1\">10</span>,<span class=\"pl-c1\">1</span>]) }))\n\n</pre></div>\n<p>Sometimes I get a segfault with this</p>", "body_text": "tf.sparse_placeholder Sparse tensors aren't serialized in meta graphs, one has to serialize tf.placeholder tensors for the indices and values individually.\nAt present add_collection_def (called by create_meta_graph_def, which is typically called by export_scoped_meta_graph, found in /tensorflow/python/framework/meta_graph.py, ) fails when a key resolves to a SparseTensor as SparseTensors do not have name attribute: here is the specific line.\nSuggested solutions:\n\ngive SparseTensor a name attribute and any other methods and properties necessary\n\nor\n\nEnable SparseTensor or sparse_placeholder to be added to _proto_function_registry so that ops.get_to_proto_function works in add_collection_def, perhaps using the SAVEABLE_OBJECTS key, something like the following being found in the SparseTensor file:\n\nops.register_proto_function(\n    ops.GraphKeys.SAVERS,\n    proto_type=saver_pb2.SaverDef,\n    to_proto=Saver.to_proto,\n    from_proto=Saver.from_proto)\n\nspeculative, I don't know the best implementation:\nCould do something similar to the _as_graph_def method of Graph and loop through graph._nodes_by_id, compare the SparseTensor's _indices to an op (node) _outputs from _nodes_by_id.\nSmall Test\ng = tf.Graph()\nwith g.as_default(), tf.Session(graph=g).as_default() as sess:\n  st = tf.sparse_placeholder(tf.string)\n  ops.add_to_collection('_sparse_test', st)\n  ops.add_to_collection('_test', tf.placeholder(tf.string))\n  # FORMERLY GAVE A WARNING WHEN EXCEPTION THROWN\n  tf.train.export_meta_graph('tmp_model/test-model.meta', as_text=True, graph=g,\n                             collection_list=['_sparse_test', '_test']) \n  # WORKS\n  print(sess.run(st, feed_dict={ st: ([[i,0] for i in range(10)],\n                                      list(map(str,range(10))),\n                                      [10,1]) }))\n    \ng2 = tf.Graph()\nwith g2.as_default(), tf.Session(graph=g2).as_default() as sess2:\n  tf.train.import_meta_graph('tmp_model/test-model.meta')\n  t = tf.get_collection('_test')[0]\n  # FAILS\n  st = tf.get_collection('_sparse_test')[0]\n  print(sess2.run(st, feed_dict={ st: ([[i,0] for i in range(10)],\n                                      list(map(str,range(20,30))),\n                                      [10,1]) }))\n\n\nSometimes I get a segfault with this", "body": "`tf.sparse_placeholder` Sparse tensors aren't serialized in meta graphs, one has to serialize tf.placeholder tensors for the indices and values individually.\r\n\r\nAt present `add_collection_def` (called by `create_meta_graph_def`, which is typically called by `export_scoped_meta_graph`, found in [/tensorflow/python/framework/meta_graph.py](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/framework/meta_graph.py), ) **fails** when a `key` resolves to a `SparseTensor` as `SparseTensor`s do not have `name` attribute: here is the specific [line](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/framework/meta_graph.py#L290).\r\n\r\n## Suggested solutions:\r\n- give `SparseTensor` a `name` attribute and any other methods and properties necessary\r\n\r\nor\r\n\r\n- Enable `SparseTensor` or `sparse_placeholder` to be added to `_proto_function_registry` so that [ops.get_to_proto_function](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/framework/meta_graph.py#L275) works in `add_collection_def`, perhaps using the `SAVEABLE_OBJECTS` key, something like the following being found in the SparseTensor file:\r\n\r\n```\r\nops.register_proto_function(\r\n    ops.GraphKeys.SAVERS,\r\n    proto_type=saver_pb2.SaverDef,\r\n    to_proto=Saver.to_proto,\r\n    from_proto=Saver.from_proto)\r\n```\r\n\r\nspeculative, I don't know the best implementation:\r\n\r\nCould do something similar to the [`_as_graph_def`](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/framework/ops.py#L2114) method of `Graph` and loop through `graph._nodes_by_id`, compare the `SparseTensor`'s `_indices` to an `op` (node) `_outputs` from `_nodes_by_id`.\r\n\r\n## Small Test\r\n\r\n```python\r\n\r\ng = tf.Graph()\r\nwith g.as_default(), tf.Session(graph=g).as_default() as sess:\r\n  st = tf.sparse_placeholder(tf.string)\r\n  ops.add_to_collection('_sparse_test', st)\r\n  ops.add_to_collection('_test', tf.placeholder(tf.string))\r\n  # FORMERLY GAVE A WARNING WHEN EXCEPTION THROWN\r\n  tf.train.export_meta_graph('tmp_model/test-model.meta', as_text=True, graph=g,\r\n                             collection_list=['_sparse_test', '_test']) \r\n  # WORKS\r\n  print(sess.run(st, feed_dict={ st: ([[i,0] for i in range(10)],\r\n                                      list(map(str,range(10))),\r\n                                      [10,1]) }))\r\n    \r\ng2 = tf.Graph()\r\nwith g2.as_default(), tf.Session(graph=g2).as_default() as sess2:\r\n  tf.train.import_meta_graph('tmp_model/test-model.meta')\r\n  t = tf.get_collection('_test')[0]\r\n  # FAILS\r\n  st = tf.get_collection('_sparse_test')[0]\r\n  print(sess2.run(st, feed_dict={ st: ([[i,0] for i in range(10)],\r\n                                      list(map(str,range(20,30))),\r\n                                      [10,1]) }))\r\n\r\n\r\n```\r\n\r\nSometimes I get a segfault with this"}