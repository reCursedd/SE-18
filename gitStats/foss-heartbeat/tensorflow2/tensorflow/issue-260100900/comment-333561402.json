{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/333561402", "html_url": "https://github.com/tensorflow/tensorflow/pull/13274#issuecomment-333561402", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13274", "id": 333561402, "node_id": "MDEyOklzc3VlQ29tbWVudDMzMzU2MTQwMg==", "user": {"login": "ilya-edrenkin", "id": 13562803, "node_id": "MDQ6VXNlcjEzNTYyODAz", "avatar_url": "https://avatars2.githubusercontent.com/u/13562803?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ilya-edrenkin", "html_url": "https://github.com/ilya-edrenkin", "followers_url": "https://api.github.com/users/ilya-edrenkin/followers", "following_url": "https://api.github.com/users/ilya-edrenkin/following{/other_user}", "gists_url": "https://api.github.com/users/ilya-edrenkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/ilya-edrenkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ilya-edrenkin/subscriptions", "organizations_url": "https://api.github.com/users/ilya-edrenkin/orgs", "repos_url": "https://api.github.com/users/ilya-edrenkin/repos", "events_url": "https://api.github.com/users/ilya-edrenkin/events{/privacy}", "received_events_url": "https://api.github.com/users/ilya-edrenkin/received_events", "type": "User", "site_admin": false}, "created_at": "2017-10-02T15:01:54Z", "updated_at": "2017-10-02T15:01:54Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=1517779\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/sb2nov\">@sb2nov</a>: OK, I will add tests next weekend.</p>\n<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=5061\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/alextp\">@alextp</a>:<br>\nI can do it both ways. However, have chosen this particular way to keep the code minimal.<br>\nIf I use composition, I will have to add a considerable amount of boilerplate code to proxy requests like <code>get_slot</code> etc to the wrapped optimizer instance. This can be easily avoided by the proposed solution.</p>\n<p>Moreover, if the wrapped optimizer instance does provide some arbitrary non-standard interface (actually anything not defined in the abstract tf.train.Optimizer superclass), I don't see an easy way to proxy it at all (at least without magic that would override method/field lookups).<br>\nSo the client will have to use <code>wrapper._opt.custom_call()</code> instead of <code>wrapper.custom_call()</code>. Therefore, the wrapper will no longer be a drop-in replacement to the original optimizer, as the client code will have to be modified in this manner.</p>\n<p>Am I missing something?</p>", "body_text": "@sb2nov: OK, I will add tests next weekend.\n@alextp:\nI can do it both ways. However, have chosen this particular way to keep the code minimal.\nIf I use composition, I will have to add a considerable amount of boilerplate code to proxy requests like get_slot etc to the wrapped optimizer instance. This can be easily avoided by the proposed solution.\nMoreover, if the wrapped optimizer instance does provide some arbitrary non-standard interface (actually anything not defined in the abstract tf.train.Optimizer superclass), I don't see an easy way to proxy it at all (at least without magic that would override method/field lookups).\nSo the client will have to use wrapper._opt.custom_call() instead of wrapper.custom_call(). Therefore, the wrapper will no longer be a drop-in replacement to the original optimizer, as the client code will have to be modified in this manner.\nAm I missing something?", "body": "@sb2nov: OK, I will add tests next weekend.\r\n\r\n@alextp:\r\nI can do it both ways. However, have chosen this particular way to keep the code minimal. \r\nIf I use composition, I will have to add a considerable amount of boilerplate code to proxy requests like `get_slot` etc to the wrapped optimizer instance. This can be easily avoided by the proposed solution.\r\n\r\nMoreover, if the wrapped optimizer instance does provide some arbitrary non-standard interface (actually anything not defined in the abstract tf.train.Optimizer superclass), I don't see an easy way to proxy it at all (at least without magic that would override method/field lookups).\r\nSo the client will have to use `wrapper._opt.custom_call()` instead of `wrapper.custom_call()`. Therefore, the wrapper will no longer be a drop-in replacement to the original optimizer, as the client code will have to be modified in this manner.\r\n\r\nAm I missing something?"}