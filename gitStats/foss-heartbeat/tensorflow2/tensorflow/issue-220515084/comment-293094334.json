{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/293094334", "html_url": "https://github.com/tensorflow/tensorflow/pull/9093#issuecomment-293094334", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9093", "id": 293094334, "node_id": "MDEyOklzc3VlQ29tbWVudDI5MzA5NDMzNA==", "user": {"login": "MartinMoon", "id": 2959621, "node_id": "MDQ6VXNlcjI5NTk2MjE=", "avatar_url": "https://avatars1.githubusercontent.com/u/2959621?v=4", "gravatar_id": "", "url": "https://api.github.com/users/MartinMoon", "html_url": "https://github.com/MartinMoon", "followers_url": "https://api.github.com/users/MartinMoon/followers", "following_url": "https://api.github.com/users/MartinMoon/following{/other_user}", "gists_url": "https://api.github.com/users/MartinMoon/gists{/gist_id}", "starred_url": "https://api.github.com/users/MartinMoon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/MartinMoon/subscriptions", "organizations_url": "https://api.github.com/users/MartinMoon/orgs", "repos_url": "https://api.github.com/users/MartinMoon/repos", "events_url": "https://api.github.com/users/MartinMoon/events{/privacy}", "received_events_url": "https://api.github.com/users/MartinMoon/received_events", "type": "User", "site_admin": false}, "created_at": "2017-04-10T22:13:08Z", "updated_at": "2017-04-10T22:13:08Z", "author_association": "NONE", "body_html": "<p>Hi mrry, thanks for your reply. I got the original error message when I try to feed a <em>string tensor</em> to a <em>tf.train.string_input_producer()</em>:</p>\n<div class=\"highlight highlight-source-python\"><pre>input_placeholder <span class=\"pl-k\">=</span> tf.placeholder(tf.string, <span class=\"pl-v\">shape</span><span class=\"pl-k\">=</span>[<span class=\"pl-c1\">None</span>])\nname_queue <span class=\"pl-k\">=</span> tf.train.string_input_producer(input_placeholder)\n<span class=\"pl-c1\">...</span>\n\n<span class=\"pl-k\">with</span> tf.Session() <span class=\"pl-k\">as</span> sess:\n        \n        coord <span class=\"pl-k\">=</span> tf.train.Coordinator()\n        threads <span class=\"pl-k\">=</span> tf.train.start_queue_runners(<span class=\"pl-v\">coord</span><span class=\"pl-k\">=</span>coord)\n        <span class=\"pl-c1\">...</span>.\n        images <span class=\"pl-k\">=</span> [<span class=\"pl-s\"><span class=\"pl-pds\">'</span>1.jpg<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>2.jpg<span class=\"pl-pds\">'</span></span>, <span class=\"pl-c1\">...</span>.]\n        sess.run(predict,  <span class=\"pl-v\">feed_dict</span><span class=\"pl-k\">=</span>{input_placeholder:images})\n</pre></div>\n<p>The program will got the <em>InvalidArgumentError</em>, which seems the input images can not be passed to initialized the queue of file names.</p>\n<p>At first, I think it is because of the shapes are not compatible, so I suggest the default 'element_shape' value should be set as 'None'. Finally I found this not the root of the problem. The non-compatible problem is due to my silly code which set the wrong placeholder shape as <em>tf.placeholder(tf.string, shape=[None,1])</em> .....</p>\n<p>Come back to the <em>InvalidArgumentError</em> problem, I found it is because when <em>tf.train.string_input_producer</em> is called, a queue is created and return back, and implicitly, a <em>enqueue_many</em> operation is added into the queue_runner, combined with the queue, as follow:</p>\n<div class=\"highlight highlight-source-python\"><pre>    enq <span class=\"pl-k\">=</span> q.enqueue_many([input_tensor])\n    queue_runner.add_queue_runner(\n            queue_runner.QueueRunner(\n            q, [enq], <span class=\"pl-v\">cancel_op</span><span class=\"pl-k\">=</span>cancel_op))</pre></div>\n<p>So in the session module, when tf.train.start_queue_runners(coord=coord) is called, the string_name queue is run as a independent thread, when this thread excute <em>enqueue_many</em> operation, there will be a <em>InvalidArgumentError</em> problem, since there is no feed_dict.</p>\n<p>So, as a summary, I think if the  <em>tf.train.string_input_producer()</em> is designed to only accept constant tensors (or return from <em>tf.train.match_filenames_once()</em>), this is OK. You can just close this pull request <g-emoji class=\"g-emoji\" alias=\"sweat_smile\" fallback-src=\"https://assets-cdn.github.com/images/icons/emoji/unicode/1f605.png\">\ud83d\ude05</g-emoji>. If it is also want to accept input from <em>tf.placeholder</em>, there maybe need some change...</p>\n<p>Thanks for your patience <g-emoji class=\"g-emoji\" alias=\"smile\" fallback-src=\"https://assets-cdn.github.com/images/icons/emoji/unicode/1f604.png\">\ud83d\ude04</g-emoji></p>", "body_text": "Hi mrry, thanks for your reply. I got the original error message when I try to feed a string tensor to a tf.train.string_input_producer():\ninput_placeholder = tf.placeholder(tf.string, shape=[None])\nname_queue = tf.train.string_input_producer(input_placeholder)\n...\n\nwith tf.Session() as sess:\n        \n        coord = tf.train.Coordinator()\n        threads = tf.train.start_queue_runners(coord=coord)\n        ....\n        images = ['1.jpg', '2.jpg', ....]\n        sess.run(predict,  feed_dict={input_placeholder:images})\n\nThe program will got the InvalidArgumentError, which seems the input images can not be passed to initialized the queue of file names.\nAt first, I think it is because of the shapes are not compatible, so I suggest the default 'element_shape' value should be set as 'None'. Finally I found this not the root of the problem. The non-compatible problem is due to my silly code which set the wrong placeholder shape as tf.placeholder(tf.string, shape=[None,1]) .....\nCome back to the InvalidArgumentError problem, I found it is because when tf.train.string_input_producer is called, a queue is created and return back, and implicitly, a enqueue_many operation is added into the queue_runner, combined with the queue, as follow:\n    enq = q.enqueue_many([input_tensor])\n    queue_runner.add_queue_runner(\n            queue_runner.QueueRunner(\n            q, [enq], cancel_op=cancel_op))\nSo in the session module, when tf.train.start_queue_runners(coord=coord) is called, the string_name queue is run as a independent thread, when this thread excute enqueue_many operation, there will be a InvalidArgumentError problem, since there is no feed_dict.\nSo, as a summary, I think if the  tf.train.string_input_producer() is designed to only accept constant tensors (or return from tf.train.match_filenames_once()), this is OK. You can just close this pull request \ud83d\ude05. If it is also want to accept input from tf.placeholder, there maybe need some change...\nThanks for your patience \ud83d\ude04", "body": "Hi mrry, thanks for your reply. I got the original error message when I try to feed a *string tensor* to a *tf.train.string_input_producer()*:\r\n\r\n```python\r\ninput_placeholder = tf.placeholder(tf.string, shape=[None])\r\nname_queue = tf.train.string_input_producer(input_placeholder)\r\n...\r\n\r\nwith tf.Session() as sess:\r\n        \r\n        coord = tf.train.Coordinator()\r\n        threads = tf.train.start_queue_runners(coord=coord)\r\n        ....\r\n        images = ['1.jpg', '2.jpg', ....]\r\n        sess.run(predict,  feed_dict={input_placeholder:images})\r\n\r\n```\r\nThe program will got the *InvalidArgumentError*, which seems the input images can not be passed to initialized the queue of file names.\r\n\r\nAt first, I think it is because of the shapes are not compatible, so I suggest the default 'element_shape' value should be set as 'None'. Finally I found this not the root of the problem. The non-compatible problem is due to my silly code which set the wrong placeholder shape as *tf.placeholder(tf.string, shape=[None,1])* .....\r\n\r\nCome back to the *InvalidArgumentError* problem, I found it is because when *tf.train.string_input_producer* is called, a queue is created and return back, and implicitly, a *enqueue_many* operation is added into the queue_runner, combined with the queue, as follow:\r\n\r\n```python\r\n    enq = q.enqueue_many([input_tensor])\r\n    queue_runner.add_queue_runner(\r\n            queue_runner.QueueRunner(\r\n            q, [enq], cancel_op=cancel_op))\r\n```\r\nSo in the session module, when tf.train.start_queue_runners(coord=coord) is called, the string_name queue is run as a independent thread, when this thread excute *enqueue_many* operation, there will be a *InvalidArgumentError* problem, since there is no feed_dict.\r\n\r\nSo, as a summary, I think if the  *tf.train.string_input_producer()* is designed to only accept constant tensors (or return from *tf.train.match_filenames_once()*), this is OK. You can just close this pull request :sweat_smile:. If it is also want to accept input from *tf.placeholder*, there maybe need some change...\r\n\r\nThanks for your patience :smile:\r\n"}