{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/15077", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/15077/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/15077/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/15077/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/15077", "id": 278778996, "node_id": "MDU6SXNzdWUyNzg3Nzg5OTY=", "number": 15077, "title": "The sequence of session.run and control_dependencies?", "user": {"login": "gauss-clb", "id": 11674304, "node_id": "MDQ6VXNlcjExNjc0MzA0", "avatar_url": "https://avatars2.githubusercontent.com/u/11674304?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gauss-clb", "html_url": "https://github.com/gauss-clb", "followers_url": "https://api.github.com/users/gauss-clb/followers", "following_url": "https://api.github.com/users/gauss-clb/following{/other_user}", "gists_url": "https://api.github.com/users/gauss-clb/gists{/gist_id}", "starred_url": "https://api.github.com/users/gauss-clb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gauss-clb/subscriptions", "organizations_url": "https://api.github.com/users/gauss-clb/orgs", "repos_url": "https://api.github.com/users/gauss-clb/repos", "events_url": "https://api.github.com/users/gauss-clb/events{/privacy}", "received_events_url": "https://api.github.com/users/gauss-clb/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 11, "created_at": "2017-12-03T13:57:34Z", "updated_at": "2018-04-27T01:56:20Z", "closed_at": "2017-12-05T00:27:29Z", "author_association": "NONE", "body_html": "<p>See three examples:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">import</span> tensorflow <span class=\"pl-k\">as</span> tf\n\nx <span class=\"pl-k\">=</span> tf.constant(<span class=\"pl-c1\">1.0</span>)\nx <span class=\"pl-k\">=</span> tf.Print(x, [<span class=\"pl-s\"><span class=\"pl-pds\">'</span>x<span class=\"pl-pds\">'</span></span>])\ny <span class=\"pl-k\">=</span> tf.constant(<span class=\"pl-c1\">2.0</span>)\ny <span class=\"pl-k\">=</span> tf.Print(y, [<span class=\"pl-s\"><span class=\"pl-pds\">'</span>y<span class=\"pl-pds\">'</span></span>])\nz <span class=\"pl-k\">=</span> tf.constant(<span class=\"pl-c1\">3.0</span>)\nz <span class=\"pl-k\">=</span> tf.Print(z, [<span class=\"pl-s\"><span class=\"pl-pds\">'</span>z<span class=\"pl-pds\">'</span></span>])\n\n<span class=\"pl-k\">with</span> tf.Session() <span class=\"pl-k\">as</span> sess:\n    <span class=\"pl-c1\">print</span>(sess.run([x,y,z]))</pre></div>\n<p>The sequence of output of <code>tf.Print</code> is indeterminate, which means <code>sess.run</code> don't executes tensors from left to right.</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">import</span> tensorflow <span class=\"pl-k\">as</span> tf\n\nx <span class=\"pl-k\">=</span> tf.constant(<span class=\"pl-c1\">1.0</span>)\nx <span class=\"pl-k\">=</span> tf.Print(x, [<span class=\"pl-s\"><span class=\"pl-pds\">'</span>x<span class=\"pl-pds\">'</span></span>])\ny <span class=\"pl-k\">=</span> tf.constant(<span class=\"pl-c1\">2.0</span>)\ny <span class=\"pl-k\">=</span> tf.Print(y, [<span class=\"pl-s\"><span class=\"pl-pds\">'</span>y<span class=\"pl-pds\">'</span></span>])\n<span class=\"pl-k\">with</span> tf.control_dependencies([x, y]):\n    z <span class=\"pl-k\">=</span> tf.constant(<span class=\"pl-c1\">3.0</span>)\n    z <span class=\"pl-k\">=</span> tf.Print(z, [<span class=\"pl-s\"><span class=\"pl-pds\">'</span>z<span class=\"pl-pds\">'</span></span>])\n\n<span class=\"pl-k\">with</span> tf.Session() <span class=\"pl-k\">as</span> sess:\n    <span class=\"pl-c1\">print</span>(sess.run(z))</pre></div>\n<p>The sequence  of <code>x</code> and <code>y</code> is indeterminate, which means <code>control_dependencies</code> don't executes tensors from left to right.</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">import</span> tensorflow <span class=\"pl-k\">as</span> tf\n\nx <span class=\"pl-k\">=</span> tf.constant(<span class=\"pl-c1\">1.0</span>)\nx <span class=\"pl-k\">=</span> tf.Print(x, [<span class=\"pl-s\"><span class=\"pl-pds\">'</span>x<span class=\"pl-pds\">'</span></span>])\ny <span class=\"pl-k\">=</span> tf.constant(<span class=\"pl-c1\">2.0</span>)\ny <span class=\"pl-k\">=</span> tf.Print(y, [<span class=\"pl-s\"><span class=\"pl-pds\">'</span>y<span class=\"pl-pds\">'</span></span>])\nd <span class=\"pl-k\">=</span> tf.constant(<span class=\"pl-c1\">3.0</span>)\nd <span class=\"pl-k\">=</span> tf.Print(d, [<span class=\"pl-s\"><span class=\"pl-pds\">'</span>d<span class=\"pl-pds\">'</span></span>])\n<span class=\"pl-k\">with</span> tf.control_dependencies([x, y]):\n    z <span class=\"pl-k\">=</span> tf.add(d, <span class=\"pl-c1\">3</span>.)\n    z <span class=\"pl-k\">=</span> tf.Print(z, [<span class=\"pl-s\"><span class=\"pl-pds\">'</span>z<span class=\"pl-pds\">'</span></span>])\n\n<span class=\"pl-k\">with</span> tf.Session() <span class=\"pl-k\">as</span> sess:\n    <span class=\"pl-c1\">print</span>(sess.run(z))</pre></div>\n<p>The sequence of <code>x</code>, <code>y</code> and <code>d</code> is indeterminate.</p>\n<p>Is it intentional behavior or bug?  I find that if the sequence is indeterminate, the program may get different result.</p>\n<p>Another example I can't explain:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">import</span> tensorflow <span class=\"pl-k\">as</span> tf\n\nx <span class=\"pl-k\">=</span> tf.placeholder(tf.float32, [])\ny <span class=\"pl-k\">=</span> tf.Variable(<span class=\"pl-c1\">2</span>.)\nop <span class=\"pl-k\">=</span> tf.assign(y, x)\nop <span class=\"pl-k\">=</span> tf.Print(op, [<span class=\"pl-s\"><span class=\"pl-pds\">'</span>op<span class=\"pl-pds\">'</span></span>])\n\n<span class=\"pl-k\">with</span> tf.control_dependencies([op]):\n    q <span class=\"pl-k\">=</span> tf.Print(y, [y])\n\n\n<span class=\"pl-k\">with</span> tf.Session() <span class=\"pl-k\">as</span> sess:\n    tf.global_variables_initializer().run()\n    <span class=\"pl-c1\">print</span>(sess.run([q], <span class=\"pl-v\">feed_dict</span><span class=\"pl-k\">=</span>{x: <span class=\"pl-k\">-</span><span class=\"pl-c1\">1.0</span>}))</pre></div>\n<p>The <code>[op]</code> is printed before <code>[y]</code>, but <code>q=2.0</code>, why? If <code>op</code> is executed before <code>y</code>, y will be assigned by <code>x</code>, which means <code>y=-1.0</code>, and <code>q</code> should be <code>-1.0</code>.</p>", "body_text": "See three examples:\nimport tensorflow as tf\n\nx = tf.constant(1.0)\nx = tf.Print(x, ['x'])\ny = tf.constant(2.0)\ny = tf.Print(y, ['y'])\nz = tf.constant(3.0)\nz = tf.Print(z, ['z'])\n\nwith tf.Session() as sess:\n    print(sess.run([x,y,z]))\nThe sequence of output of tf.Print is indeterminate, which means sess.run don't executes tensors from left to right.\nimport tensorflow as tf\n\nx = tf.constant(1.0)\nx = tf.Print(x, ['x'])\ny = tf.constant(2.0)\ny = tf.Print(y, ['y'])\nwith tf.control_dependencies([x, y]):\n    z = tf.constant(3.0)\n    z = tf.Print(z, ['z'])\n\nwith tf.Session() as sess:\n    print(sess.run(z))\nThe sequence  of x and y is indeterminate, which means control_dependencies don't executes tensors from left to right.\nimport tensorflow as tf\n\nx = tf.constant(1.0)\nx = tf.Print(x, ['x'])\ny = tf.constant(2.0)\ny = tf.Print(y, ['y'])\nd = tf.constant(3.0)\nd = tf.Print(d, ['d'])\nwith tf.control_dependencies([x, y]):\n    z = tf.add(d, 3.)\n    z = tf.Print(z, ['z'])\n\nwith tf.Session() as sess:\n    print(sess.run(z))\nThe sequence of x, y and d is indeterminate.\nIs it intentional behavior or bug?  I find that if the sequence is indeterminate, the program may get different result.\nAnother example I can't explain:\nimport tensorflow as tf\n\nx = tf.placeholder(tf.float32, [])\ny = tf.Variable(2.)\nop = tf.assign(y, x)\nop = tf.Print(op, ['op'])\n\nwith tf.control_dependencies([op]):\n    q = tf.Print(y, [y])\n\n\nwith tf.Session() as sess:\n    tf.global_variables_initializer().run()\n    print(sess.run([q], feed_dict={x: -1.0}))\nThe [op] is printed before [y], but q=2.0, why? If op is executed before y, y will be assigned by x, which means y=-1.0, and q should be -1.0.", "body": "See three examples:\r\n\r\n```python\r\nimport tensorflow as tf\r\n\r\nx = tf.constant(1.0)\r\nx = tf.Print(x, ['x'])\r\ny = tf.constant(2.0)\r\ny = tf.Print(y, ['y'])\r\nz = tf.constant(3.0)\r\nz = tf.Print(z, ['z'])\r\n\r\nwith tf.Session() as sess:\r\n    print(sess.run([x,y,z]))\r\n```\r\n\r\nThe sequence of output of `tf.Print` is indeterminate, which means `sess.run` don't executes tensors from left to right.\r\n\r\n```python\r\nimport tensorflow as tf\r\n\r\nx = tf.constant(1.0)\r\nx = tf.Print(x, ['x'])\r\ny = tf.constant(2.0)\r\ny = tf.Print(y, ['y'])\r\nwith tf.control_dependencies([x, y]):\r\n    z = tf.constant(3.0)\r\n    z = tf.Print(z, ['z'])\r\n\r\nwith tf.Session() as sess:\r\n    print(sess.run(z))\r\n```\r\n\r\nThe sequence  of `x` and `y` is indeterminate, which means `control_dependencies` don't executes tensors from left to right.\r\n\r\n```python\r\nimport tensorflow as tf\r\n\r\nx = tf.constant(1.0)\r\nx = tf.Print(x, ['x'])\r\ny = tf.constant(2.0)\r\ny = tf.Print(y, ['y'])\r\nd = tf.constant(3.0)\r\nd = tf.Print(d, ['d'])\r\nwith tf.control_dependencies([x, y]):\r\n    z = tf.add(d, 3.)\r\n    z = tf.Print(z, ['z'])\r\n\r\nwith tf.Session() as sess:\r\n    print(sess.run(z))\r\n```\r\n\r\nThe sequence of `x`, `y` and `d` is indeterminate.\r\n\r\nIs it intentional behavior or bug?  I find that if the sequence is indeterminate, the program may get different result.\r\n\r\n\r\nAnother example I can't explain:\r\n\r\n```python\r\nimport tensorflow as tf\r\n\r\nx = tf.placeholder(tf.float32, [])\r\ny = tf.Variable(2.)\r\nop = tf.assign(y, x)\r\nop = tf.Print(op, ['op'])\r\n\r\nwith tf.control_dependencies([op]):\r\n    q = tf.Print(y, [y])\r\n\r\n\r\nwith tf.Session() as sess:\r\n    tf.global_variables_initializer().run()\r\n    print(sess.run([q], feed_dict={x: -1.0}))\r\n```\r\n\r\nThe `[op]` is printed before `[y]`, but `q=2.0`, why? If `op` is executed before `y`, y will be assigned by `x`, which means `y=-1.0`, and `q` should be `-1.0`.\r\n\r\n"}