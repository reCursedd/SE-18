{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/385542858", "html_url": "https://github.com/tensorflow/tensorflow/issues/18880#issuecomment-385542858", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/18880", "id": 385542858, "node_id": "MDEyOklzc3VlQ29tbWVudDM4NTU0Mjg1OA==", "user": {"login": "make1980", "id": 19718982, "node_id": "MDQ6VXNlcjE5NzE4OTgy", "avatar_url": "https://avatars3.githubusercontent.com/u/19718982?v=4", "gravatar_id": "", "url": "https://api.github.com/users/make1980", "html_url": "https://github.com/make1980", "followers_url": "https://api.github.com/users/make1980/followers", "following_url": "https://api.github.com/users/make1980/following{/other_user}", "gists_url": "https://api.github.com/users/make1980/gists{/gist_id}", "starred_url": "https://api.github.com/users/make1980/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/make1980/subscriptions", "organizations_url": "https://api.github.com/users/make1980/orgs", "repos_url": "https://api.github.com/users/make1980/repos", "events_url": "https://api.github.com/users/make1980/events{/privacy}", "received_events_url": "https://api.github.com/users/make1980/received_events", "type": "User", "site_admin": false}, "created_at": "2018-04-30T22:05:10Z", "updated_at": "2018-04-30T22:33:15Z", "author_association": "NONE", "body_html": "<p>Hi <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=1284535\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/saeta\">@saeta</a> ,</p>\n<p>Thanks for the links. I looked at the implementation of ClusterSpec propagation and ClusterResolver which allows the following scenario if I understand correctly - a worker which initiated the session failed over, it can restart and construct a new cluster spec using a pluggable cluster resolver to restart a new session. ClusterSpec propagation allows all the workers participating in the new session to retrieve the IP/port of other workers (including the worker which just failed over) from the master.</p>\n<p>However, in this scenario for the sessions initiated from other workers, this failed-over worker can't rejoin the existing session on behalf of its previous incarnation(for example, in-graph replication case).</p>\n<p>There are definitely more details that need to be figured out such as how failed-over workers rejoining an existing session would be able to recover its local state, and how failed-over ps can restore its variables. But as the first step, I think having a translation layer from a logical hostname to IP/port at runtime is more flexible and necessary.</p>\n<p>ClusterSpec propagation can be used to enable scenarios such as auto-scaling but we need this dynamic RPC resolution feature to easily support the single worker fail-over scenario based on my understanding.</p>", "body_text": "Hi @saeta ,\nThanks for the links. I looked at the implementation of ClusterSpec propagation and ClusterResolver which allows the following scenario if I understand correctly - a worker which initiated the session failed over, it can restart and construct a new cluster spec using a pluggable cluster resolver to restart a new session. ClusterSpec propagation allows all the workers participating in the new session to retrieve the IP/port of other workers (including the worker which just failed over) from the master.\nHowever, in this scenario for the sessions initiated from other workers, this failed-over worker can't rejoin the existing session on behalf of its previous incarnation(for example, in-graph replication case).\nThere are definitely more details that need to be figured out such as how failed-over workers rejoining an existing session would be able to recover its local state, and how failed-over ps can restore its variables. But as the first step, I think having a translation layer from a logical hostname to IP/port at runtime is more flexible and necessary.\nClusterSpec propagation can be used to enable scenarios such as auto-scaling but we need this dynamic RPC resolution feature to easily support the single worker fail-over scenario based on my understanding.", "body": "Hi @saeta ,\r\n\r\nThanks for the links. I looked at the implementation of ClusterSpec propagation and ClusterResolver which allows the following scenario if I understand correctly - a worker which initiated the session failed over, it can restart and construct a new cluster spec using a pluggable cluster resolver to restart a new session. ClusterSpec propagation allows all the workers participating in the new session to retrieve the IP/port of other workers (including the worker which just failed over) from the master. \r\n\r\nHowever, in this scenario for the sessions initiated from other workers, this failed-over worker can't rejoin the existing session on behalf of its previous incarnation(for example, in-graph replication case).\r\n\r\nThere are definitely more details that need to be figured out such as how failed-over workers rejoining an existing session would be able to recover its local state, and how failed-over ps can restore its variables. But as the first step, I think having a translation layer from a logical hostname to IP/port at runtime is more flexible and necessary.\r\n\r\nClusterSpec propagation can be used to enable scenarios such as auto-scaling but we need this dynamic RPC resolution feature to easily support the single worker fail-over scenario based on my understanding."}