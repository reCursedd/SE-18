{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/286808055", "html_url": "https://github.com/tensorflow/tensorflow/issues/4809#issuecomment-286808055", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/4809", "id": 286808055, "node_id": "MDEyOklzc3VlQ29tbWVudDI4NjgwODA1NQ==", "user": {"login": "yaroslavvb", "id": 23068, "node_id": "MDQ6VXNlcjIzMDY4", "avatar_url": "https://avatars3.githubusercontent.com/u/23068?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yaroslavvb", "html_url": "https://github.com/yaroslavvb", "followers_url": "https://api.github.com/users/yaroslavvb/followers", "following_url": "https://api.github.com/users/yaroslavvb/following{/other_user}", "gists_url": "https://api.github.com/users/yaroslavvb/gists{/gist_id}", "starred_url": "https://api.github.com/users/yaroslavvb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yaroslavvb/subscriptions", "organizations_url": "https://api.github.com/users/yaroslavvb/orgs", "repos_url": "https://api.github.com/users/yaroslavvb/repos", "events_url": "https://api.github.com/users/yaroslavvb/events{/privacy}", "received_events_url": "https://api.github.com/users/yaroslavvb/received_events", "type": "User", "site_admin": false}, "created_at": "2017-03-15T16:57:29Z", "updated_at": "2017-03-15T16:57:29Z", "author_association": "CONTRIBUTOR", "body_html": "<p>There's been a feature added recently that provides a work-around -- <code>tf.Print</code> nodes now print microsecond-level timestamp to stderr.</p>\n<p>So you could use tf.Print to wrap nodes responsible for sending/receiving data (ie, generally variable accesses), log things to stderr, and then parse stderr logs for exact timings.</p>\n<p>One possible snag -- wrapping an op in tf.Print guarantees that the op is executed after tf.Print, but it may not be executed immediately after tf.Print. So you could log the timings and take minimum over many tries to get more precise timing. Also, you may use utility like <a href=\"https://github.com/yaroslavvb/stuff/blob/master/linearize\">https://github.com/yaroslavvb/stuff/blob/master/linearize</a> to force TensorFlow to do all computations serially, and double check that the execution order that is chosen does not insert ops between <code>tf.Print</code> and the target op.</p>", "body_text": "There's been a feature added recently that provides a work-around -- tf.Print nodes now print microsecond-level timestamp to stderr.\nSo you could use tf.Print to wrap nodes responsible for sending/receiving data (ie, generally variable accesses), log things to stderr, and then parse stderr logs for exact timings.\nOne possible snag -- wrapping an op in tf.Print guarantees that the op is executed after tf.Print, but it may not be executed immediately after tf.Print. So you could log the timings and take minimum over many tries to get more precise timing. Also, you may use utility like https://github.com/yaroslavvb/stuff/blob/master/linearize to force TensorFlow to do all computations serially, and double check that the execution order that is chosen does not insert ops between tf.Print and the target op.", "body": "There's been a feature added recently that provides a work-around -- `tf.Print` nodes now print microsecond-level timestamp to stderr.\r\n\r\nSo you could use tf.Print to wrap nodes responsible for sending/receiving data (ie, generally variable accesses), log things to stderr, and then parse stderr logs for exact timings.\r\n\r\nOne possible snag -- wrapping an op in tf.Print guarantees that the op is executed after tf.Print, but it may not be executed immediately after tf.Print. So you could log the timings and take minimum over many tries to get more precise timing. Also, you may use utility like https://github.com/yaroslavvb/stuff/blob/master/linearize to force TensorFlow to do all computations serially, and double check that the execution order that is chosen does not insert ops between `tf.Print` and the target op.\r\n\r\n"}