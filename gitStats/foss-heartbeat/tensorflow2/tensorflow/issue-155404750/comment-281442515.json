{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/281442515", "html_url": "https://github.com/tensorflow/tensorflow/issues/2412#issuecomment-281442515", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2412", "id": 281442515, "node_id": "MDEyOklzc3VlQ29tbWVudDI4MTQ0MjUxNQ==", "user": {"login": "mrry", "id": 192142, "node_id": "MDQ6VXNlcjE5MjE0Mg==", "avatar_url": "https://avatars1.githubusercontent.com/u/192142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mrry", "html_url": "https://github.com/mrry", "followers_url": "https://api.github.com/users/mrry/followers", "following_url": "https://api.github.com/users/mrry/following{/other_user}", "gists_url": "https://api.github.com/users/mrry/gists{/gist_id}", "starred_url": "https://api.github.com/users/mrry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mrry/subscriptions", "organizations_url": "https://api.github.com/users/mrry/orgs", "repos_url": "https://api.github.com/users/mrry/repos", "events_url": "https://api.github.com/users/mrry/events{/privacy}", "received_events_url": "https://api.github.com/users/mrry/received_events", "type": "User", "site_admin": false}, "created_at": "2017-02-21T18:59:09Z", "updated_at": "2017-02-21T18:59:09Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=7381578\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/acomarce\">@acomarce</a> Two things, really:</p>\n<ol>\n<li>We'd need to set up the <code>__declspec(dllexport)</code>/<code>__declspec(dllimport)</code> annotations to define the set of symbols that would be exported by/imported from such a DLL.</li>\n<li>We'd need some additional build rules for creating the DLL in either the CMake or Bazel builds.</li>\n</ol>\n<p>Part 1 will probably be easier if we focus on the C API, which has been designed as a stable API for consumption by many different projects, and has stronger versioning guarantees. The C++ API is more sprawling, and it would require invasive changes to set up the appropriate annotations. (I was just chatting with <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=22941064\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/guschmue\">@guschmue</a>, who observed that CMake has a newish feature for generating these definitions without code modification, but the resulting DLL ends up with more than the maximum 65536 symbols exported....)</p>\n<p>I'm not aware of anyone who is working on this right now. Contributions would be welcome!</p>", "body_text": "@acomarce Two things, really:\n\nWe'd need to set up the __declspec(dllexport)/__declspec(dllimport) annotations to define the set of symbols that would be exported by/imported from such a DLL.\nWe'd need some additional build rules for creating the DLL in either the CMake or Bazel builds.\n\nPart 1 will probably be easier if we focus on the C API, which has been designed as a stable API for consumption by many different projects, and has stronger versioning guarantees. The C++ API is more sprawling, and it would require invasive changes to set up the appropriate annotations. (I was just chatting with @guschmue, who observed that CMake has a newish feature for generating these definitions without code modification, but the resulting DLL ends up with more than the maximum 65536 symbols exported....)\nI'm not aware of anyone who is working on this right now. Contributions would be welcome!", "body": "@acomarce Two things, really:\r\n\r\n1. We'd need to set up the `__declspec(dllexport)`/`__declspec(dllimport)` annotations to define the set of symbols that would be exported by/imported from such a DLL.\r\n2. We'd need some additional build rules for creating the DLL in either the CMake or Bazel builds.\r\n\r\nPart 1 will probably be easier if we focus on the C API, which has been designed as a stable API for consumption by many different projects, and has stronger versioning guarantees. The C++ API is more sprawling, and it would require invasive changes to set up the appropriate annotations. (I was just chatting with @guschmue, who observed that CMake has a newish feature for generating these definitions without code modification, but the resulting DLL ends up with more than the maximum 65536 symbols exported....)\r\n\r\nI'm not aware of anyone who is working on this right now. Contributions would be welcome!"}