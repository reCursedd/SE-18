{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/288481410", "html_url": "https://github.com/tensorflow/tensorflow/issues/2412#issuecomment-288481410", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2412", "id": 288481410, "node_id": "MDEyOklzc3VlQ29tbWVudDI4ODQ4MTQxMA==", "user": {"login": "mrry", "id": 192142, "node_id": "MDQ6VXNlcjE5MjE0Mg==", "avatar_url": "https://avatars1.githubusercontent.com/u/192142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mrry", "html_url": "https://github.com/mrry", "followers_url": "https://api.github.com/users/mrry/followers", "following_url": "https://api.github.com/users/mrry/following{/other_user}", "gists_url": "https://api.github.com/users/mrry/gists{/gist_id}", "starred_url": "https://api.github.com/users/mrry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mrry/subscriptions", "organizations_url": "https://api.github.com/users/mrry/orgs", "repos_url": "https://api.github.com/users/mrry/repos", "events_url": "https://api.github.com/users/mrry/events{/privacy}", "received_events_url": "https://api.github.com/users/mrry/received_events", "type": "User", "site_admin": false}, "created_at": "2017-03-22T17:44:42Z", "updated_at": "2017-03-22T17:44:42Z", "author_association": "CONTRIBUTOR", "body_html": "<p>For the public <em>client</em> API, it should be relatively easy to make a DLL that exports just the symbols in <a href=\"https://github.com/tensorflow/tensorflow/blob/master/tensorflow/c/c_api.h\"><code>c_api.h</code></a> and I think we'd welcome contributions to the CMake or Bazel/Windows builds that make this possible.</p>\n<p>The <code>_pywrap_tensorflow.pyd</code> library exports far more symbols in order to support the implicity-defined public <em>framework</em> API which custom op kernels use. Making <code>tf.load_library()</code> work on Windows required heroic efforts from <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=22941064\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/guschmue\">@guschmue</a> to scrape all of the necessary symbols :) from the library (and then subset them to avoid hitting symbol table limits). Part of the issue is that some of the public framework API includes generated code (e.g. protobuf headers), and threading the appropriate definitions through to the linker is somewhat challenging....</p>\n<p>All of which is a long-winded way of saying (in my opinion) the de facto public API for the framework (i.e. to support custom ops) is too unwieldy, and I don't think we should exhaustively trace down every symbol that needs to be exported. It would be better to spend time defining a clean, self-contained, and possibly versioned API for creating extension modules, probably exporting C bindings like the client API, and then we could have more confidence about modules working across different builds of TensorFlow. This would be a big undertaking though....</p>", "body_text": "For the public client API, it should be relatively easy to make a DLL that exports just the symbols in c_api.h and I think we'd welcome contributions to the CMake or Bazel/Windows builds that make this possible.\nThe _pywrap_tensorflow.pyd library exports far more symbols in order to support the implicity-defined public framework API which custom op kernels use. Making tf.load_library() work on Windows required heroic efforts from @guschmue to scrape all of the necessary symbols :) from the library (and then subset them to avoid hitting symbol table limits). Part of the issue is that some of the public framework API includes generated code (e.g. protobuf headers), and threading the appropriate definitions through to the linker is somewhat challenging....\nAll of which is a long-winded way of saying (in my opinion) the de facto public API for the framework (i.e. to support custom ops) is too unwieldy, and I don't think we should exhaustively trace down every symbol that needs to be exported. It would be better to spend time defining a clean, self-contained, and possibly versioned API for creating extension modules, probably exporting C bindings like the client API, and then we could have more confidence about modules working across different builds of TensorFlow. This would be a big undertaking though....", "body": "For the public *client* API, it should be relatively easy to make a DLL that exports just the symbols in [`c_api.h`](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/c/c_api.h) and I think we'd welcome contributions to the CMake or Bazel/Windows builds that make this possible.\r\n\r\nThe `_pywrap_tensorflow.pyd` library exports far more symbols in order to support the implicity-defined public *framework* API which custom op kernels use. Making `tf.load_library()` work on Windows required heroic efforts from @guschmue to scrape all of the necessary symbols :) from the library (and then subset them to avoid hitting symbol table limits). Part of the issue is that some of the public framework API includes generated code (e.g. protobuf headers), and threading the appropriate definitions through to the linker is somewhat challenging....\r\n\r\nAll of which is a long-winded way of saying (in my opinion) the de facto public API for the framework (i.e. to support custom ops) is too unwieldy, and I don't think we should exhaustively trace down every symbol that needs to be exported. It would be better to spend time defining a clean, self-contained, and possibly versioned API for creating extension modules, probably exporting C bindings like the client API, and then we could have more confidence about modules working across different builds of TensorFlow. This would be a big undertaking though...."}