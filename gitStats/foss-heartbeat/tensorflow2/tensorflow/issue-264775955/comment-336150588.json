{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/336150588", "html_url": "https://github.com/tensorflow/tensorflow/issues/13648#issuecomment-336150588", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13648", "id": 336150588, "node_id": "MDEyOklzc3VlQ29tbWVudDMzNjE1MDU4OA==", "user": {"login": "mrry", "id": 192142, "node_id": "MDQ6VXNlcjE5MjE0Mg==", "avatar_url": "https://avatars1.githubusercontent.com/u/192142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mrry", "html_url": "https://github.com/mrry", "followers_url": "https://api.github.com/users/mrry/followers", "following_url": "https://api.github.com/users/mrry/following{/other_user}", "gists_url": "https://api.github.com/users/mrry/gists{/gist_id}", "starred_url": "https://api.github.com/users/mrry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mrry/subscriptions", "organizations_url": "https://api.github.com/users/mrry/orgs", "repos_url": "https://api.github.com/users/mrry/repos", "events_url": "https://api.github.com/users/mrry/events{/privacy}", "received_events_url": "https://api.github.com/users/mrry/received_events", "type": "User", "site_admin": false}, "created_at": "2017-10-12T14:15:14Z", "updated_at": "2017-10-12T14:15:14Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Yes, Todd's explanation is correct. The most confusing aspect of <code>tf.train.string_input_producer()</code> is that, while it looks like a regular operation, it is actually implemented using a separate set of <code>sess.run()</code> calls that run in the background in a queue-runner thread. It is these hidden calls that are failing because they don't know about the value you want to bind to the placeholder. They also start happening when you call <code>tf.train.start_queue_runners()</code>, and <strong>before</strong> you feed the value for the placeholder.</p>\n<p>Todd also mentioned that we have a new API that makes doing this kind of thing easier. (One nit: you can use the much simpler \"initializable\" iterators, and don't need to use \"feedable\" ones for this case.) Here's what your program would look like in TF 1.4 (for TF 1.3, using <code>tf.contrib.data</code> instead of <code>tf.data</code>):</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">import</span> tensorflow <span class=\"pl-k\">as</span> tf\n\nfilename <span class=\"pl-k\">=</span> tf.placeholder(tf.string, [], <span class=\"pl-v\">name</span> <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>s<span class=\"pl-pds\">'</span></span>)\nrecord_defaults <span class=\"pl-k\">=</span> [[<span class=\"pl-c1\">1.0</span>], [<span class=\"pl-c1\">1</span>]]\n\nlines_dataset <span class=\"pl-k\">=</span> tf.data.TextLineDataset(filename)\nparsed_dataset <span class=\"pl-k\">=</span> lines_dataset.map(<span class=\"pl-k\">lambda</span> <span class=\"pl-smi\">line</span>: tf.decode_csv(line, <span class=\"pl-v\">record_defaults</span><span class=\"pl-k\">=</span>record_defaults))\niterator <span class=\"pl-k\">=</span> parsed_dataset.make_initializable_iterator()\ninputs, labels <span class=\"pl-k\">=</span> iterator.get_next()\n\nss <span class=\"pl-k\">=</span> [<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>file0.csv<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>file1.csv<span class=\"pl-pds\">\"</span></span>]\n\n<span class=\"pl-k\">with</span> tf.Session() <span class=\"pl-k\">as</span> sess:\n  <span class=\"pl-k\">for</span> e <span class=\"pl-k\">in</span> ss:\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> Feed once per file to initialize the iterator.</span>\n    sess.run(iterator.initializer, <span class=\"pl-v\">feed_dict</span><span class=\"pl-k\">=</span>{filename: e})\n\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> Loop over the lines of the file until `OutOfRangeError` indicates end-of-file.</span>\n    <span class=\"pl-k\">try</span>:\n      <span class=\"pl-k\">while</span> <span class=\"pl-c1\">True</span>:\n        inputs_val, labels_val <span class=\"pl-k\">=</span> sess.run([inputs, labels])  <span class=\"pl-c\"><span class=\"pl-c\">#</span> <span class=\"pl-k\">NOTE</span>: No `feed_dict` needed here.</span>\n        <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>input <span class=\"pl-c1\">{}</span> - label <span class=\"pl-c1\">{}</span><span class=\"pl-pds\">\"</span></span>.format(inputs_val, labels_val))\n      <span class=\"pl-k\">except</span> tf.errors.OutOfRangeError:\n        <span class=\"pl-k\">pass</span></pre></div>", "body_text": "Yes, Todd's explanation is correct. The most confusing aspect of tf.train.string_input_producer() is that, while it looks like a regular operation, it is actually implemented using a separate set of sess.run() calls that run in the background in a queue-runner thread. It is these hidden calls that are failing because they don't know about the value you want to bind to the placeholder. They also start happening when you call tf.train.start_queue_runners(), and before you feed the value for the placeholder.\nTodd also mentioned that we have a new API that makes doing this kind of thing easier. (One nit: you can use the much simpler \"initializable\" iterators, and don't need to use \"feedable\" ones for this case.) Here's what your program would look like in TF 1.4 (for TF 1.3, using tf.contrib.data instead of tf.data):\nimport tensorflow as tf\n\nfilename = tf.placeholder(tf.string, [], name = 's')\nrecord_defaults = [[1.0], [1]]\n\nlines_dataset = tf.data.TextLineDataset(filename)\nparsed_dataset = lines_dataset.map(lambda line: tf.decode_csv(line, record_defaults=record_defaults))\niterator = parsed_dataset.make_initializable_iterator()\ninputs, labels = iterator.get_next()\n\nss = [\"file0.csv\", \"file1.csv\"]\n\nwith tf.Session() as sess:\n  for e in ss:\n    # Feed once per file to initialize the iterator.\n    sess.run(iterator.initializer, feed_dict={filename: e})\n\n    # Loop over the lines of the file until `OutOfRangeError` indicates end-of-file.\n    try:\n      while True:\n        inputs_val, labels_val = sess.run([inputs, labels])  # NOTE: No `feed_dict` needed here.\n        print(\"input {} - label {}\".format(inputs_val, labels_val))\n      except tf.errors.OutOfRangeError:\n        pass", "body": "Yes, Todd's explanation is correct. The most confusing aspect of `tf.train.string_input_producer()` is that, while it looks like a regular operation, it is actually implemented using a separate set of `sess.run()` calls that run in the background in a queue-runner thread. It is these hidden calls that are failing because they don't know about the value you want to bind to the placeholder. They also start happening when you call `tf.train.start_queue_runners()`, and **before** you feed the value for the placeholder.\r\n\r\nTodd also mentioned that we have a new API that makes doing this kind of thing easier. (One nit: you can use the much simpler \"initializable\" iterators, and don't need to use \"feedable\" ones for this case.) Here's what your program would look like in TF 1.4 (for TF 1.3, using `tf.contrib.data` instead of `tf.data`):\r\n\r\n```python\r\nimport tensorflow as tf\r\n\r\nfilename = tf.placeholder(tf.string, [], name = 's')\r\nrecord_defaults = [[1.0], [1]]\r\n\r\nlines_dataset = tf.data.TextLineDataset(filename)\r\nparsed_dataset = lines_dataset.map(lambda line: tf.decode_csv(line, record_defaults=record_defaults))\r\niterator = parsed_dataset.make_initializable_iterator()\r\ninputs, labels = iterator.get_next()\r\n\r\nss = [\"file0.csv\", \"file1.csv\"]\r\n\r\nwith tf.Session() as sess:\r\n  for e in ss:\r\n    # Feed once per file to initialize the iterator.\r\n    sess.run(iterator.initializer, feed_dict={filename: e})\r\n\r\n    # Loop over the lines of the file until `OutOfRangeError` indicates end-of-file.\r\n    try:\r\n      while True:\r\n        inputs_val, labels_val = sess.run([inputs, labels])  # NOTE: No `feed_dict` needed here.\r\n        print(\"input {} - label {}\".format(inputs_val, labels_val))\r\n      except tf.errors.OutOfRangeError:\r\n        pass\r\n```"}