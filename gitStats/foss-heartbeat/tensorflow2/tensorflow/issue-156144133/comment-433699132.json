{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/433699132", "html_url": "https://github.com/tensorflow/tensorflow/issues/2462#issuecomment-433699132", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2462", "id": 433699132, "node_id": "MDEyOklzc3VlQ29tbWVudDQzMzY5OTEzMg==", "user": {"login": "mrgloom", "id": 4003908, "node_id": "MDQ6VXNlcjQwMDM5MDg=", "avatar_url": "https://avatars0.githubusercontent.com/u/4003908?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mrgloom", "html_url": "https://github.com/mrgloom", "followers_url": "https://api.github.com/users/mrgloom/followers", "following_url": "https://api.github.com/users/mrgloom/following{/other_user}", "gists_url": "https://api.github.com/users/mrgloom/gists{/gist_id}", "starred_url": "https://api.github.com/users/mrgloom/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mrgloom/subscriptions", "organizations_url": "https://api.github.com/users/mrgloom/orgs", "repos_url": "https://api.github.com/users/mrgloom/repos", "events_url": "https://api.github.com/users/mrgloom/events{/privacy}", "received_events_url": "https://api.github.com/users/mrgloom/received_events", "type": "User", "site_admin": false}, "created_at": "2018-10-28T12:07:00Z", "updated_at": "2018-10-28T12:07:00Z", "author_association": "NONE", "body_html": "<p>Is clipping with <code>eps</code> still not make solution stable?</p>\n<p>Example:</p>\n<pre><code># Array of samples\ny_pred_arr = np.array([[0.4,0.3,0.3], [1.0,0.0,0.0], [0.0,0.0,1.0]], np.float32)\ny_true_arr = np.array([[1,0,0], [1,0,0], [0,0,1]], np.float32)\n\nprint('y_pred_arr.shape', y_pred_arr.shape)\nprint('y_true_arr.shape', y_true_arr.shape)\n\n# 1 : Implemented in numpy\ndef cross_entropy_loss(y_pred_arr, y_true_arr, eps=1e-6):\n    p_arr = np.clip(y_pred_arr, eps, 1 - eps)\n    n_samples = p_arr.shape[0]\n    n_classes = p_arr.shape[1]\n    loss_arr = np.zeros((n_samples,), np.float32)\n    for i in range(n_samples):\n        for c in range(n_classes):\n            loss_arr[i] += -y_true_arr[i][c] * np.log(p_arr[i][c])\n    loss = np.mean(loss_arr)\n    return loss\nloss = cross_entropy_loss(y_pred_arr, y_true_arr)\nprint(loss)\n\n# 2 : Implemented in sklearn\nfrom sklearn.metrics import log_loss\nloss = log_loss(np.argmax(y_true_arr,axis=1), y_pred_arr, labels=[0,1,2], eps=1e-6)\nprint(loss)\n\n# 3 : Implemented in tensorflow\ny_pred_tf = tf.convert_to_tensor(y_pred_arr, np.float32)\ny_true_tf = tf.convert_to_tensor(y_true_arr, np.float32)\neps = 1e-6\ncliped_y_pref_tf = tf.clip_by_value(y_pred_tf, eps, 1-eps)\nloss_tf = tf.reduce_mean(-tf.reduce_sum(y_true_tf * tf.log(cliped_y_pref_tf), axis=1))\nwith tf.Session() as sess:\n    loss = sess.run(loss_tf)\n    print(loss)\n</code></pre>\n<p>Output:</p>\n<pre><code>y_pred_arr.shape (3, 3)\ny_true_arr.shape (3, 3)\n0.30543092\n0.30543154478209544\n0.30543092\n</code></pre>", "body_text": "Is clipping with eps still not make solution stable?\nExample:\n# Array of samples\ny_pred_arr = np.array([[0.4,0.3,0.3], [1.0,0.0,0.0], [0.0,0.0,1.0]], np.float32)\ny_true_arr = np.array([[1,0,0], [1,0,0], [0,0,1]], np.float32)\n\nprint('y_pred_arr.shape', y_pred_arr.shape)\nprint('y_true_arr.shape', y_true_arr.shape)\n\n# 1 : Implemented in numpy\ndef cross_entropy_loss(y_pred_arr, y_true_arr, eps=1e-6):\n    p_arr = np.clip(y_pred_arr, eps, 1 - eps)\n    n_samples = p_arr.shape[0]\n    n_classes = p_arr.shape[1]\n    loss_arr = np.zeros((n_samples,), np.float32)\n    for i in range(n_samples):\n        for c in range(n_classes):\n            loss_arr[i] += -y_true_arr[i][c] * np.log(p_arr[i][c])\n    loss = np.mean(loss_arr)\n    return loss\nloss = cross_entropy_loss(y_pred_arr, y_true_arr)\nprint(loss)\n\n# 2 : Implemented in sklearn\nfrom sklearn.metrics import log_loss\nloss = log_loss(np.argmax(y_true_arr,axis=1), y_pred_arr, labels=[0,1,2], eps=1e-6)\nprint(loss)\n\n# 3 : Implemented in tensorflow\ny_pred_tf = tf.convert_to_tensor(y_pred_arr, np.float32)\ny_true_tf = tf.convert_to_tensor(y_true_arr, np.float32)\neps = 1e-6\ncliped_y_pref_tf = tf.clip_by_value(y_pred_tf, eps, 1-eps)\nloss_tf = tf.reduce_mean(-tf.reduce_sum(y_true_tf * tf.log(cliped_y_pref_tf), axis=1))\nwith tf.Session() as sess:\n    loss = sess.run(loss_tf)\n    print(loss)\n\nOutput:\ny_pred_arr.shape (3, 3)\ny_true_arr.shape (3, 3)\n0.30543092\n0.30543154478209544\n0.30543092", "body": "Is clipping with `eps` still not make solution stable?\r\n\r\nExample:\r\n\r\n~~~\r\n# Array of samples\r\ny_pred_arr = np.array([[0.4,0.3,0.3], [1.0,0.0,0.0], [0.0,0.0,1.0]], np.float32)\r\ny_true_arr = np.array([[1,0,0], [1,0,0], [0,0,1]], np.float32)\r\n\r\nprint('y_pred_arr.shape', y_pred_arr.shape)\r\nprint('y_true_arr.shape', y_true_arr.shape)\r\n\r\n# 1 : Implemented in numpy\r\ndef cross_entropy_loss(y_pred_arr, y_true_arr, eps=1e-6):\r\n    p_arr = np.clip(y_pred_arr, eps, 1 - eps)\r\n    n_samples = p_arr.shape[0]\r\n    n_classes = p_arr.shape[1]\r\n    loss_arr = np.zeros((n_samples,), np.float32)\r\n    for i in range(n_samples):\r\n        for c in range(n_classes):\r\n            loss_arr[i] += -y_true_arr[i][c] * np.log(p_arr[i][c])\r\n    loss = np.mean(loss_arr)\r\n    return loss\r\nloss = cross_entropy_loss(y_pred_arr, y_true_arr)\r\nprint(loss)\r\n\r\n# 2 : Implemented in sklearn\r\nfrom sklearn.metrics import log_loss\r\nloss = log_loss(np.argmax(y_true_arr,axis=1), y_pred_arr, labels=[0,1,2], eps=1e-6)\r\nprint(loss)\r\n\r\n# 3 : Implemented in tensorflow\r\ny_pred_tf = tf.convert_to_tensor(y_pred_arr, np.float32)\r\ny_true_tf = tf.convert_to_tensor(y_true_arr, np.float32)\r\neps = 1e-6\r\ncliped_y_pref_tf = tf.clip_by_value(y_pred_tf, eps, 1-eps)\r\nloss_tf = tf.reduce_mean(-tf.reduce_sum(y_true_tf * tf.log(cliped_y_pref_tf), axis=1))\r\nwith tf.Session() as sess:\r\n    loss = sess.run(loss_tf)\r\n    print(loss)\r\n~~~\r\n\r\nOutput:\r\n~~~\r\ny_pred_arr.shape (3, 3)\r\ny_true_arr.shape (3, 3)\r\n0.30543092\r\n0.30543154478209544\r\n0.30543092\r\n~~~"}