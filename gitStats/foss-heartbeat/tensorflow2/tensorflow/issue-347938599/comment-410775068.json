{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/410775068", "html_url": "https://github.com/tensorflow/tensorflow/issues/21410#issuecomment-410775068", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/21410", "id": 410775068, "node_id": "MDEyOklzc3VlQ29tbWVudDQxMDc3NTA2OA==", "user": {"login": "olesalscheider", "id": 1006058, "node_id": "MDQ6VXNlcjEwMDYwNTg=", "avatar_url": "https://avatars2.githubusercontent.com/u/1006058?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olesalscheider", "html_url": "https://github.com/olesalscheider", "followers_url": "https://api.github.com/users/olesalscheider/followers", "following_url": "https://api.github.com/users/olesalscheider/following{/other_user}", "gists_url": "https://api.github.com/users/olesalscheider/gists{/gist_id}", "starred_url": "https://api.github.com/users/olesalscheider/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olesalscheider/subscriptions", "organizations_url": "https://api.github.com/users/olesalscheider/orgs", "repos_url": "https://api.github.com/users/olesalscheider/repos", "events_url": "https://api.github.com/users/olesalscheider/events{/privacy}", "received_events_url": "https://api.github.com/users/olesalscheider/received_events", "type": "User", "site_admin": false}, "created_at": "2018-08-06T16:53:09Z", "updated_at": "2018-08-06T16:53:09Z", "author_association": "CONTRIBUTOR", "body_html": "<p>It seems that the code just allocates and deallocates a lot of memory - maybe because the size of the masked tensor changes all the time.</p>\n<p>The allocated tensors are quite large but when the pool of the PoolAllocator cannot find a matching chunk it allocates a new one. Since the pool size is only tracked in the number of entries instead of the allocated memory size, the eviction code will only be triggered when the count limit (initially 100) is reached. At this point there are already a lot of unused huge chunks in the pool.</p>\n<p>Maybe PoolAllocator should track the number of bytes in use and try to free huge chunks early if it contains a lot of them?</p>\n<p>Another problem that I saw with the code is that there is a hardcoded eviction rate limit in PoolAllocator. If the eviction rate is high, PoolAllocator does not release the memory but just keeps growing the pool size.<br>\nThis seems useful for performance reasons to some degree, but probably the pool size should have a hard limit since the amount of memory is not unlimited?<br>\nMaybe a good idea would be to ignore the eviction rate once e. g. more than 80% of the system memory is in use. What do you think?</p>", "body_text": "It seems that the code just allocates and deallocates a lot of memory - maybe because the size of the masked tensor changes all the time.\nThe allocated tensors are quite large but when the pool of the PoolAllocator cannot find a matching chunk it allocates a new one. Since the pool size is only tracked in the number of entries instead of the allocated memory size, the eviction code will only be triggered when the count limit (initially 100) is reached. At this point there are already a lot of unused huge chunks in the pool.\nMaybe PoolAllocator should track the number of bytes in use and try to free huge chunks early if it contains a lot of them?\nAnother problem that I saw with the code is that there is a hardcoded eviction rate limit in PoolAllocator. If the eviction rate is high, PoolAllocator does not release the memory but just keeps growing the pool size.\nThis seems useful for performance reasons to some degree, but probably the pool size should have a hard limit since the amount of memory is not unlimited?\nMaybe a good idea would be to ignore the eviction rate once e. g. more than 80% of the system memory is in use. What do you think?", "body": "It seems that the code just allocates and deallocates a lot of memory - maybe because the size of the masked tensor changes all the time.\r\n\r\nThe allocated tensors are quite large but when the pool of the PoolAllocator cannot find a matching chunk it allocates a new one. Since the pool size is only tracked in the number of entries instead of the allocated memory size, the eviction code will only be triggered when the count limit (initially 100) is reached. At this point there are already a lot of unused huge chunks in the pool.\r\n\r\nMaybe PoolAllocator should track the number of bytes in use and try to free huge chunks early if it contains a lot of them?\r\n\r\nAnother problem that I saw with the code is that there is a hardcoded eviction rate limit in PoolAllocator. If the eviction rate is high, PoolAllocator does not release the memory but just keeps growing the pool size.\r\nThis seems useful for performance reasons to some degree, but probably the pool size should have a hard limit since the amount of memory is not unlimited?\r\nMaybe a good idea would be to ignore the eviction rate once e. g. more than 80% of the system memory is in use. What do you think?"}