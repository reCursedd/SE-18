{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/354026312", "html_url": "https://github.com/tensorflow/tensorflow/issues/15589#issuecomment-354026312", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/15589", "id": 354026312, "node_id": "MDEyOklzc3VlQ29tbWVudDM1NDAyNjMxMg==", "user": {"login": "m3bm3b", "id": 10168793, "node_id": "MDQ6VXNlcjEwMTY4Nzkz", "avatar_url": "https://avatars0.githubusercontent.com/u/10168793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m3bm3b", "html_url": "https://github.com/m3bm3b", "followers_url": "https://api.github.com/users/m3bm3b/followers", "following_url": "https://api.github.com/users/m3bm3b/following{/other_user}", "gists_url": "https://api.github.com/users/m3bm3b/gists{/gist_id}", "starred_url": "https://api.github.com/users/m3bm3b/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m3bm3b/subscriptions", "organizations_url": "https://api.github.com/users/m3bm3b/orgs", "repos_url": "https://api.github.com/users/m3bm3b/repos", "events_url": "https://api.github.com/users/m3bm3b/events{/privacy}", "received_events_url": "https://api.github.com/users/m3bm3b/received_events", "type": "User", "site_admin": false}, "created_at": "2017-12-26T23:55:42Z", "updated_at": "2017-12-26T23:55:42Z", "author_association": "NONE", "body_html": "<p>My guess is that the session state pointer in the context is invalid or corrupt.<br>\nI don't know why that would be, but maybe <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=70511\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/girving\">@girving</a> has some thoughts.</p>\n<p>Here's what I see from the stack trace and the source:</p>\n<p>We know that GetSessionHandleOp::Compute() got a SessionState pointer<br>\nout of the context ctx, and it called SessionState::GetNewId() passing that pointer.<br>\nGetNewId() called nsync_mu_lock() passing a pointer that's a constant<br>\noffset from the SessionState pointer.   Thus, the first routine to indirect through that<br>\npointer was nsync_mu_lock().</p>\n<p>It's likely that nsync_mu_lock() is crashing because that SessionState<br>\npointer is bad.  The evidence is:</p>\n<ul>\n<li>The mutex acquistion code crashed in nsync_mu_lock(), rather than in one<br>\nof the routines it calls.  The routine is straightforward, and aside from its stack frame,<br>\nit accesses only one word, in the mutex itself.  Thus, to get a segfault in that routine<br>\ndirectly, either the stack pointer is bad, or the pointer to the mutex is bad.</li>\n<li>Routines on this platform are 16-byte aligned.<br>\nThe PC of the faulting instruction is 0x00007fffb765b307, which is 7 mod 16.<br>\nThat's what you'd expect if nsync_mu_lock() failed on the first attempt to touch the<br>\nmutex, which (as we normally compile it) is at offset 0x17 from the start of the routine.<br>\nIf the stack pointer were bad, we might expect a crash at an address 0 mod 16<br>\n(or indeed at an earlier call)  because the first instruction of the routine pushes to the stack.</li>\n</ul>\n<p>To confirm this, I recommend that you get to the crash in gdb,<br>\nthen report the output of<br>\ndisas<br>\nThis will disassemble nsync::nsync_mu_lock(nsync::nsync_mu_s_*) ,<br>\nand indicate which instruction failed.<br>\nI also recommend reporting the output of<br>\ninfo reg<br>\nwhich will indicate the value of the register being used for the indirection.<br>\nThe pointer value may give a clue as to how it became corrupt.</p>", "body_text": "My guess is that the session state pointer in the context is invalid or corrupt.\nI don't know why that would be, but maybe @girving has some thoughts.\nHere's what I see from the stack trace and the source:\nWe know that GetSessionHandleOp::Compute() got a SessionState pointer\nout of the context ctx, and it called SessionState::GetNewId() passing that pointer.\nGetNewId() called nsync_mu_lock() passing a pointer that's a constant\noffset from the SessionState pointer.   Thus, the first routine to indirect through that\npointer was nsync_mu_lock().\nIt's likely that nsync_mu_lock() is crashing because that SessionState\npointer is bad.  The evidence is:\n\nThe mutex acquistion code crashed in nsync_mu_lock(), rather than in one\nof the routines it calls.  The routine is straightforward, and aside from its stack frame,\nit accesses only one word, in the mutex itself.  Thus, to get a segfault in that routine\ndirectly, either the stack pointer is bad, or the pointer to the mutex is bad.\nRoutines on this platform are 16-byte aligned.\nThe PC of the faulting instruction is 0x00007fffb765b307, which is 7 mod 16.\nThat's what you'd expect if nsync_mu_lock() failed on the first attempt to touch the\nmutex, which (as we normally compile it) is at offset 0x17 from the start of the routine.\nIf the stack pointer were bad, we might expect a crash at an address 0 mod 16\n(or indeed at an earlier call)  because the first instruction of the routine pushes to the stack.\n\nTo confirm this, I recommend that you get to the crash in gdb,\nthen report the output of\ndisas\nThis will disassemble nsync::nsync_mu_lock(nsync::nsync_mu_s_*) ,\nand indicate which instruction failed.\nI also recommend reporting the output of\ninfo reg\nwhich will indicate the value of the register being used for the indirection.\nThe pointer value may give a clue as to how it became corrupt.", "body": "My guess is that the session state pointer in the context is invalid or corrupt.\r\nI don't know why that would be, but maybe @girving has some thoughts.\r\n\r\nHere's what I see from the stack trace and the source:\r\n\r\nWe know that GetSessionHandleOp::Compute() got a SessionState pointer\r\nout of the context ctx, and it called SessionState::GetNewId() passing that pointer.\r\nGetNewId() called nsync_mu_lock() passing a pointer that's a constant \r\noffset from the SessionState pointer.   Thus, the first routine to indirect through that\r\npointer was nsync_mu_lock().\r\n\r\nIt's likely that nsync_mu_lock() is crashing because that SessionState\r\npointer is bad.  The evidence is:\r\n- The mutex acquistion code crashed in nsync_mu_lock(), rather than in one\r\n  of the routines it calls.  The routine is straightforward, and aside from its stack frame, \r\n  it accesses only one word, in the mutex itself.  Thus, to get a segfault in that routine \r\n  directly, either the stack pointer is bad, or the pointer to the mutex is bad. \r\n- Routines on this platform are 16-byte aligned.\r\n  The PC of the faulting instruction is 0x00007fffb765b307, which is 7 mod 16.\r\n  That's what you'd expect if nsync_mu_lock() failed on the first attempt to touch the\r\n   mutex, which (as we normally compile it) is at offset 0x17 from the start of the routine.\r\n   If the stack pointer were bad, we might expect a crash at an address 0 mod 16\r\n   (or indeed at an earlier call)  because the first instruction of the routine pushes to the stack.\r\n\r\nTo confirm this, I recommend that you get to the crash in gdb, \r\nthen report the output of\r\n    disas\r\nThis will disassemble nsync::nsync_mu_lock(nsync::nsync_mu_s_*) ,\r\nand indicate which instruction failed.\r\nI also recommend reporting the output of \r\n    info reg\r\nwhich will indicate the value of the register being used for the indirection.\r\nThe pointer value may give a clue as to how it became corrupt.\r\n\r\n"}