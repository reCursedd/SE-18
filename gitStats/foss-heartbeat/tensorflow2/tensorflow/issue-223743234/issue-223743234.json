{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9407", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9407/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9407/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9407/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/9407", "id": 223743234, "node_id": "MDU6SXNzdWUyMjM3NDMyMzQ=", "number": 9407, "title": "Usage of float64 with version >0.11", "user": {"login": "link-er", "id": 1128291, "node_id": "MDQ6VXNlcjExMjgyOTE=", "avatar_url": "https://avatars3.githubusercontent.com/u/1128291?v=4", "gravatar_id": "", "url": "https://api.github.com/users/link-er", "html_url": "https://github.com/link-er", "followers_url": "https://api.github.com/users/link-er/followers", "following_url": "https://api.github.com/users/link-er/following{/other_user}", "gists_url": "https://api.github.com/users/link-er/gists{/gist_id}", "starred_url": "https://api.github.com/users/link-er/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/link-er/subscriptions", "organizations_url": "https://api.github.com/users/link-er/orgs", "repos_url": "https://api.github.com/users/link-er/repos", "events_url": "https://api.github.com/users/link-er/events{/privacy}", "received_events_url": "https://api.github.com/users/link-er/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2017-04-24T08:39:12Z", "updated_at": "2017-04-24T16:15:20Z", "closed_at": "2017-04-24T16:15:20Z", "author_association": "NONE", "body_html": "<h3>System information</h3>\n<ul>\n<li>Tensorflow is used as a backend for Keras library with setup \"floatx\":\"float64\", i.e. this is default float type</li>\n<li>OS X El Capitan operational system</li>\n<li>TensorFlow was installed via pip</li>\n<li>Tensorflow version 0.12.1</li>\n</ul>\n<p>My custom loss function includes exponent and it gets overflowed very easily, that is why I have to use float64. But after updating TensorFlow from 0.11 to 0.12 (I needed tensorboard) I started to get error while creating the model, when convolutional layer is added.</p>\n<p>Traceback of the error when I am adding a Conv layer to my model:</p>\n<pre><code>miniconda/lib/python2.7/site-packages/keras/models.pyc in add(self, layer)\n    330                  output_shapes=[self.outputs[0]._keras_shape])\n    331         else:\n--&gt; 332             output_tensor = layer(self.outputs[0])\n    333             if isinstance(output_tensor, list):\n    334                 raise TypeError('All layers in a Sequential model '\n\nminiconda/lib/python2.7/site-packages/keras/engine/topology.pyc in __call__(self, x, mask)\n    570         if inbound_layers:\n    571             # This will call layer.build() if necessary.\n--&gt; 572             self.add_inbound_node(inbound_layers, node_indices, tensor_indices)\n    573             # Outputs were already computed when calling self.add_inbound_node.\n    574             outputs = self.inbound_nodes[-1].output_tensors\n\nminiconda/lib/python2.7/site-packages/keras/engine/topology.pyc in add_inbound_node(self, inbound_layers, node_indices, tensor_indices)\n    633         # creating the node automatically updates self.inbound_nodes\n    634         # as well as outbound_nodes on inbound layers.\n--&gt; 635         Node.create_node(self, inbound_layers, node_indices, tensor_indices)\n    636 \n    637     def get_output_shape_for(self, input_shape):\n\nminiconda/lib/python2.7/site-packages/keras/engine/topology.pyc in create_node(cls, outbound_layer, inbound_layers, node_indices, tensor_indices)\n    164 \n    165         if len(input_tensors) == 1:\n--&gt; 166             output_tensors = to_list(outbound_layer.call(input_tensors[0], mask=input_masks[0]))\n    167             output_masks = to_list(outbound_layer.compute_mask(input_tensors[0], input_masks[0]))\n    168             # TODO: try to auto-infer shape\n\nminiconda/lib/python2.7/site-packages/keras/layers/convolutional.pyc in call(self, x, mask)\n    161         output = K.conv2d(x, self.W, strides=self.subsample,\n    162                           border_mode=self.border_mode,\n--&gt; 163                           dim_ordering='tf')\n    164         output = K.squeeze(output, 2)  # remove the dummy dimension\n    165         if self.bias:\n\nminiconda/lib/python2.7/site-packages/keras/backend/tensorflow_backend.pyc in conv2d(x, kernel, strides, border_mode, dim_ordering, image_shape, filter_shape, filter_dilation)\n   2689     if filter_dilation == (1, 1):\n   2690         strides = (1,) + strides + (1,)\n-&gt; 2691         x = tf.nn.conv2d(x, kernel, strides, padding=padding)\n   2692     else:\n   2693         assert filter_dilation[0] == filter_dilation[1]\n\nminiconda/lib/python2.7/site-packages/tensorflow/python/ops/gen_nn_ops.pyc in conv2d(input, filter, strides, padding, use_cudnn_on_gpu, data_format, name)\n    394                                 strides=strides, padding=padding,\n    395                                 use_cudnn_on_gpu=use_cudnn_on_gpu,\n--&gt; 396                                 data_format=data_format, name=name)\n    397   return result\n    398 \n\nminiconda/lib/python2.7/site-packages/tensorflow/python/framework/op_def_library.pyc in apply_op(self, op_type_name, name, **keywords)\n    519                   \"%s type %s of argument '%s'.\" %\n    520                   (prefix, dtypes.as_dtype(attrs[input_arg.type_attr]).name,\n--&gt; 521                    inferred_from[input_arg.type_attr]))\n    522 \n    523           types = [values.dtype]\n\nTypeError: Input 'filter' of 'Conv2D' Op has type float64 that does not match type float32 of argument 'input'.\n</code></pre>\n<p>As I understood, float64 is simply not supported as it is considered to be not needed to have that much of precision, but I need this format because of the numbers that are calculated.<br>\nIs there any solution to this problem?</p>", "body_text": "System information\n\nTensorflow is used as a backend for Keras library with setup \"floatx\":\"float64\", i.e. this is default float type\nOS X El Capitan operational system\nTensorFlow was installed via pip\nTensorflow version 0.12.1\n\nMy custom loss function includes exponent and it gets overflowed very easily, that is why I have to use float64. But after updating TensorFlow from 0.11 to 0.12 (I needed tensorboard) I started to get error while creating the model, when convolutional layer is added.\nTraceback of the error when I am adding a Conv layer to my model:\nminiconda/lib/python2.7/site-packages/keras/models.pyc in add(self, layer)\n    330                  output_shapes=[self.outputs[0]._keras_shape])\n    331         else:\n--> 332             output_tensor = layer(self.outputs[0])\n    333             if isinstance(output_tensor, list):\n    334                 raise TypeError('All layers in a Sequential model '\n\nminiconda/lib/python2.7/site-packages/keras/engine/topology.pyc in __call__(self, x, mask)\n    570         if inbound_layers:\n    571             # This will call layer.build() if necessary.\n--> 572             self.add_inbound_node(inbound_layers, node_indices, tensor_indices)\n    573             # Outputs were already computed when calling self.add_inbound_node.\n    574             outputs = self.inbound_nodes[-1].output_tensors\n\nminiconda/lib/python2.7/site-packages/keras/engine/topology.pyc in add_inbound_node(self, inbound_layers, node_indices, tensor_indices)\n    633         # creating the node automatically updates self.inbound_nodes\n    634         # as well as outbound_nodes on inbound layers.\n--> 635         Node.create_node(self, inbound_layers, node_indices, tensor_indices)\n    636 \n    637     def get_output_shape_for(self, input_shape):\n\nminiconda/lib/python2.7/site-packages/keras/engine/topology.pyc in create_node(cls, outbound_layer, inbound_layers, node_indices, tensor_indices)\n    164 \n    165         if len(input_tensors) == 1:\n--> 166             output_tensors = to_list(outbound_layer.call(input_tensors[0], mask=input_masks[0]))\n    167             output_masks = to_list(outbound_layer.compute_mask(input_tensors[0], input_masks[0]))\n    168             # TODO: try to auto-infer shape\n\nminiconda/lib/python2.7/site-packages/keras/layers/convolutional.pyc in call(self, x, mask)\n    161         output = K.conv2d(x, self.W, strides=self.subsample,\n    162                           border_mode=self.border_mode,\n--> 163                           dim_ordering='tf')\n    164         output = K.squeeze(output, 2)  # remove the dummy dimension\n    165         if self.bias:\n\nminiconda/lib/python2.7/site-packages/keras/backend/tensorflow_backend.pyc in conv2d(x, kernel, strides, border_mode, dim_ordering, image_shape, filter_shape, filter_dilation)\n   2689     if filter_dilation == (1, 1):\n   2690         strides = (1,) + strides + (1,)\n-> 2691         x = tf.nn.conv2d(x, kernel, strides, padding=padding)\n   2692     else:\n   2693         assert filter_dilation[0] == filter_dilation[1]\n\nminiconda/lib/python2.7/site-packages/tensorflow/python/ops/gen_nn_ops.pyc in conv2d(input, filter, strides, padding, use_cudnn_on_gpu, data_format, name)\n    394                                 strides=strides, padding=padding,\n    395                                 use_cudnn_on_gpu=use_cudnn_on_gpu,\n--> 396                                 data_format=data_format, name=name)\n    397   return result\n    398 \n\nminiconda/lib/python2.7/site-packages/tensorflow/python/framework/op_def_library.pyc in apply_op(self, op_type_name, name, **keywords)\n    519                   \"%s type %s of argument '%s'.\" %\n    520                   (prefix, dtypes.as_dtype(attrs[input_arg.type_attr]).name,\n--> 521                    inferred_from[input_arg.type_attr]))\n    522 \n    523           types = [values.dtype]\n\nTypeError: Input 'filter' of 'Conv2D' Op has type float64 that does not match type float32 of argument 'input'.\n\nAs I understood, float64 is simply not supported as it is considered to be not needed to have that much of precision, but I need this format because of the numbers that are calculated.\nIs there any solution to this problem?", "body": "### System information\r\n- Tensorflow is used as a backend for Keras library with setup \"floatx\":\"float64\", i.e. this is default float type\r\n- OS X El Capitan operational system\r\n- TensorFlow was installed via pip\r\n- Tensorflow version 0.12.1\r\n \r\nMy custom loss function includes exponent and it gets overflowed very easily, that is why I have to use float64. But after updating TensorFlow from 0.11 to 0.12 (I needed tensorboard) I started to get error while creating the model, when convolutional layer is added.\r\n\r\nTraceback of the error when I am adding a Conv layer to my model:\r\n```\r\nminiconda/lib/python2.7/site-packages/keras/models.pyc in add(self, layer)\r\n    330                  output_shapes=[self.outputs[0]._keras_shape])\r\n    331         else:\r\n--> 332             output_tensor = layer(self.outputs[0])\r\n    333             if isinstance(output_tensor, list):\r\n    334                 raise TypeError('All layers in a Sequential model '\r\n\r\nminiconda/lib/python2.7/site-packages/keras/engine/topology.pyc in __call__(self, x, mask)\r\n    570         if inbound_layers:\r\n    571             # This will call layer.build() if necessary.\r\n--> 572             self.add_inbound_node(inbound_layers, node_indices, tensor_indices)\r\n    573             # Outputs were already computed when calling self.add_inbound_node.\r\n    574             outputs = self.inbound_nodes[-1].output_tensors\r\n\r\nminiconda/lib/python2.7/site-packages/keras/engine/topology.pyc in add_inbound_node(self, inbound_layers, node_indices, tensor_indices)\r\n    633         # creating the node automatically updates self.inbound_nodes\r\n    634         # as well as outbound_nodes on inbound layers.\r\n--> 635         Node.create_node(self, inbound_layers, node_indices, tensor_indices)\r\n    636 \r\n    637     def get_output_shape_for(self, input_shape):\r\n\r\nminiconda/lib/python2.7/site-packages/keras/engine/topology.pyc in create_node(cls, outbound_layer, inbound_layers, node_indices, tensor_indices)\r\n    164 \r\n    165         if len(input_tensors) == 1:\r\n--> 166             output_tensors = to_list(outbound_layer.call(input_tensors[0], mask=input_masks[0]))\r\n    167             output_masks = to_list(outbound_layer.compute_mask(input_tensors[0], input_masks[0]))\r\n    168             # TODO: try to auto-infer shape\r\n\r\nminiconda/lib/python2.7/site-packages/keras/layers/convolutional.pyc in call(self, x, mask)\r\n    161         output = K.conv2d(x, self.W, strides=self.subsample,\r\n    162                           border_mode=self.border_mode,\r\n--> 163                           dim_ordering='tf')\r\n    164         output = K.squeeze(output, 2)  # remove the dummy dimension\r\n    165         if self.bias:\r\n\r\nminiconda/lib/python2.7/site-packages/keras/backend/tensorflow_backend.pyc in conv2d(x, kernel, strides, border_mode, dim_ordering, image_shape, filter_shape, filter_dilation)\r\n   2689     if filter_dilation == (1, 1):\r\n   2690         strides = (1,) + strides + (1,)\r\n-> 2691         x = tf.nn.conv2d(x, kernel, strides, padding=padding)\r\n   2692     else:\r\n   2693         assert filter_dilation[0] == filter_dilation[1]\r\n\r\nminiconda/lib/python2.7/site-packages/tensorflow/python/ops/gen_nn_ops.pyc in conv2d(input, filter, strides, padding, use_cudnn_on_gpu, data_format, name)\r\n    394                                 strides=strides, padding=padding,\r\n    395                                 use_cudnn_on_gpu=use_cudnn_on_gpu,\r\n--> 396                                 data_format=data_format, name=name)\r\n    397   return result\r\n    398 \r\n\r\nminiconda/lib/python2.7/site-packages/tensorflow/python/framework/op_def_library.pyc in apply_op(self, op_type_name, name, **keywords)\r\n    519                   \"%s type %s of argument '%s'.\" %\r\n    520                   (prefix, dtypes.as_dtype(attrs[input_arg.type_attr]).name,\r\n--> 521                    inferred_from[input_arg.type_attr]))\r\n    522 \r\n    523           types = [values.dtype]\r\n\r\nTypeError: Input 'filter' of 'Conv2D' Op has type float64 that does not match type float32 of argument 'input'.\r\n```\r\nAs I understood, float64 is simply not supported as it is considered to be not needed to have that much of precision, but I need this format because of the numbers that are calculated.\r\nIs there any solution to this problem?\r\n"}