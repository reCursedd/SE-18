{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/170297344", "html_url": "https://github.com/tensorflow/tensorflow/pull/664#issuecomment-170297344", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/664", "id": 170297344, "node_id": "MDEyOklzc3VlQ29tbWVudDE3MDI5NzM0NA==", "user": {"login": "NathanHowell", "id": 170829, "node_id": "MDQ6VXNlcjE3MDgyOQ==", "avatar_url": "https://avatars1.githubusercontent.com/u/170829?v=4", "gravatar_id": "", "url": "https://api.github.com/users/NathanHowell", "html_url": "https://github.com/NathanHowell", "followers_url": "https://api.github.com/users/NathanHowell/followers", "following_url": "https://api.github.com/users/NathanHowell/following{/other_user}", "gists_url": "https://api.github.com/users/NathanHowell/gists{/gist_id}", "starred_url": "https://api.github.com/users/NathanHowell/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/NathanHowell/subscriptions", "organizations_url": "https://api.github.com/users/NathanHowell/orgs", "repos_url": "https://api.github.com/users/NathanHowell/repos", "events_url": "https://api.github.com/users/NathanHowell/events{/privacy}", "received_events_url": "https://api.github.com/users/NathanHowell/received_events", "type": "User", "site_admin": false}, "created_at": "2016-01-10T00:50:05Z", "updated_at": "2016-01-10T00:50:05Z", "author_association": "CONTRIBUTOR", "body_html": "<p>I eventually did get this working but the version of Eigen referenced in here is very broken. Eigen HEAD (fd9611fa2d9c) does work aside from a nvcc build break in TensorIntDiv.h, <code>DividerHelper&lt;64, T&gt;::computeMultiplier</code> is missing a cast... but it does at least seem to work.</p>\n<p>Previous failure looked like this:</p>\n<blockquote>\n<p>libc++abi.dylib: terminating with uncaught exception of type std::__1::system_error: mutex lock failed: Invalid argument</p>\n</blockquote>\n<p>After a bit of hunting around it turns out that the mutex instances had already been destructed after someone called <code>exit(1)</code> <g-emoji class=\"g-emoji\" alias=\"hushed\" fallback-src=\"https://assets-cdn.github.com/images/icons/emoji/unicode/1f62f.png\">\ud83d\ude2f</g-emoji></p>\n<pre><code>(lldb) bt\n* thread #2: tid = 0x4649e, 0x00007fff98e3f738 libsystem_c.dylib`exit, stop reason = breakpoint 1.1\n  * frame #0: 0x00007fff98e3f738 libsystem_c.dylib`exit\n    frame #1: 0x00000001066e9f0e _pywrap_tensorflow.so`void Eigen::internal::EigenMetaKernel_Vectorizable&lt;Eigen::TensorEvaluator&lt;Eigen::TensorAssignOp&lt;Eigen::TensorMap&lt;Eigen::Tensor&lt;float, 1, 1, int&gt;, 16&gt;, Eigen::TensorCwiseUnaryOp&lt;Eigen::internal::scalar_right&lt;float, float, Eigen::internal::scalar_difference_op&lt;float&gt;, true&gt;, Eigen::TensorMap&lt;Eigen::Tensor&lt;float const, 1, 1, int&gt;, 16&gt; const&gt; const&gt; const, Eigen::GpuDevice&gt;, int&gt;(Eigen::TensorEvaluator&lt;Eigen::TensorAssignOp&lt;Eigen::TensorMap&lt;Eigen::Tensor&lt;float, 1, 1, int&gt;, 16&gt;, Eigen::TensorCwiseUnaryOp&lt;Eigen::internal::scalar_right&lt;float, float, Eigen::internal::scalar_difference_op&lt;float&gt;, true&gt;, Eigen::TensorMap&lt;Eigen::Tensor&lt;float const, 1, 1, int&gt;, 16&gt; const&gt; const&gt; const, Eigen::GpuDevice&gt;, int) + 14\n    frame #2: 0x00000001066e6ec1 _pywrap_tensorflow.so`tensorflow::functor::BinaryFunctor&lt;Eigen::GpuDevice, tensorflow::functor::sub&lt;float&gt;, 1&gt;::Right(Eigen::GpuDevice const&amp;, Eigen::TensorMap&lt;Eigen::Tensor&lt;float, 1, 1, long&gt;, 16&gt;, Eigen::TensorMap&lt;Eigen::Tensor&lt;float const, 1, 1, long&gt;, 16&gt;, Eigen::TensorMap&lt;Eigen::TensorFixedSize&lt;float const, Eigen::Sizes&lt;&gt;, 1, long&gt;, 16&gt;) + 257\n</code></pre>\n<p>And it turns out that all the <code>EigenMetaKernel_Vectorizable</code> specializations don't work as intended:</p>\n<pre><code>(lldb) disassemble\n_pywrap_tensorflow.so`void Eigen::internal::EigenMetaKernel_Vectorizable&lt;Eigen::TensorEvaluator&lt;Eigen::TensorAssignOp&lt;Eigen::TensorMap&lt;Eigen::Tensor&lt;float, 1, 1, int&gt;, 16&gt;, Eigen::TensorCwiseUnaryOp&lt;Eigen::internal::scalar_right&lt;float, float, Eigen::internal::scalar_difference_op&lt;float&gt;, true&gt;, Eigen::TensorMap&lt;Eigen::Tensor&lt;float const, 1, 1, int&gt;, 16&gt; const&gt; const&gt; const, Eigen::GpuDevice&gt;, int&gt;:\n    0x1066e9f00 &lt;+0&gt;:  pushq  %rbp\n    0x1066e9f01 &lt;+1&gt;:  movq   %rsp, %rbp\n    0x1066e9f04 &lt;+4&gt;:  movl   $0x1, %edi\n    0x1066e9f09 &lt;+9&gt;:  callq  0x1069fe13e               ; symbol stub for: exit\n    0x1066e9f0e &lt;+14&gt;: nop\n</code></pre>", "body_text": "I eventually did get this working but the version of Eigen referenced in here is very broken. Eigen HEAD (fd9611fa2d9c) does work aside from a nvcc build break in TensorIntDiv.h, DividerHelper<64, T>::computeMultiplier is missing a cast... but it does at least seem to work.\nPrevious failure looked like this:\n\nlibc++abi.dylib: terminating with uncaught exception of type std::__1::system_error: mutex lock failed: Invalid argument\n\nAfter a bit of hunting around it turns out that the mutex instances had already been destructed after someone called exit(1) \ud83d\ude2f\n(lldb) bt\n* thread #2: tid = 0x4649e, 0x00007fff98e3f738 libsystem_c.dylib`exit, stop reason = breakpoint 1.1\n  * frame #0: 0x00007fff98e3f738 libsystem_c.dylib`exit\n    frame #1: 0x00000001066e9f0e _pywrap_tensorflow.so`void Eigen::internal::EigenMetaKernel_Vectorizable<Eigen::TensorEvaluator<Eigen::TensorAssignOp<Eigen::TensorMap<Eigen::Tensor<float, 1, 1, int>, 16>, Eigen::TensorCwiseUnaryOp<Eigen::internal::scalar_right<float, float, Eigen::internal::scalar_difference_op<float>, true>, Eigen::TensorMap<Eigen::Tensor<float const, 1, 1, int>, 16> const> const> const, Eigen::GpuDevice>, int>(Eigen::TensorEvaluator<Eigen::TensorAssignOp<Eigen::TensorMap<Eigen::Tensor<float, 1, 1, int>, 16>, Eigen::TensorCwiseUnaryOp<Eigen::internal::scalar_right<float, float, Eigen::internal::scalar_difference_op<float>, true>, Eigen::TensorMap<Eigen::Tensor<float const, 1, 1, int>, 16> const> const> const, Eigen::GpuDevice>, int) + 14\n    frame #2: 0x00000001066e6ec1 _pywrap_tensorflow.so`tensorflow::functor::BinaryFunctor<Eigen::GpuDevice, tensorflow::functor::sub<float>, 1>::Right(Eigen::GpuDevice const&, Eigen::TensorMap<Eigen::Tensor<float, 1, 1, long>, 16>, Eigen::TensorMap<Eigen::Tensor<float const, 1, 1, long>, 16>, Eigen::TensorMap<Eigen::TensorFixedSize<float const, Eigen::Sizes<>, 1, long>, 16>) + 257\n\nAnd it turns out that all the EigenMetaKernel_Vectorizable specializations don't work as intended:\n(lldb) disassemble\n_pywrap_tensorflow.so`void Eigen::internal::EigenMetaKernel_Vectorizable<Eigen::TensorEvaluator<Eigen::TensorAssignOp<Eigen::TensorMap<Eigen::Tensor<float, 1, 1, int>, 16>, Eigen::TensorCwiseUnaryOp<Eigen::internal::scalar_right<float, float, Eigen::internal::scalar_difference_op<float>, true>, Eigen::TensorMap<Eigen::Tensor<float const, 1, 1, int>, 16> const> const> const, Eigen::GpuDevice>, int>:\n    0x1066e9f00 <+0>:  pushq  %rbp\n    0x1066e9f01 <+1>:  movq   %rsp, %rbp\n    0x1066e9f04 <+4>:  movl   $0x1, %edi\n    0x1066e9f09 <+9>:  callq  0x1069fe13e               ; symbol stub for: exit\n    0x1066e9f0e <+14>: nop", "body": "I eventually did get this working but the version of Eigen referenced in here is very broken. Eigen HEAD (fd9611fa2d9c) does work aside from a nvcc build break in TensorIntDiv.h, `DividerHelper<64, T>::computeMultiplier` is missing a cast... but it does at least seem to work.\n\nPrevious failure looked like this:\n\n> libc++abi.dylib: terminating with uncaught exception of type std::__1::system_error: mutex lock failed: Invalid argument\n\nAfter a bit of hunting around it turns out that the mutex instances had already been destructed after someone called `exit(1)` :hushed: \n\n```\n(lldb) bt\n* thread #2: tid = 0x4649e, 0x00007fff98e3f738 libsystem_c.dylib`exit, stop reason = breakpoint 1.1\n  * frame #0: 0x00007fff98e3f738 libsystem_c.dylib`exit\n    frame #1: 0x00000001066e9f0e _pywrap_tensorflow.so`void Eigen::internal::EigenMetaKernel_Vectorizable<Eigen::TensorEvaluator<Eigen::TensorAssignOp<Eigen::TensorMap<Eigen::Tensor<float, 1, 1, int>, 16>, Eigen::TensorCwiseUnaryOp<Eigen::internal::scalar_right<float, float, Eigen::internal::scalar_difference_op<float>, true>, Eigen::TensorMap<Eigen::Tensor<float const, 1, 1, int>, 16> const> const> const, Eigen::GpuDevice>, int>(Eigen::TensorEvaluator<Eigen::TensorAssignOp<Eigen::TensorMap<Eigen::Tensor<float, 1, 1, int>, 16>, Eigen::TensorCwiseUnaryOp<Eigen::internal::scalar_right<float, float, Eigen::internal::scalar_difference_op<float>, true>, Eigen::TensorMap<Eigen::Tensor<float const, 1, 1, int>, 16> const> const> const, Eigen::GpuDevice>, int) + 14\n    frame #2: 0x00000001066e6ec1 _pywrap_tensorflow.so`tensorflow::functor::BinaryFunctor<Eigen::GpuDevice, tensorflow::functor::sub<float>, 1>::Right(Eigen::GpuDevice const&, Eigen::TensorMap<Eigen::Tensor<float, 1, 1, long>, 16>, Eigen::TensorMap<Eigen::Tensor<float const, 1, 1, long>, 16>, Eigen::TensorMap<Eigen::TensorFixedSize<float const, Eigen::Sizes<>, 1, long>, 16>) + 257\n```\n\nAnd it turns out that all the `EigenMetaKernel_Vectorizable` specializations don't work as intended:\n\n```\n(lldb) disassemble\n_pywrap_tensorflow.so`void Eigen::internal::EigenMetaKernel_Vectorizable<Eigen::TensorEvaluator<Eigen::TensorAssignOp<Eigen::TensorMap<Eigen::Tensor<float, 1, 1, int>, 16>, Eigen::TensorCwiseUnaryOp<Eigen::internal::scalar_right<float, float, Eigen::internal::scalar_difference_op<float>, true>, Eigen::TensorMap<Eigen::Tensor<float const, 1, 1, int>, 16> const> const> const, Eigen::GpuDevice>, int>:\n    0x1066e9f00 <+0>:  pushq  %rbp\n    0x1066e9f01 <+1>:  movq   %rsp, %rbp\n    0x1066e9f04 <+4>:  movl   $0x1, %edi\n    0x1066e9f09 <+9>:  callq  0x1069fe13e               ; symbol stub for: exit\n    0x1066e9f0e <+14>: nop\n```\n"}