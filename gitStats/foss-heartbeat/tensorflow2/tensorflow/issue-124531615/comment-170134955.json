{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/170134955", "html_url": "https://github.com/tensorflow/tensorflow/pull/664#issuecomment-170134955", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/664", "id": 170134955, "node_id": "MDEyOklzc3VlQ29tbWVudDE3MDEzNDk1NQ==", "user": {"login": "NathanHowell", "id": 170829, "node_id": "MDQ6VXNlcjE3MDgyOQ==", "avatar_url": "https://avatars1.githubusercontent.com/u/170829?v=4", "gravatar_id": "", "url": "https://api.github.com/users/NathanHowell", "html_url": "https://github.com/NathanHowell", "followers_url": "https://api.github.com/users/NathanHowell/followers", "following_url": "https://api.github.com/users/NathanHowell/following{/other_user}", "gists_url": "https://api.github.com/users/NathanHowell/gists{/gist_id}", "starred_url": "https://api.github.com/users/NathanHowell/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/NathanHowell/subscriptions", "organizations_url": "https://api.github.com/users/NathanHowell/orgs", "repos_url": "https://api.github.com/users/NathanHowell/repos", "events_url": "https://api.github.com/users/NathanHowell/events{/privacy}", "received_events_url": "https://api.github.com/users/NathanHowell/received_events", "type": "User", "site_admin": false}, "created_at": "2016-01-08T21:37:20Z", "updated_at": "2016-01-08T21:37:20Z", "author_association": "CONTRIBUTOR", "body_html": "<p>I get a segfault when the  cuda libs are not setup properly due to <code>getenv(\"LD_LIBRARY_PATH\")</code> returning null:</p>\n<pre><code>(lldb) bt\n* thread #1: tid = 0x30ae49, 0x00007fff8ed8e752 libsystem_c.dylib`strlen + 18, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x0)\n  * frame #0: 0x00007fff8ed8e752 libsystem_c.dylib`strlen + 18\n    frame #1: 0x0000000105f0d7a4 _pywrap_tensorflow.so`std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;&amp; std::__1::operator&lt;&lt;&lt;std::__1::char_traits&lt;char&gt; &gt;(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;&amp;, char const*) [inlined] std::__1::char_traits&lt;char&gt;::length(__s=0x0000000000000000) + 52 at string:651\n    frame #2: 0x0000000105f0d790 _pywrap_tensorflow.so`std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;&amp; std::__1::operator&lt;&lt;&lt;std::__1::char_traits&lt;char&gt; &gt;(__os=0x00007fff5fbfbb10, __str=0x0000000000000000) + 32 at ostream:882\n    frame #3: 0x000000010895c96a _pywrap_tensorflow.so`perftools::gputools::internal::DsoLoader::GetDsoHandle(tensorflow::StringPiece, void**, perftools::gputools::internal::DsoLoader::LoadKind) [inlined] std::__1::enable_if&lt;(__os=0x00007fff5fbfbb10, __x=0x00007fff5fbfbb08)) &amp;&amp; (is_base_of&lt;std::__1::ios_base, tensorflow::internal::LogMessage&gt;::value), tensorflow::internal::LogMessage&amp;&amp;&gt;::type std::__1::operator&lt;&lt;&lt;tensorflow::internal::LogMessage, char*&gt;(tensorflow::internal::LogMessage&amp;&amp;, char* const&amp;) + 19 at ostream:1057\n&lt;trimmed&gt;\n(lldb) frame select 4\nframe #4: 0x000000010895c957 _pywrap_tensorflow.so`perftools::gputools::internal::DsoLoader::GetDsoHandle(path=(data_ = \"libcuda.dylib\", size_ = 13), dso_handle=0x00007fff5fbfc138, load_kind=kLocal) + 887 at dso_loader.cc:99\n   96     string path_string = path.ToString();\n   97     *dso_handle = dlopen(path_string.c_str(), dynload_flags);\n   98     if (*dso_handle == nullptr) {\n-&gt; 99       LOG(INFO) &lt;&lt; \"Couldn't open CUDA library \" &lt;&lt; path\n   100                &lt;&lt; \". LD_LIBRARY_PATH: \" &lt;&lt; getenv(\"LD_LIBRARY_PATH\");\n   101      // TODO(b/22689637): Eliminate unnecessary ToString once StrCat has been\n   102      // moved to the open-sourceable version.\n</code></pre>", "body_text": "I get a segfault when the  cuda libs are not setup properly due to getenv(\"LD_LIBRARY_PATH\") returning null:\n(lldb) bt\n* thread #1: tid = 0x30ae49, 0x00007fff8ed8e752 libsystem_c.dylib`strlen + 18, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x0)\n  * frame #0: 0x00007fff8ed8e752 libsystem_c.dylib`strlen + 18\n    frame #1: 0x0000000105f0d7a4 _pywrap_tensorflow.so`std::__1::basic_ostream<char, std::__1::char_traits<char> >& std::__1::operator<<<std::__1::char_traits<char> >(std::__1::basic_ostream<char, std::__1::char_traits<char> >&, char const*) [inlined] std::__1::char_traits<char>::length(__s=0x0000000000000000) + 52 at string:651\n    frame #2: 0x0000000105f0d790 _pywrap_tensorflow.so`std::__1::basic_ostream<char, std::__1::char_traits<char> >& std::__1::operator<<<std::__1::char_traits<char> >(__os=0x00007fff5fbfbb10, __str=0x0000000000000000) + 32 at ostream:882\n    frame #3: 0x000000010895c96a _pywrap_tensorflow.so`perftools::gputools::internal::DsoLoader::GetDsoHandle(tensorflow::StringPiece, void**, perftools::gputools::internal::DsoLoader::LoadKind) [inlined] std::__1::enable_if<(__os=0x00007fff5fbfbb10, __x=0x00007fff5fbfbb08)) && (is_base_of<std::__1::ios_base, tensorflow::internal::LogMessage>::value), tensorflow::internal::LogMessage&&>::type std::__1::operator<<<tensorflow::internal::LogMessage, char*>(tensorflow::internal::LogMessage&&, char* const&) + 19 at ostream:1057\n<trimmed>\n(lldb) frame select 4\nframe #4: 0x000000010895c957 _pywrap_tensorflow.so`perftools::gputools::internal::DsoLoader::GetDsoHandle(path=(data_ = \"libcuda.dylib\", size_ = 13), dso_handle=0x00007fff5fbfc138, load_kind=kLocal) + 887 at dso_loader.cc:99\n   96     string path_string = path.ToString();\n   97     *dso_handle = dlopen(path_string.c_str(), dynload_flags);\n   98     if (*dso_handle == nullptr) {\n-> 99       LOG(INFO) << \"Couldn't open CUDA library \" << path\n   100                << \". LD_LIBRARY_PATH: \" << getenv(\"LD_LIBRARY_PATH\");\n   101      // TODO(b/22689637): Eliminate unnecessary ToString once StrCat has been\n   102      // moved to the open-sourceable version.", "body": "I get a segfault when the  cuda libs are not setup properly due to `getenv(\"LD_LIBRARY_PATH\")` returning null:\n\n```\n(lldb) bt\n* thread #1: tid = 0x30ae49, 0x00007fff8ed8e752 libsystem_c.dylib`strlen + 18, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x0)\n  * frame #0: 0x00007fff8ed8e752 libsystem_c.dylib`strlen + 18\n    frame #1: 0x0000000105f0d7a4 _pywrap_tensorflow.so`std::__1::basic_ostream<char, std::__1::char_traits<char> >& std::__1::operator<<<std::__1::char_traits<char> >(std::__1::basic_ostream<char, std::__1::char_traits<char> >&, char const*) [inlined] std::__1::char_traits<char>::length(__s=0x0000000000000000) + 52 at string:651\n    frame #2: 0x0000000105f0d790 _pywrap_tensorflow.so`std::__1::basic_ostream<char, std::__1::char_traits<char> >& std::__1::operator<<<std::__1::char_traits<char> >(__os=0x00007fff5fbfbb10, __str=0x0000000000000000) + 32 at ostream:882\n    frame #3: 0x000000010895c96a _pywrap_tensorflow.so`perftools::gputools::internal::DsoLoader::GetDsoHandle(tensorflow::StringPiece, void**, perftools::gputools::internal::DsoLoader::LoadKind) [inlined] std::__1::enable_if<(__os=0x00007fff5fbfbb10, __x=0x00007fff5fbfbb08)) && (is_base_of<std::__1::ios_base, tensorflow::internal::LogMessage>::value), tensorflow::internal::LogMessage&&>::type std::__1::operator<<<tensorflow::internal::LogMessage, char*>(tensorflow::internal::LogMessage&&, char* const&) + 19 at ostream:1057\n<trimmed>\n(lldb) frame select 4\nframe #4: 0x000000010895c957 _pywrap_tensorflow.so`perftools::gputools::internal::DsoLoader::GetDsoHandle(path=(data_ = \"libcuda.dylib\", size_ = 13), dso_handle=0x00007fff5fbfc138, load_kind=kLocal) + 887 at dso_loader.cc:99\n   96     string path_string = path.ToString();\n   97     *dso_handle = dlopen(path_string.c_str(), dynload_flags);\n   98     if (*dso_handle == nullptr) {\n-> 99       LOG(INFO) << \"Couldn't open CUDA library \" << path\n   100                << \". LD_LIBRARY_PATH: \" << getenv(\"LD_LIBRARY_PATH\");\n   101      // TODO(b/22689637): Eliminate unnecessary ToString once StrCat has been\n   102      // moved to the open-sourceable version.\n```\n"}