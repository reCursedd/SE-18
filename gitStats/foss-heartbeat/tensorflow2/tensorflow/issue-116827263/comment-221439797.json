{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/221439797", "html_url": "https://github.com/tensorflow/tensorflow/issues/206#issuecomment-221439797", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/206", "id": 221439797, "node_id": "MDEyOklzc3VlQ29tbWVudDIyMTQzOTc5Nw==", "user": {"login": "shoyer", "id": 1217238, "node_id": "MDQ6VXNlcjEyMTcyMzg=", "avatar_url": "https://avatars2.githubusercontent.com/u/1217238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/shoyer", "html_url": "https://github.com/shoyer", "followers_url": "https://api.github.com/users/shoyer/followers", "following_url": "https://api.github.com/users/shoyer/following{/other_user}", "gists_url": "https://api.github.com/users/shoyer/gists{/gist_id}", "starred_url": "https://api.github.com/users/shoyer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/shoyer/subscriptions", "organizations_url": "https://api.github.com/users/shoyer/orgs", "repos_url": "https://api.github.com/users/shoyer/repos", "events_url": "https://api.github.com/users/shoyer/events{/privacy}", "received_events_url": "https://api.github.com/users/shoyer/received_events", "type": "User", "site_admin": false}, "created_at": "2016-05-25T00:18:30Z", "updated_at": "2016-05-25T00:18:30Z", "author_association": "MEMBER", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=70511\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/girving\">@girving</a> I agree that NumPy's vectorized indexing is great. The problem is that NumPy's implementation includes a hacks to make it \"more intuitive\" when slices and arrays are mixed, which work a lot of the time but then result in some very bizarre edge cases.</p>\n<p>The <a href=\"https://mail.scipy.org/pipermail/numpy-discussion/2015-April/072607.html\" rel=\"nofollow\">canonical example</a> is indexing operations like <code>x[0, :, [0, 1, 2, 3]]</code>, which converts an array of shape <code>(2, 3, 4)</code> to <code>(4, 3)</code> rather than the \"obvious\" <code>(3, 4)</code>. This is point (2) under the motivation in proposal PR (<a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"103508907\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/numpy/numpy/issues/6256\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/numpy/numpy/pull/6256/hovercard\" href=\"https://github.com/numpy/numpy/pull/6256\">numpy/numpy#6256</a>).</p>\n<p>One way to avoid this issue entirely is to prohibit mixed slice/array indexing. But if you do allow mixed slice/array indexing (which is very tempting to handle cases like <code>x[:, [0, 1, 2]]</code>), then this edge case will inevitably arise. Hence the appeal of the alternative indexing operation <code>vindex</code> for vectorized indexing, which lets indexing like <code>x[:, [0, 1, 2]]</code> and <code>x[[0, 1, 2], :]</code> do the obvious \"outer indexing\" thing without any kludges.</p>\n<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=23068\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/yaroslavvb\">@yaroslavvb</a> There are a few niggling details to figure out in the proposal, but I think it's extremely like that it (and the implementation <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"94894340\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/numpy/numpy/issues/6075\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/numpy/numpy/pull/6075/hovercard\" href=\"https://github.com/numpy/numpy/pull/6075\">numpy/numpy#6075</a>) will be merged at some point. There was a long discussion last year about just how unintuitive numpy's current indexing behavior is, and I think all the core developers agreed that this is the obvious path forward.</p>", "body_text": "@girving I agree that NumPy's vectorized indexing is great. The problem is that NumPy's implementation includes a hacks to make it \"more intuitive\" when slices and arrays are mixed, which work a lot of the time but then result in some very bizarre edge cases.\nThe canonical example is indexing operations like x[0, :, [0, 1, 2, 3]], which converts an array of shape (2, 3, 4) to (4, 3) rather than the \"obvious\" (3, 4). This is point (2) under the motivation in proposal PR (numpy/numpy#6256).\nOne way to avoid this issue entirely is to prohibit mixed slice/array indexing. But if you do allow mixed slice/array indexing (which is very tempting to handle cases like x[:, [0, 1, 2]]), then this edge case will inevitably arise. Hence the appeal of the alternative indexing operation vindex for vectorized indexing, which lets indexing like x[:, [0, 1, 2]] and x[[0, 1, 2], :] do the obvious \"outer indexing\" thing without any kludges.\n@yaroslavvb There are a few niggling details to figure out in the proposal, but I think it's extremely like that it (and the implementation numpy/numpy#6075) will be merged at some point. There was a long discussion last year about just how unintuitive numpy's current indexing behavior is, and I think all the core developers agreed that this is the obvious path forward.", "body": "@girving I agree that NumPy's vectorized indexing is great. The problem is that NumPy's implementation includes a hacks to make it \"more intuitive\" when slices and arrays are mixed, which work a lot of the time but then result in some very bizarre edge cases.\n\nThe [canonical example](https://mail.scipy.org/pipermail/numpy-discussion/2015-April/072607.html) is indexing operations like `x[0, :, [0, 1, 2, 3]]`, which converts an array of shape `(2, 3, 4)` to `(4, 3)` rather than the \"obvious\" `(3, 4)`. This is point (2) under the motivation in proposal PR (https://github.com/numpy/numpy/pull/6256).\n\nOne way to avoid this issue entirely is to prohibit mixed slice/array indexing. But if you do allow mixed slice/array indexing (which is very tempting to handle cases like `x[:, [0, 1, 2]]`), then this edge case will inevitably arise. Hence the appeal of the alternative indexing operation `vindex` for vectorized indexing, which lets indexing like `x[:, [0, 1, 2]]` and `x[[0, 1, 2], :]` do the obvious \"outer indexing\" thing without any kludges.\n\n@yaroslavvb There are a few niggling details to figure out in the proposal, but I think it's extremely like that it (and the implementation https://github.com/numpy/numpy/pull/6075) will be merged at some point. There was a long discussion last year about just how unintuitive numpy's current indexing behavior is, and I think all the core developers agreed that this is the obvious path forward.\n"}