{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/269705715", "html_url": "https://github.com/tensorflow/tensorflow/pull/6528#issuecomment-269705715", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/6528", "id": 269705715, "node_id": "MDEyOklzc3VlQ29tbWVudDI2OTcwNTcxNQ==", "user": {"login": "EronWright", "id": 1775518, "node_id": "MDQ6VXNlcjE3NzU1MTg=", "avatar_url": "https://avatars0.githubusercontent.com/u/1775518?v=4", "gravatar_id": "", "url": "https://api.github.com/users/EronWright", "html_url": "https://github.com/EronWright", "followers_url": "https://api.github.com/users/EronWright/followers", "following_url": "https://api.github.com/users/EronWright/following{/other_user}", "gists_url": "https://api.github.com/users/EronWright/gists{/gist_id}", "starred_url": "https://api.github.com/users/EronWright/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/EronWright/subscriptions", "organizations_url": "https://api.github.com/users/EronWright/orgs", "repos_url": "https://api.github.com/users/EronWright/repos", "events_url": "https://api.github.com/users/EronWright/events{/privacy}", "received_events_url": "https://api.github.com/users/EronWright/received_events", "type": "User", "site_admin": false}, "created_at": "2016-12-29T22:48:19Z", "updated_at": "2016-12-29T22:48:19Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Thanks for the feedback!   I'd still like to convince you that reference counting is superior for this library, especially given its power-over-convenience nature (and hopeful foundation for Scala/Kotlin/Closure libraries, which may not support try-with-resources).   Frankly it is more convenient too.</p>\n<p>I've been writing integration code based on this patch, that I'm almost ready to share with folks.   I find it more convenient; input tensors (passed to <code>feed</code> or <code>setAttr</code>) needn't be dereferenced.  Output tensors must have <code>unref</code> or <code>close</code> called in any case.</p>\n<p>This style of reference counting (callee must unref) is familiar to Netty developers.  Any scenario involving chaining, asynchrony, or caching will benefit from this; it simply took Netty a few versions to find this solution.</p>\n<p>I agree with your concern about the runner/builder leaks.  <code>finalize</code> was a catch-all solution but the runner should probably be <code>AutoCloseable</code>.</p>", "body_text": "Thanks for the feedback!   I'd still like to convince you that reference counting is superior for this library, especially given its power-over-convenience nature (and hopeful foundation for Scala/Kotlin/Closure libraries, which may not support try-with-resources).   Frankly it is more convenient too.\nI've been writing integration code based on this patch, that I'm almost ready to share with folks.   I find it more convenient; input tensors (passed to feed or setAttr) needn't be dereferenced.  Output tensors must have unref or close called in any case.\nThis style of reference counting (callee must unref) is familiar to Netty developers.  Any scenario involving chaining, asynchrony, or caching will benefit from this; it simply took Netty a few versions to find this solution.\nI agree with your concern about the runner/builder leaks.  finalize was a catch-all solution but the runner should probably be AutoCloseable.", "body": "Thanks for the feedback!   I'd still like to convince you that reference counting is superior for this library, especially given its power-over-convenience nature (and hopeful foundation for Scala/Kotlin/Closure libraries, which may not support try-with-resources).   Frankly it is more convenient too.\r\n\r\nI've been writing integration code based on this patch, that I'm almost ready to share with folks.   I find it more convenient; input tensors (passed to `feed` or `setAttr`) needn't be dereferenced.  Output tensors must have `unref` or `close` called in any case. \r\n\r\nThis style of reference counting (callee must unref) is familiar to Netty developers.  Any scenario involving chaining, asynchrony, or caching will benefit from this; it simply took Netty a few versions to find this solution.\r\n\r\nI agree with your concern about the runner/builder leaks.  `finalize` was a catch-all solution but the runner should probably be `AutoCloseable`."}