{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/269594209", "html_url": "https://github.com/tensorflow/tensorflow/pull/6528#issuecomment-269594209", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/6528", "id": 269594209, "node_id": "MDEyOklzc3VlQ29tbWVudDI2OTU5NDIwOQ==", "user": {"login": "asimshankar", "id": 16018, "node_id": "MDQ6VXNlcjE2MDE4", "avatar_url": "https://avatars2.githubusercontent.com/u/16018?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asimshankar", "html_url": "https://github.com/asimshankar", "followers_url": "https://api.github.com/users/asimshankar/followers", "following_url": "https://api.github.com/users/asimshankar/following{/other_user}", "gists_url": "https://api.github.com/users/asimshankar/gists{/gist_id}", "starred_url": "https://api.github.com/users/asimshankar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asimshankar/subscriptions", "organizations_url": "https://api.github.com/users/asimshankar/orgs", "repos_url": "https://api.github.com/users/asimshankar/repos", "events_url": "https://api.github.com/users/asimshankar/events{/privacy}", "received_events_url": "https://api.github.com/users/asimshankar/received_events", "type": "User", "site_admin": false}, "created_at": "2016-12-29T07:53:16Z", "updated_at": "2016-12-29T07:53:16Z", "author_association": "MEMBER", "body_html": "<p>Thanks for the suggestion and pull request <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=1775518\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/EronWright\">@EronWright</a> .</p>\n<p>However, I'm a bit skeptical on this one. I did consider this but felt that the language support for <code>AutoCloseable</code> makes it a more appropriate choice at this lower level. Some reservations:</p>\n<ul>\n<li>I fear that it will be much easier for developers to forget to <code>unref()</code> than forget to close an <code>AutoCloseable</code>, mostly because of language support (and implied un-idiomatic nature of reference counting in Java).</li>\n<li>There is asymmetry between creation and cleanup that is very subtle. For example, if <code>Session.Runner.run()</code> isn't called after <code>Session.Runner.feed()</code> (perhaps because of some exception thrown in intervening code), then the <code>Tensor</code>s are not cleaned up. I see that the PR also uses finalizers, but relying on that is generally unadvisable given that there are no guarantees on garbage collection and that <code>Tensor</code> objects can have large memory footprints</li>\n</ul>\n<p>A wrapper for reference counting and/or a list of <code>AutoCloseable</code>s seems easy enough, but perhaps I'm not fully appreciating the complexity of that. I had thought of something like:</p>\n<div class=\"highlight highlight-source-java\"><pre><span class=\"pl-k\">public</span> <span class=\"pl-k\">class</span> <span class=\"pl-en\">AutoCloseableList</span> <span class=\"pl-k\">implements</span> <span class=\"pl-e\">List&lt;<span class=\"pl-smi\">AutoCloseable</span>&gt;</span>, <span class=\"pl-e\">AutoCloseable</span> {\n   <span class=\"pl-c\"><span class=\"pl-c\">//</span> ...</span>\n   <span class=\"pl-k\">public</span> <span class=\"pl-k\">void</span> <span class=\"pl-en\">close</span>() {\n      <span class=\"pl-k\">for</span> (<span class=\"pl-smi\">AutoCloseable</span> c <span class=\"pl-k\">:</span> list) {\n         c<span class=\"pl-k\">.</span>close();\n      }\n   }\n}</pre></div>\n<p>to make it easier to work with <code>Session.Runner</code>, or with reference counting something like:</p>\n<div class=\"highlight highlight-source-java\"><pre><span class=\"pl-k\">public</span> <span class=\"pl-k\">class</span> <span class=\"pl-en\">RefCounted</span>&lt;E <span class=\"pl-k\">implements</span> <span class=\"pl-e\">AutoCloseable</span>&gt; {\n   <span class=\"pl-k\">public</span> <span class=\"pl-smi\">E</span> <span class=\"pl-en\">ref</span>() { <span class=\"pl-c1\">...</span> }\n   <span class=\"pl-k\">public</span> <span class=\"pl-k\">boolean</span> <span class=\"pl-en\">unref</span>() {\n      <span class=\"pl-k\">if</span> (refcnt<span class=\"pl-k\">--</span> <span class=\"pl-k\">==</span> <span class=\"pl-c1\">0</span>) {\n        object<span class=\"pl-k\">.</span>close();\n        <span class=\"pl-k\">return</span> <span class=\"pl-c1\">true</span>;\n     }\n    <span class=\"pl-k\">return</span> <span class=\"pl-c1\">false</span>;\n  }\n}</pre></div>\n<p>Which I was hoping would be trivial and easy to incorporate adapters into Netty-like settings (and I'd be happy to add those to <code>org.tensorflow.util</code>)</p>\n<p>Could you perhaps elaborate on why you think such wrappers would be burdensome? Is there some example code you can share that can maybe guide us in finding the right balance? For example, I feel <code>LabelImage.java</code> is easier to read without the reference counting. But I am wide open to looking at more use cases.</p>\n<p>CC <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=170179\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/jhseu\">@jhseu</a></p>", "body_text": "Thanks for the suggestion and pull request @EronWright .\nHowever, I'm a bit skeptical on this one. I did consider this but felt that the language support for AutoCloseable makes it a more appropriate choice at this lower level. Some reservations:\n\nI fear that it will be much easier for developers to forget to unref() than forget to close an AutoCloseable, mostly because of language support (and implied un-idiomatic nature of reference counting in Java).\nThere is asymmetry between creation and cleanup that is very subtle. For example, if Session.Runner.run() isn't called after Session.Runner.feed() (perhaps because of some exception thrown in intervening code), then the Tensors are not cleaned up. I see that the PR also uses finalizers, but relying on that is generally unadvisable given that there are no guarantees on garbage collection and that Tensor objects can have large memory footprints\n\nA wrapper for reference counting and/or a list of AutoCloseables seems easy enough, but perhaps I'm not fully appreciating the complexity of that. I had thought of something like:\npublic class AutoCloseableList implements List<AutoCloseable>, AutoCloseable {\n   // ...\n   public void close() {\n      for (AutoCloseable c : list) {\n         c.close();\n      }\n   }\n}\nto make it easier to work with Session.Runner, or with reference counting something like:\npublic class RefCounted<E implements AutoCloseable> {\n   public E ref() { ... }\n   public boolean unref() {\n      if (refcnt-- == 0) {\n        object.close();\n        return true;\n     }\n    return false;\n  }\n}\nWhich I was hoping would be trivial and easy to incorporate adapters into Netty-like settings (and I'd be happy to add those to org.tensorflow.util)\nCould you perhaps elaborate on why you think such wrappers would be burdensome? Is there some example code you can share that can maybe guide us in finding the right balance? For example, I feel LabelImage.java is easier to read without the reference counting. But I am wide open to looking at more use cases.\nCC @jhseu", "body": "Thanks for the suggestion and pull request @EronWright .\r\n\r\nHowever, I'm a bit skeptical on this one. I did consider this but felt that the language support for `AutoCloseable` makes it a more appropriate choice at this lower level. Some reservations:\r\n\r\n- I fear that it will be much easier for developers to forget to `unref()` than forget to close an `AutoCloseable`, mostly because of language support (and implied un-idiomatic nature of reference counting in Java).\r\n- There is asymmetry between creation and cleanup that is very subtle. For example, if `Session.Runner.run()` isn't called after `Session.Runner.feed()` (perhaps because of some exception thrown in intervening code), then the `Tensor`s are not cleaned up. I see that the PR also uses finalizers, but relying on that is generally unadvisable given that there are no guarantees on garbage collection and that `Tensor` objects can have large memory footprints\r\n\r\nA wrapper for reference counting and/or a list of `AutoCloseable`s seems easy enough, but perhaps I'm not fully appreciating the complexity of that. I had thought of something like:\r\n\r\n```java\r\npublic class AutoCloseableList implements List<AutoCloseable>, AutoCloseable {\r\n   // ...\r\n   public void close() {\r\n      for (AutoCloseable c : list) {\r\n         c.close();\r\n      }\r\n   }\r\n}\r\n```\r\n\r\nto make it easier to work with `Session.Runner`, or with reference counting something like:\r\n\r\n```java\r\npublic class RefCounted<E implements AutoCloseable> {\r\n   public E ref() { ... }\r\n   public boolean unref() {\r\n      if (refcnt-- == 0) {\r\n        object.close();\r\n        return true;\r\n     }\r\n    return false;\r\n  }\r\n}\r\n```\r\n\r\nWhich I was hoping would be trivial and easy to incorporate adapters into Netty-like settings (and I'd be happy to add those to `org.tensorflow.util`)\r\n\r\nCould you perhaps elaborate on why you think such wrappers would be burdensome? Is there some example code you can share that can maybe guide us in finding the right balance? For example, I feel `LabelImage.java` is easier to read without the reference counting. But I am wide open to looking at more use cases.\r\n\r\nCC @jhseu "}