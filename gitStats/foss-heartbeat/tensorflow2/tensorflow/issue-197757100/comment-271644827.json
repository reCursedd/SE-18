{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/271644827", "html_url": "https://github.com/tensorflow/tensorflow/pull/6528#issuecomment-271644827", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/6528", "id": 271644827, "node_id": "MDEyOklzc3VlQ29tbWVudDI3MTY0NDgyNw==", "user": {"login": "EronWright", "id": 1775518, "node_id": "MDQ6VXNlcjE3NzU1MTg=", "avatar_url": "https://avatars0.githubusercontent.com/u/1775518?v=4", "gravatar_id": "", "url": "https://api.github.com/users/EronWright", "html_url": "https://github.com/EronWright", "followers_url": "https://api.github.com/users/EronWright/followers", "following_url": "https://api.github.com/users/EronWright/following{/other_user}", "gists_url": "https://api.github.com/users/EronWright/gists{/gist_id}", "starred_url": "https://api.github.com/users/EronWright/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/EronWright/subscriptions", "organizations_url": "https://api.github.com/users/EronWright/orgs", "repos_url": "https://api.github.com/users/EronWright/repos", "events_url": "https://api.github.com/users/EronWright/events{/privacy}", "received_events_url": "https://api.github.com/users/EronWright/received_events", "type": "User", "site_admin": false}, "created_at": "2017-01-10T17:44:27Z", "updated_at": "2017-01-10T17:44:27Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Thanks for indulging this conversation, these are reasonable objections to be sure.  Go ahead and close the PR if still not convinced after reading the below.</p>\n<p>Maybe it is a bit counter-intuitive but reference counting as defined in this PR actually leads to less user code in the common case and fewer leaks.  This is because the callee (<code>OperationBuilder</code>, <code>Session.Runner</code>) dereferences the object.</p>\n<p>Maybe I can strengthen the case by showing how reference counting could simplify the handling of the output tensors.   Imagine that <code>Session.Runner::run()</code> returned an object of type <code>RunResult</code>.</p>\n<div class=\"highlight highlight-source-java\"><pre><span class=\"pl-k\">class</span> <span class=\"pl-en\">RunResult</span> <span class=\"pl-k\">extends</span> <span class=\"pl-e\">AbstractReferenceCounted</span> {\n  <span class=\"pl-k\">private</span> <span class=\"pl-smi\">RunMetadata</span> metadata;\n  <span class=\"pl-k\">private</span> <span class=\"pl-k\">Tensor</span>[] outputTensors;\n  \n  <span class=\"pl-k\">public</span> <span class=\"pl-k\">List&lt;<span class=\"pl-smi\">Tensor</span>&gt;</span> <span class=\"pl-en\">outputTensors</span>() { <span class=\"pl-c1\">...</span> }\n\n  <span class=\"pl-k\">@Override</span>\n  <span class=\"pl-k\">protected</span> <span class=\"pl-k\">void</span> <span class=\"pl-en\">deallocate</span>() {\n    <span class=\"pl-k\">for</span>(<span class=\"pl-smi\">Tensor</span> t<span class=\"pl-k\">:</span> outputTensors) { t<span class=\"pl-k\">.</span>unref(); }\n  }\n}</pre></div>\n<p>Typical user code need only <code>unref</code> the result to cleanup everything.  Any tensors that need be retained may simply be <code>ref</code>ed.   In the status-quo, the protocol would be more complex IMO.</p>", "body_text": "Thanks for indulging this conversation, these are reasonable objections to be sure.  Go ahead and close the PR if still not convinced after reading the below.\nMaybe it is a bit counter-intuitive but reference counting as defined in this PR actually leads to less user code in the common case and fewer leaks.  This is because the callee (OperationBuilder, Session.Runner) dereferences the object.\nMaybe I can strengthen the case by showing how reference counting could simplify the handling of the output tensors.   Imagine that Session.Runner::run() returned an object of type RunResult.\nclass RunResult extends AbstractReferenceCounted {\n  private RunMetadata metadata;\n  private Tensor[] outputTensors;\n  \n  public List<Tensor> outputTensors() { ... }\n\n  @Override\n  protected void deallocate() {\n    for(Tensor t: outputTensors) { t.unref(); }\n  }\n}\nTypical user code need only unref the result to cleanup everything.  Any tensors that need be retained may simply be refed.   In the status-quo, the protocol would be more complex IMO.", "body": "Thanks for indulging this conversation, these are reasonable objections to be sure.  Go ahead and close the PR if still not convinced after reading the below.\r\n\r\nMaybe it is a bit counter-intuitive but reference counting as defined in this PR actually leads to less user code in the common case and fewer leaks.  This is because the callee (`OperationBuilder`, `Session.Runner`) dereferences the object.\r\n\r\nMaybe I can strengthen the case by showing how reference counting could simplify the handling of the output tensors.   Imagine that `Session.Runner::run()` returned an object of type `RunResult`.   \r\n\r\n```java\r\nclass RunResult extends AbstractReferenceCounted {\r\n  private RunMetadata metadata;\r\n  private Tensor[] outputTensors;\r\n  \r\n  public List<Tensor> outputTensors() { ... }\r\n\r\n  @Override\r\n  protected void deallocate() {\r\n    for(Tensor t: outputTensors) { t.unref(); }\r\n  }\r\n}\r\n```\r\n\r\nTypical user code need only `unref` the result to cleanup everything.  Any tensors that need be retained may simply be `ref`ed.   In the status-quo, the protocol would be more complex IMO."}