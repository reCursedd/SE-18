{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11663", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11663/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11663/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11663/events", "html_url": "https://github.com/tensorflow/tensorflow/pull/11663", "id": 244598635, "node_id": "MDExOlB1bGxSZXF1ZXN0MTMxNzIyMTc0", "number": 11663, "title": "Add name of C++ source file to generated Python files for ops.", "user": {"login": "frreiss", "id": 12436991, "node_id": "MDQ6VXNlcjEyNDM2OTkx", "avatar_url": "https://avatars1.githubusercontent.com/u/12436991?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frreiss", "html_url": "https://github.com/frreiss", "followers_url": "https://api.github.com/users/frreiss/followers", "following_url": "https://api.github.com/users/frreiss/following{/other_user}", "gists_url": "https://api.github.com/users/frreiss/gists{/gist_id}", "starred_url": "https://api.github.com/users/frreiss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frreiss/subscriptions", "organizations_url": "https://api.github.com/users/frreiss/orgs", "repos_url": "https://api.github.com/users/frreiss/repos", "events_url": "https://api.github.com/users/frreiss/events{/privacy}", "received_events_url": "https://api.github.com/users/frreiss/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 419840263, "node_id": "MDU6TGFiZWw0MTk4NDAyNjM=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/awaiting%20testing%20(then%20merge)", "name": "awaiting testing (then merge)", "color": "c2e0c6", "default": false}, {"id": 300136587, "node_id": "MDU6TGFiZWwzMDAxMzY1ODc=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/cla:%20yes", "name": "cla: yes", "color": "009800", "default": false}], "state": "closed", "locked": false, "assignee": {"login": "josh11b", "id": 15258583, "node_id": "MDQ6VXNlcjE1MjU4NTgz", "avatar_url": "https://avatars0.githubusercontent.com/u/15258583?v=4", "gravatar_id": "", "url": "https://api.github.com/users/josh11b", "html_url": "https://github.com/josh11b", "followers_url": "https://api.github.com/users/josh11b/followers", "following_url": "https://api.github.com/users/josh11b/following{/other_user}", "gists_url": "https://api.github.com/users/josh11b/gists{/gist_id}", "starred_url": "https://api.github.com/users/josh11b/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/josh11b/subscriptions", "organizations_url": "https://api.github.com/users/josh11b/orgs", "repos_url": "https://api.github.com/users/josh11b/repos", "events_url": "https://api.github.com/users/josh11b/events{/privacy}", "received_events_url": "https://api.github.com/users/josh11b/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "josh11b", "id": 15258583, "node_id": "MDQ6VXNlcjE1MjU4NTgz", "avatar_url": "https://avatars0.githubusercontent.com/u/15258583?v=4", "gravatar_id": "", "url": "https://api.github.com/users/josh11b", "html_url": "https://github.com/josh11b", "followers_url": "https://api.github.com/users/josh11b/followers", "following_url": "https://api.github.com/users/josh11b/following{/other_user}", "gists_url": "https://api.github.com/users/josh11b/gists{/gist_id}", "starred_url": "https://api.github.com/users/josh11b/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/josh11b/subscriptions", "organizations_url": "https://api.github.com/users/josh11b/orgs", "repos_url": "https://api.github.com/users/josh11b/repos", "events_url": "https://api.github.com/users/josh11b/events{/privacy}", "received_events_url": "https://api.github.com/users/josh11b/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 8, "created_at": "2017-07-21T08:25:26Z", "updated_at": "2017-09-05T16:34:24Z", "closed_at": "2017-09-05T16:34:24Z", "author_association": "CONTRIBUTOR", "pull_request": {"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/11663", "html_url": "https://github.com/tensorflow/tensorflow/pull/11663", "diff_url": "https://github.com/tensorflow/tensorflow/pull/11663.diff", "patch_url": "https://github.com/tensorflow/tensorflow/pull/11663.patch"}, "body_html": "<p>While tracing back through the Python logging APIs to find their implementation, I ran into a dead end at the generated file <code>gen_logging_ops.py</code>. This generated file contains no information about where it came from. It took a fair amount of time poking through Bazel build files to track down the rule that generates this file from the output of a program that is linked against an object file that is produced by compiling <code>logging_ops.cc</code>.</p>\n<p>Other developers don't seem to have gotten that far; for example the reporter <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"219225742\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/tensorflow/tensorflow/issues/8953\" data-hovercard-type=\"issue\" data-hovercard-url=\"/tensorflow/tensorflow/issues/8953/hovercard\" href=\"https://github.com/tensorflow/tensorflow/issues/8953\">#8953</a> , who gave up without finding <code>logging_ops.cc</code>.</p>\n<p>This PR adds the name of the original C++ source file to the generated Python files for built-in operators. I've modified <code>python_op_gen_main.cc</code> to check whether it is running from one of the special executables that the Bazel build creates for these internal operators. If the program is running from inside such a rule, it generates a header comment with the name of the original C++ source file:</p>\n<pre><code>\"\"\"Python wrappers around TensorFlow ops.\n\nThis file is MACHINE GENERATED! Do not edit.\nOriginal C++ source file: logging_ops.cc\n\"\"\"\n</code></pre>\n<p>Note the last line, \"Original C++ source file...\". This should be enough information for someone new to the project to track down the implementation of a built-in operator.</p>\n<p>I would have preferred to modify the <code>REGISTER_OP()</code> macro to incorporate information about the original source file in the <code>OpDef</code> itself, but doing so would have required modifying <code>op_def.proto</code>. Hence this approach of checking the executable name in <code>python_op_gen_main.cc</code>.</p>", "body_text": "While tracing back through the Python logging APIs to find their implementation, I ran into a dead end at the generated file gen_logging_ops.py. This generated file contains no information about where it came from. It took a fair amount of time poking through Bazel build files to track down the rule that generates this file from the output of a program that is linked against an object file that is produced by compiling logging_ops.cc.\nOther developers don't seem to have gotten that far; for example the reporter #8953 , who gave up without finding logging_ops.cc.\nThis PR adds the name of the original C++ source file to the generated Python files for built-in operators. I've modified python_op_gen_main.cc to check whether it is running from one of the special executables that the Bazel build creates for these internal operators. If the program is running from inside such a rule, it generates a header comment with the name of the original C++ source file:\n\"\"\"Python wrappers around TensorFlow ops.\n\nThis file is MACHINE GENERATED! Do not edit.\nOriginal C++ source file: logging_ops.cc\n\"\"\"\n\nNote the last line, \"Original C++ source file...\". This should be enough information for someone new to the project to track down the implementation of a built-in operator.\nI would have preferred to modify the REGISTER_OP() macro to incorporate information about the original source file in the OpDef itself, but doing so would have required modifying op_def.proto. Hence this approach of checking the executable name in python_op_gen_main.cc.", "body": "While tracing back through the Python logging APIs to find their implementation, I ran into a dead end at the generated file `gen_logging_ops.py`. This generated file contains no information about where it came from. It took a fair amount of time poking through Bazel build files to track down the rule that generates this file from the output of a program that is linked against an object file that is produced by compiling `logging_ops.cc`.\r\n\r\nOther developers don't seem to have gotten that far; for example the reporter https://github.com/tensorflow/tensorflow/issues/8953 , who gave up without finding `logging_ops.cc`.\r\n\r\nThis PR adds the name of the original C++ source file to the generated Python files for built-in operators. I've modified `python_op_gen_main.cc` to check whether it is running from one of the special executables that the Bazel build creates for these internal operators. If the program is running from inside such a rule, it generates a header comment with the name of the original C++ source file:\r\n```\r\n\"\"\"Python wrappers around TensorFlow ops.\r\n\r\nThis file is MACHINE GENERATED! Do not edit.\r\nOriginal C++ source file: logging_ops.cc\r\n\"\"\"\r\n```\r\nNote the last line, \"Original C++ source file...\". This should be enough information for someone new to the project to track down the implementation of a built-in operator.\r\n\r\nI would have preferred to modify the `REGISTER_OP()` macro to incorporate information about the original source file in the `OpDef` itself, but doing so would have required modifying `op_def.proto`. Hence this approach of checking the executable name in `python_op_gen_main.cc`."}