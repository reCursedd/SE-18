{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/108039064", "pull_request_review_id": 29050330, "id": 108039064, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwODAzOTA2NA==", "diff_hunk": "@@ -0,0 +1,86 @@\n+/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.", "path": "tensorflow/java/src/test/java/org/tensorflow/TensorMatcher.java", "position": 1, "original_position": 1, "commit_id": "0404ac06d5d0d07e08b97e987106b9096c6cb045", "original_commit_id": "0404ac06d5d0d07e08b97e987106b9096c6cb045", "user": {"login": "craykg", "id": 15415443, "node_id": "MDQ6VXNlcjE1NDE1NDQz", "avatar_url": "https://avatars1.githubusercontent.com/u/15415443?v=4", "gravatar_id": "", "url": "https://api.github.com/users/craykg", "html_url": "https://github.com/craykg", "followers_url": "https://api.github.com/users/craykg/followers", "following_url": "https://api.github.com/users/craykg/following{/other_user}", "gists_url": "https://api.github.com/users/craykg/gists{/gist_id}", "starred_url": "https://api.github.com/users/craykg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/craykg/subscriptions", "organizations_url": "https://api.github.com/users/craykg/orgs", "repos_url": "https://api.github.com/users/craykg/repos", "events_url": "https://api.github.com/users/craykg/events{/privacy}", "received_events_url": "https://api.github.com/users/craykg/received_events", "type": "User", "site_admin": false}, "body": "The benefit comes from readability in the tests, and improved failure messages, and in the case of Scalar Tensors a reduction in the number of asserts needed per test. Generally, I advocate for replacing all assert* with assertThat and hamcrest matchers because of readability of code and failure messages. There are also type safety and portability (between junit and testng) benefits as well, but thats not usually why I'm advocating for them.\r\n\r\n**Readability**\r\n`assertThat(tensor, is(scalar());` \r\nversus\r\n`assertEquals(0, tensor.numDimensions());\r\nassertEquals(0, tensor.shape().length);`\r\n\r\nThe first when read left to right is literally _'assert that tensor is scalar'_. Using the older junit assertEquals we need two tightly coupled asserts statements to prove a tensor is scalar, which read like _'assert equals 0 the tensor.numDimensions and assert equals 0 the tensor.shape length'_\r\n\r\n**Failure messages**\r\nIf we have a tensor with a dimension of 1 and a shape length of 1, the assertThat failure message will read:\r\n\"Expected: Tensor with shape length [0] and number of dimensions [0]\r\nbut: was Tensor with shape length [1] and number of dimensions [1]\"\r\n\r\nThe assertEquals failure messages will read:\r\nExpected: 0 was 1.\r\n\r\n**Type safety**\r\nassertThat(tensor, is(scalar()); will not compile if tensor is not actually a tensor. This is less of a problem for assertEquals(0, tensor.numDimension()) and assertEquals(0, tensor.shape().length) because we are calling specific function numDimension() and shape() which are non-standard java getters names anyway (so chance of accidentally having a class with the same method signatures is probably low). Still, something to think about.\r\n\r\nUltimately I was on the fence about adding the tensor matcher class, primarily because of the additional maintenance burden all code come with. What pushed me over to the side of adding one is that the tensor seems to be the building block of the program, so it is likely to be used all over the place to test things. ", "created_at": "2017-03-25T15:56:51Z", "updated_at": "2017-03-25T15:56:51Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/8400#discussion_r108039064", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/8400", "author_association": "NONE", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/108039064"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/8400#discussion_r108039064"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/8400"}}, "body_html": "<p>The benefit comes from readability in the tests, and improved failure messages, and in the case of Scalar Tensors a reduction in the number of asserts needed per test. Generally, I advocate for replacing all assert* with assertThat and hamcrest matchers because of readability of code and failure messages. There are also type safety and portability (between junit and testng) benefits as well, but thats not usually why I'm advocating for them.</p>\n<p><strong>Readability</strong><br>\n<code>assertThat(tensor, is(scalar());</code><br>\nversus<br>\n<code>assertEquals(0, tensor.numDimensions()); assertEquals(0, tensor.shape().length);</code></p>\n<p>The first when read left to right is literally <em>'assert that tensor is scalar'</em>. Using the older junit assertEquals we need two tightly coupled asserts statements to prove a tensor is scalar, which read like <em>'assert equals 0 the tensor.numDimensions and assert equals 0 the tensor.shape length'</em></p>\n<p><strong>Failure messages</strong><br>\nIf we have a tensor with a dimension of 1 and a shape length of 1, the assertThat failure message will read:<br>\n\"Expected: Tensor with shape length [0] and number of dimensions [0]<br>\nbut: was Tensor with shape length [1] and number of dimensions [1]\"</p>\n<p>The assertEquals failure messages will read:<br>\nExpected: 0 was 1.</p>\n<p><strong>Type safety</strong><br>\nassertThat(tensor, is(scalar()); will not compile if tensor is not actually a tensor. This is less of a problem for assertEquals(0, tensor.numDimension()) and assertEquals(0, tensor.shape().length) because we are calling specific function numDimension() and shape() which are non-standard java getters names anyway (so chance of accidentally having a class with the same method signatures is probably low). Still, something to think about.</p>\n<p>Ultimately I was on the fence about adding the tensor matcher class, primarily because of the additional maintenance burden all code come with. What pushed me over to the side of adding one is that the tensor seems to be the building block of the program, so it is likely to be used all over the place to test things.</p>", "body_text": "The benefit comes from readability in the tests, and improved failure messages, and in the case of Scalar Tensors a reduction in the number of asserts needed per test. Generally, I advocate for replacing all assert* with assertThat and hamcrest matchers because of readability of code and failure messages. There are also type safety and portability (between junit and testng) benefits as well, but thats not usually why I'm advocating for them.\nReadability\nassertThat(tensor, is(scalar());\nversus\nassertEquals(0, tensor.numDimensions()); assertEquals(0, tensor.shape().length);\nThe first when read left to right is literally 'assert that tensor is scalar'. Using the older junit assertEquals we need two tightly coupled asserts statements to prove a tensor is scalar, which read like 'assert equals 0 the tensor.numDimensions and assert equals 0 the tensor.shape length'\nFailure messages\nIf we have a tensor with a dimension of 1 and a shape length of 1, the assertThat failure message will read:\n\"Expected: Tensor with shape length [0] and number of dimensions [0]\nbut: was Tensor with shape length [1] and number of dimensions [1]\"\nThe assertEquals failure messages will read:\nExpected: 0 was 1.\nType safety\nassertThat(tensor, is(scalar()); will not compile if tensor is not actually a tensor. This is less of a problem for assertEquals(0, tensor.numDimension()) and assertEquals(0, tensor.shape().length) because we are calling specific function numDimension() and shape() which are non-standard java getters names anyway (so chance of accidentally having a class with the same method signatures is probably low). Still, something to think about.\nUltimately I was on the fence about adding the tensor matcher class, primarily because of the additional maintenance burden all code come with. What pushed me over to the side of adding one is that the tensor seems to be the building block of the program, so it is likely to be used all over the place to test things.", "in_reply_to_id": 107839240}