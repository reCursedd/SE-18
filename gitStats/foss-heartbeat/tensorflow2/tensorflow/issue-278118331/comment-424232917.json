{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/424232917", "html_url": "https://github.com/tensorflow/tensorflow/issues/15002#issuecomment-424232917", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/15002", "id": 424232917, "node_id": "MDEyOklzc3VlQ29tbWVudDQyNDIzMjkxNw==", "user": {"login": "PatWie", "id": 6756603, "node_id": "MDQ6VXNlcjY3NTY2MDM=", "avatar_url": "https://avatars3.githubusercontent.com/u/6756603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/PatWie", "html_url": "https://github.com/PatWie", "followers_url": "https://api.github.com/users/PatWie/followers", "following_url": "https://api.github.com/users/PatWie/following{/other_user}", "gists_url": "https://api.github.com/users/PatWie/gists{/gist_id}", "starred_url": "https://api.github.com/users/PatWie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/PatWie/subscriptions", "organizations_url": "https://api.github.com/users/PatWie/orgs", "repos_url": "https://api.github.com/users/PatWie/repos", "events_url": "https://api.github.com/users/PatWie/events{/privacy}", "received_events_url": "https://api.github.com/users/PatWie/received_events", "type": "User", "site_admin": false}, "created_at": "2018-09-25T07:15:51Z", "updated_at": "2018-09-25T07:18:57Z", "author_association": "NONE", "body_html": "<p>Messing up the system with symbolic links is usually a bad idea.<br>\nThe root of all evil is the path <code>#include \"cuda/include/cuda.h\"</code> itself. Usually, you use <code>#include \"cuda.h\"</code> or <code>#include \"cuda_runtime.h\"</code>  when doing CUDA programming.</p>\n<h3>Solution CMake</h3>\n<p>Usually <code>FindCuda.cmake</code> sets <code>CUDA_INCLUDE_DIRS</code> properly which relies on the environment variables <code>CUDA_PATH</code> and <code>CUDA_INC_PATH</code> and they are pointing directly to the header files:</p>\n<p>Any simple CMakeLists.txt should detect the correct path</p>\n<div class=\"highlight highlight-source-cmake\"><pre><span class=\"pl-c1\">cmake_minimum_required</span>( <span class=\"pl-k\">VERSION</span> 2.8 )\n\n<span class=\"pl-c1\">find_package</span>(CUDA 9 <span class=\"pl-k\">REQUIRED</span>)\n<span class=\"pl-c1\">message</span>(STATUS <span class=\"pl-smi\">${CUDA_INCLUDE_DIRS}</span>)\n<span class=\"pl-c1\">message</span>(STATUS <span class=\"pl-smi\">${CUDA_TOOLKIT_INCLUDE}</span>)\n\n</pre></div>\n<p>gives</p>\n<pre><code>/usr/local/cuda/include\n/usr/local/cuda/include\n</code></pre>\n<p>So any <a href=\"https://github.com/PatWie/tensorflow-cmake/blob/203efca40fb4f91a8922626dd76ecd0f6a41e66d/custom_op/user_ops/CMakeLists.txt#L19\">easy fix</a> in CMake is:</p>\n<div class=\"highlight highlight-source-cmake\"><pre><span class=\"pl-c1\">find_package</span>(CUDA <span class=\"pl-k\">REQUIRED</span>)\n<span class=\"pl-c1\">include_directories</span>(<span class=\"pl-k\">SYSTEM</span> <span class=\"pl-s\">\"<span class=\"pl-smi\">${CUDA_INCLUDE_DIRS}</span>/../../\"</span>)\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> or probably better</span>\n<span class=\"pl-c1\">include_directories</span>(<span class=\"pl-k\">SYSTEM</span> <span class=\"pl-s\">\"<span class=\"pl-smi\">${CUDA_TOOLKIT_INCLUDE}</span>/../../\"</span>)</pre></div>\n<p>If you are using some other toolkit location (I do), setting the env-var <code>CUDA_PATH</code> seems to be sufficient (see below).</p>\n<h3>Solution Makefile</h3>\n<p>When not relying on CMake and you are writing a shell-script or plain Makefile, it it a good idea to specify the environment variables <a href=\"https://github.com/Kitware/CMake/blob/1fea56c3bd99be6c7a6bfaa1454ba67e7a04da72/Modules/FindCUDA.cmake#L782-L783\"><code>CUDA_PATH, CUDA_INC_PATH</code></a></p>\n<div class=\"highlight highlight-source-shell\"><pre><span class=\"pl-k\">export</span> CUDA_PATH=/path/to/cuda/toolkit_9.0/cuda\n<span class=\"pl-k\">export</span> CUDA_INC_PATH=<span class=\"pl-smi\">${CUDA_PATH}</span>/include</pre></div>\n<p>Now, something like</p>\n<pre><code>nvcc -I${CUDA_INC_PATH}../../\n</code></pre>\n<p>is sufficient.</p>", "body_text": "Messing up the system with symbolic links is usually a bad idea.\nThe root of all evil is the path #include \"cuda/include/cuda.h\" itself. Usually, you use #include \"cuda.h\" or #include \"cuda_runtime.h\"  when doing CUDA programming.\nSolution CMake\nUsually FindCuda.cmake sets CUDA_INCLUDE_DIRS properly which relies on the environment variables CUDA_PATH and CUDA_INC_PATH and they are pointing directly to the header files:\nAny simple CMakeLists.txt should detect the correct path\ncmake_minimum_required( VERSION 2.8 )\n\nfind_package(CUDA 9 REQUIRED)\nmessage(STATUS ${CUDA_INCLUDE_DIRS})\nmessage(STATUS ${CUDA_TOOLKIT_INCLUDE})\n\n\ngives\n/usr/local/cuda/include\n/usr/local/cuda/include\n\nSo any easy fix in CMake is:\nfind_package(CUDA REQUIRED)\ninclude_directories(SYSTEM \"${CUDA_INCLUDE_DIRS}/../../\")\n# or probably better\ninclude_directories(SYSTEM \"${CUDA_TOOLKIT_INCLUDE}/../../\")\nIf you are using some other toolkit location (I do), setting the env-var CUDA_PATH seems to be sufficient (see below).\nSolution Makefile\nWhen not relying on CMake and you are writing a shell-script or plain Makefile, it it a good idea to specify the environment variables CUDA_PATH, CUDA_INC_PATH\nexport CUDA_PATH=/path/to/cuda/toolkit_9.0/cuda\nexport CUDA_INC_PATH=${CUDA_PATH}/include\nNow, something like\nnvcc -I${CUDA_INC_PATH}../../\n\nis sufficient.", "body": "Messing up the system with symbolic links is usually a bad idea.\r\nThe root of all evil is the path `#include \"cuda/include/cuda.h\"` itself. Usually, you use `#include \"cuda.h\"` or `#include \"cuda_runtime.h\"`  when doing CUDA programming. \r\n\r\n### Solution CMake\r\nUsually `FindCuda.cmake` sets `CUDA_INCLUDE_DIRS` properly which relies on the environment variables `CUDA_PATH` and `CUDA_INC_PATH` and they are pointing directly to the header files:\r\n\r\nAny simple CMakeLists.txt should detect the correct path\r\n\r\n```cmake\r\ncmake_minimum_required( VERSION 2.8 )\r\n\r\nfind_package(CUDA 9 REQUIRED)\r\nmessage(STATUS ${CUDA_INCLUDE_DIRS})\r\nmessage(STATUS ${CUDA_TOOLKIT_INCLUDE})\r\n\r\n\r\n```\r\ngives\r\n\r\n```\r\n/usr/local/cuda/include\r\n/usr/local/cuda/include\r\n```\r\n\r\nSo any [easy fix](https://github.com/PatWie/tensorflow-cmake/blob/203efca40fb4f91a8922626dd76ecd0f6a41e66d/custom_op/user_ops/CMakeLists.txt#L19) in CMake is:\r\n```cmake\r\nfind_package(CUDA REQUIRED)\r\ninclude_directories(SYSTEM \"${CUDA_INCLUDE_DIRS}/../../\")\r\n# or probably better\r\ninclude_directories(SYSTEM \"${CUDA_TOOLKIT_INCLUDE}/../../\")\r\n```\r\n\r\nIf you are using some other toolkit location (I do), setting the env-var `CUDA_PATH` seems to be sufficient (see below).\r\n\r\n### Solution Makefile\r\n\r\nWhen not relying on CMake and you are writing a shell-script or plain Makefile, it it a good idea to specify the environment variables [`CUDA_PATH, CUDA_INC_PATH`](https://github.com/Kitware/CMake/blob/1fea56c3bd99be6c7a6bfaa1454ba67e7a04da72/Modules/FindCUDA.cmake#L782-L783)\r\n\r\n\r\n```bash\r\nexport CUDA_PATH=/path/to/cuda/toolkit_9.0/cuda\r\nexport CUDA_INC_PATH=${CUDA_PATH}/include\r\n```\r\n\r\nNow, something like\r\n```\r\nnvcc -I${CUDA_INC_PATH}../../\r\n```\r\nis sufficient."}