{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/223721966", "html_url": "https://github.com/tensorflow/tensorflow/issues/2645#issuecomment-223721966", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2645", "id": 223721966, "node_id": "MDEyOklzc3VlQ29tbWVudDIyMzcyMTk2Ng==", "user": {"login": "yaroslavvb", "id": 23068, "node_id": "MDQ6VXNlcjIzMDY4", "avatar_url": "https://avatars3.githubusercontent.com/u/23068?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yaroslavvb", "html_url": "https://github.com/yaroslavvb", "followers_url": "https://api.github.com/users/yaroslavvb/followers", "following_url": "https://api.github.com/users/yaroslavvb/following{/other_user}", "gists_url": "https://api.github.com/users/yaroslavvb/gists{/gist_id}", "starred_url": "https://api.github.com/users/yaroslavvb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yaroslavvb/subscriptions", "organizations_url": "https://api.github.com/users/yaroslavvb/orgs", "repos_url": "https://api.github.com/users/yaroslavvb/repos", "events_url": "https://api.github.com/users/yaroslavvb/events{/privacy}", "received_events_url": "https://api.github.com/users/yaroslavvb/received_events", "type": "User", "site_admin": false}, "created_at": "2016-06-04T00:04:22Z", "updated_at": "2016-06-04T00:04:46Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Actually for fix above to work, <code>_auto_gc_enabled</code> has to be set to <code>False</code> for all TensorHandles. The issue is that when <code>update_with_movers</code> moves CPU Tensor to GPU, it'll register CPU tensor handle for deletion. But if <code>_auto_gc_enabled</code> is True (it is True by default), at the point when Python runtime garbage collects that <code>TensorHandle</code> object, it'll register same handle for deletion again, so the program will fail on next gc pass with something like</p>\n<p><code>InvalidArgumentError: Failed to delete a tensor with handle 'GetSessionHandle_4;9;/job:localhost/replica:0/task:0/cpu:0' in the session store. </code></p>", "body_text": "Actually for fix above to work, _auto_gc_enabled has to be set to False for all TensorHandles. The issue is that when update_with_movers moves CPU Tensor to GPU, it'll register CPU tensor handle for deletion. But if _auto_gc_enabled is True (it is True by default), at the point when Python runtime garbage collects that TensorHandle object, it'll register same handle for deletion again, so the program will fail on next gc pass with something like\nInvalidArgumentError: Failed to delete a tensor with handle 'GetSessionHandle_4;9;/job:localhost/replica:0/task:0/cpu:0' in the session store.", "body": "Actually for fix above to work, `_auto_gc_enabled` has to be set to `False` for all TensorHandles. The issue is that when `update_with_movers` moves CPU Tensor to GPU, it'll register CPU tensor handle for deletion. But if `_auto_gc_enabled` is True (it is True by default), at the point when Python runtime garbage collects that `TensorHandle` object, it'll register same handle for deletion again, so the program will fail on next gc pass with something like\n\n`InvalidArgumentError: Failed to delete a tensor with handle 'GetSessionHandle_4;9;/job:localhost/replica:0/task:0/cpu:0' in the session store.\n`\n"}