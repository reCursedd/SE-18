{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/184603479", "html_url": "https://github.com/tensorflow/tensorflow/issues/929#issuecomment-184603479", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/929", "id": 184603479, "node_id": "MDEyOklzc3VlQ29tbWVudDE4NDYwMzQ3OQ==", "user": {"login": "dvyukov", "id": 1095328, "node_id": "MDQ6VXNlcjEwOTUzMjg=", "avatar_url": "https://avatars3.githubusercontent.com/u/1095328?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dvyukov", "html_url": "https://github.com/dvyukov", "followers_url": "https://api.github.com/users/dvyukov/followers", "following_url": "https://api.github.com/users/dvyukov/following{/other_user}", "gists_url": "https://api.github.com/users/dvyukov/gists{/gist_id}", "starred_url": "https://api.github.com/users/dvyukov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dvyukov/subscriptions", "organizations_url": "https://api.github.com/users/dvyukov/orgs", "repos_url": "https://api.github.com/users/dvyukov/repos", "events_url": "https://api.github.com/users/dvyukov/events{/privacy}", "received_events_url": "https://api.github.com/users/dvyukov/received_events", "type": "User", "site_admin": false}, "created_at": "2016-02-16T09:55:55Z", "updated_at": "2016-02-16T09:55:55Z", "author_association": "NONE", "body_html": "<p>Thanks, Jeremy. To clarify, you run label_image with your pool and did not see deadlocks; or you did not run label_image and did not see deadlocks?</p>\n<p>Pulling for work while waiting can help to some degree, but it still has problems when blocked tasks stack up on a single thread:</p>\n<ol>\n<li>Stack can grow without limit and cause stack overflow, and you can't limit recursion at runtime because then you get back to deadlocks.</li>\n<li>This limit available parallelism: a task can be already ready to run but is sitting on a thread stack, and the thread is busy executing another task. It is not possible to execute the readied task until all tasks on the same thread finish.</li>\n<li>And more importantly, it is subject to deadlocks as well. Consider that a task is waiting for completion of a task that is blocked on the very same stack below it. Oops.</li>\n</ol>\n<p>Some parallel computation libraries avoid the deadlocks by imposing a DAG requirement of work structure where all dependent tasks must be spawned by the task itself. This again requires fixing structure of all algorithms rather than just plugging polling into wait objects. And it makes (2) worse.</p>\n<p>Some other systems solve this by playing tricks with virtual memory:<br>\n<a href=\"http://groups.csail.mit.edu/sct/wiki/index.php?title=The_Cilk-M_Project\" rel=\"nofollow\">http://groups.csail.mit.edu/sct/wiki/index.php?title=The_Cilk-M_Project</a><br>\n<a href=\"http://supertech.csail.mit.edu/papers/stacks.pdf\" rel=\"nofollow\">http://supertech.csail.mit.edu/papers/stacks.pdf</a><br>\nBut I think this is out of question here.</p>\n<p>I would suggest to explicitly schedule continuations instead of blocking on worker thread stack. Continuations suck code-wise. But that's what we have in C++. Hopefully it's not that bad with closures.</p>", "body_text": "Thanks, Jeremy. To clarify, you run label_image with your pool and did not see deadlocks; or you did not run label_image and did not see deadlocks?\nPulling for work while waiting can help to some degree, but it still has problems when blocked tasks stack up on a single thread:\n\nStack can grow without limit and cause stack overflow, and you can't limit recursion at runtime because then you get back to deadlocks.\nThis limit available parallelism: a task can be already ready to run but is sitting on a thread stack, and the thread is busy executing another task. It is not possible to execute the readied task until all tasks on the same thread finish.\nAnd more importantly, it is subject to deadlocks as well. Consider that a task is waiting for completion of a task that is blocked on the very same stack below it. Oops.\n\nSome parallel computation libraries avoid the deadlocks by imposing a DAG requirement of work structure where all dependent tasks must be spawned by the task itself. This again requires fixing structure of all algorithms rather than just plugging polling into wait objects. And it makes (2) worse.\nSome other systems solve this by playing tricks with virtual memory:\nhttp://groups.csail.mit.edu/sct/wiki/index.php?title=The_Cilk-M_Project\nhttp://supertech.csail.mit.edu/papers/stacks.pdf\nBut I think this is out of question here.\nI would suggest to explicitly schedule continuations instead of blocking on worker thread stack. Continuations suck code-wise. But that's what we have in C++. Hopefully it's not that bad with closures.", "body": "Thanks, Jeremy. To clarify, you run label_image with your pool and did not see deadlocks; or you did not run label_image and did not see deadlocks?\n\nPulling for work while waiting can help to some degree, but it still has problems when blocked tasks stack up on a single thread:\n1. Stack can grow without limit and cause stack overflow, and you can't limit recursion at runtime because then you get back to deadlocks.\n2. This limit available parallelism: a task can be already ready to run but is sitting on a thread stack, and the thread is busy executing another task. It is not possible to execute the readied task until all tasks on the same thread finish.\n3. And more importantly, it is subject to deadlocks as well. Consider that a task is waiting for completion of a task that is blocked on the very same stack below it. Oops.\n\nSome parallel computation libraries avoid the deadlocks by imposing a DAG requirement of work structure where all dependent tasks must be spawned by the task itself. This again requires fixing structure of all algorithms rather than just plugging polling into wait objects. And it makes (2) worse.\n\nSome other systems solve this by playing tricks with virtual memory:\nhttp://groups.csail.mit.edu/sct/wiki/index.php?title=The_Cilk-M_Project\nhttp://supertech.csail.mit.edu/papers/stacks.pdf\nBut I think this is out of question here.\n\nI would suggest to explicitly schedule continuations instead of blocking on worker thread stack. Continuations suck code-wise. But that's what we have in C++. Hopefully it's not that bad with closures.\n"}