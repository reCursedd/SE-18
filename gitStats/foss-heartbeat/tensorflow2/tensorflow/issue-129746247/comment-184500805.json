{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/184500805", "html_url": "https://github.com/tensorflow/tensorflow/issues/929#issuecomment-184500805", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/929", "id": 184500805, "node_id": "MDEyOklzc3VlQ29tbWVudDE4NDUwMDgwNQ==", "user": {"login": "jeremybarnes", "id": 112556, "node_id": "MDQ6VXNlcjExMjU1Ng==", "avatar_url": "https://avatars3.githubusercontent.com/u/112556?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jeremybarnes", "html_url": "https://github.com/jeremybarnes", "followers_url": "https://api.github.com/users/jeremybarnes/followers", "following_url": "https://api.github.com/users/jeremybarnes/following{/other_user}", "gists_url": "https://api.github.com/users/jeremybarnes/gists{/gist_id}", "starred_url": "https://api.github.com/users/jeremybarnes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jeremybarnes/subscriptions", "organizations_url": "https://api.github.com/users/jeremybarnes/orgs", "repos_url": "https://api.github.com/users/jeremybarnes/repos", "events_url": "https://api.github.com/users/jeremybarnes/events{/privacy}", "received_events_url": "https://api.github.com/users/jeremybarnes/received_events", "type": "User", "site_admin": false}, "created_at": "2016-02-16T03:38:00Z", "updated_at": "2016-02-16T03:38:00Z", "author_association": "NONE", "body_html": "<p>(I've been submerged for the last couple of weeks, and I didn't see the notification).</p>\n<p>I didn't see any deadlocks, but I can see that they are definitely possible on any thread pool that doesn't know to schedule a new thread if a worker thread blocks.  We need to be very careful in any bounded thread scenario, as it's not possible to guarantee progress in the general case on a finite number of threads.</p>\n<p>In general the pattern I use to work around these kind of deadlocks with a fixed number of threads is to poll instead of block, and perform work from the threadpool after un unsuccessful poll to guarantee forward progress.  That would require some deeper changes to Eigen so that it knew it was in a worker thread and could adjust its behaviour accordingly.</p>", "body_text": "(I've been submerged for the last couple of weeks, and I didn't see the notification).\nI didn't see any deadlocks, but I can see that they are definitely possible on any thread pool that doesn't know to schedule a new thread if a worker thread blocks.  We need to be very careful in any bounded thread scenario, as it's not possible to guarantee progress in the general case on a finite number of threads.\nIn general the pattern I use to work around these kind of deadlocks with a fixed number of threads is to poll instead of block, and perform work from the threadpool after un unsuccessful poll to guarantee forward progress.  That would require some deeper changes to Eigen so that it knew it was in a worker thread and could adjust its behaviour accordingly.", "body": "(I've been submerged for the last couple of weeks, and I didn't see the notification).\n\nI didn't see any deadlocks, but I can see that they are definitely possible on any thread pool that doesn't know to schedule a new thread if a worker thread blocks.  We need to be very careful in any bounded thread scenario, as it's not possible to guarantee progress in the general case on a finite number of threads.\n\nIn general the pattern I use to work around these kind of deadlocks with a fixed number of threads is to poll instead of block, and perform work from the threadpool after un unsuccessful poll to guarantee forward progress.  That would require some deeper changes to Eigen so that it knew it was in a worker thread and could adjust its behaviour accordingly.\n"}