{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/215396200", "html_url": "https://github.com/tensorflow/tensorflow/issues/2130#issuecomment-215396200", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2130", "id": 215396200, "node_id": "MDEyOklzc3VlQ29tbWVudDIxNTM5NjIwMA==", "user": {"login": "ivankreso", "id": 2056432, "node_id": "MDQ6VXNlcjIwNTY0MzI=", "avatar_url": "https://avatars3.githubusercontent.com/u/2056432?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ivankreso", "html_url": "https://github.com/ivankreso", "followers_url": "https://api.github.com/users/ivankreso/followers", "following_url": "https://api.github.com/users/ivankreso/following{/other_user}", "gists_url": "https://api.github.com/users/ivankreso/gists{/gist_id}", "starred_url": "https://api.github.com/users/ivankreso/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ivankreso/subscriptions", "organizations_url": "https://api.github.com/users/ivankreso/orgs", "repos_url": "https://api.github.com/users/ivankreso/repos", "events_url": "https://api.github.com/users/ivankreso/events{/privacy}", "received_events_url": "https://api.github.com/users/ivankreso/received_events", "type": "User", "site_admin": false}, "created_at": "2016-04-28T11:34:52Z", "updated_at": "2016-04-28T11:34:52Z", "author_association": "NONE", "body_html": "<p>Thanks a lot <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=23068\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/yaroslavvb\">@yaroslavvb</a>! I somehow missed the queue.close() bug.</p>\n<p>I fixed my training code and everything works now.<br>\nI need to handle data manualy in order to perform validation after each epoch as I have only one Titan X :)<br>\nThere was one more thing I had to fix in my training code.<br>\nIn all official examples the summary operation is run like this:</p>\n<pre><code>      if step % 100 == 0:\n        summary_str = sess.run(summary_op)\n        summary_writer.add_summary(summary_str, step)\n</code></pre>\n<p>This means that every 100th image is skipped in applying the training operation because ordinary summary_op includes the loss operation and subsequently the whole forward pass.<br>\nI uderstand this is not an issue when using the shuffled version of tf.train.string_input_producer but  it becomes a problem when handing queues manually because summary_op will dequeue and you need to count it as a full iteration.<br>\nI fixed it by simply running summary_op and train_op jointly:</p>\n<pre><code>      if step % 100 == 0:\n        _, loss_value, summary_str = sess.run([train_op, loss, summary_op])\n        summary_writer.add_summary(summary_str, global_step_val)\n      else:\n        _, loss_value = sess.run([train_op, loss])\n</code></pre>\n<p>I think it would be useful if Tensorflow documentation or source code contaned an example of how to train and validate (after each epoch) the model on single GPU. A lot of people have limiting resources and they can't reserve one GPU only for validation. If you want I can send you a simplified version of my implementation.</p>", "body_text": "Thanks a lot @yaroslavvb! I somehow missed the queue.close() bug.\nI fixed my training code and everything works now.\nI need to handle data manualy in order to perform validation after each epoch as I have only one Titan X :)\nThere was one more thing I had to fix in my training code.\nIn all official examples the summary operation is run like this:\n      if step % 100 == 0:\n        summary_str = sess.run(summary_op)\n        summary_writer.add_summary(summary_str, step)\n\nThis means that every 100th image is skipped in applying the training operation because ordinary summary_op includes the loss operation and subsequently the whole forward pass.\nI uderstand this is not an issue when using the shuffled version of tf.train.string_input_producer but  it becomes a problem when handing queues manually because summary_op will dequeue and you need to count it as a full iteration.\nI fixed it by simply running summary_op and train_op jointly:\n      if step % 100 == 0:\n        _, loss_value, summary_str = sess.run([train_op, loss, summary_op])\n        summary_writer.add_summary(summary_str, global_step_val)\n      else:\n        _, loss_value = sess.run([train_op, loss])\n\nI think it would be useful if Tensorflow documentation or source code contaned an example of how to train and validate (after each epoch) the model on single GPU. A lot of people have limiting resources and they can't reserve one GPU only for validation. If you want I can send you a simplified version of my implementation.", "body": "Thanks a lot @yaroslavvb! I somehow missed the queue.close() bug.\n\nI fixed my training code and everything works now.\nI need to handle data manualy in order to perform validation after each epoch as I have only one Titan X :)\nThere was one more thing I had to fix in my training code.\nIn all official examples the summary operation is run like this:\n\n```\n      if step % 100 == 0:\n        summary_str = sess.run(summary_op)\n        summary_writer.add_summary(summary_str, step)\n```\n\nThis means that every 100th image is skipped in applying the training operation because ordinary summary_op includes the loss operation and subsequently the whole forward pass.\nI uderstand this is not an issue when using the shuffled version of tf.train.string_input_producer but  it becomes a problem when handing queues manually because summary_op will dequeue and you need to count it as a full iteration.\nI fixed it by simply running summary_op and train_op jointly:\n\n```\n      if step % 100 == 0:\n        _, loss_value, summary_str = sess.run([train_op, loss, summary_op])\n        summary_writer.add_summary(summary_str, global_step_val)\n      else:\n        _, loss_value = sess.run([train_op, loss])\n```\n\nI think it would be useful if Tensorflow documentation or source code contaned an example of how to train and validate (after each epoch) the model on single GPU. A lot of people have limiting resources and they can't reserve one GPU only for validation. If you want I can send you a simplified version of my implementation.\n"}