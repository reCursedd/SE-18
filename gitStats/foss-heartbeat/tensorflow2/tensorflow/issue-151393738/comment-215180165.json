{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/215180165", "html_url": "https://github.com/tensorflow/tensorflow/issues/2130#issuecomment-215180165", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2130", "id": 215180165, "node_id": "MDEyOklzc3VlQ29tbWVudDIxNTE4MDE2NQ==", "user": {"login": "yaroslavvb", "id": 23068, "node_id": "MDQ6VXNlcjIzMDY4", "avatar_url": "https://avatars3.githubusercontent.com/u/23068?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yaroslavvb", "html_url": "https://github.com/yaroslavvb", "followers_url": "https://api.github.com/users/yaroslavvb/followers", "following_url": "https://api.github.com/users/yaroslavvb/following{/other_user}", "gists_url": "https://api.github.com/users/yaroslavvb/gists{/gist_id}", "starred_url": "https://api.github.com/users/yaroslavvb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yaroslavvb/subscriptions", "organizations_url": "https://api.github.com/users/yaroslavvb/orgs", "repos_url": "https://api.github.com/users/yaroslavvb/repos", "events_url": "https://api.github.com/users/yaroslavvb/events{/privacy}", "received_events_url": "https://api.github.com/users/yaroslavvb/received_events", "type": "User", "site_admin": false}, "created_at": "2016-04-27T18:18:56Z", "updated_at": "2016-04-27T18:18:56Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Oh...you are calling \"queue.close()\", but that actually returns an op which needs to be run to do anything. You need to do <code>sess.run(q.close())</code>. Since your first queue is not closed, your \"batch\" queue is waiting forever for something to be added to the first queue.</p>\n<p>Furthermore, this wait is happening in C++ mutex, so <code>stop_grace_period_secs</code> is useless -- the queue runner thread checks for \"stop_requested\" between session <code>run</code> calls, but because dequeue op never returns, it's stuck inside <code>session.run</code> forever.</p>\n<p>Here's the simpler example I made for myself to reproduce this</p>\n<pre><code>def create_session():\n  \"\"\"Resets local session, returns new InteractiveSession\"\"\"\n\n  config = tf.ConfigProto(log_device_placement=True)\n  config.gpu_options.per_process_gpu_memory_fraction=0.3 # don't hog all vRAM\n  config.operation_timeout_in_ms=5000   # terminate on long hangs\n  sess = tf.InteractiveSession(\"\", config=config)\n  return sess\n\ntf.reset_default_graph()\nq = tf.FIFOQueue(4, tf.string)\nenqueue_val = tf.placeholder(dtype=tf.string)\nenqueue_op = q.enqueue(enqueue_val)\nsize_op = q.size()\ndequeue_op = q.dequeue()\nsess = create_session()\ndef enqueueit(val):\n  sess.run([enqueue_op], feed_dict={enqueue_val:val})\n  print \"queue1 size: \", sess.run(size_op)\nenqueueit(\"1\")\nenqueueit(\"2\")\nenqueueit(\"3\")\n#sess.run(q.close())\n\ndequeue_op.set_shape([])\nqueue2 = tf.train.batch([dequeue_op], batch_size=1, num_threads=1, capacity=1)\nthreads = tf.train.start_queue_runners()\n\ndef dequeueit():\n  print \"queue1 size: \", sess.run(size_op)\n  print \"queue2 size before: \", sess.run(\"batch/fifo_queue_Size:0\")\n  print \"result: \", sess.run(queue2)\n  print \"queue2 size after: \", sess.run(\"batch/fifo_queue_Size:0\")\n\ndequeueit()\ndequeueit()\ndequeueit()\ncoord.request_stop()\ncoord.join(threads, stop_grace_period_secs=5)\n</code></pre>", "body_text": "Oh...you are calling \"queue.close()\", but that actually returns an op which needs to be run to do anything. You need to do sess.run(q.close()). Since your first queue is not closed, your \"batch\" queue is waiting forever for something to be added to the first queue.\nFurthermore, this wait is happening in C++ mutex, so stop_grace_period_secs is useless -- the queue runner thread checks for \"stop_requested\" between session run calls, but because dequeue op never returns, it's stuck inside session.run forever.\nHere's the simpler example I made for myself to reproduce this\ndef create_session():\n  \"\"\"Resets local session, returns new InteractiveSession\"\"\"\n\n  config = tf.ConfigProto(log_device_placement=True)\n  config.gpu_options.per_process_gpu_memory_fraction=0.3 # don't hog all vRAM\n  config.operation_timeout_in_ms=5000   # terminate on long hangs\n  sess = tf.InteractiveSession(\"\", config=config)\n  return sess\n\ntf.reset_default_graph()\nq = tf.FIFOQueue(4, tf.string)\nenqueue_val = tf.placeholder(dtype=tf.string)\nenqueue_op = q.enqueue(enqueue_val)\nsize_op = q.size()\ndequeue_op = q.dequeue()\nsess = create_session()\ndef enqueueit(val):\n  sess.run([enqueue_op], feed_dict={enqueue_val:val})\n  print \"queue1 size: \", sess.run(size_op)\nenqueueit(\"1\")\nenqueueit(\"2\")\nenqueueit(\"3\")\n#sess.run(q.close())\n\ndequeue_op.set_shape([])\nqueue2 = tf.train.batch([dequeue_op], batch_size=1, num_threads=1, capacity=1)\nthreads = tf.train.start_queue_runners()\n\ndef dequeueit():\n  print \"queue1 size: \", sess.run(size_op)\n  print \"queue2 size before: \", sess.run(\"batch/fifo_queue_Size:0\")\n  print \"result: \", sess.run(queue2)\n  print \"queue2 size after: \", sess.run(\"batch/fifo_queue_Size:0\")\n\ndequeueit()\ndequeueit()\ndequeueit()\ncoord.request_stop()\ncoord.join(threads, stop_grace_period_secs=5)", "body": "Oh...you are calling \"queue.close()\", but that actually returns an op which needs to be run to do anything. You need to do `sess.run(q.close())`. Since your first queue is not closed, your \"batch\" queue is waiting forever for something to be added to the first queue.\n\nFurthermore, this wait is happening in C++ mutex, so `stop_grace_period_secs` is useless -- the queue runner thread checks for \"stop_requested\" between session `run` calls, but because dequeue op never returns, it's stuck inside `session.run` forever.\n\nHere's the simpler example I made for myself to reproduce this\n\n```\ndef create_session():\n  \"\"\"Resets local session, returns new InteractiveSession\"\"\"\n\n  config = tf.ConfigProto(log_device_placement=True)\n  config.gpu_options.per_process_gpu_memory_fraction=0.3 # don't hog all vRAM\n  config.operation_timeout_in_ms=5000   # terminate on long hangs\n  sess = tf.InteractiveSession(\"\", config=config)\n  return sess\n\ntf.reset_default_graph()\nq = tf.FIFOQueue(4, tf.string)\nenqueue_val = tf.placeholder(dtype=tf.string)\nenqueue_op = q.enqueue(enqueue_val)\nsize_op = q.size()\ndequeue_op = q.dequeue()\nsess = create_session()\ndef enqueueit(val):\n  sess.run([enqueue_op], feed_dict={enqueue_val:val})\n  print \"queue1 size: \", sess.run(size_op)\nenqueueit(\"1\")\nenqueueit(\"2\")\nenqueueit(\"3\")\n#sess.run(q.close())\n\ndequeue_op.set_shape([])\nqueue2 = tf.train.batch([dequeue_op], batch_size=1, num_threads=1, capacity=1)\nthreads = tf.train.start_queue_runners()\n\ndef dequeueit():\n  print \"queue1 size: \", sess.run(size_op)\n  print \"queue2 size before: \", sess.run(\"batch/fifo_queue_Size:0\")\n  print \"result: \", sess.run(queue2)\n  print \"queue2 size after: \", sess.run(\"batch/fifo_queue_Size:0\")\n\ndequeueit()\ndequeueit()\ndequeueit()\ncoord.request_stop()\ncoord.join(threads, stop_grace_period_secs=5)\n```\n"}