{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/285204705", "html_url": "https://github.com/tensorflow/tensorflow/issues/8051#issuecomment-285204705", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8051", "id": 285204705, "node_id": "MDEyOklzc3VlQ29tbWVudDI4NTIwNDcwNQ==", "user": {"login": "shoyer", "id": 1217238, "node_id": "MDQ6VXNlcjEyMTcyMzg=", "avatar_url": "https://avatars2.githubusercontent.com/u/1217238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/shoyer", "html_url": "https://github.com/shoyer", "followers_url": "https://api.github.com/users/shoyer/followers", "following_url": "https://api.github.com/users/shoyer/following{/other_user}", "gists_url": "https://api.github.com/users/shoyer/gists{/gist_id}", "starred_url": "https://api.github.com/users/shoyer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/shoyer/subscriptions", "organizations_url": "https://api.github.com/users/shoyer/orgs", "repos_url": "https://api.github.com/users/shoyer/repos", "events_url": "https://api.github.com/users/shoyer/events{/privacy}", "received_events_url": "https://api.github.com/users/shoyer/received_events", "type": "User", "site_admin": false}, "created_at": "2017-03-08T23:31:02Z", "updated_at": "2017-03-08T23:33:50Z", "author_association": "MEMBER", "body_html": "<p>Let me try to provide some context around <code>__array_priority__</code> as a NumPy developer. (There has actually been extensive discussion about <a href=\"https://github.com/numpy/numpy/issues/5844\" data-hovercard-type=\"issue\" data-hovercard-url=\"/numpy/numpy/issues/5844/hovercard\">removing it entirely</a> going forward, but that's a whole different matter that you probably don't want to get into.)</p>\n<p>It exists because NumPy has two different ways of interacting with objects of an unknown type. For example, suppose <code>array = np.array([1, 2, 3])</code> and <code>other = SomeType()</code>. What should <code>array + other</code> give?</p>\n<ol>\n<li>If <code>__array_priority__</code> is unset or less than 1: treat the unknown type as a scalar, and apply the operation in an element-wise fashion over each element of the array, e.g., <code>array + other</code> -&gt; <code>np.array([1 + other, 2 + other, 3 + other])</code>.</li>\n<li>If <code>__array_priority__</code> is greater than 1: treat the unknown type as an array, and let it try to handle the entire NumPy array, e.g., <code>array + other</code> -&gt; <code>other.__radd__(array)</code>.</li>\n</ol>\n<p>I don't think TensorFlow <em>ever</em> wants behavior (1). Hence we don't need <code>__tensor_priority__</code>. TensorFlow should stick to Python's default system for overriding arithmetic operations.</p>\n<p>Something like one of these solutions seems like a good place to start:</p>\n<p>\"Try converting everything to a tensor\"</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-c\"><span class=\"pl-c\">#</span> This is possibly not flexible enough, because you might, for example,</span>\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> want to define a type (e.g., a tensor with physical units) that is convertible</span>\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> to a tensor but still wants to override arithmetic.</span>\n<span class=\"pl-k\">def</span> <span class=\"pl-c1\">__add__</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>, <span class=\"pl-smi\">other</span>):\n  <span class=\"pl-k\">try</span>:\n    other <span class=\"pl-k\">=</span> ops.convert_to_tensor(other)\n  <span class=\"pl-k\">except</span> <span class=\"pl-c1\">TypeError</span>:\n    <span class=\"pl-k\">return</span> <span class=\"pl-c1\">NotImplemented</span>\n  <span class=\"pl-k\">return</span> add_impl(<span class=\"pl-c1\">self</span>, other)</pre></div>\n<p>Or \"Let the other type try to override the operation, otherwise convert to tensor\" (I like this one better)</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-c\"><span class=\"pl-c\">#</span> needs to at least include tf.Tensor, but what other types to include would</span>\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> depend on internal implementation details.</span>\n<span class=\"pl-c1\">KNOWN_TYPES</span> <span class=\"pl-k\">=</span> (tf.Tensor, tf.Variable, <span class=\"pl-c1\">...</span>)\n\n<span class=\"pl-k\">def</span> <span class=\"pl-c1\">__add__</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>, <span class=\"pl-smi\">other</span>):\n  <span class=\"pl-c\"><span class=\"pl-c\">#</span> We need exclude known types (including type(self)) to avoid an</span>\n  <span class=\"pl-c\"><span class=\"pl-c\">#</span> infinite loop due to similar code in the implementation of Tensor.__radd__</span>\n  <span class=\"pl-k\">if</span> <span class=\"pl-k\">not</span> <span class=\"pl-c1\">isinstance</span>(other, <span class=\"pl-c1\">KNOWN_TYPES</span>):\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> defer to the other type, if it provides an implementation</span>\n    result <span class=\"pl-k\">=</span> other.<span class=\"pl-c1\">__radd__</span>(<span class=\"pl-c1\">self</span>)\n    <span class=\"pl-k\">if</span> result <span class=\"pl-k\">is</span> <span class=\"pl-k\">not</span> <span class=\"pl-c1\">NotImplemented</span>:\n      <span class=\"pl-k\">return</span> result\n  <span class=\"pl-c\"><span class=\"pl-c\">#</span> other is known or does not provide an implementation</span>\n  other <span class=\"pl-k\">=</span> ops.convert_to_tensor(other)\n  <span class=\"pl-k\">return</span> add_impl(<span class=\"pl-c1\">self</span>, other)</pre></div>", "body_text": "Let me try to provide some context around __array_priority__ as a NumPy developer. (There has actually been extensive discussion about removing it entirely going forward, but that's a whole different matter that you probably don't want to get into.)\nIt exists because NumPy has two different ways of interacting with objects of an unknown type. For example, suppose array = np.array([1, 2, 3]) and other = SomeType(). What should array + other give?\n\nIf __array_priority__ is unset or less than 1: treat the unknown type as a scalar, and apply the operation in an element-wise fashion over each element of the array, e.g., array + other -> np.array([1 + other, 2 + other, 3 + other]).\nIf __array_priority__ is greater than 1: treat the unknown type as an array, and let it try to handle the entire NumPy array, e.g., array + other -> other.__radd__(array).\n\nI don't think TensorFlow ever wants behavior (1). Hence we don't need __tensor_priority__. TensorFlow should stick to Python's default system for overriding arithmetic operations.\nSomething like one of these solutions seems like a good place to start:\n\"Try converting everything to a tensor\"\n# This is possibly not flexible enough, because you might, for example,\n# want to define a type (e.g., a tensor with physical units) that is convertible\n# to a tensor but still wants to override arithmetic.\ndef __add__(self, other):\n  try:\n    other = ops.convert_to_tensor(other)\n  except TypeError:\n    return NotImplemented\n  return add_impl(self, other)\nOr \"Let the other type try to override the operation, otherwise convert to tensor\" (I like this one better)\n# needs to at least include tf.Tensor, but what other types to include would\n# depend on internal implementation details.\nKNOWN_TYPES = (tf.Tensor, tf.Variable, ...)\n\ndef __add__(self, other):\n  # We need exclude known types (including type(self)) to avoid an\n  # infinite loop due to similar code in the implementation of Tensor.__radd__\n  if not isinstance(other, KNOWN_TYPES):\n    # defer to the other type, if it provides an implementation\n    result = other.__radd__(self)\n    if result is not NotImplemented:\n      return result\n  # other is known or does not provide an implementation\n  other = ops.convert_to_tensor(other)\n  return add_impl(self, other)", "body": "Let me try to provide some context around `__array_priority__` as a NumPy developer. (There has actually been extensive discussion about [removing it entirely](https://github.com/numpy/numpy/issues/5844) going forward, but that's a whole different matter that you probably don't want to get into.)\r\n\r\nIt exists because NumPy has two different ways of interacting with objects of an unknown type. For example, suppose `array = np.array([1, 2, 3])` and `other = SomeType()`. What should `array + other` give?\r\n\r\n1. If `__array_priority__` is unset or less than 1: treat the unknown type as a scalar, and apply the operation in an element-wise fashion over each element of the array, e.g., `array + other` -> `np.array([1 + other, 2 + other, 3 + other])`.\r\n2. If `__array_priority__` is greater than 1: treat the unknown type as an array, and let it try to handle the entire NumPy array, e.g., `array + other` -> `other.__radd__(array)`.\r\n\r\nI don't think TensorFlow *ever* wants behavior (1). Hence we don't need `__tensor_priority__`. TensorFlow should stick to Python's default system for overriding arithmetic operations.\r\n\r\nSomething like one of these solutions seems like a good place to start:\r\n\r\n\"Try converting everything to a tensor\"\r\n```python\r\n# This is possibly not flexible enough, because you might, for example,\r\n# want to define a type (e.g., a tensor with physical units) that is convertible\r\n# to a tensor but still wants to override arithmetic.\r\ndef __add__(self, other):\r\n  try:\r\n    other = ops.convert_to_tensor(other)\r\n  except TypeError:\r\n    return NotImplemented\r\n  return add_impl(self, other)\r\n```\r\n\r\nOr \"Let the other type try to override the operation, otherwise convert to tensor\" (I like this one better)\r\n```python\r\n# needs to at least include tf.Tensor, but what other types to include would\r\n# depend on internal implementation details.\r\nKNOWN_TYPES = (tf.Tensor, tf.Variable, ...)\r\n\r\ndef __add__(self, other):\r\n  # We need exclude known types (including type(self)) to avoid an\r\n  # infinite loop due to similar code in the implementation of Tensor.__radd__\r\n  if not isinstance(other, KNOWN_TYPES):\r\n    # defer to the other type, if it provides an implementation\r\n    result = other.__radd__(self)\r\n    if result is not NotImplemented:\r\n      return result\r\n  # other is known or does not provide an implementation\r\n  other = ops.convert_to_tensor(other)\r\n  return add_impl(self, other)\r\n```\r\n"}