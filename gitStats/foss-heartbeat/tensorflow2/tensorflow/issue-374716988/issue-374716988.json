{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/23322", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/23322/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/23322/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/23322/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/23322", "id": 374716988, "node_id": "MDU6SXNzdWUzNzQ3MTY5ODg=", "number": 23322, "title": "How can parse_fn be put into tf.data.map without arguments?", "user": {"login": "khle08", "id": 36943166, "node_id": "MDQ6VXNlcjM2OTQzMTY2", "avatar_url": "https://avatars3.githubusercontent.com/u/36943166?v=4", "gravatar_id": "", "url": "https://api.github.com/users/khle08", "html_url": "https://github.com/khle08", "followers_url": "https://api.github.com/users/khle08/followers", "following_url": "https://api.github.com/users/khle08/following{/other_user}", "gists_url": "https://api.github.com/users/khle08/gists{/gist_id}", "starred_url": "https://api.github.com/users/khle08/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/khle08/subscriptions", "organizations_url": "https://api.github.com/users/khle08/orgs", "repos_url": "https://api.github.com/users/khle08/repos", "events_url": "https://api.github.com/users/khle08/events{/privacy}", "received_events_url": "https://api.github.com/users/khle08/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": {"login": "harshini-gadige", "id": 42781361, "node_id": "MDQ6VXNlcjQyNzgxMzYx", "avatar_url": "https://avatars1.githubusercontent.com/u/42781361?v=4", "gravatar_id": "", "url": "https://api.github.com/users/harshini-gadige", "html_url": "https://github.com/harshini-gadige", "followers_url": "https://api.github.com/users/harshini-gadige/followers", "following_url": "https://api.github.com/users/harshini-gadige/following{/other_user}", "gists_url": "https://api.github.com/users/harshini-gadige/gists{/gist_id}", "starred_url": "https://api.github.com/users/harshini-gadige/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/harshini-gadige/subscriptions", "organizations_url": "https://api.github.com/users/harshini-gadige/orgs", "repos_url": "https://api.github.com/users/harshini-gadige/repos", "events_url": "https://api.github.com/users/harshini-gadige/events{/privacy}", "received_events_url": "https://api.github.com/users/harshini-gadige/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "harshini-gadige", "id": 42781361, "node_id": "MDQ6VXNlcjQyNzgxMzYx", "avatar_url": "https://avatars1.githubusercontent.com/u/42781361?v=4", "gravatar_id": "", "url": "https://api.github.com/users/harshini-gadige", "html_url": "https://github.com/harshini-gadige", "followers_url": "https://api.github.com/users/harshini-gadige/followers", "following_url": "https://api.github.com/users/harshini-gadige/following{/other_user}", "gists_url": "https://api.github.com/users/harshini-gadige/gists{/gist_id}", "starred_url": "https://api.github.com/users/harshini-gadige/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/harshini-gadige/subscriptions", "organizations_url": "https://api.github.com/users/harshini-gadige/orgs", "repos_url": "https://api.github.com/users/harshini-gadige/repos", "events_url": "https://api.github.com/users/harshini-gadige/events{/privacy}", "received_events_url": "https://api.github.com/users/harshini-gadige/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 1, "created_at": "2018-10-28T04:47:35Z", "updated_at": "2018-10-29T21:33:08Z", "closed_at": "2018-10-29T21:33:08Z", "author_association": "NONE", "body_html": "<p><strong>System information</strong></p>\n<ul>\n<li>TensorFlow version: 1.10.1</li>\n</ul>\n<p><strong>Describe the documentation issue</strong><br>\nI am familiar with parsing tfrecord back to tensor without using tf.data API. And now I'm trying to use this API to construct a more robust pipeline. The code goes like this:<br>\n`def parse_fn(serialized):<br>\nfeatures = {<br>\n'image': tf.FixedLenFeature([], tf.string),<br>\n'label': tf.FixedLenFeature([], tf.int64)<br>\n}<br>\nparse_exp = tf.parse_single_example(serialized=serialized, features=features)<br>\ndata = parse_exp['image']<br>\ndata = tf.decode_raw(data, tf.uint8)<br>\ndata = tf.cast(data, tf.float32)<br>\nreturn data, parse_exp['label']</p>\n<p>def input_fn(data_list, batch_size=32, shuffle_size=1024, prefetch_size=2):<br>\nfiles = tf.data.Dataset.list_files(data_list)<br>\ndataset = files.interleave(tf.data.TFRecordDataset)<br>\ndataset = dataset.shuffle(buffer_size=shuffle_size)<br>\ndataset = dataset.repeat()<br>\ndataset = dataset.map(parse_fn, num_parallel_calls=4)<br>\ndataset = dataset.batch(batch_size)<br>\ndataset = dataset.prefetch(buffer_size=prefetch_size)<br>\niterator = dataset.make_one_shot_iterator()<br>\nimages_batch, labels_batch = iterator.get_next()<br>\nreturn {'image': images_batch}, labels_batch`</p>\n<p>But based on my knowledge, tfrecord file is a protocol buffer file containing binary data. So here are my 2 consecutive questions...</p>\n<ol>\n<li>How can tf know which part and which part should be shuffled before parse the file into tf datatype?</li>\n<li>How can the parse_fn function be substituted into map func without argument? where will the 'serialized' argument come from? What if I want to add more arguments to parse_fn, what can I do?</li>\n</ol>\n<p>Lastly, in this case I use 'label' as the int64List dict name to store data into tfrecord so that I can extract the corresponding data using key 'label' here again. But why I didn't get error when I use the other name as the key in order to get data? This makes me feel weird because when I was using TFRecordReader.read() to extract binary data, it is pretty sensitive that I should use exactly the same key name so that there would be no errors.</p>", "body_text": "System information\n\nTensorFlow version: 1.10.1\n\nDescribe the documentation issue\nI am familiar with parsing tfrecord back to tensor without using tf.data API. And now I'm trying to use this API to construct a more robust pipeline. The code goes like this:\n`def parse_fn(serialized):\nfeatures = {\n'image': tf.FixedLenFeature([], tf.string),\n'label': tf.FixedLenFeature([], tf.int64)\n}\nparse_exp = tf.parse_single_example(serialized=serialized, features=features)\ndata = parse_exp['image']\ndata = tf.decode_raw(data, tf.uint8)\ndata = tf.cast(data, tf.float32)\nreturn data, parse_exp['label']\ndef input_fn(data_list, batch_size=32, shuffle_size=1024, prefetch_size=2):\nfiles = tf.data.Dataset.list_files(data_list)\ndataset = files.interleave(tf.data.TFRecordDataset)\ndataset = dataset.shuffle(buffer_size=shuffle_size)\ndataset = dataset.repeat()\ndataset = dataset.map(parse_fn, num_parallel_calls=4)\ndataset = dataset.batch(batch_size)\ndataset = dataset.prefetch(buffer_size=prefetch_size)\niterator = dataset.make_one_shot_iterator()\nimages_batch, labels_batch = iterator.get_next()\nreturn {'image': images_batch}, labels_batch`\nBut based on my knowledge, tfrecord file is a protocol buffer file containing binary data. So here are my 2 consecutive questions...\n\nHow can tf know which part and which part should be shuffled before parse the file into tf datatype?\nHow can the parse_fn function be substituted into map func without argument? where will the 'serialized' argument come from? What if I want to add more arguments to parse_fn, what can I do?\n\nLastly, in this case I use 'label' as the int64List dict name to store data into tfrecord so that I can extract the corresponding data using key 'label' here again. But why I didn't get error when I use the other name as the key in order to get data? This makes me feel weird because when I was using TFRecordReader.read() to extract binary data, it is pretty sensitive that I should use exactly the same key name so that there would be no errors.", "body": "**System information**\r\n- TensorFlow version: 1.10.1\r\n\r\n**Describe the documentation issue**\r\nI am familiar with parsing tfrecord back to tensor without using tf.data API. And now I'm trying to use this API to construct a more robust pipeline. The code goes like this:\r\n`def parse_fn(serialized):\r\n    features = {\r\n        'image': tf.FixedLenFeature([], tf.string),\r\n        'label': tf.FixedLenFeature([], tf.int64)\r\n    }\r\n    parse_exp = tf.parse_single_example(serialized=serialized, features=features)\r\n    data = parse_exp['image']\r\n    data = tf.decode_raw(data, tf.uint8)\r\n    data = tf.cast(data, tf.float32)\r\n    return data, parse_exp['label']\r\n\r\n\r\ndef input_fn(data_list, batch_size=32, shuffle_size=1024, prefetch_size=2):\r\n    files = tf.data.Dataset.list_files(data_list)\r\n    dataset = files.interleave(tf.data.TFRecordDataset)\r\n    dataset = dataset.shuffle(buffer_size=shuffle_size)\r\n    dataset = dataset.repeat()\r\n    dataset = dataset.map(parse_fn, num_parallel_calls=4)\r\n    dataset = dataset.batch(batch_size)\r\n    dataset = dataset.prefetch(buffer_size=prefetch_size)\r\n    iterator = dataset.make_one_shot_iterator()\r\n    images_batch, labels_batch = iterator.get_next()\r\n    return {'image': images_batch}, labels_batch`\r\n\r\nBut based on my knowledge, tfrecord file is a protocol buffer file containing binary data. So here are my 2 consecutive questions...\r\n1. How can tf know which part and which part should be shuffled before parse the file into tf datatype? \r\n2. How can the parse_fn function be substituted into map func without argument? where will the 'serialized' argument come from? What if I want to add more arguments to parse_fn, what can I do?\r\n\r\nLastly, in this case I use 'label' as the int64List dict name to store data into tfrecord so that I can extract the corresponding data using key 'label' here again. But why I didn't get error when I use the other name as the key in order to get data? This makes me feel weird because when I was using TFRecordReader.read() to extract binary data, it is pretty sensitive that I should use exactly the same key name so that there would be no errors."}