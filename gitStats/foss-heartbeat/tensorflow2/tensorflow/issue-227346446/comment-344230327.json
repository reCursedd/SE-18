{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/344230327", "html_url": "https://github.com/tensorflow/tensorflow/pull/9792#issuecomment-344230327", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9792", "id": 344230327, "node_id": "MDEyOklzc3VlQ29tbWVudDM0NDIzMDMyNw==", "user": {"login": "wodesuck", "id": 3124581, "node_id": "MDQ6VXNlcjMxMjQ1ODE=", "avatar_url": "https://avatars2.githubusercontent.com/u/3124581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wodesuck", "html_url": "https://github.com/wodesuck", "followers_url": "https://api.github.com/users/wodesuck/followers", "following_url": "https://api.github.com/users/wodesuck/following{/other_user}", "gists_url": "https://api.github.com/users/wodesuck/gists{/gist_id}", "starred_url": "https://api.github.com/users/wodesuck/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wodesuck/subscriptions", "organizations_url": "https://api.github.com/users/wodesuck/orgs", "repos_url": "https://api.github.com/users/wodesuck/repos", "events_url": "https://api.github.com/users/wodesuck/events{/privacy}", "received_events_url": "https://api.github.com/users/wodesuck/received_events", "type": "User", "site_admin": false}, "created_at": "2017-11-14T11:29:24Z", "updated_at": "2017-11-14T11:29:24Z", "author_association": "CONTRIBUTOR", "body_html": "<p>In <code>tensorflow/core/kernels/quantize_op.cc</code>, add few lines as below:</p>\n<pre><code>  void Compute(OpKernelContext* ctx) override {\n    const Tensor&amp; input = ctx-&gt;input(0);\n    const float input_min_range = ctx-&gt;input(1).flat&lt;float&gt;()(0);\n    const float input_max_range = ctx-&gt;input(2).flat&lt;float&gt;()(0);\n\n    if (input.NumElements() == 0) {\n      Tensor* output = nullptr;\n      OP_REQUIRES_OK(ctx, ctx-&gt;allocate_output(0, input.shape(), &amp;output));\n\n      Tensor* output_min_tensor = nullptr;\n      OP_REQUIRES_OK(ctx, ctx-&gt;allocate_output(1, {}, &amp;output_min_tensor));\n      output_min_tensor-&gt;flat&lt;float&gt;()(0) = 0.0;\n\n      Tensor* output_max_tensor = nullptr;\n      OP_REQUIRES_OK(ctx, ctx-&gt;allocate_output(2, {}, &amp;output_max_tensor));\n      output_max_tensor-&gt;flat&lt;float&gt;()(0) = 1.0;\n\n      return;\n    }\n\n    float min_range;\n    float max_range;\n    OP_REQUIRES(ctx, !(input_max_range &lt; input_min_range),\n                errors::InvalidArgument(\n                    \"input_max_range must be larger than input_min_range.\"));\n</code></pre>\n<p>It just detect whether input is empty or not, if yes, just set <code>min = 0.0, max = 1.0</code>. (for it's empty, the value of minmax may not matter, I think)</p>", "body_text": "In tensorflow/core/kernels/quantize_op.cc, add few lines as below:\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor& input = ctx->input(0);\n    const float input_min_range = ctx->input(1).flat<float>()(0);\n    const float input_max_range = ctx->input(2).flat<float>()(0);\n\n    if (input.NumElements() == 0) {\n      Tensor* output = nullptr;\n      OP_REQUIRES_OK(ctx, ctx->allocate_output(0, input.shape(), &output));\n\n      Tensor* output_min_tensor = nullptr;\n      OP_REQUIRES_OK(ctx, ctx->allocate_output(1, {}, &output_min_tensor));\n      output_min_tensor->flat<float>()(0) = 0.0;\n\n      Tensor* output_max_tensor = nullptr;\n      OP_REQUIRES_OK(ctx, ctx->allocate_output(2, {}, &output_max_tensor));\n      output_max_tensor->flat<float>()(0) = 1.0;\n\n      return;\n    }\n\n    float min_range;\n    float max_range;\n    OP_REQUIRES(ctx, !(input_max_range < input_min_range),\n                errors::InvalidArgument(\n                    \"input_max_range must be larger than input_min_range.\"));\n\nIt just detect whether input is empty or not, if yes, just set min = 0.0, max = 1.0. (for it's empty, the value of minmax may not matter, I think)", "body": "In `tensorflow/core/kernels/quantize_op.cc`, add few lines as below:\r\n\r\n```\r\n  void Compute(OpKernelContext* ctx) override {\r\n    const Tensor& input = ctx->input(0);\r\n    const float input_min_range = ctx->input(1).flat<float>()(0);\r\n    const float input_max_range = ctx->input(2).flat<float>()(0);\r\n\r\n    if (input.NumElements() == 0) {\r\n      Tensor* output = nullptr;\r\n      OP_REQUIRES_OK(ctx, ctx->allocate_output(0, input.shape(), &output));\r\n\r\n      Tensor* output_min_tensor = nullptr;\r\n      OP_REQUIRES_OK(ctx, ctx->allocate_output(1, {}, &output_min_tensor));\r\n      output_min_tensor->flat<float>()(0) = 0.0;\r\n\r\n      Tensor* output_max_tensor = nullptr;\r\n      OP_REQUIRES_OK(ctx, ctx->allocate_output(2, {}, &output_max_tensor));\r\n      output_max_tensor->flat<float>()(0) = 1.0;\r\n\r\n      return;\r\n    }\r\n\r\n    float min_range;\r\n    float max_range;\r\n    OP_REQUIRES(ctx, !(input_max_range < input_min_range),\r\n                errors::InvalidArgument(\r\n                    \"input_max_range must be larger than input_min_range.\"));\r\n```\r\n\r\nIt just detect whether input is empty or not, if yes, just set `min = 0.0, max = 1.0`. (for it's empty, the value of minmax may not matter, I think)"}