{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11403", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11403/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11403/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11403/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/11403", "id": 241589715, "node_id": "MDU6SXNzdWUyNDE1ODk3MTU=", "number": 11403, "title": "Feature request: explicit state interfaces", "user": {"login": "netheril96", "id": 836839, "node_id": "MDQ6VXNlcjgzNjgzOQ==", "avatar_url": "https://avatars1.githubusercontent.com/u/836839?v=4", "gravatar_id": "", "url": "https://api.github.com/users/netheril96", "html_url": "https://github.com/netheril96", "followers_url": "https://api.github.com/users/netheril96/followers", "following_url": "https://api.github.com/users/netheril96/following{/other_user}", "gists_url": "https://api.github.com/users/netheril96/gists{/gist_id}", "starred_url": "https://api.github.com/users/netheril96/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/netheril96/subscriptions", "organizations_url": "https://api.github.com/users/netheril96/orgs", "repos_url": "https://api.github.com/users/netheril96/repos", "events_url": "https://api.github.com/users/netheril96/events{/privacy}", "received_events_url": "https://api.github.com/users/netheril96/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2017-07-10T03:24:41Z", "updated_at": "2017-07-13T00:06:43Z", "closed_at": "2017-07-13T00:06:43Z", "author_association": "NONE", "body_html": "<h3>System information</h3>\n<ul>\n<li><strong>Have I written custom code (as opposed to using a stock example script provided in TensorFlow)</strong>: Yes</li>\n<li><strong>OS Platform and Distribution (e.g., Linux Ubuntu 16.04)</strong>: Ubuntu 14.04</li>\n<li><strong>TensorFlow installed from (source or binary)</strong>: source</li>\n<li><strong>TensorFlow version (use command below)</strong>: 1.2.0</li>\n<li><strong>Python version</strong>: 2.7.12</li>\n</ul>\n<h3>Description:</h3>\n<p>The current API is immensely stateful. Each function and object creation affects and is affected by countless mutable global states. Running a declaration of <code>Variable</code> or summary mutates the graph and collections and may return different results based on the current <code>NameScope</code> or <code>VariableScope</code> or <code>control_dependencies</code>. A function running twice can easily return wildly different result, even though it <em>looks</em> pure (but it isn't because almost no tensorflow function is pure). Declaring something and then deleting it won't restore the global state, as it may or may not be added somewhere in the graph or the collections or some other hidden objects. Reasoning about what changes what is incredibly difficult.</p>\n<p>What I would like to see is a API where all state mutations are explicit. When I declare a variable, it is just a variable, and not added to anything unless I call <code>add</code>. The current entangled interfaces can be built on top of that, preserving convenience functions such as <code>global_variable_initializers</code> for those who prefer.</p>", "body_text": "System information\n\nHave I written custom code (as opposed to using a stock example script provided in TensorFlow): Yes\nOS Platform and Distribution (e.g., Linux Ubuntu 16.04): Ubuntu 14.04\nTensorFlow installed from (source or binary): source\nTensorFlow version (use command below): 1.2.0\nPython version: 2.7.12\n\nDescription:\nThe current API is immensely stateful. Each function and object creation affects and is affected by countless mutable global states. Running a declaration of Variable or summary mutates the graph and collections and may return different results based on the current NameScope or VariableScope or control_dependencies. A function running twice can easily return wildly different result, even though it looks pure (but it isn't because almost no tensorflow function is pure). Declaring something and then deleting it won't restore the global state, as it may or may not be added somewhere in the graph or the collections or some other hidden objects. Reasoning about what changes what is incredibly difficult.\nWhat I would like to see is a API where all state mutations are explicit. When I declare a variable, it is just a variable, and not added to anything unless I call add. The current entangled interfaces can be built on top of that, preserving convenience functions such as global_variable_initializers for those who prefer.", "body": "### System information\r\n- **Have I written custom code (as opposed to using a stock example script provided in TensorFlow)**: Yes\r\n- **OS Platform and Distribution (e.g., Linux Ubuntu 16.04)**: Ubuntu 14.04\r\n- **TensorFlow installed from (source or binary)**: source \r\n- **TensorFlow version (use command below)**: 1.2.0\r\n- **Python version**: 2.7.12\r\n \r\n### Description:\r\n\r\nThe current API is immensely stateful. Each function and object creation affects and is affected by countless mutable global states. Running a declaration of `Variable` or summary mutates the graph and collections and may return different results based on the current `NameScope` or `VariableScope` or `control_dependencies`. A function running twice can easily return wildly different result, even though it *looks* pure (but it isn't because almost no tensorflow function is pure). Declaring something and then deleting it won't restore the global state, as it may or may not be added somewhere in the graph or the collections or some other hidden objects. Reasoning about what changes what is incredibly difficult.\r\n\r\nWhat I would like to see is a API where all state mutations are explicit. When I declare a variable, it is just a variable, and not added to anything unless I call `add`. The current entangled interfaces can be built on top of that, preserving convenience functions such as `global_variable_initializers` for those who prefer."}