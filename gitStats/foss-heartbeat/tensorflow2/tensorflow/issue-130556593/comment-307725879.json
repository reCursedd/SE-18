{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/307725879", "html_url": "https://github.com/tensorflow/tensorflow/issues/956#issuecomment-307725879", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/956", "id": 307725879, "node_id": "MDEyOklzc3VlQ29tbWVudDMwNzcyNTg3OQ==", "user": {"login": "FedericoMuciaccia", "id": 16505346, "node_id": "MDQ6VXNlcjE2NTA1MzQ2", "avatar_url": "https://avatars3.githubusercontent.com/u/16505346?v=4", "gravatar_id": "", "url": "https://api.github.com/users/FedericoMuciaccia", "html_url": "https://github.com/FedericoMuciaccia", "followers_url": "https://api.github.com/users/FedericoMuciaccia/followers", "following_url": "https://api.github.com/users/FedericoMuciaccia/following{/other_user}", "gists_url": "https://api.github.com/users/FedericoMuciaccia/gists{/gist_id}", "starred_url": "https://api.github.com/users/FedericoMuciaccia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/FedericoMuciaccia/subscriptions", "organizations_url": "https://api.github.com/users/FedericoMuciaccia/orgs", "repos_url": "https://api.github.com/users/FedericoMuciaccia/repos", "events_url": "https://api.github.com/users/FedericoMuciaccia/events{/privacy}", "received_events_url": "https://api.github.com/users/FedericoMuciaccia/received_events", "type": "User", "site_admin": false}, "created_at": "2017-06-12T08:39:57Z", "updated_at": "2017-06-12T08:39:57Z", "author_association": "NONE", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=24493073\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/YuanmanLi\">@YuanmanLi</a> here are two ways to possibly implement this. the first one is way simpler, faster and memory efficient:</p>\n<pre><code>import tensorflow as tf\n\ndef periodic_padding(image, padding=1):\n    '''\n    Create a periodic padding (wrap) around the image, to emulate periodic boundary conditions\n    '''\n    \n    upper_pad = image[-padding:,:]\n    lower_pad = image[:padding,:]\n    \n    partial_image = tf.concat([upper_pad, image, lower_pad], axis=0)\n    \n    left_pad = partial_image[:,-padding:]\n    right_pad = partial_image[:,:padding]\n    \n    padded_image = tf.concat([left_pad, partial_image, right_pad], axis=1)\n    \n    return padded_image\n\n# usage example:\nsession = tf.InteractiveSession()\nimage = tf.reshape(tf.range(30, dtype='float32'), shape=[5,6])\npadded_image = periodic_padding(image, padding=2)\nimage.eval()\npadded_image.eval()\n</code></pre>\n<p>the second one is more complex, and slower, because it requires a lot of calculations. but here the padding is done via matrix multiplication (with fixed auxiliary matrices), so in principle I think that this implementation could be used to exploit end-to-end differentiation</p>\n<pre><code>import tensorflow as tf\n\ndef periodic_padding(image, padding=1):\n    '''\n    Create a periodic padding (wrap) around the image, to emulate periodic boundary conditions\n    '''\n\n    rows, columns = image.shape\n    \n    # create left matrix\n    left_corner_diagonal = tf.eye(padding)\n    left_filled_zeros = tf.zeros([padding,rows.value-padding])\n    \n    left_upper = tf.concat([left_filled_zeros, left_corner_diagonal], axis=1)\n    left_center_diagonal = tf.eye(rows.value)\n    left_lower = tf.concat([left_corner_diagonal,left_filled_zeros], axis=1)\n    \n    left_matrix = tf.concat([left_upper, left_center_diagonal, left_lower], axis=0)\n    \n    # create right matrix\n    right_corner_diagonal = tf.eye(padding)\n    right_filled_zeros = tf.zeros([columns.value-padding,padding])\n    \n    right_left_side = tf.concat([right_filled_zeros, right_corner_diagonal], axis=0)\n    right_center_diagonal = tf.eye(columns.value)\n    right_right_side = tf.concat([right_corner_diagonal,right_filled_zeros], axis=0)\n    \n    right_matrix = tf.concat([right_left_side, right_center_diagonal, right_right_side], axis=1)\n    \n    # left and right matrices are immutable\n    padded_image = tf.matmul(left_matrix, tf.matmul(image, right_matrix))\n\n    return padded_image\n\n# usage example:\nsession = tf.InteractiveSession()\n# left and right matrices are immutable, given a fixed image shape\nimage = tf.reshape(tf.range(30, dtype='float32'), shape=[5,6])\npadded_image = periodic_padding(image, padding=2)\nimage.eval()\npadded_image.eval()\n</code></pre>\n<p>is there any tensorflower willing to expand this sketch of code to implement the wrap padding in the next official release?</p>", "body_text": "@YuanmanLi here are two ways to possibly implement this. the first one is way simpler, faster and memory efficient:\nimport tensorflow as tf\n\ndef periodic_padding(image, padding=1):\n    '''\n    Create a periodic padding (wrap) around the image, to emulate periodic boundary conditions\n    '''\n    \n    upper_pad = image[-padding:,:]\n    lower_pad = image[:padding,:]\n    \n    partial_image = tf.concat([upper_pad, image, lower_pad], axis=0)\n    \n    left_pad = partial_image[:,-padding:]\n    right_pad = partial_image[:,:padding]\n    \n    padded_image = tf.concat([left_pad, partial_image, right_pad], axis=1)\n    \n    return padded_image\n\n# usage example:\nsession = tf.InteractiveSession()\nimage = tf.reshape(tf.range(30, dtype='float32'), shape=[5,6])\npadded_image = periodic_padding(image, padding=2)\nimage.eval()\npadded_image.eval()\n\nthe second one is more complex, and slower, because it requires a lot of calculations. but here the padding is done via matrix multiplication (with fixed auxiliary matrices), so in principle I think that this implementation could be used to exploit end-to-end differentiation\nimport tensorflow as tf\n\ndef periodic_padding(image, padding=1):\n    '''\n    Create a periodic padding (wrap) around the image, to emulate periodic boundary conditions\n    '''\n\n    rows, columns = image.shape\n    \n    # create left matrix\n    left_corner_diagonal = tf.eye(padding)\n    left_filled_zeros = tf.zeros([padding,rows.value-padding])\n    \n    left_upper = tf.concat([left_filled_zeros, left_corner_diagonal], axis=1)\n    left_center_diagonal = tf.eye(rows.value)\n    left_lower = tf.concat([left_corner_diagonal,left_filled_zeros], axis=1)\n    \n    left_matrix = tf.concat([left_upper, left_center_diagonal, left_lower], axis=0)\n    \n    # create right matrix\n    right_corner_diagonal = tf.eye(padding)\n    right_filled_zeros = tf.zeros([columns.value-padding,padding])\n    \n    right_left_side = tf.concat([right_filled_zeros, right_corner_diagonal], axis=0)\n    right_center_diagonal = tf.eye(columns.value)\n    right_right_side = tf.concat([right_corner_diagonal,right_filled_zeros], axis=0)\n    \n    right_matrix = tf.concat([right_left_side, right_center_diagonal, right_right_side], axis=1)\n    \n    # left and right matrices are immutable\n    padded_image = tf.matmul(left_matrix, tf.matmul(image, right_matrix))\n\n    return padded_image\n\n# usage example:\nsession = tf.InteractiveSession()\n# left and right matrices are immutable, given a fixed image shape\nimage = tf.reshape(tf.range(30, dtype='float32'), shape=[5,6])\npadded_image = periodic_padding(image, padding=2)\nimage.eval()\npadded_image.eval()\n\nis there any tensorflower willing to expand this sketch of code to implement the wrap padding in the next official release?", "body": "@YuanmanLi here are two ways to possibly implement this. the first one is way simpler, faster and memory efficient:\r\n\r\n```\r\nimport tensorflow as tf\r\n\r\ndef periodic_padding(image, padding=1):\r\n    '''\r\n    Create a periodic padding (wrap) around the image, to emulate periodic boundary conditions\r\n    '''\r\n    \r\n    upper_pad = image[-padding:,:]\r\n    lower_pad = image[:padding,:]\r\n    \r\n    partial_image = tf.concat([upper_pad, image, lower_pad], axis=0)\r\n    \r\n    left_pad = partial_image[:,-padding:]\r\n    right_pad = partial_image[:,:padding]\r\n    \r\n    padded_image = tf.concat([left_pad, partial_image, right_pad], axis=1)\r\n    \r\n    return padded_image\r\n\r\n# usage example:\r\nsession = tf.InteractiveSession()\r\nimage = tf.reshape(tf.range(30, dtype='float32'), shape=[5,6])\r\npadded_image = periodic_padding(image, padding=2)\r\nimage.eval()\r\npadded_image.eval()\r\n```\r\n\r\nthe second one is more complex, and slower, because it requires a lot of calculations. but here the padding is done via matrix multiplication (with fixed auxiliary matrices), so in principle I think that this implementation could be used to exploit end-to-end differentiation\r\n\r\n```\r\nimport tensorflow as tf\r\n\r\ndef periodic_padding(image, padding=1):\r\n    '''\r\n    Create a periodic padding (wrap) around the image, to emulate periodic boundary conditions\r\n    '''\r\n\r\n    rows, columns = image.shape\r\n    \r\n    # create left matrix\r\n    left_corner_diagonal = tf.eye(padding)\r\n    left_filled_zeros = tf.zeros([padding,rows.value-padding])\r\n    \r\n    left_upper = tf.concat([left_filled_zeros, left_corner_diagonal], axis=1)\r\n    left_center_diagonal = tf.eye(rows.value)\r\n    left_lower = tf.concat([left_corner_diagonal,left_filled_zeros], axis=1)\r\n    \r\n    left_matrix = tf.concat([left_upper, left_center_diagonal, left_lower], axis=0)\r\n    \r\n    # create right matrix\r\n    right_corner_diagonal = tf.eye(padding)\r\n    right_filled_zeros = tf.zeros([columns.value-padding,padding])\r\n    \r\n    right_left_side = tf.concat([right_filled_zeros, right_corner_diagonal], axis=0)\r\n    right_center_diagonal = tf.eye(columns.value)\r\n    right_right_side = tf.concat([right_corner_diagonal,right_filled_zeros], axis=0)\r\n    \r\n    right_matrix = tf.concat([right_left_side, right_center_diagonal, right_right_side], axis=1)\r\n    \r\n    # left and right matrices are immutable\r\n    padded_image = tf.matmul(left_matrix, tf.matmul(image, right_matrix))\r\n\r\n    return padded_image\r\n\r\n# usage example:\r\nsession = tf.InteractiveSession()\r\n# left and right matrices are immutable, given a fixed image shape\r\nimage = tf.reshape(tf.range(30, dtype='float32'), shape=[5,6])\r\npadded_image = periodic_padding(image, padding=2)\r\nimage.eval()\r\npadded_image.eval()\r\n```\r\n\r\nis there any tensorflower willing to expand this sketch of code to implement the wrap padding in the next official release?"}