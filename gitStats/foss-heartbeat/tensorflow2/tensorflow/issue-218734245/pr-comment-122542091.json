{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/122542091", "pull_request_review_id": 44636482, "id": 122542091, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEyMjU0MjA5MQ==", "diff_hunk": "@@ -29,73 +32,155 @@ class FixedLengthRecordReader : public ReaderBase {\n  public:\n   FixedLengthRecordReader(const string& node_name, int64 header_bytes,\n                           int64 record_bytes, int64 footer_bytes,\n-                          int64 hop_bytes, Env* env)\n+                          int64 hop_bytes, const string& encoding, Env* env)\n       : ReaderBase(\n             strings::StrCat(\"FixedLengthRecordReader '\", node_name, \"'\")),\n         header_bytes_(header_bytes),\n         record_bytes_(record_bytes),\n         footer_bytes_(footer_bytes),\n         hop_bytes_(hop_bytes),\n         env_(env),\n-        file_pos_limit_(-1),\n-        record_number_(0) {}\n+        record_number_(0),\n+        encoding_(encoding) {}\n \n   // On success:\n-  // * input_buffer_ != nullptr,\n-  // * input_buffer_->Tell() == header_bytes_\n-  // * file_pos_limit_ == file size - footer_bytes_\n+  // * buffered_inputstream_ != nullptr,\n+  // * buffered_inputstream_->Tell() == header_bytes_\n   Status OnWorkStartedLocked() override {\n     record_number_ = 0;\n-    uint64 file_size = 0;\n-    TF_RETURN_IF_ERROR(env_->GetFileSize(current_work(), &file_size));\n-    file_pos_limit_ = file_size - footer_bytes_;\n+\n+    lookahead_cache_.clear();\n \n     TF_RETURN_IF_ERROR(env_->NewRandomAccessFile(current_work(), &file_));\n+    if (encoding_ == \"ZLIB\" || encoding_ == \"GZIP\") {\n+      const io::ZlibCompressionOptions zlib_options =\n+          encoding_ == \"ZLIB\" ? io::ZlibCompressionOptions::DEFAULT()\n+                              : io::ZlibCompressionOptions::GZIP();\n+      file_stream_.reset(new io::RandomAccessInputStream(file_.get()));\n+      buffered_inputstream_.reset(\n+          new io::ZlibInputStream(file_stream_.get(), (size_t)kBufferSize,\n+                                  (size_t)kBufferSize, zlib_options));\n+    } else {\n+      buffered_inputstream_.reset(\n+          new io::BufferedInputStream(file_.get(), kBufferSize));\n+    }\n+    TF_RETURN_IF_ERROR(buffered_inputstream_->SkipNBytes(header_bytes_));\n+\n+    // In case hop_bytes_ is in between 0 and record_bytes_,\n+    // we will need to hold a cache so that later on we could prefix the cache\n+    // with the remaining data to read:\n+    // For example, assume record_bytes is 2 and hop_bytes is 1,\n+    // and header_bytes is 1,\n+    // For file \"H123\",\n+    // We will process the data in the following way:\n+    // 1. Read hop_bytes of 1 (\"1\") and save it in hop cache.\n+    // 2. Read record_bytes - hop_bytes = 1 (\"2\")\n+    // 3. Prefix data in 2. with hop cache in one, we have \"12\",\n+    //    this is used for the record.\n+    // 4. Shift hop_bytes of 1 from the record, and we put \"2\" to hop cache.\n+    // 5. Continue step 2.\n+    // In order to acheive the above, we will peek in \"record_bytes_ -\n+    // hop_bytes_\"\n+    // before we read the first record.\n+\n+    // Even if the num_records=0, the footer_bytes_ has to exist:\n+    TF_RETURN_IF_ERROR(\n+        buffered_inputstream_->ReadNBytes(footer_bytes_, &lookahead_cache_));\n \n-    input_buffer_.reset(new io::InputBuffer(file_.get(), kBufferSize));\n-    TF_RETURN_IF_ERROR(input_buffer_->SkipNBytes(header_bytes_));\n     return Status::OK();\n   }\n \n   Status OnWorkFinishedLocked() override {\n-    input_buffer_.reset(nullptr);\n+    buffered_inputstream_.reset(nullptr);\n     return Status::OK();\n   }\n \n   Status ReadLocked(string* key, string* value, bool* produced,\n                     bool* at_end) override {\n-    // The condition `input_buffer_->Tell() + record_bytes_ > file_pos_limit_`\n-    // is to confirm that none of record bytes is out of the range of\n-    // file_pos_limit_.\n-    // This is necessary for the condition `hop_bytes > 0`. For example.\n-    // File: \"0123456\"\n-    // Reader setting: `record_bytes=3`, `hop_bytes=2`, `footer_bytes=0`,\n-    //     `header_bytes=0`\n-    // Without this checking condition, the forth time the reader will at\n-    // this position: \"012345|6\" and the reading operation will result in\n-    // an error.\n-    if (input_buffer_->Tell() >= file_pos_limit_ ||\n-        input_buffer_->Tell() + record_bytes_ > file_pos_limit_) {\n+    // In case hop_bytes_ is in between 0 and record_bytes_,\n+    // we will need to hold a cache so that later on we could prefix the cache\n+    // with the remaining data to read:\n+    // For example, assume record_bytes is 2 and hop_bytes is 1,\n+    // and header_bytes is 1,\n+    // For file \"H123\",\n+    // We will process the data in the following way:\n+    // 1. Read hop_bytes of 1 (\"1\") and save it in hop cache.\n+    // 2. Read record_bytes - hop_bytes = 1 (\"2\")\n+    // 3. Prefix data in 2. with hop cache in one, we have \"12\",\n+    //    this is used for the record.\n+    // 4. Shift hop_bytes of 1 from the record, and we put \"2\" to hop cache.\n+    // 5. Continue step 2.\n+    // In order to acheive the above, in the following only\n+    // 'record_bytes_ - lookahead_cache_.size()' needs to be read. The\n+    // lookahead_cache_\n+    // is then prefixed to piece together the whole record.\n+\n+    if (record_number_ == 0) {\n+      // we will peek in \"record_bytes_ - hop_bytes_\"\n+      // before we read the first record.\n+      // Note lookahead_cache_ should have hold footer_bytes_ in starup\n+      if (0 < hop_bytes_ && hop_bytes_ < record_bytes_) {\n+        int bytes_to_read = record_bytes_ - hop_bytes_;\n+        Status s = buffered_inputstream_->ReadNBytes(bytes_to_read, value);\n+        if (!s.ok() && !errors::IsOutOfRange(s)) {\n+          return s;\n+        }\n+\n+        // EOF reached\n+        if (value->size() == 0) {\n+          *at_end = true;\n+          return Status::OK();\n+        }\n+        // Now\n+        lookahead_cache_.append(*value, 0, bytes_to_read);\n+        value->clear();\n+      }\n+    }\n+\n+    int bytes_to_read = record_bytes_;\n+    if (0 < hop_bytes_) {", "path": "tensorflow/core/kernels/fixed_length_record_reader_op.cc", "position": null, "original_position": 146, "commit_id": "58c7ad730e58a411864bd5b2d24df0a2d2aabc5b", "original_commit_id": "048046f9fea949db5acd029906123b89babd3ee4", "user": {"login": "saxenasaurabh", "id": 3967488, "node_id": "MDQ6VXNlcjM5Njc0ODg=", "avatar_url": "https://avatars0.githubusercontent.com/u/3967488?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saxenasaurabh", "html_url": "https://github.com/saxenasaurabh", "followers_url": "https://api.github.com/users/saxenasaurabh/followers", "following_url": "https://api.github.com/users/saxenasaurabh/following{/other_user}", "gists_url": "https://api.github.com/users/saxenasaurabh/gists{/gist_id}", "starred_url": "https://api.github.com/users/saxenasaurabh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saxenasaurabh/subscriptions", "organizations_url": "https://api.github.com/users/saxenasaurabh/orgs", "repos_url": "https://api.github.com/users/saxenasaurabh/repos", "events_url": "https://api.github.com/users/saxenasaurabh/events{/privacy}", "received_events_url": "https://api.github.com/users/saxenasaurabh/received_events", "type": "User", "site_admin": false}, "body": "I know this has a lot of corner cases. Here's one suggestion for a simpler mental model:\r\n\r\nIn the constructor, set `hop_bytes_ = record_bytes_` if `hop_bytes_ == 0`. So now `hop_bytes_` is always > 0.\r\n\r\nRemove the `buffered_inputstream_->ReadNBytes(footer_bytes_, &lookahead_cache_)` from `OnWorkStarted`.\r\n\r\nIn `ReadLocked`\r\n\r\n1. Skip past `hop_bytes_` if not reading first record.\r\n```cpp\r\nif (record_number_ != 0) {\r\n  if (hop_bytes_ <= lookahead_cache_.size()) {\r\n    lookahead_cache_ = lookahead_cache_.substr(hop_bytes_);\r\n  } else {\r\n    int64 cache_size = lookahead_cache_.size();\r\n    lookahead_cache_.clear();\r\n    Status s = buffered_inputstream_->SkipNBytes(hop_bytes_-cache_size);\r\n    if (!s.ok()) {\r\n      if (!errors::IsOutOfRange(s)) {\r\n        return s;\r\n      }\r\n      *at_end = true;\r\n      return Status::OK();\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n2. Fill up `lookahead_cache_` to `record_bytes_ + footer_bytes_`.\r\n```cpp\r\nbytes_to_read = record_bytes_ + footer_bytes_ - lookahead_cache_.size();\r\nStatus s = buffered_inputstream_->ReadNBytes(bytes_to_read, value);\r\nif (!s.ok()) {\r\n  value.clear();\r\n  if (!errors::IsOutOfRange(s)) {\r\n    return s;\r\n  }\r\n  *at_end = true;\r\n  return Status::OK();\r\n}\r\nlookahead_cache_.append(*value, 0, bytes_to_read);\r\nvalue->clear();\r\n```\r\n\r\n3. Copy first `record_bytes_` from cache to `value`\r\n```cpp\r\n*value = lookahead_cache_.substr(0, record_bytes_);\r\n```", "created_at": "2017-06-16T22:02:24Z", "updated_at": "2017-06-27T00:11:31Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/8901#discussion_r122542091", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/8901", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/122542091"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/8901#discussion_r122542091"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/8901"}}, "body_html": "<p>I know this has a lot of corner cases. Here's one suggestion for a simpler mental model:</p>\n<p>In the constructor, set <code>hop_bytes_ = record_bytes_</code> if <code>hop_bytes_ == 0</code>. So now <code>hop_bytes_</code> is always &gt; 0.</p>\n<p>Remove the <code>buffered_inputstream_-&gt;ReadNBytes(footer_bytes_, &amp;lookahead_cache_)</code> from <code>OnWorkStarted</code>.</p>\n<p>In <code>ReadLocked</code></p>\n<ol>\n<li>Skip past <code>hop_bytes_</code> if not reading first record.</li>\n</ol>\n<div class=\"highlight highlight-source-c++\"><pre><span class=\"pl-k\">if</span> (record_number_ != <span class=\"pl-c1\">0</span>) {\n  <span class=\"pl-k\">if</span> (hop_bytes_ &lt;= lookahead_cache_.<span class=\"pl-c1\">size</span>()) {\n    lookahead_cache_ = lookahead_cache_.<span class=\"pl-c1\">substr</span>(hop_bytes_);\n  } <span class=\"pl-k\">else</span> {\n    int64 cache_size = lookahead_cache_.<span class=\"pl-c1\">size</span>();\n    lookahead_cache_.<span class=\"pl-c1\">clear</span>();\n    Status s = buffered_inputstream_-&gt;<span class=\"pl-c1\">SkipNBytes</span>(hop_bytes_-cache_size);\n    <span class=\"pl-k\">if</span> (!s.<span class=\"pl-c1\">ok</span>()) {\n      <span class=\"pl-k\">if</span> (!<span class=\"pl-c1\">errors::IsOutOfRange</span>(s)) {\n        <span class=\"pl-k\">return</span> s;\n      }\n      *at_end = <span class=\"pl-c1\">true</span>;\n      <span class=\"pl-k\">return</span> <span class=\"pl-c1\">Status::OK</span>();\n    }\n  }\n}</pre></div>\n<ol start=\"2\">\n<li>Fill up <code>lookahead_cache_</code> to <code>record_bytes_ + footer_bytes_</code>.</li>\n</ol>\n<div class=\"highlight highlight-source-c++\"><pre>bytes_to_read = record_bytes_ + footer_bytes_ - lookahead_cache_.size();\nStatus s = buffered_inputstream_-&gt;<span class=\"pl-en\">ReadNBytes</span>(bytes_to_read, value);\n<span class=\"pl-k\">if</span> (!s.ok()) {\n  value.<span class=\"pl-c1\">clear</span>();\n  <span class=\"pl-k\">if</span> (!<span class=\"pl-c1\">errors::IsOutOfRange</span>(s)) {\n    <span class=\"pl-k\">return</span> s;\n  }\n  *at_end = <span class=\"pl-c1\">true</span>;\n  <span class=\"pl-k\">return</span> <span class=\"pl-c1\">Status::OK</span>();\n}\nlookahead_cache_.append(*value, <span class=\"pl-c1\">0</span>, bytes_to_read);\nvalue-&gt;<span class=\"pl-en\">clear</span>();</pre></div>\n<ol start=\"3\">\n<li>Copy first <code>record_bytes_</code> from cache to <code>value</code></li>\n</ol>\n<div class=\"highlight highlight-source-c++\"><pre>*value = lookahead_cache_.substr(<span class=\"pl-c1\">0</span>, record_bytes_);</pre></div>", "body_text": "I know this has a lot of corner cases. Here's one suggestion for a simpler mental model:\nIn the constructor, set hop_bytes_ = record_bytes_ if hop_bytes_ == 0. So now hop_bytes_ is always > 0.\nRemove the buffered_inputstream_->ReadNBytes(footer_bytes_, &lookahead_cache_) from OnWorkStarted.\nIn ReadLocked\n\nSkip past hop_bytes_ if not reading first record.\n\nif (record_number_ != 0) {\n  if (hop_bytes_ <= lookahead_cache_.size()) {\n    lookahead_cache_ = lookahead_cache_.substr(hop_bytes_);\n  } else {\n    int64 cache_size = lookahead_cache_.size();\n    lookahead_cache_.clear();\n    Status s = buffered_inputstream_->SkipNBytes(hop_bytes_-cache_size);\n    if (!s.ok()) {\n      if (!errors::IsOutOfRange(s)) {\n        return s;\n      }\n      *at_end = true;\n      return Status::OK();\n    }\n  }\n}\n\nFill up lookahead_cache_ to record_bytes_ + footer_bytes_.\n\nbytes_to_read = record_bytes_ + footer_bytes_ - lookahead_cache_.size();\nStatus s = buffered_inputstream_->ReadNBytes(bytes_to_read, value);\nif (!s.ok()) {\n  value.clear();\n  if (!errors::IsOutOfRange(s)) {\n    return s;\n  }\n  *at_end = true;\n  return Status::OK();\n}\nlookahead_cache_.append(*value, 0, bytes_to_read);\nvalue->clear();\n\nCopy first record_bytes_ from cache to value\n\n*value = lookahead_cache_.substr(0, record_bytes_);", "in_reply_to_id": 122530937}