{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/298284951", "html_url": "https://github.com/tensorflow/tensorflow/pull/8901#issuecomment-298284951", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8901", "id": 298284951, "node_id": "MDEyOklzc3VlQ29tbWVudDI5ODI4NDk1MQ==", "user": {"login": "yongtang", "id": 6932348, "node_id": "MDQ6VXNlcjY5MzIzNDg=", "avatar_url": "https://avatars0.githubusercontent.com/u/6932348?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yongtang", "html_url": "https://github.com/yongtang", "followers_url": "https://api.github.com/users/yongtang/followers", "following_url": "https://api.github.com/users/yongtang/following{/other_user}", "gists_url": "https://api.github.com/users/yongtang/gists{/gist_id}", "starred_url": "https://api.github.com/users/yongtang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yongtang/subscriptions", "organizations_url": "https://api.github.com/users/yongtang/orgs", "repos_url": "https://api.github.com/users/yongtang/repos", "events_url": "https://api.github.com/users/yongtang/events{/privacy}", "received_events_url": "https://api.github.com/users/yongtang/received_events", "type": "User", "site_admin": false}, "created_at": "2017-05-01T04:38:44Z", "updated_at": "2017-05-01T04:38:44Z", "author_association": "MEMBER", "body_html": "<p>Thanks <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=3967488\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/saxenasaurabh\">@saxenasaurabh</a> for the review. The reason that <code>footer_cache_</code> is needed is that <code>zlib/gzip</code> are essentially non-seekable. In other words, once a byte is read, we could not go backward. We can only start from the beginning again to find the previous location. In addition, <code>zlib/gzip</code> does not give us the uncompressed file size before hand. (we could certainly do a two-pass but that is likely inefficient if the file is large.)</p>\n<p>In case of FixedlengthRecord, a footer might be possible. However, at the time we try to read the next bytes, we don't know if the next bytes belongs to a record, or a footer. Assume the record is <code>1</code> bytes and the footer is <code>2</code> bytes:</p>\n<pre><code>HRFF\n</code></pre>\n<p>When we read the first <code>R</code>, we don't know if it is record, or footer. We only knows it is a record when we read two <code>FF</code> + EOF. At this point, we knows that <code>FF</code> is the footer, thus <code>R</code> can only be record.</p>\n<p>For that we maintains a <code>footer_cache_</code> so that we could find out the record <code>R</code> without seek back the file. (gzip/zlib is non-seekable and we could not find the length before hand).</p>\n<p>I will update the PR to add a detailed explanation.</p>", "body_text": "Thanks @saxenasaurabh for the review. The reason that footer_cache_ is needed is that zlib/gzip are essentially non-seekable. In other words, once a byte is read, we could not go backward. We can only start from the beginning again to find the previous location. In addition, zlib/gzip does not give us the uncompressed file size before hand. (we could certainly do a two-pass but that is likely inefficient if the file is large.)\nIn case of FixedlengthRecord, a footer might be possible. However, at the time we try to read the next bytes, we don't know if the next bytes belongs to a record, or a footer. Assume the record is 1 bytes and the footer is 2 bytes:\nHRFF\n\nWhen we read the first R, we don't know if it is record, or footer. We only knows it is a record when we read two FF + EOF. At this point, we knows that FF is the footer, thus R can only be record.\nFor that we maintains a footer_cache_ so that we could find out the record R without seek back the file. (gzip/zlib is non-seekable and we could not find the length before hand).\nI will update the PR to add a detailed explanation.", "body": "Thanks @saxenasaurabh for the review. The reason that `footer_cache_` is needed is that `zlib/gzip` are essentially non-seekable. In other words, once a byte is read, we could not go backward. We can only start from the beginning again to find the previous location. In addition, `zlib/gzip` does not give us the uncompressed file size before hand. (we could certainly do a two-pass but that is likely inefficient if the file is large.)\r\n\r\nIn case of FixedlengthRecord, a footer might be possible. However, at the time we try to read the next bytes, we don't know if the next bytes belongs to a record, or a footer. Assume the record is `1` bytes and the footer is `2` bytes:\r\n```\r\nHRFF\r\n```\r\nWhen we read the first `R`, we don't know if it is record, or footer. We only knows it is a record when we read two `FF` + EOF. At this point, we knows that `FF` is the footer, thus `R` can only be record.\r\n\r\nFor that we maintains a `footer_cache_` so that we could find out the record `R` without seek back the file. (gzip/zlib is non-seekable and we could not find the length before hand).\r\n\r\nI will update the PR to add a detailed explanation."}