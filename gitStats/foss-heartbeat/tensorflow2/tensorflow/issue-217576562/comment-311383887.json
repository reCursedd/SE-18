{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/311383887", "html_url": "https://github.com/tensorflow/tensorflow/issues/8776#issuecomment-311383887", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8776", "id": 311383887, "node_id": "MDEyOklzc3VlQ29tbWVudDMxMTM4Mzg4Nw==", "user": {"login": "kopekC", "id": 28070492, "node_id": "MDQ6VXNlcjI4MDcwNDky", "avatar_url": "https://avatars0.githubusercontent.com/u/28070492?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kopekC", "html_url": "https://github.com/kopekC", "followers_url": "https://api.github.com/users/kopekC/followers", "following_url": "https://api.github.com/users/kopekC/following{/other_user}", "gists_url": "https://api.github.com/users/kopekC/gists{/gist_id}", "starred_url": "https://api.github.com/users/kopekC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kopekC/subscriptions", "organizations_url": "https://api.github.com/users/kopekC/orgs", "repos_url": "https://api.github.com/users/kopekC/repos", "events_url": "https://api.github.com/users/kopekC/events{/privacy}", "received_events_url": "https://api.github.com/users/kopekC/received_events", "type": "User", "site_admin": false}, "created_at": "2017-06-27T14:53:56Z", "updated_at": "2017-06-27T14:53:56Z", "author_association": "NONE", "body_html": "<p>This is not a TF issue.</p>\n<p>Closures are defined over names and not over values (<a href=\"https://stackoverflow.com/a/13355291\" rel=\"nofollow\">https://stackoverflow.com/a/13355291</a>). In this case, all the lambdas ended up with the value the variable had at the end of the loop. A simple solution is to have a lambda generate the lambdas you are trying to iterate over and pass the iterated value as the first and only argument. The closure is now defined over a constant, or the result of the evaluation of the first lambda (which only depends on the argument, which is itself copied).</p>\n<p>So the code that yields the results you are looking for looks like:</p>\n<pre><code>import tensorflow as tf\n\norig_label = tf.constant(0.046026)\nlabel_bounds = [0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08]\npreds = [tf.less(orig_label, bound) for bound in label_bounds]\n# Pair each predicate with a function returning the index of the predicate.\nz = lambda x: lambda: tf.constant(x)\npred_fn_pairs = [(pred, z(i))\n                 for i, pred in enumerate(preds)]\n# If no predicate evaluates to true, default to returning the index after\n# the index of the last predicate.\ndefault = lambda: tf.constant(len(pred_fn_pairs))\ncase = tf.case(pred_fn_pairs, default=default, exclusive=False)\n\nwith tf.Session() as sess:\n    sess.run(tf.global_variables_initializer())\n    print(sess.run([preds, case]))\nprint(list(enumerate(label_bounds)))\nprint(len(preds))\n</code></pre>", "body_text": "This is not a TF issue.\nClosures are defined over names and not over values (https://stackoverflow.com/a/13355291). In this case, all the lambdas ended up with the value the variable had at the end of the loop. A simple solution is to have a lambda generate the lambdas you are trying to iterate over and pass the iterated value as the first and only argument. The closure is now defined over a constant, or the result of the evaluation of the first lambda (which only depends on the argument, which is itself copied).\nSo the code that yields the results you are looking for looks like:\nimport tensorflow as tf\n\norig_label = tf.constant(0.046026)\nlabel_bounds = [0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08]\npreds = [tf.less(orig_label, bound) for bound in label_bounds]\n# Pair each predicate with a function returning the index of the predicate.\nz = lambda x: lambda: tf.constant(x)\npred_fn_pairs = [(pred, z(i))\n                 for i, pred in enumerate(preds)]\n# If no predicate evaluates to true, default to returning the index after\n# the index of the last predicate.\ndefault = lambda: tf.constant(len(pred_fn_pairs))\ncase = tf.case(pred_fn_pairs, default=default, exclusive=False)\n\nwith tf.Session() as sess:\n    sess.run(tf.global_variables_initializer())\n    print(sess.run([preds, case]))\nprint(list(enumerate(label_bounds)))\nprint(len(preds))", "body": "This is not a TF issue.\r\n\r\nClosures are defined over names and not over values (https://stackoverflow.com/a/13355291). In this case, all the lambdas ended up with the value the variable had at the end of the loop. A simple solution is to have a lambda generate the lambdas you are trying to iterate over and pass the iterated value as the first and only argument. The closure is now defined over a constant, or the result of the evaluation of the first lambda (which only depends on the argument, which is itself copied).\r\n\r\nSo the code that yields the results you are looking for looks like:\r\n\r\n    import tensorflow as tf\r\n\r\n    orig_label = tf.constant(0.046026)\r\n    label_bounds = [0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08]\r\n    preds = [tf.less(orig_label, bound) for bound in label_bounds]\r\n    # Pair each predicate with a function returning the index of the predicate.\r\n    z = lambda x: lambda: tf.constant(x)\r\n    pred_fn_pairs = [(pred, z(i))\r\n                     for i, pred in enumerate(preds)]\r\n    # If no predicate evaluates to true, default to returning the index after\r\n    # the index of the last predicate.\r\n    default = lambda: tf.constant(len(pred_fn_pairs))\r\n    case = tf.case(pred_fn_pairs, default=default, exclusive=False)\r\n\r\n    with tf.Session() as sess:\r\n        sess.run(tf.global_variables_initializer())\r\n        print(sess.run([preds, case]))\r\n    print(list(enumerate(label_bounds)))\r\n    print(len(preds))"}