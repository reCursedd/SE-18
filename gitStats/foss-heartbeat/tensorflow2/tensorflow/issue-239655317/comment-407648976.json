{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/407648976", "html_url": "https://github.com/tensorflow/tensorflow/issues/11157#issuecomment-407648976", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11157", "id": 407648976, "node_id": "MDEyOklzc3VlQ29tbWVudDQwNzY0ODk3Ng==", "user": {"login": "safdark", "id": 1193219, "node_id": "MDQ6VXNlcjExOTMyMTk=", "avatar_url": "https://avatars0.githubusercontent.com/u/1193219?v=4", "gravatar_id": "", "url": "https://api.github.com/users/safdark", "html_url": "https://github.com/safdark", "followers_url": "https://api.github.com/users/safdark/followers", "following_url": "https://api.github.com/users/safdark/following{/other_user}", "gists_url": "https://api.github.com/users/safdark/gists{/gist_id}", "starred_url": "https://api.github.com/users/safdark/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/safdark/subscriptions", "organizations_url": "https://api.github.com/users/safdark/orgs", "repos_url": "https://api.github.com/users/safdark/repos", "events_url": "https://api.github.com/users/safdark/events{/privacy}", "received_events_url": "https://api.github.com/users/safdark/received_events", "type": "User", "site_admin": false}, "created_at": "2018-07-25T06:35:10Z", "updated_at": "2018-07-25T06:44:42Z", "author_association": "NONE", "body_html": "<p>I'm getting a similar error with keras 2.0.9 and tensorflow 1.3.0. Note, however, that this happens only when I wrap a model using the <strong>keras.utils.training_utils.multi_gpu_model</strong> class, as below:</p>\n<pre><code>model = multi_gpu_model(model, gpus=8) # I was trying to utilize 8 GPUs\n..\n..\ncheckpointer = ModelCheckpoint(filepath='results/model.hd5', verbose=0)\n..\nhist = model.fit_generator(generator=audio_gen.next_train(), steps_per_epoch=steps_per_epoch,\n        epochs=epochs, validation_data=audio_gen.next_valid(), validation_steps=validation_steps,\n        callbacks=[checkpointer], verbose=verbose)  &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; # ON THIS LINE #\n\n</code></pre>\n<p>In the absence of multi_gpu_model, this code above runs without a problem.</p>\n<p>===================== OUTPUT ======================<br>\nEpoch 1/20<br>\n24/106 [================&gt;.] - ETA: 35 - loss: 194.7247</p>\n<pre><code>TypeError                                 Traceback (most recent call last)\n     74     hist = model.fit_generator(generator=audio_gen.next_train(), steps_per_epoch=steps_per_epoch,\n     75         epochs=epochs, validation_data=audio_gen.next_valid(), validation_steps=validation_steps,\n---&gt; 76         callbacks=[checkpointer], verbose=verbose)\n     77 \n     78     # save model loss\n\n/usr/local/lib/python3.5/dist-packages/keras/legacy/interfaces.py in wrapper(*args, **kwargs)\n     85                 warnings.warn('Update your `' + object_name +\n     86                               '` call to the Keras 2 API: ' + signature, stacklevel=2)\n---&gt; 87             return func(*args, **kwargs)\n     88         wrapper._original_function = func\n     89         return wrapper\n\n/usr/local/lib/python3.5/dist-packages/keras/engine/training.py in fit_generator(self, generator, steps_per_epoch, epochs, verbose, callbacks, validation_data, validation_steps, class_weight, max_queue_size, workers, use_multiprocessing, shuffle, initial_epoch)\n   2115                         break\n   2116 \n-&gt; 2117                 callbacks.on_epoch_end(epoch, epoch_logs)\n   2118                 epoch += 1\n   2119                 if callback_model.stop_training:\n\n/usr/local/lib/python3.5/dist-packages/keras/callbacks.py in on_epoch_end(self, epoch, logs)\n     71         logs = logs or {}\n     72         for callback in self.callbacks:\n---&gt; 73             callback.on_epoch_end(epoch, logs)\n     74 \n     75     def on_batch_begin(self, batch, logs=None):\n\n/usr/local/lib/python3.5/dist-packages/keras/callbacks.py in on_epoch_end(self, epoch, logs)\n    423                     self.model.save_weights(filepath, overwrite=True)\n    424                 else:\n--&gt; 425                     self.model.save(filepath, overwrite=True)\n    426 \n    427 \n\n/usr/local/lib/python3.5/dist-packages/keras/engine/topology.py in save(self, filepath, overwrite, include_optimizer)\n   2554         \"\"\"\n   2555         from ..models import save_model\n-&gt; 2556         save_model(self, filepath, overwrite, include_optimizer)\n   2557 \n   2558     def save_weights(self, filepath, overwrite=True):\n\n/usr/local/lib/python3.5/dist-packages/keras/models.py in save_model(model, filepath, overwrite, include_optimizer)\n    105         f.attrs['model_config'] = json.dumps({\n    106             'class_name': model.__class__.__name__,\n--&gt; 107             'config': model.get_config()\n    108         }, default=get_json_type).encode('utf8')\n    109 \n\n/usr/local/lib/python3.5/dist-packages/keras/engine/topology.py in get_config(self)\n   2395             model_outputs.append([layer.name, new_node_index, tensor_index])\n   2396         config['output_layers'] = model_outputs\n-&gt; 2397         return copy.deepcopy(config)\n   2398 \n   2399     @classmethod\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    153     copier = _deepcopy_dispatch.get(cls)\n    154     if copier:\n--&gt; 155         y = copier(x, memo)\n    156     else:\n    157         try:\n\n/usr/lib/python3.5/copy.py in _deepcopy_dict(x, memo)\n    241     memo[id(x)] = y\n    242     for key, value in x.items():\n--&gt; 243         y[deepcopy(key, memo)] = deepcopy(value, memo)\n    244     return y\n    245 d[dict] = _deepcopy_dict\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    153     copier = _deepcopy_dispatch.get(cls)\n    154     if copier:\n--&gt; 155         y = copier(x, memo)\n    156     else:\n    157         try:\n\n/usr/lib/python3.5/copy.py in _deepcopy_list(x, memo)\n    216     memo[id(x)] = y\n    217     for a in x:\n--&gt; 218         y.append(deepcopy(a, memo))\n    219     return y\n    220 d[list] = _deepcopy_list\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    153     copier = _deepcopy_dispatch.get(cls)\n    154     if copier:\n--&gt; 155         y = copier(x, memo)\n    156     else:\n    157         try:\n\n/usr/lib/python3.5/copy.py in _deepcopy_dict(x, memo)\n    241     memo[id(x)] = y\n    242     for key, value in x.items():\n--&gt; 243         y[deepcopy(key, memo)] = deepcopy(value, memo)\n    244     return y\n    245 d[dict] = _deepcopy_dict\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    153     copier = _deepcopy_dispatch.get(cls)\n    154     if copier:\n--&gt; 155         y = copier(x, memo)\n    156     else:\n    157         try:\n\n/usr/lib/python3.5/copy.py in _deepcopy_dict(x, memo)\n    241     memo[id(x)] = y\n    242     for key, value in x.items():\n--&gt; 243         y[deepcopy(key, memo)] = deepcopy(value, memo)\n    244     return y\n    245 d[dict] = _deepcopy_dict\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    153     copier = _deepcopy_dispatch.get(cls)\n    154     if copier:\n--&gt; 155         y = copier(x, memo)\n    156     else:\n    157         try:\n\n/usr/lib/python3.5/copy.py in _deepcopy_tuple(x, memo)\n    221 \n    222 def _deepcopy_tuple(x, memo):\n--&gt; 223     y = [deepcopy(a, memo) for a in x]\n    224     # We're not going to put the tuple in the memo, but it's still important we\n    225     # check for it, in case the tuple contains recursive mutable structures.\n\n/usr/lib/python3.5/copy.py in &lt;listcomp&gt;(.0)\n    221 \n    222 def _deepcopy_tuple(x, memo):\n--&gt; 223     y = [deepcopy(a, memo) for a in x]\n    224     # We're not going to put the tuple in the memo, but it's still important we\n    225     # check for it, in case the tuple contains recursive mutable structures.\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    153     copier = _deepcopy_dispatch.get(cls)\n    154     if copier:\n--&gt; 155         y = copier(x, memo)\n    156     else:\n    157         try:\n\n/usr/lib/python3.5/copy.py in _deepcopy_tuple(x, memo)\n    221 \n    222 def _deepcopy_tuple(x, memo):\n--&gt; 223     y = [deepcopy(a, memo) for a in x]\n    224     # We're not going to put the tuple in the memo, but it's still important we\n    225     # check for it, in case the tuple contains recursive mutable structures.\n\n/usr/lib/python3.5/copy.py in &lt;listcomp&gt;(.0)\n    221 \n    222 def _deepcopy_tuple(x, memo):\n--&gt; 223     y = [deepcopy(a, memo) for a in x]\n    224     # We're not going to put the tuple in the memo, but it's still important we\n    225     # check for it, in case the tuple contains recursive mutable structures.\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    180                             raise Error(\n    181                                 \"un(deep)copyable object of type %s\" % cls)\n--&gt; 182                 y = _reconstruct(x, rv, 1, memo)\n    183 \n    184     # If is its own copy, don't memoize.\n\n/usr/lib/python3.5/copy.py in _reconstruct(x, info, deep, memo)\n    295     if state is not None:\n    296         if deep:\n--&gt; 297             state = deepcopy(state, memo)\n    298         if hasattr(y, '__setstate__'):\n    299             y.__setstate__(state)\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    153     copier = _deepcopy_dispatch.get(cls)\n    154     if copier:\n--&gt; 155         y = copier(x, memo)\n    156     else:\n    157         try:\n\n/usr/lib/python3.5/copy.py in _deepcopy_dict(x, memo)\n    241     memo[id(x)] = y\n    242     for key, value in x.items():\n--&gt; 243         y[deepcopy(key, memo)] = deepcopy(value, memo)\n    244     return y\n    245 d[dict] = _deepcopy_dict\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    180                             raise Error(\n    181                                 \"un(deep)copyable object of type %s\" % cls)\n--&gt; 182                 y = _reconstruct(x, rv, 1, memo)\n    183 \n    184     # If is its own copy, don't memoize.\n\n/usr/lib/python3.5/copy.py in _reconstruct(x, info, deep, memo)\n    295     if state is not None:\n    296         if deep:\n--&gt; 297             state = deepcopy(state, memo)\n    298         if hasattr(y, '__setstate__'):\n    299             y.__setstate__(state)\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    153     copier = _deepcopy_dispatch.get(cls)\n    154     if copier:\n--&gt; 155         y = copier(x, memo)\n    156     else:\n    157         try:\n\n/usr/lib/python3.5/copy.py in _deepcopy_dict(x, memo)\n    241     memo[id(x)] = y\n    242     for key, value in x.items():\n--&gt; 243         y[deepcopy(key, memo)] = deepcopy(value, memo)\n    244     return y\n    245 d[dict] = _deepcopy_dict\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    153     copier = _deepcopy_dispatch.get(cls)\n    154     if copier:\n--&gt; 155         y = copier(x, memo)\n    156     else:\n    157         try:\n\n/usr/lib/python3.5/copy.py in _deepcopy_dict(x, memo)\n    241     memo[id(x)] = y\n    242     for key, value in x.items():\n--&gt; 243         y[deepcopy(key, memo)] = deepcopy(value, memo)\n    244     return y\n    245 d[dict] = _deepcopy_dict\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    153     copier = _deepcopy_dispatch.get(cls)\n    154     if copier:\n--&gt; 155         y = copier(x, memo)\n    156     else:\n    157         try:\n\n/usr/lib/python3.5/copy.py in _deepcopy_method(x, memo)\n    248 \n    249 def _deepcopy_method(x, memo): # Copy instance methods\n--&gt; 250     return type(x)(x.__func__, deepcopy(x.__self__, memo))\n    251 _deepcopy_dispatch[types.MethodType] = _deepcopy_method\n    252 \n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    180                             raise Error(\n    181                                 \"un(deep)copyable object of type %s\" % cls)\n--&gt; 182                 y = _reconstruct(x, rv, 1, memo)\n    183 \n    184     # If is its own copy, don't memoize.\n\n/usr/lib/python3.5/copy.py in _reconstruct(x, info, deep, memo)\n    295     if state is not None:\n    296         if deep:\n--&gt; 297             state = deepcopy(state, memo)\n    298         if hasattr(y, '__setstate__'):\n    299             y.__setstate__(state)\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    153     copier = _deepcopy_dispatch.get(cls)\n    154     if copier:\n--&gt; 155         y = copier(x, memo)\n    156     else:\n    157         try:\n\n/usr/lib/python3.5/copy.py in _deepcopy_dict(x, memo)\n    241     memo[id(x)] = y\n    242     for key, value in x.items():\n--&gt; 243         y[deepcopy(key, memo)] = deepcopy(value, memo)\n    244     return y\n    245 d[dict] = _deepcopy_dict\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    153     copier = _deepcopy_dispatch.get(cls)\n    154     if copier:\n--&gt; 155         y = copier(x, memo)\n    156     else:\n    157         try:\n\n/usr/lib/python3.5/copy.py in _deepcopy_dict(x, memo)\n    241     memo[id(x)] = y\n    242     for key, value in x.items():\n--&gt; 243         y[deepcopy(key, memo)] = deepcopy(value, memo)\n    244     return y\n    245 d[dict] = _deepcopy_dict\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    180                             raise Error(\n    181                                 \"un(deep)copyable object of type %s\" % cls)\n--&gt; 182                 y = _reconstruct(x, rv, 1, memo)\n    183 \n    184     # If is its own copy, don't memoize.\n\n/usr/lib/python3.5/copy.py in _reconstruct(x, info, deep, memo)\n    295     if state is not None:\n    296         if deep:\n--&gt; 297             state = deepcopy(state, memo)\n    298         if hasattr(y, '__setstate__'):\n    299             y.__setstate__(state)\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    153     copier = _deepcopy_dispatch.get(cls)\n    154     if copier:\n--&gt; 155         y = copier(x, memo)\n    156     else:\n    157         try:\n\n/usr/lib/python3.5/copy.py in _deepcopy_dict(x, memo)\n    241     memo[id(x)] = y\n    242     for key, value in x.items():\n--&gt; 243         y[deepcopy(key, memo)] = deepcopy(value, memo)\n    244     return y\n    245 d[dict] = _deepcopy_dict\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    153     copier = _deepcopy_dispatch.get(cls)\n    154     if copier:\n--&gt; 155         y = copier(x, memo)\n    156     else:\n    157         try:\n\n/usr/lib/python3.5/copy.py in _deepcopy_dict(x, memo)\n    241     memo[id(x)] = y\n    242     for key, value in x.items():\n--&gt; 243         y[deepcopy(key, memo)] = deepcopy(value, memo)\n    244     return y\n    245 d[dict] = _deepcopy_dict\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    180                             raise Error(\n    181                                 \"un(deep)copyable object of type %s\" % cls)\n--&gt; 182                 y = _reconstruct(x, rv, 1, memo)\n    183 \n    184     # If is its own copy, don't memoize.\n\n/usr/lib/python3.5/copy.py in _reconstruct(x, info, deep, memo)\n    295     if state is not None:\n    296         if deep:\n--&gt; 297             state = deepcopy(state, memo)\n    298         if hasattr(y, '__setstate__'):\n    299             y.__setstate__(state)\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    153     copier = _deepcopy_dispatch.get(cls)\n    154     if copier:\n--&gt; 155         y = copier(x, memo)\n    156     else:\n    157         try:\n\n/usr/lib/python3.5/copy.py in _deepcopy_dict(x, memo)\n    241     memo[id(x)] = y\n    242     for key, value in x.items():\n--&gt; 243         y[deepcopy(key, memo)] = deepcopy(value, memo)\n    244     return y\n    245 d[dict] = _deepcopy_dict\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    180                             raise Error(\n    181                                 \"un(deep)copyable object of type %s\" % cls)\n--&gt; 182                 y = _reconstruct(x, rv, 1, memo)\n    183 \n    184     # If is its own copy, don't memoize.\n\n/usr/lib/python3.5/copy.py in _reconstruct(x, info, deep, memo)\n    295     if state is not None:\n    296         if deep:\n--&gt; 297             state = deepcopy(state, memo)\n    298         if hasattr(y, '__setstate__'):\n    299             y.__setstate__(state)\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    153     copier = _deepcopy_dispatch.get(cls)\n    154     if copier:\n--&gt; 155         y = copier(x, memo)\n    156     else:\n    157         try:\n\n/usr/lib/python3.5/copy.py in _deepcopy_dict(x, memo)\n    241     memo[id(x)] = y\n    242     for key, value in x.items():\n--&gt; 243         y[deepcopy(key, memo)] = deepcopy(value, memo)\n    244     return y\n    245 d[dict] = _deepcopy_dict\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    180                             raise Error(\n    181                                 \"un(deep)copyable object of type %s\" % cls)\n--&gt; 182                 y = _reconstruct(x, rv, 1, memo)\n    183 \n    184     # If is its own copy, don't memoize.\n\n/usr/lib/python3.5/copy.py in _reconstruct(x, info, deep, memo)\n    295     if state is not None:\n    296         if deep:\n--&gt; 297             state = deepcopy(state, memo)\n    298         if hasattr(y, '__setstate__'):\n    299             y.__setstate__(state)\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    153     copier = _deepcopy_dispatch.get(cls)\n    154     if copier:\n--&gt; 155         y = copier(x, memo)\n    156     else:\n    157         try:\n\n/usr/lib/python3.5/copy.py in _deepcopy_dict(x, memo)\n    241     memo[id(x)] = y\n    242     for key, value in x.items():\n--&gt; 243         y[deepcopy(key, memo)] = deepcopy(value, memo)\n    244     return y\n    245 d[dict] = _deepcopy_dict\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    172                     reductor = getattr(x, \"__reduce_ex__\", None)\n    173                     if reductor:\n--&gt; 174                         rv = reductor(4)\n    175                     else:\n    176                         reductor = getattr(x, \"__reduce__\", None)\n\nTypeError: can't pickle _thread.lock objects\n</code></pre>", "body_text": "I'm getting a similar error with keras 2.0.9 and tensorflow 1.3.0. Note, however, that this happens only when I wrap a model using the keras.utils.training_utils.multi_gpu_model class, as below:\nmodel = multi_gpu_model(model, gpus=8) # I was trying to utilize 8 GPUs\n..\n..\ncheckpointer = ModelCheckpoint(filepath='results/model.hd5', verbose=0)\n..\nhist = model.fit_generator(generator=audio_gen.next_train(), steps_per_epoch=steps_per_epoch,\n        epochs=epochs, validation_data=audio_gen.next_valid(), validation_steps=validation_steps,\n        callbacks=[checkpointer], verbose=verbose)  <<<<<<<<<<< # ON THIS LINE #\n\n\nIn the absence of multi_gpu_model, this code above runs without a problem.\n===================== OUTPUT ======================\nEpoch 1/20\n24/106 [================>.] - ETA: 35 - loss: 194.7247\nTypeError                                 Traceback (most recent call last)\n     74     hist = model.fit_generator(generator=audio_gen.next_train(), steps_per_epoch=steps_per_epoch,\n     75         epochs=epochs, validation_data=audio_gen.next_valid(), validation_steps=validation_steps,\n---> 76         callbacks=[checkpointer], verbose=verbose)\n     77 \n     78     # save model loss\n\n/usr/local/lib/python3.5/dist-packages/keras/legacy/interfaces.py in wrapper(*args, **kwargs)\n     85                 warnings.warn('Update your `' + object_name +\n     86                               '` call to the Keras 2 API: ' + signature, stacklevel=2)\n---> 87             return func(*args, **kwargs)\n     88         wrapper._original_function = func\n     89         return wrapper\n\n/usr/local/lib/python3.5/dist-packages/keras/engine/training.py in fit_generator(self, generator, steps_per_epoch, epochs, verbose, callbacks, validation_data, validation_steps, class_weight, max_queue_size, workers, use_multiprocessing, shuffle, initial_epoch)\n   2115                         break\n   2116 \n-> 2117                 callbacks.on_epoch_end(epoch, epoch_logs)\n   2118                 epoch += 1\n   2119                 if callback_model.stop_training:\n\n/usr/local/lib/python3.5/dist-packages/keras/callbacks.py in on_epoch_end(self, epoch, logs)\n     71         logs = logs or {}\n     72         for callback in self.callbacks:\n---> 73             callback.on_epoch_end(epoch, logs)\n     74 \n     75     def on_batch_begin(self, batch, logs=None):\n\n/usr/local/lib/python3.5/dist-packages/keras/callbacks.py in on_epoch_end(self, epoch, logs)\n    423                     self.model.save_weights(filepath, overwrite=True)\n    424                 else:\n--> 425                     self.model.save(filepath, overwrite=True)\n    426 \n    427 \n\n/usr/local/lib/python3.5/dist-packages/keras/engine/topology.py in save(self, filepath, overwrite, include_optimizer)\n   2554         \"\"\"\n   2555         from ..models import save_model\n-> 2556         save_model(self, filepath, overwrite, include_optimizer)\n   2557 \n   2558     def save_weights(self, filepath, overwrite=True):\n\n/usr/local/lib/python3.5/dist-packages/keras/models.py in save_model(model, filepath, overwrite, include_optimizer)\n    105         f.attrs['model_config'] = json.dumps({\n    106             'class_name': model.__class__.__name__,\n--> 107             'config': model.get_config()\n    108         }, default=get_json_type).encode('utf8')\n    109 \n\n/usr/local/lib/python3.5/dist-packages/keras/engine/topology.py in get_config(self)\n   2395             model_outputs.append([layer.name, new_node_index, tensor_index])\n   2396         config['output_layers'] = model_outputs\n-> 2397         return copy.deepcopy(config)\n   2398 \n   2399     @classmethod\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    153     copier = _deepcopy_dispatch.get(cls)\n    154     if copier:\n--> 155         y = copier(x, memo)\n    156     else:\n    157         try:\n\n/usr/lib/python3.5/copy.py in _deepcopy_dict(x, memo)\n    241     memo[id(x)] = y\n    242     for key, value in x.items():\n--> 243         y[deepcopy(key, memo)] = deepcopy(value, memo)\n    244     return y\n    245 d[dict] = _deepcopy_dict\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    153     copier = _deepcopy_dispatch.get(cls)\n    154     if copier:\n--> 155         y = copier(x, memo)\n    156     else:\n    157         try:\n\n/usr/lib/python3.5/copy.py in _deepcopy_list(x, memo)\n    216     memo[id(x)] = y\n    217     for a in x:\n--> 218         y.append(deepcopy(a, memo))\n    219     return y\n    220 d[list] = _deepcopy_list\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    153     copier = _deepcopy_dispatch.get(cls)\n    154     if copier:\n--> 155         y = copier(x, memo)\n    156     else:\n    157         try:\n\n/usr/lib/python3.5/copy.py in _deepcopy_dict(x, memo)\n    241     memo[id(x)] = y\n    242     for key, value in x.items():\n--> 243         y[deepcopy(key, memo)] = deepcopy(value, memo)\n    244     return y\n    245 d[dict] = _deepcopy_dict\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    153     copier = _deepcopy_dispatch.get(cls)\n    154     if copier:\n--> 155         y = copier(x, memo)\n    156     else:\n    157         try:\n\n/usr/lib/python3.5/copy.py in _deepcopy_dict(x, memo)\n    241     memo[id(x)] = y\n    242     for key, value in x.items():\n--> 243         y[deepcopy(key, memo)] = deepcopy(value, memo)\n    244     return y\n    245 d[dict] = _deepcopy_dict\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    153     copier = _deepcopy_dispatch.get(cls)\n    154     if copier:\n--> 155         y = copier(x, memo)\n    156     else:\n    157         try:\n\n/usr/lib/python3.5/copy.py in _deepcopy_tuple(x, memo)\n    221 \n    222 def _deepcopy_tuple(x, memo):\n--> 223     y = [deepcopy(a, memo) for a in x]\n    224     # We're not going to put the tuple in the memo, but it's still important we\n    225     # check for it, in case the tuple contains recursive mutable structures.\n\n/usr/lib/python3.5/copy.py in <listcomp>(.0)\n    221 \n    222 def _deepcopy_tuple(x, memo):\n--> 223     y = [deepcopy(a, memo) for a in x]\n    224     # We're not going to put the tuple in the memo, but it's still important we\n    225     # check for it, in case the tuple contains recursive mutable structures.\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    153     copier = _deepcopy_dispatch.get(cls)\n    154     if copier:\n--> 155         y = copier(x, memo)\n    156     else:\n    157         try:\n\n/usr/lib/python3.5/copy.py in _deepcopy_tuple(x, memo)\n    221 \n    222 def _deepcopy_tuple(x, memo):\n--> 223     y = [deepcopy(a, memo) for a in x]\n    224     # We're not going to put the tuple in the memo, but it's still important we\n    225     # check for it, in case the tuple contains recursive mutable structures.\n\n/usr/lib/python3.5/copy.py in <listcomp>(.0)\n    221 \n    222 def _deepcopy_tuple(x, memo):\n--> 223     y = [deepcopy(a, memo) for a in x]\n    224     # We're not going to put the tuple in the memo, but it's still important we\n    225     # check for it, in case the tuple contains recursive mutable structures.\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    180                             raise Error(\n    181                                 \"un(deep)copyable object of type %s\" % cls)\n--> 182                 y = _reconstruct(x, rv, 1, memo)\n    183 \n    184     # If is its own copy, don't memoize.\n\n/usr/lib/python3.5/copy.py in _reconstruct(x, info, deep, memo)\n    295     if state is not None:\n    296         if deep:\n--> 297             state = deepcopy(state, memo)\n    298         if hasattr(y, '__setstate__'):\n    299             y.__setstate__(state)\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    153     copier = _deepcopy_dispatch.get(cls)\n    154     if copier:\n--> 155         y = copier(x, memo)\n    156     else:\n    157         try:\n\n/usr/lib/python3.5/copy.py in _deepcopy_dict(x, memo)\n    241     memo[id(x)] = y\n    242     for key, value in x.items():\n--> 243         y[deepcopy(key, memo)] = deepcopy(value, memo)\n    244     return y\n    245 d[dict] = _deepcopy_dict\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    180                             raise Error(\n    181                                 \"un(deep)copyable object of type %s\" % cls)\n--> 182                 y = _reconstruct(x, rv, 1, memo)\n    183 \n    184     # If is its own copy, don't memoize.\n\n/usr/lib/python3.5/copy.py in _reconstruct(x, info, deep, memo)\n    295     if state is not None:\n    296         if deep:\n--> 297             state = deepcopy(state, memo)\n    298         if hasattr(y, '__setstate__'):\n    299             y.__setstate__(state)\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    153     copier = _deepcopy_dispatch.get(cls)\n    154     if copier:\n--> 155         y = copier(x, memo)\n    156     else:\n    157         try:\n\n/usr/lib/python3.5/copy.py in _deepcopy_dict(x, memo)\n    241     memo[id(x)] = y\n    242     for key, value in x.items():\n--> 243         y[deepcopy(key, memo)] = deepcopy(value, memo)\n    244     return y\n    245 d[dict] = _deepcopy_dict\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    153     copier = _deepcopy_dispatch.get(cls)\n    154     if copier:\n--> 155         y = copier(x, memo)\n    156     else:\n    157         try:\n\n/usr/lib/python3.5/copy.py in _deepcopy_dict(x, memo)\n    241     memo[id(x)] = y\n    242     for key, value in x.items():\n--> 243         y[deepcopy(key, memo)] = deepcopy(value, memo)\n    244     return y\n    245 d[dict] = _deepcopy_dict\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    153     copier = _deepcopy_dispatch.get(cls)\n    154     if copier:\n--> 155         y = copier(x, memo)\n    156     else:\n    157         try:\n\n/usr/lib/python3.5/copy.py in _deepcopy_method(x, memo)\n    248 \n    249 def _deepcopy_method(x, memo): # Copy instance methods\n--> 250     return type(x)(x.__func__, deepcopy(x.__self__, memo))\n    251 _deepcopy_dispatch[types.MethodType] = _deepcopy_method\n    252 \n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    180                             raise Error(\n    181                                 \"un(deep)copyable object of type %s\" % cls)\n--> 182                 y = _reconstruct(x, rv, 1, memo)\n    183 \n    184     # If is its own copy, don't memoize.\n\n/usr/lib/python3.5/copy.py in _reconstruct(x, info, deep, memo)\n    295     if state is not None:\n    296         if deep:\n--> 297             state = deepcopy(state, memo)\n    298         if hasattr(y, '__setstate__'):\n    299             y.__setstate__(state)\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    153     copier = _deepcopy_dispatch.get(cls)\n    154     if copier:\n--> 155         y = copier(x, memo)\n    156     else:\n    157         try:\n\n/usr/lib/python3.5/copy.py in _deepcopy_dict(x, memo)\n    241     memo[id(x)] = y\n    242     for key, value in x.items():\n--> 243         y[deepcopy(key, memo)] = deepcopy(value, memo)\n    244     return y\n    245 d[dict] = _deepcopy_dict\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    153     copier = _deepcopy_dispatch.get(cls)\n    154     if copier:\n--> 155         y = copier(x, memo)\n    156     else:\n    157         try:\n\n/usr/lib/python3.5/copy.py in _deepcopy_dict(x, memo)\n    241     memo[id(x)] = y\n    242     for key, value in x.items():\n--> 243         y[deepcopy(key, memo)] = deepcopy(value, memo)\n    244     return y\n    245 d[dict] = _deepcopy_dict\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    180                             raise Error(\n    181                                 \"un(deep)copyable object of type %s\" % cls)\n--> 182                 y = _reconstruct(x, rv, 1, memo)\n    183 \n    184     # If is its own copy, don't memoize.\n\n/usr/lib/python3.5/copy.py in _reconstruct(x, info, deep, memo)\n    295     if state is not None:\n    296         if deep:\n--> 297             state = deepcopy(state, memo)\n    298         if hasattr(y, '__setstate__'):\n    299             y.__setstate__(state)\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    153     copier = _deepcopy_dispatch.get(cls)\n    154     if copier:\n--> 155         y = copier(x, memo)\n    156     else:\n    157         try:\n\n/usr/lib/python3.5/copy.py in _deepcopy_dict(x, memo)\n    241     memo[id(x)] = y\n    242     for key, value in x.items():\n--> 243         y[deepcopy(key, memo)] = deepcopy(value, memo)\n    244     return y\n    245 d[dict] = _deepcopy_dict\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    153     copier = _deepcopy_dispatch.get(cls)\n    154     if copier:\n--> 155         y = copier(x, memo)\n    156     else:\n    157         try:\n\n/usr/lib/python3.5/copy.py in _deepcopy_dict(x, memo)\n    241     memo[id(x)] = y\n    242     for key, value in x.items():\n--> 243         y[deepcopy(key, memo)] = deepcopy(value, memo)\n    244     return y\n    245 d[dict] = _deepcopy_dict\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    180                             raise Error(\n    181                                 \"un(deep)copyable object of type %s\" % cls)\n--> 182                 y = _reconstruct(x, rv, 1, memo)\n    183 \n    184     # If is its own copy, don't memoize.\n\n/usr/lib/python3.5/copy.py in _reconstruct(x, info, deep, memo)\n    295     if state is not None:\n    296         if deep:\n--> 297             state = deepcopy(state, memo)\n    298         if hasattr(y, '__setstate__'):\n    299             y.__setstate__(state)\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    153     copier = _deepcopy_dispatch.get(cls)\n    154     if copier:\n--> 155         y = copier(x, memo)\n    156     else:\n    157         try:\n\n/usr/lib/python3.5/copy.py in _deepcopy_dict(x, memo)\n    241     memo[id(x)] = y\n    242     for key, value in x.items():\n--> 243         y[deepcopy(key, memo)] = deepcopy(value, memo)\n    244     return y\n    245 d[dict] = _deepcopy_dict\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    180                             raise Error(\n    181                                 \"un(deep)copyable object of type %s\" % cls)\n--> 182                 y = _reconstruct(x, rv, 1, memo)\n    183 \n    184     # If is its own copy, don't memoize.\n\n/usr/lib/python3.5/copy.py in _reconstruct(x, info, deep, memo)\n    295     if state is not None:\n    296         if deep:\n--> 297             state = deepcopy(state, memo)\n    298         if hasattr(y, '__setstate__'):\n    299             y.__setstate__(state)\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    153     copier = _deepcopy_dispatch.get(cls)\n    154     if copier:\n--> 155         y = copier(x, memo)\n    156     else:\n    157         try:\n\n/usr/lib/python3.5/copy.py in _deepcopy_dict(x, memo)\n    241     memo[id(x)] = y\n    242     for key, value in x.items():\n--> 243         y[deepcopy(key, memo)] = deepcopy(value, memo)\n    244     return y\n    245 d[dict] = _deepcopy_dict\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    180                             raise Error(\n    181                                 \"un(deep)copyable object of type %s\" % cls)\n--> 182                 y = _reconstruct(x, rv, 1, memo)\n    183 \n    184     # If is its own copy, don't memoize.\n\n/usr/lib/python3.5/copy.py in _reconstruct(x, info, deep, memo)\n    295     if state is not None:\n    296         if deep:\n--> 297             state = deepcopy(state, memo)\n    298         if hasattr(y, '__setstate__'):\n    299             y.__setstate__(state)\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    153     copier = _deepcopy_dispatch.get(cls)\n    154     if copier:\n--> 155         y = copier(x, memo)\n    156     else:\n    157         try:\n\n/usr/lib/python3.5/copy.py in _deepcopy_dict(x, memo)\n    241     memo[id(x)] = y\n    242     for key, value in x.items():\n--> 243         y[deepcopy(key, memo)] = deepcopy(value, memo)\n    244     return y\n    245 d[dict] = _deepcopy_dict\n\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\n    172                     reductor = getattr(x, \"__reduce_ex__\", None)\n    173                     if reductor:\n--> 174                         rv = reductor(4)\n    175                     else:\n    176                         reductor = getattr(x, \"__reduce__\", None)\n\nTypeError: can't pickle _thread.lock objects", "body": "I'm getting a similar error with keras 2.0.9 and tensorflow 1.3.0. Note, however, that this happens only when I wrap a model using the **keras.utils.training_utils.multi_gpu_model** class, as below:\r\n\r\n```\r\nmodel = multi_gpu_model(model, gpus=8) # I was trying to utilize 8 GPUs\r\n..\r\n..\r\ncheckpointer = ModelCheckpoint(filepath='results/model.hd5', verbose=0)\r\n..\r\nhist = model.fit_generator(generator=audio_gen.next_train(), steps_per_epoch=steps_per_epoch,\r\n        epochs=epochs, validation_data=audio_gen.next_valid(), validation_steps=validation_steps,\r\n        callbacks=[checkpointer], verbose=verbose)  <<<<<<<<<<< # ON THIS LINE #\r\n\r\n```\r\n\r\nIn the absence of multi_gpu_model, this code above runs without a problem.\r\n\r\n===================== OUTPUT ======================\r\nEpoch 1/20\r\n 24/106 [================>.] - ETA: 35 - loss: 194.7247\r\n\r\n```\r\nTypeError                                 Traceback (most recent call last)\r\n     74     hist = model.fit_generator(generator=audio_gen.next_train(), steps_per_epoch=steps_per_epoch,\r\n     75         epochs=epochs, validation_data=audio_gen.next_valid(), validation_steps=validation_steps,\r\n---> 76         callbacks=[checkpointer], verbose=verbose)\r\n     77 \r\n     78     # save model loss\r\n\r\n/usr/local/lib/python3.5/dist-packages/keras/legacy/interfaces.py in wrapper(*args, **kwargs)\r\n     85                 warnings.warn('Update your `' + object_name +\r\n     86                               '` call to the Keras 2 API: ' + signature, stacklevel=2)\r\n---> 87             return func(*args, **kwargs)\r\n     88         wrapper._original_function = func\r\n     89         return wrapper\r\n\r\n/usr/local/lib/python3.5/dist-packages/keras/engine/training.py in fit_generator(self, generator, steps_per_epoch, epochs, verbose, callbacks, validation_data, validation_steps, class_weight, max_queue_size, workers, use_multiprocessing, shuffle, initial_epoch)\r\n   2115                         break\r\n   2116 \r\n-> 2117                 callbacks.on_epoch_end(epoch, epoch_logs)\r\n   2118                 epoch += 1\r\n   2119                 if callback_model.stop_training:\r\n\r\n/usr/local/lib/python3.5/dist-packages/keras/callbacks.py in on_epoch_end(self, epoch, logs)\r\n     71         logs = logs or {}\r\n     72         for callback in self.callbacks:\r\n---> 73             callback.on_epoch_end(epoch, logs)\r\n     74 \r\n     75     def on_batch_begin(self, batch, logs=None):\r\n\r\n/usr/local/lib/python3.5/dist-packages/keras/callbacks.py in on_epoch_end(self, epoch, logs)\r\n    423                     self.model.save_weights(filepath, overwrite=True)\r\n    424                 else:\r\n--> 425                     self.model.save(filepath, overwrite=True)\r\n    426 \r\n    427 \r\n\r\n/usr/local/lib/python3.5/dist-packages/keras/engine/topology.py in save(self, filepath, overwrite, include_optimizer)\r\n   2554         \"\"\"\r\n   2555         from ..models import save_model\r\n-> 2556         save_model(self, filepath, overwrite, include_optimizer)\r\n   2557 \r\n   2558     def save_weights(self, filepath, overwrite=True):\r\n\r\n/usr/local/lib/python3.5/dist-packages/keras/models.py in save_model(model, filepath, overwrite, include_optimizer)\r\n    105         f.attrs['model_config'] = json.dumps({\r\n    106             'class_name': model.__class__.__name__,\r\n--> 107             'config': model.get_config()\r\n    108         }, default=get_json_type).encode('utf8')\r\n    109 \r\n\r\n/usr/local/lib/python3.5/dist-packages/keras/engine/topology.py in get_config(self)\r\n   2395             model_outputs.append([layer.name, new_node_index, tensor_index])\r\n   2396         config['output_layers'] = model_outputs\r\n-> 2397         return copy.deepcopy(config)\r\n   2398 \r\n   2399     @classmethod\r\n\r\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\r\n    153     copier = _deepcopy_dispatch.get(cls)\r\n    154     if copier:\r\n--> 155         y = copier(x, memo)\r\n    156     else:\r\n    157         try:\r\n\r\n/usr/lib/python3.5/copy.py in _deepcopy_dict(x, memo)\r\n    241     memo[id(x)] = y\r\n    242     for key, value in x.items():\r\n--> 243         y[deepcopy(key, memo)] = deepcopy(value, memo)\r\n    244     return y\r\n    245 d[dict] = _deepcopy_dict\r\n\r\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\r\n    153     copier = _deepcopy_dispatch.get(cls)\r\n    154     if copier:\r\n--> 155         y = copier(x, memo)\r\n    156     else:\r\n    157         try:\r\n\r\n/usr/lib/python3.5/copy.py in _deepcopy_list(x, memo)\r\n    216     memo[id(x)] = y\r\n    217     for a in x:\r\n--> 218         y.append(deepcopy(a, memo))\r\n    219     return y\r\n    220 d[list] = _deepcopy_list\r\n\r\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\r\n    153     copier = _deepcopy_dispatch.get(cls)\r\n    154     if copier:\r\n--> 155         y = copier(x, memo)\r\n    156     else:\r\n    157         try:\r\n\r\n/usr/lib/python3.5/copy.py in _deepcopy_dict(x, memo)\r\n    241     memo[id(x)] = y\r\n    242     for key, value in x.items():\r\n--> 243         y[deepcopy(key, memo)] = deepcopy(value, memo)\r\n    244     return y\r\n    245 d[dict] = _deepcopy_dict\r\n\r\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\r\n    153     copier = _deepcopy_dispatch.get(cls)\r\n    154     if copier:\r\n--> 155         y = copier(x, memo)\r\n    156     else:\r\n    157         try:\r\n\r\n/usr/lib/python3.5/copy.py in _deepcopy_dict(x, memo)\r\n    241     memo[id(x)] = y\r\n    242     for key, value in x.items():\r\n--> 243         y[deepcopy(key, memo)] = deepcopy(value, memo)\r\n    244     return y\r\n    245 d[dict] = _deepcopy_dict\r\n\r\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\r\n    153     copier = _deepcopy_dispatch.get(cls)\r\n    154     if copier:\r\n--> 155         y = copier(x, memo)\r\n    156     else:\r\n    157         try:\r\n\r\n/usr/lib/python3.5/copy.py in _deepcopy_tuple(x, memo)\r\n    221 \r\n    222 def _deepcopy_tuple(x, memo):\r\n--> 223     y = [deepcopy(a, memo) for a in x]\r\n    224     # We're not going to put the tuple in the memo, but it's still important we\r\n    225     # check for it, in case the tuple contains recursive mutable structures.\r\n\r\n/usr/lib/python3.5/copy.py in <listcomp>(.0)\r\n    221 \r\n    222 def _deepcopy_tuple(x, memo):\r\n--> 223     y = [deepcopy(a, memo) for a in x]\r\n    224     # We're not going to put the tuple in the memo, but it's still important we\r\n    225     # check for it, in case the tuple contains recursive mutable structures.\r\n\r\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\r\n    153     copier = _deepcopy_dispatch.get(cls)\r\n    154     if copier:\r\n--> 155         y = copier(x, memo)\r\n    156     else:\r\n    157         try:\r\n\r\n/usr/lib/python3.5/copy.py in _deepcopy_tuple(x, memo)\r\n    221 \r\n    222 def _deepcopy_tuple(x, memo):\r\n--> 223     y = [deepcopy(a, memo) for a in x]\r\n    224     # We're not going to put the tuple in the memo, but it's still important we\r\n    225     # check for it, in case the tuple contains recursive mutable structures.\r\n\r\n/usr/lib/python3.5/copy.py in <listcomp>(.0)\r\n    221 \r\n    222 def _deepcopy_tuple(x, memo):\r\n--> 223     y = [deepcopy(a, memo) for a in x]\r\n    224     # We're not going to put the tuple in the memo, but it's still important we\r\n    225     # check for it, in case the tuple contains recursive mutable structures.\r\n\r\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\r\n    180                             raise Error(\r\n    181                                 \"un(deep)copyable object of type %s\" % cls)\r\n--> 182                 y = _reconstruct(x, rv, 1, memo)\r\n    183 \r\n    184     # If is its own copy, don't memoize.\r\n\r\n/usr/lib/python3.5/copy.py in _reconstruct(x, info, deep, memo)\r\n    295     if state is not None:\r\n    296         if deep:\r\n--> 297             state = deepcopy(state, memo)\r\n    298         if hasattr(y, '__setstate__'):\r\n    299             y.__setstate__(state)\r\n\r\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\r\n    153     copier = _deepcopy_dispatch.get(cls)\r\n    154     if copier:\r\n--> 155         y = copier(x, memo)\r\n    156     else:\r\n    157         try:\r\n\r\n/usr/lib/python3.5/copy.py in _deepcopy_dict(x, memo)\r\n    241     memo[id(x)] = y\r\n    242     for key, value in x.items():\r\n--> 243         y[deepcopy(key, memo)] = deepcopy(value, memo)\r\n    244     return y\r\n    245 d[dict] = _deepcopy_dict\r\n\r\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\r\n    180                             raise Error(\r\n    181                                 \"un(deep)copyable object of type %s\" % cls)\r\n--> 182                 y = _reconstruct(x, rv, 1, memo)\r\n    183 \r\n    184     # If is its own copy, don't memoize.\r\n\r\n/usr/lib/python3.5/copy.py in _reconstruct(x, info, deep, memo)\r\n    295     if state is not None:\r\n    296         if deep:\r\n--> 297             state = deepcopy(state, memo)\r\n    298         if hasattr(y, '__setstate__'):\r\n    299             y.__setstate__(state)\r\n\r\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\r\n    153     copier = _deepcopy_dispatch.get(cls)\r\n    154     if copier:\r\n--> 155         y = copier(x, memo)\r\n    156     else:\r\n    157         try:\r\n\r\n/usr/lib/python3.5/copy.py in _deepcopy_dict(x, memo)\r\n    241     memo[id(x)] = y\r\n    242     for key, value in x.items():\r\n--> 243         y[deepcopy(key, memo)] = deepcopy(value, memo)\r\n    244     return y\r\n    245 d[dict] = _deepcopy_dict\r\n\r\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\r\n    153     copier = _deepcopy_dispatch.get(cls)\r\n    154     if copier:\r\n--> 155         y = copier(x, memo)\r\n    156     else:\r\n    157         try:\r\n\r\n/usr/lib/python3.5/copy.py in _deepcopy_dict(x, memo)\r\n    241     memo[id(x)] = y\r\n    242     for key, value in x.items():\r\n--> 243         y[deepcopy(key, memo)] = deepcopy(value, memo)\r\n    244     return y\r\n    245 d[dict] = _deepcopy_dict\r\n\r\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\r\n    153     copier = _deepcopy_dispatch.get(cls)\r\n    154     if copier:\r\n--> 155         y = copier(x, memo)\r\n    156     else:\r\n    157         try:\r\n\r\n/usr/lib/python3.5/copy.py in _deepcopy_method(x, memo)\r\n    248 \r\n    249 def _deepcopy_method(x, memo): # Copy instance methods\r\n--> 250     return type(x)(x.__func__, deepcopy(x.__self__, memo))\r\n    251 _deepcopy_dispatch[types.MethodType] = _deepcopy_method\r\n    252 \r\n\r\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\r\n    180                             raise Error(\r\n    181                                 \"un(deep)copyable object of type %s\" % cls)\r\n--> 182                 y = _reconstruct(x, rv, 1, memo)\r\n    183 \r\n    184     # If is its own copy, don't memoize.\r\n\r\n/usr/lib/python3.5/copy.py in _reconstruct(x, info, deep, memo)\r\n    295     if state is not None:\r\n    296         if deep:\r\n--> 297             state = deepcopy(state, memo)\r\n    298         if hasattr(y, '__setstate__'):\r\n    299             y.__setstate__(state)\r\n\r\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\r\n    153     copier = _deepcopy_dispatch.get(cls)\r\n    154     if copier:\r\n--> 155         y = copier(x, memo)\r\n    156     else:\r\n    157         try:\r\n\r\n/usr/lib/python3.5/copy.py in _deepcopy_dict(x, memo)\r\n    241     memo[id(x)] = y\r\n    242     for key, value in x.items():\r\n--> 243         y[deepcopy(key, memo)] = deepcopy(value, memo)\r\n    244     return y\r\n    245 d[dict] = _deepcopy_dict\r\n\r\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\r\n    153     copier = _deepcopy_dispatch.get(cls)\r\n    154     if copier:\r\n--> 155         y = copier(x, memo)\r\n    156     else:\r\n    157         try:\r\n\r\n/usr/lib/python3.5/copy.py in _deepcopy_dict(x, memo)\r\n    241     memo[id(x)] = y\r\n    242     for key, value in x.items():\r\n--> 243         y[deepcopy(key, memo)] = deepcopy(value, memo)\r\n    244     return y\r\n    245 d[dict] = _deepcopy_dict\r\n\r\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\r\n    180                             raise Error(\r\n    181                                 \"un(deep)copyable object of type %s\" % cls)\r\n--> 182                 y = _reconstruct(x, rv, 1, memo)\r\n    183 \r\n    184     # If is its own copy, don't memoize.\r\n\r\n/usr/lib/python3.5/copy.py in _reconstruct(x, info, deep, memo)\r\n    295     if state is not None:\r\n    296         if deep:\r\n--> 297             state = deepcopy(state, memo)\r\n    298         if hasattr(y, '__setstate__'):\r\n    299             y.__setstate__(state)\r\n\r\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\r\n    153     copier = _deepcopy_dispatch.get(cls)\r\n    154     if copier:\r\n--> 155         y = copier(x, memo)\r\n    156     else:\r\n    157         try:\r\n\r\n/usr/lib/python3.5/copy.py in _deepcopy_dict(x, memo)\r\n    241     memo[id(x)] = y\r\n    242     for key, value in x.items():\r\n--> 243         y[deepcopy(key, memo)] = deepcopy(value, memo)\r\n    244     return y\r\n    245 d[dict] = _deepcopy_dict\r\n\r\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\r\n    153     copier = _deepcopy_dispatch.get(cls)\r\n    154     if copier:\r\n--> 155         y = copier(x, memo)\r\n    156     else:\r\n    157         try:\r\n\r\n/usr/lib/python3.5/copy.py in _deepcopy_dict(x, memo)\r\n    241     memo[id(x)] = y\r\n    242     for key, value in x.items():\r\n--> 243         y[deepcopy(key, memo)] = deepcopy(value, memo)\r\n    244     return y\r\n    245 d[dict] = _deepcopy_dict\r\n\r\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\r\n    180                             raise Error(\r\n    181                                 \"un(deep)copyable object of type %s\" % cls)\r\n--> 182                 y = _reconstruct(x, rv, 1, memo)\r\n    183 \r\n    184     # If is its own copy, don't memoize.\r\n\r\n/usr/lib/python3.5/copy.py in _reconstruct(x, info, deep, memo)\r\n    295     if state is not None:\r\n    296         if deep:\r\n--> 297             state = deepcopy(state, memo)\r\n    298         if hasattr(y, '__setstate__'):\r\n    299             y.__setstate__(state)\r\n\r\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\r\n    153     copier = _deepcopy_dispatch.get(cls)\r\n    154     if copier:\r\n--> 155         y = copier(x, memo)\r\n    156     else:\r\n    157         try:\r\n\r\n/usr/lib/python3.5/copy.py in _deepcopy_dict(x, memo)\r\n    241     memo[id(x)] = y\r\n    242     for key, value in x.items():\r\n--> 243         y[deepcopy(key, memo)] = deepcopy(value, memo)\r\n    244     return y\r\n    245 d[dict] = _deepcopy_dict\r\n\r\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\r\n    180                             raise Error(\r\n    181                                 \"un(deep)copyable object of type %s\" % cls)\r\n--> 182                 y = _reconstruct(x, rv, 1, memo)\r\n    183 \r\n    184     # If is its own copy, don't memoize.\r\n\r\n/usr/lib/python3.5/copy.py in _reconstruct(x, info, deep, memo)\r\n    295     if state is not None:\r\n    296         if deep:\r\n--> 297             state = deepcopy(state, memo)\r\n    298         if hasattr(y, '__setstate__'):\r\n    299             y.__setstate__(state)\r\n\r\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\r\n    153     copier = _deepcopy_dispatch.get(cls)\r\n    154     if copier:\r\n--> 155         y = copier(x, memo)\r\n    156     else:\r\n    157         try:\r\n\r\n/usr/lib/python3.5/copy.py in _deepcopy_dict(x, memo)\r\n    241     memo[id(x)] = y\r\n    242     for key, value in x.items():\r\n--> 243         y[deepcopy(key, memo)] = deepcopy(value, memo)\r\n    244     return y\r\n    245 d[dict] = _deepcopy_dict\r\n\r\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\r\n    180                             raise Error(\r\n    181                                 \"un(deep)copyable object of type %s\" % cls)\r\n--> 182                 y = _reconstruct(x, rv, 1, memo)\r\n    183 \r\n    184     # If is its own copy, don't memoize.\r\n\r\n/usr/lib/python3.5/copy.py in _reconstruct(x, info, deep, memo)\r\n    295     if state is not None:\r\n    296         if deep:\r\n--> 297             state = deepcopy(state, memo)\r\n    298         if hasattr(y, '__setstate__'):\r\n    299             y.__setstate__(state)\r\n\r\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\r\n    153     copier = _deepcopy_dispatch.get(cls)\r\n    154     if copier:\r\n--> 155         y = copier(x, memo)\r\n    156     else:\r\n    157         try:\r\n\r\n/usr/lib/python3.5/copy.py in _deepcopy_dict(x, memo)\r\n    241     memo[id(x)] = y\r\n    242     for key, value in x.items():\r\n--> 243         y[deepcopy(key, memo)] = deepcopy(value, memo)\r\n    244     return y\r\n    245 d[dict] = _deepcopy_dict\r\n\r\n/usr/lib/python3.5/copy.py in deepcopy(x, memo, _nil)\r\n    172                     reductor = getattr(x, \"__reduce_ex__\", None)\r\n    173                     if reductor:\r\n--> 174                         rv = reductor(4)\r\n    175                     else:\r\n    176                         reductor = getattr(x, \"__reduce__\", None)\r\n\r\nTypeError: can't pickle _thread.lock objects\r\n```"}