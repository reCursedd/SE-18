{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/15340", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/15340/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/15340/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/15340/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/15340", "id": 281749310, "node_id": "MDU6SXNzdWUyODE3NDkzMTA=", "number": 15340, "title": "StagingArea.get() ignores timeout", "user": {"login": "maxhgerlach", "id": 1778667, "node_id": "MDQ6VXNlcjE3Nzg2Njc=", "avatar_url": "https://avatars1.githubusercontent.com/u/1778667?v=4", "gravatar_id": "", "url": "https://api.github.com/users/maxhgerlach", "html_url": "https://github.com/maxhgerlach", "followers_url": "https://api.github.com/users/maxhgerlach/followers", "following_url": "https://api.github.com/users/maxhgerlach/following{/other_user}", "gists_url": "https://api.github.com/users/maxhgerlach/gists{/gist_id}", "starred_url": "https://api.github.com/users/maxhgerlach/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/maxhgerlach/subscriptions", "organizations_url": "https://api.github.com/users/maxhgerlach/orgs", "repos_url": "https://api.github.com/users/maxhgerlach/repos", "events_url": "https://api.github.com/users/maxhgerlach/events{/privacy}", "received_events_url": "https://api.github.com/users/maxhgerlach/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 404586594, "node_id": "MDU6TGFiZWw0MDQ1ODY1OTQ=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:awaiting%20tensorflower", "name": "stat:awaiting tensorflower", "color": "f4b400", "default": false}], "state": "closed", "locked": false, "assignee": {"login": "bignamehyp", "id": 3474655, "node_id": "MDQ6VXNlcjM0NzQ2NTU=", "avatar_url": "https://avatars2.githubusercontent.com/u/3474655?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bignamehyp", "html_url": "https://github.com/bignamehyp", "followers_url": "https://api.github.com/users/bignamehyp/followers", "following_url": "https://api.github.com/users/bignamehyp/following{/other_user}", "gists_url": "https://api.github.com/users/bignamehyp/gists{/gist_id}", "starred_url": "https://api.github.com/users/bignamehyp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bignamehyp/subscriptions", "organizations_url": "https://api.github.com/users/bignamehyp/orgs", "repos_url": "https://api.github.com/users/bignamehyp/repos", "events_url": "https://api.github.com/users/bignamehyp/events{/privacy}", "received_events_url": "https://api.github.com/users/bignamehyp/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "bignamehyp", "id": 3474655, "node_id": "MDQ6VXNlcjM0NzQ2NTU=", "avatar_url": "https://avatars2.githubusercontent.com/u/3474655?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bignamehyp", "html_url": "https://github.com/bignamehyp", "followers_url": "https://api.github.com/users/bignamehyp/followers", "following_url": "https://api.github.com/users/bignamehyp/following{/other_user}", "gists_url": "https://api.github.com/users/bignamehyp/gists{/gist_id}", "starred_url": "https://api.github.com/users/bignamehyp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bignamehyp/subscriptions", "organizations_url": "https://api.github.com/users/bignamehyp/orgs", "repos_url": "https://api.github.com/users/bignamehyp/repos", "events_url": "https://api.github.com/users/bignamehyp/events{/privacy}", "received_events_url": "https://api.github.com/users/bignamehyp/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 10, "created_at": "2017-12-13T13:28:01Z", "updated_at": "2018-03-31T18:58:41Z", "closed_at": "2018-03-31T18:31:35Z", "author_association": "NONE", "body_html": "<h3>System information</h3>\n<ul>\n<li><strong>Have I written custom code (as opposed to using a stock example script provided in TensorFlow)</strong>: yes</li>\n<li><strong>OS Platform and Distribution (e.g., Linux Ubuntu 16.04)</strong>: macOS 10.13.1</li>\n<li><strong>TensorFlow installed from (source or binary)</strong>: binary</li>\n<li><strong>TensorFlow version (use command below)</strong>: 1.4.1</li>\n<li><strong>Python version</strong>: 2.7.14</li>\n<li><strong>Bazel version (if compiling from source)</strong>:</li>\n<li><strong>GCC/Compiler version (if compiling from source)</strong>:</li>\n<li><strong>CUDA/cuDNN version</strong>:</li>\n<li><strong>GPU model and memory</strong>:</li>\n<li><strong>Exact command to reproduce</strong>:</li>\n</ul>\n<h3>Describe the problem</h3>\n<p>The <code>get()</code> method of a <code>tf.contrib.staging.StagingArea</code> is a blocking operation. I would expect it to respect any operation timeout that has been set for the Tensorflow session. This is important to avoid deadlocks, e.g., if the StagingArea is empty.</p>\n<p>In comparison, the <code>dequeue()</code> method of a <code>tf.FIFOQueue</code> respects the timeout by raising<code>tf.errors.DeadlineExceededError</code>.</p>\n<h3>Source code / logs</h3>\n<p>Example script:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">import</span> tensorflow <span class=\"pl-k\">as</span> tf\n<span class=\"pl-k\">from</span> <span class=\"pl-c1\">__future__</span> <span class=\"pl-k\">import</span> print_function\n\n<span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Testing tf.FIFOQueue<span class=\"pl-pds\">\"</span></span>)\nempty_queue <span class=\"pl-k\">=</span> tf.FIFOQueue(<span class=\"pl-v\">capacity</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">1</span>, <span class=\"pl-v\">shapes</span><span class=\"pl-k\">=</span>[<span class=\"pl-c1\">1</span>,], <span class=\"pl-v\">dtypes</span><span class=\"pl-k\">=</span>tf.int32)\n<span class=\"pl-k\">with</span> tf.Session() <span class=\"pl-k\">as</span> sess:\n  <span class=\"pl-k\">try</span>:\n    <span class=\"pl-c1\">print</span>(sess.run(empty_queue.dequeue(), <span class=\"pl-v\">options</span><span class=\"pl-k\">=</span>tf.RunOptions(<span class=\"pl-v\">timeout_in_ms</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">500</span>)))\n  <span class=\"pl-k\">except</span> tf.errors.DeadlineExceededError <span class=\"pl-k\">as</span> e:\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Error:<span class=\"pl-pds\">\"</span></span>, e)\n\n\n<span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Testing tf.contrib.staging.StagingArea<span class=\"pl-pds\">\"</span></span>)\nempty_stagingArea <span class=\"pl-k\">=</span> tf.contrib.staging.StagingArea([tf.int64], <span class=\"pl-v\">shapes</span><span class=\"pl-k\">=</span>[(<span class=\"pl-c1\">1</span>,)])\n<span class=\"pl-k\">with</span> tf.Session() <span class=\"pl-k\">as</span> sess:\n  <span class=\"pl-k\">try</span>:\n    <span class=\"pl-c1\">print</span>(sess.run(empty_stagingArea.get(), <span class=\"pl-v\">options</span><span class=\"pl-k\">=</span>tf.RunOptions(<span class=\"pl-v\">timeout_in_ms</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">500</span>)))\n  <span class=\"pl-k\">except</span> tf.errors.DeadlineExceededError <span class=\"pl-k\">as</span> e:\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Error:<span class=\"pl-pds\">\"</span></span>, e)</pre></div>\n<p>Example output:</p>\n<pre><code>Testing tf.FIFOQueue\nError: Timed out waiting for notification\nTesting tf.contrib.staging.StagingArea\n</code></pre>\n<p>The final <code>sess.run</code> call hangs indefinitely.</p>", "body_text": "System information\n\nHave I written custom code (as opposed to using a stock example script provided in TensorFlow): yes\nOS Platform and Distribution (e.g., Linux Ubuntu 16.04): macOS 10.13.1\nTensorFlow installed from (source or binary): binary\nTensorFlow version (use command below): 1.4.1\nPython version: 2.7.14\nBazel version (if compiling from source):\nGCC/Compiler version (if compiling from source):\nCUDA/cuDNN version:\nGPU model and memory:\nExact command to reproduce:\n\nDescribe the problem\nThe get() method of a tf.contrib.staging.StagingArea is a blocking operation. I would expect it to respect any operation timeout that has been set for the Tensorflow session. This is important to avoid deadlocks, e.g., if the StagingArea is empty.\nIn comparison, the dequeue() method of a tf.FIFOQueue respects the timeout by raisingtf.errors.DeadlineExceededError.\nSource code / logs\nExample script:\nimport tensorflow as tf\nfrom __future__ import print_function\n\nprint(\"Testing tf.FIFOQueue\")\nempty_queue = tf.FIFOQueue(capacity=1, shapes=[1,], dtypes=tf.int32)\nwith tf.Session() as sess:\n  try:\n    print(sess.run(empty_queue.dequeue(), options=tf.RunOptions(timeout_in_ms = 500)))\n  except tf.errors.DeadlineExceededError as e:\n    print(\"Error:\", e)\n\n\nprint(\"Testing tf.contrib.staging.StagingArea\")\nempty_stagingArea = tf.contrib.staging.StagingArea([tf.int64], shapes=[(1,)])\nwith tf.Session() as sess:\n  try:\n    print(sess.run(empty_stagingArea.get(), options=tf.RunOptions(timeout_in_ms = 500)))\n  except tf.errors.DeadlineExceededError as e:\n    print(\"Error:\", e)\nExample output:\nTesting tf.FIFOQueue\nError: Timed out waiting for notification\nTesting tf.contrib.staging.StagingArea\n\nThe final sess.run call hangs indefinitely.", "body": "### System information\r\n- **Have I written custom code (as opposed to using a stock example script provided in TensorFlow)**: yes\r\n- **OS Platform and Distribution (e.g., Linux Ubuntu 16.04)**: macOS 10.13.1\r\n- **TensorFlow installed from (source or binary)**: binary\r\n- **TensorFlow version (use command below)**: 1.4.1\r\n- **Python version**: 2.7.14\r\n- **Bazel version (if compiling from source)**:\r\n- **GCC/Compiler version (if compiling from source)**:\r\n- **CUDA/cuDNN version**:\r\n- **GPU model and memory**:\r\n- **Exact command to reproduce**:\r\n\r\n### Describe the problem\r\nThe `get()` method of a `tf.contrib.staging.StagingArea` is a blocking operation. I would expect it to respect any operation timeout that has been set for the Tensorflow session. This is important to avoid deadlocks, e.g., if the StagingArea is empty.\r\n\r\nIn comparison, the `dequeue()` method of a `tf.FIFOQueue` respects the timeout by raising`tf.errors.DeadlineExceededError`.\r\n\r\n\r\n### Source code / logs\r\nExample script:\r\n```python\r\nimport tensorflow as tf\r\nfrom __future__ import print_function\r\n\r\nprint(\"Testing tf.FIFOQueue\")\r\nempty_queue = tf.FIFOQueue(capacity=1, shapes=[1,], dtypes=tf.int32)\r\nwith tf.Session() as sess:\r\n  try:\r\n    print(sess.run(empty_queue.dequeue(), options=tf.RunOptions(timeout_in_ms = 500)))\r\n  except tf.errors.DeadlineExceededError as e:\r\n    print(\"Error:\", e)\r\n\r\n\r\nprint(\"Testing tf.contrib.staging.StagingArea\")\r\nempty_stagingArea = tf.contrib.staging.StagingArea([tf.int64], shapes=[(1,)])\r\nwith tf.Session() as sess:\r\n  try:\r\n    print(sess.run(empty_stagingArea.get(), options=tf.RunOptions(timeout_in_ms = 500)))\r\n  except tf.errors.DeadlineExceededError as e:\r\n    print(\"Error:\", e)\r\n```\r\nExample output:\r\n```\r\nTesting tf.FIFOQueue\r\nError: Timed out waiting for notification\r\nTesting tf.contrib.staging.StagingArea\r\n```\r\nThe final `sess.run` call hangs indefinitely."}