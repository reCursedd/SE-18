{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/286024511", "html_url": "https://github.com/tensorflow/tensorflow/issues/4742#issuecomment-286024511", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/4742", "id": 286024511, "node_id": "MDEyOklzc3VlQ29tbWVudDI4NjAyNDUxMQ==", "user": {"login": "ahundt", "id": 55744, "node_id": "MDQ6VXNlcjU1NzQ0", "avatar_url": "https://avatars1.githubusercontent.com/u/55744?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ahundt", "html_url": "https://github.com/ahundt", "followers_url": "https://api.github.com/users/ahundt/followers", "following_url": "https://api.github.com/users/ahundt/following{/other_user}", "gists_url": "https://api.github.com/users/ahundt/gists{/gist_id}", "starred_url": "https://api.github.com/users/ahundt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ahundt/subscriptions", "organizations_url": "https://api.github.com/users/ahundt/orgs", "repos_url": "https://api.github.com/users/ahundt/repos", "events_url": "https://api.github.com/users/ahundt/events{/privacy}", "received_events_url": "https://api.github.com/users/ahundt/received_events", "type": "User", "site_admin": false}, "created_at": "2017-03-13T06:23:53Z", "updated_at": "2017-03-13T17:54:44Z", "author_association": "NONE", "body_html": "<p>Okay I answered my own question. Yes, both <code>tf.nn.atrous_conv2d</code> and <code>tf.nn.convolution</code> produce the same output dimensions with the <code>SAME</code> flag. I was mixing up the effect of filter size on output dimension, sorry about that.</p>\n<p>I made this test and ran it on tf 1.0 which does confirm the original issue with <code>None</code> values:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">import</span> tensorflow <span class=\"pl-k\">as</span> tf\n<span class=\"pl-k\">import</span> numpy <span class=\"pl-k\">as</span> np\n\ninput_img_np <span class=\"pl-k\">=</span> np.random.random((<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">256</span>, <span class=\"pl-c1\">256</span>, <span class=\"pl-c1\">1</span>)).astype(np.float32)\nkernel <span class=\"pl-k\">=</span>  np.random.random((<span class=\"pl-c1\">6</span>,<span class=\"pl-c1\">6</span>,<span class=\"pl-c1\">1</span>,<span class=\"pl-c1\">1</span>)).astype(np.float32)\n\n<span class=\"pl-k\">with</span> tf.Session() <span class=\"pl-k\">as</span> sess:\n    concrete_input_op <span class=\"pl-k\">=</span> tf.constant(input_img_np)\n    concrete_output_op <span class=\"pl-k\">=</span> tf.nn.convolution(concrete_input_op, kernel, <span class=\"pl-v\">padding</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>SAME<span class=\"pl-pds\">'</span></span>, <span class=\"pl-v\">dilation_rate</span><span class=\"pl-k\">=</span>np.array([<span class=\"pl-c1\">2</span>, <span class=\"pl-c1\">2</span>]))\n    concrete_output <span class=\"pl-k\">=</span> sess.run(concrete_output_op)\n    \n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>convolution + CONCRETE + SAME<span class=\"pl-pds\">'</span></span>)\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>concrete_input_op: <span class=\"pl-pds\">'</span></span>, concrete_input_op.get_shape())\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>concrete_output_op: <span class=\"pl-pds\">'</span></span>, concrete_output_op.get_shape())\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>concrete_output:<span class=\"pl-pds\">'</span></span>, concrete_output.shape)\n    <span class=\"pl-k\">assert</span>(concrete_input_op.get_shape() <span class=\"pl-k\">==</span> concrete_output_op.get_shape())\n\n\n    undef_input_op <span class=\"pl-k\">=</span> tf.placeholder(tf.float32, <span class=\"pl-v\">shape</span><span class=\"pl-k\">=</span>(<span class=\"pl-c1\">None</span>, <span class=\"pl-c1\">256</span>, <span class=\"pl-c1\">256</span>, <span class=\"pl-c1\">1</span>))\n    undef_output_op <span class=\"pl-k\">=</span> tf.nn.convolution(undef_input_op, kernel, <span class=\"pl-v\">padding</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>SAME<span class=\"pl-pds\">'</span></span>, <span class=\"pl-v\">dilation_rate</span><span class=\"pl-k\">=</span>np.array([<span class=\"pl-c1\">2</span>, <span class=\"pl-c1\">2</span>]))\n    undef_output <span class=\"pl-k\">=</span> sess.run(undef_output_op, <span class=\"pl-v\">feed_dict</span><span class=\"pl-k\">=</span>{undef_input_op: input_img_np})\n    \n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>convolution + UNDEF + SAME<span class=\"pl-pds\">'</span></span>)\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>undef_input_op: <span class=\"pl-pds\">'</span></span>, undef_input_op.get_shape())\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>undef_output_op: <span class=\"pl-pds\">'</span></span>, undef_output_op.get_shape())\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>undef_output:<span class=\"pl-pds\">'</span></span>, undef_output.shape)\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> This assert will correctly fail even though the shapes are ok because shapes are only partially known</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> assert(undef_input_op.get_shape() == undef_output_op.get_shape())</span>\n\n    valid_concrete_input_op <span class=\"pl-k\">=</span> tf.constant(input_img_np)\n    valid_concrete_output_op <span class=\"pl-k\">=</span> tf.nn.convolution(valid_concrete_input_op, kernel, <span class=\"pl-v\">padding</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>VALID<span class=\"pl-pds\">'</span></span>, <span class=\"pl-v\">dilation_rate</span><span class=\"pl-k\">=</span>np.array([<span class=\"pl-c1\">2</span>, <span class=\"pl-c1\">2</span>]))\n    valid_concrete_output <span class=\"pl-k\">=</span> sess.run(valid_concrete_output_op)\n    \n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>convolution + CONCRETE + VALID<span class=\"pl-pds\">'</span></span>)\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>valid_concrete_input_op: <span class=\"pl-pds\">'</span></span>, valid_concrete_input_op.get_shape())\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>valid_concrete_output_op: <span class=\"pl-pds\">'</span></span>, valid_concrete_output_op.get_shape())\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>valid_concrete_output:<span class=\"pl-pds\">'</span></span>, valid_concrete_output.shape)\n\n\n    valid_undef_input_op <span class=\"pl-k\">=</span> tf.placeholder(tf.float32, <span class=\"pl-v\">shape</span><span class=\"pl-k\">=</span>(<span class=\"pl-c1\">None</span>, <span class=\"pl-c1\">256</span>, <span class=\"pl-c1\">256</span>, <span class=\"pl-c1\">1</span>))\n    valid_undef_output_op <span class=\"pl-k\">=</span> tf.nn.convolution(valid_undef_input_op, kernel, <span class=\"pl-v\">padding</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>VALID<span class=\"pl-pds\">'</span></span>, <span class=\"pl-v\">dilation_rate</span><span class=\"pl-k\">=</span>np.array([<span class=\"pl-c1\">2</span>, <span class=\"pl-c1\">2</span>]))\n    valid_undef_output <span class=\"pl-k\">=</span> sess.run(valid_undef_output_op, <span class=\"pl-v\">feed_dict</span><span class=\"pl-k\">=</span>{valid_undef_input_op: input_img_np})\n    \n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>convolution + UNDEF + VALID<span class=\"pl-pds\">'</span></span>)\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>valid_undef_input_op: <span class=\"pl-pds\">'</span></span>,  valid_undef_input_op.get_shape())\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>valid_undef_output_op: <span class=\"pl-pds\">'</span></span>, valid_undef_output_op.get_shape())\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>valid_undef_output:<span class=\"pl-pds\">'</span></span>, valid_undef_output.shape)\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> This assert will correctly fail even though the shapes are ok because shapes are only partially known</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> assert(undef_input_op.get_shape() == undef_output_op.get_shape())</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span>###########################################################################</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> Now atrous</span>\n    concrete_input_op <span class=\"pl-k\">=</span> tf.constant(input_img_np)\n    concrete_output_op <span class=\"pl-k\">=</span> tf.nn.atrous_conv2d(concrete_input_op, kernel, <span class=\"pl-v\">padding</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>SAME<span class=\"pl-pds\">'</span></span>, <span class=\"pl-v\">rate</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">2</span>)\n    concrete_output <span class=\"pl-k\">=</span> sess.run(concrete_output_op)\n    \n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>atrous_conv2d + CONCRETE + SAME<span class=\"pl-pds\">'</span></span>)\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>concrete_input_op: <span class=\"pl-pds\">'</span></span>, concrete_input_op.get_shape())\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>concrete_output_op: <span class=\"pl-pds\">'</span></span>, concrete_output_op.get_shape())\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>concrete_output_op: <span class=\"pl-pds\">'</span></span>, concrete_output_op.get_shape())\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>concrete_output:<span class=\"pl-pds\">'</span></span>, concrete_output.shape)\n    <span class=\"pl-k\">assert</span>(concrete_input_op.get_shape() <span class=\"pl-k\">==</span> concrete_output_op.get_shape())\n\n\n    undef_input_op <span class=\"pl-k\">=</span> tf.placeholder(tf.float32, <span class=\"pl-v\">shape</span><span class=\"pl-k\">=</span>(<span class=\"pl-c1\">None</span>, <span class=\"pl-c1\">256</span>, <span class=\"pl-c1\">256</span>, <span class=\"pl-c1\">1</span>))\n    undef_output_op <span class=\"pl-k\">=</span> tf.nn.atrous_conv2d(undef_input_op, kernel, <span class=\"pl-v\">padding</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>SAME<span class=\"pl-pds\">'</span></span>, <span class=\"pl-v\">rate</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">2</span>)\n    undef_output <span class=\"pl-k\">=</span> sess.run(undef_output_op, <span class=\"pl-v\">feed_dict</span><span class=\"pl-k\">=</span>{undef_input_op: input_img_np})\n    \n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>atrous_conv2d + UNDEF + SAME<span class=\"pl-pds\">'</span></span>)\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>undef_input_op: <span class=\"pl-pds\">'</span></span>, undef_input_op.get_shape())\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>undef_output_op: <span class=\"pl-pds\">'</span></span>, undef_output_op.get_shape())\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>undef_output:<span class=\"pl-pds\">'</span></span>, undef_output.shape)\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> This assert will correctly fail even though the shapes are ok because shapes are only partially known</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> assert(undef_input_op.get_shape() == undef_output_op.get_shape())</span>\n\n    valid_concrete_input_op <span class=\"pl-k\">=</span> tf.constant(input_img_np)\n    valid_concrete_output_op <span class=\"pl-k\">=</span> tf.nn.atrous_conv2d(valid_concrete_input_op, kernel, <span class=\"pl-v\">padding</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>VALID<span class=\"pl-pds\">'</span></span>, <span class=\"pl-v\">rate</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">2</span>)\n    valid_concrete_output <span class=\"pl-k\">=</span> sess.run(valid_concrete_output_op)\n    \n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>atrous_conv2d + CONCRETE + VALID<span class=\"pl-pds\">'</span></span>)\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>valid_concrete_input_op: <span class=\"pl-pds\">'</span></span>, valid_concrete_input_op.get_shape())\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>valid_concrete_output_op: <span class=\"pl-pds\">'</span></span>, valid_concrete_output_op.get_shape())\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>valid_concrete_output:<span class=\"pl-pds\">'</span></span>, valid_concrete_output.shape)\n\n\n    valid_undef_input_op <span class=\"pl-k\">=</span> tf.placeholder(tf.float32, <span class=\"pl-v\">shape</span><span class=\"pl-k\">=</span>(<span class=\"pl-c1\">None</span>, <span class=\"pl-c1\">256</span>, <span class=\"pl-c1\">256</span>, <span class=\"pl-c1\">1</span>))\n    valid_undef_output_op <span class=\"pl-k\">=</span> tf.nn.atrous_conv2d(valid_undef_input_op, kernel, <span class=\"pl-v\">padding</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>VALID<span class=\"pl-pds\">'</span></span>, <span class=\"pl-v\">rate</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">2</span>)\n    valid_undef_output <span class=\"pl-k\">=</span> sess.run(valid_undef_output_op, <span class=\"pl-v\">feed_dict</span><span class=\"pl-k\">=</span>{valid_undef_input_op: input_img_np})\n    \n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>atrous_conv2d + UNDEF + VALID<span class=\"pl-pds\">'</span></span>)\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>valid_undef_input_op: <span class=\"pl-pds\">'</span></span>,  valid_undef_input_op.get_shape())\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>valid_undef_output_op: <span class=\"pl-pds\">'</span></span>, valid_undef_output_op.get_shape())\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>valid_undef_output:<span class=\"pl-pds\">'</span></span>, valid_undef_output.shape)\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> This assert will correctly fail even though the shapes are ok because shapes are only partially known</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> assert(undef_input_op.get_shape() == undef_output_op.get_shape())</span></pre></div>\n<p>Which produces this output with the additional <code>None</code> values on the last set of printouts:</p>\n<pre><code>convolution + CONCRETE + SAME\n('concrete_input_op: ', TensorShape([Dimension(1), Dimension(256), Dimension(256), Dimension(1)]))\n('concrete_output_op: ', TensorShape([Dimension(1), Dimension(256), Dimension(256), Dimension(1)]))\n('concrete_output:', (1, 256, 256, 1))\nconvolution + UNDEF + SAME\n('undef_input_op: ', TensorShape([Dimension(None), Dimension(256), Dimension(256), Dimension(1)]))\n('undef_output_op: ', TensorShape([Dimension(None), Dimension(256), Dimension(256), Dimension(1)]))\n('undef_output:', (1, 256, 256, 1))\nconvolution + CONCRETE + VALID\n('valid_concrete_input_op: ', TensorShape([Dimension(1), Dimension(256), Dimension(256), Dimension(1)]))\n('valid_concrete_output_op: ', TensorShape([Dimension(1), Dimension(246), Dimension(246), Dimension(1)]))\n('valid_concrete_output:', (1, 246, 246, 1))\nconvolution + UNDEF + VALID\n('valid_undef_input_op: ', TensorShape([Dimension(None), Dimension(256), Dimension(256), Dimension(1)]))\n('valid_undef_output_op: ', TensorShape([Dimension(None), Dimension(246), Dimension(246), Dimension(1)]))\n('valid_undef_output:', (1, 246, 246, 1))\natrous_conv2d + CONCRETE + SAME\n('concrete_input_op: ', TensorShape([Dimension(1), Dimension(256), Dimension(256), Dimension(1)]))\n('concrete_output_op: ', TensorShape([Dimension(1), Dimension(256), Dimension(256), Dimension(1)]))\n('concrete_output_op: ', TensorShape([Dimension(1), Dimension(256), Dimension(256), Dimension(1)]))\n('concrete_output:', (1, 256, 256, 1))\natrous_conv2d + UNDEF + SAME\n('undef_input_op: ', TensorShape([Dimension(None), Dimension(256), Dimension(256), Dimension(1)]))\n('undef_output_op: ', TensorShape([Dimension(None), Dimension(None), Dimension(None), Dimension(1)]))\n('undef_output:', (1, 256, 256, 1))\natrous_conv2d + CONCRETE + VALID\n('valid_concrete_input_op: ', TensorShape([Dimension(1), Dimension(256), Dimension(256), Dimension(1)]))\n('valid_concrete_output_op: ', TensorShape([Dimension(1), Dimension(246), Dimension(246), Dimension(1)]))\n('valid_concrete_output:', (1, 246, 246, 1))\natrous_conv2d + UNDEF + VALID\n('valid_undef_input_op: ', TensorShape([Dimension(None), Dimension(256), Dimension(256), Dimension(1)]))\n('valid_undef_output_op: ', TensorShape([Dimension(None), Dimension(None), Dimension(None), Dimension(1)]))\n('valid_undef_output:', (1, 246, 246, 1))\n</code></pre>", "body_text": "Okay I answered my own question. Yes, both tf.nn.atrous_conv2d and tf.nn.convolution produce the same output dimensions with the SAME flag. I was mixing up the effect of filter size on output dimension, sorry about that.\nI made this test and ran it on tf 1.0 which does confirm the original issue with None values:\nimport tensorflow as tf\nimport numpy as np\n\ninput_img_np = np.random.random((1, 256, 256, 1)).astype(np.float32)\nkernel =  np.random.random((6,6,1,1)).astype(np.float32)\n\nwith tf.Session() as sess:\n    concrete_input_op = tf.constant(input_img_np)\n    concrete_output_op = tf.nn.convolution(concrete_input_op, kernel, padding='SAME', dilation_rate=np.array([2, 2]))\n    concrete_output = sess.run(concrete_output_op)\n    \n    print('convolution + CONCRETE + SAME')\n    print('concrete_input_op: ', concrete_input_op.get_shape())\n    print('concrete_output_op: ', concrete_output_op.get_shape())\n    print('concrete_output:', concrete_output.shape)\n    assert(concrete_input_op.get_shape() == concrete_output_op.get_shape())\n\n\n    undef_input_op = tf.placeholder(tf.float32, shape=(None, 256, 256, 1))\n    undef_output_op = tf.nn.convolution(undef_input_op, kernel, padding='SAME', dilation_rate=np.array([2, 2]))\n    undef_output = sess.run(undef_output_op, feed_dict={undef_input_op: input_img_np})\n    \n    print('convolution + UNDEF + SAME')\n    print('undef_input_op: ', undef_input_op.get_shape())\n    print('undef_output_op: ', undef_output_op.get_shape())\n    print('undef_output:', undef_output.shape)\n    # This assert will correctly fail even though the shapes are ok because shapes are only partially known\n    # assert(undef_input_op.get_shape() == undef_output_op.get_shape())\n\n    valid_concrete_input_op = tf.constant(input_img_np)\n    valid_concrete_output_op = tf.nn.convolution(valid_concrete_input_op, kernel, padding='VALID', dilation_rate=np.array([2, 2]))\n    valid_concrete_output = sess.run(valid_concrete_output_op)\n    \n    print('convolution + CONCRETE + VALID')\n    print('valid_concrete_input_op: ', valid_concrete_input_op.get_shape())\n    print('valid_concrete_output_op: ', valid_concrete_output_op.get_shape())\n    print('valid_concrete_output:', valid_concrete_output.shape)\n\n\n    valid_undef_input_op = tf.placeholder(tf.float32, shape=(None, 256, 256, 1))\n    valid_undef_output_op = tf.nn.convolution(valid_undef_input_op, kernel, padding='VALID', dilation_rate=np.array([2, 2]))\n    valid_undef_output = sess.run(valid_undef_output_op, feed_dict={valid_undef_input_op: input_img_np})\n    \n    print('convolution + UNDEF + VALID')\n    print('valid_undef_input_op: ',  valid_undef_input_op.get_shape())\n    print('valid_undef_output_op: ', valid_undef_output_op.get_shape())\n    print('valid_undef_output:', valid_undef_output.shape)\n    # This assert will correctly fail even though the shapes are ok because shapes are only partially known\n    # assert(undef_input_op.get_shape() == undef_output_op.get_shape())\n    ############################################################################\n    # Now atrous\n    concrete_input_op = tf.constant(input_img_np)\n    concrete_output_op = tf.nn.atrous_conv2d(concrete_input_op, kernel, padding='SAME', rate=2)\n    concrete_output = sess.run(concrete_output_op)\n    \n    print('atrous_conv2d + CONCRETE + SAME')\n    print('concrete_input_op: ', concrete_input_op.get_shape())\n    print('concrete_output_op: ', concrete_output_op.get_shape())\n    print('concrete_output_op: ', concrete_output_op.get_shape())\n    print('concrete_output:', concrete_output.shape)\n    assert(concrete_input_op.get_shape() == concrete_output_op.get_shape())\n\n\n    undef_input_op = tf.placeholder(tf.float32, shape=(None, 256, 256, 1))\n    undef_output_op = tf.nn.atrous_conv2d(undef_input_op, kernel, padding='SAME', rate=2)\n    undef_output = sess.run(undef_output_op, feed_dict={undef_input_op: input_img_np})\n    \n    print('atrous_conv2d + UNDEF + SAME')\n    print('undef_input_op: ', undef_input_op.get_shape())\n    print('undef_output_op: ', undef_output_op.get_shape())\n    print('undef_output:', undef_output.shape)\n    # This assert will correctly fail even though the shapes are ok because shapes are only partially known\n    # assert(undef_input_op.get_shape() == undef_output_op.get_shape())\n\n    valid_concrete_input_op = tf.constant(input_img_np)\n    valid_concrete_output_op = tf.nn.atrous_conv2d(valid_concrete_input_op, kernel, padding='VALID', rate=2)\n    valid_concrete_output = sess.run(valid_concrete_output_op)\n    \n    print('atrous_conv2d + CONCRETE + VALID')\n    print('valid_concrete_input_op: ', valid_concrete_input_op.get_shape())\n    print('valid_concrete_output_op: ', valid_concrete_output_op.get_shape())\n    print('valid_concrete_output:', valid_concrete_output.shape)\n\n\n    valid_undef_input_op = tf.placeholder(tf.float32, shape=(None, 256, 256, 1))\n    valid_undef_output_op = tf.nn.atrous_conv2d(valid_undef_input_op, kernel, padding='VALID', rate=2)\n    valid_undef_output = sess.run(valid_undef_output_op, feed_dict={valid_undef_input_op: input_img_np})\n    \n    print('atrous_conv2d + UNDEF + VALID')\n    print('valid_undef_input_op: ',  valid_undef_input_op.get_shape())\n    print('valid_undef_output_op: ', valid_undef_output_op.get_shape())\n    print('valid_undef_output:', valid_undef_output.shape)\n    # This assert will correctly fail even though the shapes are ok because shapes are only partially known\n    # assert(undef_input_op.get_shape() == undef_output_op.get_shape())\nWhich produces this output with the additional None values on the last set of printouts:\nconvolution + CONCRETE + SAME\n('concrete_input_op: ', TensorShape([Dimension(1), Dimension(256), Dimension(256), Dimension(1)]))\n('concrete_output_op: ', TensorShape([Dimension(1), Dimension(256), Dimension(256), Dimension(1)]))\n('concrete_output:', (1, 256, 256, 1))\nconvolution + UNDEF + SAME\n('undef_input_op: ', TensorShape([Dimension(None), Dimension(256), Dimension(256), Dimension(1)]))\n('undef_output_op: ', TensorShape([Dimension(None), Dimension(256), Dimension(256), Dimension(1)]))\n('undef_output:', (1, 256, 256, 1))\nconvolution + CONCRETE + VALID\n('valid_concrete_input_op: ', TensorShape([Dimension(1), Dimension(256), Dimension(256), Dimension(1)]))\n('valid_concrete_output_op: ', TensorShape([Dimension(1), Dimension(246), Dimension(246), Dimension(1)]))\n('valid_concrete_output:', (1, 246, 246, 1))\nconvolution + UNDEF + VALID\n('valid_undef_input_op: ', TensorShape([Dimension(None), Dimension(256), Dimension(256), Dimension(1)]))\n('valid_undef_output_op: ', TensorShape([Dimension(None), Dimension(246), Dimension(246), Dimension(1)]))\n('valid_undef_output:', (1, 246, 246, 1))\natrous_conv2d + CONCRETE + SAME\n('concrete_input_op: ', TensorShape([Dimension(1), Dimension(256), Dimension(256), Dimension(1)]))\n('concrete_output_op: ', TensorShape([Dimension(1), Dimension(256), Dimension(256), Dimension(1)]))\n('concrete_output_op: ', TensorShape([Dimension(1), Dimension(256), Dimension(256), Dimension(1)]))\n('concrete_output:', (1, 256, 256, 1))\natrous_conv2d + UNDEF + SAME\n('undef_input_op: ', TensorShape([Dimension(None), Dimension(256), Dimension(256), Dimension(1)]))\n('undef_output_op: ', TensorShape([Dimension(None), Dimension(None), Dimension(None), Dimension(1)]))\n('undef_output:', (1, 256, 256, 1))\natrous_conv2d + CONCRETE + VALID\n('valid_concrete_input_op: ', TensorShape([Dimension(1), Dimension(256), Dimension(256), Dimension(1)]))\n('valid_concrete_output_op: ', TensorShape([Dimension(1), Dimension(246), Dimension(246), Dimension(1)]))\n('valid_concrete_output:', (1, 246, 246, 1))\natrous_conv2d + UNDEF + VALID\n('valid_undef_input_op: ', TensorShape([Dimension(None), Dimension(256), Dimension(256), Dimension(1)]))\n('valid_undef_output_op: ', TensorShape([Dimension(None), Dimension(None), Dimension(None), Dimension(1)]))\n('valid_undef_output:', (1, 246, 246, 1))", "body": "Okay I answered my own question. Yes, both `tf.nn.atrous_conv2d` and `tf.nn.convolution` produce the same output dimensions with the `SAME` flag. I was mixing up the effect of filter size on output dimension, sorry about that. \r\n\r\nI made this test and ran it on tf 1.0 which does confirm the original issue with `None` values:\r\n```python\r\nimport tensorflow as tf\r\nimport numpy as np\r\n\r\ninput_img_np = np.random.random((1, 256, 256, 1)).astype(np.float32)\r\nkernel =  np.random.random((6,6,1,1)).astype(np.float32)\r\n\r\nwith tf.Session() as sess:\r\n    concrete_input_op = tf.constant(input_img_np)\r\n    concrete_output_op = tf.nn.convolution(concrete_input_op, kernel, padding='SAME', dilation_rate=np.array([2, 2]))\r\n    concrete_output = sess.run(concrete_output_op)\r\n    \r\n    print('convolution + CONCRETE + SAME')\r\n    print('concrete_input_op: ', concrete_input_op.get_shape())\r\n    print('concrete_output_op: ', concrete_output_op.get_shape())\r\n    print('concrete_output:', concrete_output.shape)\r\n    assert(concrete_input_op.get_shape() == concrete_output_op.get_shape())\r\n\r\n\r\n    undef_input_op = tf.placeholder(tf.float32, shape=(None, 256, 256, 1))\r\n    undef_output_op = tf.nn.convolution(undef_input_op, kernel, padding='SAME', dilation_rate=np.array([2, 2]))\r\n    undef_output = sess.run(undef_output_op, feed_dict={undef_input_op: input_img_np})\r\n    \r\n    print('convolution + UNDEF + SAME')\r\n    print('undef_input_op: ', undef_input_op.get_shape())\r\n    print('undef_output_op: ', undef_output_op.get_shape())\r\n    print('undef_output:', undef_output.shape)\r\n    # This assert will correctly fail even though the shapes are ok because shapes are only partially known\r\n    # assert(undef_input_op.get_shape() == undef_output_op.get_shape())\r\n\r\n    valid_concrete_input_op = tf.constant(input_img_np)\r\n    valid_concrete_output_op = tf.nn.convolution(valid_concrete_input_op, kernel, padding='VALID', dilation_rate=np.array([2, 2]))\r\n    valid_concrete_output = sess.run(valid_concrete_output_op)\r\n    \r\n    print('convolution + CONCRETE + VALID')\r\n    print('valid_concrete_input_op: ', valid_concrete_input_op.get_shape())\r\n    print('valid_concrete_output_op: ', valid_concrete_output_op.get_shape())\r\n    print('valid_concrete_output:', valid_concrete_output.shape)\r\n\r\n\r\n    valid_undef_input_op = tf.placeholder(tf.float32, shape=(None, 256, 256, 1))\r\n    valid_undef_output_op = tf.nn.convolution(valid_undef_input_op, kernel, padding='VALID', dilation_rate=np.array([2, 2]))\r\n    valid_undef_output = sess.run(valid_undef_output_op, feed_dict={valid_undef_input_op: input_img_np})\r\n    \r\n    print('convolution + UNDEF + VALID')\r\n    print('valid_undef_input_op: ',  valid_undef_input_op.get_shape())\r\n    print('valid_undef_output_op: ', valid_undef_output_op.get_shape())\r\n    print('valid_undef_output:', valid_undef_output.shape)\r\n    # This assert will correctly fail even though the shapes are ok because shapes are only partially known\r\n    # assert(undef_input_op.get_shape() == undef_output_op.get_shape())\r\n    ############################################################################\r\n    # Now atrous\r\n    concrete_input_op = tf.constant(input_img_np)\r\n    concrete_output_op = tf.nn.atrous_conv2d(concrete_input_op, kernel, padding='SAME', rate=2)\r\n    concrete_output = sess.run(concrete_output_op)\r\n    \r\n    print('atrous_conv2d + CONCRETE + SAME')\r\n    print('concrete_input_op: ', concrete_input_op.get_shape())\r\n    print('concrete_output_op: ', concrete_output_op.get_shape())\r\n    print('concrete_output_op: ', concrete_output_op.get_shape())\r\n    print('concrete_output:', concrete_output.shape)\r\n    assert(concrete_input_op.get_shape() == concrete_output_op.get_shape())\r\n\r\n\r\n    undef_input_op = tf.placeholder(tf.float32, shape=(None, 256, 256, 1))\r\n    undef_output_op = tf.nn.atrous_conv2d(undef_input_op, kernel, padding='SAME', rate=2)\r\n    undef_output = sess.run(undef_output_op, feed_dict={undef_input_op: input_img_np})\r\n    \r\n    print('atrous_conv2d + UNDEF + SAME')\r\n    print('undef_input_op: ', undef_input_op.get_shape())\r\n    print('undef_output_op: ', undef_output_op.get_shape())\r\n    print('undef_output:', undef_output.shape)\r\n    # This assert will correctly fail even though the shapes are ok because shapes are only partially known\r\n    # assert(undef_input_op.get_shape() == undef_output_op.get_shape())\r\n\r\n    valid_concrete_input_op = tf.constant(input_img_np)\r\n    valid_concrete_output_op = tf.nn.atrous_conv2d(valid_concrete_input_op, kernel, padding='VALID', rate=2)\r\n    valid_concrete_output = sess.run(valid_concrete_output_op)\r\n    \r\n    print('atrous_conv2d + CONCRETE + VALID')\r\n    print('valid_concrete_input_op: ', valid_concrete_input_op.get_shape())\r\n    print('valid_concrete_output_op: ', valid_concrete_output_op.get_shape())\r\n    print('valid_concrete_output:', valid_concrete_output.shape)\r\n\r\n\r\n    valid_undef_input_op = tf.placeholder(tf.float32, shape=(None, 256, 256, 1))\r\n    valid_undef_output_op = tf.nn.atrous_conv2d(valid_undef_input_op, kernel, padding='VALID', rate=2)\r\n    valid_undef_output = sess.run(valid_undef_output_op, feed_dict={valid_undef_input_op: input_img_np})\r\n    \r\n    print('atrous_conv2d + UNDEF + VALID')\r\n    print('valid_undef_input_op: ',  valid_undef_input_op.get_shape())\r\n    print('valid_undef_output_op: ', valid_undef_output_op.get_shape())\r\n    print('valid_undef_output:', valid_undef_output.shape)\r\n    # This assert will correctly fail even though the shapes are ok because shapes are only partially known\r\n    # assert(undef_input_op.get_shape() == undef_output_op.get_shape())\r\n```\r\nWhich produces this output with the additional `None` values on the last set of printouts:\r\n```\r\nconvolution + CONCRETE + SAME\r\n('concrete_input_op: ', TensorShape([Dimension(1), Dimension(256), Dimension(256), Dimension(1)]))\r\n('concrete_output_op: ', TensorShape([Dimension(1), Dimension(256), Dimension(256), Dimension(1)]))\r\n('concrete_output:', (1, 256, 256, 1))\r\nconvolution + UNDEF + SAME\r\n('undef_input_op: ', TensorShape([Dimension(None), Dimension(256), Dimension(256), Dimension(1)]))\r\n('undef_output_op: ', TensorShape([Dimension(None), Dimension(256), Dimension(256), Dimension(1)]))\r\n('undef_output:', (1, 256, 256, 1))\r\nconvolution + CONCRETE + VALID\r\n('valid_concrete_input_op: ', TensorShape([Dimension(1), Dimension(256), Dimension(256), Dimension(1)]))\r\n('valid_concrete_output_op: ', TensorShape([Dimension(1), Dimension(246), Dimension(246), Dimension(1)]))\r\n('valid_concrete_output:', (1, 246, 246, 1))\r\nconvolution + UNDEF + VALID\r\n('valid_undef_input_op: ', TensorShape([Dimension(None), Dimension(256), Dimension(256), Dimension(1)]))\r\n('valid_undef_output_op: ', TensorShape([Dimension(None), Dimension(246), Dimension(246), Dimension(1)]))\r\n('valid_undef_output:', (1, 246, 246, 1))\r\natrous_conv2d + CONCRETE + SAME\r\n('concrete_input_op: ', TensorShape([Dimension(1), Dimension(256), Dimension(256), Dimension(1)]))\r\n('concrete_output_op: ', TensorShape([Dimension(1), Dimension(256), Dimension(256), Dimension(1)]))\r\n('concrete_output_op: ', TensorShape([Dimension(1), Dimension(256), Dimension(256), Dimension(1)]))\r\n('concrete_output:', (1, 256, 256, 1))\r\natrous_conv2d + UNDEF + SAME\r\n('undef_input_op: ', TensorShape([Dimension(None), Dimension(256), Dimension(256), Dimension(1)]))\r\n('undef_output_op: ', TensorShape([Dimension(None), Dimension(None), Dimension(None), Dimension(1)]))\r\n('undef_output:', (1, 256, 256, 1))\r\natrous_conv2d + CONCRETE + VALID\r\n('valid_concrete_input_op: ', TensorShape([Dimension(1), Dimension(256), Dimension(256), Dimension(1)]))\r\n('valid_concrete_output_op: ', TensorShape([Dimension(1), Dimension(246), Dimension(246), Dimension(1)]))\r\n('valid_concrete_output:', (1, 246, 246, 1))\r\natrous_conv2d + UNDEF + VALID\r\n('valid_undef_input_op: ', TensorShape([Dimension(None), Dimension(256), Dimension(256), Dimension(1)]))\r\n('valid_undef_output_op: ', TensorShape([Dimension(None), Dimension(None), Dimension(None), Dimension(1)]))\r\n('valid_undef_output:', (1, 246, 246, 1))\r\n```"}