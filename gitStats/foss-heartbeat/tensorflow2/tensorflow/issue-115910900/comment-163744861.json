{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/163744861", "html_url": "https://github.com/tensorflow/tensorflow/issues/5#issuecomment-163744861", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5", "id": 163744861, "node_id": "MDEyOklzc3VlQ29tbWVudDE2Mzc0NDg2MQ==", "user": {"login": "kovasb", "id": 184241, "node_id": "MDQ6VXNlcjE4NDI0MQ==", "avatar_url": "https://avatars0.githubusercontent.com/u/184241?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kovasb", "html_url": "https://github.com/kovasb", "followers_url": "https://api.github.com/users/kovasb/followers", "following_url": "https://api.github.com/users/kovasb/following{/other_user}", "gists_url": "https://api.github.com/users/kovasb/gists{/gist_id}", "starred_url": "https://api.github.com/users/kovasb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kovasb/subscriptions", "organizations_url": "https://api.github.com/users/kovasb/orgs", "repos_url": "https://api.github.com/users/kovasb/repos", "events_url": "https://api.github.com/users/kovasb/events{/privacy}", "received_events_url": "https://api.github.com/users/kovasb/received_events", "type": "User", "site_admin": false}, "created_at": "2015-12-10T20:47:20Z", "updated_at": "2015-12-10T20:47:50Z", "author_association": "NONE", "body_html": "<p>I've been using <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=3328023\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/saudet\">@saudet</a>'s JavaCPP presets, extremely useful, thanks! I'm using it to build a Clojure interface to tensorflow.</p>\n<p>Some comments:</p>\n<p>a) There is opportunity for simplification / a higher-level layer</p>\n<p>A lot of the JavaCPP api replicates protobuf functionality that can be directly achieved on the JVM, without the bridge. Took me a bit to realize this, but one is simply building up a protobuf object using the JavaCPP bindings, producing this platform-independent representation using interop, and then stuffing it into the Session.</p>\n<p>I've ended up just using jvm-based protobufs to build the graph directly, bypassing the JavaCPP constructor functions. This has several advantages -- a simpler api to program against, and also nice .toString format that shows the human-readable protobuf.</p>\n<p>Particularly for Clojure, its much easier to describe the tensorflow graph in terms of data structures and then convert directly them to protobuf, than it is to look up and invoke a constructor function for each node in my data structure.</p>\n<p>b) Building and package improvements</p>\n<p>I'm not expert in building native code, or in the build tools used in these projects. It would be great to have maven-ized artifacts; in particular if they also included the generated java protobuf classes. It took an embarrassing amount of time for me to figure out how to do this.</p>\n<p>c) It would be useful to have a small number of graph test cases to target.</p>\n<p>Right now my methodology is somewhat cumbersome: Use the JavaCPP constructor functions to generate a graph, mashall it into my JVM protobufs and see the human-readable form, and figure out how to build my own constructors to make the same form.</p>\n<p>It would be useful to have a small collection of very simple graphs that exercise the core functionalities of TensorFlow, so people like me have a reasonable set of test cases to target for interop to different languages.</p>\n<p>Anyway thanks for everyones efforts and keep up the good work!</p>", "body_text": "I've been using @saudet's JavaCPP presets, extremely useful, thanks! I'm using it to build a Clojure interface to tensorflow.\nSome comments:\na) There is opportunity for simplification / a higher-level layer\nA lot of the JavaCPP api replicates protobuf functionality that can be directly achieved on the JVM, without the bridge. Took me a bit to realize this, but one is simply building up a protobuf object using the JavaCPP bindings, producing this platform-independent representation using interop, and then stuffing it into the Session.\nI've ended up just using jvm-based protobufs to build the graph directly, bypassing the JavaCPP constructor functions. This has several advantages -- a simpler api to program against, and also nice .toString format that shows the human-readable protobuf.\nParticularly for Clojure, its much easier to describe the tensorflow graph in terms of data structures and then convert directly them to protobuf, than it is to look up and invoke a constructor function for each node in my data structure.\nb) Building and package improvements\nI'm not expert in building native code, or in the build tools used in these projects. It would be great to have maven-ized artifacts; in particular if they also included the generated java protobuf classes. It took an embarrassing amount of time for me to figure out how to do this.\nc) It would be useful to have a small number of graph test cases to target.\nRight now my methodology is somewhat cumbersome: Use the JavaCPP constructor functions to generate a graph, mashall it into my JVM protobufs and see the human-readable form, and figure out how to build my own constructors to make the same form.\nIt would be useful to have a small collection of very simple graphs that exercise the core functionalities of TensorFlow, so people like me have a reasonable set of test cases to target for interop to different languages.\nAnyway thanks for everyones efforts and keep up the good work!", "body": "I've been using @saudet's JavaCPP presets, extremely useful, thanks! I'm using it to build a Clojure interface to tensorflow. \n\nSome comments:\n\na) There is opportunity for simplification / a higher-level layer\n\nA lot of the JavaCPP api replicates protobuf functionality that can be directly achieved on the JVM, without the bridge. Took me a bit to realize this, but one is simply building up a protobuf object using the JavaCPP bindings, producing this platform-independent representation using interop, and then stuffing it into the Session.\n\nI've ended up just using jvm-based protobufs to build the graph directly, bypassing the JavaCPP constructor functions. This has several advantages -- a simpler api to program against, and also nice .toString format that shows the human-readable protobuf. \n\nParticularly for Clojure, its much easier to describe the tensorflow graph in terms of data structures and then convert directly them to protobuf, than it is to look up and invoke a constructor function for each node in my data structure.\n\nb) Building and package improvements\n\nI'm not expert in building native code, or in the build tools used in these projects. It would be great to have maven-ized artifacts; in particular if they also included the generated java protobuf classes. It took an embarrassing amount of time for me to figure out how to do this. \n\nc) It would be useful to have a small number of graph test cases to target. \n\nRight now my methodology is somewhat cumbersome: Use the JavaCPP constructor functions to generate a graph, mashall it into my JVM protobufs and see the human-readable form, and figure out how to build my own constructors to make the same form. \n\nIt would be useful to have a small collection of very simple graphs that exercise the core functionalities of TensorFlow, so people like me have a reasonable set of test cases to target for interop to different languages. \n\nAnyway thanks for everyones efforts and keep up the good work!\n"}