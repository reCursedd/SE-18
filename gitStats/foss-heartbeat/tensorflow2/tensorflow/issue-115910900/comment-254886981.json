{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/254886981", "html_url": "https://github.com/tensorflow/tensorflow/issues/5#issuecomment-254886981", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5", "id": 254886981, "node_id": "MDEyOklzc3VlQ29tbWVudDI1NDg4Njk4MQ==", "user": {"login": "jbolla", "id": 2093086, "node_id": "MDQ6VXNlcjIwOTMwODY=", "avatar_url": "https://avatars3.githubusercontent.com/u/2093086?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbolla", "html_url": "https://github.com/jbolla", "followers_url": "https://api.github.com/users/jbolla/followers", "following_url": "https://api.github.com/users/jbolla/following{/other_user}", "gists_url": "https://api.github.com/users/jbolla/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbolla/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbolla/subscriptions", "organizations_url": "https://api.github.com/users/jbolla/orgs", "repos_url": "https://api.github.com/users/jbolla/repos", "events_url": "https://api.github.com/users/jbolla/events{/privacy}", "received_events_url": "https://api.github.com/users/jbolla/received_events", "type": "User", "site_admin": false}, "created_at": "2016-10-19T17:42:29Z", "updated_at": "2016-10-19T17:42:29Z", "author_association": "NONE", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=1247794\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/jdolson\">@jdolson</a> Does the API you expose accept TensorFlow's protocol buffer objects? One of the biggest issues I've had using the javacpp presets from <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=3328023\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/saudet\">@saudet</a> is that when you are manipulating tensor objects in Java client code you're dealing with a org.tensorflow.framework.TensorProto which is generated by the protocol buffer compiler when configured to output java. But in the TensorFlow API wrapper you are dealing with a org.bytedeco.javacpp.tensorflow.TensorProto.TensorProto which is generated by javacpp when pointed at the c code generated by the protocol buffer compiler when configured to produce C. Since the types aren't the same you can't directly use your java code's tensors when calling the wrapped TensorFlow API.</p>", "body_text": "@jdolson Does the API you expose accept TensorFlow's protocol buffer objects? One of the biggest issues I've had using the javacpp presets from @saudet is that when you are manipulating tensor objects in Java client code you're dealing with a org.tensorflow.framework.TensorProto which is generated by the protocol buffer compiler when configured to output java. But in the TensorFlow API wrapper you are dealing with a org.bytedeco.javacpp.tensorflow.TensorProto.TensorProto which is generated by javacpp when pointed at the c code generated by the protocol buffer compiler when configured to produce C. Since the types aren't the same you can't directly use your java code's tensors when calling the wrapped TensorFlow API.", "body": "@jdolson Does the API you expose accept TensorFlow's protocol buffer objects? One of the biggest issues I've had using the javacpp presets from @saudet is that when you are manipulating tensor objects in Java client code you're dealing with a org.tensorflow.framework.TensorProto which is generated by the protocol buffer compiler when configured to output java. But in the TensorFlow API wrapper you are dealing with a org.bytedeco.javacpp.tensorflow.TensorProto.TensorProto which is generated by javacpp when pointed at the c code generated by the protocol buffer compiler when configured to produce C. Since the types aren't the same you can't directly use your java code's tensors when calling the wrapped TensorFlow API.\n"}