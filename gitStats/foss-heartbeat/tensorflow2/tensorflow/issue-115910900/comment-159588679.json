{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/159588679", "html_url": "https://github.com/tensorflow/tensorflow/issues/5#issuecomment-159588679", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5", "id": 159588679, "node_id": "MDEyOklzc3VlQ29tbWVudDE1OTU4ODY3OQ==", "user": {"login": "davidzchen", "id": 5283042, "node_id": "MDQ6VXNlcjUyODMwNDI=", "avatar_url": "https://avatars1.githubusercontent.com/u/5283042?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidzchen", "html_url": "https://github.com/davidzchen", "followers_url": "https://api.github.com/users/davidzchen/followers", "following_url": "https://api.github.com/users/davidzchen/following{/other_user}", "gists_url": "https://api.github.com/users/davidzchen/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidzchen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidzchen/subscriptions", "organizations_url": "https://api.github.com/users/davidzchen/orgs", "repos_url": "https://api.github.com/users/davidzchen/repos", "events_url": "https://api.github.com/users/davidzchen/events{/privacy}", "received_events_url": "https://api.github.com/users/davidzchen/received_events", "type": "User", "site_admin": false}, "created_at": "2015-11-25T12:00:40Z", "updated_at": "2015-11-25T12:00:40Z", "author_association": "MEMBER", "body_html": "<p>Sorry, it turns out I was wrong. In order to build a <code>.so</code> that includes the transitive dependencies, what <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=3328023\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/saudet\">@saudet</a> did using <code>cc_binary</code> with <code>linkshared = 1</code> and <code>name = \"libtensorflow.so\"</code> was correct. From <a href=\"http://bazel.io/docs/be/c-cpp.html#cc_binary.linkshared\" rel=\"nofollow\">the <code>cc_binary.linkshared</code> documentation</a>:</p>\n<blockquote>\n<p>Create a shared library. To enable this attribute, include linkshared=1 in your rule. By default this option is off. If you enable it, you must name your binary libfoo.so (or whatever is the naming convention of libraries on the target platform) for some sensible value of foo.</p>\n</blockquote>\n<p>The main difference between the <code>.so</code>'s built by <code>cc_library</code> targets and the <code>.so</code> built with <code>cc_binary</code> using the method described above is that the <code>cc_library</code> artifacts only contain the code in <code>srcs</code>. This is why building <code>cc_library</code> targets with no <code>srcs</code> and only <code>deps</code>, such as <code>//tensorflow/core</code>, do not produce any artifacts. On the other hand, <code>cc_binary</code> targets will link in all the transitive dependencies.</p>\n<p>I apologize for the confusion. Perhaps we should improve our documentation and add an example on building <code>.so</code>s.</p>", "body_text": "Sorry, it turns out I was wrong. In order to build a .so that includes the transitive dependencies, what @saudet did using cc_binary with linkshared = 1 and name = \"libtensorflow.so\" was correct. From the cc_binary.linkshared documentation:\n\nCreate a shared library. To enable this attribute, include linkshared=1 in your rule. By default this option is off. If you enable it, you must name your binary libfoo.so (or whatever is the naming convention of libraries on the target platform) for some sensible value of foo.\n\nThe main difference between the .so's built by cc_library targets and the .so built with cc_binary using the method described above is that the cc_library artifacts only contain the code in srcs. This is why building cc_library targets with no srcs and only deps, such as //tensorflow/core, do not produce any artifacts. On the other hand, cc_binary targets will link in all the transitive dependencies.\nI apologize for the confusion. Perhaps we should improve our documentation and add an example on building .sos.", "body": "Sorry, it turns out I was wrong. In order to build a `.so` that includes the transitive dependencies, what @saudet did using `cc_binary` with `linkshared = 1` and `name = \"libtensorflow.so\"` was correct. From [the `cc_binary.linkshared` documentation](http://bazel.io/docs/be/c-cpp.html#cc_binary.linkshared):\n\n> Create a shared library. To enable this attribute, include linkshared=1 in your rule. By default this option is off. If you enable it, you must name your binary libfoo.so (or whatever is the naming convention of libraries on the target platform) for some sensible value of foo.\n\nThe main difference between the `.so`'s built by `cc_library` targets and the `.so` built with `cc_binary` using the method described above is that the `cc_library` artifacts only contain the code in `srcs`. This is why building `cc_library` targets with no `srcs` and only `deps`, such as `//tensorflow/core`, do not produce any artifacts. On the other hand, `cc_binary` targets will link in all the transitive dependencies.\n\nI apologize for the confusion. Perhaps we should improve our documentation and add an example on building `.so`s.\n"}