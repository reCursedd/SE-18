{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/159132853", "html_url": "https://github.com/tensorflow/tensorflow/issues/5#issuecomment-159132853", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5", "id": 159132853, "node_id": "MDEyOklzc3VlQ29tbWVudDE1OTEzMjg1Mw==", "user": {"login": "davidzchen", "id": 5283042, "node_id": "MDQ6VXNlcjUyODMwNDI=", "avatar_url": "https://avatars1.githubusercontent.com/u/5283042?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidzchen", "html_url": "https://github.com/davidzchen", "followers_url": "https://api.github.com/users/davidzchen/followers", "following_url": "https://api.github.com/users/davidzchen/following{/other_user}", "gists_url": "https://api.github.com/users/davidzchen/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidzchen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidzchen/subscriptions", "organizations_url": "https://api.github.com/users/davidzchen/orgs", "repos_url": "https://api.github.com/users/davidzchen/repos", "events_url": "https://api.github.com/users/davidzchen/events{/privacy}", "received_events_url": "https://api.github.com/users/davidzchen/received_events", "type": "User", "site_admin": false}, "created_at": "2015-11-24T02:22:38Z", "updated_at": "2015-11-24T02:22:38Z", "author_association": "MEMBER", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=3328023\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/saudet\">@saudet</a> Is there a reason why you are using a <code>cc_binary</code> rule to build the shared library rather than <code>cc_library</code>? You can just have a <code>cc_library</code> rule with the name <code>tensorflow</code> and the build target will build a shared library called <code>libtensorflow.so</code>.</p>\n<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=6148088\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/kylevedder\">@kylevedder</a> If your goal is to generate an <code>.so</code> file, then something similar to what <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=3328023\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/saudet\">@saudet</a> suggested would work.</p>\n<p>If you need to use the TensorFlow protos in Java code, then you would need to add dependencies from your <code>java_*</code> Bazel build targets to the <code>proto_library</code> targets that generate the Java classes from the <code>.proto</code> files.</p>\n<p>We still have a bit of work to do before we open-source the native <code>proto_library</code> rules (see <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"64239946\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/bazelbuild/bazel/issues/52\" data-hovercard-type=\"issue\" data-hovercard-url=\"/bazelbuild/bazel/issues/52/hovercard\" href=\"https://github.com/bazelbuild/bazel/issues/52\">bazelbuild/bazel#52</a>), but in the meantime, TensorFlow uses the <a href=\"https://github.com/google/protobuf/blob/master/protobuf.bzl\"><code>cc_proto_library</code> and <code>py_proto_library</code> rules provided by protobuf</a>, and for Java, you should be able to use the <a href=\"https://github.com/bazelbuild/bazel/blob/master/tools/build_rules/genproto.bzl\">Java <code>genproto</code> rule that is included with Bazel</a>. I will check with the team to find out what the timeline for <code>proto_library</code> is and whether it would be worthwhile to unify the rules provided by Protobuf with <code>genproto</code>.</p>\n<p>A few other bits of feedback:</p>\n<ul>\n<li>I think it would be better to keep the directory names consistent and use <code>java_wrapper</code> rather than <code>javaWrapper</code></li>\n<li>Perhaps a better place for the Java wrapper would be <code>//tensorflow/java/wrapper</code> rather than <code>//tensorflow/core/java_wrapper</code>?</li>\n<li>Internally, we have some build rules that take <code>.swig</code> files and generate the sources. This is more ideal because we would avoid checking in the generated files. I can take a look to see how difficult it would be for us to add some SWIG build rules for Bazel to make stuff like this easier.</li>\n</ul>", "body_text": "@saudet Is there a reason why you are using a cc_binary rule to build the shared library rather than cc_library? You can just have a cc_library rule with the name tensorflow and the build target will build a shared library called libtensorflow.so.\n@kylevedder If your goal is to generate an .so file, then something similar to what @saudet suggested would work.\nIf you need to use the TensorFlow protos in Java code, then you would need to add dependencies from your java_* Bazel build targets to the proto_library targets that generate the Java classes from the .proto files.\nWe still have a bit of work to do before we open-source the native proto_library rules (see bazelbuild/bazel#52), but in the meantime, TensorFlow uses the cc_proto_library and py_proto_library rules provided by protobuf, and for Java, you should be able to use the Java genproto rule that is included with Bazel. I will check with the team to find out what the timeline for proto_library is and whether it would be worthwhile to unify the rules provided by Protobuf with genproto.\nA few other bits of feedback:\n\nI think it would be better to keep the directory names consistent and use java_wrapper rather than javaWrapper\nPerhaps a better place for the Java wrapper would be //tensorflow/java/wrapper rather than //tensorflow/core/java_wrapper?\nInternally, we have some build rules that take .swig files and generate the sources. This is more ideal because we would avoid checking in the generated files. I can take a look to see how difficult it would be for us to add some SWIG build rules for Bazel to make stuff like this easier.", "body": "@saudet Is there a reason why you are using a `cc_binary` rule to build the shared library rather than `cc_library`? You can just have a `cc_library` rule with the name `tensorflow` and the build target will build a shared library called `libtensorflow.so`.\n\n@kylevedder If your goal is to generate an `.so` file, then something similar to what @saudet suggested would work.\n\nIf you need to use the TensorFlow protos in Java code, then you would need to add dependencies from your `java_*` Bazel build targets to the `proto_library` targets that generate the Java classes from the `.proto` files.\n\nWe still have a bit of work to do before we open-source the native `proto_library` rules (see bazelbuild/bazel#52), but in the meantime, TensorFlow uses the [`cc_proto_library` and `py_proto_library` rules provided by protobuf](https://github.com/google/protobuf/blob/master/protobuf.bzl), and for Java, you should be able to use the [Java `genproto` rule that is included with Bazel](https://github.com/bazelbuild/bazel/blob/master/tools/build_rules/genproto.bzl). I will check with the team to find out what the timeline for `proto_library` is and whether it would be worthwhile to unify the rules provided by Protobuf with `genproto`.\n\nA few other bits of feedback:\n- I think it would be better to keep the directory names consistent and use `java_wrapper` rather than `javaWrapper`\n- Perhaps a better place for the Java wrapper would be `//tensorflow/java/wrapper` rather than `//tensorflow/core/java_wrapper`?\n- Internally, we have some build rules that take `.swig` files and generate the sources. This is more ideal because we would avoid checking in the generated files. I can take a look to see how difficult it would be for us to add some SWIG build rules for Bazel to make stuff like this easier.\n"}