{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/17884", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/17884/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/17884/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/17884/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/17884", "id": 307124243, "node_id": "MDU6SXNzdWUzMDcxMjQyNDM=", "number": 17884, "title": "\"dangling\" iterator after freeze model", "user": {"login": "qianyizhang", "id": 12500132, "node_id": "MDQ6VXNlcjEyNTAwMTMy", "avatar_url": "https://avatars0.githubusercontent.com/u/12500132?v=4", "gravatar_id": "", "url": "https://api.github.com/users/qianyizhang", "html_url": "https://github.com/qianyizhang", "followers_url": "https://api.github.com/users/qianyizhang/followers", "following_url": "https://api.github.com/users/qianyizhang/following{/other_user}", "gists_url": "https://api.github.com/users/qianyizhang/gists{/gist_id}", "starred_url": "https://api.github.com/users/qianyizhang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/qianyizhang/subscriptions", "organizations_url": "https://api.github.com/users/qianyizhang/orgs", "repos_url": "https://api.github.com/users/qianyizhang/repos", "events_url": "https://api.github.com/users/qianyizhang/events{/privacy}", "received_events_url": "https://api.github.com/users/qianyizhang/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 386191887, "node_id": "MDU6TGFiZWwzODYxOTE4ODc=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:awaiting%20response", "name": "stat:awaiting response", "color": "f4b400", "default": false}], "state": "closed", "locked": false, "assignee": {"login": "skye", "id": 88808, "node_id": "MDQ6VXNlcjg4ODA4", "avatar_url": "https://avatars1.githubusercontent.com/u/88808?v=4", "gravatar_id": "", "url": "https://api.github.com/users/skye", "html_url": "https://github.com/skye", "followers_url": "https://api.github.com/users/skye/followers", "following_url": "https://api.github.com/users/skye/following{/other_user}", "gists_url": "https://api.github.com/users/skye/gists{/gist_id}", "starred_url": "https://api.github.com/users/skye/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/skye/subscriptions", "organizations_url": "https://api.github.com/users/skye/orgs", "repos_url": "https://api.github.com/users/skye/repos", "events_url": "https://api.github.com/users/skye/events{/privacy}", "received_events_url": "https://api.github.com/users/skye/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "skye", "id": 88808, "node_id": "MDQ6VXNlcjg4ODA4", "avatar_url": "https://avatars1.githubusercontent.com/u/88808?v=4", "gravatar_id": "", "url": "https://api.github.com/users/skye", "html_url": "https://github.com/skye", "followers_url": "https://api.github.com/users/skye/followers", "following_url": "https://api.github.com/users/skye/following{/other_user}", "gists_url": "https://api.github.com/users/skye/gists{/gist_id}", "starred_url": "https://api.github.com/users/skye/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/skye/subscriptions", "organizations_url": "https://api.github.com/users/skye/orgs", "repos_url": "https://api.github.com/users/skye/repos", "events_url": "https://api.github.com/users/skye/events{/privacy}", "received_events_url": "https://api.github.com/users/skye/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 7, "created_at": "2018-03-21T05:29:25Z", "updated_at": "2018-11-21T23:34:45Z", "closed_at": "2018-06-10T18:33:24Z", "author_association": "NONE", "body_html": "<p>I've using tf.data.Iterator to feed in data (as suggested?)<br>\nHowever, when I freeze my model using tf.graph_util.convert_variables_to_constants, all the prerequisite nodes which constructs the iterator are lost.<br>\nIs this a feature or a bug?<br>\nIf it's a feature, how to utilize the iterator again or what's the point?</p>\n<p>The following code snippet shows the \"problem\"</p>\n<p>PS: I am using tf1.4-gpu installed installed on win7 using PIP</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">import</span> tensorflow <span class=\"pl-k\">as</span> tf\n<span class=\"pl-k\">import</span> numpy <span class=\"pl-k\">as</span> np\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> build graph</span>\ng <span class=\"pl-k\">=</span> tf.Graph()\n<span class=\"pl-k\">with</span> g.as_default():\n    <span class=\"pl-k\">with</span> tf.variable_scope(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>data_set<span class=\"pl-pds\">\"</span></span>):\n        <span class=\"pl-c\"><span class=\"pl-c\">#</span> one x-y pair for single evaluation</span>\n        x <span class=\"pl-k\">=</span> tf.placeholder(\n            <span class=\"pl-v\">dtype</span><span class=\"pl-k\">=</span>tf.float32, <span class=\"pl-v\">shape</span><span class=\"pl-k\">=</span>(<span class=\"pl-c1\">None</span>, <span class=\"pl-c1\">None</span>, <span class=\"pl-c1\">1</span>), <span class=\"pl-v\">name</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>inputs<span class=\"pl-pds\">'</span></span>)\n        y <span class=\"pl-k\">=</span> tf.placeholder(\n            <span class=\"pl-v\">dtype</span><span class=\"pl-k\">=</span>tf.float32, <span class=\"pl-v\">shape</span><span class=\"pl-k\">=</span>(<span class=\"pl-c1\">None</span>, <span class=\"pl-c1\">None</span>, <span class=\"pl-c1\">1</span>), <span class=\"pl-v\">name</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>target<span class=\"pl-pds\">'</span></span>)\n        eval_set <span class=\"pl-k\">=</span> tf.data.Dataset()\\\n            .from_tensors((x, y))\n        iterator <span class=\"pl-k\">=</span> tf.data.Iterator.from_structure(eval_set.output_types,\n                                                   <span class=\"pl-v\">output_shapes</span><span class=\"pl-k\">=</span>eval_set.output_shapes)\n        eval_init_op <span class=\"pl-k\">=</span> iterator.make_initializer(eval_set)\n        <span class=\"pl-c\"><span class=\"pl-c\">#</span> some other dataset for training</span>\n        <span class=\"pl-c\"><span class=\"pl-c\">#</span> train_set = tf.data.Dataset()......</span>\n        <span class=\"pl-c\"><span class=\"pl-c\">#</span>#training_init_op = iterator.make_initializer(train_set)</span>\n        x_in, y_in <span class=\"pl-k\">=</span> iterator.get_next()\n    <span class=\"pl-k\">with</span> tf.variable_scope(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>network<span class=\"pl-pds\">\"</span></span>):\n        var <span class=\"pl-k\">=</span> tf.Variable(<span class=\"pl-v\">initial_value</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">5.0</span>, <span class=\"pl-v\">dtype</span><span class=\"pl-k\">=</span>tf.float32)\n        l0 <span class=\"pl-k\">=</span> var <span class=\"pl-k\">*</span> tf.reduce_sum(x_in)\n        l1 <span class=\"pl-k\">=</span> tf.reduce_sum(y_in)\n        <span class=\"pl-k\">with</span> tf.variable_scope(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>output<span class=\"pl-pds\">\"</span></span>):\n            out <span class=\"pl-k\">=</span> l1 <span class=\"pl-k\">-</span> l0\n        variable_init_op <span class=\"pl-k\">=</span> tf.initialize_all_variables()\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> some eval step</span>\n<span class=\"pl-s\"><span class=\"pl-pds\">'''</span></span>\n<span class=\"pl-s\">with tf.Session(graph=g) as sess:</span>\n<span class=\"pl-s\">    sess.run(variable_init_op)</span>\n<span class=\"pl-s\">    sess.run(eval_init_op, feed_dict={x: np.ones(</span>\n<span class=\"pl-s\">        (2, 2, 1), dtype=np.float32), y: np.ones((3, 3, 1), dtype=np.float32)})</span>\n<span class=\"pl-s\">    result = sess.run(out)</span>\n<span class=\"pl-s\">    print(\"result: {}\".format(result))</span>\n<span class=\"pl-s\"><span class=\"pl-pds\">'''</span></span>\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> freeze the graph</span>\n<span class=\"pl-k\">with</span> tf.Session(<span class=\"pl-v\">graph</span><span class=\"pl-k\">=</span>g) <span class=\"pl-k\">as</span> sess:\n    sess.run(variable_init_op)\n    names <span class=\"pl-k\">=</span> [n.name <span class=\"pl-k\">for</span> n <span class=\"pl-k\">in</span> g.as_graph_def().node]\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>oroiginal graph has <span class=\"pl-c1\">{}</span> nodes<span class=\"pl-pds\">\"</span></span>.format(<span class=\"pl-c1\">len</span>(g.as_graph_def().node)))\n    <span class=\"pl-c1\">print</span>([n.name <span class=\"pl-k\">for</span> n <span class=\"pl-k\">in</span> g.as_graph_def().node])\n    <span class=\"pl-s\"><span class=\"pl-pds\">'''</span></span>\n<span class=\"pl-s\">    ['data_set/inputs', 'data_set/target', 'data_set/Iterator', 'data_set/TensorDataset', 'data_set/make_initializer', 'data_set/IteratorGetNext', 'network/Variable/initial_value', 'network/Variable', 'network/Variable/Assign', 'network/Variable/read', 'network/Const', 'network/Sum', 'network/mul', 'network/Const_1', 'network/Sum_1', 'network/output/sub', 'network/init']</span>\n<span class=\"pl-s\">    <span class=\"pl-pds\">'''</span></span>\n    frozen_graph <span class=\"pl-k\">=</span> tf.graph_util.convert_variables_to_constants(\n        sess, g.as_graph_def(), [<span class=\"pl-s\"><span class=\"pl-pds\">'</span>network/output/sub<span class=\"pl-pds\">'</span></span>])\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>new graph nodes: <span class=\"pl-c1\">{}</span><span class=\"pl-pds\">\"</span></span>.format(<span class=\"pl-c1\">len</span>(frozen_graph.node)))\n    <span class=\"pl-c1\">print</span>([n.name <span class=\"pl-k\">for</span> n <span class=\"pl-k\">in</span> frozen_graph.node])\n    <span class=\"pl-s\"><span class=\"pl-pds\">'''</span></span>\n<span class=\"pl-s\">    ['data_set/Iterator', 'data_set/IteratorGetNext', 'network/Variable', 'network/Variable/read', 'network/Const', 'network/Sum', 'network/mul', 'network/Const_1', 'network/Sum_1', 'network/output/sub']</span>\n<span class=\"pl-s\">    <span class=\"pl-pds\">'''</span></span>\n    <span class=\"pl-bu\">```</span></pre></div>", "body_text": "I've using tf.data.Iterator to feed in data (as suggested?)\nHowever, when I freeze my model using tf.graph_util.convert_variables_to_constants, all the prerequisite nodes which constructs the iterator are lost.\nIs this a feature or a bug?\nIf it's a feature, how to utilize the iterator again or what's the point?\nThe following code snippet shows the \"problem\"\nPS: I am using tf1.4-gpu installed installed on win7 using PIP\nimport tensorflow as tf\nimport numpy as np\n# build graph\ng = tf.Graph()\nwith g.as_default():\n    with tf.variable_scope(\"data_set\"):\n        # one x-y pair for single evaluation\n        x = tf.placeholder(\n            dtype=tf.float32, shape=(None, None, 1), name='inputs')\n        y = tf.placeholder(\n            dtype=tf.float32, shape=(None, None, 1), name='target')\n        eval_set = tf.data.Dataset()\\\n            .from_tensors((x, y))\n        iterator = tf.data.Iterator.from_structure(eval_set.output_types,\n                                                   output_shapes=eval_set.output_shapes)\n        eval_init_op = iterator.make_initializer(eval_set)\n        # some other dataset for training\n        # train_set = tf.data.Dataset()......\n        ##training_init_op = iterator.make_initializer(train_set)\n        x_in, y_in = iterator.get_next()\n    with tf.variable_scope(\"network\"):\n        var = tf.Variable(initial_value=5.0, dtype=tf.float32)\n        l0 = var * tf.reduce_sum(x_in)\n        l1 = tf.reduce_sum(y_in)\n        with tf.variable_scope(\"output\"):\n            out = l1 - l0\n        variable_init_op = tf.initialize_all_variables()\n\n# some eval step\n'''\nwith tf.Session(graph=g) as sess:\n    sess.run(variable_init_op)\n    sess.run(eval_init_op, feed_dict={x: np.ones(\n        (2, 2, 1), dtype=np.float32), y: np.ones((3, 3, 1), dtype=np.float32)})\n    result = sess.run(out)\n    print(\"result: {}\".format(result))\n'''\n\n# freeze the graph\nwith tf.Session(graph=g) as sess:\n    sess.run(variable_init_op)\n    names = [n.name for n in g.as_graph_def().node]\n    print(\"oroiginal graph has {} nodes\".format(len(g.as_graph_def().node)))\n    print([n.name for n in g.as_graph_def().node])\n    '''\n    ['data_set/inputs', 'data_set/target', 'data_set/Iterator', 'data_set/TensorDataset', 'data_set/make_initializer', 'data_set/IteratorGetNext', 'network/Variable/initial_value', 'network/Variable', 'network/Variable/Assign', 'network/Variable/read', 'network/Const', 'network/Sum', 'network/mul', 'network/Const_1', 'network/Sum_1', 'network/output/sub', 'network/init']\n    '''\n    frozen_graph = tf.graph_util.convert_variables_to_constants(\n        sess, g.as_graph_def(), ['network/output/sub'])\n    print(\"new graph nodes: {}\".format(len(frozen_graph.node)))\n    print([n.name for n in frozen_graph.node])\n    '''\n    ['data_set/Iterator', 'data_set/IteratorGetNext', 'network/Variable', 'network/Variable/read', 'network/Const', 'network/Sum', 'network/mul', 'network/Const_1', 'network/Sum_1', 'network/output/sub']\n    '''\n    ```", "body": "I've using tf.data.Iterator to feed in data (as suggested?)\r\nHowever, when I freeze my model using tf.graph_util.convert_variables_to_constants, all the prerequisite nodes which constructs the iterator are lost.\r\nIs this a feature or a bug?\r\nIf it's a feature, how to utilize the iterator again or what's the point?\r\n\r\nThe following code snippet shows the \"problem\"\r\n\r\nPS: I am using tf1.4-gpu installed installed on win7 using PIP \r\n```python\r\nimport tensorflow as tf\r\nimport numpy as np\r\n# build graph\r\ng = tf.Graph()\r\nwith g.as_default():\r\n    with tf.variable_scope(\"data_set\"):\r\n        # one x-y pair for single evaluation\r\n        x = tf.placeholder(\r\n            dtype=tf.float32, shape=(None, None, 1), name='inputs')\r\n        y = tf.placeholder(\r\n            dtype=tf.float32, shape=(None, None, 1), name='target')\r\n        eval_set = tf.data.Dataset()\\\r\n            .from_tensors((x, y))\r\n        iterator = tf.data.Iterator.from_structure(eval_set.output_types,\r\n                                                   output_shapes=eval_set.output_shapes)\r\n        eval_init_op = iterator.make_initializer(eval_set)\r\n        # some other dataset for training\r\n        # train_set = tf.data.Dataset()......\r\n        ##training_init_op = iterator.make_initializer(train_set)\r\n        x_in, y_in = iterator.get_next()\r\n    with tf.variable_scope(\"network\"):\r\n        var = tf.Variable(initial_value=5.0, dtype=tf.float32)\r\n        l0 = var * tf.reduce_sum(x_in)\r\n        l1 = tf.reduce_sum(y_in)\r\n        with tf.variable_scope(\"output\"):\r\n            out = l1 - l0\r\n        variable_init_op = tf.initialize_all_variables()\r\n\r\n# some eval step\r\n'''\r\nwith tf.Session(graph=g) as sess:\r\n    sess.run(variable_init_op)\r\n    sess.run(eval_init_op, feed_dict={x: np.ones(\r\n        (2, 2, 1), dtype=np.float32), y: np.ones((3, 3, 1), dtype=np.float32)})\r\n    result = sess.run(out)\r\n    print(\"result: {}\".format(result))\r\n'''\r\n\r\n# freeze the graph\r\nwith tf.Session(graph=g) as sess:\r\n    sess.run(variable_init_op)\r\n    names = [n.name for n in g.as_graph_def().node]\r\n    print(\"oroiginal graph has {} nodes\".format(len(g.as_graph_def().node)))\r\n    print([n.name for n in g.as_graph_def().node])\r\n    '''\r\n    ['data_set/inputs', 'data_set/target', 'data_set/Iterator', 'data_set/TensorDataset', 'data_set/make_initializer', 'data_set/IteratorGetNext', 'network/Variable/initial_value', 'network/Variable', 'network/Variable/Assign', 'network/Variable/read', 'network/Const', 'network/Sum', 'network/mul', 'network/Const_1', 'network/Sum_1', 'network/output/sub', 'network/init']\r\n    '''\r\n    frozen_graph = tf.graph_util.convert_variables_to_constants(\r\n        sess, g.as_graph_def(), ['network/output/sub'])\r\n    print(\"new graph nodes: {}\".format(len(frozen_graph.node)))\r\n    print([n.name for n in frozen_graph.node])\r\n    '''\r\n    ['data_set/Iterator', 'data_set/IteratorGetNext', 'network/Variable', 'network/Variable/read', 'network/Const', 'network/Sum', 'network/mul', 'network/Const_1', 'network/Sum_1', 'network/output/sub']\r\n    '''\r\n    ```"}