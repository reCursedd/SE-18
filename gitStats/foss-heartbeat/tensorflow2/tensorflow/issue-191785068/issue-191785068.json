{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5871", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5871/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5871/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5871/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/5871", "id": 191785068, "node_id": "MDU6SXNzdWUxOTE3ODUwNjg=", "number": 5871, "title": "Check the Status after call builder.Finalize() in generated io_ops.cc", "user": {"login": "snnn", "id": 856316, "node_id": "MDQ6VXNlcjg1NjMxNg==", "avatar_url": "https://avatars3.githubusercontent.com/u/856316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/snnn", "html_url": "https://github.com/snnn", "followers_url": "https://api.github.com/users/snnn/followers", "following_url": "https://api.github.com/users/snnn/following{/other_user}", "gists_url": "https://api.github.com/users/snnn/gists{/gist_id}", "starred_url": "https://api.github.com/users/snnn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/snnn/subscriptions", "organizations_url": "https://api.github.com/users/snnn/orgs", "repos_url": "https://api.github.com/users/snnn/repos", "events_url": "https://api.github.com/users/snnn/events{/privacy}", "received_events_url": "https://api.github.com/users/snnn/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": {"login": "keveman", "id": 229914, "node_id": "MDQ6VXNlcjIyOTkxNA==", "avatar_url": "https://avatars1.githubusercontent.com/u/229914?v=4", "gravatar_id": "", "url": "https://api.github.com/users/keveman", "html_url": "https://github.com/keveman", "followers_url": "https://api.github.com/users/keveman/followers", "following_url": "https://api.github.com/users/keveman/following{/other_user}", "gists_url": "https://api.github.com/users/keveman/gists{/gist_id}", "starred_url": "https://api.github.com/users/keveman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/keveman/subscriptions", "organizations_url": "https://api.github.com/users/keveman/orgs", "repos_url": "https://api.github.com/users/keveman/repos", "events_url": "https://api.github.com/users/keveman/events{/privacy}", "received_events_url": "https://api.github.com/users/keveman/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "keveman", "id": 229914, "node_id": "MDQ6VXNlcjIyOTkxNA==", "avatar_url": "https://avatars1.githubusercontent.com/u/229914?v=4", "gravatar_id": "", "url": "https://api.github.com/users/keveman", "html_url": "https://github.com/keveman", "followers_url": "https://api.github.com/users/keveman/followers", "following_url": "https://api.github.com/users/keveman/following{/other_user}", "gists_url": "https://api.github.com/users/keveman/gists{/gist_id}", "starred_url": "https://api.github.com/users/keveman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/keveman/subscriptions", "organizations_url": "https://api.github.com/users/keveman/orgs", "repos_url": "https://api.github.com/users/keveman/repos", "events_url": "https://api.github.com/users/keveman/events{/privacy}", "received_events_url": "https://api.github.com/users/keveman/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 3, "created_at": "2016-11-26T03:51:35Z", "updated_at": "2016-12-10T04:49:28Z", "closed_at": "2016-12-10T04:49:28Z", "author_association": "CONTRIBUTOR", "body_html": "<p>e.g.</p>\n<p>Let's assume someone passed an int32 tensor into ReaderReadUpTo as the third input(num_records), which should have a type of int64.</p>\n<pre><code>ReaderReadUpTo::ReaderReadUpTo(const ::tensorflow::Scope&amp; scope,\n                               ::tensorflow::ops::Input reader_handle,\n                               ::tensorflow::ops::Input queue_handle,\n                               ::tensorflow::ops::Input num_records) {\n  if (!scope.ok()) return;\n  auto _reader_handle = ::tensorflow::ops::AsNodeOut(scope, reader_handle);\n  if (!scope.ok()) return;\n  auto _queue_handle = ::tensorflow::ops::AsNodeOut(scope, queue_handle);\n  if (!scope.ok()) return;\n  auto _num_records = ::tensorflow::ops::AsNodeOut(scope, num_records);\n  if (!scope.ok()) return;\n  ::tensorflow::Node* ret;\n  const auto  unique_name = scope.GetUniqueNameForOp(\"ReaderReadUpTo\");\n  auto builder = ::tensorflow::NodeBuilder(unique_name, \"ReaderReadUpTo\")\n                     .Input(_reader_handle)\n                     .Input(_queue_handle)\n                     .Input(_num_records)\n  ;\n  scope.UpdateBuilder(&amp;builder);\n  scope.UpdateStatus(builder.Finalize(scope.graph(), &amp;ret));\n  //HERE: builder.Finalize may fails. We should check if ret==NULL, otherwise it will cause a core dump.\n  ::tensorflow::NameRangeMap _outputs_range;\n  ::tensorflow::Status _status_ = ::tensorflow::NameRangesForNode(ret-&gt;def(), ret-&gt;op_def(), nullptr, &amp;_outputs_range);\n  if (!_status_.ok()) {\n    scope.UpdateStatus(_status_);\n    return;\n  }\n\n  this-&gt;keys = Output(ret, _outputs_range[\"keys\"].first);\n  this-&gt;values = Output(ret, _outputs_range[\"values\"].first);\n}\n</code></pre>\n<p>We need modify the function at tensorflow\\tensorflow\\cc\\framework\\cc_op_gen.cc:655</p>\n<p>string OpInfo::GetConstructorBody() const</p>\n<p>to add the check.</p>", "body_text": "e.g.\nLet's assume someone passed an int32 tensor into ReaderReadUpTo as the third input(num_records), which should have a type of int64.\nReaderReadUpTo::ReaderReadUpTo(const ::tensorflow::Scope& scope,\n                               ::tensorflow::ops::Input reader_handle,\n                               ::tensorflow::ops::Input queue_handle,\n                               ::tensorflow::ops::Input num_records) {\n  if (!scope.ok()) return;\n  auto _reader_handle = ::tensorflow::ops::AsNodeOut(scope, reader_handle);\n  if (!scope.ok()) return;\n  auto _queue_handle = ::tensorflow::ops::AsNodeOut(scope, queue_handle);\n  if (!scope.ok()) return;\n  auto _num_records = ::tensorflow::ops::AsNodeOut(scope, num_records);\n  if (!scope.ok()) return;\n  ::tensorflow::Node* ret;\n  const auto  unique_name = scope.GetUniqueNameForOp(\"ReaderReadUpTo\");\n  auto builder = ::tensorflow::NodeBuilder(unique_name, \"ReaderReadUpTo\")\n                     .Input(_reader_handle)\n                     .Input(_queue_handle)\n                     .Input(_num_records)\n  ;\n  scope.UpdateBuilder(&builder);\n  scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));\n  //HERE: builder.Finalize may fails. We should check if ret==NULL, otherwise it will cause a core dump.\n  ::tensorflow::NameRangeMap _outputs_range;\n  ::tensorflow::Status _status_ = ::tensorflow::NameRangesForNode(ret->def(), ret->op_def(), nullptr, &_outputs_range);\n  if (!_status_.ok()) {\n    scope.UpdateStatus(_status_);\n    return;\n  }\n\n  this->keys = Output(ret, _outputs_range[\"keys\"].first);\n  this->values = Output(ret, _outputs_range[\"values\"].first);\n}\n\nWe need modify the function at tensorflow\\tensorflow\\cc\\framework\\cc_op_gen.cc:655\nstring OpInfo::GetConstructorBody() const\nto add the check.", "body": "e.g.\r\n\r\nLet's assume someone passed an int32 tensor into ReaderReadUpTo as the third input(num_records), which should have a type of int64.\r\n```\r\nReaderReadUpTo::ReaderReadUpTo(const ::tensorflow::Scope& scope,\r\n                               ::tensorflow::ops::Input reader_handle,\r\n                               ::tensorflow::ops::Input queue_handle,\r\n                               ::tensorflow::ops::Input num_records) {\r\n  if (!scope.ok()) return;\r\n  auto _reader_handle = ::tensorflow::ops::AsNodeOut(scope, reader_handle);\r\n  if (!scope.ok()) return;\r\n  auto _queue_handle = ::tensorflow::ops::AsNodeOut(scope, queue_handle);\r\n  if (!scope.ok()) return;\r\n  auto _num_records = ::tensorflow::ops::AsNodeOut(scope, num_records);\r\n  if (!scope.ok()) return;\r\n  ::tensorflow::Node* ret;\r\n  const auto  unique_name = scope.GetUniqueNameForOp(\"ReaderReadUpTo\");\r\n  auto builder = ::tensorflow::NodeBuilder(unique_name, \"ReaderReadUpTo\")\r\n                     .Input(_reader_handle)\r\n                     .Input(_queue_handle)\r\n                     .Input(_num_records)\r\n  ;\r\n  scope.UpdateBuilder(&builder);\r\n  scope.UpdateStatus(builder.Finalize(scope.graph(), &ret));\r\n  //HERE: builder.Finalize may fails. We should check if ret==NULL, otherwise it will cause a core dump.\r\n  ::tensorflow::NameRangeMap _outputs_range;\r\n  ::tensorflow::Status _status_ = ::tensorflow::NameRangesForNode(ret->def(), ret->op_def(), nullptr, &_outputs_range);\r\n  if (!_status_.ok()) {\r\n    scope.UpdateStatus(_status_);\r\n    return;\r\n  }\r\n\r\n  this->keys = Output(ret, _outputs_range[\"keys\"].first);\r\n  this->values = Output(ret, _outputs_range[\"values\"].first);\r\n}\r\n```\r\n\r\nWe need modify the function at tensorflow\\tensorflow\\cc\\framework\\cc_op_gen.cc:655 \r\n\r\nstring OpInfo::GetConstructorBody() const \r\n\r\nto add the check."}