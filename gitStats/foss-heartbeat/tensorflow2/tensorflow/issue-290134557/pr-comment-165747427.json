{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/165747427", "pull_request_review_id": 93740377, "id": 165747427, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2NTc0NzQyNw==", "diff_hunk": "@@ -0,0 +1,262 @@\n+/* Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"tensorflow/contrib/tensorrt/segment/segment.h\"\n+\n+#include <set>\n+#include <string>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include \"tensorflow/contrib/tensorrt/segment/union_find.h\"\n+#include \"tensorflow/core/graph/algorithm.h\"\n+#include \"tensorflow/core/graph/graph.h\"\n+#include \"tensorflow/core/graph/graph_constructor.h\"\n+#include \"tensorflow/core/lib/core/errors.h\"\n+#include \"tensorflow/core/lib/core/status.h\"\n+\n+namespace tensorflow {\n+namespace tensorrt {\n+namespace segment {\n+\n+namespace {\n+\n+bool CanContractEdge(const tensorflow::Edge* edge,\n+                     const tensorflow::Graph& graph) {\n+  const tensorflow::Node* src = edge->src();\n+  const tensorflow::Node* dst = edge->dst();\n+\n+  // Can't contract edge if doing so would cause a cycle in the\n+  // graph. So, if there is a directed path from 'src' to 'dst', other\n+  // than 'edge' (or any other direct edge from 'src' to 'dst'), then\n+  // combining 'src' and 'dst' will cause a cycle along that path.\n+  //\n+  // In practice, to avoid modifying the graph and to take advantage\n+  // of existing graph functions, we perform an equivalent.\n+  //   1. Get all nodes incoming to 'dst', excluding 'src'\n+  //   2. Reverse DFS from those nodes\n+  //   3. If reverse DFS reaches 'src' then we have a cycle\n+  std::vector<tensorflow::Node*> dfs_start_nodes;\n+  for (tensorflow::Node* node : dst->in_nodes()) {\n+    if (node != src) {\n+      dfs_start_nodes.push_back(node);\n+    }\n+  }\n+\n+  bool is_cycle = false;\n+  if (!dfs_start_nodes.empty()) {\n+    tensorflow::ReverseDFSFrom(graph, dfs_start_nodes, {},\n+                               [&is_cycle, src](tensorflow::Node* node) {\n+                                 if (node == src) {\n+                                   is_cycle = true;\n+                                 }\n+                               });\n+  }\n+\n+  return !is_cycle;\n+}\n+\n+void ContractEdge(tensorflow::Edge* edge, tensorflow::Graph* graph,\n+                  std::vector<const tensorflow::Edge*>* remove_edges) {\n+  // Transfer all inputs and outputs of 'dst' to 'src' except edges\n+  // connecting the two.\n+  tensorflow::Node* src = edge->src();\n+  tensorflow::Node* dst = edge->dst();\n+\n+  // We can use '0' for input/output index because we don't need them\n+  // to be accurate for the way we are using the graph.\n+  std::vector<const tensorflow::Edge*> in_edges(dst->in_edges().begin(),\n+                                                dst->in_edges().end());\n+  for (const tensorflow::Edge* in_edge : in_edges) {\n+    if (in_edge->src() != src) {\n+      tensorflow::Edge* e = const_cast<tensorflow::Edge*>(in_edge);\n+      if (e->src() == graph->source_node()) {\n+        graph->AddEdge(e->src(), e->src_output(), src,\n+                       tensorflow::Graph::kControlSlot);\n+      } else {\n+        graph->AddEdge(e->src(), e->src_output(), src, 0 /* input index */);\n+      }\n+    }\n+  }\n+\n+  std::vector<const tensorflow::Edge*> out_edges(dst->out_edges().begin(),\n+                                                 dst->out_edges().end());\n+  for (const tensorflow::Edge* out_edge : out_edges) {\n+    tensorflow::Edge* e = const_cast<tensorflow::Edge*>(out_edge);\n+    if (e->dst() == graph->sink_node()) {\n+      graph->AddEdge(src, tensorflow::Graph::kControlSlot, e->dst(),\n+                     e->dst_input());\n+    } else {\n+      graph->AddEdge(src, 0 /* output index */, e->dst(), e->dst_input());\n+    }\n+  }\n+\n+  // Return the edges that must be removed to disconnect 'dst' from\n+  // the graph. We don't actually remove 'dst' since the caller holds\n+  // references to all the nodes.\n+  for (const auto& in_edge : dst->in_edges()) {\n+    remove_edges->push_back(in_edge);\n+  }\n+  for (const auto& out_edge : dst->out_edges()) {\n+    remove_edges->push_back(out_edge);\n+  }\n+}\n+\n+}  // namespace\n+\n+tensorflow::Status SegmentGraph(\n+    const tensorflow::GraphDef& gdef,\n+    const std::function<bool(const tensorflow::NodeDef&)>& candidate_fn,\n+    const SegmentOptions& options, SegmentNodesVector* segments) {\n+  // Create a Graph representation of the GraphDef.\n+  tensorflow::FunctionLibraryDefinition flib(tensorflow::OpRegistry::Global(),\n+                                             gdef.library());\n+  tensorflow::Graph graph(flib);\n+  TF_RETURN_IF_ERROR(tensorflow::ConvertGraphDefToGraph(\n+      tensorflow::GraphConstructorOptions(), gdef, &graph));\n+\n+  // tensorflow::DumpGraph(\"Pre-Segment\", &graph);\n+\n+  // Use a union-find to collect the nodes that belong to the same\n+  // segment. A node value of nullptr indicates that the node is not a\n+  // candidate for TRT.\n+  std::vector<UnionFind<tensorflow::Node*>> node_segments;\n+  for (int i = 0; i < graph.num_node_ids(); ++i) {\n+    tensorflow::Node* node = graph.FindNodeId(i);\n+    if (options.exclude_node_list.count(node->name()) != 0 ||\n+        !candidate_fn(node->def())) {\n+      node = nullptr;\n+    }\n+    node_segments.emplace_back(node);\n+  }\n+\n+  // The segmentation algorithm below visits nodes in reverse\n+  // topological order and attempts to merge nodes along output\n+  // edges. That means that subgraphs grow from the output-side of the\n+  // network towards the inputs. In general this is not guaranteed to\n+  // produce a globally optimal segmentation. In the future if we have\n+  // a measure of how beneficial it is to include a given node in a\n+  // TRT subgraph then we can revisit this algorithm to take advantage\n+  // of that information.\n+  std::vector<tensorflow::Node*> order;\n+  tensorflow::GetPostOrder(graph, &order);\n+\n+  for (const tensorflow::Node* node : order) {\n+    // All output nodes of 'node' have been visited...\n+    VLOG(2) << \"Trying node \" << node->name();\n+\n+    // 'node' must be a TRT candidate...\n+    if (node_segments[node->id()].Value() == nullptr) {\n+      VLOG(2) << \"... not a TRT candidate\";\n+      continue;\n+    }\n+\n+    // Contract output edges to combine 'node' with output\n+    // nodes. Iterate since combining two nodes may unblock other\n+    // combining.\n+    while (true) {\n+      std::set<const tensorflow::Edge*> contract_edges;\n+      for (const tensorflow::Edge* out_edge : node->out_edges()) {\n+        VLOG(2) << \"... out node \" << out_edge->dst()->name();\n+\n+        // Out node must be TRT candidate...\n+        if (node_segments[out_edge->dst()->id()].Value() == nullptr) {\n+          VLOG(2) << \"... ... not a TRT candidate\";\n+          continue;\n+        }\n+\n+        if (CanContractEdge(out_edge, graph)) {\n+          VLOG(2) << \"... ... can contract\";\n+          contract_edges.insert(out_edge);\n+        } else {\n+          VLOG(2) << \"... ... cannot contract, would form cycle\";\n+        }\n+      }\n+\n+      if (contract_edges.empty()) {\n+        break;\n+      }\n+\n+      // Contract edges and collect the adjacent nodes into the same\n+      // segment/subgraph.\n+      while (!contract_edges.empty()) {\n+        const tensorflow::Edge* contract_edge = *contract_edges.begin();\n+        const tensorflow::Node* src = contract_edge->src();\n+        const tensorflow::Node* dst = contract_edge->dst();\n+\n+        VLOG(2) << \"Merge \" << src->name() << \" <- \" << dst->name();\n+        node_segments[src->id()].Merge(&node_segments[dst->id()]);\n+\n+        // Contracting the edge leaves disconnected graph edges.\n+        // Remove these from the graph and from 'contract_edges' so we\n+        // don't visit them again.\n+        tensorflow::Edge* e = const_cast<tensorflow::Edge*>(contract_edge);\n+        std::vector<const tensorflow::Edge*> remove_edges;\n+        ContractEdge(e, &graph, &remove_edges);\n+\n+        for (const tensorflow::Edge* r : remove_edges) {\n+          contract_edges.erase(r);\n+          graph.RemoveEdge(r);\n+        }\n+      }\n+    }\n+  }\n+\n+  // Collect the segments/subgraphs. Each subgraph is represented by a\n+  // set of the names of the nodes in that subgraph.\n+  std::unordered_map<std::string, std::set<std::string>> sg_map;\n+  for (auto& u : node_segments) {\n+    if ((u.Value() != nullptr) && (u.ParentValue() != nullptr)) {\n+      sg_map[u.ParentValue()->name()].insert(u.Value()->name());\n+    }\n+  }\n+\n+  // Cleanup the graph to remove disconnected nodes before outputting\n+  if (VLOG_IS_ON(2)) {\n+    for (tensorflow::Node* node : graph.nodes()) {\n+      if ((node->in_edges().size() == 0) && (node->out_edges().size() == 0)) {\n+        graph.RemoveNode(node);", "path": "tensorflow/contrib/tensorrt/segment/segment.cc", "position": null, "original_position": 230, "commit_id": "1e4b5b8c0cc1675b9ecac3569c91563a2a4f9984", "original_commit_id": "97aa1856bc6dc75afd65dc4ad2a5e5a48d1ea6d6", "user": {"login": "aaroey", "id": 31743510, "node_id": "MDQ6VXNlcjMxNzQzNTEw", "avatar_url": "https://avatars0.githubusercontent.com/u/31743510?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aaroey", "html_url": "https://github.com/aaroey", "followers_url": "https://api.github.com/users/aaroey/followers", "following_url": "https://api.github.com/users/aaroey/following{/other_user}", "gists_url": "https://api.github.com/users/aaroey/gists{/gist_id}", "starred_url": "https://api.github.com/users/aaroey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aaroey/subscriptions", "organizations_url": "https://api.github.com/users/aaroey/orgs", "repos_url": "https://api.github.com/users/aaroey/repos", "events_url": "https://api.github.com/users/aaroey/events{/privacy}", "received_events_url": "https://api.github.com/users/aaroey/received_events", "type": "User", "site_admin": false}, "body": "Where do we log the graph?", "created_at": "2018-02-02T20:09:43Z", "updated_at": "2018-02-12T23:36:57Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/16253#discussion_r165747427", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/16253", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/165747427"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/16253#discussion_r165747427"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/16253"}}, "body_html": "<p>Where do we log the graph?</p>", "body_text": "Where do we log the graph?"}