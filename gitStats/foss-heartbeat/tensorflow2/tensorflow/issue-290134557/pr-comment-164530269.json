{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/164530269", "pull_request_review_id": 92317475, "id": 164530269, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2NDUzMDI2OQ==", "diff_hunk": "@@ -0,0 +1,259 @@\n+/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"tensorflow/contrib/tensorrt/segment/segment.h\"\n+\n+#include <set>\n+#include <string>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include \"tensorflow/contrib/tensorrt/segment/union_find.h\"\n+#include \"tensorflow/core/graph/algorithm.h\"\n+#include \"tensorflow/core/graph/graph.h\"\n+#include \"tensorflow/core/graph/graph_constructor.h\"\n+#include \"tensorflow/core/lib/core/errors.h\"\n+#include \"tensorflow/core/lib/core/status.h\"\n+\n+//------------------------------------------------------------------------------\n+namespace tensorrt {\n+namespace segment {\n+\n+//------------------------------------------------------------------------------\n+namespace {\n+\n+//------------------------------------------------------------------------------\n+bool CanContractEdge(const tensorflow::Edge* edge,\n+                     const tensorflow::Graph& graph) {\n+  const tensorflow::Node* src = edge->src();\n+  const tensorflow::Node* dst = edge->dst();\n+\n+  // Can't contract edge if doing so would cause a cycle in the\n+  // graph. So, if there is a directed path from 'src' to 'dst', other\n+  // than 'edge' (or any other direct edge from 'src' to 'dst'), then\n+  // combining 'src' and 'dst' will cause a cycle along that path.\n+  //\n+  // In practice, to avoid modifying the graph and to take advantage\n+  // of existing graph functions, we perform an equivalent.\n+  //   1. Get all nodes incoming to 'dst', excluding 'src'\n+  //   2. Reverse DFS from those nodes\n+  //   3. If reverse DFS reaches 'src' then we have a cycle\n+  std::vector<tensorflow::Node*> dfs_start_nodes;\n+  for (tensorflow::Node* node : dst->in_nodes()) {\n+    if (node != src) {\n+      dfs_start_nodes.push_back(node);\n+    }\n+  }\n+\n+  bool is_cycle = false;\n+  if (!dfs_start_nodes.empty()) {\n+    tensorflow::ReverseDFSFrom(graph, dfs_start_nodes, {},\n+                               [&is_cycle, src](tensorflow::Node* node) {\n+                                 if (node == src) {\n+                                   is_cycle = true;\n+                                 }\n+                               });\n+  }\n+\n+  return !is_cycle;\n+}\n+\n+//------------------------------------------------------------------------------\n+void ContractEdge(tensorflow::Edge* edge, tensorflow::Graph* graph,\n+                  std::vector<const tensorflow::Edge*>* remove_edges) {\n+  // Transfer all inputs and outputs of 'dst' to 'src' except edges\n+  // connecting the two.\n+  tensorflow::Node* src = edge->src();\n+  tensorflow::Node* dst = edge->dst();\n+\n+  // We can use '0' for input/output index because we don't need them\n+  // to be accurate for the way we are using the graph.\n+  std::vector<const tensorflow::Edge*> in_edges(dst->in_edges().begin(),\n+                                                dst->in_edges().end());\n+  for (const tensorflow::Edge* in_edge : in_edges) {\n+    if (in_edge->src() != src) {\n+      tensorflow::Edge* e = const_cast<tensorflow::Edge*>(in_edge);\n+      if (e->src() == graph->source_node()) {\n+        graph->AddEdge(e->src(), e->src_output(), src,\n+                       tensorflow::Graph::kControlSlot);\n+      } else {\n+        graph->AddEdge(e->src(), e->src_output(), src, 0 /* input index */);\n+      }\n+    }\n+  }\n+\n+  std::vector<const tensorflow::Edge*> out_edges(dst->out_edges().begin(),\n+                                                 dst->out_edges().end());\n+  for (const tensorflow::Edge* out_edge : out_edges) {\n+    tensorflow::Edge* e = const_cast<tensorflow::Edge*>(out_edge);\n+    if (e->dst() == graph->sink_node()) {\n+      graph->AddEdge(src, tensorflow::Graph::kControlSlot, e->dst(),\n+                     e->dst_input());\n+    } else {\n+      graph->AddEdge(src, 0 /* output index */, e->dst(), e->dst_input());\n+    }\n+  }\n+\n+  // Return the edges that must be removed to disconnect 'dst' from\n+  // the graph. We don't actually remove 'dst' since the caller holds\n+  // references to all the nodes.\n+  for (const auto& in_edge : dst->in_edges()) {\n+    remove_edges->push_back(in_edge);\n+  }\n+  for (const auto& out_edge : dst->out_edges()) {\n+    remove_edges->push_back(out_edge);\n+  }\n+}\n+\n+}  // namespace\n+\n+//------------------------------------------------------------------------------\n+tensorflow::Status SegmentGraph(\n+    const tensorflow::GraphDef& gdef,\n+    const std::function<bool(const tensorflow::NodeDef&)>& candidate_fn,\n+    const SegmentOptions& options, SegmentNodesVector* segments) {\n+  // Create a Graph representation of the GraphDef.\n+  tensorflow::FunctionLibraryDefinition flib(tensorflow::OpRegistry::Global(),\n+                                             gdef.library());\n+  tensorflow::Graph graph(flib);\n+  TF_RETURN_IF_ERROR(tensorflow::ConvertGraphDefToGraph(\n+      tensorflow::GraphConstructorOptions(), gdef, &graph));\n+\n+  // tensorflow::DumpGraph(\"Pre-Segment\", &graph);\n+\n+  // Use a union-find to collect the nodes that belong to the same\n+  // segment. A node value of nullptr indicates that the node is not a\n+  // candidate for TRT.\n+  std::vector<UnionFind<tensorflow::Node*>> node_segments;\n+  for (int i = 0; i < graph.num_node_ids(); ++i) {\n+    tensorflow::Node* node = graph.FindNodeId(i);\n+    if (!candidate_fn(node->def())) {\n+      node = nullptr;\n+    }\n+    node_segments.emplace_back(node);\n+  }\n+\n+  // Visit nodes in reverse topological order and use edge\n+  // contraction to merge candidate nodes.\n+  std::vector<tensorflow::Node*> order;\n+  tensorflow::GetPostOrder(graph, &order);\n+\n+  for (const tensorflow::Node* node : order) {\n+    // All output nodes of 'node' have been visited...\n+    VLOG(2) << \"Trying node \" << node->name();\n+\n+    // 'node' must be a TRT candidate...\n+    if (node_segments[node->id()].Value() == nullptr) {\n+      VLOG(2) << \"... not a TRT candidate\";\n+      continue;\n+    }\n+\n+    // Contract output edges to combine 'node' with output\n+    // nodes. Iterate since combining two nodes may unblock other\n+    // combining.\n+    while (true) {\n+      std::set<const tensorflow::Edge*> contract_edges;\n+      for (const tensorflow::Edge* out_edge : node->out_edges()) {\n+        VLOG(2) << \"... out node \" << out_edge->dst()->name();\n+\n+        // Out node must be TRT candidate...\n+        if (node_segments[out_edge->dst()->id()].Value() == nullptr) {\n+          VLOG(2) << \"... ... not a TRT candidate\";\n+          continue;\n+        }\n+\n+        if (CanContractEdge(out_edge, graph)) {\n+          VLOG(2) << \"... ... can contract\";\n+          contract_edges.insert(out_edge);", "path": "tensorflow/contrib/tensorrt/segment/segment.cc", "position": 182, "original_position": 179, "commit_id": "1e4b5b8c0cc1675b9ecac3569c91563a2a4f9984", "original_commit_id": "7035501c1b35d52d80d8fde3a95492d83a96f495", "user": {"login": "benoitsteiner", "id": 6969686, "node_id": "MDQ6VXNlcjY5Njk2ODY=", "avatar_url": "https://avatars0.githubusercontent.com/u/6969686?v=4", "gravatar_id": "", "url": "https://api.github.com/users/benoitsteiner", "html_url": "https://github.com/benoitsteiner", "followers_url": "https://api.github.com/users/benoitsteiner/followers", "following_url": "https://api.github.com/users/benoitsteiner/following{/other_user}", "gists_url": "https://api.github.com/users/benoitsteiner/gists{/gist_id}", "starred_url": "https://api.github.com/users/benoitsteiner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/benoitsteiner/subscriptions", "organizations_url": "https://api.github.com/users/benoitsteiner/orgs", "repos_url": "https://api.github.com/users/benoitsteiner/repos", "events_url": "https://api.github.com/users/benoitsteiner/events{/privacy}", "received_events_url": "https://api.github.com/users/benoitsteiner/received_events", "type": "User", "site_admin": false}, "body": "We have an internal effort to try to figure out how to globally segment the graph into fused clusters. It's not ready yet, but once it is it would be interesting to interface it with TensorRT.", "created_at": "2018-01-29T19:01:57Z", "updated_at": "2018-02-12T23:36:57Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/16253#discussion_r164530269", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/16253", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/164530269"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/16253#discussion_r164530269"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/16253"}}, "body_html": "<p>We have an internal effort to try to figure out how to globally segment the graph into fused clusters. It's not ready yet, but once it is it would be interesting to interface it with TensorRT.</p>", "body_text": "We have an internal effort to try to figure out how to globally segment the graph into fused clusters. It's not ready yet, but once it is it would be interesting to interface it with TensorRT.", "in_reply_to_id": 163644366}