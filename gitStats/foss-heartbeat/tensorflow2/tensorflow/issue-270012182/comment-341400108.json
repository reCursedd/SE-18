{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/341400108", "html_url": "https://github.com/tensorflow/tensorflow/issues/14127#issuecomment-341400108", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/14127", "id": 341400108, "node_id": "MDEyOklzc3VlQ29tbWVudDM0MTQwMDEwOA==", "user": {"login": "Timmmm", "id": 376842, "node_id": "MDQ6VXNlcjM3Njg0Mg==", "avatar_url": "https://avatars3.githubusercontent.com/u/376842?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Timmmm", "html_url": "https://github.com/Timmmm", "followers_url": "https://api.github.com/users/Timmmm/followers", "following_url": "https://api.github.com/users/Timmmm/following{/other_user}", "gists_url": "https://api.github.com/users/Timmmm/gists{/gist_id}", "starred_url": "https://api.github.com/users/Timmmm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Timmmm/subscriptions", "organizations_url": "https://api.github.com/users/Timmmm/orgs", "repos_url": "https://api.github.com/users/Timmmm/repos", "events_url": "https://api.github.com/users/Timmmm/events{/privacy}", "received_events_url": "https://api.github.com/users/Timmmm/received_events", "type": "User", "site_admin": false}, "created_at": "2017-11-02T12:00:32Z", "updated_at": "2017-11-02T12:00:32Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Same error <a href=\"https://github.com/Project-OSRM/osrm-backend/issues/1000\" data-hovercard-type=\"issue\" data-hovercard-url=\"/Project-OSRM/osrm-backend/issues/1000/hovercard\">here</a>. The fundamental problem is that <code>double sin(double)</code> and <code>float sin(float)</code> (and so on) are both available in the global namespace so the cast is ambiguous.</p>\n<p>As far as I understand it, when you <code>#include &lt;math.h&gt;</code> you should only get the <code>double</code> version and not the <code>float</code> version. When you <code>#include &lt;cmath&gt;</code> you should get <code>double std::sin(double)</code> and <code>float std::sin(float)</code>. However, Apple have set it up so that when you <code>#include &lt;cmath&gt;</code> you get both those functions imported into the global namespace.</p>\n<p>The only reliable way around this seems to be to be explicit about the signature for the overloaded functions, as follows:</p>\n<p>First, add <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=606831\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/DavidNorman\">@DavidNorman</a>'s <code>sincos</code> fix, but with the correct function types:</p>\n<pre><code>#if defined(__APPLE__)\nstatic void sincos(double, double*, double*)  __attribute__((weakref (\"__sincos\")));\nstatic void sincosf(float, float*, float*) __attribute__((weakref (\"__sincosf\")));\n#endif\n</code></pre>\n<p>Then:</p>\n<pre><code>#define REGISTER_LIBM_SYMBOL(name, sig)                               \\\n  do {                                                                \\\n    /* Register both the F32 and F64 variants of the libm symbol.  */ \\\n    registry-&gt;Register(#name \"f\", reinterpret_cast&lt;void*&gt;(name##f));  \\\n    registry-&gt;Register(#name, reinterpret_cast&lt;void*&gt;(static_cast&lt;sig&gt;(name)));\\\n  } while (false)\n\n  REGISTER_LIBM_SYMBOL(acos, double(*)(double));\n  REGISTER_LIBM_SYMBOL(acosh, double(*)(double));\n  REGISTER_LIBM_SYMBOL(asin, double(*)(double));\n  REGISTER_LIBM_SYMBOL(asinh, double(*)(double));\n  REGISTER_LIBM_SYMBOL(atan, double(*)(double));\n  REGISTER_LIBM_SYMBOL(atan2, double(*)(double, double));\n  REGISTER_LIBM_SYMBOL(atanh, double(*)(double));\n  REGISTER_LIBM_SYMBOL(cbrt, double(*)(double));\n  REGISTER_LIBM_SYMBOL(ceil, double(*)(double));\n  REGISTER_LIBM_SYMBOL(copysign, double(*)(double, double));\n  REGISTER_LIBM_SYMBOL(cos, double(*)(double));\n  REGISTER_LIBM_SYMBOL(cosh, double(*)(double));\n  REGISTER_LIBM_SYMBOL(erf, double(*)(double));\n  REGISTER_LIBM_SYMBOL(erfc, double(*)(double));\n  REGISTER_LIBM_SYMBOL(exp, double(*)(double));\n  REGISTER_LIBM_SYMBOL(exp2, double(*)(double));\n  REGISTER_LIBM_SYMBOL(expm1, double(*)(double));\n  REGISTER_LIBM_SYMBOL(fabs, double(*)(double));\n  REGISTER_LIBM_SYMBOL(fdim, double(*)(double, double));\n  REGISTER_LIBM_SYMBOL(floor, double(*)(double));\n  REGISTER_LIBM_SYMBOL(fma, double(*)(double, double, double));\n  REGISTER_LIBM_SYMBOL(fmax, double(*)(double, double));\n  REGISTER_LIBM_SYMBOL(fmin, double(*)(double, double));\n  REGISTER_LIBM_SYMBOL(fmod, double(*)(double, double));\n  REGISTER_LIBM_SYMBOL(frexp, double(*)(double, int*));\n  REGISTER_LIBM_SYMBOL(hypot, double(*)(double, double));\n  REGISTER_LIBM_SYMBOL(ilogb, int(*)(double));\n  REGISTER_LIBM_SYMBOL(ldexp, double(*)(double, int));\n  REGISTER_LIBM_SYMBOL(lgamma, double(*)(double));\n  REGISTER_LIBM_SYMBOL(llrint, long long(*)(double));\n  REGISTER_LIBM_SYMBOL(llround, long long(*)(double));\n  REGISTER_LIBM_SYMBOL(log, double(*)(double));\n  REGISTER_LIBM_SYMBOL(log10, double(*)(double));\n  REGISTER_LIBM_SYMBOL(log1p, double(*)(double));\n  REGISTER_LIBM_SYMBOL(log2, double(*)(double));\n  REGISTER_LIBM_SYMBOL(logb, double(*)(double));\n  REGISTER_LIBM_SYMBOL(lrint, long(*)(double));\n  REGISTER_LIBM_SYMBOL(lround, long(*)(double));\n  REGISTER_LIBM_SYMBOL(modf, double(*)(double, double*));\n  REGISTER_LIBM_SYMBOL(nan, double(*)(const char*));\n  REGISTER_LIBM_SYMBOL(nearbyint, double(*)(double));\n  REGISTER_LIBM_SYMBOL(nextafter, double(*)(double, double));\n  REGISTER_LIBM_SYMBOL(nexttoward, double(*)(double, long double));\n  REGISTER_LIBM_SYMBOL(pow, double(*)(double, double));\n  REGISTER_LIBM_SYMBOL(remainder, double(*)(double, double));\n  REGISTER_LIBM_SYMBOL(remquo, double(*)(double, double, int*));\n  REGISTER_LIBM_SYMBOL(rint, double(*)(double));\n  REGISTER_LIBM_SYMBOL(round, double(*)(double));\n  REGISTER_LIBM_SYMBOL(scalbln, double(*)(double, long));\n  REGISTER_LIBM_SYMBOL(scalbn, double(*)(double, int));\n  REGISTER_LIBM_SYMBOL(sin, double(*)(double));\n  REGISTER_LIBM_SYMBOL(sincos, void(*)(double, double*, double*));\n  REGISTER_LIBM_SYMBOL(sinh, double(*)(double));\n  REGISTER_LIBM_SYMBOL(sqrt, double(*)(double));\n  REGISTER_LIBM_SYMBOL(tan, double(*)(double));\n  REGISTER_LIBM_SYMBOL(tanh, double(*)(double));\n  REGISTER_LIBM_SYMBOL(tgamma, double(*)(double));\n  REGISTER_LIBM_SYMBOL(trunc, double(*)(double));\n</code></pre>\n<p>Tedious but it seems to work. Fortunately the <code>sinf(float)</code> and similar functions are never overloaded so a cast isn't needed for those.</p>", "body_text": "Same error here. The fundamental problem is that double sin(double) and float sin(float) (and so on) are both available in the global namespace so the cast is ambiguous.\nAs far as I understand it, when you #include <math.h> you should only get the double version and not the float version. When you #include <cmath> you should get double std::sin(double) and float std::sin(float). However, Apple have set it up so that when you #include <cmath> you get both those functions imported into the global namespace.\nThe only reliable way around this seems to be to be explicit about the signature for the overloaded functions, as follows:\nFirst, add @DavidNorman's sincos fix, but with the correct function types:\n#if defined(__APPLE__)\nstatic void sincos(double, double*, double*)  __attribute__((weakref (\"__sincos\")));\nstatic void sincosf(float, float*, float*) __attribute__((weakref (\"__sincosf\")));\n#endif\n\nThen:\n#define REGISTER_LIBM_SYMBOL(name, sig)                               \\\n  do {                                                                \\\n    /* Register both the F32 and F64 variants of the libm symbol.  */ \\\n    registry->Register(#name \"f\", reinterpret_cast<void*>(name##f));  \\\n    registry->Register(#name, reinterpret_cast<void*>(static_cast<sig>(name)));\\\n  } while (false)\n\n  REGISTER_LIBM_SYMBOL(acos, double(*)(double));\n  REGISTER_LIBM_SYMBOL(acosh, double(*)(double));\n  REGISTER_LIBM_SYMBOL(asin, double(*)(double));\n  REGISTER_LIBM_SYMBOL(asinh, double(*)(double));\n  REGISTER_LIBM_SYMBOL(atan, double(*)(double));\n  REGISTER_LIBM_SYMBOL(atan2, double(*)(double, double));\n  REGISTER_LIBM_SYMBOL(atanh, double(*)(double));\n  REGISTER_LIBM_SYMBOL(cbrt, double(*)(double));\n  REGISTER_LIBM_SYMBOL(ceil, double(*)(double));\n  REGISTER_LIBM_SYMBOL(copysign, double(*)(double, double));\n  REGISTER_LIBM_SYMBOL(cos, double(*)(double));\n  REGISTER_LIBM_SYMBOL(cosh, double(*)(double));\n  REGISTER_LIBM_SYMBOL(erf, double(*)(double));\n  REGISTER_LIBM_SYMBOL(erfc, double(*)(double));\n  REGISTER_LIBM_SYMBOL(exp, double(*)(double));\n  REGISTER_LIBM_SYMBOL(exp2, double(*)(double));\n  REGISTER_LIBM_SYMBOL(expm1, double(*)(double));\n  REGISTER_LIBM_SYMBOL(fabs, double(*)(double));\n  REGISTER_LIBM_SYMBOL(fdim, double(*)(double, double));\n  REGISTER_LIBM_SYMBOL(floor, double(*)(double));\n  REGISTER_LIBM_SYMBOL(fma, double(*)(double, double, double));\n  REGISTER_LIBM_SYMBOL(fmax, double(*)(double, double));\n  REGISTER_LIBM_SYMBOL(fmin, double(*)(double, double));\n  REGISTER_LIBM_SYMBOL(fmod, double(*)(double, double));\n  REGISTER_LIBM_SYMBOL(frexp, double(*)(double, int*));\n  REGISTER_LIBM_SYMBOL(hypot, double(*)(double, double));\n  REGISTER_LIBM_SYMBOL(ilogb, int(*)(double));\n  REGISTER_LIBM_SYMBOL(ldexp, double(*)(double, int));\n  REGISTER_LIBM_SYMBOL(lgamma, double(*)(double));\n  REGISTER_LIBM_SYMBOL(llrint, long long(*)(double));\n  REGISTER_LIBM_SYMBOL(llround, long long(*)(double));\n  REGISTER_LIBM_SYMBOL(log, double(*)(double));\n  REGISTER_LIBM_SYMBOL(log10, double(*)(double));\n  REGISTER_LIBM_SYMBOL(log1p, double(*)(double));\n  REGISTER_LIBM_SYMBOL(log2, double(*)(double));\n  REGISTER_LIBM_SYMBOL(logb, double(*)(double));\n  REGISTER_LIBM_SYMBOL(lrint, long(*)(double));\n  REGISTER_LIBM_SYMBOL(lround, long(*)(double));\n  REGISTER_LIBM_SYMBOL(modf, double(*)(double, double*));\n  REGISTER_LIBM_SYMBOL(nan, double(*)(const char*));\n  REGISTER_LIBM_SYMBOL(nearbyint, double(*)(double));\n  REGISTER_LIBM_SYMBOL(nextafter, double(*)(double, double));\n  REGISTER_LIBM_SYMBOL(nexttoward, double(*)(double, long double));\n  REGISTER_LIBM_SYMBOL(pow, double(*)(double, double));\n  REGISTER_LIBM_SYMBOL(remainder, double(*)(double, double));\n  REGISTER_LIBM_SYMBOL(remquo, double(*)(double, double, int*));\n  REGISTER_LIBM_SYMBOL(rint, double(*)(double));\n  REGISTER_LIBM_SYMBOL(round, double(*)(double));\n  REGISTER_LIBM_SYMBOL(scalbln, double(*)(double, long));\n  REGISTER_LIBM_SYMBOL(scalbn, double(*)(double, int));\n  REGISTER_LIBM_SYMBOL(sin, double(*)(double));\n  REGISTER_LIBM_SYMBOL(sincos, void(*)(double, double*, double*));\n  REGISTER_LIBM_SYMBOL(sinh, double(*)(double));\n  REGISTER_LIBM_SYMBOL(sqrt, double(*)(double));\n  REGISTER_LIBM_SYMBOL(tan, double(*)(double));\n  REGISTER_LIBM_SYMBOL(tanh, double(*)(double));\n  REGISTER_LIBM_SYMBOL(tgamma, double(*)(double));\n  REGISTER_LIBM_SYMBOL(trunc, double(*)(double));\n\nTedious but it seems to work. Fortunately the sinf(float) and similar functions are never overloaded so a cast isn't needed for those.", "body": "Same error [here](https://github.com/Project-OSRM/osrm-backend/issues/1000). The fundamental problem is that `double sin(double)` and `float sin(float)` (and so on) are both available in the global namespace so the cast is ambiguous.\r\n\r\nAs far as I understand it, when you `#include <math.h>` you should only get the `double` version and not the `float` version. When you `#include <cmath>` you should get `double std::sin(double)` and `float std::sin(float)`. However, Apple have set it up so that when you `#include <cmath>` you get both those functions imported into the global namespace.\r\n\r\nThe only reliable way around this seems to be to be explicit about the signature for the overloaded functions, as follows:\r\n\r\nFirst, add @DavidNorman's `sincos` fix, but with the correct function types:\r\n\r\n```\r\n#if defined(__APPLE__)\r\nstatic void sincos(double, double*, double*)  __attribute__((weakref (\"__sincos\")));\r\nstatic void sincosf(float, float*, float*) __attribute__((weakref (\"__sincosf\")));\r\n#endif\r\n```\r\n\r\nThen:\r\n\r\n```\r\n#define REGISTER_LIBM_SYMBOL(name, sig)                               \\\r\n  do {                                                                \\\r\n    /* Register both the F32 and F64 variants of the libm symbol.  */ \\\r\n    registry->Register(#name \"f\", reinterpret_cast<void*>(name##f));  \\\r\n    registry->Register(#name, reinterpret_cast<void*>(static_cast<sig>(name)));\\\r\n  } while (false)\r\n\r\n  REGISTER_LIBM_SYMBOL(acos, double(*)(double));\r\n  REGISTER_LIBM_SYMBOL(acosh, double(*)(double));\r\n  REGISTER_LIBM_SYMBOL(asin, double(*)(double));\r\n  REGISTER_LIBM_SYMBOL(asinh, double(*)(double));\r\n  REGISTER_LIBM_SYMBOL(atan, double(*)(double));\r\n  REGISTER_LIBM_SYMBOL(atan2, double(*)(double, double));\r\n  REGISTER_LIBM_SYMBOL(atanh, double(*)(double));\r\n  REGISTER_LIBM_SYMBOL(cbrt, double(*)(double));\r\n  REGISTER_LIBM_SYMBOL(ceil, double(*)(double));\r\n  REGISTER_LIBM_SYMBOL(copysign, double(*)(double, double));\r\n  REGISTER_LIBM_SYMBOL(cos, double(*)(double));\r\n  REGISTER_LIBM_SYMBOL(cosh, double(*)(double));\r\n  REGISTER_LIBM_SYMBOL(erf, double(*)(double));\r\n  REGISTER_LIBM_SYMBOL(erfc, double(*)(double));\r\n  REGISTER_LIBM_SYMBOL(exp, double(*)(double));\r\n  REGISTER_LIBM_SYMBOL(exp2, double(*)(double));\r\n  REGISTER_LIBM_SYMBOL(expm1, double(*)(double));\r\n  REGISTER_LIBM_SYMBOL(fabs, double(*)(double));\r\n  REGISTER_LIBM_SYMBOL(fdim, double(*)(double, double));\r\n  REGISTER_LIBM_SYMBOL(floor, double(*)(double));\r\n  REGISTER_LIBM_SYMBOL(fma, double(*)(double, double, double));\r\n  REGISTER_LIBM_SYMBOL(fmax, double(*)(double, double));\r\n  REGISTER_LIBM_SYMBOL(fmin, double(*)(double, double));\r\n  REGISTER_LIBM_SYMBOL(fmod, double(*)(double, double));\r\n  REGISTER_LIBM_SYMBOL(frexp, double(*)(double, int*));\r\n  REGISTER_LIBM_SYMBOL(hypot, double(*)(double, double));\r\n  REGISTER_LIBM_SYMBOL(ilogb, int(*)(double));\r\n  REGISTER_LIBM_SYMBOL(ldexp, double(*)(double, int));\r\n  REGISTER_LIBM_SYMBOL(lgamma, double(*)(double));\r\n  REGISTER_LIBM_SYMBOL(llrint, long long(*)(double));\r\n  REGISTER_LIBM_SYMBOL(llround, long long(*)(double));\r\n  REGISTER_LIBM_SYMBOL(log, double(*)(double));\r\n  REGISTER_LIBM_SYMBOL(log10, double(*)(double));\r\n  REGISTER_LIBM_SYMBOL(log1p, double(*)(double));\r\n  REGISTER_LIBM_SYMBOL(log2, double(*)(double));\r\n  REGISTER_LIBM_SYMBOL(logb, double(*)(double));\r\n  REGISTER_LIBM_SYMBOL(lrint, long(*)(double));\r\n  REGISTER_LIBM_SYMBOL(lround, long(*)(double));\r\n  REGISTER_LIBM_SYMBOL(modf, double(*)(double, double*));\r\n  REGISTER_LIBM_SYMBOL(nan, double(*)(const char*));\r\n  REGISTER_LIBM_SYMBOL(nearbyint, double(*)(double));\r\n  REGISTER_LIBM_SYMBOL(nextafter, double(*)(double, double));\r\n  REGISTER_LIBM_SYMBOL(nexttoward, double(*)(double, long double));\r\n  REGISTER_LIBM_SYMBOL(pow, double(*)(double, double));\r\n  REGISTER_LIBM_SYMBOL(remainder, double(*)(double, double));\r\n  REGISTER_LIBM_SYMBOL(remquo, double(*)(double, double, int*));\r\n  REGISTER_LIBM_SYMBOL(rint, double(*)(double));\r\n  REGISTER_LIBM_SYMBOL(round, double(*)(double));\r\n  REGISTER_LIBM_SYMBOL(scalbln, double(*)(double, long));\r\n  REGISTER_LIBM_SYMBOL(scalbn, double(*)(double, int));\r\n  REGISTER_LIBM_SYMBOL(sin, double(*)(double));\r\n  REGISTER_LIBM_SYMBOL(sincos, void(*)(double, double*, double*));\r\n  REGISTER_LIBM_SYMBOL(sinh, double(*)(double));\r\n  REGISTER_LIBM_SYMBOL(sqrt, double(*)(double));\r\n  REGISTER_LIBM_SYMBOL(tan, double(*)(double));\r\n  REGISTER_LIBM_SYMBOL(tanh, double(*)(double));\r\n  REGISTER_LIBM_SYMBOL(tgamma, double(*)(double));\r\n  REGISTER_LIBM_SYMBOL(trunc, double(*)(double));\r\n```\r\n\r\nTedious but it seems to work. Fortunately the `sinf(float)` and similar functions are never overloaded so a cast isn't needed for those."}