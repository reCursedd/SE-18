{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/424975162", "html_url": "https://github.com/tensorflow/tensorflow/issues/22512#issuecomment-424975162", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/22512", "id": 424975162, "node_id": "MDEyOklzc3VlQ29tbWVudDQyNDk3NTE2Mg==", "user": {"login": "Overdrivr", "id": 1294805, "node_id": "MDQ6VXNlcjEyOTQ4MDU=", "avatar_url": "https://avatars0.githubusercontent.com/u/1294805?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Overdrivr", "html_url": "https://github.com/Overdrivr", "followers_url": "https://api.github.com/users/Overdrivr/followers", "following_url": "https://api.github.com/users/Overdrivr/following{/other_user}", "gists_url": "https://api.github.com/users/Overdrivr/gists{/gist_id}", "starred_url": "https://api.github.com/users/Overdrivr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Overdrivr/subscriptions", "organizations_url": "https://api.github.com/users/Overdrivr/orgs", "repos_url": "https://api.github.com/users/Overdrivr/repos", "events_url": "https://api.github.com/users/Overdrivr/events{/privacy}", "received_events_url": "https://api.github.com/users/Overdrivr/received_events", "type": "User", "site_admin": false}, "created_at": "2018-09-27T06:35:39Z", "updated_at": "2018-09-27T06:35:39Z", "author_association": "NONE", "body_html": "<p>I have tried TF 1.5 and it solves the issue. TF can be imported just fine. So, clearly, it has be an issue with AVX.</p>\n<p>But it is stated <a href=\"https://www.intel.fr/content/www/fr/fr/products/processors/xeon/e5-processors/e5-2623-v4.html\" rel=\"nofollow\">here</a> (and everywhere else) that the Xeon E5-2623 v4 supports AVX2, so I guess it should support AVX too, right ?</p>\n<p>To be sure, I wrote a small script that fetches CPUID and checks if the hardware supports AVX.<br>\nInstall <a href=\"https://pypi.org/project/cpuid/\" rel=\"nofollow\">cpuid</a> to run it.</p>\n<pre><code>from cpuid import *\n\ndef _is_set(id, reg_idx, bit):\n    regs = cpuid(id)\n\n    if (1 &lt;&lt; bit) &amp; regs[reg_idx]:\n        return \"Yes\"\n    else:\n        return \"--\"\n\nprint(\"Vendor ID         : %s\" % cpu_vendor())\nprint(\"CPU name          : %s\" % cpu_name())\nprint(\"Microarchitecture : %s%s\" % cpu_microarchitecture())\nprint(\"Vector instructions supported:\")\nprint(\"SSE       : %s\" % _is_set(1, 3, 25))\nprint(\"SSE2      : %s\" % _is_set(1, 3, 26))\nprint(\"SSE3      : %s\" % _is_set(1, 2, 0))\nprint(\"SSSE3     : %s\" % _is_set(1, 2, 9))\nprint(\"SSE4.1    : %s\" % _is_set(1, 2, 19))\nprint(\"SSE4.2    : %s\" % _is_set(1, 2, 20))\nprint(\"SSE4a     : %s\" % _is_set(0x80000001, 2, 6))\nprint(\"AVX       : %s\" % _is_set(1, 2, 28))\nprint(\"AVX2      : %s\" % _is_set(7, 1, 5))\nprint(\"BMI1      : %s\" % _is_set(7, 1, 3))\nprint(\"BMI2      : %s\" % _is_set(7, 1, 8))\n</code></pre>\n<p>And this is what I get:</p>\n<pre><code>Vendor ID         : GenuineIntel\nCPU name          : Intel(R) Xeon(R) CPU E5-2623 v4 @ 2.60GHz\nMicroarchitecture : broadwellnoavx\nVector instructions supported:\nSSE       : Yes\nSSE2      : Yes\nSSE3      : Yes\nSSSE3     : Yes\nSSE4.1    : Yes\nSSE4.2    : Yes\nSSE4a     : --\nAVX       : --\nAVX2      : --\nBMI1      : Yes\nBMI2      : Yes\n</code></pre>\n<p>Just the name of the micro-architecture is pretty self-explanatory.<br>\nNot only does he not support AVX2, he does not even support AVX1.</p>\n<p>I would like to give a big <strong>THANKS</strong> to intel for advertising their processor to support AVX when they clearly don't (and for wasting our time).</p>", "body_text": "I have tried TF 1.5 and it solves the issue. TF can be imported just fine. So, clearly, it has be an issue with AVX.\nBut it is stated here (and everywhere else) that the Xeon E5-2623 v4 supports AVX2, so I guess it should support AVX too, right ?\nTo be sure, I wrote a small script that fetches CPUID and checks if the hardware supports AVX.\nInstall cpuid to run it.\nfrom cpuid import *\n\ndef _is_set(id, reg_idx, bit):\n    regs = cpuid(id)\n\n    if (1 << bit) & regs[reg_idx]:\n        return \"Yes\"\n    else:\n        return \"--\"\n\nprint(\"Vendor ID         : %s\" % cpu_vendor())\nprint(\"CPU name          : %s\" % cpu_name())\nprint(\"Microarchitecture : %s%s\" % cpu_microarchitecture())\nprint(\"Vector instructions supported:\")\nprint(\"SSE       : %s\" % _is_set(1, 3, 25))\nprint(\"SSE2      : %s\" % _is_set(1, 3, 26))\nprint(\"SSE3      : %s\" % _is_set(1, 2, 0))\nprint(\"SSSE3     : %s\" % _is_set(1, 2, 9))\nprint(\"SSE4.1    : %s\" % _is_set(1, 2, 19))\nprint(\"SSE4.2    : %s\" % _is_set(1, 2, 20))\nprint(\"SSE4a     : %s\" % _is_set(0x80000001, 2, 6))\nprint(\"AVX       : %s\" % _is_set(1, 2, 28))\nprint(\"AVX2      : %s\" % _is_set(7, 1, 5))\nprint(\"BMI1      : %s\" % _is_set(7, 1, 3))\nprint(\"BMI2      : %s\" % _is_set(7, 1, 8))\n\nAnd this is what I get:\nVendor ID         : GenuineIntel\nCPU name          : Intel(R) Xeon(R) CPU E5-2623 v4 @ 2.60GHz\nMicroarchitecture : broadwellnoavx\nVector instructions supported:\nSSE       : Yes\nSSE2      : Yes\nSSE3      : Yes\nSSSE3     : Yes\nSSE4.1    : Yes\nSSE4.2    : Yes\nSSE4a     : --\nAVX       : --\nAVX2      : --\nBMI1      : Yes\nBMI2      : Yes\n\nJust the name of the micro-architecture is pretty self-explanatory.\nNot only does he not support AVX2, he does not even support AVX1.\nI would like to give a big THANKS to intel for advertising their processor to support AVX when they clearly don't (and for wasting our time).", "body": "I have tried TF 1.5 and it solves the issue. TF can be imported just fine. So, clearly, it has be an issue with AVX.\r\n\r\nBut it is stated [here](https://www.intel.fr/content/www/fr/fr/products/processors/xeon/e5-processors/e5-2623-v4.html) (and everywhere else) that the Xeon E5-2623 v4 supports AVX2, so I guess it should support AVX too, right ?\r\n\r\nTo be sure, I wrote a small script that fetches CPUID and checks if the hardware supports AVX.\r\nInstall [cpuid](https://pypi.org/project/cpuid/) to run it.\r\n\r\n```\r\nfrom cpuid import *\r\n\r\ndef _is_set(id, reg_idx, bit):\r\n    regs = cpuid(id)\r\n\r\n    if (1 << bit) & regs[reg_idx]:\r\n        return \"Yes\"\r\n    else:\r\n        return \"--\"\r\n\r\nprint(\"Vendor ID         : %s\" % cpu_vendor())\r\nprint(\"CPU name          : %s\" % cpu_name())\r\nprint(\"Microarchitecture : %s%s\" % cpu_microarchitecture())\r\nprint(\"Vector instructions supported:\")\r\nprint(\"SSE       : %s\" % _is_set(1, 3, 25))\r\nprint(\"SSE2      : %s\" % _is_set(1, 3, 26))\r\nprint(\"SSE3      : %s\" % _is_set(1, 2, 0))\r\nprint(\"SSSE3     : %s\" % _is_set(1, 2, 9))\r\nprint(\"SSE4.1    : %s\" % _is_set(1, 2, 19))\r\nprint(\"SSE4.2    : %s\" % _is_set(1, 2, 20))\r\nprint(\"SSE4a     : %s\" % _is_set(0x80000001, 2, 6))\r\nprint(\"AVX       : %s\" % _is_set(1, 2, 28))\r\nprint(\"AVX2      : %s\" % _is_set(7, 1, 5))\r\nprint(\"BMI1      : %s\" % _is_set(7, 1, 3))\r\nprint(\"BMI2      : %s\" % _is_set(7, 1, 8))\r\n```\r\n\r\nAnd this is what I get:\r\n\r\n```\r\nVendor ID         : GenuineIntel\r\nCPU name          : Intel(R) Xeon(R) CPU E5-2623 v4 @ 2.60GHz\r\nMicroarchitecture : broadwellnoavx\r\nVector instructions supported:\r\nSSE       : Yes\r\nSSE2      : Yes\r\nSSE3      : Yes\r\nSSSE3     : Yes\r\nSSE4.1    : Yes\r\nSSE4.2    : Yes\r\nSSE4a     : --\r\nAVX       : --\r\nAVX2      : --\r\nBMI1      : Yes\r\nBMI2      : Yes\r\n```\r\n\r\nJust the name of the micro-architecture is pretty self-explanatory.\r\nNot only does he not support AVX2, he does not even support AVX1.\r\n\r\nI would like to give a big **THANKS** to intel for advertising their processor to support AVX when they clearly don't (and for wasting our time).\r\n"}