{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9260", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9260/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9260/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9260/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/9260", "id": 222076137, "node_id": "MDU6SXNzdWUyMjIwNzYxMzc=", "number": 9260, "title": "Sampling from a categorical distribution without replacement", "user": {"login": "danijar", "id": 2111293, "node_id": "MDQ6VXNlcjIxMTEyOTM=", "avatar_url": "https://avatars0.githubusercontent.com/u/2111293?v=4", "gravatar_id": "", "url": "https://api.github.com/users/danijar", "html_url": "https://github.com/danijar", "followers_url": "https://api.github.com/users/danijar/followers", "following_url": "https://api.github.com/users/danijar/following{/other_user}", "gists_url": "https://api.github.com/users/danijar/gists{/gist_id}", "starred_url": "https://api.github.com/users/danijar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/danijar/subscriptions", "organizations_url": "https://api.github.com/users/danijar/orgs", "repos_url": "https://api.github.com/users/danijar/repos", "events_url": "https://api.github.com/users/danijar/events{/privacy}", "received_events_url": "https://api.github.com/users/danijar/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 299643928, "node_id": "MDU6TGFiZWwyOTk2NDM5Mjg=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:contributions%20welcome", "name": "stat:contributions welcome", "color": "f4b400", "default": false}, {"id": 473173272, "node_id": "MDU6TGFiZWw0NzMxNzMyNzI=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:feature", "name": "type:feature", "color": "159b2e", "default": false}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 8, "created_at": "2017-04-17T06:36:27Z", "updated_at": "2018-11-12T13:15:05Z", "closed_at": null, "author_association": "MEMBER", "body_html": "<p>Both <code>tf.multinomial()</code> and <code>tf.contrib.distributions.Categorical.sample()</code> allow to sample from a multinomial distribution. However, they only allow sampling with replacement.</p>\n<p>In constrast, Numpy's <code>numpy.random.choice()</code> has a <code>replace</code> parameter that allows sampling without replacement. Would it be possible to add a similar functionality to TensorFlow?</p>\n<p>One use case is sampling examples from the dataset proportional to the model's last loss on them. When an example generates a very large loss, the next batch will mainly consist of that example. Using sampling without replacement, we can avoid this problem.</p>\n<p>I see that sampling with replacement can be parallelized and implemented in a vectorized way, but I don't think sampling speed is a bottleneck in most people's programs.</p>", "body_text": "Both tf.multinomial() and tf.contrib.distributions.Categorical.sample() allow to sample from a multinomial distribution. However, they only allow sampling with replacement.\nIn constrast, Numpy's numpy.random.choice() has a replace parameter that allows sampling without replacement. Would it be possible to add a similar functionality to TensorFlow?\nOne use case is sampling examples from the dataset proportional to the model's last loss on them. When an example generates a very large loss, the next batch will mainly consist of that example. Using sampling without replacement, we can avoid this problem.\nI see that sampling with replacement can be parallelized and implemented in a vectorized way, but I don't think sampling speed is a bottleneck in most people's programs.", "body": "Both `tf.multinomial()` and `tf.contrib.distributions.Categorical.sample()` allow to sample from a multinomial distribution. However, they only allow sampling with replacement.\r\n\r\nIn constrast, Numpy's `numpy.random.choice()` has a `replace` parameter that allows sampling without replacement. Would it be possible to add a similar functionality to TensorFlow?\r\n\r\nOne use case is sampling examples from the dataset proportional to the model's last loss on them. When an example generates a very large loss, the next batch will mainly consist of that example. Using sampling without replacement, we can avoid this problem.\r\n\r\nI see that sampling with replacement can be parallelized and implemented in a vectorized way, but I don't think sampling speed is a bottleneck in most people's programs."}