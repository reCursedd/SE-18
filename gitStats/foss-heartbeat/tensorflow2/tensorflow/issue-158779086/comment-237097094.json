{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/237097094", "html_url": "https://github.com/tensorflow/tensorflow/issues/2695#issuecomment-237097094", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2695", "id": 237097094, "node_id": "MDEyOklzc3VlQ29tbWVudDIzNzA5NzA5NA==", "user": {"login": "memo", "id": 144230, "node_id": "MDQ6VXNlcjE0NDIzMA==", "avatar_url": "https://avatars0.githubusercontent.com/u/144230?v=4", "gravatar_id": "", "url": "https://api.github.com/users/memo", "html_url": "https://github.com/memo", "followers_url": "https://api.github.com/users/memo/followers", "following_url": "https://api.github.com/users/memo/following{/other_user}", "gists_url": "https://api.github.com/users/memo/gists{/gist_id}", "starred_url": "https://api.github.com/users/memo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/memo/subscriptions", "organizations_url": "https://api.github.com/users/memo/orgs", "repos_url": "https://api.github.com/users/memo/repos", "events_url": "https://api.github.com/users/memo/events{/privacy}", "received_events_url": "https://api.github.com/users/memo/received_events", "type": "User", "site_admin": false}, "created_at": "2016-08-03T00:47:41Z", "updated_at": "2016-08-03T00:47:41Z", "author_association": "CONTRIBUTOR", "body_html": "<p>just a follow up on this. I think I have it fully working now (tested a small model). For a Graves-style sequence generation it took quite a bit of wrangling.</p>\n<p>This was the original code (relevant bits only) without tuples</p>\n<pre><code>state = model.initial_state.eval()\nloop:\n    feed = {model.inputs:x, model.initial_state: state}\n    loss, state, _ = sess.run([model.outputs, model.state], feed)\n</code></pre>\n<p>and this is what it took (relevant bits only) to get it working with tuples, it would be great to wrap this up somehow, and make it easier:</p>\n<pre><code>def get_states_list(states, state_is_tuple):\n    \"\"\"\n    given a 'states' variable from a tensorflow model,\n    return a flattened list of states\n    \"\"\"\n    if state_is_tuple:\n        states_list = [] # flattened list of all tensors in states\n        for layer in states:\n            for state in layer:\n                states_list.append(state)\n    else:\n        states_list = [states]\n\n    return states_list\n\n\ndef get_states_dict(states, state_is_tuple):\n    \"\"\"\n    given a 'states' variable from a tensorflow model,\n    return a dict of { tensor : evaluated value }\n    \"\"\"\n    if state_is_tuple:\n        states_dict = {} # dict of { tensor : value } \n        for layer in states:\n            for state in layer:\n                states_dict[state] = state.eval()\n\n    else:\n        states_dict = {states : states.eval()}\n\n    return states_dict\n\ninit_states_list = utils.get_states_list(model.initial_state, model.state_is_tuple)\ninit_states_dict = utils.get_states_dict(model.initial_state, model.state_is_tuple)\nfinal_states_list = utils.get_states_list(model.final_state, model.state_is_tuple)\n\nstates_dict = init_states_dict\n\nloop:\n    feed = {model.inputs:x}\n    feed.update(states_dict)\n    fetch = [model.outputs] + final_states_list\n    ret = sess.run(fetch, feed)\n    outputs = ret[0]\n    states = ret[1:]\n    states_dict = dict(zip(init_states_list, states))\n</code></pre>", "body_text": "just a follow up on this. I think I have it fully working now (tested a small model). For a Graves-style sequence generation it took quite a bit of wrangling.\nThis was the original code (relevant bits only) without tuples\nstate = model.initial_state.eval()\nloop:\n    feed = {model.inputs:x, model.initial_state: state}\n    loss, state, _ = sess.run([model.outputs, model.state], feed)\n\nand this is what it took (relevant bits only) to get it working with tuples, it would be great to wrap this up somehow, and make it easier:\ndef get_states_list(states, state_is_tuple):\n    \"\"\"\n    given a 'states' variable from a tensorflow model,\n    return a flattened list of states\n    \"\"\"\n    if state_is_tuple:\n        states_list = [] # flattened list of all tensors in states\n        for layer in states:\n            for state in layer:\n                states_list.append(state)\n    else:\n        states_list = [states]\n\n    return states_list\n\n\ndef get_states_dict(states, state_is_tuple):\n    \"\"\"\n    given a 'states' variable from a tensorflow model,\n    return a dict of { tensor : evaluated value }\n    \"\"\"\n    if state_is_tuple:\n        states_dict = {} # dict of { tensor : value } \n        for layer in states:\n            for state in layer:\n                states_dict[state] = state.eval()\n\n    else:\n        states_dict = {states : states.eval()}\n\n    return states_dict\n\ninit_states_list = utils.get_states_list(model.initial_state, model.state_is_tuple)\ninit_states_dict = utils.get_states_dict(model.initial_state, model.state_is_tuple)\nfinal_states_list = utils.get_states_list(model.final_state, model.state_is_tuple)\n\nstates_dict = init_states_dict\n\nloop:\n    feed = {model.inputs:x}\n    feed.update(states_dict)\n    fetch = [model.outputs] + final_states_list\n    ret = sess.run(fetch, feed)\n    outputs = ret[0]\n    states = ret[1:]\n    states_dict = dict(zip(init_states_list, states))", "body": "just a follow up on this. I think I have it fully working now (tested a small model). For a Graves-style sequence generation it took quite a bit of wrangling. \n\nThis was the original code (relevant bits only) without tuples\n\n```\nstate = model.initial_state.eval()\nloop:\n    feed = {model.inputs:x, model.initial_state: state}\n    loss, state, _ = sess.run([model.outputs, model.state], feed)\n```\n\nand this is what it took (relevant bits only) to get it working with tuples, it would be great to wrap this up somehow, and make it easier:\n\n```\ndef get_states_list(states, state_is_tuple):\n    \"\"\"\n    given a 'states' variable from a tensorflow model,\n    return a flattened list of states\n    \"\"\"\n    if state_is_tuple:\n        states_list = [] # flattened list of all tensors in states\n        for layer in states:\n            for state in layer:\n                states_list.append(state)\n    else:\n        states_list = [states]\n\n    return states_list\n\n\ndef get_states_dict(states, state_is_tuple):\n    \"\"\"\n    given a 'states' variable from a tensorflow model,\n    return a dict of { tensor : evaluated value }\n    \"\"\"\n    if state_is_tuple:\n        states_dict = {} # dict of { tensor : value } \n        for layer in states:\n            for state in layer:\n                states_dict[state] = state.eval()\n\n    else:\n        states_dict = {states : states.eval()}\n\n    return states_dict\n\ninit_states_list = utils.get_states_list(model.initial_state, model.state_is_tuple)\ninit_states_dict = utils.get_states_dict(model.initial_state, model.state_is_tuple)\nfinal_states_list = utils.get_states_list(model.final_state, model.state_is_tuple)\n\nstates_dict = init_states_dict\n\nloop:\n    feed = {model.inputs:x}\n    feed.update(states_dict)\n    fetch = [model.outputs] + final_states_list\n    ret = sess.run(fetch, feed)\n    outputs = ret[0]\n    states = ret[1:]\n    states_dict = dict(zip(init_states_list, states))\n```\n"}