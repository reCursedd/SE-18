{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/237057659", "html_url": "https://github.com/tensorflow/tensorflow/issues/2695#issuecomment-237057659", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2695", "id": 237057659, "node_id": "MDEyOklzc3VlQ29tbWVudDIzNzA1NzY1OQ==", "user": {"login": "memo", "id": 144230, "node_id": "MDQ6VXNlcjE0NDIzMA==", "avatar_url": "https://avatars0.githubusercontent.com/u/144230?v=4", "gravatar_id": "", "url": "https://api.github.com/users/memo", "html_url": "https://github.com/memo", "followers_url": "https://api.github.com/users/memo/followers", "following_url": "https://api.github.com/users/memo/following{/other_user}", "gists_url": "https://api.github.com/users/memo/gists{/gist_id}", "starred_url": "https://api.github.com/users/memo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/memo/subscriptions", "organizations_url": "https://api.github.com/users/memo/orgs", "repos_url": "https://api.github.com/users/memo/repos", "events_url": "https://api.github.com/users/memo/events{/privacy}", "received_events_url": "https://api.github.com/users/memo/received_events", "type": "User", "site_admin": false}, "created_at": "2016-08-02T21:54:42Z", "updated_at": "2016-08-02T21:54:42Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Sorry to comment on this closed issue, but I came across the exact same problem when trying to get rid of the 'state_is_tuple' warning. The usage of the tuple-less state was very nice and manageable (at least for the basic stuff I was doing), passing in and out a single tensor. With the tuple state, if I have a variable number of cells (e.g. trying different hyperparameters), the code becomes a bit more ugly. I wrote something like this below, which returns a dict which I can use for feeding into the initial state. But then the final state also becomes a problem, and I'm not sure what the best way to manage this dynamically is. is this really the best way?</p>\n<pre><code>def init_state(self):\n    states_dict = {}\n    for layer in self.initial_states_:\n        for state in layer:\n            states_dict[state] = state.eval()\n    return states_dict\n</code></pre>", "body_text": "Sorry to comment on this closed issue, but I came across the exact same problem when trying to get rid of the 'state_is_tuple' warning. The usage of the tuple-less state was very nice and manageable (at least for the basic stuff I was doing), passing in and out a single tensor. With the tuple state, if I have a variable number of cells (e.g. trying different hyperparameters), the code becomes a bit more ugly. I wrote something like this below, which returns a dict which I can use for feeding into the initial state. But then the final state also becomes a problem, and I'm not sure what the best way to manage this dynamically is. is this really the best way?\ndef init_state(self):\n    states_dict = {}\n    for layer in self.initial_states_:\n        for state in layer:\n            states_dict[state] = state.eval()\n    return states_dict", "body": "Sorry to comment on this closed issue, but I came across the exact same problem when trying to get rid of the 'state_is_tuple' warning. The usage of the tuple-less state was very nice and manageable (at least for the basic stuff I was doing), passing in and out a single tensor. With the tuple state, if I have a variable number of cells (e.g. trying different hyperparameters), the code becomes a bit more ugly. I wrote something like this below, which returns a dict which I can use for feeding into the initial state. But then the final state also becomes a problem, and I'm not sure what the best way to manage this dynamically is. is this really the best way?\n\n```\ndef init_state(self):\n    states_dict = {}\n    for layer in self.initial_states_:\n        for state in layer:\n            states_dict[state] = state.eval()\n    return states_dict\n```\n"}