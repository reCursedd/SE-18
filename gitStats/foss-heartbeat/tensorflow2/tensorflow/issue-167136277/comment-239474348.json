{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/239474348", "html_url": "https://github.com/tensorflow/tensorflow/issues/3470#issuecomment-239474348", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/3470", "id": 239474348, "node_id": "MDEyOklzc3VlQ29tbWVudDIzOTQ3NDM0OA==", "user": {"login": "mrry", "id": 192142, "node_id": "MDQ6VXNlcjE5MjE0Mg==", "avatar_url": "https://avatars1.githubusercontent.com/u/192142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mrry", "html_url": "https://github.com/mrry", "followers_url": "https://api.github.com/users/mrry/followers", "following_url": "https://api.github.com/users/mrry/following{/other_user}", "gists_url": "https://api.github.com/users/mrry/gists{/gist_id}", "starred_url": "https://api.github.com/users/mrry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mrry/subscriptions", "organizations_url": "https://api.github.com/users/mrry/orgs", "repos_url": "https://api.github.com/users/mrry/repos", "events_url": "https://api.github.com/users/mrry/events{/privacy}", "received_events_url": "https://api.github.com/users/mrry/received_events", "type": "User", "site_admin": false}, "created_at": "2016-08-12T15:16:03Z", "updated_at": "2016-08-12T15:16:03Z", "author_association": "CONTRIBUTOR", "body_html": "<p>An alternative and more plausible hypothesis for the \"thread leak\" I mentioned above: backpressure on the cleanup task would prevent these from completing in a timely manner. However, since the master doesn't block on the completion of that task before returning, a single client thread would be free to send more run requests, creating further cleanup tasks without bound. Since the worker service was only allowing a single cleanup task to complete at once, and the parameter server would be receiving cleanup tasks from all of the workers, this would create an unbounded number of threads in each master, eventually causing some of them to fail upon creating another thread.</p>\n<p>There's a fix in PR <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"170774735\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/tensorflow/tensorflow/issues/3757\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/tensorflow/tensorflow/pull/3757/hovercard\" href=\"https://github.com/tensorflow/tensorflow/pull/3757\">#3757</a>, which is under review now. I tested it locally, and it's been running for hours now on my local machine without failure. Can you try it and confirm that it works?</p>\n<p>Thanks for persevering with this long-running issue!</p>", "body_text": "An alternative and more plausible hypothesis for the \"thread leak\" I mentioned above: backpressure on the cleanup task would prevent these from completing in a timely manner. However, since the master doesn't block on the completion of that task before returning, a single client thread would be free to send more run requests, creating further cleanup tasks without bound. Since the worker service was only allowing a single cleanup task to complete at once, and the parameter server would be receiving cleanup tasks from all of the workers, this would create an unbounded number of threads in each master, eventually causing some of them to fail upon creating another thread.\nThere's a fix in PR #3757, which is under review now. I tested it locally, and it's been running for hours now on my local machine without failure. Can you try it and confirm that it works?\nThanks for persevering with this long-running issue!", "body": "An alternative and more plausible hypothesis for the \"thread leak\" I mentioned above: backpressure on the cleanup task would prevent these from completing in a timely manner. However, since the master doesn't block on the completion of that task before returning, a single client thread would be free to send more run requests, creating further cleanup tasks without bound. Since the worker service was only allowing a single cleanup task to complete at once, and the parameter server would be receiving cleanup tasks from all of the workers, this would create an unbounded number of threads in each master, eventually causing some of them to fail upon creating another thread.\n\nThere's a fix in PR #3757, which is under review now. I tested it locally, and it's been running for hours now on my local machine without failure. Can you try it and confirm that it works?\n\nThanks for persevering with this long-running issue!\n"}