{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/239312416", "html_url": "https://github.com/tensorflow/tensorflow/issues/3470#issuecomment-239312416", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/3470", "id": 239312416, "node_id": "MDEyOklzc3VlQ29tbWVudDIzOTMxMjQxNg==", "user": {"login": "mrry", "id": 192142, "node_id": "MDQ6VXNlcjE5MjE0Mg==", "avatar_url": "https://avatars1.githubusercontent.com/u/192142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mrry", "html_url": "https://github.com/mrry", "followers_url": "https://api.github.com/users/mrry/followers", "following_url": "https://api.github.com/users/mrry/following{/other_user}", "gists_url": "https://api.github.com/users/mrry/gists{/gist_id}", "starred_url": "https://api.github.com/users/mrry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mrry/subscriptions", "organizations_url": "https://api.github.com/users/mrry/orgs", "repos_url": "https://api.github.com/users/mrry/repos", "events_url": "https://api.github.com/users/mrry/events{/privacy}", "received_events_url": "https://api.github.com/users/mrry/received_events", "type": "User", "site_admin": false}, "created_at": "2016-08-11T22:26:33Z", "updated_at": "2016-08-12T15:14:03Z", "author_association": "CONTRIBUTOR", "body_html": "<p>An update: I was able to reproduce the memory leak with r0.10, and it seems to be due to an RPC stub object not being deleted correctly. This logic was changed just after r0.10 was branched, and it appears that the nightly code no longer has the same leak.</p>\n<p>However, there's a second issue, which is related to the core dump you were seeing:</p>\n<blockquote>\n<pre><code>terminate called after throwing an instance of 'std::system_error'\n  what():  Resource temporarily unavailable\nAborted (core dumped)\n</code></pre>\n</blockquote>\n<p>This is being caused by a <strong>thread leak</strong>* in the distributed runtime. When I reproduced this and inspected a core dump, I found over 2000 threads blocked on a notification at the same point in the code, which is related to cleaning up after running a step. It appears that in some fraction of steps, at least one of the responses to these messages was being lost (or the request never made it to the remote server), which would leak a thread waiting on the response.</p>\n<p>I have a workaround in preparation, and I'll send a PR soon.</p>\n<p>[* <strong>EDIT:</strong> see next message for a better explanation.]</p>", "body_text": "An update: I was able to reproduce the memory leak with r0.10, and it seems to be due to an RPC stub object not being deleted correctly. This logic was changed just after r0.10 was branched, and it appears that the nightly code no longer has the same leak.\nHowever, there's a second issue, which is related to the core dump you were seeing:\n\nterminate called after throwing an instance of 'std::system_error'\n  what():  Resource temporarily unavailable\nAborted (core dumped)\n\n\nThis is being caused by a thread leak* in the distributed runtime. When I reproduced this and inspected a core dump, I found over 2000 threads blocked on a notification at the same point in the code, which is related to cleaning up after running a step. It appears that in some fraction of steps, at least one of the responses to these messages was being lost (or the request never made it to the remote server), which would leak a thread waiting on the response.\nI have a workaround in preparation, and I'll send a PR soon.\n[* EDIT: see next message for a better explanation.]", "body": "An update: I was able to reproduce the memory leak with r0.10, and it seems to be due to an RPC stub object not being deleted correctly. This logic was changed just after r0.10 was branched, and it appears that the nightly code no longer has the same leak.\n\nHowever, there's a second issue, which is related to the core dump you were seeing:\n\n> ```\n> terminate called after throwing an instance of 'std::system_error'\n>   what():  Resource temporarily unavailable\n> Aborted (core dumped)\n> ```\n\nThis is being caused by a **thread leak**\\* in the distributed runtime. When I reproduced this and inspected a core dump, I found over 2000 threads blocked on a notification at the same point in the code, which is related to cleaning up after running a step. It appears that in some fraction of steps, at least one of the responses to these messages was being lost (or the request never made it to the remote server), which would leak a thread waiting on the response.\n\nI have a workaround in preparation, and I'll send a PR soon.\n\n[\\* **EDIT:** see next message for a better explanation.]\n"}