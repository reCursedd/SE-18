{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/319306351", "html_url": "https://github.com/tensorflow/tensorflow/pull/11907#issuecomment-319306351", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11907", "id": 319306351, "node_id": "MDEyOklzc3VlQ29tbWVudDMxOTMwNjM1MQ==", "user": {"login": "DavidNorman", "id": 606831, "node_id": "MDQ6VXNlcjYwNjgzMQ==", "avatar_url": "https://avatars2.githubusercontent.com/u/606831?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DavidNorman", "html_url": "https://github.com/DavidNorman", "followers_url": "https://api.github.com/users/DavidNorman/followers", "following_url": "https://api.github.com/users/DavidNorman/following{/other_user}", "gists_url": "https://api.github.com/users/DavidNorman/gists{/gist_id}", "starred_url": "https://api.github.com/users/DavidNorman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DavidNorman/subscriptions", "organizations_url": "https://api.github.com/users/DavidNorman/orgs", "repos_url": "https://api.github.com/users/DavidNorman/repos", "events_url": "https://api.github.com/users/DavidNorman/events{/privacy}", "received_events_url": "https://api.github.com/users/DavidNorman/received_events", "type": "User", "site_admin": false}, "created_at": "2017-08-01T08:38:15Z", "updated_at": "2017-08-01T08:38:15Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Sure.  The limitations of the current scheme are that there are only 6 explicit types.  One of them is  'kConvBackwardFilter', which maps to a special backwards conv operation specifically for the GPU hardware.</p>\n<p>In our hardware we have, for instance, an operation is which like parts of an average_pool.  It is like the reduce_window followed by the divide.  I am using the fusion mechanism to fuse these two things into one thing, just like the kConvBackwardFilter does for the GPU hardware.</p>\n<p>To label this fusion, I could introduce a new value into the enumeration that describes the operation.  However, I have been asked not to put things into the public repo that are specific to our hardware.  Notwithstanding the fact that other companies are doing exactly that, I think it is a good idea to separate out 3rd party devices.</p>\n<p>Which means that the public repo must provide a mechanism for extending all enumerations cleanly.   Adding a 'custom' upper bound is one way of doing this - probably the simplest way.</p>\n<p>Hope this helps.</p>\n<p>Cheers</p>", "body_text": "Sure.  The limitations of the current scheme are that there are only 6 explicit types.  One of them is  'kConvBackwardFilter', which maps to a special backwards conv operation specifically for the GPU hardware.\nIn our hardware we have, for instance, an operation is which like parts of an average_pool.  It is like the reduce_window followed by the divide.  I am using the fusion mechanism to fuse these two things into one thing, just like the kConvBackwardFilter does for the GPU hardware.\nTo label this fusion, I could introduce a new value into the enumeration that describes the operation.  However, I have been asked not to put things into the public repo that are specific to our hardware.  Notwithstanding the fact that other companies are doing exactly that, I think it is a good idea to separate out 3rd party devices.\nWhich means that the public repo must provide a mechanism for extending all enumerations cleanly.   Adding a 'custom' upper bound is one way of doing this - probably the simplest way.\nHope this helps.\nCheers", "body": "Sure.  The limitations of the current scheme are that there are only 6 explicit types.  One of them is  'kConvBackwardFilter', which maps to a special backwards conv operation specifically for the GPU hardware.\r\n\r\nIn our hardware we have, for instance, an operation is which like parts of an average_pool.  It is like the reduce_window<add> followed by the divide.  I am using the fusion mechanism to fuse these two things into one thing, just like the kConvBackwardFilter does for the GPU hardware.\r\n\r\nTo label this fusion, I could introduce a new value into the enumeration that describes the operation.  However, I have been asked not to put things into the public repo that are specific to our hardware.  Notwithstanding the fact that other companies are doing exactly that, I think it is a good idea to separate out 3rd party devices.\r\n\r\nWhich means that the public repo must provide a mechanism for extending all enumerations cleanly.   Adding a 'custom' upper bound is one way of doing this - probably the simplest way.\r\n\r\nHope this helps.\r\n\r\nCheers\r\n\r\n"}