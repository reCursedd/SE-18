{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/306163407", "html_url": "https://github.com/tensorflow/tensorflow/issues/9360#issuecomment-306163407", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9360", "id": 306163407, "node_id": "MDEyOklzc3VlQ29tbWVudDMwNjE2MzQwNw==", "user": {"login": "sandipmgiri", "id": 16284232, "node_id": "MDQ6VXNlcjE2Mjg0MjMy", "avatar_url": "https://avatars0.githubusercontent.com/u/16284232?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sandipmgiri", "html_url": "https://github.com/sandipmgiri", "followers_url": "https://api.github.com/users/sandipmgiri/followers", "following_url": "https://api.github.com/users/sandipmgiri/following{/other_user}", "gists_url": "https://api.github.com/users/sandipmgiri/gists{/gist_id}", "starred_url": "https://api.github.com/users/sandipmgiri/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sandipmgiri/subscriptions", "organizations_url": "https://api.github.com/users/sandipmgiri/orgs", "repos_url": "https://api.github.com/users/sandipmgiri/repos", "events_url": "https://api.github.com/users/sandipmgiri/events{/privacy}", "received_events_url": "https://api.github.com/users/sandipmgiri/received_events", "type": "User", "site_admin": false}, "created_at": "2017-06-05T11:12:50Z", "updated_at": "2017-06-13T05:30:54Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Hi <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=20959853\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/drpngx\">@drpngx</a> , <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=577277\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/martinwicke\">@martinwicke</a>,</p>\n<p>I have discussed this issue with numpy community - <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"225672370\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/numpy/numpy/issues/9040\" data-hovercard-type=\"issue\" data-hovercard-url=\"/numpy/numpy/issues/9040/hovercard\" href=\"https://github.com/numpy/numpy/issues/9040\">numpy/numpy#9040</a></p>\n<p><strong>Issue</strong> :  np.float64(\"inf\").astype(np.int32) is negative on x86 but positive on ppc64le</p>\n<p><strong>They mentioned as follows</strong> -</p>\n<ol>\n<li>\n<p>Note that doing this cast incurs undefined behaviour, so it's hard to say which platform is incorrect here.I'd argue that we should just issue a warning and leave the platform-specific behaviour.</p>\n</li>\n<li>\n<p>This is also true of any C program that tries to cast float to int. If the author of a python package included a C extension that does this cast, they still have the problem.<br>\nThe same argument you use for \"we should fix this is numpy, not in the user package\" can be applied to \"we should fix this in C, not in numpy\". Presumably for speed reasons, that argument was rejected during the design of C.<br>\nHaving said that, we already diverge from C behaviour in some place (eg, integer promotion for arithmetic and comparison), so it wouldn't be unreasonable to add special casing here.</p>\n</li>\n</ol>\n<p>To understand more clearly, please go through numpy discussion i.e . <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"225672370\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/numpy/numpy/issues/9040\" data-hovercard-type=\"issue\" data-hovercard-url=\"/numpy/numpy/issues/9040/hovercard\" href=\"https://github.com/numpy/numpy/issues/9040\">numpy/numpy#9040</a></p>\n<p>So as per this discussion -  I think we should add the power specific condition in tensorflow source code  : <a href=\"https://github.com/tensorflow/tensorflow/blob/v1.0.1/tensorflow/python/kernel_tests/cast_op_test.py#L150-L151\">https://github.com/tensorflow/tensorflow/blob/v1.0.1/tensorflow/python/kernel_tests/cast_op_test.py#L150-L151</a></p>\n<pre><code>def testInfNan(self):\n    i4 = np.iinfo(np.int32)\n    i8 = np.iinfo(np.int64)\n\n    self._compare(np.inf, np.float32, np.inf, False)\n    self._compare(np.inf, np.float64, np.inf, False)\n    if sys.byteorder == \"big\":\n      self._compare(np.inf, np.int32, i4.max, False)\n      self._compare(np.inf, np.int64, i8.max, False)\n    else:\n        self._compare(np.inf, np.int32, i4.min, False)\n        self._compare(np.inf, np.int64, i8.min, False)\n\n</code></pre>\n<p>It could be changed to :</p>\n<pre><code>`def testInfNan(self):\n    i4 = np.iinfo(np.int32)\n    i8 = np.iinfo(np.int64)\n\n    self._compare(np.inf, np.float32, np.inf, False)\n    self._compare(np.inf, np.float64, np.inf, False)\n    if sys.byteorder == \"big\":\n      self._compare(np.inf, np.int32, i4.max, False)\n      self._compare(np.inf, np.int64, i8.max, False)\n    else:\n      if platform.machine() == \"ppc64le\":\n        self._compare(-np.inf, np.int32, i4.min, False)\n        self._compare(-np.inf, np.int64, i8.min, False)\n      else:\n        self._compare(np.inf, np.int32, i4.min, False)\n        self._compare(np.inf, np.int64, i8.min, False)\n`\n</code></pre>\n<p>After this change test is passing on ppc64le. Please provide your comments/suggestions on this.Thanks!</p>", "body_text": "Hi @drpngx , @martinwicke,\nI have discussed this issue with numpy community - numpy/numpy#9040\nIssue :  np.float64(\"inf\").astype(np.int32) is negative on x86 but positive on ppc64le\nThey mentioned as follows -\n\n\nNote that doing this cast incurs undefined behaviour, so it's hard to say which platform is incorrect here.I'd argue that we should just issue a warning and leave the platform-specific behaviour.\n\n\nThis is also true of any C program that tries to cast float to int. If the author of a python package included a C extension that does this cast, they still have the problem.\nThe same argument you use for \"we should fix this is numpy, not in the user package\" can be applied to \"we should fix this in C, not in numpy\". Presumably for speed reasons, that argument was rejected during the design of C.\nHaving said that, we already diverge from C behaviour in some place (eg, integer promotion for arithmetic and comparison), so it wouldn't be unreasonable to add special casing here.\n\n\nTo understand more clearly, please go through numpy discussion i.e . numpy/numpy#9040\nSo as per this discussion -  I think we should add the power specific condition in tensorflow source code  : https://github.com/tensorflow/tensorflow/blob/v1.0.1/tensorflow/python/kernel_tests/cast_op_test.py#L150-L151\ndef testInfNan(self):\n    i4 = np.iinfo(np.int32)\n    i8 = np.iinfo(np.int64)\n\n    self._compare(np.inf, np.float32, np.inf, False)\n    self._compare(np.inf, np.float64, np.inf, False)\n    if sys.byteorder == \"big\":\n      self._compare(np.inf, np.int32, i4.max, False)\n      self._compare(np.inf, np.int64, i8.max, False)\n    else:\n        self._compare(np.inf, np.int32, i4.min, False)\n        self._compare(np.inf, np.int64, i8.min, False)\n\n\nIt could be changed to :\n`def testInfNan(self):\n    i4 = np.iinfo(np.int32)\n    i8 = np.iinfo(np.int64)\n\n    self._compare(np.inf, np.float32, np.inf, False)\n    self._compare(np.inf, np.float64, np.inf, False)\n    if sys.byteorder == \"big\":\n      self._compare(np.inf, np.int32, i4.max, False)\n      self._compare(np.inf, np.int64, i8.max, False)\n    else:\n      if platform.machine() == \"ppc64le\":\n        self._compare(-np.inf, np.int32, i4.min, False)\n        self._compare(-np.inf, np.int64, i8.min, False)\n      else:\n        self._compare(np.inf, np.int32, i4.min, False)\n        self._compare(np.inf, np.int64, i8.min, False)\n`\n\nAfter this change test is passing on ppc64le. Please provide your comments/suggestions on this.Thanks!", "body": "Hi @drpngx , @martinwicke,\r\n\r\nI have discussed this issue with numpy community - https://github.com/numpy/numpy/issues/9040\r\n\r\n**Issue** :  np.float64(\"inf\").astype(np.int32) is negative on x86 but positive on ppc64le\r\n\r\n**They mentioned as follows** -\r\n\r\n1. Note that doing this cast incurs undefined behaviour, so it's hard to say which platform is incorrect here.I'd argue that we should just issue a warning and leave the platform-specific behaviour.\r\n\r\n2. This is also true of any C program that tries to cast float to int. If the author of a python package included a C extension that does this cast, they still have the problem.\r\n The same argument you use for \"we should fix this is numpy, not in the user package\" can be applied to \"we should fix this in C, not in numpy\". Presumably for speed reasons, that argument was rejected during the design of C.\r\nHaving said that, we already diverge from C behaviour in some place (eg, integer promotion for arithmetic and comparison), so it wouldn't be unreasonable to add special casing here.\r\n\r\nTo understand more clearly, please go through numpy discussion i.e . https://github.com/numpy/numpy/issues/9040\r\n\r\nSo as per this discussion -  I think we should add the power specific condition in tensorflow source code  : https://github.com/tensorflow/tensorflow/blob/v1.0.1/tensorflow/python/kernel_tests/cast_op_test.py#L150-L151\r\n\r\n```\r\ndef testInfNan(self):\r\n    i4 = np.iinfo(np.int32)\r\n    i8 = np.iinfo(np.int64)\r\n\r\n    self._compare(np.inf, np.float32, np.inf, False)\r\n    self._compare(np.inf, np.float64, np.inf, False)\r\n    if sys.byteorder == \"big\":\r\n      self._compare(np.inf, np.int32, i4.max, False)\r\n      self._compare(np.inf, np.int64, i8.max, False)\r\n    else:\r\n        self._compare(np.inf, np.int32, i4.min, False)\r\n        self._compare(np.inf, np.int64, i8.min, False)\r\n\r\n```\r\nIt could be changed to : \r\n```\r\n`def testInfNan(self):\r\n    i4 = np.iinfo(np.int32)\r\n    i8 = np.iinfo(np.int64)\r\n\r\n    self._compare(np.inf, np.float32, np.inf, False)\r\n    self._compare(np.inf, np.float64, np.inf, False)\r\n    if sys.byteorder == \"big\":\r\n      self._compare(np.inf, np.int32, i4.max, False)\r\n      self._compare(np.inf, np.int64, i8.max, False)\r\n    else:\r\n      if platform.machine() == \"ppc64le\":\r\n        self._compare(-np.inf, np.int32, i4.min, False)\r\n        self._compare(-np.inf, np.int64, i8.min, False)\r\n      else:\r\n        self._compare(np.inf, np.int32, i4.min, False)\r\n        self._compare(np.inf, np.int64, i8.min, False)\r\n`\r\n```\r\n\r\nAfter this change test is passing on ppc64le. Please provide your comments/suggestions on this.Thanks!"}