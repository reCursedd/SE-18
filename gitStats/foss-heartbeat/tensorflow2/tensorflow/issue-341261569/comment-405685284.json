{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/405685284", "html_url": "https://github.com/tensorflow/tensorflow/issues/20805#issuecomment-405685284", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/20805", "id": 405685284, "node_id": "MDEyOklzc3VlQ29tbWVudDQwNTY4NTI4NA==", "user": {"login": "nairouz", "id": 10966954, "node_id": "MDQ6VXNlcjEwOTY2OTU0", "avatar_url": "https://avatars0.githubusercontent.com/u/10966954?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nairouz", "html_url": "https://github.com/nairouz", "followers_url": "https://api.github.com/users/nairouz/followers", "following_url": "https://api.github.com/users/nairouz/following{/other_user}", "gists_url": "https://api.github.com/users/nairouz/gists{/gist_id}", "starred_url": "https://api.github.com/users/nairouz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nairouz/subscriptions", "organizations_url": "https://api.github.com/users/nairouz/orgs", "repos_url": "https://api.github.com/users/nairouz/repos", "events_url": "https://api.github.com/users/nairouz/events{/privacy}", "received_events_url": "https://api.github.com/users/nairouz/received_events", "type": "User", "site_admin": false}, "created_at": "2018-07-17T18:39:21Z", "updated_at": "2018-07-17T18:40:58Z", "author_association": "NONE", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=17325195\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/raymond-yuan\">@raymond-yuan</a><br>\nWhen defining my own custom layer's build function.<br>\nFor the graph based execution, there should be no problem running the code without the TensorShape trick.<br>\nTry running the code that you gave me without the TensorShape trick in the case of the graph based execution, you will get an error.</p>\n<h3>Code:</h3>\n<pre><code>import tensorflow.keras as keras \n\nclass MyLayer(keras.layers.Layer):\n\n  def __init__(self, output_dim, **kwargs):\n    self.output_dim = output_dim\n    super(MyLayer, self).__init__(**kwargs)\n\n  def build(self, input_shape):\n    # Create a trainable weight variable for this layer.\n    self.kernel = self.add_weight(name='kernel',\n                                  shape=(input_shape[1], self.output_dim),\n                                  initializer='uniform',\n                                  trainable=True)\n    # Be sure to call this at the end\n    super(MyLayer, self).build(input_shape)\n\n  def call(self, inputs):\n    return tf.matmul(inputs, self.kernel)\n\n  def compute_output_shape(self, input_shape):\n    shape = tf.TensorShape(input_shape).as_list()\n    shape[-1] = self.output_dim\n    return tf.TensorShape(shape)\n\n  def get_config(self):\n    base_config = super(MyLayer, self).get_config()\n    base_config['output_dim'] = self.output_dim\n\n  @classmethod\n  def from_config(cls, config):\n    return cls(**config)\n\ninput1 = keras.layers.Input(shape=(10,), name=\"input\")\nlayer = MyLayer(output_dim=5, name='clustering')\nout = layer(input1)\nprint(out)\n</code></pre>\n<h3>Error</h3>\n<p>/usr/local/lib/python2.7/dist-packages/tensorflow/python/ops/random_ops.pyc in random_uniform(shape, minval, maxval, dtype, seed, name)<br>\n232     maxval = 1<br>\n233   with ops.name_scope(name, \"random_uniform\", [shape, minval, maxval]) as name:<br>\n--&gt; 234     shape = _ShapeTensor(shape)<br>\n235     minval = ops.convert_to_tensor(minval, dtype=dtype, name=\"min\")<br>\n236     maxval = ops.convert_to_tensor(maxval, dtype=dtype, name=\"max\")</p>\n<p>/usr/local/lib/python2.7/dist-packages/tensorflow/python/ops/random_ops.pyc in _ShapeTensor(shape)<br>\n41   else:<br>\n42     dtype = None<br>\n---&gt; 43   return ops.convert_to_tensor(shape, dtype=dtype, name=\"shape\")<br>\n44<br>\n45</p>\n<p>/usr/local/lib/python2.7/dist-packages/tensorflow/python/framework/ops.pyc in convert_to_tensor(value, dtype, name, preferred_dtype)<br>\n1009       name=name,<br>\n1010       preferred_dtype=preferred_dtype,<br>\n-&gt; 1011       as_ref=False)<br>\n1012<br>\n1013</p>\n<p>/usr/local/lib/python2.7/dist-packages/tensorflow/python/framework/ops.pyc in internal_convert_to_tensor(value, dtype, name, as_ref, preferred_dtype, ctx)<br>\n1105<br>\n1106     if ret is None:<br>\n-&gt; 1107       ret = conversion_func(value, dtype=dtype, name=name, as_ref=as_ref)<br>\n1108<br>\n1109     if ret is NotImplemented:</p>\n<p>/usr/local/lib/python2.7/dist-packages/tensorflow/python/framework/constant_op.pyc in _constant_tensor_conversion_function(v, dtype, name, as_ref)<br>\n215                                          as_ref=False):<br>\n216   _ = as_ref<br>\n--&gt; 217   return constant(v, dtype=dtype, name=name)<br>\n218<br>\n219</p>\n<p>/usr/local/lib/python2.7/dist-packages/tensorflow/python/framework/constant_op.pyc in constant(value, dtype, shape, name, verify_shape)<br>\n194   tensor_value.tensor.CopyFrom(<br>\n195       tensor_util.make_tensor_proto(<br>\n--&gt; 196           value, dtype=dtype, shape=shape, verify_shape=verify_shape))<br>\n197   dtype_value = attr_value_pb2.AttrValue(type=tensor_value.tensor.dtype)<br>\n198   const_tensor = g.create_op(</p>\n<p>/usr/local/lib/python2.7/dist-packages/tensorflow/python/framework/tensor_util.pyc in make_tensor_proto(values, dtype, shape, verify_shape)<br>\n523       raise TypeError(\"Failed to convert object of type %s to Tensor. \"<br>\n524                       \"Contents: %s. Consider casting elements to a \"<br>\n--&gt; 525                       \"supported type.\" % (type(values), values))<br>\n526     tensor_proto.string_val.extend(str_values)<br>\n527     return tensor_proto</p>\n<p>TypeError: Failed to convert object of type &lt;type 'tuple'&gt; to Tensor. Contents: (Dimension(10), 5). Consider casting elements to a supported type.</p>", "body_text": "@raymond-yuan\nWhen defining my own custom layer's build function.\nFor the graph based execution, there should be no problem running the code without the TensorShape trick.\nTry running the code that you gave me without the TensorShape trick in the case of the graph based execution, you will get an error.\nCode:\nimport tensorflow.keras as keras \n\nclass MyLayer(keras.layers.Layer):\n\n  def __init__(self, output_dim, **kwargs):\n    self.output_dim = output_dim\n    super(MyLayer, self).__init__(**kwargs)\n\n  def build(self, input_shape):\n    # Create a trainable weight variable for this layer.\n    self.kernel = self.add_weight(name='kernel',\n                                  shape=(input_shape[1], self.output_dim),\n                                  initializer='uniform',\n                                  trainable=True)\n    # Be sure to call this at the end\n    super(MyLayer, self).build(input_shape)\n\n  def call(self, inputs):\n    return tf.matmul(inputs, self.kernel)\n\n  def compute_output_shape(self, input_shape):\n    shape = tf.TensorShape(input_shape).as_list()\n    shape[-1] = self.output_dim\n    return tf.TensorShape(shape)\n\n  def get_config(self):\n    base_config = super(MyLayer, self).get_config()\n    base_config['output_dim'] = self.output_dim\n\n  @classmethod\n  def from_config(cls, config):\n    return cls(**config)\n\ninput1 = keras.layers.Input(shape=(10,), name=\"input\")\nlayer = MyLayer(output_dim=5, name='clustering')\nout = layer(input1)\nprint(out)\n\nError\n/usr/local/lib/python2.7/dist-packages/tensorflow/python/ops/random_ops.pyc in random_uniform(shape, minval, maxval, dtype, seed, name)\n232     maxval = 1\n233   with ops.name_scope(name, \"random_uniform\", [shape, minval, maxval]) as name:\n--> 234     shape = _ShapeTensor(shape)\n235     minval = ops.convert_to_tensor(minval, dtype=dtype, name=\"min\")\n236     maxval = ops.convert_to_tensor(maxval, dtype=dtype, name=\"max\")\n/usr/local/lib/python2.7/dist-packages/tensorflow/python/ops/random_ops.pyc in _ShapeTensor(shape)\n41   else:\n42     dtype = None\n---> 43   return ops.convert_to_tensor(shape, dtype=dtype, name=\"shape\")\n44\n45\n/usr/local/lib/python2.7/dist-packages/tensorflow/python/framework/ops.pyc in convert_to_tensor(value, dtype, name, preferred_dtype)\n1009       name=name,\n1010       preferred_dtype=preferred_dtype,\n-> 1011       as_ref=False)\n1012\n1013\n/usr/local/lib/python2.7/dist-packages/tensorflow/python/framework/ops.pyc in internal_convert_to_tensor(value, dtype, name, as_ref, preferred_dtype, ctx)\n1105\n1106     if ret is None:\n-> 1107       ret = conversion_func(value, dtype=dtype, name=name, as_ref=as_ref)\n1108\n1109     if ret is NotImplemented:\n/usr/local/lib/python2.7/dist-packages/tensorflow/python/framework/constant_op.pyc in _constant_tensor_conversion_function(v, dtype, name, as_ref)\n215                                          as_ref=False):\n216   _ = as_ref\n--> 217   return constant(v, dtype=dtype, name=name)\n218\n219\n/usr/local/lib/python2.7/dist-packages/tensorflow/python/framework/constant_op.pyc in constant(value, dtype, shape, name, verify_shape)\n194   tensor_value.tensor.CopyFrom(\n195       tensor_util.make_tensor_proto(\n--> 196           value, dtype=dtype, shape=shape, verify_shape=verify_shape))\n197   dtype_value = attr_value_pb2.AttrValue(type=tensor_value.tensor.dtype)\n198   const_tensor = g.create_op(\n/usr/local/lib/python2.7/dist-packages/tensorflow/python/framework/tensor_util.pyc in make_tensor_proto(values, dtype, shape, verify_shape)\n523       raise TypeError(\"Failed to convert object of type %s to Tensor. \"\n524                       \"Contents: %s. Consider casting elements to a \"\n--> 525                       \"supported type.\" % (type(values), values))\n526     tensor_proto.string_val.extend(str_values)\n527     return tensor_proto\nTypeError: Failed to convert object of type <type 'tuple'> to Tensor. Contents: (Dimension(10), 5). Consider casting elements to a supported type.", "body": "@raymond-yuan \r\nWhen defining my own custom layer's build function.\r\nFor the graph based execution, there should be no problem running the code without the TensorShape trick.\r\nTry running the code that you gave me without the TensorShape trick in the case of the graph based execution, you will get an error.\r\n\r\n###  Code:\r\n\r\n    import tensorflow.keras as keras \r\n\r\n    class MyLayer(keras.layers.Layer):\r\n\r\n      def __init__(self, output_dim, **kwargs):\r\n        self.output_dim = output_dim\r\n        super(MyLayer, self).__init__(**kwargs)\r\n\r\n      def build(self, input_shape):\r\n        # Create a trainable weight variable for this layer.\r\n        self.kernel = self.add_weight(name='kernel',\r\n                                      shape=(input_shape[1], self.output_dim),\r\n                                      initializer='uniform',\r\n                                      trainable=True)\r\n        # Be sure to call this at the end\r\n        super(MyLayer, self).build(input_shape)\r\n\r\n      def call(self, inputs):\r\n        return tf.matmul(inputs, self.kernel)\r\n\r\n      def compute_output_shape(self, input_shape):\r\n        shape = tf.TensorShape(input_shape).as_list()\r\n        shape[-1] = self.output_dim\r\n        return tf.TensorShape(shape)\r\n\r\n      def get_config(self):\r\n        base_config = super(MyLayer, self).get_config()\r\n        base_config['output_dim'] = self.output_dim\r\n\r\n      @classmethod\r\n      def from_config(cls, config):\r\n        return cls(**config)\r\n\r\n    input1 = keras.layers.Input(shape=(10,), name=\"input\")\r\n    layer = MyLayer(output_dim=5, name='clustering')\r\n    out = layer(input1)\r\n    print(out)\r\n\r\n### Error\r\n\r\n/usr/local/lib/python2.7/dist-packages/tensorflow/python/ops/random_ops.pyc in random_uniform(shape, minval, maxval, dtype, seed, name)\r\n    232     maxval = 1\r\n    233   with ops.name_scope(name, \"random_uniform\", [shape, minval, maxval]) as name:\r\n--> 234     shape = _ShapeTensor(shape)\r\n    235     minval = ops.convert_to_tensor(minval, dtype=dtype, name=\"min\")\r\n    236     maxval = ops.convert_to_tensor(maxval, dtype=dtype, name=\"max\")\r\n\r\n/usr/local/lib/python2.7/dist-packages/tensorflow/python/ops/random_ops.pyc in _ShapeTensor(shape)\r\n     41   else:\r\n     42     dtype = None\r\n---> 43   return ops.convert_to_tensor(shape, dtype=dtype, name=\"shape\")\r\n     44 \r\n     45 \r\n\r\n/usr/local/lib/python2.7/dist-packages/tensorflow/python/framework/ops.pyc in convert_to_tensor(value, dtype, name, preferred_dtype)\r\n   1009       name=name,\r\n   1010       preferred_dtype=preferred_dtype,\r\n-> 1011       as_ref=False)\r\n   1012 \r\n   1013 \r\n\r\n/usr/local/lib/python2.7/dist-packages/tensorflow/python/framework/ops.pyc in internal_convert_to_tensor(value, dtype, name, as_ref, preferred_dtype, ctx)\r\n   1105 \r\n   1106     if ret is None:\r\n-> 1107       ret = conversion_func(value, dtype=dtype, name=name, as_ref=as_ref)\r\n   1108 \r\n   1109     if ret is NotImplemented:\r\n\r\n/usr/local/lib/python2.7/dist-packages/tensorflow/python/framework/constant_op.pyc in _constant_tensor_conversion_function(v, dtype, name, as_ref)\r\n    215                                          as_ref=False):\r\n    216   _ = as_ref\r\n--> 217   return constant(v, dtype=dtype, name=name)\r\n    218 \r\n    219 \r\n\r\n/usr/local/lib/python2.7/dist-packages/tensorflow/python/framework/constant_op.pyc in constant(value, dtype, shape, name, verify_shape)\r\n    194   tensor_value.tensor.CopyFrom(\r\n    195       tensor_util.make_tensor_proto(\r\n--> 196           value, dtype=dtype, shape=shape, verify_shape=verify_shape))\r\n    197   dtype_value = attr_value_pb2.AttrValue(type=tensor_value.tensor.dtype)\r\n    198   const_tensor = g.create_op(\r\n\r\n/usr/local/lib/python2.7/dist-packages/tensorflow/python/framework/tensor_util.pyc in make_tensor_proto(values, dtype, shape, verify_shape)\r\n    523       raise TypeError(\"Failed to convert object of type %s to Tensor. \"\r\n    524                       \"Contents: %s. Consider casting elements to a \"\r\n--> 525                       \"supported type.\" % (type(values), values))\r\n    526     tensor_proto.string_val.extend(str_values)\r\n    527     return tensor_proto\r\n\r\nTypeError: Failed to convert object of type <type 'tuple'> to Tensor. Contents: (Dimension(10), 5). Consider casting elements to a supported type.\r\n\r\n"}