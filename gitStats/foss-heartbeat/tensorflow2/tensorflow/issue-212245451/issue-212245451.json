{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8139", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8139/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8139/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8139/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/8139", "id": 212245451, "node_id": "MDU6SXNzdWUyMTIyNDU0NTE=", "number": 8139, "title": "Misunderstood noise with moments of reused variables", "user": {"login": "lw394", "id": 15891975, "node_id": "MDQ6VXNlcjE1ODkxOTc1", "avatar_url": "https://avatars3.githubusercontent.com/u/15891975?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lw394", "html_url": "https://github.com/lw394", "followers_url": "https://api.github.com/users/lw394/followers", "following_url": "https://api.github.com/users/lw394/following{/other_user}", "gists_url": "https://api.github.com/users/lw394/gists{/gist_id}", "starred_url": "https://api.github.com/users/lw394/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lw394/subscriptions", "organizations_url": "https://api.github.com/users/lw394/orgs", "repos_url": "https://api.github.com/users/lw394/repos", "events_url": "https://api.github.com/users/lw394/events{/privacy}", "received_events_url": "https://api.github.com/users/lw394/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2017-03-06T20:49:00Z", "updated_at": "2017-03-06T22:06:45Z", "closed_at": "2017-03-06T22:06:45Z", "author_association": "NONE", "body_html": "<p>I'm getting small variations in the result of running the same op repeatedly on what should be the same data for every sess.run().</p>\n<p>The included script demonstrates the issue.  Similar to batch norm, the function normalizer() maintains moving averages of the mean and var of the input tensor, but only updates those values when 'update=True'.  Whether True of False, the function returns the input tensor scaled and centered by the current moving average statistics.</p>\n<p>In this example, I first normalize the input by its moments, and print out the new moments, only to validate that I get the same result every time, since the input is a constant.</p>\n<p>Next, I compute the moments of the output repeatedly when normalizer() is configured with update =True, so I can see the moments converging as expected towards their final state, but stop after only 20 steps.</p>\n<p>These first two steps behave as expected.</p>\n<p>Lastly, I compute the moments of the same output tensor repeatedly when normalizer() is configured with update=False. In this case, the moving averages shouldn't be updating so I expect to see the same moment values at every step. This is almost true, but there is a small amount noise that I wouldn't expect. Is this a tensorflow bug?</p>\n<h3>What related GitHub issues or StackOverflow threads have you found by searching the web for your problem?</h3>\n<p>None</p>\n<h3>Environment info</h3>\n<p>Operating System: Ubuntu 16.04</p>\n<p>Installed version of CUDA and cuDNN:<br>\n-rw-r--r-- 1 root   root    556000 Jan 26 18:48 /usr/local/cuda/lib64/libcudadevrt.a<br>\nlrwxrwxrwx 1 root   root        16 Jan 26 18:51 /usr/local/cuda/lib64/libcudart.so -&gt; libcudart.so.8.0<br>\nlrwxrwxrwx 1 root   root        19 Jan 26 18:51 /usr/local/cuda/lib64/libcudart.so.8.0 -&gt; libcudart.so.8.0.61<br>\n-rw-r--r-- 1 root   root    415432 Jan 26 18:48 /usr/local/cuda/lib64/libcudart.so.8.0.61<br>\n-rw-r--r-- 1 root   root    775162 Jan 26 18:48 /usr/local/cuda/lib64/libcudart_static.a<br>\nlrwxrwxrwx 1 bmages users       13 Jul 27  2016 /usr/local/cuda/lib64/libcudnn.so -&gt; libcudnn.so.5<br>\nlrwxrwxrwx 1 bmages users       17 Jul 27  2016 /usr/local/cuda/lib64/libcudnn.so.5 -&gt; libcudnn.so.5.1.5<br>\n-rwxrwxr-x 1 bmages users 79337624 Jul 27  2016 /usr/local/cuda/lib64/libcudnn.so.5.1.5<br>\n-rw-rw-r-- 1 bmages users 69756172 Jul 27  2016 /usr/local/cuda/lib64/libcudnn_static.a</p>\n<p>Tensorflow 1.0.0</p>\n<h3>Code</h3>\n<pre><code>\nimport numpy as np\nimport tensorflow as tf\ndef normalizer(tensor,shape,axis=[0],decay = .999,update=True,\n                          epsilon = 1e-10,scope='normalizer' ):\n\n    with tf.variable_scope(scope,reuse=not(update)):\n\n        ma_mean = tf.get_variable(\n                      'ma_mean',\n                      shape=shape,\n                      initializer=tf.zeros_initializer(),\n                      trainable=False)\n        ma_var = tf.get_variable(\n              'ma_variance',\n              shape=shape,\n              initializer=tf.ones_initializer(),\n              trainable=False)\n\n        if update:\n\n            tensor_mean,tensor_var = tf.nn.moments(tensor,axis)\n            mean = tf.assign(ma_mean,ma_mean*decay + (1-decay)*tensor_mean)\n            var = tf.assign(ma_var,ma_var*decay + (1-decay)*tensor_var)\n\n            with tf.control_dependencies([mean, var]):\n                return tf.rsqrt(var+epsilon)*(tensor-mean)\n        else:\n\n            return tf.rsqrt(ma_var+epsilon)*(tensor-ma_mean)\n\n# random frame with scale and bias\nxdata = np.random.randn(16394,2)*np.array([10,20]) + np.array([-5,5])\nbatch = tf.constant(xdata,dtype=tf.float32)\n\n# normalize the input batch with its moments,\nxmean,xvar = tf.nn.moments(batch,axes=[0])\nxnorm = tf.rsqrt(xvar)*(batch-xmean)\nmoments_x = tf.nn.moments(xnorm,axes=[0])\n\n# create normalizer in update mode\ny = normalizer(batch,shape=[2],axis=[0],decay = .99,update=True)\nmoments_y = tf.nn.moments(y,axes=[0])\n# create in test mode\ny_test = normalizer(batch,shape=[2],axis=[0],decay = .99,update=False)\nmoments_test = tf.nn.moments(y_test,axes=[0])\n\nwith tf.Session() as sess:\n    sess.run(tf.group(tf.global_variables_initializer(),tf.local_variables_initializer()))\n\n    print('\\nRun input moments for 10 steps for sanity check,every step should be identical...\\n')\n    for _ in range(10):\n        mean,var = sess.run(moments_x)\n        print(mean,var)\n    print('\\nRun update for 20 steps...\\n')\n    for _ in range(20):\n        mean,var = sess.run(moments_y)\n        print(mean,var)\n    print('\\nRun test for 20 steps, every step should be identical...\\n')\n    for _ in range(20):\n        mean,var = sess.run(moments_test)\n        print(mean,var)\n</code></pre>\n<p>Here is a print out that I get from running this script:</p>\n<pre><code>Run input moments for 10 steps for sanity check,every step should be identical...\n\n[ -8.81308182e-09  -2.29443700e-08] [ 1.00000048  1.00000143]\n[ -8.81308182e-09  -2.29443700e-08] [ 1.00000048  1.00000143]\n[ -8.81308182e-09  -2.29443700e-08] [ 1.00000048  1.00000143]\n[ -8.81308182e-09  -2.29443700e-08] [ 1.00000048  1.00000143]\n[ -8.81308182e-09  -2.29443700e-08] [ 1.00000048  1.00000143]\n[ -8.81308182e-09  -2.29443700e-08] [ 1.00000048  1.00000143]\n[ -8.81308182e-09  -2.29443700e-08] [ 1.00000048  1.00000143]\n[ -8.81308182e-09  -2.29443700e-08] [ 1.00000048  1.00000143]\n[ -8.81308182e-09  -2.29443700e-08] [ 1.00000048  1.00000143]\n[ -8.81308182e-09  -2.29443700e-08] [ 1.00000048  1.00000143]\n\nRun update for 20 steps...\n\n[-3.51247048  2.21043849] [ 50.22803497  80.21085358]\n[-2.84657669  1.6346755 ] [ 33.65858841  44.75781631]\n[-2.44675541  1.34974301] [ 25.37238884  31.13418961]\n[-2.17202067  1.17136073] [ 20.40036011  23.92469788]\n[-1.96787024  1.04593885] [ 17.08568954  19.46290207]\n[-1.80818331  0.95137215] [ 14.71818542  16.4295311 ]\n[-1.67866027  0.876652  ] [ 12.94268036  14.2333889 ]\n[-1.57072532  0.81559616] [ 11.56188488  12.56995583]\n[-1.47887969  0.76442826] [ 10.45738792  11.26643467]\n[-1.3994118   0.72069311] [  9.55385685  10.21746349]\n[-1.32971382  0.68271512] [ 8.80101871  9.35515976]\n[-1.26789105  0.64930677] [ 8.16414165  8.63379192]\n[-1.21253002  0.6195991 ] [ 7.61835909  8.02145481]\n[-1.16255021  0.59293979] [ 7.14544487  7.4951849 ]\n[-1.11711097  0.56882787] [ 6.73175192  7.03804827]\n[-1.07554555  0.5468713 ] [ 6.3668232   6.63729095]\n[-1.03731847  0.52675873] [ 6.04253292  6.2830925 ]\n[-1.00199318  0.50823855] [ 5.75246429  5.96780682]\n[-0.96920985  0.49110541] [ 5.49148464  5.68536663]\n[-0.93866938  0.47518966] [ 5.25543642  5.43090725]\n\nRun test for 20 steps, every step should be identical...\n\n[-0.93866932  0.47518966] [ 5.25543785  5.43090677]\n[-0.93866938  0.47518966] [ 5.2554369   5.43090773]\n[-0.93866938  0.47518966] [ 5.25543928  5.43090773]\n[-0.93866938  0.47518963] [ 5.25543547  5.43090773]\n[-0.93866938  0.47518966] [ 5.25543976  5.43090773]\n[-0.93866938  0.47518963] [ 5.25543642  5.43090725]\n[-0.93866938  0.47518966] [ 5.25543976  5.43090582]\n[-0.93866938  0.47518966] [ 5.2554388   5.43090677]\n[-0.93866932  0.47518966] [ 5.25543737  5.43090725]\n[-0.93866938  0.47518966] [ 5.25543642  5.43090677]\n[-0.93866938  0.47518963] [ 5.2554388   5.43090725]\n[-0.93866932  0.47518963] [ 5.25543642  5.43090773]\n[-0.93866938  0.47518966] [ 5.25543928  5.43090677]\n[-0.93866932  0.47518966] [ 5.25543737  5.43090725]\n[-0.93866932  0.47518966] [ 5.2554388   5.43090582]\n[-0.93866938  0.47518963] [ 5.25543642  5.4309082 ]\n[-0.93866932  0.47518966] [ 5.25543737  5.43090582]\n[-0.93866938  0.47518966] [ 5.25543594  5.43090725]\n[-0.93866932  0.47518966] [ 5.2554369   5.43090677]\n[-0.93866938  0.47518963] [ 5.25543547  5.43090677]\n</code></pre>\n<h3>What other attempted solutions have you tried?</h3>\n<p>I've tried many variants of this but without any difference.  This is a stripped down example.</p>\n<h3>Logs or other output that would be helpful</h3>\n<p>(If logs are large, please upload as attachment or provide link).</p>", "body_text": "I'm getting small variations in the result of running the same op repeatedly on what should be the same data for every sess.run().\nThe included script demonstrates the issue.  Similar to batch norm, the function normalizer() maintains moving averages of the mean and var of the input tensor, but only updates those values when 'update=True'.  Whether True of False, the function returns the input tensor scaled and centered by the current moving average statistics.\nIn this example, I first normalize the input by its moments, and print out the new moments, only to validate that I get the same result every time, since the input is a constant.\nNext, I compute the moments of the output repeatedly when normalizer() is configured with update =True, so I can see the moments converging as expected towards their final state, but stop after only 20 steps.\nThese first two steps behave as expected.\nLastly, I compute the moments of the same output tensor repeatedly when normalizer() is configured with update=False. In this case, the moving averages shouldn't be updating so I expect to see the same moment values at every step. This is almost true, but there is a small amount noise that I wouldn't expect. Is this a tensorflow bug?\nWhat related GitHub issues or StackOverflow threads have you found by searching the web for your problem?\nNone\nEnvironment info\nOperating System: Ubuntu 16.04\nInstalled version of CUDA and cuDNN:\n-rw-r--r-- 1 root   root    556000 Jan 26 18:48 /usr/local/cuda/lib64/libcudadevrt.a\nlrwxrwxrwx 1 root   root        16 Jan 26 18:51 /usr/local/cuda/lib64/libcudart.so -> libcudart.so.8.0\nlrwxrwxrwx 1 root   root        19 Jan 26 18:51 /usr/local/cuda/lib64/libcudart.so.8.0 -> libcudart.so.8.0.61\n-rw-r--r-- 1 root   root    415432 Jan 26 18:48 /usr/local/cuda/lib64/libcudart.so.8.0.61\n-rw-r--r-- 1 root   root    775162 Jan 26 18:48 /usr/local/cuda/lib64/libcudart_static.a\nlrwxrwxrwx 1 bmages users       13 Jul 27  2016 /usr/local/cuda/lib64/libcudnn.so -> libcudnn.so.5\nlrwxrwxrwx 1 bmages users       17 Jul 27  2016 /usr/local/cuda/lib64/libcudnn.so.5 -> libcudnn.so.5.1.5\n-rwxrwxr-x 1 bmages users 79337624 Jul 27  2016 /usr/local/cuda/lib64/libcudnn.so.5.1.5\n-rw-rw-r-- 1 bmages users 69756172 Jul 27  2016 /usr/local/cuda/lib64/libcudnn_static.a\nTensorflow 1.0.0\nCode\n\nimport numpy as np\nimport tensorflow as tf\ndef normalizer(tensor,shape,axis=[0],decay = .999,update=True,\n                          epsilon = 1e-10,scope='normalizer' ):\n\n    with tf.variable_scope(scope,reuse=not(update)):\n\n        ma_mean = tf.get_variable(\n                      'ma_mean',\n                      shape=shape,\n                      initializer=tf.zeros_initializer(),\n                      trainable=False)\n        ma_var = tf.get_variable(\n              'ma_variance',\n              shape=shape,\n              initializer=tf.ones_initializer(),\n              trainable=False)\n\n        if update:\n\n            tensor_mean,tensor_var = tf.nn.moments(tensor,axis)\n            mean = tf.assign(ma_mean,ma_mean*decay + (1-decay)*tensor_mean)\n            var = tf.assign(ma_var,ma_var*decay + (1-decay)*tensor_var)\n\n            with tf.control_dependencies([mean, var]):\n                return tf.rsqrt(var+epsilon)*(tensor-mean)\n        else:\n\n            return tf.rsqrt(ma_var+epsilon)*(tensor-ma_mean)\n\n# random frame with scale and bias\nxdata = np.random.randn(16394,2)*np.array([10,20]) + np.array([-5,5])\nbatch = tf.constant(xdata,dtype=tf.float32)\n\n# normalize the input batch with its moments,\nxmean,xvar = tf.nn.moments(batch,axes=[0])\nxnorm = tf.rsqrt(xvar)*(batch-xmean)\nmoments_x = tf.nn.moments(xnorm,axes=[0])\n\n# create normalizer in update mode\ny = normalizer(batch,shape=[2],axis=[0],decay = .99,update=True)\nmoments_y = tf.nn.moments(y,axes=[0])\n# create in test mode\ny_test = normalizer(batch,shape=[2],axis=[0],decay = .99,update=False)\nmoments_test = tf.nn.moments(y_test,axes=[0])\n\nwith tf.Session() as sess:\n    sess.run(tf.group(tf.global_variables_initializer(),tf.local_variables_initializer()))\n\n    print('\\nRun input moments for 10 steps for sanity check,every step should be identical...\\n')\n    for _ in range(10):\n        mean,var = sess.run(moments_x)\n        print(mean,var)\n    print('\\nRun update for 20 steps...\\n')\n    for _ in range(20):\n        mean,var = sess.run(moments_y)\n        print(mean,var)\n    print('\\nRun test for 20 steps, every step should be identical...\\n')\n    for _ in range(20):\n        mean,var = sess.run(moments_test)\n        print(mean,var)\n\nHere is a print out that I get from running this script:\nRun input moments for 10 steps for sanity check,every step should be identical...\n\n[ -8.81308182e-09  -2.29443700e-08] [ 1.00000048  1.00000143]\n[ -8.81308182e-09  -2.29443700e-08] [ 1.00000048  1.00000143]\n[ -8.81308182e-09  -2.29443700e-08] [ 1.00000048  1.00000143]\n[ -8.81308182e-09  -2.29443700e-08] [ 1.00000048  1.00000143]\n[ -8.81308182e-09  -2.29443700e-08] [ 1.00000048  1.00000143]\n[ -8.81308182e-09  -2.29443700e-08] [ 1.00000048  1.00000143]\n[ -8.81308182e-09  -2.29443700e-08] [ 1.00000048  1.00000143]\n[ -8.81308182e-09  -2.29443700e-08] [ 1.00000048  1.00000143]\n[ -8.81308182e-09  -2.29443700e-08] [ 1.00000048  1.00000143]\n[ -8.81308182e-09  -2.29443700e-08] [ 1.00000048  1.00000143]\n\nRun update for 20 steps...\n\n[-3.51247048  2.21043849] [ 50.22803497  80.21085358]\n[-2.84657669  1.6346755 ] [ 33.65858841  44.75781631]\n[-2.44675541  1.34974301] [ 25.37238884  31.13418961]\n[-2.17202067  1.17136073] [ 20.40036011  23.92469788]\n[-1.96787024  1.04593885] [ 17.08568954  19.46290207]\n[-1.80818331  0.95137215] [ 14.71818542  16.4295311 ]\n[-1.67866027  0.876652  ] [ 12.94268036  14.2333889 ]\n[-1.57072532  0.81559616] [ 11.56188488  12.56995583]\n[-1.47887969  0.76442826] [ 10.45738792  11.26643467]\n[-1.3994118   0.72069311] [  9.55385685  10.21746349]\n[-1.32971382  0.68271512] [ 8.80101871  9.35515976]\n[-1.26789105  0.64930677] [ 8.16414165  8.63379192]\n[-1.21253002  0.6195991 ] [ 7.61835909  8.02145481]\n[-1.16255021  0.59293979] [ 7.14544487  7.4951849 ]\n[-1.11711097  0.56882787] [ 6.73175192  7.03804827]\n[-1.07554555  0.5468713 ] [ 6.3668232   6.63729095]\n[-1.03731847  0.52675873] [ 6.04253292  6.2830925 ]\n[-1.00199318  0.50823855] [ 5.75246429  5.96780682]\n[-0.96920985  0.49110541] [ 5.49148464  5.68536663]\n[-0.93866938  0.47518966] [ 5.25543642  5.43090725]\n\nRun test for 20 steps, every step should be identical...\n\n[-0.93866932  0.47518966] [ 5.25543785  5.43090677]\n[-0.93866938  0.47518966] [ 5.2554369   5.43090773]\n[-0.93866938  0.47518966] [ 5.25543928  5.43090773]\n[-0.93866938  0.47518963] [ 5.25543547  5.43090773]\n[-0.93866938  0.47518966] [ 5.25543976  5.43090773]\n[-0.93866938  0.47518963] [ 5.25543642  5.43090725]\n[-0.93866938  0.47518966] [ 5.25543976  5.43090582]\n[-0.93866938  0.47518966] [ 5.2554388   5.43090677]\n[-0.93866932  0.47518966] [ 5.25543737  5.43090725]\n[-0.93866938  0.47518966] [ 5.25543642  5.43090677]\n[-0.93866938  0.47518963] [ 5.2554388   5.43090725]\n[-0.93866932  0.47518963] [ 5.25543642  5.43090773]\n[-0.93866938  0.47518966] [ 5.25543928  5.43090677]\n[-0.93866932  0.47518966] [ 5.25543737  5.43090725]\n[-0.93866932  0.47518966] [ 5.2554388   5.43090582]\n[-0.93866938  0.47518963] [ 5.25543642  5.4309082 ]\n[-0.93866932  0.47518966] [ 5.25543737  5.43090582]\n[-0.93866938  0.47518966] [ 5.25543594  5.43090725]\n[-0.93866932  0.47518966] [ 5.2554369   5.43090677]\n[-0.93866938  0.47518963] [ 5.25543547  5.43090677]\n\nWhat other attempted solutions have you tried?\nI've tried many variants of this but without any difference.  This is a stripped down example.\nLogs or other output that would be helpful\n(If logs are large, please upload as attachment or provide link).", "body": "I'm getting small variations in the result of running the same op repeatedly on what should be the same data for every sess.run().  \r\n\r\nThe included script demonstrates the issue.  Similar to batch norm, the function normalizer() maintains moving averages of the mean and var of the input tensor, but only updates those values when 'update=True'.  Whether True of False, the function returns the input tensor scaled and centered by the current moving average statistics. \r\n\r\nIn this example, I first normalize the input by its moments, and print out the new moments, only to validate that I get the same result every time, since the input is a constant.\r\n\r\nNext, I compute the moments of the output repeatedly when normalizer() is configured with update =True, so I can see the moments converging as expected towards their final state, but stop after only 20 steps.\r\n\r\nThese first two steps behave as expected.\r\n\r\nLastly, I compute the moments of the same output tensor repeatedly when normalizer() is configured with update=False. In this case, the moving averages shouldn't be updating so I expect to see the same moment values at every step. This is almost true, but there is a small amount noise that I wouldn't expect. Is this a tensorflow bug? \r\n\r\n### What related GitHub issues or StackOverflow threads have you found by searching the web for your problem? \r\n\r\nNone\r\n\r\n### Environment info\r\nOperating System: Ubuntu 16.04\r\n\r\nInstalled version of CUDA and cuDNN: \r\n-rw-r--r-- 1 root   root    556000 Jan 26 18:48 /usr/local/cuda/lib64/libcudadevrt.a\r\nlrwxrwxrwx 1 root   root        16 Jan 26 18:51 /usr/local/cuda/lib64/libcudart.so -> libcudart.so.8.0\r\nlrwxrwxrwx 1 root   root        19 Jan 26 18:51 /usr/local/cuda/lib64/libcudart.so.8.0 -> libcudart.so.8.0.61\r\n-rw-r--r-- 1 root   root    415432 Jan 26 18:48 /usr/local/cuda/lib64/libcudart.so.8.0.61\r\n-rw-r--r-- 1 root   root    775162 Jan 26 18:48 /usr/local/cuda/lib64/libcudart_static.a\r\nlrwxrwxrwx 1 bmages users       13 Jul 27  2016 /usr/local/cuda/lib64/libcudnn.so -> libcudnn.so.5\r\nlrwxrwxrwx 1 bmages users       17 Jul 27  2016 /usr/local/cuda/lib64/libcudnn.so.5 -> libcudnn.so.5.1.5\r\n-rwxrwxr-x 1 bmages users 79337624 Jul 27  2016 /usr/local/cuda/lib64/libcudnn.so.5.1.5\r\n-rw-rw-r-- 1 bmages users 69756172 Jul 27  2016 /usr/local/cuda/lib64/libcudnn_static.a\r\n\r\nTensorflow 1.0.0\r\n\r\n### Code\r\n\r\n```\r\n\r\nimport numpy as np\r\nimport tensorflow as tf\r\ndef normalizer(tensor,shape,axis=[0],decay = .999,update=True,\r\n                          epsilon = 1e-10,scope='normalizer' ):\r\n\r\n    with tf.variable_scope(scope,reuse=not(update)):\r\n\r\n        ma_mean = tf.get_variable(\r\n                      'ma_mean',\r\n                      shape=shape,\r\n                      initializer=tf.zeros_initializer(),\r\n                      trainable=False)\r\n        ma_var = tf.get_variable(\r\n              'ma_variance',\r\n              shape=shape,\r\n              initializer=tf.ones_initializer(),\r\n              trainable=False)\r\n\r\n        if update:\r\n\r\n            tensor_mean,tensor_var = tf.nn.moments(tensor,axis)\r\n            mean = tf.assign(ma_mean,ma_mean*decay + (1-decay)*tensor_mean)\r\n            var = tf.assign(ma_var,ma_var*decay + (1-decay)*tensor_var)\r\n\r\n            with tf.control_dependencies([mean, var]):\r\n                return tf.rsqrt(var+epsilon)*(tensor-mean)\r\n        else:\r\n\r\n            return tf.rsqrt(ma_var+epsilon)*(tensor-ma_mean)\r\n\r\n# random frame with scale and bias\r\nxdata = np.random.randn(16394,2)*np.array([10,20]) + np.array([-5,5])\r\nbatch = tf.constant(xdata,dtype=tf.float32)\r\n\r\n# normalize the input batch with its moments,\r\nxmean,xvar = tf.nn.moments(batch,axes=[0])\r\nxnorm = tf.rsqrt(xvar)*(batch-xmean)\r\nmoments_x = tf.nn.moments(xnorm,axes=[0])\r\n\r\n# create normalizer in update mode\r\ny = normalizer(batch,shape=[2],axis=[0],decay = .99,update=True)\r\nmoments_y = tf.nn.moments(y,axes=[0])\r\n# create in test mode\r\ny_test = normalizer(batch,shape=[2],axis=[0],decay = .99,update=False)\r\nmoments_test = tf.nn.moments(y_test,axes=[0])\r\n\r\nwith tf.Session() as sess:\r\n    sess.run(tf.group(tf.global_variables_initializer(),tf.local_variables_initializer()))\r\n\r\n    print('\\nRun input moments for 10 steps for sanity check,every step should be identical...\\n')\r\n    for _ in range(10):\r\n        mean,var = sess.run(moments_x)\r\n        print(mean,var)\r\n    print('\\nRun update for 20 steps...\\n')\r\n    for _ in range(20):\r\n        mean,var = sess.run(moments_y)\r\n        print(mean,var)\r\n    print('\\nRun test for 20 steps, every step should be identical...\\n')\r\n    for _ in range(20):\r\n        mean,var = sess.run(moments_test)\r\n        print(mean,var)\r\n```\r\nHere is a print out that I get from running this script:\r\n```\r\nRun input moments for 10 steps for sanity check,every step should be identical...\r\n\r\n[ -8.81308182e-09  -2.29443700e-08] [ 1.00000048  1.00000143]\r\n[ -8.81308182e-09  -2.29443700e-08] [ 1.00000048  1.00000143]\r\n[ -8.81308182e-09  -2.29443700e-08] [ 1.00000048  1.00000143]\r\n[ -8.81308182e-09  -2.29443700e-08] [ 1.00000048  1.00000143]\r\n[ -8.81308182e-09  -2.29443700e-08] [ 1.00000048  1.00000143]\r\n[ -8.81308182e-09  -2.29443700e-08] [ 1.00000048  1.00000143]\r\n[ -8.81308182e-09  -2.29443700e-08] [ 1.00000048  1.00000143]\r\n[ -8.81308182e-09  -2.29443700e-08] [ 1.00000048  1.00000143]\r\n[ -8.81308182e-09  -2.29443700e-08] [ 1.00000048  1.00000143]\r\n[ -8.81308182e-09  -2.29443700e-08] [ 1.00000048  1.00000143]\r\n\r\nRun update for 20 steps...\r\n\r\n[-3.51247048  2.21043849] [ 50.22803497  80.21085358]\r\n[-2.84657669  1.6346755 ] [ 33.65858841  44.75781631]\r\n[-2.44675541  1.34974301] [ 25.37238884  31.13418961]\r\n[-2.17202067  1.17136073] [ 20.40036011  23.92469788]\r\n[-1.96787024  1.04593885] [ 17.08568954  19.46290207]\r\n[-1.80818331  0.95137215] [ 14.71818542  16.4295311 ]\r\n[-1.67866027  0.876652  ] [ 12.94268036  14.2333889 ]\r\n[-1.57072532  0.81559616] [ 11.56188488  12.56995583]\r\n[-1.47887969  0.76442826] [ 10.45738792  11.26643467]\r\n[-1.3994118   0.72069311] [  9.55385685  10.21746349]\r\n[-1.32971382  0.68271512] [ 8.80101871  9.35515976]\r\n[-1.26789105  0.64930677] [ 8.16414165  8.63379192]\r\n[-1.21253002  0.6195991 ] [ 7.61835909  8.02145481]\r\n[-1.16255021  0.59293979] [ 7.14544487  7.4951849 ]\r\n[-1.11711097  0.56882787] [ 6.73175192  7.03804827]\r\n[-1.07554555  0.5468713 ] [ 6.3668232   6.63729095]\r\n[-1.03731847  0.52675873] [ 6.04253292  6.2830925 ]\r\n[-1.00199318  0.50823855] [ 5.75246429  5.96780682]\r\n[-0.96920985  0.49110541] [ 5.49148464  5.68536663]\r\n[-0.93866938  0.47518966] [ 5.25543642  5.43090725]\r\n\r\nRun test for 20 steps, every step should be identical...\r\n\r\n[-0.93866932  0.47518966] [ 5.25543785  5.43090677]\r\n[-0.93866938  0.47518966] [ 5.2554369   5.43090773]\r\n[-0.93866938  0.47518966] [ 5.25543928  5.43090773]\r\n[-0.93866938  0.47518963] [ 5.25543547  5.43090773]\r\n[-0.93866938  0.47518966] [ 5.25543976  5.43090773]\r\n[-0.93866938  0.47518963] [ 5.25543642  5.43090725]\r\n[-0.93866938  0.47518966] [ 5.25543976  5.43090582]\r\n[-0.93866938  0.47518966] [ 5.2554388   5.43090677]\r\n[-0.93866932  0.47518966] [ 5.25543737  5.43090725]\r\n[-0.93866938  0.47518966] [ 5.25543642  5.43090677]\r\n[-0.93866938  0.47518963] [ 5.2554388   5.43090725]\r\n[-0.93866932  0.47518963] [ 5.25543642  5.43090773]\r\n[-0.93866938  0.47518966] [ 5.25543928  5.43090677]\r\n[-0.93866932  0.47518966] [ 5.25543737  5.43090725]\r\n[-0.93866932  0.47518966] [ 5.2554388   5.43090582]\r\n[-0.93866938  0.47518963] [ 5.25543642  5.4309082 ]\r\n[-0.93866932  0.47518966] [ 5.25543737  5.43090582]\r\n[-0.93866938  0.47518966] [ 5.25543594  5.43090725]\r\n[-0.93866932  0.47518966] [ 5.2554369   5.43090677]\r\n[-0.93866938  0.47518963] [ 5.25543547  5.43090677]\r\n```\r\n### What other attempted solutions have you tried?\r\nI've tried many variants of this but without any difference.  This is a stripped down example.\r\n\r\n### Logs or other output that would be helpful\r\n(If logs are large, please upload as attachment or provide link).\r\n"}