{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/397792339", "html_url": "https://github.com/tensorflow/tensorflow/issues/20072#issuecomment-397792339", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/20072", "id": 397792339, "node_id": "MDEyOklzc3VlQ29tbWVudDM5Nzc5MjMzOQ==", "user": {"login": "frankzhangrui", "id": 8742978, "node_id": "MDQ6VXNlcjg3NDI5Nzg=", "avatar_url": "https://avatars0.githubusercontent.com/u/8742978?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frankzhangrui", "html_url": "https://github.com/frankzhangrui", "followers_url": "https://api.github.com/users/frankzhangrui/followers", "following_url": "https://api.github.com/users/frankzhangrui/following{/other_user}", "gists_url": "https://api.github.com/users/frankzhangrui/gists{/gist_id}", "starred_url": "https://api.github.com/users/frankzhangrui/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frankzhangrui/subscriptions", "organizations_url": "https://api.github.com/users/frankzhangrui/orgs", "repos_url": "https://api.github.com/users/frankzhangrui/repos", "events_url": "https://api.github.com/users/frankzhangrui/events{/privacy}", "received_events_url": "https://api.github.com/users/frankzhangrui/received_events", "type": "User", "site_admin": false}, "created_at": "2018-06-16T06:57:48Z", "updated_at": "2018-06-16T06:59:59Z", "author_association": "NONE", "body_html": "<p>I somehow got around this issue with a hacky way like<br>\nval savedModelBundle: SavedModelBundle = SavedModelBundle.load(some_local_model_path, \"serve\")<br>\nval isFullyLoaded: Boolean =<br>\nsavedModelBundle<br>\n.graph<br>\n.operations<br>\n.asScala<br>\n.map(_.name())<br>\n.filter(x =&gt; x.contains(some_node_defined_in_python))<br>\n.map(<br>\nop =&gt; Try(savedModelBundle.session.runner.fetch(op).runAndFetchMetadata)<br>\n)<br>\n.forall(p =&gt; p.isReturn)</p>\n<p>So for the models I tried, if the local model is incomplete, isFullyLoaded = false. If the model on disk is correct, isFullyLoaded = true. Not sure if this is the correct way to test though.</p>", "body_text": "I somehow got around this issue with a hacky way like\nval savedModelBundle: SavedModelBundle = SavedModelBundle.load(some_local_model_path, \"serve\")\nval isFullyLoaded: Boolean =\nsavedModelBundle\n.graph\n.operations\n.asScala\n.map(_.name())\n.filter(x => x.contains(some_node_defined_in_python))\n.map(\nop => Try(savedModelBundle.session.runner.fetch(op).runAndFetchMetadata)\n)\n.forall(p => p.isReturn)\nSo for the models I tried, if the local model is incomplete, isFullyLoaded = false. If the model on disk is correct, isFullyLoaded = true. Not sure if this is the correct way to test though.", "body": "I somehow got around this issue with a hacky way like\r\nval savedModelBundle: SavedModelBundle = SavedModelBundle.load(some_local_model_path, \"serve\")\r\nval isFullyLoaded: Boolean =\r\n    savedModelBundle\r\n      .graph\r\n      .operations\r\n      .asScala\r\n      .map(_.name())\r\n      .filter(x => x.contains(some_node_defined_in_python))\r\n      .map(\r\n        op => Try(savedModelBundle.session.runner.fetch(op).runAndFetchMetadata)\r\n      )\r\n      .forall(p => p.isReturn)\r\n\r\nSo for the models I tried, if the local model is incomplete, isFullyLoaded = false. If the model on disk is correct, isFullyLoaded = true. Not sure if this is the correct way to test though."}