{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/141501552", "pull_request_review_id": 65725559, "id": 141501552, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE0MTUwMTU1Mg==", "diff_hunk": "@@ -28,89 +28,123 @@\n import java.util.HashMap;\n \n /**\n- * A typed multi-dimensional array.\n+ * A statically typed multi-dimensional array whose elements are of a type described by T.\n  *\n  * <p>Instances of a Tensor are <b>not</b> thread-safe.\n  *\n  * <p><b>WARNING:</b> Resources consumed by the Tensor object <b>must</b> be explicitly freed by\n  * invoking the {@link #close()} method when the object is no longer needed. For example, using a\n- * try-with-resources block like:\n+ * try-with-resources block:\n  *\n  * <pre>{@code\n- * try(Tensor t = Tensor.create(...)) {\n+ * try (Tensor t = Tensor.create(...)) {\n  *   doSomethingWith(t);\n  * }\n  * }</pre>\n  */\n-public final class Tensor implements AutoCloseable {\n+public final class Tensor<T> implements AutoCloseable {\n \n   /**\n-   * Create a Tensor from a Java object.\n+   * Creates a Tensor from a Java object.\n    *\n-   * <p>A Tensor is a multi-dimensional array of elements of a limited set of types ({@link\n-   * DataType}). Thus, not all Java objects can be converted to a Tensor. In particular, {@code obj}\n-   * must be either a primitive (float, double, int, long, boolean) or a multi-dimensional array of\n-   * one of those primitives. For example:\n+   * <p>A {@code Tensor} is a multi-dimensional array of elements of a limited set of types ({@link\n+   * types}), so not all Java objects can be converted to a {@code Tensor}. In particular, the\n+   * argument {@code obj} must be either a primitive (float, double, int, long, boolean, byte) or a\n+   * multi-dimensional array of one of those primitives. The argument {@code type} specifies how to\n+   * interpret the first argument as a TensorFlow type. For example:\n    *\n    * <pre>{@code\n    * // Valid: A 64-bit integer scalar.\n-   * Tensor s = Tensor.create(42L);\n+   * Tensor<Long> s = Tensor.create(42L, Long.class);\n    *\n    * // Valid: A 3x2 matrix of floats.\n    * float[][] matrix = new float[3][2];\n-   * Tensor m = Tensor.create(matrix);\n+   * Tensor<Float> m = Tensor.create(matrix, Float.class);\n    *\n    * // Invalid: Will throw an IllegalArgumentException as an arbitrary Object\n    * // does not fit into the TensorFlow type system.\n-   * Tensor o = Tensor.create(new Object());\n+   * Tensor<?> o = Tensor.create(new Object(), ...);\n    *\n    * // Invalid: Will throw an IllegalArgumentException since there are\n    * // a differing number of elements in each row of this 2-D array.\n    * int[][] twoD = new int[2][];\n    * twoD[0] = new int[1];\n    * twoD[1] = new int[2];\n-   * Tensor x = Tensor.create(twoD);\n+   * Tensor<Integer> x = Tensor.create(twoD, Integer.class);\n    * }</pre>\n    *\n-   * {@link DataType#STRING} typed Tensors are multi-dimensionary arrays of arbitrary byte sequences\n-   * and thus have {@code byte[]} and not {@code String}-valued elements. For example:\n+   * {@link types.String} typed Tensors are multi-dimensional arrays of arbitrary byte sequences, so\n+   * can be initialized from arrays of {@code byte[]} elements. For example:\n    *\n    * <pre>{@code\n-   * // Valid: A DataType.STRING tensor.\n-   * Tensor s = Tensor.create(new byte[]{1, 2, 3});\n+   * // Valid: A String tensor.\n+   * Tensor<String> s = Tensor.create(new byte[]{1, 2, 3}, String.class);", "path": "tensorflow/java/src/main/java/org/tensorflow/Tensor.java", "position": 71, "original_position": 71, "commit_id": "bf2c8b494abf6c330c87b3ba18e6644fc8c0b22d", "original_commit_id": "d594284af0ace286b153f1fd7c424731e3f65c2c", "user": {"login": "asimshankar", "id": 16018, "node_id": "MDQ6VXNlcjE2MDE4", "avatar_url": "https://avatars2.githubusercontent.com/u/16018?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asimshankar", "html_url": "https://github.com/asimshankar", "followers_url": "https://api.github.com/users/asimshankar/followers", "following_url": "https://api.github.com/users/asimshankar/following{/other_user}", "gists_url": "https://api.github.com/users/asimshankar/gists{/gist_id}", "starred_url": "https://api.github.com/users/asimshankar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asimshankar/subscriptions", "organizations_url": "https://api.github.com/users/asimshankar/orgs", "repos_url": "https://api.github.com/users/asimshankar/repos", "events_url": "https://api.github.com/users/asimshankar/events{/privacy}", "received_events_url": "https://api.github.com/users/asimshankar/received_events", "type": "User", "site_admin": false}, "body": "Taking a step back, I think we agree on wanting to make it convenient to convert Java `String`s into `Tensor`s. Mostly via methods in the (yet to come) `Tensors` class with factory functions.\r\n\r\nThe point of debate here is what these functions should return, i.e.:\r\n\r\n```java\r\npublic class Tensors {\r\n  public static Tensor<String> create(String value);  // UTF-8 encoded\r\n  public static Tensor<String> create(String value, Charset charset);\r\n  public static Tensor<String> create(byte[] value);\r\n}\r\n```\r\n\r\n*or*\r\n\r\n```java\r\npublic class Tensors {\r\n  public static Tensor<Bytes> create(String value);  // UTF-8 encoded\r\n  public static Tensor<Bytes> create(String value, Charset charset);\r\n  public static Tensor<Bytes> create(byte[] value);\r\n}\r\n```\r\n\r\nMy contention was that the latter is preferable. It makes it clear that the element type of the tensor is a sequence of bytes, not a `String`. I feel that this is more accurate and if the developer blinks, it's because this is a distinction worth knowing about.  For example, [`tf.equal`](https://www.tensorflow.org/api_docs/python/tf/equal) on two scalar `Tensor<String>` objects will return `false` even if they are the same \"strings\" because the encoding use to create the `Tensor<String>` might have been different.\r\n\r\nPoint taken about the serialized protocol buffers and ISO-8859-1 encoding. But it seems to be more natural to represent the serialized buffer as a `byte[]` rather than a `String`, which is why presumably the [protocol buffer APIs use them](https://developers.google.com/protocol-buffers/docs/javatutorial#parsing-and-serialization).\r\n\r\nYou example on `tf.constant(\"filename.txt\")` remains equally convenient in both, no? It's just whether the returned value is a `Tensor<Bytes>` or a `Tensor<String>`.\r\n\r\nThoughts? :)", "created_at": "2017-09-28T00:36:57Z", "updated_at": "2017-09-28T14:09:48Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/11535#discussion_r141501552", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/11535", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/141501552"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/11535#discussion_r141501552"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/11535"}}, "body_html": "<p>Taking a step back, I think we agree on wanting to make it convenient to convert Java <code>String</code>s into <code>Tensor</code>s. Mostly via methods in the (yet to come) <code>Tensors</code> class with factory functions.</p>\n<p>The point of debate here is what these functions should return, i.e.:</p>\n<div class=\"highlight highlight-source-java\"><pre><span class=\"pl-k\">public</span> <span class=\"pl-k\">class</span> <span class=\"pl-en\">Tensors</span> {\n  <span class=\"pl-k\">public</span> <span class=\"pl-k\">static</span> <span class=\"pl-k\">Tensor&lt;<span class=\"pl-smi\">String</span>&gt;</span> <span class=\"pl-en\">create</span>(<span class=\"pl-smi\">String</span> <span class=\"pl-v\">value</span>);  <span class=\"pl-c\"><span class=\"pl-c\">//</span> UTF-8 encoded</span>\n  <span class=\"pl-k\">public</span> <span class=\"pl-k\">static</span> <span class=\"pl-k\">Tensor&lt;<span class=\"pl-smi\">String</span>&gt;</span> <span class=\"pl-en\">create</span>(<span class=\"pl-smi\">String</span> <span class=\"pl-v\">value</span>, <span class=\"pl-smi\">Charset</span> <span class=\"pl-v\">charset</span>);\n  <span class=\"pl-k\">public</span> <span class=\"pl-k\">static</span> <span class=\"pl-k\">Tensor&lt;<span class=\"pl-smi\">String</span>&gt;</span> <span class=\"pl-en\">create</span>(<span class=\"pl-k\">byte</span>[] <span class=\"pl-v\">value</span>);\n}</pre></div>\n<p><em>or</em></p>\n<div class=\"highlight highlight-source-java\"><pre><span class=\"pl-k\">public</span> <span class=\"pl-k\">class</span> <span class=\"pl-en\">Tensors</span> {\n  <span class=\"pl-k\">public</span> <span class=\"pl-k\">static</span> <span class=\"pl-k\">Tensor&lt;<span class=\"pl-smi\">Bytes</span>&gt;</span> <span class=\"pl-en\">create</span>(<span class=\"pl-smi\">String</span> <span class=\"pl-v\">value</span>);  <span class=\"pl-c\"><span class=\"pl-c\">//</span> UTF-8 encoded</span>\n  <span class=\"pl-k\">public</span> <span class=\"pl-k\">static</span> <span class=\"pl-k\">Tensor&lt;<span class=\"pl-smi\">Bytes</span>&gt;</span> <span class=\"pl-en\">create</span>(<span class=\"pl-smi\">String</span> <span class=\"pl-v\">value</span>, <span class=\"pl-smi\">Charset</span> <span class=\"pl-v\">charset</span>);\n  <span class=\"pl-k\">public</span> <span class=\"pl-k\">static</span> <span class=\"pl-k\">Tensor&lt;<span class=\"pl-smi\">Bytes</span>&gt;</span> <span class=\"pl-en\">create</span>(<span class=\"pl-k\">byte</span>[] <span class=\"pl-v\">value</span>);\n}</pre></div>\n<p>My contention was that the latter is preferable. It makes it clear that the element type of the tensor is a sequence of bytes, not a <code>String</code>. I feel that this is more accurate and if the developer blinks, it's because this is a distinction worth knowing about.  For example, <a href=\"https://www.tensorflow.org/api_docs/python/tf/equal\" rel=\"nofollow\"><code>tf.equal</code></a> on two scalar <code>Tensor&lt;String&gt;</code> objects will return <code>false</code> even if they are the same \"strings\" because the encoding use to create the <code>Tensor&lt;String&gt;</code> might have been different.</p>\n<p>Point taken about the serialized protocol buffers and ISO-8859-1 encoding. But it seems to be more natural to represent the serialized buffer as a <code>byte[]</code> rather than a <code>String</code>, which is why presumably the <a href=\"https://developers.google.com/protocol-buffers/docs/javatutorial#parsing-and-serialization\" rel=\"nofollow\">protocol buffer APIs use them</a>.</p>\n<p>You example on <code>tf.constant(\"filename.txt\")</code> remains equally convenient in both, no? It's just whether the returned value is a <code>Tensor&lt;Bytes&gt;</code> or a <code>Tensor&lt;String&gt;</code>.</p>\n<p>Thoughts? :)</p>", "body_text": "Taking a step back, I think we agree on wanting to make it convenient to convert Java Strings into Tensors. Mostly via methods in the (yet to come) Tensors class with factory functions.\nThe point of debate here is what these functions should return, i.e.:\npublic class Tensors {\n  public static Tensor<String> create(String value);  // UTF-8 encoded\n  public static Tensor<String> create(String value, Charset charset);\n  public static Tensor<String> create(byte[] value);\n}\nor\npublic class Tensors {\n  public static Tensor<Bytes> create(String value);  // UTF-8 encoded\n  public static Tensor<Bytes> create(String value, Charset charset);\n  public static Tensor<Bytes> create(byte[] value);\n}\nMy contention was that the latter is preferable. It makes it clear that the element type of the tensor is a sequence of bytes, not a String. I feel that this is more accurate and if the developer blinks, it's because this is a distinction worth knowing about.  For example, tf.equal on two scalar Tensor<String> objects will return false even if they are the same \"strings\" because the encoding use to create the Tensor<String> might have been different.\nPoint taken about the serialized protocol buffers and ISO-8859-1 encoding. But it seems to be more natural to represent the serialized buffer as a byte[] rather than a String, which is why presumably the protocol buffer APIs use them.\nYou example on tf.constant(\"filename.txt\") remains equally convenient in both, no? It's just whether the returned value is a Tensor<Bytes> or a Tensor<String>.\nThoughts? :)", "in_reply_to_id": 140672501}