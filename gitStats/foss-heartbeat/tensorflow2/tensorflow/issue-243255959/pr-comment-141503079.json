{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/141503079", "pull_request_review_id": 65727073, "id": 141503079, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE0MTUwMzA3OQ==", "diff_hunk": "@@ -28,89 +28,123 @@\n import java.util.HashMap;\n \n /**\n- * A typed multi-dimensional array.\n+ * A statically typed multi-dimensional array whose elements are of a type described by T.\n  *\n  * <p>Instances of a Tensor are <b>not</b> thread-safe.\n  *\n  * <p><b>WARNING:</b> Resources consumed by the Tensor object <b>must</b> be explicitly freed by\n  * invoking the {@link #close()} method when the object is no longer needed. For example, using a\n- * try-with-resources block like:\n+ * try-with-resources block:\n  *\n  * <pre>{@code\n- * try(Tensor t = Tensor.create(...)) {\n+ * try (Tensor t = Tensor.create(...)) {\n  *   doSomethingWith(t);\n  * }\n  * }</pre>\n  */\n-public final class Tensor implements AutoCloseable {\n+public final class Tensor<T> implements AutoCloseable {\n \n   /**\n-   * Create a Tensor from a Java object.\n+   * Creates a Tensor from a Java object.\n    *\n-   * <p>A Tensor is a multi-dimensional array of elements of a limited set of types ({@link\n-   * DataType}). Thus, not all Java objects can be converted to a Tensor. In particular, {@code obj}\n-   * must be either a primitive (float, double, int, long, boolean) or a multi-dimensional array of\n-   * one of those primitives. For example:\n+   * <p>A {@code Tensor} is a multi-dimensional array of elements of a limited set of types ({@link\n+   * types}), so not all Java objects can be converted to a {@code Tensor}. In particular, the\n+   * argument {@code obj} must be either a primitive (float, double, int, long, boolean, byte) or a\n+   * multi-dimensional array of one of those primitives. The argument {@code type} specifies how to\n+   * interpret the first argument as a TensorFlow type. For example:\n    *\n    * <pre>{@code\n    * // Valid: A 64-bit integer scalar.\n-   * Tensor s = Tensor.create(42L);\n+   * Tensor<Long> s = Tensor.create(42L, Long.class);\n    *\n    * // Valid: A 3x2 matrix of floats.\n    * float[][] matrix = new float[3][2];\n-   * Tensor m = Tensor.create(matrix);\n+   * Tensor<Float> m = Tensor.create(matrix, Float.class);\n    *\n    * // Invalid: Will throw an IllegalArgumentException as an arbitrary Object\n    * // does not fit into the TensorFlow type system.\n-   * Tensor o = Tensor.create(new Object());\n+   * Tensor<?> o = Tensor.create(new Object(), ...);\n    *\n    * // Invalid: Will throw an IllegalArgumentException since there are\n    * // a differing number of elements in each row of this 2-D array.\n    * int[][] twoD = new int[2][];\n    * twoD[0] = new int[1];\n    * twoD[1] = new int[2];\n-   * Tensor x = Tensor.create(twoD);\n+   * Tensor<Integer> x = Tensor.create(twoD, Integer.class);\n    * }</pre>\n    *\n-   * {@link DataType#STRING} typed Tensors are multi-dimensionary arrays of arbitrary byte sequences\n-   * and thus have {@code byte[]} and not {@code String}-valued elements. For example:\n+   * {@link types.String} typed Tensors are multi-dimensional arrays of arbitrary byte sequences, so\n+   * can be initialized from arrays of {@code byte[]} elements. For example:\n    *\n    * <pre>{@code\n-   * // Valid: A DataType.STRING tensor.\n-   * Tensor s = Tensor.create(new byte[]{1, 2, 3});\n+   * // Valid: A String tensor.\n+   * Tensor<String> s = Tensor.create(new byte[]{1, 2, 3}, String.class);", "path": "tensorflow/java/src/main/java/org/tensorflow/Tensor.java", "position": 71, "original_position": 71, "commit_id": "bf2c8b494abf6c330c87b3ba18e6644fc8c0b22d", "original_commit_id": "d594284af0ace286b153f1fd7c424731e3f65c2c", "user": {"login": "andrewcmyers", "id": 4623813, "node_id": "MDQ6VXNlcjQ2MjM4MTM=", "avatar_url": "https://avatars1.githubusercontent.com/u/4623813?v=4", "gravatar_id": "", "url": "https://api.github.com/users/andrewcmyers", "html_url": "https://github.com/andrewcmyers", "followers_url": "https://api.github.com/users/andrewcmyers/followers", "following_url": "https://api.github.com/users/andrewcmyers/following{/other_user}", "gists_url": "https://api.github.com/users/andrewcmyers/gists{/gist_id}", "starred_url": "https://api.github.com/users/andrewcmyers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/andrewcmyers/subscriptions", "organizations_url": "https://api.github.com/users/andrewcmyers/orgs", "repos_url": "https://api.github.com/users/andrewcmyers/repos", "events_url": "https://api.github.com/users/andrewcmyers/events{/privacy}", "received_events_url": "https://api.github.com/users/andrewcmyers/received_events", "type": "User", "site_admin": false}, "body": "You're absolutely right, we can offer exactly the same API whether we call it `Tensor<String>` or `Tensor<Bytes>`. And I think we agree about what that API should look like modulo this choice. If we go the second route, I would prefer to call it `Tensor<TFString>` rather than `Tensor<Bytes>` because 1) that makes the correspondence to the other language APIs (e.g., `tf.string`) more direct and obvious, 2) it communicates that this is the way you solve the common problem of putting strings into tensors, and 3) still adds the developer eye-blink you're after.\r\n\r\nPersonally, I think that people will, in the odd case that it matters, still make the same silly encoding/decoding mistakes regardless of what we call the type parameter, so I feel the familiarity of `String` is more valuable than the warning conveyed by the unexpected names `Bytes`/`TFString`.", "created_at": "2017-09-28T00:49:52Z", "updated_at": "2017-09-28T14:09:48Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/11535#discussion_r141503079", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/11535", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/141503079"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/11535#discussion_r141503079"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/11535"}}, "body_html": "<p>You're absolutely right, we can offer exactly the same API whether we call it <code>Tensor&lt;String&gt;</code> or <code>Tensor&lt;Bytes&gt;</code>. And I think we agree about what that API should look like modulo this choice. If we go the second route, I would prefer to call it <code>Tensor&lt;TFString&gt;</code> rather than <code>Tensor&lt;Bytes&gt;</code> because 1) that makes the correspondence to the other language APIs (e.g., <code>tf.string</code>) more direct and obvious, 2) it communicates that this is the way you solve the common problem of putting strings into tensors, and 3) still adds the developer eye-blink you're after.</p>\n<p>Personally, I think that people will, in the odd case that it matters, still make the same silly encoding/decoding mistakes regardless of what we call the type parameter, so I feel the familiarity of <code>String</code> is more valuable than the warning conveyed by the unexpected names <code>Bytes</code>/<code>TFString</code>.</p>", "body_text": "You're absolutely right, we can offer exactly the same API whether we call it Tensor<String> or Tensor<Bytes>. And I think we agree about what that API should look like modulo this choice. If we go the second route, I would prefer to call it Tensor<TFString> rather than Tensor<Bytes> because 1) that makes the correspondence to the other language APIs (e.g., tf.string) more direct and obvious, 2) it communicates that this is the way you solve the common problem of putting strings into tensors, and 3) still adds the developer eye-blink you're after.\nPersonally, I think that people will, in the odd case that it matters, still make the same silly encoding/decoding mistakes regardless of what we call the type parameter, so I feel the familiarity of String is more valuable than the warning conveyed by the unexpected names Bytes/TFString.", "in_reply_to_id": 140672501}