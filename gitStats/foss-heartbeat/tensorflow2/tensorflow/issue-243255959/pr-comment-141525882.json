{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/141525882", "pull_request_review_id": 65750886, "id": 141525882, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE0MTUyNTg4Mg==", "diff_hunk": "@@ -28,89 +28,123 @@\n import java.util.HashMap;\n \n /**\n- * A typed multi-dimensional array.\n+ * A statically typed multi-dimensional array whose elements are of a type described by T.\n  *\n  * <p>Instances of a Tensor are <b>not</b> thread-safe.\n  *\n  * <p><b>WARNING:</b> Resources consumed by the Tensor object <b>must</b> be explicitly freed by\n  * invoking the {@link #close()} method when the object is no longer needed. For example, using a\n- * try-with-resources block like:\n+ * try-with-resources block:\n  *\n  * <pre>{@code\n- * try(Tensor t = Tensor.create(...)) {\n+ * try (Tensor t = Tensor.create(...)) {\n  *   doSomethingWith(t);\n  * }\n  * }</pre>\n  */\n-public final class Tensor implements AutoCloseable {\n+public final class Tensor<T> implements AutoCloseable {\n \n   /**\n-   * Create a Tensor from a Java object.\n+   * Creates a Tensor from a Java object.\n    *\n-   * <p>A Tensor is a multi-dimensional array of elements of a limited set of types ({@link\n-   * DataType}). Thus, not all Java objects can be converted to a Tensor. In particular, {@code obj}\n-   * must be either a primitive (float, double, int, long, boolean) or a multi-dimensional array of\n-   * one of those primitives. For example:\n+   * <p>A {@code Tensor} is a multi-dimensional array of elements of a limited set of types ({@link\n+   * types}), so not all Java objects can be converted to a {@code Tensor}. In particular, the\n+   * argument {@code obj} must be either a primitive (float, double, int, long, boolean, byte) or a\n+   * multi-dimensional array of one of those primitives. The argument {@code type} specifies how to\n+   * interpret the first argument as a TensorFlow type. For example:\n    *\n    * <pre>{@code\n    * // Valid: A 64-bit integer scalar.\n-   * Tensor s = Tensor.create(42L);\n+   * Tensor<Long> s = Tensor.create(42L, Long.class);\n    *\n    * // Valid: A 3x2 matrix of floats.\n    * float[][] matrix = new float[3][2];\n-   * Tensor m = Tensor.create(matrix);\n+   * Tensor<Float> m = Tensor.create(matrix, Float.class);\n    *\n    * // Invalid: Will throw an IllegalArgumentException as an arbitrary Object\n    * // does not fit into the TensorFlow type system.\n-   * Tensor o = Tensor.create(new Object());\n+   * Tensor<?> o = Tensor.create(new Object(), ...);\n    *\n    * // Invalid: Will throw an IllegalArgumentException since there are\n    * // a differing number of elements in each row of this 2-D array.\n    * int[][] twoD = new int[2][];\n    * twoD[0] = new int[1];\n    * twoD[1] = new int[2];\n-   * Tensor x = Tensor.create(twoD);\n+   * Tensor<Integer> x = Tensor.create(twoD, Integer.class);\n    * }</pre>\n    *\n-   * {@link DataType#STRING} typed Tensors are multi-dimensionary arrays of arbitrary byte sequences\n-   * and thus have {@code byte[]} and not {@code String}-valued elements. For example:\n+   * {@link types.String} typed Tensors are multi-dimensional arrays of arbitrary byte sequences, so\n+   * can be initialized from arrays of {@code byte[]} elements. For example:\n    *\n    * <pre>{@code\n-   * // Valid: A DataType.STRING tensor.\n-   * Tensor s = Tensor.create(new byte[]{1, 2, 3});\n+   * // Valid: A String tensor.\n+   * Tensor<String> s = Tensor.create(new byte[]{1, 2, 3}, String.class);", "path": "tensorflow/java/src/main/java/org/tensorflow/Tensor.java", "position": 71, "original_position": 71, "commit_id": "bf2c8b494abf6c330c87b3ba18e6644fc8c0b22d", "original_commit_id": "d594284af0ace286b153f1fd7c424731e3f65c2c", "user": {"login": "asimshankar", "id": 16018, "node_id": "MDQ6VXNlcjE2MDE4", "avatar_url": "https://avatars2.githubusercontent.com/u/16018?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asimshankar", "html_url": "https://github.com/asimshankar", "followers_url": "https://api.github.com/users/asimshankar/followers", "following_url": "https://api.github.com/users/asimshankar/following{/other_user}", "gists_url": "https://api.github.com/users/asimshankar/gists{/gist_id}", "starred_url": "https://api.github.com/users/asimshankar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asimshankar/subscriptions", "organizations_url": "https://api.github.com/users/asimshankar/orgs", "repos_url": "https://api.github.com/users/asimshankar/repos", "events_url": "https://api.github.com/users/asimshankar/events{/privacy}", "received_events_url": "https://api.github.com/users/asimshankar/received_events", "type": "User", "site_admin": false}, "body": "Let's agree to disagree here (regarding familiarity with `String`) :). My fear is that developers will _think_ they're comfortable with `String` and 95% of the time it will work out fine, but those 5% where it will differ from the other types (e.g., `Integer.equals()` and `tf.equals(Tensor<Integer>, Tensor<Integer>)` will be consistent, while `String.equals()` and `tf.equals(Tensor<String>, Tensor<String>)` will not) will be annoying.\r\n\r\nThat said, other than this `String` business we do agree and there is much to this PR and I'd like to get this in before 1.4 is cut, so let's proceed with the PR as is and we can consider changing `String` to `Bytes` or `TFString` in a follow up (I'll try to find some time to gather more opinions).\r\n\r\n", "created_at": "2017-09-28T04:50:55Z", "updated_at": "2017-09-28T14:09:48Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/11535#discussion_r141525882", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/11535", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/141525882"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/11535#discussion_r141525882"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/11535"}}, "body_html": "<p>Let's agree to disagree here (regarding familiarity with <code>String</code>) :). My fear is that developers will <em>think</em> they're comfortable with <code>String</code> and 95% of the time it will work out fine, but those 5% where it will differ from the other types (e.g., <code>Integer.equals()</code> and <code>tf.equals(Tensor&lt;Integer&gt;, Tensor&lt;Integer&gt;)</code> will be consistent, while <code>String.equals()</code> and <code>tf.equals(Tensor&lt;String&gt;, Tensor&lt;String&gt;)</code> will not) will be annoying.</p>\n<p>That said, other than this <code>String</code> business we do agree and there is much to this PR and I'd like to get this in before 1.4 is cut, so let's proceed with the PR as is and we can consider changing <code>String</code> to <code>Bytes</code> or <code>TFString</code> in a follow up (I'll try to find some time to gather more opinions).</p>", "body_text": "Let's agree to disagree here (regarding familiarity with String) :). My fear is that developers will think they're comfortable with String and 95% of the time it will work out fine, but those 5% where it will differ from the other types (e.g., Integer.equals() and tf.equals(Tensor<Integer>, Tensor<Integer>) will be consistent, while String.equals() and tf.equals(Tensor<String>, Tensor<String>) will not) will be annoying.\nThat said, other than this String business we do agree and there is much to this PR and I'd like to get this in before 1.4 is cut, so let's proceed with the PR as is and we can consider changing String to Bytes or TFString in a follow up (I'll try to find some time to gather more opinions).", "in_reply_to_id": 140672501}