{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/139070017", "pull_request_review_id": 62949450, "id": 139070017, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEzOTA3MDAxNw==", "diff_hunk": "@@ -26,89 +26,130 @@\n import java.nio.LongBuffer;\n import java.util.Arrays;\n import java.util.HashMap;\n+import org.tensorflow.types.TFDouble;\n+import org.tensorflow.types.TFFloat;\n+import org.tensorflow.types.TFInt32;\n+import org.tensorflow.types.TFInt64;\n+import org.tensorflow.types.TFType;\n+import org.tensorflow.types.Types;\n \n /**\n- * A typed multi-dimensional array.\n+ * A statically typed multi-dimensional array whose elements are of a type described by T.\n+ * Appropriate types T are declared in the package {@link org.tensorflow.types} and are subtypes of\n+ * {@link org.tensorflow.types.TFType}.\n  *\n  * <p>Instances of a Tensor are <b>not</b> thread-safe.\n  *\n  * <p><b>WARNING:</b> Resources consumed by the Tensor object <b>must</b> be explicitly freed by\n  * invoking the {@link #close()} method when the object is no longer needed. For example, using a\n- * try-with-resources block like:\n+ * try-with-resources block:\n  *\n  * <pre>{@code\n- * try(Tensor t = Tensor.create(...)) {\n+ * try (Tensor t = Tensor.create(...)) {\n  *   doSomethingWith(t);\n  * }\n  * }</pre>\n  */\n-public final class Tensor implements AutoCloseable {\n+public final class Tensor<T> implements AutoCloseable {\n \n   /**\n-   * Create a Tensor from a Java object.\n+   * Creates a Tensor from a Java object.\n    *\n-   * <p>A Tensor is a multi-dimensional array of elements of a limited set of types ({@link\n-   * DataType}). Thus, not all Java objects can be converted to a Tensor. In particular, {@code obj}\n-   * must be either a primitive (float, double, int, long, boolean) or a multi-dimensional array of\n-   * one of those primitives. For example:\n+   * <p>A {@code Tensor} is a multi-dimensional array of elements of a limited set of types ({@link\n+   * types}), so not all Java objects can be converted to a {@code Tensor}. In particular, the\n+   * argument {@code obj} must be either a primitive (float, double, int, long, boolean, byte) or a\n+   * multi-dimensional array of one of those primitives. The argument {@code type} specifies how to\n+   * interpret the first argument as a TensorFlow type. For example:\n    *\n    * <pre>{@code\n    * // Valid: A 64-bit integer scalar.\n-   * Tensor s = Tensor.create(42L);\n+   * Tensor<TFInt64> s = Tensor.create(42L, TFInt64.class);\n    *\n    * // Valid: A 3x2 matrix of floats.\n    * float[][] matrix = new float[3][2];\n-   * Tensor m = Tensor.create(matrix);\n+   * Tensor<TFFloat> m = Tensor.create(matrix, TFFloat.class);\n    *\n    * // Invalid: Will throw an IllegalArgumentException as an arbitrary Object\n    * // does not fit into the TensorFlow type system.\n-   * Tensor o = Tensor.create(new Object());\n+   * Tensor<?> o = Tensor.create(new Object(), ...);\n    *\n    * // Invalid: Will throw an IllegalArgumentException since there are\n    * // a differing number of elements in each row of this 2-D array.\n    * int[][] twoD = new int[2][];\n    * twoD[0] = new int[1];\n    * twoD[1] = new int[2];\n-   * Tensor x = Tensor.create(twoD);\n+   * Tensor<TFInt32> x = Tensor.create(twoD, TFInt32.class);\n    * }</pre>\n    *\n-   * {@link DataType#STRING} typed Tensors are multi-dimensionary arrays of arbitrary byte sequences\n-   * and thus have {@code byte[]} and not {@code String}-valued elements. For example:\n+   * {@link types.TFString} typed Tensors are multi-dimensional arrays of arbitrary byte sequences,\n+   * so can be initialized from arrays of {@code byte[]} elements. For example:\n    *\n    * <pre>{@code\n-   * // Valid: A DataType.STRING tensor.\n-   * Tensor s = Tensor.create(new byte[]{1, 2, 3});\n+   * // Valid: A TFString tensor.\n+   * Tensor<TFString> s = Tensor.create(new byte[]{1, 2, 3}, TFString.class);\n    *\n    * // Java Strings will need to be encoded into a byte-sequence.\n    * String mystring = \"foo\";\n-   * Tensor s = Tensor.create(mystring.getBytes(\"UTF-8\"));\n+   * Tensor<TFString> s = Tensor.create(mystring.getBytes(\"UTF-8\"), TFString.class);\n    *\n-   * // Valid: Matrix of DataType.STRING tensors.\n+   * // Valid: Matrix of TFString tensors.\n    * // Each element might have a different length.\n    * byte[][][] matrix = new byte[2][2][];\n    * matrix[0][0] = \"this\".getBytes(\"UTF-8\");\n    * matrix[0][1] = \"is\".getBytes(\"UTF-8\");\n    * matrix[1][0] = \"a\".getBytes(\"UTF-8\");\n    * matrix[1][1] = \"matrix\".getBytes(\"UTF-8\");\n-   * Tensor m = Tensor.create(matrix);\n+   * Tensor<TFString> m = Tensor.create(matrix, TFString.class);\n    * }</pre>\n    *\n+   * @param obj The object to convert to a Tensor<T>. Note that whether the it is compatible with\n+   *     the type T is not checked by the type system. For type-safe creation of tensors, use {@link\n+   *     op.Tensors}.\n+   * @param type The class object representing the type T.\n    * @throws IllegalArgumentException if {@code obj} is not compatible with the TensorFlow type\n-   *     system, or if obj does not disambiguate between multiple DataTypes. In that case, consider\n-   *     using {@link #create(DataType, long[], ByteBuffer)} instead.\n+   *     system.\n+   * @see org.tensorflow.op.Tensors\n    */\n-  public static Tensor create(Object obj) {\n-    return create(obj, dataTypeOf(obj));\n+  public static <T extends TFType> Tensor<T> create(Object obj, Class<T> type) {", "path": "tensorflow/java/src/main/java/org/tensorflow/Tensor.java", "position": null, "original_position": 112, "commit_id": "bf2c8b494abf6c330c87b3ba18e6644fc8c0b22d", "original_commit_id": "e424a03d18cd093b540789086ad3f2d328418682", "user": {"login": "asimshankar", "id": 16018, "node_id": "MDQ6VXNlcjE2MDE4", "avatar_url": "https://avatars2.githubusercontent.com/u/16018?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asimshankar", "html_url": "https://github.com/asimshankar", "followers_url": "https://api.github.com/users/asimshankar/followers", "following_url": "https://api.github.com/users/asimshankar/following{/other_user}", "gists_url": "https://api.github.com/users/asimshankar/gists{/gist_id}", "starred_url": "https://api.github.com/users/asimshankar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asimshankar/subscriptions", "organizations_url": "https://api.github.com/users/asimshankar/orgs", "repos_url": "https://api.github.com/users/asimshankar/repos", "events_url": "https://api.github.com/users/asimshankar/events{/privacy}", "received_events_url": "https://api.github.com/users/asimshankar/received_events", "type": "User", "site_admin": false}, "body": "IIUC, this is the factory function to use to get type-checking while the `create(Object)` one will generate runtime errors.\r\n\r\nThis distinction between when types are specified as `DataType` and when as `Class<T>` is a bit confusing, particularly since this `Tensor` class is providing factory functions for both. What do you think about the following:\r\n\r\n- `Tensor.java` will NOT provide compile-time type checking. All the methods do runtime checks and functions use the `DataType` enum for type information\r\n- All the \"type-safe\" construction is with methods in `Tensors.java`\r\n\r\nSubtle, but that way we perhaps more clearly layer the use of `DataType` vs. `Class<T>`?\r\nAnd then over time we can train folks to use `Tensors` for creating `Tensor` objects.", "created_at": "2017-09-15T06:05:59Z", "updated_at": "2017-09-28T14:09:48Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/11535#discussion_r139070017", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/11535", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/139070017"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/11535#discussion_r139070017"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/11535"}}, "body_html": "<p>IIUC, this is the factory function to use to get type-checking while the <code>create(Object)</code> one will generate runtime errors.</p>\n<p>This distinction between when types are specified as <code>DataType</code> and when as <code>Class&lt;T&gt;</code> is a bit confusing, particularly since this <code>Tensor</code> class is providing factory functions for both. What do you think about the following:</p>\n<ul>\n<li><code>Tensor.java</code> will NOT provide compile-time type checking. All the methods do runtime checks and functions use the <code>DataType</code> enum for type information</li>\n<li>All the \"type-safe\" construction is with methods in <code>Tensors.java</code></li>\n</ul>\n<p>Subtle, but that way we perhaps more clearly layer the use of <code>DataType</code> vs. <code>Class&lt;T&gt;</code>?<br>\nAnd then over time we can train folks to use <code>Tensors</code> for creating <code>Tensor</code> objects.</p>", "body_text": "IIUC, this is the factory function to use to get type-checking while the create(Object) one will generate runtime errors.\nThis distinction between when types are specified as DataType and when as Class<T> is a bit confusing, particularly since this Tensor class is providing factory functions for both. What do you think about the following:\n\nTensor.java will NOT provide compile-time type checking. All the methods do runtime checks and functions use the DataType enum for type information\nAll the \"type-safe\" construction is with methods in Tensors.java\n\nSubtle, but that way we perhaps more clearly layer the use of DataType vs. Class<T>?\nAnd then over time we can train folks to use Tensors for creating Tensor objects."}