{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/275546198", "html_url": "https://github.com/tensorflow/tensorflow/issues/6716#issuecomment-275546198", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/6716", "id": 275546198, "node_id": "MDEyOklzc3VlQ29tbWVudDI3NTU0NjE5OA==", "user": {"login": "michaelisard", "id": 5376757, "node_id": "MDQ6VXNlcjUzNzY3NTc=", "avatar_url": "https://avatars1.githubusercontent.com/u/5376757?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelisard", "html_url": "https://github.com/michaelisard", "followers_url": "https://api.github.com/users/michaelisard/followers", "following_url": "https://api.github.com/users/michaelisard/following{/other_user}", "gists_url": "https://api.github.com/users/michaelisard/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelisard/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelisard/subscriptions", "organizations_url": "https://api.github.com/users/michaelisard/orgs", "repos_url": "https://api.github.com/users/michaelisard/repos", "events_url": "https://api.github.com/users/michaelisard/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelisard/received_events", "type": "User", "site_admin": false}, "created_at": "2017-01-26T23:25:48Z", "updated_at": "2017-01-26T23:25:48Z", "author_association": "MEMBER", "body_html": "<p>I have given this a little thought but not yet looked into the details of the implementation. It looks as if it should be ok to add the step_id to the tracked metadata, so that you won't have to use heuristics to guess it.</p>\n<p>As for putting deallocation into the timeline, I have one idea which is a bit half-baked and has not been subjected to code review. Before I type it in, I'd like feedback on whether it would solve your problem or not.</p>\n<p>I could add a thread-local callback to the tracking allocator, such that deallocations trigger the callback. Then, when memory tracking is enabled, each Op would install a callback before it began executing, and remove it after it completed. Any tensor that was freed on that thread while the Op was executing would be added to the timeline of the Op. This would obviously fail to work if deallocations happened on an intra-op threadpool, but hopefully that is rare or nonexistent.</p>\n<p>What do you think?</p>", "body_text": "I have given this a little thought but not yet looked into the details of the implementation. It looks as if it should be ok to add the step_id to the tracked metadata, so that you won't have to use heuristics to guess it.\nAs for putting deallocation into the timeline, I have one idea which is a bit half-baked and has not been subjected to code review. Before I type it in, I'd like feedback on whether it would solve your problem or not.\nI could add a thread-local callback to the tracking allocator, such that deallocations trigger the callback. Then, when memory tracking is enabled, each Op would install a callback before it began executing, and remove it after it completed. Any tensor that was freed on that thread while the Op was executing would be added to the timeline of the Op. This would obviously fail to work if deallocations happened on an intra-op threadpool, but hopefully that is rare or nonexistent.\nWhat do you think?", "body": "I have given this a little thought but not yet looked into the details of the implementation. It looks as if it should be ok to add the step_id to the tracked metadata, so that you won't have to use heuristics to guess it.\r\n\r\nAs for putting deallocation into the timeline, I have one idea which is a bit half-baked and has not been subjected to code review. Before I type it in, I'd like feedback on whether it would solve your problem or not.\r\n\r\nI could add a thread-local callback to the tracking allocator, such that deallocations trigger the callback. Then, when memory tracking is enabled, each Op would install a callback before it began executing, and remove it after it completed. Any tensor that was freed on that thread while the Op was executing would be added to the timeline of the Op. This would obviously fail to work if deallocations happened on an intra-op threadpool, but hopefully that is rare or nonexistent.\r\n\r\nWhat do you think?"}