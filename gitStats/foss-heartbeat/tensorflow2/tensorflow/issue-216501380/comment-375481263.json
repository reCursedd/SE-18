{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/375481263", "html_url": "https://github.com/tensorflow/tensorflow/issues/8665#issuecomment-375481263", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8665", "id": 375481263, "node_id": "MDEyOklzc3VlQ29tbWVudDM3NTQ4MTI2Mw==", "user": {"login": "xinyang", "id": 747429, "node_id": "MDQ6VXNlcjc0NzQyOQ==", "avatar_url": "https://avatars2.githubusercontent.com/u/747429?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xinyang", "html_url": "https://github.com/xinyang", "followers_url": "https://api.github.com/users/xinyang/followers", "following_url": "https://api.github.com/users/xinyang/following{/other_user}", "gists_url": "https://api.github.com/users/xinyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/xinyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xinyang/subscriptions", "organizations_url": "https://api.github.com/users/xinyang/orgs", "repos_url": "https://api.github.com/users/xinyang/repos", "events_url": "https://api.github.com/users/xinyang/events{/privacy}", "received_events_url": "https://api.github.com/users/xinyang/received_events", "type": "User", "site_admin": false}, "created_at": "2018-03-22T22:42:02Z", "updated_at": "2018-03-23T13:23:39Z", "author_association": "NONE", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=1057200\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/jkiske\">@jkiske</a> 's workaround worked for me!</p>\n<p>We also built on top of it to make it work with <code>tf.tables_initializer()</code>, but it requires two other changes:</p>\n<ul>\n<li>OUTPUT_NAMES needs to include the table initialization ops, which can be obtained with <code>tf.get_collection(tf.GraphKeys.TABLE_INITIALIZERS)</code>.</li>\n<li>The MetaGraph, instead of the Graph, needs to be what's exported/imported. This is because <code>tf.tables_initializer()</code> references the <code>tf.GraphKeys.TABLE_INITIALIZERS</code> collection. The Graph does not contain a collection_list, but the MetaGraph does.</li>\n</ul>\n<p>So here's a solution that works for us:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">import</span> os\n\n<span class=\"pl-k\">import</span> tensorflow <span class=\"pl-k\">as</span> tf\n<span class=\"pl-k\">from</span> tensorflow.python.framework.graph_util <span class=\"pl-k\">import</span> convert_variables_to_constants\n<span class=\"pl-k\">from</span> tensorflow.python.ops.lookup_ops <span class=\"pl-k\">import</span> HashTable, KeyValueTensorInitializer\n\nos.environ[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>TF_CPP_MIN_LOG_LEVEL<span class=\"pl-pds\">'</span></span>] <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>3<span class=\"pl-pds\">'</span></span>\n\n<span class=\"pl-c1\">OUTPUT_FOLDER</span> <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>/tmp<span class=\"pl-pds\">'</span></span>\n<span class=\"pl-c1\">OUTPUT_NAME</span> <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>hash_table.pb<span class=\"pl-pds\">'</span></span>\n<span class=\"pl-c1\">OUTPUT_NAMES</span> <span class=\"pl-k\">=</span> [<span class=\"pl-s\"><span class=\"pl-pds\">'</span>graph/output<span class=\"pl-pds\">'</span></span>]\n\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">build_graph</span>():\n    d <span class=\"pl-k\">=</span> {<span class=\"pl-s\"><span class=\"pl-pds\">'</span>a<span class=\"pl-pds\">'</span></span>: <span class=\"pl-c1\">1</span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>b<span class=\"pl-pds\">'</span></span>: <span class=\"pl-c1\">2</span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>c<span class=\"pl-pds\">'</span></span>: <span class=\"pl-c1\">3</span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>d<span class=\"pl-pds\">'</span></span>: <span class=\"pl-c1\">4</span>}\n    init <span class=\"pl-k\">=</span> KeyValueTensorInitializer(d.keys(), d.values())\n    hash_table <span class=\"pl-k\">=</span> HashTable(init, <span class=\"pl-v\">default_value</span><span class=\"pl-k\">=</span><span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>)\n    data <span class=\"pl-k\">=</span> tf.placeholder(tf.string, (<span class=\"pl-c1\">None</span>,), <span class=\"pl-v\">name</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>data<span class=\"pl-pds\">'</span></span>)\n    values <span class=\"pl-k\">=</span> hash_table.lookup(data)\n    output <span class=\"pl-k\">=</span> tf.identity(values <span class=\"pl-k\">*</span> <span class=\"pl-c1\">2</span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>output<span class=\"pl-pds\">'</span></span>)\n\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">freeze_graph</span>():\n    <span class=\"pl-k\">with</span> tf.Graph().as_default() <span class=\"pl-k\">as</span> graph:\n        <span class=\"pl-k\">with</span> tf.name_scope(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>graph<span class=\"pl-pds\">'</span></span>):\n            build_graph()\n\n        <span class=\"pl-k\">with</span> tf.Session(<span class=\"pl-v\">graph</span><span class=\"pl-k\">=</span>graph) <span class=\"pl-k\">as</span> sess:\n            sess.run(tf.tables_initializer())\n            <span class=\"pl-c1\">print</span> sess.run(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>graph/output:0<span class=\"pl-pds\">'</span></span>, <span class=\"pl-v\">feed_dict</span><span class=\"pl-k\">=</span>{<span class=\"pl-s\"><span class=\"pl-pds\">'</span>graph/data:0<span class=\"pl-pds\">'</span></span>: [<span class=\"pl-s\"><span class=\"pl-pds\">'</span>a<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>b<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>c<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>d<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>e<span class=\"pl-pds\">'</span></span>]})\n            <span class=\"pl-k\">for</span> table_init_op <span class=\"pl-k\">in</span> tf.get_collection(tf.GraphKeys.<span class=\"pl-c1\">TABLE_INITIALIZERS</span>):\n                <span class=\"pl-c1\">OUTPUT_NAMES</span>.append(table_init_op.name)\n            frozen_graph <span class=\"pl-k\">=</span> convert_variables_to_constants(sess, sess.graph_def, <span class=\"pl-c1\">OUTPUT_NAMES</span>)\n            tf.train.export_meta_graph(\n                <span class=\"pl-v\">filename</span><span class=\"pl-k\">=</span>os.path.join(<span class=\"pl-c1\">OUTPUT_FOLDER</span>, <span class=\"pl-c1\">OUTPUT_NAME</span>),\n                <span class=\"pl-v\">graph_def</span><span class=\"pl-k\">=</span>frozen_graph,\n                <span class=\"pl-v\">collection_list</span><span class=\"pl-k\">=</span>[tf.GraphKeys.<span class=\"pl-c1\">TABLE_INITIALIZERS</span>])\n\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">load_frozen_graph</span>():\n    <span class=\"pl-k\">with</span> tf.Graph().as_default() <span class=\"pl-k\">as</span> graph:\n        tf.train.import_meta_graph(os.path.join(<span class=\"pl-c1\">OUTPUT_FOLDER</span>, <span class=\"pl-c1\">OUTPUT_NAME</span>))\n        <span class=\"pl-k\">with</span> tf.Session(<span class=\"pl-v\">graph</span><span class=\"pl-k\">=</span>graph) <span class=\"pl-k\">as</span> sess:\n            sess.run(tf.tables_initializer())\n            <span class=\"pl-c1\">print</span> sess.run(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>graph/output:0<span class=\"pl-pds\">'</span></span>, <span class=\"pl-v\">feed_dict</span><span class=\"pl-k\">=</span>{<span class=\"pl-s\"><span class=\"pl-pds\">'</span>graph/data:0<span class=\"pl-pds\">'</span></span>: [<span class=\"pl-s\"><span class=\"pl-pds\">'</span>a<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>b<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>c<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>d<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>e<span class=\"pl-pds\">'</span></span>]})\n\n\n<span class=\"pl-k\">if</span> <span class=\"pl-c1\">__name__</span> <span class=\"pl-k\">==</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>__main__<span class=\"pl-pds\">'</span></span>:\n    freeze_graph()\n    load_frozen_graph()</pre></div>", "body_text": "@jkiske 's workaround worked for me!\nWe also built on top of it to make it work with tf.tables_initializer(), but it requires two other changes:\n\nOUTPUT_NAMES needs to include the table initialization ops, which can be obtained with tf.get_collection(tf.GraphKeys.TABLE_INITIALIZERS).\nThe MetaGraph, instead of the Graph, needs to be what's exported/imported. This is because tf.tables_initializer() references the tf.GraphKeys.TABLE_INITIALIZERS collection. The Graph does not contain a collection_list, but the MetaGraph does.\n\nSo here's a solution that works for us:\nimport os\n\nimport tensorflow as tf\nfrom tensorflow.python.framework.graph_util import convert_variables_to_constants\nfrom tensorflow.python.ops.lookup_ops import HashTable, KeyValueTensorInitializer\n\nos.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'\n\nOUTPUT_FOLDER = '/tmp'\nOUTPUT_NAME = 'hash_table.pb'\nOUTPUT_NAMES = ['graph/output']\n\n\ndef build_graph():\n    d = {'a': 1, 'b': 2, 'c': 3, 'd': 4}\n    init = KeyValueTensorInitializer(d.keys(), d.values())\n    hash_table = HashTable(init, default_value=-1)\n    data = tf.placeholder(tf.string, (None,), name='data')\n    values = hash_table.lookup(data)\n    output = tf.identity(values * 2, 'output')\n\n\ndef freeze_graph():\n    with tf.Graph().as_default() as graph:\n        with tf.name_scope('graph'):\n            build_graph()\n\n        with tf.Session(graph=graph) as sess:\n            sess.run(tf.tables_initializer())\n            print sess.run('graph/output:0', feed_dict={'graph/data:0': ['a', 'b', 'c', 'd', 'e']})\n            for table_init_op in tf.get_collection(tf.GraphKeys.TABLE_INITIALIZERS):\n                OUTPUT_NAMES.append(table_init_op.name)\n            frozen_graph = convert_variables_to_constants(sess, sess.graph_def, OUTPUT_NAMES)\n            tf.train.export_meta_graph(\n                filename=os.path.join(OUTPUT_FOLDER, OUTPUT_NAME),\n                graph_def=frozen_graph,\n                collection_list=[tf.GraphKeys.TABLE_INITIALIZERS])\n\n\ndef load_frozen_graph():\n    with tf.Graph().as_default() as graph:\n        tf.train.import_meta_graph(os.path.join(OUTPUT_FOLDER, OUTPUT_NAME))\n        with tf.Session(graph=graph) as sess:\n            sess.run(tf.tables_initializer())\n            print sess.run('graph/output:0', feed_dict={'graph/data:0': ['a', 'b', 'c', 'd', 'e']})\n\n\nif __name__ == '__main__':\n    freeze_graph()\n    load_frozen_graph()", "body": "@jkiske 's workaround worked for me!\r\n\r\nWe also built on top of it to make it work with `tf.tables_initializer()`, but it requires two other changes:\r\n- OUTPUT_NAMES needs to include the table initialization ops, which can be obtained with `tf.get_collection(tf.GraphKeys.TABLE_INITIALIZERS)`.\r\n- The MetaGraph, instead of the Graph, needs to be what's exported/imported. This is because `tf.tables_initializer()` references the `tf.GraphKeys.TABLE_INITIALIZERS` collection. The Graph does not contain a collection_list, but the MetaGraph does.\r\n\r\nSo here's a solution that works for us:\r\n\r\n```python\r\nimport os\r\n\r\nimport tensorflow as tf\r\nfrom tensorflow.python.framework.graph_util import convert_variables_to_constants\r\nfrom tensorflow.python.ops.lookup_ops import HashTable, KeyValueTensorInitializer\r\n\r\nos.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'\r\n\r\nOUTPUT_FOLDER = '/tmp'\r\nOUTPUT_NAME = 'hash_table.pb'\r\nOUTPUT_NAMES = ['graph/output']\r\n\r\n\r\ndef build_graph():\r\n    d = {'a': 1, 'b': 2, 'c': 3, 'd': 4}\r\n    init = KeyValueTensorInitializer(d.keys(), d.values())\r\n    hash_table = HashTable(init, default_value=-1)\r\n    data = tf.placeholder(tf.string, (None,), name='data')\r\n    values = hash_table.lookup(data)\r\n    output = tf.identity(values * 2, 'output')\r\n\r\n\r\ndef freeze_graph():\r\n    with tf.Graph().as_default() as graph:\r\n        with tf.name_scope('graph'):\r\n            build_graph()\r\n\r\n        with tf.Session(graph=graph) as sess:\r\n            sess.run(tf.tables_initializer())\r\n            print sess.run('graph/output:0', feed_dict={'graph/data:0': ['a', 'b', 'c', 'd', 'e']})\r\n            for table_init_op in tf.get_collection(tf.GraphKeys.TABLE_INITIALIZERS):\r\n                OUTPUT_NAMES.append(table_init_op.name)\r\n            frozen_graph = convert_variables_to_constants(sess, sess.graph_def, OUTPUT_NAMES)\r\n            tf.train.export_meta_graph(\r\n                filename=os.path.join(OUTPUT_FOLDER, OUTPUT_NAME),\r\n                graph_def=frozen_graph,\r\n                collection_list=[tf.GraphKeys.TABLE_INITIALIZERS])\r\n\r\n\r\ndef load_frozen_graph():\r\n    with tf.Graph().as_default() as graph:\r\n        tf.train.import_meta_graph(os.path.join(OUTPUT_FOLDER, OUTPUT_NAME))\r\n        with tf.Session(graph=graph) as sess:\r\n            sess.run(tf.tables_initializer())\r\n            print sess.run('graph/output:0', feed_dict={'graph/data:0': ['a', 'b', 'c', 'd', 'e']})\r\n\r\n\r\nif __name__ == '__main__':\r\n    freeze_graph()\r\n    load_frozen_graph()\r\n```"}