{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/336294088", "html_url": "https://github.com/tensorflow/tensorflow/issues/8665#issuecomment-336294088", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8665", "id": 336294088, "node_id": "MDEyOklzc3VlQ29tbWVudDMzNjI5NDA4OA==", "user": {"login": "jkiske", "id": 1057200, "node_id": "MDQ6VXNlcjEwNTcyMDA=", "avatar_url": "https://avatars0.githubusercontent.com/u/1057200?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jkiske", "html_url": "https://github.com/jkiske", "followers_url": "https://api.github.com/users/jkiske/followers", "following_url": "https://api.github.com/users/jkiske/following{/other_user}", "gists_url": "https://api.github.com/users/jkiske/gists{/gist_id}", "starred_url": "https://api.github.com/users/jkiske/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jkiske/subscriptions", "organizations_url": "https://api.github.com/users/jkiske/orgs", "repos_url": "https://api.github.com/users/jkiske/repos", "events_url": "https://api.github.com/users/jkiske/events{/privacy}", "received_events_url": "https://api.github.com/users/jkiske/received_events", "type": "User", "site_admin": false}, "created_at": "2017-10-12T22:25:33Z", "updated_at": "2017-10-12T22:25:33Z", "author_association": "NONE", "body_html": "<p>Adding <code>init_all_tables</code> to the list of names to export fixes this issue.</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">import</span> os\n\n<span class=\"pl-k\">import</span> tensorflow <span class=\"pl-k\">as</span> tf\n<span class=\"pl-k\">from</span> tensorflow.python.framework.graph_util <span class=\"pl-k\">import</span> convert_variables_to_constants\n<span class=\"pl-k\">from</span> tensorflow.python.ops.lookup_ops <span class=\"pl-k\">import</span> HashTable, KeyValueTensorInitializer\n\nos.environ[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>TF_CPP_MIN_LOG_LEVEL<span class=\"pl-pds\">'</span></span>] <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>3<span class=\"pl-pds\">'</span></span>\n\n<span class=\"pl-c1\">OUTPUT_FOLDER</span> <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>/tmp<span class=\"pl-pds\">'</span></span>\n<span class=\"pl-c1\">OUTPUT_NAME</span> <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>hash_table.pb<span class=\"pl-pds\">'</span></span>\n<span class=\"pl-c1\">OUTPUT_NAMES</span> <span class=\"pl-k\">=</span> [<span class=\"pl-s\"><span class=\"pl-pds\">'</span>graph/output<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>init_all_tables<span class=\"pl-pds\">'</span></span>]\n\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">build_graph</span>():\n    d <span class=\"pl-k\">=</span> {<span class=\"pl-s\"><span class=\"pl-pds\">'</span>a<span class=\"pl-pds\">'</span></span>: <span class=\"pl-c1\">1</span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>b<span class=\"pl-pds\">'</span></span>: <span class=\"pl-c1\">2</span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>c<span class=\"pl-pds\">'</span></span>: <span class=\"pl-c1\">3</span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>d<span class=\"pl-pds\">'</span></span>: <span class=\"pl-c1\">4</span>}\n    init <span class=\"pl-k\">=</span> KeyValueTensorInitializer(d.keys(), d.values())\n    hash_table <span class=\"pl-k\">=</span> HashTable(init, <span class=\"pl-v\">default_value</span><span class=\"pl-k\">=</span><span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>)\n    data <span class=\"pl-k\">=</span> tf.placeholder(tf.string, (<span class=\"pl-c1\">None</span>,), <span class=\"pl-v\">name</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>data<span class=\"pl-pds\">'</span></span>)\n    values <span class=\"pl-k\">=</span> hash_table.lookup(data)\n    output <span class=\"pl-k\">=</span> tf.identity(values <span class=\"pl-k\">*</span> <span class=\"pl-c1\">2</span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>output<span class=\"pl-pds\">'</span></span>)\n\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">freeze_graph</span>():\n    <span class=\"pl-k\">with</span> tf.Graph().as_default() <span class=\"pl-k\">as</span> graph:\n        <span class=\"pl-k\">with</span> tf.name_scope(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>graph<span class=\"pl-pds\">'</span></span>):\n            build_graph()\n\n        <span class=\"pl-k\">with</span> tf.Session(<span class=\"pl-v\">graph</span><span class=\"pl-k\">=</span>graph) <span class=\"pl-k\">as</span> sess:\n            sess.run(tf.tables_initializer())\n            <span class=\"pl-c1\">print</span> sess.run(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>graph/output:0<span class=\"pl-pds\">'</span></span>, <span class=\"pl-v\">feed_dict</span><span class=\"pl-k\">=</span>{<span class=\"pl-s\"><span class=\"pl-pds\">'</span>graph/data:0<span class=\"pl-pds\">'</span></span>: [<span class=\"pl-s\"><span class=\"pl-pds\">'</span>a<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>b<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>c<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>d<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>e<span class=\"pl-pds\">'</span></span>]})\n            frozen_graph <span class=\"pl-k\">=</span> convert_variables_to_constants(sess, sess.graph_def, <span class=\"pl-c1\">OUTPUT_NAMES</span>)\n            tf.train.write_graph(frozen_graph, <span class=\"pl-c1\">OUTPUT_FOLDER</span>, <span class=\"pl-c1\">OUTPUT_NAME</span>, <span class=\"pl-v\">as_text</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">False</span>)\n\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">load_frozen_graph</span>():\n    <span class=\"pl-k\">with</span> <span class=\"pl-c1\">open</span>(os.path.join(<span class=\"pl-c1\">OUTPUT_FOLDER</span>, <span class=\"pl-c1\">OUTPUT_NAME</span>), <span class=\"pl-s\"><span class=\"pl-pds\">'</span>rb<span class=\"pl-pds\">'</span></span>) <span class=\"pl-k\">as</span> f:\n        output_graph_def <span class=\"pl-k\">=</span> tf.GraphDef()\n        output_graph_def.ParseFromString(f.read())\n\n    <span class=\"pl-k\">with</span> tf.Graph().as_default() <span class=\"pl-k\">as</span> graph:\n        tf.import_graph_def(output_graph_def, <span class=\"pl-v\">name</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span><span class=\"pl-pds\">'</span></span>)\n        <span class=\"pl-k\">with</span> tf.Session(<span class=\"pl-v\">graph</span><span class=\"pl-k\">=</span>graph) <span class=\"pl-k\">as</span> sess:\n            <span class=\"pl-k\">try</span>:\n                sess.run(graph.get_operation_by_name(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>init_all_tables<span class=\"pl-pds\">'</span></span>))\n            <span class=\"pl-k\">except</span> <span class=\"pl-c1\">KeyError</span>:\n                <span class=\"pl-k\">pass</span>\n            <span class=\"pl-c1\">print</span> sess.run(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>graph/output:0<span class=\"pl-pds\">'</span></span>, <span class=\"pl-v\">feed_dict</span><span class=\"pl-k\">=</span>{<span class=\"pl-s\"><span class=\"pl-pds\">'</span>graph/data:0<span class=\"pl-pds\">'</span></span>: [<span class=\"pl-s\"><span class=\"pl-pds\">'</span>a<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>b<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>c<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>d<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>e<span class=\"pl-pds\">'</span></span>]})\n\n\n<span class=\"pl-k\">if</span> <span class=\"pl-c1\">__name__</span> <span class=\"pl-k\">==</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>__main__<span class=\"pl-pds\">'</span></span>:\n    freeze_graph()\n    load_frozen_graph()</pre></div>\n<p>The call to <code>extract_sub_graph</code> inside <code>convert_variables_to_constants</code> prunes out this op and its descendants (keys, values) if you don't include <code>init_all_tables</code> in <code>output_node_names</code>. I don't like the idea of running an initializer op during inference and having a try/except seems hacky to me. Is there another way to do this?</p>", "body_text": "Adding init_all_tables to the list of names to export fixes this issue.\nimport os\n\nimport tensorflow as tf\nfrom tensorflow.python.framework.graph_util import convert_variables_to_constants\nfrom tensorflow.python.ops.lookup_ops import HashTable, KeyValueTensorInitializer\n\nos.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'\n\nOUTPUT_FOLDER = '/tmp'\nOUTPUT_NAME = 'hash_table.pb'\nOUTPUT_NAMES = ['graph/output', 'init_all_tables']\n\n\ndef build_graph():\n    d = {'a': 1, 'b': 2, 'c': 3, 'd': 4}\n    init = KeyValueTensorInitializer(d.keys(), d.values())\n    hash_table = HashTable(init, default_value=-1)\n    data = tf.placeholder(tf.string, (None,), name='data')\n    values = hash_table.lookup(data)\n    output = tf.identity(values * 2, 'output')\n\n\ndef freeze_graph():\n    with tf.Graph().as_default() as graph:\n        with tf.name_scope('graph'):\n            build_graph()\n\n        with tf.Session(graph=graph) as sess:\n            sess.run(tf.tables_initializer())\n            print sess.run('graph/output:0', feed_dict={'graph/data:0': ['a', 'b', 'c', 'd', 'e']})\n            frozen_graph = convert_variables_to_constants(sess, sess.graph_def, OUTPUT_NAMES)\n            tf.train.write_graph(frozen_graph, OUTPUT_FOLDER, OUTPUT_NAME, as_text=False)\n\n\ndef load_frozen_graph():\n    with open(os.path.join(OUTPUT_FOLDER, OUTPUT_NAME), 'rb') as f:\n        output_graph_def = tf.GraphDef()\n        output_graph_def.ParseFromString(f.read())\n\n    with tf.Graph().as_default() as graph:\n        tf.import_graph_def(output_graph_def, name='')\n        with tf.Session(graph=graph) as sess:\n            try:\n                sess.run(graph.get_operation_by_name('init_all_tables'))\n            except KeyError:\n                pass\n            print sess.run('graph/output:0', feed_dict={'graph/data:0': ['a', 'b', 'c', 'd', 'e']})\n\n\nif __name__ == '__main__':\n    freeze_graph()\n    load_frozen_graph()\nThe call to extract_sub_graph inside convert_variables_to_constants prunes out this op and its descendants (keys, values) if you don't include init_all_tables in output_node_names. I don't like the idea of running an initializer op during inference and having a try/except seems hacky to me. Is there another way to do this?", "body": "Adding `init_all_tables` to the list of names to export fixes this issue. \r\n\r\n```python\r\nimport os\r\n\r\nimport tensorflow as tf\r\nfrom tensorflow.python.framework.graph_util import convert_variables_to_constants\r\nfrom tensorflow.python.ops.lookup_ops import HashTable, KeyValueTensorInitializer\r\n\r\nos.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'\r\n\r\nOUTPUT_FOLDER = '/tmp'\r\nOUTPUT_NAME = 'hash_table.pb'\r\nOUTPUT_NAMES = ['graph/output', 'init_all_tables']\r\n\r\n\r\ndef build_graph():\r\n    d = {'a': 1, 'b': 2, 'c': 3, 'd': 4}\r\n    init = KeyValueTensorInitializer(d.keys(), d.values())\r\n    hash_table = HashTable(init, default_value=-1)\r\n    data = tf.placeholder(tf.string, (None,), name='data')\r\n    values = hash_table.lookup(data)\r\n    output = tf.identity(values * 2, 'output')\r\n\r\n\r\ndef freeze_graph():\r\n    with tf.Graph().as_default() as graph:\r\n        with tf.name_scope('graph'):\r\n            build_graph()\r\n\r\n        with tf.Session(graph=graph) as sess:\r\n            sess.run(tf.tables_initializer())\r\n            print sess.run('graph/output:0', feed_dict={'graph/data:0': ['a', 'b', 'c', 'd', 'e']})\r\n            frozen_graph = convert_variables_to_constants(sess, sess.graph_def, OUTPUT_NAMES)\r\n            tf.train.write_graph(frozen_graph, OUTPUT_FOLDER, OUTPUT_NAME, as_text=False)\r\n\r\n\r\ndef load_frozen_graph():\r\n    with open(os.path.join(OUTPUT_FOLDER, OUTPUT_NAME), 'rb') as f:\r\n        output_graph_def = tf.GraphDef()\r\n        output_graph_def.ParseFromString(f.read())\r\n\r\n    with tf.Graph().as_default() as graph:\r\n        tf.import_graph_def(output_graph_def, name='')\r\n        with tf.Session(graph=graph) as sess:\r\n            try:\r\n                sess.run(graph.get_operation_by_name('init_all_tables'))\r\n            except KeyError:\r\n                pass\r\n            print sess.run('graph/output:0', feed_dict={'graph/data:0': ['a', 'b', 'c', 'd', 'e']})\r\n\r\n\r\nif __name__ == '__main__':\r\n    freeze_graph()\r\n    load_frozen_graph()\r\n```\r\nThe call to `extract_sub_graph` inside `convert_variables_to_constants` prunes out this op and its descendants (keys, values) if you don't include `init_all_tables` in `output_node_names`. I don't like the idea of running an initializer op during inference and having a try/except seems hacky to me. Is there another way to do this?"}