{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/22974", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/22974/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/22974/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/22974/events", "html_url": "https://github.com/tensorflow/tensorflow/pull/22974", "id": 369957581, "node_id": "MDExOlB1bGxSZXF1ZXN0MjIyNzUyMzUx", "number": 22974, "title": "[XLA] Add simple HLO if conversion pass", "user": {"login": "Keno", "id": 1291671, "node_id": "MDQ6VXNlcjEyOTE2NzE=", "avatar_url": "https://avatars1.githubusercontent.com/u/1291671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Keno", "html_url": "https://github.com/Keno", "followers_url": "https://api.github.com/users/Keno/followers", "following_url": "https://api.github.com/users/Keno/following{/other_user}", "gists_url": "https://api.github.com/users/Keno/gists{/gist_id}", "starred_url": "https://api.github.com/users/Keno/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Keno/subscriptions", "organizations_url": "https://api.github.com/users/Keno/orgs", "repos_url": "https://api.github.com/users/Keno/repos", "events_url": "https://api.github.com/users/Keno/events{/privacy}", "received_events_url": "https://api.github.com/users/Keno/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 300136587, "node_id": "MDU6TGFiZWwzMDAxMzY1ODc=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/cla:%20yes", "name": "cla: yes", "color": "009800", "default": false}], "state": "open", "locked": false, "assignee": {"login": "ymodak", "id": 42785357, "node_id": "MDQ6VXNlcjQyNzg1MzU3", "avatar_url": "https://avatars1.githubusercontent.com/u/42785357?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ymodak", "html_url": "https://github.com/ymodak", "followers_url": "https://api.github.com/users/ymodak/followers", "following_url": "https://api.github.com/users/ymodak/following{/other_user}", "gists_url": "https://api.github.com/users/ymodak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ymodak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ymodak/subscriptions", "organizations_url": "https://api.github.com/users/ymodak/orgs", "repos_url": "https://api.github.com/users/ymodak/repos", "events_url": "https://api.github.com/users/ymodak/events{/privacy}", "received_events_url": "https://api.github.com/users/ymodak/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "ymodak", "id": 42785357, "node_id": "MDQ6VXNlcjQyNzg1MzU3", "avatar_url": "https://avatars1.githubusercontent.com/u/42785357?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ymodak", "html_url": "https://github.com/ymodak", "followers_url": "https://api.github.com/users/ymodak/followers", "following_url": "https://api.github.com/users/ymodak/following{/other_user}", "gists_url": "https://api.github.com/users/ymodak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ymodak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ymodak/subscriptions", "organizations_url": "https://api.github.com/users/ymodak/orgs", "repos_url": "https://api.github.com/users/ymodak/repos", "events_url": "https://api.github.com/users/ymodak/events{/privacy}", "received_events_url": "https://api.github.com/users/ymodak/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 7, "created_at": "2018-10-14T23:52:58Z", "updated_at": "2018-11-21T00:05:24Z", "closed_at": null, "author_association": "CONTRIBUTOR", "pull_request": {"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/22974", "html_url": "https://github.com/tensorflow/tensorflow/pull/22974", "diff_url": "https://github.com/tensorflow/tensorflow/pull/22974.diff", "patch_url": "https://github.com/tensorflow/tensorflow/pull/22974.patch"}, "body_html": "<p>kConditional operations are currently generally disallowed in parallel contexts<br>\n(e.g. in mapped computations). The julia XLA frontend was running into this limitation<br>\nquite a bit, because existing julia code tends to use the terniary operator for select,<br>\ne.g. to describe the derivative of a <code>max</code> call (and thus a <code>relu</code>) - see the<br>\ndefinitions of the derivatives of <code>max</code> at<br>\n<a href=\"https://github.com/JuliaDiff/DiffRules.jl/blob/master/src/rules.jl#L94\">https://github.com/JuliaDiff/DiffRules.jl/blob/master/src/rules.jl#L94</a></p>\n<p>To support these sorts of patterns, add a simple if conversion pass that converts<br>\nconditionals in parallel context by equivalent select operations (which are well supported),<br>\ni.e. a computation like:</p>\n<pre><code>if {\n %pif = () parameter(0)\n ROOT %cif = f32[] constant(0)\n}\n\nelse {\n %pelse = () parameter(0)\n ROOT %celse = f32[] constant(1)\n}\n\nmapped {\n %a = f32[] parameter(0)\n %b = f32[] parameter(1)\n %lt = pred[] less-than(%a, %b)\n %t = () tuple()\n ROOT %conditional = f32[] conditional(%lt, %t, %t), true_computation=if, false_computation=else\n}\n\nENTRY comp {\n %p1 = f32[1000]{0} parameter(0)\n %p2 = f32[1000]{0} parameter(1)\n ROOT %mapped = f32[1000]{0} map(%p1, %p2), dimensions={0}, to_apply=mapped\n}\n</code></pre>\n<p>gets rewritten to</p>\n<pre><code>mapped {\n %a = f32[] parameter(0)\n %b = f32[] parameter(1)\n %cif = f32[] constant(0)\n %celse = f32[] constant(1)\n %lt = pred[] less-than(%a, %b)\n ROOT %select = f32[] select(%lt, %cif, %celse)\n}\n\nENTRY comp {\n %p1 = f32[1000]{0} parameter(0)\n %p2 = f32[1000]{0} parameter(1)\n ROOT %mapped = f32[1000]{0} map(%p1, %p2) dimensions={0} to_apply=mapped\n}\n</code></pre>\n<p>To keep things simple, this is accomplished by first rewriting the conditional<br>\nto two calls and a select and then inlining the individual calls. Naturally,<br>\nthe transformation is only applied if the called computation do not<br>\nhave side effects (which they generally don't if they're in parallel<br>\ncontext). In the future, it would be good to let MapInliner further<br>\nsimplify this to an implicitly mapped select.</p>", "body_text": "kConditional operations are currently generally disallowed in parallel contexts\n(e.g. in mapped computations). The julia XLA frontend was running into this limitation\nquite a bit, because existing julia code tends to use the terniary operator for select,\ne.g. to describe the derivative of a max call (and thus a relu) - see the\ndefinitions of the derivatives of max at\nhttps://github.com/JuliaDiff/DiffRules.jl/blob/master/src/rules.jl#L94\nTo support these sorts of patterns, add a simple if conversion pass that converts\nconditionals in parallel context by equivalent select operations (which are well supported),\ni.e. a computation like:\nif {\n %pif = () parameter(0)\n ROOT %cif = f32[] constant(0)\n}\n\nelse {\n %pelse = () parameter(0)\n ROOT %celse = f32[] constant(1)\n}\n\nmapped {\n %a = f32[] parameter(0)\n %b = f32[] parameter(1)\n %lt = pred[] less-than(%a, %b)\n %t = () tuple()\n ROOT %conditional = f32[] conditional(%lt, %t, %t), true_computation=if, false_computation=else\n}\n\nENTRY comp {\n %p1 = f32[1000]{0} parameter(0)\n %p2 = f32[1000]{0} parameter(1)\n ROOT %mapped = f32[1000]{0} map(%p1, %p2), dimensions={0}, to_apply=mapped\n}\n\ngets rewritten to\nmapped {\n %a = f32[] parameter(0)\n %b = f32[] parameter(1)\n %cif = f32[] constant(0)\n %celse = f32[] constant(1)\n %lt = pred[] less-than(%a, %b)\n ROOT %select = f32[] select(%lt, %cif, %celse)\n}\n\nENTRY comp {\n %p1 = f32[1000]{0} parameter(0)\n %p2 = f32[1000]{0} parameter(1)\n ROOT %mapped = f32[1000]{0} map(%p1, %p2) dimensions={0} to_apply=mapped\n}\n\nTo keep things simple, this is accomplished by first rewriting the conditional\nto two calls and a select and then inlining the individual calls. Naturally,\nthe transformation is only applied if the called computation do not\nhave side effects (which they generally don't if they're in parallel\ncontext). In the future, it would be good to let MapInliner further\nsimplify this to an implicitly mapped select.", "body": "kConditional operations are currently generally disallowed in parallel contexts\r\n(e.g. in mapped computations). The julia XLA frontend was running into this limitation\r\nquite a bit, because existing julia code tends to use the terniary operator for select,\r\ne.g. to describe the derivative of a `max` call (and thus a `relu`) - see the\r\ndefinitions of the derivatives of `max` at\r\nhttps://github.com/JuliaDiff/DiffRules.jl/blob/master/src/rules.jl#L94\r\n\r\nTo support these sorts of patterns, add a simple if conversion pass that converts\r\nconditionals in parallel context by equivalent select operations (which are well supported),\r\ni.e. a computation like:\r\n\r\n```\r\nif {\r\n %pif = () parameter(0)\r\n ROOT %cif = f32[] constant(0)\r\n}\r\n\r\nelse {\r\n %pelse = () parameter(0)\r\n ROOT %celse = f32[] constant(1)\r\n}\r\n\r\nmapped {\r\n %a = f32[] parameter(0)\r\n %b = f32[] parameter(1)\r\n %lt = pred[] less-than(%a, %b)\r\n %t = () tuple()\r\n ROOT %conditional = f32[] conditional(%lt, %t, %t), true_computation=if, false_computation=else\r\n}\r\n\r\nENTRY comp {\r\n %p1 = f32[1000]{0} parameter(0)\r\n %p2 = f32[1000]{0} parameter(1)\r\n ROOT %mapped = f32[1000]{0} map(%p1, %p2), dimensions={0}, to_apply=mapped\r\n}\r\n```\r\n\r\ngets rewritten to\r\n\r\n```\r\nmapped {\r\n %a = f32[] parameter(0)\r\n %b = f32[] parameter(1)\r\n %cif = f32[] constant(0)\r\n %celse = f32[] constant(1)\r\n %lt = pred[] less-than(%a, %b)\r\n ROOT %select = f32[] select(%lt, %cif, %celse)\r\n}\r\n\r\nENTRY comp {\r\n %p1 = f32[1000]{0} parameter(0)\r\n %p2 = f32[1000]{0} parameter(1)\r\n ROOT %mapped = f32[1000]{0} map(%p1, %p2) dimensions={0} to_apply=mapped\r\n}\r\n```\r\n\r\nTo keep things simple, this is accomplished by first rewriting the conditional\r\nto two calls and a select and then inlining the individual calls. Naturally,\r\nthe transformation is only applied if the called computation do not\r\nhave side effects (which they generally don't if they're in parallel\r\ncontext). In the future, it would be good to let MapInliner further\r\nsimplify this to an implicitly mapped select."}