{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/365938347", "html_url": "https://github.com/tensorflow/tensorflow/issues/16942#issuecomment-365938347", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/16942", "id": 365938347, "node_id": "MDEyOklzc3VlQ29tbWVudDM2NTkzODM0Nw==", "user": {"login": "Joshuaalbert", "id": 14807032, "node_id": "MDQ6VXNlcjE0ODA3MDMy", "avatar_url": "https://avatars2.githubusercontent.com/u/14807032?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Joshuaalbert", "html_url": "https://github.com/Joshuaalbert", "followers_url": "https://api.github.com/users/Joshuaalbert/followers", "following_url": "https://api.github.com/users/Joshuaalbert/following{/other_user}", "gists_url": "https://api.github.com/users/Joshuaalbert/gists{/gist_id}", "starred_url": "https://api.github.com/users/Joshuaalbert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Joshuaalbert/subscriptions", "organizations_url": "https://api.github.com/users/Joshuaalbert/orgs", "repos_url": "https://api.github.com/users/Joshuaalbert/repos", "events_url": "https://api.github.com/users/Joshuaalbert/events{/privacy}", "received_events_url": "https://api.github.com/users/Joshuaalbert/received_events", "type": "User", "site_admin": false}, "created_at": "2018-02-15T14:12:18Z", "updated_at": "2018-02-15T14:12:18Z", "author_association": "NONE", "body_html": "<p>So I ran sess.run first and then 10 runs in a timing loop with the constant variable, and also with a random variable. I also created a profile timeline for each.</p>\n<p>Constant:<br>\nV1 timing: 0.00014590219943784178 / run 10 runs<br>\nV2 timing: 0.2790762079996057 / run 10 runs</p>\n<p>Random:<br>\nV1 timing: 1.2271329755021725 / run 10 runs<br>\nV2 timing: 1.209720030199969 / run 10 runs</p>\n<p>So it seems while loop is slower as expected after initial graph run.</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">import</span> tensorflow <span class=\"pl-k\">as</span> tf\n<span class=\"pl-k\">from</span> timeit <span class=\"pl-k\">import</span> default_timer\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">func</span>(<span class=\"pl-smi\">nums</span>):\n    <span class=\"pl-k\">return</span> tf.reduce_sum(tf.multiply(tf.add(nums,<span class=\"pl-c1\">1</span>), nums))\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">v1</span>(<span class=\"pl-smi\">random</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">False</span>):\n    graph <span class=\"pl-k\">=</span> tf.Graph()\n    <span class=\"pl-k\">with</span> graph.as_default(), tf.device(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>/cpu:0<span class=\"pl-pds\">'</span></span>):\n        <span class=\"pl-k\">if</span> random:\n            nums <span class=\"pl-k\">=</span> tf.random_normal(<span class=\"pl-v\">shape</span><span class=\"pl-k\">=</span>(<span class=\"pl-c1\">200000000</span>,),<span class=\"pl-v\">dtype</span><span class=\"pl-k\">=</span>tf.float32)\n        <span class=\"pl-k\">else</span>:\n            nums <span class=\"pl-k\">=</span> tf.range(<span class=\"pl-c1\">200000000</span>, <span class=\"pl-v\">dtype</span><span class=\"pl-k\">=</span>tf.float32)\n        dot_product <span class=\"pl-k\">=</span> func(nums)\n    <span class=\"pl-k\">with</span> tf.Session(<span class=\"pl-v\">graph</span><span class=\"pl-k\">=</span>graph) <span class=\"pl-k\">as</span> sess:\n        sess.run(dot_product)\n        t1 <span class=\"pl-k\">=</span> default_timer()\n        <span class=\"pl-k\">for</span> i <span class=\"pl-k\">in</span> <span class=\"pl-c1\">range</span>(<span class=\"pl-c1\">10</span>):\n            sess.run(dot_product)\n        <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>V1 timing: <span class=\"pl-c1\">{}</span> / run 10 runs<span class=\"pl-pds\">\"</span></span>.format((default_timer() <span class=\"pl-k\">-</span> t1)<span class=\"pl-k\">/</span><span class=\"pl-c1\">10</span>.))\n\n        profiler <span class=\"pl-k\">=</span> tf.profiler.Profiler(sess.graph)\n        run_meta <span class=\"pl-k\">=</span> tf.RunMetadata()\n        sess.run(dot_product,\n                <span class=\"pl-v\">options</span> <span class=\"pl-k\">=</span> tf.RunOptions(<span class=\"pl-v\">trace_level</span> <span class=\"pl-k\">=</span> tf.RunOptions.<span class=\"pl-c1\">FULL_TRACE</span>),\n                <span class=\"pl-v\">run_metadata</span> <span class=\"pl-k\">=</span> run_meta)\n        profiler.add_step(<span class=\"pl-c1\">0</span>,run_meta)\n        opts <span class=\"pl-k\">=</span> (tf.profiler.ProfileOptionBuilder(\n                 tf.profiler.ProfileOptionBuilder.time_and_memory())\n                 .with_step(<span class=\"pl-c1\">0</span>)\n                 .with_timeline_output(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>timeline_v1_<span class=\"pl-c1\">{}</span><span class=\"pl-pds\">'</span></span>.format(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>random<span class=\"pl-pds\">'</span></span> <span class=\"pl-k\">if</span> random <span class=\"pl-k\">else</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>const<span class=\"pl-pds\">'</span></span>)).build())\n        profiler.profile_graph(<span class=\"pl-v\">options</span><span class=\"pl-k\">=</span>opts)\n\n\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">v2</span>(<span class=\"pl-smi\">random</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">False</span>):\n    graph <span class=\"pl-k\">=</span> tf.Graph()\n    <span class=\"pl-k\">with</span> graph.as_default(), tf.device(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>/cpu:0<span class=\"pl-pds\">'</span></span>):\n        arr <span class=\"pl-k\">=</span> tf.TensorArray(<span class=\"pl-v\">size</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">1</span>, <span class=\"pl-v\">dtype</span><span class=\"pl-k\">=</span>tf.float32)\n        <span class=\"pl-k\">if</span> random:\n            nums <span class=\"pl-k\">=</span> tf.random_normal(<span class=\"pl-v\">shape</span><span class=\"pl-k\">=</span>(<span class=\"pl-c1\">200000000</span>,),<span class=\"pl-v\">dtype</span><span class=\"pl-k\">=</span>tf.float32)\n        <span class=\"pl-k\">else</span>:\n            nums <span class=\"pl-k\">=</span> tf.range(<span class=\"pl-c1\">200000000</span>, <span class=\"pl-v\">dtype</span><span class=\"pl-k\">=</span>tf.float32)\n        i <span class=\"pl-k\">=</span> tf.constant(<span class=\"pl-c1\">0</span>)\n        <span class=\"pl-k\">def</span> <span class=\"pl-en\">body</span>(<span class=\"pl-smi\">i</span>, <span class=\"pl-smi\">arr</span>):\n            arr <span class=\"pl-k\">=</span> arr.write(i, func(nums))\n            <span class=\"pl-k\">return</span> i<span class=\"pl-k\">+</span><span class=\"pl-c1\">1</span>, arr\n        i, arr <span class=\"pl-k\">=</span> tf.while_loop(\n            <span class=\"pl-v\">cond</span><span class=\"pl-k\">=</span><span class=\"pl-k\">lambda</span> <span class=\"pl-smi\">i</span>, <span class=\"pl-smi\">x</span>: i <span class=\"pl-k\">&lt;</span> <span class=\"pl-c1\">1</span>,\n            <span class=\"pl-v\">body</span><span class=\"pl-k\">=</span>body,\n            <span class=\"pl-v\">loop_vars</span><span class=\"pl-k\">=</span>[i, arr],\n            <span class=\"pl-v\">parallel_iterations</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">1</span>)\n        dot_product <span class=\"pl-k\">=</span> arr.read(<span class=\"pl-c1\">0</span>)\n    <span class=\"pl-k\">with</span> tf.Session(<span class=\"pl-v\">graph</span><span class=\"pl-k\">=</span>graph) <span class=\"pl-k\">as</span> sess:\n        sess.run(dot_product)\n        t1 <span class=\"pl-k\">=</span> default_timer()\n        <span class=\"pl-k\">for</span> i <span class=\"pl-k\">in</span> <span class=\"pl-c1\">range</span>(<span class=\"pl-c1\">10</span>):\n            sess.run(dot_product)\n        <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>V2 timing: <span class=\"pl-c1\">{}</span> / run 10 runs<span class=\"pl-pds\">\"</span></span>.format((default_timer() <span class=\"pl-k\">-</span> t1)<span class=\"pl-k\">/</span><span class=\"pl-c1\">10</span>.))\n\n        profiler <span class=\"pl-k\">=</span> tf.profiler.Profiler(sess.graph)\n        run_meta <span class=\"pl-k\">=</span> tf.RunMetadata()\n        sess.run(dot_product,\n                <span class=\"pl-v\">options</span> <span class=\"pl-k\">=</span> tf.RunOptions(<span class=\"pl-v\">trace_level</span> <span class=\"pl-k\">=</span> tf.RunOptions.<span class=\"pl-c1\">FULL_TRACE</span>),\n                <span class=\"pl-v\">run_metadata</span> <span class=\"pl-k\">=</span> run_meta)\n        profiler.add_step(<span class=\"pl-c1\">0</span>,run_meta)\n        opts <span class=\"pl-k\">=</span> (tf.profiler.ProfileOptionBuilder(\n                 tf.profiler.ProfileOptionBuilder.time_and_memory())\n                 .with_step(<span class=\"pl-c1\">0</span>)\n                 .with_timeline_output(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>timeline_v2_<span class=\"pl-c1\">{}</span><span class=\"pl-pds\">'</span></span>.format(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>random<span class=\"pl-pds\">'</span></span> <span class=\"pl-k\">if</span> random <span class=\"pl-k\">else</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>const<span class=\"pl-pds\">'</span></span>)).build())\n        profiler.profile_graph(<span class=\"pl-v\">options</span><span class=\"pl-k\">=</span>opts)\n\n<span class=\"pl-k\">if</span> <span class=\"pl-c1\">__name__</span> <span class=\"pl-k\">==</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>__main__<span class=\"pl-pds\">'</span></span>:\n    v1(<span class=\"pl-c1\">False</span>)\n    v2(<span class=\"pl-c1\">False</span>)\n    v1(<span class=\"pl-c1\">True</span>)\n    v2(<span class=\"pl-c1\">True</span>)</pre></div>", "body_text": "So I ran sess.run first and then 10 runs in a timing loop with the constant variable, and also with a random variable. I also created a profile timeline for each.\nConstant:\nV1 timing: 0.00014590219943784178 / run 10 runs\nV2 timing: 0.2790762079996057 / run 10 runs\nRandom:\nV1 timing: 1.2271329755021725 / run 10 runs\nV2 timing: 1.209720030199969 / run 10 runs\nSo it seems while loop is slower as expected after initial graph run.\nimport tensorflow as tf\nfrom timeit import default_timer\n\ndef func(nums):\n    return tf.reduce_sum(tf.multiply(tf.add(nums,1), nums))\n\ndef v1(random=False):\n    graph = tf.Graph()\n    with graph.as_default(), tf.device('/cpu:0'):\n        if random:\n            nums = tf.random_normal(shape=(200000000,),dtype=tf.float32)\n        else:\n            nums = tf.range(200000000, dtype=tf.float32)\n        dot_product = func(nums)\n    with tf.Session(graph=graph) as sess:\n        sess.run(dot_product)\n        t1 = default_timer()\n        for i in range(10):\n            sess.run(dot_product)\n        print(\"V1 timing: {} / run 10 runs\".format((default_timer() - t1)/10.))\n\n        profiler = tf.profiler.Profiler(sess.graph)\n        run_meta = tf.RunMetadata()\n        sess.run(dot_product,\n                options = tf.RunOptions(trace_level = tf.RunOptions.FULL_TRACE),\n                run_metadata = run_meta)\n        profiler.add_step(0,run_meta)\n        opts = (tf.profiler.ProfileOptionBuilder(\n                 tf.profiler.ProfileOptionBuilder.time_and_memory())\n                 .with_step(0)\n                 .with_timeline_output('timeline_v1_{}'.format('random' if random else 'const')).build())\n        profiler.profile_graph(options=opts)\n\n\n\ndef v2(random=False):\n    graph = tf.Graph()\n    with graph.as_default(), tf.device('/cpu:0'):\n        arr = tf.TensorArray(size=1, dtype=tf.float32)\n        if random:\n            nums = tf.random_normal(shape=(200000000,),dtype=tf.float32)\n        else:\n            nums = tf.range(200000000, dtype=tf.float32)\n        i = tf.constant(0)\n        def body(i, arr):\n            arr = arr.write(i, func(nums))\n            return i+1, arr\n        i, arr = tf.while_loop(\n            cond=lambda i, x: i < 1,\n            body=body,\n            loop_vars=[i, arr],\n            parallel_iterations=1)\n        dot_product = arr.read(0)\n    with tf.Session(graph=graph) as sess:\n        sess.run(dot_product)\n        t1 = default_timer()\n        for i in range(10):\n            sess.run(dot_product)\n        print(\"V2 timing: {} / run 10 runs\".format((default_timer() - t1)/10.))\n\n        profiler = tf.profiler.Profiler(sess.graph)\n        run_meta = tf.RunMetadata()\n        sess.run(dot_product,\n                options = tf.RunOptions(trace_level = tf.RunOptions.FULL_TRACE),\n                run_metadata = run_meta)\n        profiler.add_step(0,run_meta)\n        opts = (tf.profiler.ProfileOptionBuilder(\n                 tf.profiler.ProfileOptionBuilder.time_and_memory())\n                 .with_step(0)\n                 .with_timeline_output('timeline_v2_{}'.format('random' if random else 'const')).build())\n        profiler.profile_graph(options=opts)\n\nif __name__ == '__main__':\n    v1(False)\n    v2(False)\n    v1(True)\n    v2(True)", "body": "So I ran sess.run first and then 10 runs in a timing loop with the constant variable, and also with a random variable. I also created a profile timeline for each.\r\n\r\nConstant:\r\nV1 timing: 0.00014590219943784178 / run 10 runs\r\nV2 timing: 0.2790762079996057 / run 10 runs\r\n\r\nRandom:\r\nV1 timing: 1.2271329755021725 / run 10 runs\r\nV2 timing: 1.209720030199969 / run 10 runs\r\n\r\nSo it seems while loop is slower as expected after initial graph run.\r\n\r\n``` python\r\nimport tensorflow as tf\r\nfrom timeit import default_timer\r\n\r\ndef func(nums):\r\n    return tf.reduce_sum(tf.multiply(tf.add(nums,1), nums))\r\n\r\ndef v1(random=False):\r\n    graph = tf.Graph()\r\n    with graph.as_default(), tf.device('/cpu:0'):\r\n        if random:\r\n            nums = tf.random_normal(shape=(200000000,),dtype=tf.float32)\r\n        else:\r\n            nums = tf.range(200000000, dtype=tf.float32)\r\n        dot_product = func(nums)\r\n    with tf.Session(graph=graph) as sess:\r\n        sess.run(dot_product)\r\n        t1 = default_timer()\r\n        for i in range(10):\r\n            sess.run(dot_product)\r\n        print(\"V1 timing: {} / run 10 runs\".format((default_timer() - t1)/10.))\r\n\r\n        profiler = tf.profiler.Profiler(sess.graph)\r\n        run_meta = tf.RunMetadata()\r\n        sess.run(dot_product,\r\n                options = tf.RunOptions(trace_level = tf.RunOptions.FULL_TRACE),\r\n                run_metadata = run_meta)\r\n        profiler.add_step(0,run_meta)\r\n        opts = (tf.profiler.ProfileOptionBuilder(\r\n                 tf.profiler.ProfileOptionBuilder.time_and_memory())\r\n                 .with_step(0)\r\n                 .with_timeline_output('timeline_v1_{}'.format('random' if random else 'const')).build())\r\n        profiler.profile_graph(options=opts)\r\n\r\n\r\n\r\ndef v2(random=False):\r\n    graph = tf.Graph()\r\n    with graph.as_default(), tf.device('/cpu:0'):\r\n        arr = tf.TensorArray(size=1, dtype=tf.float32)\r\n        if random:\r\n            nums = tf.random_normal(shape=(200000000,),dtype=tf.float32)\r\n        else:\r\n            nums = tf.range(200000000, dtype=tf.float32)\r\n        i = tf.constant(0)\r\n        def body(i, arr):\r\n            arr = arr.write(i, func(nums))\r\n            return i+1, arr\r\n        i, arr = tf.while_loop(\r\n            cond=lambda i, x: i < 1,\r\n            body=body,\r\n            loop_vars=[i, arr],\r\n            parallel_iterations=1)\r\n        dot_product = arr.read(0)\r\n    with tf.Session(graph=graph) as sess:\r\n        sess.run(dot_product)\r\n        t1 = default_timer()\r\n        for i in range(10):\r\n            sess.run(dot_product)\r\n        print(\"V2 timing: {} / run 10 runs\".format((default_timer() - t1)/10.))\r\n\r\n        profiler = tf.profiler.Profiler(sess.graph)\r\n        run_meta = tf.RunMetadata()\r\n        sess.run(dot_product,\r\n                options = tf.RunOptions(trace_level = tf.RunOptions.FULL_TRACE),\r\n                run_metadata = run_meta)\r\n        profiler.add_step(0,run_meta)\r\n        opts = (tf.profiler.ProfileOptionBuilder(\r\n                 tf.profiler.ProfileOptionBuilder.time_and_memory())\r\n                 .with_step(0)\r\n                 .with_timeline_output('timeline_v2_{}'.format('random' if random else 'const')).build())\r\n        profiler.profile_graph(options=opts)\r\n\r\nif __name__ == '__main__':\r\n    v1(False)\r\n    v2(False)\r\n    v1(True)\r\n    v2(True)\r\n```"}