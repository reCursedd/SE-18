{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/376606731", "html_url": "https://github.com/tensorflow/tensorflow/issues/17930#issuecomment-376606731", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/17930", "id": 376606731, "node_id": "MDEyOklzc3VlQ29tbWVudDM3NjYwNjczMQ==", "user": {"login": "asimshankar", "id": 16018, "node_id": "MDQ6VXNlcjE2MDE4", "avatar_url": "https://avatars2.githubusercontent.com/u/16018?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asimshankar", "html_url": "https://github.com/asimshankar", "followers_url": "https://api.github.com/users/asimshankar/followers", "following_url": "https://api.github.com/users/asimshankar/following{/other_user}", "gists_url": "https://api.github.com/users/asimshankar/gists{/gist_id}", "starred_url": "https://api.github.com/users/asimshankar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asimshankar/subscriptions", "organizations_url": "https://api.github.com/users/asimshankar/orgs", "repos_url": "https://api.github.com/users/asimshankar/repos", "events_url": "https://api.github.com/users/asimshankar/events{/privacy}", "received_events_url": "https://api.github.com/users/asimshankar/received_events", "type": "User", "site_admin": false}, "created_at": "2018-03-27T17:23:28Z", "updated_at": "2018-03-27T17:23:28Z", "author_association": "MEMBER", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=5429005\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/chrisrsipes\">@chrisrsipes</a> : Ah, sorry, I think I misunderstood the problem. If I understand correctly, you're <em>not</em> claiming that there is a memory leak in that the total memory footprint keeps on increasing and eventually the process runs out of memory. Instead, you're pointing out that the virtual memory size and the resident set size of the process does not decrease. Correct?</p>\n<p>If so, that is intended behavior. This happens because the TensorFlow runtime's memory allocator (e.g., <a href=\"http://jemalloc.net\" rel=\"nofollow\">jemalloc</a> on some platforms) may manage memory allocations itself. In other words, it can allocate memory from the system and instead of returning it, can keep it around for future allocations. Which is why, even though the VM size and RSS don't go down after you call <code>close()</code>, it doesn't go up on the next iteration either (since the allocator is re-using that memory).</p>\n<p>Let me know if I understood correctly.<br>\nThanks.</p>", "body_text": "@chrisrsipes : Ah, sorry, I think I misunderstood the problem. If I understand correctly, you're not claiming that there is a memory leak in that the total memory footprint keeps on increasing and eventually the process runs out of memory. Instead, you're pointing out that the virtual memory size and the resident set size of the process does not decrease. Correct?\nIf so, that is intended behavior. This happens because the TensorFlow runtime's memory allocator (e.g., jemalloc on some platforms) may manage memory allocations itself. In other words, it can allocate memory from the system and instead of returning it, can keep it around for future allocations. Which is why, even though the VM size and RSS don't go down after you call close(), it doesn't go up on the next iteration either (since the allocator is re-using that memory).\nLet me know if I understood correctly.\nThanks.", "body": "@chrisrsipes : Ah, sorry, I think I misunderstood the problem. If I understand correctly, you're _not_ claiming that there is a memory leak in that the total memory footprint keeps on increasing and eventually the process runs out of memory. Instead, you're pointing out that the virtual memory size and the resident set size of the process does not decrease. Correct?\r\n\r\nIf so, that is intended behavior. This happens because the TensorFlow runtime's memory allocator (e.g., [jemalloc](http://jemalloc.net) on some platforms) may manage memory allocations itself. In other words, it can allocate memory from the system and instead of returning it, can keep it around for future allocations. Which is why, even though the VM size and RSS don't go down after you call `close()`, it doesn't go up on the next iteration either (since the allocator is re-using that memory).\r\n\r\nLet me know if I understood correctly.\r\nThanks."}