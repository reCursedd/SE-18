{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/7902", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/7902/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/7902/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/7902/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/7902", "id": 210332399, "node_id": "MDU6SXNzdWUyMTAzMzIzOTk=", "number": 7902, "title": "Periodically evaluating on a validation set", "user": {"login": "varunkumar3618", "id": 9327561, "node_id": "MDQ6VXNlcjkzMjc1NjE=", "avatar_url": "https://avatars0.githubusercontent.com/u/9327561?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varunkumar3618", "html_url": "https://github.com/varunkumar3618", "followers_url": "https://api.github.com/users/varunkumar3618/followers", "following_url": "https://api.github.com/users/varunkumar3618/following{/other_user}", "gists_url": "https://api.github.com/users/varunkumar3618/gists{/gist_id}", "starred_url": "https://api.github.com/users/varunkumar3618/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varunkumar3618/subscriptions", "organizations_url": "https://api.github.com/users/varunkumar3618/orgs", "repos_url": "https://api.github.com/users/varunkumar3618/repos", "events_url": "https://api.github.com/users/varunkumar3618/events{/privacy}", "received_events_url": "https://api.github.com/users/varunkumar3618/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 8, "created_at": "2017-02-26T17:13:36Z", "updated_at": "2017-12-21T14:46:48Z", "closed_at": "2017-03-01T00:28:26Z", "author_association": "NONE", "body_html": "<p>A common training pattern is to run an epoch, or a few epochs, of training and then evaluate on a development set. As far as I can tell, there does not seem to be an easy way to do this while also using the TFRecords format. While it is possible to run through a data split by setting the num_epochs parameter in the functions to read in single examples, doing so would require the computation graph to be rebuilt before every validation phase. Instead, it would be preferable to have a symbolic example that could be reset to the beginning of the dataset using a related operation.</p>\n<p>I feel that the above pattern is sufficiently widely used to make a new feature worthwhile. Further, having control over the number of epochs also becomes important when trying to replicate the performance numbers of other implementations.</p>\n<h4></h4>\n<p>The same training-validation pattern using feed dicts:<br>\nfor epoch in num_epochs:<br>\nfor batch in get_batches(train, epoch):<br>\nsess.run(train_op, feed_dict={\"batch\": batch)<br>\nnum_correct, total = 0, 0<br>\nfor batch in get_batches(val, epoch):<br>\nacc = sess.run(acc_op, feed_dict={\"batch\", batch)<br>\ntotal += batch.shape[0]<br>\nnum_correct += batch.shape[0] * acc<br>\nprint \"Dev accuracy after %s epochs: %s\" % (epoch + 1, num_correct / total)</p>", "body_text": "A common training pattern is to run an epoch, or a few epochs, of training and then evaluate on a development set. As far as I can tell, there does not seem to be an easy way to do this while also using the TFRecords format. While it is possible to run through a data split by setting the num_epochs parameter in the functions to read in single examples, doing so would require the computation graph to be rebuilt before every validation phase. Instead, it would be preferable to have a symbolic example that could be reset to the beginning of the dataset using a related operation.\nI feel that the above pattern is sufficiently widely used to make a new feature worthwhile. Further, having control over the number of epochs also becomes important when trying to replicate the performance numbers of other implementations.\n\nThe same training-validation pattern using feed dicts:\nfor epoch in num_epochs:\nfor batch in get_batches(train, epoch):\nsess.run(train_op, feed_dict={\"batch\": batch)\nnum_correct, total = 0, 0\nfor batch in get_batches(val, epoch):\nacc = sess.run(acc_op, feed_dict={\"batch\", batch)\ntotal += batch.shape[0]\nnum_correct += batch.shape[0] * acc\nprint \"Dev accuracy after %s epochs: %s\" % (epoch + 1, num_correct / total)", "body": "A common training pattern is to run an epoch, or a few epochs, of training and then evaluate on a development set. As far as I can tell, there does not seem to be an easy way to do this while also using the TFRecords format. While it is possible to run through a data split by setting the num_epochs parameter in the functions to read in single examples, doing so would require the computation graph to be rebuilt before every validation phase. Instead, it would be preferable to have a symbolic example that could be reset to the beginning of the dataset using a related operation.\r\n\r\nI feel that the above pattern is sufficiently widely used to make a new feature worthwhile. Further, having control over the number of epochs also becomes important when trying to replicate the performance numbers of other implementations.\r\n\r\n####\r\nThe same training-validation pattern using feed dicts:\r\nfor epoch in num_epochs:\r\n  for batch in get_batches(train, epoch):\r\n    sess.run(train_op, feed_dict={\"batch\": batch)\r\n  num_correct, total = 0, 0\r\n  for batch in get_batches(val, epoch):\r\n    acc = sess.run(acc_op, feed_dict={\"batch\", batch)\r\n    total += batch.shape[0]\r\n    num_correct += batch.shape[0] * acc\r\n  print \"Dev accuracy after %s epochs: %s\" % (epoch + 1, num_correct / total)"}