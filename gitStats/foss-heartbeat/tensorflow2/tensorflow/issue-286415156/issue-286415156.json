{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/15891", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/15891/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/15891/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/15891/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/15891", "id": 286415156, "node_id": "MDU6SXNzdWUyODY0MTUxNTY=", "number": 15891, "title": "Dependencies of tensors created within a tf.while_loop() might not be executed", "user": {"login": "ghost", "id": 10137, "node_id": "MDQ6VXNlcjEwMTM3", "avatar_url": "https://avatars3.githubusercontent.com/u/10137?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ghost", "html_url": "https://github.com/ghost", "followers_url": "https://api.github.com/users/ghost/followers", "following_url": "https://api.github.com/users/ghost/following{/other_user}", "gists_url": "https://api.github.com/users/ghost/gists{/gist_id}", "starred_url": "https://api.github.com/users/ghost/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ghost/subscriptions", "organizations_url": "https://api.github.com/users/ghost/orgs", "repos_url": "https://api.github.com/users/ghost/repos", "events_url": "https://api.github.com/users/ghost/events{/privacy}", "received_events_url": "https://api.github.com/users/ghost/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 404586594, "node_id": "MDU6TGFiZWw0MDQ1ODY1OTQ=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:awaiting%20tensorflower", "name": "stat:awaiting tensorflower", "color": "f4b400", "default": false}, {"id": 473172988, "node_id": "MDU6TGFiZWw0NzMxNzI5ODg=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:bug/performance", "name": "type:bug/performance", "color": "159b2e", "default": false}], "state": "closed", "locked": false, "assignee": {"login": "skye", "id": 88808, "node_id": "MDQ6VXNlcjg4ODA4", "avatar_url": "https://avatars1.githubusercontent.com/u/88808?v=4", "gravatar_id": "", "url": "https://api.github.com/users/skye", "html_url": "https://github.com/skye", "followers_url": "https://api.github.com/users/skye/followers", "following_url": "https://api.github.com/users/skye/following{/other_user}", "gists_url": "https://api.github.com/users/skye/gists{/gist_id}", "starred_url": "https://api.github.com/users/skye/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/skye/subscriptions", "organizations_url": "https://api.github.com/users/skye/orgs", "repos_url": "https://api.github.com/users/skye/repos", "events_url": "https://api.github.com/users/skye/events{/privacy}", "received_events_url": "https://api.github.com/users/skye/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "skye", "id": 88808, "node_id": "MDQ6VXNlcjg4ODA4", "avatar_url": "https://avatars1.githubusercontent.com/u/88808?v=4", "gravatar_id": "", "url": "https://api.github.com/users/skye", "html_url": "https://github.com/skye", "followers_url": "https://api.github.com/users/skye/followers", "following_url": "https://api.github.com/users/skye/following{/other_user}", "gists_url": "https://api.github.com/users/skye/gists{/gist_id}", "starred_url": "https://api.github.com/users/skye/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/skye/subscriptions", "organizations_url": "https://api.github.com/users/skye/orgs", "repos_url": "https://api.github.com/users/skye/repos", "events_url": "https://api.github.com/users/skye/events{/privacy}", "received_events_url": "https://api.github.com/users/skye/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 12, "created_at": "2018-01-05T21:51:29Z", "updated_at": "2018-02-06T18:29:02Z", "closed_at": "2018-02-06T18:29:02Z", "author_association": "NONE", "body_html": "<h3>System information</h3>\n<ul>\n<li><strong>Have I written custom code (as opposed to using a stock example script provided in TensorFlow)</strong>: Yes. See test case below.</li>\n<li><strong>OS Platform and Distribution (e.g., Linux Ubuntu 16.04)</strong>: macOS 'Sierra' Version 10.12.6 (16G1114)</li>\n<li><strong>TensorFlow installed from (source or binary)</strong>: Both. I have compiled TensorFlow at <a class=\"commit-link\" data-hovercard-type=\"commit\" data-hovercard-url=\"https://github.com/tensorflow/tensorflow/commit/136697ecdc64b5171522fb7f89cfe51a02f0f1c1/hovercard\" href=\"https://github.com/tensorflow/tensorflow/commit/136697ecdc64b5171522fb7f89cfe51a02f0f1c1\"><tt>136697e</tt></a> with my small change in PR <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"285802795\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/tensorflow/tensorflow/issues/15823\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/tensorflow/tensorflow/pull/15823/hovercard\" href=\"https://github.com/tensorflow/tensorflow/pull/15823\">#15823</a>. I have also tried using the pip package.</li>\n<li><strong>TensorFlow version (use command below)</strong>: ('v1.4.0-19-ga52c8d9b01', '1.4.1') (pip package)</li>\n<li><strong>Python version</strong>: 2.7.10</li>\n<li><strong>Bazel version (if compiling from source)</strong>: 0.9.0-homebrew</li>\n<li><strong>GCC/Compiler version (if compiling from source)</strong>: Apple LLVM version 8.1.0 (clang-802.0.42)</li>\n<li><strong>CUDA/cuDNN version</strong>: CUDA 9.0.176_mac, cuDNN 9.0-osx-x64-v7</li>\n<li><strong>GPU model and memory</strong>: NVIDIA GeForce GT 750M with 2048 MB device memory (CUDA Compute Capability 3.0)</li>\n<li><strong>Exact command to reproduce</strong>:</li>\n</ul>\n<p><code>python repro.py</code></p>\n<p>.. where <code>repro.py</code> contains the test case to reproduce, listed below.</p>\n<h3>Describe the problem</h3>\n<p>Here is my test case:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-c\"><span class=\"pl-c\">#</span> Part I</span>\n<span class=\"pl-k\">from</span> <span class=\"pl-c1\">__future__</span> <span class=\"pl-k\">import</span> division, print_function\n<span class=\"pl-k\">import</span> numpy <span class=\"pl-k\">as</span> np\n<span class=\"pl-k\">import</span> tensorflow <span class=\"pl-k\">as</span> tf\n<span class=\"pl-k\">from</span> tensorflow.python.ops <span class=\"pl-k\">import</span> resource_variable_ops <span class=\"pl-k\">as</span> rr\n\nrs <span class=\"pl-k\">=</span> np.random.RandomState(<span class=\"pl-v\">seed</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">2</span>)\nA <span class=\"pl-k\">=</span> rs.normal(<span class=\"pl-v\">size</span> <span class=\"pl-k\">=</span> (<span class=\"pl-c1\">10</span>, <span class=\"pl-c1\">10</span>,))\n<span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>singular values of A: <span class=\"pl-c1\">%s</span><span class=\"pl-pds\">'</span></span> <span class=\"pl-k\">%</span> (np.linalg.svd(A, <span class=\"pl-v\">compute_uv</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">False</span>),))\nB <span class=\"pl-k\">=</span> rs.normal(<span class=\"pl-v\">size</span> <span class=\"pl-k\">=</span> (<span class=\"pl-c1\">10</span>, <span class=\"pl-c1\">10</span>,))\n<span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>singular values of B: <span class=\"pl-c1\">%s</span><span class=\"pl-pds\">'</span></span> <span class=\"pl-k\">%</span> (np.linalg.svd(B, <span class=\"pl-v\">compute_uv</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">False</span>),))\n\n\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> Part II</span>\nA_var <span class=\"pl-k\">=</span> tf.Variable(B)\ninit_A_var_op <span class=\"pl-k\">=</span> tf.assign(A_var, A)\nA_dep <span class=\"pl-k\">=</span> tf.constant(<span class=\"pl-c1\">10</span>, tf.int32)\n\n<span class=\"pl-k\">with</span> tf.control_dependencies([init_A_var_op]):\n    A_dep <span class=\"pl-k\">=</span> A_dep <span class=\"pl-k\">+</span> <span class=\"pl-c1\">1</span>\n\n<span class=\"pl-k\">with</span> tf.control_dependencies([A_dep]):\n    var_s <span class=\"pl-k\">=</span> tf.svd(A_var, <span class=\"pl-v\">compute_uv</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">False</span>)\n<span class=\"pl-k\">with</span> tf.Session() <span class=\"pl-k\">as</span> session:\n    session.run(tf.global_variables_initializer())\n    computed_s, computed_A_dep <span class=\"pl-k\">=</span> session.run([var_s, A_dep])\n<span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>computed_s = <span class=\"pl-c1\">%s</span>, computed_A_dep = <span class=\"pl-c1\">%d</span><span class=\"pl-pds\">'</span></span> <span class=\"pl-k\">%</span> (computed_s, computed_A_dep,))\n\n\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> Part III</span>\nA_var <span class=\"pl-k\">=</span> tf.Variable(B)\ninit_A_var_op <span class=\"pl-k\">=</span> tf.assign(A_var, A)\nA_dep <span class=\"pl-k\">=</span> tf.constant(<span class=\"pl-c1\">9</span>, tf.int32)\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">loop_condition</span>(<span class=\"pl-smi\">j</span>, <span class=\"pl-smi\">A_dep</span>):\n    <span class=\"pl-k\">return</span> j <span class=\"pl-k\">&lt;</span> <span class=\"pl-c1\">1</span>\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">loop_body</span>(<span class=\"pl-smi\">j</span>, <span class=\"pl-smi\">A_dep</span>):\n    <span class=\"pl-k\">with</span> tf.control_dependencies([init_A_var_op]):\n        A_dep <span class=\"pl-k\">=</span> A_dep <span class=\"pl-k\">+</span> <span class=\"pl-c1\">1</span>\n    <span class=\"pl-k\">return</span> j <span class=\"pl-k\">+</span> <span class=\"pl-c1\">1</span>, A_dep\n\n_, A_dep <span class=\"pl-k\">=</span> tf.while_loop(loop_condition,\n                         loop_body,\n                         <span class=\"pl-v\">loop_vars</span> <span class=\"pl-k\">=</span> [tf.constant(<span class=\"pl-c1\">0</span>, tf.int32), A_dep],\n                         <span class=\"pl-v\">parallel_iterations</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">1</span>,\n                         <span class=\"pl-v\">back_prop</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">False</span>)\n\n<span class=\"pl-k\">with</span> tf.control_dependencies([A_dep]):\n    var_s <span class=\"pl-k\">=</span> tf.svd(A_var, <span class=\"pl-v\">compute_uv</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">False</span>)\n<span class=\"pl-k\">with</span> tf.Session() <span class=\"pl-k\">as</span> session:\n    session.run(tf.global_variables_initializer())\n    computed_s, computed_A_dep <span class=\"pl-k\">=</span> session.run([var_s, A_dep])\n<span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>computed_s = <span class=\"pl-c1\">%s</span>, computed_A_dep = <span class=\"pl-c1\">%d</span><span class=\"pl-pds\">'</span></span> <span class=\"pl-k\">%</span> (computed_s, computed_A_dep,))\n\n\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> Part IV</span>\nA_var <span class=\"pl-k\">=</span> rr.ResourceVariable(B)\ninit_A_var_op <span class=\"pl-k\">=</span> A_var.assign(A)\nA_dep <span class=\"pl-k\">=</span> tf.constant(<span class=\"pl-c1\">8</span>, tf.int32)\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">loop_condition</span>(<span class=\"pl-smi\">j</span>, <span class=\"pl-smi\">A_dep</span>):\n    <span class=\"pl-k\">return</span> j <span class=\"pl-k\">&lt;</span> <span class=\"pl-c1\">1</span>\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">loop_body</span>(<span class=\"pl-smi\">j</span>, <span class=\"pl-smi\">A_dep</span>):\n    <span class=\"pl-k\">with</span> tf.control_dependencies([init_A_var_op]):\n        A_dep <span class=\"pl-k\">=</span> A_dep <span class=\"pl-k\">+</span> <span class=\"pl-c1\">1</span>\n    <span class=\"pl-k\">return</span> j <span class=\"pl-k\">+</span> <span class=\"pl-c1\">1</span>, A_dep\n\n_, A_dep <span class=\"pl-k\">=</span> tf.while_loop(loop_condition,\n                         loop_body,\n                         <span class=\"pl-v\">loop_vars</span> <span class=\"pl-k\">=</span> [tf.constant(<span class=\"pl-c1\">0</span>, tf.int32), A_dep],\n                         <span class=\"pl-v\">parallel_iterations</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">1</span>,\n                         <span class=\"pl-v\">back_prop</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">False</span>)\n\n<span class=\"pl-k\">with</span> tf.control_dependencies([A_dep]):\n    var_s <span class=\"pl-k\">=</span> tf.svd(A_var.read_value(), <span class=\"pl-v\">compute_uv</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">False</span>)\n<span class=\"pl-k\">with</span> tf.Session() <span class=\"pl-k\">as</span> session:\n    session.run(tf.global_variables_initializer())\n    computed_s, computed_A_dep <span class=\"pl-k\">=</span> session.run([var_s, A_dep])\n<span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>computed_s = <span class=\"pl-c1\">%s</span>, computed_A_dep = <span class=\"pl-c1\">%d</span><span class=\"pl-pds\">'</span></span> <span class=\"pl-k\">%</span> (computed_s, computed_A_dep,))</pre></div>\n<p>Part I is basic setup. I create two random 10\u00d710 matrices and compute their singular values:</p>\n<pre>singular values of A: [ 5.65906715  4.9420261   4.40626739  3.73506125  2.70703249  2.57429488\n  1.73387162  1.16000494  0.58836563  0.39101954]\nsingular values of B: [ 7.0283055   4.65840063  4.48502098  3.25319445  2.94667168  2.74267484\n  1.86004291  1.6626967   0.63884034  0.27131664]\n</pre>\n<p>Part II shows usage of control_dependencies() to guarantee that <code>A</code> has been assigned to <code>A_var</code> before the singular values of <code>A_var</code> are computed. The output from this part is:</p>\n<pre>computed_s = [ 5.65906715  4.9420261   4.40626739  3.73506125  2.70703249  2.57429488\n  1.73387162  1.16000494  0.58836563  0.39101954], computed_A_dep = 11\n</pre>\n<p>(This is the expected result for Part II.)</p>\n<p>In Part III, I have introduced use of a tf.while_loop(). Now, tf.svd() is returning the singular values of <code>B</code>:</p>\n<pre>computed_s = [ 7.0283055   4.65840063  4.48502098  3.25319445  2.94667168  2.74267484\n  1.86004291  1.6626967   0.63884034  0.27131664], computed_A_dep = 10\n</pre>\n<p>(This is <strong>not</strong> the expected result for Part III. I expect that the singular values of <code>A</code> would be printed.)</p>\n<p>In Part IV, based on reading <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"180191179\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/tensorflow/tensorflow/issues/4663\" data-hovercard-type=\"issue\" data-hovercard-url=\"/tensorflow/tensorflow/issues/4663/hovercard?comment_id=336609536&amp;comment_type=issue_comment\" href=\"https://github.com/tensorflow/tensorflow/issues/4663#issuecomment-336609536\">#4663 (comment)</a> , I switched to using <code>ResourceVariable</code>. However, the output is still the same (the singular values of <code>B</code>):</p>\n<pre>computed_s = [ 7.0283055   4.65840063  4.48502098  3.25319445  2.94667168  2.74267484\n  1.86004291  1.6626967   0.63884034  0.27131664], computed_A_dep = 9\n</pre>\n<p>(This is <strong>not</strong> the expected result for Part IV. I expect that the singular values of <code>A</code> would be printed.)</p>\n<p>It appears the issue is that tf.control_dependencies() on tensors created by tf.while_loop() might not execute the tensors' own dependencies.</p>\n<p>This used to work okay (around TensorFlow 1.1, if I recall correctly).</p>\n<p>While searching for a previous report of this issue, I found <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"193534788\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/tensorflow/tensorflow/issues/6087\" data-hovercard-type=\"issue\" data-hovercard-url=\"/tensorflow/tensorflow/issues/6087/hovercard\" href=\"https://github.com/tensorflow/tensorflow/issues/6087\">#6087</a> which appears related, in that the sample code there has a tf.while_loop() that creates tensors with dependencies. When I run the sample code, I consistently get result = 10. This is an unexpected result, in my opinion. What is happening is that <code>update_x</code> runs exactly once, so for each of the 5 loop iterations, <code>x</code> has the value 2.</p>\n<p>I tried rewriting the sample code to use a ResourceVariable, but the output is the same:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">from</span> <span class=\"pl-c1\">__future__</span> <span class=\"pl-k\">import</span> division, print_function\n<span class=\"pl-k\">import</span> tensorflow <span class=\"pl-k\">as</span> tf\n<span class=\"pl-k\">from</span> tensorflow.python.ops <span class=\"pl-k\">import</span> resource_variable_ops <span class=\"pl-k\">as</span> rr\n\n<span class=\"pl-k\">with</span> tf.variable_scope(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>state<span class=\"pl-pds\">'</span></span>):\n    x <span class=\"pl-k\">=</span> rr.ResourceVariable(tf.constant(<span class=\"pl-c1\">1</span>, <span class=\"pl-v\">dtype</span><span class=\"pl-k\">=</span>tf.float32))\n    update_x <span class=\"pl-k\">=</span> x.assign(x.read_value() <span class=\"pl-k\">+</span> <span class=\"pl-c1\">1</span>)\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">iter_fun</span>(<span class=\"pl-smi\">i</span>, <span class=\"pl-smi\">y</span>):\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> comment the line below, the program will run without any error</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> but I need control_dependencies, or at least some way to replace it...</span>\n    <span class=\"pl-k\">with</span> tf.control_dependencies([update_x]):\n        y <span class=\"pl-k\">=</span> y <span class=\"pl-k\">+</span> tf.Print(x.read_value(), [<span class=\"pl-s\"><span class=\"pl-pds\">'</span>i = <span class=\"pl-pds\">'</span></span>, i, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>y = <span class=\"pl-pds\">'</span></span>, y, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>x = <span class=\"pl-pds\">'</span></span>, x.read_value()])\n    <span class=\"pl-k\">return</span> (i<span class=\"pl-k\">+</span><span class=\"pl-c1\">1</span>, y,)\n\n<span class=\"pl-k\">with</span> tf.variable_scope(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>iteration<span class=\"pl-pds\">'</span></span>):\n    num_iterations <span class=\"pl-k\">=</span> <span class=\"pl-c1\">5</span>\n    initial_i <span class=\"pl-k\">=</span> tf.constant(<span class=\"pl-c1\">0</span>, <span class=\"pl-v\">dtype</span><span class=\"pl-k\">=</span>tf.int32)\n    initial_y <span class=\"pl-k\">=</span> tf.constant(<span class=\"pl-c1\">0</span>, <span class=\"pl-v\">dtype</span><span class=\"pl-k\">=</span>tf.float32)\n    _, result <span class=\"pl-k\">=</span> tf.while_loop(\n        <span class=\"pl-v\">cond</span><span class=\"pl-k\">=</span><span class=\"pl-k\">lambda</span> <span class=\"pl-smi\">i</span>, <span class=\"pl-k\">*</span><span class=\"pl-smi\">_</span>: i <span class=\"pl-k\">&lt;</span> num_iterations,\n        <span class=\"pl-v\">body</span><span class=\"pl-k\">=</span>iter_fun,\n        <span class=\"pl-v\">loop_vars</span><span class=\"pl-k\">=</span>(initial_i, initial_y))\n\ninit_op <span class=\"pl-k\">=</span> tf.global_variables_initializer()\n\n<span class=\"pl-k\">with</span> tf.Session() <span class=\"pl-k\">as</span> sess:\n    sess.run(init_op)\n    <span class=\"pl-c1\">print</span>(sess.run(result))</pre></div>", "body_text": "System information\n\nHave I written custom code (as opposed to using a stock example script provided in TensorFlow): Yes. See test case below.\nOS Platform and Distribution (e.g., Linux Ubuntu 16.04): macOS 'Sierra' Version 10.12.6 (16G1114)\nTensorFlow installed from (source or binary): Both. I have compiled TensorFlow at 136697e with my small change in PR #15823. I have also tried using the pip package.\nTensorFlow version (use command below): ('v1.4.0-19-ga52c8d9b01', '1.4.1') (pip package)\nPython version: 2.7.10\nBazel version (if compiling from source): 0.9.0-homebrew\nGCC/Compiler version (if compiling from source): Apple LLVM version 8.1.0 (clang-802.0.42)\nCUDA/cuDNN version: CUDA 9.0.176_mac, cuDNN 9.0-osx-x64-v7\nGPU model and memory: NVIDIA GeForce GT 750M with 2048 MB device memory (CUDA Compute Capability 3.0)\nExact command to reproduce:\n\npython repro.py\n.. where repro.py contains the test case to reproduce, listed below.\nDescribe the problem\nHere is my test case:\n# Part I\nfrom __future__ import division, print_function\nimport numpy as np\nimport tensorflow as tf\nfrom tensorflow.python.ops import resource_variable_ops as rr\n\nrs = np.random.RandomState(seed = 2)\nA = rs.normal(size = (10, 10,))\nprint('singular values of A: %s' % (np.linalg.svd(A, compute_uv = False),))\nB = rs.normal(size = (10, 10,))\nprint('singular values of B: %s' % (np.linalg.svd(B, compute_uv = False),))\n\n\n\n# Part II\nA_var = tf.Variable(B)\ninit_A_var_op = tf.assign(A_var, A)\nA_dep = tf.constant(10, tf.int32)\n\nwith tf.control_dependencies([init_A_var_op]):\n    A_dep = A_dep + 1\n\nwith tf.control_dependencies([A_dep]):\n    var_s = tf.svd(A_var, compute_uv = False)\nwith tf.Session() as session:\n    session.run(tf.global_variables_initializer())\n    computed_s, computed_A_dep = session.run([var_s, A_dep])\nprint('computed_s = %s, computed_A_dep = %d' % (computed_s, computed_A_dep,))\n\n\n\n# Part III\nA_var = tf.Variable(B)\ninit_A_var_op = tf.assign(A_var, A)\nA_dep = tf.constant(9, tf.int32)\n\ndef loop_condition(j, A_dep):\n    return j < 1\ndef loop_body(j, A_dep):\n    with tf.control_dependencies([init_A_var_op]):\n        A_dep = A_dep + 1\n    return j + 1, A_dep\n\n_, A_dep = tf.while_loop(loop_condition,\n                         loop_body,\n                         loop_vars = [tf.constant(0, tf.int32), A_dep],\n                         parallel_iterations = 1,\n                         back_prop = False)\n\nwith tf.control_dependencies([A_dep]):\n    var_s = tf.svd(A_var, compute_uv = False)\nwith tf.Session() as session:\n    session.run(tf.global_variables_initializer())\n    computed_s, computed_A_dep = session.run([var_s, A_dep])\nprint('computed_s = %s, computed_A_dep = %d' % (computed_s, computed_A_dep,))\n\n\n\n# Part IV\nA_var = rr.ResourceVariable(B)\ninit_A_var_op = A_var.assign(A)\nA_dep = tf.constant(8, tf.int32)\n\ndef loop_condition(j, A_dep):\n    return j < 1\ndef loop_body(j, A_dep):\n    with tf.control_dependencies([init_A_var_op]):\n        A_dep = A_dep + 1\n    return j + 1, A_dep\n\n_, A_dep = tf.while_loop(loop_condition,\n                         loop_body,\n                         loop_vars = [tf.constant(0, tf.int32), A_dep],\n                         parallel_iterations = 1,\n                         back_prop = False)\n\nwith tf.control_dependencies([A_dep]):\n    var_s = tf.svd(A_var.read_value(), compute_uv = False)\nwith tf.Session() as session:\n    session.run(tf.global_variables_initializer())\n    computed_s, computed_A_dep = session.run([var_s, A_dep])\nprint('computed_s = %s, computed_A_dep = %d' % (computed_s, computed_A_dep,))\nPart I is basic setup. I create two random 10\u00d710 matrices and compute their singular values:\nsingular values of A: [ 5.65906715  4.9420261   4.40626739  3.73506125  2.70703249  2.57429488\n  1.73387162  1.16000494  0.58836563  0.39101954]\nsingular values of B: [ 7.0283055   4.65840063  4.48502098  3.25319445  2.94667168  2.74267484\n  1.86004291  1.6626967   0.63884034  0.27131664]\n\nPart II shows usage of control_dependencies() to guarantee that A has been assigned to A_var before the singular values of A_var are computed. The output from this part is:\ncomputed_s = [ 5.65906715  4.9420261   4.40626739  3.73506125  2.70703249  2.57429488\n  1.73387162  1.16000494  0.58836563  0.39101954], computed_A_dep = 11\n\n(This is the expected result for Part II.)\nIn Part III, I have introduced use of a tf.while_loop(). Now, tf.svd() is returning the singular values of B:\ncomputed_s = [ 7.0283055   4.65840063  4.48502098  3.25319445  2.94667168  2.74267484\n  1.86004291  1.6626967   0.63884034  0.27131664], computed_A_dep = 10\n\n(This is not the expected result for Part III. I expect that the singular values of A would be printed.)\nIn Part IV, based on reading #4663 (comment) , I switched to using ResourceVariable. However, the output is still the same (the singular values of B):\ncomputed_s = [ 7.0283055   4.65840063  4.48502098  3.25319445  2.94667168  2.74267484\n  1.86004291  1.6626967   0.63884034  0.27131664], computed_A_dep = 9\n\n(This is not the expected result for Part IV. I expect that the singular values of A would be printed.)\nIt appears the issue is that tf.control_dependencies() on tensors created by tf.while_loop() might not execute the tensors' own dependencies.\nThis used to work okay (around TensorFlow 1.1, if I recall correctly).\nWhile searching for a previous report of this issue, I found #6087 which appears related, in that the sample code there has a tf.while_loop() that creates tensors with dependencies. When I run the sample code, I consistently get result = 10. This is an unexpected result, in my opinion. What is happening is that update_x runs exactly once, so for each of the 5 loop iterations, x has the value 2.\nI tried rewriting the sample code to use a ResourceVariable, but the output is the same:\nfrom __future__ import division, print_function\nimport tensorflow as tf\nfrom tensorflow.python.ops import resource_variable_ops as rr\n\nwith tf.variable_scope('state'):\n    x = rr.ResourceVariable(tf.constant(1, dtype=tf.float32))\n    update_x = x.assign(x.read_value() + 1)\n\ndef iter_fun(i, y):\n    # comment the line below, the program will run without any error\n    # but I need control_dependencies, or at least some way to replace it...\n    with tf.control_dependencies([update_x]):\n        y = y + tf.Print(x.read_value(), ['i = ', i, 'y = ', y, 'x = ', x.read_value()])\n    return (i+1, y,)\n\nwith tf.variable_scope('iteration'):\n    num_iterations = 5\n    initial_i = tf.constant(0, dtype=tf.int32)\n    initial_y = tf.constant(0, dtype=tf.float32)\n    _, result = tf.while_loop(\n        cond=lambda i, *_: i < num_iterations,\n        body=iter_fun,\n        loop_vars=(initial_i, initial_y))\n\ninit_op = tf.global_variables_initializer()\n\nwith tf.Session() as sess:\n    sess.run(init_op)\n    print(sess.run(result))", "body": "### System information\r\n- **Have I written custom code (as opposed to using a stock example script provided in TensorFlow)**: Yes. See test case below.\r\n- **OS Platform and Distribution (e.g., Linux Ubuntu 16.04)**: macOS 'Sierra' Version 10.12.6 (16G1114)\r\n- **TensorFlow installed from (source or binary)**: Both. I have compiled TensorFlow at 136697ecdc64b5171522fb7f89cfe51a02f0f1c1 with my small change in PR #15823. I have also tried using the pip package.\r\n- **TensorFlow version (use command below)**: ('v1.4.0-19-ga52c8d9b01', '1.4.1') (pip package)\r\n- **Python version**: 2.7.10\r\n- **Bazel version (if compiling from source)**: 0.9.0-homebrew\r\n- **GCC/Compiler version (if compiling from source)**: Apple LLVM version 8.1.0 (clang-802.0.42)\r\n- **CUDA/cuDNN version**: CUDA 9.0.176_mac, cuDNN 9.0-osx-x64-v7\r\n- **GPU model and memory**: NVIDIA GeForce GT 750M with 2048 MB device memory (CUDA Compute Capability 3.0)\r\n- **Exact command to reproduce**:\r\n\r\n`python repro.py`\r\n\r\n.. where `repro.py` contains the test case to reproduce, listed below.\r\n\r\n### Describe the problem\r\nHere is my test case:\r\n\r\n```python\r\n# Part I\r\nfrom __future__ import division, print_function\r\nimport numpy as np\r\nimport tensorflow as tf\r\nfrom tensorflow.python.ops import resource_variable_ops as rr\r\n\r\nrs = np.random.RandomState(seed = 2)\r\nA = rs.normal(size = (10, 10,))\r\nprint('singular values of A: %s' % (np.linalg.svd(A, compute_uv = False),))\r\nB = rs.normal(size = (10, 10,))\r\nprint('singular values of B: %s' % (np.linalg.svd(B, compute_uv = False),))\r\n\r\n\r\n\r\n# Part II\r\nA_var = tf.Variable(B)\r\ninit_A_var_op = tf.assign(A_var, A)\r\nA_dep = tf.constant(10, tf.int32)\r\n\r\nwith tf.control_dependencies([init_A_var_op]):\r\n    A_dep = A_dep + 1\r\n\r\nwith tf.control_dependencies([A_dep]):\r\n    var_s = tf.svd(A_var, compute_uv = False)\r\nwith tf.Session() as session:\r\n    session.run(tf.global_variables_initializer())\r\n    computed_s, computed_A_dep = session.run([var_s, A_dep])\r\nprint('computed_s = %s, computed_A_dep = %d' % (computed_s, computed_A_dep,))\r\n\r\n\r\n\r\n# Part III\r\nA_var = tf.Variable(B)\r\ninit_A_var_op = tf.assign(A_var, A)\r\nA_dep = tf.constant(9, tf.int32)\r\n\r\ndef loop_condition(j, A_dep):\r\n    return j < 1\r\ndef loop_body(j, A_dep):\r\n    with tf.control_dependencies([init_A_var_op]):\r\n        A_dep = A_dep + 1\r\n    return j + 1, A_dep\r\n\r\n_, A_dep = tf.while_loop(loop_condition,\r\n                         loop_body,\r\n                         loop_vars = [tf.constant(0, tf.int32), A_dep],\r\n                         parallel_iterations = 1,\r\n                         back_prop = False)\r\n\r\nwith tf.control_dependencies([A_dep]):\r\n    var_s = tf.svd(A_var, compute_uv = False)\r\nwith tf.Session() as session:\r\n    session.run(tf.global_variables_initializer())\r\n    computed_s, computed_A_dep = session.run([var_s, A_dep])\r\nprint('computed_s = %s, computed_A_dep = %d' % (computed_s, computed_A_dep,))\r\n\r\n\r\n\r\n# Part IV\r\nA_var = rr.ResourceVariable(B)\r\ninit_A_var_op = A_var.assign(A)\r\nA_dep = tf.constant(8, tf.int32)\r\n\r\ndef loop_condition(j, A_dep):\r\n    return j < 1\r\ndef loop_body(j, A_dep):\r\n    with tf.control_dependencies([init_A_var_op]):\r\n        A_dep = A_dep + 1\r\n    return j + 1, A_dep\r\n\r\n_, A_dep = tf.while_loop(loop_condition,\r\n                         loop_body,\r\n                         loop_vars = [tf.constant(0, tf.int32), A_dep],\r\n                         parallel_iterations = 1,\r\n                         back_prop = False)\r\n\r\nwith tf.control_dependencies([A_dep]):\r\n    var_s = tf.svd(A_var.read_value(), compute_uv = False)\r\nwith tf.Session() as session:\r\n    session.run(tf.global_variables_initializer())\r\n    computed_s, computed_A_dep = session.run([var_s, A_dep])\r\nprint('computed_s = %s, computed_A_dep = %d' % (computed_s, computed_A_dep,))\r\n```\r\n\r\nPart I is basic setup. I create two random 10&times;10 matrices and compute their singular values:\r\n<pre>\r\nsingular values of A: [ 5.65906715  4.9420261   4.40626739  3.73506125  2.70703249  2.57429488\r\n  1.73387162  1.16000494  0.58836563  0.39101954]\r\nsingular values of B: [ 7.0283055   4.65840063  4.48502098  3.25319445  2.94667168  2.74267484\r\n  1.86004291  1.6626967   0.63884034  0.27131664]\r\n</pre>\r\n\r\nPart II shows usage of control_dependencies() to guarantee that `A` has been assigned to `A_var` before the singular values of `A_var` are computed. The output from this part is:\r\n<pre>\r\ncomputed_s = [ 5.65906715  4.9420261   4.40626739  3.73506125  2.70703249  2.57429488\r\n  1.73387162  1.16000494  0.58836563  0.39101954], computed_A_dep = 11\r\n</pre>\r\n\r\n(This is the expected result for Part II.)\r\n\r\nIn Part III, I have introduced use of a tf.while_loop(). Now, tf.svd() is returning the singular values of `B`:\r\n<pre>\r\ncomputed_s = [ 7.0283055   4.65840063  4.48502098  3.25319445  2.94667168  2.74267484\r\n  1.86004291  1.6626967   0.63884034  0.27131664], computed_A_dep = 10\r\n</pre>\r\n\r\n(This is **not** the expected result for Part III. I expect that the singular values of `A` would be printed.)\r\n\r\nIn Part IV, based on reading https://github.com/tensorflow/tensorflow/issues/4663#issuecomment-336609536 , I switched to using `ResourceVariable`. However, the output is still the same (the singular values of `B`):\r\n<pre>\r\ncomputed_s = [ 7.0283055   4.65840063  4.48502098  3.25319445  2.94667168  2.74267484\r\n  1.86004291  1.6626967   0.63884034  0.27131664], computed_A_dep = 9\r\n</pre>\r\n\r\n(This is **not** the expected result for Part IV. I expect that the singular values of `A` would be printed.)\r\n\r\nIt appears the issue is that tf.control_dependencies() on tensors created by tf.while_loop() might not execute the tensors' own dependencies.\r\n\r\nThis used to work okay (around TensorFlow 1.1, if I recall correctly).\r\n\r\nWhile searching for a previous report of this issue, I found #6087 which appears related, in that the sample code there has a tf.while_loop() that creates tensors with dependencies. When I run the sample code, I consistently get result = 10. This is an unexpected result, in my opinion. What is happening is that `update_x` runs exactly once, so for each of the 5 loop iterations, `x` has the value 2.\r\n\r\nI tried rewriting the sample code to use a ResourceVariable, but the output is the same:\r\n\r\n```python\r\nfrom __future__ import division, print_function\r\nimport tensorflow as tf\r\nfrom tensorflow.python.ops import resource_variable_ops as rr\r\n\r\nwith tf.variable_scope('state'):\r\n    x = rr.ResourceVariable(tf.constant(1, dtype=tf.float32))\r\n    update_x = x.assign(x.read_value() + 1)\r\n\r\ndef iter_fun(i, y):\r\n    # comment the line below, the program will run without any error\r\n    # but I need control_dependencies, or at least some way to replace it...\r\n    with tf.control_dependencies([update_x]):\r\n        y = y + tf.Print(x.read_value(), ['i = ', i, 'y = ', y, 'x = ', x.read_value()])\r\n    return (i+1, y,)\r\n\r\nwith tf.variable_scope('iteration'):\r\n    num_iterations = 5\r\n    initial_i = tf.constant(0, dtype=tf.int32)\r\n    initial_y = tf.constant(0, dtype=tf.float32)\r\n    _, result = tf.while_loop(\r\n        cond=lambda i, *_: i < num_iterations,\r\n        body=iter_fun,\r\n        loop_vars=(initial_i, initial_y))\r\n\r\ninit_op = tf.global_variables_initializer()\r\n\r\nwith tf.Session() as sess:\r\n    sess.run(init_op)\r\n    print(sess.run(result))\r\n```\r\n  "}