{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/361460917", "html_url": "https://github.com/tensorflow/tensorflow/issues/15891#issuecomment-361460917", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/15891", "id": 361460917, "node_id": "MDEyOklzc3VlQ29tbWVudDM2MTQ2MDkxNw==", "user": {"login": "ghost", "id": 10137, "node_id": "MDQ6VXNlcjEwMTM3", "avatar_url": "https://avatars3.githubusercontent.com/u/10137?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ghost", "html_url": "https://github.com/ghost", "followers_url": "https://api.github.com/users/ghost/followers", "following_url": "https://api.github.com/users/ghost/following{/other_user}", "gists_url": "https://api.github.com/users/ghost/gists{/gist_id}", "starred_url": "https://api.github.com/users/ghost/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ghost/subscriptions", "organizations_url": "https://api.github.com/users/ghost/orgs", "repos_url": "https://api.github.com/users/ghost/repos", "events_url": "https://api.github.com/users/ghost/events{/privacy}", "received_events_url": "https://api.github.com/users/ghost/received_events", "type": "User", "site_admin": false}, "created_at": "2018-01-30T02:56:02Z", "updated_at": "2018-01-30T02:56:02Z", "author_association": "NONE", "body_html": "<p>Looking at the graph def, it looks like no node has control input \"^init_A_var_op\".</p>\n<p>Contrasting that with the following working script\u2014which does not use a tf.while_loop()\u2014the \"increment_A_dep/y\" node corresponding to the const second argument to the \"increment_A_dep\" tf.add() op has control input \"^init_A_var_op\":</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">from</span> <span class=\"pl-c1\">__future__</span> <span class=\"pl-k\">import</span> division, print_function\n<span class=\"pl-k\">import</span> numpy <span class=\"pl-k\">as</span> np\n<span class=\"pl-k\">import</span> tensorflow <span class=\"pl-k\">as</span> tf\n\nrs <span class=\"pl-k\">=</span> np.random.RandomState(<span class=\"pl-v\">seed</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">2</span>)\nA <span class=\"pl-k\">=</span> rs.normal(<span class=\"pl-v\">size</span> <span class=\"pl-k\">=</span> (<span class=\"pl-c1\">10</span>, <span class=\"pl-c1\">10</span>,))\n<span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>singular values of A: <span class=\"pl-c1\">%s</span><span class=\"pl-pds\">'</span></span> <span class=\"pl-k\">%</span> (np.linalg.svd(A, <span class=\"pl-v\">compute_uv</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">False</span>),))\nB <span class=\"pl-k\">=</span> rs.normal(<span class=\"pl-v\">size</span> <span class=\"pl-k\">=</span> (<span class=\"pl-c1\">10</span>, <span class=\"pl-c1\">10</span>,))\n<span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>singular values of B: <span class=\"pl-c1\">%s</span><span class=\"pl-pds\">'</span></span> <span class=\"pl-k\">%</span> (np.linalg.svd(B, <span class=\"pl-v\">compute_uv</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">False</span>),))\n\ngraph <span class=\"pl-k\">=</span> tf.Graph()\n<span class=\"pl-k\">with</span> graph.as_default():\n    A_var <span class=\"pl-k\">=</span> tf.Variable(B, <span class=\"pl-v\">name</span> <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>A_var<span class=\"pl-pds\">'</span></span>)\n    init_A_var_op <span class=\"pl-k\">=</span> tf.assign(A_var, A, <span class=\"pl-v\">name</span> <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>init_A_var_op<span class=\"pl-pds\">'</span></span>)\n    A_dep <span class=\"pl-k\">=</span> tf.constant(<span class=\"pl-c1\">9</span>, tf.int32, <span class=\"pl-v\">name</span> <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>initial_A_dep<span class=\"pl-pds\">'</span></span>)\n\n    <span class=\"pl-k\">with</span> tf.control_dependencies([init_A_var_op]):\n        A_dep <span class=\"pl-k\">=</span> tf.add(A_dep, <span class=\"pl-c1\">1</span>, <span class=\"pl-v\">name</span> <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>increment_A_dep<span class=\"pl-pds\">'</span></span>)\n\n    <span class=\"pl-k\">with</span> tf.control_dependencies([A_dep]):\n        var_s <span class=\"pl-k\">=</span> tf.svd(A_var, <span class=\"pl-v\">compute_uv</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">False</span>)\n\n<span class=\"pl-c1\">print</span>(graph.as_graph_def())\n\n<span class=\"pl-k\">with</span> tf.Session(<span class=\"pl-v\">graph</span> <span class=\"pl-k\">=</span> graph) <span class=\"pl-k\">as</span> session:\n    session.run(tf.global_variables_initializer())\n    computed_A_dep, computed_s, computed_A_dep2 <span class=\"pl-k\">=</span> session.run([A_dep, var_s, A_dep])\n    <span class=\"pl-k\">assert</span> computed_A_dep <span class=\"pl-k\">==</span> computed_A_dep2\n<span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>computed_s = <span class=\"pl-c1\">%s</span>, computed_A_dep = <span class=\"pl-c1\">%d</span><span class=\"pl-pds\">'</span></span> <span class=\"pl-k\">%</span> (computed_s, computed_A_dep,))</pre></div>\n<p>Here is an excerpt from the working script's graph def:</p>\n<pre><code>node {\n  name: \"initial_A_dep\"\n  op: \"Const\"\n  attr {\n    key: \"dtype\"\n    value {\n      type: DT_INT32\n    }\n  }\n  attr {\n    key: \"value\"\n    value {\n      tensor {\n        dtype: DT_INT32\n        tensor_shape {\n        }\n        int_val: 9\n      }\n    }\n  }\n}\nnode {\n  name: \"increment_A_dep/y\"\n  op: \"Const\"\n  input: \"^init_A_var_op\"\n  attr {\n    key: \"dtype\"\n    value {\n      type: DT_INT32\n    }\n  }\n  attr {\n    key: \"value\"\n    value {\n      tensor {\n        dtype: DT_INT32\n        tensor_shape {\n        }\n        int_val: 1\n      }\n    }\n  }\n}\nnode {\n  name: \"increment_A_dep\"\n  op: \"Add\"\n  input: \"initial_A_dep\"\n  input: \"increment_A_dep/y\"\n  attr {\n    key: \"T\"\n    value {\n      type: DT_INT32\n    }\n  }\n}\nnode {\n  name: \"Svd\"\n  op: \"Svd\"\n  input: \"A_var/read\"\n  input: \"^increment_A_dep\"\n  attr {\n    key: \"T\"\n    value {\n      type: DT_DOUBLE\n    }\n  }\n  attr {\n    key: \"compute_uv\"\n    value {\n      b: false\n    }\n  }\n  attr {\n    key: \"full_matrices\"\n    value {\n      b: false\n    }\n  }\n}\n</code></pre>\n<p>The non-working graph's \"while/increment_A_dep/y\" node has control input \"^while/Identity\" but not \"^init_A_var_op\".</p>", "body_text": "Looking at the graph def, it looks like no node has control input \"^init_A_var_op\".\nContrasting that with the following working script\u2014which does not use a tf.while_loop()\u2014the \"increment_A_dep/y\" node corresponding to the const second argument to the \"increment_A_dep\" tf.add() op has control input \"^init_A_var_op\":\nfrom __future__ import division, print_function\nimport numpy as np\nimport tensorflow as tf\n\nrs = np.random.RandomState(seed = 2)\nA = rs.normal(size = (10, 10,))\nprint('singular values of A: %s' % (np.linalg.svd(A, compute_uv = False),))\nB = rs.normal(size = (10, 10,))\nprint('singular values of B: %s' % (np.linalg.svd(B, compute_uv = False),))\n\ngraph = tf.Graph()\nwith graph.as_default():\n    A_var = tf.Variable(B, name = 'A_var')\n    init_A_var_op = tf.assign(A_var, A, name = 'init_A_var_op')\n    A_dep = tf.constant(9, tf.int32, name = 'initial_A_dep')\n\n    with tf.control_dependencies([init_A_var_op]):\n        A_dep = tf.add(A_dep, 1, name = 'increment_A_dep')\n\n    with tf.control_dependencies([A_dep]):\n        var_s = tf.svd(A_var, compute_uv = False)\n\nprint(graph.as_graph_def())\n\nwith tf.Session(graph = graph) as session:\n    session.run(tf.global_variables_initializer())\n    computed_A_dep, computed_s, computed_A_dep2 = session.run([A_dep, var_s, A_dep])\n    assert computed_A_dep == computed_A_dep2\nprint('computed_s = %s, computed_A_dep = %d' % (computed_s, computed_A_dep,))\nHere is an excerpt from the working script's graph def:\nnode {\n  name: \"initial_A_dep\"\n  op: \"Const\"\n  attr {\n    key: \"dtype\"\n    value {\n      type: DT_INT32\n    }\n  }\n  attr {\n    key: \"value\"\n    value {\n      tensor {\n        dtype: DT_INT32\n        tensor_shape {\n        }\n        int_val: 9\n      }\n    }\n  }\n}\nnode {\n  name: \"increment_A_dep/y\"\n  op: \"Const\"\n  input: \"^init_A_var_op\"\n  attr {\n    key: \"dtype\"\n    value {\n      type: DT_INT32\n    }\n  }\n  attr {\n    key: \"value\"\n    value {\n      tensor {\n        dtype: DT_INT32\n        tensor_shape {\n        }\n        int_val: 1\n      }\n    }\n  }\n}\nnode {\n  name: \"increment_A_dep\"\n  op: \"Add\"\n  input: \"initial_A_dep\"\n  input: \"increment_A_dep/y\"\n  attr {\n    key: \"T\"\n    value {\n      type: DT_INT32\n    }\n  }\n}\nnode {\n  name: \"Svd\"\n  op: \"Svd\"\n  input: \"A_var/read\"\n  input: \"^increment_A_dep\"\n  attr {\n    key: \"T\"\n    value {\n      type: DT_DOUBLE\n    }\n  }\n  attr {\n    key: \"compute_uv\"\n    value {\n      b: false\n    }\n  }\n  attr {\n    key: \"full_matrices\"\n    value {\n      b: false\n    }\n  }\n}\n\nThe non-working graph's \"while/increment_A_dep/y\" node has control input \"^while/Identity\" but not \"^init_A_var_op\".", "body": "Looking at the graph def, it looks like no node has control input \"^init_A_var_op\".\r\n\r\nContrasting that with the following working script\u2014which does not use a tf.while_loop()\u2014the \"increment_A_dep/y\" node corresponding to the const second argument to the \"increment_A_dep\" tf.add() op has control input \"^init_A_var_op\":\r\n\r\n```python\r\nfrom __future__ import division, print_function\r\nimport numpy as np\r\nimport tensorflow as tf\r\n\r\nrs = np.random.RandomState(seed = 2)\r\nA = rs.normal(size = (10, 10,))\r\nprint('singular values of A: %s' % (np.linalg.svd(A, compute_uv = False),))\r\nB = rs.normal(size = (10, 10,))\r\nprint('singular values of B: %s' % (np.linalg.svd(B, compute_uv = False),))\r\n\r\ngraph = tf.Graph()\r\nwith graph.as_default():\r\n    A_var = tf.Variable(B, name = 'A_var')\r\n    init_A_var_op = tf.assign(A_var, A, name = 'init_A_var_op')\r\n    A_dep = tf.constant(9, tf.int32, name = 'initial_A_dep')\r\n\r\n    with tf.control_dependencies([init_A_var_op]):\r\n        A_dep = tf.add(A_dep, 1, name = 'increment_A_dep')\r\n\r\n    with tf.control_dependencies([A_dep]):\r\n        var_s = tf.svd(A_var, compute_uv = False)\r\n\r\nprint(graph.as_graph_def())\r\n\r\nwith tf.Session(graph = graph) as session:\r\n    session.run(tf.global_variables_initializer())\r\n    computed_A_dep, computed_s, computed_A_dep2 = session.run([A_dep, var_s, A_dep])\r\n    assert computed_A_dep == computed_A_dep2\r\nprint('computed_s = %s, computed_A_dep = %d' % (computed_s, computed_A_dep,))\r\n```\r\n\r\nHere is an excerpt from the working script's graph def:\r\n\r\n```\r\nnode {\r\n  name: \"initial_A_dep\"\r\n  op: \"Const\"\r\n  attr {\r\n    key: \"dtype\"\r\n    value {\r\n      type: DT_INT32\r\n    }\r\n  }\r\n  attr {\r\n    key: \"value\"\r\n    value {\r\n      tensor {\r\n        dtype: DT_INT32\r\n        tensor_shape {\r\n        }\r\n        int_val: 9\r\n      }\r\n    }\r\n  }\r\n}\r\nnode {\r\n  name: \"increment_A_dep/y\"\r\n  op: \"Const\"\r\n  input: \"^init_A_var_op\"\r\n  attr {\r\n    key: \"dtype\"\r\n    value {\r\n      type: DT_INT32\r\n    }\r\n  }\r\n  attr {\r\n    key: \"value\"\r\n    value {\r\n      tensor {\r\n        dtype: DT_INT32\r\n        tensor_shape {\r\n        }\r\n        int_val: 1\r\n      }\r\n    }\r\n  }\r\n}\r\nnode {\r\n  name: \"increment_A_dep\"\r\n  op: \"Add\"\r\n  input: \"initial_A_dep\"\r\n  input: \"increment_A_dep/y\"\r\n  attr {\r\n    key: \"T\"\r\n    value {\r\n      type: DT_INT32\r\n    }\r\n  }\r\n}\r\nnode {\r\n  name: \"Svd\"\r\n  op: \"Svd\"\r\n  input: \"A_var/read\"\r\n  input: \"^increment_A_dep\"\r\n  attr {\r\n    key: \"T\"\r\n    value {\r\n      type: DT_DOUBLE\r\n    }\r\n  }\r\n  attr {\r\n    key: \"compute_uv\"\r\n    value {\r\n      b: false\r\n    }\r\n  }\r\n  attr {\r\n    key: \"full_matrices\"\r\n    value {\r\n      b: false\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nThe non-working graph's \"while/increment_A_dep/y\" node has control input \"^while/Identity\" but not \"^init_A_var_op\"."}