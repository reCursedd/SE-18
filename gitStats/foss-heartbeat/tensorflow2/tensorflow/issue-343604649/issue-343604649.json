{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/21051", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/21051/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/21051/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/21051/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/21051", "id": 343604649, "node_id": "MDU6SXNzdWUzNDM2MDQ2NDk=", "number": 21051, "title": "Doc: ctc_beam_search_decoder", "user": {"login": "githubharald", "id": 15148095, "node_id": "MDQ6VXNlcjE1MTQ4MDk1", "avatar_url": "https://avatars2.githubusercontent.com/u/15148095?v=4", "gravatar_id": "", "url": "https://api.github.com/users/githubharald", "html_url": "https://github.com/githubharald", "followers_url": "https://api.github.com/users/githubharald/followers", "following_url": "https://api.github.com/users/githubharald/following{/other_user}", "gists_url": "https://api.github.com/users/githubharald/gists{/gist_id}", "starred_url": "https://api.github.com/users/githubharald/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/githubharald/subscriptions", "organizations_url": "https://api.github.com/users/githubharald/orgs", "repos_url": "https://api.github.com/users/githubharald/repos", "events_url": "https://api.github.com/users/githubharald/events{/privacy}", "received_events_url": "https://api.github.com/users/githubharald/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "open", "locked": false, "assignee": {"login": "tatianashp", "id": 986732, "node_id": "MDQ6VXNlcjk4NjczMg==", "avatar_url": "https://avatars2.githubusercontent.com/u/986732?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tatianashp", "html_url": "https://github.com/tatianashp", "followers_url": "https://api.github.com/users/tatianashp/followers", "following_url": "https://api.github.com/users/tatianashp/following{/other_user}", "gists_url": "https://api.github.com/users/tatianashp/gists{/gist_id}", "starred_url": "https://api.github.com/users/tatianashp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tatianashp/subscriptions", "organizations_url": "https://api.github.com/users/tatianashp/orgs", "repos_url": "https://api.github.com/users/tatianashp/repos", "events_url": "https://api.github.com/users/tatianashp/events{/privacy}", "received_events_url": "https://api.github.com/users/tatianashp/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "tatianashp", "id": 986732, "node_id": "MDQ6VXNlcjk4NjczMg==", "avatar_url": "https://avatars2.githubusercontent.com/u/986732?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tatianashp", "html_url": "https://github.com/tatianashp", "followers_url": "https://api.github.com/users/tatianashp/followers", "following_url": "https://api.github.com/users/tatianashp/following{/other_user}", "gists_url": "https://api.github.com/users/tatianashp/gists{/gist_id}", "starred_url": "https://api.github.com/users/tatianashp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tatianashp/subscriptions", "organizations_url": "https://api.github.com/users/tatianashp/orgs", "repos_url": "https://api.github.com/users/tatianashp/repos", "events_url": "https://api.github.com/users/tatianashp/events{/privacy}", "received_events_url": "https://api.github.com/users/tatianashp/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 3, "created_at": "2018-07-23T12:04:26Z", "updated_at": "2018-11-21T19:00:38Z", "closed_at": null, "author_association": "NONE", "body_html": "<p>The <a href=\"https://www.tensorflow.org/api_docs/python/tf/nn/ctc_beam_search_decoder\" rel=\"nofollow\">TF documentation </a> says: <em>\"Note The ctc_greedy_decoder is a special case of the ctc_beam_search_decoder with top_paths=1 and beam_width=1 (but that decoder is faster for this special case).\"</em></p>\n<p>This implies that the result of the greedy and beam decoder is equal if beam width is set to 1.</p>\n<p>However, this is not the case. Even with beam width set to 1, beam search uses more information by distinguishing paths ending with blank and non-blank.<br>\nTherefore, it is possible to create inputs from which beam search can extract enough information to produce the correct result, while best path decoding fails.</p>\n<p>Here is such an input matrix with 3 time-steps. It contains a label '0' and the blank '-'. The best path \"0-0\" is marked by a red line:<br>\n<a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://user-images.githubusercontent.com/15148095/43075266-908f4740-8e80-11e8-85a5-91e9ffd08015.png\"><img src=\"https://user-images.githubusercontent.com/15148095/43075266-908f4740-8e80-11e8-85a5-91e9ffd08015.png\" alt=\"matrix_best\" style=\"max-width:100%;\"></a></p>\n<p>And here is the code which produces different results, depending on the decoder:</p>\n<pre><code>import tensorflow as tf\nimport numpy as np\n\n\nbatchSize=1\nnumClasses=2\nnumTimesteps=3\n\n\ndef createGraph():\n\t\"create tensors\"\n\ttinputs=tf.placeholder(tf.float32, [numTimesteps, batchSize, numClasses])\n\ttseqLen=tf.placeholder(tf.int32, [None]) # list of sequence length in batch\n\ttbeam=tf.nn.ctc_beam_search_decoder(tinputs, tseqLen, beam_width=1, merge_repeated=False)\n\ttbest=tf.nn.ctc_greedy_decoder(tinputs, tseqLen, merge_repeated=True)\n\n\treturn (tinputs, tseqLen, tbeam, tbest)\n\n\ndef getData():\n\t\"get data matrix of size TxBxC with T=3, B=1 and C=2 (one label + blank)\"\n\tseqLen=[numTimesteps]\n\tinputs=np.asarray([ [[0.51, 0.49]], [[0.49, 0.51]], [[0.51, 0.49]] ], np.float32)\n\treturn (inputs, seqLen) \n\n\ndef toLabelString(decoderOutput):\n\t\"map sparse tensor from decoder to label string\"\n\tdecoded=decoderOutput[0][0]\n\tidxDict={b:[] for b in range(batchSize)}\n\tencodedLabels=[[] for i in range(batchSize)]\n\tfor (idxVal, idx2d) in enumerate(decoded.indices):\n\t\tvalue=decoded.values[idxVal]\n\t\tbatch=idx2d[0]\n\t\tencodedLabels[batch].append(value)\n\n\treturn encodedLabels[0]\n\ndef main():\n\t# initialize\n\t(tinputs, tseqLen, tbeam, tbest)=createGraph()\n\tsess=tf.Session()\n\tsess.run(tf.global_variables_initializer())\n\n\t# compute decoded result\n\t(inputs, seqLen)=getData()\n\t[retBeam, retBest]=sess.run([tbeam, tbest], {tinputs:inputs, tseqLen:seqLen } )\n\tprint('Beam Search Decoding :', toLabelString(retBeam))\n\tprint('Best Path Decoding   :', toLabelString(retBest))\n\n\nif __name__ == '__main__':\n\tmain()\n</code></pre>\n<p>Output:</p>\n<pre><code>Beam Search Decoding : [0]\nBest Path Decoding   : [0, 0]\n</code></pre>\n<hr>\n<p>Have I written custom code: code see above<br>\nOS Platform and Distribution: N/A<br>\nTensorFlow installed from: N/A<br>\nTensorFlow version: tested with 1.3 and 1.6<br>\nBazel version: N/A<br>\nCUDA/cuDNN version: N/A<br>\nGPU model and memory: N/A<br>\nExact command to reproduce: code see above, doc is linked<br>\nMobile device: N/A</p>", "body_text": "The TF documentation  says: \"Note The ctc_greedy_decoder is a special case of the ctc_beam_search_decoder with top_paths=1 and beam_width=1 (but that decoder is faster for this special case).\"\nThis implies that the result of the greedy and beam decoder is equal if beam width is set to 1.\nHowever, this is not the case. Even with beam width set to 1, beam search uses more information by distinguishing paths ending with blank and non-blank.\nTherefore, it is possible to create inputs from which beam search can extract enough information to produce the correct result, while best path decoding fails.\nHere is such an input matrix with 3 time-steps. It contains a label '0' and the blank '-'. The best path \"0-0\" is marked by a red line:\n\nAnd here is the code which produces different results, depending on the decoder:\nimport tensorflow as tf\nimport numpy as np\n\n\nbatchSize=1\nnumClasses=2\nnumTimesteps=3\n\n\ndef createGraph():\n\t\"create tensors\"\n\ttinputs=tf.placeholder(tf.float32, [numTimesteps, batchSize, numClasses])\n\ttseqLen=tf.placeholder(tf.int32, [None]) # list of sequence length in batch\n\ttbeam=tf.nn.ctc_beam_search_decoder(tinputs, tseqLen, beam_width=1, merge_repeated=False)\n\ttbest=tf.nn.ctc_greedy_decoder(tinputs, tseqLen, merge_repeated=True)\n\n\treturn (tinputs, tseqLen, tbeam, tbest)\n\n\ndef getData():\n\t\"get data matrix of size TxBxC with T=3, B=1 and C=2 (one label + blank)\"\n\tseqLen=[numTimesteps]\n\tinputs=np.asarray([ [[0.51, 0.49]], [[0.49, 0.51]], [[0.51, 0.49]] ], np.float32)\n\treturn (inputs, seqLen) \n\n\ndef toLabelString(decoderOutput):\n\t\"map sparse tensor from decoder to label string\"\n\tdecoded=decoderOutput[0][0]\n\tidxDict={b:[] for b in range(batchSize)}\n\tencodedLabels=[[] for i in range(batchSize)]\n\tfor (idxVal, idx2d) in enumerate(decoded.indices):\n\t\tvalue=decoded.values[idxVal]\n\t\tbatch=idx2d[0]\n\t\tencodedLabels[batch].append(value)\n\n\treturn encodedLabels[0]\n\ndef main():\n\t# initialize\n\t(tinputs, tseqLen, tbeam, tbest)=createGraph()\n\tsess=tf.Session()\n\tsess.run(tf.global_variables_initializer())\n\n\t# compute decoded result\n\t(inputs, seqLen)=getData()\n\t[retBeam, retBest]=sess.run([tbeam, tbest], {tinputs:inputs, tseqLen:seqLen } )\n\tprint('Beam Search Decoding :', toLabelString(retBeam))\n\tprint('Best Path Decoding   :', toLabelString(retBest))\n\n\nif __name__ == '__main__':\n\tmain()\n\nOutput:\nBeam Search Decoding : [0]\nBest Path Decoding   : [0, 0]\n\n\nHave I written custom code: code see above\nOS Platform and Distribution: N/A\nTensorFlow installed from: N/A\nTensorFlow version: tested with 1.3 and 1.6\nBazel version: N/A\nCUDA/cuDNN version: N/A\nGPU model and memory: N/A\nExact command to reproduce: code see above, doc is linked\nMobile device: N/A", "body": "The [TF documentation ](https://www.tensorflow.org/api_docs/python/tf/nn/ctc_beam_search_decoder) says: _\"Note The ctc_greedy_decoder is a special case of the ctc_beam_search_decoder with top_paths=1 and beam_width=1 (but that decoder is faster for this special case).\"_\r\n\r\nThis implies that the result of the greedy and beam decoder is equal if beam width is set to 1.\r\n\r\nHowever, this is not the case. Even with beam width set to 1, beam search uses more information by distinguishing paths ending with blank and non-blank.\r\nTherefore, it is possible to create inputs from which beam search can extract enough information to produce the correct result, while best path decoding fails.\r\n\r\nHere is such an input matrix with 3 time-steps. It contains a label '0' and the blank '-'. The best path \"0-0\" is marked by a red line:\r\n![matrix_best](https://user-images.githubusercontent.com/15148095/43075266-908f4740-8e80-11e8-85a5-91e9ffd08015.png)\r\n\r\n \r\n\r\n\r\nAnd here is the code which produces different results, depending on the decoder:\r\n\r\n```\r\nimport tensorflow as tf\r\nimport numpy as np\r\n\r\n\r\nbatchSize=1\r\nnumClasses=2\r\nnumTimesteps=3\r\n\r\n\r\ndef createGraph():\r\n\t\"create tensors\"\r\n\ttinputs=tf.placeholder(tf.float32, [numTimesteps, batchSize, numClasses])\r\n\ttseqLen=tf.placeholder(tf.int32, [None]) # list of sequence length in batch\r\n\ttbeam=tf.nn.ctc_beam_search_decoder(tinputs, tseqLen, beam_width=1, merge_repeated=False)\r\n\ttbest=tf.nn.ctc_greedy_decoder(tinputs, tseqLen, merge_repeated=True)\r\n\r\n\treturn (tinputs, tseqLen, tbeam, tbest)\r\n\r\n\r\ndef getData():\r\n\t\"get data matrix of size TxBxC with T=3, B=1 and C=2 (one label + blank)\"\r\n\tseqLen=[numTimesteps]\r\n\tinputs=np.asarray([ [[0.51, 0.49]], [[0.49, 0.51]], [[0.51, 0.49]] ], np.float32)\r\n\treturn (inputs, seqLen) \r\n\r\n\r\ndef toLabelString(decoderOutput):\r\n\t\"map sparse tensor from decoder to label string\"\r\n\tdecoded=decoderOutput[0][0]\r\n\tidxDict={b:[] for b in range(batchSize)}\r\n\tencodedLabels=[[] for i in range(batchSize)]\r\n\tfor (idxVal, idx2d) in enumerate(decoded.indices):\r\n\t\tvalue=decoded.values[idxVal]\r\n\t\tbatch=idx2d[0]\r\n\t\tencodedLabels[batch].append(value)\r\n\r\n\treturn encodedLabels[0]\r\n\r\ndef main():\r\n\t# initialize\r\n\t(tinputs, tseqLen, tbeam, tbest)=createGraph()\r\n\tsess=tf.Session()\r\n\tsess.run(tf.global_variables_initializer())\r\n\r\n\t# compute decoded result\r\n\t(inputs, seqLen)=getData()\r\n\t[retBeam, retBest]=sess.run([tbeam, tbest], {tinputs:inputs, tseqLen:seqLen } )\r\n\tprint('Beam Search Decoding :', toLabelString(retBeam))\r\n\tprint('Best Path Decoding   :', toLabelString(retBest))\r\n\r\n\r\nif __name__ == '__main__':\r\n\tmain()\r\n```\r\n\r\n\r\nOutput:\r\n```\r\nBeam Search Decoding : [0]\r\nBest Path Decoding   : [0, 0]\r\n```\r\n\r\n---\r\n\r\nHave I written custom code: code see above\r\nOS Platform and Distribution: N/A\r\nTensorFlow installed from: N/A\r\nTensorFlow version: tested with 1.3 and 1.6\r\nBazel version: N/A\r\nCUDA/cuDNN version: N/A\r\nGPU model and memory: N/A\r\nExact command to reproduce: code see above, doc is linked\r\nMobile device: N/A\r\n"}