{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/211543994", "html_url": "https://github.com/tensorflow/tensorflow/pull/1991#issuecomment-211543994", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/1991", "id": 211543994, "node_id": "MDEyOklzc3VlQ29tbWVudDIxMTU0Mzk5NA==", "user": {"login": "ry", "id": 80, "node_id": "MDQ6VXNlcjgw", "avatar_url": "https://avatars1.githubusercontent.com/u/80?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ry", "html_url": "https://github.com/ry", "followers_url": "https://api.github.com/users/ry/followers", "following_url": "https://api.github.com/users/ry/following{/other_user}", "gists_url": "https://api.github.com/users/ry/gists{/gist_id}", "starred_url": "https://api.github.com/users/ry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ry/subscriptions", "organizations_url": "https://api.github.com/users/ry/orgs", "repos_url": "https://api.github.com/users/ry/repos", "events_url": "https://api.github.com/users/ry/events{/privacy}", "received_events_url": "https://api.github.com/users/ry/received_events", "type": "User", "site_admin": false}, "created_at": "2016-04-18T19:38:22Z", "updated_at": "2016-04-18T19:45:33Z", "author_association": "CONTRIBUTOR", "body_html": "<blockquote>\n<p>In one case above (R=C=3, S=2, K=1), we have: R' = C' = 2, Pr = Pc = 1 * 2 + 1 - 3 = 0, so it feels like the padding calculation is wrong for that case, since it's now calculated as '1' even though it's unneeded.</p>\n<p>In the case that failed for you: R=C=4, S=2, K=1 we have R'=C'=2, Pr = Pc = 1 * 2 + 1 - 4 = -1, so we have negative padding. My guess is that you changed the code to avoid tripping the check failure -- if you use std::max(0, calculated_padding), I'm thinking the math will generally work out. What do you think?</p>\n</blockquote>\n<p>Let's consider another case (padding=SAME) where the kernel is bigger than 1x1 and the strides are bigger than the kernel, such that the kernel lays across the boundary of the image.</p>\n<p>So take R=C=4, K=2, S=3. R'=C'=2 and</p>\n<pre><code>pad_needed_width = (R' - 1)S + K - R = 1*3 + 2 - 4 = 1\npad_left =  pad_needed_width / 2 = 0\npad_right = pad_needed_width - pad_left  = 1\n</code></pre>\n<p>That seems okay, it calculates some 2x2 output matrix. In the case of the tests we'd have <code>expected == [44, 28, 41, 16]</code>.</p>\n<p>But in Theano with <code>border_mode='full'</code> it pads with one on all sides and calculates <code>expected == [4, 25, 70, 144]</code>.</p>\n<p>Using this patch, TF would calculate:</p>\n<pre><code>pad_needed_width = (R' - 1)S + max(S,K) - R = 1*3 + 3 - 4 = 2\npad_left = pad_needed_width / 2 = 1\npad_right = pad_needed_width - pad_left  = 1\n</code></pre>\n<p>See the second test here: <a href=\"https://gist.github.com/ry/273e0a8b83e33f891afbe09a6130c72c\">https://gist.github.com/ry/273e0a8b83e33f891afbe09a6130c72c</a></p>\n<p>I think the way Theano does it seems more centered.</p>", "body_text": "In one case above (R=C=3, S=2, K=1), we have: R' = C' = 2, Pr = Pc = 1 * 2 + 1 - 3 = 0, so it feels like the padding calculation is wrong for that case, since it's now calculated as '1' even though it's unneeded.\nIn the case that failed for you: R=C=4, S=2, K=1 we have R'=C'=2, Pr = Pc = 1 * 2 + 1 - 4 = -1, so we have negative padding. My guess is that you changed the code to avoid tripping the check failure -- if you use std::max(0, calculated_padding), I'm thinking the math will generally work out. What do you think?\n\nLet's consider another case (padding=SAME) where the kernel is bigger than 1x1 and the strides are bigger than the kernel, such that the kernel lays across the boundary of the image.\nSo take R=C=4, K=2, S=3. R'=C'=2 and\npad_needed_width = (R' - 1)S + K - R = 1*3 + 2 - 4 = 1\npad_left =  pad_needed_width / 2 = 0\npad_right = pad_needed_width - pad_left  = 1\n\nThat seems okay, it calculates some 2x2 output matrix. In the case of the tests we'd have expected == [44, 28, 41, 16].\nBut in Theano with border_mode='full' it pads with one on all sides and calculates expected == [4, 25, 70, 144].\nUsing this patch, TF would calculate:\npad_needed_width = (R' - 1)S + max(S,K) - R = 1*3 + 3 - 4 = 2\npad_left = pad_needed_width / 2 = 1\npad_right = pad_needed_width - pad_left  = 1\n\nSee the second test here: https://gist.github.com/ry/273e0a8b83e33f891afbe09a6130c72c\nI think the way Theano does it seems more centered.", "body": "> In one case above (R=C=3, S=2, K=1), we have: R' = C' = 2, Pr = Pc = 1 \\* 2 + 1 - 3 = 0, so it feels like the padding calculation is wrong for that case, since it's now calculated as '1' even though it's unneeded.\n> \n> In the case that failed for you: R=C=4, S=2, K=1 we have R'=C'=2, Pr = Pc = 1 \\* 2 + 1 - 4 = -1, so we have negative padding. My guess is that you changed the code to avoid tripping the check failure -- if you use std::max(0, calculated_padding), I'm thinking the math will generally work out. What do you think?\n\nLet's consider another case (padding=SAME) where the kernel is bigger than 1x1 and the strides are bigger than the kernel, such that the kernel lays across the boundary of the image.\n\nSo take R=C=4, K=2, S=3. R'=C'=2 and \n\n```\npad_needed_width = (R' - 1)S + K - R = 1*3 + 2 - 4 = 1\npad_left =  pad_needed_width / 2 = 0\npad_right = pad_needed_width - pad_left  = 1\n```\n\nThat seems okay, it calculates some 2x2 output matrix. In the case of the tests we'd have `expected == [44, 28, 41, 16]`.\n\nBut in Theano with `border_mode='full'` it pads with one on all sides and calculates `expected == [4, 25, 70, 144]`.\n\nUsing this patch, TF would calculate:\n\n```\npad_needed_width = (R' - 1)S + max(S,K) - R = 1*3 + 3 - 4 = 2\npad_left = pad_needed_width / 2 = 1\npad_right = pad_needed_width - pad_left  = 1\n```\n\nSee the second test here: https://gist.github.com/ry/273e0a8b83e33f891afbe09a6130c72c\n\nI think the way Theano does it seems more centered.\n"}