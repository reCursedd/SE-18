{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/4883", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/4883/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/4883/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/4883/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/4883", "id": 182126107, "node_id": "MDU6SXNzdWUxODIxMjYxMDc=", "number": 4883, "title": "Ability to directly set the gradient of a node for use in backpropagation.", "user": {"login": "zergylord", "id": 2257125, "node_id": "MDQ6VXNlcjIyNTcxMjU=", "avatar_url": "https://avatars2.githubusercontent.com/u/2257125?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zergylord", "html_url": "https://github.com/zergylord", "followers_url": "https://api.github.com/users/zergylord/followers", "following_url": "https://api.github.com/users/zergylord/following{/other_user}", "gists_url": "https://api.github.com/users/zergylord/gists{/gist_id}", "starred_url": "https://api.github.com/users/zergylord/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zergylord/subscriptions", "organizations_url": "https://api.github.com/users/zergylord/orgs", "repos_url": "https://api.github.com/users/zergylord/repos", "events_url": "https://api.github.com/users/zergylord/events{/privacy}", "received_events_url": "https://api.github.com/users/zergylord/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2016-10-10T22:03:46Z", "updated_at": "2016-10-14T00:16:17Z", "closed_at": "2016-10-14T00:16:17Z", "author_association": "NONE", "body_html": "<p>Imagine a tiny network defined as follows, where linear is a typical helper function defining TensorFlow variables for a weight matrix and activation function:</p>\n<p><code>final_layer = linear(linear(_input,10,tf.nn.tanh),20)</code></p>\n<p>Normally this would be optimized via gradient descent on a loss:</p>\n<p><code>loss = tf.reduce_sum(tf.square(final_layer - _target)) train_step = tf.train.AdamOptimizer().minimmize(loss)</code></p>\n<p>But assume I'm getting the derivatives of the loss w.r.t. final_layer from an external  source (e.g. a tf.placeholder named _deriv). I would like to be able to use this gradient information with one of the builtin optimizers to backpropagate and update the network parameters, but this appears to be currently impossible.</p>\n<p>The workaround I'm currently using is to construct an artificial loss consisting of the inner product between _deriv and final_layer (since the derivatives of this loss w.r.t. final_layer will be equal to _deriv).</p>\n<p><code>loss = tf.reduce_sum(final_layer*_deriv) train_step = tf.train.AdamOptimizer().minimmize(loss)</code></p>\n<p>This is very wasteful though, as it needs to do this unnecessary inner product and calculate its derivative for every training step even though I already know this information.</p>\n<p>For those thinking this an odd thing to need to do, it is necessary for implementing <a href=\"https://arxiv.org/abs/1608.05343\" rel=\"nofollow\">synthetic gradients</a>.</p>", "body_text": "Imagine a tiny network defined as follows, where linear is a typical helper function defining TensorFlow variables for a weight matrix and activation function:\nfinal_layer = linear(linear(_input,10,tf.nn.tanh),20)\nNormally this would be optimized via gradient descent on a loss:\nloss = tf.reduce_sum(tf.square(final_layer - _target)) train_step = tf.train.AdamOptimizer().minimmize(loss)\nBut assume I'm getting the derivatives of the loss w.r.t. final_layer from an external  source (e.g. a tf.placeholder named _deriv). I would like to be able to use this gradient information with one of the builtin optimizers to backpropagate and update the network parameters, but this appears to be currently impossible.\nThe workaround I'm currently using is to construct an artificial loss consisting of the inner product between _deriv and final_layer (since the derivatives of this loss w.r.t. final_layer will be equal to _deriv).\nloss = tf.reduce_sum(final_layer*_deriv) train_step = tf.train.AdamOptimizer().minimmize(loss)\nThis is very wasteful though, as it needs to do this unnecessary inner product and calculate its derivative for every training step even though I already know this information.\nFor those thinking this an odd thing to need to do, it is necessary for implementing synthetic gradients.", "body": "Imagine a tiny network defined as follows, where linear is a typical helper function defining TensorFlow variables for a weight matrix and activation function:\n\n`final_layer = linear(linear(_input,10,tf.nn.tanh),20)`\n\nNormally this would be optimized via gradient descent on a loss:\n\n`loss = tf.reduce_sum(tf.square(final_layer - _target))\ntrain_step = tf.train.AdamOptimizer().minimmize(loss)`\n\nBut assume I'm getting the derivatives of the loss w.r.t. final_layer from an external  source (e.g. a tf.placeholder named _deriv). I would like to be able to use this gradient information with one of the builtin optimizers to backpropagate and update the network parameters, but this appears to be currently impossible.\n\nThe workaround I'm currently using is to construct an artificial loss consisting of the inner product between _deriv and final_layer (since the derivatives of this loss w.r.t. final_layer will be equal to _deriv). \n\n`loss = tf.reduce_sum(final_layer*_deriv)\ntrain_step = tf.train.AdamOptimizer().minimmize(loss)`\n\nThis is very wasteful though, as it needs to do this unnecessary inner product and calculate its derivative for every training step even though I already know this information.\n\nFor those thinking this an odd thing to need to do, it is necessary for implementing [synthetic gradients](https://arxiv.org/abs/1608.05343).\n"}