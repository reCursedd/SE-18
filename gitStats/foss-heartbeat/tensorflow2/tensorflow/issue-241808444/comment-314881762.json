{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/314881762", "html_url": "https://github.com/tensorflow/tensorflow/issues/11416#issuecomment-314881762", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11416", "id": 314881762, "node_id": "MDEyOklzc3VlQ29tbWVudDMxNDg4MTc2Mg==", "user": {"login": "shamoya", "id": 22274255, "node_id": "MDQ6VXNlcjIyMjc0MjU1", "avatar_url": "https://avatars2.githubusercontent.com/u/22274255?v=4", "gravatar_id": "", "url": "https://api.github.com/users/shamoya", "html_url": "https://github.com/shamoya", "followers_url": "https://api.github.com/users/shamoya/followers", "following_url": "https://api.github.com/users/shamoya/following{/other_user}", "gists_url": "https://api.github.com/users/shamoya/gists{/gist_id}", "starred_url": "https://api.github.com/users/shamoya/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/shamoya/subscriptions", "organizations_url": "https://api.github.com/users/shamoya/orgs", "repos_url": "https://api.github.com/users/shamoya/repos", "events_url": "https://api.github.com/users/shamoya/events{/privacy}", "received_events_url": "https://api.github.com/users/shamoya/received_events", "type": "User", "site_admin": false}, "created_at": "2017-07-12T20:07:16Z", "updated_at": "2017-07-12T20:07:16Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=5404419\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/on-the-run\">@on-the-run</a>, Looking at the ps log, something doesn't make sense to me.<br>\nThe second call of RecvFromRemoteAsync is for Tensor 140513923548928.<br>\nThe thread (coming from RecvFromRemoteAsync) then calls EnqueItem (with a lock) and then SendNextItem which doesn't do Write since local and remove are busy.<br>\nBut this tensor should stay at the top of the queue, and the next SendNextItem should send it, but that doesn't happen (same for the third tensor - 140514712069888)</p>\n<p>After the RDMA_MESSAGE_ACK is received (which set remote = idle and calls SendNextItem) the SendNextItem takes Tensor 140513093064448, and I don't understand why ?</p>\n<p>Is it possible your print change the locking scheme of the queue ?</p>", "body_text": "@on-the-run, Looking at the ps log, something doesn't make sense to me.\nThe second call of RecvFromRemoteAsync is for Tensor 140513923548928.\nThe thread (coming from RecvFromRemoteAsync) then calls EnqueItem (with a lock) and then SendNextItem which doesn't do Write since local and remove are busy.\nBut this tensor should stay at the top of the queue, and the next SendNextItem should send it, but that doesn't happen (same for the third tensor - 140514712069888)\nAfter the RDMA_MESSAGE_ACK is received (which set remote = idle and calls SendNextItem) the SendNextItem takes Tensor 140513093064448, and I don't understand why ?\nIs it possible your print change the locking scheme of the queue ?", "body": "@on-the-run, Looking at the ps log, something doesn't make sense to me.\r\nThe second call of RecvFromRemoteAsync is for Tensor 140513923548928.\r\nThe thread (coming from RecvFromRemoteAsync) then calls EnqueItem (with a lock) and then SendNextItem which doesn't do Write since local and remove are busy.\r\nBut this tensor should stay at the top of the queue, and the next SendNextItem should send it, but that doesn't happen (same for the third tensor - 140514712069888)\r\n\r\nAfter the RDMA_MESSAGE_ACK is received (which set remote = idle and calls SendNextItem) the SendNextItem takes Tensor 140513093064448, and I don't understand why ? \r\n\r\nIs it possible your print change the locking scheme of the queue ? \r\n\r\n"}