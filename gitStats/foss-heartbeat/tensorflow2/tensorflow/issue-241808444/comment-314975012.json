{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/314975012", "html_url": "https://github.com/tensorflow/tensorflow/issues/11416#issuecomment-314975012", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11416", "id": 314975012, "node_id": "MDEyOklzc3VlQ29tbWVudDMxNDk3NTAxMg==", "user": {"login": "junshi15", "id": 12075848, "node_id": "MDQ6VXNlcjEyMDc1ODQ4", "avatar_url": "https://avatars3.githubusercontent.com/u/12075848?v=4", "gravatar_id": "", "url": "https://api.github.com/users/junshi15", "html_url": "https://github.com/junshi15", "followers_url": "https://api.github.com/users/junshi15/followers", "following_url": "https://api.github.com/users/junshi15/following{/other_user}", "gists_url": "https://api.github.com/users/junshi15/gists{/gist_id}", "starred_url": "https://api.github.com/users/junshi15/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/junshi15/subscriptions", "organizations_url": "https://api.github.com/users/junshi15/orgs", "repos_url": "https://api.github.com/users/junshi15/repos", "events_url": "https://api.github.com/users/junshi15/events{/privacy}", "received_events_url": "https://api.github.com/users/junshi15/received_events", "type": "User", "site_admin": false}, "created_at": "2017-07-13T05:29:49Z", "updated_at": "2017-07-13T05:42:52Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=5404419\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/on-the-run\">@on-the-run</a><br>\nI refreshed my memory. Here is how the buffers are protected. I will focus on rx buffer which is protected by its remote side (tx side).</p>\n<p>Rx_TensorBuffer:<br>\nWhen we send a tensor via TensorBuffer, we need to make sure both the Tx_TensorBuffer (at the sender) and the Rx_TensorBuffer (at the receiver) are idle. This is achieved by checking <a href=\"https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/verbs/rdma.cc#L778\">local_status_ and remote_status_</a> at the sender under a lock. When the tensor is received, the receiver send a <a href=\"https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/verbs/rdma_rendezvous_mgr.cc#L142\">RDMA_MESSAGE_BUFFER_IDLE message</a> to release remote_status_, while local_status_ is released at the <a href=\"https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/verbs/rdma.cc#L222\">sender</a>.</p>\n<p>Rx_MessageBuffer:<br>\nSimilar to Rx_TensorBuffer, both local_status_ and remote_status_ flags are <a href=\"https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/verbs/rdma.cc#L643\">checked</a>. They are turned to <a href=\"https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/verbs/rdma.cc#L644-L645\">busy</a> once transmission starts. When the receiver reads the buffer, it sends an ACK to notify the sender to release <a href=\"https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/verbs/rdma.cc#L153\">remote_status_</a>.</p>\n<p>Rx_AckBuffer:<br>\nNo protection at all. The sender does not check AckBuffer before sending an Ack. This is OK because (1) all the acks are sent (<code>ab-&gt;SendNextItem()</code>) by one thread inside Process_CQ().<br>\n(2) messages and acks are interleaved. Let's say A wants to send multiple messages to B. After the first message is sent, A has to wait for the ack before sending the next message, i.e. <a href=\"https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/verbs/rdma.cc#L148\">this</a> is the only place tx_message_buffer_.remote_status_ becomes idle. Since A can not send multiple messages consecutively, B can not ack consecutively. No risk of multiple ACKs stepping on each other.</p>\n<p>But I afraid I may have missed corner cases. This messaging system is very fragile. If one message, even an ACK, is missing, you will likely get a hang.</p>\n<p>To further debug, I suggest <a href=\"https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/verbs/rdma.h#L55-L60\">the following change</a>. Switch <code>RDMA_MESSAGE_ACK</code>  with <code>RDMA_MESSAGE_TENSOR_WRITE</code>. If indeed all message types are zero due to memory corruption, you should see all <code>RDMA_MESSAGE_TENSOR_WRITE</code> in your log.</p>", "body_text": "@on-the-run\nI refreshed my memory. Here is how the buffers are protected. I will focus on rx buffer which is protected by its remote side (tx side).\nRx_TensorBuffer:\nWhen we send a tensor via TensorBuffer, we need to make sure both the Tx_TensorBuffer (at the sender) and the Rx_TensorBuffer (at the receiver) are idle. This is achieved by checking local_status_ and remote_status_ at the sender under a lock. When the tensor is received, the receiver send a RDMA_MESSAGE_BUFFER_IDLE message to release remote_status_, while local_status_ is released at the sender.\nRx_MessageBuffer:\nSimilar to Rx_TensorBuffer, both local_status_ and remote_status_ flags are checked. They are turned to busy once transmission starts. When the receiver reads the buffer, it sends an ACK to notify the sender to release remote_status_.\nRx_AckBuffer:\nNo protection at all. The sender does not check AckBuffer before sending an Ack. This is OK because (1) all the acks are sent (ab->SendNextItem()) by one thread inside Process_CQ().\n(2) messages and acks are interleaved. Let's say A wants to send multiple messages to B. After the first message is sent, A has to wait for the ack before sending the next message, i.e. this is the only place tx_message_buffer_.remote_status_ becomes idle. Since A can not send multiple messages consecutively, B can not ack consecutively. No risk of multiple ACKs stepping on each other.\nBut I afraid I may have missed corner cases. This messaging system is very fragile. If one message, even an ACK, is missing, you will likely get a hang.\nTo further debug, I suggest the following change. Switch RDMA_MESSAGE_ACK  with RDMA_MESSAGE_TENSOR_WRITE. If indeed all message types are zero due to memory corruption, you should see all RDMA_MESSAGE_TENSOR_WRITE in your log.", "body": "@on-the-run \r\nI refreshed my memory. Here is how the buffers are protected. I will focus on rx buffer which is protected by its remote side (tx side).\r\n\r\nRx_TensorBuffer:\r\nWhen we send a tensor via TensorBuffer, we need to make sure both the Tx_TensorBuffer (at the sender) and the Rx_TensorBuffer (at the receiver) are idle. This is achieved by checking [local_status_ and remote_status_](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/verbs/rdma.cc#L778) at the sender under a lock. When the tensor is received, the receiver send a [RDMA_MESSAGE_BUFFER_IDLE message](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/verbs/rdma_rendezvous_mgr.cc#L142) to release remote_status_, while local_status_ is released at the [sender](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/verbs/rdma.cc#L222).\r\n\r\nRx_MessageBuffer:\r\nSimilar to Rx_TensorBuffer, both local_status_ and remote_status_ flags are [checked](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/verbs/rdma.cc#L643). They are turned to [busy](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/verbs/rdma.cc#L644-L645) once transmission starts. When the receiver reads the buffer, it sends an ACK to notify the sender to release [remote_status_](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/verbs/rdma.cc#L153).\r\n\r\nRx_AckBuffer:\r\nNo protection at all. The sender does not check AckBuffer before sending an Ack. This is OK because (1) all the acks are sent (`ab->SendNextItem()`) by one thread inside Process_CQ().\r\n(2) messages and acks are interleaved. Let's say A wants to send multiple messages to B. After the first message is sent, A has to wait for the ack before sending the next message, i.e. [this](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/verbs/rdma.cc#L148) is the only place tx_message_buffer_.remote_status_ becomes idle. Since A can not send multiple messages consecutively, B can not ack consecutively. No risk of multiple ACKs stepping on each other.\r\n\r\nBut I afraid I may have missed corner cases. This messaging system is very fragile. If one message, even an ACK, is missing, you will likely get a hang.\r\n\r\nTo further debug, I suggest [the following change](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/verbs/rdma.h#L55-L60). Switch `RDMA_MESSAGE_ACK`  with `RDMA_MESSAGE_TENSOR_WRITE`. If indeed all message types are zero due to memory corruption, you should see all `RDMA_MESSAGE_TENSOR_WRITE` in your log. "}