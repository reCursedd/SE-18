{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5087", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5087/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5087/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5087/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/5087", "id": 184131605, "node_id": "MDU6SXNzdWUxODQxMzE2MDU=", "number": 5087, "title": "C++ style concern of potential memory leak", "user": {"login": "byronyi", "id": 2613663, "node_id": "MDQ6VXNlcjI2MTM2NjM=", "avatar_url": "https://avatars2.githubusercontent.com/u/2613663?v=4", "gravatar_id": "", "url": "https://api.github.com/users/byronyi", "html_url": "https://github.com/byronyi", "followers_url": "https://api.github.com/users/byronyi/followers", "following_url": "https://api.github.com/users/byronyi/following{/other_user}", "gists_url": "https://api.github.com/users/byronyi/gists{/gist_id}", "starred_url": "https://api.github.com/users/byronyi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/byronyi/subscriptions", "organizations_url": "https://api.github.com/users/byronyi/orgs", "repos_url": "https://api.github.com/users/byronyi/repos", "events_url": "https://api.github.com/users/byronyi/events{/privacy}", "received_events_url": "https://api.github.com/users/byronyi/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2016-10-20T04:18:27Z", "updated_at": "2016-10-20T09:41:44Z", "closed_at": "2016-10-20T09:41:44Z", "author_association": "CONTRIBUTOR", "body_html": "<p>All the factories methods consisting a <code>static</code> pointer to heap allocated variable potentially cause memory leak, as the static in-function variables are allocated/disposed for the program life-time, but if the object is dynamically allocated on heap, the object itself is never disposed (only its pointer gets disposed).</p>\n<p>For example, in <a href=\"https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/common_runtime/session_factory.cc#L37\">session_factory.cc:37</a></p>\n<div class=\"highlight highlight-source-c++\"><pre><span class=\"pl-k\">static</span> mutex* <span class=\"pl-en\">get_session_factory_lock</span>() {\n  <span class=\"pl-k\">static</span> mutex session_factory_lock;\n  <span class=\"pl-k\">return</span> &amp;session_factory_lock;\n}\n\n<span class=\"pl-k\">typedef</span> std::unordered_map&lt;string, SessionFactory*&gt; SessionFactories;\nSessionFactories* <span class=\"pl-en\">session_factories</span>() {\n  <span class=\"pl-k\">static</span> SessionFactories* factories = <span class=\"pl-k\">new</span> SessionFactories;\n  <span class=\"pl-k\">return</span> factories;\n}</pre></div>\n<p>Note that the <code>factories</code> is a <em>static pointer</em>, not a <em>pointer to a static object</em>. Since the object itself is not static, it will not be disposed and cause memory leak.</p>\n<p>Suggested change:</p>\n<div class=\"highlight highlight-source-c++\"><pre><span class=\"pl-k\">static</span> mutex* <span class=\"pl-en\">get_session_factory_lock</span>() {\n  <span class=\"pl-k\">static</span> mutex session_factory_lock;\n  <span class=\"pl-k\">return</span> &amp;session_factory_lock;\n}\n\n<span class=\"pl-k\">typedef</span> std::unordered_map&lt;string, SessionFactory*&gt; SessionFactories;\nSessionFactories* <span class=\"pl-en\">session_factories</span>() {\n  <span class=\"pl-k\">static</span> SessionFactories factories = <span class=\"pl-c1\">SessionFactories</span>();\n  <span class=\"pl-k\">return</span> &amp;factories;\n}</pre></div>\n<p>One could easily write a small program and use <code>valgrind</code> to verify the memory leak. One example is <a href=\"https://gist.github.com/a5b0d262e5f64f36b299003634493eca\">here</a>.</p>", "body_text": "All the factories methods consisting a static pointer to heap allocated variable potentially cause memory leak, as the static in-function variables are allocated/disposed for the program life-time, but if the object is dynamically allocated on heap, the object itself is never disposed (only its pointer gets disposed).\nFor example, in session_factory.cc:37\nstatic mutex* get_session_factory_lock() {\n  static mutex session_factory_lock;\n  return &session_factory_lock;\n}\n\ntypedef std::unordered_map<string, SessionFactory*> SessionFactories;\nSessionFactories* session_factories() {\n  static SessionFactories* factories = new SessionFactories;\n  return factories;\n}\nNote that the factories is a static pointer, not a pointer to a static object. Since the object itself is not static, it will not be disposed and cause memory leak.\nSuggested change:\nstatic mutex* get_session_factory_lock() {\n  static mutex session_factory_lock;\n  return &session_factory_lock;\n}\n\ntypedef std::unordered_map<string, SessionFactory*> SessionFactories;\nSessionFactories* session_factories() {\n  static SessionFactories factories = SessionFactories();\n  return &factories;\n}\nOne could easily write a small program and use valgrind to verify the memory leak. One example is here.", "body": "All the factories methods consisting a `static` pointer to heap allocated variable potentially cause memory leak, as the static in-function variables are allocated/disposed for the program life-time, but if the object is dynamically allocated on heap, the object itself is never disposed (only its pointer gets disposed).\n\nFor example, in [session_factory.cc:37](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/common_runtime/session_factory.cc#L37)\n\n``` cpp\nstatic mutex* get_session_factory_lock() {\n  static mutex session_factory_lock;\n  return &session_factory_lock;\n}\n\ntypedef std::unordered_map<string, SessionFactory*> SessionFactories;\nSessionFactories* session_factories() {\n  static SessionFactories* factories = new SessionFactories;\n  return factories;\n}\n```\n\nNote that the `factories` is a _static pointer_, not a _pointer to a static object_. Since the object itself is not static, it will not be disposed and cause memory leak.\n\nSuggested change:\n\n``` cpp\nstatic mutex* get_session_factory_lock() {\n  static mutex session_factory_lock;\n  return &session_factory_lock;\n}\n\ntypedef std::unordered_map<string, SessionFactory*> SessionFactories;\nSessionFactories* session_factories() {\n  static SessionFactories factories = SessionFactories();\n  return &factories;\n}\n```\n\nOne could easily write a small program and use `valgrind` to verify the memory leak. One example is [here](https://gist.github.com/a5b0d262e5f64f36b299003634493eca).\n"}