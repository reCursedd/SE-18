{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/439163340", "html_url": "https://github.com/tensorflow/tensorflow/issues/23591#issuecomment-439163340", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/23591", "id": 439163340, "node_id": "MDEyOklzc3VlQ29tbWVudDQzOTE2MzM0MA==", "user": {"login": "sjain-stanford", "id": 19234106, "node_id": "MDQ6VXNlcjE5MjM0MTA2", "avatar_url": "https://avatars0.githubusercontent.com/u/19234106?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sjain-stanford", "html_url": "https://github.com/sjain-stanford", "followers_url": "https://api.github.com/users/sjain-stanford/followers", "following_url": "https://api.github.com/users/sjain-stanford/following{/other_user}", "gists_url": "https://api.github.com/users/sjain-stanford/gists{/gist_id}", "starred_url": "https://api.github.com/users/sjain-stanford/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sjain-stanford/subscriptions", "organizations_url": "https://api.github.com/users/sjain-stanford/orgs", "repos_url": "https://api.github.com/users/sjain-stanford/repos", "events_url": "https://api.github.com/users/sjain-stanford/events{/privacy}", "received_events_url": "https://api.github.com/users/sjain-stanford/received_events", "type": "User", "site_admin": false}, "created_at": "2018-11-15T19:35:16Z", "updated_at": "2018-11-15T19:35:16Z", "author_association": "NONE", "body_html": "<p>Per <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=5061\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/alextp\">@alextp</a>'s suggestion above, I updated <code>RestoredVariable</code> definition to use <code>Variable.from_proto</code> instead of inheriting from <code>tf.Variable</code> with <code>__init__</code>. This seems to fix the issue with TF&gt;=1.11.</p>\n<p>I wasn't sure how to obtain <code>variable_def</code> directly from <code>node_def</code> that is read from <code>graph_def</code>, so I created one and populated its proto fields. I think this is <strong>not</strong> the cleanest implementation. <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=5061\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/alextp\">@alextp</a> - what is a better way to do this?</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">import</span> tensorflow <span class=\"pl-k\">as</span> tf \n<span class=\"pl-k\">from</span> tensorflow.core.framework <span class=\"pl-k\">import</span> variable_pb2\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">restored_variable</span>(<span class=\"pl-smi\">name</span>, <span class=\"pl-smi\">trainable</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">True</span>, <span class=\"pl-smi\">collections</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">None</span>, <span class=\"pl-smi\">graph</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">None</span>):\n  <span class=\"pl-s\"><span class=\"pl-pds\">\"\"\"</span></span>\n<span class=\"pl-s\">  A variable restored from disk. (FIX for TF&gt;=1.11) See issue: </span>\n<span class=\"pl-s\">  https://github.com/tensorflow/tensorflow/issues/23591</span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">  Example:</span>\n<span class=\"pl-s\">  1) variable = restored_variable(node.name)</span>\n<span class=\"pl-s\">  2) variables = [ restored_variable(node.name, trainable=True, collections=None, graph=g) for node in g.as_graph_def().node if 'Variable' in node.op ]</span>\n<span class=\"pl-s\">  <span class=\"pl-pds\">\"\"\"</span></span>\n  variable_def <span class=\"pl-k\">=</span> variable_pb2.VariableDef()\n  <span class=\"pl-k\">if</span> graph <span class=\"pl-k\">is</span> <span class=\"pl-c1\">None</span>:\n    graph <span class=\"pl-k\">=</span> tf.get_default_graph()\n  <span class=\"pl-k\">if</span> collections <span class=\"pl-k\">is</span> <span class=\"pl-c1\">None</span>:\n    collections <span class=\"pl-k\">=</span> [tf.GraphKeys.<span class=\"pl-c1\">GLOBAL_VARIABLES</span>]\n  <span class=\"pl-k\">if</span> trainable <span class=\"pl-k\">and</span> tf.GraphKeys.<span class=\"pl-c1\">TRAINABLE_VARIABLES</span> <span class=\"pl-k\">not</span> <span class=\"pl-k\">in</span> collections:\n    collections <span class=\"pl-k\">=</span> collections <span class=\"pl-k\">+</span> [tf.GraphKeys.<span class=\"pl-c1\">TRAINABLE_VARIABLES</span>]\n  variable_def.variable_name <span class=\"pl-k\">=</span> graph.as_graph_element(name).outputs[<span class=\"pl-c1\">0</span>].name\n  variable_def.snapshot_name <span class=\"pl-k\">=</span> graph.as_graph_element(name <span class=\"pl-k\">+</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>/read<span class=\"pl-pds\">'</span></span>).outputs[<span class=\"pl-c1\">0</span>].name\n  variable_def.initializer_name <span class=\"pl-k\">=</span> graph.as_graph_element(name <span class=\"pl-k\">+</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>/Assign<span class=\"pl-pds\">'</span></span>).name\n  variable_def.trainable <span class=\"pl-k\">=</span> trainable\n  i_name <span class=\"pl-k\">=</span> name <span class=\"pl-k\">+</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>/Initializer/<span class=\"pl-pds\">'</span></span>\n  keys <span class=\"pl-k\">=</span> [ k <span class=\"pl-k\">for</span> k <span class=\"pl-k\">in</span> graph._nodes_by_name.keys() <span class=\"pl-k\">if</span> k.startswith(i_name) <span class=\"pl-k\">and</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>/<span class=\"pl-pds\">'</span></span> <span class=\"pl-k\">not</span> <span class=\"pl-k\">in</span> k[<span class=\"pl-c1\">len</span>(i_name):] ]\n  <span class=\"pl-k\">if</span> <span class=\"pl-c1\">len</span>(keys) <span class=\"pl-k\">!=</span> <span class=\"pl-c1\">1</span>:\n    <span class=\"pl-k\">raise</span> <span class=\"pl-c1\">ValueError</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>Could not find initializer for variable<span class=\"pl-pds\">'</span></span>, keys)\n  variable_def.initial_value_name <span class=\"pl-k\">=</span> graph.as_graph_element(keys[<span class=\"pl-c1\">0</span>]).outputs[<span class=\"pl-c1\">0</span>].name\n  var <span class=\"pl-k\">=</span> tf.Variable.from_proto(variable_def)\n  <span class=\"pl-k\">for</span> key <span class=\"pl-k\">in</span> collections:\n    graph.add_to_collection(key, var)\n  <span class=\"pl-k\">return</span> var</pre></div>", "body_text": "Per @alextp's suggestion above, I updated RestoredVariable definition to use Variable.from_proto instead of inheriting from tf.Variable with __init__. This seems to fix the issue with TF>=1.11.\nI wasn't sure how to obtain variable_def directly from node_def that is read from graph_def, so I created one and populated its proto fields. I think this is not the cleanest implementation. @alextp - what is a better way to do this?\nimport tensorflow as tf \nfrom tensorflow.core.framework import variable_pb2\n\ndef restored_variable(name, trainable=True, collections=None, graph=None):\n  \"\"\"\n  A variable restored from disk. (FIX for TF>=1.11) See issue: \n  https://github.com/tensorflow/tensorflow/issues/23591\n\n  Example:\n  1) variable = restored_variable(node.name)\n  2) variables = [ restored_variable(node.name, trainable=True, collections=None, graph=g) for node in g.as_graph_def().node if 'Variable' in node.op ]\n  \"\"\"\n  variable_def = variable_pb2.VariableDef()\n  if graph is None:\n    graph = tf.get_default_graph()\n  if collections is None:\n    collections = [tf.GraphKeys.GLOBAL_VARIABLES]\n  if trainable and tf.GraphKeys.TRAINABLE_VARIABLES not in collections:\n    collections = collections + [tf.GraphKeys.TRAINABLE_VARIABLES]\n  variable_def.variable_name = graph.as_graph_element(name).outputs[0].name\n  variable_def.snapshot_name = graph.as_graph_element(name + '/read').outputs[0].name\n  variable_def.initializer_name = graph.as_graph_element(name + '/Assign').name\n  variable_def.trainable = trainable\n  i_name = name + '/Initializer/'\n  keys = [ k for k in graph._nodes_by_name.keys() if k.startswith(i_name) and '/' not in k[len(i_name):] ]\n  if len(keys) != 1:\n    raise ValueError('Could not find initializer for variable', keys)\n  variable_def.initial_value_name = graph.as_graph_element(keys[0]).outputs[0].name\n  var = tf.Variable.from_proto(variable_def)\n  for key in collections:\n    graph.add_to_collection(key, var)\n  return var", "body": "Per @alextp's suggestion above, I updated `RestoredVariable` definition to use `Variable.from_proto` instead of inheriting from `tf.Variable` with `__init__`. This seems to fix the issue with TF>=1.11.\r\n\r\nI wasn't sure how to obtain `variable_def` directly from `node_def` that is read from `graph_def`, so I created one and populated its proto fields. I think this is **not** the cleanest implementation. @alextp - what is a better way to do this?\r\n\r\n```python3\r\nimport tensorflow as tf \r\nfrom tensorflow.core.framework import variable_pb2\r\n\r\ndef restored_variable(name, trainable=True, collections=None, graph=None):\r\n  \"\"\"\r\n  A variable restored from disk. (FIX for TF>=1.11) See issue: \r\n  https://github.com/tensorflow/tensorflow/issues/23591\r\n\r\n  Example:\r\n  1) variable = restored_variable(node.name)\r\n  2) variables = [ restored_variable(node.name, trainable=True, collections=None, graph=g) for node in g.as_graph_def().node if 'Variable' in node.op ]\r\n  \"\"\"\r\n  variable_def = variable_pb2.VariableDef()\r\n  if graph is None:\r\n    graph = tf.get_default_graph()\r\n  if collections is None:\r\n    collections = [tf.GraphKeys.GLOBAL_VARIABLES]\r\n  if trainable and tf.GraphKeys.TRAINABLE_VARIABLES not in collections:\r\n    collections = collections + [tf.GraphKeys.TRAINABLE_VARIABLES]\r\n  variable_def.variable_name = graph.as_graph_element(name).outputs[0].name\r\n  variable_def.snapshot_name = graph.as_graph_element(name + '/read').outputs[0].name\r\n  variable_def.initializer_name = graph.as_graph_element(name + '/Assign').name\r\n  variable_def.trainable = trainable\r\n  i_name = name + '/Initializer/'\r\n  keys = [ k for k in graph._nodes_by_name.keys() if k.startswith(i_name) and '/' not in k[len(i_name):] ]\r\n  if len(keys) != 1:\r\n    raise ValueError('Could not find initializer for variable', keys)\r\n  variable_def.initial_value_name = graph.as_graph_element(keys[0]).outputs[0].name\r\n  var = tf.Variable.from_proto(variable_def)\r\n  for key in collections:\r\n    graph.add_to_collection(key, var)\r\n  return var\r\n```"}