{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13666", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13666/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13666/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13666/events", "html_url": "https://github.com/tensorflow/tensorflow/pull/13666", "id": 264978188, "node_id": "MDExOlB1bGxSZXF1ZXN0MTQ2MjM1MjYx", "number": 13666, "title": "Add GPU support and improve performance for tf.diag and tf.diag_part", "user": {"login": "jinze1994", "id": 13191886, "node_id": "MDQ6VXNlcjEzMTkxODg2", "avatar_url": "https://avatars3.githubusercontent.com/u/13191886?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jinze1994", "html_url": "https://github.com/jinze1994", "followers_url": "https://api.github.com/users/jinze1994/followers", "following_url": "https://api.github.com/users/jinze1994/following{/other_user}", "gists_url": "https://api.github.com/users/jinze1994/gists{/gist_id}", "starred_url": "https://api.github.com/users/jinze1994/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jinze1994/subscriptions", "organizations_url": "https://api.github.com/users/jinze1994/orgs", "repos_url": "https://api.github.com/users/jinze1994/repos", "events_url": "https://api.github.com/users/jinze1994/events{/privacy}", "received_events_url": "https://api.github.com/users/jinze1994/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 390482148, "node_id": "MDU6TGFiZWwzOTA0ODIxNDg=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/awaiting%20review", "name": "awaiting review", "color": "fef2c0", "default": false}, {"id": 300136587, "node_id": "MDU6TGFiZWwzMDAxMzY1ODc=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/cla:%20yes", "name": "cla: yes", "color": "009800", "default": false}], "state": "closed", "locked": false, "assignee": {"login": "cwhipkey", "id": 17578177, "node_id": "MDQ6VXNlcjE3NTc4MTc3", "avatar_url": "https://avatars0.githubusercontent.com/u/17578177?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cwhipkey", "html_url": "https://github.com/cwhipkey", "followers_url": "https://api.github.com/users/cwhipkey/followers", "following_url": "https://api.github.com/users/cwhipkey/following{/other_user}", "gists_url": "https://api.github.com/users/cwhipkey/gists{/gist_id}", "starred_url": "https://api.github.com/users/cwhipkey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cwhipkey/subscriptions", "organizations_url": "https://api.github.com/users/cwhipkey/orgs", "repos_url": "https://api.github.com/users/cwhipkey/repos", "events_url": "https://api.github.com/users/cwhipkey/events{/privacy}", "received_events_url": "https://api.github.com/users/cwhipkey/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "cwhipkey", "id": 17578177, "node_id": "MDQ6VXNlcjE3NTc4MTc3", "avatar_url": "https://avatars0.githubusercontent.com/u/17578177?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cwhipkey", "html_url": "https://github.com/cwhipkey", "followers_url": "https://api.github.com/users/cwhipkey/followers", "following_url": "https://api.github.com/users/cwhipkey/following{/other_user}", "gists_url": "https://api.github.com/users/cwhipkey/gists{/gist_id}", "starred_url": "https://api.github.com/users/cwhipkey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cwhipkey/subscriptions", "organizations_url": "https://api.github.com/users/cwhipkey/orgs", "repos_url": "https://api.github.com/users/cwhipkey/repos", "events_url": "https://api.github.com/users/cwhipkey/events{/privacy}", "received_events_url": "https://api.github.com/users/cwhipkey/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 17, "created_at": "2017-10-12T15:08:35Z", "updated_at": "2017-10-20T16:40:20Z", "closed_at": "2017-10-20T15:20:03Z", "author_association": "CONTRIBUTOR", "pull_request": {"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/13666", "html_url": "https://github.com/tensorflow/tensorflow/pull/13666", "diff_url": "https://github.com/tensorflow/tensorflow/pull/13666.diff", "patch_url": "https://github.com/tensorflow/tensorflow/pull/13666.patch"}, "body_html": "<p>This PR tries to settle the issue <a href=\"https://github.com/tensorflow/tensorflow/issues/13491\" data-hovercard-type=\"issue\" data-hovercard-url=\"/tensorflow/tensorflow/issues/13491/hovercard\">#13491</a> and makes some contribution for tf.diag and tf.diag_part:</p>\n<ul>\n<li>Add GPU support.</li>\n<li>Using a simple transfer trick makes code clear and easy to be parallel.</li>\n<li>Rewrite the CPU code using the recent rewrite of matrix_band_part as a template, which getting rid of the Eigen generator mechanism, remove the restriction which the input rank is at most 3.</li>\n</ul>\n<p>Implementation of transfer trick can be described as follows.</p>\n<p>According to the <a href=\"https://www.tensorflow.org/versions/master/api_docs/python/tf/diag\" rel=\"nofollow\">tf.diag</a> op definition, <code>output[i1,..., ik, i1,..., ik] = input[i1,..., ik]</code>.</p>\n<p>Let the rank of input is <code>[s1,..., sk]</code>, then any offset of input's pointer can be represented by coordinate <code>[i1,..., ik]</code>, where <code>index = i1*(s2*...*sk) + i2*(s3*...*sk) +... + ik</code>.</p>\n<p>Let new_index is the offset of output's pointer with coordinate <code>[i1,..., ik, i1,..., ik]</code>, then we have</p>\n<pre><code>new_index = i1*(s2*...sk*s1*...*sk) + i2*(s3*...*sk*s1*...*sk) +... + \\\n            ik*(s1*...*sk) + i1*(s2*...*sk) + i2*(s3*...*sk) +... + ik\n          = (i1*(s2*...*sk) + i2*(s3*...*sk) +... + ik) * (1 + s1*...*sk)\n          = index * (1 + s1*...*sk)\n</code></pre>\n<p>Let <code>size = s1*...*sk</code>, we finally have <code>new_index = index * (1 + size)</code>, which is the transfer function we use below.</p>\n<p>This trick make our implementations clear and easy to be parallel.</p>\n<p>If there is anything I need to modify, please let me know. Thank you for your review.</p>", "body_text": "This PR tries to settle the issue #13491 and makes some contribution for tf.diag and tf.diag_part:\n\nAdd GPU support.\nUsing a simple transfer trick makes code clear and easy to be parallel.\nRewrite the CPU code using the recent rewrite of matrix_band_part as a template, which getting rid of the Eigen generator mechanism, remove the restriction which the input rank is at most 3.\n\nImplementation of transfer trick can be described as follows.\nAccording to the tf.diag op definition, output[i1,..., ik, i1,..., ik] = input[i1,..., ik].\nLet the rank of input is [s1,..., sk], then any offset of input's pointer can be represented by coordinate [i1,..., ik], where index = i1*(s2*...*sk) + i2*(s3*...*sk) +... + ik.\nLet new_index is the offset of output's pointer with coordinate [i1,..., ik, i1,..., ik], then we have\nnew_index = i1*(s2*...sk*s1*...*sk) + i2*(s3*...*sk*s1*...*sk) +... + \\\n            ik*(s1*...*sk) + i1*(s2*...*sk) + i2*(s3*...*sk) +... + ik\n          = (i1*(s2*...*sk) + i2*(s3*...*sk) +... + ik) * (1 + s1*...*sk)\n          = index * (1 + s1*...*sk)\n\nLet size = s1*...*sk, we finally have new_index = index * (1 + size), which is the transfer function we use below.\nThis trick make our implementations clear and easy to be parallel.\nIf there is anything I need to modify, please let me know. Thank you for your review.", "body": "This PR tries to settle the issue [#13491](https://github.com/tensorflow/tensorflow/issues/13491) and makes some contribution for tf.diag and tf.diag_part:\r\n- Add GPU support.\r\n- Using a simple transfer trick makes code clear and easy to be parallel.\r\n- Rewrite the CPU code using the recent rewrite of matrix_band_part as a template, which getting rid of the Eigen generator mechanism, remove the restriction which the input rank is at most 3.\r\n\r\nImplementation of transfer trick can be described as follows.\r\n\r\nAccording to the [tf.diag](https://www.tensorflow.org/versions/master/api_docs/python/tf/diag) op definition, `output[i1,..., ik, i1,..., ik] = input[i1,..., ik]`.\r\n\r\nLet the rank of input is `[s1,..., sk]`, then any offset of input's pointer can be represented by coordinate `[i1,..., ik]`, where `index = i1*(s2*...*sk) + i2*(s3*...*sk) +... + ik`.\r\n\r\nLet new_index is the offset of output's pointer with coordinate `[i1,..., ik, i1,..., ik]`, then we have\r\n```\r\nnew_index = i1*(s2*...sk*s1*...*sk) + i2*(s3*...*sk*s1*...*sk) +... + \\\r\n            ik*(s1*...*sk) + i1*(s2*...*sk) + i2*(s3*...*sk) +... + ik\r\n          = (i1*(s2*...*sk) + i2*(s3*...*sk) +... + ik) * (1 + s1*...*sk)\r\n          = index * (1 + s1*...*sk)\r\n```\r\n\r\nLet `size = s1*...*sk`, we finally have `new_index = index * (1 + size)`, which is the transfer function we use below.\r\n\r\nThis trick make our implementations clear and easy to be parallel.\r\n\r\nIf there is anything I need to modify, please let me know. Thank you for your review."}