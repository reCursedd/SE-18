{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/301833621", "html_url": "https://github.com/tensorflow/tensorflow/issues/9931#issuecomment-301833621", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9931", "id": 301833621, "node_id": "MDEyOklzc3VlQ29tbWVudDMwMTgzMzYyMQ==", "user": {"login": "asimshankar", "id": 16018, "node_id": "MDQ6VXNlcjE2MDE4", "avatar_url": "https://avatars2.githubusercontent.com/u/16018?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asimshankar", "html_url": "https://github.com/asimshankar", "followers_url": "https://api.github.com/users/asimshankar/followers", "following_url": "https://api.github.com/users/asimshankar/following{/other_user}", "gists_url": "https://api.github.com/users/asimshankar/gists{/gist_id}", "starred_url": "https://api.github.com/users/asimshankar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asimshankar/subscriptions", "organizations_url": "https://api.github.com/users/asimshankar/orgs", "repos_url": "https://api.github.com/users/asimshankar/repos", "events_url": "https://api.github.com/users/asimshankar/events{/privacy}", "received_events_url": "https://api.github.com/users/asimshankar/received_events", "type": "User", "site_admin": false}, "created_at": "2017-05-16T16:13:55Z", "updated_at": "2017-05-16T16:13:55Z", "author_association": "MEMBER", "body_html": "<p>Thanks for the report <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=8427788\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/galeone\">@galeone</a> , there are multiple things going on here.</p>\n<ol>\n<li>\n<p>There was a bug in the underlying C API where it was suppressing errors during graph construction. That is fixed at head in <a class=\"commit-link\" data-hovercard-type=\"commit\" data-hovercard-url=\"https://github.com/tensorflow/tensorflow/commit/7d785f1e18af9d22d940f18aac6e8c9ffd268b22/hovercard\" href=\"https://github.com/tensorflow/tensorflow/commit/7d785f1e18af9d22d940f18aac6e8c9ffd268b22\"><tt>7d785f1</tt></a>, so it will be available with the 1.2 release of the TensorFlow C API</p>\n</li>\n<li>\n<p>The <code>Scope</code> type follows the \"builder pattern\" for graph construction. So, while <a href=\"https://godoc.org/github.com/tensorflow/tensorflow/tensorflow/go/op#ResizeNearestNeighbor\" rel=\"nofollow\"><code>op.ResizeNearestNeighbor(Scope*, ...)</code></a> doesn't return an error, errors are collected in <a href=\"https://godoc.org/github.com/tensorflow/tensorflow/tensorflow/go/op#Scope.Err\" rel=\"nofollow\"><code>Scope.Err</code></a>. This allows for more compact graph definitions (see the <a href=\"https://godoc.org/github.com/tensorflow/tensorflow/tensorflow/go/op#ex-package\" rel=\"nofollow\">package example for the <code>op</code> package</a>), at the cost of forgetting to check the error. Setting aside comments on the merits of this design, before using any of the returned <code>tf.Outputs</code> from the functions in the <code>op</code> package, one is encouraged to check the error. So, in line 30 of the snippet above for example, I'd suggest:</p>\n<div class=\"highlight highlight-source-go\"><pre><span class=\"pl-smi\">resize1</span> <span class=\"pl-k\">:=</span> op.<span class=\"pl-c1\">ResizeNearestNeighbor</span>(root.<span class=\"pl-c1\">SubScope</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>ResizeArea<span class=\"pl-pds\">\"</span></span>), value, op.<span class=\"pl-c1\">Const</span>(root.<span class=\"pl-c1\">SubScope</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>size<span class=\"pl-pds\">\"</span></span>), []<span class=\"pl-k\">int32</span>{<span class=\"pl-k\">int32</span>(<span class=\"pl-c1\">80</span>), <span class=\"pl-c1\">int32</span>(<span class=\"pl-c1\">80</span>)}))\n<span class=\"pl-k\">if</span> <span class=\"pl-smi\">err</span> <span class=\"pl-k\">:=</span> root.<span class=\"pl-c1\">Err</span>(); err != <span class=\"pl-c1\">nil</span> {\n    t.<span class=\"pl-c1\">Fatal</span>(err)\n}\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> If the size parameter is an int32, no error is raised but the operation is no sense</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> Because it returns ? instead of [80, 80, 3]</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> The reason is taht Resize* methods requires a batch of images: should raise an error?</span>\nfmt.<span class=\"pl-c1\">Println</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Shape with int32: <span class=\"pl-pds\">\"</span></span>, resize1.<span class=\"pl-c1\">Shape</span>().<span class=\"pl-c1\">String</span>())</pre></div>\n</li>\n<li>\n<p>Regardless, the Go API should never end up with segfaults from the underlying C API (in this case, providing an invalid <code>TF_Operation</code> pointer). So I'm going to send a fix for that.</p>\n</li>\n</ol>\n<p>Long story short: A couple of fixes will ensure error messages/panics that are more useful than the cryptic segfaults. Additionally, it's good practice to check the error on the <code>Scope</code> object.</p>\n<p>Hope that helps (will update this issue with the fix mentioned above). Comments/thoughts welcome.</p>", "body_text": "Thanks for the report @galeone , there are multiple things going on here.\n\n\nThere was a bug in the underlying C API where it was suppressing errors during graph construction. That is fixed at head in 7d785f1, so it will be available with the 1.2 release of the TensorFlow C API\n\n\nThe Scope type follows the \"builder pattern\" for graph construction. So, while op.ResizeNearestNeighbor(Scope*, ...) doesn't return an error, errors are collected in Scope.Err. This allows for more compact graph definitions (see the package example for the op package), at the cost of forgetting to check the error. Setting aside comments on the merits of this design, before using any of the returned tf.Outputs from the functions in the op package, one is encouraged to check the error. So, in line 30 of the snippet above for example, I'd suggest:\nresize1 := op.ResizeNearestNeighbor(root.SubScope(\"ResizeArea\"), value, op.Const(root.SubScope(\"size\"), []int32{int32(80), int32(80)}))\nif err := root.Err(); err != nil {\n    t.Fatal(err)\n}\n\n// If the size parameter is an int32, no error is raised but the operation is no sense\n// Because it returns ? instead of [80, 80, 3]\n// The reason is taht Resize* methods requires a batch of images: should raise an error?\nfmt.Println(\"Shape with int32: \", resize1.Shape().String())\n\n\nRegardless, the Go API should never end up with segfaults from the underlying C API (in this case, providing an invalid TF_Operation pointer). So I'm going to send a fix for that.\n\n\nLong story short: A couple of fixes will ensure error messages/panics that are more useful than the cryptic segfaults. Additionally, it's good practice to check the error on the Scope object.\nHope that helps (will update this issue with the fix mentioned above). Comments/thoughts welcome.", "body": "Thanks for the report @galeone , there are multiple things going on here.\r\n\r\n1. There was a bug in the underlying C API where it was suppressing errors during graph construction. That is fixed at head in 7d785f1e18af9d22d940f18aac6e8c9ffd268b22, so it will be available with the 1.2 release of the TensorFlow C API\r\n\r\n2. The `Scope` type follows the \"builder pattern\" for graph construction. So, while [`op.ResizeNearestNeighbor(Scope*, ...)`](https://godoc.org/github.com/tensorflow/tensorflow/tensorflow/go/op#ResizeNearestNeighbor) doesn't return an error, errors are collected in [`Scope.Err`](https://godoc.org/github.com/tensorflow/tensorflow/tensorflow/go/op#Scope.Err). This allows for more compact graph definitions (see the [package example for the `op` package](https://godoc.org/github.com/tensorflow/tensorflow/tensorflow/go/op#ex-package)), at the cost of forgetting to check the error. Setting aside comments on the merits of this design, before using any of the returned `tf.Outputs` from the functions in the `op` package, one is encouraged to check the error. So, in line 30 of the snippet above for example, I'd suggest:\r\n\r\n    ```go\r\n    resize1 := op.ResizeNearestNeighbor(root.SubScope(\"ResizeArea\"), value, op.Const(root.SubScope(\"size\"), []int32{int32(80), int32(80)}))\r\n    if err := root.Err(); err != nil {\r\n        t.Fatal(err)\r\n    }\r\n    \r\n    // If the size parameter is an int32, no error is raised but the operation is no sense\r\n    // Because it returns ? instead of [80, 80, 3]\r\n    // The reason is taht Resize* methods requires a batch of images: should raise an error?\r\n    fmt.Println(\"Shape with int32: \", resize1.Shape().String())\r\n    ```\r\n\r\n3. Regardless, the Go API should never end up with segfaults from the underlying C API (in this case, providing an invalid `TF_Operation` pointer). So I'm going to send a fix for that.\r\n\r\nLong story short: A couple of fixes will ensure error messages/panics that are more useful than the cryptic segfaults. Additionally, it's good practice to check the error on the `Scope` object.\r\n\r\nHope that helps (will update this issue with the fix mentioned above). Comments/thoughts welcome."}