{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9931", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9931/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9931/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9931/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/9931", "id": 228959136, "node_id": "MDU6SXNzdWUyMjg5NTkxMzY=", "number": 9931, "title": "Go: SIGSEGV when using int32 instead of int64 and missing error in Resize functions", "user": {"login": "galeone", "id": 8427788, "node_id": "MDQ6VXNlcjg0Mjc3ODg=", "avatar_url": "https://avatars1.githubusercontent.com/u/8427788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/galeone", "html_url": "https://github.com/galeone", "followers_url": "https://api.github.com/users/galeone/followers", "following_url": "https://api.github.com/users/galeone/following{/other_user}", "gists_url": "https://api.github.com/users/galeone/gists{/gist_id}", "starred_url": "https://api.github.com/users/galeone/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/galeone/subscriptions", "organizations_url": "https://api.github.com/users/galeone/orgs", "repos_url": "https://api.github.com/users/galeone/repos", "events_url": "https://api.github.com/users/galeone/events{/privacy}", "received_events_url": "https://api.github.com/users/galeone/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 473172988, "node_id": "MDU6TGFiZWw0NzMxNzI5ODg=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:bug/performance", "name": "type:bug/performance", "color": "159b2e", "default": false}], "state": "closed", "locked": false, "assignee": {"login": "asimshankar", "id": 16018, "node_id": "MDQ6VXNlcjE2MDE4", "avatar_url": "https://avatars2.githubusercontent.com/u/16018?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asimshankar", "html_url": "https://github.com/asimshankar", "followers_url": "https://api.github.com/users/asimshankar/followers", "following_url": "https://api.github.com/users/asimshankar/following{/other_user}", "gists_url": "https://api.github.com/users/asimshankar/gists{/gist_id}", "starred_url": "https://api.github.com/users/asimshankar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asimshankar/subscriptions", "organizations_url": "https://api.github.com/users/asimshankar/orgs", "repos_url": "https://api.github.com/users/asimshankar/repos", "events_url": "https://api.github.com/users/asimshankar/events{/privacy}", "received_events_url": "https://api.github.com/users/asimshankar/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "asimshankar", "id": 16018, "node_id": "MDQ6VXNlcjE2MDE4", "avatar_url": "https://avatars2.githubusercontent.com/u/16018?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asimshankar", "html_url": "https://github.com/asimshankar", "followers_url": "https://api.github.com/users/asimshankar/followers", "following_url": "https://api.github.com/users/asimshankar/following{/other_user}", "gists_url": "https://api.github.com/users/asimshankar/gists{/gist_id}", "starred_url": "https://api.github.com/users/asimshankar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asimshankar/subscriptions", "organizations_url": "https://api.github.com/users/asimshankar/orgs", "repos_url": "https://api.github.com/users/asimshankar/repos", "events_url": "https://api.github.com/users/asimshankar/events{/privacy}", "received_events_url": "https://api.github.com/users/asimshankar/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 7, "created_at": "2017-05-16T08:52:31Z", "updated_at": "2017-05-17T20:01:53Z", "closed_at": "2017-05-17T20:01:53Z", "author_association": "NONE", "body_html": "<h2>Problem</h2>\n<p>In Go, some operation causes a SIGSEGV when using an <code>int32</code> instead of an <code>int64</code> (and I have reasons to believe that the same will happen when using <code>float</code> instead of <code>double</code> and vice-versa).</p>\n<p>The <code>Resize*</code> operations don't define the output shape correctly when the input is not a \"batch\": they just let the dimensions undefined instead of raising some errors.</p>\n<p>The tests below are commented so I hope that's enough to let you understand what the problems are.</p>\n<h3>Source code / logs</h3>\n<div class=\"highlight highlight-source-go\"><pre><span class=\"pl-k\">package</span> poc_test\n\n<span class=\"pl-k\">import</span> (\n        <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>fmt<span class=\"pl-pds\">\"</span></span>\n        <span class=\"pl-c\"><span class=\"pl-c\">//</span>tf \"github.com/tensorflow/tensorflow/tensorflow/go\"</span>\n        <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>github.com/tensorflow/tensorflow/tensorflow/go/op<span class=\"pl-pds\">\"</span></span>\n        <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>testing<span class=\"pl-pds\">\"</span></span>\n)\n\n<span class=\"pl-k\">func</span> <span class=\"pl-en\">TestResizeWithoutBatchIsNoSense</span>(<span class=\"pl-v\">t</span> *<span class=\"pl-v\">testing</span>.<span class=\"pl-v\">T</span>) {\n        <span class=\"pl-c\"><span class=\"pl-c\">//</span> Create root scope</span>\n        <span class=\"pl-smi\">root</span> <span class=\"pl-k\">:=</span> op.<span class=\"pl-c1\">NewScope</span>()\n\n        <span class=\"pl-c\"><span class=\"pl-c\">//</span> Define graph</span>\n\n        <span class=\"pl-c\"><span class=\"pl-c\">//</span> 1: read image content</span>\n        <span class=\"pl-smi\">imagePath</span> <span class=\"pl-k\">:=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>test.jpg<span class=\"pl-pds\">\"</span></span>\n        <span class=\"pl-smi\">contents</span> <span class=\"pl-k\">:=</span> op.<span class=\"pl-c1\">ReadFile</span>(root.<span class=\"pl-c1\">SubScope</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>ReadFile<span class=\"pl-pds\">\"</span></span>), op.<span class=\"pl-c1\">Const</span>(root.<span class=\"pl-c1\">SubScope</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>filename<span class=\"pl-pds\">\"</span></span>), imagePath))\n\n        <span class=\"pl-c\"><span class=\"pl-c\">//</span> 2: decode Jpeg</span>\n        <span class=\"pl-smi\">value</span> <span class=\"pl-k\">:=</span> op.<span class=\"pl-c1\">DecodeJpeg</span>(root.<span class=\"pl-c1\">SubScope</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>DecodeJpeg<span class=\"pl-pds\">\"</span></span>), contents, op.<span class=\"pl-c1\">DecodeJpegChannels</span>(<span class=\"pl-c1\">3</span>))\n\n        <span class=\"pl-c\"><span class=\"pl-c\">//</span> I'd like to add noise to the image, so I'd like to define a nose tensor with the same shape of the image</span>\n        <span class=\"pl-c\"><span class=\"pl-c\">//</span> Just to be sure that the image shape is fully defined, I resize it</span>\n        <span class=\"pl-smi\">resize1</span> <span class=\"pl-k\">:=</span> op.<span class=\"pl-c1\">ResizeNearestNeighbor</span>(root.<span class=\"pl-c1\">SubScope</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>ResizeArea<span class=\"pl-pds\">\"</span></span>), value, op.<span class=\"pl-c1\">Const</span>(root.<span class=\"pl-c1\">SubScope</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>size<span class=\"pl-pds\">\"</span></span>), []<span class=\"pl-k\">int32</span>{<span class=\"pl-k\">int32</span>(<span class=\"pl-c1\">80</span>), <span class=\"pl-c1\">int32</span>(<span class=\"pl-c1\">80</span>)}))\n\n        <span class=\"pl-c\"><span class=\"pl-c\">//</span> If the size parameter is an int32, no error is raised but the operation is no sense</span>\n        <span class=\"pl-c\"><span class=\"pl-c\">//</span> Because it returns ? instead of [80, 80, 3]</span>\n        <span class=\"pl-c\"><span class=\"pl-c\">//</span> The reason is taht Resize* methods requires a batch of images: should raise an error?</span>\n        fmt.<span class=\"pl-c1\">Println</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Shape with int32: <span class=\"pl-pds\">\"</span></span>, resize1.<span class=\"pl-c1\">Shape</span>().<span class=\"pl-c1\">String</span>())\n        <span class=\"pl-k\">if</span> <span class=\"pl-smi\">dims64</span>, <span class=\"pl-smi\">err</span> <span class=\"pl-k\">:=</span> resize1.<span class=\"pl-c1\">Shape</span>().<span class=\"pl-c1\">ToSlice</span>(); err != <span class=\"pl-c1\">nil</span> {                                                                                                                                                                                                              \n                fmt.<span class=\"pl-c1\">Println</span>(dims64)                                                                                                                                                                                                                                            \n        } <span class=\"pl-k\">else</span> {                                                                                                                                                                                                                                                               \n                t.<span class=\"pl-c1\">Error</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Error: <span class=\"pl-pds\">\"</span></span>, err.<span class=\"pl-c1\">Error</span>())                                                                                                                                                                                                                                \n        }                                                                                                                                                                                                                                                                      \n                                                                                                                                                                                                                                                                               \n        <span class=\"pl-c\"><span class=\"pl-c\">//</span> I expect a fully defined shape                                                                                                                                                                                                                                      </span>\n        <span class=\"pl-k\">if</span> !resize1.<span class=\"pl-c1\">Shape</span>().<span class=\"pl-c1\">IsFullySpecified</span>() {                                                                                                                                                                                                                               \n                t.<span class=\"pl-c1\">Error</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Not defined shape<span class=\"pl-pds\">\"</span></span>)                                                                                                                                                                                                                                   \n        }                                                                                                                                                                                                                                                                      \n                                                                                                                                                                                                                                                                               \n        <span class=\"pl-c\"><span class=\"pl-c\">//</span> create the batch and see how things changes                                                                                                                                                                                                                         </span>\n        <span class=\"pl-smi\">batch</span> <span class=\"pl-k\">:=</span> op.<span class=\"pl-c1\">ExpandDims</span>(root.<span class=\"pl-c1\">SubScope</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>expand<span class=\"pl-pds\">\"</span></span>), value, op.<span class=\"pl-c1\">Const</span>(root.<span class=\"pl-c1\">SubScope</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>axis<span class=\"pl-pds\">\"</span></span>), []<span class=\"pl-k\">int32</span>{<span class=\"pl-c1\">0</span>}))                                                                                                                                                                    \n        resize1 = op.<span class=\"pl-c1\">ResizeNearestNeighbor</span>(root.<span class=\"pl-c1\">SubScope</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>ResizeArea<span class=\"pl-pds\">\"</span></span>), batch, op.<span class=\"pl-c1\">Const</span>(root.<span class=\"pl-c1\">SubScope</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>size<span class=\"pl-pds\">\"</span></span>), []<span class=\"pl-k\">int32</span>{<span class=\"pl-k\">int32</span>(<span class=\"pl-c1\">80</span>), <span class=\"pl-c1\">int32</span>(<span class=\"pl-c1\">80</span>)}))                                                                                                                                 \n        fmt.<span class=\"pl-c1\">Println</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Shape with int32 and input as a batch: <span class=\"pl-pds\">\"</span></span>, resize1.<span class=\"pl-c1\">Shape</span>().<span class=\"pl-c1\">String</span>())                                                                                                                                                                                       \n        <span class=\"pl-k\">if</span> <span class=\"pl-smi\">dims64</span>, <span class=\"pl-smi\">err</span> <span class=\"pl-k\">:=</span> resize1.<span class=\"pl-c1\">Shape</span>().<span class=\"pl-c1\">ToSlice</span>(); err == <span class=\"pl-c1\">nil</span> {                                                                                                                                                                                                              \n                fmt.<span class=\"pl-c1\">Println</span>(dims64)                                                                                                                                                                                                                                            \n        } <span class=\"pl-k\">else</span> {                                                                                                                                                                                                                                                               \n                fmt.<span class=\"pl-c1\">Println</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Error: <span class=\"pl-pds\">\"</span></span>, err.<span class=\"pl-c1\">Error</span>())                                                                                                                                                                                                                            \n        }                                                                                                                                                                                                                                                                      \n        <span class=\"pl-c\"><span class=\"pl-c\">//</span> Now the things have sense and the shape is defined and equals to [ 1, 80, 80, 3]                                                                                                                                                                                    </span>\n}                                                                                                                                                                                                                                                                              \n                                                                                                                                                                                                                                                                               \n<span class=\"pl-k\">func</span> <span class=\"pl-en\">TestResizeWithIn64ShapeSigSegvs</span>(<span class=\"pl-v\">t</span> *<span class=\"pl-v\">testing</span>.<span class=\"pl-v\">T</span>) {                                                                                                                                                                                                                           \n        <span class=\"pl-k\">defer</span> <span class=\"pl-k\">func</span>() {                                                                                                                                                                                                                                                         \n                <span class=\"pl-k\">if</span> <span class=\"pl-smi\">r</span> <span class=\"pl-k\">:=</span> <span class=\"pl-c1\">recover</span>(); r != <span class=\"pl-c1\">nil</span> {                                                                                                                                                                                                                                  \n                        t.<span class=\"pl-c1\">Error</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Panic!<span class=\"pl-pds\">\"</span></span>)                                                                                                                                                                                                                                      \n                }                                                                                                                                                                                                                                                              \n        }()\n        <span class=\"pl-c\"><span class=\"pl-c\">//</span> Create root scope</span>\n        <span class=\"pl-smi\">root</span> <span class=\"pl-k\">:=</span> op.<span class=\"pl-c1\">NewScope</span>()\n\n        <span class=\"pl-c\"><span class=\"pl-c\">//</span> Define graph</span>\n\n        <span class=\"pl-c\"><span class=\"pl-c\">//</span> 1: read image content</span>\n        <span class=\"pl-smi\">imagePath</span> <span class=\"pl-k\">:=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>test.jpg<span class=\"pl-pds\">\"</span></span>\n        <span class=\"pl-smi\">contents</span> <span class=\"pl-k\">:=</span> op.<span class=\"pl-c1\">ReadFile</span>(root.<span class=\"pl-c1\">SubScope</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>ReadFile<span class=\"pl-pds\">\"</span></span>), op.<span class=\"pl-c1\">Const</span>(root.<span class=\"pl-c1\">SubScope</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>filename<span class=\"pl-pds\">\"</span></span>), imagePath))\n\n        <span class=\"pl-c\"><span class=\"pl-c\">//</span> 2: decode Jpeg</span>\n        <span class=\"pl-smi\">value</span> <span class=\"pl-k\">:=</span> op.<span class=\"pl-c1\">DecodeJpeg</span>(root.<span class=\"pl-c1\">SubScope</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>DecodeJpeg<span class=\"pl-pds\">\"</span></span>), contents, op.<span class=\"pl-c1\">DecodeJpegChannels</span>(<span class=\"pl-c1\">3</span>))\n\n        <span class=\"pl-c\"><span class=\"pl-c\">//</span> However, changing int32 with int64 breaks everyting (no matter if I use `batch` or `value`)</span>\n        <span class=\"pl-smi\">resize2</span> <span class=\"pl-k\">:=</span> op.<span class=\"pl-c1\">ResizeArea</span>(root.<span class=\"pl-c1\">SubScope</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>ResizeArea2<span class=\"pl-pds\">\"</span></span>), value, op.<span class=\"pl-c1\">Const</span>(root.<span class=\"pl-c1\">SubScope</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>size2<span class=\"pl-pds\">\"</span></span>), []<span class=\"pl-k\">int64</span>{<span class=\"pl-k\">int64</span>(<span class=\"pl-c1\">80</span>), <span class=\"pl-c1\">int64</span>(<span class=\"pl-c1\">80</span>)}))\n        <span class=\"pl-c\"><span class=\"pl-c\">//</span> This operation causes a SIGSEGV</span>\n        fmt.<span class=\"pl-c1\">Println</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Shape value: <span class=\"pl-pds\">\"</span></span>, resize2.<span class=\"pl-c1\">Shape</span>())\n        fmt.<span class=\"pl-c1\">Println</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Shape with int64: <span class=\"pl-pds\">\"</span></span>, resize2.<span class=\"pl-c1\">Shape</span>().<span class=\"pl-c1\">String</span>())\n\n        <span class=\"pl-c\"><span class=\"pl-c\">//</span> In short, chaning int32 with int64 causes SIGSEGV. It looks like kernels are not registered to handle both types</span>\n\n        <span class=\"pl-c\"><span class=\"pl-c\">//</span> This can bring the code to be a mess to debug, because If I'd like to, for example, add noise to an image</span>\n        <span class=\"pl-c\"><span class=\"pl-c\">//</span> I have to generate a set of values with the same shape of the input images.</span>\n        <span class=\"pl-c\"><span class=\"pl-c\">//</span> Using the one with the defined shape (the batch) I'd like to use the output of Shape().ToSlice()</span>\n        <span class=\"pl-c\"><span class=\"pl-c\">//</span> But I can't.</span>\n}\n\n<span class=\"pl-k\">func</span> <span class=\"pl-en\">TestGenerateNoiseWithInt32Shape</span>(<span class=\"pl-v\">t</span> *<span class=\"pl-v\">testing</span>.<span class=\"pl-v\">T</span>) {\n        <span class=\"pl-k\">defer</span> <span class=\"pl-k\">func</span>() {\n                <span class=\"pl-k\">if</span> <span class=\"pl-smi\">r</span> <span class=\"pl-k\">:=</span> <span class=\"pl-c1\">recover</span>(); r != <span class=\"pl-c1\">nil</span> {\n                        t.<span class=\"pl-c1\">Error</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Panic!<span class=\"pl-pds\">\"</span></span>)\n                }\n        }()\n        <span class=\"pl-c\"><span class=\"pl-c\">//</span> Create root scope</span>\n        <span class=\"pl-smi\">root</span> <span class=\"pl-k\">:=</span> op.<span class=\"pl-c1\">NewScope</span>()\n\n        <span class=\"pl-c\"><span class=\"pl-c\">//</span> Define graph</span>\n\n        <span class=\"pl-c\"><span class=\"pl-c\">//</span> 1: read image content</span>\n        <span class=\"pl-smi\">imagePath</span> <span class=\"pl-k\">:=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>test.jpg<span class=\"pl-pds\">\"</span></span>\n        <span class=\"pl-smi\">contents</span> <span class=\"pl-k\">:=</span> op.<span class=\"pl-c1\">ReadFile</span>(root.<span class=\"pl-c1\">SubScope</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>ReadFile<span class=\"pl-pds\">\"</span></span>), op.<span class=\"pl-c1\">Const</span>(root.<span class=\"pl-c1\">SubScope</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>filename<span class=\"pl-pds\">\"</span></span>), imagePath))\n        <span class=\"pl-c\"><span class=\"pl-c\">//</span> 2: decode Jpeg</span>\n        <span class=\"pl-smi\">value</span> <span class=\"pl-k\">:=</span> op.<span class=\"pl-c1\">DecodeJpeg</span>(root.<span class=\"pl-c1\">SubScope</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>DecodeJpeg<span class=\"pl-pds\">\"</span></span>), contents, op.<span class=\"pl-c1\">DecodeJpegChannels</span>(<span class=\"pl-c1\">3</span>))\n        <span class=\"pl-smi\">batch</span> <span class=\"pl-k\">:=</span> op.<span class=\"pl-c1\">ExpandDims</span>(root.<span class=\"pl-c1\">SubScope</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>expand<span class=\"pl-pds\">\"</span></span>), value, op.<span class=\"pl-c1\">Const</span>(root.<span class=\"pl-c1\">SubScope</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>axis<span class=\"pl-pds\">\"</span></span>), []<span class=\"pl-k\">int32</span>{<span class=\"pl-c1\">0</span>}))\n        <span class=\"pl-smi\">resize1</span> <span class=\"pl-k\">:=</span> op.<span class=\"pl-c1\">ResizeNearestNeighbor</span>(root.<span class=\"pl-c1\">SubScope</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>ResizeArea<span class=\"pl-pds\">\"</span></span>), batch, op.<span class=\"pl-c1\">Const</span>(root.<span class=\"pl-c1\">SubScope</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>size<span class=\"pl-pds\">\"</span></span>), []<span class=\"pl-k\">int32</span>{<span class=\"pl-k\">int32</span>(<span class=\"pl-c1\">80</span>), <span class=\"pl-c1\">int32</span>(<span class=\"pl-c1\">80</span>)}))\n        fmt.<span class=\"pl-c1\">Println</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Shape with int32 and input as a batch: <span class=\"pl-pds\">\"</span></span>, resize1.<span class=\"pl-c1\">Shape</span>().<span class=\"pl-c1\">String</span>())\n        <span class=\"pl-k\">if</span> <span class=\"pl-smi\">dims64</span>, <span class=\"pl-smi\">err</span> <span class=\"pl-k\">:=</span> resize1.<span class=\"pl-c1\">Shape</span>().<span class=\"pl-c1\">ToSlice</span>(); err != <span class=\"pl-c1\">nil</span> {\n                fmt.<span class=\"pl-c1\">Println</span>(dims64)\n        } <span class=\"pl-k\">else</span> {\n                fmt.<span class=\"pl-c1\">Println</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Error: <span class=\"pl-pds\">\"</span></span>, err.<span class=\"pl-c1\">Error</span>())\n        }\n\n        <span class=\"pl-smi\">dims64</span>, <span class=\"pl-smi\">_</span> <span class=\"pl-k\">:=</span> resize1.<span class=\"pl-c1\">Shape</span>().<span class=\"pl-c1\">ToSlice</span>()\n        <span class=\"pl-smi\">noise</span> <span class=\"pl-k\">:=</span> op.<span class=\"pl-c1\">ParameterizedTruncatedNormal</span>(root.<span class=\"pl-c1\">SubScope</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>ParameterizedTruncatedNormal<span class=\"pl-pds\">\"</span></span>),\n                op.<span class=\"pl-c1\">Const</span>(root.<span class=\"pl-c1\">SubScope</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>shape<span class=\"pl-pds\">\"</span></span>), dims64),\n                op.<span class=\"pl-c1\">Const</span>(root.<span class=\"pl-c1\">SubScope</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>means<span class=\"pl-pds\">\"</span></span>), <span class=\"pl-c1\">0</span>.),\n                op.<span class=\"pl-c1\">Const</span>(root.<span class=\"pl-c1\">SubScope</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>stddev<span class=\"pl-pds\">\"</span></span>), <span class=\"pl-c1\">1</span>.),\n                op.<span class=\"pl-c1\">Const</span>(root.<span class=\"pl-c1\">SubScope</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>minvals<span class=\"pl-pds\">\"</span></span>), <span class=\"pl-c1\">0</span>.),\n                op.<span class=\"pl-c1\">Const</span>(root.<span class=\"pl-c1\">SubScope</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>maxvals<span class=\"pl-pds\">\"</span></span>), <span class=\"pl-c1\">1</span>.))\n        fmt.<span class=\"pl-c1\">Println</span>(noise)\n\n        <span class=\"pl-c\"><span class=\"pl-c\">//</span> ^ This operation causes SIGSEGV</span>\n        <span class=\"pl-c\"><span class=\"pl-c\">//</span> I have to convert dims64 to a slice of int32 and then the operation works</span>\n\n}\n\n<span class=\"pl-k\">func</span> <span class=\"pl-en\">TestGenerateNoiseWithInt64Shape</span>(<span class=\"pl-v\">t</span> *<span class=\"pl-v\">testing</span>.<span class=\"pl-v\">T</span>) {\n        <span class=\"pl-c\"><span class=\"pl-c\">//</span> Create root scope</span>\n        <span class=\"pl-smi\">root</span> <span class=\"pl-k\">:=</span> op.<span class=\"pl-c1\">NewScope</span>()\n\n        <span class=\"pl-c\"><span class=\"pl-c\">//</span> Define graph</span>\n\n        <span class=\"pl-c\"><span class=\"pl-c\">//</span> 1: read image content</span>\n        <span class=\"pl-smi\">imagePath</span> <span class=\"pl-k\">:=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>test.jpg<span class=\"pl-pds\">\"</span></span>\n        <span class=\"pl-smi\">contents</span> <span class=\"pl-k\">:=</span> op.<span class=\"pl-c1\">ReadFile</span>(root.<span class=\"pl-c1\">SubScope</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>ReadFile<span class=\"pl-pds\">\"</span></span>), op.<span class=\"pl-c1\">Const</span>(root.<span class=\"pl-c1\">SubScope</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>filename<span class=\"pl-pds\">\"</span></span>), imagePath))\n        <span class=\"pl-c\"><span class=\"pl-c\">//</span> 2: decode Jpeg</span>\n        <span class=\"pl-smi\">value</span> <span class=\"pl-k\">:=</span> op.<span class=\"pl-c1\">DecodeJpeg</span>(root.<span class=\"pl-c1\">SubScope</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>DecodeJpeg<span class=\"pl-pds\">\"</span></span>), contents, op.<span class=\"pl-c1\">DecodeJpegChannels</span>(<span class=\"pl-c1\">3</span>))\n        <span class=\"pl-smi\">batch</span> <span class=\"pl-k\">:=</span> op.<span class=\"pl-c1\">ExpandDims</span>(root.<span class=\"pl-c1\">SubScope</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>expand<span class=\"pl-pds\">\"</span></span>), value, op.<span class=\"pl-c1\">Const</span>(root.<span class=\"pl-c1\">SubScope</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>axis<span class=\"pl-pds\">\"</span></span>), []<span class=\"pl-k\">int32</span>{<span class=\"pl-c1\">0</span>}))\n        <span class=\"pl-smi\">resize1</span> <span class=\"pl-k\">:=</span> op.<span class=\"pl-c1\">ResizeNearestNeighbor</span>(root.<span class=\"pl-c1\">SubScope</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>ResizeArea<span class=\"pl-pds\">\"</span></span>), batch, op.<span class=\"pl-c1\">Const</span>(root.<span class=\"pl-c1\">SubScope</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>size<span class=\"pl-pds\">\"</span></span>), []<span class=\"pl-k\">int32</span>{<span class=\"pl-k\">int32</span>(<span class=\"pl-c1\">80</span>), <span class=\"pl-c1\">int32</span>(<span class=\"pl-c1\">80</span>)}))\n        fmt.<span class=\"pl-c1\">Println</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Shape with int32 and input as a batch: <span class=\"pl-pds\">\"</span></span>, resize1.<span class=\"pl-c1\">Shape</span>().<span class=\"pl-c1\">String</span>())\n        <span class=\"pl-k\">if</span> <span class=\"pl-smi\">dims64</span>, <span class=\"pl-smi\">err</span> <span class=\"pl-k\">:=</span> resize1.<span class=\"pl-c1\">Shape</span>().<span class=\"pl-c1\">ToSlice</span>(); err != <span class=\"pl-c1\">nil</span> {\n                fmt.<span class=\"pl-c1\">Println</span>(dims64)\n        } <span class=\"pl-k\">else</span> {\n                fmt.<span class=\"pl-c1\">Println</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Error: <span class=\"pl-pds\">\"</span></span>, err.<span class=\"pl-c1\">Error</span>())\n        }\n\n        <span class=\"pl-smi\">dims64</span>, <span class=\"pl-smi\">_</span> <span class=\"pl-k\">:=</span> resize1.<span class=\"pl-c1\">Shape</span>().<span class=\"pl-c1\">ToSlice</span>()\n\n        <span class=\"pl-k\">var</span> <span class=\"pl-smi\">dims</span> []<span class=\"pl-k\">int32</span> = <span class=\"pl-c1\">make</span>([]<span class=\"pl-k\">int32</span>, <span class=\"pl-c1\">len</span>(dims64))\n        <span class=\"pl-k\">for</span> <span class=\"pl-smi\">i</span>, <span class=\"pl-smi\">dim</span> <span class=\"pl-k\">:=</span> <span class=\"pl-k\">range</span> dims64 {\n                dims[i] = <span class=\"pl-c1\">int32</span>(dim)\n        }\n\n        <span class=\"pl-smi\">noise</span> <span class=\"pl-k\">:=</span> op.<span class=\"pl-c1\">ParameterizedTruncatedNormal</span>(root.<span class=\"pl-c1\">SubScope</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>ParameterizedTruncatedNormal<span class=\"pl-pds\">\"</span></span>),\n                op.<span class=\"pl-c1\">Const</span>(root.<span class=\"pl-c1\">SubScope</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>shape<span class=\"pl-pds\">\"</span></span>), dims64),\n                op.<span class=\"pl-c1\">Const</span>(root.<span class=\"pl-c1\">SubScope</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>means<span class=\"pl-pds\">\"</span></span>), <span class=\"pl-c1\">0</span>.),\n                op.<span class=\"pl-c1\">Const</span>(root.<span class=\"pl-c1\">SubScope</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>stddev<span class=\"pl-pds\">\"</span></span>), <span class=\"pl-c1\">1</span>.),\n                op.<span class=\"pl-c1\">Const</span>(root.<span class=\"pl-c1\">SubScope</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>minvals<span class=\"pl-pds\">\"</span></span>), <span class=\"pl-c1\">0</span>.),\n                op.<span class=\"pl-c1\">Const</span>(root.<span class=\"pl-c1\">SubScope</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>maxvals<span class=\"pl-pds\">\"</span></span>), <span class=\"pl-c1\">1</span>.))\n        fmt.<span class=\"pl-c1\">Println</span>(noise.<span class=\"pl-c1\">Shape</span>().<span class=\"pl-c1\">String</span>())\n}\n</pre></div>\n<h3>System information</h3>\n<ul>\n<li><strong>Have I written custom code (as opposed to using a stock example script provided in TensorFlow)</strong>: yes</li>\n<li><strong>OS Platform and Distribution (e.g., Linux Ubuntu 16.04)</strong>: Archlinux</li>\n<li><strong>TensorFlow installed from (source or binary)</strong>: source</li>\n<li><strong>TensorFlow version (use command below)</strong>: 1.1.0-rc2</li>\n<li><strong>Bazel version (if compiling from source)</strong>: 0.4.5</li>\n<li><strong>CUDA/cuDNN version</strong>: cuda 8, cudnn 5.1</li>\n<li><strong>GPU model and memory</strong>:  GeForce GTX 1080</li>\n<li><strong>Exact command to reproduce</strong>: <code>go test</code></li>\n</ul>", "body_text": "Problem\nIn Go, some operation causes a SIGSEGV when using an int32 instead of an int64 (and I have reasons to believe that the same will happen when using float instead of double and vice-versa).\nThe Resize* operations don't define the output shape correctly when the input is not a \"batch\": they just let the dimensions undefined instead of raising some errors.\nThe tests below are commented so I hope that's enough to let you understand what the problems are.\nSource code / logs\npackage poc_test\n\nimport (\n        \"fmt\"\n        //tf \"github.com/tensorflow/tensorflow/tensorflow/go\"\n        \"github.com/tensorflow/tensorflow/tensorflow/go/op\"\n        \"testing\"\n)\n\nfunc TestResizeWithoutBatchIsNoSense(t *testing.T) {\n        // Create root scope\n        root := op.NewScope()\n\n        // Define graph\n\n        // 1: read image content\n        imagePath := \"test.jpg\"\n        contents := op.ReadFile(root.SubScope(\"ReadFile\"), op.Const(root.SubScope(\"filename\"), imagePath))\n\n        // 2: decode Jpeg\n        value := op.DecodeJpeg(root.SubScope(\"DecodeJpeg\"), contents, op.DecodeJpegChannels(3))\n\n        // I'd like to add noise to the image, so I'd like to define a nose tensor with the same shape of the image\n        // Just to be sure that the image shape is fully defined, I resize it\n        resize1 := op.ResizeNearestNeighbor(root.SubScope(\"ResizeArea\"), value, op.Const(root.SubScope(\"size\"), []int32{int32(80), int32(80)}))\n\n        // If the size parameter is an int32, no error is raised but the operation is no sense\n        // Because it returns ? instead of [80, 80, 3]\n        // The reason is taht Resize* methods requires a batch of images: should raise an error?\n        fmt.Println(\"Shape with int32: \", resize1.Shape().String())\n        if dims64, err := resize1.Shape().ToSlice(); err != nil {                                                                                                                                                                                                              \n                fmt.Println(dims64)                                                                                                                                                                                                                                            \n        } else {                                                                                                                                                                                                                                                               \n                t.Error(\"Error: \", err.Error())                                                                                                                                                                                                                                \n        }                                                                                                                                                                                                                                                                      \n                                                                                                                                                                                                                                                                               \n        // I expect a fully defined shape                                                                                                                                                                                                                                      \n        if !resize1.Shape().IsFullySpecified() {                                                                                                                                                                                                                               \n                t.Error(\"Not defined shape\")                                                                                                                                                                                                                                   \n        }                                                                                                                                                                                                                                                                      \n                                                                                                                                                                                                                                                                               \n        // create the batch and see how things changes                                                                                                                                                                                                                         \n        batch := op.ExpandDims(root.SubScope(\"expand\"), value, op.Const(root.SubScope(\"axis\"), []int32{0}))                                                                                                                                                                    \n        resize1 = op.ResizeNearestNeighbor(root.SubScope(\"ResizeArea\"), batch, op.Const(root.SubScope(\"size\"), []int32{int32(80), int32(80)}))                                                                                                                                 \n        fmt.Println(\"Shape with int32 and input as a batch: \", resize1.Shape().String())                                                                                                                                                                                       \n        if dims64, err := resize1.Shape().ToSlice(); err == nil {                                                                                                                                                                                                              \n                fmt.Println(dims64)                                                                                                                                                                                                                                            \n        } else {                                                                                                                                                                                                                                                               \n                fmt.Println(\"Error: \", err.Error())                                                                                                                                                                                                                            \n        }                                                                                                                                                                                                                                                                      \n        // Now the things have sense and the shape is defined and equals to [ 1, 80, 80, 3]                                                                                                                                                                                    \n}                                                                                                                                                                                                                                                                              \n                                                                                                                                                                                                                                                                               \nfunc TestResizeWithIn64ShapeSigSegvs(t *testing.T) {                                                                                                                                                                                                                           \n        defer func() {                                                                                                                                                                                                                                                         \n                if r := recover(); r != nil {                                                                                                                                                                                                                                  \n                        t.Error(\"Panic!\")                                                                                                                                                                                                                                      \n                }                                                                                                                                                                                                                                                              \n        }()\n        // Create root scope\n        root := op.NewScope()\n\n        // Define graph\n\n        // 1: read image content\n        imagePath := \"test.jpg\"\n        contents := op.ReadFile(root.SubScope(\"ReadFile\"), op.Const(root.SubScope(\"filename\"), imagePath))\n\n        // 2: decode Jpeg\n        value := op.DecodeJpeg(root.SubScope(\"DecodeJpeg\"), contents, op.DecodeJpegChannels(3))\n\n        // However, changing int32 with int64 breaks everyting (no matter if I use `batch` or `value`)\n        resize2 := op.ResizeArea(root.SubScope(\"ResizeArea2\"), value, op.Const(root.SubScope(\"size2\"), []int64{int64(80), int64(80)}))\n        // This operation causes a SIGSEGV\n        fmt.Println(\"Shape value: \", resize2.Shape())\n        fmt.Println(\"Shape with int64: \", resize2.Shape().String())\n\n        // In short, chaning int32 with int64 causes SIGSEGV. It looks like kernels are not registered to handle both types\n\n        // This can bring the code to be a mess to debug, because If I'd like to, for example, add noise to an image\n        // I have to generate a set of values with the same shape of the input images.\n        // Using the one with the defined shape (the batch) I'd like to use the output of Shape().ToSlice()\n        // But I can't.\n}\n\nfunc TestGenerateNoiseWithInt32Shape(t *testing.T) {\n        defer func() {\n                if r := recover(); r != nil {\n                        t.Error(\"Panic!\")\n                }\n        }()\n        // Create root scope\n        root := op.NewScope()\n\n        // Define graph\n\n        // 1: read image content\n        imagePath := \"test.jpg\"\n        contents := op.ReadFile(root.SubScope(\"ReadFile\"), op.Const(root.SubScope(\"filename\"), imagePath))\n        // 2: decode Jpeg\n        value := op.DecodeJpeg(root.SubScope(\"DecodeJpeg\"), contents, op.DecodeJpegChannels(3))\n        batch := op.ExpandDims(root.SubScope(\"expand\"), value, op.Const(root.SubScope(\"axis\"), []int32{0}))\n        resize1 := op.ResizeNearestNeighbor(root.SubScope(\"ResizeArea\"), batch, op.Const(root.SubScope(\"size\"), []int32{int32(80), int32(80)}))\n        fmt.Println(\"Shape with int32 and input as a batch: \", resize1.Shape().String())\n        if dims64, err := resize1.Shape().ToSlice(); err != nil {\n                fmt.Println(dims64)\n        } else {\n                fmt.Println(\"Error: \", err.Error())\n        }\n\n        dims64, _ := resize1.Shape().ToSlice()\n        noise := op.ParameterizedTruncatedNormal(root.SubScope(\"ParameterizedTruncatedNormal\"),\n                op.Const(root.SubScope(\"shape\"), dims64),\n                op.Const(root.SubScope(\"means\"), 0.),\n                op.Const(root.SubScope(\"stddev\"), 1.),\n                op.Const(root.SubScope(\"minvals\"), 0.),\n                op.Const(root.SubScope(\"maxvals\"), 1.))\n        fmt.Println(noise)\n\n        // ^ This operation causes SIGSEGV\n        // I have to convert dims64 to a slice of int32 and then the operation works\n\n}\n\nfunc TestGenerateNoiseWithInt64Shape(t *testing.T) {\n        // Create root scope\n        root := op.NewScope()\n\n        // Define graph\n\n        // 1: read image content\n        imagePath := \"test.jpg\"\n        contents := op.ReadFile(root.SubScope(\"ReadFile\"), op.Const(root.SubScope(\"filename\"), imagePath))\n        // 2: decode Jpeg\n        value := op.DecodeJpeg(root.SubScope(\"DecodeJpeg\"), contents, op.DecodeJpegChannels(3))\n        batch := op.ExpandDims(root.SubScope(\"expand\"), value, op.Const(root.SubScope(\"axis\"), []int32{0}))\n        resize1 := op.ResizeNearestNeighbor(root.SubScope(\"ResizeArea\"), batch, op.Const(root.SubScope(\"size\"), []int32{int32(80), int32(80)}))\n        fmt.Println(\"Shape with int32 and input as a batch: \", resize1.Shape().String())\n        if dims64, err := resize1.Shape().ToSlice(); err != nil {\n                fmt.Println(dims64)\n        } else {\n                fmt.Println(\"Error: \", err.Error())\n        }\n\n        dims64, _ := resize1.Shape().ToSlice()\n\n        var dims []int32 = make([]int32, len(dims64))\n        for i, dim := range dims64 {\n                dims[i] = int32(dim)\n        }\n\n        noise := op.ParameterizedTruncatedNormal(root.SubScope(\"ParameterizedTruncatedNormal\"),\n                op.Const(root.SubScope(\"shape\"), dims64),\n                op.Const(root.SubScope(\"means\"), 0.),\n                op.Const(root.SubScope(\"stddev\"), 1.),\n                op.Const(root.SubScope(\"minvals\"), 0.),\n                op.Const(root.SubScope(\"maxvals\"), 1.))\n        fmt.Println(noise.Shape().String())\n}\n\nSystem information\n\nHave I written custom code (as opposed to using a stock example script provided in TensorFlow): yes\nOS Platform and Distribution (e.g., Linux Ubuntu 16.04): Archlinux\nTensorFlow installed from (source or binary): source\nTensorFlow version (use command below): 1.1.0-rc2\nBazel version (if compiling from source): 0.4.5\nCUDA/cuDNN version: cuda 8, cudnn 5.1\nGPU model and memory:  GeForce GTX 1080\nExact command to reproduce: go test", "body": "## Problem\r\n\r\nIn Go, some operation causes a SIGSEGV when using an `int32` instead of an `int64` (and I have reasons to believe that the same will happen when using `float` instead of `double` and vice-versa).\r\n\r\nThe `Resize*` operations don't define the output shape correctly when the input is not a \"batch\": they just let the dimensions undefined instead of raising some errors.\r\n\r\nThe tests below are commented so I hope that's enough to let you understand what the problems are.\r\n\r\n### Source code / logs\r\n\r\n```go\r\npackage poc_test\r\n\r\nimport (\r\n        \"fmt\"\r\n        //tf \"github.com/tensorflow/tensorflow/tensorflow/go\"\r\n        \"github.com/tensorflow/tensorflow/tensorflow/go/op\"\r\n        \"testing\"\r\n)\r\n\r\nfunc TestResizeWithoutBatchIsNoSense(t *testing.T) {\r\n        // Create root scope\r\n        root := op.NewScope()\r\n\r\n        // Define graph\r\n\r\n        // 1: read image content\r\n        imagePath := \"test.jpg\"\r\n        contents := op.ReadFile(root.SubScope(\"ReadFile\"), op.Const(root.SubScope(\"filename\"), imagePath))\r\n\r\n        // 2: decode Jpeg\r\n        value := op.DecodeJpeg(root.SubScope(\"DecodeJpeg\"), contents, op.DecodeJpegChannels(3))\r\n\r\n        // I'd like to add noise to the image, so I'd like to define a nose tensor with the same shape of the image\r\n        // Just to be sure that the image shape is fully defined, I resize it\r\n        resize1 := op.ResizeNearestNeighbor(root.SubScope(\"ResizeArea\"), value, op.Const(root.SubScope(\"size\"), []int32{int32(80), int32(80)}))\r\n\r\n        // If the size parameter is an int32, no error is raised but the operation is no sense\r\n        // Because it returns ? instead of [80, 80, 3]\r\n        // The reason is taht Resize* methods requires a batch of images: should raise an error?\r\n        fmt.Println(\"Shape with int32: \", resize1.Shape().String())\r\n        if dims64, err := resize1.Shape().ToSlice(); err != nil {                                                                                                                                                                                                              \r\n                fmt.Println(dims64)                                                                                                                                                                                                                                            \r\n        } else {                                                                                                                                                                                                                                                               \r\n                t.Error(\"Error: \", err.Error())                                                                                                                                                                                                                                \r\n        }                                                                                                                                                                                                                                                                      \r\n                                                                                                                                                                                                                                                                               \r\n        // I expect a fully defined shape                                                                                                                                                                                                                                      \r\n        if !resize1.Shape().IsFullySpecified() {                                                                                                                                                                                                                               \r\n                t.Error(\"Not defined shape\")                                                                                                                                                                                                                                   \r\n        }                                                                                                                                                                                                                                                                      \r\n                                                                                                                                                                                                                                                                               \r\n        // create the batch and see how things changes                                                                                                                                                                                                                         \r\n        batch := op.ExpandDims(root.SubScope(\"expand\"), value, op.Const(root.SubScope(\"axis\"), []int32{0}))                                                                                                                                                                    \r\n        resize1 = op.ResizeNearestNeighbor(root.SubScope(\"ResizeArea\"), batch, op.Const(root.SubScope(\"size\"), []int32{int32(80), int32(80)}))                                                                                                                                 \r\n        fmt.Println(\"Shape with int32 and input as a batch: \", resize1.Shape().String())                                                                                                                                                                                       \r\n        if dims64, err := resize1.Shape().ToSlice(); err == nil {                                                                                                                                                                                                              \r\n                fmt.Println(dims64)                                                                                                                                                                                                                                            \r\n        } else {                                                                                                                                                                                                                                                               \r\n                fmt.Println(\"Error: \", err.Error())                                                                                                                                                                                                                            \r\n        }                                                                                                                                                                                                                                                                      \r\n        // Now the things have sense and the shape is defined and equals to [ 1, 80, 80, 3]                                                                                                                                                                                    \r\n}                                                                                                                                                                                                                                                                              \r\n                                                                                                                                                                                                                                                                               \r\nfunc TestResizeWithIn64ShapeSigSegvs(t *testing.T) {                                                                                                                                                                                                                           \r\n        defer func() {                                                                                                                                                                                                                                                         \r\n                if r := recover(); r != nil {                                                                                                                                                                                                                                  \r\n                        t.Error(\"Panic!\")                                                                                                                                                                                                                                      \r\n                }                                                                                                                                                                                                                                                              \r\n        }()\r\n        // Create root scope\r\n        root := op.NewScope()\r\n\r\n        // Define graph\r\n\r\n        // 1: read image content\r\n        imagePath := \"test.jpg\"\r\n        contents := op.ReadFile(root.SubScope(\"ReadFile\"), op.Const(root.SubScope(\"filename\"), imagePath))\r\n\r\n        // 2: decode Jpeg\r\n        value := op.DecodeJpeg(root.SubScope(\"DecodeJpeg\"), contents, op.DecodeJpegChannels(3))\r\n\r\n        // However, changing int32 with int64 breaks everyting (no matter if I use `batch` or `value`)\r\n        resize2 := op.ResizeArea(root.SubScope(\"ResizeArea2\"), value, op.Const(root.SubScope(\"size2\"), []int64{int64(80), int64(80)}))\r\n        // This operation causes a SIGSEGV\r\n        fmt.Println(\"Shape value: \", resize2.Shape())\r\n        fmt.Println(\"Shape with int64: \", resize2.Shape().String())\r\n\r\n        // In short, chaning int32 with int64 causes SIGSEGV. It looks like kernels are not registered to handle both types\r\n\r\n        // This can bring the code to be a mess to debug, because If I'd like to, for example, add noise to an image\r\n        // I have to generate a set of values with the same shape of the input images.\r\n        // Using the one with the defined shape (the batch) I'd like to use the output of Shape().ToSlice()\r\n        // But I can't.\r\n}\r\n\r\nfunc TestGenerateNoiseWithInt32Shape(t *testing.T) {\r\n        defer func() {\r\n                if r := recover(); r != nil {\r\n                        t.Error(\"Panic!\")\r\n                }\r\n        }()\r\n        // Create root scope\r\n        root := op.NewScope()\r\n\r\n        // Define graph\r\n\r\n        // 1: read image content\r\n        imagePath := \"test.jpg\"\r\n        contents := op.ReadFile(root.SubScope(\"ReadFile\"), op.Const(root.SubScope(\"filename\"), imagePath))\r\n        // 2: decode Jpeg\r\n        value := op.DecodeJpeg(root.SubScope(\"DecodeJpeg\"), contents, op.DecodeJpegChannels(3))\r\n        batch := op.ExpandDims(root.SubScope(\"expand\"), value, op.Const(root.SubScope(\"axis\"), []int32{0}))\r\n        resize1 := op.ResizeNearestNeighbor(root.SubScope(\"ResizeArea\"), batch, op.Const(root.SubScope(\"size\"), []int32{int32(80), int32(80)}))\r\n        fmt.Println(\"Shape with int32 and input as a batch: \", resize1.Shape().String())\r\n        if dims64, err := resize1.Shape().ToSlice(); err != nil {\r\n                fmt.Println(dims64)\r\n        } else {\r\n                fmt.Println(\"Error: \", err.Error())\r\n        }\r\n\r\n        dims64, _ := resize1.Shape().ToSlice()\r\n        noise := op.ParameterizedTruncatedNormal(root.SubScope(\"ParameterizedTruncatedNormal\"),\r\n                op.Const(root.SubScope(\"shape\"), dims64),\r\n                op.Const(root.SubScope(\"means\"), 0.),\r\n                op.Const(root.SubScope(\"stddev\"), 1.),\r\n                op.Const(root.SubScope(\"minvals\"), 0.),\r\n                op.Const(root.SubScope(\"maxvals\"), 1.))\r\n        fmt.Println(noise)\r\n\r\n        // ^ This operation causes SIGSEGV\r\n        // I have to convert dims64 to a slice of int32 and then the operation works\r\n\r\n}\r\n\r\nfunc TestGenerateNoiseWithInt64Shape(t *testing.T) {\r\n        // Create root scope\r\n        root := op.NewScope()\r\n\r\n        // Define graph\r\n\r\n        // 1: read image content\r\n        imagePath := \"test.jpg\"\r\n        contents := op.ReadFile(root.SubScope(\"ReadFile\"), op.Const(root.SubScope(\"filename\"), imagePath))\r\n        // 2: decode Jpeg\r\n        value := op.DecodeJpeg(root.SubScope(\"DecodeJpeg\"), contents, op.DecodeJpegChannels(3))\r\n        batch := op.ExpandDims(root.SubScope(\"expand\"), value, op.Const(root.SubScope(\"axis\"), []int32{0}))\r\n        resize1 := op.ResizeNearestNeighbor(root.SubScope(\"ResizeArea\"), batch, op.Const(root.SubScope(\"size\"), []int32{int32(80), int32(80)}))\r\n        fmt.Println(\"Shape with int32 and input as a batch: \", resize1.Shape().String())\r\n        if dims64, err := resize1.Shape().ToSlice(); err != nil {\r\n                fmt.Println(dims64)\r\n        } else {\r\n                fmt.Println(\"Error: \", err.Error())\r\n        }\r\n\r\n        dims64, _ := resize1.Shape().ToSlice()\r\n\r\n        var dims []int32 = make([]int32, len(dims64))\r\n        for i, dim := range dims64 {\r\n                dims[i] = int32(dim)\r\n        }\r\n\r\n        noise := op.ParameterizedTruncatedNormal(root.SubScope(\"ParameterizedTruncatedNormal\"),\r\n                op.Const(root.SubScope(\"shape\"), dims64),\r\n                op.Const(root.SubScope(\"means\"), 0.),\r\n                op.Const(root.SubScope(\"stddev\"), 1.),\r\n                op.Const(root.SubScope(\"minvals\"), 0.),\r\n                op.Const(root.SubScope(\"maxvals\"), 1.))\r\n        fmt.Println(noise.Shape().String())\r\n}\r\n\r\n```\r\n\r\n### System information\r\n- **Have I written custom code (as opposed to using a stock example script provided in TensorFlow)**: yes\r\n- **OS Platform and Distribution (e.g., Linux Ubuntu 16.04)**: Archlinux\r\n- **TensorFlow installed from (source or binary)**: source\r\n- **TensorFlow version (use command below)**: 1.1.0-rc2\r\n- **Bazel version (if compiling from source)**: 0.4.5\r\n- **CUDA/cuDNN version**: cuda 8, cudnn 5.1\r\n- **GPU model and memory**:  GeForce GTX 1080\r\n- **Exact command to reproduce**: `go test`\r\n"}