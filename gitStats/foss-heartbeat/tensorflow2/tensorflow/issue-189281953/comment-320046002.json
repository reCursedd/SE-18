{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/320046002", "html_url": "https://github.com/tensorflow/tensorflow/issues/5609#issuecomment-320046002", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5609", "id": 320046002, "node_id": "MDEyOklzc3VlQ29tbWVudDMyMDA0NjAwMg==", "user": {"login": "AndreasMadsen", "id": 505333, "node_id": "MDQ6VXNlcjUwNTMzMw==", "avatar_url": "https://avatars0.githubusercontent.com/u/505333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AndreasMadsen", "html_url": "https://github.com/AndreasMadsen", "followers_url": "https://api.github.com/users/AndreasMadsen/followers", "following_url": "https://api.github.com/users/AndreasMadsen/following{/other_user}", "gists_url": "https://api.github.com/users/AndreasMadsen/gists{/gist_id}", "starred_url": "https://api.github.com/users/AndreasMadsen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AndreasMadsen/subscriptions", "organizations_url": "https://api.github.com/users/AndreasMadsen/orgs", "repos_url": "https://api.github.com/users/AndreasMadsen/repos", "events_url": "https://api.github.com/users/AndreasMadsen/events{/privacy}", "received_events_url": "https://api.github.com/users/AndreasMadsen/received_events", "type": "User", "site_admin": false}, "created_at": "2017-08-03T18:04:58Z", "updated_at": "2017-08-03T18:04:58Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=13489453\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/francotheengineer\">@francotheengineer</a> you can replace it with something like this:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">class</span> <span class=\"pl-en\">SequenceQueueExternal</span>(<span class=\"pl-e\">SequenceQueue</span>):\n    data_file: <span class=\"pl-c1\">str</span>\n    writer <span class=\"pl-k\">=</span> tf.python_io.TFRecordWriter\n\n    <span class=\"pl-k\">def</span> <span class=\"pl-c1\">__init__</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>, <span class=\"pl-smi\">external_encoding</span>: <span class=\"pl-c1\">str</span>, <span class=\"pl-k\">*</span><span class=\"pl-smi\">args</span>, <span class=\"pl-k\">**</span><span class=\"pl-smi\">kwargs</span>):\n        <span class=\"pl-c1\">self</span>.data_file <span class=\"pl-k\">=</span> path.realpath(external_encoding)\n\n        <span class=\"pl-c\"><span class=\"pl-c\">#</span> detect if data file exists</span>\n        has_data <span class=\"pl-k\">=</span> (path.exists(<span class=\"pl-c1\">self</span>.data_file) <span class=\"pl-k\">and</span>\n                    os.stat(<span class=\"pl-c1\">self</span>.data_file).st_size <span class=\"pl-k\">&gt;</span> <span class=\"pl-c1\">0</span>)\n        <span class=\"pl-c1\">super</span>().<span class=\"pl-c1\">__init__</span>(<span class=\"pl-k\">not</span> has_data, <span class=\"pl-k\">*</span>args, <span class=\"pl-k\">**</span>kwargs)\n\n        <span class=\"pl-k\">if</span> <span class=\"pl-c1\">self</span>.need_data:\n            os.makedirs(path.dirname(<span class=\"pl-c1\">self</span>.data_file), <span class=\"pl-v\">exist_ok</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">True</span>)\n            <span class=\"pl-k\">with</span> <span class=\"pl-c1\">open</span>(<span class=\"pl-c1\">self</span>.data_file, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>w<span class=\"pl-pds\">'</span></span>):\n                <span class=\"pl-c1\">self</span>.writer <span class=\"pl-k\">=</span> tf.python_io.TFRecordWriter(\n                    <span class=\"pl-c1\">self</span>.data_file,\n                    <span class=\"pl-v\">options</span><span class=\"pl-k\">=</span>tf.python_io.TFRecordOptions(\n                        tf.python_io.TFRecordCompressionType.<span class=\"pl-c1\">ZLIB</span>\n                    )\n                )\n\n    <span class=\"pl-k\">def</span> <span class=\"pl-en\">write</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>,\n              <span class=\"pl-smi\">length</span>: <span class=\"pl-c1\">int</span>, <span class=\"pl-smi\">source</span>: np.ndarray, <span class=\"pl-smi\">target</span>: np.ndarray) -&gt; <span class=\"pl-c1\">None</span>:\n        <span class=\"pl-k\">if</span> <span class=\"pl-k\">not</span> <span class=\"pl-c1\">self</span>.need_data:\n            <span class=\"pl-k\">raise</span> <span class=\"pl-c1\">RuntimeError</span>(\n                <span class=\"pl-s\"><span class=\"pl-pds\">'</span>queue.write should not be called when need_data is false<span class=\"pl-pds\">'</span></span>\n            )\n\n        example <span class=\"pl-k\">=</span> make_sequence_example(length, source, target)\n        <span class=\"pl-c1\">self</span>.writer.write(example.SerializeToString())\n\n    <span class=\"pl-k\">def</span> <span class=\"pl-en\">read</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>) -&gt; Tuple[tf.Tensor, tf.Tensor, tf.Tensor]:\n        <span class=\"pl-k\">if</span> <span class=\"pl-c1\">self</span>.need_data:\n            <span class=\"pl-c1\">self</span>.writer.close()\n\n        <span class=\"pl-c\"><span class=\"pl-c\">#</span> create filename queue of one filename. TFRecordReader demands this.</span>\n        filename_queue <span class=\"pl-k\">=</span> tf.train.string_input_producer(\n            [<span class=\"pl-c1\">self</span>.data_file],\n            <span class=\"pl-v\">num_epochs</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">None</span> <span class=\"pl-k\">if</span> <span class=\"pl-c1\">self</span>.repeat <span class=\"pl-k\">else</span> <span class=\"pl-c1\">1</span>,\n            <span class=\"pl-v\">name</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">self</span>.name\n        )\n\n        <span class=\"pl-c\"><span class=\"pl-c\">#</span> read serialized data</span>\n        reader <span class=\"pl-k\">=</span> tf.TFRecordReader(\n            <span class=\"pl-v\">options</span><span class=\"pl-k\">=</span>tf.python_io.TFRecordOptions(\n                tf.python_io.TFRecordCompressionType.<span class=\"pl-c1\">ZLIB</span>\n            )\n        )\n        reader_dequeue <span class=\"pl-k\">=</span> reader.read(filename_queue)\n\n        <span class=\"pl-c\"><span class=\"pl-c\">#</span> parse data</span>\n        length, source, target <span class=\"pl-k\">=</span> parse_sequence_example(reader_dequeue.value)\n\n        <span class=\"pl-c\"><span class=\"pl-c\">#</span> cast to original type</span>\n        length <span class=\"pl-k\">=</span> tf.cast(length, <span class=\"pl-v\">dtype</span><span class=\"pl-k\">=</span>tf.int32)\n        source <span class=\"pl-k\">=</span> tf.cast(source, <span class=\"pl-v\">dtype</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">self</span>.dtype)\n        target <span class=\"pl-k\">=</span> tf.cast(target, <span class=\"pl-v\">dtype</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">self</span>.dtype)\n\n        <span class=\"pl-c\"><span class=\"pl-c\">#</span> To get a continues shuffling behaviour similar to suffle_batch</span>\n        <span class=\"pl-c\"><span class=\"pl-c\">#</span> put in a RandomShuffleQueue</span>\n        <span class=\"pl-k\">if</span> <span class=\"pl-c1\">self</span>.shuffle:\n            length, source, target <span class=\"pl-k\">=</span> shuffle_tensor_list(\n                (length, source, target),\n                <span class=\"pl-v\">capacity</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">self</span>.batch_size <span class=\"pl-k\">*</span> <span class=\"pl-c1\">128</span>,\n                <span class=\"pl-v\">min_after_dequeue</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">self</span>.batch_size <span class=\"pl-k\">*</span> <span class=\"pl-c1\">64</span>,\n                <span class=\"pl-v\">seed</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">self</span>.seed,\n                <span class=\"pl-v\">name</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">self</span>.name\n            )\n\n        <span class=\"pl-k\">return</span> (length, source, target)</pre></div>", "body_text": "@francotheengineer you can replace it with something like this:\nclass SequenceQueueExternal(SequenceQueue):\n    data_file: str\n    writer = tf.python_io.TFRecordWriter\n\n    def __init__(self, external_encoding: str, *args, **kwargs):\n        self.data_file = path.realpath(external_encoding)\n\n        # detect if data file exists\n        has_data = (path.exists(self.data_file) and\n                    os.stat(self.data_file).st_size > 0)\n        super().__init__(not has_data, *args, **kwargs)\n\n        if self.need_data:\n            os.makedirs(path.dirname(self.data_file), exist_ok=True)\n            with open(self.data_file, 'w'):\n                self.writer = tf.python_io.TFRecordWriter(\n                    self.data_file,\n                    options=tf.python_io.TFRecordOptions(\n                        tf.python_io.TFRecordCompressionType.ZLIB\n                    )\n                )\n\n    def write(self,\n              length: int, source: np.ndarray, target: np.ndarray) -> None:\n        if not self.need_data:\n            raise RuntimeError(\n                'queue.write should not be called when need_data is false'\n            )\n\n        example = make_sequence_example(length, source, target)\n        self.writer.write(example.SerializeToString())\n\n    def read(self) -> Tuple[tf.Tensor, tf.Tensor, tf.Tensor]:\n        if self.need_data:\n            self.writer.close()\n\n        # create filename queue of one filename. TFRecordReader demands this.\n        filename_queue = tf.train.string_input_producer(\n            [self.data_file],\n            num_epochs=None if self.repeat else 1,\n            name=self.name\n        )\n\n        # read serialized data\n        reader = tf.TFRecordReader(\n            options=tf.python_io.TFRecordOptions(\n                tf.python_io.TFRecordCompressionType.ZLIB\n            )\n        )\n        reader_dequeue = reader.read(filename_queue)\n\n        # parse data\n        length, source, target = parse_sequence_example(reader_dequeue.value)\n\n        # cast to original type\n        length = tf.cast(length, dtype=tf.int32)\n        source = tf.cast(source, dtype=self.dtype)\n        target = tf.cast(target, dtype=self.dtype)\n\n        # To get a continues shuffling behaviour similar to suffle_batch\n        # put in a RandomShuffleQueue\n        if self.shuffle:\n            length, source, target = shuffle_tensor_list(\n                (length, source, target),\n                capacity=self.batch_size * 128,\n                min_after_dequeue=self.batch_size * 64,\n                seed=self.seed,\n                name=self.name\n            )\n\n        return (length, source, target)", "body": "@francotheengineer you can replace it with something like this:\r\n\r\n```py\r\n\r\nclass SequenceQueueExternal(SequenceQueue):\r\n    data_file: str\r\n    writer = tf.python_io.TFRecordWriter\r\n\r\n    def __init__(self, external_encoding: str, *args, **kwargs):\r\n        self.data_file = path.realpath(external_encoding)\r\n\r\n        # detect if data file exists\r\n        has_data = (path.exists(self.data_file) and\r\n                    os.stat(self.data_file).st_size > 0)\r\n        super().__init__(not has_data, *args, **kwargs)\r\n\r\n        if self.need_data:\r\n            os.makedirs(path.dirname(self.data_file), exist_ok=True)\r\n            with open(self.data_file, 'w'):\r\n                self.writer = tf.python_io.TFRecordWriter(\r\n                    self.data_file,\r\n                    options=tf.python_io.TFRecordOptions(\r\n                        tf.python_io.TFRecordCompressionType.ZLIB\r\n                    )\r\n                )\r\n\r\n    def write(self,\r\n              length: int, source: np.ndarray, target: np.ndarray) -> None:\r\n        if not self.need_data:\r\n            raise RuntimeError(\r\n                'queue.write should not be called when need_data is false'\r\n            )\r\n\r\n        example = make_sequence_example(length, source, target)\r\n        self.writer.write(example.SerializeToString())\r\n\r\n    def read(self) -> Tuple[tf.Tensor, tf.Tensor, tf.Tensor]:\r\n        if self.need_data:\r\n            self.writer.close()\r\n\r\n        # create filename queue of one filename. TFRecordReader demands this.\r\n        filename_queue = tf.train.string_input_producer(\r\n            [self.data_file],\r\n            num_epochs=None if self.repeat else 1,\r\n            name=self.name\r\n        )\r\n\r\n        # read serialized data\r\n        reader = tf.TFRecordReader(\r\n            options=tf.python_io.TFRecordOptions(\r\n                tf.python_io.TFRecordCompressionType.ZLIB\r\n            )\r\n        )\r\n        reader_dequeue = reader.read(filename_queue)\r\n\r\n        # parse data\r\n        length, source, target = parse_sequence_example(reader_dequeue.value)\r\n\r\n        # cast to original type\r\n        length = tf.cast(length, dtype=tf.int32)\r\n        source = tf.cast(source, dtype=self.dtype)\r\n        target = tf.cast(target, dtype=self.dtype)\r\n\r\n        # To get a continues shuffling behaviour similar to suffle_batch\r\n        # put in a RandomShuffleQueue\r\n        if self.shuffle:\r\n            length, source, target = shuffle_tensor_list(\r\n                (length, source, target),\r\n                capacity=self.batch_size * 128,\r\n                min_after_dequeue=self.batch_size * 64,\r\n                seed=self.seed,\r\n                name=self.name\r\n            )\r\n\r\n        return (length, source, target)\r\n```"}