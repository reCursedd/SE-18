{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/209381592", "pull_request_review_id": 145387965, "id": 209381592, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwOTM4MTU5Mg==", "diff_hunk": "@@ -0,0 +1,236 @@\n+/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\r\n+\r\n+Licensed under the Apache License, Version 2.0 (the \"License\");\r\n+you may not use this file except in compliance with the License.\r\n+You may obtain a copy of the License at\r\n+\r\n+    http://www.apache.org/licenses/LICENSE-2.0\r\n+\r\n+Unless required by applicable law or agreed to in writing, software\r\n+distributed under the License is distributed on an \"AS IS\" BASIS,\r\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n+See the License for the specific language governing permissions and\r\n+limitations under the License.\r\n+==============================================================================*/\r\n+\r\n+#include \"tensorflow/core/framework/op_kernel.h\"\r\n+#include \"tensorflow/core/framework/register_types.h\"\r\n+#include \"tensorflow/core/framework/tensor.h\"\r\n+#include \"tensorflow/core/framework/tensor_shape.h\"\r\n+#include \"tensorflow/core/framework/tensor_util.h\"\r\n+#include \"tensorflow/core/framework/types.h\"\r\n+#include \"tensorflow/core/lib/strings/str_util.h\"\r\n+#include \"tensorflow/core/util/sparse/sparse_tensor.h\"\r\n+\r\n+using tensorflow::sparse::SparseTensor;\r\n+\r\n+namespace tensorflow {\r\n+\r\n+struct ReduceDetails {\r\n+  // The dimensions to call Reorder() with.\r\n+  std::vector<int64> reorder_dims;\r\n+  // The dimensions to call group() with after Reorder().\r\n+  std::vector<int64> group_by_dims;\r\n+  // The shape after reduction.\r\n+  TensorShape reduced_shape;\r\n+};\r\n+\r\n+ReduceDetails SparseTensorReduceHelper(const SparseTensor& sp,\r\n+                                       gtl::ArraySlice<int32> axes_slice) {\r\n+  ReduceDetails reduction;\r\n+\r\n+  std::vector<int32> reduction_axes(axes_slice.begin(), axes_slice.end());\r\n+  int ndims = sp.dims();\r\n+  for (int64 i = 0; i < reduction_axes.size(); ++i) {\r\n+    reduction_axes[i] = (reduction_axes[i] + ndims) % ndims;\r\n+  }\r\n+  std::sort(reduction_axes.begin(), reduction_axes.end());\r\n+\r\n+  // (0) Calculate the grouping dimensions:\r\n+  // group_by_dims == {0, .., NDIMS-1} \\ reduction_axes.\r\n+  std::vector<int64> perm(ndims);\r\n+  std::iota(perm.begin(), perm.end(), 0);\r\n+\r\n+  // Requires perm and reduction_axes_ be sorted; group_by_dims will be\r\n+  // sorted as well.\r\n+  std::set_difference(\r\n+      perm.begin(), perm.end(), reduction_axes.begin(), reduction_axes.end(),\r\n+      std::inserter(reduction.group_by_dims, reduction.group_by_dims.begin()));\r\n+\r\n+  // Now append the rest of the axes (the complement of group_by_dims_);\r\n+  // result is used by Reorder().\r\n+  reduction.reorder_dims = reduction.group_by_dims;\r\n+  std::set_difference(perm.begin(), perm.end(), reduction.group_by_dims.begin(),\r\n+                      reduction.group_by_dims.end(),\r\n+                      std::back_inserter(reduction.reorder_dims));\r\n+\r\n+  // (1) Calculate the shape after reduction.\r\n+  auto sp_shape = sp.shape();\r\n+  std::vector<int64> out_dim_sizes;\r\n+  out_dim_sizes = sp.PickDims(reduction.group_by_dims);\r\n+\r\n+  reduction.reduced_shape = TensorShape(out_dim_sizes);\r\n+  return reduction;\r\n+}\r\n+\r\n+std::vector<int64> GetRowOfTensor(const Tensor t, const int64 i) {\r\n+  std::vector<int64> res;\r\n+  auto t_values = t.matrix<int64>();\r\n+  for (int64 j = 0; j < t.shape().dim_size(1); j++) {\r\n+    res.push_back(t_values(i, j));\r\n+  }\r\n+  return res;\r\n+}\r\n+\r\n+// This operator is used for tiling a to a new SparseTensor like b.\r\n+template <typename T>\r\n+class SparseTileLikeOp : public OpKernel {\r\n+ public:\r\n+  explicit SparseTileLikeOp(OpKernelConstruction* context)\r\n+      : OpKernel(context) {}\r\n+\r\n+  void Compute(OpKernelContext* ctx) override {\r\n+    // Define the tensors.\r\n+    const Tensor *a_indices_t, *a_values_t, *a_shape_t, *b_indices_t,\r\n+        *b_values_t, *b_shape_t, *axes_t;\r\n+\r\n+    OP_REQUIRES_OK(ctx, ctx->input(\"a_input_indices\", &a_indices_t));\r\n+    OP_REQUIRES_OK(ctx, ctx->input(\"a_input_values\", &a_values_t));\r\n+    OP_REQUIRES_OK(ctx, ctx->input(\"a_input_shape\", &a_shape_t));\r\n+    OP_REQUIRES_OK(ctx, ctx->input(\"b_input_indices\", &b_indices_t));\r\n+    OP_REQUIRES_OK(ctx, ctx->input(\"b_input_values\", &b_values_t));\r\n+    OP_REQUIRES_OK(ctx, ctx->input(\"b_input_shape\", &b_shape_t));\r\n+    OP_REQUIRES_OK(ctx, ctx->input(\"axes\", &axes_t));\r\n+\r\n+    ValidateInput(ctx, a_indices_t, a_values_t, a_shape_t, b_indices_t,\r\n+                  b_values_t, b_shape_t, axes_t);\r\n+\r\n+    // Set values for out_values.\r\n+    std::vector<int64> group_axes;\r\n+    std::vector<int64> reduction_a;\r\n+    auto axes = axes_t->flat<int32>();\r\n+    int64 a = 0;\r\n+    for (int32 i = 0; i < b_shape_t->dim_size(0); i++) {\r\n+      if (i != axes(0)) {\r\n+        group_axes.push_back(i);\r\n+        reduction_a.push_back(a);\r\n+        a++;\r\n+      }\r\n+    }\r\n+\r\n+    SparseTensor sp_b(tensor::DeepCopy(*b_indices_t),\r\n+                      tensor::DeepCopy(*b_values_t),\r\n+                      TensorShape(b_shape_t->vec<int64>()));\r\n+    ReduceDetails reduction =\r\n+        SparseTensorReduceHelper(sp_b, axes_t->flat<int32>());\r\n+    sp_b.Reorder<T>(reduction.reorder_dims);\r\n+\r\n+    SparseTensor sp_a(tensor::DeepCopy(*a_indices_t),\r\n+                      tensor::DeepCopy(*a_values_t),\r\n+                      TensorShape(a_shape_t->vec<int64>()));\r\n+    sp_a.Reorder<T>(reduction_a);\r\n+\r\n+    std::vector<T> out_values_vec;\r\n+    int64 h = 0;\r\n+    int64 output_shape0 = 0;\r\n+    int64 tmp_count = 0;\r\n+    std::vector<int64> output_ids;\r\n+    auto a_values = a_values_t->vec<T>();\r\n+\r\n+    for (const auto& g : sp_b.group(group_axes)) {\r\n+      std::vector<int64> group = g.group();\r\n+      std::vector<int64> row = GetRowOfTensor(sp_a.indices(), h);\r\n+      int64 g_indice_len = g.values<T>().dimension(0);\r\n+      while (row < group) {\r", "path": "tensorflow/contrib/layers/kernels/sparse_tile_like_kernel.cc", "position": 144, "original_position": 144, "commit_id": "65961683050079b9bb8d2c6a66120dd9d476cc07", "original_commit_id": "65961683050079b9bb8d2c6a66120dd9d476cc07", "user": {"login": "drpngx", "id": 20959853, "node_id": "MDQ6VXNlcjIwOTU5ODUz", "avatar_url": "https://avatars1.githubusercontent.com/u/20959853?v=4", "gravatar_id": "", "url": "https://api.github.com/users/drpngx", "html_url": "https://github.com/drpngx", "followers_url": "https://api.github.com/users/drpngx/followers", "following_url": "https://api.github.com/users/drpngx/following{/other_user}", "gists_url": "https://api.github.com/users/drpngx/gists{/gist_id}", "starred_url": "https://api.github.com/users/drpngx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/drpngx/subscriptions", "organizations_url": "https://api.github.com/users/drpngx/orgs", "repos_url": "https://api.github.com/users/drpngx/repos", "events_url": "https://api.github.com/users/drpngx/events{/privacy}", "received_events_url": "https://api.github.com/users/drpngx/received_events", "type": "User", "site_admin": false}, "body": "huh? Does that build?", "created_at": "2018-08-10T20:51:20Z", "updated_at": "2018-08-10T20:52:14Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/15184#discussion_r209381592", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/15184", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/209381592"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/15184#discussion_r209381592"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/15184"}}, "body_html": "<p>huh? Does that build?</p>", "body_text": "huh? Does that build?"}