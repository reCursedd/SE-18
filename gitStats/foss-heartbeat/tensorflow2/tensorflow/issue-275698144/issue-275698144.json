{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/14755", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/14755/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/14755/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/14755/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/14755", "id": 275698144, "node_id": "MDU6SXNzdWUyNzU2OTgxNDQ=", "number": 14755, "title": "Problem with assigning values to matrix indices in tensorflow", "user": {"login": "cohen5", "id": 22967057, "node_id": "MDQ6VXNlcjIyOTY3MDU3", "avatar_url": "https://avatars0.githubusercontent.com/u/22967057?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cohen5", "html_url": "https://github.com/cohen5", "followers_url": "https://api.github.com/users/cohen5/followers", "following_url": "https://api.github.com/users/cohen5/following{/other_user}", "gists_url": "https://api.github.com/users/cohen5/gists{/gist_id}", "starred_url": "https://api.github.com/users/cohen5/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cohen5/subscriptions", "organizations_url": "https://api.github.com/users/cohen5/orgs", "repos_url": "https://api.github.com/users/cohen5/repos", "events_url": "https://api.github.com/users/cohen5/events{/privacy}", "received_events_url": "https://api.github.com/users/cohen5/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2017-11-21T12:42:01Z", "updated_at": "2017-12-01T00:20:55Z", "closed_at": "2017-12-01T00:20:55Z", "author_association": "NONE", "body_html": "<p>Hi,</p>\n<p>I am constructing a NN with tensorflow that uses a custom stddev function. I have for a batch and indices i and j a function <code>AcrossBatchSD(batch, i, j)</code>. Of course, <code>import tensorflow as tf</code>.</p>\n<pre><code>def AcrossBatchSD(batch, i, j):\n\n    _, varR = tf.nn.moments(batch[:, i, j, 0], axes=[0])\n    _, varG = tf.nn.moments(batch[:, i, j, 1], axes=[0])\n    _, varB = tf.nn.moments(batch[:, i, j, 2], axes=[0]) \n \n    return tf.sqrt(varR), tf.sqrt(varG), tf.sqrt(varB)\n</code></pre>\n<p>This function seems to work, but then I would like to do the following:</p>\n<pre><code>def MinibatchStdDev(batch, window, mb_size):\n\n    n = batch[0].shape[0].value \n    f1 = tf.Variable(tf.zeros([n, n]))\n    f2 = tf.Variable(tf.zeros([n, n]))\n    f3 = tf.Variable(tf.zeros([n, n]))\n\n    for i in range(n):\n        for j in range(n):\n\n            sqrtR, sqrtG, sqrtB = AcrossBatchSD(batch, i, j)          \n            f1[i, j].assign(sqrtR)\n            f2[i, j].assign(sqrtG)\n            f3[i, j].assign(sqrtB) \n                \n    f = tf.divide(tf.add(tf.add(f1, f2), f3), 3)\n    F = tf.reduce_mean(f)\n\n    return tf.multiply(F, tf.ones(([mb_size, window, window]))))\n</code></pre>\n<p>My problem is that the function <code>assign</code> in tensorflow is not differentiable, so <code>tf.gradients</code> will outout a <code>NoneType</code>. Therefore, my network cannot be trained.</p>\n<p>A test can be done with</p>\n<pre><code>mb_size = 3\nwindow = 4\nbatch = tf.Variable(tf.random_normal([mb_size, 1024, 1024, 3]), tf.float32)\nout = MinibatchStdDev(batch=batch, window=window, mb_size=mb_size)\ninit = tf.global_variables_initializer()\nsess = tf.Session()\nsess.run(init)\nsess.run(out)\n</code></pre>", "body_text": "Hi,\nI am constructing a NN with tensorflow that uses a custom stddev function. I have for a batch and indices i and j a function AcrossBatchSD(batch, i, j). Of course, import tensorflow as tf.\ndef AcrossBatchSD(batch, i, j):\n\n    _, varR = tf.nn.moments(batch[:, i, j, 0], axes=[0])\n    _, varG = tf.nn.moments(batch[:, i, j, 1], axes=[0])\n    _, varB = tf.nn.moments(batch[:, i, j, 2], axes=[0]) \n \n    return tf.sqrt(varR), tf.sqrt(varG), tf.sqrt(varB)\n\nThis function seems to work, but then I would like to do the following:\ndef MinibatchStdDev(batch, window, mb_size):\n\n    n = batch[0].shape[0].value \n    f1 = tf.Variable(tf.zeros([n, n]))\n    f2 = tf.Variable(tf.zeros([n, n]))\n    f3 = tf.Variable(tf.zeros([n, n]))\n\n    for i in range(n):\n        for j in range(n):\n\n            sqrtR, sqrtG, sqrtB = AcrossBatchSD(batch, i, j)          \n            f1[i, j].assign(sqrtR)\n            f2[i, j].assign(sqrtG)\n            f3[i, j].assign(sqrtB) \n                \n    f = tf.divide(tf.add(tf.add(f1, f2), f3), 3)\n    F = tf.reduce_mean(f)\n\n    return tf.multiply(F, tf.ones(([mb_size, window, window]))))\n\nMy problem is that the function assign in tensorflow is not differentiable, so tf.gradients will outout a NoneType. Therefore, my network cannot be trained.\nA test can be done with\nmb_size = 3\nwindow = 4\nbatch = tf.Variable(tf.random_normal([mb_size, 1024, 1024, 3]), tf.float32)\nout = MinibatchStdDev(batch=batch, window=window, mb_size=mb_size)\ninit = tf.global_variables_initializer()\nsess = tf.Session()\nsess.run(init)\nsess.run(out)", "body": "Hi,\r\n\r\nI am constructing a NN with tensorflow that uses a custom stddev function. I have for a batch and indices i and j a function `AcrossBatchSD(batch, i, j)`. Of course, `import tensorflow as tf`.\r\n\r\n```\r\ndef AcrossBatchSD(batch, i, j):\r\n\r\n    _, varR = tf.nn.moments(batch[:, i, j, 0], axes=[0])\r\n    _, varG = tf.nn.moments(batch[:, i, j, 1], axes=[0])\r\n    _, varB = tf.nn.moments(batch[:, i, j, 2], axes=[0]) \r\n \r\n    return tf.sqrt(varR), tf.sqrt(varG), tf.sqrt(varB)\r\n```\r\n\r\nThis function seems to work, but then I would like to do the following:\r\n\r\n```\r\ndef MinibatchStdDev(batch, window, mb_size):\r\n\r\n    n = batch[0].shape[0].value \r\n    f1 = tf.Variable(tf.zeros([n, n]))\r\n    f2 = tf.Variable(tf.zeros([n, n]))\r\n    f3 = tf.Variable(tf.zeros([n, n]))\r\n\r\n    for i in range(n):\r\n        for j in range(n):\r\n\r\n            sqrtR, sqrtG, sqrtB = AcrossBatchSD(batch, i, j)          \r\n            f1[i, j].assign(sqrtR)\r\n            f2[i, j].assign(sqrtG)\r\n            f3[i, j].assign(sqrtB) \r\n                \r\n    f = tf.divide(tf.add(tf.add(f1, f2), f3), 3)\r\n    F = tf.reduce_mean(f)\r\n\r\n    return tf.multiply(F, tf.ones(([mb_size, window, window]))))\r\n```\r\n\r\nMy problem is that the function `assign` in tensorflow is not differentiable, so `tf.gradients` will outout a `NoneType`. Therefore, my network cannot be trained.\r\n\r\nA test can be done with\r\n\r\n```\r\nmb_size = 3\r\nwindow = 4\r\nbatch = tf.Variable(tf.random_normal([mb_size, 1024, 1024, 3]), tf.float32)\r\nout = MinibatchStdDev(batch=batch, window=window, mb_size=mb_size)\r\ninit = tf.global_variables_initializer()\r\nsess = tf.Session()\r\nsess.run(init)\r\nsess.run(out)\r\n```"}