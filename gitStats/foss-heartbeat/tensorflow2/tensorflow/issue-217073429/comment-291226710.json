{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/291226710", "html_url": "https://github.com/tensorflow/tensorflow/pull/8728#issuecomment-291226710", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8728", "id": 291226710, "node_id": "MDEyOklzc3VlQ29tbWVudDI5MTIyNjcxMA==", "user": {"login": "mrry", "id": 192142, "node_id": "MDQ6VXNlcjE5MjE0Mg==", "avatar_url": "https://avatars1.githubusercontent.com/u/192142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mrry", "html_url": "https://github.com/mrry", "followers_url": "https://api.github.com/users/mrry/followers", "following_url": "https://api.github.com/users/mrry/following{/other_user}", "gists_url": "https://api.github.com/users/mrry/gists{/gist_id}", "starred_url": "https://api.github.com/users/mrry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mrry/subscriptions", "organizations_url": "https://api.github.com/users/mrry/orgs", "repos_url": "https://api.github.com/users/mrry/repos", "events_url": "https://api.github.com/users/mrry/events{/privacy}", "received_events_url": "https://api.github.com/users/mrry/received_events", "type": "User", "site_admin": false}, "created_at": "2017-04-03T18:13:23Z", "updated_at": "2017-04-03T18:13:23Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=966348\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/tillahoffmann\">@tillahoffmann</a> Thanks for submitting this PR! I have some thoughts about the interface, but many of these could be postponed by moving the implementation to <code>tf.contrib</code> while we iterate on the design.</p>\n<ul>\n<li>\n<p>For most new stateful ops, we try to separate the state from the op-kernels that act on it. This would entail splitting the op into two: a \"constructor\" op that sets up the ZMQ socket/context and adds an object to the <code>ResourceMgr</code>, and an \"accessor\" op that retrieves the object from the <code>ResourceMgr</code> and invokes a method on it. (For examples, see the implementations of the readers, queues, variables, etc.) The benefits of doing this are clearer when there are multiple implementations of the same state (e.g. a similar RabbitMQ or Kafka resource? Or maybe various RPC protocols?) or multiple \"accessor\" ops that access the same state, and it would be good to understand if we'd like to support such things before adding this to the core library.</p>\n</li>\n<li>\n<p>I assume that the <code>zmq_msg_recv()</code> call can block. This would block one of the (finitely many) TF thread pool threads, and could lead to deadlock. Typically we would implement such an operation as an <code>AsyncOpKernel</code>. I'm not familiar enough with ZMQ to know the best way to receive a message asynchronously, but hopefully there is a standard pattern that we could use here.</p>\n</li>\n</ul>\n<p>(Regarding the licensing question, I don't know what the consequences are, but <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=577277\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/martinwicke\">@martinwicke</a> probably does (or knows someone who does). Regarding the post from <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=24883463\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/RealTimeDeployment\">@RealTimeDeployment</a>, I don't know what we can do to help on this thread, but I'd suggest opening a new issue if you continue to have problems.)</p>", "body_text": "@tillahoffmann Thanks for submitting this PR! I have some thoughts about the interface, but many of these could be postponed by moving the implementation to tf.contrib while we iterate on the design.\n\n\nFor most new stateful ops, we try to separate the state from the op-kernels that act on it. This would entail splitting the op into two: a \"constructor\" op that sets up the ZMQ socket/context and adds an object to the ResourceMgr, and an \"accessor\" op that retrieves the object from the ResourceMgr and invokes a method on it. (For examples, see the implementations of the readers, queues, variables, etc.) The benefits of doing this are clearer when there are multiple implementations of the same state (e.g. a similar RabbitMQ or Kafka resource? Or maybe various RPC protocols?) or multiple \"accessor\" ops that access the same state, and it would be good to understand if we'd like to support such things before adding this to the core library.\n\n\nI assume that the zmq_msg_recv() call can block. This would block one of the (finitely many) TF thread pool threads, and could lead to deadlock. Typically we would implement such an operation as an AsyncOpKernel. I'm not familiar enough with ZMQ to know the best way to receive a message asynchronously, but hopefully there is a standard pattern that we could use here.\n\n\n(Regarding the licensing question, I don't know what the consequences are, but @martinwicke probably does (or knows someone who does). Regarding the post from @RealTimeDeployment, I don't know what we can do to help on this thread, but I'd suggest opening a new issue if you continue to have problems.)", "body": "@tillahoffmann Thanks for submitting this PR! I have some thoughts about the interface, but many of these could be postponed by moving the implementation to `tf.contrib` while we iterate on the design.\r\n\r\n* For most new stateful ops, we try to separate the state from the op-kernels that act on it. This would entail splitting the op into two: a \"constructor\" op that sets up the ZMQ socket/context and adds an object to the `ResourceMgr`, and an \"accessor\" op that retrieves the object from the `ResourceMgr` and invokes a method on it. (For examples, see the implementations of the readers, queues, variables, etc.) The benefits of doing this are clearer when there are multiple implementations of the same state (e.g. a similar RabbitMQ or Kafka resource? Or maybe various RPC protocols?) or multiple \"accessor\" ops that access the same state, and it would be good to understand if we'd like to support such things before adding this to the core library.\r\n\r\n* I assume that the `zmq_msg_recv()` call can block. This would block one of the (finitely many) TF thread pool threads, and could lead to deadlock. Typically we would implement such an operation as an `AsyncOpKernel`. I'm not familiar enough with ZMQ to know the best way to receive a message asynchronously, but hopefully there is a standard pattern that we could use here.\r\n\r\n(Regarding the licensing question, I don't know what the consequences are, but @martinwicke probably does (or knows someone who does). Regarding the post from @RealTimeDeployment, I don't know what we can do to help on this thread, but I'd suggest opening a new issue if you continue to have problems.)"}