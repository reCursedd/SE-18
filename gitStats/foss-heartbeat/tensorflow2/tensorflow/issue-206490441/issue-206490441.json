{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/7384", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/7384/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/7384/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/7384/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/7384", "id": 206490441, "node_id": "MDU6SXNzdWUyMDY0OTA0NDE=", "number": 7384, "title": "freeze_graph.py script fails with FailedPreconditionError: 01", "user": {"login": "oliblum90", "id": 21020039, "node_id": "MDQ6VXNlcjIxMDIwMDM5", "avatar_url": "https://avatars2.githubusercontent.com/u/21020039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oliblum90", "html_url": "https://github.com/oliblum90", "followers_url": "https://api.github.com/users/oliblum90/followers", "following_url": "https://api.github.com/users/oliblum90/following{/other_user}", "gists_url": "https://api.github.com/users/oliblum90/gists{/gist_id}", "starred_url": "https://api.github.com/users/oliblum90/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oliblum90/subscriptions", "organizations_url": "https://api.github.com/users/oliblum90/orgs", "repos_url": "https://api.github.com/users/oliblum90/repos", "events_url": "https://api.github.com/users/oliblum90/events{/privacy}", "received_events_url": "https://api.github.com/users/oliblum90/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 473184161, "node_id": "MDU6TGFiZWw0NzMxODQxNjE=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:support", "name": "type:support", "color": "159b2e", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2017-02-09T12:31:31Z", "updated_at": "2017-02-09T16:21:44Z", "closed_at": "2017-02-09T16:21:38Z", "author_association": "NONE", "body_html": "<p>I want to freeze a graph for the usage on a mobile device. The code I wrote was motivated by the freeze_graph_test.py script.</p>\n<p>import modules</p>\n<pre><code>import os\nimport numpy as np\nimport tensorflow as tf\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nfrom tensorflow.core.framework import graph_pb2\nfrom tensorflow.core.protobuf import saver_pb2\nfrom tensorflow.python.client import session\n\nimport imp\ngraph_io = imp.load_source('graph_io.py', \n'/export/home/oblum/bibs/tensorflow/tensorflow/python/framework/graph_io.py')   \n\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.ops import variables\nfrom tensorflow.python.platform import test\nfrom tensorflow.python.tools import freeze_graph\nfrom tensorflow.python.training import saver as saver_lib\n</code></pre>\n<p>set path and file names</p>\n<pre><code>checkpoint_prefix     = \"01/saved_checkpoint\"\ncheckpoint_state_name = \"checkpoint_state\"\ninput_graph_name      = \"input_graph.pb\"\noutput_graph_name     = \"output_graph.pb\"\ncheckpoint_path       = \"01\"\n</code></pre>\n<p>define the graph, load weights and and save checkpoint</p>\n<pre><code>with ops.Graph().as_default():\n\n\n    # load weights\n    fname = \"alex_finetuned.npy\"\n    pretrained_net = np.load(fname).item()\n\n    # save weights in dictionary\n    weights = { \n            \"conv1\": tf.Variable(pretrained_net[\"conv1\"][0]),\n            \"conv2\": tf.Variable(pretrained_net[\"conv2\"][0]),\n            \"conv3\": tf.Variable(pretrained_net[\"conv3\"][0]),\n            \"conv4\": tf.Variable(pretrained_net[\"conv4\"][0]),\n            \"conv5\": tf.Variable(pretrained_net[\"conv5\"][0]),\n            \"fc6\": tf.Variable(pretrained_net[\"fc6\"][0]),\n            \"fc7\": tf.Variable(pretrained_net[\"fc7\"][0]),\n            \"fc8\": tf.Variable(pretrained_net[\"fc8\"][0])\n              }\n\n    # save biases to dictionary\n    biases = { \n            \"conv1\": tf.Variable(pretrained_net[\"conv1\"][1]),\n            \"conv2\": tf.Variable(pretrained_net[\"conv2\"][1]),\n            \"conv3\": tf.Variable(pretrained_net[\"conv3\"][1]),\n            \"conv4\": tf.Variable(pretrained_net[\"conv4\"][1]),\n            \"conv5\": tf.Variable(pretrained_net[\"conv5\"][1]),\n            \"fc6\": tf.Variable(pretrained_net[\"fc6\"][1]),\n            \"fc7\": tf.Variable(pretrained_net[\"fc7\"][1]),\n            \"fc8\": tf.Variable(pretrained_net[\"fc8\"][1])\n              }\n\n\n    def conv(input, kernel, biases, k_h, k_w, c_o, s_h, s_w,  \n             padding=\"VALID\", group=1):\n        '''\n        From https://github.com/ethereon/caffe-tensorflow\n        '''\n        c_i = input.get_shape()[-1]\n        assert c_i%group==0\n        assert c_o%group==0\n        convolve = lambda i, k: tf.nn.conv2d(i, k, [1, s_h, s_w, 1], \n                                             padding=padding)\n\n\n        if group==1:\n            conv = convolve(input, kernel)\n        else:\n            input_groups = tf.split(3, group, input)\n            kernel_groups = tf.split(3, group, kernel)\n            output_groups = [convolve(i, k) for i,k in zip(input_groups, \n                                                           kernel_groups)]\n            conv = tf.concat(3, output_groups)\n        return  tf.reshape(tf.nn.bias_add(conv, biases), \n                           [-1]+conv.get_shape().as_list()[1:])\n\n\n    # input\n    #####################################################################\n    x = tf.placeholder(tf.float32, (None, 227, 227, 3), name=\"input\")\n    #####################################################################\n\n    #conv1\n    k_h = 11; k_w = 11; c_o = 96; s_h = 4; s_w = 4\n    conv1_in = conv(x, weights[\"conv1\"], biases[\"conv1\"], k_h, k_w, c_o, \n                    s_h, s_w, padding=\"SAME\", group=1)\n    conv1 = tf.nn.relu(conv1_in)\n\n    #lrn1\n    radius = 2; alpha = 2e-05; beta = 0.75; bias = 1.0\n    lrn1 = tf.nn.local_response_normalization(conv1,\n                                              depth_radius=radius,\n                                              alpha=alpha,\n                                              beta=beta,\n                                              bias=bias)\n\n    #maxpool1\n    k_h = 3; k_w = 3; s_h = 2; s_w = 2; padding = 'VALID'\n    maxpool1 = tf.nn.max_pool(lrn1, ksize=[1, k_h, k_w, 1], \n                              strides=[1, s_h, s_w, 1], padding=padding)\n\n\n    #conv2\n    k_h = 5; k_w = 5; c_o = 256; s_h = 1; s_w = 1; group = 2\n    conv2_in = conv(maxpool1, weights[\"conv2\"], biases[\"conv2\"], k_h, k_w, \n                    c_o, s_h, s_w, padding=\"SAME\", group=group)\n    conv2 = tf.nn.relu(conv2_in)\n\n\n    #lrn2\n    radius = 2; alpha = 2e-05; beta = 0.75; bias = 1.0\n    lrn2 = tf.nn.local_response_normalization(conv2,\n                                              depth_radius=radius,\n                                              alpha=alpha,\n                                              beta=beta,\n                                              bias=bias)\n\n    #maxpool2\n    k_h = 3; k_w = 3; s_h = 2; s_w = 2; padding = 'VALID'\n    maxpool2 = tf.nn.max_pool(lrn2, ksize=[1, k_h, k_w, 1], \n                              strides=[1, s_h, s_w, 1], padding=padding)\n\n    #conv3\n    k_h = 3; k_w = 3; c_o = 384; s_h = 1; s_w = 1; group = 1\n    conv3_in = conv(maxpool2, weights[\"conv3\"], biases[\"conv3\"], k_h, k_w, \n                    c_o, s_h, s_w, padding=\"SAME\", group=group)\n    conv3 = tf.nn.relu(conv3_in)\n\n    #conv4\n    k_h = 3; k_w = 3; c_o = 384; s_h = 1; s_w = 1; group = 2\n    conv4_in = conv(conv3, weights[\"conv4\"], biases[\"conv4\"], k_h, k_w, \n                    c_o, s_h, s_w, padding=\"SAME\", group=group)\n    conv4 = tf.nn.relu(conv4_in)\n\n\n    #conv5\n    k_h = 3; k_w = 3; c_o = 256; s_h = 1; s_w = 1; group = 2\n    conv5_in = conv(conv4, weights[\"conv5\"], biases[\"conv5\"], k_h, k_w, \n                    c_o, s_h, s_w, padding=\"SAME\", group=group)\n    conv5 = tf.nn.relu(conv5_in)\n\n    #maxpool5\n    k_h = 3; k_w = 3; s_h = 2; s_w = 2; padding = 'VALID'\n    maxpool5 = tf.nn.max_pool(conv5, ksize=[1, k_h, k_w, 1], \n                              strides=[1, s_h, s_w, 1], padding=padding)\n\n    #fc6\n    reshape = tf.reshape(maxpool5,\n                         [-1, int(np.prod(maxpool5.get_shape()[1:]))]) \n    fc6 = tf.nn.relu(tf.matmul(reshape,  weights[\"fc6\"]) + biases[\"fc6\"])\n\n    #fc7\n    fc7 = tf.nn.relu(tf.matmul(fc6, weights[\"fc7\"]) + biases[\"fc7\"])\n\n    #fc8\n    fc8 = tf.nn.xw_plus_b(fc7, weights[\"fc8\"], biases[\"fc8\"])\n\n    # output\n    #####################################################################\n    prob = tf.nn.softmax(fc8, name = \"output\")\n    #####################################################################\n        \n    sess = session.Session()\n    \n    init = variables.global_variables_initializer()\n    sess.run(init)\n    \n#     output = sess.run(prob)\n    \n#     self.assertNear(2.0, output, 0.00001)\n    \n    saver = saver_lib.Saver()\n    checkpoint_path = saver.save(\n      sess,\n      checkpoint_prefix,\n      global_step = 0,\n      latest_filename = checkpoint_state_name)\n    \n    graph_io.write_graph(sess.graph, \"01\", input_graph_name)\n    \n</code></pre>\n<p>set further paths for freezing the graph</p>\n<pre><code>input_graph_path     = input_graph_name\ninput_saver_def_path = \"01\"\ninput_binary         = False\noutput_node_names    = \"output\"\nrestore_op_name      = \"save/restore_all\"\nfilename_tensor_name = \"save/Const:0\"\noutput_graph_path    = output_graph_name\nclear_devices        = False\ninitializer_nodes    = \"input\"\n</code></pre>\n<p>freeze the graph</p>\n<pre><code>freeze_graph.freeze_graph(input_graph_path, input_saver_def_path,\n                          input_binary, checkpoint_path, output_node_names,\n                          restore_op_name, filename_tensor_name,\n                          output_graph_path, clear_devices, initializer_nodes)\n</code></pre>\n<p>when I run the code I get an <strong>FailedPreconditionError: 01</strong> error in the last function freeze_graph.freeze_graph():</p>\n<pre><code>FailedPreconditionError                   Traceback (most recent call last)\n&lt;ipython-input-6-5251505a5d45&gt; in &lt;module&gt;()\n      2                           input_binary, checkpoint_path, output_node_names,\n      3                           restore_op_name, filename_tensor_name,\n----&gt; 4                           output_graph_path, clear_devices, initializer_nodes)\n\n/net/hciserver03/storage/oblum/bibs/venv_new/local/lib/python2.7/site-packages/tensorflow/python/tools/freeze_graph.pyc in freeze_graph(input_graph, input_saver, input_binary, input_checkpoint, output_node_names, restore_op_name, filename_tensor_name, output_graph, clear_devices, initializer_nodes)\n    111           saver_def.ParseFromString(f.read())\n    112         else:\n--&gt; 113           text_format.Merge(f.read(), saver_def)\n    114         saver = tf.train.Saver(saver_def=saver_def)\n    115         saver.restore(sess, input_checkpoint)\n\n/net/hciserver03/storage/oblum/bibs/venv_new/local/lib/python2.7/site-packages/tensorflow/python/lib/io/file_io.pyc in read(self, n)\n    110       else:\n    111         length = n\n--&gt; 112       return pywrap_tensorflow.ReadFromStream(self._read_buf, length, status)\n    113 \n    114   def seek(self, position):\n\n/usr/lib/python2.7/contextlib.pyc in __exit__(self, type, value, traceback)\n     22         if type is None:\n     23             try:\n---&gt; 24                 self.gen.next()\n     25             except StopIteration:\n     26                 return\n\n/net/hciserver03/storage/oblum/bibs/venv_new/local/lib/python2.7/site-packages/tensorflow/python/framework/errors_impl.pyc in raise_exception_on_not_ok_status()\n    467           None, None,\n    468           compat.as_text(pywrap_tensorflow.TF_Message(status)),\n--&gt; 469           pywrap_tensorflow.TF_GetCode(status))\n    470   finally:\n    471     pywrap_tensorflow.TF_DeleteStatus(status)\n\nFailedPreconditionError: 01\n</code></pre>\n<p>does anyone has suggestions how to resolve this?</p>", "body_text": "I want to freeze a graph for the usage on a mobile device. The code I wrote was motivated by the freeze_graph_test.py script.\nimport modules\nimport os\nimport numpy as np\nimport tensorflow as tf\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nfrom tensorflow.core.framework import graph_pb2\nfrom tensorflow.core.protobuf import saver_pb2\nfrom tensorflow.python.client import session\n\nimport imp\ngraph_io = imp.load_source('graph_io.py', \n'/export/home/oblum/bibs/tensorflow/tensorflow/python/framework/graph_io.py')   \n\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.ops import variables\nfrom tensorflow.python.platform import test\nfrom tensorflow.python.tools import freeze_graph\nfrom tensorflow.python.training import saver as saver_lib\n\nset path and file names\ncheckpoint_prefix     = \"01/saved_checkpoint\"\ncheckpoint_state_name = \"checkpoint_state\"\ninput_graph_name      = \"input_graph.pb\"\noutput_graph_name     = \"output_graph.pb\"\ncheckpoint_path       = \"01\"\n\ndefine the graph, load weights and and save checkpoint\nwith ops.Graph().as_default():\n\n\n    # load weights\n    fname = \"alex_finetuned.npy\"\n    pretrained_net = np.load(fname).item()\n\n    # save weights in dictionary\n    weights = { \n            \"conv1\": tf.Variable(pretrained_net[\"conv1\"][0]),\n            \"conv2\": tf.Variable(pretrained_net[\"conv2\"][0]),\n            \"conv3\": tf.Variable(pretrained_net[\"conv3\"][0]),\n            \"conv4\": tf.Variable(pretrained_net[\"conv4\"][0]),\n            \"conv5\": tf.Variable(pretrained_net[\"conv5\"][0]),\n            \"fc6\": tf.Variable(pretrained_net[\"fc6\"][0]),\n            \"fc7\": tf.Variable(pretrained_net[\"fc7\"][0]),\n            \"fc8\": tf.Variable(pretrained_net[\"fc8\"][0])\n              }\n\n    # save biases to dictionary\n    biases = { \n            \"conv1\": tf.Variable(pretrained_net[\"conv1\"][1]),\n            \"conv2\": tf.Variable(pretrained_net[\"conv2\"][1]),\n            \"conv3\": tf.Variable(pretrained_net[\"conv3\"][1]),\n            \"conv4\": tf.Variable(pretrained_net[\"conv4\"][1]),\n            \"conv5\": tf.Variable(pretrained_net[\"conv5\"][1]),\n            \"fc6\": tf.Variable(pretrained_net[\"fc6\"][1]),\n            \"fc7\": tf.Variable(pretrained_net[\"fc7\"][1]),\n            \"fc8\": tf.Variable(pretrained_net[\"fc8\"][1])\n              }\n\n\n    def conv(input, kernel, biases, k_h, k_w, c_o, s_h, s_w,  \n             padding=\"VALID\", group=1):\n        '''\n        From https://github.com/ethereon/caffe-tensorflow\n        '''\n        c_i = input.get_shape()[-1]\n        assert c_i%group==0\n        assert c_o%group==0\n        convolve = lambda i, k: tf.nn.conv2d(i, k, [1, s_h, s_w, 1], \n                                             padding=padding)\n\n\n        if group==1:\n            conv = convolve(input, kernel)\n        else:\n            input_groups = tf.split(3, group, input)\n            kernel_groups = tf.split(3, group, kernel)\n            output_groups = [convolve(i, k) for i,k in zip(input_groups, \n                                                           kernel_groups)]\n            conv = tf.concat(3, output_groups)\n        return  tf.reshape(tf.nn.bias_add(conv, biases), \n                           [-1]+conv.get_shape().as_list()[1:])\n\n\n    # input\n    #####################################################################\n    x = tf.placeholder(tf.float32, (None, 227, 227, 3), name=\"input\")\n    #####################################################################\n\n    #conv1\n    k_h = 11; k_w = 11; c_o = 96; s_h = 4; s_w = 4\n    conv1_in = conv(x, weights[\"conv1\"], biases[\"conv1\"], k_h, k_w, c_o, \n                    s_h, s_w, padding=\"SAME\", group=1)\n    conv1 = tf.nn.relu(conv1_in)\n\n    #lrn1\n    radius = 2; alpha = 2e-05; beta = 0.75; bias = 1.0\n    lrn1 = tf.nn.local_response_normalization(conv1,\n                                              depth_radius=radius,\n                                              alpha=alpha,\n                                              beta=beta,\n                                              bias=bias)\n\n    #maxpool1\n    k_h = 3; k_w = 3; s_h = 2; s_w = 2; padding = 'VALID'\n    maxpool1 = tf.nn.max_pool(lrn1, ksize=[1, k_h, k_w, 1], \n                              strides=[1, s_h, s_w, 1], padding=padding)\n\n\n    #conv2\n    k_h = 5; k_w = 5; c_o = 256; s_h = 1; s_w = 1; group = 2\n    conv2_in = conv(maxpool1, weights[\"conv2\"], biases[\"conv2\"], k_h, k_w, \n                    c_o, s_h, s_w, padding=\"SAME\", group=group)\n    conv2 = tf.nn.relu(conv2_in)\n\n\n    #lrn2\n    radius = 2; alpha = 2e-05; beta = 0.75; bias = 1.0\n    lrn2 = tf.nn.local_response_normalization(conv2,\n                                              depth_radius=radius,\n                                              alpha=alpha,\n                                              beta=beta,\n                                              bias=bias)\n\n    #maxpool2\n    k_h = 3; k_w = 3; s_h = 2; s_w = 2; padding = 'VALID'\n    maxpool2 = tf.nn.max_pool(lrn2, ksize=[1, k_h, k_w, 1], \n                              strides=[1, s_h, s_w, 1], padding=padding)\n\n    #conv3\n    k_h = 3; k_w = 3; c_o = 384; s_h = 1; s_w = 1; group = 1\n    conv3_in = conv(maxpool2, weights[\"conv3\"], biases[\"conv3\"], k_h, k_w, \n                    c_o, s_h, s_w, padding=\"SAME\", group=group)\n    conv3 = tf.nn.relu(conv3_in)\n\n    #conv4\n    k_h = 3; k_w = 3; c_o = 384; s_h = 1; s_w = 1; group = 2\n    conv4_in = conv(conv3, weights[\"conv4\"], biases[\"conv4\"], k_h, k_w, \n                    c_o, s_h, s_w, padding=\"SAME\", group=group)\n    conv4 = tf.nn.relu(conv4_in)\n\n\n    #conv5\n    k_h = 3; k_w = 3; c_o = 256; s_h = 1; s_w = 1; group = 2\n    conv5_in = conv(conv4, weights[\"conv5\"], biases[\"conv5\"], k_h, k_w, \n                    c_o, s_h, s_w, padding=\"SAME\", group=group)\n    conv5 = tf.nn.relu(conv5_in)\n\n    #maxpool5\n    k_h = 3; k_w = 3; s_h = 2; s_w = 2; padding = 'VALID'\n    maxpool5 = tf.nn.max_pool(conv5, ksize=[1, k_h, k_w, 1], \n                              strides=[1, s_h, s_w, 1], padding=padding)\n\n    #fc6\n    reshape = tf.reshape(maxpool5,\n                         [-1, int(np.prod(maxpool5.get_shape()[1:]))]) \n    fc6 = tf.nn.relu(tf.matmul(reshape,  weights[\"fc6\"]) + biases[\"fc6\"])\n\n    #fc7\n    fc7 = tf.nn.relu(tf.matmul(fc6, weights[\"fc7\"]) + biases[\"fc7\"])\n\n    #fc8\n    fc8 = tf.nn.xw_plus_b(fc7, weights[\"fc8\"], biases[\"fc8\"])\n\n    # output\n    #####################################################################\n    prob = tf.nn.softmax(fc8, name = \"output\")\n    #####################################################################\n        \n    sess = session.Session()\n    \n    init = variables.global_variables_initializer()\n    sess.run(init)\n    \n#     output = sess.run(prob)\n    \n#     self.assertNear(2.0, output, 0.00001)\n    \n    saver = saver_lib.Saver()\n    checkpoint_path = saver.save(\n      sess,\n      checkpoint_prefix,\n      global_step = 0,\n      latest_filename = checkpoint_state_name)\n    \n    graph_io.write_graph(sess.graph, \"01\", input_graph_name)\n    \n\nset further paths for freezing the graph\ninput_graph_path     = input_graph_name\ninput_saver_def_path = \"01\"\ninput_binary         = False\noutput_node_names    = \"output\"\nrestore_op_name      = \"save/restore_all\"\nfilename_tensor_name = \"save/Const:0\"\noutput_graph_path    = output_graph_name\nclear_devices        = False\ninitializer_nodes    = \"input\"\n\nfreeze the graph\nfreeze_graph.freeze_graph(input_graph_path, input_saver_def_path,\n                          input_binary, checkpoint_path, output_node_names,\n                          restore_op_name, filename_tensor_name,\n                          output_graph_path, clear_devices, initializer_nodes)\n\nwhen I run the code I get an FailedPreconditionError: 01 error in the last function freeze_graph.freeze_graph():\nFailedPreconditionError                   Traceback (most recent call last)\n<ipython-input-6-5251505a5d45> in <module>()\n      2                           input_binary, checkpoint_path, output_node_names,\n      3                           restore_op_name, filename_tensor_name,\n----> 4                           output_graph_path, clear_devices, initializer_nodes)\n\n/net/hciserver03/storage/oblum/bibs/venv_new/local/lib/python2.7/site-packages/tensorflow/python/tools/freeze_graph.pyc in freeze_graph(input_graph, input_saver, input_binary, input_checkpoint, output_node_names, restore_op_name, filename_tensor_name, output_graph, clear_devices, initializer_nodes)\n    111           saver_def.ParseFromString(f.read())\n    112         else:\n--> 113           text_format.Merge(f.read(), saver_def)\n    114         saver = tf.train.Saver(saver_def=saver_def)\n    115         saver.restore(sess, input_checkpoint)\n\n/net/hciserver03/storage/oblum/bibs/venv_new/local/lib/python2.7/site-packages/tensorflow/python/lib/io/file_io.pyc in read(self, n)\n    110       else:\n    111         length = n\n--> 112       return pywrap_tensorflow.ReadFromStream(self._read_buf, length, status)\n    113 \n    114   def seek(self, position):\n\n/usr/lib/python2.7/contextlib.pyc in __exit__(self, type, value, traceback)\n     22         if type is None:\n     23             try:\n---> 24                 self.gen.next()\n     25             except StopIteration:\n     26                 return\n\n/net/hciserver03/storage/oblum/bibs/venv_new/local/lib/python2.7/site-packages/tensorflow/python/framework/errors_impl.pyc in raise_exception_on_not_ok_status()\n    467           None, None,\n    468           compat.as_text(pywrap_tensorflow.TF_Message(status)),\n--> 469           pywrap_tensorflow.TF_GetCode(status))\n    470   finally:\n    471     pywrap_tensorflow.TF_DeleteStatus(status)\n\nFailedPreconditionError: 01\n\ndoes anyone has suggestions how to resolve this?", "body": "I want to freeze a graph for the usage on a mobile device. The code I wrote was motivated by the freeze_graph_test.py script.\r\n\r\nimport modules\r\n```\r\nimport os\r\nimport numpy as np\r\nimport tensorflow as tf\r\n\r\nfrom __future__ import absolute_import\r\nfrom __future__ import division\r\nfrom __future__ import print_function\r\n\r\nfrom tensorflow.core.framework import graph_pb2\r\nfrom tensorflow.core.protobuf import saver_pb2\r\nfrom tensorflow.python.client import session\r\n\r\nimport imp\r\ngraph_io = imp.load_source('graph_io.py', \r\n'/export/home/oblum/bibs/tensorflow/tensorflow/python/framework/graph_io.py')   \r\n\r\nfrom tensorflow.python.framework import ops\r\nfrom tensorflow.python.framework import test_util\r\nfrom tensorflow.python.ops import math_ops\r\nfrom tensorflow.python.ops import variables\r\nfrom tensorflow.python.platform import test\r\nfrom tensorflow.python.tools import freeze_graph\r\nfrom tensorflow.python.training import saver as saver_lib\r\n```\r\n\r\nset path and file names\r\n```\r\ncheckpoint_prefix     = \"01/saved_checkpoint\"\r\ncheckpoint_state_name = \"checkpoint_state\"\r\ninput_graph_name      = \"input_graph.pb\"\r\noutput_graph_name     = \"output_graph.pb\"\r\ncheckpoint_path       = \"01\"\r\n```\r\n\r\ndefine the graph, load weights and and save checkpoint\r\n```\r\nwith ops.Graph().as_default():\r\n\r\n\r\n    # load weights\r\n    fname = \"alex_finetuned.npy\"\r\n    pretrained_net = np.load(fname).item()\r\n\r\n    # save weights in dictionary\r\n    weights = { \r\n            \"conv1\": tf.Variable(pretrained_net[\"conv1\"][0]),\r\n            \"conv2\": tf.Variable(pretrained_net[\"conv2\"][0]),\r\n            \"conv3\": tf.Variable(pretrained_net[\"conv3\"][0]),\r\n            \"conv4\": tf.Variable(pretrained_net[\"conv4\"][0]),\r\n            \"conv5\": tf.Variable(pretrained_net[\"conv5\"][0]),\r\n            \"fc6\": tf.Variable(pretrained_net[\"fc6\"][0]),\r\n            \"fc7\": tf.Variable(pretrained_net[\"fc7\"][0]),\r\n            \"fc8\": tf.Variable(pretrained_net[\"fc8\"][0])\r\n              }\r\n\r\n    # save biases to dictionary\r\n    biases = { \r\n            \"conv1\": tf.Variable(pretrained_net[\"conv1\"][1]),\r\n            \"conv2\": tf.Variable(pretrained_net[\"conv2\"][1]),\r\n            \"conv3\": tf.Variable(pretrained_net[\"conv3\"][1]),\r\n            \"conv4\": tf.Variable(pretrained_net[\"conv4\"][1]),\r\n            \"conv5\": tf.Variable(pretrained_net[\"conv5\"][1]),\r\n            \"fc6\": tf.Variable(pretrained_net[\"fc6\"][1]),\r\n            \"fc7\": tf.Variable(pretrained_net[\"fc7\"][1]),\r\n            \"fc8\": tf.Variable(pretrained_net[\"fc8\"][1])\r\n              }\r\n\r\n\r\n    def conv(input, kernel, biases, k_h, k_w, c_o, s_h, s_w,  \r\n             padding=\"VALID\", group=1):\r\n        '''\r\n        From https://github.com/ethereon/caffe-tensorflow\r\n        '''\r\n        c_i = input.get_shape()[-1]\r\n        assert c_i%group==0\r\n        assert c_o%group==0\r\n        convolve = lambda i, k: tf.nn.conv2d(i, k, [1, s_h, s_w, 1], \r\n                                             padding=padding)\r\n\r\n\r\n        if group==1:\r\n            conv = convolve(input, kernel)\r\n        else:\r\n            input_groups = tf.split(3, group, input)\r\n            kernel_groups = tf.split(3, group, kernel)\r\n            output_groups = [convolve(i, k) for i,k in zip(input_groups, \r\n                                                           kernel_groups)]\r\n            conv = tf.concat(3, output_groups)\r\n        return  tf.reshape(tf.nn.bias_add(conv, biases), \r\n                           [-1]+conv.get_shape().as_list()[1:])\r\n\r\n\r\n    # input\r\n    #####################################################################\r\n    x = tf.placeholder(tf.float32, (None, 227, 227, 3), name=\"input\")\r\n    #####################################################################\r\n\r\n    #conv1\r\n    k_h = 11; k_w = 11; c_o = 96; s_h = 4; s_w = 4\r\n    conv1_in = conv(x, weights[\"conv1\"], biases[\"conv1\"], k_h, k_w, c_o, \r\n                    s_h, s_w, padding=\"SAME\", group=1)\r\n    conv1 = tf.nn.relu(conv1_in)\r\n\r\n    #lrn1\r\n    radius = 2; alpha = 2e-05; beta = 0.75; bias = 1.0\r\n    lrn1 = tf.nn.local_response_normalization(conv1,\r\n                                              depth_radius=radius,\r\n                                              alpha=alpha,\r\n                                              beta=beta,\r\n                                              bias=bias)\r\n\r\n    #maxpool1\r\n    k_h = 3; k_w = 3; s_h = 2; s_w = 2; padding = 'VALID'\r\n    maxpool1 = tf.nn.max_pool(lrn1, ksize=[1, k_h, k_w, 1], \r\n                              strides=[1, s_h, s_w, 1], padding=padding)\r\n\r\n\r\n    #conv2\r\n    k_h = 5; k_w = 5; c_o = 256; s_h = 1; s_w = 1; group = 2\r\n    conv2_in = conv(maxpool1, weights[\"conv2\"], biases[\"conv2\"], k_h, k_w, \r\n                    c_o, s_h, s_w, padding=\"SAME\", group=group)\r\n    conv2 = tf.nn.relu(conv2_in)\r\n\r\n\r\n    #lrn2\r\n    radius = 2; alpha = 2e-05; beta = 0.75; bias = 1.0\r\n    lrn2 = tf.nn.local_response_normalization(conv2,\r\n                                              depth_radius=radius,\r\n                                              alpha=alpha,\r\n                                              beta=beta,\r\n                                              bias=bias)\r\n\r\n    #maxpool2\r\n    k_h = 3; k_w = 3; s_h = 2; s_w = 2; padding = 'VALID'\r\n    maxpool2 = tf.nn.max_pool(lrn2, ksize=[1, k_h, k_w, 1], \r\n                              strides=[1, s_h, s_w, 1], padding=padding)\r\n\r\n    #conv3\r\n    k_h = 3; k_w = 3; c_o = 384; s_h = 1; s_w = 1; group = 1\r\n    conv3_in = conv(maxpool2, weights[\"conv3\"], biases[\"conv3\"], k_h, k_w, \r\n                    c_o, s_h, s_w, padding=\"SAME\", group=group)\r\n    conv3 = tf.nn.relu(conv3_in)\r\n\r\n    #conv4\r\n    k_h = 3; k_w = 3; c_o = 384; s_h = 1; s_w = 1; group = 2\r\n    conv4_in = conv(conv3, weights[\"conv4\"], biases[\"conv4\"], k_h, k_w, \r\n                    c_o, s_h, s_w, padding=\"SAME\", group=group)\r\n    conv4 = tf.nn.relu(conv4_in)\r\n\r\n\r\n    #conv5\r\n    k_h = 3; k_w = 3; c_o = 256; s_h = 1; s_w = 1; group = 2\r\n    conv5_in = conv(conv4, weights[\"conv5\"], biases[\"conv5\"], k_h, k_w, \r\n                    c_o, s_h, s_w, padding=\"SAME\", group=group)\r\n    conv5 = tf.nn.relu(conv5_in)\r\n\r\n    #maxpool5\r\n    k_h = 3; k_w = 3; s_h = 2; s_w = 2; padding = 'VALID'\r\n    maxpool5 = tf.nn.max_pool(conv5, ksize=[1, k_h, k_w, 1], \r\n                              strides=[1, s_h, s_w, 1], padding=padding)\r\n\r\n    #fc6\r\n    reshape = tf.reshape(maxpool5,\r\n                         [-1, int(np.prod(maxpool5.get_shape()[1:]))]) \r\n    fc6 = tf.nn.relu(tf.matmul(reshape,  weights[\"fc6\"]) + biases[\"fc6\"])\r\n\r\n    #fc7\r\n    fc7 = tf.nn.relu(tf.matmul(fc6, weights[\"fc7\"]) + biases[\"fc7\"])\r\n\r\n    #fc8\r\n    fc8 = tf.nn.xw_plus_b(fc7, weights[\"fc8\"], biases[\"fc8\"])\r\n\r\n    # output\r\n    #####################################################################\r\n    prob = tf.nn.softmax(fc8, name = \"output\")\r\n    #####################################################################\r\n        \r\n    sess = session.Session()\r\n    \r\n    init = variables.global_variables_initializer()\r\n    sess.run(init)\r\n    \r\n#     output = sess.run(prob)\r\n    \r\n#     self.assertNear(2.0, output, 0.00001)\r\n    \r\n    saver = saver_lib.Saver()\r\n    checkpoint_path = saver.save(\r\n      sess,\r\n      checkpoint_prefix,\r\n      global_step = 0,\r\n      latest_filename = checkpoint_state_name)\r\n    \r\n    graph_io.write_graph(sess.graph, \"01\", input_graph_name)\r\n    \r\n```\r\n\r\nset further paths for freezing the graph\r\n```\r\ninput_graph_path     = input_graph_name\r\ninput_saver_def_path = \"01\"\r\ninput_binary         = False\r\noutput_node_names    = \"output\"\r\nrestore_op_name      = \"save/restore_all\"\r\nfilename_tensor_name = \"save/Const:0\"\r\noutput_graph_path    = output_graph_name\r\nclear_devices        = False\r\ninitializer_nodes    = \"input\"\r\n```\r\n\r\nfreeze the graph\r\n```\r\nfreeze_graph.freeze_graph(input_graph_path, input_saver_def_path,\r\n                          input_binary, checkpoint_path, output_node_names,\r\n                          restore_op_name, filename_tensor_name,\r\n                          output_graph_path, clear_devices, initializer_nodes)\r\n```\r\n\r\nwhen I run the code I get an **FailedPreconditionError: 01** error in the last function freeze_graph.freeze_graph():\r\n```\r\nFailedPreconditionError                   Traceback (most recent call last)\r\n<ipython-input-6-5251505a5d45> in <module>()\r\n      2                           input_binary, checkpoint_path, output_node_names,\r\n      3                           restore_op_name, filename_tensor_name,\r\n----> 4                           output_graph_path, clear_devices, initializer_nodes)\r\n\r\n/net/hciserver03/storage/oblum/bibs/venv_new/local/lib/python2.7/site-packages/tensorflow/python/tools/freeze_graph.pyc in freeze_graph(input_graph, input_saver, input_binary, input_checkpoint, output_node_names, restore_op_name, filename_tensor_name, output_graph, clear_devices, initializer_nodes)\r\n    111           saver_def.ParseFromString(f.read())\r\n    112         else:\r\n--> 113           text_format.Merge(f.read(), saver_def)\r\n    114         saver = tf.train.Saver(saver_def=saver_def)\r\n    115         saver.restore(sess, input_checkpoint)\r\n\r\n/net/hciserver03/storage/oblum/bibs/venv_new/local/lib/python2.7/site-packages/tensorflow/python/lib/io/file_io.pyc in read(self, n)\r\n    110       else:\r\n    111         length = n\r\n--> 112       return pywrap_tensorflow.ReadFromStream(self._read_buf, length, status)\r\n    113 \r\n    114   def seek(self, position):\r\n\r\n/usr/lib/python2.7/contextlib.pyc in __exit__(self, type, value, traceback)\r\n     22         if type is None:\r\n     23             try:\r\n---> 24                 self.gen.next()\r\n     25             except StopIteration:\r\n     26                 return\r\n\r\n/net/hciserver03/storage/oblum/bibs/venv_new/local/lib/python2.7/site-packages/tensorflow/python/framework/errors_impl.pyc in raise_exception_on_not_ok_status()\r\n    467           None, None,\r\n    468           compat.as_text(pywrap_tensorflow.TF_Message(status)),\r\n--> 469           pywrap_tensorflow.TF_GetCode(status))\r\n    470   finally:\r\n    471     pywrap_tensorflow.TF_DeleteStatus(status)\r\n\r\nFailedPreconditionError: 01\r\n```\r\n\r\ndoes anyone has suggestions how to resolve this?"}