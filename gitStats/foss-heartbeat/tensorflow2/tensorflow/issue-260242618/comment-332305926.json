{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/332305926", "html_url": "https://github.com/tensorflow/tensorflow/pull/13291#issuecomment-332305926", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13291", "id": 332305926, "node_id": "MDEyOklzc3VlQ29tbWVudDMzMjMwNTkyNg==", "user": {"login": "jart", "id": 49262, "node_id": "MDQ6VXNlcjQ5MjYy", "avatar_url": "https://avatars1.githubusercontent.com/u/49262?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jart", "html_url": "https://github.com/jart", "followers_url": "https://api.github.com/users/jart/followers", "following_url": "https://api.github.com/users/jart/following{/other_user}", "gists_url": "https://api.github.com/users/jart/gists{/gist_id}", "starred_url": "https://api.github.com/users/jart/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jart/subscriptions", "organizations_url": "https://api.github.com/users/jart/orgs", "repos_url": "https://api.github.com/users/jart/repos", "events_url": "https://api.github.com/users/jart/events{/privacy}", "received_events_url": "https://api.github.com/users/jart/received_events", "type": "User", "site_admin": false}, "created_at": "2017-09-26T19:16:31Z", "updated_at": "2017-09-26T19:20:41Z", "author_association": "MEMBER", "body_html": "<p>I have limited familiarity with XLA but I understand the problem you're describing.</p>\n<p>If the labels were all knowable, you could have a <code>config_setting</code> like we do for jemalloc where the user passes <code>--config=with_xla_foo=true</code> to Bazel, which then gets triggered by <code>select()</code>. But if the labels are unknowable, then Bazel's design is you can only really do it by having the user define a new rule at the tip of the build tree.</p>\n<p>For example, if XLA compiler was a cc_binary, you'd have your own rule with the standard set of plugins and a shell main.cc file that statically registers them and invokes the compiler. Then the user swaps that out to change the set of plugins. But since I'm assuming XLA is baked into TensorFlow's big .so file, it's probably not as trivial as writing a cc_binary() to define a custom tip for the entire TensorFlow build.</p>\n<p>In that case, have you considered doing what custom ops do? Plugin is an alwayslink=1 library with that C++11 lambda singleton registration hack, which a Python file dynamically links at runtime.</p>", "body_text": "I have limited familiarity with XLA but I understand the problem you're describing.\nIf the labels were all knowable, you could have a config_setting like we do for jemalloc where the user passes --config=with_xla_foo=true to Bazel, which then gets triggered by select(). But if the labels are unknowable, then Bazel's design is you can only really do it by having the user define a new rule at the tip of the build tree.\nFor example, if XLA compiler was a cc_binary, you'd have your own rule with the standard set of plugins and a shell main.cc file that statically registers them and invokes the compiler. Then the user swaps that out to change the set of plugins. But since I'm assuming XLA is baked into TensorFlow's big .so file, it's probably not as trivial as writing a cc_binary() to define a custom tip for the entire TensorFlow build.\nIn that case, have you considered doing what custom ops do? Plugin is an alwayslink=1 library with that C++11 lambda singleton registration hack, which a Python file dynamically links at runtime.", "body": "I have limited familiarity with XLA but I understand the problem you're describing.\r\n\r\nIf the labels were all knowable, you could have a `config_setting` like we do for jemalloc where the user passes `--config=with_xla_foo=true` to Bazel, which then gets triggered by `select()`. But if the labels are unknowable, then Bazel's design is you can only really do it by having the user define a new rule at the tip of the build tree.\r\n\r\nFor example, if XLA compiler was a cc_binary, you'd have your own rule with the standard set of plugins and a shell main.cc file that statically registers them and invokes the compiler. Then the user swaps that out to change the set of plugins. But since I'm assuming XLA is baked into TensorFlow's big .so file, it's probably not as trivial as writing a cc_binary() to define a custom tip for the entire TensorFlow build.\r\n\r\nIn that case, have you considered doing what custom ops do? Plugin is an alwayslink=1 library with that C++11 lambda singleton registration hack, which a Python file dynamically links at runtime."}