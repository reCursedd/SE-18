{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2358", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2358/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2358/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2358/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/2358", "id": 154811961, "node_id": "MDU6SXNzdWUxNTQ4MTE5NjE=", "number": 2358, "title": "scatter_add for non variable tensors", "user": {"login": "altaetran", "id": 6753285, "node_id": "MDQ6VXNlcjY3NTMyODU=", "avatar_url": "https://avatars1.githubusercontent.com/u/6753285?v=4", "gravatar_id": "", "url": "https://api.github.com/users/altaetran", "html_url": "https://github.com/altaetran", "followers_url": "https://api.github.com/users/altaetran/followers", "following_url": "https://api.github.com/users/altaetran/following{/other_user}", "gists_url": "https://api.github.com/users/altaetran/gists{/gist_id}", "starred_url": "https://api.github.com/users/altaetran/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/altaetran/subscriptions", "organizations_url": "https://api.github.com/users/altaetran/orgs", "repos_url": "https://api.github.com/users/altaetran/repos", "events_url": "https://api.github.com/users/altaetran/events{/privacy}", "received_events_url": "https://api.github.com/users/altaetran/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 299643928, "node_id": "MDU6TGFiZWwyOTk2NDM5Mjg=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:contributions%20welcome", "name": "stat:contributions welcome", "color": "f4b400", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 25, "created_at": "2016-05-13T22:25:12Z", "updated_at": "2018-02-02T09:47:22Z", "closed_at": "2017-06-16T19:46:12Z", "author_association": "NONE", "body_html": "<p>Hi,</p>\n<p>I am interested in using scatter_add when the tensor being update is not a variable. Is this possible?</p>\n<p>I am looking to do something like this:</p>\n<p><code>X1_ph = tf.placeholder(tf.float32, shape=(None, 3))</code><br>\n<code>ind_ph = tf.placeholder(tf.int32, shape=(None))</code></p>\n<p><code>#Z = tf.Variable(tf.zeros([10, 3]))</code><br>\n<code>Z = tf.zeros([10, N_feat])</code></p>\n<p><code>X1 = np.array([[1,0.00,1],</code><br>\n<code>[2,0.00,1],</code><br>\n<code>[3,0.00,1],</code><br>\n<code>[5,0.00,1.1],</code><br>\n<code>[6,1.0,1.8]])</code></p>\n<p><code>ind = [0, 1, 1, 0, 0]</code></p>\n<p><code>Z = tf.scatter_add(Z, ind_ph, X1)</code></p>\n<p>If I declare Z as a tf.Variable, I can do this, but I need to call this operation hundreds of thousands of times, and do not want to store any copies of Z once I am done with them. If I were to declare Z as a Variable, would there be any way to destroy Z once I am done with it (maybe with a garbage collector or something similar)? Thank you so much for your help!</p>", "body_text": "Hi,\nI am interested in using scatter_add when the tensor being update is not a variable. Is this possible?\nI am looking to do something like this:\nX1_ph = tf.placeholder(tf.float32, shape=(None, 3))\nind_ph = tf.placeholder(tf.int32, shape=(None))\n#Z = tf.Variable(tf.zeros([10, 3]))\nZ = tf.zeros([10, N_feat])\nX1 = np.array([[1,0.00,1],\n[2,0.00,1],\n[3,0.00,1],\n[5,0.00,1.1],\n[6,1.0,1.8]])\nind = [0, 1, 1, 0, 0]\nZ = tf.scatter_add(Z, ind_ph, X1)\nIf I declare Z as a tf.Variable, I can do this, but I need to call this operation hundreds of thousands of times, and do not want to store any copies of Z once I am done with them. If I were to declare Z as a Variable, would there be any way to destroy Z once I am done with it (maybe with a garbage collector or something similar)? Thank you so much for your help!", "body": "Hi,\n\nI am interested in using scatter_add when the tensor being update is not a variable. Is this possible?\n\nI am looking to do something like this:\n\n`X1_ph = tf.placeholder(tf.float32, shape=(None, 3))`\n`ind_ph = tf.placeholder(tf.int32, shape=(None))`\n\n`#Z = tf.Variable(tf.zeros([10, 3]))`\n`Z = tf.zeros([10, N_feat])`\n\n`X1 = np.array([[1,0.00,1],`\n`[2,0.00,1],`\n`[3,0.00,1],`\n`[5,0.00,1.1],`\n`[6,1.0,1.8]])`\n\n`ind = [0, 1, 1, 0, 0]`\n\n`Z = tf.scatter_add(Z, ind_ph, X1)`\n\nIf I declare Z as a tf.Variable, I can do this, but I need to call this operation hundreds of thousands of times, and do not want to store any copies of Z once I am done with them. If I were to declare Z as a Variable, would there be any way to destroy Z once I am done with it (maybe with a garbage collector or something similar)? Thank you so much for your help!\n"}