{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/292394503", "html_url": "https://github.com/tensorflow/tensorflow/issues/5719#issuecomment-292394503", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5719", "id": 292394503, "node_id": "MDEyOklzc3VlQ29tbWVudDI5MjM5NDUwMw==", "user": {"login": "ed-alertedh", "id": 24605895, "node_id": "MDQ6VXNlcjI0NjA1ODk1", "avatar_url": "https://avatars1.githubusercontent.com/u/24605895?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ed-alertedh", "html_url": "https://github.com/ed-alertedh", "followers_url": "https://api.github.com/users/ed-alertedh/followers", "following_url": "https://api.github.com/users/ed-alertedh/following{/other_user}", "gists_url": "https://api.github.com/users/ed-alertedh/gists{/gist_id}", "starred_url": "https://api.github.com/users/ed-alertedh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ed-alertedh/subscriptions", "organizations_url": "https://api.github.com/users/ed-alertedh/orgs", "repos_url": "https://api.github.com/users/ed-alertedh/repos", "events_url": "https://api.github.com/users/ed-alertedh/events{/privacy}", "received_events_url": "https://api.github.com/users/ed-alertedh/received_events", "type": "User", "site_admin": false}, "created_at": "2017-04-07T01:44:05Z", "updated_at": "2017-04-07T06:59:47Z", "author_association": "NONE", "body_html": "<p>For those interested, I've started attempting an implementation of this. Unfortunately I'm having to learn CUDA as I go, so it's slow going. I figure if I make something suboptimal that avoids D2H/H2D transfers then that is still a good starting point.</p>\n<p>The GGKS code would need some modification so it couldn't just be placed in the third_party folder. That presumably would mean we'd need to get the original authors to sign the CLA in addition to myself - perhaps <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=11547801\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/prb12\">@prb12</a> or <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=326106\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/aselle\">@aselle</a> can confirm my assumption there? Given that the paper referenced above has enough detail to implement it from scratch, I've decided to go that route for now (making sure not to look at the original code to avoid plagiarism).</p>\n<p>The fact that this op also requires a sort at the end makes things a little messier. That is probably something that could best be achieved using a third_party lib such as Nvidia's <a href=\"https://github.com/thrust/thrust\">thrust</a> (licensed under Apache 2.0). This could also be used to make a dedicated sort op (see issue <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"117748892\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/tensorflow/tensorflow/issues/288\" data-hovercard-type=\"issue\" data-hovercard-url=\"/tensorflow/tensorflow/issues/288/hovercard\" href=\"https://github.com/tensorflow/tensorflow/issues/288\">#288</a>). I'll focus on the selection algorithm for now, perhaps others might have some input?</p>\n<p>edit: as I've progressed further I've also found it would be nice to have pre-canned minmax and cumulative sum (scan) algorithms which thrust also has. Perhaps Eigen is able to perform those operations on GPU if I can somehow create a tensor object from my pointer into device memory. Using Eigen still wouldn't solve the problem of sorting though.</p>\n<p>edit 2: As far as I can tell, thrust is installed along with the CUDA toolkit....woops! I'll have a go at using it.</p>", "body_text": "For those interested, I've started attempting an implementation of this. Unfortunately I'm having to learn CUDA as I go, so it's slow going. I figure if I make something suboptimal that avoids D2H/H2D transfers then that is still a good starting point.\nThe GGKS code would need some modification so it couldn't just be placed in the third_party folder. That presumably would mean we'd need to get the original authors to sign the CLA in addition to myself - perhaps @prb12 or @aselle can confirm my assumption there? Given that the paper referenced above has enough detail to implement it from scratch, I've decided to go that route for now (making sure not to look at the original code to avoid plagiarism).\nThe fact that this op also requires a sort at the end makes things a little messier. That is probably something that could best be achieved using a third_party lib such as Nvidia's thrust (licensed under Apache 2.0). This could also be used to make a dedicated sort op (see issue #288). I'll focus on the selection algorithm for now, perhaps others might have some input?\nedit: as I've progressed further I've also found it would be nice to have pre-canned minmax and cumulative sum (scan) algorithms which thrust also has. Perhaps Eigen is able to perform those operations on GPU if I can somehow create a tensor object from my pointer into device memory. Using Eigen still wouldn't solve the problem of sorting though.\nedit 2: As far as I can tell, thrust is installed along with the CUDA toolkit....woops! I'll have a go at using it.", "body": "For those interested, I've started attempting an implementation of this. Unfortunately I'm having to learn CUDA as I go, so it's slow going. I figure if I make something suboptimal that avoids D2H/H2D transfers then that is still a good starting point.\r\n\r\nThe GGKS code would need some modification so it couldn't just be placed in the third_party folder. That presumably would mean we'd need to get the original authors to sign the CLA in addition to myself - perhaps @prb12 or @aselle can confirm my assumption there? Given that the paper referenced above has enough detail to implement it from scratch, I've decided to go that route for now (making sure not to look at the original code to avoid plagiarism).\r\n\r\nThe fact that this op also requires a sort at the end makes things a little messier. That is probably something that could best be achieved using a third_party lib such as Nvidia's [thrust](https://github.com/thrust/thrust) (licensed under Apache 2.0). This could also be used to make a dedicated sort op (see issue #288). I'll focus on the selection algorithm for now, perhaps others might have some input?\r\n\r\nedit: as I've progressed further I've also found it would be nice to have pre-canned minmax and cumulative sum (scan) algorithms which thrust also has. Perhaps Eigen is able to perform those operations on GPU if I can somehow create a tensor object from my pointer into device memory. Using Eigen still wouldn't solve the problem of sorting though.\r\n\r\nedit 2: As far as I can tell, thrust is installed along with the CUDA toolkit....woops! I'll have a go at using it."}