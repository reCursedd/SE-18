{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/229078054", "html_url": "https://github.com/tensorflow/tensorflow/issues/2921#issuecomment-229078054", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2921", "id": 229078054, "node_id": "MDEyOklzc3VlQ29tbWVudDIyOTA3ODA1NA==", "user": {"login": "hughsalimbeni", "id": 4891485, "node_id": "MDQ6VXNlcjQ4OTE0ODU=", "avatar_url": "https://avatars2.githubusercontent.com/u/4891485?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hughsalimbeni", "html_url": "https://github.com/hughsalimbeni", "followers_url": "https://api.github.com/users/hughsalimbeni/followers", "following_url": "https://api.github.com/users/hughsalimbeni/following{/other_user}", "gists_url": "https://api.github.com/users/hughsalimbeni/gists{/gist_id}", "starred_url": "https://api.github.com/users/hughsalimbeni/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hughsalimbeni/subscriptions", "organizations_url": "https://api.github.com/users/hughsalimbeni/orgs", "repos_url": "https://api.github.com/users/hughsalimbeni/repos", "events_url": "https://api.github.com/users/hughsalimbeni/events{/privacy}", "received_events_url": "https://api.github.com/users/hughsalimbeni/received_events", "type": "User", "site_admin": false}, "created_at": "2016-06-28T15:05:10Z", "updated_at": "2016-06-28T15:05:10Z", "author_association": "NONE", "body_html": "<p>My code is rather messy and very far from a minimal example, but here it is:</p>\n<pre><code>    def make_x_hat(self, x):\n        L, H = self.L, self.H\n        #put two cols of zeros\n        # TODO sort out messy tranpose\n        padded = tf.pad(tf.transpose(x), [[0, 0], [1, 1]], 'CONSTANT')\n        #make 4d and swap to make indexing work more nicely\n        x4 = tf.expand_dims(tf.expand_dims(tf.transpose(padded), 0), 3)\n        #rectangular patches of 2 (cols) by L+1 rows\n        ksizes = [1, 2, L + 1, 1]\n        strides = [1, ]*4\n        rates = [1, ]*4\n        patches = tf.extract_image_patches(x4, 'VALID', ksizes, strides, rates)\n        #first layer: [0, :, 0, -L:] \n        #middle layers [0, :, 0,  1:-1]\n        #final layer [0, :, 4, 1:L+1]\n\n        raw = tf.squeeze(tf.transpose(patches, (0, 2, 1, 3)))\n\n        ret = []\n        ret.append(raw[:, 0, L+1:2*L+1])\n        for h in range(1, H):\n            ret.append(raw[:, h, 1:(2*L+1)])\n        ret.append(raw[:, H, 1:L+1])\n        return ret\n</code></pre>\n<p>I was intending to use extract_image_patches to avoid a loop over h (I was going to combine the middle layers to a single array, if it had worked), but the performance gain is so minimal I just used this instead:</p>\n<pre><code>    def make_x_hat(self, x):\n        x = tf.transpose(x)\n        N, L, H = self.N, self.L, self.H    \n        n = N + L \n        ret = []        \n        a = []\n        for l in range(L):\n            a.append(x[l:n-L+l, 0])\n        ret.append(tf.transpose(tf.pack(a)))\n\n        for h in range(1, H):\n            a = []\n            b = []\n            for l in range(L):\n                a.append(x[l:n-L+l, h])\n                b.append(x[l+1:n-L+l+1, h-1])\n\n            A = tf.transpose(tf.pack(a))\n            B = tf.transpose(tf.pack(b))\n            ret.append(tf.concat(1, (B, A)))\n\n        a = []\n        for l in range(L):\n            a.append(x[l+1:n-L+l+1, H-1])\n        ret.append(tf.transpose(tf.pack(a)))\n\n        return ret\n</code></pre>\n<p>which works fine.</p>", "body_text": "My code is rather messy and very far from a minimal example, but here it is:\n    def make_x_hat(self, x):\n        L, H = self.L, self.H\n        #put two cols of zeros\n        # TODO sort out messy tranpose\n        padded = tf.pad(tf.transpose(x), [[0, 0], [1, 1]], 'CONSTANT')\n        #make 4d and swap to make indexing work more nicely\n        x4 = tf.expand_dims(tf.expand_dims(tf.transpose(padded), 0), 3)\n        #rectangular patches of 2 (cols) by L+1 rows\n        ksizes = [1, 2, L + 1, 1]\n        strides = [1, ]*4\n        rates = [1, ]*4\n        patches = tf.extract_image_patches(x4, 'VALID', ksizes, strides, rates)\n        #first layer: [0, :, 0, -L:] \n        #middle layers [0, :, 0,  1:-1]\n        #final layer [0, :, 4, 1:L+1]\n\n        raw = tf.squeeze(tf.transpose(patches, (0, 2, 1, 3)))\n\n        ret = []\n        ret.append(raw[:, 0, L+1:2*L+1])\n        for h in range(1, H):\n            ret.append(raw[:, h, 1:(2*L+1)])\n        ret.append(raw[:, H, 1:L+1])\n        return ret\n\nI was intending to use extract_image_patches to avoid a loop over h (I was going to combine the middle layers to a single array, if it had worked), but the performance gain is so minimal I just used this instead:\n    def make_x_hat(self, x):\n        x = tf.transpose(x)\n        N, L, H = self.N, self.L, self.H    \n        n = N + L \n        ret = []        \n        a = []\n        for l in range(L):\n            a.append(x[l:n-L+l, 0])\n        ret.append(tf.transpose(tf.pack(a)))\n\n        for h in range(1, H):\n            a = []\n            b = []\n            for l in range(L):\n                a.append(x[l:n-L+l, h])\n                b.append(x[l+1:n-L+l+1, h-1])\n\n            A = tf.transpose(tf.pack(a))\n            B = tf.transpose(tf.pack(b))\n            ret.append(tf.concat(1, (B, A)))\n\n        a = []\n        for l in range(L):\n            a.append(x[l+1:n-L+l+1, H-1])\n        ret.append(tf.transpose(tf.pack(a)))\n\n        return ret\n\nwhich works fine.", "body": "My code is rather messy and very far from a minimal example, but here it is:\n\n```\n    def make_x_hat(self, x):\n        L, H = self.L, self.H\n        #put two cols of zeros\n        # TODO sort out messy tranpose\n        padded = tf.pad(tf.transpose(x), [[0, 0], [1, 1]], 'CONSTANT')\n        #make 4d and swap to make indexing work more nicely\n        x4 = tf.expand_dims(tf.expand_dims(tf.transpose(padded), 0), 3)\n        #rectangular patches of 2 (cols) by L+1 rows\n        ksizes = [1, 2, L + 1, 1]\n        strides = [1, ]*4\n        rates = [1, ]*4\n        patches = tf.extract_image_patches(x4, 'VALID', ksizes, strides, rates)\n        #first layer: [0, :, 0, -L:] \n        #middle layers [0, :, 0,  1:-1]\n        #final layer [0, :, 4, 1:L+1]\n\n        raw = tf.squeeze(tf.transpose(patches, (0, 2, 1, 3)))\n\n        ret = []\n        ret.append(raw[:, 0, L+1:2*L+1])\n        for h in range(1, H):\n            ret.append(raw[:, h, 1:(2*L+1)])\n        ret.append(raw[:, H, 1:L+1])\n        return ret\n```\n\nI was intending to use extract_image_patches to avoid a loop over h (I was going to combine the middle layers to a single array, if it had worked), but the performance gain is so minimal I just used this instead:\n\n```\n    def make_x_hat(self, x):\n        x = tf.transpose(x)\n        N, L, H = self.N, self.L, self.H    \n        n = N + L \n        ret = []        \n        a = []\n        for l in range(L):\n            a.append(x[l:n-L+l, 0])\n        ret.append(tf.transpose(tf.pack(a)))\n\n        for h in range(1, H):\n            a = []\n            b = []\n            for l in range(L):\n                a.append(x[l:n-L+l, h])\n                b.append(x[l+1:n-L+l+1, h-1])\n\n            A = tf.transpose(tf.pack(a))\n            B = tf.transpose(tf.pack(b))\n            ret.append(tf.concat(1, (B, A)))\n\n        a = []\n        for l in range(L):\n            a.append(x[l+1:n-L+l+1, H-1])\n        ret.append(tf.transpose(tf.pack(a)))\n\n        return ret\n```\n\nwhich works fine. \n"}