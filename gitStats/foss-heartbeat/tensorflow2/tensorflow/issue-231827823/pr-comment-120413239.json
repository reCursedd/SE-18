{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/120413239", "pull_request_review_id": 42374157, "id": 120413239, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEyMDQxMzIzOQ==", "diff_hunk": "@@ -0,0 +1,198 @@\n+/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+package org.tensorflow;\n+\n+/**\n+ * A {@code Scope} represents a set of related properties when creating Tensorflow Operations, such\n+ * as a common name prefix.\n+ *\n+ * <p>A {@code Scope} is a container for common properties applied to TensorFlow Ops. Normal user\n+ * code initializes a {@code Scope} and provides it to Operation building classes. For example:\n+ *\n+ * <pre>{@code\n+ * Scope scope = Scope.create(graph);\n+ * Constant c = Constant.create(scope, 42);\n+ * }</pre>\n+ *\n+ * <p>An Operation building class acquires a Scope, and uses it to set properties on the underlying\n+ * Tensorflow ops. For example:\n+ *\n+ * <pre>{@code\n+ * // An operator class that adds a constant.\n+ * public class Constant {\n+ *   public static Constant create(Scope scope, ...) {\n+ *      scope.graph().opBuilder(\n+ *        \"Constant\", scope.makeOpName(\"Constant\"))\n+ *        .setAttr(...)\n+ *        .build()\n+ *      ...\n+ *   }\n+ * }\n+ * }</pre>\n+ *\n+ * <p><b>Scope hierarchy:</b>\n+ *\n+ * <p>A {@code Scope} provides various {@code with()} methods that create a new scope. The new scope\n+ * typically has one property changed while other properties are inherited from the parent scope.\n+ *\n+ * <p>An example using {@code Constant} implemented as before:\n+ *\n+ * <pre>{@code\n+ * Scope root = Scope.create(graph);\n+ *\n+ * // The linear subscope will generate names like linear/...\n+ * Scope linear = Scope.withSubScope(\"linear\");\n+ *\n+ * // This op name will be \"linear/W\"\n+ * Constant.create(linear.withOpName(\"W\"), ...);\n+ *\n+ * // This op will be \"linear/Constant\", using the default\n+ * // name provided by Constant\n+ * Constant.create(linear, ...);\n+ *\n+ * // This op will be \"linear/Constant_1\", using the default\n+ * // name provided by Constant and making it unique within\n+ * // this scope\n+ * Constant.create(linear, ...);\n+ * }</pre>\n+ *\n+ * <p>Scope objects are thread-safe.\n+ */\n+public final class Scope {\n+  /**\n+   * Create a new top-level scope.\n+   *\n+   * @param graph The graph instance to be managed by the scope.\n+   * @return a top-level Scope.\n+   */\n+  public static Scope create(Graph graph) {\n+    return builder(graph).build();\n+  }\n+\n+  /** @return the graph managed by this scope. */\n+  public Graph graph() {\n+    return graph;\n+  }\n+\n+  /**\n+   * Return a new subscope with the provided name.\n+   *\n+   * <p>Ops created with this scope will have {@code name/childScopeName/} as the prefix. The actual\n+   * name will be unique in the returned scope. All other properties are inherited from the current\n+   * scope.\n+   *\n+   * <p>Valid child scope names must match one of the following regular expressions:\n+   *\n+   * <pre>{@code\n+   * [A-Za-z0-9.][A-Za-z0-9_.\\\\-]* (for scopes at the root)\n+   * [A-Za-z0-9_.\\\\-]+ (for other scopes)\n+   * }</pre>\n+   *\n+   * @param childScopeName name for the new child scope\n+   * @return a new subscope\n+   * @throws IllegalArgumentException if the name is invalid\n+   */\n+  public Scope withSubScope(String childScopeName) {\n+    return toBuilder().nameScope(nameScope.withSubScope(childScopeName)).build();\n+  }\n+\n+  /**\n+   * Return a new scope that uses the provided name for an op.\n+   *\n+   * <p>Operations created within this scope will have a name of the form {@code\n+   * name/opName[_suffix]}. This lets you name a specific operator more meaningfully.\n+   *\n+   * <p>Valid operator names must match the regular expression {@code [A-Za-z0-9.][A-Za-z0-9_.\\\\-]*}\n+   *\n+   * @param opName name for an operator in the returned scope\n+   * @return a new Scope that uses opName for operations.\n+   * @throws IllegalArgumentException if the name is invalid\n+   */\n+  public Scope withOpName(String opName) {\n+    return toBuilder().nameScope(nameScope.withOpName(opName)).build();\n+  }\n+\n+  /**\n+   * Create a unique name for an operator, using a provided default if necessary.\n+   *\n+   * <p>This is normally called only by operator building classes.\n+   *\n+   * <p>This method generates a unique name, appropriate for the name scope controlled by this\n+   * instance. Typical operator building code might look like\n+   *\n+   * <pre>{@code\n+   * scope.graph().opBuilder(\"Constant\", scope.makeOpName(\"Constant\"))...\n+   * }</pre>\n+   *\n+   * <p><b>Note:</b> if you provide a composite operator building class (i.e, a class that adds a\n+   * set of related operations to the graph by calling other operator building code) you should also\n+   * create a {@link #withSubScope(String)} scope for the underlying operators to group them under a\n+   * meaningful name.\n+   *\n+   * <pre>{@code\n+   * public static Stddev create(Scope scope, ...) {\n+   *   // group sub-operations under a common name\n+   *   Scope group = scope.withSubScope(\"stddev\");\n+   *   ... Sqrt.create(group, Mean.create(group, ...))\n+   * }\n+   * }</pre>\n+   *\n+   * @param defaultName name for the underlying operator.\n+   * @return unique name for the operator.\n+   * @throws IllegalArgumentException if the default name is invalid.\n+   */\n+  public String makeOpName(String defaultName) {\n+    return nameScope.makeOpName(defaultName);\n+  }\n+\n+  private Scope(Builder builder) {\n+    graph = builder.graph;\n+    if (builder.nameScope != null) {\n+      nameScope = builder.nameScope;\n+    } else {\n+      nameScope = NameScope.create();\n+    }\n+  }\n+\n+  private final Graph graph;\n+  private final NameScope nameScope;\n+\n+  private Builder toBuilder() {\n+    return builder(graph).nameScope(nameScope);\n+  }\n+\n+  private static Builder builder(Graph graph) {\n+    return new Builder(graph);\n+  }\n+\n+  private static final class Builder {\n+    private Builder(Graph g) {\n+      graph = g;\n+    }\n+\n+    private Builder nameScope(NameScope ns) {\n+      nameScope = ns;\n+      return this;\n+    }\n+\n+    private Scope build() {\n+      return new Scope(this);", "path": "tensorflow/java/src/main/java/org/tensorflow/Scope.java", "position": null, "original_position": 192, "commit_id": "f049c08e7876b0638293c38d9f0aa6af8774a325", "original_commit_id": "1dc0d3a71f4bc0969711bdb4ece8f59860de58b6", "user": {"login": "kbsriram", "id": 1495065, "node_id": "MDQ6VXNlcjE0OTUwNjU=", "avatar_url": "https://avatars3.githubusercontent.com/u/1495065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kbsriram", "html_url": "https://github.com/kbsriram", "followers_url": "https://api.github.com/users/kbsriram/followers", "following_url": "https://api.github.com/users/kbsriram/following{/other_user}", "gists_url": "https://api.github.com/users/kbsriram/gists{/gist_id}", "starred_url": "https://api.github.com/users/kbsriram/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kbsriram/subscriptions", "organizations_url": "https://api.github.com/users/kbsriram/orgs", "repos_url": "https://api.github.com/users/kbsriram/repos", "events_url": "https://api.github.com/users/kbsriram/events{/privacy}", "received_events_url": "https://api.github.com/users/kbsriram/received_events", "type": "User", "site_admin": false}, "body": "Thank you for the thoughtful and detailed comments @asimshankar - much appreciated! I'll update this PR to reflect your suggestions.\r\n\r\nMay we sound you out a bit further on `Scope` and `NameScope`? No problem collapsing them in one class, though this what we were thinking.\r\n\r\nThere are two classes now, with `Scope` delegating to `NameScope`. We organized it as a main class delegating to a specialized class so we can add other self-contained groups of properties like \"control dependencies\" without putting everything in one implementation.\r\n\r\nIn this approach, the public `Scope` would be augmented to hold package private `NameScope` and `ControlDependency` objects, delegating to each as appropriate.\r\n\r\nA `Scope` carrying a certain name hierarchy would then implement `withControlDependencies()` by reusing the existing `NameScope` and just creating a new `ControlDependency` object. `withName()` and `withOpName()` would do the opposite, etc. Having specialized classes to manage each group of properties would also make it a bit easier to test each in isolation.\r\n\r\nWhat do you think?\r\n\r\n[Re: Builders to construct classes rather than raw constructors; we were following [https://engdoc.corp.google.com/eng/doc/devguide/java/practices/builders.md?cl=head](https://engdoc.corp.google.com/eng/doc/devguide/java/practices/builders.md?cl=head) style that  prefers Builders or a static factory method to raw constructors. We chose Builders here as `NameScope` manages 3/4 constructor parameters of interest, and `Scope` currently has just one but we anticipate at least two after adding `ControlDependency`.  That said, we're happy to switch to raw constructors if you prefer this style for Tensorflow, we can switch \r\n in this and subsequent PRs, please let us know.]             ", "created_at": "2017-06-06T16:38:35Z", "updated_at": "2017-06-09T00:05:47Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/10255#discussion_r120413239", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/10255", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/120413239"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/10255#discussion_r120413239"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/10255"}}, "body_html": "<p>Thank you for the thoughtful and detailed comments <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=16018\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/asimshankar\">@asimshankar</a> - much appreciated! I'll update this PR to reflect your suggestions.</p>\n<p>May we sound you out a bit further on <code>Scope</code> and <code>NameScope</code>? No problem collapsing them in one class, though this what we were thinking.</p>\n<p>There are two classes now, with <code>Scope</code> delegating to <code>NameScope</code>. We organized it as a main class delegating to a specialized class so we can add other self-contained groups of properties like \"control dependencies\" without putting everything in one implementation.</p>\n<p>In this approach, the public <code>Scope</code> would be augmented to hold package private <code>NameScope</code> and <code>ControlDependency</code> objects, delegating to each as appropriate.</p>\n<p>A <code>Scope</code> carrying a certain name hierarchy would then implement <code>withControlDependencies()</code> by reusing the existing <code>NameScope</code> and just creating a new <code>ControlDependency</code> object. <code>withName()</code> and <code>withOpName()</code> would do the opposite, etc. Having specialized classes to manage each group of properties would also make it a bit easier to test each in isolation.</p>\n<p>What do you think?</p>\n<p>[Re: Builders to construct classes rather than raw constructors; we were following <a href=\"https://engdoc.corp.google.com/eng/doc/devguide/java/practices/builders.md?cl=head\" rel=\"nofollow\">https://engdoc.corp.google.com/eng/doc/devguide/java/practices/builders.md?cl=head</a> style that  prefers Builders or a static factory method to raw constructors. We chose Builders here as <code>NameScope</code> manages 3/4 constructor parameters of interest, and <code>Scope</code> currently has just one but we anticipate at least two after adding <code>ControlDependency</code>.  That said, we're happy to switch to raw constructors if you prefer this style for Tensorflow, we can switch<br>\nin this and subsequent PRs, please let us know.]</p>", "body_text": "Thank you for the thoughtful and detailed comments @asimshankar - much appreciated! I'll update this PR to reflect your suggestions.\nMay we sound you out a bit further on Scope and NameScope? No problem collapsing them in one class, though this what we were thinking.\nThere are two classes now, with Scope delegating to NameScope. We organized it as a main class delegating to a specialized class so we can add other self-contained groups of properties like \"control dependencies\" without putting everything in one implementation.\nIn this approach, the public Scope would be augmented to hold package private NameScope and ControlDependency objects, delegating to each as appropriate.\nA Scope carrying a certain name hierarchy would then implement withControlDependencies() by reusing the existing NameScope and just creating a new ControlDependency object. withName() and withOpName() would do the opposite, etc. Having specialized classes to manage each group of properties would also make it a bit easier to test each in isolation.\nWhat do you think?\n[Re: Builders to construct classes rather than raw constructors; we were following https://engdoc.corp.google.com/eng/doc/devguide/java/practices/builders.md?cl=head style that  prefers Builders or a static factory method to raw constructors. We chose Builders here as NameScope manages 3/4 constructor parameters of interest, and Scope currently has just one but we anticipate at least two after adding ControlDependency.  That said, we're happy to switch to raw constructors if you prefer this style for Tensorflow, we can switch\nin this and subsequent PRs, please let us know.]", "in_reply_to_id": 120265733}