{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/12536", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/12536/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/12536/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/12536/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/12536", "id": 252397873, "node_id": "MDU6SXNzdWUyNTIzOTc4NzM=", "number": 12536, "title": "Eager execution API strided slice problem.", "user": {"login": "eaplatanios", "id": 1294940, "node_id": "MDQ6VXNlcjEyOTQ5NDA=", "avatar_url": "https://avatars2.githubusercontent.com/u/1294940?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eaplatanios", "html_url": "https://github.com/eaplatanios", "followers_url": "https://api.github.com/users/eaplatanios/followers", "following_url": "https://api.github.com/users/eaplatanios/following{/other_user}", "gists_url": "https://api.github.com/users/eaplatanios/gists{/gist_id}", "starred_url": "https://api.github.com/users/eaplatanios/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eaplatanios/subscriptions", "organizations_url": "https://api.github.com/users/eaplatanios/orgs", "repos_url": "https://api.github.com/users/eaplatanios/repos", "events_url": "https://api.github.com/users/eaplatanios/events{/privacy}", "received_events_url": "https://api.github.com/users/eaplatanios/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 9, "created_at": "2017-08-23T19:56:06Z", "updated_at": "2017-08-23T23:40:27Z", "closed_at": "2017-08-23T23:40:27Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=5061\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/alextp\">@alextp</a> there seems to be a problem with eagerly executing strided slice ops. The problem seems to be in the shape inference component and is non-deterministic. If you add the following code in the <code>eager/c_api_test.cc</code> file and run the test multiple times, you'll notice that sometimes it succeeds and sometimes it fails, randomly. More specifically, I get errors related to the strides input tensor, but I think this may have to do with how the memory is managed for eager tensors:</p>\n<div class=\"highlight highlight-source-c++\"><pre>TFE_TensorHandle* <span class=\"pl-en\">TestBeginTensorHandle</span>() {\n  <span class=\"pl-c1\">int64_t</span> dims[] = {<span class=\"pl-c1\">2</span>};\n  <span class=\"pl-k\">int</span> data[] = {<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">0</span>};\n  TF_Tensor* t = <span class=\"pl-c1\">TF_AllocateTensor</span>(\n      TF_INT32, &amp;dims[<span class=\"pl-c1\">0</span>], <span class=\"pl-k\">sizeof</span>(dims) / <span class=\"pl-k\">sizeof</span>(<span class=\"pl-c1\">int64_t</span>), <span class=\"pl-k\">sizeof</span>(data));\n  <span class=\"pl-c1\">memcpy</span>(<span class=\"pl-c1\">TF_TensorData</span>(t), &amp;data[<span class=\"pl-c1\">0</span>], <span class=\"pl-c1\">TF_TensorByteSize</span>(t));\n  TFE_TensorHandle* th = <span class=\"pl-c1\">TFE_NewTensorHandle</span>(t);\n  <span class=\"pl-c1\">TF_DeleteTensor</span>(t);\n  <span class=\"pl-k\">return</span> th;\n}\n\nTFE_TensorHandle* <span class=\"pl-en\">TestEndTensorHandle</span>() {\n  <span class=\"pl-c1\">int64_t</span> dims[] = {<span class=\"pl-c1\">2</span>};\n  <span class=\"pl-k\">int</span> data[] = {<span class=\"pl-c1\">2</span>, <span class=\"pl-c1\">1</span>};\n  TF_Tensor* t = <span class=\"pl-c1\">TF_AllocateTensor</span>(\n      TF_INT32, &amp;dims[<span class=\"pl-c1\">0</span>], <span class=\"pl-k\">sizeof</span>(dims) / <span class=\"pl-k\">sizeof</span>(<span class=\"pl-c1\">int64_t</span>), <span class=\"pl-k\">sizeof</span>(data));\n  <span class=\"pl-c1\">memcpy</span>(<span class=\"pl-c1\">TF_TensorData</span>(t), &amp;data[<span class=\"pl-c1\">0</span>], <span class=\"pl-c1\">TF_TensorByteSize</span>(t));\n  TFE_TensorHandle* th = <span class=\"pl-c1\">TFE_NewTensorHandle</span>(t);\n  <span class=\"pl-c1\">TF_DeleteTensor</span>(t);\n  <span class=\"pl-k\">return</span> th;\n}\n\nTFE_TensorHandle* <span class=\"pl-en\">TestStridesTensorHandle</span>() {\n  <span class=\"pl-c1\">int64_t</span> dims[] = {<span class=\"pl-c1\">2</span>};\n  <span class=\"pl-k\">int</span> data[] = {<span class=\"pl-c1\">1</span>};\n  TF_Tensor* t = <span class=\"pl-c1\">TF_AllocateTensor</span>(\n      TF_INT32, &amp;dims[<span class=\"pl-c1\">0</span>], <span class=\"pl-k\">sizeof</span>(dims) / <span class=\"pl-k\">sizeof</span>(<span class=\"pl-c1\">int64_t</span>), <span class=\"pl-k\">sizeof</span>(data));\n  <span class=\"pl-c1\">memcpy</span>(<span class=\"pl-c1\">TF_TensorData</span>(t), &amp;data[<span class=\"pl-c1\">0</span>], <span class=\"pl-c1\">TF_TensorByteSize</span>(t));\n  TFE_TensorHandle* th = <span class=\"pl-c1\">TFE_NewTensorHandle</span>(t);\n  <span class=\"pl-c1\">TF_DeleteTensor</span>(t);\n  <span class=\"pl-k\">return</span> th;\n}\n\n<span class=\"pl-en\">TEST</span>(CAPI, ExecuteStridedSlice) {\n  TF_Status* status = <span class=\"pl-c1\">TF_NewStatus</span>();\n  TF_SessionOptions* opts = <span class=\"pl-c1\">TF_NewSessionOptions</span>();\n  TFE_Context* ctx = <span class=\"pl-c1\">TFE_NewContext</span>(opts, status);\n  <span class=\"pl-c1\">CHECK_EQ</span>(TF_OK, <span class=\"pl-c1\">TF_GetCode</span>(status)) &lt;&lt; <span class=\"pl-c1\">TF_Message</span>(status);\n  <span class=\"pl-c1\">TF_DeleteSessionOptions</span>(opts);\n\n  TFE_TensorHandle* a = <span class=\"pl-c1\">TestMatrixTensorHandle</span>();\n  TFE_TensorHandle* begin = <span class=\"pl-c1\">TestBeginTensorHandle</span>();\n  TFE_TensorHandle* end = <span class=\"pl-c1\">TestEndTensorHandle</span>();\n  TFE_TensorHandle* strides = <span class=\"pl-c1\">TestStridesTensorHandle</span>();\n  TFE_Op* op = <span class=\"pl-c1\">TFE_NewOp</span>(ctx, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>StridedSlice<span class=\"pl-pds\">\"</span></span>, status);\n  <span class=\"pl-c1\">CHECK_EQ</span>(TF_OK, <span class=\"pl-c1\">TF_GetCode</span>(status)) &lt;&lt; <span class=\"pl-c1\">TF_Message</span>(status);\n  <span class=\"pl-c1\">TFE_OpAddInput</span>(op, a, status);\n  <span class=\"pl-c1\">CHECK_EQ</span>(TF_OK, <span class=\"pl-c1\">TF_GetCode</span>(status)) &lt;&lt; <span class=\"pl-c1\">TF_Message</span>(status);\n  <span class=\"pl-c1\">TFE_OpAddInput</span>(op, begin, status);\n  <span class=\"pl-c1\">CHECK_EQ</span>(TF_OK, <span class=\"pl-c1\">TF_GetCode</span>(status)) &lt;&lt; <span class=\"pl-c1\">TF_Message</span>(status);\n  <span class=\"pl-c1\">TFE_OpAddInput</span>(op, end, status);\n  <span class=\"pl-c1\">CHECK_EQ</span>(TF_OK, <span class=\"pl-c1\">TF_GetCode</span>(status)) &lt;&lt; <span class=\"pl-c1\">TF_Message</span>(status);\n  <span class=\"pl-c1\">TFE_OpAddInput</span>(op, strides, status);\n  <span class=\"pl-c1\">CHECK_EQ</span>(TF_OK, <span class=\"pl-c1\">TF_GetCode</span>(status)) &lt;&lt; <span class=\"pl-c1\">TF_Message</span>(status);\n  <span class=\"pl-c1\">TFE_OpSetAttrType</span>(op, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>T<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-c1\">TFE_TensorHandleDataType</span>(a));\n  <span class=\"pl-c1\">TFE_OpSetAttrType</span>(op, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Index<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-c1\">TFE_TensorHandleDataType</span>(begin));\n  <span class=\"pl-c1\">TFE_OpSetAttrInt</span>(op, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>begin_mask<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-c1\">0</span>);\n  <span class=\"pl-c1\">TFE_OpSetAttrInt</span>(op, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>end_mask<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-c1\">0</span>);\n  <span class=\"pl-c1\">TFE_OpSetAttrInt</span>(op, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>ellipsis_mask<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-c1\">0</span>);\n  <span class=\"pl-c1\">TFE_OpSetAttrInt</span>(op, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>new_axis_mask<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-c1\">0</span>);\n  <span class=\"pl-c1\">TFE_OpSetAttrInt</span>(op, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>shrink_axis_mask<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-c1\">3</span>);\n\n  TFE_TensorHandle* retvals[<span class=\"pl-c1\">2</span>] = {<span class=\"pl-c1\">nullptr</span>};\n  <span class=\"pl-k\">int</span> num_retvals = <span class=\"pl-c1\">2</span>;  <span class=\"pl-c\"><span class=\"pl-c\">//</span> Should be reduced to 1 by the TFE_Execute call.</span>\n  <span class=\"pl-c1\">TFE_Execute</span>(op, &amp;retvals[<span class=\"pl-c1\">0</span>], &amp;num_retvals, status);\n  <span class=\"pl-c1\">EXPECT_EQ</span>(TF_OK, <span class=\"pl-c1\">TF_GetCode</span>(status)) &lt;&lt; <span class=\"pl-c1\">TF_Message</span>(status);\n  <span class=\"pl-c1\">TFE_DeleteOp</span>(op);\n  <span class=\"pl-c1\">TFE_DeleteTensorHandle</span>(a);\n  <span class=\"pl-c1\">TFE_DeleteTensorHandle</span>(begin);\n  <span class=\"pl-c1\">TFE_DeleteTensorHandle</span>(end);\n  <span class=\"pl-c1\">TFE_DeleteTensorHandle</span>(strides);\n  <span class=\"pl-c1\">TFE_DeleteContext</span>(ctx, status);\n  <span class=\"pl-c1\">ASSERT_EQ</span>(TF_OK, <span class=\"pl-c1\">TF_GetCode</span>(status)) &lt;&lt; <span class=\"pl-c1\">TF_Message</span>(status);\n  <span class=\"pl-c1\">ASSERT_EQ</span>(<span class=\"pl-c1\">1</span>, num_retvals);\n\n  TF_Tensor* t = <span class=\"pl-c1\">TFE_TensorHandleResolve</span>(retvals[<span class=\"pl-c1\">0</span>], status);\n  <span class=\"pl-c1\">TFE_DeleteTensorHandle</span>(retvals[<span class=\"pl-c1\">0</span>]);\n  <span class=\"pl-c1\">ASSERT_EQ</span>(TF_OK, <span class=\"pl-c1\">TF_GetCode</span>(status)) &lt;&lt; <span class=\"pl-c1\">TF_Message</span>(status);\n  <span class=\"pl-k\">float</span> result[<span class=\"pl-c1\">1</span>] = {<span class=\"pl-c1\">0</span>};\n  <span class=\"pl-c1\">EXPECT_EQ</span>(<span class=\"pl-k\">sizeof</span>(result), <span class=\"pl-c1\">TF_TensorByteSize</span>(t));\n  <span class=\"pl-c1\">memcpy</span>(&amp;result[<span class=\"pl-c1\">0</span>], <span class=\"pl-c1\">TF_TensorData</span>(t), <span class=\"pl-c1\">TF_TensorByteSize</span>(t));\n  <span class=\"pl-c1\">TF_DeleteTensor</span>(t);\n  <span class=\"pl-c1\">EXPECT_EQ</span>(<span class=\"pl-c1\">3</span>, result[<span class=\"pl-c1\">0</span>]);\n  <span class=\"pl-c1\">TF_DeleteStatus</span>(status);\n}</pre></div>", "body_text": "@alextp there seems to be a problem with eagerly executing strided slice ops. The problem seems to be in the shape inference component and is non-deterministic. If you add the following code in the eager/c_api_test.cc file and run the test multiple times, you'll notice that sometimes it succeeds and sometimes it fails, randomly. More specifically, I get errors related to the strides input tensor, but I think this may have to do with how the memory is managed for eager tensors:\nTFE_TensorHandle* TestBeginTensorHandle() {\n  int64_t dims[] = {2};\n  int data[] = {1, 0};\n  TF_Tensor* t = TF_AllocateTensor(\n      TF_INT32, &dims[0], sizeof(dims) / sizeof(int64_t), sizeof(data));\n  memcpy(TF_TensorData(t), &data[0], TF_TensorByteSize(t));\n  TFE_TensorHandle* th = TFE_NewTensorHandle(t);\n  TF_DeleteTensor(t);\n  return th;\n}\n\nTFE_TensorHandle* TestEndTensorHandle() {\n  int64_t dims[] = {2};\n  int data[] = {2, 1};\n  TF_Tensor* t = TF_AllocateTensor(\n      TF_INT32, &dims[0], sizeof(dims) / sizeof(int64_t), sizeof(data));\n  memcpy(TF_TensorData(t), &data[0], TF_TensorByteSize(t));\n  TFE_TensorHandle* th = TFE_NewTensorHandle(t);\n  TF_DeleteTensor(t);\n  return th;\n}\n\nTFE_TensorHandle* TestStridesTensorHandle() {\n  int64_t dims[] = {2};\n  int data[] = {1};\n  TF_Tensor* t = TF_AllocateTensor(\n      TF_INT32, &dims[0], sizeof(dims) / sizeof(int64_t), sizeof(data));\n  memcpy(TF_TensorData(t), &data[0], TF_TensorByteSize(t));\n  TFE_TensorHandle* th = TFE_NewTensorHandle(t);\n  TF_DeleteTensor(t);\n  return th;\n}\n\nTEST(CAPI, ExecuteStridedSlice) {\n  TF_Status* status = TF_NewStatus();\n  TF_SessionOptions* opts = TF_NewSessionOptions();\n  TFE_Context* ctx = TFE_NewContext(opts, status);\n  CHECK_EQ(TF_OK, TF_GetCode(status)) << TF_Message(status);\n  TF_DeleteSessionOptions(opts);\n\n  TFE_TensorHandle* a = TestMatrixTensorHandle();\n  TFE_TensorHandle* begin = TestBeginTensorHandle();\n  TFE_TensorHandle* end = TestEndTensorHandle();\n  TFE_TensorHandle* strides = TestStridesTensorHandle();\n  TFE_Op* op = TFE_NewOp(ctx, \"StridedSlice\", status);\n  CHECK_EQ(TF_OK, TF_GetCode(status)) << TF_Message(status);\n  TFE_OpAddInput(op, a, status);\n  CHECK_EQ(TF_OK, TF_GetCode(status)) << TF_Message(status);\n  TFE_OpAddInput(op, begin, status);\n  CHECK_EQ(TF_OK, TF_GetCode(status)) << TF_Message(status);\n  TFE_OpAddInput(op, end, status);\n  CHECK_EQ(TF_OK, TF_GetCode(status)) << TF_Message(status);\n  TFE_OpAddInput(op, strides, status);\n  CHECK_EQ(TF_OK, TF_GetCode(status)) << TF_Message(status);\n  TFE_OpSetAttrType(op, \"T\", TFE_TensorHandleDataType(a));\n  TFE_OpSetAttrType(op, \"Index\", TFE_TensorHandleDataType(begin));\n  TFE_OpSetAttrInt(op, \"begin_mask\", 0);\n  TFE_OpSetAttrInt(op, \"end_mask\", 0);\n  TFE_OpSetAttrInt(op, \"ellipsis_mask\", 0);\n  TFE_OpSetAttrInt(op, \"new_axis_mask\", 0);\n  TFE_OpSetAttrInt(op, \"shrink_axis_mask\", 3);\n\n  TFE_TensorHandle* retvals[2] = {nullptr};\n  int num_retvals = 2;  // Should be reduced to 1 by the TFE_Execute call.\n  TFE_Execute(op, &retvals[0], &num_retvals, status);\n  EXPECT_EQ(TF_OK, TF_GetCode(status)) << TF_Message(status);\n  TFE_DeleteOp(op);\n  TFE_DeleteTensorHandle(a);\n  TFE_DeleteTensorHandle(begin);\n  TFE_DeleteTensorHandle(end);\n  TFE_DeleteTensorHandle(strides);\n  TFE_DeleteContext(ctx, status);\n  ASSERT_EQ(TF_OK, TF_GetCode(status)) << TF_Message(status);\n  ASSERT_EQ(1, num_retvals);\n\n  TF_Tensor* t = TFE_TensorHandleResolve(retvals[0], status);\n  TFE_DeleteTensorHandle(retvals[0]);\n  ASSERT_EQ(TF_OK, TF_GetCode(status)) << TF_Message(status);\n  float result[1] = {0};\n  EXPECT_EQ(sizeof(result), TF_TensorByteSize(t));\n  memcpy(&result[0], TF_TensorData(t), TF_TensorByteSize(t));\n  TF_DeleteTensor(t);\n  EXPECT_EQ(3, result[0]);\n  TF_DeleteStatus(status);\n}", "body": "@alextp there seems to be a problem with eagerly executing strided slice ops. The problem seems to be in the shape inference component and is non-deterministic. If you add the following code in the `eager/c_api_test.cc` file and run the test multiple times, you'll notice that sometimes it succeeds and sometimes it fails, randomly. More specifically, I get errors related to the strides input tensor, but I think this may have to do with how the memory is managed for eager tensors:\r\n\r\n```cc\r\nTFE_TensorHandle* TestBeginTensorHandle() {\r\n  int64_t dims[] = {2};\r\n  int data[] = {1, 0};\r\n  TF_Tensor* t = TF_AllocateTensor(\r\n      TF_INT32, &dims[0], sizeof(dims) / sizeof(int64_t), sizeof(data));\r\n  memcpy(TF_TensorData(t), &data[0], TF_TensorByteSize(t));\r\n  TFE_TensorHandle* th = TFE_NewTensorHandle(t);\r\n  TF_DeleteTensor(t);\r\n  return th;\r\n}\r\n\r\nTFE_TensorHandle* TestEndTensorHandle() {\r\n  int64_t dims[] = {2};\r\n  int data[] = {2, 1};\r\n  TF_Tensor* t = TF_AllocateTensor(\r\n      TF_INT32, &dims[0], sizeof(dims) / sizeof(int64_t), sizeof(data));\r\n  memcpy(TF_TensorData(t), &data[0], TF_TensorByteSize(t));\r\n  TFE_TensorHandle* th = TFE_NewTensorHandle(t);\r\n  TF_DeleteTensor(t);\r\n  return th;\r\n}\r\n\r\nTFE_TensorHandle* TestStridesTensorHandle() {\r\n  int64_t dims[] = {2};\r\n  int data[] = {1};\r\n  TF_Tensor* t = TF_AllocateTensor(\r\n      TF_INT32, &dims[0], sizeof(dims) / sizeof(int64_t), sizeof(data));\r\n  memcpy(TF_TensorData(t), &data[0], TF_TensorByteSize(t));\r\n  TFE_TensorHandle* th = TFE_NewTensorHandle(t);\r\n  TF_DeleteTensor(t);\r\n  return th;\r\n}\r\n\r\nTEST(CAPI, ExecuteStridedSlice) {\r\n  TF_Status* status = TF_NewStatus();\r\n  TF_SessionOptions* opts = TF_NewSessionOptions();\r\n  TFE_Context* ctx = TFE_NewContext(opts, status);\r\n  CHECK_EQ(TF_OK, TF_GetCode(status)) << TF_Message(status);\r\n  TF_DeleteSessionOptions(opts);\r\n\r\n  TFE_TensorHandle* a = TestMatrixTensorHandle();\r\n  TFE_TensorHandle* begin = TestBeginTensorHandle();\r\n  TFE_TensorHandle* end = TestEndTensorHandle();\r\n  TFE_TensorHandle* strides = TestStridesTensorHandle();\r\n  TFE_Op* op = TFE_NewOp(ctx, \"StridedSlice\", status);\r\n  CHECK_EQ(TF_OK, TF_GetCode(status)) << TF_Message(status);\r\n  TFE_OpAddInput(op, a, status);\r\n  CHECK_EQ(TF_OK, TF_GetCode(status)) << TF_Message(status);\r\n  TFE_OpAddInput(op, begin, status);\r\n  CHECK_EQ(TF_OK, TF_GetCode(status)) << TF_Message(status);\r\n  TFE_OpAddInput(op, end, status);\r\n  CHECK_EQ(TF_OK, TF_GetCode(status)) << TF_Message(status);\r\n  TFE_OpAddInput(op, strides, status);\r\n  CHECK_EQ(TF_OK, TF_GetCode(status)) << TF_Message(status);\r\n  TFE_OpSetAttrType(op, \"T\", TFE_TensorHandleDataType(a));\r\n  TFE_OpSetAttrType(op, \"Index\", TFE_TensorHandleDataType(begin));\r\n  TFE_OpSetAttrInt(op, \"begin_mask\", 0);\r\n  TFE_OpSetAttrInt(op, \"end_mask\", 0);\r\n  TFE_OpSetAttrInt(op, \"ellipsis_mask\", 0);\r\n  TFE_OpSetAttrInt(op, \"new_axis_mask\", 0);\r\n  TFE_OpSetAttrInt(op, \"shrink_axis_mask\", 3);\r\n\r\n  TFE_TensorHandle* retvals[2] = {nullptr};\r\n  int num_retvals = 2;  // Should be reduced to 1 by the TFE_Execute call.\r\n  TFE_Execute(op, &retvals[0], &num_retvals, status);\r\n  EXPECT_EQ(TF_OK, TF_GetCode(status)) << TF_Message(status);\r\n  TFE_DeleteOp(op);\r\n  TFE_DeleteTensorHandle(a);\r\n  TFE_DeleteTensorHandle(begin);\r\n  TFE_DeleteTensorHandle(end);\r\n  TFE_DeleteTensorHandle(strides);\r\n  TFE_DeleteContext(ctx, status);\r\n  ASSERT_EQ(TF_OK, TF_GetCode(status)) << TF_Message(status);\r\n  ASSERT_EQ(1, num_retvals);\r\n\r\n  TF_Tensor* t = TFE_TensorHandleResolve(retvals[0], status);\r\n  TFE_DeleteTensorHandle(retvals[0]);\r\n  ASSERT_EQ(TF_OK, TF_GetCode(status)) << TF_Message(status);\r\n  float result[1] = {0};\r\n  EXPECT_EQ(sizeof(result), TF_TensorByteSize(t));\r\n  memcpy(&result[0], TF_TensorData(t), TF_TensorByteSize(t));\r\n  TF_DeleteTensor(t);\r\n  EXPECT_EQ(3, result[0]);\r\n  TF_DeleteStatus(status);\r\n}\r\n```"}