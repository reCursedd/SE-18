{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/328302245", "html_url": "https://github.com/tensorflow/tensorflow/issues/12876#issuecomment-328302245", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/12876", "id": 328302245, "node_id": "MDEyOklzc3VlQ29tbWVudDMyODMwMjI0NQ==", "user": {"login": "quaeler", "id": 22581048, "node_id": "MDQ6VXNlcjIyNTgxMDQ4", "avatar_url": "https://avatars3.githubusercontent.com/u/22581048?v=4", "gravatar_id": "", "url": "https://api.github.com/users/quaeler", "html_url": "https://github.com/quaeler", "followers_url": "https://api.github.com/users/quaeler/followers", "following_url": "https://api.github.com/users/quaeler/following{/other_user}", "gists_url": "https://api.github.com/users/quaeler/gists{/gist_id}", "starred_url": "https://api.github.com/users/quaeler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/quaeler/subscriptions", "organizations_url": "https://api.github.com/users/quaeler/orgs", "repos_url": "https://api.github.com/users/quaeler/repos", "events_url": "https://api.github.com/users/quaeler/events{/privacy}", "received_events_url": "https://api.github.com/users/quaeler/received_events", "type": "User", "site_admin": false}, "created_at": "2017-09-09T20:41:58Z", "updated_at": "2017-09-09T20:41:58Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Interesting - thanks. ... but something is still rotten here; this isn't really TF's problem, but it seems like a real problem that will affect Python users of TF and so maybe that at least warrants some note in a read-me somewhere?</p>\n<p>There's a use case problem which highlights the data representation problem.</p>\n<p>The use case problem is: i should be able to do math operations on the values in my protobuf object prior to serialization, and have them be numerically equivalent to the result were i to perform those same operations on a deserialized version of that object.</p>\n<p>The related data representation problem is: once it comes out of deserialization, that true original value isn't easily reclaimable (beyond some truly hacky schlock.)</p>\n<p>Illustrated using the above simple float proto object &amp; r1.3:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> sf <span class=\"pl-k\">=</span> simple_float_pb2.SimpleFloat()\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> sf.value <span class=\"pl-k\">=</span> <span class=\"pl-c1\">12.17</span>\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> cubedSF <span class=\"pl-k\">=</span> math.pow(sf.value, <span class=\"pl-c1\">3</span>)\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> cubedSF\n<span class=\"pl-c1\">1802.485313</span>\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> npSF <span class=\"pl-k\">=</span> np.float32(sf.value)\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> npSF\n<span class=\"pl-c1\">12.17</span>\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> <span class=\"pl-c1\">print</span> npSF\n<span class=\"pl-c1\">12.17</span>\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> cubedNPSF <span class=\"pl-k\">=</span> math.pow(npSF, <span class=\"pl-c1\">3</span>)\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> cubedNPSF  <span class=\"pl-c\"><span class=\"pl-c\">#</span> now it is revealed that numpy was holding on to precision-schmutz</span>\n<span class=\"pl-c1\">1802.4853468994372</span>\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> serialized <span class=\"pl-k\">=</span> sf.SerializeToString()\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> reconstitution <span class=\"pl-k\">=</span> simple_float_pb2.SimpleFloat()\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> reconstitution.ParseFromString(serialized)\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> <span class=\"pl-c1\">print</span> reconstitution.value\n<span class=\"pl-c1\">12.1700000763</span>\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> reconstitution.value\n<span class=\"pl-c1\">12.170000076293945</span>\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> sf.value <span class=\"pl-k\">==</span> reconstitution.value   <span class=\"pl-c\"><span class=\"pl-c\">#</span> non-trivial problem</span>\n<span class=\"pl-c1\">False</span>\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> np.float32(sf.value) <span class=\"pl-k\">==</span> reconstitution.value  <span class=\"pl-c\"><span class=\"pl-c\">#</span> but i could always write a custom comparator for pre &amp; post serialization objects</span>\n<span class=\"pl-c1\">True</span>\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> np.equal(sf.value, reconstitution.value)   <span class=\"pl-c\"><span class=\"pl-c\">#</span> maybe using Numpy will solve everything</span>\n<span class=\"pl-c1\">False</span>\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> cubedRe <span class=\"pl-k\">=</span> math.pow(reconstitution.value, <span class=\"pl-c1\">3</span>)\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> cubedRe\n<span class=\"pl-c1\">1802.4853468994372</span>\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> npRe <span class=\"pl-k\">=</span> np.float32(reconstitution.value)\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> npRe   <span class=\"pl-c\"><span class=\"pl-c\">#</span> actually unexpected - ?thank you Numpy?</span>\n<span class=\"pl-c1\">12.17</span>\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> <span class=\"pl-c1\">print</span> npRe\n<span class=\"pl-c1\">12.17</span>\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> sf.value <span class=\"pl-k\">==</span> npRe   <span class=\"pl-c\"><span class=\"pl-c\">#</span> i can always dream</span>\n<span class=\"pl-c1\">False</span>\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> np.equal(sf.value, npRe)  <span class=\"pl-c\"><span class=\"pl-c\">#</span> really dream</span>\n<span class=\"pl-c1\">False</span>\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> cubedNPRe <span class=\"pl-k\">=</span> math.pow(npRe, <span class=\"pl-c1\">3</span>)\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> cubedNPRe\n<span class=\"pl-c1\">1802.4853468994372</span>\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> <span class=\"pl-k\">import</span> StringIO  <span class=\"pl-c\"><span class=\"pl-c\">#</span> were i intent on reclaiming the original value...</span>\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> hack <span class=\"pl-k\">=</span> StringIO.StringIO()\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> <span class=\"pl-c1\">print</span> <span class=\"pl-k\">&gt;&gt;</span>hack, npRe\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> hack.getvalue()\n<span class=\"pl-s\"><span class=\"pl-pds\">'</span>12.17<span class=\"pl-cce\">\\n</span><span class=\"pl-pds\">'</span></span>\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> originalValue <span class=\"pl-k\">=</span> <span class=\"pl-c1\">float</span>(hack.getvalue())\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> originalValue\n<span class=\"pl-c1\">12.17</span>\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> sf.value <span class=\"pl-k\">==</span> originalValue\n<span class=\"pl-c1\">True</span>\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> np.equal(sf.value, originalValue)\n<span class=\"pl-c1\">True</span>\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> math.pow(originalValue, <span class=\"pl-c1\">3</span>)\n<span class=\"pl-c1\">1802.485313</span></pre></div>\n<p>To get <em>consistent</em> behaviour, i should cast sf.value via np.float32() to do operations; then i will have consistent values from operations on pre and post serialization versions of the object - of course, those values would be wrong all along.<br>\nTo get <em>correct</em> behaviour, i need to do a string parsing hack on my deserialized float prior to operations; then i will be able to have consistent results from operations on pre and post serialization versions of the object, and will have correct logic function results as well.</p>\n<p>Am i cuckoo-banana to think this situation is a valid problem?</p>", "body_text": "Interesting - thanks. ... but something is still rotten here; this isn't really TF's problem, but it seems like a real problem that will affect Python users of TF and so maybe that at least warrants some note in a read-me somewhere?\nThere's a use case problem which highlights the data representation problem.\nThe use case problem is: i should be able to do math operations on the values in my protobuf object prior to serialization, and have them be numerically equivalent to the result were i to perform those same operations on a deserialized version of that object.\nThe related data representation problem is: once it comes out of deserialization, that true original value isn't easily reclaimable (beyond some truly hacky schlock.)\nIllustrated using the above simple float proto object & r1.3:\n>>> sf = simple_float_pb2.SimpleFloat()\n>>> sf.value = 12.17\n>>> cubedSF = math.pow(sf.value, 3)\n>>> cubedSF\n1802.485313\n>>> npSF = np.float32(sf.value)\n>>> npSF\n12.17\n>>> print npSF\n12.17\n>>> cubedNPSF = math.pow(npSF, 3)\n>>> cubedNPSF  # now it is revealed that numpy was holding on to precision-schmutz\n1802.4853468994372\n>>> serialized = sf.SerializeToString()\n>>> reconstitution = simple_float_pb2.SimpleFloat()\n>>> reconstitution.ParseFromString(serialized)\n>>> print reconstitution.value\n12.1700000763\n>>> reconstitution.value\n12.170000076293945\n>>> sf.value == reconstitution.value   # non-trivial problem\nFalse\n>>> np.float32(sf.value) == reconstitution.value  # but i could always write a custom comparator for pre & post serialization objects\nTrue\n>>> np.equal(sf.value, reconstitution.value)   # maybe using Numpy will solve everything\nFalse\n>>> cubedRe = math.pow(reconstitution.value, 3)\n>>> cubedRe\n1802.4853468994372\n>>> npRe = np.float32(reconstitution.value)\n>>> npRe   # actually unexpected - ?thank you Numpy?\n12.17\n>>> print npRe\n12.17\n>>> sf.value == npRe   # i can always dream\nFalse\n>>> np.equal(sf.value, npRe)  # really dream\nFalse\n>>> cubedNPRe = math.pow(npRe, 3)\n>>> cubedNPRe\n1802.4853468994372\n>>> import StringIO  # were i intent on reclaiming the original value...\n>>> hack = StringIO.StringIO()\n>>> print >>hack, npRe\n>>> hack.getvalue()\n'12.17\\n'\n>>> originalValue = float(hack.getvalue())\n>>> originalValue\n12.17\n>>> sf.value == originalValue\nTrue\n>>> np.equal(sf.value, originalValue)\nTrue\n>>> math.pow(originalValue, 3)\n1802.485313\nTo get consistent behaviour, i should cast sf.value via np.float32() to do operations; then i will have consistent values from operations on pre and post serialization versions of the object - of course, those values would be wrong all along.\nTo get correct behaviour, i need to do a string parsing hack on my deserialized float prior to operations; then i will be able to have consistent results from operations on pre and post serialization versions of the object, and will have correct logic function results as well.\nAm i cuckoo-banana to think this situation is a valid problem?", "body": "Interesting - thanks. ... but something is still rotten here; this isn't really TF's problem, but it seems like a real problem that will affect Python users of TF and so maybe that at least warrants some note in a read-me somewhere?\r\n\r\nThere's a use case problem which highlights the data representation problem.\r\n\r\nThe use case problem is: i should be able to do math operations on the values in my protobuf object prior to serialization, and have them be numerically equivalent to the result were i to perform those same operations on a deserialized version of that object.\r\n\r\nThe related data representation problem is: once it comes out of deserialization, that true original value isn't easily reclaimable (beyond some truly hacky schlock.)\r\n\r\nIllustrated using the above simple float proto object & r1.3:\r\n\r\n```python\r\n>>> sf = simple_float_pb2.SimpleFloat()\r\n>>> sf.value = 12.17\r\n>>> cubedSF = math.pow(sf.value, 3)\r\n>>> cubedSF\r\n1802.485313\r\n>>> npSF = np.float32(sf.value)\r\n>>> npSF\r\n12.17\r\n>>> print npSF\r\n12.17\r\n>>> cubedNPSF = math.pow(npSF, 3)\r\n>>> cubedNPSF  # now it is revealed that numpy was holding on to precision-schmutz\r\n1802.4853468994372\r\n>>> serialized = sf.SerializeToString()\r\n>>> reconstitution = simple_float_pb2.SimpleFloat()\r\n>>> reconstitution.ParseFromString(serialized)\r\n>>> print reconstitution.value\r\n12.1700000763\r\n>>> reconstitution.value\r\n12.170000076293945\r\n>>> sf.value == reconstitution.value   # non-trivial problem\r\nFalse\r\n>>> np.float32(sf.value) == reconstitution.value  # but i could always write a custom comparator for pre & post serialization objects\r\nTrue\r\n>>> np.equal(sf.value, reconstitution.value)   # maybe using Numpy will solve everything\r\nFalse\r\n>>> cubedRe = math.pow(reconstitution.value, 3)\r\n>>> cubedRe\r\n1802.4853468994372\r\n>>> npRe = np.float32(reconstitution.value)\r\n>>> npRe   # actually unexpected - ?thank you Numpy?\r\n12.17\r\n>>> print npRe\r\n12.17\r\n>>> sf.value == npRe   # i can always dream\r\nFalse\r\n>>> np.equal(sf.value, npRe)  # really dream\r\nFalse\r\n>>> cubedNPRe = math.pow(npRe, 3)\r\n>>> cubedNPRe\r\n1802.4853468994372\r\n>>> import StringIO  # were i intent on reclaiming the original value...\r\n>>> hack = StringIO.StringIO()\r\n>>> print >>hack, npRe\r\n>>> hack.getvalue()\r\n'12.17\\n'\r\n>>> originalValue = float(hack.getvalue())\r\n>>> originalValue\r\n12.17\r\n>>> sf.value == originalValue\r\nTrue\r\n>>> np.equal(sf.value, originalValue)\r\nTrue\r\n>>> math.pow(originalValue, 3)\r\n1802.485313\r\n```\r\nTo get *consistent* behaviour, i should cast sf.value via np.float32() to do operations; then i will have consistent values from operations on pre and post serialization versions of the object - of course, those values would be wrong all along.\r\nTo get *correct* behaviour, i need to do a string parsing hack on my deserialized float prior to operations; then i will be able to have consistent results from operations on pre and post serialization versions of the object, and will have correct logic function results as well.\r\n\r\nAm i cuckoo-banana to think this situation is a valid problem?\r\n"}