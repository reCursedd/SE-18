{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/328295387", "html_url": "https://github.com/tensorflow/tensorflow/issues/12876#issuecomment-328295387", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/12876", "id": 328295387, "node_id": "MDEyOklzc3VlQ29tbWVudDMyODI5NTM4Nw==", "user": {"login": "martinwicke", "id": 577277, "node_id": "MDQ6VXNlcjU3NzI3Nw==", "avatar_url": "https://avatars2.githubusercontent.com/u/577277?v=4", "gravatar_id": "", "url": "https://api.github.com/users/martinwicke", "html_url": "https://github.com/martinwicke", "followers_url": "https://api.github.com/users/martinwicke/followers", "following_url": "https://api.github.com/users/martinwicke/following{/other_user}", "gists_url": "https://api.github.com/users/martinwicke/gists{/gist_id}", "starred_url": "https://api.github.com/users/martinwicke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/martinwicke/subscriptions", "organizations_url": "https://api.github.com/users/martinwicke/orgs", "repos_url": "https://api.github.com/users/martinwicke/repos", "events_url": "https://api.github.com/users/martinwicke/events{/privacy}", "received_events_url": "https://api.github.com/users/martinwicke/received_events", "type": "User", "site_admin": false}, "created_at": "2017-09-09T18:29:58Z", "updated_at": "2017-09-09T18:29:58Z", "author_association": "MEMBER", "body_html": "<p>Actually, it's all much simpler. Python uses float64 internally (Python \"float\" is really double). Once you cast 4.3 to 4.3f you get 4.30000019073486.</p>\n<p>Proof:</p>\n<pre><code>cat &gt; foo.cpp &lt;&lt;EOF\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\nint main(){\n  double a = 4.3;\n  float b = (float) a;\n  double c = (double) b;\n  std::cout&lt;&lt;std::setprecision(15)&lt;&lt;a&lt;&lt;\" \"&lt;&lt;b&lt;&lt;\" \"&lt;&lt;c&lt;&lt;std::endl;\n}\nEOF\ng++ foo.cpp &amp;&amp; ./a.out\n</code></pre>\n<p>yields</p>\n<pre><code>4.3 4.30000019073486 4.30000019073486\n</code></pre>\n<p>Thanks <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=348932\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/hawkinsp\">@hawkinsp</a>, <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=326106\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/aselle\">@aselle</a>!</p>\n<p>Casting explicitly to <code>np.float32</code> and printing that before serialization should yield the same. The confusing part is that default print options will prevent you from seeing anything useful.</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> <span class=\"pl-k\">import</span> numpy <span class=\"pl-k\">as</span> np\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> np.set_printoptions(<span class=\"pl-v\">precision</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">15</span>)\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> x <span class=\"pl-k\">=</span> <span class=\"pl-c1\">4.3</span>\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> y <span class=\"pl-k\">=</span> np.float32(x)\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> <span class=\"pl-c1\">print</span> y\n<span class=\"pl-c1\">4.3</span>\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> y \n<span class=\"pl-c1\">4.3000002</span>\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> x\n<span class=\"pl-c1\">4.3</span></pre></div>", "body_text": "Actually, it's all much simpler. Python uses float64 internally (Python \"float\" is really double). Once you cast 4.3 to 4.3f you get 4.30000019073486.\nProof:\ncat > foo.cpp <<EOF\n#include <iostream>\n#include <iomanip>\nint main(){\n  double a = 4.3;\n  float b = (float) a;\n  double c = (double) b;\n  std::cout<<std::setprecision(15)<<a<<\" \"<<b<<\" \"<<c<<std::endl;\n}\nEOF\ng++ foo.cpp && ./a.out\n\nyields\n4.3 4.30000019073486 4.30000019073486\n\nThanks @hawkinsp, @aselle!\nCasting explicitly to np.float32 and printing that before serialization should yield the same. The confusing part is that default print options will prevent you from seeing anything useful.\n>>> import numpy as np\n>>> np.set_printoptions(precision=15)\n>>> x = 4.3\n>>> y = np.float32(x)\n>>> print y\n4.3\n>>> y \n4.3000002\n>>> x\n4.3", "body": "Actually, it's all much simpler. Python uses float64 internally (Python \"float\" is really double). Once you cast 4.3 to 4.3f you get 4.30000019073486.\r\n\r\nProof:\r\n```\r\ncat > foo.cpp <<EOF\r\n#include <iostream>\r\n#include <iomanip>\r\nint main(){\r\n  double a = 4.3;\r\n  float b = (float) a;\r\n  double c = (double) b;\r\n  std::cout<<std::setprecision(15)<<a<<\" \"<<b<<\" \"<<c<<std::endl;\r\n}\r\nEOF\r\ng++ foo.cpp && ./a.out\r\n```\r\nyields\r\n```\r\n4.3 4.30000019073486 4.30000019073486\r\n```\r\n\r\nThanks @hawkinsp, @aselle!\r\n\r\nCasting explicitly to `np.float32` and printing that before serialization should yield the same. The confusing part is that default print options will prevent you from seeing anything useful.\r\n\r\n```python\r\n>>> import numpy as np\r\n>>> np.set_printoptions(precision=15)\r\n>>> x = 4.3\r\n>>> y = np.float32(x)\r\n>>> print y\r\n4.3\r\n>>> y \r\n4.3000002\r\n>>> x\r\n4.3\r\n```"}