{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/331278615", "html_url": "https://github.com/tensorflow/tensorflow/issues/9560#issuecomment-331278615", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9560", "id": 331278615, "node_id": "MDEyOklzc3VlQ29tbWVudDMzMTI3ODYxNQ==", "user": {"login": "codrut3", "id": 10788581, "node_id": "MDQ6VXNlcjEwNzg4NTgx", "avatar_url": "https://avatars1.githubusercontent.com/u/10788581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/codrut3", "html_url": "https://github.com/codrut3", "followers_url": "https://api.github.com/users/codrut3/followers", "following_url": "https://api.github.com/users/codrut3/following{/other_user}", "gists_url": "https://api.github.com/users/codrut3/gists{/gist_id}", "starred_url": "https://api.github.com/users/codrut3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/codrut3/subscriptions", "organizations_url": "https://api.github.com/users/codrut3/orgs", "repos_url": "https://api.github.com/users/codrut3/repos", "events_url": "https://api.github.com/users/codrut3/events{/privacy}", "received_events_url": "https://api.github.com/users/codrut3/received_events", "type": "User", "site_admin": false}, "created_at": "2017-09-21T20:53:08Z", "updated_at": "2017-09-21T20:57:03Z", "author_association": "CONTRIBUTOR", "body_html": "<p>I've looked in the source code and the origin of this bug is in Eigen, specifically src/Core/MathFunctions.h. They specialize their template for pow to the case of both parameters integers, and provide an implementation which only works for positive y. The problem is the well-known bug-loop of shifting y to the left: if y &lt; 0, then the bit sign extends and it continues indefinitely.</p>\n<p>Here is the code from Eigen:</p>\n<pre><code>template&lt;typename ScalarX,typename ScalarY&gt;\nstruct pow_impl&lt;ScalarX,ScalarY, true&gt;\n{\n  typedef ScalarX result_type;\n  static EIGEN_DEVICE_FUNC inline ScalarX run(ScalarX x, ScalarY y)\n  {\n    ScalarX res(1);\n    eigen_assert(!NumTraits&lt;ScalarY&gt;::IsSigned || y &gt;= 0);\n    if(y &amp; 1) res *= x;\n    y &gt;&gt;= 1;\n    while(y)\n    {\n      x *= x;\n      if(y&amp;1) res *= x;\n      y &gt;&gt;= 1;\n    }\n    return res;\n  }\n};\n</code></pre>\n<p>However, it would be difficult to fix this: the template specifically requests that the return type is Scalar, and not Real, and changing this in Eigen might break things for other people.</p>\n<p>What I could do, would be to change pow in cwise_ops.h in tensorflow/core to fix this bug. But then again, tf.pow would start returning float for integers inputs. Is this acceptable? I don't see any way to fix the bug without accepting that tf.pow should also return float for integer inputs.</p>\n<p>If you agree with this change, I can fix the issue.</p>", "body_text": "I've looked in the source code and the origin of this bug is in Eigen, specifically src/Core/MathFunctions.h. They specialize their template for pow to the case of both parameters integers, and provide an implementation which only works for positive y. The problem is the well-known bug-loop of shifting y to the left: if y < 0, then the bit sign extends and it continues indefinitely.\nHere is the code from Eigen:\ntemplate<typename ScalarX,typename ScalarY>\nstruct pow_impl<ScalarX,ScalarY, true>\n{\n  typedef ScalarX result_type;\n  static EIGEN_DEVICE_FUNC inline ScalarX run(ScalarX x, ScalarY y)\n  {\n    ScalarX res(1);\n    eigen_assert(!NumTraits<ScalarY>::IsSigned || y >= 0);\n    if(y & 1) res *= x;\n    y >>= 1;\n    while(y)\n    {\n      x *= x;\n      if(y&1) res *= x;\n      y >>= 1;\n    }\n    return res;\n  }\n};\n\nHowever, it would be difficult to fix this: the template specifically requests that the return type is Scalar, and not Real, and changing this in Eigen might break things for other people.\nWhat I could do, would be to change pow in cwise_ops.h in tensorflow/core to fix this bug. But then again, tf.pow would start returning float for integers inputs. Is this acceptable? I don't see any way to fix the bug without accepting that tf.pow should also return float for integer inputs.\nIf you agree with this change, I can fix the issue.", "body": "I've looked in the source code and the origin of this bug is in Eigen, specifically src/Core/MathFunctions.h. They specialize their template for pow to the case of both parameters integers, and provide an implementation which only works for positive y. The problem is the well-known bug-loop of shifting y to the left: if y < 0, then the bit sign extends and it continues indefinitely.\r\n\r\nHere is the code from Eigen:\r\n\r\n```\r\ntemplate<typename ScalarX,typename ScalarY>\r\nstruct pow_impl<ScalarX,ScalarY, true>\r\n{\r\n  typedef ScalarX result_type;\r\n  static EIGEN_DEVICE_FUNC inline ScalarX run(ScalarX x, ScalarY y)\r\n  {\r\n    ScalarX res(1);\r\n    eigen_assert(!NumTraits<ScalarY>::IsSigned || y >= 0);\r\n    if(y & 1) res *= x;\r\n    y >>= 1;\r\n    while(y)\r\n    {\r\n      x *= x;\r\n      if(y&1) res *= x;\r\n      y >>= 1;\r\n    }\r\n    return res;\r\n  }\r\n};\r\n```\r\n\r\n\r\nHowever, it would be difficult to fix this: the template specifically requests that the return type is Scalar, and not Real, and changing this in Eigen might break things for other people.\r\n\r\nWhat I could do, would be to change pow in cwise_ops.h in tensorflow/core to fix this bug. But then again, tf.pow would start returning float for integers inputs. Is this acceptable? I don't see any way to fix the bug without accepting that tf.pow should also return float for integer inputs.\r\n\r\nIf you agree with this change, I can fix the issue."}