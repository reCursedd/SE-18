{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5972", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5972/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5972/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5972/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/5972", "id": 192496073, "node_id": "MDU6SXNzdWUxOTI0OTYwNzM=", "number": 5972, "title": "optimize variable with dynamic shape not supported", "user": {"login": "albertz", "id": 59132, "node_id": "MDQ6VXNlcjU5MTMy", "avatar_url": "https://avatars0.githubusercontent.com/u/59132?v=4", "gravatar_id": "", "url": "https://api.github.com/users/albertz", "html_url": "https://github.com/albertz", "followers_url": "https://api.github.com/users/albertz/followers", "following_url": "https://api.github.com/users/albertz/following{/other_user}", "gists_url": "https://api.github.com/users/albertz/gists{/gist_id}", "starred_url": "https://api.github.com/users/albertz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/albertz/subscriptions", "organizations_url": "https://api.github.com/users/albertz/orgs", "repos_url": "https://api.github.com/users/albertz/repos", "events_url": "https://api.github.com/users/albertz/events{/privacy}", "received_events_url": "https://api.github.com/users/albertz/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 299643928, "node_id": "MDU6TGFiZWwyOTk2NDM5Mjg=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:contributions%20welcome", "name": "stat:contributions welcome", "color": "f4b400", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2016-11-30T07:39:55Z", "updated_at": "2018-02-08T00:24:06Z", "closed_at": "2018-02-08T00:24:06Z", "author_association": "NONE", "body_html": "<p>TensorFlow 0.11.0.</p>\n<p>I want to use a variable where the shape is unknown in advance and it will change from time to time (although ndim is known and fixed).</p>\n<p>I declare it like:</p>\n<pre><code>initializer = tf.random_uniform_initializer()\nshape = (s0, s1, s2)  # these are symbolic vars\nfoo_var = tf.Variable(initializer(shape=shape), name=\"foo\", validate_shape=False)\n</code></pre>\n<p>This seems to work when I create the computation graph up to the point where I want to optimize w.r.t. this variable, i.e.:</p>\n<pre><code>optimizer = tf.train.AdamOptimizer(learning_rate=0.1, epsilon=1e-4)\noptim = optimizer.minimize(loss, var_list=[foo_var])\n</code></pre>\n<p>That fails in the optimizer in some function <code>create_zeros_slot</code> where it seems to depend on the static shape information (it uses <code>primary.get_shape().as_list()</code>).</p>\n<p>So, using the optimizer works only with variables with static shape? Is that a bug?</p>\n<p>My current solution is some hacky monkey patching:</p>\n<pre><code>def _tf_create_slot_var(primary, val, scope):\n  \"\"\"Helper function for creating a slot variable.\"\"\"\n\n  from tensorflow.python.ops import variables\n  slot = variables.Variable(val, name=scope, trainable=False, validate_shape=primary.get_shape().is_fully_defined())\n  # pylint: disable=protected-access\n  if isinstance(primary, variables.Variable) and primary._save_slice_info:\n    # Primary is a partitioned variable, so we need to also indicate that\n    # the slot is a partitioned variable.  Slots have the same partitioning\n    # as their primaries.\n    real_slot_name = scope[len(primary.op.name + \"/\"):-1]\n    slice_info = primary._save_slice_info\n    slot._set_save_slice_info(variables.Variable.SaveSliceInfo(\n        slice_info.full_name + \"/\" + real_slot_name,\n        slice_info.full_shape[:],\n        slice_info.var_offset[:],\n        slice_info.var_shape[:]))\n  # pylint: enable=protected-access\n  return slot\n\n\ndef _tf_create_zeros_slot(primary, name, dtype=None, colocate_with_primary=True):\n  \"\"\"Create a slot initialized to 0 with same shape as the primary object.\n\n  Args:\n    primary: The primary `Variable` or `Tensor`.\n    name: Name to use for the slot variable.\n    dtype: Type of the slot variable.  Defaults to the type of `primary`.\n    colocate_with_primary: Boolean.  If True the slot is located\n      on the same device as `primary`.\n\n  Returns:\n    A `Variable` object.\n  \"\"\"\n  if dtype is None:\n    dtype = primary.dtype\n  from tensorflow.python.ops import array_ops\n  val = array_ops.zeros(\n      primary.get_shape().as_list() if primary.get_shape().is_fully_defined() else tf.shape(primary),\n      dtype=dtype)\n  from tensorflow.python.training import slot_creator\n  return slot_creator.create_slot(primary, val, name, colocate_with_primary=colocate_with_primary)\n\n\ndef monkey_patch_tf_slot_creator():\n    \"\"\"\n    The TensorFlow optimizers cannot handle variables with unknown shape.\n    We hack this.\n    \"\"\"\n    from tensorflow.python.training import slot_creator\n    slot_creator._create_slot_var = _tf_create_slot_var\n    slot_creator.create_zeros_slot = _tf_create_zeros_slot\n</code></pre>\n<p>(That was also asked <a href=\"http://stackoverflow.com/questions/40863082/optimize-variable-with-dynamic-shape/\" rel=\"nofollow\">on StackOverflow</a>.)</p>", "body_text": "TensorFlow 0.11.0.\nI want to use a variable where the shape is unknown in advance and it will change from time to time (although ndim is known and fixed).\nI declare it like:\ninitializer = tf.random_uniform_initializer()\nshape = (s0, s1, s2)  # these are symbolic vars\nfoo_var = tf.Variable(initializer(shape=shape), name=\"foo\", validate_shape=False)\n\nThis seems to work when I create the computation graph up to the point where I want to optimize w.r.t. this variable, i.e.:\noptimizer = tf.train.AdamOptimizer(learning_rate=0.1, epsilon=1e-4)\noptim = optimizer.minimize(loss, var_list=[foo_var])\n\nThat fails in the optimizer in some function create_zeros_slot where it seems to depend on the static shape information (it uses primary.get_shape().as_list()).\nSo, using the optimizer works only with variables with static shape? Is that a bug?\nMy current solution is some hacky monkey patching:\ndef _tf_create_slot_var(primary, val, scope):\n  \"\"\"Helper function for creating a slot variable.\"\"\"\n\n  from tensorflow.python.ops import variables\n  slot = variables.Variable(val, name=scope, trainable=False, validate_shape=primary.get_shape().is_fully_defined())\n  # pylint: disable=protected-access\n  if isinstance(primary, variables.Variable) and primary._save_slice_info:\n    # Primary is a partitioned variable, so we need to also indicate that\n    # the slot is a partitioned variable.  Slots have the same partitioning\n    # as their primaries.\n    real_slot_name = scope[len(primary.op.name + \"/\"):-1]\n    slice_info = primary._save_slice_info\n    slot._set_save_slice_info(variables.Variable.SaveSliceInfo(\n        slice_info.full_name + \"/\" + real_slot_name,\n        slice_info.full_shape[:],\n        slice_info.var_offset[:],\n        slice_info.var_shape[:]))\n  # pylint: enable=protected-access\n  return slot\n\n\ndef _tf_create_zeros_slot(primary, name, dtype=None, colocate_with_primary=True):\n  \"\"\"Create a slot initialized to 0 with same shape as the primary object.\n\n  Args:\n    primary: The primary `Variable` or `Tensor`.\n    name: Name to use for the slot variable.\n    dtype: Type of the slot variable.  Defaults to the type of `primary`.\n    colocate_with_primary: Boolean.  If True the slot is located\n      on the same device as `primary`.\n\n  Returns:\n    A `Variable` object.\n  \"\"\"\n  if dtype is None:\n    dtype = primary.dtype\n  from tensorflow.python.ops import array_ops\n  val = array_ops.zeros(\n      primary.get_shape().as_list() if primary.get_shape().is_fully_defined() else tf.shape(primary),\n      dtype=dtype)\n  from tensorflow.python.training import slot_creator\n  return slot_creator.create_slot(primary, val, name, colocate_with_primary=colocate_with_primary)\n\n\ndef monkey_patch_tf_slot_creator():\n    \"\"\"\n    The TensorFlow optimizers cannot handle variables with unknown shape.\n    We hack this.\n    \"\"\"\n    from tensorflow.python.training import slot_creator\n    slot_creator._create_slot_var = _tf_create_slot_var\n    slot_creator.create_zeros_slot = _tf_create_zeros_slot\n\n(That was also asked on StackOverflow.)", "body": "TensorFlow 0.11.0.\r\n\r\nI want to use a variable where the shape is unknown in advance and it will change from time to time (although ndim is known and fixed).\r\n\r\nI declare it like:\r\n\r\n```\r\ninitializer = tf.random_uniform_initializer()\r\nshape = (s0, s1, s2)  # these are symbolic vars\r\nfoo_var = tf.Variable(initializer(shape=shape), name=\"foo\", validate_shape=False)\r\n```\r\nThis seems to work when I create the computation graph up to the point where I want to optimize w.r.t. this variable, i.e.:\r\n```\r\noptimizer = tf.train.AdamOptimizer(learning_rate=0.1, epsilon=1e-4)\r\noptim = optimizer.minimize(loss, var_list=[foo_var])\r\n```\r\n\r\nThat fails in the optimizer in some function `create_zeros_slot` where it seems to depend on the static shape information (it uses `primary.get_shape().as_list()`).\r\n\r\nSo, using the optimizer works only with variables with static shape? Is that a bug?\r\n\r\nMy current solution is some hacky monkey patching:\r\n```\r\ndef _tf_create_slot_var(primary, val, scope):\r\n  \"\"\"Helper function for creating a slot variable.\"\"\"\r\n\r\n  from tensorflow.python.ops import variables\r\n  slot = variables.Variable(val, name=scope, trainable=False, validate_shape=primary.get_shape().is_fully_defined())\r\n  # pylint: disable=protected-access\r\n  if isinstance(primary, variables.Variable) and primary._save_slice_info:\r\n    # Primary is a partitioned variable, so we need to also indicate that\r\n    # the slot is a partitioned variable.  Slots have the same partitioning\r\n    # as their primaries.\r\n    real_slot_name = scope[len(primary.op.name + \"/\"):-1]\r\n    slice_info = primary._save_slice_info\r\n    slot._set_save_slice_info(variables.Variable.SaveSliceInfo(\r\n        slice_info.full_name + \"/\" + real_slot_name,\r\n        slice_info.full_shape[:],\r\n        slice_info.var_offset[:],\r\n        slice_info.var_shape[:]))\r\n  # pylint: enable=protected-access\r\n  return slot\r\n\r\n\r\ndef _tf_create_zeros_slot(primary, name, dtype=None, colocate_with_primary=True):\r\n  \"\"\"Create a slot initialized to 0 with same shape as the primary object.\r\n\r\n  Args:\r\n    primary: The primary `Variable` or `Tensor`.\r\n    name: Name to use for the slot variable.\r\n    dtype: Type of the slot variable.  Defaults to the type of `primary`.\r\n    colocate_with_primary: Boolean.  If True the slot is located\r\n      on the same device as `primary`.\r\n\r\n  Returns:\r\n    A `Variable` object.\r\n  \"\"\"\r\n  if dtype is None:\r\n    dtype = primary.dtype\r\n  from tensorflow.python.ops import array_ops\r\n  val = array_ops.zeros(\r\n      primary.get_shape().as_list() if primary.get_shape().is_fully_defined() else tf.shape(primary),\r\n      dtype=dtype)\r\n  from tensorflow.python.training import slot_creator\r\n  return slot_creator.create_slot(primary, val, name, colocate_with_primary=colocate_with_primary)\r\n\r\n\r\ndef monkey_patch_tf_slot_creator():\r\n    \"\"\"\r\n    The TensorFlow optimizers cannot handle variables with unknown shape.\r\n    We hack this.\r\n    \"\"\"\r\n    from tensorflow.python.training import slot_creator\r\n    slot_creator._create_slot_var = _tf_create_slot_var\r\n    slot_creator.create_zeros_slot = _tf_create_zeros_slot\r\n```\r\n\r\n(That was also asked [on StackOverflow](http://stackoverflow.com/questions/40863082/optimize-variable-with-dynamic-shape/).)"}