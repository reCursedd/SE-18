{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/132831448", "pull_request_review_id": 55956104, "id": 132831448, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEzMjgzMTQ0OA==", "diff_hunk": "@@ -77,6 +80,22 @@ public Operation operation(String name) {\n   }\n \n   /**\n+   * Returns all operations that exist in the Graph.\n+   */\n+  public List<Operation> getOperations() {", "path": "tensorflow/java/src/main/java/org/tensorflow/Graph.java", "position": null, "original_position": 16, "commit_id": "9fec80a40ef43cf2991bee1020061da738d3ff8a", "original_commit_id": "a1e7eaccca151a036eb086d5a6e08bd7c57793db", "user": {"login": "asimshankar", "id": 16018, "node_id": "MDQ6VXNlcjE2MDE4", "avatar_url": "https://avatars2.githubusercontent.com/u/16018?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asimshankar", "html_url": "https://github.com/asimshankar", "followers_url": "https://api.github.com/users/asimshankar/followers", "following_url": "https://api.github.com/users/asimshankar/following{/other_user}", "gists_url": "https://api.github.com/users/asimshankar/gists{/gist_id}", "starred_url": "https://api.github.com/users/asimshankar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asimshankar/subscriptions", "organizations_url": "https://api.github.com/users/asimshankar/orgs", "repos_url": "https://api.github.com/users/asimshankar/repos", "events_url": "https://api.github.com/users/asimshankar/events{/privacy}", "received_events_url": "https://api.github.com/users/asimshankar/received_events", "type": "User", "site_admin": false}, "body": "Let's make this return an `Iterator<Operation>` instead of a `List<Operation>`. The C API for iteration predates my involvement with the project, so I'm not entirely sure, but it seems that if there was a reason to prefer iteration there (perhaps memory footprint of when traversing very large graphs), that same reason would apply here. \r\n\r\nI'd imagine something like:\r\n\r\n```java\r\nprivate final class OperationIterator implements Iterator<Operation> {\r\n  OperationIterator(Graph g) {\r\n    this.graph = g;\r\n    advance();\r\n  }\r\n\r\n  private void advance() {\r\n    Graph.Reference ref = graph.ref();\r\n    long opHandle = 0;\r\n    try {\r\n       // nextOperation would be a method in graph_jni.cc\r\n       opHandle = Graph.nextOperation(ref.nativeHandle(), pos++);\r\n    } finally {\r\n      ref.close();\r\n    }\r\n    op = opHandle == 0 ? new Operation(this.graph, opHandle) : null;\r\n  }\r\n  public boolean hasNext() { return op != null; }\r\n  public Operation next() { \r\n    Operation ret = op;\r\n    advance();\r\n    return ret;\r\n  }\r\n\r\n  private Graph graph;\r\n  private Operation op = null;\r\n  private int pos = 0;\r\n}\r\n\r\npublic Iterator<Operation> operations() {\r\n  return new OperationIterator(this);\r\n}\r\n```", "created_at": "2017-08-13T03:27:04Z", "updated_at": "2017-08-14T19:16:15Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/12243#discussion_r132831448", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/12243", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/132831448"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/12243#discussion_r132831448"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/12243"}}, "body_html": "<p>Let's make this return an <code>Iterator&lt;Operation&gt;</code> instead of a <code>List&lt;Operation&gt;</code>. The C API for iteration predates my involvement with the project, so I'm not entirely sure, but it seems that if there was a reason to prefer iteration there (perhaps memory footprint of when traversing very large graphs), that same reason would apply here.</p>\n<p>I'd imagine something like:</p>\n<div class=\"highlight highlight-source-java\"><pre><span class=\"pl-k\">private</span> <span class=\"pl-k\">final</span> <span class=\"pl-k\">class</span> <span class=\"pl-en\">OperationIterator</span> <span class=\"pl-k\">implements</span> <span class=\"pl-e\">Iterator&lt;<span class=\"pl-smi\">Operation</span>&gt;</span> {\n  <span class=\"pl-en\">OperationIterator</span>(<span class=\"pl-smi\">Graph</span> <span class=\"pl-v\">g</span>) {\n    <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>graph <span class=\"pl-k\">=</span> g;\n    advance();\n  }\n\n  <span class=\"pl-k\">private</span> <span class=\"pl-k\">void</span> <span class=\"pl-en\">advance</span>() {\n    <span class=\"pl-smi\">Graph</span><span class=\"pl-k\">.</span><span class=\"pl-smi\">Reference</span> ref <span class=\"pl-k\">=</span> graph<span class=\"pl-k\">.</span>ref();\n    <span class=\"pl-k\">long</span> opHandle <span class=\"pl-k\">=</span> <span class=\"pl-c1\">0</span>;\n    <span class=\"pl-k\">try</span> {\n       <span class=\"pl-c\"><span class=\"pl-c\">//</span> nextOperation would be a method in graph_jni.cc</span>\n       opHandle <span class=\"pl-k\">=</span> <span class=\"pl-smi\">Graph</span><span class=\"pl-k\">.</span>nextOperation(ref<span class=\"pl-k\">.</span>nativeHandle(), pos<span class=\"pl-k\">++</span>);\n    } <span class=\"pl-k\">finally</span> {\n      ref<span class=\"pl-k\">.</span>close();\n    }\n    op <span class=\"pl-k\">=</span> opHandle <span class=\"pl-k\">==</span> <span class=\"pl-c1\">0</span> <span class=\"pl-k\">?</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">Operation</span>(<span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>graph, opHandle) <span class=\"pl-k\">:</span> <span class=\"pl-c1\">null</span>;\n  }\n  <span class=\"pl-k\">public</span> <span class=\"pl-k\">boolean</span> <span class=\"pl-en\">hasNext</span>() { <span class=\"pl-k\">return</span> op <span class=\"pl-k\">!=</span> <span class=\"pl-c1\">null</span>; }\n  <span class=\"pl-k\">public</span> <span class=\"pl-smi\">Operation</span> <span class=\"pl-en\">next</span>() { \n    <span class=\"pl-smi\">Operation</span> ret <span class=\"pl-k\">=</span> op;\n    advance();\n    <span class=\"pl-k\">return</span> ret;\n  }\n\n  <span class=\"pl-k\">private</span> <span class=\"pl-smi\">Graph</span> graph;\n  <span class=\"pl-k\">private</span> <span class=\"pl-smi\">Operation</span> op <span class=\"pl-k\">=</span> <span class=\"pl-c1\">null</span>;\n  <span class=\"pl-k\">private</span> <span class=\"pl-k\">int</span> pos <span class=\"pl-k\">=</span> <span class=\"pl-c1\">0</span>;\n}\n\n<span class=\"pl-k\">public</span> <span class=\"pl-k\">Iterator&lt;<span class=\"pl-smi\">Operation</span>&gt;</span> operations() {\n  <span class=\"pl-k\">return</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">OperationIterator</span>(<span class=\"pl-c1\">this</span>);\n}</pre></div>", "body_text": "Let's make this return an Iterator<Operation> instead of a List<Operation>. The C API for iteration predates my involvement with the project, so I'm not entirely sure, but it seems that if there was a reason to prefer iteration there (perhaps memory footprint of when traversing very large graphs), that same reason would apply here.\nI'd imagine something like:\nprivate final class OperationIterator implements Iterator<Operation> {\n  OperationIterator(Graph g) {\n    this.graph = g;\n    advance();\n  }\n\n  private void advance() {\n    Graph.Reference ref = graph.ref();\n    long opHandle = 0;\n    try {\n       // nextOperation would be a method in graph_jni.cc\n       opHandle = Graph.nextOperation(ref.nativeHandle(), pos++);\n    } finally {\n      ref.close();\n    }\n    op = opHandle == 0 ? new Operation(this.graph, opHandle) : null;\n  }\n  public boolean hasNext() { return op != null; }\n  public Operation next() { \n    Operation ret = op;\n    advance();\n    return ret;\n  }\n\n  private Graph graph;\n  private Operation op = null;\n  private int pos = 0;\n}\n\npublic Iterator<Operation> operations() {\n  return new OperationIterator(this);\n}"}