{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/240463608", "html_url": "https://github.com/tensorflow/tensorflow/issues/3717#issuecomment-240463608", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/3717", "id": 240463608, "node_id": "MDEyOklzc3VlQ29tbWVudDI0MDQ2MzYwOA==", "user": {"login": "prb12", "id": 11547801, "node_id": "MDQ6VXNlcjExNTQ3ODAx", "avatar_url": "https://avatars1.githubusercontent.com/u/11547801?v=4", "gravatar_id": "", "url": "https://api.github.com/users/prb12", "html_url": "https://github.com/prb12", "followers_url": "https://api.github.com/users/prb12/followers", "following_url": "https://api.github.com/users/prb12/following{/other_user}", "gists_url": "https://api.github.com/users/prb12/gists{/gist_id}", "starred_url": "https://api.github.com/users/prb12/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/prb12/subscriptions", "organizations_url": "https://api.github.com/users/prb12/orgs", "repos_url": "https://api.github.com/users/prb12/repos", "events_url": "https://api.github.com/users/prb12/events{/privacy}", "received_events_url": "https://api.github.com/users/prb12/received_events", "type": "User", "site_admin": false}, "created_at": "2016-08-17T16:14:13Z", "updated_at": "2016-08-17T16:14:47Z", "author_association": "MEMBER", "body_html": "<p>It is unfortunate, but expected, to have some 'undefined' tensors/ops in the current Timeline view.<br>\nThe reasons for this are due to some internal implementation details of the tracing framework.</p>\n<p>In particular, the <code>timeline_label</code> field in the <code>StepStats</code> proto is generated from the <code>NodeDef</code>s in the <strong>original</strong> <code>GraphDef</code>, and the code which does this currently has no way to know about the ever-increasing amount of graph rewriting which happens before execution.</p>\n<p>Quite often the original input nodes of the graph are simply no longer present at execution time and so do not appear in the <code>StepStats</code>.  The <code>tf.Timeline</code> code uses an extremely simple heuristic to parse this <code>timeline_label</code> and <em>attempt</em> to find the input nodes elsewhere in the trace (i.e. the <code>StepStats</code>)...  but this heuristic is increasingly fragile.</p>\n<p>Some examples of rewriting which can cause input nodes to 'disappear' from the graph are:</p>\n<ul>\n<li>Partitioning of the graph across 'devices' (e.g. CPU vs CPU) which turns an edge in the original graph into <code>_Send</code> and <code>_Recv</code> nodes with freshly generated names (usually ending with a numeric suffix)</li>\n<li>Constant folding (if running with optimizations enabled) can frequently reduce non-trivial subgraphs to constant nodes with names ending in <code>__cf_[digits]</code></li>\n<li>Device-specific graph rewrites (see <code>Device::MaybeRewriteGraphDef</code>)</li>\n<li>Any <code>OptimizationPass</code> which may have been registered.</li>\n</ul>\n<p>Most of the time, the only places where people will encounter this problem are when tensors cross device boundaries or when there has been some constant folding...  if the former is happening a lot then you have probably found your performance problem ;-)</p>\n<p>It's arguably overdue to refactor some of these APIs, but there are other changes in progress which will need to happen first.</p>\n<p>The most likely solution is to add some additional metadata APIs (e.g. to <code>Session</code>) to allow the collection of the optimized and partitioned <code>GraphDefs</code> which actually get executed.  (e.g. <code>RunMetadata</code> could be extended to return the <em>actual</em> <code>GraphDefs</code> and this information could be provided to <code>tf.Timeline</code>).  This would probably save a <em>lot</em> of wasted debugging time and help people understand what is going on under the hood.</p>", "body_text": "It is unfortunate, but expected, to have some 'undefined' tensors/ops in the current Timeline view.\nThe reasons for this are due to some internal implementation details of the tracing framework.\nIn particular, the timeline_label field in the StepStats proto is generated from the NodeDefs in the original GraphDef, and the code which does this currently has no way to know about the ever-increasing amount of graph rewriting which happens before execution.\nQuite often the original input nodes of the graph are simply no longer present at execution time and so do not appear in the StepStats.  The tf.Timeline code uses an extremely simple heuristic to parse this timeline_label and attempt to find the input nodes elsewhere in the trace (i.e. the StepStats)...  but this heuristic is increasingly fragile.\nSome examples of rewriting which can cause input nodes to 'disappear' from the graph are:\n\nPartitioning of the graph across 'devices' (e.g. CPU vs CPU) which turns an edge in the original graph into _Send and _Recv nodes with freshly generated names (usually ending with a numeric suffix)\nConstant folding (if running with optimizations enabled) can frequently reduce non-trivial subgraphs to constant nodes with names ending in __cf_[digits]\nDevice-specific graph rewrites (see Device::MaybeRewriteGraphDef)\nAny OptimizationPass which may have been registered.\n\nMost of the time, the only places where people will encounter this problem are when tensors cross device boundaries or when there has been some constant folding...  if the former is happening a lot then you have probably found your performance problem ;-)\nIt's arguably overdue to refactor some of these APIs, but there are other changes in progress which will need to happen first.\nThe most likely solution is to add some additional metadata APIs (e.g. to Session) to allow the collection of the optimized and partitioned GraphDefs which actually get executed.  (e.g. RunMetadata could be extended to return the actual GraphDefs and this information could be provided to tf.Timeline).  This would probably save a lot of wasted debugging time and help people understand what is going on under the hood.", "body": "It is unfortunate, but expected, to have some 'undefined' tensors/ops in the current Timeline view.\nThe reasons for this are due to some internal implementation details of the tracing framework. \n\nIn particular, the `timeline_label` field in the `StepStats` proto is generated from the `NodeDef`s in the **original** `GraphDef`, and the code which does this currently has no way to know about the ever-increasing amount of graph rewriting which happens before execution.  \n\nQuite often the original input nodes of the graph are simply no longer present at execution time and so do not appear in the `StepStats`.  The `tf.Timeline` code uses an extremely simple heuristic to parse this `timeline_label` and _attempt_ to find the input nodes elsewhere in the trace (i.e. the `StepStats`)...  but this heuristic is increasingly fragile.\n\nSome examples of rewriting which can cause input nodes to 'disappear' from the graph are:\n- Partitioning of the graph across 'devices' (e.g. CPU vs CPU) which turns an edge in the original graph into `_Send` and `_Recv` nodes with freshly generated names (usually ending with a numeric suffix)\n- Constant folding (if running with optimizations enabled) can frequently reduce non-trivial subgraphs to constant nodes with names ending in `__cf_[digits]` \n- Device-specific graph rewrites (see `Device::MaybeRewriteGraphDef`)\n- Any `OptimizationPass` which may have been registered. \n\nMost of the time, the only places where people will encounter this problem are when tensors cross device boundaries or when there has been some constant folding...  if the former is happening a lot then you have probably found your performance problem ;-)  \n\nIt's arguably overdue to refactor some of these APIs, but there are other changes in progress which will need to happen first.\n\nThe most likely solution is to add some additional metadata APIs (e.g. to `Session`) to allow the collection of the optimized and partitioned `GraphDefs` which actually get executed.  (e.g. `RunMetadata` could be extended to return the _actual_ `GraphDefs` and this information could be provided to `tf.Timeline`).  This would probably save a _lot_ of wasted debugging time and help people understand what is going on under the hood.\n"}