{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/348436692", "html_url": "https://github.com/tensorflow/tensorflow/issues/12859#issuecomment-348436692", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/12859", "id": 348436692, "node_id": "MDEyOklzc3VlQ29tbWVudDM0ODQzNjY5Mg==", "user": {"login": "maxfiedler", "id": 4192637, "node_id": "MDQ6VXNlcjQxOTI2Mzc=", "avatar_url": "https://avatars1.githubusercontent.com/u/4192637?v=4", "gravatar_id": "", "url": "https://api.github.com/users/maxfiedler", "html_url": "https://github.com/maxfiedler", "followers_url": "https://api.github.com/users/maxfiedler/followers", "following_url": "https://api.github.com/users/maxfiedler/following{/other_user}", "gists_url": "https://api.github.com/users/maxfiedler/gists{/gist_id}", "starred_url": "https://api.github.com/users/maxfiedler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/maxfiedler/subscriptions", "organizations_url": "https://api.github.com/users/maxfiedler/orgs", "repos_url": "https://api.github.com/users/maxfiedler/repos", "events_url": "https://api.github.com/users/maxfiedler/events{/privacy}", "received_events_url": "https://api.github.com/users/maxfiedler/received_events", "type": "User", "site_admin": false}, "created_at": "2017-12-01T08:45:33Z", "updated_at": "2017-12-01T08:45:33Z", "author_association": "NONE", "body_html": "<p>Yes this does the trick. Below the hack in the source code of SummarySaverHook that will make the example above work (starting in line 628 of basic_session_run_hooks.py of TF r1.4):</p>\n<pre><code>  def begin(self):\n    if self._summary_writer is None and self._output_dir:\n      self._summary_writer = SummaryWriterCache.get(self._output_dir)\n    self._next_step = None\n    self._global_step_tensor = training_util._get_or_create_global_step_read()  # pylint: disable=protected-access\n    self._start = False\n    if self._global_step_tensor is None:\n      raise RuntimeError(\n          \"Global step should be created to use SummarySaverHook.\")\n\n  def before_run(self, run_context):  # pylint: disable=unused-argument\n    if self._start:\n      self._request_summary = (\n          self._next_step is None or\n          self._timer.should_trigger_for_step(self._next_step))\n      requests = {\"global_step\": self._global_step_tensor}\n      if self._request_summary:\n        if self._get_summary_op() is not None:\n          requests[\"summary\"] = self._get_summary_op()\n\n      return SessionRunArgs(requests)\n\n  def after_run(self, run_context, run_values):\n    if self._start:\n      _ = run_context\n      if not self._summary_writer:\n        return\n\n      stale_global_step = run_values.results[\"global_step\"]\n      global_step = stale_global_step + 1\n      if self._next_step is None or self._request_summary:\n        global_step = run_context.session.run(self._global_step_tensor)\n\n      if self._next_step is None:\n        self._summary_writer.add_session_log(\n            SessionLog(status=SessionLog.START), global_step)\n\n      if self._request_summary:\n        self._timer.update_last_triggered_step(global_step)\n        if \"summary\" in run_values.results:\n          for summary in run_values.results[\"summary\"]:\n            self._summary_writer.add_summary(summary, global_step)\n\n      self._next_step = global_step + 1\n    self._start = True\n</code></pre>\n<p>Of course this shouldn't be the official fix ;)<br>\nAlternatively one could check the fetches of a session run call and don't execute the before_run and after_run off a hook if the fetches contain a <code>Tensor(\"IteratorToStringHandle:0\", shape=(), dtype=string)</code><br>\nBut this also seems rather roundabout ...</p>", "body_text": "Yes this does the trick. Below the hack in the source code of SummarySaverHook that will make the example above work (starting in line 628 of basic_session_run_hooks.py of TF r1.4):\n  def begin(self):\n    if self._summary_writer is None and self._output_dir:\n      self._summary_writer = SummaryWriterCache.get(self._output_dir)\n    self._next_step = None\n    self._global_step_tensor = training_util._get_or_create_global_step_read()  # pylint: disable=protected-access\n    self._start = False\n    if self._global_step_tensor is None:\n      raise RuntimeError(\n          \"Global step should be created to use SummarySaverHook.\")\n\n  def before_run(self, run_context):  # pylint: disable=unused-argument\n    if self._start:\n      self._request_summary = (\n          self._next_step is None or\n          self._timer.should_trigger_for_step(self._next_step))\n      requests = {\"global_step\": self._global_step_tensor}\n      if self._request_summary:\n        if self._get_summary_op() is not None:\n          requests[\"summary\"] = self._get_summary_op()\n\n      return SessionRunArgs(requests)\n\n  def after_run(self, run_context, run_values):\n    if self._start:\n      _ = run_context\n      if not self._summary_writer:\n        return\n\n      stale_global_step = run_values.results[\"global_step\"]\n      global_step = stale_global_step + 1\n      if self._next_step is None or self._request_summary:\n        global_step = run_context.session.run(self._global_step_tensor)\n\n      if self._next_step is None:\n        self._summary_writer.add_session_log(\n            SessionLog(status=SessionLog.START), global_step)\n\n      if self._request_summary:\n        self._timer.update_last_triggered_step(global_step)\n        if \"summary\" in run_values.results:\n          for summary in run_values.results[\"summary\"]:\n            self._summary_writer.add_summary(summary, global_step)\n\n      self._next_step = global_step + 1\n    self._start = True\n\nOf course this shouldn't be the official fix ;)\nAlternatively one could check the fetches of a session run call and don't execute the before_run and after_run off a hook if the fetches contain a Tensor(\"IteratorToStringHandle:0\", shape=(), dtype=string)\nBut this also seems rather roundabout ...", "body": "Yes this does the trick. Below the hack in the source code of SummarySaverHook that will make the example above work (starting in line 628 of basic_session_run_hooks.py of TF r1.4):\r\n```\r\n  def begin(self):\r\n    if self._summary_writer is None and self._output_dir:\r\n      self._summary_writer = SummaryWriterCache.get(self._output_dir)\r\n    self._next_step = None\r\n    self._global_step_tensor = training_util._get_or_create_global_step_read()  # pylint: disable=protected-access\r\n    self._start = False\r\n    if self._global_step_tensor is None:\r\n      raise RuntimeError(\r\n          \"Global step should be created to use SummarySaverHook.\")\r\n\r\n  def before_run(self, run_context):  # pylint: disable=unused-argument\r\n    if self._start:\r\n      self._request_summary = (\r\n          self._next_step is None or\r\n          self._timer.should_trigger_for_step(self._next_step))\r\n      requests = {\"global_step\": self._global_step_tensor}\r\n      if self._request_summary:\r\n        if self._get_summary_op() is not None:\r\n          requests[\"summary\"] = self._get_summary_op()\r\n\r\n      return SessionRunArgs(requests)\r\n\r\n  def after_run(self, run_context, run_values):\r\n    if self._start:\r\n      _ = run_context\r\n      if not self._summary_writer:\r\n        return\r\n\r\n      stale_global_step = run_values.results[\"global_step\"]\r\n      global_step = stale_global_step + 1\r\n      if self._next_step is None or self._request_summary:\r\n        global_step = run_context.session.run(self._global_step_tensor)\r\n\r\n      if self._next_step is None:\r\n        self._summary_writer.add_session_log(\r\n            SessionLog(status=SessionLog.START), global_step)\r\n\r\n      if self._request_summary:\r\n        self._timer.update_last_triggered_step(global_step)\r\n        if \"summary\" in run_values.results:\r\n          for summary in run_values.results[\"summary\"]:\r\n            self._summary_writer.add_summary(summary, global_step)\r\n\r\n      self._next_step = global_step + 1\r\n    self._start = True\r\n```\r\nOf course this shouldn't be the official fix ;)\r\nAlternatively one could check the fetches of a session run call and don't execute the before_run and after_run off a hook if the fetches contain a `Tensor(\"IteratorToStringHandle:0\", shape=(), dtype=string)`\r\nBut this also seems rather roundabout ...\r\n"}