{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/286822012", "html_url": "https://github.com/tensorflow/tensorflow/issues/8403#issuecomment-286822012", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8403", "id": 286822012, "node_id": "MDEyOklzc3VlQ29tbWVudDI4NjgyMjAxMg==", "user": {"login": "drpngx", "id": 20959853, "node_id": "MDQ6VXNlcjIwOTU5ODUz", "avatar_url": "https://avatars1.githubusercontent.com/u/20959853?v=4", "gravatar_id": "", "url": "https://api.github.com/users/drpngx", "html_url": "https://github.com/drpngx", "followers_url": "https://api.github.com/users/drpngx/followers", "following_url": "https://api.github.com/users/drpngx/following{/other_user}", "gists_url": "https://api.github.com/users/drpngx/gists{/gist_id}", "starred_url": "https://api.github.com/users/drpngx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/drpngx/subscriptions", "organizations_url": "https://api.github.com/users/drpngx/orgs", "repos_url": "https://api.github.com/users/drpngx/repos", "events_url": "https://api.github.com/users/drpngx/events{/privacy}", "received_events_url": "https://api.github.com/users/drpngx/received_events", "type": "User", "site_admin": false}, "created_at": "2017-03-15T17:40:49Z", "updated_at": "2017-03-15T17:40:49Z", "author_association": "MEMBER", "body_html": "<p>This is essentially a variation of <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"214044373\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/tensorflow/tensorflow/issues/8394\" data-hovercard-type=\"issue\" data-hovercard-url=\"/tensorflow/tensorflow/issues/8394/hovercard\" href=\"https://github.com/tensorflow/tensorflow/issues/8394\">#8394</a>.</p>\n<p>What happens is that you have this</p>\n<pre><code>  libprotobuf.so.12 =&gt; /usr/local/lib/libprotobuf.so.12 (0x00007fc8933f8000)\n</code></pre>\n<p>Even though it's the same version, each SO library has its own <code>.data</code> segment, where static variables are stored. Protobuf uses the static store for registration, default values, and various caching mechanism. When you first start up the program, you are using your own protobuf, with its own static store. Any function that you call will refer to your app's <code>.data</code> segment. When you load <code>_pywrap_tensorflow_internal</code>, it will clobber these functions, referring to the tensorflow, statically-linked protobuf, therefore trying to free things that don't exist etc.</p>\n<p>This is not a problem with your usage, rather, with our library.</p>\n<p>For now, a workaround is to link against <code>_pywrap_tensorflow</code> to get the protobuf symbols. Make sure you <em>do not have</em> any static initializers, or if you do, try using <code>__attribute__((constructor))</code>.</p>", "body_text": "This is essentially a variation of #8394.\nWhat happens is that you have this\n  libprotobuf.so.12 => /usr/local/lib/libprotobuf.so.12 (0x00007fc8933f8000)\n\nEven though it's the same version, each SO library has its own .data segment, where static variables are stored. Protobuf uses the static store for registration, default values, and various caching mechanism. When you first start up the program, you are using your own protobuf, with its own static store. Any function that you call will refer to your app's .data segment. When you load _pywrap_tensorflow_internal, it will clobber these functions, referring to the tensorflow, statically-linked protobuf, therefore trying to free things that don't exist etc.\nThis is not a problem with your usage, rather, with our library.\nFor now, a workaround is to link against _pywrap_tensorflow to get the protobuf symbols. Make sure you do not have any static initializers, or if you do, try using __attribute__((constructor)).", "body": "This is essentially a variation of https://github.com/tensorflow/tensorflow/issues/8394.\r\n\r\nWhat happens is that you have this\r\n```\r\n  libprotobuf.so.12 => /usr/local/lib/libprotobuf.so.12 (0x00007fc8933f8000)\r\n```\r\n\r\nEven though it's the same version, each SO library has its own `.data` segment, where static variables are stored. Protobuf uses the static store for registration, default values, and various caching mechanism. When you first start up the program, you are using your own protobuf, with its own static store. Any function that you call will refer to your app's `.data` segment. When you load `_pywrap_tensorflow_internal`, it will clobber these functions, referring to the tensorflow, statically-linked protobuf, therefore trying to free things that don't exist etc.\r\n\r\nThis is not a problem with your usage, rather, with our library.\r\n\r\nFor now, a workaround is to link against `_pywrap_tensorflow` to get the protobuf symbols. Make sure you *do not have* any static initializers, or if you do, try using `__attribute__((constructor))`."}