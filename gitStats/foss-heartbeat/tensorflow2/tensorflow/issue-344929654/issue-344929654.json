{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/21169", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/21169/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/21169/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/21169/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/21169", "id": 344929654, "node_id": "MDU6SXNzdWUzNDQ5Mjk2NTQ=", "number": 21169, "title": "tf.Estimator can't load weights at runtime", "user": {"login": "KevinLucidyne", "id": 19497849, "node_id": "MDQ6VXNlcjE5NDk3ODQ5", "avatar_url": "https://avatars2.githubusercontent.com/u/19497849?v=4", "gravatar_id": "", "url": "https://api.github.com/users/KevinLucidyne", "html_url": "https://github.com/KevinLucidyne", "followers_url": "https://api.github.com/users/KevinLucidyne/followers", "following_url": "https://api.github.com/users/KevinLucidyne/following{/other_user}", "gists_url": "https://api.github.com/users/KevinLucidyne/gists{/gist_id}", "starred_url": "https://api.github.com/users/KevinLucidyne/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/KevinLucidyne/subscriptions", "organizations_url": "https://api.github.com/users/KevinLucidyne/orgs", "repos_url": "https://api.github.com/users/KevinLucidyne/repos", "events_url": "https://api.github.com/users/KevinLucidyne/events{/privacy}", "received_events_url": "https://api.github.com/users/KevinLucidyne/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2018-07-26T17:09:17Z", "updated_at": "2018-07-26T20:46:22Z", "closed_at": "2018-07-26T20:46:22Z", "author_association": "NONE", "body_html": "<p>This is not a StackOverflow question because it simply can't be done the way tf.Estimator is currently designed.  This is a design flaw.</p>\n<p>Language: Anaconda Python 3.6<br>\nOS Platform and Distribution: Ubuntu 17.10<br>\nTensorFlow version: 1.8<br>\nCuda compilation tools, release 9.0, V9.0.176 /<br>\nCUDNN 7.0.5<br>\nGPU model and memory: NVIDIA Titan V, Driver Version: 387.34, 12057MiB</p>\n<p>I'm working on building a distributed TensorFlow model for semantic segmentation (pixel-based, not bounding-box-based) using the <a href=\"https://github.com/tensorflow/models/tree/master/tutorials/image/cifar10_estimator\">https://github.com/tensorflow/models/tree/master/tutorials/image/cifar10_estimator</a> example.  The code fragments below are based on that example.</p>\n<p>This model is for production, not research so as part of the input pipeline, I have to extract training images from production images and calculate training class weights on the fly.  However, the current design of tf.Estimator appears to make this impossible.</p>\n<p>If the class weights are uploaded into a static variable and then I attempt to collate them in _resnet_model_fn to use in the loss function I get errors telling me that the class weights are in the wrong class.</p>\n<p>Runtime class weights assembly:</p>\n<pre><code>class MyDataSet(object):\n    _class_weights = None\n\n    def __init__(self, data_dir):\n        self.data_dir = data_dir\n        if MyDataSet._class_weights is None:\n            MyDataSet._class_weights = MyDataSet.map_weights(data_dir)\n\n    @staticmethod\n    def train_id_to_weight_map_func(label):\n        return MyDataSet._class_weights[label]\n\n    @staticmethod\n    def map_weights(data_dir):\n        weights = pickle.load(open(os.path.join(data_dir, 'weight.pkl'), 'rb'))\n        class_weights = [0] * weights.size\n        for i, w in enumerate(weights):\n            class_weights[i] = w\n        return tf.convert_to_tensor(class_weights, np.float32)\n\n</code></pre>\n<p>cyfar10_main.py:</p>\n<pre><code>def _resnet_model_fn(features, labels, mode, params):\n    tower_labels = labels\n    tower_weight = []\n    for label in tower_labels:\n        tower_weight.append(tf.map_fn(lambda x: MyDataSet.train_id_to_weight_map_func(x), label, np.float32)\n</code></pre>\n<p>Error:</p>\n<pre><code>ValueError: Tensor(\"map/while/TensorArrayReadV3:0\", shape=(256, 512), dtype=int32) must be from the same graph as Tensor(\"Const:0\", shape=(25,), dtype=float32)\nprint(label.graph)\n&lt;tensorflow.python.framework.ops.Graph object at 0x7f9a206630f0&gt;\nprint(LinkNetDataSet._class_weights.graph)\n&lt;tensorflow.python.framework.ops.Graph object at 0x7f9a2a8b1cf8&gt;`\n</code></pre>\n<p>If I next try to load the weights into input_fn to get them into the same graph, I am unable to do so because Estimator is only expecting two lists of Tensors from input_fn: features and labels.  And features is already taken up with the training image so there's no place to put the class weights.</p>", "body_text": "This is not a StackOverflow question because it simply can't be done the way tf.Estimator is currently designed.  This is a design flaw.\nLanguage: Anaconda Python 3.6\nOS Platform and Distribution: Ubuntu 17.10\nTensorFlow version: 1.8\nCuda compilation tools, release 9.0, V9.0.176 /\nCUDNN 7.0.5\nGPU model and memory: NVIDIA Titan V, Driver Version: 387.34, 12057MiB\nI'm working on building a distributed TensorFlow model for semantic segmentation (pixel-based, not bounding-box-based) using the https://github.com/tensorflow/models/tree/master/tutorials/image/cifar10_estimator example.  The code fragments below are based on that example.\nThis model is for production, not research so as part of the input pipeline, I have to extract training images from production images and calculate training class weights on the fly.  However, the current design of tf.Estimator appears to make this impossible.\nIf the class weights are uploaded into a static variable and then I attempt to collate them in _resnet_model_fn to use in the loss function I get errors telling me that the class weights are in the wrong class.\nRuntime class weights assembly:\nclass MyDataSet(object):\n    _class_weights = None\n\n    def __init__(self, data_dir):\n        self.data_dir = data_dir\n        if MyDataSet._class_weights is None:\n            MyDataSet._class_weights = MyDataSet.map_weights(data_dir)\n\n    @staticmethod\n    def train_id_to_weight_map_func(label):\n        return MyDataSet._class_weights[label]\n\n    @staticmethod\n    def map_weights(data_dir):\n        weights = pickle.load(open(os.path.join(data_dir, 'weight.pkl'), 'rb'))\n        class_weights = [0] * weights.size\n        for i, w in enumerate(weights):\n            class_weights[i] = w\n        return tf.convert_to_tensor(class_weights, np.float32)\n\n\ncyfar10_main.py:\ndef _resnet_model_fn(features, labels, mode, params):\n    tower_labels = labels\n    tower_weight = []\n    for label in tower_labels:\n        tower_weight.append(tf.map_fn(lambda x: MyDataSet.train_id_to_weight_map_func(x), label, np.float32)\n\nError:\nValueError: Tensor(\"map/while/TensorArrayReadV3:0\", shape=(256, 512), dtype=int32) must be from the same graph as Tensor(\"Const:0\", shape=(25,), dtype=float32)\nprint(label.graph)\n<tensorflow.python.framework.ops.Graph object at 0x7f9a206630f0>\nprint(LinkNetDataSet._class_weights.graph)\n<tensorflow.python.framework.ops.Graph object at 0x7f9a2a8b1cf8>`\n\nIf I next try to load the weights into input_fn to get them into the same graph, I am unable to do so because Estimator is only expecting two lists of Tensors from input_fn: features and labels.  And features is already taken up with the training image so there's no place to put the class weights.", "body": "This is not a StackOverflow question because it simply can't be done the way tf.Estimator is currently designed.  This is a design flaw.\r\n\r\nLanguage: Anaconda Python 3.6\r\nOS Platform and Distribution: Ubuntu 17.10\r\nTensorFlow version: 1.8\r\nCuda compilation tools, release 9.0, V9.0.176 /\r\nCUDNN 7.0.5\r\nGPU model and memory: NVIDIA Titan V, Driver Version: 387.34, 12057MiB\r\n\r\nI'm working on building a distributed TensorFlow model for semantic segmentation (pixel-based, not bounding-box-based) using the https://github.com/tensorflow/models/tree/master/tutorials/image/cifar10_estimator example.  The code fragments below are based on that example. \r\n\r\nThis model is for production, not research so as part of the input pipeline, I have to extract training images from production images and calculate training class weights on the fly.  However, the current design of tf.Estimator appears to make this impossible.\r\n\r\nIf the class weights are uploaded into a static variable and then I attempt to collate them in _resnet_model_fn to use in the loss function I get errors telling me that the class weights are in the wrong class.\r\n\r\nRuntime class weights assembly:\r\n```\r\nclass MyDataSet(object):\r\n    _class_weights = None\r\n\r\n    def __init__(self, data_dir):\r\n        self.data_dir = data_dir\r\n        if MyDataSet._class_weights is None:\r\n            MyDataSet._class_weights = MyDataSet.map_weights(data_dir)\r\n\r\n    @staticmethod\r\n    def train_id_to_weight_map_func(label):\r\n        return MyDataSet._class_weights[label]\r\n\r\n    @staticmethod\r\n    def map_weights(data_dir):\r\n        weights = pickle.load(open(os.path.join(data_dir, 'weight.pkl'), 'rb'))\r\n        class_weights = [0] * weights.size\r\n        for i, w in enumerate(weights):\r\n            class_weights[i] = w\r\n        return tf.convert_to_tensor(class_weights, np.float32)\r\n\r\n```\r\n \r\ncyfar10_main.py:\r\n\r\n```\r\ndef _resnet_model_fn(features, labels, mode, params):\r\n    tower_labels = labels\r\n    tower_weight = []\r\n    for label in tower_labels:\r\n        tower_weight.append(tf.map_fn(lambda x: MyDataSet.train_id_to_weight_map_func(x), label, np.float32)\r\n```\r\nError:\r\n```\r\nValueError: Tensor(\"map/while/TensorArrayReadV3:0\", shape=(256, 512), dtype=int32) must be from the same graph as Tensor(\"Const:0\", shape=(25,), dtype=float32)\r\nprint(label.graph)\r\n<tensorflow.python.framework.ops.Graph object at 0x7f9a206630f0>\r\nprint(LinkNetDataSet._class_weights.graph)\r\n<tensorflow.python.framework.ops.Graph object at 0x7f9a2a8b1cf8>`\r\n```\r\n\r\nIf I next try to load the weights into input_fn to get them into the same graph, I am unable to do so because Estimator is only expecting two lists of Tensors from input_fn: features and labels.  And features is already taken up with the training image so there's no place to put the class weights."}