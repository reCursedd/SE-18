{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/289783064", "html_url": "https://github.com/tensorflow/tensorflow/issues/8712#issuecomment-289783064", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/8712", "id": 289783064, "node_id": "MDEyOklzc3VlQ29tbWVudDI4OTc4MzA2NA==", "user": {"login": "Androbin", "id": 16437156, "node_id": "MDQ6VXNlcjE2NDM3MTU2", "avatar_url": "https://avatars1.githubusercontent.com/u/16437156?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Androbin", "html_url": "https://github.com/Androbin", "followers_url": "https://api.github.com/users/Androbin/followers", "following_url": "https://api.github.com/users/Androbin/following{/other_user}", "gists_url": "https://api.github.com/users/Androbin/gists{/gist_id}", "starred_url": "https://api.github.com/users/Androbin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Androbin/subscriptions", "organizations_url": "https://api.github.com/users/Androbin/orgs", "repos_url": "https://api.github.com/users/Androbin/repos", "events_url": "https://api.github.com/users/Androbin/events{/privacy}", "received_events_url": "https://api.github.com/users/Androbin/received_events", "type": "User", "site_admin": false}, "created_at": "2017-03-28T14:13:12Z", "updated_at": "2017-03-28T14:25:44Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=16018\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/asimshankar\">@asimshankar</a> So, what would have the least overhead?<br>\nFilling a previously allocated <code>float[]</code> and finally calling <code>FloatBuffer.wrap(float[])</code> each time<br>\nor calling <code>FloatBuffer.put(float)</code> on a previously allocated direct buffer in native byte order?<br>\nAnd for the last case: My pre-processing is parallel. Does it matter to the performance of <code>FloatBuffer.put(int, float)</code> if there are jumps in position?</p>", "body_text": "@asimshankar So, what would have the least overhead?\nFilling a previously allocated float[] and finally calling FloatBuffer.wrap(float[]) each time\nor calling FloatBuffer.put(float) on a previously allocated direct buffer in native byte order?\nAnd for the last case: My pre-processing is parallel. Does it matter to the performance of FloatBuffer.put(int, float) if there are jumps in position?", "body": "@asimshankar So, what would have the least overhead?\r\nFilling a previously allocated `float[]` and finally calling `FloatBuffer.wrap(float[])` each time\r\nor calling `FloatBuffer.put(float)` on a previously allocated direct buffer in native byte order?\r\nAnd for the last case: My pre-processing is parallel. Does it matter to the performance of `FloatBuffer.put(int, float)` if there are jumps in position?"}