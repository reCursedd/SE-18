{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9794", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9794/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9794/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9794/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/9794", "id": 227352564, "node_id": "MDU6SXNzdWUyMjczNTI1NjQ=", "number": 9794, "title": "how to get image shape after decode in C++ ", "user": {"login": "freesouls", "id": 9496288, "node_id": "MDQ6VXNlcjk0OTYyODg=", "avatar_url": "https://avatars1.githubusercontent.com/u/9496288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/freesouls", "html_url": "https://github.com/freesouls", "followers_url": "https://api.github.com/users/freesouls/followers", "following_url": "https://api.github.com/users/freesouls/following{/other_user}", "gists_url": "https://api.github.com/users/freesouls/gists{/gist_id}", "starred_url": "https://api.github.com/users/freesouls/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/freesouls/subscriptions", "organizations_url": "https://api.github.com/users/freesouls/orgs", "repos_url": "https://api.github.com/users/freesouls/repos", "events_url": "https://api.github.com/users/freesouls/events{/privacy}", "received_events_url": "https://api.github.com/users/freesouls/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2017-05-09T12:40:50Z", "updated_at": "2017-11-14T22:04:19Z", "closed_at": "2017-05-10T00:02:49Z", "author_association": "NONE", "body_html": "<h3>System information</h3>\n<ul>\n<li><strong>OS Platform and Distribution</strong>: Debian</li>\n<li><strong>TensorFlow installed from (source or binary)</strong>: source</li>\n<li><strong>TensorFlow version (use command below)</strong>: 1.0.1</li>\n<li><strong>Bazel version (if compiling from source)</strong>: 0.4.5</li>\n<li><strong>CUDA/cuDNN version</strong>: cuda-8.0, cudnn5.1.5</li>\n<li><strong>GPU model and memory</strong>: 12GB</li>\n</ul>\n<p>I follow the tutorial of <a href=\"https://www.tensorflow.org/tutorials/image_recognition\" rel=\"nofollow\">inception label_image</a>,<br>\n<a href=\"https://github.com/tensorflow/tensorflow/blob/master/tensorflow/examples/label_image/main.cc\">source codes</a> ,<br>\n<a href=\"https://github.com/tensorflow/tensorflow/tree/master/tensorflow/examples/label_image\">README.md</a> , I can compile and run the demo c++ code successfully.</p>\n<p>I want to adapt this demo to my own project, the input images to my own Network is height fixed, while width varies accordingly, for example, the original image is size of 64x100, and I want to resize it to 32x50, as I said 32 is the new_height, and I want to know original image size after reading from the file, how can I get width=100 and height=64? then I can get new_width = new_height/height x width=32/64x100=50</p>\n<p>the following is a small piece of the image_recognition tutorial C++ codes, resize is hard coded to a pre-define size, I try <code>float_caster.shape()</code>, <code>tensor()</code>, <code>float_caster.dimension(0)</code>, etc, all failed(<code>float_caster</code>, <code>file_reader</code> are all not <code>Tensor</code>, I don't know why Google design like this, really slow down the development, and I find no documentation about this), is there any easy way to get the image size? or cast the <code>tensorflow::Ouput</code> type to <code>Tensor</code>?</p>\n<p>one possible way is first use opencv to load the image, and resize it, then copy the elements to tensor like this <a href=\"https://gist.github.com/kyrs/9adf86366e9e4f04addb\">example</a> <strong>pixel by pixel</strong>, but the performance is the main problem and it seems hard to compile tensorflow along with opencv.  Any one knows some methods using tensorflow's API?</p>\n<p>Thanks in advance!</p>\n<pre><code>\n// Given an image file name, read in the data, try to decode it as an image,\n// resize it to the requested size, and then scale the values as desired.\nStatus ReadTensorFromImageFile(string file_name, const int input_height,\n                               const int input_width, const float input_mean,\n                               const float input_std,\n                               std::vector&lt;Tensor&gt;* out_tensors) {\n  auto root = tensorflow::Scope::NewRootScope();\n  using namespace ::tensorflow::ops;  // NOLINT(build/namespaces)\n\n  string input_name = \"file_reader\";\n  string output_name = \"normalized\";\n  auto file_reader =\n      tensorflow::ops::ReadFile(root.WithOpName(input_name), file_name);\n  // Now try to figure out what kind of file it is and decode it.\n  const int wanted_channels = 3;\n  tensorflow::Output image_reader;\n  if (tensorflow::StringPiece(file_name).ends_with(\".png\")) {\n    image_reader = DecodePng(root.WithOpName(\"png_reader\"), file_reader,\n                             DecodePng::Channels(wanted_channels));\n  } else if (tensorflow::StringPiece(file_name).ends_with(\".gif\")) {\n    image_reader = DecodeGif(root.WithOpName(\"gif_reader\"), file_reader);\n  } else {\n    // Assume if it's neither a PNG nor a GIF then it must be a JPEG.\n    image_reader = DecodeJpeg(root.WithOpName(\"jpeg_reader\"), file_reader,\n                              DecodeJpeg::Channels(wanted_channels));\n  }\n  // Now cast the image data to float so we can do normal math on it.\n  auto float_caster =\n      Cast(root.WithOpName(\"float_caster\"), image_reader, tensorflow::DT_FLOAT);\n  // The convention for image ops in TensorFlow is that all images are expected\n  // to be in batches, so that they're four-dimensional arrays with indices of\n  // [batch, height, width, channel]. Because we only have a single image, we\n  // have to add a batch dimension of 1 to the start with ExpandDims().\n  auto dims_expander = ExpandDims(root, float_caster, 0);\n  // Bilinearly resize the image to fit the required dimensions.\n  auto resized = ResizeBilinear(\n      root, dims_expander,\n      Const(root.WithOpName(\"size\"), {input_height, input_width}));\n  // Subtract the mean and divide by the scale.\n  Div(root.WithOpName(output_name), Sub(root, resized, {input_mean}),\n      {input_std});\n\n  // This runs the GraphDef network definition that we've just constructed, and\n  // returns the results in the output tensor.\n  tensorflow::GraphDef graph;\n  TF_RETURN_IF_ERROR(root.ToGraphDef(&amp;graph));\n\n  std::unique_ptr&lt;tensorflow::Session&gt; session(\n      tensorflow::NewSession(tensorflow::SessionOptions()));\n  TF_RETURN_IF_ERROR(session-&gt;Create(graph));\n  TF_RETURN_IF_ERROR(session-&gt;Run({}, {output_name}, {}, out_tensors));\n  return Status::OK();\n}\n</code></pre>", "body_text": "System information\n\nOS Platform and Distribution: Debian\nTensorFlow installed from (source or binary): source\nTensorFlow version (use command below): 1.0.1\nBazel version (if compiling from source): 0.4.5\nCUDA/cuDNN version: cuda-8.0, cudnn5.1.5\nGPU model and memory: 12GB\n\nI follow the tutorial of inception label_image,\nsource codes ,\nREADME.md , I can compile and run the demo c++ code successfully.\nI want to adapt this demo to my own project, the input images to my own Network is height fixed, while width varies accordingly, for example, the original image is size of 64x100, and I want to resize it to 32x50, as I said 32 is the new_height, and I want to know original image size after reading from the file, how can I get width=100 and height=64? then I can get new_width = new_height/height x width=32/64x100=50\nthe following is a small piece of the image_recognition tutorial C++ codes, resize is hard coded to a pre-define size, I try float_caster.shape(), tensor(), float_caster.dimension(0), etc, all failed(float_caster, file_reader are all not Tensor, I don't know why Google design like this, really slow down the development, and I find no documentation about this), is there any easy way to get the image size? or cast the tensorflow::Ouput type to Tensor?\none possible way is first use opencv to load the image, and resize it, then copy the elements to tensor like this example pixel by pixel, but the performance is the main problem and it seems hard to compile tensorflow along with opencv.  Any one knows some methods using tensorflow's API?\nThanks in advance!\n\n// Given an image file name, read in the data, try to decode it as an image,\n// resize it to the requested size, and then scale the values as desired.\nStatus ReadTensorFromImageFile(string file_name, const int input_height,\n                               const int input_width, const float input_mean,\n                               const float input_std,\n                               std::vector<Tensor>* out_tensors) {\n  auto root = tensorflow::Scope::NewRootScope();\n  using namespace ::tensorflow::ops;  // NOLINT(build/namespaces)\n\n  string input_name = \"file_reader\";\n  string output_name = \"normalized\";\n  auto file_reader =\n      tensorflow::ops::ReadFile(root.WithOpName(input_name), file_name);\n  // Now try to figure out what kind of file it is and decode it.\n  const int wanted_channels = 3;\n  tensorflow::Output image_reader;\n  if (tensorflow::StringPiece(file_name).ends_with(\".png\")) {\n    image_reader = DecodePng(root.WithOpName(\"png_reader\"), file_reader,\n                             DecodePng::Channels(wanted_channels));\n  } else if (tensorflow::StringPiece(file_name).ends_with(\".gif\")) {\n    image_reader = DecodeGif(root.WithOpName(\"gif_reader\"), file_reader);\n  } else {\n    // Assume if it's neither a PNG nor a GIF then it must be a JPEG.\n    image_reader = DecodeJpeg(root.WithOpName(\"jpeg_reader\"), file_reader,\n                              DecodeJpeg::Channels(wanted_channels));\n  }\n  // Now cast the image data to float so we can do normal math on it.\n  auto float_caster =\n      Cast(root.WithOpName(\"float_caster\"), image_reader, tensorflow::DT_FLOAT);\n  // The convention for image ops in TensorFlow is that all images are expected\n  // to be in batches, so that they're four-dimensional arrays with indices of\n  // [batch, height, width, channel]. Because we only have a single image, we\n  // have to add a batch dimension of 1 to the start with ExpandDims().\n  auto dims_expander = ExpandDims(root, float_caster, 0);\n  // Bilinearly resize the image to fit the required dimensions.\n  auto resized = ResizeBilinear(\n      root, dims_expander,\n      Const(root.WithOpName(\"size\"), {input_height, input_width}));\n  // Subtract the mean and divide by the scale.\n  Div(root.WithOpName(output_name), Sub(root, resized, {input_mean}),\n      {input_std});\n\n  // This runs the GraphDef network definition that we've just constructed, and\n  // returns the results in the output tensor.\n  tensorflow::GraphDef graph;\n  TF_RETURN_IF_ERROR(root.ToGraphDef(&graph));\n\n  std::unique_ptr<tensorflow::Session> session(\n      tensorflow::NewSession(tensorflow::SessionOptions()));\n  TF_RETURN_IF_ERROR(session->Create(graph));\n  TF_RETURN_IF_ERROR(session->Run({}, {output_name}, {}, out_tensors));\n  return Status::OK();\n}", "body": "### System information\r\n- **OS Platform and Distribution**: Debian\r\n- **TensorFlow installed from (source or binary)**: source\r\n- **TensorFlow version (use command below)**: 1.0.1\r\n- **Bazel version (if compiling from source)**: 0.4.5\r\n- **CUDA/cuDNN version**: cuda-8.0, cudnn5.1.5\r\n- **GPU model and memory**: 12GB\r\n\r\nI follow the tutorial of [inception label_image](https://www.tensorflow.org/tutorials/image_recognition),  \r\n[source codes](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/examples/label_image/main.cc) , \r\n[README.md](https://github.com/tensorflow/tensorflow/tree/master/tensorflow/examples/label_image) , I can compile and run the demo c++ code successfully.\r\n\r\nI want to adapt this demo to my own project, the input images to my own Network is height fixed, while width varies accordingly, for example, the original image is size of 64x100, and I want to resize it to 32x50, as I said 32 is the new_height, and I want to know original image size after reading from the file, how can I get width=100 and height=64? then I can get new_width = new_height/height x width=32/64x100=50\r\n\r\nthe following is a small piece of the image_recognition tutorial C++ codes, resize is hard coded to a pre-define size, I try `float_caster.shape()`, `tensor()`, `float_caster.dimension(0)`, etc, all failed(`float_caster`, `file_reader` are all not `Tensor`, I don't know why Google design like this, really slow down the development, and I find no documentation about this), is there any easy way to get the image size? or cast the `tensorflow::Ouput` type to `Tensor`?\r\n\r\none possible way is first use opencv to load the image, and resize it, then copy the elements to tensor like this [example](https://gist.github.com/kyrs/9adf86366e9e4f04addb) **pixel by pixel**, but the performance is the main problem and it seems hard to compile tensorflow along with opencv.  Any one knows some methods using tensorflow's API?\r\n\r\nThanks in advance!\r\n\r\n```\r\n\r\n// Given an image file name, read in the data, try to decode it as an image,\r\n// resize it to the requested size, and then scale the values as desired.\r\nStatus ReadTensorFromImageFile(string file_name, const int input_height,\r\n                               const int input_width, const float input_mean,\r\n                               const float input_std,\r\n                               std::vector<Tensor>* out_tensors) {\r\n  auto root = tensorflow::Scope::NewRootScope();\r\n  using namespace ::tensorflow::ops;  // NOLINT(build/namespaces)\r\n\r\n  string input_name = \"file_reader\";\r\n  string output_name = \"normalized\";\r\n  auto file_reader =\r\n      tensorflow::ops::ReadFile(root.WithOpName(input_name), file_name);\r\n  // Now try to figure out what kind of file it is and decode it.\r\n  const int wanted_channels = 3;\r\n  tensorflow::Output image_reader;\r\n  if (tensorflow::StringPiece(file_name).ends_with(\".png\")) {\r\n    image_reader = DecodePng(root.WithOpName(\"png_reader\"), file_reader,\r\n                             DecodePng::Channels(wanted_channels));\r\n  } else if (tensorflow::StringPiece(file_name).ends_with(\".gif\")) {\r\n    image_reader = DecodeGif(root.WithOpName(\"gif_reader\"), file_reader);\r\n  } else {\r\n    // Assume if it's neither a PNG nor a GIF then it must be a JPEG.\r\n    image_reader = DecodeJpeg(root.WithOpName(\"jpeg_reader\"), file_reader,\r\n                              DecodeJpeg::Channels(wanted_channels));\r\n  }\r\n  // Now cast the image data to float so we can do normal math on it.\r\n  auto float_caster =\r\n      Cast(root.WithOpName(\"float_caster\"), image_reader, tensorflow::DT_FLOAT);\r\n  // The convention for image ops in TensorFlow is that all images are expected\r\n  // to be in batches, so that they're four-dimensional arrays with indices of\r\n  // [batch, height, width, channel]. Because we only have a single image, we\r\n  // have to add a batch dimension of 1 to the start with ExpandDims().\r\n  auto dims_expander = ExpandDims(root, float_caster, 0);\r\n  // Bilinearly resize the image to fit the required dimensions.\r\n  auto resized = ResizeBilinear(\r\n      root, dims_expander,\r\n      Const(root.WithOpName(\"size\"), {input_height, input_width}));\r\n  // Subtract the mean and divide by the scale.\r\n  Div(root.WithOpName(output_name), Sub(root, resized, {input_mean}),\r\n      {input_std});\r\n\r\n  // This runs the GraphDef network definition that we've just constructed, and\r\n  // returns the results in the output tensor.\r\n  tensorflow::GraphDef graph;\r\n  TF_RETURN_IF_ERROR(root.ToGraphDef(&graph));\r\n\r\n  std::unique_ptr<tensorflow::Session> session(\r\n      tensorflow::NewSession(tensorflow::SessionOptions()));\r\n  TF_RETURN_IF_ERROR(session->Create(graph));\r\n  TF_RETURN_IF_ERROR(session->Run({}, {output_name}, {}, out_tensors));\r\n  return Status::OK();\r\n}\r\n```"}