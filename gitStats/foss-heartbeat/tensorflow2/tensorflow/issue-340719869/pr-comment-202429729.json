{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/202429729", "pull_request_review_id": 137134246, "id": 202429729, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjQyOTcyOQ==", "diff_hunk": "@@ -0,0 +1,459 @@\n+/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef TENSORFLOW_CORE_KERNELS_CROP_RESIZE_BILINEAR_CORE_H_\n+#define TENSORFLOW_CORE_KERNELS_CROP_RESIZE_BILINEAR_CORE_H_\n+\n+namespace tensorflow {\n+namespace {\n+// Compute the interpolation indices only once.\n+struct CachedInterpolation {\n+  int lower;  // Lower source index used in the interpolation\n+  int upper;  // Upper source index used in the interpolation\n+  // 1-D linear iterpolation scale (see:\n+  // https://en.wikipedia.org/wiki/Bilinear_interpolation)\n+  float lerp;\n+};\n+\n+inline bool compute_single_interpolation_weight(\n+    const int in_size, const float out2in_scale, const float out2in_start,\n+    const bool clip, const int i, int& lower, int& upper, float& lerp) {\n+  const float in = i * out2in_scale + out2in_start;\n+  lower = (int)floor(in);\n+  upper = (int)ceil(in);\n+  lerp = (float)(in - (float)lower);\n+  if (clip) {\n+    if (lower < 0)\n+      lower = 0;\n+    else if (lower >= in_size)\n+      lower = in_size - 1;\n+    if (upper < 0)\n+      upper = 0;\n+    else if (upper >= in_size)\n+      upper = in_size - 1;\n+    return true;\n+  } else {\n+    return (lower >= 0 && upper < in_size) ? true : false;\n+  }\n+}\n+/**\n+ * Compute interpolation values for output indexes in range\n+ * [out_start,out_start+out_size-1].\n+ * Returns true if all output indexes have lower and upper (input) indexes\n+ * within range [0,in_size-1].\n+ */\n+inline bool compute_interpolation_weights(const int min_i, const int max_i,\n+                                          const int in_size,\n+                                          const float out2in_scale,\n+                                          const float out2in_start,\n+                                          const bool clip,\n+                                          CachedInterpolation* interpolation) {\n+  bool rval = true;\n+  int num_i = max_i - min_i + 1;\n+  for (int i = 0; i < num_i; ++i) {\n+    if (!compute_single_interpolation_weight(\n+            in_size, out2in_scale, out2in_start, clip, i + min_i,\n+            interpolation[i].lower, interpolation[i].upper,\n+            interpolation[i].lerp)) {\n+      rval = false;\n+    }\n+  }\n+  return rval;\n+}\n+/**\n+ * Compatibility method for resize_bilinear_op.cc\n+ */\n+inline void compute_interpolation_weights(const int out_size, const int in_size,\n+                                          const float out2in_scale,\n+                                          CachedInterpolation* interpolation) {\n+  interpolation[out_size].lower = 0;\n+  interpolation[out_size].upper = 0;\n+  const bool clip = true;\n+  if (!compute_interpolation_weights(0, out_size - 1, in_size, out2in_scale,\n+                                     0.0f, clip, interpolation)) {\n+    // Should never happen, check for it anyway\n+    printf(\n+        \"Warning! Interpolation values have lower,upper indexes outside of \"\n+        \"range [0,in_size-1]\\n\");\n+  }\n+}\n+/**\n+ * Compute minimum and maximum (output) i where both lower and upper (input) is\n+ * in range [0,in_size-1]\n+ * If no values of i satisfy condition, min_i = in_size, max_i = -1 and method\n+ * returns false.\n+ * Returns true if min_i >= max_i.\n+ */\n+inline bool compute_minmax_indexes(const int out_size, const int in_size,\n+                                   const float out2in_scale,\n+                                   const float out2in_start, int& min_i,\n+                                   int& max_i) {\n+  min_i = out_size;\n+  max_i = -1;\n+  int lower, upper;\n+  float lerp;\n+  for (int i = 0; i < out_size; ++i) {\n+    if (compute_single_interpolation_weight(in_size, out2in_scale, out2in_start,\n+                                            false, i, lower, upper, lerp)) {\n+      if (i < min_i) min_i = i;\n+      if (i > max_i) max_i = i;\n+    }\n+  }\n+  return (min_i <= max_i) ? true : false;\n+}\n+/**\n+ * Compute interpolation weights for crop_and_resize_op.cc\n+ * Also computes extrapolation areas.\n+ * Returns true if at least one point requires interpolation, false otherwise.\n+ */\n+inline bool compute_interpolation_weights(\n+    const int out_size, const int in_size,\n+    const float x1,  // lower bounding box, crop region starts at in_size*x1\n+    const float x2,  // upper bounding box, crop region ends at in_size*x2\n+    int& min_i, int& max_i, CachedInterpolation*& interpolation) {\n+  float out2in_start = out_size > 1\n+                           ? (float)(in_size - 1) * (float)x1\n+                           : (float)(in_size - 1) * (float)(x1 + x2) / 2.0f;\n+  float out2in_scale =\n+      out_size > 1\n+          ? (float)(x2 - x1) * (float)(in_size - 1) / (float)(out_size - 1)\n+          : 0.0f;\n+  if (compute_minmax_indexes(out_size, in_size, out2in_scale, out2in_start,\n+                             min_i, max_i)) {\n+    interpolation = new CachedInterpolation[max_i - min_i + 1];\n+    bool all_inputs_ok =\n+        compute_interpolation_weights(min_i, max_i, in_size, out2in_scale,\n+                                      out2in_start, false, interpolation);\n+    if (!all_inputs_ok) {\n+      // should never happen, purpose of compute_minmax_indexes is to ensure\n+      // that all inputs are ok.\n+      printf(\n+          \"Error! compute_interpolation_weights returned input indexes outside \"\n+          \"valid range - SEGV will likely ensue.\\n\");\n+    }\n+    return true;\n+  } else {\n+    interpolation = 0l;\n+    return false;\n+  }\n+}\n+\n+template <typename U>\n+U cast_to(float v, float min_val, float max_val, U u_min_val, U u_max_val);\n+template <typename U>\n+inline U cast_to(float v, float min_val, float max_val, U u_min_val,\n+                 U u_max_val) {\n+  if (v < min_val)\n+    return u_min_val;\n+  else if (v > max_val)\n+    return u_max_val;\n+  else\n+    return static_cast<U>(v);\n+}\n+template <>\n+inline float cast_to<float>(float v, float min_val, float max_val,\n+                            float u_min_val, float u_max_val) {\n+  return v;\n+}\n+\n+inline float compute_lerp(const float top_left, const float top_right,\n+                          const float bottom_left, const float bottom_right,\n+                          const float x_lerp, const float y_lerp) {\n+  const float top = top_left + (top_right - top_left) * x_lerp;\n+  const float bottom = bottom_left + (bottom_right - bottom_left) * x_lerp;\n+  return top + (bottom - top) * y_lerp;\n+}\n+\n+/**\n+ * Computes the bilinear interpolation from the appropriate 4 float points\n+ * and the linear interpolation weights.\n+ * Accepts input tensors of type T and produces output tensors of type U.\n+ * Optionally flips horizontal and/or vertical axis.\n+ */\n+template <typename T, typename U>\n+void crop_resize_single_image(const T* image, const int64 in_height,\n+                              const int64 in_width, const int64 out_height,\n+                              const int64 out_width, const int channels,\n+                              const int min_ix, const int max_ix,\n+                              const CachedInterpolation* xs, const int min_iy,\n+                              const int max_iy, const CachedInterpolation* ys,\n+                              const float extrapolated_value, const bool flip_x,\n+                              const bool flip_y,\n+                              U* output) TF_ATTRIBUTE_NOINLINE;\n+template <typename T, typename U>\n+void crop_resize_single_image(const T* image, const int64 in_height,\n+                              const int64 in_width, const int64 out_height,\n+                              const int64 out_width, const int channels,\n+                              const int min_ix, const int max_ix,\n+                              const CachedInterpolation* xs, const int min_iy,\n+                              const int max_iy, const CachedInterpolation* ys,\n+                              const float extrapolated_value, const bool flip_x,\n+                              const bool flip_y, U* output) {\n+  const int64 in_row_size = in_width * channels;\n+  const int64 out_row_size = out_width * channels;\n+  U u_min_val = std::numeric_limits<U>::min();\n+  U u_max_val = std::numeric_limits<U>::max();\n+  float min_val = static_cast<float>(u_min_val);\n+  float max_val = static_cast<float>(u_max_val);\n+  U uEx =\n+      cast_to<U>(extrapolated_value, min_val, max_val, u_min_val, u_max_val);\n+  // low y extrapolation zone\n+  if (min_iy > 0) {\n+    U* p = flip_y ? output + out_row_size * (out_height - min_iy) : output;\n+    int64 nn = out_row_size * (int64)min_iy;\n+    for (int64 i = 0; i < nn; ++i) p[i] = uEx;\n+  }\n+  // high y extrapolation zone\n+  if (max_iy < out_height - 1) {\n+    U* p = flip_y ? output : output + out_row_size * (max_iy + 1);\n+    int64 nn = out_row_size * (int64)(out_height - 1 - max_iy);\n+    for (int64 i = 0; i < nn; ++i) p[i] = uEx;\n+  }\n+  // low x extrapolation zone\n+  if (min_ix > 0) {\n+    for (int iy = min_iy; iy <= max_iy; ++iy) {\n+      int xx0 = flip_x ? (out_width - min_ix) * channels : 0;\n+      int nxx = min_ix * channels;\n+      U* p = output + xx0 +\n+             out_row_size * (int64)(flip_y ? out_height - 1 - iy : iy);\n+      for (int ix = 0; ix < nxx; ++ix) {\n+        p[ix] = uEx;\n+      }\n+    }\n+  }\n+  // high x extrapolation zone\n+  if (max_ix < out_width - 1) {\n+    for (int iy = min_iy; iy <= max_iy; ++iy) {\n+      int xx0 = flip_x ? 0 : (max_ix + 1) * channels;\n+      int nxx = (out_width - 1 - max_ix) * channels;\n+      U* p = output + xx0 +\n+             out_row_size * (int64)(flip_y ? out_height - 1 - iy : iy);\n+      for (int ix = 0; ix < nxx; ++ix) {\n+        p[ix] = uEx;\n+      }\n+    }\n+  }\n+  U* output_y_ptr =\n+      output +\n+      out_row_size * (int64)(flip_y ? out_height - 1 - min_iy : min_iy);\n+  // interpolation zone\n+  if (channels == 1) {\n+    for (int y = min_iy; y <= max_iy; ++y) {\n+      const int iy = y - min_iy;\n+      const T* ys_input_lower_ptr = image + ys[iy].lower * in_row_size;\n+      const T* ys_input_upper_ptr = image + ys[iy].upper * in_row_size;\n+      const float ys_lerp = ys[iy].lerp;\n+      const int x0 = flip_x ? out_width - 1 - max_ix : min_ix;\n+      const int x1 = flip_x ? out_width - 1 - min_ix : max_ix;\n+      for (int x = x0; x <= x1; ++x) {\n+        const int ix = flip_x ? out_width - 1 - min_ix - x : x - min_ix;\n+        const int64 xs_lower = xs[ix].lower;\n+        const int64 xs_upper = xs[ix].upper;\n+        const float xs_lerp = xs[ix].lerp;\n+\n+        // Read channel 0.\n+        const float top_left0(ys_input_lower_ptr[xs_lower]);\n+        const float top_right0(ys_input_lower_ptr[xs_upper]);\n+        const float bottom_left0(ys_input_upper_ptr[xs_lower]);\n+        const float bottom_right0(ys_input_upper_ptr[xs_upper]);\n+\n+        // Compute output.\n+        float result0 = compute_lerp(top_left0, top_right0, bottom_left0,\n+                                     bottom_right0, xs_lerp, ys_lerp);\n+        output_y_ptr[x] =\n+            cast_to<U>(result0, min_val, max_val, u_min_val, u_max_val);\n+      }\n+      output_y_ptr =\n+          flip_y ? output_y_ptr - out_row_size : output_y_ptr + out_row_size;\n+    }\n+  } else if (channels == 2) {\n+    for (int y = min_iy; y <= max_iy; ++y) {\n+      const int iy = y - min_iy;\n+      const T* ys_input_lower_ptr = image + ys[iy].lower * in_row_size;\n+      const T* ys_input_upper_ptr = image + ys[iy].upper * in_row_size;\n+      const float ys_lerp = ys[iy].lerp;\n+      const int x0 = flip_x ? out_width - 1 - max_ix : min_ix;\n+      const int x1 = flip_x ? out_width - 1 - min_ix : max_ix;\n+      for (int x = x0; x <= x1; ++x) {\n+        const int ix = flip_x ? out_width - 1 - min_ix - x : x - min_ix;\n+        const int64 xs_lower = xs[ix].lower;\n+        const int64 xs_upper = xs[ix].upper;\n+        const float xs_lerp = xs[ix].lerp;\n+\n+        // Read channel 0.\n+        const float top_left0(ys_input_lower_ptr[xs_lower + 0]);\n+        const float top_right0(ys_input_lower_ptr[xs_upper + 0]);\n+        const float bottom_left0(ys_input_upper_ptr[xs_lower + 0]);\n+        const float bottom_right0(ys_input_upper_ptr[xs_upper + 0]);\n+\n+        // Read channel 1.\n+        const float top_left1(ys_input_lower_ptr[xs_lower + 1]);\n+        const float top_right1(ys_input_lower_ptr[xs_upper + 1]);\n+        const float bottom_left1(ys_input_upper_ptr[xs_lower + 1]);\n+        const float bottom_right1(ys_input_upper_ptr[xs_upper + 1]);\n+\n+        // Compute output.\n+        float result0 = compute_lerp(top_left0, top_right0, bottom_left0,\n+                                     bottom_right0, xs_lerp, ys_lerp);\n+        float result1 = compute_lerp(top_left1, top_right1, bottom_left1,\n+                                     bottom_right1, xs_lerp, ys_lerp);\n+        output_y_ptr[x * 2 + 0] =\n+            cast_to<U>(result0, min_val, max_val, u_min_val, u_max_val);\n+        output_y_ptr[x * 2 + 1] =\n+            cast_to<U>(result1, min_val, max_val, u_min_val, u_max_val);\n+      }\n+      output_y_ptr =\n+          flip_y ? output_y_ptr - out_row_size : output_y_ptr + out_row_size;\n+    }\n+  } else if (channels == 3) {\n+    for (int y = min_iy; y <= max_iy; ++y) {\n+      const int iy = y - min_iy;\n+      const T* ys_input_lower_ptr = image + ys[iy].lower * in_row_size;\n+      const T* ys_input_upper_ptr = image + ys[iy].upper * in_row_size;\n+      const float ys_lerp = ys[iy].lerp;\n+      const int x0 = flip_x ? out_width - 1 - max_ix : min_ix;\n+      const int x1 = flip_x ? out_width - 1 - min_ix : max_ix;\n+      for (int x = x0; x <= x1; ++x) {\n+        const int ix = flip_x ? out_width - 1 - min_ix - x : x - min_ix;\n+        const int64 xs_lower = xs[ix].lower;\n+        const int64 xs_upper = xs[ix].upper;\n+        const float xs_lerp = xs[ix].lerp;\n+\n+        // Read channel 0.\n+        const float top_left0(ys_input_lower_ptr[xs_lower + 0]);\n+        const float top_right0(ys_input_lower_ptr[xs_upper + 0]);\n+        const float bottom_left0(ys_input_upper_ptr[xs_lower + 0]);\n+        const float bottom_right0(ys_input_upper_ptr[xs_upper + 0]);\n+\n+        // Read channel 1.\n+        const float top_left1(ys_input_lower_ptr[xs_lower + 1]);\n+        const float top_right1(ys_input_lower_ptr[xs_upper + 1]);\n+        const float bottom_left1(ys_input_upper_ptr[xs_lower + 1]);\n+        const float bottom_right1(ys_input_upper_ptr[xs_upper + 1]);\n+\n+        // Read channel 2.\n+        const float top_left2(ys_input_lower_ptr[xs_lower + 2]);\n+        const float top_right2(ys_input_lower_ptr[xs_upper + 2]);\n+        const float bottom_left2(ys_input_upper_ptr[xs_lower + 2]);\n+        const float bottom_right2(ys_input_upper_ptr[xs_upper + 2]);\n+\n+        // Compute output.\n+        float result0 = compute_lerp(top_left0, top_right0, bottom_left0,\n+                                     bottom_right0, xs_lerp, ys_lerp);\n+        float result1 = compute_lerp(top_left1, top_right1, bottom_left1,\n+                                     bottom_right1, xs_lerp, ys_lerp);\n+        float result2 = compute_lerp(top_left2, top_right2, bottom_left2,\n+                                     bottom_right2, xs_lerp, ys_lerp);\n+        output_y_ptr[x * 3 + 0] =\n+            cast_to<U>(result0, min_val, max_val, u_min_val, u_max_val);\n+        output_y_ptr[x * 3 + 1] =\n+            cast_to<U>(result1, min_val, max_val, u_min_val, u_max_val);\n+        output_y_ptr[x * 3 + 2] =\n+            cast_to<U>(result2, min_val, max_val, u_min_val, u_max_val);\n+      }\n+      output_y_ptr =\n+          flip_y ? output_y_ptr - out_row_size : output_y_ptr + out_row_size;\n+    }\n+  } else if (channels == 4) {\n+    for (int y = min_iy; y <= max_iy; ++y) {\n+      const int iy = y - min_iy;\n+      const T* ys_input_lower_ptr = image + ys[iy].lower * in_row_size;\n+      const T* ys_input_upper_ptr = image + ys[iy].upper * in_row_size;\n+      const float ys_lerp = ys[iy].lerp;\n+      const int x0 = flip_x ? out_width - 1 - max_ix : min_ix;\n+      const int x1 = flip_x ? out_width - 1 - min_ix : max_ix;\n+      for (int x = x0; x <= x1; ++x) {\n+        const int ix = flip_x ? out_width - 1 - min_ix - x : x - min_ix;\n+        const int64 xs_lower = xs[ix].lower;\n+        const int64 xs_upper = xs[ix].upper;\n+        const float xs_lerp = xs[ix].lerp;\n+\n+        // Read channel 0.\n+        const float top_left0(ys_input_lower_ptr[xs_lower + 0]);\n+        const float top_right0(ys_input_lower_ptr[xs_upper + 0]);\n+        const float bottom_left0(ys_input_upper_ptr[xs_lower + 0]);\n+        const float bottom_right0(ys_input_upper_ptr[xs_upper + 0]);\n+\n+        // Read channel 1.\n+        const float top_left1(ys_input_lower_ptr[xs_lower + 1]);\n+        const float top_right1(ys_input_lower_ptr[xs_upper + 1]);\n+        const float bottom_left1(ys_input_upper_ptr[xs_lower + 1]);\n+        const float bottom_right1(ys_input_upper_ptr[xs_upper + 1]);\n+\n+        // Read channel 2.\n+        const float top_left2(ys_input_lower_ptr[xs_lower + 2]);\n+        const float top_right2(ys_input_lower_ptr[xs_upper + 2]);\n+        const float bottom_left2(ys_input_upper_ptr[xs_lower + 2]);\n+        const float bottom_right2(ys_input_upper_ptr[xs_upper + 2]);\n+\n+        // Read channel 3.\n+        const float top_left3(ys_input_lower_ptr[xs_lower + 3]);\n+        const float top_right3(ys_input_lower_ptr[xs_upper + 3]);\n+        const float bottom_left3(ys_input_upper_ptr[xs_lower + 3]);\n+        const float bottom_right3(ys_input_upper_ptr[xs_upper + 3]);\n+\n+        // Compute output.\n+        float result0 = compute_lerp(top_left0, top_right0, bottom_left0,\n+                                     bottom_right0, xs_lerp, ys_lerp);\n+        float result1 = compute_lerp(top_left1, top_right1, bottom_left1,\n+                                     bottom_right1, xs_lerp, ys_lerp);\n+        float result2 = compute_lerp(top_left2, top_right2, bottom_left2,\n+                                     bottom_right2, xs_lerp, ys_lerp);\n+        float result3 = compute_lerp(top_left3, top_right3, bottom_left3,\n+                                     bottom_right3, xs_lerp, ys_lerp);\n+        output_y_ptr[x * 4 + 0] =\n+            cast_to<U>(result0, min_val, max_val, u_min_val, u_max_val);\n+        output_y_ptr[x * 4 + 1] =\n+            cast_to<U>(result1, min_val, max_val, u_min_val, u_max_val);\n+        output_y_ptr[x * 4 + 2] =\n+            cast_to<U>(result2, min_val, max_val, u_min_val, u_max_val);\n+        output_y_ptr[x * 4 + 3] =\n+            cast_to<U>(result3, min_val, max_val, u_min_val, u_max_val);\n+      }\n+      output_y_ptr =\n+          flip_y ? output_y_ptr - out_row_size : output_y_ptr + out_row_size;\n+    }\n+  } else {\n+    for (int y = min_iy; y <= max_iy; ++y) {\n+      const int iy = y - min_iy;\n+      const T* ys_input_lower_ptr = image + ys[iy].lower * in_row_size;\n+      const T* ys_input_upper_ptr = image + ys[iy].upper * in_row_size;\n+      const float ys_lerp = ys[iy].lerp;\n+      const int x0 = flip_x ? out_width - 1 - max_ix : min_ix;\n+      const int x1 = flip_x ? out_width - 1 - min_ix : max_ix;\n+      for (int x = x0; x <= x1; ++x) {\n+        const int ix = flip_x ? out_width - 1 - min_ix - x : x - min_ix;\n+        const int64 xs_lower = xs[ix].lower;\n+        const int64 xs_upper = xs[ix].upper;\n+        const float xs_lerp = xs[ix].lerp;\n+        for (int ichan = 0; ichan < channels; ++ichan) {\n+          const float top_left0(ys_input_lower_ptr[xs_lower + ichan]);\n+          const float top_right0(ys_input_lower_ptr[xs_upper + ichan]);\n+          const float bottom_left0(ys_input_upper_ptr[xs_lower + ichan]);\n+          const float bottom_right0(ys_input_upper_ptr[xs_upper + ichan]);\n+          float result0 = compute_lerp(top_left0, top_right0, bottom_left0,\n+                                       bottom_right0, xs_lerp, ys_lerp);\n+          output_y_ptr[x * channels + ichan] =\n+              cast_to<U>(result0, min_val, max_val, u_min_val, u_max_val);\n+        }\n+      }\n+      output_y_ptr =\n+          flip_y ? output_y_ptr - out_row_size : output_y_ptr + out_row_size;\n+    }\n+  }\n+}\n+}  // namespace\n+}  // namespace tensorflow\n+#endif", "path": "tensorflow/core/kernels/crop_resize_bilinear_core.h", "position": null, "original_position": 459, "commit_id": "053443589925adea4e24aeb589f668df5bbc823d", "original_commit_id": "6bcbaa5ce71804caeda56a0037cc1b3c6fa77009", "user": {"login": "alextp", "id": 5061, "node_id": "MDQ6VXNlcjUwNjE=", "avatar_url": "https://avatars0.githubusercontent.com/u/5061?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alextp", "html_url": "https://github.com/alextp", "followers_url": "https://api.github.com/users/alextp/followers", "following_url": "https://api.github.com/users/alextp/following{/other_user}", "gists_url": "https://api.github.com/users/alextp/gists{/gist_id}", "starred_url": "https://api.github.com/users/alextp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alextp/subscriptions", "organizations_url": "https://api.github.com/users/alextp/orgs", "repos_url": "https://api.github.com/users/alextp/repos", "events_url": "https://api.github.com/users/alextp/events{/privacy}", "received_events_url": "https://api.github.com/users/alextp/received_events", "type": "User", "site_admin": false}, "body": "Add a comment with what #if is ending here", "created_at": "2018-07-13T18:01:52Z", "updated_at": "2018-07-16T20:15:25Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/20746#discussion_r202429729", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/20746", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/202429729"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/20746#discussion_r202429729"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/20746"}}, "body_html": "<p>Add a comment with what #if is ending here</p>", "body_text": "Add a comment with what #if is ending here"}