{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/14732", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/14732/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/14732/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/14732/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/14732", "id": 275448748, "node_id": "MDU6SXNzdWUyNzU0NDg3NDg=", "number": 14732, "title": "Eager: Eager execution of tf.data pipelines", "user": {"login": "hsm207", "id": 2398765, "node_id": "MDQ6VXNlcjIzOTg3NjU=", "avatar_url": "https://avatars0.githubusercontent.com/u/2398765?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hsm207", "html_url": "https://github.com/hsm207", "followers_url": "https://api.github.com/users/hsm207/followers", "following_url": "https://api.github.com/users/hsm207/following{/other_user}", "gists_url": "https://api.github.com/users/hsm207/gists{/gist_id}", "starred_url": "https://api.github.com/users/hsm207/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hsm207/subscriptions", "organizations_url": "https://api.github.com/users/hsm207/orgs", "repos_url": "https://api.github.com/users/hsm207/repos", "events_url": "https://api.github.com/users/hsm207/events{/privacy}", "received_events_url": "https://api.github.com/users/hsm207/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 736653459, "node_id": "MDU6TGFiZWw3MzY2NTM0NTk=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/comp:eager", "name": "comp:eager", "color": "0052cc", "default": false}, {"id": 473173272, "node_id": "MDU6TGFiZWw0NzMxNzMyNzI=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:feature", "name": "type:feature", "color": "159b2e", "default": false}], "state": "closed", "locked": false, "assignee": {"login": "asimshankar", "id": 16018, "node_id": "MDQ6VXNlcjE2MDE4", "avatar_url": "https://avatars2.githubusercontent.com/u/16018?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asimshankar", "html_url": "https://github.com/asimshankar", "followers_url": "https://api.github.com/users/asimshankar/followers", "following_url": "https://api.github.com/users/asimshankar/following{/other_user}", "gists_url": "https://api.github.com/users/asimshankar/gists{/gist_id}", "starred_url": "https://api.github.com/users/asimshankar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asimshankar/subscriptions", "organizations_url": "https://api.github.com/users/asimshankar/orgs", "repos_url": "https://api.github.com/users/asimshankar/repos", "events_url": "https://api.github.com/users/asimshankar/events{/privacy}", "received_events_url": "https://api.github.com/users/asimshankar/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "asimshankar", "id": 16018, "node_id": "MDQ6VXNlcjE2MDE4", "avatar_url": "https://avatars2.githubusercontent.com/u/16018?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asimshankar", "html_url": "https://github.com/asimshankar", "followers_url": "https://api.github.com/users/asimshankar/followers", "following_url": "https://api.github.com/users/asimshankar/following{/other_user}", "gists_url": "https://api.github.com/users/asimshankar/gists{/gist_id}", "starred_url": "https://api.github.com/users/asimshankar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asimshankar/subscriptions", "organizations_url": "https://api.github.com/users/asimshankar/orgs", "repos_url": "https://api.github.com/users/asimshankar/repos", "events_url": "https://api.github.com/users/asimshankar/events{/privacy}", "received_events_url": "https://api.github.com/users/asimshankar/received_events", "type": "User", "site_admin": false}, {"login": "akshayka", "id": 1994308, "node_id": "MDQ6VXNlcjE5OTQzMDg=", "avatar_url": "https://avatars0.githubusercontent.com/u/1994308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/akshayka", "html_url": "https://github.com/akshayka", "followers_url": "https://api.github.com/users/akshayka/followers", "following_url": "https://api.github.com/users/akshayka/following{/other_user}", "gists_url": "https://api.github.com/users/akshayka/gists{/gist_id}", "starred_url": "https://api.github.com/users/akshayka/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/akshayka/subscriptions", "organizations_url": "https://api.github.com/users/akshayka/orgs", "repos_url": "https://api.github.com/users/akshayka/repos", "events_url": "https://api.github.com/users/akshayka/events{/privacy}", "received_events_url": "https://api.github.com/users/akshayka/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 13, "created_at": "2017-11-20T18:09:32Z", "updated_at": "2018-04-21T22:16:40Z", "closed_at": "2018-04-21T22:16:40Z", "author_association": "CONTRIBUTOR", "body_html": "<h1>System information</h1>\n<p>Tensorflow version:</p>\n<p>1.5.0-dev20171120</p>\n<p>Python version:</p>\n<p>python 3.6.3 |Anaconda, Inc.| (default, Nov  8 2017, 15:10:56) [MSC v.1900 64 bit (AMD64)]</p>\n<h1>Problem</h1>\n<p>When debugging, calling the <code>numpy()</code> method on a <code>Tensor</code> object results in <code>AttributeError: 'Tensor' object has no attribute 'numpy' </code> in certain situations.</p>\n<h1>Steps to reproduce</h1>\n<ol>\n<li>Put this code in a script:</li>\n</ol>\n<pre><code>import tensorflow as tf\nimport tensorflow.contrib.eager as tfe\nimport numpy as np\nimport tensorflow as tf\nfrom collections import defaultdict, Counter\n\ntfe.enable_eager_execution()\n\nclass_probs = dict(\n    a=0.15,\n    b=0.3,\n    c=0.8,\n    d=0.9,\n    e=0.2,\n    f=0.02\n)\nnum_classes = len(class_probs)\n\nclass_probs = {k: v / sum(class_probs.values()) for k, v in class_probs.items()}\nclass_mapping = {n: i for i, n in enumerate(class_probs.keys())}\n\nclass_names = list(class_probs.keys())\nclass_weights = list(class_probs.values())\nsampled_dataset = np.random.choice(class_names, size=1000, p=class_weights)\n\ndataset_data = defaultdict(list)\nfor i, d in enumerate(sampled_dataset):\n    dataset_data['class_name'].append(d)\n    dataset_data['class_id'].append(class_mapping[d])\n    dataset_data['data'].append(np.array([i]))\n    dataset_data['class_prob'].append(class_probs[d])\n\n    dataset_data['class_target_prob'].append(1 / num_classes)\n\nfor k, v in dataset_data.items():\n    dataset_data[k] = np.array(dataset_data[k])\n\nclass_counts = Counter(sampled_dataset)\n\noversampling_coef = 0.9\n\n\ndef oversample_classes(example):\n    \"\"\"\n    Returns the number of copies of given example\n    \"\"\"\n    class_prob = example['class_prob']\n    class_target_prob = example['class_target_prob']\n    prob_ratio = tf.cast(class_target_prob / class_prob, dtype=tf.float32)\n\n    prob_ratio = prob_ratio ** oversampling_coef\n\n    prob_ratio = tf.maximum(prob_ratio, 1)\n    # Breakpoint 1\n    repeat_count = tf.floor(prob_ratio)\n\n    repeat_residual = prob_ratio - repeat_count  # a number between 0-1\n    residual_acceptance = tf.less_equal(\n        tf.random_uniform([], dtype=tf.float32), repeat_residual\n    )\n\n    residual_acceptance = tf.cast(residual_acceptance, tf.int64)\n    repeat_count = tf.cast(repeat_count, dtype=tf.int64)\n\n    return repeat_count + residual_acceptance\n\n\ndataset = tf.data.Dataset.from_tensor_slices(dict(dataset_data))\n\ndataset = dataset.flat_map(\n    lambda x: tf.data.Dataset.from_tensors(x).repeat(oversample_classes(x))\n)\n\ni = tfe.Iterator(dataset)\nx = i.next()['class_id']\n\n# Breakpoint 2\nprint('end')\n</code></pre>\n<ol start=\"2\">\n<li>\n<p>Insert the breakpoints in the lines following the comments Breakpoint 1 and Breakpoint 2</p>\n</li>\n<li>\n<p>Debug the script</p>\n</li>\n<li>\n<p>When breakpoint 1 is reached, evaluate the following:<br>\n<code>prob_ratio.numpy()</code><br>\nThis will result in the attribute error message.</p>\n</li>\n<li>\n<p>When breakpoint 2 is reached, evaluate the following:<br>\n<code>x.numpy()</code><br>\nThis will not result in the attribute error message.</p>\n</li>\n</ol>", "body_text": "System information\nTensorflow version:\n1.5.0-dev20171120\nPython version:\npython 3.6.3 |Anaconda, Inc.| (default, Nov  8 2017, 15:10:56) [MSC v.1900 64 bit (AMD64)]\nProblem\nWhen debugging, calling the numpy() method on a Tensor object results in AttributeError: 'Tensor' object has no attribute 'numpy'  in certain situations.\nSteps to reproduce\n\nPut this code in a script:\n\nimport tensorflow as tf\nimport tensorflow.contrib.eager as tfe\nimport numpy as np\nimport tensorflow as tf\nfrom collections import defaultdict, Counter\n\ntfe.enable_eager_execution()\n\nclass_probs = dict(\n    a=0.15,\n    b=0.3,\n    c=0.8,\n    d=0.9,\n    e=0.2,\n    f=0.02\n)\nnum_classes = len(class_probs)\n\nclass_probs = {k: v / sum(class_probs.values()) for k, v in class_probs.items()}\nclass_mapping = {n: i for i, n in enumerate(class_probs.keys())}\n\nclass_names = list(class_probs.keys())\nclass_weights = list(class_probs.values())\nsampled_dataset = np.random.choice(class_names, size=1000, p=class_weights)\n\ndataset_data = defaultdict(list)\nfor i, d in enumerate(sampled_dataset):\n    dataset_data['class_name'].append(d)\n    dataset_data['class_id'].append(class_mapping[d])\n    dataset_data['data'].append(np.array([i]))\n    dataset_data['class_prob'].append(class_probs[d])\n\n    dataset_data['class_target_prob'].append(1 / num_classes)\n\nfor k, v in dataset_data.items():\n    dataset_data[k] = np.array(dataset_data[k])\n\nclass_counts = Counter(sampled_dataset)\n\noversampling_coef = 0.9\n\n\ndef oversample_classes(example):\n    \"\"\"\n    Returns the number of copies of given example\n    \"\"\"\n    class_prob = example['class_prob']\n    class_target_prob = example['class_target_prob']\n    prob_ratio = tf.cast(class_target_prob / class_prob, dtype=tf.float32)\n\n    prob_ratio = prob_ratio ** oversampling_coef\n\n    prob_ratio = tf.maximum(prob_ratio, 1)\n    # Breakpoint 1\n    repeat_count = tf.floor(prob_ratio)\n\n    repeat_residual = prob_ratio - repeat_count  # a number between 0-1\n    residual_acceptance = tf.less_equal(\n        tf.random_uniform([], dtype=tf.float32), repeat_residual\n    )\n\n    residual_acceptance = tf.cast(residual_acceptance, tf.int64)\n    repeat_count = tf.cast(repeat_count, dtype=tf.int64)\n\n    return repeat_count + residual_acceptance\n\n\ndataset = tf.data.Dataset.from_tensor_slices(dict(dataset_data))\n\ndataset = dataset.flat_map(\n    lambda x: tf.data.Dataset.from_tensors(x).repeat(oversample_classes(x))\n)\n\ni = tfe.Iterator(dataset)\nx = i.next()['class_id']\n\n# Breakpoint 2\nprint('end')\n\n\n\nInsert the breakpoints in the lines following the comments Breakpoint 1 and Breakpoint 2\n\n\nDebug the script\n\n\nWhen breakpoint 1 is reached, evaluate the following:\nprob_ratio.numpy()\nThis will result in the attribute error message.\n\n\nWhen breakpoint 2 is reached, evaluate the following:\nx.numpy()\nThis will not result in the attribute error message.", "body": "# System information\r\nTensorflow version:\r\n\r\n1.5.0-dev20171120\r\n\r\nPython version:\r\n\r\npython 3.6.3 |Anaconda, Inc.| (default, Nov  8 2017, 15:10:56) [MSC v.1900 64 bit (AMD64)]\r\n\r\n# Problem\r\n\r\nWhen debugging, calling the `numpy()` method on a `Tensor` object results in `AttributeError: 'Tensor' object has no attribute 'numpy' ` in certain situations.\r\n\r\n# Steps to reproduce\r\n\r\n1.  Put this code in a script:\r\n\r\n\r\n```\r\nimport tensorflow as tf\r\nimport tensorflow.contrib.eager as tfe\r\nimport numpy as np\r\nimport tensorflow as tf\r\nfrom collections import defaultdict, Counter\r\n\r\ntfe.enable_eager_execution()\r\n\r\nclass_probs = dict(\r\n    a=0.15,\r\n    b=0.3,\r\n    c=0.8,\r\n    d=0.9,\r\n    e=0.2,\r\n    f=0.02\r\n)\r\nnum_classes = len(class_probs)\r\n\r\nclass_probs = {k: v / sum(class_probs.values()) for k, v in class_probs.items()}\r\nclass_mapping = {n: i for i, n in enumerate(class_probs.keys())}\r\n\r\nclass_names = list(class_probs.keys())\r\nclass_weights = list(class_probs.values())\r\nsampled_dataset = np.random.choice(class_names, size=1000, p=class_weights)\r\n\r\ndataset_data = defaultdict(list)\r\nfor i, d in enumerate(sampled_dataset):\r\n    dataset_data['class_name'].append(d)\r\n    dataset_data['class_id'].append(class_mapping[d])\r\n    dataset_data['data'].append(np.array([i]))\r\n    dataset_data['class_prob'].append(class_probs[d])\r\n\r\n    dataset_data['class_target_prob'].append(1 / num_classes)\r\n\r\nfor k, v in dataset_data.items():\r\n    dataset_data[k] = np.array(dataset_data[k])\r\n\r\nclass_counts = Counter(sampled_dataset)\r\n\r\noversampling_coef = 0.9\r\n\r\n\r\ndef oversample_classes(example):\r\n    \"\"\"\r\n    Returns the number of copies of given example\r\n    \"\"\"\r\n    class_prob = example['class_prob']\r\n    class_target_prob = example['class_target_prob']\r\n    prob_ratio = tf.cast(class_target_prob / class_prob, dtype=tf.float32)\r\n\r\n    prob_ratio = prob_ratio ** oversampling_coef\r\n\r\n    prob_ratio = tf.maximum(prob_ratio, 1)\r\n    # Breakpoint 1\r\n    repeat_count = tf.floor(prob_ratio)\r\n\r\n    repeat_residual = prob_ratio - repeat_count  # a number between 0-1\r\n    residual_acceptance = tf.less_equal(\r\n        tf.random_uniform([], dtype=tf.float32), repeat_residual\r\n    )\r\n\r\n    residual_acceptance = tf.cast(residual_acceptance, tf.int64)\r\n    repeat_count = tf.cast(repeat_count, dtype=tf.int64)\r\n\r\n    return repeat_count + residual_acceptance\r\n\r\n\r\ndataset = tf.data.Dataset.from_tensor_slices(dict(dataset_data))\r\n\r\ndataset = dataset.flat_map(\r\n    lambda x: tf.data.Dataset.from_tensors(x).repeat(oversample_classes(x))\r\n)\r\n\r\ni = tfe.Iterator(dataset)\r\nx = i.next()['class_id']\r\n\r\n# Breakpoint 2\r\nprint('end')\r\n```\r\n\r\n2. Insert the breakpoints in the lines following the comments Breakpoint 1 and Breakpoint 2\r\n\r\n3. Debug the script\r\n\r\n4. When breakpoint 1 is reached, evaluate the following:\r\n     `prob_ratio.numpy()`\r\n     This will result in the attribute error message.\r\n\r\n5. When breakpoint 2 is reached, evaluate the following:\r\n     `x.numpy()`\r\n     This will not result in the attribute error message."}