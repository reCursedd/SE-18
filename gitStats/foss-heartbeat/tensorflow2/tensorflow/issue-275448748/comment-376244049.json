{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/376244049", "html_url": "https://github.com/tensorflow/tensorflow/issues/14732#issuecomment-376244049", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/14732", "id": 376244049, "node_id": "MDEyOklzc3VlQ29tbWVudDM3NjI0NDA0OQ==", "user": {"login": "akshayka", "id": 1994308, "node_id": "MDQ6VXNlcjE5OTQzMDg=", "avatar_url": "https://avatars0.githubusercontent.com/u/1994308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/akshayka", "html_url": "https://github.com/akshayka", "followers_url": "https://api.github.com/users/akshayka/followers", "following_url": "https://api.github.com/users/akshayka/following{/other_user}", "gists_url": "https://api.github.com/users/akshayka/gists{/gist_id}", "starred_url": "https://api.github.com/users/akshayka/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/akshayka/subscriptions", "organizations_url": "https://api.github.com/users/akshayka/orgs", "repos_url": "https://api.github.com/users/akshayka/repos", "events_url": "https://api.github.com/users/akshayka/events{/privacy}", "received_events_url": "https://api.github.com/users/akshayka/received_events", "type": "User", "site_admin": false}, "created_at": "2018-03-26T17:20:49Z", "updated_at": "2018-03-26T17:20:49Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=2398765\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/hsm207\">@hsm207</a></p>\n<p>Here's the promised solution; by wrapping the logic of <code>oversample_classes</code> into a <code>tfe.py_func</code>, the below code ensures that the logic is always executed eagerly. Sorry for the delay!</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">def</span> <span class=\"pl-en\">oversample_classes</span>(<span class=\"pl-smi\">example</span>):\n    <span class=\"pl-s\"><span class=\"pl-pds\">\"\"\"</span></span>\n<span class=\"pl-s\">    Returns the number of copies of given example</span>\n<span class=\"pl-s\">    <span class=\"pl-pds\">\"\"\"</span></span>\n    class_prob <span class=\"pl-k\">=</span> example[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>class_prob<span class=\"pl-pds\">'</span></span>]\n    class_target_prob <span class=\"pl-k\">=</span> example[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>class_target_prob<span class=\"pl-pds\">'</span></span>]\n    <span class=\"pl-k\">def</span> <span class=\"pl-en\">oversample_logic</span>(<span class=\"pl-smi\">class_prob</span>, <span class=\"pl-smi\">class_target_prob</span>):\n      prob_ratio <span class=\"pl-k\">=</span> tf.cast(class_target_prob <span class=\"pl-k\">/</span> class_prob, <span class=\"pl-v\">dtype</span><span class=\"pl-k\">=</span>tf.float32)\n\n      prob_ratio <span class=\"pl-k\">=</span> prob_ratio <span class=\"pl-k\">**</span> oversampling_coef\n\n      prob_ratio <span class=\"pl-k\">=</span> tf.maximum(prob_ratio, <span class=\"pl-c1\">1</span>)\n      <span class=\"pl-c\"><span class=\"pl-c\">#</span> Breakpoint 1: You can verify that prob_ratio.numpy() returns a NumPy scalar.</span>\n      repeat_count <span class=\"pl-k\">=</span> tf.floor(prob_ratio) \n      repeat_residual <span class=\"pl-k\">=</span> prob_ratio <span class=\"pl-k\">-</span> repeat_count  <span class=\"pl-c\"><span class=\"pl-c\">#</span> a number between 0-1</span>\n      residual_acceptance <span class=\"pl-k\">=</span> tf.less_equal(\n          tf.random_uniform([], <span class=\"pl-v\">dtype</span><span class=\"pl-k\">=</span>tf.float32), repeat_residual\n      )\n\n      residual_acceptance <span class=\"pl-k\">=</span> tf.cast(residual_acceptance, tf.int64)\n      repeat_count <span class=\"pl-k\">=</span> tf.cast(repeat_count, <span class=\"pl-v\">dtype</span><span class=\"pl-k\">=</span>tf.int64)\n\n      <span class=\"pl-k\">return</span> repeat_count <span class=\"pl-k\">+</span> residual_acceptance\n    <span class=\"pl-k\">return</span> tfe.py_func(<span class=\"pl-v\">func</span><span class=\"pl-k\">=</span>oversample_logic,\n                       <span class=\"pl-v\">inp</span><span class=\"pl-k\">=</span>[class_prob, class_target_prob], <span class=\"pl-v\">Tout</span><span class=\"pl-k\">=</span>tf.int64)</pre></div>", "body_text": "@hsm207\nHere's the promised solution; by wrapping the logic of oversample_classes into a tfe.py_func, the below code ensures that the logic is always executed eagerly. Sorry for the delay!\ndef oversample_classes(example):\n    \"\"\"\n    Returns the number of copies of given example\n    \"\"\"\n    class_prob = example['class_prob']\n    class_target_prob = example['class_target_prob']\n    def oversample_logic(class_prob, class_target_prob):\n      prob_ratio = tf.cast(class_target_prob / class_prob, dtype=tf.float32)\n\n      prob_ratio = prob_ratio ** oversampling_coef\n\n      prob_ratio = tf.maximum(prob_ratio, 1)\n      # Breakpoint 1: You can verify that prob_ratio.numpy() returns a NumPy scalar.\n      repeat_count = tf.floor(prob_ratio) \n      repeat_residual = prob_ratio - repeat_count  # a number between 0-1\n      residual_acceptance = tf.less_equal(\n          tf.random_uniform([], dtype=tf.float32), repeat_residual\n      )\n\n      residual_acceptance = tf.cast(residual_acceptance, tf.int64)\n      repeat_count = tf.cast(repeat_count, dtype=tf.int64)\n\n      return repeat_count + residual_acceptance\n    return tfe.py_func(func=oversample_logic,\n                       inp=[class_prob, class_target_prob], Tout=tf.int64)", "body": "@hsm207 \r\n\r\nHere's the promised solution; by wrapping the logic of `oversample_classes` into a `tfe.py_func`, the below code ensures that the logic is always executed eagerly. Sorry for the delay!\r\n\r\n```python\r\ndef oversample_classes(example):\r\n    \"\"\"\r\n    Returns the number of copies of given example\r\n    \"\"\"\r\n    class_prob = example['class_prob']\r\n    class_target_prob = example['class_target_prob']\r\n    def oversample_logic(class_prob, class_target_prob):\r\n      prob_ratio = tf.cast(class_target_prob / class_prob, dtype=tf.float32)\r\n\r\n      prob_ratio = prob_ratio ** oversampling_coef\r\n\r\n      prob_ratio = tf.maximum(prob_ratio, 1)\r\n      # Breakpoint 1: You can verify that prob_ratio.numpy() returns a NumPy scalar.\r\n      repeat_count = tf.floor(prob_ratio) \r\n      repeat_residual = prob_ratio - repeat_count  # a number between 0-1\r\n      residual_acceptance = tf.less_equal(\r\n          tf.random_uniform([], dtype=tf.float32), repeat_residual\r\n      )\r\n\r\n      residual_acceptance = tf.cast(residual_acceptance, tf.int64)\r\n      repeat_count = tf.cast(repeat_count, dtype=tf.int64)\r\n\r\n      return repeat_count + residual_acceptance\r\n    return tfe.py_func(func=oversample_logic,\r\n                       inp=[class_prob, class_target_prob], Tout=tf.int64)\r\n```"}