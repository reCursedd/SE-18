{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/279787403", "html_url": "https://github.com/tensorflow/tensorflow/pull/7487#issuecomment-279787403", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/7487", "id": 279787403, "node_id": "MDEyOklzc3VlQ29tbWVudDI3OTc4NzQwMw==", "user": {"login": "drasmuss", "id": 1952220, "node_id": "MDQ6VXNlcjE5NTIyMjA=", "avatar_url": "https://avatars1.githubusercontent.com/u/1952220?v=4", "gravatar_id": "", "url": "https://api.github.com/users/drasmuss", "html_url": "https://github.com/drasmuss", "followers_url": "https://api.github.com/users/drasmuss/followers", "following_url": "https://api.github.com/users/drasmuss/following{/other_user}", "gists_url": "https://api.github.com/users/drasmuss/gists{/gist_id}", "starred_url": "https://api.github.com/users/drasmuss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/drasmuss/subscriptions", "organizations_url": "https://api.github.com/users/drasmuss/orgs", "repos_url": "https://api.github.com/users/drasmuss/repos", "events_url": "https://api.github.com/users/drasmuss/events{/privacy}", "received_events_url": "https://api.github.com/users/drasmuss/received_events", "type": "User", "site_admin": false}, "created_at": "2017-02-14T18:09:07Z", "updated_at": "2017-02-14T18:09:07Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Here's the quick script I put together to test things out, if you want to play with the numbers.  I didn't do any rigorous parameter sweeps.</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">import</span> time\n\n<span class=\"pl-k\">import</span> numpy <span class=\"pl-k\">as</span> np\n<span class=\"pl-k\">import</span> tensorflow <span class=\"pl-k\">as</span> tf\n\nstitch_size <span class=\"pl-k\">=</span> <span class=\"pl-c1\">1000</span>\nn_inputs <span class=\"pl-k\">=</span> <span class=\"pl-c1\">10</span>\ninput_shape <span class=\"pl-k\">=</span> (<span class=\"pl-c1\">100</span>, <span class=\"pl-c1\">50</span>, <span class=\"pl-c1\">50</span>)\nreps <span class=\"pl-k\">=</span> <span class=\"pl-c1\">10</span>\n\n<span class=\"pl-k\">with</span> tf.device(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>/cpu:0<span class=\"pl-pds\">\"</span></span>):\n    idxs <span class=\"pl-k\">=</span> [tf.constant(np.random.randint(stitch_size, <span class=\"pl-v\">size</span><span class=\"pl-k\">=</span>input_shape[<span class=\"pl-c1\">0</span>]))\n            <span class=\"pl-k\">for</span> _ <span class=\"pl-k\">in</span> <span class=\"pl-c1\">range</span>(n_inputs)]\n    vals <span class=\"pl-k\">=</span> [tf.constant(np.random.uniform(<span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">1</span>, <span class=\"pl-v\">size</span><span class=\"pl-k\">=</span>input_shape))\n            <span class=\"pl-k\">for</span> _ <span class=\"pl-k\">in</span> <span class=\"pl-c1\">range</span>(n_inputs)]\n    y <span class=\"pl-k\">=</span> tf.dynamic_stitch(idxs, vals)\n    grad <span class=\"pl-k\">=</span> tf.gradients(y, vals)\n\ntotal_time <span class=\"pl-k\">=</span> <span class=\"pl-c1\">0.0</span>\n<span class=\"pl-k\">for</span> _ <span class=\"pl-k\">in</span> <span class=\"pl-c1\">range</span>(reps):\n    <span class=\"pl-k\">with</span> tf.Session() <span class=\"pl-k\">as</span> sess:\n        start <span class=\"pl-k\">=</span> time.time()\n        sess.run(grad)\n        total_time <span class=\"pl-k\">+=</span> time.time() <span class=\"pl-k\">-</span> start\n\n<span class=\"pl-c1\">print</span>(total_time <span class=\"pl-k\">/</span> reps)</pre></div>\n<p>on my computer this gives</p>\n<pre><code>baseline: 0.17385516166687012\nimplementation 1: 0.45461173057556153\nimplementation 2: 0.3225952863693237\nimplementation 3: 0.4177032709121704\n</code></pre>", "body_text": "Here's the quick script I put together to test things out, if you want to play with the numbers.  I didn't do any rigorous parameter sweeps.\nimport time\n\nimport numpy as np\nimport tensorflow as tf\n\nstitch_size = 1000\nn_inputs = 10\ninput_shape = (100, 50, 50)\nreps = 10\n\nwith tf.device(\"/cpu:0\"):\n    idxs = [tf.constant(np.random.randint(stitch_size, size=input_shape[0]))\n            for _ in range(n_inputs)]\n    vals = [tf.constant(np.random.uniform(-1, 1, size=input_shape))\n            for _ in range(n_inputs)]\n    y = tf.dynamic_stitch(idxs, vals)\n    grad = tf.gradients(y, vals)\n\ntotal_time = 0.0\nfor _ in range(reps):\n    with tf.Session() as sess:\n        start = time.time()\n        sess.run(grad)\n        total_time += time.time() - start\n\nprint(total_time / reps)\non my computer this gives\nbaseline: 0.17385516166687012\nimplementation 1: 0.45461173057556153\nimplementation 2: 0.3225952863693237\nimplementation 3: 0.4177032709121704", "body": "Here's the quick script I put together to test things out, if you want to play with the numbers.  I didn't do any rigorous parameter sweeps.\r\n``` python\r\nimport time\r\n\r\nimport numpy as np\r\nimport tensorflow as tf\r\n\r\nstitch_size = 1000\r\nn_inputs = 10\r\ninput_shape = (100, 50, 50)\r\nreps = 10\r\n\r\nwith tf.device(\"/cpu:0\"):\r\n    idxs = [tf.constant(np.random.randint(stitch_size, size=input_shape[0]))\r\n            for _ in range(n_inputs)]\r\n    vals = [tf.constant(np.random.uniform(-1, 1, size=input_shape))\r\n            for _ in range(n_inputs)]\r\n    y = tf.dynamic_stitch(idxs, vals)\r\n    grad = tf.gradients(y, vals)\r\n\r\ntotal_time = 0.0\r\nfor _ in range(reps):\r\n    with tf.Session() as sess:\r\n        start = time.time()\r\n        sess.run(grad)\r\n        total_time += time.time() - start\r\n\r\nprint(total_time / reps)\r\n```\r\non my computer this gives\r\n```\r\nbaseline: 0.17385516166687012\r\nimplementation 1: 0.45461173057556153\r\nimplementation 2: 0.3225952863693237\r\nimplementation 3: 0.4177032709121704\r\n```"}