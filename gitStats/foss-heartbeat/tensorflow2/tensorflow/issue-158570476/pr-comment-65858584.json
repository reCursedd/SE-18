{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/65858584", "pull_request_review_id": null, "id": 65858584, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODU4NTg0", "diff_hunk": "@@ -0,0 +1,169 @@\n+#  Copyright 2015-present The Scikit Flow Authors. All Rights Reserved.\n+#\n+#  Licensed under the Apache License, Version 2.0 (the \"License\");\n+#  you may not use this file except in compliance with the License.\n+#  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+#  Unless required by applicable law or agreed to in writing, software\n+#  distributed under the License is distributed on an \"AS IS\" BASIS,\n+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+#  See the License for the specific language governing permissions and\n+#  limitations under the License.\n+import numpy as np\n+import pandas as pd\n+import tensorflow as tf\n+from tensorflow.python.framework import dtypes\n+from tensorflow.contrib import learn\n+from sklearn.metrics import mean_squared_error\n+\n+\n+LOG_DIR = './ops_logs'\n+TRAINING_STEPS = 10000\n+BATCH_SIZE = 10\n+PRINT_STEPS = TRAINING_STEPS / 1000\n+\n+\n+def sin_cos(x):\n+    return pd.DataFrame(dict(a=np.sin(x), b=np.cos(x)), index=x)\n+\n+\n+def rnn_data(data, time_steps, labels=False):\n+    \"\"\"\n+    creates new data frame based on previous observation\n+      * example:\n+        l = [1, 2, 3, 4, 5]\n+        time_steps = 2\n+        -> labels == False [[1, 2], [2, 3], [3, 4]]\n+        -> labels == True [2, 3, 4, 5]\n+    \"\"\"\n+    rnn_df = []\n+    for i in range(len(data) - time_steps):\n+        if labels:\n+            try:\n+                rnn_df.append(data.iloc[i + time_steps].as_matrix())\n+            except AttributeError:\n+                rnn_df.append(data.iloc[i + time_steps])\n+        else:\n+            data_ = data.iloc[i: i + time_steps].as_matrix()\n+            rnn_df.append(data_ if len(data_.shape) > 1 else [[i] for i in data_])\n+    return np.array(rnn_df)\n+\n+\n+def split_data(data, val_size=0.1, test_size=0.1):\n+    \"\"\"\n+    splits data to training, validation and testing parts\n+    \"\"\"\n+    ntest = int(round(len(data) * (1 - test_size)))\n+    nval = int(round(len(data.iloc[:ntest]) * (1 - val_size)))\n+\n+    df_train, df_val, df_test = data.iloc[:nval], data.iloc[nval:ntest], data.iloc[ntest:]\n+\n+    return df_train, df_val, df_test\n+\n+\n+def prepare_data(data, time_steps, labels=False, val_size=0.1, test_size=0.1):\n+    \"\"\"\n+    Given the number of `time_steps` and some data,\n+    prepares training, validation and test data for an lstm cell.\n+    \"\"\"\n+    df_train, df_val, df_test = split_data(data, val_size, test_size)\n+    return (rnn_data(df_train, time_steps, labels=labels),\n+            rnn_data(df_val, time_steps, labels=labels),\n+            rnn_data(df_test, time_steps, labels=labels))\n+\n+\n+def generate_data(fct, x, time_steps, seperate=False):\n+    \"\"\"generates data with based on a function fct\"\"\"\n+    data = fct(x)\n+    if not isinstance(data, pd.DataFrame):\n+        data = pd.DataFrame(data)\n+    train_x, val_x, test_x = prepare_data(data['a'] if seperate else data, time_steps)\n+    train_y, val_y, test_y = prepare_data(data['b'] if seperate else data, time_steps, labels=True)\n+    return dict(train=train_x, val=val_x, test=test_x), dict(train=train_y, val=val_y, test=test_y)\n+\n+\n+def lstm_model(time_steps, rnn_layers, dense_layers=None):\n+    \"\"\"\n+    Creates a deep model based on:\n+        * stacked lstm cells\n+        * an optional dense layers\n+    :param time_steps: the number of time steps the model will be looking at.\n+    :param rnn_layers: list of int or dict\n+                         * list of int: the steps used to instantiate the `BasicLSTMCell` cell\n+                         * list of dict: [{steps: int, keep_prob: int}, ...]\n+    :param dense_layers: list of nodes for each layer\n+    :return: the model definition\n+    \"\"\"\n+\n+    def lstm_cells(layers):\n+        if isinstance(layers[0], dict):\n+            return [tf.nn.rnn_cell.DropoutWrapper(tf.nn.rnn_cell.BasicLSTMCell(layer['steps'],\n+                                                                               state_is_tuple=True),\n+                                                  layer['keep_prob'])\n+                    if layer.get('keep_prob') else tf.nn.rnn_cell.BasicLSTMCell(layer['steps'],\n+                                                                                state_is_tuple=True)\n+                    for layer in layers]\n+        return [tf.nn.rnn_cell.BasicLSTMCell(steps, state_is_tuple=True) for steps in layers]\n+\n+    def dnn_layers(input_layers, layers):\n+        if layers and isinstance(layers, dict):\n+            return learn.ops.dnn(input_layers,\n+                                 layers['layers'],\n+                                 activation=layers.get('activation'),\n+                                 dropout=layers.get('dropout'))\n+        elif layers:\n+            return learn.ops.dnn(input_layers, layers)\n+        else:\n+            return input_layers\n+\n+    def _lstm_model(X, y):\n+        stacked_lstm = tf.nn.rnn_cell.MultiRNNCell(lstm_cells(rnn_layers), state_is_tuple=True)\n+        x_ = learn.ops.split_squeeze(1, time_steps, X)\n+        output, layers = tf.nn.rnn(stacked_lstm, x_, dtype=dtypes.float32)\n+        output = dnn_layers(output[-1], dense_layers)\n+        return learn.models.linear_regression(output, y)\n+\n+    return _lstm_model\n+\n+# predicting sin function\n+TIMESTEPS = 5\n+RNN_LAYERS = [{'steps': TIMESTEPS}, {'steps': TIMESTEPS, 'keep_prob': 0.5}]\n+DENSE_LAYERS = None\n+\n+regressor = learn.TensorFlowEstimator(model_fn=lstm_model(TIMESTEPS, RNN_LAYERS, DENSE_LAYERS),\n+                                      n_classes=0, verbose=1,\n+                                      steps=TRAINING_STEPS, optimizer='Adagrad',\n+                                      learning_rate=0.03, batch_size=BATCH_SIZE)\n+\n+X, y = generate_data(np.sin, np.linspace(0, 100, 10000), TIMESTEPS, seperate=False)\n+# create a lstm instance and validation monitor\n+validation_monitor = learn.monitors.ValidationMonitor(X['val'], y['val'],\n+                                                      every_n_steps=PRINT_STEPS,\n+                                                      early_stopping_rounds=1000)\n+regressor.fit(X['train'], y['train'], monitors=[validation_monitor], logdir=LOG_DIR+'1')\n+predicted = regressor.predict(X['test'])\n+score = mean_squared_error(predicted, y['test'])\n+print (\"MSE: %f\" % score)\n+\n+\n+# predicting cos-sin function\n+TIMESTEPS = 10\n+RNN_LAYERS = [{'steps': TIMESTEPS}, {'steps': TIMESTEPS, 'keep_prob': 0.5}]\n+DENSE_LAYERS = [2]\n+\n+regressor = learn.TensorFlowEstimator(model_fn=lstm_model(TIMESTEPS, RNN_LAYERS, DENSE_LAYERS),\n+                                      n_classes=0, verbose=1,\n+                                      steps=TRAINING_STEPS, optimizer='Adagrad',", "path": "tensorflow/examples/skflow/lstm_regression.py", "position": null, "original_position": 158, "commit_id": "c1b0ad805542026707452e88bcdecdb3c9e8e950", "original_commit_id": "8e118809acb8e8d530de46c35954eae55f32cb67", "user": {"login": "mouradmourafiq", "id": 1261626, "node_id": "MDQ6VXNlcjEyNjE2MjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/1261626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mouradmourafiq", "html_url": "https://github.com/mouradmourafiq", "followers_url": "https://api.github.com/users/mouradmourafiq/followers", "following_url": "https://api.github.com/users/mouradmourafiq/following{/other_user}", "gists_url": "https://api.github.com/users/mouradmourafiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/mouradmourafiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mouradmourafiq/subscriptions", "organizations_url": "https://api.github.com/users/mouradmourafiq/orgs", "repos_url": "https://api.github.com/users/mouradmourafiq/repos", "events_url": "https://api.github.com/users/mouradmourafiq/events{/privacy}", "received_events_url": "https://api.github.com/users/mouradmourafiq/received_events", "type": "User", "site_admin": false}, "body": "I moved both `steps` and `batch_size` to the `fit` function as suggested, although `TensorFlowEstimator` is not updated yet to accept `batch_size` as an arg.\n", "created_at": "2016-06-06T09:14:24Z", "updated_at": "2016-06-07T10:33:31Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/2674#discussion_r65858584", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/2674", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/65858584"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/2674#discussion_r65858584"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/2674"}}, "body_html": "<p>I moved both <code>steps</code> and <code>batch_size</code> to the <code>fit</code> function as suggested, although <code>TensorFlowEstimator</code> is not updated yet to accept <code>batch_size</code> as an arg.</p>", "body_text": "I moved both steps and batch_size to the fit function as suggested, although TensorFlowEstimator is not updated yet to accept batch_size as an arg."}