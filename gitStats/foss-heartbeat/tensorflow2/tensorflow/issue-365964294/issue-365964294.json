{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/22670", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/22670/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/22670/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/22670/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/22670", "id": 365964294, "node_id": "MDU6SXNzdWUzNjU5NjQyOTQ=", "number": 22670, "title": "C API: TF_SessionRun with multiple inputs gives Segmentation Fault ", "user": {"login": "EnricoGiordano1992", "id": 3462634, "node_id": "MDQ6VXNlcjM0NjI2MzQ=", "avatar_url": "https://avatars3.githubusercontent.com/u/3462634?v=4", "gravatar_id": "", "url": "https://api.github.com/users/EnricoGiordano1992", "html_url": "https://github.com/EnricoGiordano1992", "followers_url": "https://api.github.com/users/EnricoGiordano1992/followers", "following_url": "https://api.github.com/users/EnricoGiordano1992/following{/other_user}", "gists_url": "https://api.github.com/users/EnricoGiordano1992/gists{/gist_id}", "starred_url": "https://api.github.com/users/EnricoGiordano1992/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/EnricoGiordano1992/subscriptions", "organizations_url": "https://api.github.com/users/EnricoGiordano1992/orgs", "repos_url": "https://api.github.com/users/EnricoGiordano1992/repos", "events_url": "https://api.github.com/users/EnricoGiordano1992/events{/privacy}", "received_events_url": "https://api.github.com/users/EnricoGiordano1992/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2018-10-02T15:51:14Z", "updated_at": "2018-10-03T21:29:02Z", "closed_at": "2018-10-03T01:20:25Z", "author_association": "NONE", "body_html": "<h3>System information</h3>\n<ul>\n<li><strong>Have I written custom code (as opposed to using a stock example script provided in TensorFlow)</strong>: yes</li>\n<li><strong>OS Platform and Distribution (e.g., Linux Ubuntu 16.04)</strong>: Linux Ubuntu 18.04</li>\n<li><strong>Mobile device (e.g. iPhone 8, Pixel 2, Samsung Galaxy) if the issue happens on mobile device</strong>: no</li>\n<li><strong>TensorFlow installed from (source or binary)</strong>: source</li>\n<li><strong>TensorFlow version (use command below)</strong>: 1.10</li>\n<li><strong>Python version</strong>: 3.6</li>\n<li><strong>Bazel version (if compiling from source)</strong>: 0.16.1</li>\n<li><strong>GCC/Compiler version (if compiling from source)</strong>: 7.3.0</li>\n<li><strong>CUDA/cuDNN version</strong>: 9.2 / 7.3</li>\n<li><strong>GPU model and memory</strong>: NVidia GTX 1070ti</li>\n<li><strong>Exact command to reproduce</strong>: compile and execute my program</li>\n</ul>\n<h3>Describe the problem</h3>\n<p>In C API, I'm using TF_SessionRun to execute inference. I don't understand why I get Segmentation Fault when I pass to TF_SessionRun multiple input tensor, but when I pass only 1 input tensor I get no errors. I see that the signature of the function is:</p>\n<pre><code>TF_CAPI_EXPORT extern void TF_SessionRun(\n    TF_Session* session,\n    // RunOptions\n    const TF_Buffer* run_options,\n    // Input tensors\n    const TF_Output* inputs, TF_Tensor* const* input_values, int ninputs,\n    // Output tensors\n    const TF_Output* outputs, TF_Tensor** output_values, int noutputs,\n    // Target operations\n    const TF_Operation* const* target_opers, int ntargets,\n    // RunMetadata\n    TF_Buffer* run_metadata,\n    // Output status\n    TF_Status*);\n</code></pre>\n<p>It seems that, with TF_Tensor* const* input_values, I can send more that once input tensor. For passing more that once input tensor, I've created a std::vector of Tensor *, in fact I haven't any errors in compilation. My code below. My graph have this shape: ? x 50 x 50 x 3 for input, ? x 2 for output (like VGG16, you can use VGG16 for tests)</p>\n<h3>Source code / logs</h3>\n<pre><code>#include \"tensorflow/c/c_api.h\"\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;memory.h&gt;\n#include &lt;string.h&gt;\n#include &lt;assert.h&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;iterator&gt;\n#include &lt;iostream&gt;\n\n\nTF_Buffer* read_file(const char* file);\n\nvoid free_buffer(void* data, size_t length) {\n}\n\nstatic void Deallocator(void* data, size_t length, void* arg) {\n}\n\nint main() {\n  TF_Buffer* graph_def = read_file(\"data/graph.pb\");\n  TF_Graph* graph = TF_NewGraph();\n\n  TF_Status* status = TF_NewStatus();\n  TF_ImportGraphDefOptions* graph_opts = TF_NewImportGraphDefOptions();\n  TF_GraphImportGraphDef(graph, graph_def, graph_opts, status);\n  if (TF_GetCode(status) != TF_OK) {\n          fprintf(stderr, \"ERROR: Unable to import graph %s\", TF_Message(status));\n          return 1;\n  }\n  else {\n          fprintf(stdout, \"Successfully imported graph\\n\");\n  }\n  const int num_bytes_in = 1 * 50 * 50 * 3 * sizeof(float);\n  const int num_bytes_out = 1 * 2 * sizeof(float);\n\n  int64_t in_dims[] = {1, 50, 50, 3};\n  int64_t out_dims[] = {1, 2};\n\n  float values[1 * 50 * 50 * 3] = {0xff};\n\n  std::vector&lt;TF_Output&gt; inputs;\n  std::vector&lt;TF_Tensor*&gt; input_values;\n\n  inputs.push_back({TF_GraphOperationByName(graph, \"input_1\"), 0});\n  input_values.push_back(TF_NewTensor(TF_FLOAT, in_dims, 4, values, num_bytes_in, &amp;Deallocator, 0));\n  input_values.push_back(TF_NewTensor(TF_FLOAT, in_dims, 4, values, num_bytes_in, &amp;Deallocator, 0));\n\n  std::vector&lt;TF_Output&gt; outputs;\n  outputs.push_back({TF_GraphOperationByName(graph, \"dense_3/Softmax\"), 0});\n\n  std::vector&lt;TF_Tensor*&gt; output_values;\n\n  output_values.push_back(TF_AllocateTensor(TF_FLOAT, out_dims, 2, num_bytes_out));\n  output_values.push_back(TF_AllocateTensor(TF_FLOAT, out_dims, 2, num_bytes_out));\n\n  fprintf(stdout, \"Running session...\\n\");\n  TF_SessionOptions* sess_opts = TF_NewSessionOptions();\n  TF_Session* session = TF_NewSession(graph, sess_opts, status);\n  assert(TF_GetCode(status) == TF_OK);\n\n  TF_SessionRun(session, nullptr,\n                &amp;inputs[0], &amp;input_values[0], input_values.size(),\n                &amp;outputs[0], &amp;output_values[0], output_values.size(),\n                nullptr, 0, nullptr, status);\n\n  TF_Code c = TF_GetCode(status);\n\n  std::cout &lt;&lt; c &lt;&lt; std::endl;\n\n  for(size_t i = 0; i &lt; output_values.size(); ++i)\n  {\n      if (output_values.at(i) == nullptr)\n      {\n          std::cout &lt;&lt; \"bad parameters\" &lt;&lt; std::endl;\n      }\n      else\n      {\n          const auto data = static_cast&lt;float*&gt;(TF_TensorData(output_values.at(i)));\n          std::cout &lt;&lt; ((data[1] &gt; 0.5f) ? true : false) &lt;&lt; std::endl;\n      }\n  }\n\n  fprintf(stdout, \"Successfully run session\\n\");\n\n  TF_CloseSession(session, status);\n  TF_DeleteSession(session, status);\n  TF_DeleteSessionOptions(sess_opts);\n  TF_DeleteImportGraphDefOptions(graph_opts);\n  TF_DeleteGraph(graph);\n  TF_DeleteStatus(status);\n  return 0;\n}\n\nTF_Buffer* read_file(const char* file) {\n  FILE *f = fopen(file, \"rb\");\n  fseek(f, 0, SEEK_END);\n  long fsize = ftell(f);\n  fseek(f, 0, SEEK_SET);  //same as rewind(f);\n\n  void* data = malloc(fsize);\n  fread(data, fsize, 1, f);\n  fclose(f);\n\n  TF_Buffer* buf = TF_NewBuffer();\n  buf-&gt;data = data;\n  buf-&gt;length = fsize;\n  buf-&gt;data_deallocator = free_buffer;\n  return buf;\n}\n</code></pre>", "body_text": "System information\n\nHave I written custom code (as opposed to using a stock example script provided in TensorFlow): yes\nOS Platform and Distribution (e.g., Linux Ubuntu 16.04): Linux Ubuntu 18.04\nMobile device (e.g. iPhone 8, Pixel 2, Samsung Galaxy) if the issue happens on mobile device: no\nTensorFlow installed from (source or binary): source\nTensorFlow version (use command below): 1.10\nPython version: 3.6\nBazel version (if compiling from source): 0.16.1\nGCC/Compiler version (if compiling from source): 7.3.0\nCUDA/cuDNN version: 9.2 / 7.3\nGPU model and memory: NVidia GTX 1070ti\nExact command to reproduce: compile and execute my program\n\nDescribe the problem\nIn C API, I'm using TF_SessionRun to execute inference. I don't understand why I get Segmentation Fault when I pass to TF_SessionRun multiple input tensor, but when I pass only 1 input tensor I get no errors. I see that the signature of the function is:\nTF_CAPI_EXPORT extern void TF_SessionRun(\n    TF_Session* session,\n    // RunOptions\n    const TF_Buffer* run_options,\n    // Input tensors\n    const TF_Output* inputs, TF_Tensor* const* input_values, int ninputs,\n    // Output tensors\n    const TF_Output* outputs, TF_Tensor** output_values, int noutputs,\n    // Target operations\n    const TF_Operation* const* target_opers, int ntargets,\n    // RunMetadata\n    TF_Buffer* run_metadata,\n    // Output status\n    TF_Status*);\n\nIt seems that, with TF_Tensor* const* input_values, I can send more that once input tensor. For passing more that once input tensor, I've created a std::vector of Tensor *, in fact I haven't any errors in compilation. My code below. My graph have this shape: ? x 50 x 50 x 3 for input, ? x 2 for output (like VGG16, you can use VGG16 for tests)\nSource code / logs\n#include \"tensorflow/c/c_api.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <memory.h>\n#include <string.h>\n#include <assert.h>\n#include <vector>\n#include <algorithm>\n#include <iterator>\n#include <iostream>\n\n\nTF_Buffer* read_file(const char* file);\n\nvoid free_buffer(void* data, size_t length) {\n}\n\nstatic void Deallocator(void* data, size_t length, void* arg) {\n}\n\nint main() {\n  TF_Buffer* graph_def = read_file(\"data/graph.pb\");\n  TF_Graph* graph = TF_NewGraph();\n\n  TF_Status* status = TF_NewStatus();\n  TF_ImportGraphDefOptions* graph_opts = TF_NewImportGraphDefOptions();\n  TF_GraphImportGraphDef(graph, graph_def, graph_opts, status);\n  if (TF_GetCode(status) != TF_OK) {\n          fprintf(stderr, \"ERROR: Unable to import graph %s\", TF_Message(status));\n          return 1;\n  }\n  else {\n          fprintf(stdout, \"Successfully imported graph\\n\");\n  }\n  const int num_bytes_in = 1 * 50 * 50 * 3 * sizeof(float);\n  const int num_bytes_out = 1 * 2 * sizeof(float);\n\n  int64_t in_dims[] = {1, 50, 50, 3};\n  int64_t out_dims[] = {1, 2};\n\n  float values[1 * 50 * 50 * 3] = {0xff};\n\n  std::vector<TF_Output> inputs;\n  std::vector<TF_Tensor*> input_values;\n\n  inputs.push_back({TF_GraphOperationByName(graph, \"input_1\"), 0});\n  input_values.push_back(TF_NewTensor(TF_FLOAT, in_dims, 4, values, num_bytes_in, &Deallocator, 0));\n  input_values.push_back(TF_NewTensor(TF_FLOAT, in_dims, 4, values, num_bytes_in, &Deallocator, 0));\n\n  std::vector<TF_Output> outputs;\n  outputs.push_back({TF_GraphOperationByName(graph, \"dense_3/Softmax\"), 0});\n\n  std::vector<TF_Tensor*> output_values;\n\n  output_values.push_back(TF_AllocateTensor(TF_FLOAT, out_dims, 2, num_bytes_out));\n  output_values.push_back(TF_AllocateTensor(TF_FLOAT, out_dims, 2, num_bytes_out));\n\n  fprintf(stdout, \"Running session...\\n\");\n  TF_SessionOptions* sess_opts = TF_NewSessionOptions();\n  TF_Session* session = TF_NewSession(graph, sess_opts, status);\n  assert(TF_GetCode(status) == TF_OK);\n\n  TF_SessionRun(session, nullptr,\n                &inputs[0], &input_values[0], input_values.size(),\n                &outputs[0], &output_values[0], output_values.size(),\n                nullptr, 0, nullptr, status);\n\n  TF_Code c = TF_GetCode(status);\n\n  std::cout << c << std::endl;\n\n  for(size_t i = 0; i < output_values.size(); ++i)\n  {\n      if (output_values.at(i) == nullptr)\n      {\n          std::cout << \"bad parameters\" << std::endl;\n      }\n      else\n      {\n          const auto data = static_cast<float*>(TF_TensorData(output_values.at(i)));\n          std::cout << ((data[1] > 0.5f) ? true : false) << std::endl;\n      }\n  }\n\n  fprintf(stdout, \"Successfully run session\\n\");\n\n  TF_CloseSession(session, status);\n  TF_DeleteSession(session, status);\n  TF_DeleteSessionOptions(sess_opts);\n  TF_DeleteImportGraphDefOptions(graph_opts);\n  TF_DeleteGraph(graph);\n  TF_DeleteStatus(status);\n  return 0;\n}\n\nTF_Buffer* read_file(const char* file) {\n  FILE *f = fopen(file, \"rb\");\n  fseek(f, 0, SEEK_END);\n  long fsize = ftell(f);\n  fseek(f, 0, SEEK_SET);  //same as rewind(f);\n\n  void* data = malloc(fsize);\n  fread(data, fsize, 1, f);\n  fclose(f);\n\n  TF_Buffer* buf = TF_NewBuffer();\n  buf->data = data;\n  buf->length = fsize;\n  buf->data_deallocator = free_buffer;\n  return buf;\n}", "body": "### System information\r\n- **Have I written custom code (as opposed to using a stock example script provided in TensorFlow)**: yes\r\n- **OS Platform and Distribution (e.g., Linux Ubuntu 16.04)**: Linux Ubuntu 18.04\r\n- **Mobile device (e.g. iPhone 8, Pixel 2, Samsung Galaxy) if the issue happens on mobile device**: no\r\n- **TensorFlow installed from (source or binary)**: source\r\n- **TensorFlow version (use command below)**: 1.10\r\n- **Python version**: 3.6\r\n- **Bazel version (if compiling from source)**: 0.16.1\r\n- **GCC/Compiler version (if compiling from source)**: 7.3.0\r\n- **CUDA/cuDNN version**: 9.2 / 7.3\r\n- **GPU model and memory**: NVidia GTX 1070ti\r\n- **Exact command to reproduce**: compile and execute my program\r\n\r\n### Describe the problem\r\nIn C API, I'm using TF_SessionRun to execute inference. I don't understand why I get Segmentation Fault when I pass to TF_SessionRun multiple input tensor, but when I pass only 1 input tensor I get no errors. I see that the signature of the function is:\r\n```\r\nTF_CAPI_EXPORT extern void TF_SessionRun(\r\n    TF_Session* session,\r\n    // RunOptions\r\n    const TF_Buffer* run_options,\r\n    // Input tensors\r\n    const TF_Output* inputs, TF_Tensor* const* input_values, int ninputs,\r\n    // Output tensors\r\n    const TF_Output* outputs, TF_Tensor** output_values, int noutputs,\r\n    // Target operations\r\n    const TF_Operation* const* target_opers, int ntargets,\r\n    // RunMetadata\r\n    TF_Buffer* run_metadata,\r\n    // Output status\r\n    TF_Status*);\r\n```\r\nIt seems that, with TF_Tensor* const* input_values, I can send more that once input tensor. For passing more that once input tensor, I've created a std::vector of Tensor *, in fact I haven't any errors in compilation. My code below. My graph have this shape: ? x 50 x 50 x 3 for input, ? x 2 for output (like VGG16, you can use VGG16 for tests) \r\n\r\n### Source code / logs\r\n```\r\n#include \"tensorflow/c/c_api.h\"\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <memory.h>\r\n#include <string.h>\r\n#include <assert.h>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <iterator>\r\n#include <iostream>\r\n\r\n\r\nTF_Buffer* read_file(const char* file);\r\n\r\nvoid free_buffer(void* data, size_t length) {\r\n}\r\n\r\nstatic void Deallocator(void* data, size_t length, void* arg) {\r\n}\r\n\r\nint main() {\r\n  TF_Buffer* graph_def = read_file(\"data/graph.pb\");\r\n  TF_Graph* graph = TF_NewGraph();\r\n\r\n  TF_Status* status = TF_NewStatus();\r\n  TF_ImportGraphDefOptions* graph_opts = TF_NewImportGraphDefOptions();\r\n  TF_GraphImportGraphDef(graph, graph_def, graph_opts, status);\r\n  if (TF_GetCode(status) != TF_OK) {\r\n          fprintf(stderr, \"ERROR: Unable to import graph %s\", TF_Message(status));\r\n          return 1;\r\n  }\r\n  else {\r\n          fprintf(stdout, \"Successfully imported graph\\n\");\r\n  }\r\n  const int num_bytes_in = 1 * 50 * 50 * 3 * sizeof(float);\r\n  const int num_bytes_out = 1 * 2 * sizeof(float);\r\n\r\n  int64_t in_dims[] = {1, 50, 50, 3};\r\n  int64_t out_dims[] = {1, 2};\r\n\r\n  float values[1 * 50 * 50 * 3] = {0xff};\r\n\r\n  std::vector<TF_Output> inputs;\r\n  std::vector<TF_Tensor*> input_values;\r\n\r\n  inputs.push_back({TF_GraphOperationByName(graph, \"input_1\"), 0});\r\n  input_values.push_back(TF_NewTensor(TF_FLOAT, in_dims, 4, values, num_bytes_in, &Deallocator, 0));\r\n  input_values.push_back(TF_NewTensor(TF_FLOAT, in_dims, 4, values, num_bytes_in, &Deallocator, 0));\r\n\r\n  std::vector<TF_Output> outputs;\r\n  outputs.push_back({TF_GraphOperationByName(graph, \"dense_3/Softmax\"), 0});\r\n\r\n  std::vector<TF_Tensor*> output_values;\r\n\r\n  output_values.push_back(TF_AllocateTensor(TF_FLOAT, out_dims, 2, num_bytes_out));\r\n  output_values.push_back(TF_AllocateTensor(TF_FLOAT, out_dims, 2, num_bytes_out));\r\n\r\n  fprintf(stdout, \"Running session...\\n\");\r\n  TF_SessionOptions* sess_opts = TF_NewSessionOptions();\r\n  TF_Session* session = TF_NewSession(graph, sess_opts, status);\r\n  assert(TF_GetCode(status) == TF_OK);\r\n\r\n  TF_SessionRun(session, nullptr,\r\n                &inputs[0], &input_values[0], input_values.size(),\r\n                &outputs[0], &output_values[0], output_values.size(),\r\n                nullptr, 0, nullptr, status);\r\n\r\n  TF_Code c = TF_GetCode(status);\r\n\r\n  std::cout << c << std::endl;\r\n\r\n  for(size_t i = 0; i < output_values.size(); ++i)\r\n  {\r\n      if (output_values.at(i) == nullptr)\r\n      {\r\n          std::cout << \"bad parameters\" << std::endl;\r\n      }\r\n      else\r\n      {\r\n          const auto data = static_cast<float*>(TF_TensorData(output_values.at(i)));\r\n          std::cout << ((data[1] > 0.5f) ? true : false) << std::endl;\r\n      }\r\n  }\r\n\r\n  fprintf(stdout, \"Successfully run session\\n\");\r\n\r\n  TF_CloseSession(session, status);\r\n  TF_DeleteSession(session, status);\r\n  TF_DeleteSessionOptions(sess_opts);\r\n  TF_DeleteImportGraphDefOptions(graph_opts);\r\n  TF_DeleteGraph(graph);\r\n  TF_DeleteStatus(status);\r\n  return 0;\r\n}\r\n\r\nTF_Buffer* read_file(const char* file) {\r\n  FILE *f = fopen(file, \"rb\");\r\n  fseek(f, 0, SEEK_END);\r\n  long fsize = ftell(f);\r\n  fseek(f, 0, SEEK_SET);  //same as rewind(f);\r\n\r\n  void* data = malloc(fsize);\r\n  fread(data, fsize, 1, f);\r\n  fclose(f);\r\n\r\n  TF_Buffer* buf = TF_NewBuffer();\r\n  buf->data = data;\r\n  buf->length = fsize;\r\n  buf->data_deallocator = free_buffer;\r\n  return buf;\r\n}\r\n```\r\n"}