{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/302413537", "html_url": "https://github.com/tensorflow/tensorflow/issues/9742#issuecomment-302413537", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9742", "id": 302413537, "node_id": "MDEyOklzc3VlQ29tbWVudDMwMjQxMzUzNw==", "user": {"login": "yaroslavvb", "id": 23068, "node_id": "MDQ6VXNlcjIzMDY4", "avatar_url": "https://avatars3.githubusercontent.com/u/23068?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yaroslavvb", "html_url": "https://github.com/yaroslavvb", "followers_url": "https://api.github.com/users/yaroslavvb/followers", "following_url": "https://api.github.com/users/yaroslavvb/following{/other_user}", "gists_url": "https://api.github.com/users/yaroslavvb/gists{/gist_id}", "starred_url": "https://api.github.com/users/yaroslavvb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yaroslavvb/subscriptions", "organizations_url": "https://api.github.com/users/yaroslavvb/orgs", "repos_url": "https://api.github.com/users/yaroslavvb/repos", "events_url": "https://api.github.com/users/yaroslavvb/events{/privacy}", "received_events_url": "https://api.github.com/users/yaroslavvb/received_events", "type": "User", "site_admin": false}, "created_at": "2017-05-18T14:04:36Z", "updated_at": "2017-05-18T14:04:36Z", "author_association": "CONTRIBUTOR", "body_html": "<p>BTW, putting huge constants into Graph has performance implications besides higher memory, accessing data is slower too. Also there's a 2GB limit which includes graph inlined constants, once you hit it, you won't be able to add any more operations to the graph.</p>\n<p>I get around design issues by keeping global <code>init_dict</code> with links to all numpy arrays and passing it to <code>global_variables_initializer</code>.</p>\n<p>If you really wanted to find out why there's a difference you could try to narrow problem further.<br>\nFor instance, does it happen with Python protobufs as well or just with cpp?</p>\n<p>To find out which protobuf you are running:<br>\npython -c \"from google.protobuf.internal import api_implementation; print(api_implementation._default_implementation_type)\"</p>\n<p>Does it happen when the constant in question are getting read or is just the serialization step leaking memory? You can create large constant + small constant, and do \"sess.run(small_constant)\"</p>", "body_text": "BTW, putting huge constants into Graph has performance implications besides higher memory, accessing data is slower too. Also there's a 2GB limit which includes graph inlined constants, once you hit it, you won't be able to add any more operations to the graph.\nI get around design issues by keeping global init_dict with links to all numpy arrays and passing it to global_variables_initializer.\nIf you really wanted to find out why there's a difference you could try to narrow problem further.\nFor instance, does it happen with Python protobufs as well or just with cpp?\nTo find out which protobuf you are running:\npython -c \"from google.protobuf.internal import api_implementation; print(api_implementation._default_implementation_type)\"\nDoes it happen when the constant in question are getting read or is just the serialization step leaking memory? You can create large constant + small constant, and do \"sess.run(small_constant)\"", "body": "BTW, putting huge constants into Graph has performance implications besides higher memory, accessing data is slower too. Also there's a 2GB limit which includes graph inlined constants, once you hit it, you won't be able to add any more operations to the graph.\r\n\r\nI get around design issues by keeping global `init_dict` with links to all numpy arrays and passing it to `global_variables_initializer`.\r\n\r\nIf you really wanted to find out why there's a difference you could try to narrow problem further. \r\nFor instance, does it happen with Python protobufs as well or just with cpp?\r\n\r\nTo find out which protobuf you are running:\r\npython -c \"from google.protobuf.internal import api_implementation; print(api_implementation._default_implementation_type)\"\r\n\r\nDoes it happen when the constant in question are getting read or is just the serialization step leaking memory? You can create large constant + small constant, and do \"sess.run(small_constant)\""}