{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/308620186", "html_url": "https://github.com/tensorflow/tensorflow/pull/10368#issuecomment-308620186", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/10368", "id": 308620186, "node_id": "MDEyOklzc3VlQ29tbWVudDMwODYyMDE4Ng==", "user": {"login": "sj6077", "id": 2465713, "node_id": "MDQ6VXNlcjI0NjU3MTM=", "avatar_url": "https://avatars1.githubusercontent.com/u/2465713?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sj6077", "html_url": "https://github.com/sj6077", "followers_url": "https://api.github.com/users/sj6077/followers", "following_url": "https://api.github.com/users/sj6077/following{/other_user}", "gists_url": "https://api.github.com/users/sj6077/gists{/gist_id}", "starred_url": "https://api.github.com/users/sj6077/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sj6077/subscriptions", "organizations_url": "https://api.github.com/users/sj6077/orgs", "repos_url": "https://api.github.com/users/sj6077/repos", "events_url": "https://api.github.com/users/sj6077/events{/privacy}", "received_events_url": "https://api.github.com/users/sj6077/received_events", "type": "User", "site_admin": false}, "created_at": "2017-06-15T03:42:38Z", "updated_at": "2017-06-15T03:42:57Z", "author_association": "CONTRIBUTOR", "body_html": "<pre><code>class UpdateCollection(object):\n  \"\"\"Update collection info in MetaGraphDef for AutoParallel optimizer.\"\"\"\n\n  def __init__(self, metagraph, model):\n    self._metagraph = metagraph\n    self.replicate_states(model.initial_state_name)\n    self.replicate_states(model.final_state_name)\n    self.update_snapshot_name(\"variables\")\n    self.update_snapshot_name(\"trainable_variables\")\n\n  def update_snapshot_name(self, var_coll_name):\n    var_list = self._metagraph.collection_def[var_coll_name]\n    for i, value in enumerate(var_list.bytes_list.value):\n      var_def = variable_pb2.VariableDef()\n      var_def.ParseFromString(value)\n      # Somehow node Model/global_step/read doesn't have any fanout and seems to\n      # be only used for snapshot; this is different from all other variables.\n      if var_def.snapshot_name != \"Model/global_step/read:0\":\n        var_def.snapshot_name = with_autoparallel_prefix(\n            0, var_def.snapshot_name)\n      value = var_def.SerializeToString()\n      var_list.bytes_list.value[i] = value\n\n  def replicate_states(self, state_coll_name):\n    state_list = self._metagraph.collection_def[state_coll_name]\n    num_states = len(state_list.node_list.value)\n    for replica_id in range(1, FLAGS.num_gpus):\n      for i in range(num_states):\n        state_list.node_list.value.append(state_list.node_list.value[i])\n    for replica_id in range(FLAGS.num_gpus):\n      for i in range(num_states):\n        index = replica_id * num_states + i\n        state_list.node_list.value[index] = with_autoparallel_prefix(\n            replica_id, state_list.node_list.value[index])\n</code></pre>\n<p>According to the example that you mentioned, there is <code>update_snapshot_name</code> for metagraph collection. This is because variable, variable_snapshot, variable_initializer are all together defined for a variable, but snapshot and initializer are differently managed in auto_parallel. With this PR, the update_snapshot_name could be removed.</p>", "body_text": "class UpdateCollection(object):\n  \"\"\"Update collection info in MetaGraphDef for AutoParallel optimizer.\"\"\"\n\n  def __init__(self, metagraph, model):\n    self._metagraph = metagraph\n    self.replicate_states(model.initial_state_name)\n    self.replicate_states(model.final_state_name)\n    self.update_snapshot_name(\"variables\")\n    self.update_snapshot_name(\"trainable_variables\")\n\n  def update_snapshot_name(self, var_coll_name):\n    var_list = self._metagraph.collection_def[var_coll_name]\n    for i, value in enumerate(var_list.bytes_list.value):\n      var_def = variable_pb2.VariableDef()\n      var_def.ParseFromString(value)\n      # Somehow node Model/global_step/read doesn't have any fanout and seems to\n      # be only used for snapshot; this is different from all other variables.\n      if var_def.snapshot_name != \"Model/global_step/read:0\":\n        var_def.snapshot_name = with_autoparallel_prefix(\n            0, var_def.snapshot_name)\n      value = var_def.SerializeToString()\n      var_list.bytes_list.value[i] = value\n\n  def replicate_states(self, state_coll_name):\n    state_list = self._metagraph.collection_def[state_coll_name]\n    num_states = len(state_list.node_list.value)\n    for replica_id in range(1, FLAGS.num_gpus):\n      for i in range(num_states):\n        state_list.node_list.value.append(state_list.node_list.value[i])\n    for replica_id in range(FLAGS.num_gpus):\n      for i in range(num_states):\n        index = replica_id * num_states + i\n        state_list.node_list.value[index] = with_autoparallel_prefix(\n            replica_id, state_list.node_list.value[index])\n\nAccording to the example that you mentioned, there is update_snapshot_name for metagraph collection. This is because variable, variable_snapshot, variable_initializer are all together defined for a variable, but snapshot and initializer are differently managed in auto_parallel. With this PR, the update_snapshot_name could be removed.", "body": "```\r\nclass UpdateCollection(object):\r\n  \"\"\"Update collection info in MetaGraphDef for AutoParallel optimizer.\"\"\"\r\n\r\n  def __init__(self, metagraph, model):\r\n    self._metagraph = metagraph\r\n    self.replicate_states(model.initial_state_name)\r\n    self.replicate_states(model.final_state_name)\r\n    self.update_snapshot_name(\"variables\")\r\n    self.update_snapshot_name(\"trainable_variables\")\r\n\r\n  def update_snapshot_name(self, var_coll_name):\r\n    var_list = self._metagraph.collection_def[var_coll_name]\r\n    for i, value in enumerate(var_list.bytes_list.value):\r\n      var_def = variable_pb2.VariableDef()\r\n      var_def.ParseFromString(value)\r\n      # Somehow node Model/global_step/read doesn't have any fanout and seems to\r\n      # be only used for snapshot; this is different from all other variables.\r\n      if var_def.snapshot_name != \"Model/global_step/read:0\":\r\n        var_def.snapshot_name = with_autoparallel_prefix(\r\n            0, var_def.snapshot_name)\r\n      value = var_def.SerializeToString()\r\n      var_list.bytes_list.value[i] = value\r\n\r\n  def replicate_states(self, state_coll_name):\r\n    state_list = self._metagraph.collection_def[state_coll_name]\r\n    num_states = len(state_list.node_list.value)\r\n    for replica_id in range(1, FLAGS.num_gpus):\r\n      for i in range(num_states):\r\n        state_list.node_list.value.append(state_list.node_list.value[i])\r\n    for replica_id in range(FLAGS.num_gpus):\r\n      for i in range(num_states):\r\n        index = replica_id * num_states + i\r\n        state_list.node_list.value[index] = with_autoparallel_prefix(\r\n            replica_id, state_list.node_list.value[index])\r\n```\r\nAccording to the example that you mentioned, there is `update_snapshot_name` for metagraph collection. This is because variable, variable_snapshot, variable_initializer are all together defined for a variable, but snapshot and initializer are differently managed in auto_parallel. With this PR, the update_snapshot_name could be removed."}