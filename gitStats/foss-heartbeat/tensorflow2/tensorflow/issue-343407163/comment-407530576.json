{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/407530576", "html_url": "https://github.com/tensorflow/tensorflow/issues/21034#issuecomment-407530576", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/21034", "id": 407530576, "node_id": "MDEyOklzc3VlQ29tbWVudDQwNzUzMDU3Ng==", "user": {"login": "tanzhenyu", "id": 15220929, "node_id": "MDQ6VXNlcjE1MjIwOTI5", "avatar_url": "https://avatars3.githubusercontent.com/u/15220929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tanzhenyu", "html_url": "https://github.com/tanzhenyu", "followers_url": "https://api.github.com/users/tanzhenyu/followers", "following_url": "https://api.github.com/users/tanzhenyu/following{/other_user}", "gists_url": "https://api.github.com/users/tanzhenyu/gists{/gist_id}", "starred_url": "https://api.github.com/users/tanzhenyu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tanzhenyu/subscriptions", "organizations_url": "https://api.github.com/users/tanzhenyu/orgs", "repos_url": "https://api.github.com/users/tanzhenyu/repos", "events_url": "https://api.github.com/users/tanzhenyu/events{/privacy}", "received_events_url": "https://api.github.com/users/tanzhenyu/received_events", "type": "User", "site_admin": false}, "created_at": "2018-07-24T19:51:57Z", "updated_at": "2018-07-24T19:51:57Z", "author_association": "CONTRIBUTOR", "body_html": "<p>I don't think it's a bug. model itself is only aware of weights that are managed by layers. It would only work here if you use Dense with use_bias=True.<br>\nBut, if you really want to manage your own resource variable (which I don't think it's exposed as public as well), you could do subclassed layer instead of subclassed model, i.e.,<br>\nclass MyLayer(tf.keras.Layer):<br>\ndef <strong>init</strong>(self):<br>\nsuper(Layer, self).<strong>init</strong>()<br>\ndef build(self):<br>\nself.v = ResourceVariable([1.])<br>\nself.built = True<br>\ndef call(self, inputs):<br>\nreturn inputs + self.v<br>\ndef compute_output_shape(self):<br>\nsomething like return self.v.shape</p>\n<p>and use either functional or sequential model,<br>\nmodel = tf.keras.Sequential()<br>\ninput = tf.keras.Input(???)<br>\noutput = tf.keras.layers.Dense(2, use_bias=False)(input)<br>\noutput = MyLayer()(output)</p>", "body_text": "I don't think it's a bug. model itself is only aware of weights that are managed by layers. It would only work here if you use Dense with use_bias=True.\nBut, if you really want to manage your own resource variable (which I don't think it's exposed as public as well), you could do subclassed layer instead of subclassed model, i.e.,\nclass MyLayer(tf.keras.Layer):\ndef init(self):\nsuper(Layer, self).init()\ndef build(self):\nself.v = ResourceVariable([1.])\nself.built = True\ndef call(self, inputs):\nreturn inputs + self.v\ndef compute_output_shape(self):\nsomething like return self.v.shape\nand use either functional or sequential model,\nmodel = tf.keras.Sequential()\ninput = tf.keras.Input(???)\noutput = tf.keras.layers.Dense(2, use_bias=False)(input)\noutput = MyLayer()(output)", "body": "I don't think it's a bug. model itself is only aware of weights that are managed by layers. It would only work here if you use Dense with use_bias=True.\r\nBut, if you really want to manage your own resource variable (which I don't think it's exposed as public as well), you could do subclassed layer instead of subclassed model, i.e.,\r\nclass MyLayer(tf.keras.Layer):\r\n    def __init__(self):\r\n         super(Layer, self).__init__()\r\n    def build(self):\r\n         self.v = ResourceVariable([1.])\r\n         self.built = True\r\n    def call(self, inputs):\r\n         return inputs + self.v\r\n    def compute_output_shape(self):\r\n         something like return self.v.shape\r\n\r\nand use either functional or sequential model,\r\nmodel = tf.keras.Sequential()\r\ninput = tf.keras.Input(???)\r\noutput = tf.keras.layers.Dense(2, use_bias=False)(input)\r\noutput = MyLayer()(output)"}