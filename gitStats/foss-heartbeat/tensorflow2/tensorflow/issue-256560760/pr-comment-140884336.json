{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/140884336", "pull_request_review_id": 65020104, "id": 140884336, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE0MDg4NDMzNg==", "diff_hunk": "@@ -33,48 +34,117 @@ class UniqueOp : public OpKernel {\n \n   void Compute(OpKernelContext* context) override {\n     const Tensor& input = context->input(0);\n-    OP_REQUIRES(context, TensorShapeUtils::IsVector(input.shape()),\n-                errors::InvalidArgument(\"unique expects a 1D vector.\"));\n     // TODO(dga):  Make unique polymorphic for returning int32 and int64\n     // vectors to support large tensors.\n     OP_REQUIRES(context,\n                 input.NumElements() <= std::numeric_limits<int32>::max(),\n                 errors::InvalidArgument(\n                     \"unique does not support input tensors larger than \",\n                     std::numeric_limits<int32>::max(), \" elements\"));\n-    auto Tin = input.vec<T>();\n-    const int64 N = static_cast<int64>(Tin.size());\n+\n+    int64 axis = 0;\n+    std::vector<int64> new_sizes{1, input.NumElements(), 1};\n+    if (context->num_inputs() == 1) {\n+      OP_REQUIRES(context, TensorShapeUtils::IsVector(input.shape()),\n+                  errors::InvalidArgument(\"unique expects a 1D vector.\"));\n+    } else {\n+      // In case of UniqueV2, the axis is a 1D vector. The purpose is\n+      // to allow specifying either \"no axis\" or \"axis\". The `[]` means\n+      // \"no axis\", while `[x]` means `axis = x`.\n+      const Tensor& axis_tensor = context->input(1);\n+      OP_REQUIRES(context, TensorShapeUtils::IsVector(axis_tensor.shape()),\n+                  errors::InvalidArgument(\"axis expects a 1D vector.\"));\n+      OP_REQUIRES(\n+          context, axis_tensor.NumElements() <= 1,\n+          errors::InvalidArgument(\n+              \"axis does not support input tensors larger than 1 elements\"));\n+      if (axis_tensor.NumElements() == 0) {\n+        OP_REQUIRES(context, TensorShapeUtils::IsVector(input.shape()),\n+                    errors::InvalidArgument(\"unique expects a 1D vector.\"));\n+      } else {\n+        auto axis_vec = axis_tensor.vec<int64>();\n+        axis = axis_vec(0);\n+        axis = axis < 0 ? axis + input.dims() : axis;\n+        OP_REQUIRES(context, 0 <= axis && axis < input.dims(),\n+                    errors::InvalidArgument(\"axis has to be between [0, \",\n+                                            input.dims(), \")\"));\n+        if (axis > 0) {\n+          for (int64 i = 0; i < axis; i++) {\n+            new_sizes[0] *= input.dim_size(i);\n+          }\n+        }\n+        new_sizes[1] = input.dim_size(axis);\n+        if (axis + 1 < input.dims()) {\n+          for (int64 i = axis + 1; i < input.dims(); i++) {\n+            new_sizes[2] *= input.dim_size(i);\n+          }\n+        }\n+      }\n+    }\n+\n+    auto Tin = input.shaped<T, 3>(new_sizes);\n \n     Tensor* idx = nullptr;\n     OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n-                                {0}, 1, input.shape(), &idx));\n+                                {0}, 1, TensorShape({Tin.dimension(1)}), &idx));\n     auto idx_vec = idx->template vec<TIndex>();\n \n-    std::unordered_map<T, TIndex> uniq;\n-    uniq.reserve(2 * N);\n-    for (int64 i = 0, j = 0; i < N; ++i) {\n-      auto it = uniq.insert(std::make_pair(Tin(i), j));\n+    auto hash_fn = [&Tin](const int64& key) -> unsigned long {\n+      size_t hash = 0;\n+      for (int64 i = 0; i < Tin.dimension(0); i++) {\n+        for (uint64 j = 0; j < Tin.dimension(2); j++) {\n+          hash += std::hash<T>{}(Tin(i, key, j));", "path": "tensorflow/core/kernels/unique_op.cc", "position": null, "original_position": 80, "commit_id": "def6ef379d12613eb7d9287bfa85c67ee6744f61", "original_commit_id": "389f6aefb6326d30cfa3f8c5e1d390dba9e6240b", "user": {"login": "yongtang", "id": 6932348, "node_id": "MDQ6VXNlcjY5MzIzNDg=", "avatar_url": "https://avatars0.githubusercontent.com/u/6932348?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yongtang", "html_url": "https://github.com/yongtang", "followers_url": "https://api.github.com/users/yongtang/followers", "following_url": "https://api.github.com/users/yongtang/following{/other_user}", "gists_url": "https://api.github.com/users/yongtang/gists{/gist_id}", "starred_url": "https://api.github.com/users/yongtang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yongtang/subscriptions", "organizations_url": "https://api.github.com/users/yongtang/orgs", "repos_url": "https://api.github.com/users/yongtang/repos", "events_url": "https://api.github.com/users/yongtang/events{/privacy}", "received_events_url": "https://api.github.com/users/yongtang/received_events", "type": "User", "site_admin": false}, "body": "Thanks. Done. The `Hash64Combine` from `tensorflow/core/lib/hash/hash.h` has been used.", "created_at": "2017-09-25T20:11:21Z", "updated_at": "2017-11-04T16:12:07Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/12952#discussion_r140884336", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/12952", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/140884336"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/12952#discussion_r140884336"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/12952"}}, "body_html": "<p>Thanks. Done. The <code>Hash64Combine</code> from <code>tensorflow/core/lib/hash/hash.h</code> has been used.</p>", "body_text": "Thanks. Done. The Hash64Combine from tensorflow/core/lib/hash/hash.h has been used.", "in_reply_to_id": 139590460}