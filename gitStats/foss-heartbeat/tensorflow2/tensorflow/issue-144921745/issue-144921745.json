{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/1724", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/1724/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/1724/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/1724/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/1724", "id": 144921745, "node_id": "MDU6SXNzdWUxNDQ5MjE3NDU=", "number": 1724, "title": "Updating ExponentialMovingAverage based on a condition", "user": {"login": "bayerj", "id": 50352, "node_id": "MDQ6VXNlcjUwMzUy", "avatar_url": "https://avatars3.githubusercontent.com/u/50352?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bayerj", "html_url": "https://github.com/bayerj", "followers_url": "https://api.github.com/users/bayerj/followers", "following_url": "https://api.github.com/users/bayerj/following{/other_user}", "gists_url": "https://api.github.com/users/bayerj/gists{/gist_id}", "starred_url": "https://api.github.com/users/bayerj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bayerj/subscriptions", "organizations_url": "https://api.github.com/users/bayerj/orgs", "repos_url": "https://api.github.com/users/bayerj/repos", "events_url": "https://api.github.com/users/bayerj/events{/privacy}", "received_events_url": "https://api.github.com/users/bayerj/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": {"login": "yuanbyu", "id": 2342391, "node_id": "MDQ6VXNlcjIzNDIzOTE=", "avatar_url": "https://avatars1.githubusercontent.com/u/2342391?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yuanbyu", "html_url": "https://github.com/yuanbyu", "followers_url": "https://api.github.com/users/yuanbyu/followers", "following_url": "https://api.github.com/users/yuanbyu/following{/other_user}", "gists_url": "https://api.github.com/users/yuanbyu/gists{/gist_id}", "starred_url": "https://api.github.com/users/yuanbyu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yuanbyu/subscriptions", "organizations_url": "https://api.github.com/users/yuanbyu/orgs", "repos_url": "https://api.github.com/users/yuanbyu/repos", "events_url": "https://api.github.com/users/yuanbyu/events{/privacy}", "received_events_url": "https://api.github.com/users/yuanbyu/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "yuanbyu", "id": 2342391, "node_id": "MDQ6VXNlcjIzNDIzOTE=", "avatar_url": "https://avatars1.githubusercontent.com/u/2342391?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yuanbyu", "html_url": "https://github.com/yuanbyu", "followers_url": "https://api.github.com/users/yuanbyu/followers", "following_url": "https://api.github.com/users/yuanbyu/following{/other_user}", "gists_url": "https://api.github.com/users/yuanbyu/gists{/gist_id}", "starred_url": "https://api.github.com/users/yuanbyu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yuanbyu/subscriptions", "organizations_url": "https://api.github.com/users/yuanbyu/orgs", "repos_url": "https://api.github.com/users/yuanbyu/repos", "events_url": "https://api.github.com/users/yuanbyu/events{/privacy}", "received_events_url": "https://api.github.com/users/yuanbyu/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 7, "created_at": "2016-03-31T14:42:12Z", "updated_at": "2016-04-25T19:47:15Z", "closed_at": "2016-04-25T19:47:15Z", "author_association": "NONE", "body_html": "<p>Using tensorflow 0.7.1.</p>\n<p>I have followed issue <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"127320186\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/tensorflow/tensorflow/issues/804\" data-hovercard-type=\"issue\" data-hovercard-url=\"/tensorflow/tensorflow/issues/804/hovercard\" href=\"https://github.com/tensorflow/tensorflow/issues/804\">#804</a> to make use of batch normalization with tensorflow. However, I struggle to get the snippet to work as expected and have nailed down the problem to something more concise.</p>\n<p>Let us assume we want to perform a moving average over incoming scalars; sometimes we want to update the statistics of that moving average, sometimes we don't. We will model that with a placeholder <code>do_update</code>, which we can set to <code>True</code> or <code>False</code> in the <code>feed_dict</code> passed to <code>sess.run(...)</code>. Basically, this is the code from <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"127320186\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/tensorflow/tensorflow/issues/804\" data-hovercard-type=\"issue\" data-hovercard-url=\"/tensorflow/tensorflow/issues/804/hovercard\" href=\"https://github.com/tensorflow/tensorflow/issues/804\">#804</a> but greatly simplified.</p>\n<pre><code>import tensorflow as tf\nimport numpy as np\n\ninpt = tf.Variable(np.array([1.]))\ndo_update = tf.placeholder(tf.bool)\n\nema = tf.train.ExponentialMovingAverage(.9)\nema_assign = ema.apply([inpt])\n\n\ndef update():\n    with tf.control_dependencies([ema_assign]):\n        return tf.identity(ema.average(inpt))      # note the identity.\n\ndef no_update():\n    return ema.average(inpt)\n\nrun = tf.python.control_flow_ops.cond(do_update, update, no_update)\n</code></pre>\n<p>However, when I execute <code>run</code> updating will happen. It does not matter what the value of <code>do_update</code> is.</p>\n<pre><code>print run.eval({inpt: np.array([2.]), do_update: True})\nprint run.eval({inpt: np.array([2.]), do_update: True})\nprint run.eval({inpt: np.array([2.]), do_update: True})\n\n# prints:\n# [ 1.10000002]\n# [ 1.19000004]\n# [ 1.27100006]\n\nprint run.eval({inpt: np.array([2.]), do_update: False})\nprint run.eval({inpt: np.array([2.]), do_update: False})\nprint run.eval({inpt: np.array([2.]), do_update: False})\n\n# prints:\n# [ 1.34390007]\n# [ 1.40951008]\n# [ 1.46855908]\n</code></pre>\n<p>Curiously, if I remove the <code>tf.identity</code> above in the definition of <code>update</code>, neither of them performs an update after starting a new session.</p>\n<pre><code>print run.eval({inpt: np.array([2.]), do_update: True})\nprint run.eval({inpt: np.array([2.]), do_update: True})\nprint run.eval({inpt: np.array([2.]), do_update: True})\n\n# prints:\n# [ 1.]\n# [ 1.]\n# [ 1.]\n\nprint run.eval({inpt: np.array([2.]), do_update: False})\nprint run.eval({inpt: np.array([2.]), do_update: False})\nprint run.eval({inpt: np.array([2.]), do_update: False})\n\n# prints:\n# [ 1.]\n# [ 1.]\n# [ 1.]\n</code></pre>\n<p>This seems as uninteded behaviour to me, but maybe I am missing something.</p>", "body_text": "Using tensorflow 0.7.1.\nI have followed issue #804 to make use of batch normalization with tensorflow. However, I struggle to get the snippet to work as expected and have nailed down the problem to something more concise.\nLet us assume we want to perform a moving average over incoming scalars; sometimes we want to update the statistics of that moving average, sometimes we don't. We will model that with a placeholder do_update, which we can set to True or False in the feed_dict passed to sess.run(...). Basically, this is the code from #804 but greatly simplified.\nimport tensorflow as tf\nimport numpy as np\n\ninpt = tf.Variable(np.array([1.]))\ndo_update = tf.placeholder(tf.bool)\n\nema = tf.train.ExponentialMovingAverage(.9)\nema_assign = ema.apply([inpt])\n\n\ndef update():\n    with tf.control_dependencies([ema_assign]):\n        return tf.identity(ema.average(inpt))      # note the identity.\n\ndef no_update():\n    return ema.average(inpt)\n\nrun = tf.python.control_flow_ops.cond(do_update, update, no_update)\n\nHowever, when I execute run updating will happen. It does not matter what the value of do_update is.\nprint run.eval({inpt: np.array([2.]), do_update: True})\nprint run.eval({inpt: np.array([2.]), do_update: True})\nprint run.eval({inpt: np.array([2.]), do_update: True})\n\n# prints:\n# [ 1.10000002]\n# [ 1.19000004]\n# [ 1.27100006]\n\nprint run.eval({inpt: np.array([2.]), do_update: False})\nprint run.eval({inpt: np.array([2.]), do_update: False})\nprint run.eval({inpt: np.array([2.]), do_update: False})\n\n# prints:\n# [ 1.34390007]\n# [ 1.40951008]\n# [ 1.46855908]\n\nCuriously, if I remove the tf.identity above in the definition of update, neither of them performs an update after starting a new session.\nprint run.eval({inpt: np.array([2.]), do_update: True})\nprint run.eval({inpt: np.array([2.]), do_update: True})\nprint run.eval({inpt: np.array([2.]), do_update: True})\n\n# prints:\n# [ 1.]\n# [ 1.]\n# [ 1.]\n\nprint run.eval({inpt: np.array([2.]), do_update: False})\nprint run.eval({inpt: np.array([2.]), do_update: False})\nprint run.eval({inpt: np.array([2.]), do_update: False})\n\n# prints:\n# [ 1.]\n# [ 1.]\n# [ 1.]\n\nThis seems as uninteded behaviour to me, but maybe I am missing something.", "body": "Using tensorflow 0.7.1.\n\nI have followed issue #804 to make use of batch normalization with tensorflow. However, I struggle to get the snippet to work as expected and have nailed down the problem to something more concise.\n\nLet us assume we want to perform a moving average over incoming scalars; sometimes we want to update the statistics of that moving average, sometimes we don't. We will model that with a placeholder `do_update`, which we can set to `True` or `False` in the `feed_dict` passed to `sess.run(...)`. Basically, this is the code from #804 but greatly simplified.\n\n```\nimport tensorflow as tf\nimport numpy as np\n\ninpt = tf.Variable(np.array([1.]))\ndo_update = tf.placeholder(tf.bool)\n\nema = tf.train.ExponentialMovingAverage(.9)\nema_assign = ema.apply([inpt])\n\n\ndef update():\n    with tf.control_dependencies([ema_assign]):\n        return tf.identity(ema.average(inpt))      # note the identity.\n\ndef no_update():\n    return ema.average(inpt)\n\nrun = tf.python.control_flow_ops.cond(do_update, update, no_update)\n```\n\nHowever, when I execute `run` updating will happen. It does not matter what the value of `do_update` is.\n\n```\nprint run.eval({inpt: np.array([2.]), do_update: True})\nprint run.eval({inpt: np.array([2.]), do_update: True})\nprint run.eval({inpt: np.array([2.]), do_update: True})\n\n# prints:\n# [ 1.10000002]\n# [ 1.19000004]\n# [ 1.27100006]\n\nprint run.eval({inpt: np.array([2.]), do_update: False})\nprint run.eval({inpt: np.array([2.]), do_update: False})\nprint run.eval({inpt: np.array([2.]), do_update: False})\n\n# prints:\n# [ 1.34390007]\n# [ 1.40951008]\n# [ 1.46855908]\n```\n\nCuriously, if I remove the `tf.identity` above in the definition of `update`, neither of them performs an update after starting a new session.\n\n```\nprint run.eval({inpt: np.array([2.]), do_update: True})\nprint run.eval({inpt: np.array([2.]), do_update: True})\nprint run.eval({inpt: np.array([2.]), do_update: True})\n\n# prints:\n# [ 1.]\n# [ 1.]\n# [ 1.]\n\nprint run.eval({inpt: np.array([2.]), do_update: False})\nprint run.eval({inpt: np.array([2.]), do_update: False})\nprint run.eval({inpt: np.array([2.]), do_update: False})\n\n# prints:\n# [ 1.]\n# [ 1.]\n# [ 1.]\n```\n\nThis seems as uninteded behaviour to me, but maybe I am missing something.\n"}