{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/246026683", "html_url": "https://github.com/tensorflow/tensorflow/issues/2514#issuecomment-246026683", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2514", "id": 246026683, "node_id": "MDEyOklzc3VlQ29tbWVudDI0NjAyNjY4Mw==", "user": {"login": "markpwoodward", "id": 6820773, "node_id": "MDQ6VXNlcjY4MjA3NzM=", "avatar_url": "https://avatars0.githubusercontent.com/u/6820773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/markpwoodward", "html_url": "https://github.com/markpwoodward", "followers_url": "https://api.github.com/users/markpwoodward/followers", "following_url": "https://api.github.com/users/markpwoodward/following{/other_user}", "gists_url": "https://api.github.com/users/markpwoodward/gists{/gist_id}", "starred_url": "https://api.github.com/users/markpwoodward/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/markpwoodward/subscriptions", "organizations_url": "https://api.github.com/users/markpwoodward/orgs", "repos_url": "https://api.github.com/users/markpwoodward/repos", "events_url": "https://api.github.com/users/markpwoodward/events{/privacy}", "received_events_url": "https://api.github.com/users/markpwoodward/received_events", "type": "User", "site_admin": false}, "created_at": "2016-09-09T20:14:05Z", "updated_at": "2016-09-09T20:17:09Z", "author_association": "NONE", "body_html": "<p>Regarding the side track, not the original request.<br>\n<a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=8004953\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/muhammadzaheer\">@muhammadzaheer</a>, here is an example usage of <code>QueueBase.from_list()</code> that you asked for.<br>\n<a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=2111293\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/danijar\">@danijar</a>, I would recommend using <code>QueueBase.from_list()</code> over <code>tf.cond()</code>.</p>\n<pre><code>import tensorflow as tf\n\nq1 = tf.FIFOQueue(capacity=100, dtypes=[tf.int32])\ninput1 = tf.placeholder(tf.int32, [])\nenq1 = q1.enqueue(input1)\n\nq2 = tf.FIFOQueue(capacity=100, dtypes=[tf.int32])\ninput2 = tf.placeholder(tf.int32, [])\nenq2 = q2.enqueue(input2)\n\nselect_q = tf.placeholder(tf.int32, [])\nq = tf.QueueBase.from_list(select_q, [q1, q2])\ndata = q.dequeue()\n\nwith tf.Session() as sess:\n  # enqueue values (these would typically be in their own thread(s))\n  q1_vals = [1,2,3]\n  print \"q1_vals = \" + str(q1_vals)\n  for v in q1_vals:\n    sess.run(enq1, { input1: v })\n\n  q2_vals = [4,5,6]\n  print \"q2_vals = \" + str(q2_vals)\n  for v in q2_vals:\n    sess.run(enq2, { input2: v })\n\n  # run an op that pulls from the queue, specifying which queue\n  for i in range(3):\n    print \"q1.dequeue = \" + str(sess.run(data, {select_q: 0}))\n    print \"q2.dequeue = \" + str(sess.run(data, {select_q: 1}))\n</code></pre>\n<p>outputs</p>\n<pre><code>q1_vals = [1, 2, 3]\nq2_vals = [4, 5, 6]\nq1.dequeue = 1\nq2.dequeue = 4\nq1.dequeue = 2\nq2.dequeue = 5\nq1.dequeue = 3\nq2.dequeue = 6\n</code></pre>", "body_text": "Regarding the side track, not the original request.\n@muhammadzaheer, here is an example usage of QueueBase.from_list() that you asked for.\n@danijar, I would recommend using QueueBase.from_list() over tf.cond().\nimport tensorflow as tf\n\nq1 = tf.FIFOQueue(capacity=100, dtypes=[tf.int32])\ninput1 = tf.placeholder(tf.int32, [])\nenq1 = q1.enqueue(input1)\n\nq2 = tf.FIFOQueue(capacity=100, dtypes=[tf.int32])\ninput2 = tf.placeholder(tf.int32, [])\nenq2 = q2.enqueue(input2)\n\nselect_q = tf.placeholder(tf.int32, [])\nq = tf.QueueBase.from_list(select_q, [q1, q2])\ndata = q.dequeue()\n\nwith tf.Session() as sess:\n  # enqueue values (these would typically be in their own thread(s))\n  q1_vals = [1,2,3]\n  print \"q1_vals = \" + str(q1_vals)\n  for v in q1_vals:\n    sess.run(enq1, { input1: v })\n\n  q2_vals = [4,5,6]\n  print \"q2_vals = \" + str(q2_vals)\n  for v in q2_vals:\n    sess.run(enq2, { input2: v })\n\n  # run an op that pulls from the queue, specifying which queue\n  for i in range(3):\n    print \"q1.dequeue = \" + str(sess.run(data, {select_q: 0}))\n    print \"q2.dequeue = \" + str(sess.run(data, {select_q: 1}))\n\noutputs\nq1_vals = [1, 2, 3]\nq2_vals = [4, 5, 6]\nq1.dequeue = 1\nq2.dequeue = 4\nq1.dequeue = 2\nq2.dequeue = 5\nq1.dequeue = 3\nq2.dequeue = 6", "body": "Regarding the side track, not the original request.\n@muhammadzaheer, here is an example usage of `QueueBase.from_list()` that you asked for.\n@danijar, I would recommend using `QueueBase.from_list()` over `tf.cond()`.\n\n```\nimport tensorflow as tf\n\nq1 = tf.FIFOQueue(capacity=100, dtypes=[tf.int32])\ninput1 = tf.placeholder(tf.int32, [])\nenq1 = q1.enqueue(input1)\n\nq2 = tf.FIFOQueue(capacity=100, dtypes=[tf.int32])\ninput2 = tf.placeholder(tf.int32, [])\nenq2 = q2.enqueue(input2)\n\nselect_q = tf.placeholder(tf.int32, [])\nq = tf.QueueBase.from_list(select_q, [q1, q2])\ndata = q.dequeue()\n\nwith tf.Session() as sess:\n  # enqueue values (these would typically be in their own thread(s))\n  q1_vals = [1,2,3]\n  print \"q1_vals = \" + str(q1_vals)\n  for v in q1_vals:\n    sess.run(enq1, { input1: v })\n\n  q2_vals = [4,5,6]\n  print \"q2_vals = \" + str(q2_vals)\n  for v in q2_vals:\n    sess.run(enq2, { input2: v })\n\n  # run an op that pulls from the queue, specifying which queue\n  for i in range(3):\n    print \"q1.dequeue = \" + str(sess.run(data, {select_q: 0}))\n    print \"q2.dequeue = \" + str(sess.run(data, {select_q: 1}))\n```\n\noutputs\n\n```\nq1_vals = [1, 2, 3]\nq2_vals = [4, 5, 6]\nq1.dequeue = 1\nq2.dequeue = 4\nq1.dequeue = 2\nq2.dequeue = 5\nq1.dequeue = 3\nq2.dequeue = 6\n```\n"}