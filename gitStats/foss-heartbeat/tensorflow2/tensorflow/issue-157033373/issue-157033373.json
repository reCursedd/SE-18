{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2514", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2514/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2514/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2514/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/2514", "id": 157033373, "node_id": "MDU6SXNzdWUxNTcwMzMzNzM=", "number": 2514, "title": "Feature Request: multi-epoch alternative to tf.QueueBase.close()", "user": {"login": "markpwoodward", "id": 6820773, "node_id": "MDQ6VXNlcjY4MjA3NzM=", "avatar_url": "https://avatars0.githubusercontent.com/u/6820773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/markpwoodward", "html_url": "https://github.com/markpwoodward", "followers_url": "https://api.github.com/users/markpwoodward/followers", "following_url": "https://api.github.com/users/markpwoodward/following{/other_user}", "gists_url": "https://api.github.com/users/markpwoodward/gists{/gist_id}", "starred_url": "https://api.github.com/users/markpwoodward/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/markpwoodward/subscriptions", "organizations_url": "https://api.github.com/users/markpwoodward/orgs", "repos_url": "https://api.github.com/users/markpwoodward/repos", "events_url": "https://api.github.com/users/markpwoodward/events{/privacy}", "received_events_url": "https://api.github.com/users/markpwoodward/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 299643928, "node_id": "MDU6TGFiZWwyOTk2NDM5Mjg=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:contributions%20welcome", "name": "stat:contributions welcome", "color": "f4b400", "default": false}, {"id": 473173272, "node_id": "MDU6TGFiZWw0NzMxNzMyNzI=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:feature", "name": "type:feature", "color": "159b2e", "default": false}], "state": "closed", "locked": false, "assignee": {"login": "ebrevdo", "id": 1794715, "node_id": "MDQ6VXNlcjE3OTQ3MTU=", "avatar_url": "https://avatars0.githubusercontent.com/u/1794715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebrevdo", "html_url": "https://github.com/ebrevdo", "followers_url": "https://api.github.com/users/ebrevdo/followers", "following_url": "https://api.github.com/users/ebrevdo/following{/other_user}", "gists_url": "https://api.github.com/users/ebrevdo/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebrevdo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebrevdo/subscriptions", "organizations_url": "https://api.github.com/users/ebrevdo/orgs", "repos_url": "https://api.github.com/users/ebrevdo/repos", "events_url": "https://api.github.com/users/ebrevdo/events{/privacy}", "received_events_url": "https://api.github.com/users/ebrevdo/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "ebrevdo", "id": 1794715, "node_id": "MDQ6VXNlcjE3OTQ3MTU=", "avatar_url": "https://avatars0.githubusercontent.com/u/1794715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebrevdo", "html_url": "https://github.com/ebrevdo", "followers_url": "https://api.github.com/users/ebrevdo/followers", "following_url": "https://api.github.com/users/ebrevdo/following{/other_user}", "gists_url": "https://api.github.com/users/ebrevdo/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebrevdo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebrevdo/subscriptions", "organizations_url": "https://api.github.com/users/ebrevdo/orgs", "repos_url": "https://api.github.com/users/ebrevdo/repos", "events_url": "https://api.github.com/users/ebrevdo/events{/privacy}", "received_events_url": "https://api.github.com/users/ebrevdo/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 62, "created_at": "2016-05-26T17:12:27Z", "updated_at": "2017-12-31T10:46:02Z", "closed_at": "2017-11-16T18:04:29Z", "author_association": "NONE", "body_html": "<p>Examples on the web demonstrate signaling the end of queue data by calling queue.close() in the data producer and then catching the tf.errors.OutOfRangeError exception in the data consumer.</p>\n<p>This works fine for a single epoch, but I do multiple epochs, alternating between training data and testing data, and I can't reuse the queue after calling queue.close().</p>\n<p>The two solutions that I have thought of using the existing code are:</p>\n<ol>\n<li>enqueue() some sentinel at the end of an epoch in the data producer and then tf.Assert() against the sentinel and catch the tf.errors.InvalidArgumentError in the data consumer.</li>\n<li>know the number of enqueue's for the epoch and only dequeue that number.<br>\nBoth seem a little hacky.</li>\n</ol>\n<p>Multi-epoch use of queues might be simplified by adding one of the following:</p>\n<ol>\n<li>A queue.reset(), that throws one tf.errors.OutOfRangeError on dequeue() or some other exception.</li>\n<li>A queue.close(reset=True), that only throws one tf.errors.OutOfRangeError on dequeue() or some other exception.</li>\n</ol>\n<p>example usage of 1):</p>\n<pre><code>q = tf.FIFOQueue(...)\nplaceholder = ...\nenqueue_op = q.enqueue(placeholder)\n....\n\ndef producer(data_dir, sess, q, enqueue_op, placeholder):\n  for ...:\n    sess.run(enqueue_op, {placeholder:...})\n  sess.run(q.reset())\n\ndef do_epoch(data_dir, learn):\n  threading.Thread(target=producer, args=(data_dir, sess, q, enqueue_op, placeholder)).start()\n  while True:\n    try:\n      sess.run(...)\n    exception tf.errors.OutOfRangeError:\n      break\n\nfor epoch in range(NUM_EPOCHS):\n  ... = do_epoch(TRAIN_DIR, learn=True)\n  ... = do_epoch(TEST_DIR, learn=False)\n</code></pre>", "body_text": "Examples on the web demonstrate signaling the end of queue data by calling queue.close() in the data producer and then catching the tf.errors.OutOfRangeError exception in the data consumer.\nThis works fine for a single epoch, but I do multiple epochs, alternating between training data and testing data, and I can't reuse the queue after calling queue.close().\nThe two solutions that I have thought of using the existing code are:\n\nenqueue() some sentinel at the end of an epoch in the data producer and then tf.Assert() against the sentinel and catch the tf.errors.InvalidArgumentError in the data consumer.\nknow the number of enqueue's for the epoch and only dequeue that number.\nBoth seem a little hacky.\n\nMulti-epoch use of queues might be simplified by adding one of the following:\n\nA queue.reset(), that throws one tf.errors.OutOfRangeError on dequeue() or some other exception.\nA queue.close(reset=True), that only throws one tf.errors.OutOfRangeError on dequeue() or some other exception.\n\nexample usage of 1):\nq = tf.FIFOQueue(...)\nplaceholder = ...\nenqueue_op = q.enqueue(placeholder)\n....\n\ndef producer(data_dir, sess, q, enqueue_op, placeholder):\n  for ...:\n    sess.run(enqueue_op, {placeholder:...})\n  sess.run(q.reset())\n\ndef do_epoch(data_dir, learn):\n  threading.Thread(target=producer, args=(data_dir, sess, q, enqueue_op, placeholder)).start()\n  while True:\n    try:\n      sess.run(...)\n    exception tf.errors.OutOfRangeError:\n      break\n\nfor epoch in range(NUM_EPOCHS):\n  ... = do_epoch(TRAIN_DIR, learn=True)\n  ... = do_epoch(TEST_DIR, learn=False)", "body": "Examples on the web demonstrate signaling the end of queue data by calling queue.close() in the data producer and then catching the tf.errors.OutOfRangeError exception in the data consumer.\n\nThis works fine for a single epoch, but I do multiple epochs, alternating between training data and testing data, and I can't reuse the queue after calling queue.close().\n\nThe two solutions that I have thought of using the existing code are:\n1) enqueue() some sentinel at the end of an epoch in the data producer and then tf.Assert() against the sentinel and catch the tf.errors.InvalidArgumentError in the data consumer.\n2) know the number of enqueue's for the epoch and only dequeue that number.\nBoth seem a little hacky.\n\nMulti-epoch use of queues might be simplified by adding one of the following:\n1) A queue.reset(), that throws one tf.errors.OutOfRangeError on dequeue() or some other exception.\n2) A queue.close(reset=True), that only throws one tf.errors.OutOfRangeError on dequeue() or some other exception.\n\nexample usage of 1):\n\n```\nq = tf.FIFOQueue(...)\nplaceholder = ...\nenqueue_op = q.enqueue(placeholder)\n....\n\ndef producer(data_dir, sess, q, enqueue_op, placeholder):\n  for ...:\n    sess.run(enqueue_op, {placeholder:...})\n  sess.run(q.reset())\n\ndef do_epoch(data_dir, learn):\n  threading.Thread(target=producer, args=(data_dir, sess, q, enqueue_op, placeholder)).start()\n  while True:\n    try:\n      sess.run(...)\n    exception tf.errors.OutOfRangeError:\n      break\n\nfor epoch in range(NUM_EPOCHS):\n  ... = do_epoch(TRAIN_DIR, learn=True)\n  ... = do_epoch(TEST_DIR, learn=False)\n```\n"}