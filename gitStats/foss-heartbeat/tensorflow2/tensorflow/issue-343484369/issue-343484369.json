{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/21042", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/21042/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/21042/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/21042/events", "html_url": "https://github.com/tensorflow/tensorflow/pull/21042", "id": 343484369, "node_id": "MDExOlB1bGxSZXF1ZXN0MjAzMTA2ODE4", "number": 21042, "title": "Templates DataTypeToEnum and associated structs on type properties", "user": {"login": "Bidski", "id": 2320984, "node_id": "MDQ6VXNlcjIzMjA5ODQ=", "avatar_url": "https://avatars1.githubusercontent.com/u/2320984?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Bidski", "html_url": "https://github.com/Bidski", "followers_url": "https://api.github.com/users/Bidski/followers", "following_url": "https://api.github.com/users/Bidski/following{/other_user}", "gists_url": "https://api.github.com/users/Bidski/gists{/gist_id}", "starred_url": "https://api.github.com/users/Bidski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Bidski/subscriptions", "organizations_url": "https://api.github.com/users/Bidski/orgs", "repos_url": "https://api.github.com/users/Bidski/repos", "events_url": "https://api.github.com/users/Bidski/events{/privacy}", "received_events_url": "https://api.github.com/users/Bidski/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 300136587, "node_id": "MDU6TGFiZWwzMDAxMzY1ODc=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/cla:%20yes", "name": "cla: yes", "color": "009800", "default": false}], "state": "closed", "locked": false, "assignee": {"login": "caisq", "id": 16824702, "node_id": "MDQ6VXNlcjE2ODI0NzAy", "avatar_url": "https://avatars2.githubusercontent.com/u/16824702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/caisq", "html_url": "https://github.com/caisq", "followers_url": "https://api.github.com/users/caisq/followers", "following_url": "https://api.github.com/users/caisq/following{/other_user}", "gists_url": "https://api.github.com/users/caisq/gists{/gist_id}", "starred_url": "https://api.github.com/users/caisq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/caisq/subscriptions", "organizations_url": "https://api.github.com/users/caisq/orgs", "repos_url": "https://api.github.com/users/caisq/repos", "events_url": "https://api.github.com/users/caisq/events{/privacy}", "received_events_url": "https://api.github.com/users/caisq/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "caisq", "id": 16824702, "node_id": "MDQ6VXNlcjE2ODI0NzAy", "avatar_url": "https://avatars2.githubusercontent.com/u/16824702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/caisq", "html_url": "https://github.com/caisq", "followers_url": "https://api.github.com/users/caisq/followers", "following_url": "https://api.github.com/users/caisq/following{/other_user}", "gists_url": "https://api.github.com/users/caisq/gists{/gist_id}", "starred_url": "https://api.github.com/users/caisq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/caisq/subscriptions", "organizations_url": "https://api.github.com/users/caisq/orgs", "repos_url": "https://api.github.com/users/caisq/repos", "events_url": "https://api.github.com/users/caisq/events{/privacy}", "received_events_url": "https://api.github.com/users/caisq/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 6, "created_at": "2018-07-23T04:34:03Z", "updated_at": "2018-08-10T17:01:13Z", "closed_at": "2018-08-10T17:01:12Z", "author_association": "NONE", "pull_request": {"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/21042", "html_url": "https://github.com/tensorflow/tensorflow/pull/21042", "diff_url": "https://github.com/tensorflow/tensorflow/pull/21042.diff", "patch_url": "https://github.com/tensorflow/tensorflow/pull/21042.patch"}, "body_html": "<p>This PR addresses the bug outlined in <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"338810311\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/tensorflow/tensorflow/issues/20586\" data-hovercard-type=\"issue\" data-hovercard-url=\"/tensorflow/tensorflow/issues/20586/hovercard\" href=\"https://github.com/tensorflow/tensorflow/issues/20586\">#20586</a>. Rather than relying on all systems to define the <code>int64</code> data type in a manner that is consistent with a <code>long long</code>, this PR inspects the properties of the type. For instance, <code>int64</code> is a <code>signed</code>, <code>integral</code> type with a size of <code>8 bytes</code>.</p>\n<p>This is important as not all systems define the basic integral data types in the same way, but they are all defined to meet the same intrinsic properties. On the test system, <code>int64_t</code> is not equivalent to a <code>long long</code> (which is how the <code>int64</code> type is defined in <code>tensorflow/core/platform/default/integral_types.h</code>). However, both <code>long long</code> and <code>int64_t</code> meet the same intrinsic properties on the test system. The following code and output shows this inconsistency, where <code>int64_t != long long</code> from the perspective of gcc (Ubuntu 7.3.0-21ubuntu1~16.04) 7.3.0.</p>\n<pre><code>#include &lt;cstdint&gt;\n#include &lt;iostream&gt;\n\nint main(void) {\n    std::cout &lt;&lt; \"int64_t...............: \"\n              &lt;&lt; \"(\" &lt;&lt; typeid(int64_t).name() &lt;&lt; \") \" &lt;&lt; sizeof(int64_t) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"long..................: \"\n              &lt;&lt; \"(\" &lt;&lt; typeid(long).name() &lt;&lt; \") \" &lt;&lt; sizeof(long) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"long int..............: \"\n              &lt;&lt; \"(\" &lt;&lt; typeid(long int).name() &lt;&lt; \") \" &lt;&lt; sizeof(long int) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"long long int.........: \"\n              &lt;&lt; \"(\" &lt;&lt; typeid(long long int).name() &lt;&lt; \") \" &lt;&lt; sizeof(long long int) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"long long.............: \"\n              &lt;&lt; \"(\" &lt;&lt; typeid(long long).name() &lt;&lt; \") \" &lt;&lt; sizeof(long long) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"uint64_t..............: \"\n              &lt;&lt; \"(\" &lt;&lt; typeid(uint64_t).name() &lt;&lt; \") \" &lt;&lt; sizeof(int64_t) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"unsigned long.........: \"\n              &lt;&lt; \"(\" &lt;&lt; typeid(unsigned long).name() &lt;&lt; \") \" &lt;&lt; sizeof(unsigned long) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"unsigned long int.....: \"\n              &lt;&lt; \"(\" &lt;&lt; typeid(unsigned long int).name() &lt;&lt; \") \" &lt;&lt; sizeof(unsigned long int) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"unsigned long long int: \"\n              &lt;&lt; \"(\" &lt;&lt; typeid(unsigned long long int).name() &lt;&lt; \") \" &lt;&lt; sizeof(unsigned long long int) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"unsigned long long....: \"\n              &lt;&lt; \"(\" &lt;&lt; typeid(unsigned long long).name() &lt;&lt; \") \" &lt;&lt; sizeof(unsigned long long) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"long long == int64_t? \" &lt;&lt; (std::is_same&lt;long long, int64_t&gt;::value ? \"yes\" : \"no\") &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"(sizeof(long long) == 8) &amp;&amp; std::is_signed&lt;long long&gt;::value? \"\n              &lt;&lt; ((sizeof(long long) == 8) &amp;&amp; std::is_signed&lt;long long&gt;::value ? \"yes\" : \"no\") &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"(sizeof(int64_t) == 8) &amp;&amp; std::is_signed&lt;int64_t&gt;::value? \"\n              &lt;&lt; ((sizeof(int64_t) == 8) &amp;&amp; std::is_signed&lt;int64_t&gt;::value ? \"yes\" : \"no\") &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"unsigned long long == uint64_t? \"\n              &lt;&lt; (std::is_same&lt;unsigned long long, uint64_t&gt;::value ? \"yes\" : \"no\") &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"(sizeof(unsigned long long) == 8) &amp;&amp; !std::is_signed&lt;unsigned long long&gt;::value? \"\n              &lt;&lt; ((sizeof(unsigned long long) == 8) &amp;&amp; !std::is_signed&lt;unsigned long long&gt;::value ? \"yes\" : \"no\")\n              &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"(sizeof(uint64_t) == 8) &amp;&amp; !std::is_signed&lt;uint64_t&gt;::value? \"\n              &lt;&lt; ((sizeof(uint64_t) == 8) &amp;&amp; !std::is_signed&lt;uint64_t&gt;::value ? \"yes\" : \"no\") &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<pre><code>int64_t...............: (l) 8\nlong..................: (l) 8\nlong int..............: (l) 8\nlong long int.........: (x) 8\nlong long.............: (x) 8\nuint64_t..............: (m) 8\nunsigned long.........: (m) 8\nunsigned long int.....: (m) 8\nunsigned long long int: (y) 8\nunsigned long long....: (y) 8\nlong long == int64_t? no\n(sizeof(long long) == 8) &amp;&amp; std::is_signed&lt;long long&gt;::value? yes\n(sizeof(int64_t) == 8) &amp;&amp; std::is_signed&lt;int64_t&gt;::value? yes\nunsigned long long == uint64_t? no\n(sizeof(unsigned long long) == 8) &amp;&amp; !std::is_signed&lt;unsigned long long&gt;::value? yes\n(sizeof(uint64_t) == 8) &amp;&amp; !std::is_signed&lt;uint64_t&gt;::value? yes\n</code></pre>\n<p>Note: <code>int64</code> is only used as an example here, this bug applies to other types as well, which this PR addresses.</p>", "body_text": "This PR addresses the bug outlined in #20586. Rather than relying on all systems to define the int64 data type in a manner that is consistent with a long long, this PR inspects the properties of the type. For instance, int64 is a signed, integral type with a size of 8 bytes.\nThis is important as not all systems define the basic integral data types in the same way, but they are all defined to meet the same intrinsic properties. On the test system, int64_t is not equivalent to a long long (which is how the int64 type is defined in tensorflow/core/platform/default/integral_types.h). However, both long long and int64_t meet the same intrinsic properties on the test system. The following code and output shows this inconsistency, where int64_t != long long from the perspective of gcc (Ubuntu 7.3.0-21ubuntu1~16.04) 7.3.0.\n#include <cstdint>\n#include <iostream>\n\nint main(void) {\n    std::cout << \"int64_t...............: \"\n              << \"(\" << typeid(int64_t).name() << \") \" << sizeof(int64_t) << std::endl;\n    std::cout << \"long..................: \"\n              << \"(\" << typeid(long).name() << \") \" << sizeof(long) << std::endl;\n    std::cout << \"long int..............: \"\n              << \"(\" << typeid(long int).name() << \") \" << sizeof(long int) << std::endl;\n    std::cout << \"long long int.........: \"\n              << \"(\" << typeid(long long int).name() << \") \" << sizeof(long long int) << std::endl;\n    std::cout << \"long long.............: \"\n              << \"(\" << typeid(long long).name() << \") \" << sizeof(long long) << std::endl;\n    std::cout << \"uint64_t..............: \"\n              << \"(\" << typeid(uint64_t).name() << \") \" << sizeof(int64_t) << std::endl;\n    std::cout << \"unsigned long.........: \"\n              << \"(\" << typeid(unsigned long).name() << \") \" << sizeof(unsigned long) << std::endl;\n    std::cout << \"unsigned long int.....: \"\n              << \"(\" << typeid(unsigned long int).name() << \") \" << sizeof(unsigned long int) << std::endl;\n    std::cout << \"unsigned long long int: \"\n              << \"(\" << typeid(unsigned long long int).name() << \") \" << sizeof(unsigned long long int) << std::endl;\n    std::cout << \"unsigned long long....: \"\n              << \"(\" << typeid(unsigned long long).name() << \") \" << sizeof(unsigned long long) << std::endl;\n    std::cout << \"long long == int64_t? \" << (std::is_same<long long, int64_t>::value ? \"yes\" : \"no\") << std::endl;\n    std::cout << \"(sizeof(long long) == 8) && std::is_signed<long long>::value? \"\n              << ((sizeof(long long) == 8) && std::is_signed<long long>::value ? \"yes\" : \"no\") << std::endl;\n    std::cout << \"(sizeof(int64_t) == 8) && std::is_signed<int64_t>::value? \"\n              << ((sizeof(int64_t) == 8) && std::is_signed<int64_t>::value ? \"yes\" : \"no\") << std::endl;\n    std::cout << \"unsigned long long == uint64_t? \"\n              << (std::is_same<unsigned long long, uint64_t>::value ? \"yes\" : \"no\") << std::endl;\n    std::cout << \"(sizeof(unsigned long long) == 8) && !std::is_signed<unsigned long long>::value? \"\n              << ((sizeof(unsigned long long) == 8) && !std::is_signed<unsigned long long>::value ? \"yes\" : \"no\")\n              << std::endl;\n    std::cout << \"(sizeof(uint64_t) == 8) && !std::is_signed<uint64_t>::value? \"\n              << ((sizeof(uint64_t) == 8) && !std::is_signed<uint64_t>::value ? \"yes\" : \"no\") << std::endl;\n    return 0;\n}\n\nint64_t...............: (l) 8\nlong..................: (l) 8\nlong int..............: (l) 8\nlong long int.........: (x) 8\nlong long.............: (x) 8\nuint64_t..............: (m) 8\nunsigned long.........: (m) 8\nunsigned long int.....: (m) 8\nunsigned long long int: (y) 8\nunsigned long long....: (y) 8\nlong long == int64_t? no\n(sizeof(long long) == 8) && std::is_signed<long long>::value? yes\n(sizeof(int64_t) == 8) && std::is_signed<int64_t>::value? yes\nunsigned long long == uint64_t? no\n(sizeof(unsigned long long) == 8) && !std::is_signed<unsigned long long>::value? yes\n(sizeof(uint64_t) == 8) && !std::is_signed<uint64_t>::value? yes\n\nNote: int64 is only used as an example here, this bug applies to other types as well, which this PR addresses.", "body": "This PR addresses the bug outlined in #20586. Rather than relying on all systems to define the `int64` data type in a manner that is consistent with a `long long`, this PR inspects the properties of the type. For instance, `int64` is a `signed`, `integral` type with a size of `8 bytes`.\r\n\r\nThis is important as not all systems define the basic integral data types in the same way, but they are all defined to meet the same intrinsic properties. On the test system, `int64_t` is not equivalent to a `long long` (which is how the `int64` type is defined in `tensorflow/core/platform/default/integral_types.h`). However, both `long long` and `int64_t` meet the same intrinsic properties on the test system. The following code and output shows this inconsistency, where `int64_t != long long` from the perspective of gcc (Ubuntu 7.3.0-21ubuntu1~16.04) 7.3.0.\r\n\r\n```\r\n#include <cstdint>\r\n#include <iostream>\r\n\r\nint main(void) {\r\n    std::cout << \"int64_t...............: \"\r\n              << \"(\" << typeid(int64_t).name() << \") \" << sizeof(int64_t) << std::endl;\r\n    std::cout << \"long..................: \"\r\n              << \"(\" << typeid(long).name() << \") \" << sizeof(long) << std::endl;\r\n    std::cout << \"long int..............: \"\r\n              << \"(\" << typeid(long int).name() << \") \" << sizeof(long int) << std::endl;\r\n    std::cout << \"long long int.........: \"\r\n              << \"(\" << typeid(long long int).name() << \") \" << sizeof(long long int) << std::endl;\r\n    std::cout << \"long long.............: \"\r\n              << \"(\" << typeid(long long).name() << \") \" << sizeof(long long) << std::endl;\r\n    std::cout << \"uint64_t..............: \"\r\n              << \"(\" << typeid(uint64_t).name() << \") \" << sizeof(int64_t) << std::endl;\r\n    std::cout << \"unsigned long.........: \"\r\n              << \"(\" << typeid(unsigned long).name() << \") \" << sizeof(unsigned long) << std::endl;\r\n    std::cout << \"unsigned long int.....: \"\r\n              << \"(\" << typeid(unsigned long int).name() << \") \" << sizeof(unsigned long int) << std::endl;\r\n    std::cout << \"unsigned long long int: \"\r\n              << \"(\" << typeid(unsigned long long int).name() << \") \" << sizeof(unsigned long long int) << std::endl;\r\n    std::cout << \"unsigned long long....: \"\r\n              << \"(\" << typeid(unsigned long long).name() << \") \" << sizeof(unsigned long long) << std::endl;\r\n    std::cout << \"long long == int64_t? \" << (std::is_same<long long, int64_t>::value ? \"yes\" : \"no\") << std::endl;\r\n    std::cout << \"(sizeof(long long) == 8) && std::is_signed<long long>::value? \"\r\n              << ((sizeof(long long) == 8) && std::is_signed<long long>::value ? \"yes\" : \"no\") << std::endl;\r\n    std::cout << \"(sizeof(int64_t) == 8) && std::is_signed<int64_t>::value? \"\r\n              << ((sizeof(int64_t) == 8) && std::is_signed<int64_t>::value ? \"yes\" : \"no\") << std::endl;\r\n    std::cout << \"unsigned long long == uint64_t? \"\r\n              << (std::is_same<unsigned long long, uint64_t>::value ? \"yes\" : \"no\") << std::endl;\r\n    std::cout << \"(sizeof(unsigned long long) == 8) && !std::is_signed<unsigned long long>::value? \"\r\n              << ((sizeof(unsigned long long) == 8) && !std::is_signed<unsigned long long>::value ? \"yes\" : \"no\")\r\n              << std::endl;\r\n    std::cout << \"(sizeof(uint64_t) == 8) && !std::is_signed<uint64_t>::value? \"\r\n              << ((sizeof(uint64_t) == 8) && !std::is_signed<uint64_t>::value ? \"yes\" : \"no\") << std::endl;\r\n    return 0;\r\n}\r\n```\r\n```\r\nint64_t...............: (l) 8\r\nlong..................: (l) 8\r\nlong int..............: (l) 8\r\nlong long int.........: (x) 8\r\nlong long.............: (x) 8\r\nuint64_t..............: (m) 8\r\nunsigned long.........: (m) 8\r\nunsigned long int.....: (m) 8\r\nunsigned long long int: (y) 8\r\nunsigned long long....: (y) 8\r\nlong long == int64_t? no\r\n(sizeof(long long) == 8) && std::is_signed<long long>::value? yes\r\n(sizeof(int64_t) == 8) && std::is_signed<int64_t>::value? yes\r\nunsigned long long == uint64_t? no\r\n(sizeof(unsigned long long) == 8) && !std::is_signed<unsigned long long>::value? yes\r\n(sizeof(uint64_t) == 8) && !std::is_signed<uint64_t>::value? yes\r\n```\r\n\r\n\r\nNote: `int64` is only used as an example here, this bug applies to other types as well, which this PR addresses."}