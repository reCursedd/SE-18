{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/21648", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/21648/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/21648/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/21648/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/21648", "id": 351052554, "node_id": "MDU6SXNzdWUzNTEwNTI1NTQ=", "number": 21648, "title": "ReadSavedModel & related operations should follow symlinks", "user": {"login": "masonk", "id": 449998, "node_id": "MDQ6VXNlcjQ0OTk5OA==", "avatar_url": "https://avatars0.githubusercontent.com/u/449998?v=4", "gravatar_id": "", "url": "https://api.github.com/users/masonk", "html_url": "https://github.com/masonk", "followers_url": "https://api.github.com/users/masonk/followers", "following_url": "https://api.github.com/users/masonk/following{/other_user}", "gists_url": "https://api.github.com/users/masonk/gists{/gist_id}", "starred_url": "https://api.github.com/users/masonk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/masonk/subscriptions", "organizations_url": "https://api.github.com/users/masonk/orgs", "repos_url": "https://api.github.com/users/masonk/repos", "events_url": "https://api.github.com/users/masonk/events{/privacy}", "received_events_url": "https://api.github.com/users/masonk/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 386191887, "node_id": "MDU6TGFiZWwzODYxOTE4ODc=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:awaiting%20response", "name": "stat:awaiting response", "color": "f4b400", "default": false}], "state": "closed", "locked": false, "assignee": {"login": "poxvoculi", "id": 15676913, "node_id": "MDQ6VXNlcjE1Njc2OTEz", "avatar_url": "https://avatars2.githubusercontent.com/u/15676913?v=4", "gravatar_id": "", "url": "https://api.github.com/users/poxvoculi", "html_url": "https://github.com/poxvoculi", "followers_url": "https://api.github.com/users/poxvoculi/followers", "following_url": "https://api.github.com/users/poxvoculi/following{/other_user}", "gists_url": "https://api.github.com/users/poxvoculi/gists{/gist_id}", "starred_url": "https://api.github.com/users/poxvoculi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/poxvoculi/subscriptions", "organizations_url": "https://api.github.com/users/poxvoculi/orgs", "repos_url": "https://api.github.com/users/poxvoculi/repos", "events_url": "https://api.github.com/users/poxvoculi/events{/privacy}", "received_events_url": "https://api.github.com/users/poxvoculi/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "poxvoculi", "id": 15676913, "node_id": "MDQ6VXNlcjE1Njc2OTEz", "avatar_url": "https://avatars2.githubusercontent.com/u/15676913?v=4", "gravatar_id": "", "url": "https://api.github.com/users/poxvoculi", "html_url": "https://github.com/poxvoculi", "followers_url": "https://api.github.com/users/poxvoculi/followers", "following_url": "https://api.github.com/users/poxvoculi/following{/other_user}", "gists_url": "https://api.github.com/users/poxvoculi/gists{/gist_id}", "starred_url": "https://api.github.com/users/poxvoculi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/poxvoculi/subscriptions", "organizations_url": "https://api.github.com/users/poxvoculi/orgs", "repos_url": "https://api.github.com/users/poxvoculi/repos", "events_url": "https://api.github.com/users/poxvoculi/events{/privacy}", "received_events_url": "https://api.github.com/users/poxvoculi/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 6, "created_at": "2018-08-16T04:36:51Z", "updated_at": "2018-08-19T22:49:00Z", "closed_at": "2018-08-19T22:48:37Z", "author_association": "NONE", "body_html": "<p><div class=\"border rounded-1 my-2\">\n  <div class=\"f6 px-3 py-2 lh-condensed border-bottom bg-gray-light\">\n    <p class=\"mb-0 text-bold\">\n      <a href=\"https://github.com/tensorflow/tensorflow/blob/98010279f40e4963512ba2f2f39c3d732aef7b93/tensorflow/cc/saved_model/reader.cc#L34\">tensorflow/tensorflow/cc/saved_model/reader.cc</a>\n    </p>\n    <p class=\"mb-0 text-gray-light\">\n         Line 34\n      in\n      <a data-pjax=\"true\" class=\"commit-tease-sha\" href=\"/tensorflow/tensorflow/commit/98010279f40e4963512ba2f2f39c3d732aef7b93\">9801027</a>\n    </p>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper blob-wrapper-embedded data\">\n    <table class=\"highlight tab-size mb-0 js-file-line-container\" data-tab-size=\"8\">\n\n        <tbody><tr class=\"border-0\">\n          <td id=\"L34\" class=\"blob-num border-0 px-3 py-0 bg-white js-line-number\" data-line-number=\"34\"></td>\n          <td id=\"LC34\" class=\"blob-code border-0 px-3 py-0 bg-white blob-code-inner js-file-line\"> <span class=\"pl-c1\">io::JoinPath</span>(export_dir, <span class=\"pl-c1\">kSavedModelFilenamePb</span>); </td>\n        </tr>\n    </tbody></table>\n  </div>\n</div>\n</p>\n<p>Consider that line, and now consider what happens if <code>export_dir</code> is the pathname of a symlink to a directory.</p>\n<p>The way I'm reading this, the naive file join will fail to find the kSavedModelFilenamePb file that the op is looking for, since it will be looking at <code>&lt;symlink&gt;/saved_model.pb</code> instead of <code>&lt;link_target&gt;/saved_model.pb</code> as (I think) would be logical.</p>\n<p>This came up for me recently. I have one process that's continually training and occasionally promoting a new version of the model to a SavedModel for inference in a second process. The second process runs concurrently and occasionally loads the latest SavedModel from disk.</p>\n<p>Atomically swapping a directory for another directory is either not possible on POSIX or, if it is possible, I couldn't find out a way from searching. However, it's easy to atomically swap the referent of a symlink. My naive hope was to maintain a symlink to the \"current best SavedModel\" which the second process would be able to use. The second process is Rust, and it's binding to the C API, which I traced all the way back to the linked line above.</p>\n<p>Admittedly this isn't extremely easy to fix (or maybe it's not possible to fix - not sure if holding a directory fd preserves the directory's contents from removal by another process). In order to be useful for my use case, doing the easy thing of resolving the symlink in one operation and then doing file joins wouldn't work, because the symlink is subject to swap to a new referent at any point of time, and that could happen between the resolution of the symlink and ops on the referents.</p>\n<p>Anyway, there is a workaround for this use case (some sort of file locking should do the trick). But, I wanted to point this out.</p>", "body_text": "tensorflow/tensorflow/cc/saved_model/reader.cc\n    \n    \n         Line 34\n      in\n      9801027\n    \n    \n    \n    \n\n        \n          \n           io::JoinPath(export_dir, kSavedModelFilenamePb); \n        \n    \n  \n\n\nConsider that line, and now consider what happens if export_dir is the pathname of a symlink to a directory.\nThe way I'm reading this, the naive file join will fail to find the kSavedModelFilenamePb file that the op is looking for, since it will be looking at <symlink>/saved_model.pb instead of <link_target>/saved_model.pb as (I think) would be logical.\nThis came up for me recently. I have one process that's continually training and occasionally promoting a new version of the model to a SavedModel for inference in a second process. The second process runs concurrently and occasionally loads the latest SavedModel from disk.\nAtomically swapping a directory for another directory is either not possible on POSIX or, if it is possible, I couldn't find out a way from searching. However, it's easy to atomically swap the referent of a symlink. My naive hope was to maintain a symlink to the \"current best SavedModel\" which the second process would be able to use. The second process is Rust, and it's binding to the C API, which I traced all the way back to the linked line above.\nAdmittedly this isn't extremely easy to fix (or maybe it's not possible to fix - not sure if holding a directory fd preserves the directory's contents from removal by another process). In order to be useful for my use case, doing the easy thing of resolving the symlink in one operation and then doing file joins wouldn't work, because the symlink is subject to swap to a new referent at any point of time, and that could happen between the resolution of the symlink and ops on the referents.\nAnyway, there is a workaround for this use case (some sort of file locking should do the trick). But, I wanted to point this out.", "body": "https://github.com/tensorflow/tensorflow/blob/98010279f40e4963512ba2f2f39c3d732aef7b93/tensorflow/cc/saved_model/reader.cc#L34\r\n\r\nConsider that line, and now consider what happens if `export_dir` is the pathname of a symlink to a directory.\r\n\r\nThe way I'm reading this, the naive file join will fail to find the kSavedModelFilenamePb file that the op is looking for, since it will be looking at `<symlink>/saved_model.pb` instead of `<link_target>/saved_model.pb` as (I think) would be logical.\r\n\r\nThis came up for me recently. I have one process that's continually training and occasionally promoting a new version of the model to a SavedModel for inference in a second process. The second process runs concurrently and occasionally loads the latest SavedModel from disk.\r\n\r\nAtomically swapping a directory for another directory is either not possible on POSIX or, if it is possible, I couldn't find out a way from searching. However, it's easy to atomically swap the referent of a symlink. My naive hope was to maintain a symlink to the \"current best SavedModel\" which the second process would be able to use. The second process is Rust, and it's binding to the C API, which I traced all the way back to the linked line above.\r\n\r\nAdmittedly this isn't extremely easy to fix (or maybe it's not possible to fix - not sure if holding a directory fd preserves the directory's contents from removal by another process). In order to be useful for my use case, doing the easy thing of resolving the symlink in one operation and then doing file joins wouldn't work, because the symlink is subject to swap to a new referent at any point of time, and that could happen between the resolution of the symlink and ops on the referents. \r\n\r\nAnyway, there is a workaround for this use case (some sort of file locking should do the trick). But, I wanted to point this out."}