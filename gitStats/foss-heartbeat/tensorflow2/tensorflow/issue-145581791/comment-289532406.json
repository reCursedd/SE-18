{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/289532406", "html_url": "https://github.com/tensorflow/tensorflow/issues/1763#issuecomment-289532406", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/1763", "id": 289532406, "node_id": "MDEyOklzc3VlQ29tbWVudDI4OTUzMjQwNg==", "user": {"login": "martinwicke", "id": 577277, "node_id": "MDQ6VXNlcjU3NzI3Nw==", "avatar_url": "https://avatars2.githubusercontent.com/u/577277?v=4", "gravatar_id": "", "url": "https://api.github.com/users/martinwicke", "html_url": "https://github.com/martinwicke", "followers_url": "https://api.github.com/users/martinwicke/followers", "following_url": "https://api.github.com/users/martinwicke/following{/other_user}", "gists_url": "https://api.github.com/users/martinwicke/gists{/gist_id}", "starred_url": "https://api.github.com/users/martinwicke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/martinwicke/subscriptions", "organizations_url": "https://api.github.com/users/martinwicke/orgs", "repos_url": "https://api.github.com/users/martinwicke/repos", "events_url": "https://api.github.com/users/martinwicke/events{/privacy}", "received_events_url": "https://api.github.com/users/martinwicke/received_events", "type": "User", "site_admin": false}, "created_at": "2017-03-27T17:55:18Z", "updated_at": "2017-03-27T17:55:18Z", "author_association": "MEMBER", "body_html": "<p>We have made a choice to consider image data encoded as integer types to be fixed-point data. As you say, you could go the other way. Both have issues: Mostly, our image pipelines work in float, which is slower. On the other hand, if we computed things in uint8 (or int16, or int32) we'd be dealing with overflows and underflows in the middle of processing pipelines, and you'd probably see a lot more poor results because of that.</p>\n<p>The fundamental problem is that some ops take the image values at face value (resize_image) when converting dtypes, while most don't (HSV2RGB, etc.). We cannot change much about the behavior because of compatibility constraints, but we can add an argument to resize_image to make it not convert to float and work in its input dtype only (there's no reason for it to convert to float).</p>", "body_text": "We have made a choice to consider image data encoded as integer types to be fixed-point data. As you say, you could go the other way. Both have issues: Mostly, our image pipelines work in float, which is slower. On the other hand, if we computed things in uint8 (or int16, or int32) we'd be dealing with overflows and underflows in the middle of processing pipelines, and you'd probably see a lot more poor results because of that.\nThe fundamental problem is that some ops take the image values at face value (resize_image) when converting dtypes, while most don't (HSV2RGB, etc.). We cannot change much about the behavior because of compatibility constraints, but we can add an argument to resize_image to make it not convert to float and work in its input dtype only (there's no reason for it to convert to float).", "body": "We have made a choice to consider image data encoded as integer types to be fixed-point data. As you say, you could go the other way. Both have issues: Mostly, our image pipelines work in float, which is slower. On the other hand, if we computed things in uint8 (or int16, or int32) we'd be dealing with overflows and underflows in the middle of processing pipelines, and you'd probably see a lot more poor results because of that.\r\n\r\nThe fundamental problem is that some ops take the image values at face value (resize_image) when converting dtypes, while most don't (HSV2RGB, etc.). We cannot change much about the behavior because of compatibility constraints, but we can add an argument to resize_image to make it not convert to float and work in its input dtype only (there's no reason for it to convert to float)."}