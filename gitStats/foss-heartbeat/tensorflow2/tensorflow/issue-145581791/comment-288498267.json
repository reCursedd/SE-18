{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/288498267", "html_url": "https://github.com/tensorflow/tensorflow/issues/1763#issuecomment-288498267", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/1763", "id": 288498267, "node_id": "MDEyOklzc3VlQ29tbWVudDI4ODQ5ODI2Nw==", "user": {"login": "martinwicke", "id": 577277, "node_id": "MDQ6VXNlcjU3NzI3Nw==", "avatar_url": "https://avatars2.githubusercontent.com/u/577277?v=4", "gravatar_id": "", "url": "https://api.github.com/users/martinwicke", "html_url": "https://github.com/martinwicke", "followers_url": "https://api.github.com/users/martinwicke/followers", "following_url": "https://api.github.com/users/martinwicke/following{/other_user}", "gists_url": "https://api.github.com/users/martinwicke/gists{/gist_id}", "starred_url": "https://api.github.com/users/martinwicke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/martinwicke/subscriptions", "organizations_url": "https://api.github.com/users/martinwicke/orgs", "repos_url": "https://api.github.com/users/martinwicke/repos", "events_url": "https://api.github.com/users/martinwicke/events{/privacy}", "received_events_url": "https://api.github.com/users/martinwicke/received_events", "type": "User", "site_admin": false}, "created_at": "2017-03-22T18:38:08Z", "updated_at": "2017-03-22T18:38:08Z", "author_association": "MEMBER", "body_html": "<p>In the presence of HDR images, scaling unconditionally to 0-1 for float inputs is not a good idea. What would you scale by? If a previous transformation incidentally left you with float data not in the range 0-1 (say, because you increased brightness by 10%), would you divide by 255? By the max?</p>\n<p>I disagree that this is a bug. Dealing with types in image processing is always annoying, especially in the presence of int8/uint8 anywhere in the pipeline. <code>convert_image_dtype</code> is a conversion function, not a scaling function. It converts between images encoded as fixed point images stored as integers and images encoded as floating point. It says as much in the docstring.</p>\n<p>There is, however, a bug in rescale_image, which should return the same dtype it ingested (preferred), or convert the dtype appropriately. This is different from the behavior of other image processing ops, who take care to return the same dtype they got. Sadly, here we do have the backwards compatibility problem, but I would say that this function should be deprecated in favor of a safe alternative. We could start by emitting a warning if it gets non-float input.</p>", "body_text": "In the presence of HDR images, scaling unconditionally to 0-1 for float inputs is not a good idea. What would you scale by? If a previous transformation incidentally left you with float data not in the range 0-1 (say, because you increased brightness by 10%), would you divide by 255? By the max?\nI disagree that this is a bug. Dealing with types in image processing is always annoying, especially in the presence of int8/uint8 anywhere in the pipeline. convert_image_dtype is a conversion function, not a scaling function. It converts between images encoded as fixed point images stored as integers and images encoded as floating point. It says as much in the docstring.\nThere is, however, a bug in rescale_image, which should return the same dtype it ingested (preferred), or convert the dtype appropriately. This is different from the behavior of other image processing ops, who take care to return the same dtype they got. Sadly, here we do have the backwards compatibility problem, but I would say that this function should be deprecated in favor of a safe alternative. We could start by emitting a warning if it gets non-float input.", "body": "In the presence of HDR images, scaling unconditionally to 0-1 for float inputs is not a good idea. What would you scale by? If a previous transformation incidentally left you with float data not in the range 0-1 (say, because you increased brightness by 10%), would you divide by 255? By the max?\r\n\r\nI disagree that this is a bug. Dealing with types in image processing is always annoying, especially in the presence of int8/uint8 anywhere in the pipeline. `convert_image_dtype` is a conversion function, not a scaling function. It converts between images encoded as fixed point images stored as integers and images encoded as floating point. It says as much in the docstring.\r\n\r\nThere is, however, a bug in rescale_image, which should return the same dtype it ingested (preferred), or convert the dtype appropriately. This is different from the behavior of other image processing ops, who take care to return the same dtype they got. Sadly, here we do have the backwards compatibility problem, but I would say that this function should be deprecated in favor of a safe alternative. We could start by emitting a warning if it gets non-float input."}