{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/288485912", "html_url": "https://github.com/tensorflow/tensorflow/issues/1763#issuecomment-288485912", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/1763", "id": 288485912, "node_id": "MDEyOklzc3VlQ29tbWVudDI4ODQ4NTkxMg==", "user": {"login": "ghost", "id": 10137, "node_id": "MDQ6VXNlcjEwMTM3", "avatar_url": "https://avatars3.githubusercontent.com/u/10137?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ghost", "html_url": "https://github.com/ghost", "followers_url": "https://api.github.com/users/ghost/followers", "following_url": "https://api.github.com/users/ghost/following{/other_user}", "gists_url": "https://api.github.com/users/ghost/gists{/gist_id}", "starred_url": "https://api.github.com/users/ghost/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ghost/subscriptions", "organizations_url": "https://api.github.com/users/ghost/orgs", "repos_url": "https://api.github.com/users/ghost/repos", "events_url": "https://api.github.com/users/ghost/events{/privacy}", "received_events_url": "https://api.github.com/users/ghost/received_events", "type": "User", "site_admin": false}, "created_at": "2017-03-22T17:58:36Z", "updated_at": "2017-03-22T17:58:36Z", "author_association": "NONE", "body_html": "<p>IMO, the bug here is not actually that it doesn't scale the range. The bug is that range scaling depends on the input type. I will go out on a limb and say that <em>a lot</em> of people get bit by this, and there are a lot of subpar models out there as a result. Some models are able to train around the lack of rescaling, some suffer an accuracy loss, especially if some kind of range-dependent mean centering and stddev normalization is introduced later in the chain.</p>\n<p>Here's a scenario we encountered: a preliminary version of our data augmentation code used nearest neighbor interpolation, which does not convert dtype when resampling. We would resample, crop, do a few other things, and then feed everything into convert_image_dtype(). At that time we actually inspected the output of convert_image_dtype() and verified it was doing the scaling.</p>\n<p>Then, one of our researchers changed to bilinear resizing earlier in the chain (which <em>does</em> convert dtype to float32, but does not rescale to [0-1.0)). This led to convert_image_dtype() being essentially a no-op, and much head scratching regarding why our model wasn't performing as well as it should.</p>\n<p>Long rage, opaque magic like this is bad design.</p>\n<p>Given that backward compat is an issue, at this point I think the most robust solution seems to be to permanently deprecate convert_image_dtype() and recommend that people use cast() and saturate_cast() instead, and handle range rescaling separately.</p>", "body_text": "IMO, the bug here is not actually that it doesn't scale the range. The bug is that range scaling depends on the input type. I will go out on a limb and say that a lot of people get bit by this, and there are a lot of subpar models out there as a result. Some models are able to train around the lack of rescaling, some suffer an accuracy loss, especially if some kind of range-dependent mean centering and stddev normalization is introduced later in the chain.\nHere's a scenario we encountered: a preliminary version of our data augmentation code used nearest neighbor interpolation, which does not convert dtype when resampling. We would resample, crop, do a few other things, and then feed everything into convert_image_dtype(). At that time we actually inspected the output of convert_image_dtype() and verified it was doing the scaling.\nThen, one of our researchers changed to bilinear resizing earlier in the chain (which does convert dtype to float32, but does not rescale to [0-1.0)). This led to convert_image_dtype() being essentially a no-op, and much head scratching regarding why our model wasn't performing as well as it should.\nLong rage, opaque magic like this is bad design.\nGiven that backward compat is an issue, at this point I think the most robust solution seems to be to permanently deprecate convert_image_dtype() and recommend that people use cast() and saturate_cast() instead, and handle range rescaling separately.", "body": "IMO, the bug here is not actually that it doesn't scale the range. The bug is that range scaling depends on the input type. I will go out on a limb and say that _a lot_ of people get bit by this, and there are a lot of subpar models out there as a result. Some models are able to train around the lack of rescaling, some suffer an accuracy loss, especially if some kind of range-dependent mean centering and stddev normalization is introduced later in the chain.\r\n\r\nHere's a scenario we encountered: a preliminary version of our data augmentation code used nearest neighbor interpolation, which does not convert dtype when resampling. We would resample, crop, do a few other things, and then feed everything into convert_image_dtype(). At that time we actually inspected the output of convert_image_dtype() and verified it was doing the scaling.\r\n\r\nThen, one of our researchers changed to bilinear resizing earlier in the chain (which _does_ convert dtype to float32, but does not rescale to [0-1.0)). This led to convert_image_dtype() being essentially a no-op, and much head scratching regarding why our model wasn't performing as well as it should.\r\n\r\nLong rage, opaque magic like this is bad design.\r\n\r\nGiven that backward compat is an issue, at this point I think the most robust solution seems to be to permanently deprecate convert_image_dtype() and recommend that people use cast() and saturate_cast() instead, and handle range rescaling separately."}