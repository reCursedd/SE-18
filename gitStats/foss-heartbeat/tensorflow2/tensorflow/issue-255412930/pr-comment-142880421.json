{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/142880421", "pull_request_review_id": 67294110, "id": 142880421, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE0Mjg4MDQyMQ==", "diff_hunk": "@@ -0,0 +1,115 @@\n+package org.tensorflow.processor.operator;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+import javax.annotation.processing.AbstractProcessor;\n+import javax.annotation.processing.Filer;\n+import javax.annotation.processing.Messager;\n+import javax.annotation.processing.ProcessingEnvironment;\n+import javax.annotation.processing.RoundEnvironment;\n+import javax.lang.model.SourceVersion;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.TypeElement;\n+import javax.tools.Diagnostic.Kind;\n+\n+public final class OperatorProcessor extends AbstractProcessor {\n+\n+  @Override\n+  public SourceVersion getSupportedSourceVersion() {\n+    return SourceVersion.latestSupported();\n+  }\n+\n+  @Override\n+  public synchronized void init(ProcessingEnvironment processingEnv) {\n+    super.init(processingEnv);\n+    messager = processingEnv.getMessager();\n+    filer = processingEnv.getFiler();\n+  }\n+\n+  @Override\n+  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+    // Nothing needs to be done at the end of all rounds.\n+    if (roundEnv.processingOver()) {\n+      return false;\n+    }\n+\n+    // Collect all classes tagged with our annotation.\n+    Set<TypeElement> opClasses = new HashSet<TypeElement>();\n+    for (TypeElement annotation : annotations) {\n+      if (!collectOpClasses(roundEnv, opClasses, annotation)) {\n+        return true;\n+      }\n+    }\n+\n+    // Nothing to do when there are no tagged classes.\n+    if (opClasses.isEmpty()) {\n+      return false;\n+    }\n+\n+    // TODO:(kbsriram) validate operator classes and generate Op API.\n+    writeApi();\n+    hasRun = true;\n+    return true;\n+  }\n+\n+  @Override\n+  public Set<String> getSupportedAnnotationTypes() {\n+    return Collections.singleton(String.format(\"%s.annotation.Operator\", OP_PACKAGE));\n+  }\n+\n+  private void writeApi() {\n+    // Generate an empty class for now and get the build working correctly. This will be changed to\n+    // generate the actual API once we've done with build-related changes.\n+    // TODO:(kbsriram)\n+    try (PrintWriter writer =\n+        new PrintWriter(filer.createSourceFile(String.format(\"%s.Ops\", OP_PACKAGE)).openWriter())) {\n+      writer.println(String.format(\"package %s;\", OP_PACKAGE));\n+      writer.println(\"public class Ops{}\");\n+    } catch (IOException e) {\n+      error(null, \"Unexpected failure generating API: %s\", e.getMessage());\n+    }\n+  }\n+\n+  private boolean collectOpClasses(\n+      RoundEnvironment roundEnv, Set<TypeElement> opClasses, TypeElement annotation) {\n+    boolean result = true;\n+    for (Element e : roundEnv.getElementsAnnotatedWith(annotation)) {\n+      // This processor has to aggregate all op classes in one round, as it generates a single Ops\n+      // API class which cannot be modified once generated. If we find an annotation after we've\n+      // generated our code, flag the location of each such class.\n+      if (hasRun) {", "path": "tensorflow/java/src/gen/java/org/tensorflow/processor/operator/OperatorProcessor.java", "position": null, "original_position": 83, "commit_id": "52009457ea7eaa97ea974915e75f0b052261b3f1", "original_commit_id": "da2e5bfdfcf919c8f7940cdd69865bcab835f08f", "user": {"login": "asimshankar", "id": 16018, "node_id": "MDQ6VXNlcjE2MDE4", "avatar_url": "https://avatars2.githubusercontent.com/u/16018?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asimshankar", "html_url": "https://github.com/asimshankar", "followers_url": "https://api.github.com/users/asimshankar/followers", "following_url": "https://api.github.com/users/asimshankar/following{/other_user}", "gists_url": "https://api.github.com/users/asimshankar/gists{/gist_id}", "starred_url": "https://api.github.com/users/asimshankar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asimshankar/subscriptions", "organizations_url": "https://api.github.com/users/asimshankar/orgs", "repos_url": "https://api.github.com/users/asimshankar/repos", "events_url": "https://api.github.com/users/asimshankar/events{/privacy}", "received_events_url": "https://api.github.com/users/asimshankar/received_events", "type": "User", "site_admin": false}, "body": "Instead of doing this in the loop, what about the following:\r\n\r\n- Make this method:\r\n\r\n```java\r\nprivate boolean collectOpClasses(Set<? extends Element> elements, Set<TypeElement> opClasses) {\r\n  for (Element e : elements) {\r\n    ...\r\n  }\r\n}\r\n```\r\n\r\n- Make the caller (`process`) do something like:\r\n\r\n```java\r\nassert annotations.size() == 0;\r\nSet<? extends Element> annotated = roundEnv.getElementsAnnotatedWith(annotation);\r\nif (annotated.size() == 0) {\r\n  return true;\r\n}\r\nif (annotated.size() > 0 && hasRun) {\r\n  // print error\r\n  return false;\r\n}\r\nif (!collectOpClasses(annotated, opClasses)) {\r\n  return false;\r\n}\r\n...\r\n```\r\n\r\nIt's essentially the same, but I think it makes the expected constraints clearer to follow. Though, it's possible you disagree :)", "created_at": "2017-10-05T08:44:45Z", "updated_at": "2017-10-10T14:02:07Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/12828#discussion_r142880421", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/12828", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/142880421"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/12828#discussion_r142880421"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/12828"}}, "body_html": "<p>Instead of doing this in the loop, what about the following:</p>\n<ul>\n<li>Make this method:</li>\n</ul>\n<div class=\"highlight highlight-source-java\"><pre><span class=\"pl-k\">private</span> <span class=\"pl-k\">boolean</span> collectOpClasses(<span class=\"pl-k\">Set&lt;? extends <span class=\"pl-smi\">Element</span>&gt;</span> elements, <span class=\"pl-k\">Set&lt;<span class=\"pl-smi\">TypeElement</span>&gt;</span> opClasses) {\n  <span class=\"pl-k\">for</span> (<span class=\"pl-smi\">Element</span> e <span class=\"pl-k\">:</span> elements) {\n    <span class=\"pl-c1\">...</span>\n  }\n}</pre></div>\n<ul>\n<li>Make the caller (<code>process</code>) do something like:</li>\n</ul>\n<div class=\"highlight highlight-source-java\"><pre><span class=\"pl-k\">assert</span> annotations<span class=\"pl-k\">.</span>size() <span class=\"pl-k\">==</span> <span class=\"pl-c1\">0</span>;\n<span class=\"pl-k\">Set&lt;? extends <span class=\"pl-smi\">Element</span>&gt;</span> annotated <span class=\"pl-k\">=</span> roundEnv<span class=\"pl-k\">.</span>getElementsAnnotatedWith(annotation);\n<span class=\"pl-k\">if</span> (annotated<span class=\"pl-k\">.</span>size() <span class=\"pl-k\">==</span> <span class=\"pl-c1\">0</span>) {\n  <span class=\"pl-k\">return</span> <span class=\"pl-c1\">true</span>;\n}\n<span class=\"pl-k\">if</span> (annotated<span class=\"pl-k\">.</span>size() <span class=\"pl-k\">&gt;</span> <span class=\"pl-c1\">0</span> <span class=\"pl-k\">&amp;&amp;</span> hasRun) {\n  <span class=\"pl-c\"><span class=\"pl-c\">//</span> print error</span>\n  <span class=\"pl-k\">return</span> <span class=\"pl-c1\">false</span>;\n}\n<span class=\"pl-k\">if</span> (<span class=\"pl-k\">!</span>collectOpClasses(annotated, opClasses)) {\n  <span class=\"pl-k\">return</span> <span class=\"pl-c1\">false</span>;\n}\n<span class=\"pl-c1\">...</span></pre></div>\n<p>It's essentially the same, but I think it makes the expected constraints clearer to follow. Though, it's possible you disagree :)</p>", "body_text": "Instead of doing this in the loop, what about the following:\n\nMake this method:\n\nprivate boolean collectOpClasses(Set<? extends Element> elements, Set<TypeElement> opClasses) {\n  for (Element e : elements) {\n    ...\n  }\n}\n\nMake the caller (process) do something like:\n\nassert annotations.size() == 0;\nSet<? extends Element> annotated = roundEnv.getElementsAnnotatedWith(annotation);\nif (annotated.size() == 0) {\n  return true;\n}\nif (annotated.size() > 0 && hasRun) {\n  // print error\n  return false;\n}\nif (!collectOpClasses(annotated, opClasses)) {\n  return false;\n}\n...\nIt's essentially the same, but I think it makes the expected constraints clearer to follow. Though, it's possible you disagree :)"}