{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/142878641", "pull_request_review_id": 67294110, "id": 142878641, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE0Mjg3ODY0MQ==", "diff_hunk": "@@ -0,0 +1,115 @@\n+package org.tensorflow.processor.operator;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+import javax.annotation.processing.AbstractProcessor;\n+import javax.annotation.processing.Filer;\n+import javax.annotation.processing.Messager;\n+import javax.annotation.processing.ProcessingEnvironment;\n+import javax.annotation.processing.RoundEnvironment;\n+import javax.lang.model.SourceVersion;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.TypeElement;\n+import javax.tools.Diagnostic.Kind;\n+\n+public final class OperatorProcessor extends AbstractProcessor {\n+\n+  @Override\n+  public SourceVersion getSupportedSourceVersion() {\n+    return SourceVersion.latestSupported();\n+  }\n+\n+  @Override\n+  public synchronized void init(ProcessingEnvironment processingEnv) {\n+    super.init(processingEnv);\n+    messager = processingEnv.getMessager();\n+    filer = processingEnv.getFiler();\n+  }\n+\n+  @Override\n+  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+    // Nothing needs to be done at the end of all rounds.\n+    if (roundEnv.processingOver()) {\n+      return false;\n+    }\n+\n+    // Collect all classes tagged with our annotation.\n+    Set<TypeElement> opClasses = new HashSet<TypeElement>();\n+    for (TypeElement annotation : annotations) {\n+      if (!collectOpClasses(roundEnv, opClasses, annotation)) {\n+        return true;\n+      }\n+    }\n+\n+    // Nothing to do when there are no tagged classes.\n+    if (opClasses.isEmpty()) {\n+      return false;\n+    }\n+\n+    // TODO:(kbsriram) validate operator classes and generate Op API.\n+    writeApi();\n+    hasRun = true;\n+    return true;\n+  }\n+\n+  @Override\n+  public Set<String> getSupportedAnnotationTypes() {\n+    return Collections.singleton(String.format(\"%s.annotation.Operator\", OP_PACKAGE));\n+  }\n+\n+  private void writeApi() {\n+    // Generate an empty class for now and get the build working correctly. This will be changed to\n+    // generate the actual API once we've done with build-related changes.\n+    // TODO:(kbsriram)\n+    try (PrintWriter writer =\n+        new PrintWriter(filer.createSourceFile(String.format(\"%s.Ops\", OP_PACKAGE)).openWriter())) {\n+      writer.println(String.format(\"package %s;\", OP_PACKAGE));\n+      writer.println(\"public class Ops{}\");\n+    } catch (IOException e) {\n+      error(null, \"Unexpected failure generating API: %s\", e.getMessage());\n+    }\n+  }\n+\n+  private boolean collectOpClasses(\n+      RoundEnvironment roundEnv, Set<TypeElement> opClasses, TypeElement annotation) {\n+    boolean result = true;\n+    for (Element e : roundEnv.getElementsAnnotatedWith(annotation)) {\n+      // This processor has to aggregate all op classes in one round, as it generates a single Ops\n+      // API class which cannot be modified once generated. If we find an annotation after we've\n+      // generated our code, flag the location of each such class.\n+      if (hasRun) {\n+        error(e, \"Cannot handle generated @Operators\");\n+        result = false;\n+        continue;\n+      }\n+\n+      // @Operator can only apply to types, so e must be a TypeElement.\n+      if (!(e instanceof TypeElement)) {\n+        error(e, \"@Operator can only be applied to classes\");\n+        result = false;\n+        continue;\n+      }\n+      opClasses.add((TypeElement) e);\n+    }\n+    return result;\n+  }\n+\n+  private void error(Element e, String message, Object... args) {\n+    message(Kind.ERROR, e, message, args);\n+  }\n+\n+  private void message(Kind kind, Element e, String msg, Object... args) {", "path": "tensorflow/java/src/gen/java/org/tensorflow/processor/operator/OperatorProcessor.java", "position": null, "original_position": 104, "commit_id": "52009457ea7eaa97ea974915e75f0b052261b3f1", "original_commit_id": "da2e5bfdfcf919c8f7940cdd69865bcab835f08f", "user": {"login": "asimshankar", "id": 16018, "node_id": "MDQ6VXNlcjE2MDE4", "avatar_url": "https://avatars2.githubusercontent.com/u/16018?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asimshankar", "html_url": "https://github.com/asimshankar", "followers_url": "https://api.github.com/users/asimshankar/followers", "following_url": "https://api.github.com/users/asimshankar/following{/other_user}", "gists_url": "https://api.github.com/users/asimshankar/gists{/gist_id}", "starred_url": "https://api.github.com/users/asimshankar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asimshankar/subscriptions", "organizations_url": "https://api.github.com/users/asimshankar/orgs", "repos_url": "https://api.github.com/users/asimshankar/repos", "events_url": "https://api.github.com/users/asimshankar/events{/privacy}", "received_events_url": "https://api.github.com/users/asimshankar/received_events", "type": "User", "site_admin": false}, "body": "Optional: If `message` is used only for `error`, perhaps inline it in `error`?", "created_at": "2017-10-05T08:35:44Z", "updated_at": "2017-10-10T14:02:07Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/12828#discussion_r142878641", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/12828", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/142878641"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/12828#discussion_r142878641"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/12828"}}, "body_html": "<p>Optional: If <code>message</code> is used only for <code>error</code>, perhaps inline it in <code>error</code>?</p>", "body_text": "Optional: If message is used only for error, perhaps inline it in error?"}