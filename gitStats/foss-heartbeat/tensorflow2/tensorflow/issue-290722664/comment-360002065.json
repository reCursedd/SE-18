{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/360002065", "html_url": "https://github.com/tensorflow/tensorflow/issues/16313#issuecomment-360002065", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/16313", "id": 360002065, "node_id": "MDEyOklzc3VlQ29tbWVudDM2MDAwMjA2NQ==", "user": {"login": "zhongxing9006", "id": 7303899, "node_id": "MDQ6VXNlcjczMDM4OTk=", "avatar_url": "https://avatars2.githubusercontent.com/u/7303899?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zhongxing9006", "html_url": "https://github.com/zhongxing9006", "followers_url": "https://api.github.com/users/zhongxing9006/followers", "following_url": "https://api.github.com/users/zhongxing9006/following{/other_user}", "gists_url": "https://api.github.com/users/zhongxing9006/gists{/gist_id}", "starred_url": "https://api.github.com/users/zhongxing9006/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zhongxing9006/subscriptions", "organizations_url": "https://api.github.com/users/zhongxing9006/orgs", "repos_url": "https://api.github.com/users/zhongxing9006/repos", "events_url": "https://api.github.com/users/zhongxing9006/events{/privacy}", "received_events_url": "https://api.github.com/users/zhongxing9006/received_events", "type": "User", "site_admin": false}, "created_at": "2018-01-24T02:39:30Z", "updated_at": "2018-01-24T02:39:52Z", "author_association": "NONE", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=789849\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/monomon\">@monomon</a>  I have already verified the value of input_dim and it is correct. I also use tf.TFRecordReader to read the dataset directly and it worked well.</p>\n<pre><code>def loadDataFromRecord(self, dataset_label, name = None):\n    with tf.variable_scope(\"batch_\"+name):\n        reader = tf.TFRecordReader()\n        dataset_dir = [self.dataset_dir[dataset_label]]\n        filename_queue = tf.train.string_input_producer(dataset_dir, shuffle=True, capacity=64)\n        _, serializedData = reader.read(filename_queue)\n        features = tf.parse_single_example(\n            serializedData,\n            features={\n                'image': tf.FixedLenFeature([], tf.string),\n                'label': tf.FixedLenFeature([], tf.int64) \n            })\n        image, label = features['image'], features['label']\n        height, width, channels = self.input_size, self.input_size, self.input_dim\n        image = tf.decode_raw(image, tf.uint8)\n        image = tf.reshape(image, [height, width, channels])\n        min_after_dequeue = 10000\n        capacity = min_after_dequeue + 3*self.batch_size\n        image_batch, label_batch = tf.train.shuffle_batch(\n            [image, label], batch_size=self.batch_size,\n            capacity=capacity, min_after_dequeue=min_after_dequeue)\n        image_batch = tf.reshape(image_batch, [self.batch_size, self.input_size, self.input_size, self.input_dim])\n        return image_batch, label_batch\n</code></pre>", "body_text": "@monomon  I have already verified the value of input_dim and it is correct. I also use tf.TFRecordReader to read the dataset directly and it worked well.\ndef loadDataFromRecord(self, dataset_label, name = None):\n    with tf.variable_scope(\"batch_\"+name):\n        reader = tf.TFRecordReader()\n        dataset_dir = [self.dataset_dir[dataset_label]]\n        filename_queue = tf.train.string_input_producer(dataset_dir, shuffle=True, capacity=64)\n        _, serializedData = reader.read(filename_queue)\n        features = tf.parse_single_example(\n            serializedData,\n            features={\n                'image': tf.FixedLenFeature([], tf.string),\n                'label': tf.FixedLenFeature([], tf.int64) \n            })\n        image, label = features['image'], features['label']\n        height, width, channels = self.input_size, self.input_size, self.input_dim\n        image = tf.decode_raw(image, tf.uint8)\n        image = tf.reshape(image, [height, width, channels])\n        min_after_dequeue = 10000\n        capacity = min_after_dequeue + 3*self.batch_size\n        image_batch, label_batch = tf.train.shuffle_batch(\n            [image, label], batch_size=self.batch_size,\n            capacity=capacity, min_after_dequeue=min_after_dequeue)\n        image_batch = tf.reshape(image_batch, [self.batch_size, self.input_size, self.input_size, self.input_dim])\n        return image_batch, label_batch", "body": "@monomon  I have already verified the value of input_dim and it is correct. I also use tf.TFRecordReader to read the dataset directly and it worked well.\r\n\r\n    def loadDataFromRecord(self, dataset_label, name = None):\r\n        with tf.variable_scope(\"batch_\"+name):\r\n            reader = tf.TFRecordReader()\r\n            dataset_dir = [self.dataset_dir[dataset_label]]\r\n            filename_queue = tf.train.string_input_producer(dataset_dir, shuffle=True, capacity=64)\r\n            _, serializedData = reader.read(filename_queue)\r\n            features = tf.parse_single_example(\r\n                serializedData,\r\n                features={\r\n                    'image': tf.FixedLenFeature([], tf.string),\r\n                    'label': tf.FixedLenFeature([], tf.int64) \r\n                })\r\n            image, label = features['image'], features['label']\r\n            height, width, channels = self.input_size, self.input_size, self.input_dim\r\n            image = tf.decode_raw(image, tf.uint8)\r\n            image = tf.reshape(image, [height, width, channels])\r\n            min_after_dequeue = 10000\r\n            capacity = min_after_dequeue + 3*self.batch_size\r\n            image_batch, label_batch = tf.train.shuffle_batch(\r\n                [image, label], batch_size=self.batch_size,\r\n                capacity=capacity, min_after_dequeue=min_after_dequeue)\r\n            image_batch = tf.reshape(image_batch, [self.batch_size, self.input_size, self.input_size, self.input_dim])\r\n            return image_batch, label_batch"}