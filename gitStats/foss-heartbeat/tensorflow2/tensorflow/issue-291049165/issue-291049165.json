{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/16343", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/16343/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/16343/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/16343/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/16343", "id": 291049165, "node_id": "MDU6SXNzdWUyOTEwNDkxNjU=", "number": 16343, "title": "tf.data.Dataset doesn't provide a good workflow for generating custom samples from large files", "user": {"login": "davidparks21", "id": 964997, "node_id": "MDQ6VXNlcjk2NDk5Nw==", "avatar_url": "https://avatars2.githubusercontent.com/u/964997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidparks21", "html_url": "https://github.com/davidparks21", "followers_url": "https://api.github.com/users/davidparks21/followers", "following_url": "https://api.github.com/users/davidparks21/following{/other_user}", "gists_url": "https://api.github.com/users/davidparks21/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidparks21/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidparks21/subscriptions", "organizations_url": "https://api.github.com/users/davidparks21/orgs", "repos_url": "https://api.github.com/users/davidparks21/repos", "events_url": "https://api.github.com/users/davidparks21/events{/privacy}", "received_events_url": "https://api.github.com/users/davidparks21/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 404586594, "node_id": "MDU6TGFiZWw0MDQ1ODY1OTQ=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:awaiting%20tensorflower", "name": "stat:awaiting tensorflower", "color": "f4b400", "default": false}, {"id": 473173272, "node_id": "MDU6TGFiZWw0NzMxNzMyNzI=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:feature", "name": "type:feature", "color": "159b2e", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 6, "created_at": "2018-01-24T01:03:55Z", "updated_at": "2018-03-09T17:38:37Z", "closed_at": "2018-03-09T17:38:37Z", "author_association": "NONE", "body_html": "<p>We're given hundreds of data files, each containing many gigabytes worth of sample data in a custom format. As far as I can tell there are only two approaches to extract samples from this using <code>Dataset</code>:</p>\n<ol>\n<li><code>tf.data.Dataset.from_generator(generator=my_custom_reader, ...)</code></li>\n</ol>\n<p>Create a generator which produces samples. This approach is not ideal because this method must be the first dataset in the chain. The generator cannot accept a tensor. Therefore you can't batch and shuffle your list of 100's of filenames (or anything more complex). You also can't make use of <code>interleave(...)</code> because the generator can't accept a tensor, and this use case is begging to use <code>interleave(...)</code>.</p>\n<p>A solution here might be to provide a method for a generator to accept a tensor, as <code>tf.py_func(...)</code> does for functions.</p>\n<ol start=\"2\">\n<li><code>tf.data.Dataset.map(map_func=tf.py_func(my_custom_reader, ...), ...)</code></li>\n</ol>\n<p>The map function does allow us to shuffle and parallelize the filenames using all of the functionality of the Dataset pipeline, however, with <code>map</code>, the files must be read into memory completely, and these files are large. Reading numerous files into memory is infeasible.</p>\n<p>A solution here might be to extend the <code>map</code> function to support generators.</p>\n<p>Unless there's an alternative approach, which I didn't glean from the docs or stackoverflow, then this seems to be an inherent limitation and a seemingly reasonable use case on which to base a feature request.</p>", "body_text": "We're given hundreds of data files, each containing many gigabytes worth of sample data in a custom format. As far as I can tell there are only two approaches to extract samples from this using Dataset:\n\ntf.data.Dataset.from_generator(generator=my_custom_reader, ...)\n\nCreate a generator which produces samples. This approach is not ideal because this method must be the first dataset in the chain. The generator cannot accept a tensor. Therefore you can't batch and shuffle your list of 100's of filenames (or anything more complex). You also can't make use of interleave(...) because the generator can't accept a tensor, and this use case is begging to use interleave(...).\nA solution here might be to provide a method for a generator to accept a tensor, as tf.py_func(...) does for functions.\n\ntf.data.Dataset.map(map_func=tf.py_func(my_custom_reader, ...), ...)\n\nThe map function does allow us to shuffle and parallelize the filenames using all of the functionality of the Dataset pipeline, however, with map, the files must be read into memory completely, and these files are large. Reading numerous files into memory is infeasible.\nA solution here might be to extend the map function to support generators.\nUnless there's an alternative approach, which I didn't glean from the docs or stackoverflow, then this seems to be an inherent limitation and a seemingly reasonable use case on which to base a feature request.", "body": "We're given hundreds of data files, each containing many gigabytes worth of sample data in a custom format. As far as I can tell there are only two approaches to extract samples from this using `Dataset`:\r\n\r\n1) `tf.data.Dataset.from_generator(generator=my_custom_reader, ...)`\r\n\r\nCreate a generator which produces samples. This approach is not ideal because this method must be the first dataset in the chain. The generator cannot accept a tensor. Therefore you can't batch and shuffle your list of 100's of filenames (or anything more complex). You also can't make use of `interleave(...)` because the generator can't accept a tensor, and this use case is begging to use `interleave(...)`.\r\n\r\nA solution here might be to provide a method for a generator to accept a tensor, as `tf.py_func(...)` does for functions.\r\n\r\n2) `tf.data.Dataset.map(map_func=tf.py_func(my_custom_reader, ...), ...)`\r\n\r\nThe map function does allow us to shuffle and parallelize the filenames using all of the functionality of the Dataset pipeline, however, with `map`, the files must be read into memory completely, and these files are large. Reading numerous files into memory is infeasible.\r\n\r\nA solution here might be to extend the `map` function to support generators.\r\n\r\nUnless there's an alternative approach, which I didn't glean from the docs or stackoverflow, then this seems to be an inherent limitation and a seemingly reasonable use case on which to base a feature request.\r\n"}