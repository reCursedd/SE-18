{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13780", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13780/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13780/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13780/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/13780", "id": 266081897, "node_id": "MDU6SXNzdWUyNjYwODE4OTc=", "number": 13780, "title": "I don't understand why I get these errors when i used dict () instead of { }. and how could I solve it?", "user": {"login": "Jennydariska", "id": 26027044, "node_id": "MDQ6VXNlcjI2MDI3MDQ0", "avatar_url": "https://avatars1.githubusercontent.com/u/26027044?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jennydariska", "html_url": "https://github.com/Jennydariska", "followers_url": "https://api.github.com/users/Jennydariska/followers", "following_url": "https://api.github.com/users/Jennydariska/following{/other_user}", "gists_url": "https://api.github.com/users/Jennydariska/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jennydariska/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jennydariska/subscriptions", "organizations_url": "https://api.github.com/users/Jennydariska/orgs", "repos_url": "https://api.github.com/users/Jennydariska/repos", "events_url": "https://api.github.com/users/Jennydariska/events{/privacy}", "received_events_url": "https://api.github.com/users/Jennydariska/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2017-10-17T11:00:46Z", "updated_at": "2017-10-18T19:19:12Z", "closed_at": "2017-10-18T19:19:12Z", "author_association": "NONE", "body_html": "<p>This is the code. is very similar to tensorflow tutorial but uses estimator instead of classifier .</p>\n<h1>6.  Definition del model</h1>\n<p>def model_fn1(features, labels, mode=None, params=None, config=None):<br>\n# 6.1. Connect the first hidden layer to the # (features[\"x\"]) with relu activation<br>\nhidden = tf.layers.dense(features[\"x\"], 10,<br>\nactivation=tf.nn.relu)</p>\n<pre><code># 6.2. Connect the second hidden layer to the first hidden with elu activation\nhidden1 = tf.layers.dense(hidden, 10, activation=tf.nn.relu)\n\n# 6.3. Connect output to the the second hidden layer without activation\nout_y = tf.layers.dense(hidden1, 22)\nout_y = tf.reshape(out_y, [-1, 22])\n\n# 6.4. Provide an estimator spec for `ModeKeys.PREDICT`.\nif mode == tf.estimator.ModeKeys.PREDICT:\n    return tf.estimator.EstimatorSpec(\n        mode=mode,\n        predictions={'': out_y})\n        #predictions = dict(out_y))\n\n# 6.5. Calculate loss using mean squared error and another approach\nloss = tf.losses.mean_squared_error(labels, out_y)\n\n# 6.6. Training sub-graph\noptimizer = tf.train.GradientDescentOptimizer(\n    learning_rate=0.01)\ntrain_op = optimizer.minimize(\n    loss=loss, global_step=tf.train.get_global_step())\n\n# 6.7 Calculate root mean squared error as additional eval metric\neval_metric_ops = {\n    \"rmse\": tf.metrics.root_mean_squared_error(\n        tf.cast(labels, tf.float64), out_y)\n}\n\n# 6.8. Provide an estimator spec for `ModeKeys.EVAL` and `ModeKeys.TRAIN` modes.\nreturn tf.estimator.EstimatorSpec(\n    mode=mode,\n    loss=loss,\n    train_op=train_op,\n    eval_metric_ops=eval_metric_ops)\n</code></pre>\n<h1>7. Creation of an estimator</h1>\n<p>estimator1 = tf.estimator.Estimator(model_fn=model_fn1, params=None,<br>\nmodel_dir='/home/jennydariska/targetDirectory/project_1/project1/test/')</p>\n<h1>8. Running of our model</h1>\n<p>with tf.Session() as session:</p>\n<pre><code>input_fn = tf.estimator.inputs.numpy_input_fn(x={\"x\": x_train}, y=y_train,\n                                              shuffle=True, num_epochs=None)\n\ntrain_input_fn = tf.estimator.inputs.numpy_input_fn(x={\"x\": x_train}, y=y_train,\n                                                    num_epochs=None, shuffle=False)\n\neval_input_fn = tf.estimator.inputs.numpy_input_fn(x={\"x\": x_eval}, y=y_eval,\n                                                   num_epochs=1, shuffle=False)\n# 8.1 Training of the estimator\nestimator1.train(input_fn=input_fn, steps=5000)\n\n# 8.2 Evaluation of how well our model did.\ntrain_metrics = estimator1.evaluate(input_fn=train_input_fn, steps=500)\neval_metrics = estimator1.evaluate(input_fn=eval_input_fn)\nprint(\"train metrics: %r\" % train_metrics)\nprint(\"eval metrics: %r\" % eval_metrics)\nprint(\"Loss: %s\" % eval_metrics[\"loss\"])\n\n# 8.3 Prediction for the news samples\npredict_input_fn = tf.estimator.inputs.numpy_input_fn(\n    x={\"x\": new_samples}, num_epochs=1,\n    shuffle=False)\n\npredictions = estimator1.predict(input_fn=predict_input_fn)\nprint(predictions)\n\nfor i in enumerate(predictions):\n    print(\"Prediction %s: \" % i )\n</code></pre>\n<p>`                                                                                                                                                                             when i use {}, i get this error:<br>\n&lt;ERROR:tensorflow:==================================<br>\nObject was never used (type &lt;class 'tensorflow.python.framework.ops.Tensor'&gt;):<br>\n&lt;tf.Tensor 'report_uninitialized_variables_1/boolean_mask/Gather:0' shape=(?,) dtype=string&gt;<br>\nIf you want to mark it as used call its \"mark_used()\" method.</p>\n<blockquote>\n</blockquote>\n<p>when i use dict(), i get this<br>\n&lt;TypeError: 'Tensor' object is not iterable.&gt;.I can not figure out where the problem lies</p>\n<blockquote>\n</blockquote>", "body_text": "This is the code. is very similar to tensorflow tutorial but uses estimator instead of classifier .\n6.  Definition del model\ndef model_fn1(features, labels, mode=None, params=None, config=None):\n# 6.1. Connect the first hidden layer to the # (features[\"x\"]) with relu activation\nhidden = tf.layers.dense(features[\"x\"], 10,\nactivation=tf.nn.relu)\n# 6.2. Connect the second hidden layer to the first hidden with elu activation\nhidden1 = tf.layers.dense(hidden, 10, activation=tf.nn.relu)\n\n# 6.3. Connect output to the the second hidden layer without activation\nout_y = tf.layers.dense(hidden1, 22)\nout_y = tf.reshape(out_y, [-1, 22])\n\n# 6.4. Provide an estimator spec for `ModeKeys.PREDICT`.\nif mode == tf.estimator.ModeKeys.PREDICT:\n    return tf.estimator.EstimatorSpec(\n        mode=mode,\n        predictions={'': out_y})\n        #predictions = dict(out_y))\n\n# 6.5. Calculate loss using mean squared error and another approach\nloss = tf.losses.mean_squared_error(labels, out_y)\n\n# 6.6. Training sub-graph\noptimizer = tf.train.GradientDescentOptimizer(\n    learning_rate=0.01)\ntrain_op = optimizer.minimize(\n    loss=loss, global_step=tf.train.get_global_step())\n\n# 6.7 Calculate root mean squared error as additional eval metric\neval_metric_ops = {\n    \"rmse\": tf.metrics.root_mean_squared_error(\n        tf.cast(labels, tf.float64), out_y)\n}\n\n# 6.8. Provide an estimator spec for `ModeKeys.EVAL` and `ModeKeys.TRAIN` modes.\nreturn tf.estimator.EstimatorSpec(\n    mode=mode,\n    loss=loss,\n    train_op=train_op,\n    eval_metric_ops=eval_metric_ops)\n\n7. Creation of an estimator\nestimator1 = tf.estimator.Estimator(model_fn=model_fn1, params=None,\nmodel_dir='/home/jennydariska/targetDirectory/project_1/project1/test/')\n8. Running of our model\nwith tf.Session() as session:\ninput_fn = tf.estimator.inputs.numpy_input_fn(x={\"x\": x_train}, y=y_train,\n                                              shuffle=True, num_epochs=None)\n\ntrain_input_fn = tf.estimator.inputs.numpy_input_fn(x={\"x\": x_train}, y=y_train,\n                                                    num_epochs=None, shuffle=False)\n\neval_input_fn = tf.estimator.inputs.numpy_input_fn(x={\"x\": x_eval}, y=y_eval,\n                                                   num_epochs=1, shuffle=False)\n# 8.1 Training of the estimator\nestimator1.train(input_fn=input_fn, steps=5000)\n\n# 8.2 Evaluation of how well our model did.\ntrain_metrics = estimator1.evaluate(input_fn=train_input_fn, steps=500)\neval_metrics = estimator1.evaluate(input_fn=eval_input_fn)\nprint(\"train metrics: %r\" % train_metrics)\nprint(\"eval metrics: %r\" % eval_metrics)\nprint(\"Loss: %s\" % eval_metrics[\"loss\"])\n\n# 8.3 Prediction for the news samples\npredict_input_fn = tf.estimator.inputs.numpy_input_fn(\n    x={\"x\": new_samples}, num_epochs=1,\n    shuffle=False)\n\npredictions = estimator1.predict(input_fn=predict_input_fn)\nprint(predictions)\n\nfor i in enumerate(predictions):\n    print(\"Prediction %s: \" % i )\n\n`                                                                                                                                                                             when i use {}, i get this error:\n<ERROR:tensorflow:==================================\nObject was never used (type <class 'tensorflow.python.framework.ops.Tensor'>):\n<tf.Tensor 'report_uninitialized_variables_1/boolean_mask/Gather:0' shape=(?,) dtype=string>\nIf you want to mark it as used call its \"mark_used()\" method.\n\n\nwhen i use dict(), i get this\n<TypeError: 'Tensor' object is not iterable.>.I can not figure out where the problem lies", "body": "This is the code. is very similar to tensorflow tutorial but uses estimator instead of classifier .                                  \r\n# 6.  Definition del model\r\ndef model_fn1(features, labels, mode=None, params=None, config=None):\r\n    # 6.1. Connect the first hidden layer to the # (features[\"x\"]) with relu activation\r\n    hidden = tf.layers.dense(features[\"x\"], 10,\r\n                             activation=tf.nn.relu)\r\n\r\n    # 6.2. Connect the second hidden layer to the first hidden with elu activation\r\n    hidden1 = tf.layers.dense(hidden, 10, activation=tf.nn.relu)\r\n\r\n    # 6.3. Connect output to the the second hidden layer without activation\r\n    out_y = tf.layers.dense(hidden1, 22)\r\n    out_y = tf.reshape(out_y, [-1, 22])\r\n\r\n    # 6.4. Provide an estimator spec for `ModeKeys.PREDICT`.\r\n    if mode == tf.estimator.ModeKeys.PREDICT:\r\n        return tf.estimator.EstimatorSpec(\r\n            mode=mode,\r\n            predictions={'': out_y})\r\n            #predictions = dict(out_y))\r\n\r\n    # 6.5. Calculate loss using mean squared error and another approach\r\n    loss = tf.losses.mean_squared_error(labels, out_y)\r\n\r\n    # 6.6. Training sub-graph\r\n    optimizer = tf.train.GradientDescentOptimizer(\r\n        learning_rate=0.01)\r\n    train_op = optimizer.minimize(\r\n        loss=loss, global_step=tf.train.get_global_step())\r\n\r\n    # 6.7 Calculate root mean squared error as additional eval metric\r\n    eval_metric_ops = {\r\n        \"rmse\": tf.metrics.root_mean_squared_error(\r\n            tf.cast(labels, tf.float64), out_y)\r\n    }\r\n\r\n    # 6.8. Provide an estimator spec for `ModeKeys.EVAL` and `ModeKeys.TRAIN` modes.\r\n    return tf.estimator.EstimatorSpec(\r\n        mode=mode,\r\n        loss=loss,\r\n        train_op=train_op,\r\n        eval_metric_ops=eval_metric_ops)\r\n\r\n\r\n# 7. Creation of an estimator\r\nestimator1 = tf.estimator.Estimator(model_fn=model_fn1, params=None,\r\n                                    model_dir='/home/jennydariska/targetDirectory/project_1/project1/test/')\r\n\r\n# 8. Running of our model\r\nwith tf.Session() as session:\r\n\r\n    input_fn = tf.estimator.inputs.numpy_input_fn(x={\"x\": x_train}, y=y_train,\r\n                                                  shuffle=True, num_epochs=None)\r\n\r\n    train_input_fn = tf.estimator.inputs.numpy_input_fn(x={\"x\": x_train}, y=y_train,\r\n                                                        num_epochs=None, shuffle=False)\r\n\r\n    eval_input_fn = tf.estimator.inputs.numpy_input_fn(x={\"x\": x_eval}, y=y_eval,\r\n                                                       num_epochs=1, shuffle=False)\r\n    # 8.1 Training of the estimator\r\n    estimator1.train(input_fn=input_fn, steps=5000)\r\n\r\n    # 8.2 Evaluation of how well our model did.\r\n    train_metrics = estimator1.evaluate(input_fn=train_input_fn, steps=500)\r\n    eval_metrics = estimator1.evaluate(input_fn=eval_input_fn)\r\n    print(\"train metrics: %r\" % train_metrics)\r\n    print(\"eval metrics: %r\" % eval_metrics)\r\n    print(\"Loss: %s\" % eval_metrics[\"loss\"])\r\n\r\n    # 8.3 Prediction for the news samples\r\n    predict_input_fn = tf.estimator.inputs.numpy_input_fn(\r\n        x={\"x\": new_samples}, num_epochs=1,\r\n        shuffle=False)\r\n\r\n    predictions = estimator1.predict(input_fn=predict_input_fn)\r\n    print(predictions)\r\n\r\n    for i in enumerate(predictions):\r\n        print(\"Prediction %s: \" % i )\r\n`                                                                                                                                                                             when i use {}, i get this error: \r\n<ERROR:tensorflow:==================================\r\nObject was never used (type <class 'tensorflow.python.framework.ops.Tensor'>):\r\n<tf.Tensor 'report_uninitialized_variables_1/boolean_mask/Gather:0' shape=(?,) dtype=string>\r\nIf you want to mark it as used call its \"mark_used()\" method.\r\n>  \r\n when i use dict(), i get this \r\n<TypeError: 'Tensor' object is not iterable.>.I can not figure out where the problem lies\r\n\r\n> "}