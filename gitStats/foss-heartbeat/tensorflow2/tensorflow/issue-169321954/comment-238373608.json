{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/238373608", "html_url": "https://github.com/tensorflow/tensorflow/issues/3638#issuecomment-238373608", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/3638", "id": 238373608, "node_id": "MDEyOklzc3VlQ29tbWVudDIzODM3MzYwOA==", "user": {"login": "zheng-xq", "id": 15736910, "node_id": "MDQ6VXNlcjE1NzM2OTEw", "avatar_url": "https://avatars0.githubusercontent.com/u/15736910?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zheng-xq", "html_url": "https://github.com/zheng-xq", "followers_url": "https://api.github.com/users/zheng-xq/followers", "following_url": "https://api.github.com/users/zheng-xq/following{/other_user}", "gists_url": "https://api.github.com/users/zheng-xq/gists{/gist_id}", "starred_url": "https://api.github.com/users/zheng-xq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zheng-xq/subscriptions", "organizations_url": "https://api.github.com/users/zheng-xq/orgs", "repos_url": "https://api.github.com/users/zheng-xq/repos", "events_url": "https://api.github.com/users/zheng-xq/events{/privacy}", "received_events_url": "https://api.github.com/users/zheng-xq/received_events", "type": "User", "site_admin": false}, "created_at": "2016-08-08T20:53:30Z", "updated_at": "2016-08-08T20:53:30Z", "author_association": "CONTRIBUTOR", "body_html": "<p>If someone really wants to have this kernel report errors, here are some more details:</p>\n<ol>\n<li>Add non-default attribute so the kernel can optional synchronize with GPU and check errors.</li>\n<li>A more TensorFlow way is to change the kernel AsyncOpKernel, and check the errors and call \"done\" through ThenExecute. That way, the current thread is released to do other work. But ops following gather still cannot issue.</li>\n<li>Still use the sync OpKernel, schedule ThenExecute to check for the error. The down-side is the context is long gone at that point. So you can print out enough error message and crash the process with LOG(FATAL).</li>\n</ol>\n<p>I will leave it up to the contributor/developer to choose from those. But it is important that by default, we don't synchronize and hold off other kernel launches unnecessarily.</p>", "body_text": "If someone really wants to have this kernel report errors, here are some more details:\n\nAdd non-default attribute so the kernel can optional synchronize with GPU and check errors.\nA more TensorFlow way is to change the kernel AsyncOpKernel, and check the errors and call \"done\" through ThenExecute. That way, the current thread is released to do other work. But ops following gather still cannot issue.\nStill use the sync OpKernel, schedule ThenExecute to check for the error. The down-side is the context is long gone at that point. So you can print out enough error message and crash the process with LOG(FATAL).\n\nI will leave it up to the contributor/developer to choose from those. But it is important that by default, we don't synchronize and hold off other kernel launches unnecessarily.", "body": "If someone really wants to have this kernel report errors, here are some more details:\n1. Add non-default attribute so the kernel can optional synchronize with GPU and check errors. \n2. A more TensorFlow way is to change the kernel AsyncOpKernel, and check the errors and call \"done\" through ThenExecute. That way, the current thread is released to do other work. But ops following gather still cannot issue. \n3. Still use the sync OpKernel, schedule ThenExecute to check for the error. The down-side is the context is long gone at that point. So you can print out enough error message and crash the process with LOG(FATAL). \n\nI will leave it up to the contributor/developer to choose from those. But it is important that by default, we don't synchronize and hold off other kernel launches unnecessarily. \n"}