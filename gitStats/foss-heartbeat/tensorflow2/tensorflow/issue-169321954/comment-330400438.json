{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/330400438", "html_url": "https://github.com/tensorflow/tensorflow/issues/3638#issuecomment-330400438", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/3638", "id": 330400438, "node_id": "MDEyOklzc3VlQ29tbWVudDMzMDQwMDQzOA==", "user": {"login": "MattShannon", "id": 752825, "node_id": "MDQ6VXNlcjc1MjgyNQ==", "avatar_url": "https://avatars0.githubusercontent.com/u/752825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/MattShannon", "html_url": "https://github.com/MattShannon", "followers_url": "https://api.github.com/users/MattShannon/followers", "following_url": "https://api.github.com/users/MattShannon/following{/other_user}", "gists_url": "https://api.github.com/users/MattShannon/gists{/gist_id}", "starred_url": "https://api.github.com/users/MattShannon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/MattShannon/subscriptions", "organizations_url": "https://api.github.com/users/MattShannon/orgs", "repos_url": "https://api.github.com/users/MattShannon/repos", "events_url": "https://api.github.com/users/MattShannon/events{/privacy}", "received_events_url": "https://api.github.com/users/MattShannon/received_events", "type": "User", "site_admin": false}, "created_at": "2017-09-19T01:22:08Z", "updated_at": "2017-09-19T01:23:51Z", "author_association": "NONE", "body_html": "<p>What about unifying the GPU and CPU implementations of gather by always returning 0 for out-of-bound indices, then having a separate op which checks indices with a CPU-only implementation? That way you get consistent behavior, error propagation if desired and a clean interface.</p>\n<p>That would also allow \"conditional gather\"-type operations relatively easily, where a default value is used for indices that are out of range, such as:</p>\n<p>tf.gather(xs, indices) + (indices &gt;= tf.shape(xs)[0]) * 2.0</p>\n<p>At the moment performing conditional gather operations like this are tricky on the CPU, since error checking is always done (unless this can be done with another op I'm not aware of?)</p>", "body_text": "What about unifying the GPU and CPU implementations of gather by always returning 0 for out-of-bound indices, then having a separate op which checks indices with a CPU-only implementation? That way you get consistent behavior, error propagation if desired and a clean interface.\nThat would also allow \"conditional gather\"-type operations relatively easily, where a default value is used for indices that are out of range, such as:\ntf.gather(xs, indices) + (indices >= tf.shape(xs)[0]) * 2.0\nAt the moment performing conditional gather operations like this are tricky on the CPU, since error checking is always done (unless this can be done with another op I'm not aware of?)", "body": "What about unifying the GPU and CPU implementations of gather by always returning 0 for out-of-bound indices, then having a separate op which checks indices with a CPU-only implementation? That way you get consistent behavior, error propagation if desired and a clean interface.\r\n\r\nThat would also allow \"conditional gather\"-type operations relatively easily, where a default value is used for indices that are out of range, such as:\r\n\r\ntf.gather(xs, indices) + (indices >= tf.shape(xs)[0]) * 2.0\r\n\r\nAt the moment performing conditional gather operations like this are tricky on the CPU, since error checking is always done (unless this can be done with another op I'm not aware of?)"}