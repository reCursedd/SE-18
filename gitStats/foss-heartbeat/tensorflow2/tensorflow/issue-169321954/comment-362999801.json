{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/362999801", "html_url": "https://github.com/tensorflow/tensorflow/issues/3638#issuecomment-362999801", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/3638", "id": 362999801, "node_id": "MDEyOklzc3VlQ29tbWVudDM2Mjk5OTgwMQ==", "user": {"login": "MattShannon", "id": 752825, "node_id": "MDQ6VXNlcjc1MjgyNQ==", "avatar_url": "https://avatars0.githubusercontent.com/u/752825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/MattShannon", "html_url": "https://github.com/MattShannon", "followers_url": "https://api.github.com/users/MattShannon/followers", "following_url": "https://api.github.com/users/MattShannon/following{/other_user}", "gists_url": "https://api.github.com/users/MattShannon/gists{/gist_id}", "starred_url": "https://api.github.com/users/MattShannon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/MattShannon/subscriptions", "organizations_url": "https://api.github.com/users/MattShannon/orgs", "repos_url": "https://api.github.com/users/MattShannon/repos", "events_url": "https://api.github.com/users/MattShannon/events{/privacy}", "received_events_url": "https://api.github.com/users/MattShannon/received_events", "type": "User", "site_admin": false}, "created_at": "2018-02-05T07:15:05Z", "updated_at": "2018-02-05T07:15:53Z", "author_association": "NONE", "body_html": "<p>My idea was that there are two ops. The gather op is changed to be forgiving, i.e. for both GPU and CPU it returns zero whenever an index is out-of-bounds. A separate op (say \"check_indices\") with only a CPU implementation determines whether the gather is \"valid\" (i.e. no out-of-bounds lookups, in the same way that the current CPU implementation does, iiuc).</p>\n<p>For some applications, forgiving gather is exactly what you want. It is simple to turn this into something which uses a user-specified default value instead of 0, using something like the code snippet above. Afaict, forgiving gather is currently quite hard to effect in tensorflow.</p>\n<p>tf.gather can be implemented in terms of forgiving gather and check_indices. This preserves the current CPU behavior, and extends that to the GPU case, fixing this bug.</p>", "body_text": "My idea was that there are two ops. The gather op is changed to be forgiving, i.e. for both GPU and CPU it returns zero whenever an index is out-of-bounds. A separate op (say \"check_indices\") with only a CPU implementation determines whether the gather is \"valid\" (i.e. no out-of-bounds lookups, in the same way that the current CPU implementation does, iiuc).\nFor some applications, forgiving gather is exactly what you want. It is simple to turn this into something which uses a user-specified default value instead of 0, using something like the code snippet above. Afaict, forgiving gather is currently quite hard to effect in tensorflow.\ntf.gather can be implemented in terms of forgiving gather and check_indices. This preserves the current CPU behavior, and extends that to the GPU case, fixing this bug.", "body": "My idea was that there are two ops. The gather op is changed to be forgiving, i.e. for both GPU and CPU it returns zero whenever an index is out-of-bounds. A separate op (say \"check_indices\") with only a CPU implementation determines whether the gather is \"valid\" (i.e. no out-of-bounds lookups, in the same way that the current CPU implementation does, iiuc).\r\n\r\nFor some applications, forgiving gather is exactly what you want. It is simple to turn this into something which uses a user-specified default value instead of 0, using something like the code snippet above. Afaict, forgiving gather is currently quite hard to effect in tensorflow.\r\n\r\ntf.gather can be implemented in terms of forgiving gather and check_indices. This preserves the current CPU behavior, and extends that to the GPU case, fixing this bug."}