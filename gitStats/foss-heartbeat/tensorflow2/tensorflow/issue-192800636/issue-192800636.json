{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/6007", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/6007/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/6007/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/6007/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/6007", "id": 192800636, "node_id": "MDU6SXNzdWUxOTI4MDA2MzY=", "number": 6007, "title": "tf.name_scope with reuse", "user": {"login": "albertz", "id": 59132, "node_id": "MDQ6VXNlcjU5MTMy", "avatar_url": "https://avatars0.githubusercontent.com/u/59132?v=4", "gravatar_id": "", "url": "https://api.github.com/users/albertz", "html_url": "https://github.com/albertz", "followers_url": "https://api.github.com/users/albertz/followers", "following_url": "https://api.github.com/users/albertz/following{/other_user}", "gists_url": "https://api.github.com/users/albertz/gists{/gist_id}", "starred_url": "https://api.github.com/users/albertz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/albertz/subscriptions", "organizations_url": "https://api.github.com/users/albertz/orgs", "repos_url": "https://api.github.com/users/albertz/repos", "events_url": "https://api.github.com/users/albertz/events{/privacy}", "received_events_url": "https://api.github.com/users/albertz/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": {"login": "lukaszkaiser", "id": 684901, "node_id": "MDQ6VXNlcjY4NDkwMQ==", "avatar_url": "https://avatars1.githubusercontent.com/u/684901?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lukaszkaiser", "html_url": "https://github.com/lukaszkaiser", "followers_url": "https://api.github.com/users/lukaszkaiser/followers", "following_url": "https://api.github.com/users/lukaszkaiser/following{/other_user}", "gists_url": "https://api.github.com/users/lukaszkaiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/lukaszkaiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lukaszkaiser/subscriptions", "organizations_url": "https://api.github.com/users/lukaszkaiser/orgs", "repos_url": "https://api.github.com/users/lukaszkaiser/repos", "events_url": "https://api.github.com/users/lukaszkaiser/events{/privacy}", "received_events_url": "https://api.github.com/users/lukaszkaiser/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "lukaszkaiser", "id": 684901, "node_id": "MDQ6VXNlcjY4NDkwMQ==", "avatar_url": "https://avatars1.githubusercontent.com/u/684901?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lukaszkaiser", "html_url": "https://github.com/lukaszkaiser", "followers_url": "https://api.github.com/users/lukaszkaiser/followers", "following_url": "https://api.github.com/users/lukaszkaiser/following{/other_user}", "gists_url": "https://api.github.com/users/lukaszkaiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/lukaszkaiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lukaszkaiser/subscriptions", "organizations_url": "https://api.github.com/users/lukaszkaiser/orgs", "repos_url": "https://api.github.com/users/lukaszkaiser/repos", "events_url": "https://api.github.com/users/lukaszkaiser/events{/privacy}", "received_events_url": "https://api.github.com/users/lukaszkaiser/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 23, "created_at": "2016-12-01T10:00:10Z", "updated_at": "2017-08-07T13:30:45Z", "closed_at": "2016-12-07T21:58:53Z", "author_association": "NONE", "body_html": "<p>I want to reuse a name scope which was created earlier with <code>tf.name_scope</code>. Normally, name_scope will create a new unique name in the current namespace. If it ends with \"/\", it will ignore the current namespace and use it as an absolute name scope but then it doesn't make it unique. I want a way that it just uses the name as I provide it in the current namespace.</p>\n<p>Current code:</p>\n<pre><code>  @contextlib.contextmanager\n  def name_scope(self, name):\n      ...\n      old_stack = self._name_stack\n      if not name:  # Both for name=None and name=\"\" we re-set to empty scope.\n        new_stack = None\n      elif name and name[-1] == \"/\":\n        new_stack = name[:-1]\n      else:\n        new_stack = self.unique_name(name)\n      self._name_stack = new_stack\n      yield \"\" if new_stack is None else new_stack + \"/\"\n</code></pre>\n<p>I suggest something like:</p>\n<pre><code>  @contextlib.contextmanager\n  def name_scope(self, name, reuse=False):\n    if reuse:\n      new_stack = self._name_stack + \"/\" + name\n    else:\n      ...\n</code></pre>", "body_text": "I want to reuse a name scope which was created earlier with tf.name_scope. Normally, name_scope will create a new unique name in the current namespace. If it ends with \"/\", it will ignore the current namespace and use it as an absolute name scope but then it doesn't make it unique. I want a way that it just uses the name as I provide it in the current namespace.\nCurrent code:\n  @contextlib.contextmanager\n  def name_scope(self, name):\n      ...\n      old_stack = self._name_stack\n      if not name:  # Both for name=None and name=\"\" we re-set to empty scope.\n        new_stack = None\n      elif name and name[-1] == \"/\":\n        new_stack = name[:-1]\n      else:\n        new_stack = self.unique_name(name)\n      self._name_stack = new_stack\n      yield \"\" if new_stack is None else new_stack + \"/\"\n\nI suggest something like:\n  @contextlib.contextmanager\n  def name_scope(self, name, reuse=False):\n    if reuse:\n      new_stack = self._name_stack + \"/\" + name\n    else:\n      ...", "body": "I want to reuse a name scope which was created earlier with `tf.name_scope`. Normally, name_scope will create a new unique name in the current namespace. If it ends with \"/\", it will ignore the current namespace and use it as an absolute name scope but then it doesn't make it unique. I want a way that it just uses the name as I provide it in the current namespace.\r\n\r\nCurrent code:\r\n```\r\n  @contextlib.contextmanager\r\n  def name_scope(self, name):\r\n      ...\r\n      old_stack = self._name_stack\r\n      if not name:  # Both for name=None and name=\"\" we re-set to empty scope.\r\n        new_stack = None\r\n      elif name and name[-1] == \"/\":\r\n        new_stack = name[:-1]\r\n      else:\r\n        new_stack = self.unique_name(name)\r\n      self._name_stack = new_stack\r\n      yield \"\" if new_stack is None else new_stack + \"/\"\r\n```\r\n\r\nI suggest something like:\r\n\r\n```\r\n  @contextlib.contextmanager\r\n  def name_scope(self, name, reuse=False):\r\n    if reuse:\r\n      new_stack = self._name_stack + \"/\" + name\r\n    else:\r\n      ...\r\n```\r\n"}