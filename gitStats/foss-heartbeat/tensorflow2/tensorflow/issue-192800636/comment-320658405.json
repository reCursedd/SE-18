{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/320658405", "html_url": "https://github.com/tensorflow/tensorflow/issues/6007#issuecomment-320658405", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/6007", "id": 320658405, "node_id": "MDEyOklzc3VlQ29tbWVudDMyMDY1ODQwNQ==", "user": {"login": "cheind", "id": 38565, "node_id": "MDQ6VXNlcjM4NTY1", "avatar_url": "https://avatars0.githubusercontent.com/u/38565?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cheind", "html_url": "https://github.com/cheind", "followers_url": "https://api.github.com/users/cheind/followers", "following_url": "https://api.github.com/users/cheind/following{/other_user}", "gists_url": "https://api.github.com/users/cheind/gists{/gist_id}", "starred_url": "https://api.github.com/users/cheind/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cheind/subscriptions", "organizations_url": "https://api.github.com/users/cheind/orgs", "repos_url": "https://api.github.com/users/cheind/repos", "events_url": "https://api.github.com/users/cheind/events{/privacy}", "received_events_url": "https://api.github.com/users/cheind/received_events", "type": "User", "site_admin": false}, "created_at": "2017-08-07T13:07:54Z", "updated_at": "2017-08-07T13:30:45Z", "author_association": "NONE", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=59132\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/albertz\">@albertz</a>, <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=1098280\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/javidcf\">@javidcf</a> I was following your discussion here, as I've been also interested in re-opening name scopes. Here's a bit of warning though (<del>without having studied your implementations</del>). When you add <code>/</code> to your name scope names, TF will interpret the name scope as absolute path, ignoring any parental name-scopes that you are currently in. This can be quite suprising. Here's a short example that illustrates the issue.</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">import</span> tensorflow <span class=\"pl-k\">as</span> tf\n\n<span class=\"pl-k\">with</span> tf.Graph().as_default() <span class=\"pl-k\">as</span> g:\n   <span class=\"pl-k\">with</span> g.name_scope(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>parent<span class=\"pl-pds\">'</span></span>):\n       <span class=\"pl-k\">with</span> g.name_scope(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>nested<span class=\"pl-pds\">'</span></span>):\n           x <span class=\"pl-k\">=</span> tf.placeholder(<span class=\"pl-v\">dtype</span><span class=\"pl-k\">=</span>tf.float32, <span class=\"pl-v\">name</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>x<span class=\"pl-pds\">'</span></span>)\n           <span class=\"pl-c1\">print</span>(x.name)\n       <span class=\"pl-k\">with</span> g.name_scope(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>nested<span class=\"pl-pds\">'</span></span>):\n           y <span class=\"pl-k\">=</span> tf.placeholder(<span class=\"pl-v\">dtype</span><span class=\"pl-k\">=</span>tf.float32, <span class=\"pl-v\">name</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>y<span class=\"pl-pds\">'</span></span>)\n           <span class=\"pl-c1\">print</span>(y.name)\n       <span class=\"pl-k\">with</span> g.name_scope(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>nested/<span class=\"pl-pds\">'</span></span>):\n           z <span class=\"pl-k\">=</span> tf.placeholder(<span class=\"pl-v\">dtype</span><span class=\"pl-k\">=</span>tf.float32, <span class=\"pl-v\">name</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>z<span class=\"pl-pds\">'</span></span>)\n           <span class=\"pl-c1\">print</span>(z.name)\n   \n<span class=\"pl-c\"><span class=\"pl-c\">#</span> Gives</span>\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> parent/nested/x:0</span>\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> parent/nested_1/y:0</span>\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> nested/z:0</span></pre></div>\n<p>Although no suffix was added to <code>nested</code> name scope, it lost the parental relationship to <code>parent</code>. Especially in complex architectures, you never know which name-scopes have been opened outside of your function (e.g to instance your network twice under different names).</p>\n<p><strong>Update</strong> Ok, seems like your code accounts for that by prepending the current name scope</p>", "body_text": "@albertz, @javidcf I was following your discussion here, as I've been also interested in re-opening name scopes. Here's a bit of warning though (without having studied your implementations). When you add / to your name scope names, TF will interpret the name scope as absolute path, ignoring any parental name-scopes that you are currently in. This can be quite suprising. Here's a short example that illustrates the issue.\nimport tensorflow as tf\n\nwith tf.Graph().as_default() as g:\n   with g.name_scope('parent'):\n       with g.name_scope('nested'):\n           x = tf.placeholder(dtype=tf.float32, name='x')\n           print(x.name)\n       with g.name_scope('nested'):\n           y = tf.placeholder(dtype=tf.float32, name='y')\n           print(y.name)\n       with g.name_scope('nested/'):\n           z = tf.placeholder(dtype=tf.float32, name='z')\n           print(z.name)\n   \n# Gives\n# parent/nested/x:0\n# parent/nested_1/y:0\n# nested/z:0\nAlthough no suffix was added to nested name scope, it lost the parental relationship to parent. Especially in complex architectures, you never know which name-scopes have been opened outside of your function (e.g to instance your network twice under different names).\nUpdate Ok, seems like your code accounts for that by prepending the current name scope", "body": "@albertz, @javidcf I was following your discussion here, as I've been also interested in re-opening name scopes. Here's a bit of warning though (~~without having studied your implementations~~). When you add `/` to your name scope names, TF will interpret the name scope as absolute path, ignoring any parental name-scopes that you are currently in. This can be quite suprising. Here's a short example that illustrates the issue.\r\n\r\n```python\r\nimport tensorflow as tf\r\n\r\nwith tf.Graph().as_default() as g:\r\n   with g.name_scope('parent'):\r\n       with g.name_scope('nested'):\r\n           x = tf.placeholder(dtype=tf.float32, name='x')\r\n           print(x.name)\r\n       with g.name_scope('nested'):\r\n           y = tf.placeholder(dtype=tf.float32, name='y')\r\n           print(y.name)\r\n       with g.name_scope('nested/'):\r\n           z = tf.placeholder(dtype=tf.float32, name='z')\r\n           print(z.name)\r\n   \r\n# Gives\r\n# parent/nested/x:0\r\n# parent/nested_1/y:0\r\n# nested/z:0\r\n```\r\nAlthough no suffix was added to `nested` name scope, it lost the parental relationship to `parent`. Especially in complex architectures, you never know which name-scopes have been opened outside of your function (e.g to instance your network twice under different names).\r\n\r\n**Update** Ok, seems like your code accounts for that by prepending the current name scope"}