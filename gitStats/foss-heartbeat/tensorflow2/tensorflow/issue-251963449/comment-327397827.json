{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/327397827", "html_url": "https://github.com/tensorflow/tensorflow/pull/12493#issuecomment-327397827", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/12493", "id": 327397827, "node_id": "MDEyOklzc3VlQ29tbWVudDMyNzM5NzgyNw==", "user": {"login": "qianyizhang", "id": 12500132, "node_id": "MDQ6VXNlcjEyNTAwMTMy", "avatar_url": "https://avatars0.githubusercontent.com/u/12500132?v=4", "gravatar_id": "", "url": "https://api.github.com/users/qianyizhang", "html_url": "https://github.com/qianyizhang", "followers_url": "https://api.github.com/users/qianyizhang/followers", "following_url": "https://api.github.com/users/qianyizhang/following{/other_user}", "gists_url": "https://api.github.com/users/qianyizhang/gists{/gist_id}", "starred_url": "https://api.github.com/users/qianyizhang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/qianyizhang/subscriptions", "organizations_url": "https://api.github.com/users/qianyizhang/orgs", "repos_url": "https://api.github.com/users/qianyizhang/repos", "events_url": "https://api.github.com/users/qianyizhang/events{/privacy}", "received_events_url": "https://api.github.com/users/qianyizhang/received_events", "type": "User", "site_admin": false}, "created_at": "2017-09-06T07:21:22Z", "updated_at": "2017-09-06T07:29:52Z", "author_association": "NONE", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=2887803\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/panyx0718\">@panyx0718</a></p>\n<blockquote>\n<p>You can do profiling without ProfileContext, using the old way</p>\n</blockquote>\n<p>I am not sure what's missing, here is the example of profiling mnist example:</p>\n<div class=\"highlight highlight-source-python\"><pre>  <span class=\"pl-c\"><span class=\"pl-c\">#</span>I assume this is somewhat equivalent to the ProfileContext's role</span>\n  <span class=\"pl-c\"><span class=\"pl-c\">#</span>activate some tracker in the backend?</span>\n  profiler <span class=\"pl-k\">=</span> tf.profiler.Profiler(tf.get_default_graph())\n\n  <span class=\"pl-k\">for</span> i <span class=\"pl-k\">in</span> <span class=\"pl-c1\">range</span>(<span class=\"pl-c1\">FLAGS</span>.max_steps):\n    <span class=\"pl-k\">if</span> i <span class=\"pl-k\">%</span> <span class=\"pl-c1\">10</span> <span class=\"pl-k\">==</span> <span class=\"pl-c1\">0</span>:  \n      run_meta <span class=\"pl-k\">=</span> tf.RunMetadata()\n      run_options <span class=\"pl-k\">=</span> tf.RunOptions(<span class=\"pl-v\">trace_level</span><span class=\"pl-k\">=</span>tf.RunOptions.<span class=\"pl-c1\">FULL_TRACE</span>)\n      summary, acc <span class=\"pl-k\">=</span> sess.run([merged, accuracy], <span class=\"pl-v\">feed_dict</span><span class=\"pl-k\">=</span>feed_dict(<span class=\"pl-c1\">True</span>),\n                               <span class=\"pl-v\">options</span><span class=\"pl-k\">=</span>run_options, <span class=\"pl-v\">run_metadata</span><span class=\"pl-k\">=</span>run_meta)\n      profiler.add_step(i, run_meta)\n      <span class=\"pl-k\">with</span> tf.gfile.Open(os.path.join(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>d:<span class=\"pl-cce\">\\\\</span><span class=\"pl-pds\">\"</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>run_meta_<span class=\"pl-c1\">{}</span><span class=\"pl-pds\">\"</span></span>.format(<span class=\"pl-c1\">str</span>(i))), <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>w<span class=\"pl-pds\">\"</span></span>) <span class=\"pl-k\">as</span> f:\n        f.write(run_meta.SerializeToString())\n      <span class=\"pl-c\"><span class=\"pl-c\">#</span>specify opts to save?</span>\n      run_meta2 <span class=\"pl-k\">=</span> tf.RunMetadata()\n      builder <span class=\"pl-k\">=</span> tf.profiler.ProfileOptionBuilder\n      opts <span class=\"pl-k\">=</span> builder(builder.time_and_memory()).order_by(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>micros<span class=\"pl-pds\">'</span></span>).build()\n      tf.profiler.profile(tf.get_default_graph(),\n                        <span class=\"pl-v\">run_meta</span><span class=\"pl-k\">=</span>run_meta2,\n                        <span class=\"pl-v\">cmd</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span>op<span class=\"pl-pds\">\"</span></span>,\n                        <span class=\"pl-v\">options</span><span class=\"pl-k\">=</span>opts)\n      <span class=\"pl-k\">with</span> tf.gfile.Open(os.path.join(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>d:<span class=\"pl-cce\">\\\\</span><span class=\"pl-pds\">\"</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>run_meta2_<span class=\"pl-c1\">{}</span><span class=\"pl-pds\">\"</span></span>.format(<span class=\"pl-c1\">str</span>(i))), <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>w<span class=\"pl-pds\">\"</span></span>) <span class=\"pl-k\">as</span> f:\n        f.write(run_meta2.SerializeToString())</pre></div>\n<p>By calling profiler = tf.profiler.Profiler(tf.get_default_graph()) beforehand, I would get groundtruth memory from the sess.run?<br>\nI thought run_meta would give me some general info; while feeding opts into tf.profiler.profile would give me some more specific info, but it turns out I don't get anything for the run_meta2. Am I missing something?</p>", "body_text": "@panyx0718\n\nYou can do profiling without ProfileContext, using the old way\n\nI am not sure what's missing, here is the example of profiling mnist example:\n  #I assume this is somewhat equivalent to the ProfileContext's role\n  #activate some tracker in the backend?\n  profiler = tf.profiler.Profiler(tf.get_default_graph())\n\n  for i in range(FLAGS.max_steps):\n    if i % 10 == 0:  \n      run_meta = tf.RunMetadata()\n      run_options = tf.RunOptions(trace_level=tf.RunOptions.FULL_TRACE)\n      summary, acc = sess.run([merged, accuracy], feed_dict=feed_dict(True),\n                               options=run_options, run_metadata=run_meta)\n      profiler.add_step(i, run_meta)\n      with tf.gfile.Open(os.path.join(\"d:\\\\\", \"run_meta_{}\".format(str(i))), \"w\") as f:\n        f.write(run_meta.SerializeToString())\n      #specify opts to save?\n      run_meta2 = tf.RunMetadata()\n      builder = tf.profiler.ProfileOptionBuilder\n      opts = builder(builder.time_and_memory()).order_by('micros').build()\n      tf.profiler.profile(tf.get_default_graph(),\n                        run_meta=run_meta2,\n                        cmd=\"op\",\n                        options=opts)\n      with tf.gfile.Open(os.path.join(\"d:\\\\\", \"run_meta2_{}\".format(str(i))), \"w\") as f:\n        f.write(run_meta2.SerializeToString())\nBy calling profiler = tf.profiler.Profiler(tf.get_default_graph()) beforehand, I would get groundtruth memory from the sess.run?\nI thought run_meta would give me some general info; while feeding opts into tf.profiler.profile would give me some more specific info, but it turns out I don't get anything for the run_meta2. Am I missing something?", "body": "@panyx0718 \r\n\r\n> You can do profiling without ProfileContext, using the old way\r\n\r\nI am not sure what's missing, here is the example of profiling mnist example:\r\n```python\r\n  #I assume this is somewhat equivalent to the ProfileContext's role\r\n  #activate some tracker in the backend?\r\n  profiler = tf.profiler.Profiler(tf.get_default_graph())\r\n\r\n  for i in range(FLAGS.max_steps):\r\n    if i % 10 == 0:  \r\n      run_meta = tf.RunMetadata()\r\n      run_options = tf.RunOptions(trace_level=tf.RunOptions.FULL_TRACE)\r\n      summary, acc = sess.run([merged, accuracy], feed_dict=feed_dict(True),\r\n                               options=run_options, run_metadata=run_meta)\r\n      profiler.add_step(i, run_meta)\r\n      with tf.gfile.Open(os.path.join(\"d:\\\\\", \"run_meta_{}\".format(str(i))), \"w\") as f:\r\n        f.write(run_meta.SerializeToString())\r\n      #specify opts to save?\r\n      run_meta2 = tf.RunMetadata()\r\n      builder = tf.profiler.ProfileOptionBuilder\r\n      opts = builder(builder.time_and_memory()).order_by('micros').build()\r\n      tf.profiler.profile(tf.get_default_graph(),\r\n                        run_meta=run_meta2,\r\n                        cmd=\"op\",\r\n                        options=opts)\r\n      with tf.gfile.Open(os.path.join(\"d:\\\\\", \"run_meta2_{}\".format(str(i))), \"w\") as f:\r\n        f.write(run_meta2.SerializeToString())\r\n```\r\nBy calling profiler = tf.profiler.Profiler(tf.get_default_graph()) beforehand, I would get groundtruth memory from the sess.run?\r\nI thought run_meta would give me some general info; while feeding opts into tf.profiler.profile would give me some more specific info, but it turns out I don't get anything for the run_meta2. Am I missing something?"}