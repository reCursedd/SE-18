{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/3879", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/3879/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/3879/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/3879/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/3879", "id": 171732525, "node_id": "MDU6SXNzdWUxNzE3MzI1MjU=", "number": 3879, "title": "Strange behavior of tf.control_dependencies", "user": {"login": "danfeiX", "id": 5679196, "node_id": "MDQ6VXNlcjU2NzkxOTY=", "avatar_url": "https://avatars0.githubusercontent.com/u/5679196?v=4", "gravatar_id": "", "url": "https://api.github.com/users/danfeiX", "html_url": "https://github.com/danfeiX", "followers_url": "https://api.github.com/users/danfeiX/followers", "following_url": "https://api.github.com/users/danfeiX/following{/other_user}", "gists_url": "https://api.github.com/users/danfeiX/gists{/gist_id}", "starred_url": "https://api.github.com/users/danfeiX/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/danfeiX/subscriptions", "organizations_url": "https://api.github.com/users/danfeiX/orgs", "repos_url": "https://api.github.com/users/danfeiX/repos", "events_url": "https://api.github.com/users/danfeiX/events{/privacy}", "received_events_url": "https://api.github.com/users/danfeiX/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2016-08-17T18:51:46Z", "updated_at": "2016-08-22T17:20:27Z", "closed_at": "2016-08-22T17:20:27Z", "author_association": "NONE", "body_html": "<p>Consider the following code:</p>\n<pre><code>import tensorflow as tf\n\nwith tf.variable_scope('a'):\n    a = tf.get_variable('v', [], initializer=tf.constant_initializer(0), dtype=tf.int32)\n    a_assign = a.assign(a+100)\n\nwith tf.variable_scope('a', reuse=True):\n    b = tf.get_variable('v', [], initializer=tf.constant_initializer(0), dtype=tf.int32)\n    b_assign = b.assign(b+1)\n\nwith tf.control_dependencies([a_assign, b_assign]):\n    c = tf.constant(0)\n\nsess = tf.InteractiveSession()\nsess.run(tf.initialize_all_variables())\nprint(sess.run([c, a, b]))\n\n</code></pre>\n<p>I expected this piece of code to return [0, 101, 101], but instead it returns [0, 100, 100].</p>\n<p>Then I ran the \"print(sess.run([c, a, b]))\" line 10 times, the outputs were:</p>\n<p>[0, 100, 100]<br>\n[0, 200, 200]<br>\n[0, 201, 201]<br>\n[0, 202, 202]<br>\n[0, 303, 303]<br>\n[0, 403, 403]<br>\n[0, 404, 404]<br>\n[0, 405, 405]<br>\n[0, 406, 406]<br>\n[0, 506, 506]</p>\n<p>Then I re-ran the program again and the outputs were:</p>\n<p>[0, 1, 1]<br>\n[0, 2, 2]<br>\n[0, 3, 3]<br>\n[0, 4, 4]<br>\n[0, 5, 5]<br>\n[0, 6, 6]<br>\n[0, 7, 7]<br>\n[0, 8, 8]<br>\n[0, 108, 108]<br>\n[0, 208, 208]</p>\n<p>So it seems like in this case tf.control_dependencies randomly executes either a_assign or b_assign and not both at each sess.run. Could anyone explain this behavior?</p>\n<h3>Environment info</h3>\n<p>Operating System:<br>\nUbuntu 14.04<br>\nInstalled version of CUDA and cuDNN:<br>\n-rw-r--r-- 1 root root 189170 Jun  6 15:17 /usr/local/cuda/lib/libcudadevrt.a<br>\nlrwxrwxrwx 1 root root     16 Jun  6 15:17 /usr/local/cuda/lib/libcudart.so -&gt; libcudart.so.7.5<br>\nlrwxrwxrwx 1 root root     19 Jun  6 15:17 /usr/local/cuda/lib/libcudart.so.7.5 -&gt; libcudart.so.7.5.18<br>\n-rwxr-xr-x 1 root root 311596 Jun  6 15:17 /usr/local/cuda/lib/libcudart.so.7.5.18<br>\n-rw-r--r-- 1 root root 558020 Jun  6 15:17 /usr/local/cuda/lib/libcudart_static.a</p>\n<p>TensorFlow version 0.9.0</p>", "body_text": "Consider the following code:\nimport tensorflow as tf\n\nwith tf.variable_scope('a'):\n    a = tf.get_variable('v', [], initializer=tf.constant_initializer(0), dtype=tf.int32)\n    a_assign = a.assign(a+100)\n\nwith tf.variable_scope('a', reuse=True):\n    b = tf.get_variable('v', [], initializer=tf.constant_initializer(0), dtype=tf.int32)\n    b_assign = b.assign(b+1)\n\nwith tf.control_dependencies([a_assign, b_assign]):\n    c = tf.constant(0)\n\nsess = tf.InteractiveSession()\nsess.run(tf.initialize_all_variables())\nprint(sess.run([c, a, b]))\n\n\nI expected this piece of code to return [0, 101, 101], but instead it returns [0, 100, 100].\nThen I ran the \"print(sess.run([c, a, b]))\" line 10 times, the outputs were:\n[0, 100, 100]\n[0, 200, 200]\n[0, 201, 201]\n[0, 202, 202]\n[0, 303, 303]\n[0, 403, 403]\n[0, 404, 404]\n[0, 405, 405]\n[0, 406, 406]\n[0, 506, 506]\nThen I re-ran the program again and the outputs were:\n[0, 1, 1]\n[0, 2, 2]\n[0, 3, 3]\n[0, 4, 4]\n[0, 5, 5]\n[0, 6, 6]\n[0, 7, 7]\n[0, 8, 8]\n[0, 108, 108]\n[0, 208, 208]\nSo it seems like in this case tf.control_dependencies randomly executes either a_assign or b_assign and not both at each sess.run. Could anyone explain this behavior?\nEnvironment info\nOperating System:\nUbuntu 14.04\nInstalled version of CUDA and cuDNN:\n-rw-r--r-- 1 root root 189170 Jun  6 15:17 /usr/local/cuda/lib/libcudadevrt.a\nlrwxrwxrwx 1 root root     16 Jun  6 15:17 /usr/local/cuda/lib/libcudart.so -> libcudart.so.7.5\nlrwxrwxrwx 1 root root     19 Jun  6 15:17 /usr/local/cuda/lib/libcudart.so.7.5 -> libcudart.so.7.5.18\n-rwxr-xr-x 1 root root 311596 Jun  6 15:17 /usr/local/cuda/lib/libcudart.so.7.5.18\n-rw-r--r-- 1 root root 558020 Jun  6 15:17 /usr/local/cuda/lib/libcudart_static.a\nTensorFlow version 0.9.0", "body": "Consider the following code:\n\n```\nimport tensorflow as tf\n\nwith tf.variable_scope('a'):\n    a = tf.get_variable('v', [], initializer=tf.constant_initializer(0), dtype=tf.int32)\n    a_assign = a.assign(a+100)\n\nwith tf.variable_scope('a', reuse=True):\n    b = tf.get_variable('v', [], initializer=tf.constant_initializer(0), dtype=tf.int32)\n    b_assign = b.assign(b+1)\n\nwith tf.control_dependencies([a_assign, b_assign]):\n    c = tf.constant(0)\n\nsess = tf.InteractiveSession()\nsess.run(tf.initialize_all_variables())\nprint(sess.run([c, a, b]))\n\n```\n\nI expected this piece of code to return [0, 101, 101], but instead it returns [0, 100, 100]. \n\nThen I ran the \"print(sess.run([c, a, b]))\" line 10 times, the outputs were:\n\n[0, 100, 100]\n[0, 200, 200]\n[0, 201, 201]\n[0, 202, 202]\n[0, 303, 303]\n[0, 403, 403]\n[0, 404, 404]\n[0, 405, 405]\n[0, 406, 406]\n[0, 506, 506]\n\nThen I re-ran the program again and the outputs were:\n\n[0, 1, 1]\n[0, 2, 2]\n[0, 3, 3]\n[0, 4, 4]\n[0, 5, 5]\n[0, 6, 6]\n[0, 7, 7]\n[0, 8, 8]\n[0, 108, 108]\n[0, 208, 208]\n\nSo it seems like in this case tf.control_dependencies randomly executes either a_assign or b_assign and not both at each sess.run. Could anyone explain this behavior?\n### Environment info\n\nOperating System:\nUbuntu 14.04\nInstalled version of CUDA and cuDNN: \n-rw-r--r-- 1 root root 189170 Jun  6 15:17 /usr/local/cuda/lib/libcudadevrt.a\nlrwxrwxrwx 1 root root     16 Jun  6 15:17 /usr/local/cuda/lib/libcudart.so -> libcudart.so.7.5\nlrwxrwxrwx 1 root root     19 Jun  6 15:17 /usr/local/cuda/lib/libcudart.so.7.5 -> libcudart.so.7.5.18\n-rwxr-xr-x 1 root root 311596 Jun  6 15:17 /usr/local/cuda/lib/libcudart.so.7.5.18\n-rw-r--r-- 1 root root 558020 Jun  6 15:17 /usr/local/cuda/lib/libcudart_static.a\n\nTensorFlow version 0.9.0\n"}