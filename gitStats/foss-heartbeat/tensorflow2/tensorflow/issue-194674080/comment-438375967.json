{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/438375967", "html_url": "https://github.com/tensorflow/tensorflow/issues/6220#issuecomment-438375967", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/6220", "id": 438375967, "node_id": "MDEyOklzc3VlQ29tbWVudDQzODM3NTk2Nw==", "user": {"login": "zaiedsarra", "id": 33926948, "node_id": "MDQ6VXNlcjMzOTI2OTQ4", "avatar_url": "https://avatars2.githubusercontent.com/u/33926948?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zaiedsarra", "html_url": "https://github.com/zaiedsarra", "followers_url": "https://api.github.com/users/zaiedsarra/followers", "following_url": "https://api.github.com/users/zaiedsarra/following{/other_user}", "gists_url": "https://api.github.com/users/zaiedsarra/gists{/gist_id}", "starred_url": "https://api.github.com/users/zaiedsarra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zaiedsarra/subscriptions", "organizations_url": "https://api.github.com/users/zaiedsarra/orgs", "repos_url": "https://api.github.com/users/zaiedsarra/repos", "events_url": "https://api.github.com/users/zaiedsarra/events{/privacy}", "received_events_url": "https://api.github.com/users/zaiedsarra/received_events", "type": "User", "site_admin": false}, "created_at": "2018-11-13T18:05:28Z", "updated_at": "2018-11-13T18:05:28Z", "author_association": "NONE", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=684901\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/lukaszkaiser\">@lukaszkaiser</a> Hello I need your help :( , in the code i have the same error :ValueError: Variable G_fc/w does not exist, or was not created with tf.get_variable(). Did you mean to set reuse=tf.AUTO_REUSE in VarScope?<br>\nBut i didn't understand haw i can change the code (it works with GradientDescent)</p>\n<p>this is the function</p>\n<pre><code>def generator(self, z, y, gender=None, reuse_variables=False, enable_tile_label=True, tile_ratio=1.0):\n    if reuse_variables:\n        tf.get_variable_scope().reuse_variables()\n    num_layers = int(np.log2(self.size_image)) - int(self.size_kernel / 2)\n    if enable_tile_label:\n        duplicate = int(self.num_z_channels * tile_ratio / self.y_dim)\n    else:\n        duplicate = 1\n    z = concat_label(z, y, duplicate=duplicate)\n    if enable_tile_label:\n        duplicate = int(self.num_z_channels * tile_ratio / 2)\n    else:\n        duplicate = 1\n\n    size_mini_map = int(self.size_image / 2 ** num_layers)\n\n    name = 'G_fc'\n    current = fc(\n        input_vector=z,\n        num_output_length=self.num_gen_channels * size_mini_map * size_mini_map,\n        name=name,\n         # reuse = reuse_variables\n    )\n\n    current = tf.reshape(current, [-1, size_mini_map, size_mini_map, self.num_gen_channels])\n    current = tf.nn.relu(current)\n    current = concat_label(current, y)\n\n    for i in range(num_layers):\n        name = 'G_deconv' + str(i)\n        current = tf.image.resize_nearest_neighbor(current, [size_mini_map * 2 ** (i + 1), size_mini_map * 2 ** (i + 1)])\n        current = custom_conv2d(input_map=current, num_output_channels=int(self.num_gen_channels / 2 ** (i + 1)), name=name)\n        current = tf.nn.relu(current)\n        current = concat_label(current, y)\n\n    name = 'G_deconv' + str(i + 1)\n    current = tf.image.resize_nearest_neighbor(current, [self.size_image, self.size_image])\n    current = custom_conv2d(input_map=current, num_output_channels=int(self.num_gen_channels / 2 ** (i + 2)), name=name)\n    current = tf.nn.relu(current)\n    current = concat_label(current, y)\n\n    name = 'G_deconv' + str(i + 2)\n    current = custom_conv2d(input_map=current, num_output_channels=self.num_input_channels, name=name)\n\n    return tf.nn.tanh(current)\n</code></pre>\n<hr>\n<p>And this is the G_fc function</p>\n<p>def fc(input_vector, num_output_length, name='fc'):<br>\nwith tf.variable_scope(name):<br>\nstddev = np.sqrt(1.0 / (np.sqrt(input_vector.get_shape()[-1].value * num_output_length)))<br>\nw = tf.get_variable(<br>\nname='w',<br>\nshape=[input_vector.get_shape()[1], num_output_length],<br>\ndtype=tf.float32,<br>\ninitializer=tf.random_normal_initializer(stddev=stddev)<br>\n)<br>\nb = tf.get_variable(<br>\nname='b',<br>\nshape=[num_output_length],<br>\ndtype=tf.float32,<br>\ninitializer=tf.constant_initializer(0.0)<br>\n)<br>\nreturn tf.matmul(input_vector, w) + b</p>", "body_text": "@lukaszkaiser Hello I need your help :( , in the code i have the same error :ValueError: Variable G_fc/w does not exist, or was not created with tf.get_variable(). Did you mean to set reuse=tf.AUTO_REUSE in VarScope?\nBut i didn't understand haw i can change the code (it works with GradientDescent)\nthis is the function\ndef generator(self, z, y, gender=None, reuse_variables=False, enable_tile_label=True, tile_ratio=1.0):\n    if reuse_variables:\n        tf.get_variable_scope().reuse_variables()\n    num_layers = int(np.log2(self.size_image)) - int(self.size_kernel / 2)\n    if enable_tile_label:\n        duplicate = int(self.num_z_channels * tile_ratio / self.y_dim)\n    else:\n        duplicate = 1\n    z = concat_label(z, y, duplicate=duplicate)\n    if enable_tile_label:\n        duplicate = int(self.num_z_channels * tile_ratio / 2)\n    else:\n        duplicate = 1\n\n    size_mini_map = int(self.size_image / 2 ** num_layers)\n\n    name = 'G_fc'\n    current = fc(\n        input_vector=z,\n        num_output_length=self.num_gen_channels * size_mini_map * size_mini_map,\n        name=name,\n         # reuse = reuse_variables\n    )\n\n    current = tf.reshape(current, [-1, size_mini_map, size_mini_map, self.num_gen_channels])\n    current = tf.nn.relu(current)\n    current = concat_label(current, y)\n\n    for i in range(num_layers):\n        name = 'G_deconv' + str(i)\n        current = tf.image.resize_nearest_neighbor(current, [size_mini_map * 2 ** (i + 1), size_mini_map * 2 ** (i + 1)])\n        current = custom_conv2d(input_map=current, num_output_channels=int(self.num_gen_channels / 2 ** (i + 1)), name=name)\n        current = tf.nn.relu(current)\n        current = concat_label(current, y)\n\n    name = 'G_deconv' + str(i + 1)\n    current = tf.image.resize_nearest_neighbor(current, [self.size_image, self.size_image])\n    current = custom_conv2d(input_map=current, num_output_channels=int(self.num_gen_channels / 2 ** (i + 2)), name=name)\n    current = tf.nn.relu(current)\n    current = concat_label(current, y)\n\n    name = 'G_deconv' + str(i + 2)\n    current = custom_conv2d(input_map=current, num_output_channels=self.num_input_channels, name=name)\n\n    return tf.nn.tanh(current)\n\n\nAnd this is the G_fc function\ndef fc(input_vector, num_output_length, name='fc'):\nwith tf.variable_scope(name):\nstddev = np.sqrt(1.0 / (np.sqrt(input_vector.get_shape()[-1].value * num_output_length)))\nw = tf.get_variable(\nname='w',\nshape=[input_vector.get_shape()[1], num_output_length],\ndtype=tf.float32,\ninitializer=tf.random_normal_initializer(stddev=stddev)\n)\nb = tf.get_variable(\nname='b',\nshape=[num_output_length],\ndtype=tf.float32,\ninitializer=tf.constant_initializer(0.0)\n)\nreturn tf.matmul(input_vector, w) + b", "body": "@lukaszkaiser Hello I need your help :( , in the code i have the same error :ValueError: Variable G_fc/w does not exist, or was not created with tf.get_variable(). Did you mean to set reuse=tf.AUTO_REUSE in VarScope?\r\nBut i didn't understand haw i can change the code (it works with GradientDescent)\r\n\r\nthis is the function \r\n\r\n    def generator(self, z, y, gender=None, reuse_variables=False, enable_tile_label=True, tile_ratio=1.0):\r\n        if reuse_variables:\r\n            tf.get_variable_scope().reuse_variables()\r\n        num_layers = int(np.log2(self.size_image)) - int(self.size_kernel / 2)\r\n        if enable_tile_label:\r\n            duplicate = int(self.num_z_channels * tile_ratio / self.y_dim)\r\n        else:\r\n            duplicate = 1\r\n        z = concat_label(z, y, duplicate=duplicate)\r\n        if enable_tile_label:\r\n            duplicate = int(self.num_z_channels * tile_ratio / 2)\r\n        else:\r\n            duplicate = 1\r\n\r\n        size_mini_map = int(self.size_image / 2 ** num_layers)\r\n\r\n        name = 'G_fc'\r\n        current = fc(\r\n            input_vector=z,\r\n            num_output_length=self.num_gen_channels * size_mini_map * size_mini_map,\r\n            name=name,\r\n             # reuse = reuse_variables\r\n        )\r\n\r\n        current = tf.reshape(current, [-1, size_mini_map, size_mini_map, self.num_gen_channels])\r\n        current = tf.nn.relu(current)\r\n        current = concat_label(current, y)\r\n\r\n        for i in range(num_layers):\r\n            name = 'G_deconv' + str(i)\r\n            current = tf.image.resize_nearest_neighbor(current, [size_mini_map * 2 ** (i + 1), size_mini_map * 2 ** (i + 1)])\r\n            current = custom_conv2d(input_map=current, num_output_channels=int(self.num_gen_channels / 2 ** (i + 1)), name=name)\r\n            current = tf.nn.relu(current)\r\n            current = concat_label(current, y)\r\n\r\n        name = 'G_deconv' + str(i + 1)\r\n        current = tf.image.resize_nearest_neighbor(current, [self.size_image, self.size_image])\r\n        current = custom_conv2d(input_map=current, num_output_channels=int(self.num_gen_channels / 2 ** (i + 2)), name=name)\r\n        current = tf.nn.relu(current)\r\n        current = concat_label(current, y)\r\n\r\n        name = 'G_deconv' + str(i + 2)\r\n        current = custom_conv2d(input_map=current, num_output_channels=self.num_input_channels, name=name)\r\n\r\n        return tf.nn.tanh(current)\r\n\r\n  **********************************************************************************************\r\nAnd this is the G_fc function \r\n\r\n\r\ndef fc(input_vector, num_output_length, name='fc'):\r\n    with tf.variable_scope(name):\r\n        stddev = np.sqrt(1.0 / (np.sqrt(input_vector.get_shape()[-1].value * num_output_length)))\r\n        w = tf.get_variable(\r\n            name='w',\r\n            shape=[input_vector.get_shape()[1], num_output_length],\r\n            dtype=tf.float32,\r\n            initializer=tf.random_normal_initializer(stddev=stddev)\r\n        )\r\n        b = tf.get_variable(\r\n            name='b',\r\n            shape=[num_output_length],\r\n            dtype=tf.float32,\r\n            initializer=tf.constant_initializer(0.0)\r\n        )\r\n        return tf.matmul(input_vector, w) + b  "}