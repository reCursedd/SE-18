{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/87513357", "pull_request_review_id": 8124499, "id": 87513357, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDg3NTEzMzU3", "diff_hunk": "@@ -0,0 +1,201 @@\n+# Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+# ==============================================================================\n+\n+\"\"\"Module includes reference datasets and utilities to load datasets. It also \n+includes methods to generate synthetic data.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+from __future__ import division\n+from __future__ import print_function\n+\n+import numpy as np\n+\n+from tensorflow.contrib.learn.python.learn.datasets.base import Dataset\n+\n+def circles(n_samples=100, noise=None, seed=None, factor=0.8, n_classes=2, *args, **kwargs):\n+  \"\"\"Create circles separated by some value\n+\n+  Args:\n+    n_samples: int, number of datapoints to generate\n+    noise: float or None, standard deviation of the Gaussian noise added\n+    seed: int or None, seed for the noise\n+    factor: float, size factor of the inner circles with respect to the outer ones\n+    n_classes: int, number of classes to generate\n+\n+  Returns:\n+    Shuffled features and labels for 'circles' synthetic dataset of type `base.Dataset`\n+\n+  Note:\n+    The multi-class support might not work as expected if `noise` is enabled\n+\n+  TODO:\n+    - Generation of unbalanced data\n+\n+  Credit goes to (under BSD 3 clause):\n+    B. Thirion, \n+    G. Varoquaux, \n+    A. Gramfort, \n+    V. Michel, \n+    O. Grisel, \n+    G. Louppe, \n+    J. Nothman\n+  \"\"\"\n+  if seed is not None:\n+    np.random.seed(seed)\n+  # Algo: 1) Generate initial circle, 2) For ever class generate a smaller radius circle\n+  linspace = np.linspace(0, 2*np.pi, n_samples // n_classes)\n+  circ_x = np.empty(0, dtype=np.int32)\n+  circ_y = np.empty(0, dtype=np.int32)\n+  base_cos = np.cos(linspace)\n+  base_sin = np.sin(linspace)\n+\n+  y = np.empty(0, dtype=np.int32)\n+  for label in range(n_classes):\n+    circ_x = np.append(circ_x, base_cos)\n+    circ_y = np.append(circ_y, base_sin)\n+    base_cos *= factor\n+    base_sin *= factor\n+    y = np.append(y, label*np.ones(n_samples // n_classes, dtype=np.int32))\n+  \n+  # Add more points if n_samples is not divisible by n_classes (unbalanced!)\n+  extras = n_samples % n_classes\n+  circ_x = np.append(circ_x, np.cos(np.random.rand(extras)*2*np.pi))\n+  circ_y = np.append(circ_y, np.sin(np.random.rand(extras)*2*np.pi))\n+  y = np.append(y, np.zeros(extras, dtype=np.int32))\n+  \n+  # Reshape the features/labels\n+  X = np.vstack((circ_x, circ_y)).T\n+  y = np.hstack(y)\n+  \n+  # Shuffle the data\n+  indices = np.random.permutation(range(n_samples))\n+  if noise is not None:\n+    X += np.random.normal(scale=noise, size=X.shape)\n+  return Dataset(data=X[indices], target=y[indices])\n+\n+def spirals(n_samples=100, noise=None, seed=None, \n+            mode = 'archimedes', \n+            n_loops = 2,\n+            *args, **kwargs):\n+  \"\"\"Create spirals\n+\n+  Currently only binary classification is supported for spiral generation\n+\n+  Args:\n+    n_samples: int, number of datapoints to generate\n+    noise: float or None, standard deviation of the Gaussian noise added\n+    seed: int or None, seed for the noise\n+    n_loops: int, number of spiral loops, doesn't play well with 'bernoulli'\n+    mode: str, how the spiral should be generated. Current implementations:\n+      'archimedes': a spiral with equal distances between branches\n+      'bernoulli': logarithmic spiral with branch distances increasing\n+      'fermat': a spiral with branch distances decreasing (sqrt)\n+\n+  Returns:\n+    Shuffled features and labels for 'spirals' synthetic dataset of type `base.Dataset`\n+\n+  Raises:\n+    ValueError: If the generation `mode` is not valid\n+\n+  TODO:\n+    - Generation of unbalanced data\n+  \"\"\"\n+  n_classes = 2 # I am not sure how to make it multiclass\n+\n+  _modes = {\n+    'archimedes': _archimedes_spiral,\n+    'bernoulli': _bernoulli_spiral,\n+    'fermat': _fermat_spiral\n+  }\n+\n+  if mode is None or mode not in _modes:\n+    raise ValueError(\"Cannot generate spiral with mode %s\"%mode)\n+\n+  if seed is not None:\n+    np.random.seed(seed)\n+  linspace = np.linspace(0, 2*n_loops*np.pi, n_samples // n_classes)\n+  spir_x = np.empty(0, dtype=np.int32)\n+  spir_y = np.empty(0, dtype=np.int32)\n+\n+  y = np.empty(0, dtype=np.int32)\n+  for label in range(n_classes):\n+    base_cos, base_sin = _modes[mode](linspace, label*np.pi, *args, **kwargs)  \n+    spir_x = np.append(spir_x, base_cos)\n+    spir_y = np.append(spir_y, base_sin)\n+    y = np.append(y, label*np.ones(n_samples // n_classes, dtype=np.int32))\n+  \n+  # Add more points if n_samples is not divisible by n_classes (unbalanced!)\n+  extras = n_samples % n_classes\n+  if extras > 0:\n+    x_exrta, y_extra = _modes[mode](np.random.rand(extras)*2*np.pi, *args, **kwargs)\n+    spir_x = np.append(spir_x, x_extra)\n+    spir_y = np.append(spir_y, y_extra)\n+    y = np.append(y, np.zeros(extras, dtype=np.int32))\n+  \n+  # Reshape the features/labels\n+  X = np.vstack((spir_x, spir_y)).T\n+  y = np.hstack(y)\n+  \n+  # Shuffle the data\n+  indices = np.random.permutation(range(n_samples))\n+  if noise is not None:\n+    X += np.random.normal(scale=noise, size=X.shape)\n+  return Dataset(data=X[indices], target=y[indices])\n+", "path": "tensorflow/contrib/learn/python/learn/datasets/synthetic.py", "position": 86, "original_position": 157, "commit_id": "d9e729868211faafa2d5a0596568d849ca9894d9", "original_commit_id": "140fe00155d631b70713304b50d66897b9d04a1f", "user": {"login": "ilblackdragon", "id": 175486, "node_id": "MDQ6VXNlcjE3NTQ4Ng==", "avatar_url": "https://avatars2.githubusercontent.com/u/175486?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ilblackdragon", "html_url": "https://github.com/ilblackdragon", "followers_url": "https://api.github.com/users/ilblackdragon/followers", "following_url": "https://api.github.com/users/ilblackdragon/following{/other_user}", "gists_url": "https://api.github.com/users/ilblackdragon/gists{/gist_id}", "starred_url": "https://api.github.com/users/ilblackdragon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ilblackdragon/subscriptions", "organizations_url": "https://api.github.com/users/ilblackdragon/orgs", "repos_url": "https://api.github.com/users/ilblackdragon/repos", "events_url": "https://api.github.com/users/ilblackdragon/events{/privacy}", "received_events_url": "https://api.github.com/users/ilblackdragon/received_events", "type": "User", "site_admin": false}, "body": "two new lines between functions (and same below)\n", "created_at": "2016-11-11T00:00:41Z", "updated_at": "2016-11-29T21:04:22Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/5315#discussion_r87513357", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/5315", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/87513357"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/5315#discussion_r87513357"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/5315"}}, "body_html": "<p>two new lines between functions (and same below)</p>", "body_text": "two new lines between functions (and same below)"}