{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/12972", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/12972/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/12972/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/12972/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/12972", "id": 256776384, "node_id": "MDU6SXNzdWUyNTY3NzYzODQ=", "number": 12972, "title": "Dataset API fromGenerator Functionality", "user": {"login": "eaplatanios", "id": 1294940, "node_id": "MDQ6VXNlcjEyOTQ5NDA=", "avatar_url": "https://avatars2.githubusercontent.com/u/1294940?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eaplatanios", "html_url": "https://github.com/eaplatanios", "followers_url": "https://api.github.com/users/eaplatanios/followers", "following_url": "https://api.github.com/users/eaplatanios/following{/other_user}", "gists_url": "https://api.github.com/users/eaplatanios/gists{/gist_id}", "starred_url": "https://api.github.com/users/eaplatanios/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eaplatanios/subscriptions", "organizations_url": "https://api.github.com/users/eaplatanios/orgs", "repos_url": "https://api.github.com/users/eaplatanios/repos", "events_url": "https://api.github.com/users/eaplatanios/events{/privacy}", "received_events_url": "https://api.github.com/users/eaplatanios/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 404586594, "node_id": "MDU6TGFiZWw0MDQ1ODY1OTQ=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:awaiting%20tensorflower", "name": "stat:awaiting tensorflower", "color": "f4b400", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2017-09-11T17:07:28Z", "updated_at": "2018-01-03T06:06:38Z", "closed_at": "2018-01-03T06:06:38Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=192142\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/mrry\">@mrry</a> I was looking at the code for the <code>fromGenerator</code> function and I notice that you do <code>iter(generator())</code> to create multiple parallel iterators over the same generator. Maybe I'm not too familiar with the semantics of a Python generator, but my impression was that it represents a continuation and it's not necessarily repeatable, meaning that you would have to cache all the elements you get in order to reproduce them. For example, let's say a generator is querying an online service and yielding a different tensor at each time point, dependent on the answer it gets from that service. This would not be repeatable without caching those tensors. So, in that case, how would your implementation behave? And in more general, what does the <code>iter()</code> function applied in this setting mean?</p>\n<p>Regarding the caching of elements, I think that if there is a problem with the current implementation, then the right way to do this would be something along the lines of:</p>\n<ol>\n<li>Create a dataset from a generator, as it's currently done, but also store a flag in it specifying it's a <code>GeneratorDataset</code> (could also be subclassing dataset to make things simpler).</li>\n<li>When <code>repeat</code> is called on such a dataset, convert the generator to something like a Scala stream, which simply memoizes elements as you obtain them, but lazily evaluates the tail of your sequence (sort of like an iterator but with memoization) and then return a dataset that uses that stream as its source.</li>\n</ol>\n<p>It may be totally unnecessary depending on the semantics of the <code>iter()</code> function, but based on a quick search I did, I couldn't find enough information for this setting.</p>", "body_text": "@mrry I was looking at the code for the fromGenerator function and I notice that you do iter(generator()) to create multiple parallel iterators over the same generator. Maybe I'm not too familiar with the semantics of a Python generator, but my impression was that it represents a continuation and it's not necessarily repeatable, meaning that you would have to cache all the elements you get in order to reproduce them. For example, let's say a generator is querying an online service and yielding a different tensor at each time point, dependent on the answer it gets from that service. This would not be repeatable without caching those tensors. So, in that case, how would your implementation behave? And in more general, what does the iter() function applied in this setting mean?\nRegarding the caching of elements, I think that if there is a problem with the current implementation, then the right way to do this would be something along the lines of:\n\nCreate a dataset from a generator, as it's currently done, but also store a flag in it specifying it's a GeneratorDataset (could also be subclassing dataset to make things simpler).\nWhen repeat is called on such a dataset, convert the generator to something like a Scala stream, which simply memoizes elements as you obtain them, but lazily evaluates the tail of your sequence (sort of like an iterator but with memoization) and then return a dataset that uses that stream as its source.\n\nIt may be totally unnecessary depending on the semantics of the iter() function, but based on a quick search I did, I couldn't find enough information for this setting.", "body": "@mrry I was looking at the code for the `fromGenerator` function and I notice that you do `iter(generator())` to create multiple parallel iterators over the same generator. Maybe I'm not too familiar with the semantics of a Python generator, but my impression was that it represents a continuation and it's not necessarily repeatable, meaning that you would have to cache all the elements you get in order to reproduce them. For example, let's say a generator is querying an online service and yielding a different tensor at each time point, dependent on the answer it gets from that service. This would not be repeatable without caching those tensors. So, in that case, how would your implementation behave? And in more general, what does the `iter()` function applied in this setting mean?\r\n\r\nRegarding the caching of elements, I think that if there is a problem with the current implementation, then the right way to do this would be something along the lines of:\r\n1. Create a dataset from a generator, as it's currently done, but also store a flag in it specifying it's a `GeneratorDataset` (could also be subclassing dataset to make things simpler).\r\n2. When `repeat` is called on such a dataset, convert the generator to something like a Scala stream, which simply memoizes elements as you obtain them, but lazily evaluates the tail of your sequence (sort of like an iterator but with memoization) and then return a dataset that uses that stream as its source.\r\n\r\nIt may be totally unnecessary depending on the semantics of the `iter()` function, but based on a quick search I did, I couldn't find enough information for this setting."}