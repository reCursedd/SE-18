{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/210568942", "html_url": "https://github.com/tensorflow/tensorflow/issues/1941#issuecomment-210568942", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/1941", "id": 210568942, "node_id": "MDEyOklzc3VlQ29tbWVudDIxMDU2ODk0Mg==", "user": {"login": "Styrke", "id": 1035167, "node_id": "MDQ6VXNlcjEwMzUxNjc=", "avatar_url": "https://avatars3.githubusercontent.com/u/1035167?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Styrke", "html_url": "https://github.com/Styrke", "followers_url": "https://api.github.com/users/Styrke/followers", "following_url": "https://api.github.com/users/Styrke/following{/other_user}", "gists_url": "https://api.github.com/users/Styrke/gists{/gist_id}", "starred_url": "https://api.github.com/users/Styrke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Styrke/subscriptions", "organizations_url": "https://api.github.com/users/Styrke/orgs", "repos_url": "https://api.github.com/users/Styrke/repos", "events_url": "https://api.github.com/users/Styrke/events{/privacy}", "received_events_url": "https://api.github.com/users/Styrke/received_events", "type": "User", "site_admin": false}, "created_at": "2016-04-15T18:08:14Z", "updated_at": "2016-04-15T18:08:14Z", "author_association": "CONTRIBUTOR", "body_html": "<blockquote>\n<p>Could this be done as an object on top of TF?<br>\n[...]<br>\nMaybe a way to go is to have a thin wrapper like \"EasySession\" or something like this on top, and if it gets traction, then people can switch over to using it rather than the old run interface.</p>\n</blockquote>\n<p>I assume that you are talking about (at least initially) implementing it as a subclass that can be used as e.g. <code>tf.EasySession</code> or <code>tf.contrib.Session</code> instead of <code>tf.Session</code>?</p>\n<blockquote>\n<p>As you mention, one may want to extend it to tuples, nested dictionaries, or dictionaries containing lists of elements, so that's additional changes to the core TF. Also, maybe asking for \"isinstance(dict)\" is too restrictive, instead you might want to follow the spirit of duck-typing and accept any object that is dictionary-like.</p>\n</blockquote>\n<p>Yes, you're right. The <code>run()</code> function I shared above was only made to cover my own basic needs and serve as an example.</p>\n<p>For something like this to be more general I am currently thinking that it could maybe accept any python object that is an iterable container, and its return value should have the same structure. I don't know yet if that's possible, or necessary, or even worth it at all. I think my own needs would be covered if it just works with both lists and dictionaries.</p>\n<blockquote>\n<p>In general, changes to core interface may break tests in unexpected ways and require some work to get integrated. For instance, there may be some code which feeds in a dict into session.run already and expects it to fail (it may seem like a stretch, but I have seen similar scenarios)</p>\n</blockquote>\n<p>Sure, even the most (seemingly) trivial assumptions can turn out to be wrong, and especially for essential functionality that is used all the time like <code>tf.Session</code> it is a good policy to be extra cautious.</p>\n<p>Ideally the implementation should of course be fully backwards compatible so it can be included in the main <code>tf.Session</code> class.</p>", "body_text": "Could this be done as an object on top of TF?\n[...]\nMaybe a way to go is to have a thin wrapper like \"EasySession\" or something like this on top, and if it gets traction, then people can switch over to using it rather than the old run interface.\n\nI assume that you are talking about (at least initially) implementing it as a subclass that can be used as e.g. tf.EasySession or tf.contrib.Session instead of tf.Session?\n\nAs you mention, one may want to extend it to tuples, nested dictionaries, or dictionaries containing lists of elements, so that's additional changes to the core TF. Also, maybe asking for \"isinstance(dict)\" is too restrictive, instead you might want to follow the spirit of duck-typing and accept any object that is dictionary-like.\n\nYes, you're right. The run() function I shared above was only made to cover my own basic needs and serve as an example.\nFor something like this to be more general I am currently thinking that it could maybe accept any python object that is an iterable container, and its return value should have the same structure. I don't know yet if that's possible, or necessary, or even worth it at all. I think my own needs would be covered if it just works with both lists and dictionaries.\n\nIn general, changes to core interface may break tests in unexpected ways and require some work to get integrated. For instance, there may be some code which feeds in a dict into session.run already and expects it to fail (it may seem like a stretch, but I have seen similar scenarios)\n\nSure, even the most (seemingly) trivial assumptions can turn out to be wrong, and especially for essential functionality that is used all the time like tf.Session it is a good policy to be extra cautious.\nIdeally the implementation should of course be fully backwards compatible so it can be included in the main tf.Session class.", "body": "> Could this be done as an object on top of TF?\n> [...]\n> Maybe a way to go is to have a thin wrapper like \"EasySession\" or something like this on top, and if it gets traction, then people can switch over to using it rather than the old run interface.\n\nI assume that you are talking about (at least initially) implementing it as a subclass that can be used as e.g. `tf.EasySession` or `tf.contrib.Session` instead of `tf.Session`?\n\n> As you mention, one may want to extend it to tuples, nested dictionaries, or dictionaries containing lists of elements, so that's additional changes to the core TF. Also, maybe asking for \"isinstance(dict)\" is too restrictive, instead you might want to follow the spirit of duck-typing and accept any object that is dictionary-like.\n\nYes, you're right. The `run()` function I shared above was only made to cover my own basic needs and serve as an example.\n\nFor something like this to be more general I am currently thinking that it could maybe accept any python object that is an iterable container, and its return value should have the same structure. I don't know yet if that's possible, or necessary, or even worth it at all. I think my own needs would be covered if it just works with both lists and dictionaries.\n\n> In general, changes to core interface may break tests in unexpected ways and require some work to get integrated. For instance, there may be some code which feeds in a dict into session.run already and expects it to fail (it may seem like a stretch, but I have seen similar scenarios)\n\nSure, even the most (seemingly) trivial assumptions can turn out to be wrong, and especially for essential functionality that is used all the time like `tf.Session` it is a good policy to be extra cautious.\n\nIdeally the implementation should of course be fully backwards compatible so it can be included in the main `tf.Session` class.\n"}