{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/210055673", "html_url": "https://github.com/tensorflow/tensorflow/issues/1941#issuecomment-210055673", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/1941", "id": 210055673, "node_id": "MDEyOklzc3VlQ29tbWVudDIxMDA1NTY3Mw==", "user": {"login": "yaroslavvb", "id": 23068, "node_id": "MDQ6VXNlcjIzMDY4", "avatar_url": "https://avatars3.githubusercontent.com/u/23068?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yaroslavvb", "html_url": "https://github.com/yaroslavvb", "followers_url": "https://api.github.com/users/yaroslavvb/followers", "following_url": "https://api.github.com/users/yaroslavvb/following{/other_user}", "gists_url": "https://api.github.com/users/yaroslavvb/gists{/gist_id}", "starred_url": "https://api.github.com/users/yaroslavvb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yaroslavvb/subscriptions", "organizations_url": "https://api.github.com/users/yaroslavvb/orgs", "repos_url": "https://api.github.com/users/yaroslavvb/repos", "events_url": "https://api.github.com/users/yaroslavvb/events{/privacy}", "received_events_url": "https://api.github.com/users/yaroslavvb/received_events", "type": "User", "site_admin": false}, "created_at": "2016-04-14T17:14:29Z", "updated_at": "2016-04-14T17:14:29Z", "author_association": "CONTRIBUTOR", "body_html": "<p>OK, good point, it does seem mostly backward compatible. Could this be done as an object on top of TF? As you mention, one may want to extend it to tuples, nested dictionaries, or dictionaries containing lists of elements, so that's additional changes to the core TF. Also, maybe asking for \"isinstance(dict)\" is too restrictive, instead you might want to follow the spirit of duck-typing and accept any object that is dictionary-like</p>\n<p>Maybe a way to go is to have a thin wrapper like \"EasySession\" or something like this on top, and if it gets traction, then people can switch over to using it rather than the old run interface. In general, changes to core interface may break tests in unexpected ways an require some work to get integrated. For instance, there may be some code which feeds in a <code>dict</code> into session.run already and expects it to fail (it may seem like a stretch, but I have seen similar scenarios)</p>", "body_text": "OK, good point, it does seem mostly backward compatible. Could this be done as an object on top of TF? As you mention, one may want to extend it to tuples, nested dictionaries, or dictionaries containing lists of elements, so that's additional changes to the core TF. Also, maybe asking for \"isinstance(dict)\" is too restrictive, instead you might want to follow the spirit of duck-typing and accept any object that is dictionary-like\nMaybe a way to go is to have a thin wrapper like \"EasySession\" or something like this on top, and if it gets traction, then people can switch over to using it rather than the old run interface. In general, changes to core interface may break tests in unexpected ways an require some work to get integrated. For instance, there may be some code which feeds in a dict into session.run already and expects it to fail (it may seem like a stretch, but I have seen similar scenarios)", "body": "OK, good point, it does seem mostly backward compatible. Could this be done as an object on top of TF? As you mention, one may want to extend it to tuples, nested dictionaries, or dictionaries containing lists of elements, so that's additional changes to the core TF. Also, maybe asking for \"isinstance(dict)\" is too restrictive, instead you might want to follow the spirit of duck-typing and accept any object that is dictionary-like\n\nMaybe a way to go is to have a thin wrapper like \"EasySession\" or something like this on top, and if it gets traction, then people can switch over to using it rather than the old run interface. In general, changes to core interface may break tests in unexpected ways an require some work to get integrated. For instance, there may be some code which feeds in a `dict` into session.run already and expects it to fail (it may seem like a stretch, but I have seen similar scenarios)\n"}