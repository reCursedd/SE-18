{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/1941", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/1941/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/1941/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/1941/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/1941", "id": 148359785, "node_id": "MDU6SXNzdWUxNDgzNTk3ODU=", "number": 1941, "title": "Idea: support dictionary fetches with tf.Session.run()", "user": {"login": "Styrke", "id": 1035167, "node_id": "MDQ6VXNlcjEwMzUxNjc=", "avatar_url": "https://avatars3.githubusercontent.com/u/1035167?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Styrke", "html_url": "https://github.com/Styrke", "followers_url": "https://api.github.com/users/Styrke/followers", "following_url": "https://api.github.com/users/Styrke/following{/other_user}", "gists_url": "https://api.github.com/users/Styrke/gists{/gist_id}", "starred_url": "https://api.github.com/users/Styrke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Styrke/subscriptions", "organizations_url": "https://api.github.com/users/Styrke/orgs", "repos_url": "https://api.github.com/users/Styrke/repos", "events_url": "https://api.github.com/users/Styrke/events{/privacy}", "received_events_url": "https://api.github.com/users/Styrke/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 299643928, "node_id": "MDU6TGFiZWwyOTk2NDM5Mjg=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:contributions%20welcome", "name": "stat:contributions welcome", "color": "f4b400", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 10, "created_at": "2016-04-14T13:22:28Z", "updated_at": "2018-07-29T00:06:56Z", "closed_at": "2017-04-19T22:15:40Z", "author_association": "CONTRIBUTOR", "body_html": "<h1>The Idea</h1>\n<p>The <a href=\"https://www.tensorflow.org/versions/r0.8/api_docs/python/client.html#Session.run\" rel=\"nofollow\"><code>tf.Session.run()</code> method</a>, currently supports taking either a <em>single graph element</em>, or <em>a list of graph elements</em> as input for the <code>fetches</code> argument, and will return either a single value or a list of values correspondingly.</p>\n<p><strong>I propose adding support for using a dictionary as input for the fetch argument</strong>, and receiving a corresponding dictionary as the return value.</p>\n<p>Using dictionaries has at least two advantages compared to lists:</p>\n<ol>\n<li>\n<p>It will make the code <strong>more readable</strong>, and keys are easier to remember than indices. In the following example the return value of the loss can be accessed as <code>result['loss']</code> instead of <code>result[2]</code>.</p>\n<div class=\"highlight highlight-source-python\"><pre>fetches <span class=\"pl-k\">=</span> {\n<span class=\"pl-s\"><span class=\"pl-pds\">'</span>train_op<span class=\"pl-pds\">'</span></span>: train_op,\n<span class=\"pl-s\"><span class=\"pl-pds\">'</span>accuracy<span class=\"pl-pds\">'</span></span>: accuracy,\n<span class=\"pl-s\"><span class=\"pl-pds\">'</span>loss<span class=\"pl-pds\">'</span></span>: loss\n}\n\nresult <span class=\"pl-k\">=</span> sess.run(fetches, feed_dict)\n\n<span class=\"pl-c1\">print</span>(result[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>loss<span class=\"pl-pds\">'</span></span>], result[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>accuracy<span class=\"pl-pds\">'</span></span>])</pre></div>\n</li>\n<li>\n<p>It will be much <strong>easier to only fetch certain elements on flexible schedules</strong>.</p>\n<p>For example i might want to fetch summaries for TensorBoard every 20 iterations while only fetching the loss printing to the console every 50 iterations.</p>\n<p>That means that the return value would be a list that sometimes have none of the extra elements, sometimes one of them, and sometimes both. As a consequence the index in the returned list that contains the loss might vary from one run to the next, and I would have to build extra logic to handle this.</p>\n<p>With dictionaries the key doesn't change depending on other elements in the dict, so it would be possible to do something like saving summaries without even knowing the schedule:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">if</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>summaries<span class=\"pl-pds\">'</span></span> <span class=\"pl-k\">in</span> result:\n    writer.add_summary(result[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>summaries<span class=\"pl-pds\">'</span></span>], i)</pre></div>\n</li>\n</ol>\n<h1>Implementation</h1>\n<p>I have recently been emulating the proposed behavior in a project using using the following wrapper function to translate from dictionary to list and back.</p>\n<p>I suspect that it wouldn't be hard to do something similar in <a href=\"https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/client/session.py\">tensorflow/python/client/session.py</a> perhaps as part of <a href=\"https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/client/session.py#L455\">_process_fetches()</a>, but I didn't want to spend a lot of time on it before asking.</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">def</span> <span class=\"pl-en\">run</span>(<span class=\"pl-smi\">session</span>, <span class=\"pl-smi\">fetches</span>, <span class=\"pl-smi\">feed_dict</span>):\n    <span class=\"pl-s\"><span class=\"pl-pds\">\"\"\"</span>Wrapper for making Session.run() more user friendly.</span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">    With this function, fetches can be either a list or a dictionary.</span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">    If fetches is a list, this function will behave like</span>\n<span class=\"pl-s\">    tf.session.run() and return a list in the same order as well. If</span>\n<span class=\"pl-s\">    fetches is a dict then this function will also return a dict where</span>\n<span class=\"pl-s\">    the returned values are associated with the corresponding keys from</span>\n<span class=\"pl-s\">    the fetches dict.</span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">    Keyword arguments:</span>\n<span class=\"pl-s\">    session -- An open TensorFlow session.</span>\n<span class=\"pl-s\">    fetches -- A list or dict of ops to fetch.</span>\n<span class=\"pl-s\">    feed_dict -- The dict of values to feed to the computation graph.</span>\n<span class=\"pl-s\">    <span class=\"pl-pds\">\"\"\"</span></span>\n    <span class=\"pl-k\">if</span> <span class=\"pl-c1\">isinstance</span>(fetches, <span class=\"pl-c1\">dict</span>):\n        keys, values <span class=\"pl-k\">=</span> fetches.keys(), <span class=\"pl-c1\">list</span>(fetches.values())\n        res <span class=\"pl-k\">=</span> session.run(values, feed_dict)\n        <span class=\"pl-k\">return</span> {key: value <span class=\"pl-k\">for</span> key, value <span class=\"pl-k\">in</span> <span class=\"pl-c1\">zip</span>(keys, res)}\n    <span class=\"pl-k\">else</span>:\n        <span class=\"pl-k\">return</span> session.run(fetches, feed_dict)</pre></div>\n<h1>Questions</h1>\n<ul>\n<li>Is this a bad idea for some reason I don't realize? Or maybe I just overlooked some disadvantages that are worth considering?</li>\n<li>Why stop at dictionaries? What about tuples, nested dictionaries, or dictionaries containing lists of elements?</li>\n<li>General comments and thoughts?</li>\n</ul>", "body_text": "The Idea\nThe tf.Session.run() method, currently supports taking either a single graph element, or a list of graph elements as input for the fetches argument, and will return either a single value or a list of values correspondingly.\nI propose adding support for using a dictionary as input for the fetch argument, and receiving a corresponding dictionary as the return value.\nUsing dictionaries has at least two advantages compared to lists:\n\n\nIt will make the code more readable, and keys are easier to remember than indices. In the following example the return value of the loss can be accessed as result['loss'] instead of result[2].\nfetches = {\n'train_op': train_op,\n'accuracy': accuracy,\n'loss': loss\n}\n\nresult = sess.run(fetches, feed_dict)\n\nprint(result['loss'], result['accuracy'])\n\n\nIt will be much easier to only fetch certain elements on flexible schedules.\nFor example i might want to fetch summaries for TensorBoard every 20 iterations while only fetching the loss printing to the console every 50 iterations.\nThat means that the return value would be a list that sometimes have none of the extra elements, sometimes one of them, and sometimes both. As a consequence the index in the returned list that contains the loss might vary from one run to the next, and I would have to build extra logic to handle this.\nWith dictionaries the key doesn't change depending on other elements in the dict, so it would be possible to do something like saving summaries without even knowing the schedule:\nif 'summaries' in result:\n    writer.add_summary(result['summaries'], i)\n\n\nImplementation\nI have recently been emulating the proposed behavior in a project using using the following wrapper function to translate from dictionary to list and back.\nI suspect that it wouldn't be hard to do something similar in tensorflow/python/client/session.py perhaps as part of _process_fetches(), but I didn't want to spend a lot of time on it before asking.\ndef run(session, fetches, feed_dict):\n    \"\"\"Wrapper for making Session.run() more user friendly.\n\n    With this function, fetches can be either a list or a dictionary.\n\n    If fetches is a list, this function will behave like\n    tf.session.run() and return a list in the same order as well. If\n    fetches is a dict then this function will also return a dict where\n    the returned values are associated with the corresponding keys from\n    the fetches dict.\n\n    Keyword arguments:\n    session -- An open TensorFlow session.\n    fetches -- A list or dict of ops to fetch.\n    feed_dict -- The dict of values to feed to the computation graph.\n    \"\"\"\n    if isinstance(fetches, dict):\n        keys, values = fetches.keys(), list(fetches.values())\n        res = session.run(values, feed_dict)\n        return {key: value for key, value in zip(keys, res)}\n    else:\n        return session.run(fetches, feed_dict)\nQuestions\n\nIs this a bad idea for some reason I don't realize? Or maybe I just overlooked some disadvantages that are worth considering?\nWhy stop at dictionaries? What about tuples, nested dictionaries, or dictionaries containing lists of elements?\nGeneral comments and thoughts?", "body": "# The Idea\n\nThe [`tf.Session.run()` method](https://www.tensorflow.org/versions/r0.8/api_docs/python/client.html#Session.run), currently supports taking either a _single graph element_, or _a list of graph elements_ as input for the `fetches` argument, and will return either a single value or a list of values correspondingly.\n\n**I propose adding support for using a dictionary as input for the fetch argument**, and receiving a corresponding dictionary as the return value.\n\nUsing dictionaries has at least two advantages compared to lists:\n1. It will make the code **more readable**, and keys are easier to remember than indices. In the following example the return value of the loss can be accessed as `result['loss']` instead of `result[2]`.\n   \n   ``` python\n   fetches = {\n   'train_op': train_op,\n   'accuracy': accuracy,\n   'loss': loss\n   }\n   \n   result = sess.run(fetches, feed_dict)\n   \n   print(result['loss'], result['accuracy'])\n   ```\n2. It will be much **easier to only fetch certain elements on flexible schedules**.\n   \n   For example i might want to fetch summaries for TensorBoard every 20 iterations while only fetching the loss printing to the console every 50 iterations.\n   \n   That means that the return value would be a list that sometimes have none of the extra elements, sometimes one of them, and sometimes both. As a consequence the index in the returned list that contains the loss might vary from one run to the next, and I would have to build extra logic to handle this.\n   \n   With dictionaries the key doesn't change depending on other elements in the dict, so it would be possible to do something like saving summaries without even knowing the schedule:\n   \n   ``` python\n   if 'summaries' in result:\n       writer.add_summary(result['summaries'], i)\n   ```\n# Implementation\n\nI have recently been emulating the proposed behavior in a project using using the following wrapper function to translate from dictionary to list and back.\n\nI suspect that it wouldn't be hard to do something similar in [tensorflow/python/client/session.py](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/client/session.py) perhaps as part of [_process_fetches()](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/client/session.py#L455), but I didn't want to spend a lot of time on it before asking.\n\n``` python\ndef run(session, fetches, feed_dict):\n    \"\"\"Wrapper for making Session.run() more user friendly.\n\n    With this function, fetches can be either a list or a dictionary.\n\n    If fetches is a list, this function will behave like\n    tf.session.run() and return a list in the same order as well. If\n    fetches is a dict then this function will also return a dict where\n    the returned values are associated with the corresponding keys from\n    the fetches dict.\n\n    Keyword arguments:\n    session -- An open TensorFlow session.\n    fetches -- A list or dict of ops to fetch.\n    feed_dict -- The dict of values to feed to the computation graph.\n    \"\"\"\n    if isinstance(fetches, dict):\n        keys, values = fetches.keys(), list(fetches.values())\n        res = session.run(values, feed_dict)\n        return {key: value for key, value in zip(keys, res)}\n    else:\n        return session.run(fetches, feed_dict)\n```\n# Questions\n- Is this a bad idea for some reason I don't realize? Or maybe I just overlooked some disadvantages that are worth considering?\n- Why stop at dictionaries? What about tuples, nested dictionaries, or dictionaries containing lists of elements?\n- General comments and thoughts?\n"}