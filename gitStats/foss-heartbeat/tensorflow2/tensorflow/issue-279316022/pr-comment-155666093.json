{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/155666093", "pull_request_review_id": 82023489, "id": 155666093, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1NTY2NjA5Mw==", "diff_hunk": "@@ -129,7 +129,108 @@ def __del__(self):\n     _py_funcs.remove(self._token)\n \n \n-def py_func(func, inp, Tout, stateful=True, name=None):\n+def py_func(func, args=(), kwargs={}, output_types=None, output_shapes=None,\n+           stateful=True, name=None):\n+  \"\"\"Wraps a python function and uses it as a TensorFlow op.\n+\n+  Given a python function `func`, which takes numpy arrays as its\n+  inputs and returns numpy arrays as its outputs, wrap this function as an\n+  operation in a TensorFlow graph. The following snippet constructs a simple\n+  TensorFlow graph that invokes the `np.sinh()` NumPy function as a operation\n+  in the graph:\n+\n+  ```python\n+  def my_func(x):\n+    # x will be a numpy array with the contents of the placeholder below\n+    return np.sinh(x)\n+  inp = tf.placeholder(tf.float32)\n+  y = tf.py_func(my_func, [inp], tf.float32)\n+  ```\n+\n+\n+  **N.B.** The `tf.py_func()` operation has the following known limitations:\n+\n+  * The body of the function (i.e. `func`) will not be serialized in a\n+    `GraphDef`. Therefore, you should not use this function if you need to\n+    serialize your model and restore it in a different environment.\n+\n+  * The operation must run in the same address space as the Python program\n+    that calls `tf.py_func()`. If you are using distributed TensorFlow, you\n+    must run a `tf.train.Server` in the same process as the program that calls\n+    `tf.py_func()` and you must pin the created operation to a device in that\n+    server (e.g. using `with tf.device():`).\n+\n+  Args:\n+    func: A Python function, which accepts a list of NumPy `ndarray` objects\n+      having element types that match the corresponding `tf.Tensor` objects\n+      in `inp`, and returns a list of `ndarray` objects (or a single `ndarray`)\n+      having element types that match the corresponding values in `Tout`.\n+    args: A list of `Tensor` objects.\n+    kwargs: A dict with `Tensor` objects as values.\n+    output_types: A nested structure of tensorflow data types or a single\n+      tensorflow data type if there is only one, indicating what `func` returns.\n+    output_shapes: Same as output_types, except the types are replaces with\n+      shapes (optional).\n+    stateful: (Boolean.) If True, the function should be considered stateful.\n+      If a function is stateless, when given the same input it will return the\n+      same output and have no observable side effects. Optimizations such as\n+      common subexpression elimination are only performed on stateless\n+      operations.\n+    name: A name for the operation (optional).\n+\n+\n+  \"\"\"\n+  from tensorflow.python.framework import tensor_shape\n+  from tensorflow.python.util import nest\n+  # Note: tf.data.Dataset.from_generator use tensorflow.python.data.util.nest\n+\n+  if not isinstance(args, (list, tuple)):\n+    raise TypeError('args must be list and not {}. args: {}'.format(\n+      type(args), args))\n+\n+  if not isinstance(kwargs, dict):\n+    raise TypeError('kwargs must be dict and not {}. args: {}'.format(\n+      type(kwargs), kwargs))\n+\n+  # For dynamic type inference use callable output_types and output_shapes\n+  if callable(output_types):\n+    # If callable, assume same signature and call with tensors and get the types\n+    output_types = output_types(*args, **kwargs)\n+  if callable(output_shapes):\n+      # If callable, assume same signature and call with tensors and get the shapes\n+      output_shapes = output_shapes(*args, **kwargs)\n+\n+  flat_output_types = nest.flatten(output_types)", "path": "tensorflow/python/ops/script_ops.py", "position": null, "original_position": 76, "commit_id": "93cc00cd0bb28144a435324cd9d2f6db4845594a", "original_commit_id": "c92cbe13300ebcd56887ac2d0e74450e122154fc", "user": {"login": "boeddeker", "id": 13744128, "node_id": "MDQ6VXNlcjEzNzQ0MTI4", "avatar_url": "https://avatars3.githubusercontent.com/u/13744128?v=4", "gravatar_id": "", "url": "https://api.github.com/users/boeddeker", "html_url": "https://github.com/boeddeker", "followers_url": "https://api.github.com/users/boeddeker/followers", "following_url": "https://api.github.com/users/boeddeker/following{/other_user}", "gists_url": "https://api.github.com/users/boeddeker/gists{/gist_id}", "starred_url": "https://api.github.com/users/boeddeker/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/boeddeker/subscriptions", "organizations_url": "https://api.github.com/users/boeddeker/orgs", "repos_url": "https://api.github.com/users/boeddeker/repos", "events_url": "https://api.github.com/users/boeddeker/events{/privacy}", "received_events_url": "https://api.github.com/users/boeddeker/received_events", "type": "User", "site_admin": false}, "body": "You are right. The main changed are allow kwargs as input and arbitrary returns with shapes (earlier only list/scalar without shape).\r\nAnother (not so important) point is to allow shape/type inference from the input.(Useful for decorators)\r\nIf you prefer `contrib.py_func` I can move the code to contrib.\r\nIf you prefer a third-party library, I will keep the code in a private repo.\r\n \r\nWhen you need a use case inside of tf for this modification, look in `tf.data.Dataset.from_generator`.\r\nThe code there was the starting point.", "created_at": "2017-12-07T23:02:18Z", "updated_at": "2018-01-11T14:32:07Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/15121#discussion_r155666093", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/15121", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/155666093"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/15121#discussion_r155666093"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/15121"}}, "body_html": "<p>You are right. The main changed are allow kwargs as input and arbitrary returns with shapes (earlier only list/scalar without shape).<br>\nAnother (not so important) point is to allow shape/type inference from the input.(Useful for decorators)<br>\nIf you prefer <code>contrib.py_func</code> I can move the code to contrib.<br>\nIf you prefer a third-party library, I will keep the code in a private repo.</p>\n<p>When you need a use case inside of tf for this modification, look in <code>tf.data.Dataset.from_generator</code>.<br>\nThe code there was the starting point.</p>", "body_text": "You are right. The main changed are allow kwargs as input and arbitrary returns with shapes (earlier only list/scalar without shape).\nAnother (not so important) point is to allow shape/type inference from the input.(Useful for decorators)\nIf you prefer contrib.py_func I can move the code to contrib.\nIf you prefer a third-party library, I will keep the code in a private repo.\nWhen you need a use case inside of tf for this modification, look in tf.data.Dataset.from_generator.\nThe code there was the starting point.", "in_reply_to_id": 155659606}