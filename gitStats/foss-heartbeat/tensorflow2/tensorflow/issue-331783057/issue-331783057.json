{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/19959", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/19959/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/19959/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/19959/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/19959", "id": 331783057, "node_id": "MDU6SXNzdWUzMzE3ODMwNTc=", "number": 19959, "title": "Evaluate network first, and then apply gradients", "user": {"login": "kryczko", "id": 3220144, "node_id": "MDQ6VXNlcjMyMjAxNDQ=", "avatar_url": "https://avatars3.githubusercontent.com/u/3220144?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kryczko", "html_url": "https://github.com/kryczko", "followers_url": "https://api.github.com/users/kryczko/followers", "following_url": "https://api.github.com/users/kryczko/following{/other_user}", "gists_url": "https://api.github.com/users/kryczko/gists{/gist_id}", "starred_url": "https://api.github.com/users/kryczko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kryczko/subscriptions", "organizations_url": "https://api.github.com/users/kryczko/orgs", "repos_url": "https://api.github.com/users/kryczko/repos", "events_url": "https://api.github.com/users/kryczko/events{/privacy}", "received_events_url": "https://api.github.com/users/kryczko/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": {"login": "mrry", "id": 192142, "node_id": "MDQ6VXNlcjE5MjE0Mg==", "avatar_url": "https://avatars1.githubusercontent.com/u/192142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mrry", "html_url": "https://github.com/mrry", "followers_url": "https://api.github.com/users/mrry/followers", "following_url": "https://api.github.com/users/mrry/following{/other_user}", "gists_url": "https://api.github.com/users/mrry/gists{/gist_id}", "starred_url": "https://api.github.com/users/mrry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mrry/subscriptions", "organizations_url": "https://api.github.com/users/mrry/orgs", "repos_url": "https://api.github.com/users/mrry/repos", "events_url": "https://api.github.com/users/mrry/events{/privacy}", "received_events_url": "https://api.github.com/users/mrry/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "mrry", "id": 192142, "node_id": "MDQ6VXNlcjE5MjE0Mg==", "avatar_url": "https://avatars1.githubusercontent.com/u/192142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mrry", "html_url": "https://github.com/mrry", "followers_url": "https://api.github.com/users/mrry/followers", "following_url": "https://api.github.com/users/mrry/following{/other_user}", "gists_url": "https://api.github.com/users/mrry/gists{/gist_id}", "starred_url": "https://api.github.com/users/mrry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mrry/subscriptions", "organizations_url": "https://api.github.com/users/mrry/orgs", "repos_url": "https://api.github.com/users/mrry/repos", "events_url": "https://api.github.com/users/mrry/events{/privacy}", "received_events_url": "https://api.github.com/users/mrry/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 7, "created_at": "2018-06-12T22:58:20Z", "updated_at": "2018-06-29T16:56:28Z", "closed_at": "2018-06-29T16:43:19Z", "author_association": "NONE", "body_html": "<p>Dear TensorFlow team,</p>\n<p>I believe I have hit a limitation of TensorFlow and was wondering if you (or the community) could assist me. I am trying to initialize a graph with a topology from the paper seen here: <a href=\"https://arxiv.org/abs/1708.06686\" rel=\"nofollow\">https://arxiv.org/abs/1708.06686</a>. In this paper, one splits an image into tiles (which can overlap) and has some sort of network for each tile. The output of each network is then summed to obtain an output. The problem is when you split the image into many tiles, the computational graph becomes very large and one will often run out of memory. In this topology the network is shared across all tiles. For inference, one never hits a memory problem, because one can evaluate the value of each tile one by one. This is where I am having an issue. I cannot seem to define gradients properly if I first evaluate the tiles one by one. The way that TensorFlow is currently set up, I have to define the full computational graph to get the correct gradients. Is there a way I could evaluate the tiles first, and then apply gradients afterwards?</p>\n<p>OS Platform and Distribution: MacOS<br>\nTensorFlow installed from: TensorFlow<br>\nTensorFlow version: 1.8<br>\nBazel version: Unknown<br>\nCUDA/cuDNN version: N/A (this experiment was ran on CPU)<br>\nGPU model and memory: N/A<br>\nExact command to reproduce: <a href=\"https://anaconda.org/kryczko/untitled3/notebook\" rel=\"nofollow\">https://anaconda.org/kryczko/untitled3/notebook</a></p>", "body_text": "Dear TensorFlow team,\nI believe I have hit a limitation of TensorFlow and was wondering if you (or the community) could assist me. I am trying to initialize a graph with a topology from the paper seen here: https://arxiv.org/abs/1708.06686. In this paper, one splits an image into tiles (which can overlap) and has some sort of network for each tile. The output of each network is then summed to obtain an output. The problem is when you split the image into many tiles, the computational graph becomes very large and one will often run out of memory. In this topology the network is shared across all tiles. For inference, one never hits a memory problem, because one can evaluate the value of each tile one by one. This is where I am having an issue. I cannot seem to define gradients properly if I first evaluate the tiles one by one. The way that TensorFlow is currently set up, I have to define the full computational graph to get the correct gradients. Is there a way I could evaluate the tiles first, and then apply gradients afterwards?\nOS Platform and Distribution: MacOS\nTensorFlow installed from: TensorFlow\nTensorFlow version: 1.8\nBazel version: Unknown\nCUDA/cuDNN version: N/A (this experiment was ran on CPU)\nGPU model and memory: N/A\nExact command to reproduce: https://anaconda.org/kryczko/untitled3/notebook", "body": "Dear TensorFlow team,\r\n\r\nI believe I have hit a limitation of TensorFlow and was wondering if you (or the community) could assist me. I am trying to initialize a graph with a topology from the paper seen here: https://arxiv.org/abs/1708.06686. In this paper, one splits an image into tiles (which can overlap) and has some sort of network for each tile. The output of each network is then summed to obtain an output. The problem is when you split the image into many tiles, the computational graph becomes very large and one will often run out of memory. In this topology the network is shared across all tiles. For inference, one never hits a memory problem, because one can evaluate the value of each tile one by one. This is where I am having an issue. I cannot seem to define gradients properly if I first evaluate the tiles one by one. The way that TensorFlow is currently set up, I have to define the full computational graph to get the correct gradients. Is there a way I could evaluate the tiles first, and then apply gradients afterwards?\r\n\r\nOS Platform and Distribution: MacOS\r\nTensorFlow installed from: TensorFlow \r\nTensorFlow version: 1.8\r\nBazel version: Unknown\r\nCUDA/cuDNN version: N/A (this experiment was ran on CPU)\r\nGPU model and memory: N/A\r\nExact command to reproduce: https://anaconda.org/kryczko/untitled3/notebook"}