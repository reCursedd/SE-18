{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/4542", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/4542/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/4542/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/4542/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/4542", "id": 178777551, "node_id": "MDU6SXNzdWUxNzg3Nzc1NTE=", "number": 4542, "title": "\"Convolution\" across two matrices", "user": {"login": "Karl-Krauth", "id": 4045620, "node_id": "MDQ6VXNlcjQwNDU2MjA=", "avatar_url": "https://avatars0.githubusercontent.com/u/4045620?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Karl-Krauth", "html_url": "https://github.com/Karl-Krauth", "followers_url": "https://api.github.com/users/Karl-Krauth/followers", "following_url": "https://api.github.com/users/Karl-Krauth/following{/other_user}", "gists_url": "https://api.github.com/users/Karl-Krauth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Karl-Krauth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Karl-Krauth/subscriptions", "organizations_url": "https://api.github.com/users/Karl-Krauth/orgs", "repos_url": "https://api.github.com/users/Karl-Krauth/repos", "events_url": "https://api.github.com/users/Karl-Krauth/events{/privacy}", "received_events_url": "https://api.github.com/users/Karl-Krauth/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2016-09-23T03:42:53Z", "updated_at": "2016-09-25T07:48:55Z", "closed_at": "2016-09-25T07:48:55Z", "author_association": "NONE", "body_html": "<p>Are there any plans to implement \"convolutions\" wherein we have a moving patch over a second matrix that acts as a changing filter?</p>\n<p>This would be useful for implementing kernels such as this one:<br>\n<a href=\"https://papers.nips.cc/paper/5348-convolutional-kernel-networks.pdf\" rel=\"nofollow\">https://papers.nips.cc/paper/5348-convolutional-kernel-networks.pdf</a></p>\n<p>I asked whether a restricted version of this could be achieved by using already existing tf ops on <a href=\"http://stackoverflow.com/questions/39632849/dot-product-of-patches-in-tensorflow\" rel=\"nofollow\">stack overflow</a>. After thinking about it for a while though I don't think there's a way to do this in an efficient manner</p>\n<p>For a simple convolution with no strides I could do something like:<br>\n<code>filters = tf.extract_image_patches(filter_matrix, [filter_height, filter_width], [1, 1, 1, 1], [1, 1, 1, 1], padding)</code><br>\n<code>filters = tf.reshape(filters, [out_rows * out_cols, filter_height, filter_width, n_channels])</code><br>\n<code>filters = tf.transpose(filters, [1, 2, 3, 0])</code><br>\n<code>tf.conv2d(image, filters, [1, 1, 1, 1], padding)</code><br>\nbut it seems inefficient since I'd be generating an intermediate tensor that is going to be about filter_height * filter_width larger than filter_matrix.</p>\n<p>If there is a need for such an op but no plans to implement it in the immediate future, I'm happy to look into adding it.</p>", "body_text": "Are there any plans to implement \"convolutions\" wherein we have a moving patch over a second matrix that acts as a changing filter?\nThis would be useful for implementing kernels such as this one:\nhttps://papers.nips.cc/paper/5348-convolutional-kernel-networks.pdf\nI asked whether a restricted version of this could be achieved by using already existing tf ops on stack overflow. After thinking about it for a while though I don't think there's a way to do this in an efficient manner\nFor a simple convolution with no strides I could do something like:\nfilters = tf.extract_image_patches(filter_matrix, [filter_height, filter_width], [1, 1, 1, 1], [1, 1, 1, 1], padding)\nfilters = tf.reshape(filters, [out_rows * out_cols, filter_height, filter_width, n_channels])\nfilters = tf.transpose(filters, [1, 2, 3, 0])\ntf.conv2d(image, filters, [1, 1, 1, 1], padding)\nbut it seems inefficient since I'd be generating an intermediate tensor that is going to be about filter_height * filter_width larger than filter_matrix.\nIf there is a need for such an op but no plans to implement it in the immediate future, I'm happy to look into adding it.", "body": "Are there any plans to implement \"convolutions\" wherein we have a moving patch over a second matrix that acts as a changing filter?\n\nThis would be useful for implementing kernels such as this one:\nhttps://papers.nips.cc/paper/5348-convolutional-kernel-networks.pdf\n\nI asked whether a restricted version of this could be achieved by using already existing tf ops on [stack overflow](http://stackoverflow.com/questions/39632849/dot-product-of-patches-in-tensorflow). After thinking about it for a while though I don't think there's a way to do this in an efficient manner\n\nFor a simple convolution with no strides I could do something like:\n`filters = tf.extract_image_patches(filter_matrix, [filter_height, filter_width], [1, 1, 1, 1], [1, 1, 1, 1], padding)`\n`filters = tf.reshape(filters, [out_rows * out_cols, filter_height, filter_width, n_channels])`\n`filters = tf.transpose(filters, [1, 2, 3, 0])`\n`tf.conv2d(image, filters, [1, 1, 1, 1], padding)`\nbut it seems inefficient since I'd be generating an intermediate tensor that is going to be about filter_height \\* filter_width larger than filter_matrix.\n\nIf there is a need for such an op but no plans to implement it in the immediate future, I'm happy to look into adding it.\n"}