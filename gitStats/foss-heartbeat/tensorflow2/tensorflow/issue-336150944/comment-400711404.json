{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/400711404", "html_url": "https://github.com/tensorflow/tensorflow/issues/20338#issuecomment-400711404", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/20338", "id": 400711404, "node_id": "MDEyOklzc3VlQ29tbWVudDQwMDcxMTQwNA==", "user": {"login": "zakizhou", "id": 19201532, "node_id": "MDQ6VXNlcjE5MjAxNTMy", "avatar_url": "https://avatars0.githubusercontent.com/u/19201532?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zakizhou", "html_url": "https://github.com/zakizhou", "followers_url": "https://api.github.com/users/zakizhou/followers", "following_url": "https://api.github.com/users/zakizhou/following{/other_user}", "gists_url": "https://api.github.com/users/zakizhou/gists{/gist_id}", "starred_url": "https://api.github.com/users/zakizhou/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zakizhou/subscriptions", "organizations_url": "https://api.github.com/users/zakizhou/orgs", "repos_url": "https://api.github.com/users/zakizhou/repos", "events_url": "https://api.github.com/users/zakizhou/events{/privacy}", "received_events_url": "https://api.github.com/users/zakizhou/received_events", "type": "User", "site_admin": false}, "created_at": "2018-06-27T15:14:58Z", "updated_at": "2018-06-27T15:30:37Z", "author_association": "NONE", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=12476624\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/David-Mao\">@David-Mao</a> I know that, but that's impossible for your situation. Essentially you should understand why nearly all apis in keras are compatible with eager and graph, that is because that classes like <code>tf.keras.layers.Con2D</code> are just a combination of internal tensorflow operations like <code>tf.get_variable</code> and <code>tf.nn.conv2d</code> which are naturally compatible with eager and graph. But there are exceptions, the most typical one is <code>tf.placeholder</code> which stands for a empty and symbolic tensor in graph mode, in eager mode, each operation should immediately have an output tensor with exact value, so operations like <code>tf.placeholder</code> makes no sense in eager  mode and will never be compatible with eager, so is <code>tf.keras.Input</code> which make use of it.</p>", "body_text": "@David-Mao I know that, but that's impossible for your situation. Essentially you should understand why nearly all apis in keras are compatible with eager and graph, that is because that classes like tf.keras.layers.Con2D are just a combination of internal tensorflow operations like tf.get_variable and tf.nn.conv2d which are naturally compatible with eager and graph. But there are exceptions, the most typical one is tf.placeholder which stands for a empty and symbolic tensor in graph mode, in eager mode, each operation should immediately have an output tensor with exact value, so operations like tf.placeholder makes no sense in eager  mode and will never be compatible with eager, so is tf.keras.Input which make use of it.", "body": "@David-Mao I know that, but that's impossible for your situation. Essentially you should understand why nearly all apis in keras are compatible with eager and graph, that is because that classes like `tf.keras.layers.Con2D` are just a combination of internal tensorflow operations like `tf.get_variable` and `tf.nn.conv2d` which are naturally compatible with eager and graph. But there are exceptions, the most typical one is `tf.placeholder` which stands for a empty and symbolic tensor in graph mode, in eager mode, each operation should immediately have an output tensor with exact value, so operations like `tf.placeholder` makes no sense in eager  mode and will never be compatible with eager, so is `tf.keras.Input` which make use of it."}