{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/151567465", "pull_request_review_id": 77296709, "id": 151567465, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1MTU2NzQ2NQ==", "diff_hunk": "@@ -32,188 +26,295 @@\n #define LOG(x) std::cerr\n #define CHECK(x) if (!(x)) { LOG(ERROR) << #x << \"failed\"; exit(1); }\n \n-NSString* RunInferenceOnImage();\n+static void GetTopN(const float* prediction,\n+                    const int prediction_size,\n+                    const int num_results, const float threshold,\n+                    std::vector<std::pair<float, int> >* top_results);\n+\n+@interface RunModelViewController ()<UINavigationControllerDelegate, UIImagePickerControllerDelegate>\n+@property (weak, nonatomic) IBOutlet UIImageView *imageView;\n+@property (weak, nonatomic) IBOutlet UITextView *textView;\n \n-@interface RunModelViewController ()\n @end\n \n-@implementation RunModelViewController {\n-}\n+@implementation RunModelViewController\n \n-- (IBAction)getUrl:(id)sender {\n-  NSString* inference_result = RunInferenceOnImage();\n-  self.urlContentTextView.text = inference_result;\n+- (void)viewDidLoad {\n+    [super viewDidLoad];\n+    self.imageView.image = [UIImage imageNamed:@\"grace_hopper.jpg\"];\n }\n \n-@end\n+- (void)didReceiveMemoryWarning {\n+    [super didReceiveMemoryWarning];\n+    // Dispose of any resources that can be recreated.\n+}\n \n-// Returns the top N confidence values over threshold in the provided vector,\n-// sorted by confidence in descending order.\n-static void GetTopN(\n-    const float* prediction,\n-    const int prediction_size,\n-    const int num_results, const float threshold,\n-    std::vector<std::pair<float, int> >* top_results) {\n-  // Will contain top N results in ascending order.\n-  std::priority_queue<std::pair<float, int>,\n-      std::vector<std::pair<float, int> >,\n-      std::greater<std::pair<float, int> > > top_result_pq;\n-\n-  const long count = prediction_size;\n-  for (int i = 0; i < count; ++i) {\n-    const float value = prediction[i];\n-\n-    // Only add it if it beats the threshold and has a chance at being in\n-    // the top N.\n-    if (value < threshold) {\n-      continue;\n-    }\n-\n-    top_result_pq.push(std::pair<float, int>(value, i));\n-\n-    // If at capacity, kick the smallest value out.\n-    if (top_result_pq.size() > num_results) {\n-      top_result_pq.pop();\n-    }\n-  }\n-\n-  // Copy to output vector and reverse into descending order.\n-  while (!top_result_pq.empty()) {\n-    top_results->push_back(top_result_pq.top());\n-    top_result_pq.pop();\n-  }\n-  std::reverse(top_results->begin(), top_results->end());\n+- (IBAction)runModel:(UIButton *)sender {\n+    self.textView.text = [self runInferenceOnImage:self.imageView.image];\n }\n \n-NSString* FilePathForResourceName(NSString* name, NSString* extension) {\n-  NSString* file_path = [[NSBundle mainBundle] pathForResource:name ofType:extension];\n-  if (file_path == NULL) {\n-    LOG(FATAL) << \"Couldn't find '\" << [name UTF8String] << \".\"\n-\t       << [extension UTF8String] << \"' in bundle.\";\n-  }\n-  return file_path;\n+- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary<NSString *,id> *)info; {\n+    [picker dismissViewControllerAnimated:YES completion:nil];\n+    dispatch_async(dispatch_get_main_queue(), ^{\n+        self.imageView.image = [self fixrotation:info[UIImagePickerControllerOriginalImage]];;\n+    });\n }\n \n-NSString* RunInferenceOnImage() {\n-  std::string graph;\n-  const int num_threads = 1;\n-  std::string input_layer_type = \"float\";\n-  std::vector<int> sizes = {1, 224, 224, 3};\n+- (IBAction)openPhoto:(UIBarButtonItem *)sender {\n+    UIImagePickerController *picker;\n+    if ([UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypePhotoLibrary]) {\n+        picker = [[UIImagePickerController alloc] init];\n+        picker.delegate = self;\n+        picker.sourceType = UIImagePickerControllerSourceTypePhotoLibrary;\n+    }\n+    [self presentViewController:picker animated:YES completion:nil];\n+}\n \n-  NSString* graph_path = FilePathForResourceName(@\"mobilenet_v1_1.0_224\", @\"tflite\");\n+- (UIImage *)fixrotation:(UIImage *)image{\n+    if (image.imageOrientation == UIImageOrientationUp) return image;\n+    CGAffineTransform transform = CGAffineTransformIdentity;\n+    \n+    switch (image.imageOrientation) {\n+        case UIImageOrientationDown:\n+        case UIImageOrientationDownMirrored:\n+            transform = CGAffineTransformTranslate(transform, image.size.width, image.size.height);\n+            transform = CGAffineTransformRotate(transform, (CGFloat) M_PI);\n+            break;\n+            \n+        case UIImageOrientationLeft:\n+        case UIImageOrientationLeftMirrored:\n+            transform = CGAffineTransformTranslate(transform, image.size.width, 0);\n+            transform = CGAffineTransformRotate(transform, (CGFloat) M_PI_2);\n+            break;\n+            \n+        case UIImageOrientationRight:\n+        case UIImageOrientationRightMirrored:\n+            transform = CGAffineTransformTranslate(transform, 0, image.size.height);\n+            transform = CGAffineTransformRotate(transform, (CGFloat) -M_PI_2);\n+            break;\n+        case UIImageOrientationUp:\n+        case UIImageOrientationUpMirrored:\n+            break;\n+    }\n+    \n+    switch (image.imageOrientation) {\n+        case UIImageOrientationUpMirrored:\n+        case UIImageOrientationDownMirrored:\n+            transform = CGAffineTransformTranslate(transform, image.size.width, 0);\n+            transform = CGAffineTransformScale(transform, -1, 1);\n+            break;\n+            \n+        case UIImageOrientationLeftMirrored:\n+        case UIImageOrientationRightMirrored:\n+            transform = CGAffineTransformTranslate(transform, image.size.height, 0);\n+            transform = CGAffineTransformScale(transform, -1, 1);\n+            break;\n+        case UIImageOrientationUp:\n+        case UIImageOrientationDown:\n+        case UIImageOrientationLeft:\n+        case UIImageOrientationRight:\n+            break;\n+    }\n+    \n+    // Now we draw the underlying CGImage into a new context, applying the transform\n+    // calculated above.\n+    CGContextRef ctx = CGBitmapContextCreate(NULL, (size_t) image.size.width, (size_t) image.size.height,", "path": "tensorflow/contrib/lite/examples/ios/simple/RunModelViewController.mm", "position": null, "original_position": 174, "commit_id": "0027f6bad02d840afe9c9e6e8f4ce23668b91070", "original_commit_id": "2bf41d52cbae9f279db378edc0466b62ca0c6f71", "user": {"login": "dmaclach", "id": 320201, "node_id": "MDQ6VXNlcjMyMDIwMQ==", "avatar_url": "https://avatars3.githubusercontent.com/u/320201?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dmaclach", "html_url": "https://github.com/dmaclach", "followers_url": "https://api.github.com/users/dmaclach/followers", "following_url": "https://api.github.com/users/dmaclach/following{/other_user}", "gists_url": "https://api.github.com/users/dmaclach/gists{/gist_id}", "starred_url": "https://api.github.com/users/dmaclach/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dmaclach/subscriptions", "organizations_url": "https://api.github.com/users/dmaclach/orgs", "repos_url": "https://api.github.com/users/dmaclach/repos", "events_url": "https://api.github.com/users/dmaclach/events{/privacy}", "received_events_url": "https://api.github.com/users/dmaclach/received_events", "type": "User", "site_admin": false}, "body": "do you need the (size_t) casts? if so, normally we don't put a space after them.", "created_at": "2017-11-16T23:31:25Z", "updated_at": "2018-07-31T08:30:25Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/14592#discussion_r151567465", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/14592", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/151567465"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/14592#discussion_r151567465"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/14592"}}, "body_html": "<p>do you need the (size_t) casts? if so, normally we don't put a space after them.</p>", "body_text": "do you need the (size_t) casts? if so, normally we don't put a space after them."}