{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/353212429", "html_url": "https://github.com/tensorflow/tensorflow/issues/13221#issuecomment-353212429", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13221", "id": 353212429, "node_id": "MDEyOklzc3VlQ29tbWVudDM1MzIxMjQyOQ==", "user": {"login": "zheng-xq", "id": 15736910, "node_id": "MDQ6VXNlcjE1NzM2OTEw", "avatar_url": "https://avatars0.githubusercontent.com/u/15736910?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zheng-xq", "html_url": "https://github.com/zheng-xq", "followers_url": "https://api.github.com/users/zheng-xq/followers", "following_url": "https://api.github.com/users/zheng-xq/following{/other_user}", "gists_url": "https://api.github.com/users/zheng-xq/gists{/gist_id}", "starred_url": "https://api.github.com/users/zheng-xq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zheng-xq/subscriptions", "organizations_url": "https://api.github.com/users/zheng-xq/orgs", "repos_url": "https://api.github.com/users/zheng-xq/repos", "events_url": "https://api.github.com/users/zheng-xq/events{/privacy}", "received_events_url": "https://api.github.com/users/zheng-xq/received_events", "type": "User", "site_admin": false}, "created_at": "2017-12-20T23:25:19Z", "updated_at": "2017-12-20T23:25:19Z", "author_association": "CONTRIBUTOR", "body_html": "<p>I have discussed with <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=6510203\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/reedwm\">@reedwm</a>, <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=192142\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/mrry\">@mrry</a>, <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=16018\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/asimshankar\">@asimshankar</a>, and <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=5061\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/alextp\">@alextp</a>.</p>\n<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=5061\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/alextp\">@alextp</a> has a pending change to have ops like zeros_like not to use constant. Even though that might cause a small performance drop, it should cause less overall trouble.</p>\n<p>In the long term, we want to switch to a constant manager within resource manager. When a ConstantOp is initialized, it will use its TensorProto as a key to query whether the same tensor had already been created. If so, the same Tensor will be used. If we provide a hash function for TensorProto, the constant manager can be implemented as a simple unordered_map. So if the same Python op have multiple C++ op, they will all share the same underlying Tensor.</p>\n<p>This will solve the leaking Tensor on device, but it still doesn't solve the underlying duplicated TensorProto for multiple ConstantOp, which should be addressed separately.</p>\n<p>I am marking this as contribution welcome, unless someone has cycles to work on it.</p>", "body_text": "I have discussed with @reedwm, @mrry, @asimshankar, and @alextp.\n@alextp has a pending change to have ops like zeros_like not to use constant. Even though that might cause a small performance drop, it should cause less overall trouble.\nIn the long term, we want to switch to a constant manager within resource manager. When a ConstantOp is initialized, it will use its TensorProto as a key to query whether the same tensor had already been created. If so, the same Tensor will be used. If we provide a hash function for TensorProto, the constant manager can be implemented as a simple unordered_map. So if the same Python op have multiple C++ op, they will all share the same underlying Tensor.\nThis will solve the leaking Tensor on device, but it still doesn't solve the underlying duplicated TensorProto for multiple ConstantOp, which should be addressed separately.\nI am marking this as contribution welcome, unless someone has cycles to work on it.", "body": "I have discussed with @reedwm, @mrry, @asimshankar, and @alextp. \r\n\r\n@alextp has a pending change to have ops like zeros_like not to use constant. Even though that might cause a small performance drop, it should cause less overall trouble.\r\n\r\nIn the long term, we want to switch to a constant manager within resource manager. When a ConstantOp is initialized, it will use its TensorProto as a key to query whether the same tensor had already been created. If so, the same Tensor will be used. If we provide a hash function for TensorProto, the constant manager can be implemented as a simple unordered_map. So if the same Python op have multiple C++ op, they will all share the same underlying Tensor. \r\n\r\nThis will solve the leaking Tensor on device, but it still doesn't solve the underlying duplicated TensorProto for multiple ConstantOp, which should be addressed separately.\r\n\r\nI am marking this as contribution welcome, unless someone has cycles to work on it. \r\n"}