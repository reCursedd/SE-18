{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/263788721", "html_url": "https://github.com/tensorflow/tensorflow/pull/4222#issuecomment-263788721", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/4222", "id": 263788721, "node_id": "MDEyOklzc3VlQ29tbWVudDI2Mzc4ODcyMQ==", "user": {"login": "samjabrahams", "id": 11607205, "node_id": "MDQ6VXNlcjExNjA3MjA1", "avatar_url": "https://avatars0.githubusercontent.com/u/11607205?v=4", "gravatar_id": "", "url": "https://api.github.com/users/samjabrahams", "html_url": "https://github.com/samjabrahams", "followers_url": "https://api.github.com/users/samjabrahams/followers", "following_url": "https://api.github.com/users/samjabrahams/following{/other_user}", "gists_url": "https://api.github.com/users/samjabrahams/gists{/gist_id}", "starred_url": "https://api.github.com/users/samjabrahams/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/samjabrahams/subscriptions", "organizations_url": "https://api.github.com/users/samjabrahams/orgs", "repos_url": "https://api.github.com/users/samjabrahams/repos", "events_url": "https://api.github.com/users/samjabrahams/events{/privacy}", "received_events_url": "https://api.github.com/users/samjabrahams/received_events", "type": "User", "site_admin": false}, "created_at": "2016-11-30T05:45:10Z", "updated_at": "2016-11-30T05:46:06Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=70511\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/girving\">@girving</a> No worries- I've rebased and cleaned up the implementation a bit. The last major headache here is dealing with <code>channels</code> along the GIF path. Unfortunately, creating the path isn't as simple as the following:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">def</span> <span class=\"pl-en\">_gif</span>():\n    <span class=\"pl-k\">if</span> channels <span class=\"pl-k\">not</span> <span class=\"pl-k\">in</span> (<span class=\"pl-c1\">None</span>, <span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">3</span>):\n        <span class=\"pl-k\">raise</span> <span class=\"pl-c1\">ValueError</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>GIF images must be decoded with channels in (None, 0, 3)<span class=\"pl-ii\"></span></span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> ... do the op</span></pre></div>\n<p>Because <code>tf.cond</code> always ends up running the <code>_gif</code> function, the check happens even if there are no GIF files being decoded. That means that <code>channels</code> can't be set to 1 if we go with this approach.</p>\n<p>If we try using <code>tf.Assert</code> instead, it might look like this:</p>\n<div class=\"highlight highlight-source-python\"><pre>good_op <span class=\"pl-k\">=</span> tf.not_equal(channels, <span class=\"pl-c1\">1</span>)   <span class=\"pl-c\"><span class=\"pl-c\">#</span> Already checked that channels in (None, 0, 1, 3)</span>\nassert_good <span class=\"pl-k\">=</span> tf.Assert(good_op, [<span class=\"pl-s\"><span class=\"pl-pds\">'</span>channels can<span class=\"pl-pds\">'</span></span>t be <span class=\"pl-c1\">1</span>!<span class=\"pl-s\"><span class=\"pl-pds\">'</span>])<span class=\"pl-ii\"></span></span>\n<span class=\"pl-k\">with</span> tf.control_dependencies([assert_good]):\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> ...do the rest</span></pre></div>\n<p>This doesn't work either, as we run into the issue of <code>channels</code> being set to <code>None</code>, which can't be passed into <code>equal</code> or <code>not_equal</code>.</p>\n<p>In short, I'm not sure how I'd allow different channels for different image types. Here are two different ways to handle <code>channels</code> I know I can make work:</p>\n<ol>\n<li>Use <code>rgb_to_grayscale</code> to convert the GIF image to black/white if <code>channels</code> is set to 1. It might be a little bit much going on under-the-hood, but I imagine it accomplishes the intent of what users want. The current code does this.</li>\n<li>Only allow channels to be in (None, 0, 3), excluding 1 for all image types. This is a bit cleaner, though it reduces functionality.</li>\n</ol>", "body_text": "@girving No worries- I've rebased and cleaned up the implementation a bit. The last major headache here is dealing with channels along the GIF path. Unfortunately, creating the path isn't as simple as the following:\ndef _gif():\n    if channels not in (None, 0, 3):\n        raise ValueError('GIF images must be decoded with channels in (None, 0, 3)\n    # ... do the op\nBecause tf.cond always ends up running the _gif function, the check happens even if there are no GIF files being decoded. That means that channels can't be set to 1 if we go with this approach.\nIf we try using tf.Assert instead, it might look like this:\ngood_op = tf.not_equal(channels, 1)   # Already checked that channels in (None, 0, 1, 3)\nassert_good = tf.Assert(good_op, ['channels can't be 1!'])\nwith tf.control_dependencies([assert_good]):\n    # ...do the rest\nThis doesn't work either, as we run into the issue of channels being set to None, which can't be passed into equal or not_equal.\nIn short, I'm not sure how I'd allow different channels for different image types. Here are two different ways to handle channels I know I can make work:\n\nUse rgb_to_grayscale to convert the GIF image to black/white if channels is set to 1. It might be a little bit much going on under-the-hood, but I imagine it accomplishes the intent of what users want. The current code does this.\nOnly allow channels to be in (None, 0, 3), excluding 1 for all image types. This is a bit cleaner, though it reduces functionality.", "body": "@girving No worries- I've rebased and cleaned up the implementation a bit. The last major headache here is dealing with `channels` along the GIF path. Unfortunately, creating the path isn't as simple as the following:\r\n\r\n```python\r\ndef _gif():\r\n    if channels not in (None, 0, 3):\r\n        raise ValueError('GIF images must be decoded with channels in (None, 0, 3)\r\n    # ... do the op\r\n```\r\n\r\nBecause `tf.cond` always ends up running the `_gif` function, the check happens even if there are no GIF files being decoded. That means that `channels` can't be set to 1 if we go with this approach. \r\n\r\nIf we try using `tf.Assert` instead, it might look like this:\r\n\r\n```python\r\ngood_op = tf.not_equal(channels, 1)   # Already checked that channels in (None, 0, 1, 3)\r\nassert_good = tf.Assert(good_op, ['channels can't be 1!'])\r\nwith tf.control_dependencies([assert_good]):\r\n    # ...do the rest\r\n```\r\nThis doesn't work either, as we run into the issue of `channels` being set to `None`, which can't be passed into `equal` or `not_equal`.\r\n\r\nIn short, I'm not sure how I'd allow different channels for different image types. Here are two different ways to handle `channels` I know I can make work:\r\n\r\n1. Use `rgb_to_grayscale` to convert the GIF image to black/white if `channels` is set to 1. It might be a little bit much going on under-the-hood, but I imagine it accomplishes the intent of what users want. The current code does this.\r\n2. Only allow channels to be in (None, 0, 3), excluding 1 for all image types. This is a bit cleaner, though it reduces functionality."}