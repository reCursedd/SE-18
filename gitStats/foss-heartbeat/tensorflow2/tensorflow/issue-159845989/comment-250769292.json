{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/250769292", "html_url": "https://github.com/tensorflow/tensorflow/issues/2818#issuecomment-250769292", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2818", "id": 250769292, "node_id": "MDEyOklzc3VlQ29tbWVudDI1MDc2OTI5Mg==", "user": {"login": "ftamburin", "id": 15780295, "node_id": "MDQ6VXNlcjE1NzgwMjk1", "avatar_url": "https://avatars1.githubusercontent.com/u/15780295?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ftamburin", "html_url": "https://github.com/ftamburin", "followers_url": "https://api.github.com/users/ftamburin/followers", "following_url": "https://api.github.com/users/ftamburin/following{/other_user}", "gists_url": "https://api.github.com/users/ftamburin/gists{/gist_id}", "starred_url": "https://api.github.com/users/ftamburin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ftamburin/subscriptions", "organizations_url": "https://api.github.com/users/ftamburin/orgs", "repos_url": "https://api.github.com/users/ftamburin/repos", "events_url": "https://api.github.com/users/ftamburin/events{/privacy}", "received_events_url": "https://api.github.com/users/ftamburin/received_events", "type": "User", "site_admin": false}, "created_at": "2016-09-30T15:07:52Z", "updated_at": "2016-09-30T15:07:52Z", "author_association": "NONE", "body_html": "<p>I am trying to compute the gradients of a complex function in Tensorflow, but I have some trouble.<br>\nCould it be the same problem described by <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=890531\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/ibab\">@ibab</a> ?<br>\nHere is my code:</p>\n<pre><code>import numpy as np\nimport tensorflow as tf\n\ndef CompSEQ(rho0):\n\n    def EvolveRHO(prev, input):\n        return tf.matmul(rho0,prev)\n\n    rhos = tf.scan(EvolveRHO, np.array([1, 2, 3]), initializer=rho0)\n    return tf.real(tf.trace(tf.unpack(tf.slice(rhos,[2,0,0],[1,2,2]))[0]))\n\nnp.random.seed(1234)\nN = 2\n\nx_r = tf.Variable(tf.zeros([N,N], dtype=tf.float32))\nx_i = tf.Variable(tf.zeros([N,N], dtype=tf.float32))\nfun = CompSEQ(tf.complex(x_r,x_i))\n#grad = tf.gradients([fun],[x_r,x_i])    # THIS LINE CAUSES THE PROBLEM!!!\n\nsess = tf.Session()\nsess.run(tf.initialize_all_variables())\n\nre = np.random.rand(N,N).astype(np.float32)\nim = np.random.rand(N,N).astype(np.float32)\nprint('fun',sess.run(fun, feed_dict={x_r:re, x_i:im}))\nprint('grad',sess.run(grad, feed_dict={x_r:re, x_i:im}))\n</code></pre>\n<p>I use 2 input float32 vectors x,y that will be transformed into a complex matrix. All the computations are performed using complex numbers and at the end all the result is transformed into a float32 by taking the real part. If I comment the call to tf.gradients (as in the code) everything works fine, but when I try to compute the gradients I get the following error:</p>\n<pre><code>Traceback (most recent call last):\n  File \"errorS.py\", line 18, in &lt;module&gt;\n    grad = tf.gradients([fun],[x_r,x_i])    # THIS LINE CAUSES THE PROBLEM!!!\n  File \"/Users/tamburin/Library/Python/2.7/lib/python/site-packages/tensorflow/python/ops/gradients.py\", line 486, in gradients\n    _VerifyGeneratedGradients(in_grads, op)\n  File \"/Users/tamburin/Library/Python/2.7/lib/python/site-packages/tensorflow/python/ops/gradients.py\", line 264, in _VerifyGeneratedGradients\n    dtypes.as_dtype(inp.dtype).name))\nValueError: Gradient type float32 generated for op name: \"scan/while/Switch_1\"\nop: \"Switch\"\ninput: \"scan/while/Merge_1\"\ninput: \"scan/while/LoopCond\"\nattr {\n  key: \"T\"\n  value {\n    type: DT_COMPLEX64\n  }\n}\nattr {\n  key: \"_class\"\n  value {\n    list {\n      s: \"loc:@scan/while/Merge_1\"\n    }\n  }\n}\n does not match input type complex64\n</code></pre>\n<p>Converting all the computations into float32 variables (replacing tf.complex with tf.add and deleting tf.real) resolves the problem, but I need to maintain the computation on complex variables (this is a very simplified example w.r.t. my real problem).</p>", "body_text": "I am trying to compute the gradients of a complex function in Tensorflow, but I have some trouble.\nCould it be the same problem described by @ibab ?\nHere is my code:\nimport numpy as np\nimport tensorflow as tf\n\ndef CompSEQ(rho0):\n\n    def EvolveRHO(prev, input):\n        return tf.matmul(rho0,prev)\n\n    rhos = tf.scan(EvolveRHO, np.array([1, 2, 3]), initializer=rho0)\n    return tf.real(tf.trace(tf.unpack(tf.slice(rhos,[2,0,0],[1,2,2]))[0]))\n\nnp.random.seed(1234)\nN = 2\n\nx_r = tf.Variable(tf.zeros([N,N], dtype=tf.float32))\nx_i = tf.Variable(tf.zeros([N,N], dtype=tf.float32))\nfun = CompSEQ(tf.complex(x_r,x_i))\n#grad = tf.gradients([fun],[x_r,x_i])    # THIS LINE CAUSES THE PROBLEM!!!\n\nsess = tf.Session()\nsess.run(tf.initialize_all_variables())\n\nre = np.random.rand(N,N).astype(np.float32)\nim = np.random.rand(N,N).astype(np.float32)\nprint('fun',sess.run(fun, feed_dict={x_r:re, x_i:im}))\nprint('grad',sess.run(grad, feed_dict={x_r:re, x_i:im}))\n\nI use 2 input float32 vectors x,y that will be transformed into a complex matrix. All the computations are performed using complex numbers and at the end all the result is transformed into a float32 by taking the real part. If I comment the call to tf.gradients (as in the code) everything works fine, but when I try to compute the gradients I get the following error:\nTraceback (most recent call last):\n  File \"errorS.py\", line 18, in <module>\n    grad = tf.gradients([fun],[x_r,x_i])    # THIS LINE CAUSES THE PROBLEM!!!\n  File \"/Users/tamburin/Library/Python/2.7/lib/python/site-packages/tensorflow/python/ops/gradients.py\", line 486, in gradients\n    _VerifyGeneratedGradients(in_grads, op)\n  File \"/Users/tamburin/Library/Python/2.7/lib/python/site-packages/tensorflow/python/ops/gradients.py\", line 264, in _VerifyGeneratedGradients\n    dtypes.as_dtype(inp.dtype).name))\nValueError: Gradient type float32 generated for op name: \"scan/while/Switch_1\"\nop: \"Switch\"\ninput: \"scan/while/Merge_1\"\ninput: \"scan/while/LoopCond\"\nattr {\n  key: \"T\"\n  value {\n    type: DT_COMPLEX64\n  }\n}\nattr {\n  key: \"_class\"\n  value {\n    list {\n      s: \"loc:@scan/while/Merge_1\"\n    }\n  }\n}\n does not match input type complex64\n\nConverting all the computations into float32 variables (replacing tf.complex with tf.add and deleting tf.real) resolves the problem, but I need to maintain the computation on complex variables (this is a very simplified example w.r.t. my real problem).", "body": "I am trying to compute the gradients of a complex function in Tensorflow, but I have some trouble. \nCould it be the same problem described by @ibab ?\nHere is my code:\n\n```\nimport numpy as np\nimport tensorflow as tf\n\ndef CompSEQ(rho0):\n\n    def EvolveRHO(prev, input):\n        return tf.matmul(rho0,prev)\n\n    rhos = tf.scan(EvolveRHO, np.array([1, 2, 3]), initializer=rho0)\n    return tf.real(tf.trace(tf.unpack(tf.slice(rhos,[2,0,0],[1,2,2]))[0]))\n\nnp.random.seed(1234)\nN = 2\n\nx_r = tf.Variable(tf.zeros([N,N], dtype=tf.float32))\nx_i = tf.Variable(tf.zeros([N,N], dtype=tf.float32))\nfun = CompSEQ(tf.complex(x_r,x_i))\n#grad = tf.gradients([fun],[x_r,x_i])    # THIS LINE CAUSES THE PROBLEM!!!\n\nsess = tf.Session()\nsess.run(tf.initialize_all_variables())\n\nre = np.random.rand(N,N).astype(np.float32)\nim = np.random.rand(N,N).astype(np.float32)\nprint('fun',sess.run(fun, feed_dict={x_r:re, x_i:im}))\nprint('grad',sess.run(grad, feed_dict={x_r:re, x_i:im}))\n```\n\nI use 2 input float32 vectors x,y that will be transformed into a complex matrix. All the computations are performed using complex numbers and at the end all the result is transformed into a float32 by taking the real part. If I comment the call to tf.gradients (as in the code) everything works fine, but when I try to compute the gradients I get the following error:\n\n```\nTraceback (most recent call last):\n  File \"errorS.py\", line 18, in <module>\n    grad = tf.gradients([fun],[x_r,x_i])    # THIS LINE CAUSES THE PROBLEM!!!\n  File \"/Users/tamburin/Library/Python/2.7/lib/python/site-packages/tensorflow/python/ops/gradients.py\", line 486, in gradients\n    _VerifyGeneratedGradients(in_grads, op)\n  File \"/Users/tamburin/Library/Python/2.7/lib/python/site-packages/tensorflow/python/ops/gradients.py\", line 264, in _VerifyGeneratedGradients\n    dtypes.as_dtype(inp.dtype).name))\nValueError: Gradient type float32 generated for op name: \"scan/while/Switch_1\"\nop: \"Switch\"\ninput: \"scan/while/Merge_1\"\ninput: \"scan/while/LoopCond\"\nattr {\n  key: \"T\"\n  value {\n    type: DT_COMPLEX64\n  }\n}\nattr {\n  key: \"_class\"\n  value {\n    list {\n      s: \"loc:@scan/while/Merge_1\"\n    }\n  }\n}\n does not match input type complex64\n```\n\nConverting all the computations into float32 variables (replacing tf.complex with tf.add and deleting tf.real) resolves the problem, but I need to maintain the computation on complex variables (this is a very simplified example w.r.t. my real problem).\n"}