{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/23192", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/23192/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/23192/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/23192/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/23192", "id": 373113103, "node_id": "MDU6SXNzdWUzNzMxMTMxMDM=", "number": 23192, "title": "Prevent Empty Checkpointable Data Structure Restores", "user": {"login": "sleighsoft", "id": 9438971, "node_id": "MDQ6VXNlcjk0Mzg5NzE=", "avatar_url": "https://avatars3.githubusercontent.com/u/9438971?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sleighsoft", "html_url": "https://github.com/sleighsoft", "followers_url": "https://api.github.com/users/sleighsoft/followers", "following_url": "https://api.github.com/users/sleighsoft/following{/other_user}", "gists_url": "https://api.github.com/users/sleighsoft/gists{/gist_id}", "starred_url": "https://api.github.com/users/sleighsoft/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sleighsoft/subscriptions", "organizations_url": "https://api.github.com/users/sleighsoft/orgs", "repos_url": "https://api.github.com/users/sleighsoft/repos", "events_url": "https://api.github.com/users/sleighsoft/events{/privacy}", "received_events_url": "https://api.github.com/users/sleighsoft/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "open", "locked": false, "assignee": {"login": "allenlavoie", "id": 3731025, "node_id": "MDQ6VXNlcjM3MzEwMjU=", "avatar_url": "https://avatars3.githubusercontent.com/u/3731025?v=4", "gravatar_id": "", "url": "https://api.github.com/users/allenlavoie", "html_url": "https://github.com/allenlavoie", "followers_url": "https://api.github.com/users/allenlavoie/followers", "following_url": "https://api.github.com/users/allenlavoie/following{/other_user}", "gists_url": "https://api.github.com/users/allenlavoie/gists{/gist_id}", "starred_url": "https://api.github.com/users/allenlavoie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/allenlavoie/subscriptions", "organizations_url": "https://api.github.com/users/allenlavoie/orgs", "repos_url": "https://api.github.com/users/allenlavoie/repos", "events_url": "https://api.github.com/users/allenlavoie/events{/privacy}", "received_events_url": "https://api.github.com/users/allenlavoie/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "allenlavoie", "id": 3731025, "node_id": "MDQ6VXNlcjM3MzEwMjU=", "avatar_url": "https://avatars3.githubusercontent.com/u/3731025?v=4", "gravatar_id": "", "url": "https://api.github.com/users/allenlavoie", "html_url": "https://github.com/allenlavoie", "followers_url": "https://api.github.com/users/allenlavoie/followers", "following_url": "https://api.github.com/users/allenlavoie/following{/other_user}", "gists_url": "https://api.github.com/users/allenlavoie/gists{/gist_id}", "starred_url": "https://api.github.com/users/allenlavoie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/allenlavoie/subscriptions", "organizations_url": "https://api.github.com/users/allenlavoie/orgs", "repos_url": "https://api.github.com/users/allenlavoie/repos", "events_url": "https://api.github.com/users/allenlavoie/events{/privacy}", "received_events_url": "https://api.github.com/users/allenlavoie/received_events", "type": "User", "site_admin": false}, {"login": "wt-huang", "id": 42785337, "node_id": "MDQ6VXNlcjQyNzg1MzM3", "avatar_url": "https://avatars0.githubusercontent.com/u/42785337?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wt-huang", "html_url": "https://github.com/wt-huang", "followers_url": "https://api.github.com/users/wt-huang/followers", "following_url": "https://api.github.com/users/wt-huang/following{/other_user}", "gists_url": "https://api.github.com/users/wt-huang/gists{/gist_id}", "starred_url": "https://api.github.com/users/wt-huang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wt-huang/subscriptions", "organizations_url": "https://api.github.com/users/wt-huang/orgs", "repos_url": "https://api.github.com/users/wt-huang/repos", "events_url": "https://api.github.com/users/wt-huang/events{/privacy}", "received_events_url": "https://api.github.com/users/wt-huang/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 4, "created_at": "2018-10-23T17:29:42Z", "updated_at": "2018-11-16T15:35:32Z", "closed_at": null, "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=3731025\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/allenlavoie\">@allenlavoie</a></p>\n<p>Issue tracking the \"bug\" that is caused when restoring a checkpoint where the Checkpointable object has new checkpointable data structures that do not contain any checkpointable objects themselves and therefore prevent restoration when using <code>load_status.assert_consumed()</code>.</p>\n<p><em>Example Code:</em></p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">import</span> tensorflow <span class=\"pl-k\">as</span> tf\n<span class=\"pl-k\">from</span> tensorflow.python.training.checkpointable.tracking <span class=\"pl-k\">import</span> Checkpointable\n\n\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">Model</span>(<span class=\"pl-e\">Checkpointable</span>):\n\n  <span class=\"pl-k\">def</span> <span class=\"pl-c1\">__init__</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>):\n    <span class=\"pl-c1\">self</span>.variable <span class=\"pl-k\">=</span> tf.get_variable(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>variable<span class=\"pl-pds\">\"</span></span>, [<span class=\"pl-c1\">2</span>, <span class=\"pl-c1\">2</span>])\n    <span class=\"pl-c1\">self</span>.dict <span class=\"pl-k\">=</span> {\n        <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>test<span class=\"pl-pds\">\"</span></span>: <span class=\"pl-c1\">1</span>,\n        <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>test2<span class=\"pl-pds\">\"</span></span>: <span class=\"pl-c1\">2</span>,\n    }\n    <span class=\"pl-c1\">self</span>.dict_var <span class=\"pl-k\">=</span> {\n        <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>test<span class=\"pl-pds\">\"</span></span>: <span class=\"pl-c1\">1</span>,\n        <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>test2<span class=\"pl-pds\">\"</span></span>: tf.get_variable(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>dict_var<span class=\"pl-pds\">\"</span></span>, [<span class=\"pl-c1\">2</span>, <span class=\"pl-c1\">2</span>])\n    }\n    <span class=\"pl-c1\">self</span>.dict_nested_var <span class=\"pl-k\">=</span> {\n        <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>test<span class=\"pl-pds\">\"</span></span>: <span class=\"pl-c1\">1</span>,\n        <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>test2<span class=\"pl-pds\">\"</span></span>: {\n            <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>var<span class=\"pl-pds\">\"</span></span>: tf.get_variable(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>dict_nested_var<span class=\"pl-pds\">\"</span></span>, [<span class=\"pl-c1\">2</span>, <span class=\"pl-c1\">2</span>])\n        }\n    }\n    <span class=\"pl-c1\">self</span>.list_var <span class=\"pl-k\">=</span> [tf.get_variable(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>list_var<span class=\"pl-pds\">\"</span></span>, [<span class=\"pl-c1\">2</span>, <span class=\"pl-c1\">2</span>])]\n\n\n<span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>SAVE<span class=\"pl-pds\">'</span></span>)\n<span class=\"pl-k\">with</span> tf.Graph().as_default():\n\n  s <span class=\"pl-k\">=</span> tf.Session()\n\n  m <span class=\"pl-k\">=</span> Model()\n\n  s.run(tf.global_variables_initializer())\n\n  c <span class=\"pl-k\">=</span> tf.train.Checkpoint(<span class=\"pl-v\">model</span><span class=\"pl-k\">=</span>m)\n\n  c.save(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>checkpoints/<span class=\"pl-pds\">'</span></span>, <span class=\"pl-v\">session</span><span class=\"pl-k\">=</span>s)\n\n<span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>RESTORE<span class=\"pl-pds\">'</span></span>)\n<span class=\"pl-k\">with</span> tf.Graph().as_default():\n\n  s <span class=\"pl-k\">=</span> tf.Session()\n\n  m <span class=\"pl-k\">=</span> Model()\n\n  m.dict_new <span class=\"pl-k\">=</span> {\n      <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>test<span class=\"pl-pds\">\"</span></span>: <span class=\"pl-c1\">1</span>,\n      <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>test2<span class=\"pl-pds\">\"</span></span>: <span class=\"pl-c1\">2</span>\n  }\n\n  c <span class=\"pl-k\">=</span> tf.train.Checkpoint(<span class=\"pl-v\">model</span><span class=\"pl-k\">=</span>m)\n\n  status <span class=\"pl-k\">=</span> c.restore(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>checkpoints/-1<span class=\"pl-pds\">'</span></span>)\n\n  status.assert_consumed().run_restore_ops(s)</pre></div>", "body_text": "@allenlavoie\nIssue tracking the \"bug\" that is caused when restoring a checkpoint where the Checkpointable object has new checkpointable data structures that do not contain any checkpointable objects themselves and therefore prevent restoration when using load_status.assert_consumed().\nExample Code:\nimport tensorflow as tf\nfrom tensorflow.python.training.checkpointable.tracking import Checkpointable\n\n\nclass Model(Checkpointable):\n\n  def __init__(self):\n    self.variable = tf.get_variable(\"variable\", [2, 2])\n    self.dict = {\n        \"test\": 1,\n        \"test2\": 2,\n    }\n    self.dict_var = {\n        \"test\": 1,\n        \"test2\": tf.get_variable(\"dict_var\", [2, 2])\n    }\n    self.dict_nested_var = {\n        \"test\": 1,\n        \"test2\": {\n            \"var\": tf.get_variable(\"dict_nested_var\", [2, 2])\n        }\n    }\n    self.list_var = [tf.get_variable(\"list_var\", [2, 2])]\n\n\nprint('SAVE')\nwith tf.Graph().as_default():\n\n  s = tf.Session()\n\n  m = Model()\n\n  s.run(tf.global_variables_initializer())\n\n  c = tf.train.Checkpoint(model=m)\n\n  c.save('checkpoints/', session=s)\n\nprint('RESTORE')\nwith tf.Graph().as_default():\n\n  s = tf.Session()\n\n  m = Model()\n\n  m.dict_new = {\n      \"test\": 1,\n      \"test2\": 2\n  }\n\n  c = tf.train.Checkpoint(model=m)\n\n  status = c.restore('checkpoints/-1')\n\n  status.assert_consumed().run_restore_ops(s)", "body": "@allenlavoie\r\n\r\nIssue tracking the \"bug\" that is caused when restoring a checkpoint where the Checkpointable object has new checkpointable data structures that do not contain any checkpointable objects themselves and therefore prevent restoration when using `load_status.assert_consumed()`.\r\n\r\n*Example Code:*\r\n```python\r\nimport tensorflow as tf\r\nfrom tensorflow.python.training.checkpointable.tracking import Checkpointable\r\n\r\n\r\nclass Model(Checkpointable):\r\n\r\n  def __init__(self):\r\n    self.variable = tf.get_variable(\"variable\", [2, 2])\r\n    self.dict = {\r\n        \"test\": 1,\r\n        \"test2\": 2,\r\n    }\r\n    self.dict_var = {\r\n        \"test\": 1,\r\n        \"test2\": tf.get_variable(\"dict_var\", [2, 2])\r\n    }\r\n    self.dict_nested_var = {\r\n        \"test\": 1,\r\n        \"test2\": {\r\n            \"var\": tf.get_variable(\"dict_nested_var\", [2, 2])\r\n        }\r\n    }\r\n    self.list_var = [tf.get_variable(\"list_var\", [2, 2])]\r\n\r\n\r\nprint('SAVE')\r\nwith tf.Graph().as_default():\r\n\r\n  s = tf.Session()\r\n\r\n  m = Model()\r\n\r\n  s.run(tf.global_variables_initializer())\r\n\r\n  c = tf.train.Checkpoint(model=m)\r\n\r\n  c.save('checkpoints/', session=s)\r\n\r\nprint('RESTORE')\r\nwith tf.Graph().as_default():\r\n\r\n  s = tf.Session()\r\n\r\n  m = Model()\r\n\r\n  m.dict_new = {\r\n      \"test\": 1,\r\n      \"test2\": 2\r\n  }\r\n\r\n  c = tf.train.Checkpoint(model=m)\r\n\r\n  status = c.restore('checkpoints/-1')\r\n\r\n  status.assert_consumed().run_restore_ops(s)\r\n```"}