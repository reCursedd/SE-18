{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/194881985", "pull_request_review_id": 128140543, "id": 194881985, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NDg4MTk4NQ==", "diff_hunk": "@@ -0,0 +1,258 @@\n+/*\n+Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+*/\n+\n+package tensorflow\n+\n+// #include <stdlib.h>\n+// #include \"tensorflow/c/c_api.h\"\n+//\n+// TF_AttrType attrMetadataType(TF_AttrMetadata meta) {\n+//   return meta.type;\n+// }\n+import \"C\"\n+import (\n+\t\"unsafe\"\n+\n+\t\"github.com/pkg/errors\"\n+)\n+\n+type AttrType C.TF_AttrType\n+\n+const (\n+\tStringAttr      = AttrType(C.TF_ATTR_STRING)\n+\tIntAttr         = AttrType(C.TF_ATTR_INT)\n+\tFloatAttr       = AttrType(C.TF_ATTR_FLOAT)\n+\tBoolAttr        = AttrType(C.TF_ATTR_BOOL)\n+\tTypeAttr        = AttrType(C.TF_ATTR_TYPE)\n+\tShapeAttr       = AttrType(C.TF_ATTR_SHAPE)\n+\tTensorAttr      = AttrType(C.TF_ATTR_TENSOR)\n+\tPlaceholderAttr = AttrType(C.TF_ATTR_PLACEHOLDER)\n+\tFuncAttr        = AttrType(C.TF_ATTR_FUNC)\n+)\n+\n+// Attribute describes an attribute on an operation.\n+type Attribute struct {\n+\tOp *Operation\n+\n+\tName      string\n+\tIsList    bool\n+\tListSize  int64\n+\tType      AttrType\n+\tTotalSize int64\n+}\n+\n+// Attr returns info about an attribute on the operation.\n+func (op *Operation) Attr(name string) (Attribute, error) {\n+\tcname := C.CString(name)\n+\tdefer C.free(unsafe.Pointer(cname))\n+\n+\tstatus := newStatus()\n+\tmeta := C.TF_OperationGetAttrMetadata(op.c, cname, status.c)\n+\tif err := status.Err(); err != nil {\n+\t\treturn Attribute{}, err\n+\t}\n+\treturn Attribute{\n+\t\tOp:       op,\n+\t\tName:     name,\n+\t\tIsList:   meta.is_list == 1,\n+\t\tListSize: int64(meta.list_size),\n+\t\t// We have to use a C wrapper function here since you can't access the field\n+\t\t// \"type\" in go.\n+\t\tType:      AttrType(C.attrMetadataType(meta)),\n+\t\tTotalSize: int64(meta.total_size),\n+\t}, nil\n+}\n+\n+// Value returns the value of the attribute.\n+func (a Attribute) Value() (interface{}, error) {\n+\tcname := C.CString(a.Name)\n+\tdefer C.free(unsafe.Pointer(cname))\n+\tstatus := newStatus()\n+\n+\tif a.IsList {\n+\t\tswitch a.Type {\n+\t\tcase StringAttr:\n+\t\t\tvalues := make([]unsafe.Pointer, a.ListSize)\n+\t\t\tlengths := make([]C.size_t, a.ListSize)\n+\t\t\tstorage := make([]C.char, a.TotalSize)\n+\t\t\tC.TF_OperationGetAttrStringList(a.Op.c, cname, &values[0], &lengths[0], C.int(a.ListSize), unsafe.Pointer(&storage[0]), C.size_t(a.TotalSize), status.c)\n+\t\t\tif err := status.Err(); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tlist := make([]string, a.ListSize)\n+\t\t\tfor i, val := range values {\n+\t\t\t\tlength := lengths[i]\n+\t\t\t\tlist[i] = C.GoStringN((*C.char)(val), C.int(length))\n+\t\t\t}\n+\t\t\treturn list, nil\n+\n+\t\tcase IntAttr:\n+\t\t\tlist := make([]C.int64_t, a.ListSize)\n+\t\t\tC.TF_OperationGetAttrIntList(a.Op.c, cname, &list[0], C.int(a.ListSize), status.c)\n+\t\t\tif err := status.Err(); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tvals := make([]int64, a.ListSize)\n+\t\t\tfor i, val := range list {\n+\t\t\t\tvals[i] = int64(val)\n+\t\t\t}\n+\t\t\treturn vals, nil\n+\n+\t\tcase FloatAttr:\n+\t\t\tlist := make([]C.float, a.ListSize)\n+\t\t\tC.TF_OperationGetAttrFloatList(a.Op.c, cname, &list[0], C.int(a.ListSize), status.c)\n+\t\t\tif err := status.Err(); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tvals := make([]float32, a.ListSize)\n+\t\t\tfor i, val := range list {\n+\t\t\t\tvals[i] = float32(val)\n+\t\t\t}\n+\t\t\treturn vals, nil\n+\n+\t\tcase BoolAttr:\n+\t\t\tlist := make([]C.uchar, a.ListSize)\n+\t\t\tC.TF_OperationGetAttrBoolList(a.Op.c, cname, &list[0], C.int(a.ListSize), status.c)\n+\t\t\tif err := status.Err(); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tvals := make([]bool, a.ListSize)\n+\t\t\tfor i, val := range list {\n+\t\t\t\tvals[i] = val == 1\n+\t\t\t}\n+\t\t\treturn vals, nil\n+\n+\t\tcase TypeAttr:\n+\t\t\tlist := make([]C.TF_DataType, a.ListSize)\n+\t\t\tC.TF_OperationGetAttrTypeList(a.Op.c, cname, &list[0], C.int(a.ListSize), status.c)\n+\t\t\tif err := status.Err(); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tvals := make([]DataType, a.ListSize)\n+\t\t\tfor i, val := range list {\n+\t\t\t\tvals[i] = DataType(val)\n+\t\t\t}\n+\t\t\treturn vals, nil\n+\n+\t\tcase TensorAttr:\n+\t\t\tlist := make([]*C.TF_Tensor, a.ListSize)\n+\t\t\tC.TF_OperationGetAttrTensorList(a.Op.c, cname, &list[0], C.int(a.ListSize), status.c)\n+\t\t\tif err := status.Err(); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tvals := make([]*Tensor, a.ListSize)\n+\t\t\tfor i, t := range list {\n+\t\t\t\tvals[i] = newTensorFromC(t)\n+\t\t\t}\n+\t\t\treturn vals, nil\n+\n+\t\tcase ShapeAttr:\n+\t\t\tdims := make([]*C.int64_t, a.ListSize)\n+\t\t\tnumDims := make([]C.int, a.ListSize)\n+\t\t\tstorage := make([]C.int64_t, a.TotalSize)\n+\t\t\tC.TF_OperationGetAttrShapeList(a.Op.c, cname, &dims[0], &numDims[0], C.int(a.ListSize), &storage[0], C.int(a.TotalSize), status.c)\n+\t\t\tif err := status.Err(); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tlist := make([]Shape, a.ListSize)\n+\t\t\tfor i, dim := range dims {\n+\t\t\t\tnumDim := numDims[i]\n+\t\t\t\t// A []C.int64_t slice backed by C memory.\n+\t\t\t\t// See: https://github.com/golang/go/wiki/cgo#turning-c-arrays-into-go-slices\n+\t\t\t\tslice := (*[1 << 30]C.int64_t)(unsafe.Pointer(dim))[:numDim:numDim]\n+\t\t\t\ts := Shape{\n+\t\t\t\t\tdims: make([]int64, numDim),\n+\t\t\t\t}\n+\t\t\t\tfor i, dim := range slice {\n+\t\t\t\t\ts.dims[i] = int64(dim)\n+\t\t\t\t}\n+\t\t\t\tlist[i] = s\n+\t\t\t}\n+\t\t\treturn list, nil\n+\n+\t\tdefault:\n+\t\t\treturn nil, errors.Errorf(\"list type %v not supported yet\", a.Type)\n+\t\t}\n+\t}\n+\n+\tswitch a.Type {\n+\tcase StringAttr:\n+\t\tv := make([]C.char, a.TotalSize)\n+\t\tC.TF_OperationGetAttrString(a.Op.c, cname, unsafe.Pointer(&v[0]), C.size_t(a.TotalSize), status.c)\n+\t\tif err := status.Err(); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\treturn C.GoStringN(&v[0], C.int(a.TotalSize)), nil\n+\n+\tcase IntAttr:\n+\t\tvar v C.int64_t\n+\t\tC.TF_OperationGetAttrInt(a.Op.c, cname, &v, status.c)\n+\t\tif err := status.Err(); err != nil {", "path": "tensorflow/go/attrs.go", "position": null, "original_position": 203, "commit_id": "f00771010853734065a73453f8e73df4b51483da", "original_commit_id": "0bf46a701d5315660b58e0b7bb3366c9db76fd5c", "user": {"login": "asimshankar", "id": 16018, "node_id": "MDQ6VXNlcjE2MDE4", "avatar_url": "https://avatars2.githubusercontent.com/u/16018?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asimshankar", "html_url": "https://github.com/asimshankar", "followers_url": "https://api.github.com/users/asimshankar/followers", "following_url": "https://api.github.com/users/asimshankar/following{/other_user}", "gists_url": "https://api.github.com/users/asimshankar/gists{/gist_id}", "starred_url": "https://api.github.com/users/asimshankar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asimshankar/subscriptions", "organizations_url": "https://api.github.com/users/asimshankar/orgs", "repos_url": "https://api.github.com/users/asimshankar/repos", "events_url": "https://api.github.com/users/asimshankar/events{/privacy}", "received_events_url": "https://api.github.com/users/asimshankar/received_events", "type": "User", "site_admin": false}, "body": "Could you simplify this and many other lines below to:\r\n\r\n```go\r\nreturn int64(v), status.Err()\r\n```\r\n\r\netc.?\r\n", "created_at": "2018-06-12T20:43:22Z", "updated_at": "2018-06-13T16:41:25Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/19953#discussion_r194881985", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/19953", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/194881985"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/19953#discussion_r194881985"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/19953"}}, "body_html": "<p>Could you simplify this and many other lines below to:</p>\n<div class=\"highlight highlight-source-go\"><pre><span class=\"pl-k\">return</span> <span class=\"pl-c1\">int64</span>(v), status.<span class=\"pl-c1\">Err</span>()</pre></div>\n<p>etc.?</p>", "body_text": "Could you simplify this and many other lines below to:\nreturn int64(v), status.Err()\netc.?"}