{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/194896485", "pull_request_review_id": 128158096, "id": 194896485, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NDg5NjQ4NQ==", "diff_hunk": "@@ -0,0 +1,258 @@\n+/*\n+Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+*/\n+\n+package tensorflow\n+\n+// #include <stdlib.h>\n+// #include \"tensorflow/c/c_api.h\"\n+//\n+// TF_AttrType attrMetadataType(TF_AttrMetadata meta) {\n+//   return meta.type;\n+// }\n+import \"C\"\n+import (\n+\t\"unsafe\"\n+\n+\t\"github.com/pkg/errors\"\n+)\n+\n+type AttrType C.TF_AttrType\n+\n+const (\n+\tStringAttr      = AttrType(C.TF_ATTR_STRING)\n+\tIntAttr         = AttrType(C.TF_ATTR_INT)\n+\tFloatAttr       = AttrType(C.TF_ATTR_FLOAT)\n+\tBoolAttr        = AttrType(C.TF_ATTR_BOOL)\n+\tTypeAttr        = AttrType(C.TF_ATTR_TYPE)\n+\tShapeAttr       = AttrType(C.TF_ATTR_SHAPE)\n+\tTensorAttr      = AttrType(C.TF_ATTR_TENSOR)\n+\tPlaceholderAttr = AttrType(C.TF_ATTR_PLACEHOLDER)\n+\tFuncAttr        = AttrType(C.TF_ATTR_FUNC)\n+)\n+\n+// Attribute describes an attribute on an operation.\n+type Attribute struct {\n+\tOp *Operation\n+\n+\tName      string\n+\tIsList    bool\n+\tListSize  int64\n+\tType      AttrType\n+\tTotalSize int64\n+}\n+\n+// Attr returns info about an attribute on the operation.\n+func (op *Operation) Attr(name string) (Attribute, error) {\n+\tcname := C.CString(name)\n+\tdefer C.free(unsafe.Pointer(cname))\n+\n+\tstatus := newStatus()\n+\tmeta := C.TF_OperationGetAttrMetadata(op.c, cname, status.c)\n+\tif err := status.Err(); err != nil {\n+\t\treturn Attribute{}, err\n+\t}\n+\treturn Attribute{\n+\t\tOp:       op,\n+\t\tName:     name,\n+\t\tIsList:   meta.is_list == 1,\n+\t\tListSize: int64(meta.list_size),\n+\t\t// We have to use a C wrapper function here since you can't access the field\n+\t\t// \"type\" in go.\n+\t\tType:      AttrType(C.attrMetadataType(meta)),\n+\t\tTotalSize: int64(meta.total_size),\n+\t}, nil\n+}\n+\n+// Value returns the value of the attribute.\n+func (a Attribute) Value() (interface{}, error) {\n+\tcname := C.CString(a.Name)\n+\tdefer C.free(unsafe.Pointer(cname))\n+\tstatus := newStatus()\n+\n+\tif a.IsList {\n+\t\tswitch a.Type {\n+\t\tcase StringAttr:\n+\t\t\tvalues := make([]unsafe.Pointer, a.ListSize)\n+\t\t\tlengths := make([]C.size_t, a.ListSize)\n+\t\t\tstorage := make([]C.char, a.TotalSize)\n+\t\t\tC.TF_OperationGetAttrStringList(a.Op.c, cname, &values[0], &lengths[0], C.int(a.ListSize), unsafe.Pointer(&storage[0]), C.size_t(a.TotalSize), status.c)\n+\t\t\tif err := status.Err(); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tlist := make([]string, a.ListSize)\n+\t\t\tfor i, val := range values {\n+\t\t\t\tlength := lengths[i]\n+\t\t\t\tlist[i] = C.GoStringN((*C.char)(val), C.int(length))\n+\t\t\t}\n+\t\t\treturn list, nil\n+\n+\t\tcase IntAttr:\n+\t\t\tlist := make([]C.int64_t, a.ListSize)\n+\t\t\tC.TF_OperationGetAttrIntList(a.Op.c, cname, &list[0], C.int(a.ListSize), status.c)\n+\t\t\tif err := status.Err(); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tvals := make([]int64, a.ListSize)\n+\t\t\tfor i, val := range list {\n+\t\t\t\tvals[i] = int64(val)\n+\t\t\t}\n+\t\t\treturn vals, nil\n+\n+\t\tcase FloatAttr:\n+\t\t\tlist := make([]C.float, a.ListSize)\n+\t\t\tC.TF_OperationGetAttrFloatList(a.Op.c, cname, &list[0], C.int(a.ListSize), status.c)\n+\t\t\tif err := status.Err(); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tvals := make([]float32, a.ListSize)\n+\t\t\tfor i, val := range list {\n+\t\t\t\tvals[i] = float32(val)\n+\t\t\t}\n+\t\t\treturn vals, nil\n+\n+\t\tcase BoolAttr:\n+\t\t\tlist := make([]C.uchar, a.ListSize)\n+\t\t\tC.TF_OperationGetAttrBoolList(a.Op.c, cname, &list[0], C.int(a.ListSize), status.c)\n+\t\t\tif err := status.Err(); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tvals := make([]bool, a.ListSize)\n+\t\t\tfor i, val := range list {\n+\t\t\t\tvals[i] = val == 1\n+\t\t\t}\n+\t\t\treturn vals, nil\n+\n+\t\tcase TypeAttr:\n+\t\t\tlist := make([]C.TF_DataType, a.ListSize)\n+\t\t\tC.TF_OperationGetAttrTypeList(a.Op.c, cname, &list[0], C.int(a.ListSize), status.c)\n+\t\t\tif err := status.Err(); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tvals := make([]DataType, a.ListSize)\n+\t\t\tfor i, val := range list {\n+\t\t\t\tvals[i] = DataType(val)\n+\t\t\t}\n+\t\t\treturn vals, nil\n+\n+\t\tcase TensorAttr:\n+\t\t\tlist := make([]*C.TF_Tensor, a.ListSize)\n+\t\t\tC.TF_OperationGetAttrTensorList(a.Op.c, cname, &list[0], C.int(a.ListSize), status.c)\n+\t\t\tif err := status.Err(); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tvals := make([]*Tensor, a.ListSize)\n+\t\t\tfor i, t := range list {\n+\t\t\t\tvals[i] = newTensorFromC(t)\n+\t\t\t}\n+\t\t\treturn vals, nil\n+\n+\t\tcase ShapeAttr:\n+\t\t\tdims := make([]*C.int64_t, a.ListSize)\n+\t\t\tnumDims := make([]C.int, a.ListSize)\n+\t\t\tstorage := make([]C.int64_t, a.TotalSize)\n+\t\t\tC.TF_OperationGetAttrShapeList(a.Op.c, cname, &dims[0], &numDims[0], C.int(a.ListSize), &storage[0], C.int(a.TotalSize), status.c)\n+\t\t\tif err := status.Err(); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tlist := make([]Shape, a.ListSize)\n+\t\t\tfor i, dim := range dims {\n+\t\t\t\tnumDim := numDims[i]\n+\t\t\t\t// A []C.int64_t slice backed by C memory.\n+\t\t\t\t// See: https://github.com/golang/go/wiki/cgo#turning-c-arrays-into-go-slices\n+\t\t\t\tslice := (*[1 << 30]C.int64_t)(unsafe.Pointer(dim))[:numDim:numDim]\n+\t\t\t\ts := Shape{\n+\t\t\t\t\tdims: make([]int64, numDim),\n+\t\t\t\t}\n+\t\t\t\tfor i, dim := range slice {\n+\t\t\t\t\ts.dims[i] = int64(dim)\n+\t\t\t\t}\n+\t\t\t\tlist[i] = s\n+\t\t\t}\n+\t\t\treturn list, nil\n+\n+\t\tdefault:\n+\t\t\treturn nil, errors.Errorf(\"list type %v not supported yet\", a.Type)\n+\t\t}\n+\t}\n+\n+\tswitch a.Type {\n+\tcase StringAttr:\n+\t\tv := make([]C.char, a.TotalSize)\n+\t\tC.TF_OperationGetAttrString(a.Op.c, cname, unsafe.Pointer(&v[0]), C.size_t(a.TotalSize), status.c)\n+\t\tif err := status.Err(); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\treturn C.GoStringN(&v[0], C.int(a.TotalSize)), nil\n+\n+\tcase IntAttr:\n+\t\tvar v C.int64_t\n+\t\tC.TF_OperationGetAttrInt(a.Op.c, cname, &v, status.c)\n+\t\tif err := status.Err(); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\treturn int64(v), nil\n+\n+\tcase FloatAttr:\n+\t\tvar v C.float\n+\t\tC.TF_OperationGetAttrFloat(a.Op.c, cname, &v, status.c)\n+\t\tif err := status.Err(); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\treturn float32(v), nil\n+\n+\tcase BoolAttr:\n+\t\tvar v C.uchar\n+\t\tC.TF_OperationGetAttrBool(a.Op.c, cname, &v, status.c)\n+\t\tif err := status.Err(); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\treturn v == 1, nil\n+\n+\tcase TypeAttr:\n+\t\tvar v C.TF_DataType\n+\t\tC.TF_OperationGetAttrType(a.Op.c, cname, &v, status.c)\n+\t\tif err := status.Err(); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\treturn DataType(v), nil\n+\n+\tcase TensorAttr:\n+\t\tvar v *C.TF_Tensor\n+\t\tC.TF_OperationGetAttrTensor(a.Op.c, cname, &v, status.c)\n+\t\tif err := status.Err(); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\treturn newTensorFromC(v), nil\n+\n+\tcase ShapeAttr:\n+\t\tnumDims := a.TotalSize\n+\t\tdims := make([]C.int64_t, numDims)", "path": "tensorflow/go/attrs.go", "position": null, "original_position": 242, "commit_id": "f00771010853734065a73453f8e73df4b51483da", "original_commit_id": "0bf46a701d5315660b58e0b7bb3366c9db76fd5c", "user": {"login": "d4l3k", "id": 909104, "node_id": "MDQ6VXNlcjkwOTEwNA==", "avatar_url": "https://avatars2.githubusercontent.com/u/909104?v=4", "gravatar_id": "", "url": "https://api.github.com/users/d4l3k", "html_url": "https://github.com/d4l3k", "followers_url": "https://api.github.com/users/d4l3k/followers", "following_url": "https://api.github.com/users/d4l3k/following{/other_user}", "gists_url": "https://api.github.com/users/d4l3k/gists{/gist_id}", "starred_url": "https://api.github.com/users/d4l3k/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/d4l3k/subscriptions", "organizations_url": "https://api.github.com/users/d4l3k/orgs", "repos_url": "https://api.github.com/users/d4l3k/repos", "events_url": "https://api.github.com/users/d4l3k/events{/privacy}", "received_events_url": "https://api.github.com/users/d4l3k/received_events", "type": "User", "site_admin": false}, "body": "We do return a shape. This dims array is what the C fills into and then we wrap it with a Shape.", "created_at": "2018-06-12T21:35:00Z", "updated_at": "2018-06-13T16:41:25Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/19953#discussion_r194896485", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/19953", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/194896485"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/19953#discussion_r194896485"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/19953"}}, "body_html": "<p>We do return a shape. This dims array is what the C fills into and then we wrap it with a Shape.</p>", "body_text": "We do return a shape. This dims array is what the C fills into and then we wrap it with a Shape.", "in_reply_to_id": 194882419}