{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/17991", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/17991/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/17991/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/17991/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/17991", "id": 308369684, "node_id": "MDU6SXNzdWUzMDgzNjk2ODQ=", "number": 17991, "title": "Tensorflow sequence mask without reducing dimensions", "user": {"login": "burglarhobbit", "id": 15987266, "node_id": "MDQ6VXNlcjE1OTg3MjY2", "avatar_url": "https://avatars2.githubusercontent.com/u/15987266?v=4", "gravatar_id": "", "url": "https://api.github.com/users/burglarhobbit", "html_url": "https://github.com/burglarhobbit", "followers_url": "https://api.github.com/users/burglarhobbit/followers", "following_url": "https://api.github.com/users/burglarhobbit/following{/other_user}", "gists_url": "https://api.github.com/users/burglarhobbit/gists{/gist_id}", "starred_url": "https://api.github.com/users/burglarhobbit/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/burglarhobbit/subscriptions", "organizations_url": "https://api.github.com/users/burglarhobbit/orgs", "repos_url": "https://api.github.com/users/burglarhobbit/repos", "events_url": "https://api.github.com/users/burglarhobbit/events{/privacy}", "received_events_url": "https://api.github.com/users/burglarhobbit/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": {"login": "rohan100jain", "id": 144114, "node_id": "MDQ6VXNlcjE0NDExNA==", "avatar_url": "https://avatars2.githubusercontent.com/u/144114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rohan100jain", "html_url": "https://github.com/rohan100jain", "followers_url": "https://api.github.com/users/rohan100jain/followers", "following_url": "https://api.github.com/users/rohan100jain/following{/other_user}", "gists_url": "https://api.github.com/users/rohan100jain/gists{/gist_id}", "starred_url": "https://api.github.com/users/rohan100jain/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rohan100jain/subscriptions", "organizations_url": "https://api.github.com/users/rohan100jain/orgs", "repos_url": "https://api.github.com/users/rohan100jain/repos", "events_url": "https://api.github.com/users/rohan100jain/events{/privacy}", "received_events_url": "https://api.github.com/users/rohan100jain/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "rohan100jain", "id": 144114, "node_id": "MDQ6VXNlcjE0NDExNA==", "avatar_url": "https://avatars2.githubusercontent.com/u/144114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rohan100jain", "html_url": "https://github.com/rohan100jain", "followers_url": "https://api.github.com/users/rohan100jain/followers", "following_url": "https://api.github.com/users/rohan100jain/following{/other_user}", "gists_url": "https://api.github.com/users/rohan100jain/gists{/gist_id}", "starred_url": "https://api.github.com/users/rohan100jain/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rohan100jain/subscriptions", "organizations_url": "https://api.github.com/users/rohan100jain/orgs", "repos_url": "https://api.github.com/users/rohan100jain/repos", "events_url": "https://api.github.com/users/rohan100jain/events{/privacy}", "received_events_url": "https://api.github.com/users/rohan100jain/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 2, "created_at": "2018-03-25T17:45:22Z", "updated_at": "2018-04-04T14:47:48Z", "closed_at": "2018-04-04T14:34:05Z", "author_association": "NONE", "body_html": "<h3>System information</h3>\n<ul>\n<li><strong>Have I written custom code (as opposed to using a stock example script provided in TensorFlow)</strong>: Yes</li>\n<li><strong>OS Platform and Distribution</strong>: Linux Ubuntu 16.04</li>\n<li><strong>TensorFlow installed from</strong>: binary</li>\n<li><strong>TensorFlow version</strong>: 1.4.0</li>\n<li><strong>Python version</strong>: 3.5.2</li>\n<li><strong>Bazel version (if compiling from source)</strong>: not compiled from source</li>\n<li><strong>GCC/Compiler version (if compiling from source)</strong>: not compiled from source</li>\n<li><strong>CUDA/cuDNN version</strong>: 8.0/6</li>\n<li><strong>GPU model and memory</strong>: 8GB x 4 GTX 1080</li>\n<li><strong>Exact command to reproduce</strong>: N/A</li>\n</ul>\n<p>I have a sample code to run:</p>\n<pre><code>import numpy a np\nimport tensorflow as tf\nimport tensorflow.contrib.eager as tfe\ntfe.enable_eager_execution()\n\nx = np.random.randint(100,size=(4,4))\nindexes =tf.sequence_mask([1,2,2,4],4)\n\"\"\"\nindexes = [\n\t[True,False,False,False],\n\t[True,True,False,False],\n\t[True,True,False,False],\n\t[True,True,True,True],\n]\n\"\"\"\n\ny = tf.boolean_mask(x,indexes)\n# y = array([43, 78, 68, 54, 46, 28, 15, 52,  3])\n</code></pre>\n<p>Now, I don't want this as the spatial information of the original tensor is lost and I want to keep the shape intact. How can do that in tensorflow since I work with RNN data so my tensor size is = <code>[batch_size, max_time, feature_length]</code> where I would slice it such that:</p>\n<p><code>indexes = tf.sequence_mask([x_1, x_2, x_3, ..., x_batch_size], max_time)</code></p>\n<p>but still want to keep the shape intact. If its not possible, is there a way to sequence mask on multiple tensors of such size while also concatenating them so that only the extracted sequence would remain and not the masked out paddings? Paddings could be applied on the end of the concatenation.</p>", "body_text": "System information\n\nHave I written custom code (as opposed to using a stock example script provided in TensorFlow): Yes\nOS Platform and Distribution: Linux Ubuntu 16.04\nTensorFlow installed from: binary\nTensorFlow version: 1.4.0\nPython version: 3.5.2\nBazel version (if compiling from source): not compiled from source\nGCC/Compiler version (if compiling from source): not compiled from source\nCUDA/cuDNN version: 8.0/6\nGPU model and memory: 8GB x 4 GTX 1080\nExact command to reproduce: N/A\n\nI have a sample code to run:\nimport numpy a np\nimport tensorflow as tf\nimport tensorflow.contrib.eager as tfe\ntfe.enable_eager_execution()\n\nx = np.random.randint(100,size=(4,4))\nindexes =tf.sequence_mask([1,2,2,4],4)\n\"\"\"\nindexes = [\n\t[True,False,False,False],\n\t[True,True,False,False],\n\t[True,True,False,False],\n\t[True,True,True,True],\n]\n\"\"\"\n\ny = tf.boolean_mask(x,indexes)\n# y = array([43, 78, 68, 54, 46, 28, 15, 52,  3])\n\nNow, I don't want this as the spatial information of the original tensor is lost and I want to keep the shape intact. How can do that in tensorflow since I work with RNN data so my tensor size is = [batch_size, max_time, feature_length] where I would slice it such that:\nindexes = tf.sequence_mask([x_1, x_2, x_3, ..., x_batch_size], max_time)\nbut still want to keep the shape intact. If its not possible, is there a way to sequence mask on multiple tensors of such size while also concatenating them so that only the extracted sequence would remain and not the masked out paddings? Paddings could be applied on the end of the concatenation.", "body": "### System information\r\n- **Have I written custom code (as opposed to using a stock example script provided in TensorFlow)**: Yes\r\n- **OS Platform and Distribution**: Linux Ubuntu 16.04\r\n- **TensorFlow installed from**: binary\r\n- **TensorFlow version**: 1.4.0\r\n- **Python version**: 3.5.2\r\n- **Bazel version (if compiling from source)**: not compiled from source\r\n- **GCC/Compiler version (if compiling from source)**: not compiled from source\r\n- **CUDA/cuDNN version**: 8.0/6\r\n- **GPU model and memory**: 8GB x 4 GTX 1080\r\n- **Exact command to reproduce**: N/A\r\n\r\n\r\nI have a sample code to run:\r\n    \r\n    import numpy a np\r\n    import tensorflow as tf\r\n    import tensorflow.contrib.eager as tfe\r\n    tfe.enable_eager_execution()\r\n    \r\n    x = np.random.randint(100,size=(4,4))\r\n    indexes =tf.sequence_mask([1,2,2,4],4)\r\n    \"\"\"\r\n    indexes = [\r\n    \t[True,False,False,False],\r\n    \t[True,True,False,False],\r\n    \t[True,True,False,False],\r\n    \t[True,True,True,True],\r\n    ]\r\n    \"\"\"\r\n    \r\n    y = tf.boolean_mask(x,indexes)\r\n    # y = array([43, 78, 68, 54, 46, 28, 15, 52,  3])\r\n\r\nNow, I don't want this as the spatial information of the original tensor is lost and I want to keep the shape intact. How can do that in tensorflow since I work with RNN data so my tensor size is = `[batch_size, max_time, feature_length]` where I would slice it such that:\r\n\r\n`indexes = tf.sequence_mask([x_1, x_2, x_3, ..., x_batch_size], max_time)`\r\n\r\nbut still want to keep the shape intact. If its not possible, is there a way to sequence mask on multiple tensors of such size while also concatenating them so that only the extracted sequence would remain and not the masked out paddings? Paddings could be applied on the end of the concatenation."}