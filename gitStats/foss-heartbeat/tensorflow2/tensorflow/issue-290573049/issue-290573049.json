{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/16293", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/16293/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/16293/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/16293/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/16293", "id": 290573049, "node_id": "MDU6SXNzdWUyOTA1NzMwNDk=", "number": 16293, "title": "tf.errors.OutOfRangeError error not raised when using tf.train.MonitoredTrainingSession", "user": {"login": "SpikingNeurons", "id": 2289914, "node_id": "MDQ6VXNlcjIyODk5MTQ=", "avatar_url": "https://avatars2.githubusercontent.com/u/2289914?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SpikingNeurons", "html_url": "https://github.com/SpikingNeurons", "followers_url": "https://api.github.com/users/SpikingNeurons/followers", "following_url": "https://api.github.com/users/SpikingNeurons/following{/other_user}", "gists_url": "https://api.github.com/users/SpikingNeurons/gists{/gist_id}", "starred_url": "https://api.github.com/users/SpikingNeurons/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SpikingNeurons/subscriptions", "organizations_url": "https://api.github.com/users/SpikingNeurons/orgs", "repos_url": "https://api.github.com/users/SpikingNeurons/repos", "events_url": "https://api.github.com/users/SpikingNeurons/events{/privacy}", "received_events_url": "https://api.github.com/users/SpikingNeurons/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2018-01-22T18:44:30Z", "updated_at": "2018-01-22T22:23:35Z", "closed_at": "2018-01-22T22:22:55Z", "author_association": "NONE", "body_html": "<hr>\n<h3>System information</h3>\n<ul>\n<li><strong>Have I written custom code (as opposed to using a stock example script provided in TensorFlow)</strong>:<br>\nI am providing a mini snippet to reproduce bug.</li>\n<li><strong>OS Platform and Distribution (e.g., Linux Ubuntu 16.04)</strong>:<br>\nWindows 7 - 64 bit</li>\n<li><strong>TensorFlow installed from (source or binary)</strong>:<br>\nFrom binary for windows (tensorflow_gpu)</li>\n<li><strong>TensorFlow version (use command below)</strong>:<br>\n1.4.0</li>\n<li><strong>Python version</strong>:<br>\n3.6</li>\n<li><strong>Bazel version (if compiling from source)</strong>:<br>\nNot Applicable</li>\n<li><strong>GCC/Compiler version (if compiling from source)</strong>:<br>\nNot Applicable</li>\n<li><strong>CUDA/cuDNN version</strong>:<br>\nCUDA 8.5</li>\n<li><strong>GPU model and memory</strong>:<br>\nTitan X</li>\n<li><strong>Exact command to reproduce</strong>:<br>\nJust run the snippet as it is.</li>\n</ul>\n<h3>Describe the problem</h3>\n<p>When Dataset iterator reaches at the end it should raise <code>tf.errors.OutOfRangeError</code>. But when using <code>tf.train.MonitoredTrainingSession</code> with custom hook I do not get the error. Ideally I need to get the Error.</p>\n<h3>Source code / logs</h3>\n<p>Reproducible bug snippet:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-c\"><span class=\"pl-c\">#</span> coding=utf-8</span>\n<span class=\"pl-k\">import</span> tensorflow <span class=\"pl-k\">as</span> tf\n<span class=\"pl-k\">import</span> numpy <span class=\"pl-k\">as</span> np\n\n<span class=\"pl-c1\">print</span>(tf.<span class=\"pl-c1\">GIT_VERSION</span>, tf.<span class=\"pl-c1\">VERSION</span>)\n\n\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">MyHook</span>(<span class=\"pl-e\">tf</span>.<span class=\"pl-e\">train</span>.<span class=\"pl-e\">SessionRunHook</span>):\n\n    <span class=\"pl-k\">def</span> <span class=\"pl-c1\">__init__</span>(\n            <span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>,\n            <span class=\"pl-smi\">place_holders</span>,\n            <span class=\"pl-smi\">batch_size</span>, <span class=\"pl-smi\">epochs</span>\n    ):\n        <span class=\"pl-c1\">super</span>(MyHook, <span class=\"pl-c1\">self</span>).<span class=\"pl-c1\">__init__</span>()\n        <span class=\"pl-c1\">self</span>._create_iterator(place_holders, batch_size, epochs)\n        <span class=\"pl-c1\">self</span>._session <span class=\"pl-k\">=</span> <span class=\"pl-c1\">None</span>\n        <span class=\"pl-c1\">self</span>._handle <span class=\"pl-k\">=</span> <span class=\"pl-c1\">None</span>\n\n    <span class=\"pl-k\">def</span> <span class=\"pl-en\">_create_iterator</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>, <span class=\"pl-smi\">place_holders</span>, <span class=\"pl-smi\">batch_size</span>, <span class=\"pl-smi\">epochs</span>):\n\n        <span class=\"pl-c1\">self</span>._dataset <span class=\"pl-k\">=</span> tf.data.Dataset.from_tensor_slices(\n            place_holders\n        ).batch(\n            batch_size\n        ).repeat(\n            epochs\n        )  <span class=\"pl-c\"># <span class=\"pl-c\">type:</span> <span class=\"pl-c\">tf</span><span class=\"pl-c\">.</span><span class=\"pl-c\">data</span><span class=\"pl-c\">.</span><span class=\"pl-c\">Dataset</span></span>\n\n        <span class=\"pl-c1\">self</span>._iterator <span class=\"pl-k\">=</span> <span class=\"pl-c1\">self</span>._dataset.make_initializable_iterator()\n        <span class=\"pl-c1\">self</span>._next_op <span class=\"pl-k\">=</span> <span class=\"pl-c1\">self</span>._iterator.get_next()\n\n    <span class=\"pl-k\">def</span> <span class=\"pl-en\">reinit</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>, <span class=\"pl-smi\">feed_dict</span>):\n        <span class=\"pl-c1\">self</span>._session.run(<span class=\"pl-c1\">self</span>._iterator.initializer, <span class=\"pl-v\">feed_dict</span><span class=\"pl-k\">=</span>feed_dict)\n\n    <span class=\"pl-en\">@</span><span class=\"pl-c1\">property</span>\n    <span class=\"pl-k\">def</span> <span class=\"pl-c1\">next</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>):\n        <span class=\"pl-k\">return</span> <span class=\"pl-c1\">self</span>._session.run(<span class=\"pl-c1\">self</span>._next_op)\n\n    <span class=\"pl-k\">def</span> <span class=\"pl-en\">after_create_session</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>, <span class=\"pl-smi\">session</span>, <span class=\"pl-smi\">coord</span>):\n        <span class=\"pl-c1\">self</span>._session <span class=\"pl-k\">=</span> session\n\n\n<span class=\"pl-k\">if</span> <span class=\"pl-c1\">__name__</span> <span class=\"pl-k\">==</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>__main__<span class=\"pl-pds\">\"</span></span>:\n\n    data_dict <span class=\"pl-k\">=</span> {\n        <span class=\"pl-s\"><span class=\"pl-pds\">'</span>labels<span class=\"pl-pds\">'</span></span>: np.arange(<span class=\"pl-c1\">20</span>, <span class=\"pl-v\">dtype</span><span class=\"pl-k\">=</span>np.int32)\n    }\n\n    placeholders_dict <span class=\"pl-k\">=</span> {\n        <span class=\"pl-s\"><span class=\"pl-pds\">'</span>labels<span class=\"pl-pds\">'</span></span>: tf.placeholder(\n            <span class=\"pl-v\">dtype</span><span class=\"pl-k\">=</span>data_dict[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>labels<span class=\"pl-pds\">'</span></span>].dtype,\n            <span class=\"pl-v\">shape</span><span class=\"pl-k\">=</span>data_dict[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>labels<span class=\"pl-pds\">'</span></span>].shape,\n            <span class=\"pl-v\">name</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>labels<span class=\"pl-pds\">'</span></span>)\n    }\n\n    feed_dict <span class=\"pl-k\">=</span> {}\n    <span class=\"pl-k\">for</span> k, v <span class=\"pl-k\">in</span> placeholders_dict.items():\n        feed_dict[v] <span class=\"pl-k\">=</span> data_dict[k]\n\n    hook_twice <span class=\"pl-k\">=</span> MyHook(<span class=\"pl-v\">place_holders</span><span class=\"pl-k\">=</span>placeholders_dict, <span class=\"pl-v\">batch_size</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">10</span>, <span class=\"pl-v\">epochs</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">2</span>)\n    hook_infinite <span class=\"pl-k\">=</span> MyHook(<span class=\"pl-v\">place_holders</span><span class=\"pl-k\">=</span>placeholders_dict, <span class=\"pl-v\">batch_size</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">10</span>, <span class=\"pl-v\">epochs</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">None</span>)\n\n    <span class=\"pl-k\">with</span> tf.train.MonitoredTrainingSession(\n        <span class=\"pl-v\">hooks</span><span class=\"pl-k\">=</span>[hook_twice, hook_infinite]\n    ):\n        hook_twice.reinit(<span class=\"pl-v\">feed_dict</span><span class=\"pl-k\">=</span>feed_dict)\n        hook_infinite.reinit(<span class=\"pl-v\">feed_dict</span><span class=\"pl-k\">=</span>feed_dict)\n        <span class=\"pl-k\">while</span> <span class=\"pl-c1\">True</span>:\n            <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>...<span class=\"pl-pds\">\"</span></span>)\n            <span class=\"pl-c1\">print</span>(hook_twice.next)\n            <span class=\"pl-c1\">print</span>(hook_infinite.next)\n</pre></div>\n<p>As you can see <code>hook_twice</code> should repeat twice on dataset and then throw Error. Whereas <code>hook_infinite</code> should repeat infinitely but because of <code>hook_twice</code> should be abrupt-ed. But the program runs without throwing error after two iterations because of <code>hook_twice</code>.</p>\n<p>Output:</p>\n<pre lang=\"txt\"><code>b'unknown' 1.4.0\n2018-01-22 19:55:01.223557: I C:\\tf_jenkins\\home\\workspace\\rel-win\\M\\windows-gpu\\PY\\36\\tensorflow\\core\\platform\\cpu_feature_guard.cc:137] Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX AVX2\n2018-01-22 19:55:01.519963: I C:\\tf_jenkins\\home\\workspace\\rel-win\\M\\windows-gpu\\PY\\36\\tensorflow\\core\\common_runtime\\gpu\\gpu_device.cc:1030] Found device 0 with properties: \nname: GeForce GTX TITAN X major: 5 minor: 2 memoryClockRate(GHz): 1.076\npciBusID: 0000:03:00.0\ntotalMemory: 12.00GiB freeMemory: 11.78GiB\n2018-01-22 19:55:01.519963: I C:\\tf_jenkins\\home\\workspace\\rel-win\\M\\windows-gpu\\PY\\36\\tensorflow\\core\\common_runtime\\gpu\\gpu_device.cc:1120] Creating TensorFlow device (/device:GPU:0) -&gt; (device: 0, name: GeForce GTX TITAN X, pci bus id: 0000:03:00.0, compute capability: 5.2)\n...\n{'labels': array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])}\n{'labels': array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])}\n...\n{'labels': array([10, 11, 12, 13, 14, 15, 16, 17, 18, 19])}\n{'labels': array([10, 11, 12, 13, 14, 15, 16, 17, 18, 19])}\n...\n{'labels': array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])}\n{'labels': array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])}\n...\n{'labels': array([10, 11, 12, 13, 14, 15, 16, 17, 18, 19])}\n{'labels': array([10, 11, 12, 13, 14, 15, 16, 17, 18, 19])}\n...\n\nProcess finished with exit code 0\n\n</code></pre>", "body_text": "System information\n\nHave I written custom code (as opposed to using a stock example script provided in TensorFlow):\nI am providing a mini snippet to reproduce bug.\nOS Platform and Distribution (e.g., Linux Ubuntu 16.04):\nWindows 7 - 64 bit\nTensorFlow installed from (source or binary):\nFrom binary for windows (tensorflow_gpu)\nTensorFlow version (use command below):\n1.4.0\nPython version:\n3.6\nBazel version (if compiling from source):\nNot Applicable\nGCC/Compiler version (if compiling from source):\nNot Applicable\nCUDA/cuDNN version:\nCUDA 8.5\nGPU model and memory:\nTitan X\nExact command to reproduce:\nJust run the snippet as it is.\n\nDescribe the problem\nWhen Dataset iterator reaches at the end it should raise tf.errors.OutOfRangeError. But when using tf.train.MonitoredTrainingSession with custom hook I do not get the error. Ideally I need to get the Error.\nSource code / logs\nReproducible bug snippet:\n# coding=utf-8\nimport tensorflow as tf\nimport numpy as np\n\nprint(tf.GIT_VERSION, tf.VERSION)\n\n\nclass MyHook(tf.train.SessionRunHook):\n\n    def __init__(\n            self,\n            place_holders,\n            batch_size, epochs\n    ):\n        super(MyHook, self).__init__()\n        self._create_iterator(place_holders, batch_size, epochs)\n        self._session = None\n        self._handle = None\n\n    def _create_iterator(self, place_holders, batch_size, epochs):\n\n        self._dataset = tf.data.Dataset.from_tensor_slices(\n            place_holders\n        ).batch(\n            batch_size\n        ).repeat(\n            epochs\n        )  # type: tf.data.Dataset\n\n        self._iterator = self._dataset.make_initializable_iterator()\n        self._next_op = self._iterator.get_next()\n\n    def reinit(self, feed_dict):\n        self._session.run(self._iterator.initializer, feed_dict=feed_dict)\n\n    @property\n    def next(self):\n        return self._session.run(self._next_op)\n\n    def after_create_session(self, session, coord):\n        self._session = session\n\n\nif __name__ == \"__main__\":\n\n    data_dict = {\n        'labels': np.arange(20, dtype=np.int32)\n    }\n\n    placeholders_dict = {\n        'labels': tf.placeholder(\n            dtype=data_dict['labels'].dtype,\n            shape=data_dict['labels'].shape,\n            name='labels')\n    }\n\n    feed_dict = {}\n    for k, v in placeholders_dict.items():\n        feed_dict[v] = data_dict[k]\n\n    hook_twice = MyHook(place_holders=placeholders_dict, batch_size=10, epochs=2)\n    hook_infinite = MyHook(place_holders=placeholders_dict, batch_size=10, epochs=None)\n\n    with tf.train.MonitoredTrainingSession(\n        hooks=[hook_twice, hook_infinite]\n    ):\n        hook_twice.reinit(feed_dict=feed_dict)\n        hook_infinite.reinit(feed_dict=feed_dict)\n        while True:\n            print(\"...\")\n            print(hook_twice.next)\n            print(hook_infinite.next)\n\nAs you can see hook_twice should repeat twice on dataset and then throw Error. Whereas hook_infinite should repeat infinitely but because of hook_twice should be abrupt-ed. But the program runs without throwing error after two iterations because of hook_twice.\nOutput:\nb'unknown' 1.4.0\n2018-01-22 19:55:01.223557: I C:\\tf_jenkins\\home\\workspace\\rel-win\\M\\windows-gpu\\PY\\36\\tensorflow\\core\\platform\\cpu_feature_guard.cc:137] Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX AVX2\n2018-01-22 19:55:01.519963: I C:\\tf_jenkins\\home\\workspace\\rel-win\\M\\windows-gpu\\PY\\36\\tensorflow\\core\\common_runtime\\gpu\\gpu_device.cc:1030] Found device 0 with properties: \nname: GeForce GTX TITAN X major: 5 minor: 2 memoryClockRate(GHz): 1.076\npciBusID: 0000:03:00.0\ntotalMemory: 12.00GiB freeMemory: 11.78GiB\n2018-01-22 19:55:01.519963: I C:\\tf_jenkins\\home\\workspace\\rel-win\\M\\windows-gpu\\PY\\36\\tensorflow\\core\\common_runtime\\gpu\\gpu_device.cc:1120] Creating TensorFlow device (/device:GPU:0) -> (device: 0, name: GeForce GTX TITAN X, pci bus id: 0000:03:00.0, compute capability: 5.2)\n...\n{'labels': array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])}\n{'labels': array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])}\n...\n{'labels': array([10, 11, 12, 13, 14, 15, 16, 17, 18, 19])}\n{'labels': array([10, 11, 12, 13, 14, 15, 16, 17, 18, 19])}\n...\n{'labels': array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])}\n{'labels': array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])}\n...\n{'labels': array([10, 11, 12, 13, 14, 15, 16, 17, 18, 19])}\n{'labels': array([10, 11, 12, 13, 14, 15, 16, 17, 18, 19])}\n...\n\nProcess finished with exit code 0", "body": "------------------------\r\n\r\n### System information\r\n- **Have I written custom code (as opposed to using a stock example script provided in TensorFlow)**:\r\nI am providing a mini snippet to reproduce bug.\r\n- **OS Platform and Distribution (e.g., Linux Ubuntu 16.04)**:\r\nWindows 7 - 64 bit\r\n- **TensorFlow installed from (source or binary)**:\r\nFrom binary for windows (tensorflow_gpu)\r\n- **TensorFlow version (use command below)**:\r\n1.4.0\r\n- **Python version**: \r\n3.6\r\n- **Bazel version (if compiling from source)**:\r\nNot Applicable\r\n- **GCC/Compiler version (if compiling from source)**:\r\nNot Applicable\r\n- **CUDA/cuDNN version**:\r\nCUDA 8.5\r\n- **GPU model and memory**:\r\nTitan X\r\n- **Exact command to reproduce**:\r\nJust run the snippet as it is.\r\n\r\n### Describe the problem\r\n\r\nWhen Dataset iterator reaches at the end it should raise `tf.errors.OutOfRangeError`. But when using `tf.train.MonitoredTrainingSession` with custom hook I do not get the error. Ideally I need to get the Error.\r\n\r\n### Source code / logs\r\n\r\nReproducible bug snippet:\r\n\r\n```python\r\n# coding=utf-8\r\nimport tensorflow as tf\r\nimport numpy as np\r\n\r\nprint(tf.GIT_VERSION, tf.VERSION)\r\n\r\n\r\nclass MyHook(tf.train.SessionRunHook):\r\n\r\n    def __init__(\r\n            self,\r\n            place_holders,\r\n            batch_size, epochs\r\n    ):\r\n        super(MyHook, self).__init__()\r\n        self._create_iterator(place_holders, batch_size, epochs)\r\n        self._session = None\r\n        self._handle = None\r\n\r\n    def _create_iterator(self, place_holders, batch_size, epochs):\r\n\r\n        self._dataset = tf.data.Dataset.from_tensor_slices(\r\n            place_holders\r\n        ).batch(\r\n            batch_size\r\n        ).repeat(\r\n            epochs\r\n        )  # type: tf.data.Dataset\r\n\r\n        self._iterator = self._dataset.make_initializable_iterator()\r\n        self._next_op = self._iterator.get_next()\r\n\r\n    def reinit(self, feed_dict):\r\n        self._session.run(self._iterator.initializer, feed_dict=feed_dict)\r\n\r\n    @property\r\n    def next(self):\r\n        return self._session.run(self._next_op)\r\n\r\n    def after_create_session(self, session, coord):\r\n        self._session = session\r\n\r\n\r\nif __name__ == \"__main__\":\r\n\r\n    data_dict = {\r\n        'labels': np.arange(20, dtype=np.int32)\r\n    }\r\n\r\n    placeholders_dict = {\r\n        'labels': tf.placeholder(\r\n            dtype=data_dict['labels'].dtype,\r\n            shape=data_dict['labels'].shape,\r\n            name='labels')\r\n    }\r\n\r\n    feed_dict = {}\r\n    for k, v in placeholders_dict.items():\r\n        feed_dict[v] = data_dict[k]\r\n\r\n    hook_twice = MyHook(place_holders=placeholders_dict, batch_size=10, epochs=2)\r\n    hook_infinite = MyHook(place_holders=placeholders_dict, batch_size=10, epochs=None)\r\n\r\n    with tf.train.MonitoredTrainingSession(\r\n        hooks=[hook_twice, hook_infinite]\r\n    ):\r\n        hook_twice.reinit(feed_dict=feed_dict)\r\n        hook_infinite.reinit(feed_dict=feed_dict)\r\n        while True:\r\n            print(\"...\")\r\n            print(hook_twice.next)\r\n            print(hook_infinite.next)\r\n\r\n```\r\nAs you can see `hook_twice` should repeat twice on dataset and then throw Error. Whereas `hook_infinite` should repeat infinitely but because of `hook_twice` should be abrupt-ed. But the program runs without throwing error after two iterations because of `hook_twice`.\r\n\r\nOutput:\r\n\r\n```txt\r\nb'unknown' 1.4.0\r\n2018-01-22 19:55:01.223557: I C:\\tf_jenkins\\home\\workspace\\rel-win\\M\\windows-gpu\\PY\\36\\tensorflow\\core\\platform\\cpu_feature_guard.cc:137] Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX AVX2\r\n2018-01-22 19:55:01.519963: I C:\\tf_jenkins\\home\\workspace\\rel-win\\M\\windows-gpu\\PY\\36\\tensorflow\\core\\common_runtime\\gpu\\gpu_device.cc:1030] Found device 0 with properties: \r\nname: GeForce GTX TITAN X major: 5 minor: 2 memoryClockRate(GHz): 1.076\r\npciBusID: 0000:03:00.0\r\ntotalMemory: 12.00GiB freeMemory: 11.78GiB\r\n2018-01-22 19:55:01.519963: I C:\\tf_jenkins\\home\\workspace\\rel-win\\M\\windows-gpu\\PY\\36\\tensorflow\\core\\common_runtime\\gpu\\gpu_device.cc:1120] Creating TensorFlow device (/device:GPU:0) -> (device: 0, name: GeForce GTX TITAN X, pci bus id: 0000:03:00.0, compute capability: 5.2)\r\n...\r\n{'labels': array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])}\r\n{'labels': array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])}\r\n...\r\n{'labels': array([10, 11, 12, 13, 14, 15, 16, 17, 18, 19])}\r\n{'labels': array([10, 11, 12, 13, 14, 15, 16, 17, 18, 19])}\r\n...\r\n{'labels': array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])}\r\n{'labels': array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])}\r\n...\r\n{'labels': array([10, 11, 12, 13, 14, 15, 16, 17, 18, 19])}\r\n{'labels': array([10, 11, 12, 13, 14, 15, 16, 17, 18, 19])}\r\n...\r\n\r\nProcess finished with exit code 0\r\n\r\n```\r\n"}