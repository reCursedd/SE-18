{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13890", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13890/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13890/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/13890/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/13890", "id": 267415809, "node_id": "MDU6SXNzdWUyNjc0MTU4MDk=", "number": 13890, "title": "tf.image.crop_and_resize() return 0 values when assigned to GPU on  the Jetson TX2 ", "user": {"login": "0fficer1", "id": 8676810, "node_id": "MDQ6VXNlcjg2NzY4MTA=", "avatar_url": "https://avatars1.githubusercontent.com/u/8676810?v=4", "gravatar_id": "", "url": "https://api.github.com/users/0fficer1", "html_url": "https://github.com/0fficer1", "followers_url": "https://api.github.com/users/0fficer1/followers", "following_url": "https://api.github.com/users/0fficer1/following{/other_user}", "gists_url": "https://api.github.com/users/0fficer1/gists{/gist_id}", "starred_url": "https://api.github.com/users/0fficer1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/0fficer1/subscriptions", "organizations_url": "https://api.github.com/users/0fficer1/orgs", "repos_url": "https://api.github.com/users/0fficer1/repos", "events_url": "https://api.github.com/users/0fficer1/events{/privacy}", "received_events_url": "https://api.github.com/users/0fficer1/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 404586594, "node_id": "MDU6TGFiZWw0MDQ1ODY1OTQ=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:awaiting%20tensorflower", "name": "stat:awaiting tensorflower", "color": "f4b400", "default": false}, {"id": 473172988, "node_id": "MDU6TGFiZWw0NzMxNzI5ODg=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:bug/performance", "name": "type:bug/performance", "color": "159b2e", "default": false}], "state": "closed", "locked": false, "assignee": {"login": "bignamehyp", "id": 3474655, "node_id": "MDQ6VXNlcjM0NzQ2NTU=", "avatar_url": "https://avatars2.githubusercontent.com/u/3474655?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bignamehyp", "html_url": "https://github.com/bignamehyp", "followers_url": "https://api.github.com/users/bignamehyp/followers", "following_url": "https://api.github.com/users/bignamehyp/following{/other_user}", "gists_url": "https://api.github.com/users/bignamehyp/gists{/gist_id}", "starred_url": "https://api.github.com/users/bignamehyp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bignamehyp/subscriptions", "organizations_url": "https://api.github.com/users/bignamehyp/orgs", "repos_url": "https://api.github.com/users/bignamehyp/repos", "events_url": "https://api.github.com/users/bignamehyp/events{/privacy}", "received_events_url": "https://api.github.com/users/bignamehyp/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "bignamehyp", "id": 3474655, "node_id": "MDQ6VXNlcjM0NzQ2NTU=", "avatar_url": "https://avatars2.githubusercontent.com/u/3474655?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bignamehyp", "html_url": "https://github.com/bignamehyp", "followers_url": "https://api.github.com/users/bignamehyp/followers", "following_url": "https://api.github.com/users/bignamehyp/following{/other_user}", "gists_url": "https://api.github.com/users/bignamehyp/gists{/gist_id}", "starred_url": "https://api.github.com/users/bignamehyp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bignamehyp/subscriptions", "organizations_url": "https://api.github.com/users/bignamehyp/orgs", "repos_url": "https://api.github.com/users/bignamehyp/repos", "events_url": "https://api.github.com/users/bignamehyp/events{/privacy}", "received_events_url": "https://api.github.com/users/bignamehyp/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 12, "created_at": "2017-10-21T21:31:45Z", "updated_at": "2018-08-17T15:05:07Z", "closed_at": "2018-05-21T20:30:33Z", "author_association": "NONE", "body_html": "<h3>System information</h3>\n<ul>\n<li><strong>Have I written custom code (as opposed to using a stock example script provided in TensorFlow)</strong>: Yes</li>\n<li><strong>OS Platform and Distribution (e.g., Linux Ubuntu 16.04)</strong>: 16.04.LTS</li>\n<li><strong>TensorFlow installed from (source or binary)</strong>: Source</li>\n<li><strong>TensorFlow version (use command below)</strong>: 1.3.0</li>\n<li><strong>Python version</strong>:  2.7.12</li>\n<li><strong>Bazel version (if compiling from source)</strong>: 0.5.2</li>\n<li><strong>CUDA/cuDNN version</strong>: 8.0/6.0.21</li>\n<li><strong>GPU model and memory</strong>: Nvidia Tegra X2</li>\n<li><strong>Exact command to reproduce</strong>:<code>tf.image.crop_and_resize(raw_sample, boxes, box_ind)</code></li>\n</ul>\n<h3>Describe the problem</h3>\n<p>I'm getting completly different results from tensorflow's function <code>tf.image.crop_and_resize(...)</code> when assigned it to gpu and cpu.<br>\nIn other words:<br>\n-when I run this ops on CPU, I get correct results( I mean, the  right crops)<br>\n-when I put it on the GPU device I get crops fulled with 0 values.</p>\n<h3>Source code / logs</h3>\n<p>Here, you can see a simple use case:</p>\n<pre><code>import tensorflow as tf \nimport numpy as np\nimport cv2 #Just importing cv2 to read  image, you use PIL or anything else to load it\n\ndevice='gpu' \n\ndef img2batch_crops(input_image):\n    raw_sample_tensor_4d=tf.expand_dims(input_image, 0)\n    \n    #Setting the size to crop and the final size of cropped images\n    patches_top=[0,0.5]\n    patches_bottom =[0.5,0.5]\n    crop_size = [100,100]\n    boxes=tf.stack([patches_top, patches_top, patches_bottom, patches_bottom], axis=1)\n    \n    ##Here is the bug:\n        #When device == 'cpu', I got  results \n        #When device == 'gpu', I got  black cropped images( 0 values)\n    with tf.device('/'+device+':0'):  \n        crops=tf.image.crop_and_resize(raw_sample_tensor_4d, boxes, box_ind=tf.zeros_like(patches_top, dtype=tf.int32), crop_size=crop_size, name=\"croper\")\n\n    return crops\n\n\ndef main():\n\n\timg_data = cv2.imread('image.jpg') #Just loading the image,\n\n\tprint(\"Shape and type of image input \",img_data.shape, img_data.dtype) #Print the shape and the type of the image, supposed to be a numpy array\n\n\traw_image = tf.placeholder(dtype=tf.float32, shape=img_data.shape, name='input_image')\n     \n       crops = img2batch_crops(raw_image) # Adding ops to the graph\n\n\twith tf.Session() as sess:\n\t    myBatchedImages = sess.run(crops, feed_dict={raw_image:img_data})\n\t    cv2.imwrite('result_'+device+'.jpg',myBatchedImages[0])   ## Savej just one cropped image to see how it looks like\n\nmain()\n</code></pre>", "body_text": "System information\n\nHave I written custom code (as opposed to using a stock example script provided in TensorFlow): Yes\nOS Platform and Distribution (e.g., Linux Ubuntu 16.04): 16.04.LTS\nTensorFlow installed from (source or binary): Source\nTensorFlow version (use command below): 1.3.0\nPython version:  2.7.12\nBazel version (if compiling from source): 0.5.2\nCUDA/cuDNN version: 8.0/6.0.21\nGPU model and memory: Nvidia Tegra X2\nExact command to reproduce:tf.image.crop_and_resize(raw_sample, boxes, box_ind)\n\nDescribe the problem\nI'm getting completly different results from tensorflow's function tf.image.crop_and_resize(...) when assigned it to gpu and cpu.\nIn other words:\n-when I run this ops on CPU, I get correct results( I mean, the  right crops)\n-when I put it on the GPU device I get crops fulled with 0 values.\nSource code / logs\nHere, you can see a simple use case:\nimport tensorflow as tf \nimport numpy as np\nimport cv2 #Just importing cv2 to read  image, you use PIL or anything else to load it\n\ndevice='gpu' \n\ndef img2batch_crops(input_image):\n    raw_sample_tensor_4d=tf.expand_dims(input_image, 0)\n    \n    #Setting the size to crop and the final size of cropped images\n    patches_top=[0,0.5]\n    patches_bottom =[0.5,0.5]\n    crop_size = [100,100]\n    boxes=tf.stack([patches_top, patches_top, patches_bottom, patches_bottom], axis=1)\n    \n    ##Here is the bug:\n        #When device == 'cpu', I got  results \n        #When device == 'gpu', I got  black cropped images( 0 values)\n    with tf.device('/'+device+':0'):  \n        crops=tf.image.crop_and_resize(raw_sample_tensor_4d, boxes, box_ind=tf.zeros_like(patches_top, dtype=tf.int32), crop_size=crop_size, name=\"croper\")\n\n    return crops\n\n\ndef main():\n\n\timg_data = cv2.imread('image.jpg') #Just loading the image,\n\n\tprint(\"Shape and type of image input \",img_data.shape, img_data.dtype) #Print the shape and the type of the image, supposed to be a numpy array\n\n\traw_image = tf.placeholder(dtype=tf.float32, shape=img_data.shape, name='input_image')\n     \n       crops = img2batch_crops(raw_image) # Adding ops to the graph\n\n\twith tf.Session() as sess:\n\t    myBatchedImages = sess.run(crops, feed_dict={raw_image:img_data})\n\t    cv2.imwrite('result_'+device+'.jpg',myBatchedImages[0])   ## Savej just one cropped image to see how it looks like\n\nmain()", "body": "### System information\r\n- **Have I written custom code (as opposed to using a stock example script provided in TensorFlow)**: Yes\r\n- **OS Platform and Distribution (e.g., Linux Ubuntu 16.04)**: 16.04.LTS\r\n- **TensorFlow installed from (source or binary)**: Source\r\n- **TensorFlow version (use command below)**: 1.3.0\r\n- **Python version**:  2.7.12\r\n- **Bazel version (if compiling from source)**: 0.5.2\r\n- **CUDA/cuDNN version**: 8.0/6.0.21\r\n- **GPU model and memory**: Nvidia Tegra X2\r\n- **Exact command to reproduce**:`tf.image.crop_and_resize(raw_sample, boxes, box_ind)`\r\n\r\n### Describe the problem\r\nI'm getting completly different results from tensorflow's function `tf.image.crop_and_resize(...)` when assigned it to gpu and cpu.\r\nIn other words:\r\n  -when I run this ops on CPU, I get correct results( I mean, the  right crops)\r\n  -when I put it on the GPU device I get crops fulled with 0 values.\r\n\r\n### Source code / logs\r\nHere, you can see a simple use case:\r\n```\r\nimport tensorflow as tf \r\nimport numpy as np\r\nimport cv2 #Just importing cv2 to read  image, you use PIL or anything else to load it\r\n\r\ndevice='gpu' \r\n\r\ndef img2batch_crops(input_image):\r\n    raw_sample_tensor_4d=tf.expand_dims(input_image, 0)\r\n    \r\n    #Setting the size to crop and the final size of cropped images\r\n    patches_top=[0,0.5]\r\n    patches_bottom =[0.5,0.5]\r\n    crop_size = [100,100]\r\n    boxes=tf.stack([patches_top, patches_top, patches_bottom, patches_bottom], axis=1)\r\n    \r\n    ##Here is the bug:\r\n        #When device == 'cpu', I got  results \r\n        #When device == 'gpu', I got  black cropped images( 0 values)\r\n    with tf.device('/'+device+':0'):  \r\n        crops=tf.image.crop_and_resize(raw_sample_tensor_4d, boxes, box_ind=tf.zeros_like(patches_top, dtype=tf.int32), crop_size=crop_size, name=\"croper\")\r\n\r\n    return crops\r\n\r\n\r\ndef main():\r\n\r\n\timg_data = cv2.imread('image.jpg') #Just loading the image,\r\n\r\n\tprint(\"Shape and type of image input \",img_data.shape, img_data.dtype) #Print the shape and the type of the image, supposed to be a numpy array\r\n\r\n\traw_image = tf.placeholder(dtype=tf.float32, shape=img_data.shape, name='input_image')\r\n     \r\n       crops = img2batch_crops(raw_image) # Adding ops to the graph\r\n\r\n\twith tf.Session() as sess:\r\n\t    myBatchedImages = sess.run(crops, feed_dict={raw_image:img_data})\r\n\t    cv2.imwrite('result_'+device+'.jpg',myBatchedImages[0])   ## Savej just one cropped image to see how it looks like\r\n\r\nmain()\r\n```\r\n"}