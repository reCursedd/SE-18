{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/256836063", "html_url": "https://github.com/tensorflow/tensorflow/issues/4886#issuecomment-256836063", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/4886", "id": 256836063, "node_id": "MDEyOklzc3VlQ29tbWVudDI1NjgzNjA2Mw==", "user": {"login": "zheng-xq", "id": 15736910, "node_id": "MDQ6VXNlcjE1NzM2OTEw", "avatar_url": "https://avatars0.githubusercontent.com/u/15736910?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zheng-xq", "html_url": "https://github.com/zheng-xq", "followers_url": "https://api.github.com/users/zheng-xq/followers", "following_url": "https://api.github.com/users/zheng-xq/following{/other_user}", "gists_url": "https://api.github.com/users/zheng-xq/gists{/gist_id}", "starred_url": "https://api.github.com/users/zheng-xq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zheng-xq/subscriptions", "organizations_url": "https://api.github.com/users/zheng-xq/orgs", "repos_url": "https://api.github.com/users/zheng-xq/repos", "events_url": "https://api.github.com/users/zheng-xq/events{/privacy}", "received_events_url": "https://api.github.com/users/zheng-xq/received_events", "type": "User", "site_admin": false}, "created_at": "2016-10-28T04:54:17Z", "updated_at": "2016-10-28T04:54:17Z", "author_association": "CONTRIBUTOR", "body_html": "<p>I think both tf.reduce_max and tf.maxpool are correct in their own sense. But the Theano's answer is not.</p>\n<p>When a backprop comes back into a max operation, and if there are multiple winners, the credit can only be shared among them. There is no constraint on which one should get the credit, and by how much. But they shouldn't all get the full credit.</p>\n<p>Consider this:<br>\na = max(x, x, x). The correct answer is d(a)/d(x)=1, but Theano's answer leads to d(a)/d(x) = 3,  following the chain rule.</p>\n<p>Both tf.reduce_max and tf.maxpool gives somewhat self-consistent answers. One equally distributed it among all windows, while the other gives it to the first one. Both arbitrary choices, but nevertheless correct in their own sense.</p>\n<p>Since we pick the maxpool implementation from Cudnn, it's unclear that we can get all implementations consistent across all different libraries. So my perspective is that each implementation has to be self-consistent in that the total weight of a backprop value sums to 1. It might be a bit over-constrained if we require all operations to make the same arbitrary choice.</p>", "body_text": "I think both tf.reduce_max and tf.maxpool are correct in their own sense. But the Theano's answer is not.\nWhen a backprop comes back into a max operation, and if there are multiple winners, the credit can only be shared among them. There is no constraint on which one should get the credit, and by how much. But they shouldn't all get the full credit.\nConsider this:\na = max(x, x, x). The correct answer is d(a)/d(x)=1, but Theano's answer leads to d(a)/d(x) = 3,  following the chain rule.\nBoth tf.reduce_max and tf.maxpool gives somewhat self-consistent answers. One equally distributed it among all windows, while the other gives it to the first one. Both arbitrary choices, but nevertheless correct in their own sense.\nSince we pick the maxpool implementation from Cudnn, it's unclear that we can get all implementations consistent across all different libraries. So my perspective is that each implementation has to be self-consistent in that the total weight of a backprop value sums to 1. It might be a bit over-constrained if we require all operations to make the same arbitrary choice.", "body": "I think both tf.reduce_max and tf.maxpool are correct in their own sense. But the Theano's answer is not. \n\nWhen a backprop comes back into a max operation, and if there are multiple winners, the credit can only be shared among them. There is no constraint on which one should get the credit, and by how much. But they shouldn't all get the full credit. \n\nConsider this:\na = max(x, x, x). The correct answer is d(a)/d(x)=1, but Theano's answer leads to d(a)/d(x) = 3,  following the chain rule. \n\nBoth tf.reduce_max and tf.maxpool gives somewhat self-consistent answers. One equally distributed it among all windows, while the other gives it to the first one. Both arbitrary choices, but nevertheless correct in their own sense. \n\nSince we pick the maxpool implementation from Cudnn, it's unclear that we can get all implementations consistent across all different libraries. So my perspective is that each implementation has to be self-consistent in that the total weight of a backprop value sums to 1. It might be a bit over-constrained if we require all operations to make the same arbitrary choice.\n"}