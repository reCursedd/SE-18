{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/315417397", "html_url": "https://github.com/tensorflow/tensorflow/issues/11470#issuecomment-315417397", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11470", "id": 315417397, "node_id": "MDEyOklzc3VlQ29tbWVudDMxNTQxNzM5Nw==", "user": {"login": "asimshankar", "id": 16018, "node_id": "MDQ6VXNlcjE2MDE4", "avatar_url": "https://avatars2.githubusercontent.com/u/16018?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asimshankar", "html_url": "https://github.com/asimshankar", "followers_url": "https://api.github.com/users/asimshankar/followers", "following_url": "https://api.github.com/users/asimshankar/following{/other_user}", "gists_url": "https://api.github.com/users/asimshankar/gists{/gist_id}", "starred_url": "https://api.github.com/users/asimshankar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asimshankar/subscriptions", "organizations_url": "https://api.github.com/users/asimshankar/orgs", "repos_url": "https://api.github.com/users/asimshankar/repos", "events_url": "https://api.github.com/users/asimshankar/events{/privacy}", "received_events_url": "https://api.github.com/users/asimshankar/received_events", "type": "User", "site_admin": false}, "created_at": "2017-07-14T17:26:25Z", "updated_at": "2017-07-14T17:26:25Z", "author_association": "MEMBER", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=4112135\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/josemlopez\">@josemlopez</a> : It would be very helpful if you could cut this down to a small piece of code that I can use to reproduce the problem. The code you have provided above is pretty extensive with many unrelated things and is missing some information (e.g., the definition of <code>LoadModelTF</code> and data files that I do not have access to). Isolating the problem to the smallest code snippet possible that can be reproduced will help a lot.</p>\n<p>That said, I was able to try out a stripped down version and I think the problem lies in the discrepancy of how input is being processed. In particular, you want to compare what <code>loadFeatures</code> in Python returns with what <code>constructImage</code> in Java returns and I suspect that the two are not the same.</p>\n<p>For example, try the following in Python:</p>\n<div class=\"highlight highlight-source-python\"><pre>data <span class=\"pl-k\">=</span> loadFeatures([<span class=\"pl-s\"><span class=\"pl-pds\">'</span>/tmp/cat.jpg<span class=\"pl-pds\">'</span></span>])\n<span class=\"pl-c1\">print</span>(data[<span class=\"pl-c1\">0</span>].shape)\n<span class=\"pl-c1\">print</span>(data[<span class=\"pl-c1\">0</span>])</pre></div>\n<p>For my cat image I get something like:</p>\n<pre><code>(49152,)\n[   0.    5.   20. ...,   96.  105.  114. ]\n</code></pre>\n<p>suggesting that when you feed the <code>x</code> node in python (<code>input_jm</code>), a vector with 49152 elements is being provided.</p>\n<p>However, examining the same in Java:</p>\n<div class=\"highlight highlight-source-java\"><pre><span class=\"pl-k\">byte</span>[] imageBytes <span class=\"pl-k\">=</span> readAllBytesOrExit(<span class=\"pl-smi\">Paths</span><span class=\"pl-k\">.</span>get(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>/tmp/cat.jpg<span class=\"pl-pds\">\"</span></span>));\n<span class=\"pl-k\">try</span> (<span class=\"pl-smi\">Tensor</span> image <span class=\"pl-k\">=</span> constructAndExecuteGraphToNormalizeImage(<span class=\"pl-c1\">128</span>, imageBytes)) {\n  <span class=\"pl-smi\">System</span><span class=\"pl-k\">.</span>out<span class=\"pl-k\">.</span>println(image<span class=\"pl-k\">.</span>shape());\n  \n  <span class=\"pl-c\"><span class=\"pl-c\">//</span> Print a sample of the contents</span>\n  <span class=\"pl-smi\">FloatBuffer</span> buf <span class=\"pl-k\">=</span> <span class=\"pl-smi\">FloatBuffer</span><span class=\"pl-k\">.</span>allocate(<span class=\"pl-c1\">128</span><span class=\"pl-k\">*</span><span class=\"pl-c1\">128</span><span class=\"pl-k\">*</span><span class=\"pl-c1\">3</span>);\n  image<span class=\"pl-k\">.</span>writeTo(buf);\n  <span class=\"pl-k\">float</span>[] flat <span class=\"pl-k\">=</span> buf<span class=\"pl-k\">.</span>array();\n  <span class=\"pl-smi\">System</span><span class=\"pl-k\">.</span>out<span class=\"pl-k\">.</span>println(flat[<span class=\"pl-c1\">0</span>] <span class=\"pl-k\">+</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span> <span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">+</span> flat[<span class=\"pl-c1\">1</span>] <span class=\"pl-k\">+</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span> <span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">+</span> flat[<span class=\"pl-c1\">2</span>]);\n}</pre></div>\n<p>I get:</p>\n<pre><code>FLOAT tensor with shape [1, 128, 128, 3]\n64.23073 51.70092 38.50939\n</code></pre>\n<p>Suggesting that neither the shape nor the values of the input being provided matches between Python and Java. If that's the case, it would explain why the classifications are different :).</p>\n<p>The shape difference should have been flagged (since the shape of the Java <code>image</code> Tensor doesn't match the shape corresponding to the <code>input_jm</code> placeholder in the graph). Is there some other code that I'm missing? Regardless, my suggestion would be for you to validate that the shape and value of the input image being fed to the model is the same in both Python and Java.</p>", "body_text": "@josemlopez : It would be very helpful if you could cut this down to a small piece of code that I can use to reproduce the problem. The code you have provided above is pretty extensive with many unrelated things and is missing some information (e.g., the definition of LoadModelTF and data files that I do not have access to). Isolating the problem to the smallest code snippet possible that can be reproduced will help a lot.\nThat said, I was able to try out a stripped down version and I think the problem lies in the discrepancy of how input is being processed. In particular, you want to compare what loadFeatures in Python returns with what constructImage in Java returns and I suspect that the two are not the same.\nFor example, try the following in Python:\ndata = loadFeatures(['/tmp/cat.jpg'])\nprint(data[0].shape)\nprint(data[0])\nFor my cat image I get something like:\n(49152,)\n[   0.    5.   20. ...,   96.  105.  114. ]\n\nsuggesting that when you feed the x node in python (input_jm), a vector with 49152 elements is being provided.\nHowever, examining the same in Java:\nbyte[] imageBytes = readAllBytesOrExit(Paths.get(\"/tmp/cat.jpg\"));\ntry (Tensor image = constructAndExecuteGraphToNormalizeImage(128, imageBytes)) {\n  System.out.println(image.shape());\n  \n  // Print a sample of the contents\n  FloatBuffer buf = FloatBuffer.allocate(128*128*3);\n  image.writeTo(buf);\n  float[] flat = buf.array();\n  System.out.println(flat[0] + \" \" + flat[1] + \" \" + flat[2]);\n}\nI get:\nFLOAT tensor with shape [1, 128, 128, 3]\n64.23073 51.70092 38.50939\n\nSuggesting that neither the shape nor the values of the input being provided matches between Python and Java. If that's the case, it would explain why the classifications are different :).\nThe shape difference should have been flagged (since the shape of the Java image Tensor doesn't match the shape corresponding to the input_jm placeholder in the graph). Is there some other code that I'm missing? Regardless, my suggestion would be for you to validate that the shape and value of the input image being fed to the model is the same in both Python and Java.", "body": "@josemlopez : It would be very helpful if you could cut this down to a small piece of code that I can use to reproduce the problem. The code you have provided above is pretty extensive with many unrelated things and is missing some information (e.g., the definition of `LoadModelTF` and data files that I do not have access to). Isolating the problem to the smallest code snippet possible that can be reproduced will help a lot.\r\n\r\nThat said, I was able to try out a stripped down version and I think the problem lies in the discrepancy of how input is being processed. In particular, you want to compare what `loadFeatures` in Python returns with what `constructImage` in Java returns and I suspect that the two are not the same.\r\n\r\nFor example, try the following in Python:\r\n\r\n```python\r\ndata = loadFeatures(['/tmp/cat.jpg'])\r\nprint(data[0].shape)\r\nprint(data[0])\r\n```\r\n\r\nFor my cat image I get something like:\r\n\r\n```\r\n(49152,)\r\n[   0.    5.   20. ...,   96.  105.  114. ]\r\n```\r\n\r\nsuggesting that when you feed the `x` node in python (`input_jm`), a vector with 49152 elements is being provided.\r\n\r\nHowever, examining the same in Java:\r\n\r\n```java\r\nbyte[] imageBytes = readAllBytesOrExit(Paths.get(\"/tmp/cat.jpg\"));\r\ntry (Tensor image = constructAndExecuteGraphToNormalizeImage(128, imageBytes)) {\r\n  System.out.println(image.shape());\r\n  \r\n  // Print a sample of the contents\r\n  FloatBuffer buf = FloatBuffer.allocate(128*128*3);\r\n  image.writeTo(buf);\r\n  float[] flat = buf.array();\r\n  System.out.println(flat[0] + \" \" + flat[1] + \" \" + flat[2]);\r\n}\r\n```\r\n\r\nI get:\r\n```\r\nFLOAT tensor with shape [1, 128, 128, 3]\r\n64.23073 51.70092 38.50939\r\n```\r\n\r\nSuggesting that neither the shape nor the values of the input being provided matches between Python and Java. If that's the case, it would explain why the classifications are different :).\r\n\r\nThe shape difference should have been flagged (since the shape of the Java `image` Tensor doesn't match the shape corresponding to the `input_jm` placeholder in the graph). Is there some other code that I'm missing? Regardless, my suggestion would be for you to validate that the shape and value of the input image being fed to the model is the same in both Python and Java.\r\n"}