{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/242217541", "html_url": "https://github.com/tensorflow/tensorflow/issues/3624#issuecomment-242217541", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/3624", "id": 242217541, "node_id": "MDEyOklzc3VlQ29tbWVudDI0MjIxNzU0MQ==", "user": {"login": "sbrodeur", "id": 4322357, "node_id": "MDQ6VXNlcjQzMjIzNTc=", "avatar_url": "https://avatars3.githubusercontent.com/u/4322357?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sbrodeur", "html_url": "https://github.com/sbrodeur", "followers_url": "https://api.github.com/users/sbrodeur/followers", "following_url": "https://api.github.com/users/sbrodeur/following{/other_user}", "gists_url": "https://api.github.com/users/sbrodeur/gists{/gist_id}", "starred_url": "https://api.github.com/users/sbrodeur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sbrodeur/subscriptions", "organizations_url": "https://api.github.com/users/sbrodeur/orgs", "repos_url": "https://api.github.com/users/sbrodeur/repos", "events_url": "https://api.github.com/users/sbrodeur/events{/privacy}", "received_events_url": "https://api.github.com/users/sbrodeur/received_events", "type": "User", "site_admin": false}, "created_at": "2016-08-24T21:41:53Z", "updated_at": "2016-08-24T21:45:09Z", "author_association": "NONE", "body_html": "<p>I made some progress! I can make multiplication and division ops work for complex numbers if I specialized the templates in <a href=\"https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/cwise_ops.h#L432\">https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/cwise_ops.h#L432</a></p>\n<pre><code>template &lt;typename T&gt;\nstruct mul : base&lt;T, Eigen::internal::scalar_product_op&lt;T&gt; &gt; {};\n\ntemplate &lt;typename T&gt;\nstruct multiply_complex {\n  typedef std::complex&lt;T&gt; result_type;\n  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE result_type operator()(std::complex&lt;T&gt; a,\n                                                               std::complex&lt;T&gt; b) const {\n    return std::complex&lt;T&gt;(a.real()*b.real() - a.imag()*b.imag(),\n                           a.real()*b.imag() + a.imag()*b.real());\n  }\n};\n\ntemplate &lt;&gt;\nstruct mul&lt;std::complex&lt;float&gt; &gt; : base&lt;std::complex&lt;float&gt;, multiply_complex&lt;float&gt; &gt; {};\n\ntemplate &lt;&gt;\nstruct mul&lt;std::complex&lt;double&gt; &gt; : base&lt;std::complex&lt;double&gt;, multiply_complex&lt;double&gt; &gt; {};\n\n</code></pre>\n<p>It seems more like a hack, but it doesn't involve changes in Eigen for now.</p>\n<p>Not sure what is wrong with nvcc using scalar_product_op in Eigen for complex numbers:<br>\n<a href=\"https://github.com/RLovelett/eigen/blob/master/Eigen/src/Core/functors/BinaryFunctors.h#L76\">https://github.com/RLovelett/eigen/blob/master/Eigen/src/Core/functors/BinaryFunctors.h#L76</a></p>\n<p>However, it seems tightly related to using built-in * and / operators for std:complex types.<br>\nFor instance, this fails with the same errors as in the previous posts:</p>\n<pre><code>template &lt;typename T&gt;\nstruct mul : base&lt;T, Eigen::internal::scalar_product_op&lt;T&gt; &gt; {};\n\ntemplate &lt;typename T&gt;\nstruct multiply_complex {\n  typedef std::complex&lt;T&gt; result_type;\n  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE result_type operator()(std::complex&lt;T&gt; a,\n                                                               std::complex&lt;T&gt; b) const {\n    return a*b;\n  }\n};\n\ntemplate &lt;&gt;\nstruct mul&lt;std::complex&lt;float&gt; &gt; : base&lt;std::complex&lt;float&gt;, multiply_complex&lt;float&gt; &gt; {};\n\ntemplate &lt;&gt;\nstruct mul&lt;std::complex&lt;double&gt; &gt; : base&lt;std::complex&lt;double&gt;, multiply_complex&lt;double&gt; &gt; {};\n\n</code></pre>", "body_text": "I made some progress! I can make multiplication and division ops work for complex numbers if I specialized the templates in https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/cwise_ops.h#L432\ntemplate <typename T>\nstruct mul : base<T, Eigen::internal::scalar_product_op<T> > {};\n\ntemplate <typename T>\nstruct multiply_complex {\n  typedef std::complex<T> result_type;\n  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE result_type operator()(std::complex<T> a,\n                                                               std::complex<T> b) const {\n    return std::complex<T>(a.real()*b.real() - a.imag()*b.imag(),\n                           a.real()*b.imag() + a.imag()*b.real());\n  }\n};\n\ntemplate <>\nstruct mul<std::complex<float> > : base<std::complex<float>, multiply_complex<float> > {};\n\ntemplate <>\nstruct mul<std::complex<double> > : base<std::complex<double>, multiply_complex<double> > {};\n\n\nIt seems more like a hack, but it doesn't involve changes in Eigen for now.\nNot sure what is wrong with nvcc using scalar_product_op in Eigen for complex numbers:\nhttps://github.com/RLovelett/eigen/blob/master/Eigen/src/Core/functors/BinaryFunctors.h#L76\nHowever, it seems tightly related to using built-in * and / operators for std:complex types.\nFor instance, this fails with the same errors as in the previous posts:\ntemplate <typename T>\nstruct mul : base<T, Eigen::internal::scalar_product_op<T> > {};\n\ntemplate <typename T>\nstruct multiply_complex {\n  typedef std::complex<T> result_type;\n  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE result_type operator()(std::complex<T> a,\n                                                               std::complex<T> b) const {\n    return a*b;\n  }\n};\n\ntemplate <>\nstruct mul<std::complex<float> > : base<std::complex<float>, multiply_complex<float> > {};\n\ntemplate <>\nstruct mul<std::complex<double> > : base<std::complex<double>, multiply_complex<double> > {};", "body": "I made some progress! I can make multiplication and division ops work for complex numbers if I specialized the templates in https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/cwise_ops.h#L432\n\n```\ntemplate <typename T>\nstruct mul : base<T, Eigen::internal::scalar_product_op<T> > {};\n\ntemplate <typename T>\nstruct multiply_complex {\n  typedef std::complex<T> result_type;\n  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE result_type operator()(std::complex<T> a,\n                                                               std::complex<T> b) const {\n    return std::complex<T>(a.real()*b.real() - a.imag()*b.imag(),\n                           a.real()*b.imag() + a.imag()*b.real());\n  }\n};\n\ntemplate <>\nstruct mul<std::complex<float> > : base<std::complex<float>, multiply_complex<float> > {};\n\ntemplate <>\nstruct mul<std::complex<double> > : base<std::complex<double>, multiply_complex<double> > {};\n\n```\n\nIt seems more like a hack, but it doesn't involve changes in Eigen for now.\n\nNot sure what is wrong with nvcc using scalar_product_op in Eigen for complex numbers:\nhttps://github.com/RLovelett/eigen/blob/master/Eigen/src/Core/functors/BinaryFunctors.h#L76\n\nHowever, it seems tightly related to using built-in \\* and / operators for std:complex types.\nFor instance, this fails with the same errors as in the previous posts:\n\n```\ntemplate <typename T>\nstruct mul : base<T, Eigen::internal::scalar_product_op<T> > {};\n\ntemplate <typename T>\nstruct multiply_complex {\n  typedef std::complex<T> result_type;\n  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE result_type operator()(std::complex<T> a,\n                                                               std::complex<T> b) const {\n    return a*b;\n  }\n};\n\ntemplate <>\nstruct mul<std::complex<float> > : base<std::complex<float>, multiply_complex<float> > {};\n\ntemplate <>\nstruct mul<std::complex<double> > : base<std::complex<double>, multiply_complex<double> > {};\n\n```\n"}