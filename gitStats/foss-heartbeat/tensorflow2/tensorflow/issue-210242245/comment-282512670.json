{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/282512670", "html_url": "https://github.com/tensorflow/tensorflow/issues/7880#issuecomment-282512670", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/7880", "id": 282512670, "node_id": "MDEyOklzc3VlQ29tbWVudDI4MjUxMjY3MA==", "user": {"login": "yaroslavvb", "id": 23068, "node_id": "MDQ6VXNlcjIzMDY4", "avatar_url": "https://avatars3.githubusercontent.com/u/23068?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yaroslavvb", "html_url": "https://github.com/yaroslavvb", "followers_url": "https://api.github.com/users/yaroslavvb/followers", "following_url": "https://api.github.com/users/yaroslavvb/following{/other_user}", "gists_url": "https://api.github.com/users/yaroslavvb/gists{/gist_id}", "starred_url": "https://api.github.com/users/yaroslavvb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yaroslavvb/subscriptions", "organizations_url": "https://api.github.com/users/yaroslavvb/orgs", "repos_url": "https://api.github.com/users/yaroslavvb/repos", "events_url": "https://api.github.com/users/yaroslavvb/events{/privacy}", "received_events_url": "https://api.github.com/users/yaroslavvb/received_events", "type": "User", "site_admin": false}, "created_at": "2017-02-25T21:11:03Z", "updated_at": "2017-02-25T21:11:11Z", "author_association": "CONTRIBUTOR", "body_html": "<ol>\n<li>\n<p>Work-around is possible by having all accesses to a queue go through buffer. Your would have a \"queue\" object which consists of tf.FIFOQueue and tf.Variable, and the top object of the \"queue\" is stored in the tf.Variable. You can then implement \"peek\" that returns value of the variable, then and \"dequeue\" which overwrites it with value from the FIFOQueue</p>\n</li>\n<li>\n<p>Native support could be useful since <code>.peek</code> is a common abstraction</p>\n</li>\n</ol>", "body_text": "Work-around is possible by having all accesses to a queue go through buffer. Your would have a \"queue\" object which consists of tf.FIFOQueue and tf.Variable, and the top object of the \"queue\" is stored in the tf.Variable. You can then implement \"peek\" that returns value of the variable, then and \"dequeue\" which overwrites it with value from the FIFOQueue\n\n\nNative support could be useful since .peek is a common abstraction", "body": "1. Work-around is possible by having all accesses to a queue go through buffer. Your would have a \"queue\" object which consists of tf.FIFOQueue and tf.Variable, and the top object of the \"queue\" is stored in the tf.Variable. You can then implement \"peek\" that returns value of the variable, then and \"dequeue\" which overwrites it with value from the FIFOQueue\r\n\r\n2. Native support could be useful since `.peek` is a common abstraction"}