{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/263718346", "html_url": "https://github.com/tensorflow/tensorflow/issues/5907#issuecomment-263718346", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5907", "id": 263718346, "node_id": "MDEyOklzc3VlQ29tbWVudDI2MzcxODM0Ng==", "user": {"login": "poxvoculi", "id": 15676913, "node_id": "MDQ6VXNlcjE1Njc2OTEz", "avatar_url": "https://avatars2.githubusercontent.com/u/15676913?v=4", "gravatar_id": "", "url": "https://api.github.com/users/poxvoculi", "html_url": "https://github.com/poxvoculi", "followers_url": "https://api.github.com/users/poxvoculi/followers", "following_url": "https://api.github.com/users/poxvoculi/following{/other_user}", "gists_url": "https://api.github.com/users/poxvoculi/gists{/gist_id}", "starred_url": "https://api.github.com/users/poxvoculi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/poxvoculi/subscriptions", "organizations_url": "https://api.github.com/users/poxvoculi/orgs", "repos_url": "https://api.github.com/users/poxvoculi/repos", "events_url": "https://api.github.com/users/poxvoculi/events{/privacy}", "received_events_url": "https://api.github.com/users/poxvoculi/received_events", "type": "User", "site_admin": false}, "created_at": "2016-11-29T22:19:11Z", "updated_at": "2016-11-29T22:19:11Z", "author_association": "MEMBER", "body_html": "<p>Thanks for the very detailed report.  Using it I was able to reproduce your problem and confirm that the speed difference is in fact due to protocol buffer construction and parsing.  At a detailed level, constructing and then parsing a protobuf involves a number of operations that are done separately on each atomic element of the data structure, in this case float32s.  As an experiment you might try changing float32 to int64 and halving one of the dimensions.  The number of bytes is the same, but now the protobuf handling speed should be decreased.   In this test case, for the purpose of higher performance it would be convenient if one could alias the Tensor as a single binary buffer of a particular length, then reinterpret that buffer as the properly typed Tensor on the other side of the grpc call.  Protobufs would support this kind of (reckless) type aliasing, but TensorFlow does not.</p>", "body_text": "Thanks for the very detailed report.  Using it I was able to reproduce your problem and confirm that the speed difference is in fact due to protocol buffer construction and parsing.  At a detailed level, constructing and then parsing a protobuf involves a number of operations that are done separately on each atomic element of the data structure, in this case float32s.  As an experiment you might try changing float32 to int64 and halving one of the dimensions.  The number of bytes is the same, but now the protobuf handling speed should be decreased.   In this test case, for the purpose of higher performance it would be convenient if one could alias the Tensor as a single binary buffer of a particular length, then reinterpret that buffer as the properly typed Tensor on the other side of the grpc call.  Protobufs would support this kind of (reckless) type aliasing, but TensorFlow does not.", "body": "Thanks for the very detailed report.  Using it I was able to reproduce your problem and confirm that the speed difference is in fact due to protocol buffer construction and parsing.  At a detailed level, constructing and then parsing a protobuf involves a number of operations that are done separately on each atomic element of the data structure, in this case float32s.  As an experiment you might try changing float32 to int64 and halving one of the dimensions.  The number of bytes is the same, but now the protobuf handling speed should be decreased.   In this test case, for the purpose of higher performance it would be convenient if one could alias the Tensor as a single binary buffer of a particular length, then reinterpret that buffer as the properly typed Tensor on the other side of the grpc call.  Protobufs would support this kind of (reckless) type aliasing, but TensorFlow does not."}