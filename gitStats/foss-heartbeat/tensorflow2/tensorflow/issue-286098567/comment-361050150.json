{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/361050150", "html_url": "https://github.com/tensorflow/tensorflow/pull/15858#issuecomment-361050150", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/15858", "id": 361050150, "node_id": "MDEyOklzc3VlQ29tbWVudDM2MTA1MDE1MA==", "user": {"login": "PhilJd", "id": 16101605, "node_id": "MDQ6VXNlcjE2MTAxNjA1", "avatar_url": "https://avatars2.githubusercontent.com/u/16101605?v=4", "gravatar_id": "", "url": "https://api.github.com/users/PhilJd", "html_url": "https://github.com/PhilJd", "followers_url": "https://api.github.com/users/PhilJd/followers", "following_url": "https://api.github.com/users/PhilJd/following{/other_user}", "gists_url": "https://api.github.com/users/PhilJd/gists{/gist_id}", "starred_url": "https://api.github.com/users/PhilJd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/PhilJd/subscriptions", "organizations_url": "https://api.github.com/users/PhilJd/orgs", "repos_url": "https://api.github.com/users/PhilJd/repos", "events_url": "https://api.github.com/users/PhilJd/events{/privacy}", "received_events_url": "https://api.github.com/users/PhilJd/received_events", "type": "User", "site_admin": false}, "created_at": "2018-01-28T09:39:19Z", "updated_at": "2018-01-28T09:39:19Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=16907534\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/rmlarsen\">@rmlarsen</a></p>\n<ul>\n<li>How do I update the golden API for MacOS? The api_compatibility tests pass for python3. (I can't access the build log of Ubuntu python2)</li>\n<li>The new <code>cuda_kernel_helper.h</code> / <code>cuda_device_functions.h</code> are back in the master, I rebased, adapted this pull request accordingly and squashed commits.</li>\n</ul>\n<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=33667085\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/ub216\">@ub216</a>  Do you want to implement this as a native op or are you fine with a composition of native ops? For the composition you could take a look at the implementation of the gradient of unsorted_segment_max. I.e. something like this should work (untested):</p>\n<pre><code>unsorted_max = tf.unsorted_segment_max(params, ids)\ngathered_max = tf.gather(unsorted_max, ids)\narg_max = tf.where(tf.equal(gathered_max, params))\n</code></pre>\n<p>In any case, I think this is not the right thread to discuss this, if you're interested in implementing this as a cpp op I suggest to open a feature request issue to discuss it there ;)</p>", "body_text": "@rmlarsen\n\nHow do I update the golden API for MacOS? The api_compatibility tests pass for python3. (I can't access the build log of Ubuntu python2)\nThe new cuda_kernel_helper.h / cuda_device_functions.h are back in the master, I rebased, adapted this pull request accordingly and squashed commits.\n\n@ub216  Do you want to implement this as a native op or are you fine with a composition of native ops? For the composition you could take a look at the implementation of the gradient of unsorted_segment_max. I.e. something like this should work (untested):\nunsorted_max = tf.unsorted_segment_max(params, ids)\ngathered_max = tf.gather(unsorted_max, ids)\narg_max = tf.where(tf.equal(gathered_max, params))\n\nIn any case, I think this is not the right thread to discuss this, if you're interested in implementing this as a cpp op I suggest to open a feature request issue to discuss it there ;)", "body": "@rmlarsen\r\n- How do I update the golden API for MacOS? The api_compatibility tests pass for python3. (I can't access the build log of Ubuntu python2)\r\n- The new `cuda_kernel_helper.h` / `cuda_device_functions.h` are back in the master, I rebased, adapted this pull request accordingly and squashed commits.\r\n\r\n\r\n@ub216  Do you want to implement this as a native op or are you fine with a composition of native ops? For the composition you could take a look at the implementation of the gradient of unsorted_segment_max. I.e. something like this should work (untested):\r\n```\r\nunsorted_max = tf.unsorted_segment_max(params, ids)\r\ngathered_max = tf.gather(unsorted_max, ids)\r\narg_max = tf.where(tf.equal(gathered_max, params))\r\n```\r\nIn any case, I think this is not the right thread to discuss this, if you're interested in implementing this as a cpp op I suggest to open a feature request issue to discuss it there ;)"}