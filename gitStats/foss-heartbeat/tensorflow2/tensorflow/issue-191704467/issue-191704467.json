{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5863", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5863/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5863/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5863/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/5863", "id": 191704467, "node_id": "MDU6SXNzdWUxOTE3MDQ0Njc=", "number": 5863, "title": "Feature request: before throwing OutOfRangeError, dequeue the rest samples from a queue", "user": {"login": "wangchuan", "id": 1264835, "node_id": "MDQ6VXNlcjEyNjQ4MzU=", "avatar_url": "https://avatars3.githubusercontent.com/u/1264835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wangchuan", "html_url": "https://github.com/wangchuan", "followers_url": "https://api.github.com/users/wangchuan/followers", "following_url": "https://api.github.com/users/wangchuan/following{/other_user}", "gists_url": "https://api.github.com/users/wangchuan/gists{/gist_id}", "starred_url": "https://api.github.com/users/wangchuan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wangchuan/subscriptions", "organizations_url": "https://api.github.com/users/wangchuan/orgs", "repos_url": "https://api.github.com/users/wangchuan/repos", "events_url": "https://api.github.com/users/wangchuan/events{/privacy}", "received_events_url": "https://api.github.com/users/wangchuan/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 386191887, "node_id": "MDU6TGFiZWwzODYxOTE4ODc=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:awaiting%20response", "name": "stat:awaiting response", "color": "f4b400", "default": false}, {"id": 473173272, "node_id": "MDU6TGFiZWw0NzMxNzMyNzI=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:feature", "name": "type:feature", "color": "159b2e", "default": false}], "state": "closed", "locked": false, "assignee": {"login": "mrry", "id": 192142, "node_id": "MDQ6VXNlcjE5MjE0Mg==", "avatar_url": "https://avatars1.githubusercontent.com/u/192142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mrry", "html_url": "https://github.com/mrry", "followers_url": "https://api.github.com/users/mrry/followers", "following_url": "https://api.github.com/users/mrry/following{/other_user}", "gists_url": "https://api.github.com/users/mrry/gists{/gist_id}", "starred_url": "https://api.github.com/users/mrry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mrry/subscriptions", "organizations_url": "https://api.github.com/users/mrry/orgs", "repos_url": "https://api.github.com/users/mrry/repos", "events_url": "https://api.github.com/users/mrry/events{/privacy}", "received_events_url": "https://api.github.com/users/mrry/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "mrry", "id": 192142, "node_id": "MDQ6VXNlcjE5MjE0Mg==", "avatar_url": "https://avatars1.githubusercontent.com/u/192142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mrry", "html_url": "https://github.com/mrry", "followers_url": "https://api.github.com/users/mrry/followers", "following_url": "https://api.github.com/users/mrry/following{/other_user}", "gists_url": "https://api.github.com/users/mrry/gists{/gist_id}", "starred_url": "https://api.github.com/users/mrry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mrry/subscriptions", "organizations_url": "https://api.github.com/users/mrry/orgs", "repos_url": "https://api.github.com/users/mrry/repos", "events_url": "https://api.github.com/users/mrry/events{/privacy}", "received_events_url": "https://api.github.com/users/mrry/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 6, "created_at": "2016-11-25T13:39:59Z", "updated_at": "2016-12-08T00:57:18Z", "closed_at": "2016-12-08T00:57:18Z", "author_association": "NONE", "body_html": "<p>When using a FIFOQueue as the input for a pipeline, we often encounter the case that <code>epoch_size % batch_size == M</code> where <code>M != 0</code>. It will lead the following issue:</p>\n<p>if we would like to evaluate our model with the entire validation dataset, we cannot test the last <code>M</code> samples before getting the exception <code>OutOfRangeError</code> if we set <code>num_epoches</code> to 1. Even if we set <code>num_epoches</code> to <code>None</code> to avoid <code>OutOfRangeError</code>, we cannot exactly get the result because of the indivisibility issue.</p>\n<p>So what I can think of is, we need a feature like this:</p>\n<ol>\n<li>if <code>num_epoches</code> is set to None, we need to dequeue the rest M samples from the queue before every epoch is finished. For example, a dataset's size is 10, saying they are <code>[a,b,c,d,e,f,g,h,i,j]</code>, and <code>batch_size</code> is 3, the size of dequeued samples would be <code>[a,b,c], [d,e,f], [g,h,i], [j], [a,b,c], ...</code>;</li>\n<li>if <code>num_epoches</code> is set to 1, we need to dequeue the rest M samples from the queue before throwing <code>OutOfRangeError</code>.For the above example, the result would be <code>[a,b,c], [d,e,f], [g,h,i], [j], OutOfRangeError</code>.</li>\n</ol>", "body_text": "When using a FIFOQueue as the input for a pipeline, we often encounter the case that epoch_size % batch_size == M where M != 0. It will lead the following issue:\nif we would like to evaluate our model with the entire validation dataset, we cannot test the last M samples before getting the exception OutOfRangeError if we set num_epoches to 1. Even if we set num_epoches to None to avoid OutOfRangeError, we cannot exactly get the result because of the indivisibility issue.\nSo what I can think of is, we need a feature like this:\n\nif num_epoches is set to None, we need to dequeue the rest M samples from the queue before every epoch is finished. For example, a dataset's size is 10, saying they are [a,b,c,d,e,f,g,h,i,j], and batch_size is 3, the size of dequeued samples would be [a,b,c], [d,e,f], [g,h,i], [j], [a,b,c], ...;\nif num_epoches is set to 1, we need to dequeue the rest M samples from the queue before throwing OutOfRangeError.For the above example, the result would be [a,b,c], [d,e,f], [g,h,i], [j], OutOfRangeError.", "body": "When using a FIFOQueue as the input for a pipeline, we often encounter the case that `epoch_size % batch_size == M` where `M != 0`. It will lead the following issue:\r\n\r\nif we would like to evaluate our model with the entire validation dataset, we cannot test the last `M` samples before getting the exception `OutOfRangeError` if we set `num_epoches` to 1. Even if we set `num_epoches` to `None` to avoid `OutOfRangeError`, we cannot exactly get the result because of the indivisibility issue.\r\n\r\nSo what I can think of is, we need a feature like this:\r\n1) if `num_epoches` is set to None, we need to dequeue the rest M samples from the queue before every epoch is finished. For example, a dataset's size is 10, saying they are `[a,b,c,d,e,f,g,h,i,j]`, and `batch_size` is 3, the size of dequeued samples would be `[a,b,c], [d,e,f], [g,h,i], [j], [a,b,c], ...`;\r\n2) if `num_epoches` is set to 1, we need to dequeue the rest M samples from the queue before throwing `OutOfRangeError`.For the above example, the result would be `[a,b,c], [d,e,f], [g,h,i], [j], OutOfRangeError`."}