{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/316411496", "html_url": "https://github.com/tensorflow/tensorflow/issues/11575#issuecomment-316411496", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11575", "id": 316411496, "node_id": "MDEyOklzc3VlQ29tbWVudDMxNjQxMTQ5Ng==", "user": {"login": "BlGene", "id": 1850503, "node_id": "MDQ6VXNlcjE4NTA1MDM=", "avatar_url": "https://avatars3.githubusercontent.com/u/1850503?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BlGene", "html_url": "https://github.com/BlGene", "followers_url": "https://api.github.com/users/BlGene/followers", "following_url": "https://api.github.com/users/BlGene/following{/other_user}", "gists_url": "https://api.github.com/users/BlGene/gists{/gist_id}", "starred_url": "https://api.github.com/users/BlGene/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BlGene/subscriptions", "organizations_url": "https://api.github.com/users/BlGene/orgs", "repos_url": "https://api.github.com/users/BlGene/repos", "events_url": "https://api.github.com/users/BlGene/events{/privacy}", "received_events_url": "https://api.github.com/users/BlGene/received_events", "type": "User", "site_admin": false}, "created_at": "2017-07-19T14:48:22Z", "updated_at": "2017-07-19T14:48:22Z", "author_association": "NONE", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=326106\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/aselle\">@aselle</a> I think this would be useful, at the moment I have to do this:</p>\n<pre><code>assert_max = tf.Assert(tf.reduce_all(indices &lt; 256), [indices])\nwith tf.control_dependencies([assert_max]):\n  indices = tf.identity(indices)\nindices = tf.cast(indices, tf.uint8)\n\n# find unique indices, because SparseTensor needs this\nindices_pad = tf.pad(indices,[[0,0],[0,1]])  # shape to (N, 4)\nassert(indices_pad.get_shape()[1].value == 4)\nindices_bc  = tf.bitcast(indices_pad, tf.int32)\nunique32, _ = tf.unique(indices_bc)\nindices = tf.cast(tf.bitcast(unique32, tf.uint8)[:,:3],tf.int64)\n</code></pre>", "body_text": "@aselle I think this would be useful, at the moment I have to do this:\nassert_max = tf.Assert(tf.reduce_all(indices < 256), [indices])\nwith tf.control_dependencies([assert_max]):\n  indices = tf.identity(indices)\nindices = tf.cast(indices, tf.uint8)\n\n# find unique indices, because SparseTensor needs this\nindices_pad = tf.pad(indices,[[0,0],[0,1]])  # shape to (N, 4)\nassert(indices_pad.get_shape()[1].value == 4)\nindices_bc  = tf.bitcast(indices_pad, tf.int32)\nunique32, _ = tf.unique(indices_bc)\nindices = tf.cast(tf.bitcast(unique32, tf.uint8)[:,:3],tf.int64)", "body": "@aselle I think this would be useful, at the moment I have to do this:\r\n\r\n```\r\nassert_max = tf.Assert(tf.reduce_all(indices < 256), [indices])\r\nwith tf.control_dependencies([assert_max]):\r\n  indices = tf.identity(indices)\r\nindices = tf.cast(indices, tf.uint8)\r\n\r\n# find unique indices, because SparseTensor needs this\r\nindices_pad = tf.pad(indices,[[0,0],[0,1]])  # shape to (N, 4)\r\nassert(indices_pad.get_shape()[1].value == 4)\r\nindices_bc  = tf.bitcast(indices_pad, tf.int32)\r\nunique32, _ = tf.unique(indices_bc)\r\nindices = tf.cast(tf.bitcast(unique32, tf.uint8)[:,:3],tf.int64)\r\n```"}