{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/243149580", "html_url": "https://github.com/tensorflow/tensorflow/issues/4094#issuecomment-243149580", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/4094", "id": 243149580, "node_id": "MDEyOklzc3VlQ29tbWVudDI0MzE0OTU4MA==", "user": {"login": "mrry", "id": 192142, "node_id": "MDQ6VXNlcjE5MjE0Mg==", "avatar_url": "https://avatars1.githubusercontent.com/u/192142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mrry", "html_url": "https://github.com/mrry", "followers_url": "https://api.github.com/users/mrry/followers", "following_url": "https://api.github.com/users/mrry/following{/other_user}", "gists_url": "https://api.github.com/users/mrry/gists{/gist_id}", "starred_url": "https://api.github.com/users/mrry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mrry/subscriptions", "organizations_url": "https://api.github.com/users/mrry/orgs", "repos_url": "https://api.github.com/users/mrry/repos", "events_url": "https://api.github.com/users/mrry/events{/privacy}", "received_events_url": "https://api.github.com/users/mrry/received_events", "type": "User", "site_admin": false}, "created_at": "2016-08-29T14:58:14Z", "updated_at": "2016-08-29T15:11:15Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Any op created in a branch of a TensorFlow conditional or the body of a TensorFlow loop is marked as \"non-fetchable\", to prevent various programming errors. For example, there was once a bug where if you fetched (i.e. passed directly to <code>Session.run()</code>) the result of an op that was created in the <em>non-taken</em> branch of a conditional, it was possible to cause a crash (or perhaps a deadlock - I'm not 100% sure). Similarly, if you fetched the result of an op in a loop, the runtime would become confused because that tensor could have multiple values (one per iteration) at execution time. I'm not sure what your old code looked like, but it's possible that it was working by chance, given the way control flow is implemetned :).</p>\n<p>As I understand it, it's only possible to get into this situation if you create an op inside a branch/loop and store a reference to it in an outer context: either explicitly by assigning it to a non-local variable, or implicitly by adding it to a graph collection. The former case is easy to avoid; the latter is a bit more insidious. Recall that all functions passed to <code>tf.cond()</code> or <code>tf.while_loop()</code> must be pure functions, and so they must not modify their environment.</p>\n<p>In general, it should be possible to workaround this constraint by returning the ops that you want to run from the true-branch and false-branch functions (adding a <code>tf.no_op()</code> to the other side if necessary). Let us know if that isn't the case though.</p>", "body_text": "Any op created in a branch of a TensorFlow conditional or the body of a TensorFlow loop is marked as \"non-fetchable\", to prevent various programming errors. For example, there was once a bug where if you fetched (i.e. passed directly to Session.run()) the result of an op that was created in the non-taken branch of a conditional, it was possible to cause a crash (or perhaps a deadlock - I'm not 100% sure). Similarly, if you fetched the result of an op in a loop, the runtime would become confused because that tensor could have multiple values (one per iteration) at execution time. I'm not sure what your old code looked like, but it's possible that it was working by chance, given the way control flow is implemetned :).\nAs I understand it, it's only possible to get into this situation if you create an op inside a branch/loop and store a reference to it in an outer context: either explicitly by assigning it to a non-local variable, or implicitly by adding it to a graph collection. The former case is easy to avoid; the latter is a bit more insidious. Recall that all functions passed to tf.cond() or tf.while_loop() must be pure functions, and so they must not modify their environment.\nIn general, it should be possible to workaround this constraint by returning the ops that you want to run from the true-branch and false-branch functions (adding a tf.no_op() to the other side if necessary). Let us know if that isn't the case though.", "body": "Any op created in a branch of a TensorFlow conditional or the body of a TensorFlow loop is marked as \"non-fetchable\", to prevent various programming errors. For example, there was once a bug where if you fetched (i.e. passed directly to `Session.run()`) the result of an op that was created in the _non-taken_ branch of a conditional, it was possible to cause a crash (or perhaps a deadlock - I'm not 100% sure). Similarly, if you fetched the result of an op in a loop, the runtime would become confused because that tensor could have multiple values (one per iteration) at execution time. I'm not sure what your old code looked like, but it's possible that it was working by chance, given the way control flow is implemetned :).\n\nAs I understand it, it's only possible to get into this situation if you create an op inside a branch/loop and store a reference to it in an outer context: either explicitly by assigning it to a non-local variable, or implicitly by adding it to a graph collection. The former case is easy to avoid; the latter is a bit more insidious. Recall that all functions passed to `tf.cond()` or `tf.while_loop()` must be pure functions, and so they must not modify their environment.\n\nIn general, it should be possible to workaround this constraint by returning the ops that you want to run from the true-branch and false-branch functions (adding a `tf.no_op()` to the other side if necessary). Let us know if that isn't the case though.\n"}