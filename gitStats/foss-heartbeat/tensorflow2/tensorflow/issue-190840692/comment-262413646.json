{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/262413646", "html_url": "https://github.com/tensorflow/tensorflow/issues/5762#issuecomment-262413646", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5762", "id": 262413646, "node_id": "MDEyOklzc3VlQ29tbWVudDI2MjQxMzY0Ng==", "user": {"login": "prb12", "id": 11547801, "node_id": "MDQ6VXNlcjExNTQ3ODAx", "avatar_url": "https://avatars1.githubusercontent.com/u/11547801?v=4", "gravatar_id": "", "url": "https://api.github.com/users/prb12", "html_url": "https://github.com/prb12", "followers_url": "https://api.github.com/users/prb12/followers", "following_url": "https://api.github.com/users/prb12/following{/other_user}", "gists_url": "https://api.github.com/users/prb12/gists{/gist_id}", "starred_url": "https://api.github.com/users/prb12/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/prb12/subscriptions", "organizations_url": "https://api.github.com/users/prb12/orgs", "repos_url": "https://api.github.com/users/prb12/repos", "events_url": "https://api.github.com/users/prb12/events{/privacy}", "received_events_url": "https://api.github.com/users/prb12/received_events", "type": "User", "site_admin": false}, "created_at": "2016-11-23T01:16:33Z", "updated_at": "2016-11-24T00:08:05Z", "author_association": "MEMBER", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=21961227\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/yaccman\">@yaccman</a>  Believe me, I came across the exact same problem about 9 months ago when working on compiling TF graphs for new hardware platforms. ;-)</p>\n<p>Working directly from the GraphDef you are going to find an increasing number of problems like this, not least due to the ever increasing use of custom ops.  In the ideal case, constant folding removes much of this sort of code when you provide adequate shape information, but it is fragile to rely on this.</p>\n<p>For this reason we are encouraging people (internally and externally) to standardize on XLA as a portable intermediate representation for those targeting new hardware and accelerator platforms.   The aim is to have a small and complete set of primitives with well-defined semantics that compiler writers can implement, and TF will provide the translation to XLA for connected subgraphs which are suitable for compilation/acceleration.</p>\n<p>If you are working on something like this then please contact <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=874510\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/wolffg\">@wolffg</a> or Zak Stone.</p>", "body_text": "@yaccman  Believe me, I came across the exact same problem about 9 months ago when working on compiling TF graphs for new hardware platforms. ;-)\nWorking directly from the GraphDef you are going to find an increasing number of problems like this, not least due to the ever increasing use of custom ops.  In the ideal case, constant folding removes much of this sort of code when you provide adequate shape information, but it is fragile to rely on this.\nFor this reason we are encouraging people (internally and externally) to standardize on XLA as a portable intermediate representation for those targeting new hardware and accelerator platforms.   The aim is to have a small and complete set of primitives with well-defined semantics that compiler writers can implement, and TF will provide the translation to XLA for connected subgraphs which are suitable for compilation/acceleration.\nIf you are working on something like this then please contact @wolffg or Zak Stone.", "body": "@yaccman  Believe me, I came across the exact same problem about 9 months ago when working on compiling TF graphs for new hardware platforms. ;-)\r\n\r\nWorking directly from the GraphDef you are going to find an increasing number of problems like this, not least due to the ever increasing use of custom ops.  In the ideal case, constant folding removes much of this sort of code when you provide adequate shape information, but it is fragile to rely on this.\r\n\r\nFor this reason we are encouraging people (internally and externally) to standardize on XLA as a portable intermediate representation for those targeting new hardware and accelerator platforms.   The aim is to have a small and complete set of primitives with well-defined semantics that compiler writers can implement, and TF will provide the translation to XLA for connected subgraphs which are suitable for compilation/acceleration. \r\n\r\nIf you are working on something like this then please contact @wolffg or Zak Stone."}