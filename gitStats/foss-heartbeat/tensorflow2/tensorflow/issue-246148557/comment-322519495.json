{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/322519495", "html_url": "https://github.com/tensorflow/tensorflow/issues/11825#issuecomment-322519495", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11825", "id": 322519495, "node_id": "MDEyOklzc3VlQ29tbWVudDMyMjUxOTQ5NQ==", "user": {"login": "junshi15", "id": 12075848, "node_id": "MDQ6VXNlcjEyMDc1ODQ4", "avatar_url": "https://avatars3.githubusercontent.com/u/12075848?v=4", "gravatar_id": "", "url": "https://api.github.com/users/junshi15", "html_url": "https://github.com/junshi15", "followers_url": "https://api.github.com/users/junshi15/followers", "following_url": "https://api.github.com/users/junshi15/following{/other_user}", "gists_url": "https://api.github.com/users/junshi15/gists{/gist_id}", "starred_url": "https://api.github.com/users/junshi15/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/junshi15/subscriptions", "organizations_url": "https://api.github.com/users/junshi15/orgs", "repos_url": "https://api.github.com/users/junshi15/repos", "events_url": "https://api.github.com/users/junshi15/events{/privacy}", "received_events_url": "https://api.github.com/users/junshi15/received_events", "type": "User", "site_admin": false}, "created_at": "2017-08-15T16:36:53Z", "updated_at": "2017-08-15T16:36:53Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=22274255\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/shamoya\">@shamoya</a> Yes, there are three cases we have multiple RecvAsyncLocal. You listed the first two.</p>\n<ol>\n<li>\n<p>initial transfer, both sides need to step up the buffer first, then transfer. Two calls to RecvAsyncLocal.</p>\n</li>\n<li>\n<p>change of tensor size. similar to (1).</p>\n</li>\n<li>\n<p>concurrent transfer. Note the buffer is hashed by the tensor name, without the step_id. If the same tensor with two different step_ids need to be transferred at the same time, there will be a collision at the buffer. When this happens, one tensor needs a re-try. I think I have seen this kind of situation in Async training cases, but I did not dig deeper.</p>\n</li>\n</ol>", "body_text": "@shamoya Yes, there are three cases we have multiple RecvAsyncLocal. You listed the first two.\n\n\ninitial transfer, both sides need to step up the buffer first, then transfer. Two calls to RecvAsyncLocal.\n\n\nchange of tensor size. similar to (1).\n\n\nconcurrent transfer. Note the buffer is hashed by the tensor name, without the step_id. If the same tensor with two different step_ids need to be transferred at the same time, there will be a collision at the buffer. When this happens, one tensor needs a re-try. I think I have seen this kind of situation in Async training cases, but I did not dig deeper.", "body": "@shamoya Yes, there are three cases we have multiple RecvAsyncLocal. You listed the first two.\r\n\r\n1) initial transfer, both sides need to step up the buffer first, then transfer. Two calls to RecvAsyncLocal.\r\n\r\n2) change of tensor size. similar to (1).\r\n\r\n3) concurrent transfer. Note the buffer is hashed by the tensor name, without the step_id. If the same tensor with two different step_ids need to be transferred at the same time, there will be a collision at the buffer. When this happens, one tensor needs a re-try. I think I have seen this kind of situation in Async training cases, but I did not dig deeper.\r\n\r\n"}