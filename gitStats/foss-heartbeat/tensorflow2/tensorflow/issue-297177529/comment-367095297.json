{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/367095297", "html_url": "https://github.com/tensorflow/tensorflow/issues/17014#issuecomment-367095297", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/17014", "id": 367095297, "node_id": "MDEyOklzc3VlQ29tbWVudDM2NzA5NTI5Nw==", "user": {"login": "malcolmreynolds", "id": 36041, "node_id": "MDQ6VXNlcjM2MDQx", "avatar_url": "https://avatars2.githubusercontent.com/u/36041?v=4", "gravatar_id": "", "url": "https://api.github.com/users/malcolmreynolds", "html_url": "https://github.com/malcolmreynolds", "followers_url": "https://api.github.com/users/malcolmreynolds/followers", "following_url": "https://api.github.com/users/malcolmreynolds/following{/other_user}", "gists_url": "https://api.github.com/users/malcolmreynolds/gists{/gist_id}", "starred_url": "https://api.github.com/users/malcolmreynolds/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/malcolmreynolds/subscriptions", "organizations_url": "https://api.github.com/users/malcolmreynolds/orgs", "repos_url": "https://api.github.com/users/malcolmreynolds/repos", "events_url": "https://api.github.com/users/malcolmreynolds/events{/privacy}", "received_events_url": "https://api.github.com/users/malcolmreynolds/received_events", "type": "User", "site_admin": false}, "created_at": "2018-02-20T19:42:09Z", "updated_at": "2018-02-20T23:16:20Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Hi, <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=5682925\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/stefanbrugger\">@stefanbrugger</a></p>\n<p>This is unfortunately an issue with any part of the contrib library which defines custom C++ ops - you can easily modify your example to call tf.contrib.rnn.LSTMBlockFusedCell and trigger exactly the same kind of error. After you do <code>import tensorflow as tf</code>, tf skips loading all of contrib into memory until it is necessary. When you access <code>tf.contrib.resampler</code> inside <code>export()</code>, under the hood some extra ops get loaded and are available for the immediately following code. It might help to think of lines that access tf.contrib.* as having an implict <code>import</code> statement right above them, as that is effectively what is happening.</p>\n<p>In the short term a workaround is to always access the specific subpart of contrib you might want to use ops from at the top of your program - if you just do the follwing at the top of the file:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">import</span> tensorflow <span class=\"pl-k\">as</span> tf\ntf.contrib.resampler  <span class=\"pl-c\"><span class=\"pl-c\">#</span> This is effectively importing some more ops</span>\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> ... rest of code</span></pre></div>\n<p>The above change means when you come to import the saved graph def, all the ops are available and load_model completes successfully.</p>\n<p>This is currently not documented too well, we will add some extra information to the relevant docstrings.</p>\n<p>In the long term there are plans to make dealing with ops that aren't in the core more seamless, which should mean this workaround isn't necessary.</p>\n<p>Please let me know if any of the above doesn't make sense.</p>", "body_text": "Hi, @stefanbrugger\nThis is unfortunately an issue with any part of the contrib library which defines custom C++ ops - you can easily modify your example to call tf.contrib.rnn.LSTMBlockFusedCell and trigger exactly the same kind of error. After you do import tensorflow as tf, tf skips loading all of contrib into memory until it is necessary. When you access tf.contrib.resampler inside export(), under the hood some extra ops get loaded and are available for the immediately following code. It might help to think of lines that access tf.contrib.* as having an implict import statement right above them, as that is effectively what is happening.\nIn the short term a workaround is to always access the specific subpart of contrib you might want to use ops from at the top of your program - if you just do the follwing at the top of the file:\nimport tensorflow as tf\ntf.contrib.resampler  # This is effectively importing some more ops\n\n# ... rest of code\nThe above change means when you come to import the saved graph def, all the ops are available and load_model completes successfully.\nThis is currently not documented too well, we will add some extra information to the relevant docstrings.\nIn the long term there are plans to make dealing with ops that aren't in the core more seamless, which should mean this workaround isn't necessary.\nPlease let me know if any of the above doesn't make sense.", "body": "Hi, @stefanbrugger \r\n\r\nThis is unfortunately an issue with any part of the contrib library which defines custom C++ ops - you can easily modify your example to call tf.contrib.rnn.LSTMBlockFusedCell and trigger exactly the same kind of error. After you do `import tensorflow as tf`, tf skips loading all of contrib into memory until it is necessary. When you access `tf.contrib.resampler` inside `export()`, under the hood some extra ops get loaded and are available for the immediately following code. It might help to think of lines that access tf.contrib.* as having an implict `import` statement right above them, as that is effectively what is happening.\r\n\r\nIn the short term a workaround is to always access the specific subpart of contrib you might want to use ops from at the top of your program - if you just do the follwing at the top of the file:\r\n\r\n```python\r\nimport tensorflow as tf\r\ntf.contrib.resampler  # This is effectively importing some more ops\r\n\r\n# ... rest of code\r\n```\r\n\r\nThe above change means when you come to import the saved graph def, all the ops are available and load_model completes successfully.\r\n\r\nThis is currently not documented too well, we will add some extra information to the relevant docstrings.\r\n\r\nIn the long term there are plans to make dealing with ops that aren't in the core more seamless, which should mean this workaround isn't necessary.\r\n\r\nPlease let me know if any of the above doesn't make sense.\r\n\r\n"}