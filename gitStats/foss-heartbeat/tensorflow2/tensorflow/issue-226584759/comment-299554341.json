{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/299554341", "html_url": "https://github.com/tensorflow/tensorflow/pull/9686#issuecomment-299554341", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9686", "id": 299554341, "node_id": "MDEyOklzc3VlQ29tbWVudDI5OTU1NDM0MQ==", "user": {"login": "sjperkins", "id": 3530212, "node_id": "MDQ6VXNlcjM1MzAyMTI=", "avatar_url": "https://avatars3.githubusercontent.com/u/3530212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sjperkins", "html_url": "https://github.com/sjperkins", "followers_url": "https://api.github.com/users/sjperkins/followers", "following_url": "https://api.github.com/users/sjperkins/following{/other_user}", "gists_url": "https://api.github.com/users/sjperkins/gists{/gist_id}", "starred_url": "https://api.github.com/users/sjperkins/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sjperkins/subscriptions", "organizations_url": "https://api.github.com/users/sjperkins/orgs", "repos_url": "https://api.github.com/users/sjperkins/repos", "events_url": "https://api.github.com/users/sjperkins/events{/privacy}", "received_events_url": "https://api.github.com/users/sjperkins/received_events", "type": "User", "site_admin": false}, "created_at": "2017-05-05T19:25:37Z", "updated_at": "2017-05-05T19:25:37Z", "author_association": "CONTRIBUTOR", "body_html": "<blockquote>\n<p>Rather than creating new python high level ops, could we slightly modify the existing StagingArea interface by adding an optional key argument to get and put? If the key is present, then your C++ ops would be used, otherwise the current C++ ops would be used. The constructor could take an argument that decides on ordering.</p>\n</blockquote>\n<p>I disagree with this approach because two very different data structures are being exposed and I think it would be a mistake to combine their interface. They offer different <a href=\"https://en.wikipedia.org/wiki/Affordance\" rel=\"nofollow\">affordances</a> (see Norman's <a href=\"https://en.wikipedia.org/wiki/The_Design_of_Everyday_Things\" rel=\"nofollow\">The Design of Everyday Things</a>) to the user. Thus:</p>\n<ol>\n<li>Mixing the interfaces will be confusing for the end user. StagingArea behaves like a list while MapStagingArea behaves like a dict.</li>\n<li>I actually think it will be more difficult to maintain since the combination of interfaces is confusing.</li>\n<li>Does the data for the list exist in a different container from the dict?</li>\n<li>What happens if the user puts without a key and then then tries to get with a key?</li>\n</ol>\n<p>I think the following would be better:</p>\n<ol>\n<li>Keep the separate list (StagingArea) vs map (MapStagingArea) python classes</li>\n<li>Move common functionality into a Base Class (coloc op, dtype, shape, name, return value handling etc.)</li>\n<li>Rename <code>get(key)</code> to <code>peek(key)</code> in the dict. I dislike losing the name of the python dict method, but it probably too late to change <code>get()</code> to <code>pop()</code> in the list.</li>\n<li>Add <code>peek(index)</code>, <code>size</code> and <code>clear</code> methods to the list (Already got a size op for the list).</li>\n</ol>\n<blockquote>\n<p>You can choose to add fixed capacity to the existing StagingArea or remove it from the new classes (so only unbounded).</p>\n</blockquote>\n<p>OK I can do this.</p>", "body_text": "Rather than creating new python high level ops, could we slightly modify the existing StagingArea interface by adding an optional key argument to get and put? If the key is present, then your C++ ops would be used, otherwise the current C++ ops would be used. The constructor could take an argument that decides on ordering.\n\nI disagree with this approach because two very different data structures are being exposed and I think it would be a mistake to combine their interface. They offer different affordances (see Norman's The Design of Everyday Things) to the user. Thus:\n\nMixing the interfaces will be confusing for the end user. StagingArea behaves like a list while MapStagingArea behaves like a dict.\nI actually think it will be more difficult to maintain since the combination of interfaces is confusing.\nDoes the data for the list exist in a different container from the dict?\nWhat happens if the user puts without a key and then then tries to get with a key?\n\nI think the following would be better:\n\nKeep the separate list (StagingArea) vs map (MapStagingArea) python classes\nMove common functionality into a Base Class (coloc op, dtype, shape, name, return value handling etc.)\nRename get(key) to peek(key) in the dict. I dislike losing the name of the python dict method, but it probably too late to change get() to pop() in the list.\nAdd peek(index), size and clear methods to the list (Already got a size op for the list).\n\n\nYou can choose to add fixed capacity to the existing StagingArea or remove it from the new classes (so only unbounded).\n\nOK I can do this.", "body": "> Rather than creating new python high level ops, could we slightly modify the existing StagingArea interface by adding an optional key argument to get and put? If the key is present, then your C++ ops would be used, otherwise the current C++ ops would be used. The constructor could take an argument that decides on ordering.\r\n\r\nI disagree with this approach because two very different data structures are being exposed and I think it would be a mistake to combine their interface. They offer different [affordances](https://en.wikipedia.org/wiki/Affordance) (see Norman's [The Design of Everyday Things](https://en.wikipedia.org/wiki/The_Design_of_Everyday_Things)) to the user. Thus:\r\n\r\n1. Mixing the interfaces will be confusing for the end user. StagingArea behaves like a list while MapStagingArea behaves like a dict. \r\n2. I actually think it will be more difficult to maintain since the combination of interfaces is confusing.\r\n3. Does the data for the list exist in a different container from the dict?\r\n4. What happens if the user puts without a key and then then tries to get with a key?\r\n\r\nI think the following would be better:\r\n\r\n1. Keep the separate list (StagingArea) vs map (MapStagingArea) python classes\r\n2. Move common functionality into a Base Class (coloc op, dtype, shape, name, return value handling etc.)\r\n3. Rename `get(key)` to `peek(key)` in the dict. I dislike losing the name of the python dict method, but it probably too late to change `get()` to `pop()` in the list.\r\n4. Add `peek(index)`, `size` and `clear` methods to the list (Already got a size op for the list).\r\n\r\n> You can choose to add fixed capacity to the existing StagingArea or remove it from the new classes (so only unbounded).\r\n\r\nOK I can do this.\r\n"}