{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/115997896", "pull_request_review_id": 37584473, "id": 115997896, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDExNTk5Nzg5Ng==", "diff_hunk": "@@ -0,0 +1,497 @@\n+#include <map>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include \"tensorflow/core/framework/op_kernel.h\"\n+#include \"tensorflow/core/framework/resource_mgr.h\"\n+#include \"tensorflow/core/framework/tensor.h\"\n+#include \"tensorflow/core/framework/tensor_shape.h\"\n+#include \"tensorflow/core/lib/strings/strcat.h\"\n+#include \"tensorflow/core/platform/env.h\"\n+#include \"tensorflow/core/platform/mutex.h\"\n+\n+namespace tensorflow {\n+\n+namespace {\n+\n+// General Template Definition\n+template <bool Ordered, typename Key, typename Data>\n+struct MapTraits {};\n+\n+// Partially specialise for ordered\n+template <typename Key, typename Data>\n+struct MapTraits<true, Key, Data>\n+{\n+  typedef Key key_type;\n+  typedef Data data_type;\n+  typedef std::map<Key, Data> map_type;\n+};\n+\n+// Partially specialise for unordered\n+template <typename Key, typename Data>\n+struct MapTraits<false, Key, Data>\n+{\n+  typedef Key key_type;\n+  typedef Data data_type;\n+  typedef std::unordered_map<Key, Data> map_type;\n+};\n+\n+// Wrapper around map/unordered_map\n+template <bool Ordered>\n+class StagingMap : public ResourceBase\n+{\n+public:\n+  // Public typedefs\n+  typedef MapTraits<Ordered, int64, std::vector<Tensor>> map_traits;\n+  typedef typename map_traits::map_type map_type;\n+  typedef typename map_traits::key_type key_type;\n+  typedef typename map_traits::data_type Tuple;\n+\n+private:\n+  // Private variables\n+  int capacity_;\n+  mutex mu_;\n+  condition_variable not_empty_;\n+  condition_variable full_;\n+  map_type map_ GUARDED_BY(mu_);\n+\n+public:\n+  // public methods\n+  explicit StagingMap(int capacity)\n+    { capacity_ = capacity; }\n+\n+  bool has_bounded_capacity()\n+    { return capacity_ > 0; }\n+\n+  bool full()\n+    { return map_.size() >= capacity_; }\n+\n+  void put(key_type* key, Tuple* tuple)\n+  {\n+    mutex_lock l(mu_);\n+\n+    // If map capacity is bounded wait until map is not full\n+    if(has_bounded_capacity())\n+      { full_.wait(l, [this]() { return !this->full(); }); }\n+\n+    // Insert key and tuples into the map\n+    map_.insert({*key, std::move(*tuple)});\n+\n+    notify_removers(l);\n+  }\n+\n+  Status get(key_type* key, Tuple* tuple)\n+  {\n+    mutex_lock l(mu_);\n+\n+    typename map_type::const_iterator it;\n+\n+    // Wait until the element with the requested key is present\n+    not_empty_.wait(l, [&, this]() {\n+      it = map_.find(*key);\n+      return it != map_.end();\n+    });\n+\n+    // Copy tensors into the tuple\n+    for(const auto & tensor : it->second)\n+      { tuple->push_back(tensor); }\n+\n+    return Status::OK();\n+  }\n+\n+  Status pop(key_type* key, Tuple* tuple)\n+  {\n+    mutex_lock l(mu_);\n+\n+    typename map_type::iterator it;\n+\n+    // Wait until the element with the requested key is present\n+    not_empty_.wait(l, [&, this]() {\n+      it = map_.find(*key);\n+      return it != this->map_.end();\n+    });\n+\n+    // Move from the entry as its erased anyway\n+    *tuple = std::move(it->second);\n+\n+    // Remove\n+    map_.erase(it);\n+\n+    notify_inserters_if_bounded(l);\n+\n+    return Status::OK();\n+  }\n+\n+  Status popitem(key_type* key, Tuple* tuple)\n+  {\n+    mutex_lock l(mu_);\n+\n+    // Wait until map is not empty\n+    not_empty_.wait(l, [this]() { return !this->map_.empty(); });\n+\n+    // Move from the first element and erase it\n+    *tuple = std::move(map_.begin()->second);\n+    *key = map_.begin()->first;\n+    map_.erase(map_.begin());\n+\n+    notify_inserters_if_bounded(l);\n+\n+    return Status::OK();\n+  }\n+\n+  Status clear()\n+  {\n+    mutex_lock l(mu_);\n+    map_.clear();\n+    notify_inserters_if_bounded(l);\n+\n+    return Status::OK();\n+  }\n+\n+  size_t size()\n+  {\n+    // Lock the map and return the size\n+    mutex_lock l(mu_);\n+    return map_.size();\n+  }\n+\n+  string DebugString()\n+  {\n+    return \"StagingMap\";\n+  }\n+\n+private:\n+  // private methods\n+\n+  // If map is configured for bounded capacity, notify\n+  // waiting inserters that space is now available\n+  void notify_inserters_if_bounded(mutex_lock & l)\n+  {\n+    if(has_bounded_capacity())\n+    {\n+      l.unlock();\n+      full_.notify_one();\n+    }\n+  }\n+\n+  // Notify any removers waiting to extract values\n+  // that data is now available\n+  void notify_removers(mutex_lock & l)\n+  {\n+      l.unlock();\n+      not_empty_.notify_one();\n+  }\n+};\n+\n+template <bool Ordered>\n+Status GetStagingMap(OpKernelContext* ctx,\n+                    const NodeDef& ndef,\n+                    StagingMap<Ordered>** map)\n+{\n+  auto rm = ctx->resource_manager();\n+  ContainerInfo cinfo;\n+\n+  // Lambda for creating the Staging Area\n+  auto create_fn = [&ndef](StagingMap<Ordered>** ret) -> Status\n+  {\n+    int capacity;\n+    TF_RETURN_IF_ERROR(GetNodeAttr(ndef, \"capacity\", &capacity));\n+    *ret = new StagingMap<Ordered>(capacity);\n+    return Status::OK();\n+  };\n+\n+  TF_RETURN_IF_ERROR(cinfo.Init(rm, ndef, true /* use name() */));\n+  TF_RETURN_IF_ERROR(rm->LookupOrCreate<StagingMap<Ordered>>(\n+                        cinfo.container(), cinfo.name(),\n+                        map, create_fn));\n+  return Status::OK();\n+}\n+\n+template <bool Ordered>\n+class MapStageOp : public OpKernel\n+{\n+ public:\n+  explicit MapStageOp(OpKernelConstruction* ctx) : OpKernel(ctx) {}\n+\n+  void Compute(OpKernelContext* ctx) override {\n+    StagingMap<Ordered>* map = nullptr;\n+    OP_REQUIRES_OK(ctx, GetStagingMap(ctx, def(), &map));\n+    core::ScopedUnref scope(map);\n+    typename StagingMap<Ordered>::Tuple tuple;\n+\n+    const Tensor * key_tensor;\n+    OpInputList values_tensor;\n+\n+    OP_REQUIRES_OK(ctx, ctx->input(\"key\", &key_tensor));\n+    OP_REQUIRES_OK(ctx, ctx->input_list(\"values\", &values_tensor));\n+\n+    // Obtain the key\n+    auto key = key_tensor->scalar<typename StagingMap<Ordered>::key_type>()();\n+\n+    // Create the tuple to store\n+    for (int i = 0; i < values_tensor.size(); ++i) {\n+      tuple.push_back(values_tensor[i]);\n+    }\n+\n+    // Store the tuple in the map\n+    map->put(&key, &tuple);\n+  }\n+};\n+\n+REGISTER_KERNEL_BUILDER(Name(\"MapStage\").Device(DEVICE_CPU),\n+                      MapStageOp<false>);\n+REGISTER_KERNEL_BUILDER(Name(\"OrderedMapStage\").Device(DEVICE_CPU),\n+                      MapStageOp<true>);\n+\n+#if GOOGLE_CUDA\n+REGISTER_KERNEL_BUILDER(Name(\"MapStage\").HostMemory(\"key\")\n+                      .Device(DEVICE_GPU), MapStageOp<false>);\n+REGISTER_KERNEL_BUILDER(Name(\"OrderedMapStage\").HostMemory(\"key\")\n+                      .Device(DEVICE_GPU), MapStageOp<true>);\n+#endif\n+#ifdef TENSORFLOW_USE_SYCL\n+REGISTER_KERNEL_BUILDER(Name(\"MapStage\").HostMemory(\"key\")\n+                      .Device(DEVICE_SYCL), MapStageOp<false>);\n+REGISTER_KERNEL_BUILDER(Name(\"MapStage\").HostMemory(\"key\")", "path": "tensorflow/core/kernels/map_stage_op.cc", "position": null, "original_position": 255, "commit_id": "b292353578075c3a31ad438458a74a8538360ec6", "original_commit_id": "92d4d732cab8c6b8db83a38166298ed9a4e8961c", "user": {"login": "sjperkins", "id": 3530212, "node_id": "MDQ6VXNlcjM1MzAyMTI=", "avatar_url": "https://avatars3.githubusercontent.com/u/3530212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sjperkins", "html_url": "https://github.com/sjperkins", "followers_url": "https://api.github.com/users/sjperkins/followers", "following_url": "https://api.github.com/users/sjperkins/following{/other_user}", "gists_url": "https://api.github.com/users/sjperkins/gists{/gist_id}", "starred_url": "https://api.github.com/users/sjperkins/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sjperkins/subscriptions", "organizations_url": "https://api.github.com/users/sjperkins/orgs", "repos_url": "https://api.github.com/users/sjperkins/repos", "events_url": "https://api.github.com/users/sjperkins/events{/privacy}", "received_events_url": "https://api.github.com/users/sjperkins/received_events", "type": "User", "site_admin": false}, "body": "https://github.com/tensorflow/tensorflow/pull/9686/commits/895be638df52a50de74e6f99dbabb5c866df5b95", "created_at": "2017-05-11T14:02:31Z", "updated_at": "2017-05-19T19:22:57Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/9686#discussion_r115997896", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/9686", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/115997896"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/9686#discussion_r115997896"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/9686"}}, "body_html": "<p><a class=\"commit-link\" data-hovercard-type=\"commit\" data-hovercard-url=\"https://github.com/tensorflow/tensorflow/commit/895be638df52a50de74e6f99dbabb5c866df5b95/hovercard\" href=\"https://github.com/tensorflow/tensorflow/commit/895be638df52a50de74e6f99dbabb5c866df5b95\"><tt>895be63</tt></a></p>", "body_text": "895be63", "in_reply_to_id": 115607482}