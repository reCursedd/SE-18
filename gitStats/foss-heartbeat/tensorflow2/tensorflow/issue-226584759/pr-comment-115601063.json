{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/115601063", "pull_request_review_id": 37144031, "id": 115601063, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDExNTYwMTA2Mw==", "diff_hunk": "@@ -1584,19 +1642,270 @@ def get(self, name=None):\n     if name is None:\n       name = \"%s_get\" % self._name\n \n-    with ops.colocate_with(self._coloc_op):\n-      ret = gen_data_flow_ops.unstage(dtypes=self._dtypes,\n-                                      shared_name=self._name, name=name)\n+    fn = lambda: gen_data_flow_ops.unstage(dtypes=self._dtypes,\n+                    shared_name=self._name, name=name,\n+                    capacity=self._capacity)\n \n-    curr_device_scope = control_flow_ops.no_op().device\n-    if curr_device_scope != self._coloc_op.device:\n-      for i in range(len(ret)):\n-        ret[i] = array_ops.identity(ret[i])\n+    return self.__internal_get(fn, name)\n \n-    for output, shape in zip(ret, self._shapes):\n-      output.set_shape(shape)\n+  def peek(self, index, name=None):\n+    \"\"\"Peeks at an element in the staging area.\n \n-    return self._get_return_value(ret)\n+    If the staging area is too small to contain the element at\n+    the specified index, it will block until enough elements\n+    are inserted to complete the operation.\n+\n+    The placement of the returned tensor will be determined by the current\n+    device scope when this function is called.\n+\n+    Args:\n+      index: The index of the tensor within the staging area\n+              to look up.\n+      name: A name for the operation (optional).\n+\n+    Returns:\n+      The tuple of tensors that was gotten.\n+    \"\"\"\n+    if name is None:\n+      name = \"%s_peek\" % self._name\n+\n+    fn = lambda: gen_data_flow_ops.stage_peek(index,\n+                    dtypes=self._dtypes, shared_name=self._name,\n+                    name=name, capacity=self._capacity)\n+\n+    return self.__internal_get(fn, name)\n+\n+  def size(self, name=None):\n+    \"\"\"Returns the number of elements in the staging area.\n+\n+    Args:\n+        name: A name for the operation (optional)\n+\n+    Returns:\n+        The created op\n+    \"\"\"\n+    if name is None:\n+        name = \"%s_size\" % self._name\n+\n+    return gen_data_flow_ops.stage_size(shared_name=self._name,\n+                        name=name,\n+                        capacity=self._capacity)\n+\n+  def clear(self, name=None):\n+    \"\"\"Empties the staging area.\"\"\"\n+    if name is None:\n+      name = \"%s_clear\" % self._name\n+\n+    return gen_data_flow_ops.stage_clear(shared_name=self._name,\n+                        name=name,\n+                        capacity=self._capacity)\n+\n+class MapStagingArea(BaseStagingArea):\n+    \"\"\"\n+    Class for staging inputs. Similar to `StagingArea` but behaves\n+    like a hashtable with support for puts, gets, pops, popitems,", "path": "tensorflow/python/ops/data_flow_ops.py", "position": null, "original_position": 383, "commit_id": "b292353578075c3a31ad438458a74a8538360ec6", "original_commit_id": "92d4d732cab8c6b8db83a38166298ed9a4e8961c", "user": {"login": "ekelsen", "id": 2533174, "node_id": "MDQ6VXNlcjI1MzMxNzQ=", "avatar_url": "https://avatars0.githubusercontent.com/u/2533174?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ekelsen", "html_url": "https://github.com/ekelsen", "followers_url": "https://api.github.com/users/ekelsen/followers", "following_url": "https://api.github.com/users/ekelsen/following{/other_user}", "gists_url": "https://api.github.com/users/ekelsen/gists{/gist_id}", "starred_url": "https://api.github.com/users/ekelsen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ekelsen/subscriptions", "organizations_url": "https://api.github.com/users/ekelsen/orgs", "repos_url": "https://api.github.com/users/ekelsen/repos", "events_url": "https://api.github.com/users/ekelsen/events{/privacy}", "received_events_url": "https://api.github.com/users/ekelsen/received_events", "type": "User", "site_admin": false}, "body": "hashtable -> associative container? since the backing can also be a tree?", "created_at": "2017-05-09T20:59:23Z", "updated_at": "2017-05-19T19:22:57Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/9686#discussion_r115601063", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/9686", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/115601063"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/9686#discussion_r115601063"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/9686"}}, "body_html": "<p>hashtable -&gt; associative container? since the backing can also be a tree?</p>", "body_text": "hashtable -> associative container? since the backing can also be a tree?"}