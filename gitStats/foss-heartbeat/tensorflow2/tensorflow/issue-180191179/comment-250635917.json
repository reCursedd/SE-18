{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/250635917", "html_url": "https://github.com/tensorflow/tensorflow/issues/4663#issuecomment-250635917", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/4663", "id": 250635917, "node_id": "MDEyOklzc3VlQ29tbWVudDI1MDYzNTkxNw==", "user": {"login": "eamartin", "id": 287200, "node_id": "MDQ6VXNlcjI4NzIwMA==", "avatar_url": "https://avatars2.githubusercontent.com/u/287200?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eamartin", "html_url": "https://github.com/eamartin", "followers_url": "https://api.github.com/users/eamartin/followers", "following_url": "https://api.github.com/users/eamartin/following{/other_user}", "gists_url": "https://api.github.com/users/eamartin/gists{/gist_id}", "starred_url": "https://api.github.com/users/eamartin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eamartin/subscriptions", "organizations_url": "https://api.github.com/users/eamartin/orgs", "repos_url": "https://api.github.com/users/eamartin/repos", "events_url": "https://api.github.com/users/eamartin/events{/privacy}", "received_events_url": "https://api.github.com/users/eamartin/received_events", "type": "User", "site_admin": false}, "created_at": "2016-09-30T01:23:36Z", "updated_at": "2016-09-30T18:40:25Z", "author_association": "NONE", "body_html": "<p>I'm guessing <code>identity</code> has an optimization to not perform a copy if there is no device transfer. In this case, I do need a copy of <code>x</code>.</p>\n<p>Really, what I want is a function that returns both the old value and the new value of a variable. As you noted with your <code>tf.square</code> example, applying a non-identity op to <code>x</code> seems to cause a copy, so I can likely hack around this bug with <code>old_val = x + 0</code>.</p>\n<p>edit: I confirmed that replacing <code>old_val = tf.identity(x)</code> with <code>old_val = x + 0</code> causes <code>old_val</code> to fetch as <code>new_val - 1</code> (correct behavior) rather than <code>new_val</code>.</p>", "body_text": "I'm guessing identity has an optimization to not perform a copy if there is no device transfer. In this case, I do need a copy of x.\nReally, what I want is a function that returns both the old value and the new value of a variable. As you noted with your tf.square example, applying a non-identity op to x seems to cause a copy, so I can likely hack around this bug with old_val = x + 0.\nedit: I confirmed that replacing old_val = tf.identity(x) with old_val = x + 0 causes old_val to fetch as new_val - 1 (correct behavior) rather than new_val.", "body": "I'm guessing `identity` has an optimization to not perform a copy if there is no device transfer. In this case, I do need a copy of `x`.\n\nReally, what I want is a function that returns both the old value and the new value of a variable. As you noted with your `tf.square` example, applying a non-identity op to `x` seems to cause a copy, so I can likely hack around this bug with `old_val = x + 0`.\n\nedit: I confirmed that replacing `old_val = tf.identity(x)` with `old_val = x + 0` causes `old_val` to fetch as `new_val - 1` (correct behavior) rather than `new_val`.\n"}