{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/16054", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/16054/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/16054/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/16054/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/16054", "id": 287939561, "node_id": "MDU6SXNzdWUyODc5Mzk1NjE=", "number": 16054, "title": "Lack of Complex64 support for Java API", "user": {"login": "rajha-korithrien", "id": 8145476, "node_id": "MDQ6VXNlcjgxNDU0NzY=", "avatar_url": "https://avatars3.githubusercontent.com/u/8145476?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rajha-korithrien", "html_url": "https://github.com/rajha-korithrien", "followers_url": "https://api.github.com/users/rajha-korithrien/followers", "following_url": "https://api.github.com/users/rajha-korithrien/following{/other_user}", "gists_url": "https://api.github.com/users/rajha-korithrien/gists{/gist_id}", "starred_url": "https://api.github.com/users/rajha-korithrien/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rajha-korithrien/subscriptions", "organizations_url": "https://api.github.com/users/rajha-korithrien/orgs", "repos_url": "https://api.github.com/users/rajha-korithrien/repos", "events_url": "https://api.github.com/users/rajha-korithrien/events{/privacy}", "received_events_url": "https://api.github.com/users/rajha-korithrien/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 299643928, "node_id": "MDU6TGFiZWwyOTk2NDM5Mjg=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:contributions%20welcome", "name": "stat:contributions welcome", "color": "f4b400", "default": false}, {"id": 473173272, "node_id": "MDU6TGFiZWw0NzMxNzMyNzI=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:feature", "name": "type:feature", "color": "159b2e", "default": false}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2018-01-11T22:02:31Z", "updated_at": "2018-01-16T07:08:59Z", "closed_at": null, "author_association": "NONE", "body_html": "<p>This issue is not about a bug, but I will fill in the form anyhow ;-)</p>\n<h3>System information</h3>\n<ul>\n<li><strong>Have I written custom code (as opposed to using a stock example script provided in TensorFlow)</strong>:<br>\nYes</li>\n<li><strong>OS Platform and Distribution (e.g., Linux Ubuntu 16.04)</strong>:<br>\nMac 10.13.2</li>\n<li><strong>TensorFlow installed from (source or binary)</strong>:<br>\nsource</li>\n<li><strong>TensorFlow version (use command below)</strong>:<br>\nmaster branch at commit: <a class=\"commit-link\" data-hovercard-type=\"commit\" data-hovercard-url=\"https://github.com/tensorflow/tensorflow/commit/b86dc365ebbef64daceced37026518696ede5b7b/hovercard\" href=\"https://github.com/tensorflow/tensorflow/commit/b86dc365ebbef64daceced37026518696ede5b7b\"><tt>b86dc36</tt></a></li>\n<li><strong>Python version</strong>:<br>\nN/A Using Java version \"1.8.0_152\"</li>\n<li><strong>Bazel version (if compiling from source)</strong>:<br>\nBuild label: 0.8.1-homebrew<br>\nBuild target: bazel-out/darwin-opt/bin/src/main/java/com/google/devtools/build/lib/bazel/BazelServer_deploy.jar<br>\nBuild time: Tue Dec 5 19:29:04 2017 (1512502144)</li>\n<li><strong>GCC/Compiler version (if compiling from source)</strong>:<br>\nConfigured with: --prefix=/Applications/Xcode.app/Contents/Developer/usr --with-gxx-include-dir=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/c++/4.2.1<br>\nApple LLVM version 9.0.0 (clang-900.0.39.2)<br>\nTarget: x86_64-apple-darwin17.3.0<br>\nThread model: posix<br>\nInstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin</li>\n<li><strong>CUDA/cuDNN version</strong>:<br>\nN/A not using CUDA</li>\n<li><strong>GPU model and memory</strong>:<br>\nN/A not using GPU</li>\n<li><strong>Exact command to reproduce</strong>:<br>\nThere is no bug to reproduce</li>\n</ul>\n<h3>Describe the problem</h3>\n<p>There is not really a problem. I have need to build TensorFlow computations in Java and have support for complex numbers. Because the C API already supports COMPLEX64 tensors, it was a straight forward effort to expose them in the Java API. Along with unit tests, I have also added a Java example based on the Python tutorial that builds an image that displays the Mandelbrot fractal to show that the complex number support works correctly.</p>\n<h3>Source code / logs</h3>\n<p>Here is a very short example of using the API, clearly there are functions in the example that are not available defined in the example, but it gets the point across. This example is basically lifted from a new java example I created called MandelbrotExample.java</p>\n<pre><code>Tensor&lt;Complex64&gt; resultZ = null;\ntry(Graph g = new Graph()) {\n    //We create a meshgrid based on two numeric ranges, by wrapping the ranges\n    //in Tensors and then pulling out sub grids to make complex numbers\n    try (Tensor&lt;Float&gt; meshGridT = buildMeshGrid(range1Spec, range2Spec);\n         Tensor&lt;Integer&gt; zeroT = Tensors.create(new int[]{0});\n         Tensor&lt;Integer&gt; oneT = Tensors.create(new int[]{1});\n         Tensor&lt;Complex64&gt; jTensor = Tensors.create(0.0f, 1.0f)) {\n    \n        Output&lt;Integer&gt; zero = buildConstant(g, \"0\", zeroT);\n        Output&lt;Integer&gt; one = buildConstant(g, \"1\", oneT);\n\n        Output&lt;Float&gt; meshGrid = buildConstant(g, \"meshgrid\", meshGridT);\n\n        Output&lt;Complex64&gt; j = buildConstant(g, \"imagUnit\", jTensor);\n\n        //We use GatherNd to pull out the two parts of the original mesh grid\n        //the Z complex tensor\n        Output&lt;Float&gt; Yfloat = g.opBuilder(\"GatherNd\", \"get_y\")\n                .addInput(meshGrid)\n                .addInput(zero) //use zero\n                .build().output(0);\n        Output&lt;Float&gt; Xfloat = g.opBuilder(\"GatherNd\", \"get_x\")\n                .addInput(meshGrid)\n                .addInput(one) //use one\n                .build().output(0);\n\n        Output&lt;Complex64&gt; Y = g.opBuilder(\"Cast\", \"castYtoComplex\")\n                .addInput(Yfloat)\n                .setAttr(\"DstT\", DataType.COMPLEX64)\n                .build().output(0);\n\n        Output&lt;Complex64&gt; X = g.opBuilder(\"Cast\", \"castXtoComplex\")\n                .addInput(Xfloat)\n                .setAttr(\"DstT\", DataType.COMPLEX64)\n                .build().output(0);\n\n        //Z is constructed by X + Yj\n        Output&lt;Complex64&gt; mulYj = g.opBuilder(\"Mul\", \"mulYj\")\n                .addInput(Y)\n                .addInput(j)\n                .build()\n                .output(0);\n        Output&lt;Complex64&gt; Z = g.opBuilder(\"Add\", \"addZ\")\n                .addInput(X)\n                .addInput(mulYj)\n                .build()\n                .output(0);\n\n        try(Session s = new Session(g)){\n            resultZ = s.runner().fetch(Z).run().get(0).expect(Complex64.class);\n        }\n    }\n}\n</code></pre>\n<p>I would like to get my local branched pushed to GitHub and then a pull request put in with these changes. I have attached a diff file for the curious. I am still working on getting a corporate CLA put into place.<br>\nThanks for your time and consideration!<br>\n<a href=\"https://github.com/tensorflow/tensorflow/files/1624251/java-complex64.patch.txt\">java-complex64.patch.txt</a></p>", "body_text": "This issue is not about a bug, but I will fill in the form anyhow ;-)\nSystem information\n\nHave I written custom code (as opposed to using a stock example script provided in TensorFlow):\nYes\nOS Platform and Distribution (e.g., Linux Ubuntu 16.04):\nMac 10.13.2\nTensorFlow installed from (source or binary):\nsource\nTensorFlow version (use command below):\nmaster branch at commit: b86dc36\nPython version:\nN/A Using Java version \"1.8.0_152\"\nBazel version (if compiling from source):\nBuild label: 0.8.1-homebrew\nBuild target: bazel-out/darwin-opt/bin/src/main/java/com/google/devtools/build/lib/bazel/BazelServer_deploy.jar\nBuild time: Tue Dec 5 19:29:04 2017 (1512502144)\nGCC/Compiler version (if compiling from source):\nConfigured with: --prefix=/Applications/Xcode.app/Contents/Developer/usr --with-gxx-include-dir=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/c++/4.2.1\nApple LLVM version 9.0.0 (clang-900.0.39.2)\nTarget: x86_64-apple-darwin17.3.0\nThread model: posix\nInstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin\nCUDA/cuDNN version:\nN/A not using CUDA\nGPU model and memory:\nN/A not using GPU\nExact command to reproduce:\nThere is no bug to reproduce\n\nDescribe the problem\nThere is not really a problem. I have need to build TensorFlow computations in Java and have support for complex numbers. Because the C API already supports COMPLEX64 tensors, it was a straight forward effort to expose them in the Java API. Along with unit tests, I have also added a Java example based on the Python tutorial that builds an image that displays the Mandelbrot fractal to show that the complex number support works correctly.\nSource code / logs\nHere is a very short example of using the API, clearly there are functions in the example that are not available defined in the example, but it gets the point across. This example is basically lifted from a new java example I created called MandelbrotExample.java\nTensor<Complex64> resultZ = null;\ntry(Graph g = new Graph()) {\n    //We create a meshgrid based on two numeric ranges, by wrapping the ranges\n    //in Tensors and then pulling out sub grids to make complex numbers\n    try (Tensor<Float> meshGridT = buildMeshGrid(range1Spec, range2Spec);\n         Tensor<Integer> zeroT = Tensors.create(new int[]{0});\n         Tensor<Integer> oneT = Tensors.create(new int[]{1});\n         Tensor<Complex64> jTensor = Tensors.create(0.0f, 1.0f)) {\n    \n        Output<Integer> zero = buildConstant(g, \"0\", zeroT);\n        Output<Integer> one = buildConstant(g, \"1\", oneT);\n\n        Output<Float> meshGrid = buildConstant(g, \"meshgrid\", meshGridT);\n\n        Output<Complex64> j = buildConstant(g, \"imagUnit\", jTensor);\n\n        //We use GatherNd to pull out the two parts of the original mesh grid\n        //the Z complex tensor\n        Output<Float> Yfloat = g.opBuilder(\"GatherNd\", \"get_y\")\n                .addInput(meshGrid)\n                .addInput(zero) //use zero\n                .build().output(0);\n        Output<Float> Xfloat = g.opBuilder(\"GatherNd\", \"get_x\")\n                .addInput(meshGrid)\n                .addInput(one) //use one\n                .build().output(0);\n\n        Output<Complex64> Y = g.opBuilder(\"Cast\", \"castYtoComplex\")\n                .addInput(Yfloat)\n                .setAttr(\"DstT\", DataType.COMPLEX64)\n                .build().output(0);\n\n        Output<Complex64> X = g.opBuilder(\"Cast\", \"castXtoComplex\")\n                .addInput(Xfloat)\n                .setAttr(\"DstT\", DataType.COMPLEX64)\n                .build().output(0);\n\n        //Z is constructed by X + Yj\n        Output<Complex64> mulYj = g.opBuilder(\"Mul\", \"mulYj\")\n                .addInput(Y)\n                .addInput(j)\n                .build()\n                .output(0);\n        Output<Complex64> Z = g.opBuilder(\"Add\", \"addZ\")\n                .addInput(X)\n                .addInput(mulYj)\n                .build()\n                .output(0);\n\n        try(Session s = new Session(g)){\n            resultZ = s.runner().fetch(Z).run().get(0).expect(Complex64.class);\n        }\n    }\n}\n\nI would like to get my local branched pushed to GitHub and then a pull request put in with these changes. I have attached a diff file for the curious. I am still working on getting a corporate CLA put into place.\nThanks for your time and consideration!\njava-complex64.patch.txt", "body": "This issue is not about a bug, but I will fill in the form anyhow ;-)\r\n### System information\r\n- **Have I written custom code (as opposed to using a stock example script provided in TensorFlow)**:\r\nYes\r\n- **OS Platform and Distribution (e.g., Linux Ubuntu 16.04)**:\r\nMac 10.13.2\r\n- **TensorFlow installed from (source or binary)**:\r\nsource\r\n- **TensorFlow version (use command below)**:\r\nmaster branch at commit: b86dc365ebbef64daceced37026518696ede5b7b\r\n- **Python version**:\r\nN/A Using Java version \"1.8.0_152\"\r\n- **Bazel version (if compiling from source)**:\r\nBuild label: 0.8.1-homebrew\r\nBuild target: bazel-out/darwin-opt/bin/src/main/java/com/google/devtools/build/lib/bazel/BazelServer_deploy.jar\r\nBuild time: Tue Dec 5 19:29:04 2017 (1512502144)\r\n- **GCC/Compiler version (if compiling from source)**:\r\nConfigured with: --prefix=/Applications/Xcode.app/Contents/Developer/usr --with-gxx-include-dir=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.13.sdk/usr/include/c++/4.2.1\r\nApple LLVM version 9.0.0 (clang-900.0.39.2)\r\nTarget: x86_64-apple-darwin17.3.0\r\nThread model: posix\r\nInstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin\r\n- **CUDA/cuDNN version**:\r\nN/A not using CUDA\r\n- **GPU model and memory**:\r\nN/A not using GPU\r\n- **Exact command to reproduce**:\r\nThere is no bug to reproduce\r\n\r\n### Describe the problem\r\nThere is not really a problem. I have need to build TensorFlow computations in Java and have support for complex numbers. Because the C API already supports COMPLEX64 tensors, it was a straight forward effort to expose them in the Java API. Along with unit tests, I have also added a Java example based on the Python tutorial that builds an image that displays the Mandelbrot fractal to show that the complex number support works correctly.\r\n\r\n### Source code / logs\r\nHere is a very short example of using the API, clearly there are functions in the example that are not available defined in the example, but it gets the point across. This example is basically lifted from a new java example I created called MandelbrotExample.java\r\n```\r\nTensor<Complex64> resultZ = null;\r\ntry(Graph g = new Graph()) {\r\n    //We create a meshgrid based on two numeric ranges, by wrapping the ranges\r\n    //in Tensors and then pulling out sub grids to make complex numbers\r\n    try (Tensor<Float> meshGridT = buildMeshGrid(range1Spec, range2Spec);\r\n         Tensor<Integer> zeroT = Tensors.create(new int[]{0});\r\n         Tensor<Integer> oneT = Tensors.create(new int[]{1});\r\n         Tensor<Complex64> jTensor = Tensors.create(0.0f, 1.0f)) {\r\n    \r\n        Output<Integer> zero = buildConstant(g, \"0\", zeroT);\r\n        Output<Integer> one = buildConstant(g, \"1\", oneT);\r\n\r\n        Output<Float> meshGrid = buildConstant(g, \"meshgrid\", meshGridT);\r\n\r\n        Output<Complex64> j = buildConstant(g, \"imagUnit\", jTensor);\r\n\r\n        //We use GatherNd to pull out the two parts of the original mesh grid\r\n        //the Z complex tensor\r\n        Output<Float> Yfloat = g.opBuilder(\"GatherNd\", \"get_y\")\r\n                .addInput(meshGrid)\r\n                .addInput(zero) //use zero\r\n                .build().output(0);\r\n        Output<Float> Xfloat = g.opBuilder(\"GatherNd\", \"get_x\")\r\n                .addInput(meshGrid)\r\n                .addInput(one) //use one\r\n                .build().output(0);\r\n\r\n        Output<Complex64> Y = g.opBuilder(\"Cast\", \"castYtoComplex\")\r\n                .addInput(Yfloat)\r\n                .setAttr(\"DstT\", DataType.COMPLEX64)\r\n                .build().output(0);\r\n\r\n        Output<Complex64> X = g.opBuilder(\"Cast\", \"castXtoComplex\")\r\n                .addInput(Xfloat)\r\n                .setAttr(\"DstT\", DataType.COMPLEX64)\r\n                .build().output(0);\r\n\r\n        //Z is constructed by X + Yj\r\n        Output<Complex64> mulYj = g.opBuilder(\"Mul\", \"mulYj\")\r\n                .addInput(Y)\r\n                .addInput(j)\r\n                .build()\r\n                .output(0);\r\n        Output<Complex64> Z = g.opBuilder(\"Add\", \"addZ\")\r\n                .addInput(X)\r\n                .addInput(mulYj)\r\n                .build()\r\n                .output(0);\r\n\r\n        try(Session s = new Session(g)){\r\n            resultZ = s.runner().fetch(Z).run().get(0).expect(Complex64.class);\r\n        }\r\n    }\r\n}\r\n```\r\nI would like to get my local branched pushed to GitHub and then a pull request put in with these changes. I have attached a diff file for the curious. I am still working on getting a corporate CLA put into place.\r\nThanks for your time and consideration!\r\n[java-complex64.patch.txt](https://github.com/tensorflow/tensorflow/files/1624251/java-complex64.patch.txt)\r\n\r\n"}