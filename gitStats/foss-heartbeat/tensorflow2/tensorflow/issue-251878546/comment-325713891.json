{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/325713891", "html_url": "https://github.com/tensorflow/tensorflow/issues/12482#issuecomment-325713891", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/12482", "id": 325713891, "node_id": "MDEyOklzc3VlQ29tbWVudDMyNTcxMzg5MQ==", "user": {"login": "alc1218", "id": 6891461, "node_id": "MDQ6VXNlcjY4OTE0NjE=", "avatar_url": "https://avatars3.githubusercontent.com/u/6891461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alc1218", "html_url": "https://github.com/alc1218", "followers_url": "https://api.github.com/users/alc1218/followers", "following_url": "https://api.github.com/users/alc1218/following{/other_user}", "gists_url": "https://api.github.com/users/alc1218/gists{/gist_id}", "starred_url": "https://api.github.com/users/alc1218/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alc1218/subscriptions", "organizations_url": "https://api.github.com/users/alc1218/orgs", "repos_url": "https://api.github.com/users/alc1218/repos", "events_url": "https://api.github.com/users/alc1218/events{/privacy}", "received_events_url": "https://api.github.com/users/alc1218/received_events", "type": "User", "site_admin": false}, "created_at": "2017-08-29T16:09:37Z", "updated_at": "2017-08-29T16:11:11Z", "author_association": "NONE", "body_html": "<p>Hi,<br>\nI came up with a solution. Taking into account that I was able to compile everything from source on different machines, I just changed the file mutex.h for the following code:</p>\n<pre><code>/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#ifndef TENSORFLOW_PLATFORM_DEFAULT_MUTEX_H_\n#define TENSORFLOW_PLATFORM_DEFAULT_MUTEX_H_\n\n// IWYU pragma: private, include \"third_party/tensorflow/core/platform/mutex.h\"\n// IWYU pragma: friend third_party/tensorflow/core/platform/mutex.h\n\n#include &lt;chrono&gt;\n#include &lt;condition_variable&gt;\n#include &lt;mutex&gt;\n#include \"tensorflow/core/platform/thread_annotations.h\"\nnamespace tensorflow {\n\n#undef mutex_lock\n\nenum LinkerInitialized { LINKER_INITIALIZED };\n\n// A class that wraps around the std::mutex implementation, only adding an\n// additional LinkerInitialized constructor interface.\nclass LOCKABLE mutex : public std::mutex {\n public:\n  mutex() {}\n  // The default implementation of std::mutex is safe to use after the linker\n  // initializations\n  explicit mutex(LinkerInitialized x) {}\n\n  void lock() ACQUIRE() { std::mutex::lock(); }\n  bool try_lock() EXCLUSIVE_TRYLOCK_FUNCTION(true) {\n    return std::mutex::try_lock();\n  };\n  void unlock() RELEASE() { std::mutex::unlock(); }\n};\n\nclass SCOPED_LOCKABLE mutex_lock : public std::unique_lock&lt;std::mutex&gt; {\n public:\n  mutex_lock(class mutex&amp; m) ACQUIRE(m) : std::unique_lock&lt;std::mutex&gt;(m) {}\n  mutex_lock(class mutex&amp; m, std::try_to_lock_t t) ACQUIRE(m)\n      : std::unique_lock&lt;std::mutex&gt;(m, t) {}\n  mutex_lock(mutex_lock&amp;&amp; ml) noexcept\n      : std::unique_lock&lt;std::mutex&gt;(std::move(ml)) {}\n  ~mutex_lock() RELEASE() {}\n};\n\n// Catch bug where variable name is omitted, e.g. mutex_lock (mu);\n#define mutex_lock(x) static_assert(0, \"mutex_lock_decl_missing_var_name\");\n\nusing std::condition_variable;\n\ninline ConditionResult WaitForMilliseconds(mutex_lock* mu,\n                                           condition_variable* cv, int64 ms) {\n  std::cv_status s = cv-&gt;wait_for(*mu, std::chrono::milliseconds(ms));\n  return (s == std::cv_status::timeout) ? kCond_Timeout : kCond_MaybeNotified;\n}\n\n}  // namespace tensorflow\n\n#endif  // TENSORFLOW_PLATFORM_DEFAULT_MUTEX_H_\n</code></pre>\n<p>Can you edit your post and show specs of machine, tensorflow version &amp; bazel. Thanks (Just to detect where can be the mistake).</p>", "body_text": "Hi,\nI came up with a solution. Taking into account that I was able to compile everything from source on different machines, I just changed the file mutex.h for the following code:\n/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#ifndef TENSORFLOW_PLATFORM_DEFAULT_MUTEX_H_\n#define TENSORFLOW_PLATFORM_DEFAULT_MUTEX_H_\n\n// IWYU pragma: private, include \"third_party/tensorflow/core/platform/mutex.h\"\n// IWYU pragma: friend third_party/tensorflow/core/platform/mutex.h\n\n#include <chrono>\n#include <condition_variable>\n#include <mutex>\n#include \"tensorflow/core/platform/thread_annotations.h\"\nnamespace tensorflow {\n\n#undef mutex_lock\n\nenum LinkerInitialized { LINKER_INITIALIZED };\n\n// A class that wraps around the std::mutex implementation, only adding an\n// additional LinkerInitialized constructor interface.\nclass LOCKABLE mutex : public std::mutex {\n public:\n  mutex() {}\n  // The default implementation of std::mutex is safe to use after the linker\n  // initializations\n  explicit mutex(LinkerInitialized x) {}\n\n  void lock() ACQUIRE() { std::mutex::lock(); }\n  bool try_lock() EXCLUSIVE_TRYLOCK_FUNCTION(true) {\n    return std::mutex::try_lock();\n  };\n  void unlock() RELEASE() { std::mutex::unlock(); }\n};\n\nclass SCOPED_LOCKABLE mutex_lock : public std::unique_lock<std::mutex> {\n public:\n  mutex_lock(class mutex& m) ACQUIRE(m) : std::unique_lock<std::mutex>(m) {}\n  mutex_lock(class mutex& m, std::try_to_lock_t t) ACQUIRE(m)\n      : std::unique_lock<std::mutex>(m, t) {}\n  mutex_lock(mutex_lock&& ml) noexcept\n      : std::unique_lock<std::mutex>(std::move(ml)) {}\n  ~mutex_lock() RELEASE() {}\n};\n\n// Catch bug where variable name is omitted, e.g. mutex_lock (mu);\n#define mutex_lock(x) static_assert(0, \"mutex_lock_decl_missing_var_name\");\n\nusing std::condition_variable;\n\ninline ConditionResult WaitForMilliseconds(mutex_lock* mu,\n                                           condition_variable* cv, int64 ms) {\n  std::cv_status s = cv->wait_for(*mu, std::chrono::milliseconds(ms));\n  return (s == std::cv_status::timeout) ? kCond_Timeout : kCond_MaybeNotified;\n}\n\n}  // namespace tensorflow\n\n#endif  // TENSORFLOW_PLATFORM_DEFAULT_MUTEX_H_\n\nCan you edit your post and show specs of machine, tensorflow version & bazel. Thanks (Just to detect where can be the mistake).", "body": "Hi,\r\nI came up with a solution. Taking into account that I was able to compile everything from source on different machines, I just changed the file mutex.h for the following code:\r\n\r\n```\r\n/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n==============================================================================*/\r\n\r\n#ifndef TENSORFLOW_PLATFORM_DEFAULT_MUTEX_H_\r\n#define TENSORFLOW_PLATFORM_DEFAULT_MUTEX_H_\r\n\r\n// IWYU pragma: private, include \"third_party/tensorflow/core/platform/mutex.h\"\r\n// IWYU pragma: friend third_party/tensorflow/core/platform/mutex.h\r\n\r\n#include <chrono>\r\n#include <condition_variable>\r\n#include <mutex>\r\n#include \"tensorflow/core/platform/thread_annotations.h\"\r\nnamespace tensorflow {\r\n\r\n#undef mutex_lock\r\n\r\nenum LinkerInitialized { LINKER_INITIALIZED };\r\n\r\n// A class that wraps around the std::mutex implementation, only adding an\r\n// additional LinkerInitialized constructor interface.\r\nclass LOCKABLE mutex : public std::mutex {\r\n public:\r\n  mutex() {}\r\n  // The default implementation of std::mutex is safe to use after the linker\r\n  // initializations\r\n  explicit mutex(LinkerInitialized x) {}\r\n\r\n  void lock() ACQUIRE() { std::mutex::lock(); }\r\n  bool try_lock() EXCLUSIVE_TRYLOCK_FUNCTION(true) {\r\n    return std::mutex::try_lock();\r\n  };\r\n  void unlock() RELEASE() { std::mutex::unlock(); }\r\n};\r\n\r\nclass SCOPED_LOCKABLE mutex_lock : public std::unique_lock<std::mutex> {\r\n public:\r\n  mutex_lock(class mutex& m) ACQUIRE(m) : std::unique_lock<std::mutex>(m) {}\r\n  mutex_lock(class mutex& m, std::try_to_lock_t t) ACQUIRE(m)\r\n      : std::unique_lock<std::mutex>(m, t) {}\r\n  mutex_lock(mutex_lock&& ml) noexcept\r\n      : std::unique_lock<std::mutex>(std::move(ml)) {}\r\n  ~mutex_lock() RELEASE() {}\r\n};\r\n\r\n// Catch bug where variable name is omitted, e.g. mutex_lock (mu);\r\n#define mutex_lock(x) static_assert(0, \"mutex_lock_decl_missing_var_name\");\r\n\r\nusing std::condition_variable;\r\n\r\ninline ConditionResult WaitForMilliseconds(mutex_lock* mu,\r\n                                           condition_variable* cv, int64 ms) {\r\n  std::cv_status s = cv->wait_for(*mu, std::chrono::milliseconds(ms));\r\n  return (s == std::cv_status::timeout) ? kCond_Timeout : kCond_MaybeNotified;\r\n}\r\n\r\n}  // namespace tensorflow\r\n\r\n#endif  // TENSORFLOW_PLATFORM_DEFAULT_MUTEX_H_\r\n```\r\n\r\nCan you edit your post and show specs of machine, tensorflow version & bazel. Thanks (Just to detect where can be the mistake)."}