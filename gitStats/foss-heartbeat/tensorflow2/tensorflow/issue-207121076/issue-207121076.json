{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/7456", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/7456/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/7456/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/7456/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/7456", "id": 207121076, "node_id": "MDU6SXNzdWUyMDcxMjEwNzY=", "number": 7456, "title": "Training using multiple GPUs returns Inf values for loss and Nan for grads. ", "user": {"login": "YiMX", "id": 24216379, "node_id": "MDQ6VXNlcjI0MjE2Mzc5", "avatar_url": "https://avatars0.githubusercontent.com/u/24216379?v=4", "gravatar_id": "", "url": "https://api.github.com/users/YiMX", "html_url": "https://github.com/YiMX", "followers_url": "https://api.github.com/users/YiMX/followers", "following_url": "https://api.github.com/users/YiMX/following{/other_user}", "gists_url": "https://api.github.com/users/YiMX/gists{/gist_id}", "starred_url": "https://api.github.com/users/YiMX/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/YiMX/subscriptions", "organizations_url": "https://api.github.com/users/YiMX/orgs", "repos_url": "https://api.github.com/users/YiMX/repos", "events_url": "https://api.github.com/users/YiMX/events{/privacy}", "received_events_url": "https://api.github.com/users/YiMX/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 473172988, "node_id": "MDU6TGFiZWw0NzMxNzI5ODg=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:bug/performance", "name": "type:bug/performance", "color": "159b2e", "default": false}, {"id": 473184161, "node_id": "MDU6TGFiZWw0NzMxODQxNjE=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:support", "name": "type:support", "color": "159b2e", "default": false}], "state": "closed", "locked": false, "assignee": {"login": "poxvoculi", "id": 15676913, "node_id": "MDQ6VXNlcjE1Njc2OTEz", "avatar_url": "https://avatars2.githubusercontent.com/u/15676913?v=4", "gravatar_id": "", "url": "https://api.github.com/users/poxvoculi", "html_url": "https://github.com/poxvoculi", "followers_url": "https://api.github.com/users/poxvoculi/followers", "following_url": "https://api.github.com/users/poxvoculi/following{/other_user}", "gists_url": "https://api.github.com/users/poxvoculi/gists{/gist_id}", "starred_url": "https://api.github.com/users/poxvoculi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/poxvoculi/subscriptions", "organizations_url": "https://api.github.com/users/poxvoculi/orgs", "repos_url": "https://api.github.com/users/poxvoculi/repos", "events_url": "https://api.github.com/users/poxvoculi/events{/privacy}", "received_events_url": "https://api.github.com/users/poxvoculi/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "poxvoculi", "id": 15676913, "node_id": "MDQ6VXNlcjE1Njc2OTEz", "avatar_url": "https://avatars2.githubusercontent.com/u/15676913?v=4", "gravatar_id": "", "url": "https://api.github.com/users/poxvoculi", "html_url": "https://github.com/poxvoculi", "followers_url": "https://api.github.com/users/poxvoculi/followers", "following_url": "https://api.github.com/users/poxvoculi/following{/other_user}", "gists_url": "https://api.github.com/users/poxvoculi/gists{/gist_id}", "starred_url": "https://api.github.com/users/poxvoculi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/poxvoculi/subscriptions", "organizations_url": "https://api.github.com/users/poxvoculi/orgs", "repos_url": "https://api.github.com/users/poxvoculi/repos", "events_url": "https://api.github.com/users/poxvoculi/events{/privacy}", "received_events_url": "https://api.github.com/users/poxvoculi/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 26, "created_at": "2017-02-13T04:43:54Z", "updated_at": "2018-11-21T05:09:03Z", "closed_at": "2017-05-08T17:43:22Z", "author_association": "NONE", "body_html": "<p>I have two Tesla K80 cards (2 GPUs per card) and I spent few days testing a MNIST classification model using multiple GPUs. What I found is that the training process would always diverge (got Nan for grads and Inf for loss) when I use two GPUs which are in the same card, however when I allocated two GPUs to my training operation from different cards, it would lead to convergence. By the way, everything worked well on a single GPU.</p>\n<p>I am not sure about how GPUs compute those networks and it is really weird two GPUs from the same card make my model diverge and from different cards can make it converge.</p>\n<p>The output for divergence is like the below:</p>\n<div class=\"highlight highlight-text-roff\"><pre>2017-02-13 12:30:11.255323: step 10, loss = 5799703749333771039308345507840.00 (980.7 examples/sec; 0.102 sec/batch)\n2017-02-13 12:30:14.131089: step 20, loss = 2102245862526597403246592.00 (793.5 examples/sec; 0.126 sec/batch)\n2017-02-13 12:30:16.995940: step 30, loss = 2.30 (787.6 examples/sec; 0.127 sec/batch)\nW tensorflow/core/framework/op_kernel.cc:975] Invalid argument: Nan in summary histogram for: layer2/weights_1\n\t [[Node: layer2/weights_1 = HistogramSummary[T=DT_FLOAT, _device=\"/job:localhost/replica:0/task:0/cpu:0\"](layer2/weights_1/tag, layer2/weights/read/_117)]]</pre></div>\n<p>I used cpu to preprocess the input data read from tfreords. My code for computing the average grads:</p>\n<div class=\"highlight highlight-text-roff\"><pre>def average_gradients(tower_grads):\n    average_grads = []\n    for grad_and_vars in zip(*tower_grads):\n        grads = []\n        for g, _ in grad_and_vars:\n            expanded_g = tf.expand_dims(g, 0)\n            grads.append(expanded_g)\n        grad = tf.concat(0, grads)\n        grad = tf.reduce_mean(grad, 0)\n        v = grad_and_vars[0][1]\n        grad_and_var = (grad, v)\n        average_grads.append(grad_and_var)\n    return average_grads </pre></div>\n<p>The training_op:</p>\n<div class=\"highlight highlight-text-roff\"><pre>def main(argv=None): \n    with tf.Graph().as_default(), tf.device('/cpu:0'):\n        x, y_ = get_input()\n        regularizer = tf.contrib.layers.l2_regularizer(REGULARAZTION_RATE)\n        \n        global_step = tf.get_variable('global_step', [], initializer=tf.constant_initializer(0), trainable=False)\n        learning_rate = tf.train.exponential_decay(\n            LEARNING_RATE_BASE, global_step, 60000 / BATCH_SIZE, LEARNING_RATE_DECAY)       \n        \n        opt = tf.train.GradientDescentOptimizer(learning_rate)\n        \n        tower_grads = []\n        for i in range(N_GPU):\n            with tf.device('/gpu:%d' % i):\n                with tf.name_scope('GPU_%d' % i) as scope:\n                    cur_loss = get_loss(x, y_, regularizer, scope)\n                    tf.get_variable_scope().reuse_variables()\n                    grads = opt.compute_gradients(cur_loss)\n                    tower_grads.append(grads)\n        \n        grads = average_gradients(tower_grads)\n        for grad, var in grads:\n            if grad is not None:\n            \ttf.summary.histogram('gradients_on_average/%s' % var.op.name, grad)\n\n        apply_gradient_op = opt.apply_gradients(grads, global_step=global_step)\n        for var in tf.trainable_variables():\n            tf.summary.histogram(var.op.name, var)\n\n        variable_averages = tf.train.ExponentialMovingAverage(MOVING_AVERAGE_DECAY, global_step)\n        variables_averages_op = variable_averages.apply(tf.trainable_variables())\n        train_op = tf.group(apply_gradient_op, variables_averages_op)</pre></div>", "body_text": "I have two Tesla K80 cards (2 GPUs per card) and I spent few days testing a MNIST classification model using multiple GPUs. What I found is that the training process would always diverge (got Nan for grads and Inf for loss) when I use two GPUs which are in the same card, however when I allocated two GPUs to my training operation from different cards, it would lead to convergence. By the way, everything worked well on a single GPU.\nI am not sure about how GPUs compute those networks and it is really weird two GPUs from the same card make my model diverge and from different cards can make it converge.\nThe output for divergence is like the below:\n2017-02-13 12:30:11.255323: step 10, loss = 5799703749333771039308345507840.00 (980.7 examples/sec; 0.102 sec/batch)\n2017-02-13 12:30:14.131089: step 20, loss = 2102245862526597403246592.00 (793.5 examples/sec; 0.126 sec/batch)\n2017-02-13 12:30:16.995940: step 30, loss = 2.30 (787.6 examples/sec; 0.127 sec/batch)\nW tensorflow/core/framework/op_kernel.cc:975] Invalid argument: Nan in summary histogram for: layer2/weights_1\n\t [[Node: layer2/weights_1 = HistogramSummary[T=DT_FLOAT, _device=\"/job:localhost/replica:0/task:0/cpu:0\"](layer2/weights_1/tag, layer2/weights/read/_117)]]\nI used cpu to preprocess the input data read from tfreords. My code for computing the average grads:\ndef average_gradients(tower_grads):\n    average_grads = []\n    for grad_and_vars in zip(*tower_grads):\n        grads = []\n        for g, _ in grad_and_vars:\n            expanded_g = tf.expand_dims(g, 0)\n            grads.append(expanded_g)\n        grad = tf.concat(0, grads)\n        grad = tf.reduce_mean(grad, 0)\n        v = grad_and_vars[0][1]\n        grad_and_var = (grad, v)\n        average_grads.append(grad_and_var)\n    return average_grads \nThe training_op:\ndef main(argv=None): \n    with tf.Graph().as_default(), tf.device('/cpu:0'):\n        x, y_ = get_input()\n        regularizer = tf.contrib.layers.l2_regularizer(REGULARAZTION_RATE)\n        \n        global_step = tf.get_variable('global_step', [], initializer=tf.constant_initializer(0), trainable=False)\n        learning_rate = tf.train.exponential_decay(\n            LEARNING_RATE_BASE, global_step, 60000 / BATCH_SIZE, LEARNING_RATE_DECAY)       \n        \n        opt = tf.train.GradientDescentOptimizer(learning_rate)\n        \n        tower_grads = []\n        for i in range(N_GPU):\n            with tf.device('/gpu:%d' % i):\n                with tf.name_scope('GPU_%d' % i) as scope:\n                    cur_loss = get_loss(x, y_, regularizer, scope)\n                    tf.get_variable_scope().reuse_variables()\n                    grads = opt.compute_gradients(cur_loss)\n                    tower_grads.append(grads)\n        \n        grads = average_gradients(tower_grads)\n        for grad, var in grads:\n            if grad is not None:\n            \ttf.summary.histogram('gradients_on_average/%s' % var.op.name, grad)\n\n        apply_gradient_op = opt.apply_gradients(grads, global_step=global_step)\n        for var in tf.trainable_variables():\n            tf.summary.histogram(var.op.name, var)\n\n        variable_averages = tf.train.ExponentialMovingAverage(MOVING_AVERAGE_DECAY, global_step)\n        variables_averages_op = variable_averages.apply(tf.trainable_variables())\n        train_op = tf.group(apply_gradient_op, variables_averages_op)", "body": "I have two Tesla K80 cards (2 GPUs per card) and I spent few days testing a MNIST classification model using multiple GPUs. What I found is that the training process would always diverge (got Nan for grads and Inf for loss) when I use two GPUs which are in the same card, however when I allocated two GPUs to my training operation from different cards, it would lead to convergence. By the way, everything worked well on a single GPU. \r\n\r\nI am not sure about how GPUs compute those networks and it is really weird two GPUs from the same card make my model diverge and from different cards can make it converge.\r\n\r\nThe output for divergence is like the below:\r\n```man\r\n2017-02-13 12:30:11.255323: step 10, loss = 5799703749333771039308345507840.00 (980.7 examples/sec; 0.102 sec/batch)\r\n2017-02-13 12:30:14.131089: step 20, loss = 2102245862526597403246592.00 (793.5 examples/sec; 0.126 sec/batch)\r\n2017-02-13 12:30:16.995940: step 30, loss = 2.30 (787.6 examples/sec; 0.127 sec/batch)\r\nW tensorflow/core/framework/op_kernel.cc:975] Invalid argument: Nan in summary histogram for: layer2/weights_1\r\n\t [[Node: layer2/weights_1 = HistogramSummary[T=DT_FLOAT, _device=\"/job:localhost/replica:0/task:0/cpu:0\"](layer2/weights_1/tag, layer2/weights/read/_117)]]\r\n```\r\nI used cpu to preprocess the input data read from tfreords. My code for computing the average grads:\r\n```man\r\ndef average_gradients(tower_grads):\r\n    average_grads = []\r\n    for grad_and_vars in zip(*tower_grads):\r\n        grads = []\r\n        for g, _ in grad_and_vars:\r\n            expanded_g = tf.expand_dims(g, 0)\r\n            grads.append(expanded_g)\r\n        grad = tf.concat(0, grads)\r\n        grad = tf.reduce_mean(grad, 0)\r\n        v = grad_and_vars[0][1]\r\n        grad_and_var = (grad, v)\r\n        average_grads.append(grad_and_var)\r\n    return average_grads \r\n```\r\n\r\nThe training_op:\r\n```man\r\ndef main(argv=None): \r\n    with tf.Graph().as_default(), tf.device('/cpu:0'):\r\n        x, y_ = get_input()\r\n        regularizer = tf.contrib.layers.l2_regularizer(REGULARAZTION_RATE)\r\n        \r\n        global_step = tf.get_variable('global_step', [], initializer=tf.constant_initializer(0), trainable=False)\r\n        learning_rate = tf.train.exponential_decay(\r\n            LEARNING_RATE_BASE, global_step, 60000 / BATCH_SIZE, LEARNING_RATE_DECAY)       \r\n        \r\n        opt = tf.train.GradientDescentOptimizer(learning_rate)\r\n        \r\n        tower_grads = []\r\n        for i in range(N_GPU):\r\n            with tf.device('/gpu:%d' % i):\r\n                with tf.name_scope('GPU_%d' % i) as scope:\r\n                    cur_loss = get_loss(x, y_, regularizer, scope)\r\n                    tf.get_variable_scope().reuse_variables()\r\n                    grads = opt.compute_gradients(cur_loss)\r\n                    tower_grads.append(grads)\r\n        \r\n        grads = average_gradients(tower_grads)\r\n        for grad, var in grads:\r\n            if grad is not None:\r\n            \ttf.summary.histogram('gradients_on_average/%s' % var.op.name, grad)\r\n\r\n        apply_gradient_op = opt.apply_gradients(grads, global_step=global_step)\r\n        for var in tf.trainable_variables():\r\n            tf.summary.histogram(var.op.name, var)\r\n\r\n        variable_averages = tf.train.ExponentialMovingAverage(MOVING_AVERAGE_DECAY, global_step)\r\n        variables_averages_op = variable_averages.apply(tf.trainable_variables())\r\n        train_op = tf.group(apply_gradient_op, variables_averages_op)\r\n```\r\n"}