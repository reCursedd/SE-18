{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/170717134", "pull_request_review_id": 99428924, "id": 170717134, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE3MDcxNzEzNA==", "diff_hunk": "@@ -75,18 +52,131 @@ class SourceWriter {\n   // Indent(2)->Prefix(\"//\") will result in prefixing lines with \"  //\".\n   //\n   // An empty value (\"\") will remove any line prefix that was previously set.\n-  SourceWriter& Prefix(const char* line_prefix) {\n-    line_prefix_ = line_prefix;\n-    return *this;\n+  SourceWriter& Prefix(const char* line_prefix);\n+\n+  // Writes a block of code or text.\n+  //\n+  // The data might potentially contain newline characters, therefore it will\n+  // be scanned to ensure that each line is indented and prefixed properly,\n+  // making it a bit slower than Append().\n+  SourceWriter& Write(const string& text);\n+\n+  // Appends a piece of code or text.\n+  //\n+  // It is expected that no newline character is present in the data provided,\n+  // otherwise Write() must be used.\n+  SourceWriter& Append(const StringPiece& str);\n+\n+  // Appends the signature of a type to the current line.\n+  //\n+  // The type is written in its simple form (i.e. not prefixed by its package)\n+  // and followed by any parameter types it has enclosed in brackets (<>).\n+  SourceWriter& Append(const Type& type);\n+\n+  // Appends a newline character.\n+  //\n+  // Data written after calling this method will start on a new line, in respect\n+  // of the current indentation.\n+  SourceWriter& EndLine();\n+\n+  // Begins a block of code.\n+  //\n+  // This method appends a new opening brace to the current data and indent the\n+  // next lines according to Google Java Style Guide. The block can optionally\n+  // be preceded by an expression (e.g. Append(\"if(true)\").BeginBlock();)\n+  SourceWriter& BeginBlock() {\n+    return Append(newline_ ? \"{\" : \" {\").EndLine().Indent(2);\n   }\n \n+  // Ends the current block of code\n+  //\n+  // This method appends a new closing brace to the current data and outdent the\n+  // next lines back to the margin used before BeginBlock() was invoked.\n+  SourceWriter& EndBlock() {\n+    return Indent(-2).Append(\"}\").EndLine();\n+  }\n+\n+  // Begins to write a method.\n+  //\n+  // This method outputs the signature of the Java method from the data passed\n+  // in the 'method' parameter and starts a new block. Additionnal modifiers can\n+  // also be passed in parameter to define the accesses and the scope of this\n+  // method.\n+  SourceWriter& BeginMethod(const Method& method, int modifiers = 0);\n+\n+  // Ends the current method.\n+  //\n+  // This method ends the block of code that has begun when invoking\n+  // BeginMethod() prior to this.\n+  SourceWriter& EndMethod();\n+\n+  // Begins to write the main type of a source file.\n+  //\n+  // This method outputs the declaration of the Java type from the data passed\n+  // in the 'type' parameter and starts a new block. Additionnal modifiers can\n+  // also be passed in parameter to define the accesses and the scope of this\n+  // type.\n+  //\n+  // If not null, all types found in the 'dependencies' list will be imported\n+  // before declaring the new type.\n+  SourceWriter& BeginType(const Type& clazz,\n+      const std::vector<Type>* dependencies, int modifiers = 0);\n+\n+  // Begins to write a new inner type.\n+  //\n+  // This method outputs the declaration of the Java type from the data passed\n+  // in the 'type' parameter and starts a new block. Additionnal modifiers can\n+  // also be passed in parameter to define the accesses and the scope of this\n+  // type.\n+  SourceWriter& BeginInnerType(const Type& type, int modifiers = 0);\n+\n+  // Ends the current type.\n+  //\n+  // This method ends the block of code that has begun when invoking\n+  // BeginType() or BeginInnerType() prior to this.\n+  SourceWriter& EndType();\n+\n+  // Writes a list of variables as fields of a type.\n+  //\n+  // This method must be called within the definition of a type (see BeginType()\n+  // or BeginInnerType()). Additional modifiers can also be passed in parameter\n+  // to define the accesses and the scope of those fields.\n+  SourceWriter& WriteFields(const std::vector<Variable>& fields,\n+      int modifiers = 0);\n+\n  protected:\n   virtual void DoAppend(const StringPiece& str) = 0;\n \n  private:\n+  class GenericNamespace {\n+   public:\n+    GenericNamespace() = default;\n+    explicit GenericNamespace(const GenericNamespace* parent)\n+      : generic_names_(parent->generic_names_) {}\n+\n+    std::vector<const Type*> declared_types() {\n+      return declared_types_;\n+    }\n+    void operator()(const Type& type);  // type visitor\n+\n+   private:\n+    std::vector<const Type*> declared_types_;\n+    std::set<string> generic_names_;\n+  };\n+\n   string left_margin_;\n   string line_prefix_;\n   bool newline_ = true;\n+  std::stack<GenericNamespace*> generic_namespaces_;", "path": "tensorflow/java/src/gen/cc/source_writer.h", "position": 210, "original_position": 175, "commit_id": "b780d74444e89375e49e45b184f182db354fdc72", "original_commit_id": "d63dd2e128c7baa3627ae78c4f8f2b4ed3c6428b", "user": {"login": "asimshankar", "id": 16018, "node_id": "MDQ6VXNlcjE2MDE4", "avatar_url": "https://avatars2.githubusercontent.com/u/16018?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asimshankar", "html_url": "https://github.com/asimshankar", "followers_url": "https://api.github.com/users/asimshankar/followers", "following_url": "https://api.github.com/users/asimshankar/following{/other_user}", "gists_url": "https://api.github.com/users/asimshankar/gists{/gist_id}", "starred_url": "https://api.github.com/users/asimshankar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asimshankar/subscriptions", "organizations_url": "https://api.github.com/users/asimshankar/orgs", "repos_url": "https://api.github.com/users/asimshankar/repos", "events_url": "https://api.github.com/users/asimshankar/events{/privacy}", "received_events_url": "https://api.github.com/users/asimshankar/received_events", "type": "User", "site_admin": false}, "body": "I didn't quite follow why we need to maintain a stack of generic namespaces. I may have missed something, but it seems that the `GenericNamespace` object is never used beyond the function that pushes it on to the stack, so why bother with a stack?", "created_at": "2018-02-26T19:59:44Z", "updated_at": "2018-03-27T03:00:59Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/16120#discussion_r170717134", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/16120", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/170717134"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/16120#discussion_r170717134"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/16120"}}, "body_html": "<p>I didn't quite follow why we need to maintain a stack of generic namespaces. I may have missed something, but it seems that the <code>GenericNamespace</code> object is never used beyond the function that pushes it on to the stack, so why bother with a stack?</p>", "body_text": "I didn't quite follow why we need to maintain a stack of generic namespaces. I may have missed something, but it seems that the GenericNamespace object is never used beyond the function that pushes it on to the stack, so why bother with a stack?"}