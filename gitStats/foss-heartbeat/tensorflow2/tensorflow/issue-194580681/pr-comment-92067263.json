{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/92067263", "pull_request_review_id": 12576919, "id": 92067263, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDkyMDY3MjYz", "diff_hunk": "@@ -416,24 +416,38 @@ REGISTER_OP(\"SplitV\")\n     .Attr(\"T: type\")\n     .Attr(\"Tlen: {int32, int64} = DT_INT64\")\n     .SetShapeFn([](InferenceContext* c) {\n-      ShapeHandle unused;\n+      DimensionHandle split_dimension;\n+      TF_RETURN_IF_ERROR(c->MakeDimForScalarInput(2, &split_dimension));\n       int32 num_outputs = c->num_outputs();\n-      // Return unknown shapes with the same rank as the input\n-      // or unknown rank if input's rank isn't known\n-      // can't determine exact shapes until runtime because\n-      // we don't know where the tensor containing the split sizes\n-      // is located\n-      int32 rank = c->Rank(c->input(0));\n+      // Return unknown shapes if input's rank, split dimension or tensor\n+      // containing the split sizes aren't known. If we know the tensor\n+      // containing size splits, then determine the output shape.\n+      ShapeHandle input = c->input(0);\n+      int32 rank = c->Rank(input);\n       ShapeHandle output_shape;\n+      const Tensor* size_splits = c->input_tensor(1);\n       if (rank == InferenceContext::kUnknownRank) {\n         output_shape = c->UnknownShape();\n+        for (int i = 0; i < num_outputs; ++i) {\n+          c->set_output(i, output_shape);\n+        }\n       } else if (rank == 0) {\n         return errors::InvalidArgument(\"Can't split scalars\");\n-      } else {\n+      } else if (size_splits == nullptr || !c->ValueKnown(split_dimension)) {\n         output_shape = c->UnknownShapeOfRank(rank);\n-      }\n-      for (int i = 0; i < num_outputs; ++i) {\n-        c->set_output(i, output_shape);\n+        for (int i =0; i < num_outputs; ++i) {\n+          c->set_output(i, output_shape);\n+        }\n+      } else {\n+        int64 split_dim = c->Value(split_dimension);\n+        TF_RETURN_IF_ERROR(c->WithRankAtLeast(input, split_dim + 1, &input));\n+        auto vec = size_splits->vec<int32>();\n+        for (int i = 0; i < num_outputs; ++i) {", "path": "tensorflow/core/ops/array_ops.cc", "position": null, "original_position": 41, "commit_id": "622496ad3f13ded86c5bff2e3842b53f78019f4b", "original_commit_id": "ca55236a2d5650d78bd814682979edecc0d6f683", "user": {"login": "ekelsen", "id": 2533174, "node_id": "MDQ6VXNlcjI1MzMxNzQ=", "avatar_url": "https://avatars0.githubusercontent.com/u/2533174?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ekelsen", "html_url": "https://github.com/ekelsen", "followers_url": "https://api.github.com/users/ekelsen/followers", "following_url": "https://api.github.com/users/ekelsen/following{/other_user}", "gists_url": "https://api.github.com/users/ekelsen/gists{/gist_id}", "starred_url": "https://api.github.com/users/ekelsen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ekelsen/subscriptions", "organizations_url": "https://api.github.com/users/ekelsen/orgs", "repos_url": "https://api.github.com/users/ekelsen/repos", "events_url": "https://api.github.com/users/ekelsen/events{/privacy}", "received_events_url": "https://api.github.com/users/ekelsen/received_events", "type": "User", "site_admin": false}, "body": "should check that the size of vec is indeed the number of outputs.", "created_at": "2016-12-12T23:39:47Z", "updated_at": "2016-12-15T08:44:43Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/6212#discussion_r92067263", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/6212", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/92067263"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/6212#discussion_r92067263"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/6212"}}, "body_html": "<p>should check that the size of vec is indeed the number of outputs.</p>", "body_text": "should check that the size of vec is indeed the number of outputs."}