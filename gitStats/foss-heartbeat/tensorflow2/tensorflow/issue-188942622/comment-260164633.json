{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/260164633", "html_url": "https://github.com/tensorflow/tensorflow/issues/5568#issuecomment-260164633", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5568", "id": 260164633, "node_id": "MDEyOklzc3VlQ29tbWVudDI2MDE2NDYzMw==", "user": {"login": "b0noI", "id": 554101, "node_id": "MDQ6VXNlcjU1NDEwMQ==", "avatar_url": "https://avatars2.githubusercontent.com/u/554101?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b0noI", "html_url": "https://github.com/b0noI", "followers_url": "https://api.github.com/users/b0noI/followers", "following_url": "https://api.github.com/users/b0noI/following{/other_user}", "gists_url": "https://api.github.com/users/b0noI/gists{/gist_id}", "starred_url": "https://api.github.com/users/b0noI/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b0noI/subscriptions", "organizations_url": "https://api.github.com/users/b0noI/orgs", "repos_url": "https://api.github.com/users/b0noI/repos", "events_url": "https://api.github.com/users/b0noI/events{/privacy}", "received_events_url": "https://api.github.com/users/b0noI/received_events", "type": "User", "site_admin": false}, "created_at": "2016-11-13T03:28:16Z", "updated_at": "2016-11-13T03:28:16Z", "author_association": "CONTRIBUTOR", "body_html": "<p>turns out that the root cause of the issue is in the way how quantized Tensors are represented. It is expected that they always will have a tuple as the representation for each of an element. On practice this leads to the inconsistent API like the next one:</p>\n<pre><code>m = tf.constant(3, dtype=tf.int8) # Evaluates correctly since the type of the tensor is not quantized.\nm = tf.constant(3, dtype=tf.qint8) # Throws TypeError since the tensor is a quantized tensor, but the element in the tensor is not tuple.\nm = tf.constant((3,), dtype=tf.qint8) # Evaluates correctly since element in the tensor is a tuple.\n</code></pre>\n<p>Current representation of the type of elements of a quantized Tensor described by following DTypes:</p>\n<pre><code>_np_qint8 = np.dtype([(\"qint8\", np.int8, 1)])\n_np_quint8 = np.dtype([(\"quint8\", np.uint8, 1)])\n_np_qint16 = np.dtype([(\"qint16\", np.int16, 1)])\n_np_quint16 = np.dtype([(\"quint16\", np.uint16, 1)])\n_np_qint32 = np.dtype([(\"qint32\", np.int32, 1)])\n</code></pre>\n<p>One of the possible solutions would be to refactor the sanity checks for the input arguments. Current sanity check assumes that quantized Tensor has same sanity checks as non-quantized Tensor:</p>\n<pre><code> dtypes.qint16: _FilterInt,\n dtypes.qint32: _FilterInt,\n dtypes.qint8: _FilterInt,\n dtypes.quint16: _FilterInt,\n</code></pre>\n<p>PS: Still working on PR to show the proposal of new sanity checks.</p>", "body_text": "turns out that the root cause of the issue is in the way how quantized Tensors are represented. It is expected that they always will have a tuple as the representation for each of an element. On practice this leads to the inconsistent API like the next one:\nm = tf.constant(3, dtype=tf.int8) # Evaluates correctly since the type of the tensor is not quantized.\nm = tf.constant(3, dtype=tf.qint8) # Throws TypeError since the tensor is a quantized tensor, but the element in the tensor is not tuple.\nm = tf.constant((3,), dtype=tf.qint8) # Evaluates correctly since element in the tensor is a tuple.\n\nCurrent representation of the type of elements of a quantized Tensor described by following DTypes:\n_np_qint8 = np.dtype([(\"qint8\", np.int8, 1)])\n_np_quint8 = np.dtype([(\"quint8\", np.uint8, 1)])\n_np_qint16 = np.dtype([(\"qint16\", np.int16, 1)])\n_np_quint16 = np.dtype([(\"quint16\", np.uint16, 1)])\n_np_qint32 = np.dtype([(\"qint32\", np.int32, 1)])\n\nOne of the possible solutions would be to refactor the sanity checks for the input arguments. Current sanity check assumes that quantized Tensor has same sanity checks as non-quantized Tensor:\n dtypes.qint16: _FilterInt,\n dtypes.qint32: _FilterInt,\n dtypes.qint8: _FilterInt,\n dtypes.quint16: _FilterInt,\n\nPS: Still working on PR to show the proposal of new sanity checks.", "body": "turns out that the root cause of the issue is in the way how quantized Tensors are represented. It is expected that they always will have a tuple as the representation for each of an element. On practice this leads to the inconsistent API like the next one:\n\n```\nm = tf.constant(3, dtype=tf.int8) # Evaluates correctly since the type of the tensor is not quantized.\nm = tf.constant(3, dtype=tf.qint8) # Throws TypeError since the tensor is a quantized tensor, but the element in the tensor is not tuple.\nm = tf.constant((3,), dtype=tf.qint8) # Evaluates correctly since element in the tensor is a tuple.\n```\n\nCurrent representation of the type of elements of a quantized Tensor described by following DTypes:\n\n```\n_np_qint8 = np.dtype([(\"qint8\", np.int8, 1)])\n_np_quint8 = np.dtype([(\"quint8\", np.uint8, 1)])\n_np_qint16 = np.dtype([(\"qint16\", np.int16, 1)])\n_np_quint16 = np.dtype([(\"quint16\", np.uint16, 1)])\n_np_qint32 = np.dtype([(\"qint32\", np.int32, 1)])\n```\n\nOne of the possible solutions would be to refactor the sanity checks for the input arguments. Current sanity check assumes that quantized Tensor has same sanity checks as non-quantized Tensor:\n\n```\n dtypes.qint16: _FilterInt,\n dtypes.qint32: _FilterInt,\n dtypes.qint8: _FilterInt,\n dtypes.quint16: _FilterInt,\n```\n\nPS: Still working on PR to show the proposal of new sanity checks.\n"}