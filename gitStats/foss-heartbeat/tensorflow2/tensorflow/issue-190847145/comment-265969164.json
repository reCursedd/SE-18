{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/265969164", "html_url": "https://github.com/tensorflow/tensorflow/issues/5763#issuecomment-265969164", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/5763", "id": 265969164, "node_id": "MDEyOklzc3VlQ29tbWVudDI2NTk2OTE2NA==", "user": {"login": "llhe", "id": 192829, "node_id": "MDQ6VXNlcjE5MjgyOQ==", "avatar_url": "https://avatars2.githubusercontent.com/u/192829?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llhe", "html_url": "https://github.com/llhe", "followers_url": "https://api.github.com/users/llhe/followers", "following_url": "https://api.github.com/users/llhe/following{/other_user}", "gists_url": "https://api.github.com/users/llhe/gists{/gist_id}", "starred_url": "https://api.github.com/users/llhe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llhe/subscriptions", "organizations_url": "https://api.github.com/users/llhe/orgs", "repos_url": "https://api.github.com/users/llhe/repos", "events_url": "https://api.github.com/users/llhe/events{/privacy}", "received_events_url": "https://api.github.com/users/llhe/received_events", "type": "User", "site_admin": false}, "created_at": "2016-12-09T09:21:29Z", "updated_at": "2016-12-09T09:21:29Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Here is what I found in the source, the interface looks clear:</p>\n<div class=\"highlight highlight-source-c++\"><pre><span class=\"pl-en\">REGISTER_OP</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>ConcatOffset<span class=\"pl-pds\">\"</span></span>)                                                     \n    .Input(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>concat_dim: int32<span class=\"pl-pds\">\"</span></span>)                                                 \n    .Input(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>shape: N * int32<span class=\"pl-pds\">\"</span></span>)                                                  \n    .Output(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>offset: N * int32<span class=\"pl-pds\">\"</span></span>)                                                \n    .Attr(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>N: int &gt;= 2<span class=\"pl-pds\">\"</span></span>)                                                        \n    .SetShapeFn([](InferenceContext* c) {                                       \n      <span class=\"pl-k\">for</span> (<span class=\"pl-k\">int</span> i = <span class=\"pl-c1\">1</span>; i &lt; c-&gt;<span class=\"pl-c1\">num_inputs</span>(); ++i) {                               \n        c-&gt;<span class=\"pl-c1\">set_output</span>(i - <span class=\"pl-c1\">1</span>, c-&gt;<span class=\"pl-c1\">input</span>(i));                                      \n      }                                                                         \n      <span class=\"pl-k\">return</span> <span class=\"pl-c1\">Status::OK</span>();                                                      \n    })                                                                          \n    .Doc(<span class=\"pl-s\"><span class=\"pl-pds\">R\"doc(</span>                                                                 </span>\n<span class=\"pl-s\">Computes offsets of concat inputs within its output.                            </span>\n<span class=\"pl-s\">                                                                                </span>\n<span class=\"pl-s\">For example:                                                                    </span>\n<span class=\"pl-s\">                                                                                </span>\n<span class=\"pl-s\">prettyprint                                                                  </span>\n<span class=\"pl-s\"># 'x' is [2, 2, 7]                                                              </span>\n<span class=\"pl-s\"># 'y' is [2, 3, 7]                                                              </span>\n<span class=\"pl-s\"># 'z' is [2, 5, 7]                                                              </span>\n<span class=\"pl-s\">concat_offset(2, [x, y, z]) =&gt; [0, 0, 0], [0, 2, 0], [0, 5, 0]                  </span>\n<span class=\"pl-s\">                                                                           </span>\n<span class=\"pl-s\">                                                                                </span>\n<span class=\"pl-s\">concat_dim: The dimension along which to concatenate.                           </span>\n<span class=\"pl-s\">shape: The `N` int32 vectors representing shape of tensors being concatenated.  </span>\n<span class=\"pl-s\">offset: The `N` int32 vectors representing the starting offset                  </span>\n<span class=\"pl-s\">        of input tensors within the concatenated output.                        </span>\n<span class=\"pl-s\">                                                                                </span>\n<span class=\"pl-s\">This is typically used by gradient computations for a concat operation.         </span>\n<span class=\"pl-s\"><span class=\"pl-pds\">)doc\"</span></span>);</pre></div>\n<div class=\"highlight highlight-source-c++\"><pre>    <span class=\"pl-c\"><span class=\"pl-c\">//</span> Suppose a Concat() op needs to Concatenate N tensors, each of            </span>\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span> which has the same number of dimensions.  Their shapes match             </span>\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span> except the concat dimension.                                             </span>\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span>                                                                          </span>\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span> E.g., say, we want to concatenate 3 tensors in the 2nd                   </span>\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span> dimension, and their shapes are:                                         </span>\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span>                                                                          </span>\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span>  [2, 2, 5, 7]                                                            </span>\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span>  [2, 3, 5, 7]                                                            </span>\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span>  [2, 4, 5, 7]                                                            </span>\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span>                                                                          </span>\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span> Here, N=3, cdim=1, dims=4. The concatenated tensor has shape             </span>\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span> [2,9,5,7]. We will compute the cumulative sum along the 2nd              </span>\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span> dimension to figure out each input's offset in the concatenated          </span>\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span> output:                                                                  </span>\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span>  [0, 0, 0, 0]                                                            </span>\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span>  [0, 2, 0, 0]                                                            </span>\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span>  [0, 5, 0, 0]</span></pre></div>\n<p>Hope this helps.</p>", "body_text": "Here is what I found in the source, the interface looks clear:\nREGISTER_OP(\"ConcatOffset\")                                                     \n    .Input(\"concat_dim: int32\")                                                 \n    .Input(\"shape: N * int32\")                                                  \n    .Output(\"offset: N * int32\")                                                \n    .Attr(\"N: int >= 2\")                                                        \n    .SetShapeFn([](InferenceContext* c) {                                       \n      for (int i = 1; i < c->num_inputs(); ++i) {                               \n        c->set_output(i - 1, c->input(i));                                      \n      }                                                                         \n      return Status::OK();                                                      \n    })                                                                          \n    .Doc(R\"doc(                                                                 \nComputes offsets of concat inputs within its output.                            \n                                                                                \nFor example:                                                                    \n                                                                                \nprettyprint                                                                  \n# 'x' is [2, 2, 7]                                                              \n# 'y' is [2, 3, 7]                                                              \n# 'z' is [2, 5, 7]                                                              \nconcat_offset(2, [x, y, z]) => [0, 0, 0], [0, 2, 0], [0, 5, 0]                  \n                                                                           \n                                                                                \nconcat_dim: The dimension along which to concatenate.                           \nshape: The `N` int32 vectors representing shape of tensors being concatenated.  \noffset: The `N` int32 vectors representing the starting offset                  \n        of input tensors within the concatenated output.                        \n                                                                                \nThis is typically used by gradient computations for a concat operation.         \n)doc\");\n    // Suppose a Concat() op needs to Concatenate N tensors, each of            \n    // which has the same number of dimensions.  Their shapes match             \n    // except the concat dimension.                                             \n    //                                                                          \n    // E.g., say, we want to concatenate 3 tensors in the 2nd                   \n    // dimension, and their shapes are:                                         \n    //                                                                          \n    //  [2, 2, 5, 7]                                                            \n    //  [2, 3, 5, 7]                                                            \n    //  [2, 4, 5, 7]                                                            \n    //                                                                          \n    // Here, N=3, cdim=1, dims=4. The concatenated tensor has shape             \n    // [2,9,5,7]. We will compute the cumulative sum along the 2nd              \n    // dimension to figure out each input's offset in the concatenated          \n    // output:                                                                  \n    //  [0, 0, 0, 0]                                                            \n    //  [0, 2, 0, 0]                                                            \n    //  [0, 5, 0, 0]\nHope this helps.", "body": "Here is what I found in the source, the interface looks clear:\r\n```cpp\r\nREGISTER_OP(\"ConcatOffset\")                                                     \r\n    .Input(\"concat_dim: int32\")                                                 \r\n    .Input(\"shape: N * int32\")                                                  \r\n    .Output(\"offset: N * int32\")                                                \r\n    .Attr(\"N: int >= 2\")                                                        \r\n    .SetShapeFn([](InferenceContext* c) {                                       \r\n      for (int i = 1; i < c->num_inputs(); ++i) {                               \r\n        c->set_output(i - 1, c->input(i));                                      \r\n      }                                                                         \r\n      return Status::OK();                                                      \r\n    })                                                                          \r\n    .Doc(R\"doc(                                                                 \r\nComputes offsets of concat inputs within its output.                            \r\n                                                                                \r\nFor example:                                                                    \r\n                                                                                \r\nprettyprint                                                                  \r\n# 'x' is [2, 2, 7]                                                              \r\n# 'y' is [2, 3, 7]                                                              \r\n# 'z' is [2, 5, 7]                                                              \r\nconcat_offset(2, [x, y, z]) => [0, 0, 0], [0, 2, 0], [0, 5, 0]                  \r\n                                                                           \r\n                                                                                \r\nconcat_dim: The dimension along which to concatenate.                           \r\nshape: The `N` int32 vectors representing shape of tensors being concatenated.  \r\noffset: The `N` int32 vectors representing the starting offset                  \r\n        of input tensors within the concatenated output.                        \r\n                                                                                \r\nThis is typically used by gradient computations for a concat operation.         \r\n)doc\");\r\n```\r\n```cpp\r\n    // Suppose a Concat() op needs to Concatenate N tensors, each of            \r\n    // which has the same number of dimensions.  Their shapes match             \r\n    // except the concat dimension.                                             \r\n    //                                                                          \r\n    // E.g., say, we want to concatenate 3 tensors in the 2nd                   \r\n    // dimension, and their shapes are:                                         \r\n    //                                                                          \r\n    //  [2, 2, 5, 7]                                                            \r\n    //  [2, 3, 5, 7]                                                            \r\n    //  [2, 4, 5, 7]                                                            \r\n    //                                                                          \r\n    // Here, N=3, cdim=1, dims=4. The concatenated tensor has shape             \r\n    // [2,9,5,7]. We will compute the cumulative sum along the 2nd              \r\n    // dimension to figure out each input's offset in the concatenated          \r\n    // output:                                                                  \r\n    //  [0, 0, 0, 0]                                                            \r\n    //  [0, 2, 0, 0]                                                            \r\n    //  [0, 5, 0, 0]\r\n```\r\n\r\nHope this helps."}