{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/319753846", "html_url": "https://github.com/tensorflow/tensorflow/pull/11960#issuecomment-319753846", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11960", "id": 319753846, "node_id": "MDEyOklzc3VlQ29tbWVudDMxOTc1Mzg0Ng==", "user": {"login": "eaplatanios", "id": 1294940, "node_id": "MDQ6VXNlcjEyOTQ5NDA=", "avatar_url": "https://avatars2.githubusercontent.com/u/1294940?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eaplatanios", "html_url": "https://github.com/eaplatanios", "followers_url": "https://api.github.com/users/eaplatanios/followers", "following_url": "https://api.github.com/users/eaplatanios/following{/other_user}", "gists_url": "https://api.github.com/users/eaplatanios/gists{/gist_id}", "starred_url": "https://api.github.com/users/eaplatanios/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eaplatanios/subscriptions", "organizations_url": "https://api.github.com/users/eaplatanios/orgs", "repos_url": "https://api.github.com/users/eaplatanios/repos", "events_url": "https://api.github.com/users/eaplatanios/events{/privacy}", "received_events_url": "https://api.github.com/users/eaplatanios/received_events", "type": "User", "site_admin": false}, "created_at": "2017-08-02T18:13:00Z", "updated_at": "2017-08-02T18:13:00Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=88808\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/skye\">@skye</a> I would be more than willing to help with C API while loop implementation, as I do agree that repetition of this code in other language APIs is not a good idea. :)</p>\n<p>I have a couple of questions though to get started with this:</p>\n<ol>\n<li>Why do we also have a CondContext in the Python API? If we do not have that, how would we handle nested conds? In general, I would like to be clear on the functionality related to cond, before we go into while loops.</li>\n<li>Intuitively, it seems to me that we would know the control flow context of every op, at creation time, since they would be part of a cond, for example. So, wouldn't it better to make the control flow context of each op immutable and serialize it together with the op? We can perform the serialization efficiently by storing all control flow contexts of a graph, alongside the graph and then storing an ID for each op's control flow context.</li>\n<li>Are redundant cycles currently being introduced in the Python API implementation?</li>\n</ol>\n<p>I'm not sure if my questions make sense the way I phrased them, but I could explain further if needed. Probably the most helpful thing would be if you gave me an overview of what needs to be done as you said.</p>\n<p>In any case, it would also be good to think of potential ways for other language APIs to provide gradient implementations that are not yet supported in the C API, so that we can have some plan in mind for how to integrate well with them. We could follow a similar approach to how while loops are defined and create a new graph for each gradient op that we then merge into the main target graph, although I'm not sure how efficient that would be.</p>", "body_text": "@skye I would be more than willing to help with C API while loop implementation, as I do agree that repetition of this code in other language APIs is not a good idea. :)\nI have a couple of questions though to get started with this:\n\nWhy do we also have a CondContext in the Python API? If we do not have that, how would we handle nested conds? In general, I would like to be clear on the functionality related to cond, before we go into while loops.\nIntuitively, it seems to me that we would know the control flow context of every op, at creation time, since they would be part of a cond, for example. So, wouldn't it better to make the control flow context of each op immutable and serialize it together with the op? We can perform the serialization efficiently by storing all control flow contexts of a graph, alongside the graph and then storing an ID for each op's control flow context.\nAre redundant cycles currently being introduced in the Python API implementation?\n\nI'm not sure if my questions make sense the way I phrased them, but I could explain further if needed. Probably the most helpful thing would be if you gave me an overview of what needs to be done as you said.\nIn any case, it would also be good to think of potential ways for other language APIs to provide gradient implementations that are not yet supported in the C API, so that we can have some plan in mind for how to integrate well with them. We could follow a similar approach to how while loops are defined and create a new graph for each gradient op that we then merge into the main target graph, although I'm not sure how efficient that would be.", "body": "@skye I would be more than willing to help with C API while loop implementation, as I do agree that repetition of this code in other language APIs is not a good idea. :)\r\n\r\nI have a couple of questions though to get started with this:\r\n1. Why do we also have a CondContext in the Python API? If we do not have that, how would we handle nested conds? In general, I would like to be clear on the functionality related to cond, before we go into while loops.\r\n2. Intuitively, it seems to me that we would know the control flow context of every op, at creation time, since they would be part of a cond, for example. So, wouldn't it better to make the control flow context of each op immutable and serialize it together with the op? We can perform the serialization efficiently by storing all control flow contexts of a graph, alongside the graph and then storing an ID for each op's control flow context.\r\n3. Are redundant cycles currently being introduced in the Python API implementation?\r\n\r\nI'm not sure if my questions make sense the way I phrased them, but I could explain further if needed. Probably the most helpful thing would be if you gave me an overview of what needs to be done as you said.\r\n\r\nIn any case, it would also be good to think of potential ways for other language APIs to provide gradient implementations that are not yet supported in the C API, so that we can have some plan in mind for how to integrate well with them. We could follow a similar approach to how while loops are defined and create a new graph for each gradient op that we then merge into the main target graph, although I'm not sure how efficient that would be."}