{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/319739023", "html_url": "https://github.com/tensorflow/tensorflow/pull/11960#issuecomment-319739023", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11960", "id": 319739023, "node_id": "MDEyOklzc3VlQ29tbWVudDMxOTczOTAyMw==", "user": {"login": "eaplatanios", "id": 1294940, "node_id": "MDQ6VXNlcjEyOTQ5NDA=", "avatar_url": "https://avatars2.githubusercontent.com/u/1294940?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eaplatanios", "html_url": "https://github.com/eaplatanios", "followers_url": "https://api.github.com/users/eaplatanios/followers", "following_url": "https://api.github.com/users/eaplatanios/following{/other_user}", "gists_url": "https://api.github.com/users/eaplatanios/gists{/gist_id}", "starred_url": "https://api.github.com/users/eaplatanios/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eaplatanios/subscriptions", "organizations_url": "https://api.github.com/users/eaplatanios/orgs", "repos_url": "https://api.github.com/users/eaplatanios/repos", "events_url": "https://api.github.com/users/eaplatanios/events{/privacy}", "received_events_url": "https://api.github.com/users/eaplatanios/received_events", "type": "User", "site_admin": false}, "created_at": "2017-08-02T17:17:52Z", "updated_at": "2017-08-02T17:17:52Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=88808\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/skye\">@skye</a> I have actually started implementing it by mirroring what's done in the Python API. I am creating and managing control flow contexts in the Scala side, similar to how it's done on the Python side. However, that requires the ClearControlInputs function since that's used in Python. Once I finish the implementation and have something working, I can look into whether I can remove the calls to ClearControlInputs. This is unclear at this point though.</p>\n<p>One problem I have in my mind that is also not resolved in the Python API is what happens when you deserialize a graph from a MetaGraphDef file. This is generally handled very loosely in the Python API (e.g., with respect to prevent feeding and fetching, and contexts). I have done some work to improve the Scala implementation such that after loading a graph from a file, appending ops to that graph and manipulating it mimicks the behavior you'd get had you created it in the Scala side in the first place. However, with respect to control flow contexts, I don't yet have a clear picture at to when they come in and out and I can also not see them being serialized with the graph in the Python side. That's something to think about I guess, but I'll work on it after I have a basic implementation working for while loops.</p>\n<p>Also, note that I am implementing conditionals (i.e., tf.cond) in the same way as done for the Python API. That is, using a CondContext.</p>", "body_text": "@skye I have actually started implementing it by mirroring what's done in the Python API. I am creating and managing control flow contexts in the Scala side, similar to how it's done on the Python side. However, that requires the ClearControlInputs function since that's used in Python. Once I finish the implementation and have something working, I can look into whether I can remove the calls to ClearControlInputs. This is unclear at this point though.\nOne problem I have in my mind that is also not resolved in the Python API is what happens when you deserialize a graph from a MetaGraphDef file. This is generally handled very loosely in the Python API (e.g., with respect to prevent feeding and fetching, and contexts). I have done some work to improve the Scala implementation such that after loading a graph from a file, appending ops to that graph and manipulating it mimicks the behavior you'd get had you created it in the Scala side in the first place. However, with respect to control flow contexts, I don't yet have a clear picture at to when they come in and out and I can also not see them being serialized with the graph in the Python side. That's something to think about I guess, but I'll work on it after I have a basic implementation working for while loops.\nAlso, note that I am implementing conditionals (i.e., tf.cond) in the same way as done for the Python API. That is, using a CondContext.", "body": "@skye I have actually started implementing it by mirroring what's done in the Python API. I am creating and managing control flow contexts in the Scala side, similar to how it's done on the Python side. However, that requires the ClearControlInputs function since that's used in Python. Once I finish the implementation and have something working, I can look into whether I can remove the calls to ClearControlInputs. This is unclear at this point though.\r\n\r\nOne problem I have in my mind that is also not resolved in the Python API is what happens when you deserialize a graph from a MetaGraphDef file. This is generally handled very loosely in the Python API (e.g., with respect to prevent feeding and fetching, and contexts). I have done some work to improve the Scala implementation such that after loading a graph from a file, appending ops to that graph and manipulating it mimicks the behavior you'd get had you created it in the Scala side in the first place. However, with respect to control flow contexts, I don't yet have a clear picture at to when they come in and out and I can also not see them being serialized with the graph in the Python side. That's something to think about I guess, but I'll work on it after I have a basic implementation working for while loops.\r\n\r\nAlso, note that I am implementing conditionals (i.e., tf.cond) in the same way as done for the Python API. That is, using a CondContext."}