{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/1759", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/1759/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/1759/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/1759/events", "html_url": "https://github.com/tensorflow/tensorflow/pull/1759", "id": 145555764, "node_id": "MDExOlB1bGxSZXF1ZXN0NjUwODU4ODk=", "number": 1759, "title": "[WIP] CuDNN Batch Normalization Op", "user": {"login": "lukemetz", "id": 1248454, "node_id": "MDQ6VXNlcjEyNDg0NTQ=", "avatar_url": "https://avatars3.githubusercontent.com/u/1248454?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lukemetz", "html_url": "https://github.com/lukemetz", "followers_url": "https://api.github.com/users/lukemetz/followers", "following_url": "https://api.github.com/users/lukemetz/following{/other_user}", "gists_url": "https://api.github.com/users/lukemetz/gists{/gist_id}", "starred_url": "https://api.github.com/users/lukemetz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lukemetz/subscriptions", "organizations_url": "https://api.github.com/users/lukemetz/orgs", "repos_url": "https://api.github.com/users/lukemetz/repos", "events_url": "https://api.github.com/users/lukemetz/events{/privacy}", "received_events_url": "https://api.github.com/users/lukemetz/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 300136613, "node_id": "MDU6TGFiZWwzMDAxMzY2MTM=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/cla:%20no", "name": "cla: no", "color": "eb6420", "default": false}, {"id": 386191887, "node_id": "MDU6TGFiZWwzODYxOTE4ODc=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:awaiting%20response", "name": "stat:awaiting response", "color": "f4b400", "default": false}], "state": "closed", "locked": false, "assignee": {"login": "zheng-xq", "id": 15736910, "node_id": "MDQ6VXNlcjE1NzM2OTEw", "avatar_url": "https://avatars0.githubusercontent.com/u/15736910?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zheng-xq", "html_url": "https://github.com/zheng-xq", "followers_url": "https://api.github.com/users/zheng-xq/followers", "following_url": "https://api.github.com/users/zheng-xq/following{/other_user}", "gists_url": "https://api.github.com/users/zheng-xq/gists{/gist_id}", "starred_url": "https://api.github.com/users/zheng-xq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zheng-xq/subscriptions", "organizations_url": "https://api.github.com/users/zheng-xq/orgs", "repos_url": "https://api.github.com/users/zheng-xq/repos", "events_url": "https://api.github.com/users/zheng-xq/events{/privacy}", "received_events_url": "https://api.github.com/users/zheng-xq/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "zheng-xq", "id": 15736910, "node_id": "MDQ6VXNlcjE1NzM2OTEw", "avatar_url": "https://avatars0.githubusercontent.com/u/15736910?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zheng-xq", "html_url": "https://github.com/zheng-xq", "followers_url": "https://api.github.com/users/zheng-xq/followers", "following_url": "https://api.github.com/users/zheng-xq/following{/other_user}", "gists_url": "https://api.github.com/users/zheng-xq/gists{/gist_id}", "starred_url": "https://api.github.com/users/zheng-xq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zheng-xq/subscriptions", "organizations_url": "https://api.github.com/users/zheng-xq/orgs", "repos_url": "https://api.github.com/users/zheng-xq/repos", "events_url": "https://api.github.com/users/zheng-xq/events{/privacy}", "received_events_url": "https://api.github.com/users/zheng-xq/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 34, "created_at": "2016-04-04T00:24:57Z", "updated_at": "2016-08-02T18:57:08Z", "closed_at": "2016-06-27T19:55:46Z", "author_association": "NONE", "pull_request": {"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/1759", "html_url": "https://github.com/tensorflow/tensorflow/pull/1759", "diff_url": "https://github.com/tensorflow/tensorflow/pull/1759.diff", "patch_url": "https://github.com/tensorflow/tensorflow/pull/1759.patch"}, "body_html": "<p>This pull request is a WIP for adding a cudnn batchnorm op that works on NCHW data layout. Others and myself (<a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"140845173\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/tensorflow/tensorflow/issues/1502\" data-hovercard-type=\"issue\" data-hovercard-url=\"/tensorflow/tensorflow/issues/1502/hovercard\" href=\"https://github.com/tensorflow/tensorflow/issues/1502\">#1502</a>) have noticed very poor performance. Currently, the code is very rough and is just enough to do performance evaluations.</p>\n<p>Code used to create the following numbers can be found here (<a href=\"https://gist.github.com/lukemetz/bdb58d2f006b64fe234cb04f7f0e8185\">https://gist.github.com/lukemetz/bdb58d2f006b64fe234cb04f7f0e8185</a>). I tested 3 variations: current batch norm implementation plus moments in NHWC (tf_NHWC), current batch norm implementation and moments in NCHW (tf_NCHW), and my proposed op in NCHW format (cudnn_NCHW). All tests done were done on a 980, and the number listed is time taken for 100 iterations computing forward and backward passes.</p>\n<table>\n<thead>\n<tr>\n<th>Shape</th>\n<th>tf_NHWC</th>\n<th>tf_NCHW</th>\n<th>cudnn_NCHW</th>\n<th>percent faster tf_NHWC</th>\n<th>percent faster tf_NCWH</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>(32, 8, 8, 32)</td>\n<td>125.5 ms</td>\n<td>196.8 ms</td>\n<td>85.6 ms</td>\n<td>47%</td>\n<td>130%</td>\n</tr>\n<tr>\n<td>(128, 4, 4, 32)</td>\n<td>133.4 ms</td>\n<td>171.7 ms</td>\n<td>77.1 ms</td>\n<td>73%</td>\n<td>123%</td>\n</tr>\n<tr>\n<td>(256, 16, 16, 32)</td>\n<td>648.7 ms</td>\n<td>4624.5 ms</td>\n<td>388.6 ms</td>\n<td>67%</td>\n<td>1090%</td>\n</tr>\n<tr>\n<td>(128, 64, 64, 32)</td>\n<td>4900.5 ms</td>\n<td>37107.5 ms</td>\n<td>3011.5 ms</td>\n<td>63 %</td>\n<td>1132%</td>\n</tr>\n<tr>\n<td>(128, 128, 128, 32)</td>\n<td>19087.1 ms</td>\n<td>171175.2 ms</td>\n<td>11815.6 ms</td>\n<td>62%</td>\n<td>1349%</td>\n</tr>\n</tbody>\n</table>\n<p>(Note:  in my experience it is faster to transpose batchnorm transpose instead of using NCHW moments and batchnorm.)</p>\n<p>When testing on an largish net on a single GPU, there are also performance improvements. My test network is an 8 layer residual-like network on 32x32 images with batchsize 128.</p>\n<p>NCHW batchnorm and HCHW convs: approximately 2700 examples a second.</p>\n<p>NHWC with Tensorflow implementation and NHWC convs: approximately 1900 examples a second.</p>\n<p>(Note: this difference is in large part to do with using NCHW convolutions with no transposes, but this was not possible before a fast NCHW batchnorm.)</p>\n<p>The one odd thing I have encountered is that performance takes a hit when using multiple GPUs with data parallelism. . . It is actually slower than using a single GPU. If anybody has an idea as to why, or solutions, I would love to know. To my knowledge each GPU has one cuda stream so the cudnn locks shouldn't interfere with each other ???</p>\n<p>If the concept behind this PR looks good, let me know. I wanted to share results early but there is a still a lot to do in terms of cleanup/standardization, error checking, testing, and documentation as well as a front end python api.</p>\n<p>Thanks, all. Any comments appreciated.</p>", "body_text": "This pull request is a WIP for adding a cudnn batchnorm op that works on NCHW data layout. Others and myself (#1502) have noticed very poor performance. Currently, the code is very rough and is just enough to do performance evaluations.\nCode used to create the following numbers can be found here (https://gist.github.com/lukemetz/bdb58d2f006b64fe234cb04f7f0e8185). I tested 3 variations: current batch norm implementation plus moments in NHWC (tf_NHWC), current batch norm implementation and moments in NCHW (tf_NCHW), and my proposed op in NCHW format (cudnn_NCHW). All tests done were done on a 980, and the number listed is time taken for 100 iterations computing forward and backward passes.\n\n\n\nShape\ntf_NHWC\ntf_NCHW\ncudnn_NCHW\npercent faster tf_NHWC\npercent faster tf_NCWH\n\n\n\n\n(32, 8, 8, 32)\n125.5 ms\n196.8 ms\n85.6 ms\n47%\n130%\n\n\n(128, 4, 4, 32)\n133.4 ms\n171.7 ms\n77.1 ms\n73%\n123%\n\n\n(256, 16, 16, 32)\n648.7 ms\n4624.5 ms\n388.6 ms\n67%\n1090%\n\n\n(128, 64, 64, 32)\n4900.5 ms\n37107.5 ms\n3011.5 ms\n63 %\n1132%\n\n\n(128, 128, 128, 32)\n19087.1 ms\n171175.2 ms\n11815.6 ms\n62%\n1349%\n\n\n\n(Note:  in my experience it is faster to transpose batchnorm transpose instead of using NCHW moments and batchnorm.)\nWhen testing on an largish net on a single GPU, there are also performance improvements. My test network is an 8 layer residual-like network on 32x32 images with batchsize 128.\nNCHW batchnorm and HCHW convs: approximately 2700 examples a second.\nNHWC with Tensorflow implementation and NHWC convs: approximately 1900 examples a second.\n(Note: this difference is in large part to do with using NCHW convolutions with no transposes, but this was not possible before a fast NCHW batchnorm.)\nThe one odd thing I have encountered is that performance takes a hit when using multiple GPUs with data parallelism. . . It is actually slower than using a single GPU. If anybody has an idea as to why, or solutions, I would love to know. To my knowledge each GPU has one cuda stream so the cudnn locks shouldn't interfere with each other ???\nIf the concept behind this PR looks good, let me know. I wanted to share results early but there is a still a lot to do in terms of cleanup/standardization, error checking, testing, and documentation as well as a front end python api.\nThanks, all. Any comments appreciated.", "body": "This pull request is a WIP for adding a cudnn batchnorm op that works on NCHW data layout. Others and myself (https://github.com/tensorflow/tensorflow/issues/1502) have noticed very poor performance. Currently, the code is very rough and is just enough to do performance evaluations.\n\nCode used to create the following numbers can be found here (https://gist.github.com/lukemetz/bdb58d2f006b64fe234cb04f7f0e8185). I tested 3 variations: current batch norm implementation plus moments in NHWC (tf_NHWC), current batch norm implementation and moments in NCHW (tf_NCHW), and my proposed op in NCHW format (cudnn_NCHW). All tests done were done on a 980, and the number listed is time taken for 100 iterations computing forward and backward passes.\n\n| Shape | tf_NHWC | tf_NCHW | cudnn_NCHW | percent faster tf_NHWC | percent faster tf_NCWH |\n| --- | --- | --- | --- | --- | --- |\n| (32, 8, 8, 32) | 125.5 ms | 196.8 ms | 85.6 ms | 47% | 130% |\n| (128, 4, 4, 32) | 133.4 ms | 171.7 ms | 77.1 ms | 73% | 123% |\n| (256, 16, 16, 32) | 648.7 ms | 4624.5 ms | 388.6 ms | 67% | 1090% |\n| (128, 64, 64, 32) | 4900.5 ms | 37107.5 ms | 3011.5 ms | 63 % | 1132% |\n| (128, 128, 128, 32) | 19087.1 ms | 171175.2 ms | 11815.6 ms | 62% | 1349% |\n\n(Note:  in my experience it is faster to transpose batchnorm transpose instead of using NCHW moments and batchnorm.)\n\nWhen testing on an largish net on a single GPU, there are also performance improvements. My test network is an 8 layer residual-like network on 32x32 images with batchsize 128. \n\nNCHW batchnorm and HCHW convs: approximately 2700 examples a second. \n\nNHWC with Tensorflow implementation and NHWC convs: approximately 1900 examples a second. \n\n(Note: this difference is in large part to do with using NCHW convolutions with no transposes, but this was not possible before a fast NCHW batchnorm.)\n\nThe one odd thing I have encountered is that performance takes a hit when using multiple GPUs with data parallelism. . . It is actually slower than using a single GPU. If anybody has an idea as to why, or solutions, I would love to know. To my knowledge each GPU has one cuda stream so the cudnn locks shouldn't interfere with each other ???\n\nIf the concept behind this PR looks good, let me know. I wanted to share results early but there is a still a lot to do in terms of cleanup/standardization, error checking, testing, and documentation as well as a front end python api.\n\nThanks, all. Any comments appreciated.\n"}