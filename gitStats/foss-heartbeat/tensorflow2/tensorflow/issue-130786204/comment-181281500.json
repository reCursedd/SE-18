{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/181281500", "html_url": "https://github.com/tensorflow/tensorflow/pull/967#issuecomment-181281500", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/967", "id": 181281500, "node_id": "MDEyOklzc3VlQ29tbWVudDE4MTI4MTUwMA==", "user": {"login": "dvyukov", "id": 1095328, "node_id": "MDQ6VXNlcjEwOTUzMjg=", "avatar_url": "https://avatars3.githubusercontent.com/u/1095328?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dvyukov", "html_url": "https://github.com/dvyukov", "followers_url": "https://api.github.com/users/dvyukov/followers", "following_url": "https://api.github.com/users/dvyukov/following{/other_user}", "gists_url": "https://api.github.com/users/dvyukov/gists{/gist_id}", "starred_url": "https://api.github.com/users/dvyukov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dvyukov/subscriptions", "organizations_url": "https://api.github.com/users/dvyukov/orgs", "repos_url": "https://api.github.com/users/dvyukov/repos", "events_url": "https://api.github.com/users/dvyukov/events{/privacy}", "received_events_url": "https://api.github.com/users/dvyukov/received_events", "type": "User", "site_admin": false}, "created_at": "2016-02-08T09:52:11Z", "updated_at": "2016-02-08T09:52:11Z", "author_association": "NONE", "body_html": "<p>We could use a wrapper along the following lines to ensure FIFO ordering on top of a scheduler that does not give any ordering guarantees. I've tried to fix deadlocks in label_image example by applying the FIFO wrapper in TensorContractionThreadPool, but no success (even if I use FIFO for all tasks submitted in TensorContractionThreadPool, it still deadlocks).</p>\n<div class=\"highlight highlight-source-c\"><pre>class FIFO {\n public:\n  <span class=\"pl-k\">typedef</span> std::function&lt;<span class=\"pl-c1\">void</span>()&gt; F;\n\n  F <span class=\"pl-smi\">operator</span>()(F f) {\n    {\n      std::unique_lock&lt;std::mutex&gt; <span class=\"pl-c1\">lock</span>(m_mutex);\n      m_queue.<span class=\"pl-c1\">push</span>(<span class=\"pl-c1\">std::move</span>(f));\n    }\n    <span class=\"pl-k\">return</span> [this]() {\n      F f;\n      {\n        std::unique_lock&lt;std::mutex&gt; <span class=\"pl-c1\">lock</span>(m_mutex);\n        f = <span class=\"pl-c1\">std::move</span>(m_queue.<span class=\"pl-c1\">front</span>());\n        m_queue.<span class=\"pl-c1\">pop</span>();\n      }\n      <span class=\"pl-c1\">f</span>();\n    };\n  }\n\n private:\n  std::mutex m_mutex;\n  std::queue&lt;F&gt; m_queue;\n};</pre></div>", "body_text": "We could use a wrapper along the following lines to ensure FIFO ordering on top of a scheduler that does not give any ordering guarantees. I've tried to fix deadlocks in label_image example by applying the FIFO wrapper in TensorContractionThreadPool, but no success (even if I use FIFO for all tasks submitted in TensorContractionThreadPool, it still deadlocks).\nclass FIFO {\n public:\n  typedef std::function<void()> F;\n\n  F operator()(F f) {\n    {\n      std::unique_lock<std::mutex> lock(m_mutex);\n      m_queue.push(std::move(f));\n    }\n    return [this]() {\n      F f;\n      {\n        std::unique_lock<std::mutex> lock(m_mutex);\n        f = std::move(m_queue.front());\n        m_queue.pop();\n      }\n      f();\n    };\n  }\n\n private:\n  std::mutex m_mutex;\n  std::queue<F> m_queue;\n};", "body": "We could use a wrapper along the following lines to ensure FIFO ordering on top of a scheduler that does not give any ordering guarantees. I've tried to fix deadlocks in label_image example by applying the FIFO wrapper in TensorContractionThreadPool, but no success (even if I use FIFO for all tasks submitted in TensorContractionThreadPool, it still deadlocks).\n\n``` c\nclass FIFO {\n public:\n  typedef std::function<void()> F;\n\n  F operator()(F f) {\n    {\n      std::unique_lock<std::mutex> lock(m_mutex);\n      m_queue.push(std::move(f));\n    }\n    return [this]() {\n      F f;\n      {\n        std::unique_lock<std::mutex> lock(m_mutex);\n        f = std::move(m_queue.front());\n        m_queue.pop();\n      }\n      f();\n    };\n  }\n\n private:\n  std::mutex m_mutex;\n  std::queue<F> m_queue;\n};\n```\n"}