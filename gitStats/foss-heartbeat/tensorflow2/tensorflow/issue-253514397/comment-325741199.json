{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/325741199", "html_url": "https://github.com/tensorflow/tensorflow/pull/12668#issuecomment-325741199", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/12668", "id": 325741199, "node_id": "MDEyOklzc3VlQ29tbWVudDMyNTc0MTE5OQ==", "user": {"login": "asimshankar", "id": 16018, "node_id": "MDQ6VXNlcjE2MDE4", "avatar_url": "https://avatars2.githubusercontent.com/u/16018?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asimshankar", "html_url": "https://github.com/asimshankar", "followers_url": "https://api.github.com/users/asimshankar/followers", "following_url": "https://api.github.com/users/asimshankar/following{/other_user}", "gists_url": "https://api.github.com/users/asimshankar/gists{/gist_id}", "starred_url": "https://api.github.com/users/asimshankar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asimshankar/subscriptions", "organizations_url": "https://api.github.com/users/asimshankar/orgs", "repos_url": "https://api.github.com/users/asimshankar/repos", "events_url": "https://api.github.com/users/asimshankar/events{/privacy}", "received_events_url": "https://api.github.com/users/asimshankar/received_events", "type": "User", "site_admin": false}, "created_at": "2017-08-29T17:46:27Z", "updated_at": "2017-08-29T17:46:27Z", "author_association": "MEMBER", "body_html": "<p>Regarding your specific use case, it seems that you should be able to provide a <code>ByteBuffer</code> (see Java NIO support for <code>DirectByteBuffers</code>) from native code to Java, and then use that in <code>Graph.importGraphDef</code> instead of creating the <code>TF_Graph</code> object in native code. Doing so would also mean that you don't copy 100MB across the boundary. Basically, if you need some data manipulation in native code, then make the boundary between Java and native code the data manipulation instead of making the boundary be TensorFlow objects.</p>\n<p>If that doesn't work, I'd suggest posting a more detailed description of what you're trying to do on StackOverflow and seek opinions there - there is a larger community on StackOverflow and good ideas are likely to come up.</p>\n<p>For the PR though, I'm going to close it out. I don't feel comfortable providing a public API that is very easy to use incorrectly and which manifests itself with a JVM segmentation fault instead of a clear error message/exception. It also breaks an abstraction boundary - the fact that the graphs are backed by native long handles is an implementation detail that I do not think should be exposed to the user.</p>\n<p>Thanks for your understanding.</p>", "body_text": "Regarding your specific use case, it seems that you should be able to provide a ByteBuffer (see Java NIO support for DirectByteBuffers) from native code to Java, and then use that in Graph.importGraphDef instead of creating the TF_Graph object in native code. Doing so would also mean that you don't copy 100MB across the boundary. Basically, if you need some data manipulation in native code, then make the boundary between Java and native code the data manipulation instead of making the boundary be TensorFlow objects.\nIf that doesn't work, I'd suggest posting a more detailed description of what you're trying to do on StackOverflow and seek opinions there - there is a larger community on StackOverflow and good ideas are likely to come up.\nFor the PR though, I'm going to close it out. I don't feel comfortable providing a public API that is very easy to use incorrectly and which manifests itself with a JVM segmentation fault instead of a clear error message/exception. It also breaks an abstraction boundary - the fact that the graphs are backed by native long handles is an implementation detail that I do not think should be exposed to the user.\nThanks for your understanding.", "body": "Regarding your specific use case, it seems that you should be able to provide a `ByteBuffer` (see Java NIO support for `DirectByteBuffers`) from native code to Java, and then use that in `Graph.importGraphDef` instead of creating the `TF_Graph` object in native code. Doing so would also mean that you don't copy 100MB across the boundary. Basically, if you need some data manipulation in native code, then make the boundary between Java and native code the data manipulation instead of making the boundary be TensorFlow objects.\r\n\r\nIf that doesn't work, I'd suggest posting a more detailed description of what you're trying to do on StackOverflow and seek opinions there - there is a larger community on StackOverflow and good ideas are likely to come up.\r\n\r\nFor the PR though, I'm going to close it out. I don't feel comfortable providing a public API that is very easy to use incorrectly and which manifests itself with a JVM segmentation fault instead of a clear error message/exception. It also breaks an abstraction boundary - the fact that the graphs are backed by native long handles is an implementation detail that I do not think should be exposed to the user.\r\n\r\nThanks for your understanding."}