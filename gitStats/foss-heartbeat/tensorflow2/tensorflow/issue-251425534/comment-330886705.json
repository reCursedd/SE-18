{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/330886705", "html_url": "https://github.com/tensorflow/tensorflow/issues/12414#issuecomment-330886705", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/12414", "id": 330886705, "node_id": "MDEyOklzc3VlQ29tbWVudDMzMDg4NjcwNQ==", "user": {"login": "rightaditya", "id": 1624945, "node_id": "MDQ6VXNlcjE2MjQ5NDU=", "avatar_url": "https://avatars1.githubusercontent.com/u/1624945?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rightaditya", "html_url": "https://github.com/rightaditya", "followers_url": "https://api.github.com/users/rightaditya/followers", "following_url": "https://api.github.com/users/rightaditya/following{/other_user}", "gists_url": "https://api.github.com/users/rightaditya/gists{/gist_id}", "starred_url": "https://api.github.com/users/rightaditya/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rightaditya/subscriptions", "organizations_url": "https://api.github.com/users/rightaditya/orgs", "repos_url": "https://api.github.com/users/rightaditya/repos", "events_url": "https://api.github.com/users/rightaditya/events{/privacy}", "received_events_url": "https://api.github.com/users/rightaditya/received_events", "type": "User", "site_admin": false}, "created_at": "2017-09-20T15:22:31Z", "updated_at": "2017-09-20T15:22:31Z", "author_association": "NONE", "body_html": "<p>How much do you need? Here's how it starts:</p>\n<div class=\"highlight highlight-source-python\"><pre>shuf_seed <span class=\"pl-k\">=</span> tf.placeholder(tf.int64, <span class=\"pl-v\">shape</span><span class=\"pl-k\">=</span>[])\ntrn_data, n_cat <span class=\"pl-k\">=</span> setup_dataset(args.train, args.batch_size, shuf_seed)\ndev_data, _ <span class=\"pl-k\">=</span> setup_dataset(args.dev, args.batch_size)\n\nit <span class=\"pl-k\">=</span> tfdata.Iterator.from_structure(trn_data.output_types,\n                                    trn_data.output_shapes)\nx, y, y_mask <span class=\"pl-k\">=</span> it.get_next()\ny <span class=\"pl-k\">=</span> tf.reshape(y, [<span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>])\ny_mask <span class=\"pl-k\">=</span> tf.cast(tf.reshape(y_mask, [<span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>]), tf.float32)\ntemporal_padding <span class=\"pl-k\">=</span> args.filter_size[<span class=\"pl-c1\">0</span>] <span class=\"pl-k\">-</span> <span class=\"pl-c1\">1</span>\nt_pad_before <span class=\"pl-k\">=</span> temporal_padding <span class=\"pl-k\">//</span> <span class=\"pl-c1\">2</span>\nt_pad_after <span class=\"pl-k\">=</span> temporal_padding <span class=\"pl-k\">-</span> t_pad_before\nx <span class=\"pl-k\">=</span> tf.pad(x, [[<span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">0</span>], [t_pad_before, t_pad_after]])\ntrn_init <span class=\"pl-k\">=</span> it.make_initializer(trn_data)\ndev_init <span class=\"pl-k\">=</span> it.make_initializer(dev_data)\n<span class=\"pl-k\">&lt;</span>snip<span class=\"pl-k\">&gt;</span>\nemb_layer <span class=\"pl-k\">=</span> tf.Variable(embeddings, <span class=\"pl-v\">trainable</span><span class=\"pl-k\">=</span>args.trainable_embeddings,\n                        <span class=\"pl-v\">name</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>embedding_matrix<span class=\"pl-pds\">'</span></span>)\nx_embedded <span class=\"pl-k\">=</span> tf.nn.embedding_lookup(emb_layer, x)</pre></div>", "body_text": "How much do you need? Here's how it starts:\nshuf_seed = tf.placeholder(tf.int64, shape=[])\ntrn_data, n_cat = setup_dataset(args.train, args.batch_size, shuf_seed)\ndev_data, _ = setup_dataset(args.dev, args.batch_size)\n\nit = tfdata.Iterator.from_structure(trn_data.output_types,\n                                    trn_data.output_shapes)\nx, y, y_mask = it.get_next()\ny = tf.reshape(y, [-1])\ny_mask = tf.cast(tf.reshape(y_mask, [-1]), tf.float32)\ntemporal_padding = args.filter_size[0] - 1\nt_pad_before = temporal_padding // 2\nt_pad_after = temporal_padding - t_pad_before\nx = tf.pad(x, [[0, 0], [t_pad_before, t_pad_after]])\ntrn_init = it.make_initializer(trn_data)\ndev_init = it.make_initializer(dev_data)\n<snip>\nemb_layer = tf.Variable(embeddings, trainable=args.trainable_embeddings,\n                        name='embedding_matrix')\nx_embedded = tf.nn.embedding_lookup(emb_layer, x)", "body": "How much do you need? Here's how it starts:\r\n```python\r\nshuf_seed = tf.placeholder(tf.int64, shape=[])\r\ntrn_data, n_cat = setup_dataset(args.train, args.batch_size, shuf_seed)\r\ndev_data, _ = setup_dataset(args.dev, args.batch_size)\r\n\r\nit = tfdata.Iterator.from_structure(trn_data.output_types,\r\n                                    trn_data.output_shapes)\r\nx, y, y_mask = it.get_next()\r\ny = tf.reshape(y, [-1])\r\ny_mask = tf.cast(tf.reshape(y_mask, [-1]), tf.float32)\r\ntemporal_padding = args.filter_size[0] - 1\r\nt_pad_before = temporal_padding // 2\r\nt_pad_after = temporal_padding - t_pad_before\r\nx = tf.pad(x, [[0, 0], [t_pad_before, t_pad_after]])\r\ntrn_init = it.make_initializer(trn_data)\r\ndev_init = it.make_initializer(dev_data)\r\n<snip>\r\nemb_layer = tf.Variable(embeddings, trainable=args.trainable_embeddings,\r\n                        name='embedding_matrix')\r\nx_embedded = tf.nn.embedding_lookup(emb_layer, x)\r\n```"}