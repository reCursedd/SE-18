{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/224718386", "html_url": "https://github.com/tensorflow/tensorflow/issues/2646#issuecomment-224718386", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2646", "id": 224718386, "node_id": "MDEyOklzc3VlQ29tbWVudDIyNDcxODM4Ng==", "user": {"login": "aselle", "id": 326106, "node_id": "MDQ6VXNlcjMyNjEwNg==", "avatar_url": "https://avatars1.githubusercontent.com/u/326106?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aselle", "html_url": "https://github.com/aselle", "followers_url": "https://api.github.com/users/aselle/followers", "following_url": "https://api.github.com/users/aselle/following{/other_user}", "gists_url": "https://api.github.com/users/aselle/gists{/gist_id}", "starred_url": "https://api.github.com/users/aselle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aselle/subscriptions", "organizations_url": "https://api.github.com/users/aselle/orgs", "repos_url": "https://api.github.com/users/aselle/repos", "events_url": "https://api.github.com/users/aselle/events{/privacy}", "received_events_url": "https://api.github.com/users/aselle/received_events", "type": "User", "site_admin": false}, "created_at": "2016-06-08T20:33:01Z", "updated_at": "2016-06-08T20:33:01Z", "author_association": "MEMBER", "body_html": "<p>Sorry for the late reply. It's difficult to do this in general, because you'd need to put something in a translation unit for every project that might have possibly been compiled differently that you can query later. I.e. something already has to be compiled that remembers the size or that it is c++11. I don't really know enough about the toolchain to know if the compiler dumps something we could reliably use to determine if a c++11 or c++0x standard library was used. We could roll our own, but it seems difficult to control. It is best to avoid std::unordered_map being part of a systems API to avoid most times you would hit this, at least until c++0x tr stuff is put to bed.</p>", "body_text": "Sorry for the late reply. It's difficult to do this in general, because you'd need to put something in a translation unit for every project that might have possibly been compiled differently that you can query later. I.e. something already has to be compiled that remembers the size or that it is c++11. I don't really know enough about the toolchain to know if the compiler dumps something we could reliably use to determine if a c++11 or c++0x standard library was used. We could roll our own, but it seems difficult to control. It is best to avoid std::unordered_map being part of a systems API to avoid most times you would hit this, at least until c++0x tr stuff is put to bed.", "body": "Sorry for the late reply. It's difficult to do this in general, because you'd need to put something in a translation unit for every project that might have possibly been compiled differently that you can query later. I.e. something already has to be compiled that remembers the size or that it is c++11. I don't really know enough about the toolchain to know if the compiler dumps something we could reliably use to determine if a c++11 or c++0x standard library was used. We could roll our own, but it seems difficult to control. It is best to avoid std::unordered_map being part of a systems API to avoid most times you would hit this, at least until c++0x tr stuff is put to bed.\n"}