{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/327343236", "html_url": "https://github.com/tensorflow/tensorflow/pull/12820#issuecomment-327343236", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/12820", "id": 327343236, "node_id": "MDEyOklzc3VlQ29tbWVudDMyNzM0MzIzNg==", "user": {"login": "eaplatanios", "id": 1294940, "node_id": "MDQ6VXNlcjEyOTQ5NDA=", "avatar_url": "https://avatars2.githubusercontent.com/u/1294940?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eaplatanios", "html_url": "https://github.com/eaplatanios", "followers_url": "https://api.github.com/users/eaplatanios/followers", "following_url": "https://api.github.com/users/eaplatanios/following{/other_user}", "gists_url": "https://api.github.com/users/eaplatanios/gists{/gist_id}", "starred_url": "https://api.github.com/users/eaplatanios/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eaplatanios/subscriptions", "organizations_url": "https://api.github.com/users/eaplatanios/orgs", "repos_url": "https://api.github.com/users/eaplatanios/repos", "events_url": "https://api.github.com/users/eaplatanios/events{/privacy}", "received_events_url": "https://api.github.com/users/eaplatanios/received_events", "type": "User", "site_admin": false}, "created_at": "2017-09-06T00:53:32Z", "updated_at": "2017-09-06T00:53:32Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=16018\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/asimshankar\">@asimshankar</a> Yes, that's right. What I've done is that I package my cross-compiled JNI bindings along with the main Scala API in one package distributed through Sonatype. Then, for the TensorFlow binaries, I package each pre-compiled binary in its own package. Thus, when you load my API, you don't have to download the pre-compiled binaries. Also, when you do download them via depending on one of my wrapping packages, you only get to download the one corresponding to your platform (done so that the JARs are not very big).</p>\n<p>This way, when I load the libraries through the JVM, I extract the JNI bindings library into a temporary directory. If you have also provided one of my wrapping packages for the main native library in your classpath, then I also extract that in the same directory. I then load the libraries from that directory, but in this case, <code>dlopen</code> would fail to load the JNI bindings dependency on the main native library due to the absolute path in the dependency name.</p>\n<p>I hope this makes sense.</p>", "body_text": "@asimshankar Yes, that's right. What I've done is that I package my cross-compiled JNI bindings along with the main Scala API in one package distributed through Sonatype. Then, for the TensorFlow binaries, I package each pre-compiled binary in its own package. Thus, when you load my API, you don't have to download the pre-compiled binaries. Also, when you do download them via depending on one of my wrapping packages, you only get to download the one corresponding to your platform (done so that the JARs are not very big).\nThis way, when I load the libraries through the JVM, I extract the JNI bindings library into a temporary directory. If you have also provided one of my wrapping packages for the main native library in your classpath, then I also extract that in the same directory. I then load the libraries from that directory, but in this case, dlopen would fail to load the JNI bindings dependency on the main native library due to the absolute path in the dependency name.\nI hope this makes sense.", "body": "@asimshankar Yes, that's right. What I've done is that I package my cross-compiled JNI bindings along with the main Scala API in one package distributed through Sonatype. Then, for the TensorFlow binaries, I package each pre-compiled binary in its own package. Thus, when you load my API, you don't have to download the pre-compiled binaries. Also, when you do download them via depending on one of my wrapping packages, you only get to download the one corresponding to your platform (done so that the JARs are not very big).\r\n\r\nThis way, when I load the libraries through the JVM, I extract the JNI bindings library into a temporary directory. If you have also provided one of my wrapping packages for the main native library in your classpath, then I also extract that in the same directory. I then load the libraries from that directory, but in this case, `dlopen` would fail to load the JNI bindings dependency on the main native library due to the absolute path in the dependency name.\r\n\r\nI hope this makes sense."}