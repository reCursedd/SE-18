{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/232801593", "html_url": "https://github.com/tensorflow/tensorflow/issues/2919#issuecomment-232801593", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2919", "id": 232801593, "node_id": "MDEyOklzc3VlQ29tbWVudDIzMjgwMTU5Mw==", "user": {"login": "sjperkins", "id": 3530212, "node_id": "MDQ6VXNlcjM1MzAyMTI=", "avatar_url": "https://avatars3.githubusercontent.com/u/3530212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sjperkins", "html_url": "https://github.com/sjperkins", "followers_url": "https://api.github.com/users/sjperkins/followers", "following_url": "https://api.github.com/users/sjperkins/following{/other_user}", "gists_url": "https://api.github.com/users/sjperkins/gists{/gist_id}", "starred_url": "https://api.github.com/users/sjperkins/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sjperkins/subscriptions", "organizations_url": "https://api.github.com/users/sjperkins/orgs", "repos_url": "https://api.github.com/users/sjperkins/repos", "events_url": "https://api.github.com/users/sjperkins/events{/privacy}", "received_events_url": "https://api.github.com/users/sjperkins/received_events", "type": "User", "site_admin": false}, "created_at": "2016-07-14T21:44:03Z", "updated_at": "2016-07-14T21:44:03Z", "author_association": "CONTRIBUTOR", "body_html": "<blockquote>\n<p>Since numpy array object is owned by Python runtime, when it's destroyed Python will try to de-allocate the data. If there's a way to tell numpy to release the ownership of the data buffer, that could be a work-around.</p>\n</blockquote>\n<p>I see there's already a Py_DECREF \"associated\" with the numpy input arrays when they are wrapped in unique_ptr's  with <code>make_safe</code>. I guess this is to ensure they're there to encourage release of the numpy base arrays on exit of TF_wrapper_helper. Am I reading this correctly?</p>\n<p>How about using Py_INCREF on the numpy inputs to make sure they exist for the duration of <code>session.run</code> (which is guarded by the GIL) and then Py_DECREF them afterwards . This should prevent release of the underlying buffer during <code>session.run</code> which I guess is what the guard is for?</p>", "body_text": "Since numpy array object is owned by Python runtime, when it's destroyed Python will try to de-allocate the data. If there's a way to tell numpy to release the ownership of the data buffer, that could be a work-around.\n\nI see there's already a Py_DECREF \"associated\" with the numpy input arrays when they are wrapped in unique_ptr's  with make_safe. I guess this is to ensure they're there to encourage release of the numpy base arrays on exit of TF_wrapper_helper. Am I reading this correctly?\nHow about using Py_INCREF on the numpy inputs to make sure they exist for the duration of session.run (which is guarded by the GIL) and then Py_DECREF them afterwards . This should prevent release of the underlying buffer during session.run which I guess is what the guard is for?", "body": "> Since numpy array object is owned by Python runtime, when it's destroyed Python will try to de-allocate the data. If there's a way to tell numpy to release the ownership of the data buffer, that could be a work-around.\n\nI see there's already a Py_DECREF \"associated\" with the numpy input arrays when they are wrapped in unique_ptr's  with `make_safe`. I guess this is to ensure they're there to encourage release of the numpy base arrays on exit of TF_wrapper_helper. Am I reading this correctly?\n\nHow about using Py_INCREF on the numpy inputs to make sure they exist for the duration of `session.run` (which is guarded by the GIL) and then Py_DECREF them afterwards . This should prevent release of the underlying buffer during `session.run` which I guess is what the guard is for?\n"}