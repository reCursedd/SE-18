{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9284", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9284/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9284/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9284/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/9284", "id": 222373574, "node_id": "MDU6SXNzdWUyMjIzNzM1NzQ=", "number": 9284, "title": "Broadcasting support in `tf.where`", "user": {"login": "tillahoffmann", "id": 966348, "node_id": "MDQ6VXNlcjk2NjM0OA==", "avatar_url": "https://avatars2.githubusercontent.com/u/966348?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tillahoffmann", "html_url": "https://github.com/tillahoffmann", "followers_url": "https://api.github.com/users/tillahoffmann/followers", "following_url": "https://api.github.com/users/tillahoffmann/following{/other_user}", "gists_url": "https://api.github.com/users/tillahoffmann/gists{/gist_id}", "starred_url": "https://api.github.com/users/tillahoffmann/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tillahoffmann/subscriptions", "organizations_url": "https://api.github.com/users/tillahoffmann/orgs", "repos_url": "https://api.github.com/users/tillahoffmann/repos", "events_url": "https://api.github.com/users/tillahoffmann/events{/privacy}", "received_events_url": "https://api.github.com/users/tillahoffmann/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 404586558, "node_id": "MDU6TGFiZWw0MDQ1ODY1NTg=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:community%20support", "name": "stat:community support", "color": "f4b400", "default": false}, {"id": 473173272, "node_id": "MDU6TGFiZWw0NzMxNzMyNzI=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:feature", "name": "type:feature", "color": "159b2e", "default": false}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 11, "created_at": "2017-04-18T10:39:25Z", "updated_at": "2018-01-09T22:35:28Z", "closed_at": null, "author_association": "CONTRIBUTOR", "body_html": "<p><code>tf.where</code> does not support broadcasting like its numpy equivalent at the moment. How easy would it be to add broadcasting?</p>\n<p>Here are some examples.</p>\n<div class=\"highlight highlight-source-python\"><pre>condition <span class=\"pl-k\">=</span> np.random.normal(<span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">1</span>, (<span class=\"pl-c1\">3</span>, <span class=\"pl-c1\">5</span>, <span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">1</span>)) <span class=\"pl-k\">&lt;</span> <span class=\"pl-c1\">0</span>\nx <span class=\"pl-k\">=</span> np.zeros((<span class=\"pl-c1\">7</span>, <span class=\"pl-c1\">11</span>))\ny <span class=\"pl-k\">=</span> np.ones((<span class=\"pl-c1\">7</span>, <span class=\"pl-c1\">11</span>))\n\nnp.where(condition, x, y).shape  <span class=\"pl-c\"><span class=\"pl-c\">#</span> (3, 5, 7, 11)</span>\ntf.where(condition, x, y)\n\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> InvalidArgumentError: Shapes must be equal rank, but are <span class=\"pl-c1\">2</span> <span class=\"pl-k\">and</span> <span class=\"pl-c1\">4</span> <span class=\"pl-k\">for</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>Select_2<span class=\"pl-pds\">'</span></span> \n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> (op: <span class=\"pl-s\"><span class=\"pl-pds\">'</span>Select<span class=\"pl-pds\">'</span></span>)  <span class=\"pl-k\">with</span> <span class=\"pl-c1\">input</span> shapes: [<span class=\"pl-c1\">3</span>,<span class=\"pl-c1\">5</span>,<span class=\"pl-c1\">1</span>,<span class=\"pl-c1\">1</span>], [<span class=\"pl-c1\">7</span>,<span class=\"pl-c1\">11</span>], [<span class=\"pl-c1\">7</span>,<span class=\"pl-c1\">11</span>].</pre></div>\n<div class=\"highlight highlight-source-python\"><pre>condition <span class=\"pl-k\">=</span> np.random.normal(<span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">1</span>, (<span class=\"pl-c1\">3</span>, <span class=\"pl-c1\">5</span>, <span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">1</span>)) <span class=\"pl-k\">&lt;</span> <span class=\"pl-c1\">0</span>\nx <span class=\"pl-k\">=</span> np.zeros((<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">7</span>, <span class=\"pl-c1\">11</span>))\ny <span class=\"pl-k\">=</span> np.ones((<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">7</span>, <span class=\"pl-c1\">11</span>))\n\nnp.where(condition, x, y).shape  <span class=\"pl-c\"><span class=\"pl-c\">#</span> (3, 5, 7, 11)</span>\ntf.where(condition, x, y)\n\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> InvalidArgumentError: Dimension <span class=\"pl-c1\">0</span> <span class=\"pl-k\">in</span> both shapes must be equal, but are <span class=\"pl-c1\">1</span> <span class=\"pl-k\">and</span> <span class=\"pl-c1\">3</span> \n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> <span class=\"pl-k\">for</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>Select_3<span class=\"pl-pds\">'</span></span> (op: <span class=\"pl-s\"><span class=\"pl-pds\">'</span>Select<span class=\"pl-pds\">'</span></span>) <span class=\"pl-k\">with</span> <span class=\"pl-c1\">input</span> shapes: [<span class=\"pl-c1\">3</span>,<span class=\"pl-c1\">5</span>,<span class=\"pl-c1\">1</span>,<span class=\"pl-c1\">1</span>], [<span class=\"pl-c1\">1</span>,<span class=\"pl-c1\">1</span>,<span class=\"pl-c1\">7</span>,<span class=\"pl-c1\">11</span>], [<span class=\"pl-c1\">1</span>,<span class=\"pl-c1\">1</span>,<span class=\"pl-c1\">7</span>,<span class=\"pl-c1\">11</span>].</pre></div>", "body_text": "tf.where does not support broadcasting like its numpy equivalent at the moment. How easy would it be to add broadcasting?\nHere are some examples.\ncondition = np.random.normal(0, 1, (3, 5, 1, 1)) < 0\nx = np.zeros((7, 11))\ny = np.ones((7, 11))\n\nnp.where(condition, x, y).shape  # (3, 5, 7, 11)\ntf.where(condition, x, y)\n\n>>> InvalidArgumentError: Shapes must be equal rank, but are 2 and 4 for 'Select_2' \n>>> (op: 'Select')  with input shapes: [3,5,1,1], [7,11], [7,11].\ncondition = np.random.normal(0, 1, (3, 5, 1, 1)) < 0\nx = np.zeros((1, 1, 7, 11))\ny = np.ones((1, 1, 7, 11))\n\nnp.where(condition, x, y).shape  # (3, 5, 7, 11)\ntf.where(condition, x, y)\n\n>>> InvalidArgumentError: Dimension 0 in both shapes must be equal, but are 1 and 3 \n>>> for 'Select_3' (op: 'Select') with input shapes: [3,5,1,1], [1,1,7,11], [1,1,7,11].", "body": "`tf.where` does not support broadcasting like its numpy equivalent at the moment. How easy would it be to add broadcasting? \r\n\r\nHere are some examples.\r\n\r\n```python\r\ncondition = np.random.normal(0, 1, (3, 5, 1, 1)) < 0\r\nx = np.zeros((7, 11))\r\ny = np.ones((7, 11))\r\n\r\nnp.where(condition, x, y).shape  # (3, 5, 7, 11)\r\ntf.where(condition, x, y)\r\n\r\n>>> InvalidArgumentError: Shapes must be equal rank, but are 2 and 4 for 'Select_2' \r\n>>> (op: 'Select')  with input shapes: [3,5,1,1], [7,11], [7,11].\r\n```\r\n\r\n```python\r\ncondition = np.random.normal(0, 1, (3, 5, 1, 1)) < 0\r\nx = np.zeros((1, 1, 7, 11))\r\ny = np.ones((1, 1, 7, 11))\r\n\r\nnp.where(condition, x, y).shape  # (3, 5, 7, 11)\r\ntf.where(condition, x, y)\r\n\r\n>>> InvalidArgumentError: Dimension 0 in both shapes must be equal, but are 1 and 3 \r\n>>> for 'Select_3' (op: 'Select') with input shapes: [3,5,1,1], [1,1,7,11], [1,1,7,11].\r\n```\r\n"}