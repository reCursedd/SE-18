{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2473", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2473/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2473/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2473/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/2473", "id": 156246614, "node_id": "MDU6SXNzdWUxNTYyNDY2MTQ=", "number": 2473, "title": "Dynamic use of tensorflow.python.ops.array_ops.space_to_batch", "user": {"login": "ThomasWollmann", "id": 6473917, "node_id": "MDQ6VXNlcjY0NzM5MTc=", "avatar_url": "https://avatars2.githubusercontent.com/u/6473917?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ThomasWollmann", "html_url": "https://github.com/ThomasWollmann", "followers_url": "https://api.github.com/users/ThomasWollmann/followers", "following_url": "https://api.github.com/users/ThomasWollmann/following{/other_user}", "gists_url": "https://api.github.com/users/ThomasWollmann/gists{/gist_id}", "starred_url": "https://api.github.com/users/ThomasWollmann/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ThomasWollmann/subscriptions", "organizations_url": "https://api.github.com/users/ThomasWollmann/orgs", "repos_url": "https://api.github.com/users/ThomasWollmann/repos", "events_url": "https://api.github.com/users/ThomasWollmann/events{/privacy}", "received_events_url": "https://api.github.com/users/ThomasWollmann/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": {"login": "mrry", "id": 192142, "node_id": "MDQ6VXNlcjE5MjE0Mg==", "avatar_url": "https://avatars1.githubusercontent.com/u/192142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mrry", "html_url": "https://github.com/mrry", "followers_url": "https://api.github.com/users/mrry/followers", "following_url": "https://api.github.com/users/mrry/following{/other_user}", "gists_url": "https://api.github.com/users/mrry/gists{/gist_id}", "starred_url": "https://api.github.com/users/mrry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mrry/subscriptions", "organizations_url": "https://api.github.com/users/mrry/orgs", "repos_url": "https://api.github.com/users/mrry/repos", "events_url": "https://api.github.com/users/mrry/events{/privacy}", "received_events_url": "https://api.github.com/users/mrry/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "mrry", "id": 192142, "node_id": "MDQ6VXNlcjE5MjE0Mg==", "avatar_url": "https://avatars1.githubusercontent.com/u/192142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mrry", "html_url": "https://github.com/mrry", "followers_url": "https://api.github.com/users/mrry/followers", "following_url": "https://api.github.com/users/mrry/following{/other_user}", "gists_url": "https://api.github.com/users/mrry/gists{/gist_id}", "starred_url": "https://api.github.com/users/mrry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mrry/subscriptions", "organizations_url": "https://api.github.com/users/mrry/orgs", "repos_url": "https://api.github.com/users/mrry/repos", "events_url": "https://api.github.com/users/mrry/events{/privacy}", "received_events_url": "https://api.github.com/users/mrry/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 4, "created_at": "2016-05-23T10:16:40Z", "updated_at": "2016-05-26T22:08:11Z", "closed_at": "2016-05-26T22:08:11Z", "author_association": "NONE", "body_html": "<p>When calling \"tensorflow.python.ops.array_ops.space_to_batch\" in Python I need to specify the padding at compile time. In my use case I calculate the padding in the computation graph. Therefore it fails when I use a tensor as padding. I attached the stacktrace:</p>\n<pre><code>/home/user/anaconda2/lib/python2.7/site-packages/tensorflow/python/ops/gen_array_ops.pyc in space_to_batch(input, paddings, block_size, name)\n   1636   result = _op_def_lib.apply_op(\"SpaceToBatch\", input=input,\n   1637                                 paddings=paddings, block_size=block_size,\n-&gt; 1638                                 name=name)\n   1639   return result\n   1640 \n\n/home/user/anaconda2/lib/python2.7/site-packages/tensorflow/python/ops/op_def_library.pyc in apply_op(self, op_type_name, name, **keywords)\n    691           op = g.create_op(op_type_name, inputs, output_types, name=scope,\n    692                            input_types=input_types, attrs=attr_protos,\n--&gt; 693                            op_def=op_def)\n    694           outputs = op.outputs\n    695           return _Restructure(ops.convert_n_to_tensor(outputs),\n\n/home/user/anaconda2/lib/python2.7/site-packages/tensorflow/python/framework/ops.pyc in create_op(self, op_type, inputs, dtypes, input_types, name, attrs, op_def, compute_shapes, compute_device)\n   2186                     original_op=self._default_original_op, op_def=op_def)\n   2187     if compute_shapes:\n-&gt; 2188       set_shapes_for_outputs(ret)\n   2189     self._add_op(ret)\n   2190     self._record_op_seen_by_control_dependencies(ret)\n\n/home/user/anaconda2/lib/python2.7/site-packages/tensorflow/python/framework/ops.pyc in set_shapes_for_outputs(op)\n   1640       raise RuntimeError(\"No shape function registered for standard op: %s\"\n   1641                          % op.type)\n-&gt; 1642   shapes = shape_func(op)\n   1643   if len(op.outputs) != len(shapes):\n   1644     raise RuntimeError(\n\n/home/user/anaconda2/lib/python2.7/site-packages/tensorflow/python/ops/array_ops.pyc in _SpaceToBatchShape(op)\n   1630 \n   1631   paddings = tensor_util.constant_value(op.inputs[1])\n-&gt; 1632   if (paddings[0, 0] &lt; 0 or paddings[0, 1] &lt; 0 or\n   1633       paddings[1, 0] &lt; 0 or paddings[1, 1] &lt; 0):\n   1634     raise ValueError(\"paddings cannot be negative.\")\nTypeError: 'NoneType' object has no attribute '__getitem__'\n</code></pre>\n<p>I think it has something to do with the Python shape op. If so how can I override the existing shape op to test a new one with dynamic calculation?</p>", "body_text": "When calling \"tensorflow.python.ops.array_ops.space_to_batch\" in Python I need to specify the padding at compile time. In my use case I calculate the padding in the computation graph. Therefore it fails when I use a tensor as padding. I attached the stacktrace:\n/home/user/anaconda2/lib/python2.7/site-packages/tensorflow/python/ops/gen_array_ops.pyc in space_to_batch(input, paddings, block_size, name)\n   1636   result = _op_def_lib.apply_op(\"SpaceToBatch\", input=input,\n   1637                                 paddings=paddings, block_size=block_size,\n-> 1638                                 name=name)\n   1639   return result\n   1640 \n\n/home/user/anaconda2/lib/python2.7/site-packages/tensorflow/python/ops/op_def_library.pyc in apply_op(self, op_type_name, name, **keywords)\n    691           op = g.create_op(op_type_name, inputs, output_types, name=scope,\n    692                            input_types=input_types, attrs=attr_protos,\n--> 693                            op_def=op_def)\n    694           outputs = op.outputs\n    695           return _Restructure(ops.convert_n_to_tensor(outputs),\n\n/home/user/anaconda2/lib/python2.7/site-packages/tensorflow/python/framework/ops.pyc in create_op(self, op_type, inputs, dtypes, input_types, name, attrs, op_def, compute_shapes, compute_device)\n   2186                     original_op=self._default_original_op, op_def=op_def)\n   2187     if compute_shapes:\n-> 2188       set_shapes_for_outputs(ret)\n   2189     self._add_op(ret)\n   2190     self._record_op_seen_by_control_dependencies(ret)\n\n/home/user/anaconda2/lib/python2.7/site-packages/tensorflow/python/framework/ops.pyc in set_shapes_for_outputs(op)\n   1640       raise RuntimeError(\"No shape function registered for standard op: %s\"\n   1641                          % op.type)\n-> 1642   shapes = shape_func(op)\n   1643   if len(op.outputs) != len(shapes):\n   1644     raise RuntimeError(\n\n/home/user/anaconda2/lib/python2.7/site-packages/tensorflow/python/ops/array_ops.pyc in _SpaceToBatchShape(op)\n   1630 \n   1631   paddings = tensor_util.constant_value(op.inputs[1])\n-> 1632   if (paddings[0, 0] < 0 or paddings[0, 1] < 0 or\n   1633       paddings[1, 0] < 0 or paddings[1, 1] < 0):\n   1634     raise ValueError(\"paddings cannot be negative.\")\nTypeError: 'NoneType' object has no attribute '__getitem__'\n\nI think it has something to do with the Python shape op. If so how can I override the existing shape op to test a new one with dynamic calculation?", "body": "When calling \"tensorflow.python.ops.array_ops.space_to_batch\" in Python I need to specify the padding at compile time. In my use case I calculate the padding in the computation graph. Therefore it fails when I use a tensor as padding. I attached the stacktrace:\n\n```\n/home/user/anaconda2/lib/python2.7/site-packages/tensorflow/python/ops/gen_array_ops.pyc in space_to_batch(input, paddings, block_size, name)\n   1636   result = _op_def_lib.apply_op(\"SpaceToBatch\", input=input,\n   1637                                 paddings=paddings, block_size=block_size,\n-> 1638                                 name=name)\n   1639   return result\n   1640 \n\n/home/user/anaconda2/lib/python2.7/site-packages/tensorflow/python/ops/op_def_library.pyc in apply_op(self, op_type_name, name, **keywords)\n    691           op = g.create_op(op_type_name, inputs, output_types, name=scope,\n    692                            input_types=input_types, attrs=attr_protos,\n--> 693                            op_def=op_def)\n    694           outputs = op.outputs\n    695           return _Restructure(ops.convert_n_to_tensor(outputs),\n\n/home/user/anaconda2/lib/python2.7/site-packages/tensorflow/python/framework/ops.pyc in create_op(self, op_type, inputs, dtypes, input_types, name, attrs, op_def, compute_shapes, compute_device)\n   2186                     original_op=self._default_original_op, op_def=op_def)\n   2187     if compute_shapes:\n-> 2188       set_shapes_for_outputs(ret)\n   2189     self._add_op(ret)\n   2190     self._record_op_seen_by_control_dependencies(ret)\n\n/home/user/anaconda2/lib/python2.7/site-packages/tensorflow/python/framework/ops.pyc in set_shapes_for_outputs(op)\n   1640       raise RuntimeError(\"No shape function registered for standard op: %s\"\n   1641                          % op.type)\n-> 1642   shapes = shape_func(op)\n   1643   if len(op.outputs) != len(shapes):\n   1644     raise RuntimeError(\n\n/home/user/anaconda2/lib/python2.7/site-packages/tensorflow/python/ops/array_ops.pyc in _SpaceToBatchShape(op)\n   1630 \n   1631   paddings = tensor_util.constant_value(op.inputs[1])\n-> 1632   if (paddings[0, 0] < 0 or paddings[0, 1] < 0 or\n   1633       paddings[1, 0] < 0 or paddings[1, 1] < 0):\n   1634     raise ValueError(\"paddings cannot be negative.\")\nTypeError: 'NoneType' object has no attribute '__getitem__'\n```\n\nI think it has something to do with the Python shape op. If so how can I override the existing shape op to test a new one with dynamic calculation?\n"}