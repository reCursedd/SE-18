{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/400398983", "html_url": "https://github.com/tensorflow/tensorflow/issues/19583#issuecomment-400398983", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/19583", "id": 400398983, "node_id": "MDEyOklzc3VlQ29tbWVudDQwMDM5ODk4Mw==", "user": {"login": "MartinAbilev", "id": 8553447, "node_id": "MDQ6VXNlcjg1NTM0NDc=", "avatar_url": "https://avatars3.githubusercontent.com/u/8553447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/MartinAbilev", "html_url": "https://github.com/MartinAbilev", "followers_url": "https://api.github.com/users/MartinAbilev/followers", "following_url": "https://api.github.com/users/MartinAbilev/following{/other_user}", "gists_url": "https://api.github.com/users/MartinAbilev/gists{/gist_id}", "starred_url": "https://api.github.com/users/MartinAbilev/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/MartinAbilev/subscriptions", "organizations_url": "https://api.github.com/users/MartinAbilev/orgs", "repos_url": "https://api.github.com/users/MartinAbilev/repos", "events_url": "https://api.github.com/users/MartinAbilev/events{/privacy}", "received_events_url": "https://api.github.com/users/MartinAbilev/received_events", "type": "User", "site_admin": false}, "created_at": "2018-06-26T17:31:50Z", "updated_at": "2018-06-26T17:33:27Z", "author_association": "NONE", "body_html": "<p>i disabled in .....\\tensorflow\\third_party\\repo.bzl  lines  87-88 where it try apply <code>patch</code> command nonexisting on windows</p>\n<pre><code>#  if ctx.attr.patch_file != None:\n#    _apply_patch(ctx, ctx.attr.patch_file)\n</code></pre>\n<p>now my repo.bzl looks like</p>\n<pre><code># Copyright 2017 The TensorFlow Authors. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Utilities for defining TensorFlow Bazel dependencies.\"\"\"\n\n_SINGLE_URL_WHITELIST = depset([\n    \"arm_compiler\",\n    \"ortools_archive\",\n])\n\ndef _is_windows(ctx):\n  return ctx.os.name.lower().find(\"windows\") != -1\n\ndef _wrap_bash_cmd(ctx, cmd):\n  if _is_windows(ctx):\n    bazel_sh = _get_env_var(ctx, \"BAZEL_SH\")\n    if not bazel_sh:\n      fail(\"BAZEL_SH environment variable is not set\")\n    cmd = [bazel_sh, \"-l\", \"-c\", \" \".join(cmd)]\n  return cmd\n\ndef _get_env_var(ctx, name):\n  if name in ctx.os.environ:\n    return ctx.os.environ[name]\n  else:\n    return None\n\n# Executes specified command with arguments and calls 'fail' if it exited with\n# non-zero code\ndef _execute_and_check_ret_code(repo_ctx, cmd_and_args):\n  result = repo_ctx.execute(cmd_and_args, timeout=10)\n  if result.return_code != 0:\n    fail((\"Non-zero return code({1}) when executing '{0}':\\n\" + \"Stdout: {2}\\n\"\n          + \"Stderr: {3}\").format(\" \".join(cmd_and_args), result.return_code,\n                                  result.stdout, result.stderr))\n\ndef _repos_are_siblings():\n  return Label(\"@foo//bar\").workspace_root.startswith(\"../\")\n\n# Apply a patch_file to the repository root directory\n# Runs 'patch -p1'\ndef _apply_patch(ctx, patch_file):\n  # Don't check patch on Windows, because patch is only available under bash.\n  if not _is_windows(ctx) and not ctx.which(\"patch\"):\n    fail(\"patch command is not found, please install it\")\n  cmd = _wrap_bash_cmd(\n    ctx, [\"patch\", \"-p1\", \"-d\", ctx.path(\".\"), \"-i\", ctx.path(patch_file)])\n  _execute_and_check_ret_code(ctx, cmd)\n\ndef _apply_delete(ctx, paths):\n  for path in paths:\n    if path.startswith(\"/\"):\n      fail(\"refusing to rm -rf path starting with '/': \" + path)\n    if \"..\" in path:\n      fail(\"refusing to rm -rf path containing '..': \" + path)\n  cmd = _wrap_bash_cmd(ctx, [\"rm\", \"-rf\"] + [ctx.path(path) for path in paths])\n  _execute_and_check_ret_code(ctx, cmd)\n\ndef _tf_http_archive(ctx):\n  if (\"mirror.bazel.build\" not in ctx.attr.urls[0] and\n      (len(ctx.attr.urls) &lt; 2 and\n       ctx.attr.name not in _SINGLE_URL_WHITELIST)):\n    fail(\"tf_http_archive(urls) must have redundant URLs. The \" +\n         \"mirror.bazel.build URL must be present and it must come first. \" +\n         \"Even if you don't have permission to mirror the file, please \" +\n         \"put the correctly formatted mirror URL there anyway, because \" +\n         \"someone will come along shortly thereafter and mirror the file.\")\n  ctx.download_and_extract(\n      ctx.attr.urls,\n      \"\",\n      ctx.attr.sha256,\n      ctx.attr.type,\n      ctx.attr.strip_prefix)\n  if ctx.attr.delete:\n    _apply_delete(ctx, ctx.attr.delete)\n#  if ctx.attr.patch_file != None:\n#    _apply_patch(ctx, ctx.attr.patch_file)\n  if ctx.attr.build_file != None:\n    # Use BUILD.bazel to avoid conflict with third party projects with\n    # BUILD or build (directory) underneath.\n    ctx.template(\"BUILD.bazel\", ctx.attr.build_file, {\n        \"%prefix%\": \"..\" if _repos_are_siblings() else \"external\",\n    }, False)\n\ntf_http_archive = repository_rule(\n    implementation=_tf_http_archive,\n    attrs={\n        \"sha256\": attr.string(mandatory=True),\n        \"urls\": attr.string_list(mandatory=True, allow_empty=False),\n        \"strip_prefix\": attr.string(),\n        \"type\": attr.string(),\n        \"delete\": attr.string_list(),\n        \"patch_file\": attr.label(),\n        \"build_file\": attr.label(),\n    })\n\"\"\"Downloads and creates Bazel repos for dependencies.\n\nThis is a swappable replacement for both http_archive() and\nnew_http_archive() that offers some additional features. It also helps\nensure best practices are followed.\n\"\"\"\n</code></pre>", "body_text": "i disabled in .....\\tensorflow\\third_party\\repo.bzl  lines  87-88 where it try apply patch command nonexisting on windows\n#  if ctx.attr.patch_file != None:\n#    _apply_patch(ctx, ctx.attr.patch_file)\n\nnow my repo.bzl looks like\n# Copyright 2017 The TensorFlow Authors. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Utilities for defining TensorFlow Bazel dependencies.\"\"\"\n\n_SINGLE_URL_WHITELIST = depset([\n    \"arm_compiler\",\n    \"ortools_archive\",\n])\n\ndef _is_windows(ctx):\n  return ctx.os.name.lower().find(\"windows\") != -1\n\ndef _wrap_bash_cmd(ctx, cmd):\n  if _is_windows(ctx):\n    bazel_sh = _get_env_var(ctx, \"BAZEL_SH\")\n    if not bazel_sh:\n      fail(\"BAZEL_SH environment variable is not set\")\n    cmd = [bazel_sh, \"-l\", \"-c\", \" \".join(cmd)]\n  return cmd\n\ndef _get_env_var(ctx, name):\n  if name in ctx.os.environ:\n    return ctx.os.environ[name]\n  else:\n    return None\n\n# Executes specified command with arguments and calls 'fail' if it exited with\n# non-zero code\ndef _execute_and_check_ret_code(repo_ctx, cmd_and_args):\n  result = repo_ctx.execute(cmd_and_args, timeout=10)\n  if result.return_code != 0:\n    fail((\"Non-zero return code({1}) when executing '{0}':\\n\" + \"Stdout: {2}\\n\"\n          + \"Stderr: {3}\").format(\" \".join(cmd_and_args), result.return_code,\n                                  result.stdout, result.stderr))\n\ndef _repos_are_siblings():\n  return Label(\"@foo//bar\").workspace_root.startswith(\"../\")\n\n# Apply a patch_file to the repository root directory\n# Runs 'patch -p1'\ndef _apply_patch(ctx, patch_file):\n  # Don't check patch on Windows, because patch is only available under bash.\n  if not _is_windows(ctx) and not ctx.which(\"patch\"):\n    fail(\"patch command is not found, please install it\")\n  cmd = _wrap_bash_cmd(\n    ctx, [\"patch\", \"-p1\", \"-d\", ctx.path(\".\"), \"-i\", ctx.path(patch_file)])\n  _execute_and_check_ret_code(ctx, cmd)\n\ndef _apply_delete(ctx, paths):\n  for path in paths:\n    if path.startswith(\"/\"):\n      fail(\"refusing to rm -rf path starting with '/': \" + path)\n    if \"..\" in path:\n      fail(\"refusing to rm -rf path containing '..': \" + path)\n  cmd = _wrap_bash_cmd(ctx, [\"rm\", \"-rf\"] + [ctx.path(path) for path in paths])\n  _execute_and_check_ret_code(ctx, cmd)\n\ndef _tf_http_archive(ctx):\n  if (\"mirror.bazel.build\" not in ctx.attr.urls[0] and\n      (len(ctx.attr.urls) < 2 and\n       ctx.attr.name not in _SINGLE_URL_WHITELIST)):\n    fail(\"tf_http_archive(urls) must have redundant URLs. The \" +\n         \"mirror.bazel.build URL must be present and it must come first. \" +\n         \"Even if you don't have permission to mirror the file, please \" +\n         \"put the correctly formatted mirror URL there anyway, because \" +\n         \"someone will come along shortly thereafter and mirror the file.\")\n  ctx.download_and_extract(\n      ctx.attr.urls,\n      \"\",\n      ctx.attr.sha256,\n      ctx.attr.type,\n      ctx.attr.strip_prefix)\n  if ctx.attr.delete:\n    _apply_delete(ctx, ctx.attr.delete)\n#  if ctx.attr.patch_file != None:\n#    _apply_patch(ctx, ctx.attr.patch_file)\n  if ctx.attr.build_file != None:\n    # Use BUILD.bazel to avoid conflict with third party projects with\n    # BUILD or build (directory) underneath.\n    ctx.template(\"BUILD.bazel\", ctx.attr.build_file, {\n        \"%prefix%\": \"..\" if _repos_are_siblings() else \"external\",\n    }, False)\n\ntf_http_archive = repository_rule(\n    implementation=_tf_http_archive,\n    attrs={\n        \"sha256\": attr.string(mandatory=True),\n        \"urls\": attr.string_list(mandatory=True, allow_empty=False),\n        \"strip_prefix\": attr.string(),\n        \"type\": attr.string(),\n        \"delete\": attr.string_list(),\n        \"patch_file\": attr.label(),\n        \"build_file\": attr.label(),\n    })\n\"\"\"Downloads and creates Bazel repos for dependencies.\n\nThis is a swappable replacement for both http_archive() and\nnew_http_archive() that offers some additional features. It also helps\nensure best practices are followed.\n\"\"\"", "body": "i disabled in .....\\tensorflow\\third_party\\repo.bzl  lines  87-88 where it try apply `patch` command nonexisting on windows\r\n\r\n```\r\n#  if ctx.attr.patch_file != None:\r\n#    _apply_patch(ctx, ctx.attr.patch_file)\r\n```\r\n\r\nnow my repo.bzl looks like\r\n```\r\n# Copyright 2017 The TensorFlow Authors. All rights reserved.\r\n#\r\n# Licensed under the Apache License, Version 2.0 (the \"License\");\r\n# you may not use this file except in compliance with the License.\r\n# You may obtain a copy of the License at\r\n#\r\n#    http://www.apache.org/licenses/LICENSE-2.0\r\n#\r\n# Unless required by applicable law or agreed to in writing, software\r\n# distributed under the License is distributed on an \"AS IS\" BASIS,\r\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n# See the License for the specific language governing permissions and\r\n# limitations under the License.\r\n\r\n\"\"\"Utilities for defining TensorFlow Bazel dependencies.\"\"\"\r\n\r\n_SINGLE_URL_WHITELIST = depset([\r\n    \"arm_compiler\",\r\n    \"ortools_archive\",\r\n])\r\n\r\ndef _is_windows(ctx):\r\n  return ctx.os.name.lower().find(\"windows\") != -1\r\n\r\ndef _wrap_bash_cmd(ctx, cmd):\r\n  if _is_windows(ctx):\r\n    bazel_sh = _get_env_var(ctx, \"BAZEL_SH\")\r\n    if not bazel_sh:\r\n      fail(\"BAZEL_SH environment variable is not set\")\r\n    cmd = [bazel_sh, \"-l\", \"-c\", \" \".join(cmd)]\r\n  return cmd\r\n\r\ndef _get_env_var(ctx, name):\r\n  if name in ctx.os.environ:\r\n    return ctx.os.environ[name]\r\n  else:\r\n    return None\r\n\r\n# Executes specified command with arguments and calls 'fail' if it exited with\r\n# non-zero code\r\ndef _execute_and_check_ret_code(repo_ctx, cmd_and_args):\r\n  result = repo_ctx.execute(cmd_and_args, timeout=10)\r\n  if result.return_code != 0:\r\n    fail((\"Non-zero return code({1}) when executing '{0}':\\n\" + \"Stdout: {2}\\n\"\r\n          + \"Stderr: {3}\").format(\" \".join(cmd_and_args), result.return_code,\r\n                                  result.stdout, result.stderr))\r\n\r\ndef _repos_are_siblings():\r\n  return Label(\"@foo//bar\").workspace_root.startswith(\"../\")\r\n\r\n# Apply a patch_file to the repository root directory\r\n# Runs 'patch -p1'\r\ndef _apply_patch(ctx, patch_file):\r\n  # Don't check patch on Windows, because patch is only available under bash.\r\n  if not _is_windows(ctx) and not ctx.which(\"patch\"):\r\n    fail(\"patch command is not found, please install it\")\r\n  cmd = _wrap_bash_cmd(\r\n    ctx, [\"patch\", \"-p1\", \"-d\", ctx.path(\".\"), \"-i\", ctx.path(patch_file)])\r\n  _execute_and_check_ret_code(ctx, cmd)\r\n\r\ndef _apply_delete(ctx, paths):\r\n  for path in paths:\r\n    if path.startswith(\"/\"):\r\n      fail(\"refusing to rm -rf path starting with '/': \" + path)\r\n    if \"..\" in path:\r\n      fail(\"refusing to rm -rf path containing '..': \" + path)\r\n  cmd = _wrap_bash_cmd(ctx, [\"rm\", \"-rf\"] + [ctx.path(path) for path in paths])\r\n  _execute_and_check_ret_code(ctx, cmd)\r\n\r\ndef _tf_http_archive(ctx):\r\n  if (\"mirror.bazel.build\" not in ctx.attr.urls[0] and\r\n      (len(ctx.attr.urls) < 2 and\r\n       ctx.attr.name not in _SINGLE_URL_WHITELIST)):\r\n    fail(\"tf_http_archive(urls) must have redundant URLs. The \" +\r\n         \"mirror.bazel.build URL must be present and it must come first. \" +\r\n         \"Even if you don't have permission to mirror the file, please \" +\r\n         \"put the correctly formatted mirror URL there anyway, because \" +\r\n         \"someone will come along shortly thereafter and mirror the file.\")\r\n  ctx.download_and_extract(\r\n      ctx.attr.urls,\r\n      \"\",\r\n      ctx.attr.sha256,\r\n      ctx.attr.type,\r\n      ctx.attr.strip_prefix)\r\n  if ctx.attr.delete:\r\n    _apply_delete(ctx, ctx.attr.delete)\r\n#  if ctx.attr.patch_file != None:\r\n#    _apply_patch(ctx, ctx.attr.patch_file)\r\n  if ctx.attr.build_file != None:\r\n    # Use BUILD.bazel to avoid conflict with third party projects with\r\n    # BUILD or build (directory) underneath.\r\n    ctx.template(\"BUILD.bazel\", ctx.attr.build_file, {\r\n        \"%prefix%\": \"..\" if _repos_are_siblings() else \"external\",\r\n    }, False)\r\n\r\ntf_http_archive = repository_rule(\r\n    implementation=_tf_http_archive,\r\n    attrs={\r\n        \"sha256\": attr.string(mandatory=True),\r\n        \"urls\": attr.string_list(mandatory=True, allow_empty=False),\r\n        \"strip_prefix\": attr.string(),\r\n        \"type\": attr.string(),\r\n        \"delete\": attr.string_list(),\r\n        \"patch_file\": attr.label(),\r\n        \"build_file\": attr.label(),\r\n    })\r\n\"\"\"Downloads and creates Bazel repos for dependencies.\r\n\r\nThis is a swappable replacement for both http_archive() and\r\nnew_http_archive() that offers some additional features. It also helps\r\nensure best practices are followed.\r\n\"\"\"\r\n```"}