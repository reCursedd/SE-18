{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/297664377", "html_url": "https://github.com/tensorflow/tensorflow/pull/9432#issuecomment-297664377", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9432", "id": 297664377, "node_id": "MDEyOklzc3VlQ29tbWVudDI5NzY2NDM3Nw==", "user": {"login": "shamoya", "id": 22274255, "node_id": "MDQ6VXNlcjIyMjc0MjU1", "avatar_url": "https://avatars2.githubusercontent.com/u/22274255?v=4", "gravatar_id": "", "url": "https://api.github.com/users/shamoya", "html_url": "https://github.com/shamoya", "followers_url": "https://api.github.com/users/shamoya/followers", "following_url": "https://api.github.com/users/shamoya/following{/other_user}", "gists_url": "https://api.github.com/users/shamoya/gists{/gist_id}", "starred_url": "https://api.github.com/users/shamoya/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/shamoya/subscriptions", "organizations_url": "https://api.github.com/users/shamoya/orgs", "repos_url": "https://api.github.com/users/shamoya/repos", "events_url": "https://api.github.com/users/shamoya/events{/privacy}", "received_events_url": "https://api.github.com/users/shamoya/received_events", "type": "User", "site_admin": false}, "created_at": "2017-04-27T09:34:37Z", "updated_at": "2017-04-27T09:35:57Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Hi <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=12075848\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/junshi15\">@junshi15</a>  <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=1207763\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/li-ch\">@li-ch</a> <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=170179\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/jhseu\">@jhseu</a> <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=15676913\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/poxvoculi\">@poxvoculi</a> <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=22419555\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/bkovalev\">@bkovalev</a>,</p>\n<p>After thinking about it in the last day, we must move to rdmacm for the connection management part !<br>\nThis makes much more sense and the the correct way to code verbs applications.</p>\n<p>This way rdmacm will configure the correct rdma device and port, according to the gRPC channels given by the user in the cluster definition (the rdma device+port which belongs to the IP Address of each server in cluster specification will be chosen and configured correctly by a code that specialized in it).</p>\n<p>This will also eliminate the need for this code, as rdmacm will configure anything needed for the connection according to the link detected (IB or Ethernet) on the corresponding interface of the specified gRPC channel, and if Ethernet it will also take care of  RoCE V0/V1/V2 configuration according to user desired choice (The user configures the GID tables specifying which RoCE mode to configure for each gid index, and you also don't need to configure all the hop_limit and other low level values).</p>\n<p>rdmacm knows the best how to configure everything in the connection (you don't need to set all the fields in ah_attr or even pass the QPs between its states) and it's a well maintained code by the rdma community - <a href=\"https://github.com/linux-rdma/rdma-core/tree/master/librdmacm\">https://github.com/linux-rdma/rdma-core/tree/master/librdmacm</a></p>\n<p>Also this way I don't need the user the specify the rdma/port from the Server definition in the python.<br>\nThis is the way to go also when you use the same cluster for Ethernet and IB (different adapters).</p>\n<p>I can start working on it immediately and shouldn't take long (few days).<br>\nSo what do you think ?</p>", "body_text": "Hi @junshi15  @li-ch @jhseu @poxvoculi @bkovalev,\nAfter thinking about it in the last day, we must move to rdmacm for the connection management part !\nThis makes much more sense and the the correct way to code verbs applications.\nThis way rdmacm will configure the correct rdma device and port, according to the gRPC channels given by the user in the cluster definition (the rdma device+port which belongs to the IP Address of each server in cluster specification will be chosen and configured correctly by a code that specialized in it).\nThis will also eliminate the need for this code, as rdmacm will configure anything needed for the connection according to the link detected (IB or Ethernet) on the corresponding interface of the specified gRPC channel, and if Ethernet it will also take care of  RoCE V0/V1/V2 configuration according to user desired choice (The user configures the GID tables specifying which RoCE mode to configure for each gid index, and you also don't need to configure all the hop_limit and other low level values).\nrdmacm knows the best how to configure everything in the connection (you don't need to set all the fields in ah_attr or even pass the QPs between its states) and it's a well maintained code by the rdma community - https://github.com/linux-rdma/rdma-core/tree/master/librdmacm\nAlso this way I don't need the user the specify the rdma/port from the Server definition in the python.\nThis is the way to go also when you use the same cluster for Ethernet and IB (different adapters).\nI can start working on it immediately and shouldn't take long (few days).\nSo what do you think ?", "body": "Hi @junshi15  @li-ch @jhseu @poxvoculi @bkovalev,\r\n\r\nAfter thinking about it in the last day, we must move to rdmacm for the connection management part !\r\nThis makes much more sense and the the correct way to code verbs applications.\r\n\r\nThis way rdmacm will configure the correct rdma device and port, according to the gRPC channels given by the user in the cluster definition (the rdma device+port which belongs to the IP Address of each server in cluster specification will be chosen and configured correctly by a code that specialized in it).\r\n\r\nThis will also eliminate the need for this code, as rdmacm will configure anything needed for the connection according to the link detected (IB or Ethernet) on the corresponding interface of the specified gRPC channel, and if Ethernet it will also take care of  RoCE V0/V1/V2 configuration according to user desired choice (The user configures the GID tables specifying which RoCE mode to configure for each gid index, and you also don't need to configure all the hop_limit and other low level values).\r\n\r\nrdmacm knows the best how to configure everything in the connection (you don't need to set all the fields in ah_attr or even pass the QPs between its states) and it's a well maintained code by the rdma community - https://github.com/linux-rdma/rdma-core/tree/master/librdmacm\r\n\r\nAlso this way I don't need the user the specify the rdma/port from the Server definition in the python.\r\nThis is the way to go also when you use the same cluster for Ethernet and IB (different adapters).\r\n\r\nI can start working on it immediately and shouldn't take long (few days).\r\nSo what do you think ? "}