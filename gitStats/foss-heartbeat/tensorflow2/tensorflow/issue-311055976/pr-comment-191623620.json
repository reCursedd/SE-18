{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/191623620", "pull_request_review_id": 124228549, "id": 191623620, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTYyMzYyMA==", "diff_hunk": "@@ -0,0 +1,476 @@\n+from __future__ import absolute_import\n+from __future__ import division\n+from __future__ import print_function\n+\n+import collections\n+import os\n+import re\n+\n+from tensorflow.python.eager import context as _context\n+from tensorflow.python.eager import execute as _execute\n+\n+from tensorflow.python.framework import constant_op\n+from tensorflow.python.framework import dtypes\n+from tensorflow.python.framework import ops\n+from tensorflow.python.framework import sparse_tensor\n+from tensorflow.python.framework import tensor_shape\n+\n+from tensorflow.python.framework import load_library\n+from tensorflow.core.framework import attr_value_pb2 as _attr_value_pb2\n+from tensorflow.core.framework import op_def_pb2 as _op_def_pb2\n+from tensorflow.core.framework import types_pb2 as _types_pb2\n+\n+from tensorflow.python.ops import array_ops\n+from tensorflow.python.ops.parsing_ops import _features_to_raw_params, _prepend_none_dimension, VarLenFeature, \\\n+    SparseFeature, FixedLenFeature, FixedLenSequenceFeature, _construct_sparse_tensors_for_sparse_features\n+\n+# HACK: Change to tensorflow.contrib.avro when tensorflow/contrib/__init__.py\n+from tensorflow.contrib.avro.python.avro_record_dataset import _create_op_def_library\n+\n+# Load the shared library\n+this_dir = os.path.dirname(os.path.abspath(__file__))\n+lib_name = os.path.join(this_dir, '_parse_avro_record.so')  # Display the operators with lib_name.OP_LIST\n+parse_module = load_library.load_op_library(lib_name)  # Load the library with dependent so's in '.'\n+\n+\n+def parse_avro_record(serialized, schema, features):\n+    \"\"\"\n+    Parses serialized avro records into TensorFlow tensors. This method also handles a batch of serialized records and\n+    returns tensors with the batch added as first dimension.\n+\n+    :param serialized: The serialized avro record(s) as TensorFlow string(s).\n+\n+    :param schema: This is the schema that these records where serialized with. Schema resolution is not supported here\n+                   but in the AvroRecordReader.\n+\n+    :param features: Is a map of keys that describe a single entry or sparse vector in the avro record and map that\n+                     entry to a tensor. The syntax is as follows:\n+\n+                     features = {'my_meta_data/size': tf.FixedLenFeature([], tf.int64)}\n+\n+                        Select the 'size' field from a record metadata that is in the field 'my_meta_data'. In this\n+                        example we assume that the size is encoded as a long in the Avro record for the metadata.\n+\n+\n+                     features = {'my_map_data/['source']/ip_addresses': tf.VarLenFeature([], tf.string)}\n+\n+                        Select the 'ip_addresses' for the 'source' key in the map 'my_map_data'. Notice we assume that\n+                        IP addresses are encoded as strings.\n+\n+\n+                     features = {'my_friends/[1]/first_name': tf.FixedLenFeature([], tf.string)}\n+\n+                        Select the 'first_name' for the second friend with index '1'. This assumes that all of your data\n+                        has a second friend. In addition, we assume that all friends have only one first name. For this\n+                        reason we chose a 'FixedLenFeature'.\n+\n+\n+                     features = {'my_friends/[*]/first_name': tf.VarLenFeature([], tf.string)}\n+\n+                        Select all first_names in each row. For this example we use the wildcard '*' to indicate that\n+                        we want to select all 'first_name' entries from the array.\n+\n+\n+                     features = {'sparse_features': tf.SparseFeature(index_key='index', value_key='value',\n+                                dtype=tf.float32, size=10)}\n+\n+                        We assume that sparse features contains an array with records that contain an 'index' field\n+                        that MUST BE LONG and an 'value' field with floats (single precision).\n+\n+    :return: A map of with the same key as in features and that has the corresponding tensors as values.\n+    \"\"\"\n+\n+    # Code from https://github.com/tensorflow/tensorflow/blob/v1.4.1/tensorflow/python/ops/parsing_ops.py\n+    # For now I copied from these two methods 'parse_example' and '_parse_example_raw'\n+    # The TensorFlow source code could be refactored to fully integrate the avro parser and avoid copying code!\n+\n+    if not features:\n+        raise ValueError(\"Missing: features was '{}'.\".format(features))\n+    if not schema:\n+        raise ValueError(\"Missing: schema was '{}'\".format(schema))\n+\n+    features = _prepend_none_dimension(features)\n+    # ******************** START difference: This part is different from the originally copied code ********************\n+    features = _build_keys_for_sparse_features(features)", "path": "tensorflow/contrib/avro/python/parse_avro_record.py", "position": 98, "original_position": 94, "commit_id": "bdf790d5c888e59d593230286edaaf5314daaee5", "original_commit_id": "abf605ba22c95f52116b765c90f889b9f17692c1", "user": {"login": "fraudies", "id": 1770877, "node_id": "MDQ6VXNlcjE3NzA4Nzc=", "avatar_url": "https://avatars0.githubusercontent.com/u/1770877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fraudies", "html_url": "https://github.com/fraudies", "followers_url": "https://api.github.com/users/fraudies/followers", "following_url": "https://api.github.com/users/fraudies/following{/other_user}", "gists_url": "https://api.github.com/users/fraudies/gists{/gist_id}", "starred_url": "https://api.github.com/users/fraudies/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fraudies/subscriptions", "organizations_url": "https://api.github.com/users/fraudies/orgs", "repos_url": "https://api.github.com/users/fraudies/repos", "events_url": "https://api.github.com/users/fraudies/events{/privacy}", "received_events_url": "https://api.github.com/users/fraudies/received_events", "type": "User", "site_admin": false}, "body": "There are some differences (e.g. the regex for the tensor naming).  But some common code could be leveraged if we decide to break-up the existing python implementation for the protobuf format into sub-methods.", "created_at": "2018-05-30T01:57:40Z", "updated_at": "2018-10-22T21:28:38Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/18224#discussion_r191623620", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/18224", "author_association": "NONE", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/191623620"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/18224#discussion_r191623620"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/18224"}}, "body_html": "<p>There are some differences (e.g. the regex for the tensor naming).  But some common code could be leveraged if we decide to break-up the existing python implementation for the protobuf format into sub-methods.</p>", "body_text": "There are some differences (e.g. the regex for the tensor naming).  But some common code could be leveraged if we decide to break-up the existing python implementation for the protobuf format into sub-methods.", "in_reply_to_id": 180941893}