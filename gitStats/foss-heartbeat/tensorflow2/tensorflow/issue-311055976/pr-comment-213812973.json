{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/213812973", "pull_request_review_id": 150728440, "id": 213812973, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzgxMjk3Mw==", "diff_hunk": "@@ -0,0 +1,224 @@\n+# Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+# ==============================================================================\n+import collections\n+import os\n+import re\n+\n+from tensorflow.python.framework import constant_op\n+from tensorflow.python.framework import dtypes\n+from tensorflow.python.framework import ops\n+from tensorflow.python.framework import sparse_tensor\n+from tensorflow.python.framework import tensor_shape\n+\n+from tensorflow.python.framework import load_library\n+from tensorflow.python.ops import array_ops\n+from tensorflow.python.ops.parsing_ops import _features_to_raw_params, \\\n+    _prepend_none_dimension, VarLenFeature, SparseFeature, FixedLenFeature, \\\n+    FixedLenSequenceFeature, _construct_sparse_tensors_for_sparse_features\n+from tensorflow.contrib.avro.ops.gen_parse_avro_record import \\\n+    parse_avro_record as _parse_avro_record\n+\n+# Load the shared library\n+this_dir = os.path.dirname(os.path.abspath(__file__))\n+lib_name = os.path.join(\n+    this_dir,\n+    '_parse_avro_record.so')  # Display the operators with lib_name.OP_LIST\n+parse_module = load_library.load_op_library(\n+    lib_name)  # Load the library with dependent so's in '.'\n+\n+\n+def parse_avro_record(serialized, schema, features):\n+    \"\"\"\n+    Parses serialized avro records into TensorFlow tensors. This method also handles a batch of serialized records and\n+    returns tensors with the batch added as first dimension.\n+\n+    :param serialized: The serialized avro record(s) as TensorFlow string(s).\n+\n+    :param schema: This is the schema that these records where serialized with. Schema resolution is not supported here\n+                   but in the AvroRecordReader.\n+\n+    :param features: Is a map of keys that describe a single entry or sparse vector in the avro record and map that\n+                     entry to a tensor. The syntax is as follows:\n+\n+                     features = {'my_meta_data.size': tf.FixedLenFeature([], tf.int64)}\n+\n+                        Select the 'size' field from a record metadata that is in the field 'my_meta_data'. In this\n+                        example we assume that the size is encoded as a long in the Avro record for the metadata.\n+\n+\n+                     features = {'my_map_data.['source'].ip_addresses': tf.VarLenFeature([], tf.string)}\n+\n+                        Select the 'ip_addresses' for the 'source' key in the map 'my_map_data'. Notice we assume that\n+                        IP addresses are encoded as strings.\n+\n+\n+                     features = {'my_friends.[1].first_name': tf.FixedLenFeature([], tf.string)}\n+\n+                        Select the 'first_name' for the second friend with index '1'. This assumes that all of your data\n+                        has a second friend. In addition, we assume that all friends have only one first name. For this\n+                        reason we chose a 'FixedLenFeature'.\n+\n+\n+                     features = {'my_friends.[*].first_name': tf.VarLenFeature([], tf.string)}\n+\n+                        Select all first_names in each row. For this example we use the wildcard '*' to indicate that\n+                        we want to select all 'first_name' entries from the array.\n+\n+\n+                     features = {'sparse_features': tf.SparseFeature(index_key='index', value_key='value',\n+                                dtype=tf.float32, size=10)}\n+\n+                        We assume that sparse features contains an array with records that contain an 'index' field\n+                        that MUST BE LONG and an 'value' field with floats (single precision).\n+\n+    :return: A map of with the same key as in features and that has the corresponding tensors as values.\n+    \"\"\"\n+\n+    # Code from https://github.com/tensorflow/tensorflow/blob/v1.4.1/tensorflow/python/ops/parsing_ops.py\n+    # For now I copied from these two methods 'parse_example' and '_parse_example_raw'\n+    # The TensorFlow source code could be refactored to fully integrate the avro parser and avoid copying code!\n+\n+    if not features:\n+        raise ValueError(\"Missing: features was '{}'.\".format(features))\n+    if not schema:\n+        raise ValueError(\"Missing: schema was '{}'\".format(schema))\n+\n+    features = _prepend_none_dimension(features)\n+    # ******************** START difference: This part is different from the originally copied code ********************\n+    features = _build_keys_for_sparse_features(features)\n+    # ******************** END difference: This part is different from the originally copied code **********************\n+    (sparse_keys, sparse_types, dense_keys, dense_types, dense_defaults,\n+     dense_shapes) = _features_to_raw_params(features, [\n+         VarLenFeature, SparseFeature, FixedLenFeature, FixedLenSequenceFeature\n+     ])\n+\n+    dense_defaults = collections.OrderedDict(\n+    ) if dense_defaults is None else dense_defaults\n+    sparse_keys = [] if sparse_keys is None else sparse_keys\n+    sparse_types = [] if sparse_types is None else sparse_types\n+    dense_keys = [] if dense_keys is None else dense_keys\n+    dense_types = [] if dense_types is None else dense_types\n+    dense_shapes = ([[]] * len(dense_keys)\n+                    if dense_shapes is None else dense_shapes)\n+\n+    num_dense = len(dense_keys)\n+    num_sparse = len(sparse_keys)\n+\n+    if len(dense_shapes) != num_dense:\n+        raise ValueError(\"len(dense_shapes) != len(dense_keys): %d vs. %d\" %\n+                         (len(dense_shapes), num_dense))\n+    if len(dense_types) != num_dense:\n+        raise ValueError(\"len(dense_types) != len(num_dense): %d vs. %d\" %\n+                         (len(dense_types), num_dense))\n+    if len(sparse_types) != num_sparse:\n+        raise ValueError(\"len(sparse_types) != len(sparse_keys): %d vs. %d\" %\n+                         (len(sparse_types), num_sparse))\n+    if num_dense + num_sparse == 0:\n+        raise ValueError(\"Must provide at least one sparse key or dense key\")\n+    if not set(dense_keys).isdisjoint(set(sparse_keys)):\n+        raise ValueError(\n+            \"Dense and sparse keys must not intersect; intersection: %s\" %\n+            set(dense_keys).intersection(set(sparse_keys)))\n+\n+    # Convert dense_shapes to TensorShape object.\n+    dense_shapes = [tensor_shape.as_shape(shape) for shape in dense_shapes]\n+\n+    dense_defaults_vec = []\n+    for i, key in enumerate(dense_keys):\n+        default_value = dense_defaults.get(key)\n+        dense_shape = dense_shapes[i]\n+        # This part is used by the FixedLenSequenceFeature\n+        if dense_shape.ndims is not None and dense_shape.ndims > 0 and dense_shape[0].value is None:\n+            # Variable stride dense shape, the default value should be a scalar padding value\n+            if default_value is None:\n+                # ************* START difference: This part is different from the originally copied code ***************\n+                # Support default for other types\n+                if dense_types[i] == dtypes.string:\n+                    default_value = \"\"\n+                elif dense_types[i] == dtypes.bool:\n+                    default_value = False\n+                else:  # Should be numeric type\n+                    default_value = 0\n+                default_value = ops.convert_to_tensor(\n+                    default_value, dtype=dense_types[i])\n+                # ************* END difference: This part is different from the originally copied code *****************\n+            else:\n+                # Reshape to a scalar to ensure user gets an error if they\n+                # provide a tensor that's not intended to be a padding value\n+                # (0 or 2+ elements).\n+                key_name = \"padding_\" + re.sub(\"[^A-Za-z0-9_.\\\\-/]\", \"_\", key)\n+                default_value = ops.convert_to_tensor(\n+                    default_value, dtype=dense_types[i], name=key_name)\n+                default_value = array_ops.reshape(default_value, [])\n+        else:\n+            # This part is used by the FixedLenFeature\n+            if default_value is None:\n+                default_value = constant_op.constant([], dtype=dense_types[i])\n+            elif not isinstance(default_value, ops.Tensor):\n+                key_name = \"key_\" + re.sub(\"[^A-Za-z0-9_.\\\\-/]\", \"_\", key)\n+                default_value = ops.convert_to_tensor(\n+                    default_value, dtype=dense_types[i], name=key_name)\n+                default_value = array_ops.reshape(default_value, dense_shape)\n+\n+        dense_defaults_vec.append(default_value)\n+\n+    # Finally, convert dense_shapes to TensorShapeProto\n+    dense_shapes = [shape.as_proto() for shape in dense_shapes]\n+\n+    # ******************** START difference: This part is different from the originally copied code ********************\n+    outputs = _parse_avro_record(\n+        serialized=serialized,\n+        sparse_keys=sparse_keys,\n+        sparse_types=sparse_types,\n+        dense_defaults=dense_defaults_vec,\n+        dense_keys=dense_keys,\n+        dense_shapes=dense_shapes,\n+        schema=schema)\n+    # ********************** END difference: This part is different from the originally copied code ********************\n+\n+    (sparse_indices, sparse_values, sparse_shapes, dense_values) = outputs\n+\n+    sparse_tensors = [\n+        sparse_tensor.SparseTensor(ix, val, shape)\n+        for (ix, val,\n+             shape) in zip(sparse_indices, sparse_values, sparse_shapes)\n+    ]\n+\n+    return _construct_sparse_tensors_for_sparse_features(\n+        features,\n+        dict(zip(sparse_keys + dense_keys, sparse_tensors + dense_values)))\n+\n+\n+def _build_keys_for_sparse_features(features):\n+    \"\"\"\n+    Builds the fully qualified names for keys of sparse features.\n+\n+    :param features:  A map of features with keys to TensorFlow features.\n+\n+    :return: A map of features where for the sparse feature the 'index_key' and the 'value_key' have been expanded\n+             properly for the parser in the native code.\n+    \"\"\"\n+    if features:\n+        # NOTE: We iterate over sorted keys to keep things deterministic.\n+        for key in sorted(features.keys()):\n+            feature = features[key]\n+            if isinstance(feature, SparseFeature):\n+                features[key] = SparseFeature(\n+                    index_key=key + '.[*].' + feature.index_key,", "path": "tensorflow/contrib/avro/python/parse_avro_record.py", "position": null, "original_position": 219, "commit_id": "bdf790d5c888e59d593230286edaaf5314daaee5", "original_commit_id": "16920159ee94e83ddd1b4c83ce882b799b1838b2", "user": {"login": "galv", "id": 4767568, "node_id": "MDQ6VXNlcjQ3Njc1Njg=", "avatar_url": "https://avatars0.githubusercontent.com/u/4767568?v=4", "gravatar_id": "", "url": "https://api.github.com/users/galv", "html_url": "https://github.com/galv", "followers_url": "https://api.github.com/users/galv/followers", "following_url": "https://api.github.com/users/galv/following{/other_user}", "gists_url": "https://api.github.com/users/galv/gists{/gist_id}", "starred_url": "https://api.github.com/users/galv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/galv/subscriptions", "organizations_url": "https://api.github.com/users/galv/orgs", "repos_url": "https://api.github.com/users/galv/repos", "events_url": "https://api.github.com/users/galv/events{/privacy}", "received_events_url": "https://api.github.com/users/galv/received_events", "type": "User", "site_admin": false}, "body": "@fraudies Shouldn't this be '[*].'  now?", "created_at": "2018-08-29T19:55:02Z", "updated_at": "2018-10-22T21:28:38Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/18224#discussion_r213812973", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/18224", "author_association": "NONE", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/213812973"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/18224#discussion_r213812973"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/18224"}}, "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=1770877\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/fraudies\">@fraudies</a> Shouldn't this be '[*].'  now?</p>", "body_text": "@fraudies Shouldn't this be '[*].'  now?"}