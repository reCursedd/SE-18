{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/324003399", "html_url": "https://github.com/tensorflow/tensorflow/issues/12375#issuecomment-324003399", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/12375", "id": 324003399, "node_id": "MDEyOklzc3VlQ29tbWVudDMyNDAwMzM5OQ==", "user": {"login": "alextp", "id": 5061, "node_id": "MDQ6VXNlcjUwNjE=", "avatar_url": "https://avatars0.githubusercontent.com/u/5061?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alextp", "html_url": "https://github.com/alextp", "followers_url": "https://api.github.com/users/alextp/followers", "following_url": "https://api.github.com/users/alextp/following{/other_user}", "gists_url": "https://api.github.com/users/alextp/gists{/gist_id}", "starred_url": "https://api.github.com/users/alextp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alextp/subscriptions", "organizations_url": "https://api.github.com/users/alextp/orgs", "repos_url": "https://api.github.com/users/alextp/repos", "events_url": "https://api.github.com/users/alextp/events{/privacy}", "received_events_url": "https://api.github.com/users/alextp/received_events", "type": "User", "site_admin": false}, "created_at": "2017-08-22T11:53:26Z", "updated_at": "2017-08-22T11:53:26Z", "author_association": "MEMBER", "body_html": "<div class=\"email-fragment\">I think generating the JNI code automatically like we do the python and C++\nAPIs is the way to go. But please file an issue about this poor\ndocumentation.\n\nOn Sat, Aug 19, 2017 at 1:41 AM, Anthony Platanios &lt;notifications@github.com</div>\n<span class=\"email-hidden-toggle\"><a href=\"#\">\u2026</a></span><div class=\"email-hidden-reply\">\n<div class=\"email-quoted-reply\"> wrote:\n I figured it out and it is indeed what we have been discussing. It turns\n out that one big difference between the eager api and the existing op\n construction api is that in the latter, the calls to the op builder\n functions can be made independently without having issues if the name of an\n attribute passed to such a function is reallocated after the function call.\n In the eager api, the op must be constructed and executed, before any of\n these arguments are deallocated.\n\n This is an important distinction that I think we should find a way to\n document well (maybe we should have a C API design and maybe tutorial page,\n covering such things). This issue in particular is very important for\n language bindings where the memory is managed separately. For Java or\n Scala, for example, one cannot keep memory and deallocate it later, across\n different calls to a JNI function (or maybe it can be done in a convoluted\n way that requires one to keep track of multiple deallocators and keep\n passing them around somehow). This is important because it implies that for\n the eager api, for example, one has to construct and execute an op, within\n a single jni call. This forces the user (in order to have reasonable\n performance) to implement a jni function for each op, separately. In this\n case, I think this is good because we gain lots of performance (JNI can be\n incur a large overhead), but it should be documented as some of the errors\n caused are hard to trace.\n\n What are your thoughts on this?\n\n\n On Aug 18, 2017, 12:23 PM -0400, Alexandre Passos &lt;\n ***@***.***&gt;, wrote:\n &gt; I think (thought not sure) TensorFlow keeps a reference to the attr name\n &gt; string around until TFE_Execute is called. I think that's what you're\n &gt; stumbling against.\n &gt;\n &gt; On Fri, Aug 18, 2017 at 9:06 AM, Anthony Platanios &lt;\n ***@***.***\n &gt; &gt; wrote:\n &gt;\n &gt; &gt; I use this code to generate the bindings for the set attribute\n functions:\n &gt; &gt;\n &gt; &gt; #define DEFINE_SET_ATTR(atype, jtype, ctype) \\\n &gt; &gt; JNIEXPORT void JNICALL Java_org_platanios_tensorflow_jni_Tensor_00024_eagerSetOpAttr##atype(\n \\\n &gt; &gt; JNIEnv* env, jobject object, jlong handle, jstring name, jtype value)\n { \\\n &gt; &gt; static_assert( \\\n &gt; &gt; sizeof(ctype) &gt;= sizeof(jtype), \\\n &gt; &gt; \"Information loss when converting between Java and C types\"); \\\n &gt; &gt; TFE_Op* op = require_eager_op_handle(env, handle); \\\n &gt; &gt; if (op == nullptr) return; \\\n &gt; &gt; const char *c_name = env-&gt;GetStringUTFChars(name, nullptr); \\\n &gt; &gt; TFE_OpSetAttr##atype(op, c_name, static_cast&lt;ctype&gt;(value)); \\\n &gt; &gt; env-&gt;ReleaseStringUTFChars(name, c_name); \\\n &gt; &gt; }\n &gt; &gt;\n &gt; &gt; DEFINE_SET_ATTR(Int, Long, jlong, int64_t);\n &gt; &gt; DEFINE_SET_ATTR(Float, Float, jfloat, float);\n &gt; &gt; DEFINE_SET_ATTR(Bool, Boolean, jboolean, unsigned char);\n &gt; &gt; DEFINE_SET_ATTR(Type, Int, jint, TF_DataType);\n &gt; &gt; #undef DEFINE_SET_ATTR\n &gt; &gt;\n &gt; &gt; Could the ReleaseStringUTFChars method be interfering with the name\n &gt; &gt; passed to the set attribute function? Is the attribute name in that\n &gt; &gt; function handled differently than the one used in the normal op set\n &gt; &gt; attribute functions (i.e., not eager)? I guess those are the questions\n I'm\n &gt; &gt; looking into now. I feel that the name string may be deallocated by\n the JVM\n &gt; &gt; and then the pointer passed to the set attribute function may be\n invalid.\n &gt; &gt; Although, this doesn't seem to happen with the normal op set attribute\n &gt; &gt; functions.\n &gt; &gt;\n &gt; &gt; \u2014\n &gt; &gt; You are receiving this because you were mentioned.\n &gt; &gt; Reply to this email directly, view it on GitHub\n &gt; &gt; &lt;<a href=\"https://github.com/tensorflow/tensorflow/issues/\">https://github.com/tensorflow/tensorflow/issues/</a>\n 12375#issuecomment-323393167&gt;,\n &gt; &gt; or mute the thread\n &gt; &gt; &lt;<a href=\"https://github.com/notifications/unsubscribe-\">https://github.com/notifications/unsubscribe-</a>\n auth/AAATxardMJGjOzEt49AttTd-b8DS-D3Nks5sZbaCgaJpZM4O68WV&gt;\n &gt; &gt; .\n &gt; &gt;\n &gt;\n &gt;\n &gt;\n &gt; --\n &gt; - Alex\n &gt; \u2014\n &gt; You are receiving this because you authored the thread.\n\n &gt; Reply to this email directly, view it on GitHub, or mute the thread.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n &lt;<a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"251102919\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/tensorflow/tensorflow/issues/12375\" href=\"https://github.com/tensorflow/tensorflow/issues/12375#issuecomment-323502371\">#12375 (comment)</a>&gt;,\n or mute the thread\n &lt;<a href=\"https://github.com/notifications/unsubscribe-auth/AAATxVA_5yOioaZshYJpPioSTLfmuYNyks5sZnWPgaJpZM4O68WV\">https://github.com/notifications/unsubscribe-auth/AAATxVA_5yOioaZshYJpPioSTLfmuYNyks5sZnWPgaJpZM4O68WV</a>&gt;\n .\n</div>\n<div class=\"email-fragment\"></div>\n<div class=\"email-signature-reply\">-- \n - Alex</div>\n</div>", "body_text": "I think generating the JNI code automatically like we do the python and C++\nAPIs is the way to go. But please file an issue about this poor\ndocumentation.\n\nOn Sat, Aug 19, 2017 at 1:41 AM, Anthony Platanios <notifications@github.com\n\u2026\n wrote:\n I figured it out and it is indeed what we have been discussing. It turns\n out that one big difference between the eager api and the existing op\n construction api is that in the latter, the calls to the op builder\n functions can be made independently without having issues if the name of an\n attribute passed to such a function is reallocated after the function call.\n In the eager api, the op must be constructed and executed, before any of\n these arguments are deallocated.\n\n This is an important distinction that I think we should find a way to\n document well (maybe we should have a C API design and maybe tutorial page,\n covering such things). This issue in particular is very important for\n language bindings where the memory is managed separately. For Java or\n Scala, for example, one cannot keep memory and deallocate it later, across\n different calls to a JNI function (or maybe it can be done in a convoluted\n way that requires one to keep track of multiple deallocators and keep\n passing them around somehow). This is important because it implies that for\n the eager api, for example, one has to construct and execute an op, within\n a single jni call. This forces the user (in order to have reasonable\n performance) to implement a jni function for each op, separately. In this\n case, I think this is good because we gain lots of performance (JNI can be\n incur a large overhead), but it should be documented as some of the errors\n caused are hard to trace.\n\n What are your thoughts on this?\n\n\n On Aug 18, 2017, 12:23 PM -0400, Alexandre Passos <\n ***@***.***>, wrote:\n > I think (thought not sure) TensorFlow keeps a reference to the attr name\n > string around until TFE_Execute is called. I think that's what you're\n > stumbling against.\n >\n > On Fri, Aug 18, 2017 at 9:06 AM, Anthony Platanios <\n ***@***.***\n > > wrote:\n >\n > > I use this code to generate the bindings for the set attribute\n functions:\n > >\n > > #define DEFINE_SET_ATTR(atype, jtype, ctype) \\\n > > JNIEXPORT void JNICALL Java_org_platanios_tensorflow_jni_Tensor_00024_eagerSetOpAttr##atype(\n \\\n > > JNIEnv* env, jobject object, jlong handle, jstring name, jtype value)\n { \\\n > > static_assert( \\\n > > sizeof(ctype) >= sizeof(jtype), \\\n > > \"Information loss when converting between Java and C types\"); \\\n > > TFE_Op* op = require_eager_op_handle(env, handle); \\\n > > if (op == nullptr) return; \\\n > > const char *c_name = env->GetStringUTFChars(name, nullptr); \\\n > > TFE_OpSetAttr##atype(op, c_name, static_cast<ctype>(value)); \\\n > > env->ReleaseStringUTFChars(name, c_name); \\\n > > }\n > >\n > > DEFINE_SET_ATTR(Int, Long, jlong, int64_t);\n > > DEFINE_SET_ATTR(Float, Float, jfloat, float);\n > > DEFINE_SET_ATTR(Bool, Boolean, jboolean, unsigned char);\n > > DEFINE_SET_ATTR(Type, Int, jint, TF_DataType);\n > > #undef DEFINE_SET_ATTR\n > >\n > > Could the ReleaseStringUTFChars method be interfering with the name\n > > passed to the set attribute function? Is the attribute name in that\n > > function handled differently than the one used in the normal op set\n > > attribute functions (i.e., not eager)? I guess those are the questions\n I'm\n > > looking into now. I feel that the name string may be deallocated by\n the JVM\n > > and then the pointer passed to the set attribute function may be\n invalid.\n > > Although, this doesn't seem to happen with the normal op set attribute\n > > functions.\n > >\n > > \u2014\n > > You are receiving this because you were mentioned.\n > > Reply to this email directly, view it on GitHub\n > > <https://github.com/tensorflow/tensorflow/issues/\n 12375#issuecomment-323393167>,\n > > or mute the thread\n > > <https://github.com/notifications/unsubscribe-\n auth/AAATxardMJGjOzEt49AttTd-b8DS-D3Nks5sZbaCgaJpZM4O68WV>\n > > .\n > >\n >\n >\n >\n > --\n > - Alex\n > \u2014\n > You are receiving this because you authored the thread.\n\n > Reply to this email directly, view it on GitHub, or mute the thread.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#12375 (comment)>,\n or mute the thread\n <https://github.com/notifications/unsubscribe-auth/AAATxVA_5yOioaZshYJpPioSTLfmuYNyks5sZnWPgaJpZM4O68WV>\n .\n\n\n-- \n - Alex", "body": "I think generating the JNI code automatically like we do the python and C++\nAPIs is the way to go. But please file an issue about this poor\ndocumentation.\n\nOn Sat, Aug 19, 2017 at 1:41 AM, Anthony Platanios <notifications@github.com\n> wrote:\n\n> I figured it out and it is indeed what we have been discussing. It turns\n> out that one big difference between the eager api and the existing op\n> construction api is that in the latter, the calls to the op builder\n> functions can be made independently without having issues if the name of an\n> attribute passed to such a function is reallocated after the function call.\n> In the eager api, the op must be constructed and executed, before any of\n> these arguments are deallocated.\n>\n> This is an important distinction that I think we should find a way to\n> document well (maybe we should have a C API design and maybe tutorial page,\n> covering such things). This issue in particular is very important for\n> language bindings where the memory is managed separately. For Java or\n> Scala, for example, one cannot keep memory and deallocate it later, across\n> different calls to a JNI function (or maybe it can be done in a convoluted\n> way that requires one to keep track of multiple deallocators and keep\n> passing them around somehow). This is important because it implies that for\n> the eager api, for example, one has to construct and execute an op, within\n> a single jni call. This forces the user (in order to have reasonable\n> performance) to implement a jni function for each op, separately. In this\n> case, I think this is good because we gain lots of performance (JNI can be\n> incur a large overhead), but it should be documented as some of the errors\n> caused are hard to trace.\n>\n> What are your thoughts on this?\n>\n>\n> On Aug 18, 2017, 12:23 PM -0400, Alexandre Passos <\n> notifications@github.com>, wrote:\n> > I think (thought not sure) TensorFlow keeps a reference to the attr name\n> > string around until TFE_Execute is called. I think that's what you're\n> > stumbling against.\n> >\n> > On Fri, Aug 18, 2017 at 9:06 AM, Anthony Platanios <\n> notifications@github.com\n> > > wrote:\n> >\n> > > I use this code to generate the bindings for the set attribute\n> functions:\n> > >\n> > > #define DEFINE_SET_ATTR(atype, jtype, ctype) \\\n> > > JNIEXPORT void JNICALL Java_org_platanios_tensorflow_jni_Tensor_00024_eagerSetOpAttr##atype(\n> \\\n> > > JNIEnv* env, jobject object, jlong handle, jstring name, jtype value)\n> { \\\n> > > static_assert( \\\n> > > sizeof(ctype) >= sizeof(jtype), \\\n> > > \"Information loss when converting between Java and C types\"); \\\n> > > TFE_Op* op = require_eager_op_handle(env, handle); \\\n> > > if (op == nullptr) return; \\\n> > > const char *c_name = env->GetStringUTFChars(name, nullptr); \\\n> > > TFE_OpSetAttr##atype(op, c_name, static_cast<ctype>(value)); \\\n> > > env->ReleaseStringUTFChars(name, c_name); \\\n> > > }\n> > >\n> > > DEFINE_SET_ATTR(Int, Long, jlong, int64_t);\n> > > DEFINE_SET_ATTR(Float, Float, jfloat, float);\n> > > DEFINE_SET_ATTR(Bool, Boolean, jboolean, unsigned char);\n> > > DEFINE_SET_ATTR(Type, Int, jint, TF_DataType);\n> > > #undef DEFINE_SET_ATTR\n> > >\n> > > Could the ReleaseStringUTFChars method be interfering with the name\n> > > passed to the set attribute function? Is the attribute name in that\n> > > function handled differently than the one used in the normal op set\n> > > attribute functions (i.e., not eager)? I guess those are the questions\n> I'm\n> > > looking into now. I feel that the name string may be deallocated by\n> the JVM\n> > > and then the pointer passed to the set attribute function may be\n> invalid.\n> > > Although, this doesn't seem to happen with the normal op set attribute\n> > > functions.\n> > >\n> > > \u2014\n> > > You are receiving this because you were mentioned.\n> > > Reply to this email directly, view it on GitHub\n> > > <https://github.com/tensorflow/tensorflow/issues/\n> 12375#issuecomment-323393167>,\n> > > or mute the thread\n> > > <https://github.com/notifications/unsubscribe-\n> auth/AAATxardMJGjOzEt49AttTd-b8DS-D3Nks5sZbaCgaJpZM4O68WV>\n> > > .\n> > >\n> >\n> >\n> >\n> > --\n> > - Alex\n> > \u2014\n> > You are receiving this because you authored the thread.\n>\n> > Reply to this email directly, view it on GitHub, or mute the thread.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tensorflow/tensorflow/issues/12375#issuecomment-323502371>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAATxVA_5yOioaZshYJpPioSTLfmuYNyks5sZnWPgaJpZM4O68WV>\n> .\n>\n\n\n\n-- \n - Alex\n"}