{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/323393167", "html_url": "https://github.com/tensorflow/tensorflow/issues/12375#issuecomment-323393167", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/12375", "id": 323393167, "node_id": "MDEyOklzc3VlQ29tbWVudDMyMzM5MzE2Nw==", "user": {"login": "eaplatanios", "id": 1294940, "node_id": "MDQ6VXNlcjEyOTQ5NDA=", "avatar_url": "https://avatars2.githubusercontent.com/u/1294940?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eaplatanios", "html_url": "https://github.com/eaplatanios", "followers_url": "https://api.github.com/users/eaplatanios/followers", "following_url": "https://api.github.com/users/eaplatanios/following{/other_user}", "gists_url": "https://api.github.com/users/eaplatanios/gists{/gist_id}", "starred_url": "https://api.github.com/users/eaplatanios/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eaplatanios/subscriptions", "organizations_url": "https://api.github.com/users/eaplatanios/orgs", "repos_url": "https://api.github.com/users/eaplatanios/repos", "events_url": "https://api.github.com/users/eaplatanios/events{/privacy}", "received_events_url": "https://api.github.com/users/eaplatanios/received_events", "type": "User", "site_admin": false}, "created_at": "2017-08-18T16:00:20Z", "updated_at": "2017-08-18T16:00:20Z", "author_association": "CONTRIBUTOR", "body_html": "<p>I use this code to generate the bindings for the set attribute functions:</p>\n<pre><code>#define DEFINE_SET_ATTR(atype, jtype, ctype)                                            \\\n  JNIEXPORT void JNICALL Java_org_platanios_tensorflow_jni_Tensor_00024_eagerSetOpAttr##atype( \\\n      JNIEnv* env, jobject object, jlong handle, jstring name, jtype value) {                  \\\n    static_assert(                                                                             \\\n        sizeof(ctype) &gt;= sizeof(jtype),                                                        \\\n        \"Information loss when converting between Java and C types\");                          \\\n    TFE_Op* op = require_eager_op_handle(env, handle);                                         \\\n    if (op == nullptr) return;                                                                 \\\n    const char *c_name = env-&gt;GetStringUTFChars(name, nullptr);                                \\\n    TFE_OpSetAttr##atype(op, c_name, static_cast&lt;ctype&gt;(value));                               \\\n    env-&gt;ReleaseStringUTFChars(name, c_name);                                                  \\\n  }\n\nDEFINE_SET_ATTR(Int, Long, jlong, int64_t);\nDEFINE_SET_ATTR(Float, Float, jfloat, float);\nDEFINE_SET_ATTR(Bool, Boolean, jboolean, unsigned char);\nDEFINE_SET_ATTR(Type, Int, jint, TF_DataType);\n#undef DEFINE_SET_ATTR\n</code></pre>\n<p>Could the <code>ReleaseStringUTFChars</code> method be interfering with the name passed to the set attribute function? Is the attribute name in that function handled differently than the one used in the normal op set attribute functions (i.e., not eager)? I guess those are the questions I'm looking into now. I feel that the name string may be deallocated by the JVM and then the pointer passed to the set attribute function may be invalid. Although, this doesn't seem to happen with the normal op set attribute functions.</p>", "body_text": "I use this code to generate the bindings for the set attribute functions:\n#define DEFINE_SET_ATTR(atype, jtype, ctype)                                            \\\n  JNIEXPORT void JNICALL Java_org_platanios_tensorflow_jni_Tensor_00024_eagerSetOpAttr##atype( \\\n      JNIEnv* env, jobject object, jlong handle, jstring name, jtype value) {                  \\\n    static_assert(                                                                             \\\n        sizeof(ctype) >= sizeof(jtype),                                                        \\\n        \"Information loss when converting between Java and C types\");                          \\\n    TFE_Op* op = require_eager_op_handle(env, handle);                                         \\\n    if (op == nullptr) return;                                                                 \\\n    const char *c_name = env->GetStringUTFChars(name, nullptr);                                \\\n    TFE_OpSetAttr##atype(op, c_name, static_cast<ctype>(value));                               \\\n    env->ReleaseStringUTFChars(name, c_name);                                                  \\\n  }\n\nDEFINE_SET_ATTR(Int, Long, jlong, int64_t);\nDEFINE_SET_ATTR(Float, Float, jfloat, float);\nDEFINE_SET_ATTR(Bool, Boolean, jboolean, unsigned char);\nDEFINE_SET_ATTR(Type, Int, jint, TF_DataType);\n#undef DEFINE_SET_ATTR\n\nCould the ReleaseStringUTFChars method be interfering with the name passed to the set attribute function? Is the attribute name in that function handled differently than the one used in the normal op set attribute functions (i.e., not eager)? I guess those are the questions I'm looking into now. I feel that the name string may be deallocated by the JVM and then the pointer passed to the set attribute function may be invalid. Although, this doesn't seem to happen with the normal op set attribute functions.", "body": "I use this code to generate the bindings for the set attribute functions:\r\n\r\n```\r\n#define DEFINE_SET_ATTR(atype, jtype, ctype)                                            \\\r\n  JNIEXPORT void JNICALL Java_org_platanios_tensorflow_jni_Tensor_00024_eagerSetOpAttr##atype( \\\r\n      JNIEnv* env, jobject object, jlong handle, jstring name, jtype value) {                  \\\r\n    static_assert(                                                                             \\\r\n        sizeof(ctype) >= sizeof(jtype),                                                        \\\r\n        \"Information loss when converting between Java and C types\");                          \\\r\n    TFE_Op* op = require_eager_op_handle(env, handle);                                         \\\r\n    if (op == nullptr) return;                                                                 \\\r\n    const char *c_name = env->GetStringUTFChars(name, nullptr);                                \\\r\n    TFE_OpSetAttr##atype(op, c_name, static_cast<ctype>(value));                               \\\r\n    env->ReleaseStringUTFChars(name, c_name);                                                  \\\r\n  }\r\n\r\nDEFINE_SET_ATTR(Int, Long, jlong, int64_t);\r\nDEFINE_SET_ATTR(Float, Float, jfloat, float);\r\nDEFINE_SET_ATTR(Bool, Boolean, jboolean, unsigned char);\r\nDEFINE_SET_ATTR(Type, Int, jint, TF_DataType);\r\n#undef DEFINE_SET_ATTR\r\n```\r\n\r\nCould the `ReleaseStringUTFChars` method be interfering with the name passed to the set attribute function? Is the attribute name in that function handled differently than the one used in the normal op set attribute functions (i.e., not eager)? I guess those are the questions I'm looking into now. I feel that the name string may be deallocated by the JVM and then the pointer passed to the set attribute function may be invalid. Although, this doesn't seem to happen with the normal op set attribute functions."}