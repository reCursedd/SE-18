{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/323502371", "html_url": "https://github.com/tensorflow/tensorflow/issues/12375#issuecomment-323502371", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/12375", "id": 323502371, "node_id": "MDEyOklzc3VlQ29tbWVudDMyMzUwMjM3MQ==", "user": {"login": "eaplatanios", "id": 1294940, "node_id": "MDQ6VXNlcjEyOTQ5NDA=", "avatar_url": "https://avatars2.githubusercontent.com/u/1294940?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eaplatanios", "html_url": "https://github.com/eaplatanios", "followers_url": "https://api.github.com/users/eaplatanios/followers", "following_url": "https://api.github.com/users/eaplatanios/following{/other_user}", "gists_url": "https://api.github.com/users/eaplatanios/gists{/gist_id}", "starred_url": "https://api.github.com/users/eaplatanios/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eaplatanios/subscriptions", "organizations_url": "https://api.github.com/users/eaplatanios/orgs", "repos_url": "https://api.github.com/users/eaplatanios/repos", "events_url": "https://api.github.com/users/eaplatanios/events{/privacy}", "received_events_url": "https://api.github.com/users/eaplatanios/received_events", "type": "User", "site_admin": false}, "created_at": "2017-08-19T05:37:14Z", "updated_at": "2017-08-19T05:37:14Z", "author_association": "CONTRIBUTOR", "body_html": "<div class=\"email-fragment\">I figured it out and it is indeed what we have been discussing. It turns out that one big difference between the eager api and the existing op construction api is that in the latter, the calls to the op builder functions can be made independently without having issues if the name of an attribute passed to such a function is reallocated after the function call. In the eager api, the op must be constructed and executed, before any of these arguments are deallocated.\n\nThis is an important distinction that I think we should find a way to document well (maybe we should have a C API design and maybe tutorial page, covering such things). This issue in particular is very important for language bindings where the memory is managed separately. For Java or Scala, for example, one cannot keep memory and deallocate it later, across different calls to a JNI function (or maybe it can be done in a convoluted way that requires one to keep track of multiple deallocators and keep passing them around somehow). This is important because it implies that for the eager api, for example, one has to construct and execute an op, within a single jni call. This forces the user (in order to have reasonable performance) to implement a jni function for each op, separately. In this case, I think this is good because we gain lots of performance (JNI can be incur a large overhead), but it should be documented as some of the errors caused are hard to trace.\n\nWhat are your thoughts on this?</div>\n<span class=\"email-hidden-toggle\"><a href=\"#\">\u2026</a></span><div class=\"email-hidden-reply\">\n<div class=\"email-quoted-reply\">On Aug 18, 2017, 12:23 PM -0400, Alexandre Passos ***@***.***&gt;, wrote:\n I think (thought not sure) TensorFlow keeps a reference to the attr name\n string around until TFE_Execute is called. I think that's what you're\n stumbling against.\n\n On Fri, Aug 18, 2017 at 9:06 AM, Anthony Platanios ***@***.***\n &gt; wrote:\n\n &gt; I use this code to generate the bindings for the set attribute functions:\n &gt;\n &gt; #define DEFINE_SET_ATTR(atype, jtype, ctype) \\\n &gt; JNIEXPORT void JNICALL Java_org_platanios_tensorflow_jni_Tensor_00024_eagerSetOpAttr##atype( \\\n &gt; JNIEnv* env, jobject object, jlong handle, jstring name, jtype value) { \\\n &gt; static_assert( \\\n &gt; sizeof(ctype) &gt;= sizeof(jtype), \\\n &gt; \"Information loss when converting between Java and C types\"); \\\n &gt; TFE_Op* op = require_eager_op_handle(env, handle); \\\n &gt; if (op == nullptr) return; \\\n &gt; const char *c_name = env-&gt;GetStringUTFChars(name, nullptr); \\\n &gt; TFE_OpSetAttr##atype(op, c_name, static_cast&lt;ctype&gt;(value)); \\\n &gt; env-&gt;ReleaseStringUTFChars(name, c_name); \\\n &gt; }\n &gt;\n &gt; DEFINE_SET_ATTR(Int, Long, jlong, int64_t);\n &gt; DEFINE_SET_ATTR(Float, Float, jfloat, float);\n &gt; DEFINE_SET_ATTR(Bool, Boolean, jboolean, unsigned char);\n &gt; DEFINE_SET_ATTR(Type, Int, jint, TF_DataType);\n &gt; #undef DEFINE_SET_ATTR\n &gt;\n &gt; Could the ReleaseStringUTFChars method be interfering with the name\n &gt; passed to the set attribute function? Is the attribute name in that\n &gt; function handled differently than the one used in the normal op set\n &gt; attribute functions (i.e., not eager)? I guess those are the questions I'm\n &gt; looking into now. I feel that the name string may be deallocated by the JVM\n &gt; and then the pointer passed to the set attribute function may be invalid.\n &gt; Although, this doesn't seem to happen with the normal op set attribute\n &gt; functions.\n &gt;\n &gt; \u2014\n &gt; You are receiving this because you were mentioned.\n &gt; Reply to this email directly, view it on GitHub\n &gt; &lt;<a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"251102919\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/tensorflow/tensorflow/issues/12375\" href=\"https://github.com/tensorflow/tensorflow/issues/12375#issuecomment-323393167\">#12375 (comment)</a>&gt;,\n &gt; or mute the thread\n &gt; &lt;<a href=\"https://github.com/notifications/unsubscribe-auth/AAATxardMJGjOzEt49AttTd-b8DS-D3Nks5sZbaCgaJpZM4O68WV\">https://github.com/notifications/unsubscribe-auth/AAATxardMJGjOzEt49AttTd-b8DS-D3Nks5sZbaCgaJpZM4O68WV</a>&gt;\n &gt; .\n &gt;\n\n\n\n --\n - Alex\n \u2014\n You are receiving this because you authored the thread.\n Reply to this email directly, view it on GitHub, or mute the thread.</div>\n<div class=\"email-fragment\"></div>\n</div>", "body_text": "I figured it out and it is indeed what we have been discussing. It turns out that one big difference between the eager api and the existing op construction api is that in the latter, the calls to the op builder functions can be made independently without having issues if the name of an attribute passed to such a function is reallocated after the function call. In the eager api, the op must be constructed and executed, before any of these arguments are deallocated.\n\nThis is an important distinction that I think we should find a way to document well (maybe we should have a C API design and maybe tutorial page, covering such things). This issue in particular is very important for language bindings where the memory is managed separately. For Java or Scala, for example, one cannot keep memory and deallocate it later, across different calls to a JNI function (or maybe it can be done in a convoluted way that requires one to keep track of multiple deallocators and keep passing them around somehow). This is important because it implies that for the eager api, for example, one has to construct and execute an op, within a single jni call. This forces the user (in order to have reasonable performance) to implement a jni function for each op, separately. In this case, I think this is good because we gain lots of performance (JNI can be incur a large overhead), but it should be documented as some of the errors caused are hard to trace.\n\nWhat are your thoughts on this?\n\u2026\nOn Aug 18, 2017, 12:23 PM -0400, Alexandre Passos ***@***.***>, wrote:\n I think (thought not sure) TensorFlow keeps a reference to the attr name\n string around until TFE_Execute is called. I think that's what you're\n stumbling against.\n\n On Fri, Aug 18, 2017 at 9:06 AM, Anthony Platanios ***@***.***\n > wrote:\n\n > I use this code to generate the bindings for the set attribute functions:\n >\n > #define DEFINE_SET_ATTR(atype, jtype, ctype) \\\n > JNIEXPORT void JNICALL Java_org_platanios_tensorflow_jni_Tensor_00024_eagerSetOpAttr##atype( \\\n > JNIEnv* env, jobject object, jlong handle, jstring name, jtype value) { \\\n > static_assert( \\\n > sizeof(ctype) >= sizeof(jtype), \\\n > \"Information loss when converting between Java and C types\"); \\\n > TFE_Op* op = require_eager_op_handle(env, handle); \\\n > if (op == nullptr) return; \\\n > const char *c_name = env->GetStringUTFChars(name, nullptr); \\\n > TFE_OpSetAttr##atype(op, c_name, static_cast<ctype>(value)); \\\n > env->ReleaseStringUTFChars(name, c_name); \\\n > }\n >\n > DEFINE_SET_ATTR(Int, Long, jlong, int64_t);\n > DEFINE_SET_ATTR(Float, Float, jfloat, float);\n > DEFINE_SET_ATTR(Bool, Boolean, jboolean, unsigned char);\n > DEFINE_SET_ATTR(Type, Int, jint, TF_DataType);\n > #undef DEFINE_SET_ATTR\n >\n > Could the ReleaseStringUTFChars method be interfering with the name\n > passed to the set attribute function? Is the attribute name in that\n > function handled differently than the one used in the normal op set\n > attribute functions (i.e., not eager)? I guess those are the questions I'm\n > looking into now. I feel that the name string may be deallocated by the JVM\n > and then the pointer passed to the set attribute function may be invalid.\n > Although, this doesn't seem to happen with the normal op set attribute\n > functions.\n >\n > \u2014\n > You are receiving this because you were mentioned.\n > Reply to this email directly, view it on GitHub\n > <#12375 (comment)>,\n > or mute the thread\n > <https://github.com/notifications/unsubscribe-auth/AAATxardMJGjOzEt49AttTd-b8DS-D3Nks5sZbaCgaJpZM4O68WV>\n > .\n >\n\n\n\n --\n - Alex\n \u2014\n You are receiving this because you authored the thread.\n Reply to this email directly, view it on GitHub, or mute the thread.", "body": "I figured it out and it is indeed what we have been discussing. It turns out that one big difference between the eager api and the existing op construction api is that in the latter, the calls to the op builder functions can be made independently without having issues if the name of an attribute passed to such a function is reallocated after the function call. In the eager api, the op must be constructed and executed, before any of these arguments are deallocated.\n\nThis is an important distinction that I think we should find a way to document well (maybe we should have a C API design and maybe tutorial page, covering such things). This issue in particular is very important for language bindings where the memory is managed separately. For Java or Scala, for example, one cannot keep memory and deallocate it later, across different calls to a JNI function (or maybe it can be done in a convoluted way that requires one to keep track of multiple deallocators and keep passing them around somehow). This is important because it implies that for the eager api, for example, one has to construct and execute an op, within a single jni call. This forces the user (in order to have reasonable performance) to implement a jni function for each op, separately. In this case, I think this is good because we gain lots of performance (JNI can be incur a large overhead), but it should be documented as some of the errors caused are hard to trace.\n\nWhat are your thoughts on this?\n\nOn Aug 18, 2017, 12:23 PM -0400, Alexandre Passos <notifications@github.com>, wrote:\n> I think (thought not sure) TensorFlow keeps a reference to the attr name\n> string around until TFE_Execute is called. I think that's what you're\n> stumbling against.\n>\n> On Fri, Aug 18, 2017 at 9:06 AM, Anthony Platanios <notifications@github.com\n> > wrote:\n>\n> > I use this code to generate the bindings for the set attribute functions:\n> >\n> > #define DEFINE_SET_ATTR(atype, jtype, ctype) \\\n> > JNIEXPORT void JNICALL Java_org_platanios_tensorflow_jni_Tensor_00024_eagerSetOpAttr##atype( \\\n> > JNIEnv* env, jobject object, jlong handle, jstring name, jtype value) { \\\n> > static_assert( \\\n> > sizeof(ctype) >= sizeof(jtype), \\\n> > \"Information loss when converting between Java and C types\"); \\\n> > TFE_Op* op = require_eager_op_handle(env, handle); \\\n> > if (op == nullptr) return; \\\n> > const char *c_name = env->GetStringUTFChars(name, nullptr); \\\n> > TFE_OpSetAttr##atype(op, c_name, static_cast<ctype>(value)); \\\n> > env->ReleaseStringUTFChars(name, c_name); \\\n> > }\n> >\n> > DEFINE_SET_ATTR(Int, Long, jlong, int64_t);\n> > DEFINE_SET_ATTR(Float, Float, jfloat, float);\n> > DEFINE_SET_ATTR(Bool, Boolean, jboolean, unsigned char);\n> > DEFINE_SET_ATTR(Type, Int, jint, TF_DataType);\n> > #undef DEFINE_SET_ATTR\n> >\n> > Could the ReleaseStringUTFChars method be interfering with the name\n> > passed to the set attribute function? Is the attribute name in that\n> > function handled differently than the one used in the normal op set\n> > attribute functions (i.e., not eager)? I guess those are the questions I'm\n> > looking into now. I feel that the name string may be deallocated by the JVM\n> > and then the pointer passed to the set attribute function may be invalid.\n> > Although, this doesn't seem to happen with the normal op set attribute\n> > functions.\n> >\n> > \u2014\n> > You are receiving this because you were mentioned.\n> > Reply to this email directly, view it on GitHub\n> > <https://github.com/tensorflow/tensorflow/issues/12375#issuecomment-323393167>,\n> > or mute the thread\n> > <https://github.com/notifications/unsubscribe-auth/AAATxardMJGjOzEt49AttTd-b8DS-D3Nks5sZbaCgaJpZM4O68WV>\n> > .\n> >\n>\n>\n>\n> --\n> - Alex\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub, or mute the thread.\n"}