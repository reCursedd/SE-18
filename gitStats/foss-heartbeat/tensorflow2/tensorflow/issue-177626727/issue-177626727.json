{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/4432", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/4432/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/4432/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/4432/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/4432", "id": 177626727, "node_id": "MDU6SXNzdWUxNzc2MjY3Mjc=", "number": 4432, "title": "wrong tf.control_dependencies using tf.case  and tf.cond", "user": {"login": "cherishlc", "id": 13269703, "node_id": "MDQ6VXNlcjEzMjY5NzAz", "avatar_url": "https://avatars0.githubusercontent.com/u/13269703?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cherishlc", "html_url": "https://github.com/cherishlc", "followers_url": "https://api.github.com/users/cherishlc/followers", "following_url": "https://api.github.com/users/cherishlc/following{/other_user}", "gists_url": "https://api.github.com/users/cherishlc/gists{/gist_id}", "starred_url": "https://api.github.com/users/cherishlc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cherishlc/subscriptions", "organizations_url": "https://api.github.com/users/cherishlc/orgs", "repos_url": "https://api.github.com/users/cherishlc/repos", "events_url": "https://api.github.com/users/cherishlc/events{/privacy}", "received_events_url": "https://api.github.com/users/cherishlc/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 386191887, "node_id": "MDU6TGFiZWwzODYxOTE4ODc=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:awaiting%20response", "name": "stat:awaiting response", "color": "f4b400", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2016-09-18T03:28:04Z", "updated_at": "2016-09-27T02:40:08Z", "closed_at": "2016-09-27T02:40:08Z", "author_association": "NONE", "body_html": "<p>add tf.control_dependencies in one branch of tf.case infulunce the other brach:<br>\ntf version: rc10</p>\n<p>as we can see below, the tfvar is increasing no mather brach f1 or f2 is executed<br>\nchange tf.case to tf.cond will get the same output.</p>\n<p>`def testTF_case_with_control_dependencies():</p>\n<pre><code>isTraining=tf.placeholder(tf.bool,shape=[])\ntfvar=tf.Variable(tf.constant(0),tf.int32);\n\nincrease_tfvar_op=tf.assign_add(tfvar.ref(), 1);\n\nsess=tf.Session()\nsess.run(tf.initialize_all_variables())\n\ndef f1():\n    print ('f1')\n    with tf.control_dependencies([increase_tfvar_op]):\n        return -tfvar;  #if return tfvar directly, no control_dependencies is added\n\ndef f2():\n    print('f2')\n    with tf.control_dependencies([]):\n        return tfvar*10;\ncaseResult = tf.case([(isTraining, f1)], default=f2)\n\nb=True;\nfor t in range(4):\n    b=not b;\n    print('\\n------')\n    print('isTraining: ',end='')\n    print(b)\n    beforeCase=sess.run(tfvar)\n    print('\\ttfvar before run case: %d'%beforeCase)\n    r=sess.run(caseResult,feed_dict={isTraining:b})\n    print('case result:%d'%r)\n    aftercase=sess.run(tfvar)\n    print('\\ttfvar after run case: %d'%aftercase)`\n</code></pre>\n<p>output:<br>\nf2<br>\nf2<br>\nf1</p>\n<hr>\n<p>isTraining: False<br>\ntfvar before run case: 0<br>\ncase result:10<br>\ntfvar after run case: 1</p>\n<hr>\n<p>isTraining: True<br>\ntfvar before run case: 1<br>\ncase result:-2<br>\ntfvar after run case: 2</p>\n<hr>\n<p>isTraining: False<br>\ntfvar before run case: 2<br>\ncase result:30<br>\ntfvar after run case: 3</p>\n<hr>\n<p>isTraining: True<br>\ntfvar before run case: 3<br>\ncase result:-4<br>\ntfvar after run case: 4</p>", "body_text": "add tf.control_dependencies in one branch of tf.case infulunce the other brach:\ntf version: rc10\nas we can see below, the tfvar is increasing no mather brach f1 or f2 is executed\nchange tf.case to tf.cond will get the same output.\n`def testTF_case_with_control_dependencies():\nisTraining=tf.placeholder(tf.bool,shape=[])\ntfvar=tf.Variable(tf.constant(0),tf.int32);\n\nincrease_tfvar_op=tf.assign_add(tfvar.ref(), 1);\n\nsess=tf.Session()\nsess.run(tf.initialize_all_variables())\n\ndef f1():\n    print ('f1')\n    with tf.control_dependencies([increase_tfvar_op]):\n        return -tfvar;  #if return tfvar directly, no control_dependencies is added\n\ndef f2():\n    print('f2')\n    with tf.control_dependencies([]):\n        return tfvar*10;\ncaseResult = tf.case([(isTraining, f1)], default=f2)\n\nb=True;\nfor t in range(4):\n    b=not b;\n    print('\\n------')\n    print('isTraining: ',end='')\n    print(b)\n    beforeCase=sess.run(tfvar)\n    print('\\ttfvar before run case: %d'%beforeCase)\n    r=sess.run(caseResult,feed_dict={isTraining:b})\n    print('case result:%d'%r)\n    aftercase=sess.run(tfvar)\n    print('\\ttfvar after run case: %d'%aftercase)`\n\noutput:\nf2\nf2\nf1\n\nisTraining: False\ntfvar before run case: 0\ncase result:10\ntfvar after run case: 1\n\nisTraining: True\ntfvar before run case: 1\ncase result:-2\ntfvar after run case: 2\n\nisTraining: False\ntfvar before run case: 2\ncase result:30\ntfvar after run case: 3\n\nisTraining: True\ntfvar before run case: 3\ncase result:-4\ntfvar after run case: 4", "body": "add tf.control_dependencies in one branch of tf.case infulunce the other brach:\ntf version: rc10\n\nas we can see below, the tfvar is increasing no mather brach f1 or f2 is executed\nchange tf.case to tf.cond will get the same output.\n\n`def testTF_case_with_control_dependencies():\n\n```\nisTraining=tf.placeholder(tf.bool,shape=[])\ntfvar=tf.Variable(tf.constant(0),tf.int32);\n\nincrease_tfvar_op=tf.assign_add(tfvar.ref(), 1);\n\nsess=tf.Session()\nsess.run(tf.initialize_all_variables())\n\ndef f1():\n    print ('f1')\n    with tf.control_dependencies([increase_tfvar_op]):\n        return -tfvar;  #if return tfvar directly, no control_dependencies is added\n\ndef f2():\n    print('f2')\n    with tf.control_dependencies([]):\n        return tfvar*10;\ncaseResult = tf.case([(isTraining, f1)], default=f2)\n\nb=True;\nfor t in range(4):\n    b=not b;\n    print('\\n------')\n    print('isTraining: ',end='')\n    print(b)\n    beforeCase=sess.run(tfvar)\n    print('\\ttfvar before run case: %d'%beforeCase)\n    r=sess.run(caseResult,feed_dict={isTraining:b})\n    print('case result:%d'%r)\n    aftercase=sess.run(tfvar)\n    print('\\ttfvar after run case: %d'%aftercase)`\n```\n\noutput:\nf2\nf2\nf1\n\n---\n\nisTraining: False\n    tfvar before run case: 0\ncase result:10\n    tfvar after run case: 1\n\n---\n\nisTraining: True\n    tfvar before run case: 1\ncase result:-2\n    tfvar after run case: 2\n\n---\n\nisTraining: False\n    tfvar before run case: 2\ncase result:30\n    tfvar after run case: 3\n\n---\n\nisTraining: True\n    tfvar before run case: 3\ncase result:-4\n    tfvar after run case: 4\n"}