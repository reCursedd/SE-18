{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/181854175", "pull_request_review_id": 112550232, "id": 181854175, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4MTg1NDE3NQ==", "diff_hunk": "@@ -947,6 +947,119 @@ def resize_images(images,\n     return images\n \n \n+@tf_export('image.resize_image_aspect_with_pad')\n+def resize_image_aspect_with_pad(image, target_height, target_width,\n+                                 method=ResizeMethod.BILINEAR):\n+  \"\"\"\n+  Resizes and pads an image to a target width and height.\n+\n+  Resizes an image to a target width and height by keeping\n+  the aspect ratio the same without distortion and padding\n+  it evenly with zeros.\n+\n+  Args:\n+    image: 4-D Tensor of shape `[batch, height, width, channels]` or\n+           3-D Tensor of shape `[height, width, channels]`.\n+    target_height: Target height.\n+    target_width: Target width.\n+    method: Method to use for resizing image. See `resize_images()`\n+\n+  Raises:\n+    ValueError: if `target_height` or `target_width` are zero or negative.\n+\n+  Returns:\n+    Resized and padded image.\n+    If `images` was 4-D, a 4-D float Tensor of shape\n+    `[batch, new_height, new_width, channels]`.\n+    If `images` was 3-D, a 3-D float Tensor of shape\n+    `[new_height, new_width, channels]`.\n+  \"\"\"\n+  with ops.name_scope(None, 'resize_image_aspect_with_pad', [image]):\n+    image = ops.convert_to_tensor(image, name='image')\n+    image_shape = image.get_shape()\n+    is_batch = True\n+    if image_shape.ndims == 3:\n+      is_batch = False\n+      image = array_ops.expand_dims(image, 0)\n+    elif image_shape.ndims is None:\n+      is_batch = False\n+      image = array_ops.expand_dims(image, 0)\n+      image.set_shape([None] * 4)\n+    elif image_shape.ndims != 4:\n+      raise ValueError('\\'image\\' must have either 3 or 4 dimensions.')\n+\n+    assert_ops = _CheckAtLeast3DImage(image, require_static=False)\n+    assert_ops += _assert(target_width > 0, ValueError,\n+                          'target_width must be > 0.')\n+    assert_ops += _assert(target_height > 0, ValueError,\n+                          'target_height must be > 0.')\n+\n+    image = control_flow_ops.with_dependencies(assert_ops, image)\n+    if _is_tensor(target_height):\n+      target_height = control_flow_ops.with_dependencies(\n+          assert_ops, target_height)\n+    if _is_tensor(target_width):\n+      target_width = control_flow_ops.with_dependencies(assert_ops,\n+                                                        target_width)\n+\n+    def max_(x, y):\n+      if _is_tensor(x) or _is_tensor(y):\n+        return math_ops.maximum(x, y)\n+      else:\n+        return max(x, y)\n+\n+    def equal_(x, y):\n+      if _is_tensor(x) or _is_tensor(y):\n+        return math_ops.equal(x, y)\n+      else:\n+        return x == y\n+\n+    _, height, width, _ = _ImageDimensions(image, rank=4)\n+\n+    # convert values to float, to ease divisions\n+    f_height = math_ops.cast(height, dtype=dtypes.float64)\n+    f_width = math_ops.cast(width, dtype=dtypes.float64)\n+    f_target_height = math_ops.cast(target_height, dtype=dtypes.float64)\n+    f_target_width = math_ops.cast(target_width, dtype=dtypes.float64)\n+\n+    # Find the ratio by which the image must be adjusted\n+    # to fit within the target\n+    ratio = max_(f_width / f_target_width, f_height / f_target_height)\n+    p_height_float = max_((f_target_height - (f_height / ratio)) * ratio / 2, 0)\n+    p_width_float = max_((f_target_width - (f_width / ratio)) * ratio / 2, 0)\n+    p_height = math_ops.cast(math_ops.ceil(p_height_float), dtype=dtypes.int32)\n+    p_width = math_ops.cast(math_ops.ceil(p_width_float), dtype=dtypes.int32)\n+\n+    padded_height = height + (p_height * 2)\n+    padded_width = width + (p_width * 2)\n+\n+    # Pad first, then resize to meet requested dimensions", "path": "tensorflow/python/ops/image_ops_impl.py", "position": null, "original_position": 90, "commit_id": "2863cd7f72d69cdbb94af7673873d1c83ac91a6a", "original_commit_id": "3443598eafb9d3f9e080c218b9ab281f75de2fb9", "user": {"login": "martinwicke", "id": 577277, "node_id": "MDQ6VXNlcjU3NzI3Nw==", "avatar_url": "https://avatars2.githubusercontent.com/u/577277?v=4", "gravatar_id": "", "url": "https://api.github.com/users/martinwicke", "html_url": "https://github.com/martinwicke", "followers_url": "https://api.github.com/users/martinwicke/followers", "following_url": "https://api.github.com/users/martinwicke/following{/other_user}", "gists_url": "https://api.github.com/users/martinwicke/gists{/gist_id}", "starred_url": "https://api.github.com/users/martinwicke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/martinwicke/subscriptions", "organizations_url": "https://api.github.com/users/martinwicke/orgs", "repos_url": "https://api.github.com/users/martinwicke/repos", "events_url": "https://api.github.com/users/martinwicke/events{/privacy}", "received_events_url": "https://api.github.com/users/martinwicke/received_events", "type": "User", "site_admin": false}, "body": "I would have expected you pad later... is there a reason you pad first (which is more expensive, and will make padding bleed into the border of the image)?", "created_at": "2018-04-16T19:13:29Z", "updated_at": "2018-06-18T20:25:08Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/17814#discussion_r181854175", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/17814", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/181854175"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/17814#discussion_r181854175"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/17814"}}, "body_html": "<p>I would have expected you pad later... is there a reason you pad first (which is more expensive, and will make padding bleed into the border of the image)?</p>", "body_text": "I would have expected you pad later... is there a reason you pad first (which is more expensive, and will make padding bleed into the border of the image)?"}