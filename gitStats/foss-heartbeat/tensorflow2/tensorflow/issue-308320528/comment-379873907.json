{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/379873907", "html_url": "https://github.com/tensorflow/tensorflow/issues/17979#issuecomment-379873907", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/17979", "id": 379873907, "node_id": "MDEyOklzc3VlQ29tbWVudDM3OTg3MzkwNw==", "user": {"login": "taiwotman", "id": 751668, "node_id": "MDQ6VXNlcjc1MTY2OA==", "avatar_url": "https://avatars1.githubusercontent.com/u/751668?v=4", "gravatar_id": "", "url": "https://api.github.com/users/taiwotman", "html_url": "https://github.com/taiwotman", "followers_url": "https://api.github.com/users/taiwotman/followers", "following_url": "https://api.github.com/users/taiwotman/following{/other_user}", "gists_url": "https://api.github.com/users/taiwotman/gists{/gist_id}", "starred_url": "https://api.github.com/users/taiwotman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/taiwotman/subscriptions", "organizations_url": "https://api.github.com/users/taiwotman/orgs", "repos_url": "https://api.github.com/users/taiwotman/repos", "events_url": "https://api.github.com/users/taiwotman/events{/privacy}", "received_events_url": "https://api.github.com/users/taiwotman/received_events", "type": "User", "site_admin": false}, "created_at": "2018-04-09T19:54:18Z", "updated_at": "2018-04-09T20:09:15Z", "author_association": "NONE", "body_html": "<p>I hope this problem would be ultimately solved in the long run. Meanwhile, I have had a workaround. For the main error, which is the InvalidArgumentError, I handled it in a try-catch block. This error often results from getting a wrong file format and even for a JPEG/JPG  which is derived from some corrupt file such as conversion from PNG to JPEG - so just think of it as a JPEG file that is not truly JPEG. Perhaps, having Tensorflow support other file types would finally nail this bug. The second error occurs when there is a real-time stream of data which at some point causes the <code>GraphDef to exceed its limit of 2GB</code>. This is handled by recreating the <code>graph</code> from the <code>tf.Graph</code> using <code>with graph.as_default()</code></p>\n<p>So here is my proposed solution:</p>\n<pre><code>import tensorflow as tf\nimport sys\nimport os\nimport urllib2\n\ndef tensorflow_pred(imageUrl):\n\n    #suppress TF log-info messages - remove to display TF logs \n    os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'\n\n    response = urllib2.urlopen(imageUrl)\n\n    image_data = response.read()\n\n    # Loads label file, strips off carriage return\n    label_lines = [line.rstrip() for line \n                    in tf.gfile.GFile(\"./retrained_labels.txt\")]\n    try:\n        \n          graph = tf.Graph()\n\n          with graph.as_default(): \n                 # Unpersists graph from file\n                  with tf.gfile.FastGFile(\"./retrained_graph.pb\", 'rb') as f:\n                  graph_def = tf.GraphDef()\n                  graph_def.ParseFromString(f.read())\n                _ = tf.import_graph_def(graph_def, name='')\n\n         with tf.Session() as sess:\n              # Feed the image_data as input to the graph and get first prediction\n              softmax_tensor = sess.graph.get_tensor_by_name('final_result:0')\n\n              predictions = sess.run(softmax_tensor, \\\n                {'DecodeJpeg/contents:0': image_data})\n        \n            # Sort to show labels of first prediction in order of confidence\n             top_k = predictions[0].argsort()[-len(predictions[0]):][::-1]\n        \n         for node_id in top_k:\n              classification = label_lines[node_id]\n              score = predictions[0][node_id]\n              if (score &gt;=0.5):\n                return ('%s (score = %.5f)' % (classification, score))\n  except tf.errors.InvalidArgumentError:\n            print ('Poor image quality, unable to predict')\n</code></pre>\n<p><strong>Ref:</strong> <a href=\"https://stackoverflow.com/questions/49414902/tensorflow-python-framework-errors-impl-invalidargumenterror\" rel=\"nofollow\">Tensorflow.python.framework.errors_impl.InvalidArgumentError</a> also raised by me.</p>", "body_text": "I hope this problem would be ultimately solved in the long run. Meanwhile, I have had a workaround. For the main error, which is the InvalidArgumentError, I handled it in a try-catch block. This error often results from getting a wrong file format and even for a JPEG/JPG  which is derived from some corrupt file such as conversion from PNG to JPEG - so just think of it as a JPEG file that is not truly JPEG. Perhaps, having Tensorflow support other file types would finally nail this bug. The second error occurs when there is a real-time stream of data which at some point causes the GraphDef to exceed its limit of 2GB. This is handled by recreating the graph from the tf.Graph using with graph.as_default()\nSo here is my proposed solution:\nimport tensorflow as tf\nimport sys\nimport os\nimport urllib2\n\ndef tensorflow_pred(imageUrl):\n\n    #suppress TF log-info messages - remove to display TF logs \n    os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'\n\n    response = urllib2.urlopen(imageUrl)\n\n    image_data = response.read()\n\n    # Loads label file, strips off carriage return\n    label_lines = [line.rstrip() for line \n                    in tf.gfile.GFile(\"./retrained_labels.txt\")]\n    try:\n        \n          graph = tf.Graph()\n\n          with graph.as_default(): \n                 # Unpersists graph from file\n                  with tf.gfile.FastGFile(\"./retrained_graph.pb\", 'rb') as f:\n                  graph_def = tf.GraphDef()\n                  graph_def.ParseFromString(f.read())\n                _ = tf.import_graph_def(graph_def, name='')\n\n         with tf.Session() as sess:\n              # Feed the image_data as input to the graph and get first prediction\n              softmax_tensor = sess.graph.get_tensor_by_name('final_result:0')\n\n              predictions = sess.run(softmax_tensor, \\\n                {'DecodeJpeg/contents:0': image_data})\n        \n            # Sort to show labels of first prediction in order of confidence\n             top_k = predictions[0].argsort()[-len(predictions[0]):][::-1]\n        \n         for node_id in top_k:\n              classification = label_lines[node_id]\n              score = predictions[0][node_id]\n              if (score >=0.5):\n                return ('%s (score = %.5f)' % (classification, score))\n  except tf.errors.InvalidArgumentError:\n            print ('Poor image quality, unable to predict')\n\nRef: Tensorflow.python.framework.errors_impl.InvalidArgumentError also raised by me.", "body": "I hope this problem would be ultimately solved in the long run. Meanwhile, I have had a workaround. For the main error, which is the InvalidArgumentError, I handled it in a try-catch block. This error often results from getting a wrong file format and even for a JPEG/JPG  which is derived from some corrupt file such as conversion from PNG to JPEG - so just think of it as a JPEG file that is not truly JPEG. Perhaps, having Tensorflow support other file types would finally nail this bug. The second error occurs when there is a real-time stream of data which at some point causes the `GraphDef to exceed its limit of 2GB`. This is handled by recreating the `graph` from the `tf.Graph` using `with graph.as_default()`\r\n\r\nSo here is my proposed solution:\r\n\r\n```\r\nimport tensorflow as tf\r\nimport sys\r\nimport os\r\nimport urllib2\r\n\r\ndef tensorflow_pred(imageUrl):\r\n\r\n    #suppress TF log-info messages - remove to display TF logs \r\n    os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'\r\n\r\n    response = urllib2.urlopen(imageUrl)\r\n\r\n    image_data = response.read()\r\n\r\n    # Loads label file, strips off carriage return\r\n    label_lines = [line.rstrip() for line \r\n                    in tf.gfile.GFile(\"./retrained_labels.txt\")]\r\n    try:\r\n        \r\n          graph = tf.Graph()\r\n\r\n          with graph.as_default(): \r\n                 # Unpersists graph from file\r\n                  with tf.gfile.FastGFile(\"./retrained_graph.pb\", 'rb') as f:\r\n                  graph_def = tf.GraphDef()\r\n                  graph_def.ParseFromString(f.read())\r\n                _ = tf.import_graph_def(graph_def, name='')\r\n\r\n         with tf.Session() as sess:\r\n              # Feed the image_data as input to the graph and get first prediction\r\n              softmax_tensor = sess.graph.get_tensor_by_name('final_result:0')\r\n\r\n              predictions = sess.run(softmax_tensor, \\\r\n                {'DecodeJpeg/contents:0': image_data})\r\n        \r\n            # Sort to show labels of first prediction in order of confidence\r\n             top_k = predictions[0].argsort()[-len(predictions[0]):][::-1]\r\n        \r\n         for node_id in top_k:\r\n              classification = label_lines[node_id]\r\n              score = predictions[0][node_id]\r\n              if (score >=0.5):\r\n                return ('%s (score = %.5f)' % (classification, score))\r\n  except tf.errors.InvalidArgumentError:\r\n            print ('Poor image quality, unable to predict')\r\n```\r\n\r\n**Ref:** [Tensorflow.python.framework.errors_impl.InvalidArgumentError](https://stackoverflow.com/questions/49414902/tensorflow-python-framework-errors-impl-invalidargumenterror) also raised by me."}