{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/405116052", "html_url": "https://github.com/tensorflow/tensorflow/issues/18736#issuecomment-405116052", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/18736", "id": 405116052, "node_id": "MDEyOklzc3VlQ29tbWVudDQwNTExNjA1Mg==", "user": {"login": "icantrell", "id": 25952257, "node_id": "MDQ6VXNlcjI1OTUyMjU3", "avatar_url": "https://avatars3.githubusercontent.com/u/25952257?v=4", "gravatar_id": "", "url": "https://api.github.com/users/icantrell", "html_url": "https://github.com/icantrell", "followers_url": "https://api.github.com/users/icantrell/followers", "following_url": "https://api.github.com/users/icantrell/following{/other_user}", "gists_url": "https://api.github.com/users/icantrell/gists{/gist_id}", "starred_url": "https://api.github.com/users/icantrell/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/icantrell/subscriptions", "organizations_url": "https://api.github.com/users/icantrell/orgs", "repos_url": "https://api.github.com/users/icantrell/repos", "events_url": "https://api.github.com/users/icantrell/events{/privacy}", "received_events_url": "https://api.github.com/users/icantrell/received_events", "type": "User", "site_admin": false}, "created_at": "2018-07-15T20:28:24Z", "updated_at": "2018-07-15T20:28:57Z", "author_association": "NONE", "body_html": "<p>It seems like it isjust a warning and the sysetm will still allocate the same amount of memory. here's the code...</p>\n<p>void* AlignedMalloc(size_t size, int minimum_alignment) {<br>\n#if defined(<strong>ANDROID</strong>)<br>\nreturn memalign(minimum_alignment, size);<br>\n#else  // !defined(<strong>ANDROID</strong>)<br>\nvoid* ptr = nullptr;<br>\n// posix_memalign requires that the requested alignment be at least<br>\n// sizeof(void*). In this case, fall back on malloc which should return<br>\n// memory aligned to at least the size of a pointer.<br>\nconst int required_alignment = sizeof(void*);<br>\nif (minimum_alignment &lt; required_alignment) return Malloc(size);<br>\n#ifdef TENSORFLOW_USE_JEMALLOC<br>\nint err = jemalloc_posix_memalign(&amp;ptr, minimum_alignment, size);<br>\n#else<br>\nint err = posix_memalign(&amp;ptr, minimum_alignment, size);<br>\n#endif<br>\nif (err != 0) {<br>\nreturn nullptr;<br>\n} else {<br>\nreturn ptr;<br>\n}<br>\n#endif<br>\n}</p>\n<p>CALLED BY....</p>\n<p>void* AllocateRaw(size_t alignment, size_t num_bytes) override {<br>\nif (num_bytes &gt; LargeAllocationWarningBytes() &amp;&amp;<br>\nsingle_allocation_warning_count_ &lt; kMaxSingleAllocationWarnings) {<br>\n++single_allocation_warning_count_;<br>\n<strong>LOG(WARNING) &lt;&lt; \"Allocation of \" &lt;&lt; num_bytes &lt;&lt; \" exceeds \"<br>\n&lt;&lt; 100 * kLargeAllocationWarningThreshold<br>\n&lt;&lt; \"% of system memory.\";<br>\n}</strong></p>\n<pre><code>void* p = port::AlignedMalloc(num_bytes, alignment);\nif (cpu_allocator_collect_stats) {\n  const std::size_t alloc_size = port::MallocExtension_GetAllocatedSize(p);\n  mutex_lock l(mu_);\n  ++stats_.num_allocs;\n  stats_.bytes_in_use += alloc_size;\n  stats_.max_bytes_in_use =\n      std::max&lt;int64&gt;(stats_.max_bytes_in_use, stats_.bytes_in_use);\n  stats_.max_alloc_size =\n      std::max&lt;int64&gt;(stats_.max_alloc_size, alloc_size);\n\n  if (stats_.bytes_in_use &gt; TotalAllocationWarningBytes() &amp;&amp;\n      total_allocation_warning_count_ &lt; kMaxTotalAllocationWarnings) {\n    ++total_allocation_warning_count_;\n    LOG(WARNING) &lt;&lt; \"Total allocated memory \" &lt;&lt; stats_.bytes_in_use\n                 &lt;&lt; \"exceeds \" &lt;&lt; 100 * kTotalAllocationWarningThreshold\n                 &lt;&lt; \"% of system memory\";\n  }\n}\nreturn p;\n</code></pre>\n<p>}</p>", "body_text": "It seems like it isjust a warning and the sysetm will still allocate the same amount of memory. here's the code...\nvoid* AlignedMalloc(size_t size, int minimum_alignment) {\n#if defined(ANDROID)\nreturn memalign(minimum_alignment, size);\n#else  // !defined(ANDROID)\nvoid* ptr = nullptr;\n// posix_memalign requires that the requested alignment be at least\n// sizeof(void*). In this case, fall back on malloc which should return\n// memory aligned to at least the size of a pointer.\nconst int required_alignment = sizeof(void*);\nif (minimum_alignment < required_alignment) return Malloc(size);\n#ifdef TENSORFLOW_USE_JEMALLOC\nint err = jemalloc_posix_memalign(&ptr, minimum_alignment, size);\n#else\nint err = posix_memalign(&ptr, minimum_alignment, size);\n#endif\nif (err != 0) {\nreturn nullptr;\n} else {\nreturn ptr;\n}\n#endif\n}\nCALLED BY....\nvoid* AllocateRaw(size_t alignment, size_t num_bytes) override {\nif (num_bytes > LargeAllocationWarningBytes() &&\nsingle_allocation_warning_count_ < kMaxSingleAllocationWarnings) {\n++single_allocation_warning_count_;\nLOG(WARNING) << \"Allocation of \" << num_bytes << \" exceeds \"\n<< 100 * kLargeAllocationWarningThreshold\n<< \"% of system memory.\";\n}\nvoid* p = port::AlignedMalloc(num_bytes, alignment);\nif (cpu_allocator_collect_stats) {\n  const std::size_t alloc_size = port::MallocExtension_GetAllocatedSize(p);\n  mutex_lock l(mu_);\n  ++stats_.num_allocs;\n  stats_.bytes_in_use += alloc_size;\n  stats_.max_bytes_in_use =\n      std::max<int64>(stats_.max_bytes_in_use, stats_.bytes_in_use);\n  stats_.max_alloc_size =\n      std::max<int64>(stats_.max_alloc_size, alloc_size);\n\n  if (stats_.bytes_in_use > TotalAllocationWarningBytes() &&\n      total_allocation_warning_count_ < kMaxTotalAllocationWarnings) {\n    ++total_allocation_warning_count_;\n    LOG(WARNING) << \"Total allocated memory \" << stats_.bytes_in_use\n                 << \"exceeds \" << 100 * kTotalAllocationWarningThreshold\n                 << \"% of system memory\";\n  }\n}\nreturn p;\n\n}", "body": "It seems like it isjust a warning and the sysetm will still allocate the same amount of memory. here's the code...\r\n\r\nvoid* AlignedMalloc(size_t size, int minimum_alignment) {\r\n#if defined(__ANDROID__)\r\n  return memalign(minimum_alignment, size);\r\n#else  // !defined(__ANDROID__)\r\n  void* ptr = nullptr;\r\n  // posix_memalign requires that the requested alignment be at least\r\n  // sizeof(void*). In this case, fall back on malloc which should return\r\n  // memory aligned to at least the size of a pointer.\r\n  const int required_alignment = sizeof(void*);\r\n  if (minimum_alignment < required_alignment) return Malloc(size);\r\n#ifdef TENSORFLOW_USE_JEMALLOC\r\n  int err = jemalloc_posix_memalign(&ptr, minimum_alignment, size);\r\n#else\r\n  int err = posix_memalign(&ptr, minimum_alignment, size);\r\n#endif\r\n  if (err != 0) {\r\n    return nullptr;\r\n  } else {\r\n    return ptr;\r\n  }\r\n#endif\r\n}\r\n\r\nCALLED BY....\r\n\r\nvoid* AllocateRaw(size_t alignment, size_t num_bytes) override {\r\n    if (num_bytes > LargeAllocationWarningBytes() &&\r\n        single_allocation_warning_count_ < kMaxSingleAllocationWarnings) {\r\n      ++single_allocation_warning_count_;\r\n      **LOG(WARNING) << \"Allocation of \" << num_bytes << \" exceeds \"\r\n                   << 100 * kLargeAllocationWarningThreshold\r\n                   << \"% of system memory.\";\r\n    }**\r\n\r\n    void* p = port::AlignedMalloc(num_bytes, alignment);\r\n    if (cpu_allocator_collect_stats) {\r\n      const std::size_t alloc_size = port::MallocExtension_GetAllocatedSize(p);\r\n      mutex_lock l(mu_);\r\n      ++stats_.num_allocs;\r\n      stats_.bytes_in_use += alloc_size;\r\n      stats_.max_bytes_in_use =\r\n          std::max<int64>(stats_.max_bytes_in_use, stats_.bytes_in_use);\r\n      stats_.max_alloc_size =\r\n          std::max<int64>(stats_.max_alloc_size, alloc_size);\r\n\r\n      if (stats_.bytes_in_use > TotalAllocationWarningBytes() &&\r\n          total_allocation_warning_count_ < kMaxTotalAllocationWarnings) {\r\n        ++total_allocation_warning_count_;\r\n        LOG(WARNING) << \"Total allocated memory \" << stats_.bytes_in_use\r\n                     << \"exceeds \" << 100 * kTotalAllocationWarningThreshold\r\n                     << \"% of system memory\";\r\n      }\r\n    }\r\n    return p;\r\n}"}