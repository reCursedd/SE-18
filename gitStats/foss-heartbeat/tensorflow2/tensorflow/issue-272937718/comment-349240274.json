{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/349240274", "html_url": "https://github.com/tensorflow/tensorflow/issues/14448#issuecomment-349240274", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/14448", "id": 349240274, "node_id": "MDEyOklzc3VlQ29tbWVudDM0OTI0MDI3NA==", "user": {"login": "boeddeker", "id": 13744128, "node_id": "MDQ6VXNlcjEzNzQ0MTI4", "avatar_url": "https://avatars3.githubusercontent.com/u/13744128?v=4", "gravatar_id": "", "url": "https://api.github.com/users/boeddeker", "html_url": "https://github.com/boeddeker", "followers_url": "https://api.github.com/users/boeddeker/followers", "following_url": "https://api.github.com/users/boeddeker/following{/other_user}", "gists_url": "https://api.github.com/users/boeddeker/gists{/gist_id}", "starred_url": "https://api.github.com/users/boeddeker/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/boeddeker/subscriptions", "organizations_url": "https://api.github.com/users/boeddeker/orgs", "repos_url": "https://api.github.com/users/boeddeker/repos", "events_url": "https://api.github.com/users/boeddeker/events{/privacy}", "received_events_url": "https://api.github.com/users/boeddeker/received_events", "type": "User", "site_admin": false}, "created_at": "2017-12-05T09:05:41Z", "updated_at": "2017-12-05T09:05:41Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Ok, I will make a PR for improving <code>tf.pyfunc</code>. I argee backward compatibility is important, but maybe rename some arguments would be better:</p>\n<p>Current signature:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">def</span> <span class=\"pl-en\">py_func</span>(<span class=\"pl-smi\">func</span>, <span class=\"pl-smi\">inp</span>, <span class=\"pl-smi\">Tout</span>, <span class=\"pl-smi\">stateful</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">True</span>, <span class=\"pl-smi\">name</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">None</span>)</pre></div>\n<p>My prefared signature (similar to tf.data.Dataset.from_generator): (Note: output_types should not have a default argument.)</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">def</span> <span class=\"pl-en\">my_py_func</span>(<span class=\"pl-smi\">func</span>, <span class=\"pl-smi\">args</span><span class=\"pl-k\">=</span>(), <span class=\"pl-smi\">kwargs</span><span class=\"pl-k\">=</span>{}, <span class=\"pl-smi\">output_types</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">None</span>, <span class=\"pl-smi\">output_shapes</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">None</span>, <span class=\"pl-smi\">stateful</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">True</span>, <span class=\"pl-smi\">name</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">None</span>)</pre></div>\n<p>Suggestion for better backward compatibility:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">def</span> <span class=\"pl-en\">my_py_func</span>(<span class=\"pl-smi\">func</span>, <span class=\"pl-smi\">inp</span><span class=\"pl-k\">=</span>(), <span class=\"pl-smi\">kwargs</span><span class=\"pl-k\">=</span>{}, <span class=\"pl-smi\">Tout</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">None</span>, <span class=\"pl-smi\">Sout</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">None</span>, <span class=\"pl-smi\">stateful</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">True</span>, <span class=\"pl-smi\">name</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">None</span>)</pre></div>\n<p>Note: An advantage of a decorator would be, that args and kwargs can be inferred (See example from_indexable).</p>\n<p>You are right <code>from_indexable</code> takes only some few lines of code. For completeness here the code:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">def</span> <span class=\"pl-en\">from_indexable</span>(<span class=\"pl-smi\">iterator</span>, <span class=\"pl-smi\">output_types</span>, <span class=\"pl-smi\">output_shapes</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">None</span>, <span class=\"pl-smi\">num_parallel_calls</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">None</span>, <span class=\"pl-smi\">stateful</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">True</span>, <span class=\"pl-smi\">name</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">None</span>):\n    length <span class=\"pl-k\">=</span> \n    ds <span class=\"pl-k\">=</span> tf.data.Dataset.range(<span class=\"pl-c1\">len</span>(iterator))\n    <span class=\"pl-en\">@py_func_decorator</span>(output_types, output_shapes, <span class=\"pl-v\">stateful</span><span class=\"pl-k\">=</span>stateful, <span class=\"pl-v\">name</span><span class=\"pl-k\">=</span>name)\n    <span class=\"pl-k\">def</span> <span class=\"pl-en\">index_to_entry</span>(<span class=\"pl-smi\">index</span>):\n        <span class=\"pl-k\">return</span> iterator[index]\n    <span class=\"pl-k\">return</span> ds.map(index_to_entry, <span class=\"pl-v\">num_parallel_calls</span><span class=\"pl-k\">=</span>num_parallel_calls)\n</pre></div>", "body_text": "Ok, I will make a PR for improving tf.pyfunc. I argee backward compatibility is important, but maybe rename some arguments would be better:\nCurrent signature:\ndef py_func(func, inp, Tout, stateful=True, name=None)\nMy prefared signature (similar to tf.data.Dataset.from_generator): (Note: output_types should not have a default argument.)\ndef my_py_func(func, args=(), kwargs={}, output_types=None, output_shapes=None, stateful=True, name=None)\nSuggestion for better backward compatibility:\ndef my_py_func(func, inp=(), kwargs={}, Tout=None, Sout=None, stateful=True, name=None)\nNote: An advantage of a decorator would be, that args and kwargs can be inferred (See example from_indexable).\nYou are right from_indexable takes only some few lines of code. For completeness here the code:\ndef from_indexable(iterator, output_types, output_shapes=None, num_parallel_calls=None, stateful=True, name=None):\n    length = \n    ds = tf.data.Dataset.range(len(iterator))\n    @py_func_decorator(output_types, output_shapes, stateful=stateful, name=name)\n    def index_to_entry(index):\n        return iterator[index]\n    return ds.map(index_to_entry, num_parallel_calls=num_parallel_calls)", "body": "Ok, I will make a PR for improving `tf.pyfunc`. I argee backward compatibility is important, but maybe rename some arguments would be better:\r\n\r\nCurrent signature:\r\n```python\r\ndef py_func(func, inp, Tout, stateful=True, name=None)\r\n```\r\nMy prefared signature (similar to tf.data.Dataset.from_generator): (Note: output_types should not have a default argument.)\r\n```python\r\ndef my_py_func(func, args=(), kwargs={}, output_types=None, output_shapes=None, stateful=True, name=None)\r\n```\r\nSuggestion for better backward compatibility:\r\n```python\r\ndef my_py_func(func, inp=(), kwargs={}, Tout=None, Sout=None, stateful=True, name=None)\r\n```\r\n\r\nNote: An advantage of a decorator would be, that args and kwargs can be inferred (See example from_indexable).\r\n\r\nYou are right `from_indexable` takes only some few lines of code. For completeness here the code:\r\n\r\n```python\r\ndef from_indexable(iterator, output_types, output_shapes=None, num_parallel_calls=None, stateful=True, name=None):\r\n    length = \r\n    ds = tf.data.Dataset.range(len(iterator))\r\n    @py_func_decorator(output_types, output_shapes, stateful=stateful, name=name)\r\n    def index_to_entry(index):\r\n        return iterator[index]\r\n    return ds.map(index_to_entry, num_parallel_calls=num_parallel_calls)\r\n\r\n```"}