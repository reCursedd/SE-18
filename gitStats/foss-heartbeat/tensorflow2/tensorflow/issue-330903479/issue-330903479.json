{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/19880", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/19880/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/19880/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/19880/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/19880", "id": 330903479, "node_id": "MDU6SXNzdWUzMzA5MDM0Nzk=", "number": 19880, "title": "tf.image.resize_* gives negative results", "user": {"login": "Luonic", "id": 13236173, "node_id": "MDQ6VXNlcjEzMjM2MTcz", "avatar_url": "https://avatars1.githubusercontent.com/u/13236173?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Luonic", "html_url": "https://github.com/Luonic", "followers_url": "https://api.github.com/users/Luonic/followers", "following_url": "https://api.github.com/users/Luonic/following{/other_user}", "gists_url": "https://api.github.com/users/Luonic/gists{/gist_id}", "starred_url": "https://api.github.com/users/Luonic/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Luonic/subscriptions", "organizations_url": "https://api.github.com/users/Luonic/orgs", "repos_url": "https://api.github.com/users/Luonic/repos", "events_url": "https://api.github.com/users/Luonic/events{/privacy}", "received_events_url": "https://api.github.com/users/Luonic/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 386191887, "node_id": "MDU6TGFiZWwzODYxOTE4ODc=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:awaiting%20response", "name": "stat:awaiting response", "color": "f4b400", "default": false}], "state": "closed", "locked": false, "assignee": {"login": "cwhipkey", "id": 17578177, "node_id": "MDQ6VXNlcjE3NTc4MTc3", "avatar_url": "https://avatars0.githubusercontent.com/u/17578177?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cwhipkey", "html_url": "https://github.com/cwhipkey", "followers_url": "https://api.github.com/users/cwhipkey/followers", "following_url": "https://api.github.com/users/cwhipkey/following{/other_user}", "gists_url": "https://api.github.com/users/cwhipkey/gists{/gist_id}", "starred_url": "https://api.github.com/users/cwhipkey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cwhipkey/subscriptions", "organizations_url": "https://api.github.com/users/cwhipkey/orgs", "repos_url": "https://api.github.com/users/cwhipkey/repos", "events_url": "https://api.github.com/users/cwhipkey/events{/privacy}", "received_events_url": "https://api.github.com/users/cwhipkey/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "cwhipkey", "id": 17578177, "node_id": "MDQ6VXNlcjE3NTc4MTc3", "avatar_url": "https://avatars0.githubusercontent.com/u/17578177?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cwhipkey", "html_url": "https://github.com/cwhipkey", "followers_url": "https://api.github.com/users/cwhipkey/followers", "following_url": "https://api.github.com/users/cwhipkey/following{/other_user}", "gists_url": "https://api.github.com/users/cwhipkey/gists{/gist_id}", "starred_url": "https://api.github.com/users/cwhipkey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cwhipkey/subscriptions", "organizations_url": "https://api.github.com/users/cwhipkey/orgs", "repos_url": "https://api.github.com/users/cwhipkey/repos", "events_url": "https://api.github.com/users/cwhipkey/events{/privacy}", "received_events_url": "https://api.github.com/users/cwhipkey/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 8, "created_at": "2018-06-09T17:05:22Z", "updated_at": "2018-08-15T02:57:09Z", "closed_at": "2018-08-15T02:49:03Z", "author_association": "NONE", "body_html": "<h3>System information</h3>\n<ul>\n<li><strong>Have I written custom code (as opposed to using a stock example script provided in TensorFlow)</strong>: Yes</li>\n<li><strong>OS Platform and Distribution (e.g., Linux Ubuntu 16.04)</strong>: Ubuntu 16.04</li>\n<li><strong>TensorFlow installed from (source or binary)</strong>: source</li>\n<li><strong>TensorFlow version (use command below)</strong>:  v1.8.0-7-g3b85959 1.8.0</li>\n<li><strong>Python version</strong>: 3.5.2</li>\n<li><strong>Bazel version (if compiling from source)</strong>: 0.14.0</li>\n<li><strong>GCC/Compiler version (if compiling from source)</strong>: 5.4.0</li>\n<li><strong>CUDA/cuDNN version</strong>: N/A</li>\n<li><strong>GPU model and memory</strong>: N/A</li>\n<li><strong>Exact command to reproduce</strong>: N/A</li>\n</ul>\n<h3>Describe the problem</h3>\n<p>I am trying to segment images using Pascal VOC 2012. I converted indexed pngs to grayscale, replaced pixels with value 255 with 0 and written them to tfrecord. Then when reading image with tf.data.Dataset i want to resize all images to constant scale at min dim and then randomly crop to square. Problem is that when i am resizing label tensor with tf.image.resize_bicubic some values are negative but in input tensor threre is no negative values.</p>\n<p><strong>UPD</strong>: Bicubc not only gives negative values but also changes it where it should not<br>\nLook at the right image:<br>\n<a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://user-images.githubusercontent.com/13236173/41194731-12a93bc0-6c29-11e8-8793-2b40f7fa6e0d.png\"><img src=\"https://user-images.githubusercontent.com/13236173/41194731-12a93bc0-6c29-11e8-8793-2b40f7fa6e0d.png\" alt=\"image\" style=\"max-width:100%;\"></a></p>\n<h3>Source code / logs</h3>\n<p>Here is run log:</p>\n<pre><code>uint8_label_after_decode[0]\nuint8_label_after_decode[0]\nuint8_label_after_decode[0]\nuint8_label_after_decode[0]\nuint8_label_after_resize[-2.43790507]\nuint8_label_after_resize[-0.208821028]\nuint8_label_after_resize[-3.43527746]\nuint8_label_after_resize[-2.6129365]\n2018-06-09 19:45:09.765736: W tensorflow/core/framework/op_kernel.cc:1318] OP_REQUIRES failed at sparse_xent_op.cc:90 : Invalid argument: Received a label value of -2 which is outside the valid range of [0, 21). \n</code></pre>\n<pre><code>def resize_image_keep_aspect_ratio(image, max_height, max_width, use_min_ratio, use_nn_interpolation=False):\n    def compute_new_dims(height, width, max_height, max_width, use_min_ratio):\n        # If use_min_ratio is set to true than image will be resized to max of smaller dim\n        height_float = tf.cast(height, tf.float32)\n        width_float = tf.cast(width, tf.float32)\n        max_height_float = tf.cast(max_height, tf.float32)\n        max_width_float = tf.cast(max_width, tf.float32)\n\n        height_ratio = height_float / max_height_float\n        widht_ratio = width_float / max_width_float\n\n        if use_min_ratio:\n            ratio = tf.minimum(height_ratio, widht_ratio)\n        else:\n            ratio = tf.maximum(height_ratio, widht_ratio)\n\n        new_height = tf.cast(tf.floor(height_float / ratio), tf.int32)\n        new_width = tf.cast(tf.floor(width_float / ratio), tf.int32)\n\n        return (new_height, new_width)\n\n    shape = tf.shape(image)\n    height = shape[0]\n    width = shape[1]\n\n    new_height_and_width = compute_new_dims(height, width, max_height, max_width, use_min_ratio=use_min_ratio)\n\n    image = tf.expand_dims(image, 0)\n    if use_nn_interpolation:\n        image = tf.image.resize_nearest_neighbor(image, tf.stack(new_height_and_width), align_corners=True)\n    else:\n        image = tf.image.resize_bicubic(image, tf.stack(new_height_and_width), align_corners=True)\n    image = tf.squeeze(image, [0])\n    return image\n\n\n# Here I am decoding image in tf.data.Dataset\nlabel = tf.image.decode_image(example_parsed['label'], channels=1)\nlabel = tf.Print(label, [tf.reduce_min(label)], 'uint8_label_after_decode')\nlabel = tf.cast(label, tf.float32)\nlabel = resize_image_keep_aspect_ratio(label, image_size[0], image_size[1], use_min_ratio=True, \n  use_nn_interpolation=False)\nlabel = tf.Print(label, [tf.reduce_min(label)], 'uint8_label_after_resize')\nimage_and_label = tf.concat([image, label], axis=2)\ncropped_image_and_label = tf.random_crop(image_and_label, [image_size[0], image_size[1], 4])\nimage, label = tf.split(cropped_image_and_label, [3, 1], axis=2)\nimage = tf.cast(image, float_type) * (2.0 / 255.0) - 1.0\nlabel = tf.cast(label, tf.int64)\n</code></pre>", "body_text": "System information\n\nHave I written custom code (as opposed to using a stock example script provided in TensorFlow): Yes\nOS Platform and Distribution (e.g., Linux Ubuntu 16.04): Ubuntu 16.04\nTensorFlow installed from (source or binary): source\nTensorFlow version (use command below):  v1.8.0-7-g3b85959 1.8.0\nPython version: 3.5.2\nBazel version (if compiling from source): 0.14.0\nGCC/Compiler version (if compiling from source): 5.4.0\nCUDA/cuDNN version: N/A\nGPU model and memory: N/A\nExact command to reproduce: N/A\n\nDescribe the problem\nI am trying to segment images using Pascal VOC 2012. I converted indexed pngs to grayscale, replaced pixels with value 255 with 0 and written them to tfrecord. Then when reading image with tf.data.Dataset i want to resize all images to constant scale at min dim and then randomly crop to square. Problem is that when i am resizing label tensor with tf.image.resize_bicubic some values are negative but in input tensor threre is no negative values.\nUPD: Bicubc not only gives negative values but also changes it where it should not\nLook at the right image:\n\nSource code / logs\nHere is run log:\nuint8_label_after_decode[0]\nuint8_label_after_decode[0]\nuint8_label_after_decode[0]\nuint8_label_after_decode[0]\nuint8_label_after_resize[-2.43790507]\nuint8_label_after_resize[-0.208821028]\nuint8_label_after_resize[-3.43527746]\nuint8_label_after_resize[-2.6129365]\n2018-06-09 19:45:09.765736: W tensorflow/core/framework/op_kernel.cc:1318] OP_REQUIRES failed at sparse_xent_op.cc:90 : Invalid argument: Received a label value of -2 which is outside the valid range of [0, 21). \n\ndef resize_image_keep_aspect_ratio(image, max_height, max_width, use_min_ratio, use_nn_interpolation=False):\n    def compute_new_dims(height, width, max_height, max_width, use_min_ratio):\n        # If use_min_ratio is set to true than image will be resized to max of smaller dim\n        height_float = tf.cast(height, tf.float32)\n        width_float = tf.cast(width, tf.float32)\n        max_height_float = tf.cast(max_height, tf.float32)\n        max_width_float = tf.cast(max_width, tf.float32)\n\n        height_ratio = height_float / max_height_float\n        widht_ratio = width_float / max_width_float\n\n        if use_min_ratio:\n            ratio = tf.minimum(height_ratio, widht_ratio)\n        else:\n            ratio = tf.maximum(height_ratio, widht_ratio)\n\n        new_height = tf.cast(tf.floor(height_float / ratio), tf.int32)\n        new_width = tf.cast(tf.floor(width_float / ratio), tf.int32)\n\n        return (new_height, new_width)\n\n    shape = tf.shape(image)\n    height = shape[0]\n    width = shape[1]\n\n    new_height_and_width = compute_new_dims(height, width, max_height, max_width, use_min_ratio=use_min_ratio)\n\n    image = tf.expand_dims(image, 0)\n    if use_nn_interpolation:\n        image = tf.image.resize_nearest_neighbor(image, tf.stack(new_height_and_width), align_corners=True)\n    else:\n        image = tf.image.resize_bicubic(image, tf.stack(new_height_and_width), align_corners=True)\n    image = tf.squeeze(image, [0])\n    return image\n\n\n# Here I am decoding image in tf.data.Dataset\nlabel = tf.image.decode_image(example_parsed['label'], channels=1)\nlabel = tf.Print(label, [tf.reduce_min(label)], 'uint8_label_after_decode')\nlabel = tf.cast(label, tf.float32)\nlabel = resize_image_keep_aspect_ratio(label, image_size[0], image_size[1], use_min_ratio=True, \n  use_nn_interpolation=False)\nlabel = tf.Print(label, [tf.reduce_min(label)], 'uint8_label_after_resize')\nimage_and_label = tf.concat([image, label], axis=2)\ncropped_image_and_label = tf.random_crop(image_and_label, [image_size[0], image_size[1], 4])\nimage, label = tf.split(cropped_image_and_label, [3, 1], axis=2)\nimage = tf.cast(image, float_type) * (2.0 / 255.0) - 1.0\nlabel = tf.cast(label, tf.int64)", "body": "### System information\r\n- **Have I written custom code (as opposed to using a stock example script provided in TensorFlow)**: Yes\r\n- **OS Platform and Distribution (e.g., Linux Ubuntu 16.04)**: Ubuntu 16.04\r\n- **TensorFlow installed from (source or binary)**: source\r\n- **TensorFlow version (use command below)**:  v1.8.0-7-g3b85959 1.8.0\r\n- **Python version**: 3.5.2\r\n- **Bazel version (if compiling from source)**: 0.14.0\r\n- **GCC/Compiler version (if compiling from source)**: 5.4.0\r\n- **CUDA/cuDNN version**: N/A\r\n- **GPU model and memory**: N/A\r\n- **Exact command to reproduce**: N/A\r\n\r\n### Describe the problem\r\nI am trying to segment images using Pascal VOC 2012. I converted indexed pngs to grayscale, replaced pixels with value 255 with 0 and written them to tfrecord. Then when reading image with tf.data.Dataset i want to resize all images to constant scale at min dim and then randomly crop to square. Problem is that when i am resizing label tensor with tf.image.resize_bicubic some values are negative but in input tensor threre is no negative values.\r\n\r\n**UPD**: Bicubc not only gives negative values but also changes it where it should not\r\nLook at the right image:\r\n![image](https://user-images.githubusercontent.com/13236173/41194731-12a93bc0-6c29-11e8-8793-2b40f7fa6e0d.png)\r\n\r\n\r\n### Source code / logs\r\nHere is run log:\r\n```\r\nuint8_label_after_decode[0]\r\nuint8_label_after_decode[0]\r\nuint8_label_after_decode[0]\r\nuint8_label_after_decode[0]\r\nuint8_label_after_resize[-2.43790507]\r\nuint8_label_after_resize[-0.208821028]\r\nuint8_label_after_resize[-3.43527746]\r\nuint8_label_after_resize[-2.6129365]\r\n2018-06-09 19:45:09.765736: W tensorflow/core/framework/op_kernel.cc:1318] OP_REQUIRES failed at sparse_xent_op.cc:90 : Invalid argument: Received a label value of -2 which is outside the valid range of [0, 21). \r\n```\r\n\r\n```\r\ndef resize_image_keep_aspect_ratio(image, max_height, max_width, use_min_ratio, use_nn_interpolation=False):\r\n    def compute_new_dims(height, width, max_height, max_width, use_min_ratio):\r\n        # If use_min_ratio is set to true than image will be resized to max of smaller dim\r\n        height_float = tf.cast(height, tf.float32)\r\n        width_float = tf.cast(width, tf.float32)\r\n        max_height_float = tf.cast(max_height, tf.float32)\r\n        max_width_float = tf.cast(max_width, tf.float32)\r\n\r\n        height_ratio = height_float / max_height_float\r\n        widht_ratio = width_float / max_width_float\r\n\r\n        if use_min_ratio:\r\n            ratio = tf.minimum(height_ratio, widht_ratio)\r\n        else:\r\n            ratio = tf.maximum(height_ratio, widht_ratio)\r\n\r\n        new_height = tf.cast(tf.floor(height_float / ratio), tf.int32)\r\n        new_width = tf.cast(tf.floor(width_float / ratio), tf.int32)\r\n\r\n        return (new_height, new_width)\r\n\r\n    shape = tf.shape(image)\r\n    height = shape[0]\r\n    width = shape[1]\r\n\r\n    new_height_and_width = compute_new_dims(height, width, max_height, max_width, use_min_ratio=use_min_ratio)\r\n\r\n    image = tf.expand_dims(image, 0)\r\n    if use_nn_interpolation:\r\n        image = tf.image.resize_nearest_neighbor(image, tf.stack(new_height_and_width), align_corners=True)\r\n    else:\r\n        image = tf.image.resize_bicubic(image, tf.stack(new_height_and_width), align_corners=True)\r\n    image = tf.squeeze(image, [0])\r\n    return image\r\n\r\n\r\n# Here I am decoding image in tf.data.Dataset\r\nlabel = tf.image.decode_image(example_parsed['label'], channels=1)\r\nlabel = tf.Print(label, [tf.reduce_min(label)], 'uint8_label_after_decode')\r\nlabel = tf.cast(label, tf.float32)\r\nlabel = resize_image_keep_aspect_ratio(label, image_size[0], image_size[1], use_min_ratio=True, \r\n  use_nn_interpolation=False)\r\nlabel = tf.Print(label, [tf.reduce_min(label)], 'uint8_label_after_resize')\r\nimage_and_label = tf.concat([image, label], axis=2)\r\ncropped_image_and_label = tf.random_crop(image_and_label, [image_size[0], image_size[1], 4])\r\nimage, label = tf.split(cropped_image_and_label, [3, 1], axis=2)\r\nimage = tf.cast(image, float_type) * (2.0 / 255.0) - 1.0\r\nlabel = tf.cast(label, tf.int64)\r\n```"}