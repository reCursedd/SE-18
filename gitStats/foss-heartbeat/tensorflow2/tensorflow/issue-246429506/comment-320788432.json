{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/320788432", "html_url": "https://github.com/tensorflow/tensorflow/issues/11856#issuecomment-320788432", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/11856", "id": 320788432, "node_id": "MDEyOklzc3VlQ29tbWVudDMyMDc4ODQzMg==", "user": {"login": "yaroslavvb", "id": 23068, "node_id": "MDQ6VXNlcjIzMDY4", "avatar_url": "https://avatars3.githubusercontent.com/u/23068?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yaroslavvb", "html_url": "https://github.com/yaroslavvb", "followers_url": "https://api.github.com/users/yaroslavvb/followers", "following_url": "https://api.github.com/users/yaroslavvb/following{/other_user}", "gists_url": "https://api.github.com/users/yaroslavvb/gists{/gist_id}", "starred_url": "https://api.github.com/users/yaroslavvb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yaroslavvb/subscriptions", "organizations_url": "https://api.github.com/users/yaroslavvb/orgs", "repos_url": "https://api.github.com/users/yaroslavvb/repos", "events_url": "https://api.github.com/users/yaroslavvb/events{/privacy}", "received_events_url": "https://api.github.com/users/yaroslavvb/received_events", "type": "User", "site_admin": false}, "created_at": "2017-08-07T21:40:23Z", "updated_at": "2017-08-07T21:40:23Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=4221553\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/chihuahua\">@chihuahua</a> IMHO this is a counter-intuitive property of graph-based system rather than a bug --<br>\nyou always need to create a new graph node if you want constraints enforced by surrounding context managers to be enforced.</p>\n<p>In your case,<code>v</code> reuses previously created graph node which doesn't know about your desired execution order, whereas  <code>v.read_value()</code> will create a new node which respects the control dependency</p>", "body_text": "@chihuahua IMHO this is a counter-intuitive property of graph-based system rather than a bug --\nyou always need to create a new graph node if you want constraints enforced by surrounding context managers to be enforced.\nIn your case,v reuses previously created graph node which doesn't know about your desired execution order, whereas  v.read_value() will create a new node which respects the control dependency", "body": "@chihuahua IMHO this is a counter-intuitive property of graph-based system rather than a bug --\r\n you always need to create a new graph node if you want constraints enforced by surrounding context managers to be enforced.\r\n\r\nIn your case,`v` reuses previously created graph node which doesn't know about your desired execution order, whereas  `v.read_value()` will create a new node which respects the control dependency"}