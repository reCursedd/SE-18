{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/203182098", "pull_request_review_id": 138022985, "id": 203182098, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMzE4MjA5OA==", "diff_hunk": "@@ -0,0 +1,664 @@\n+# -*- Python -*-\n+\"\"\"Repository rule for ROCm autoconfiguration.\n+\n+`rocm_configure` depends on the following environment variables:\n+\n+  * `TF_NEED_ROCM`: Whether to enable building with ROCm.\n+  * `GCC_HOST_COMPILER_PATH`: The GCC host compiler path\n+  * `ROCM_TOOLKIT_PATH`: The path to the ROCm toolkit. Default is\n+    `/opt/rocm`.\n+  * `TF_ROCM_VERSION`: The version of the ROCm toolkit. If this is blank, then\n+    use the system default.\n+  * `TF_MIOPEN_VERSION`: The version of the MIOpen library.\n+  * `TF_ROCM_AMDGPU_TARGETS`: The AMDGPU targets. Default is\n+    `gfx803,gfx900`.\n+\"\"\"\n+\n+_GCC_HOST_COMPILER_PATH = \"GCC_HOST_COMPILER_PATH\"\n+_ROCM_TOOLKIT_PATH = \"ROCM_TOOLKIT_PATH\"\n+_TF_ROCM_VERSION = \"TF_ROCM_VERSION\"\n+_TF_MIOPEN_VERSION = \"TF_MIOPEN_VERSION\"\n+_TF_ROCM_AMDGPU_TARGETS = \"TF_ROCM_AMDGPU_TARGETS\"\n+_TF_ROCM_CONFIG_REPO = \"TF_ROCM_CONFIG_REPO\"\n+\n+_DEFAULT_ROCM_VERSION = \"\"\n+_DEFAULT_MIOPEN_VERSION = \"\"\n+_DEFAULT_ROCM_TOOLKIT_PATH = \"/opt/rocm\"\n+_DEFAULT_ROCM_AMDGPU_TARGETS = [\"gfx803\", \"gfx900\"]\n+\n+def find_cc(repository_ctx):\n+  \"\"\"Find the C++ compiler.\"\"\"\n+  # Return a dummy value for GCC detection here to avoid error\n+  target_cc_name = \"gcc\"\n+  cc_path_envvar = _GCC_HOST_COMPILER_PATH\n+  cc_name = target_cc_name\n+\n+  if cc_path_envvar in repository_ctx.os.environ:\n+    cc_name_from_env = repository_ctx.os.environ[cc_path_envvar].strip()\n+    if cc_name_from_env:\n+      cc_name = cc_name_from_env\n+  if cc_name.startswith(\"/\"):\n+    # Absolute path, maybe we should make this supported by our which function.\n+    return cc_name\n+  cc = repository_ctx.which(cc_name)\n+  if cc == None:\n+    fail((\"Cannot find {}, either correct your path or set the {}\" +\n+          \" environment variable\").format(target_cc_name, cc_path_envvar))\n+  return cc\n+\n+_INC_DIR_MARKER_BEGIN = \"#include <...>\"\n+\n+def _cxx_inc_convert(path):\n+  \"\"\"Convert path returned by cc -E xc++ in a complete path.\"\"\"\n+  path = path.strip()\n+  return path\n+\n+def _get_cxx_inc_directories_impl(repository_ctx, cc, lang_is_cpp):\n+  \"\"\"Compute the list of default C or C++ include directories.\"\"\"\n+  if lang_is_cpp:\n+    lang = \"c++\"\n+  else:\n+    lang = \"c\"\n+  # TODO: We pass -no-canonical-prefixes here to match the compiler flags,\n+  #       but in rocm_clang CROSSTOOL file that is a `feature` and we should\n+  #       handle the case when it's disabled and no flag is passed\n+  result = repository_ctx.execute([cc, \"-no-canonical-prefixes\",\n+                                   \"-E\", \"-x\" + lang, \"-\", \"-v\"])\n+  index1 = result.stderr.find(_INC_DIR_MARKER_BEGIN)\n+  if index1 == -1:\n+    return []\n+  index1 = result.stderr.find(\"\\n\", index1)\n+  if index1 == -1:\n+    return []\n+  index2 = result.stderr.rfind(\"\\n \")\n+  if index2 == -1 or index2 < index1:\n+    return []\n+  index2 = result.stderr.find(\"\\n\", index2 + 1)\n+  if index2 == -1:\n+    inc_dirs = result.stderr[index1 + 1:]\n+  else:\n+    inc_dirs = result.stderr[index1 + 1:index2].strip()\n+\n+  return [str(repository_ctx.path(_cxx_inc_convert(p)))\n+          for p in inc_dirs.split(\"\\n\")]\n+\n+def get_cxx_inc_directories(repository_ctx, cc):\n+  \"\"\"Compute the list of default C and C++ include directories.\"\"\"\n+  # For some reason `clang -xc` sometimes returns include paths that are\n+  # different from the ones from `clang -xc++`. (Symlink and a dir)\n+  # So we run the compiler with both `-xc` and `-xc++` and merge resulting lists\n+  includes_cpp = _get_cxx_inc_directories_impl(repository_ctx, cc, True)\n+  includes_c = _get_cxx_inc_directories_impl(repository_ctx, cc, False)\n+\n+  includes_cpp_set = depset(includes_cpp)\n+  return includes_cpp + [inc for inc in includes_c\n+                         if inc not in includes_cpp_set]\n+\n+def auto_configure_fail(msg):\n+  \"\"\"Output failure message when rocm configuration fails.\"\"\"\n+  red = \"\\033[0;31m\"\n+  no_color = \"\\033[0m\"\n+  fail(\"\\n%sCuda Configuration Error:%s %s\\n\" % (red, no_color, msg))\n+# END cc_configure common functions (see TODO above).\n+\n+def _host_compiler_includes(repository_ctx, cc):\n+  \"\"\"Generates the cxx_builtin_include_directory entries for gcc inc dirs.\n+\n+  Args:\n+    repository_ctx: The repository context.\n+    cc: The path to the gcc host compiler.\n+\n+  Returns:\n+    A string containing the cxx_builtin_include_directory for each of the gcc\n+    host compiler include directories, which can be added to the CROSSTOOL\n+    file.\n+  \"\"\"\n+  inc_dirs = get_cxx_inc_directories(repository_ctx, cc)\n+\n+  # Add numpy headers\n+  inc_dirs.append(\"/usr/lib/python2.7/dist-packages/numpy/core/include\")\n+\n+  # Add HIP headers\n+  inc_dirs.append(\"/opt/rocm/hip/include\")\n+\n+  # Add rocrand and hiprand headers\n+  inc_dirs.append(\"/opt/rocm/rocrand/include\")\n+  inc_dirs.append(\"/opt/rocm/hiprand/include\")\n+\n+  # Add rocfft headers\n+  inc_dirs.append(\"/opt/rocm/rocfft/include\")\n+\n+  # Add hipblas headers\n+  inc_dirs.append(\"/opt/rocm/hipblas/include\")\n+\n+  # Add MIOpen headers\n+  inc_dirs.append(\"/opt/rocm/miopen/include\")\n+  entries = []\n+  for inc_dir in inc_dirs:\n+    entries.append(\"  cxx_builtin_include_directory: \\\"%s\\\"\" % inc_dir)\n+\n+  # define TENSORFLOW_USE_ROCM\n+  entries.append(\"  unfiltered_cxx_flag: \\\"-DTENSORFLOW_USE_ROCM\\\"\")\n+\n+  return \"\\n\".join(entries)\n+\n+def _rocm_include_path(repository_ctx, rocm_config):\n+  \"\"\"Generates the cxx_builtin_include_directory entries for rocm inc dirs.\n+\n+  Args:\n+    repository_ctx: The repository context.\n+    cc: The path to the gcc host compiler.\n+\n+  Returns:\n+    A string containing the cxx_builtin_include_directory for each of the gcc\n+    host compiler include directories, which can be added to the CROSSTOOL\n+    file.\n+  \"\"\"\n+  target_dir = \"\"\n+  inc_entries = []\n+  if target_dir != \"\":\n+    inc_entries.append(\"  cxx_builtin_include_directory: \\\"%s\\\"\" % target_dir)\n+  default_include = rocm_config.rocm_toolkit_path + '/include'\n+  inc_entries.append(\"  cxx_builtin_include_directory: \\\"%s\\\"\" %\n+                     default_include)\n+  return \"\\n\".join(inc_entries)\n+\n+def _enable_rocm(repository_ctx):\n+  if \"TF_NEED_ROCM\" in repository_ctx.os.environ:\n+    enable_rocm = repository_ctx.os.environ[\"TF_NEED_ROCM\"].strip()\n+    return enable_rocm == \"1\"\n+  return False\n+\n+def _rocm_toolkit_path(repository_ctx):\n+  \"\"\"Finds the rocm toolkit directory.\n+\n+  Args:\n+    repository_ctx: The repository context.\n+\n+  Returns:\n+    A speculative real path of the rocm toolkit install directory.\n+  \"\"\"\n+  rocm_toolkit_path = _DEFAULT_ROCM_TOOLKIT_PATH\n+  if _ROCM_TOOLKIT_PATH in repository_ctx.os.environ:\n+    rocm_toolkit_path = repository_ctx.os.environ[_ROCM_TOOLKIT_PATH].strip()\n+  if not repository_ctx.path(rocm_toolkit_path).exists:\n+    auto_configure_fail(\"Cannot find rocm toolkit path.\")\n+  return str(repository_ctx.path(rocm_toolkit_path).realpath)\n+\n+def _amdgpu_targets(repository_ctx):\n+  \"\"\"Returns a list of strings representing AMDGPU targets.\"\"\"\n+  if _TF_ROCM_AMDGPU_TARGETS not in repository_ctx.os.environ:\n+    return _DEFAULT_ROCM_AMDGPU_TARGETS\n+  amdgpu_targets_str = repository_ctx.os.environ[_TF_ROCM_AMDGPU_TARGETS]\n+  amdgpu_targets = amdgpu_targets_str.split(\",\")\n+  for amdgpu_target in amdgpu_targets:\n+    if amdgpu_target[:3] != \"gfx\" or not amdgpu_target[3:].isdigit():\n+      auto_configure_fail(\"Invalid AMDGPU target: %s\" % amdgpu_target)\n+  return amdgpu_targets\n+\n+def _cpu_value(repository_ctx):\n+  \"\"\"Returns the name of the host operating system.\n+\n+  Args:\n+    repository_ctx: The repository context.\n+\n+  Returns:\n+    A string containing the name of the host operating system.\n+  \"\"\"\n+  os_name = repository_ctx.os.name.lower()\n+  if os_name.startswith(\"mac os\"):\n+    return \"Darwin\"\n+  if os_name.find(\"windows\") != -1:\n+    return \"Windows\"\n+  result = repository_ctx.execute([\"uname\", \"-s\"])\n+  return result.stdout.strip()\n+\n+def _lib_name(lib, cpu_value, version=\"\", static=False):\n+  \"\"\"Constructs the platform-specific name of a library.\n+\n+  Args:\n+    lib: The name of the library, such as \"rocmrt\"\n+    cpu_value: The name of the host operating system.\n+    version: The version of the library.\n+    static: True the library is static or False if it is a shared object.\n+\n+  Returns:\n+    The platform-specific name of the library.\n+  \"\"\"\n+  if cpu_value in (\"Linux\", \"FreeBSD\"):\n+    if static:\n+      return \"lib%s.a\" % lib\n+    else:\n+      if version:\n+        version = \".%s\" % version\n+      return \"lib%s.so%s\" % (lib, version)\n+  elif cpu_value == \"Windows\":\n+    return \"%s.lib\" % lib\n+  elif cpu_value == \"Darwin\":\n+    if static:\n+      return \"lib%s.a\" % lib\n+    else:\n+      if version:\n+        version = \".%s\" % version\n+    return \"lib%s%s.dylib\" % (lib, version)\n+  else:\n+    auto_configure_fail(\"Invalid cpu_value: %s\" % cpu_value)\n+\n+def _find_rocm_lib(lib, repository_ctx, cpu_value, basedir, version=\"\",\n+                   static=False):\n+  \"\"\"Finds the given CUDA or cuDNN library on the system.\n+\n+  Args:\n+    lib: The name of the library, such as \"rocmrt\"\n+    repository_ctx: The repository context.\n+    cpu_value: The name of the host operating system.\n+    basedir: The install directory of CUDA or cuDNN.\n+    version: The version of the library.\n+    static: True if static library, False if shared object.\n+\n+  Returns:\n+    Returns a struct with the following fields:\n+      file_name: The basename of the library found on the system.\n+      path: The full path to the library.\n+  \"\"\"\n+  file_name = _lib_name(lib, cpu_value, version, static)\n+  if cpu_value == \"Linux\":\n+    path = repository_ctx.path(\"%s/lib64/%s\" % (basedir, file_name))\n+    if path.exists:\n+      return struct(file_name=file_name, path=str(path.realpath))\n+    path = repository_ctx.path(\"%s/lib64/stubs/%s\" % (basedir, file_name))\n+    if path.exists:\n+      return struct(file_name=file_name, path=str(path.realpath))\n+    path = repository_ctx.path(\n+        \"%s/lib/x86_64-linux-gnu/%s\" % (basedir, file_name))\n+    if path.exists:\n+      return struct(file_name=file_name, path=str(path.realpath))\n+\n+  elif cpu_value == \"Windows\":\n+    path = repository_ctx.path(\"%s/lib/x64/%s\" % (basedir, file_name))\n+    if path.exists:\n+      return struct(file_name=file_name, path=str(path.realpath))\n+\n+  path = repository_ctx.path(\"%s/lib/%s\" % (basedir, file_name))\n+  if path.exists:\n+    return struct(file_name=file_name, path=str(path.realpath))\n+  path = repository_ctx.path(\"%s/%s\" % (basedir, file_name))\n+  if path.exists:\n+    return struct(file_name=file_name, path=str(path.realpath))\n+\n+  auto_configure_fail(\"Cannot find rocm library %s\" % file_name)\n+\n+def _find_libs(repository_ctx, rocm_config):\n+  \"\"\"Returns the CUDA and cuDNN libraries on the system.", "path": "third_party/gpus/rocm_configure.bzl", "position": null, "original_position": 292, "commit_id": "69d3b8faf41791834301a74a05e288964940427d", "original_commit_id": "4885f5e61c204ddc79d2a48cfe91c6c4b7688b18", "user": {"login": "whchung", "id": 1673574, "node_id": "MDQ6VXNlcjE2NzM1NzQ=", "avatar_url": "https://avatars1.githubusercontent.com/u/1673574?v=4", "gravatar_id": "", "url": "https://api.github.com/users/whchung", "html_url": "https://github.com/whchung", "followers_url": "https://api.github.com/users/whchung/followers", "following_url": "https://api.github.com/users/whchung/following{/other_user}", "gists_url": "https://api.github.com/users/whchung/gists{/gist_id}", "starred_url": "https://api.github.com/users/whchung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/whchung/subscriptions", "organizations_url": "https://api.github.com/users/whchung/orgs", "repos_url": "https://api.github.com/users/whchung/repos", "events_url": "https://api.github.com/users/whchung/events{/privacy}", "received_events_url": "https://api.github.com/users/whchung/received_events", "type": "User", "site_admin": false}, "body": "thanks. will fix it.", "created_at": "2018-07-17T21:18:42Z", "updated_at": "2018-09-06T00:48:23Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/20277#discussion_r203182098", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/20277", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/203182098"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/20277#discussion_r203182098"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/20277"}}, "body_html": "<p>thanks. will fix it.</p>", "body_text": "thanks. will fix it.", "in_reply_to_id": 201593993}