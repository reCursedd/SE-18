{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/203191994", "pull_request_review_id": 138033830, "id": 203191994, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMzE5MTk5NA==", "diff_hunk": "@@ -0,0 +1,664 @@\n+# -*- Python -*-\n+\"\"\"Repository rule for ROCm autoconfiguration.\n+\n+`rocm_configure` depends on the following environment variables:\n+\n+  * `TF_NEED_ROCM`: Whether to enable building with ROCm.\n+  * `GCC_HOST_COMPILER_PATH`: The GCC host compiler path\n+  * `ROCM_TOOLKIT_PATH`: The path to the ROCm toolkit. Default is\n+    `/opt/rocm`.\n+  * `TF_ROCM_VERSION`: The version of the ROCm toolkit. If this is blank, then\n+    use the system default.\n+  * `TF_MIOPEN_VERSION`: The version of the MIOpen library.\n+  * `TF_ROCM_AMDGPU_TARGETS`: The AMDGPU targets. Default is\n+    `gfx803,gfx900`.\n+\"\"\"\n+\n+_GCC_HOST_COMPILER_PATH = \"GCC_HOST_COMPILER_PATH\"\n+_ROCM_TOOLKIT_PATH = \"ROCM_TOOLKIT_PATH\"\n+_TF_ROCM_VERSION = \"TF_ROCM_VERSION\"\n+_TF_MIOPEN_VERSION = \"TF_MIOPEN_VERSION\"\n+_TF_ROCM_AMDGPU_TARGETS = \"TF_ROCM_AMDGPU_TARGETS\"\n+_TF_ROCM_CONFIG_REPO = \"TF_ROCM_CONFIG_REPO\"\n+\n+_DEFAULT_ROCM_VERSION = \"\"\n+_DEFAULT_MIOPEN_VERSION = \"\"\n+_DEFAULT_ROCM_TOOLKIT_PATH = \"/opt/rocm\"\n+_DEFAULT_ROCM_AMDGPU_TARGETS = [\"gfx803\", \"gfx900\"]\n+\n+def find_cc(repository_ctx):\n+  \"\"\"Find the C++ compiler.\"\"\"\n+  # Return a dummy value for GCC detection here to avoid error\n+  target_cc_name = \"gcc\"\n+  cc_path_envvar = _GCC_HOST_COMPILER_PATH\n+  cc_name = target_cc_name\n+\n+  if cc_path_envvar in repository_ctx.os.environ:\n+    cc_name_from_env = repository_ctx.os.environ[cc_path_envvar].strip()\n+    if cc_name_from_env:\n+      cc_name = cc_name_from_env\n+  if cc_name.startswith(\"/\"):\n+    # Absolute path, maybe we should make this supported by our which function.\n+    return cc_name\n+  cc = repository_ctx.which(cc_name)\n+  if cc == None:\n+    fail((\"Cannot find {}, either correct your path or set the {}\" +\n+          \" environment variable\").format(target_cc_name, cc_path_envvar))\n+  return cc\n+\n+_INC_DIR_MARKER_BEGIN = \"#include <...>\"\n+\n+def _cxx_inc_convert(path):\n+  \"\"\"Convert path returned by cc -E xc++ in a complete path.\"\"\"\n+  path = path.strip()\n+  return path\n+\n+def _get_cxx_inc_directories_impl(repository_ctx, cc, lang_is_cpp):\n+  \"\"\"Compute the list of default C or C++ include directories.\"\"\"\n+  if lang_is_cpp:\n+    lang = \"c++\"\n+  else:\n+    lang = \"c\"\n+  # TODO: We pass -no-canonical-prefixes here to match the compiler flags,\n+  #       but in rocm_clang CROSSTOOL file that is a `feature` and we should\n+  #       handle the case when it's disabled and no flag is passed\n+  result = repository_ctx.execute([cc, \"-no-canonical-prefixes\",\n+                                   \"-E\", \"-x\" + lang, \"-\", \"-v\"])\n+  index1 = result.stderr.find(_INC_DIR_MARKER_BEGIN)\n+  if index1 == -1:\n+    return []\n+  index1 = result.stderr.find(\"\\n\", index1)\n+  if index1 == -1:\n+    return []\n+  index2 = result.stderr.rfind(\"\\n \")\n+  if index2 == -1 or index2 < index1:\n+    return []\n+  index2 = result.stderr.find(\"\\n\", index2 + 1)\n+  if index2 == -1:\n+    inc_dirs = result.stderr[index1 + 1:]\n+  else:\n+    inc_dirs = result.stderr[index1 + 1:index2].strip()\n+\n+  return [str(repository_ctx.path(_cxx_inc_convert(p)))\n+          for p in inc_dirs.split(\"\\n\")]\n+\n+def get_cxx_inc_directories(repository_ctx, cc):\n+  \"\"\"Compute the list of default C and C++ include directories.\"\"\"\n+  # For some reason `clang -xc` sometimes returns include paths that are\n+  # different from the ones from `clang -xc++`. (Symlink and a dir)\n+  # So we run the compiler with both `-xc` and `-xc++` and merge resulting lists\n+  includes_cpp = _get_cxx_inc_directories_impl(repository_ctx, cc, True)\n+  includes_c = _get_cxx_inc_directories_impl(repository_ctx, cc, False)\n+\n+  includes_cpp_set = depset(includes_cpp)\n+  return includes_cpp + [inc for inc in includes_c\n+                         if inc not in includes_cpp_set]\n+\n+def auto_configure_fail(msg):\n+  \"\"\"Output failure message when rocm configuration fails.\"\"\"\n+  red = \"\\033[0;31m\"\n+  no_color = \"\\033[0m\"\n+  fail(\"\\n%sCuda Configuration Error:%s %s\\n\" % (red, no_color, msg))\n+# END cc_configure common functions (see TODO above).\n+\n+def _host_compiler_includes(repository_ctx, cc):\n+  \"\"\"Generates the cxx_builtin_include_directory entries for gcc inc dirs.\n+\n+  Args:\n+    repository_ctx: The repository context.\n+    cc: The path to the gcc host compiler.\n+\n+  Returns:\n+    A string containing the cxx_builtin_include_directory for each of the gcc\n+    host compiler include directories, which can be added to the CROSSTOOL\n+    file.\n+  \"\"\"\n+  inc_dirs = get_cxx_inc_directories(repository_ctx, cc)\n+\n+  # Add numpy headers\n+  inc_dirs.append(\"/usr/lib/python2.7/dist-packages/numpy/core/include\")\n+\n+  # Add HIP headers\n+  inc_dirs.append(\"/opt/rocm/hip/include\")\n+\n+  # Add rocrand and hiprand headers\n+  inc_dirs.append(\"/opt/rocm/rocrand/include\")\n+  inc_dirs.append(\"/opt/rocm/hiprand/include\")\n+\n+  # Add rocfft headers\n+  inc_dirs.append(\"/opt/rocm/rocfft/include\")\n+\n+  # Add hipblas headers\n+  inc_dirs.append(\"/opt/rocm/hipblas/include\")\n+\n+  # Add MIOpen headers\n+  inc_dirs.append(\"/opt/rocm/miopen/include\")\n+  entries = []\n+  for inc_dir in inc_dirs:\n+    entries.append(\"  cxx_builtin_include_directory: \\\"%s\\\"\" % inc_dir)\n+\n+  # define TENSORFLOW_USE_ROCM\n+  entries.append(\"  unfiltered_cxx_flag: \\\"-DTENSORFLOW_USE_ROCM\\\"\")\n+\n+  return \"\\n\".join(entries)\n+\n+def _rocm_include_path(repository_ctx, rocm_config):\n+  \"\"\"Generates the cxx_builtin_include_directory entries for rocm inc dirs.\n+\n+  Args:\n+    repository_ctx: The repository context.\n+    cc: The path to the gcc host compiler.\n+\n+  Returns:\n+    A string containing the cxx_builtin_include_directory for each of the gcc\n+    host compiler include directories, which can be added to the CROSSTOOL\n+    file.\n+  \"\"\"\n+  target_dir = \"\"\n+  inc_entries = []\n+  if target_dir != \"\":\n+    inc_entries.append(\"  cxx_builtin_include_directory: \\\"%s\\\"\" % target_dir)\n+  default_include = rocm_config.rocm_toolkit_path + '/include'\n+  inc_entries.append(\"  cxx_builtin_include_directory: \\\"%s\\\"\" %\n+                     default_include)\n+  return \"\\n\".join(inc_entries)\n+\n+def _enable_rocm(repository_ctx):\n+  if \"TF_NEED_ROCM\" in repository_ctx.os.environ:\n+    enable_rocm = repository_ctx.os.environ[\"TF_NEED_ROCM\"].strip()\n+    return enable_rocm == \"1\"\n+  return False\n+\n+def _rocm_toolkit_path(repository_ctx):\n+  \"\"\"Finds the rocm toolkit directory.\n+\n+  Args:\n+    repository_ctx: The repository context.\n+\n+  Returns:\n+    A speculative real path of the rocm toolkit install directory.\n+  \"\"\"\n+  rocm_toolkit_path = _DEFAULT_ROCM_TOOLKIT_PATH\n+  if _ROCM_TOOLKIT_PATH in repository_ctx.os.environ:\n+    rocm_toolkit_path = repository_ctx.os.environ[_ROCM_TOOLKIT_PATH].strip()\n+  if not repository_ctx.path(rocm_toolkit_path).exists:\n+    auto_configure_fail(\"Cannot find rocm toolkit path.\")\n+  return str(repository_ctx.path(rocm_toolkit_path).realpath)\n+\n+def _amdgpu_targets(repository_ctx):\n+  \"\"\"Returns a list of strings representing AMDGPU targets.\"\"\"\n+  if _TF_ROCM_AMDGPU_TARGETS not in repository_ctx.os.environ:\n+    return _DEFAULT_ROCM_AMDGPU_TARGETS\n+  amdgpu_targets_str = repository_ctx.os.environ[_TF_ROCM_AMDGPU_TARGETS]\n+  amdgpu_targets = amdgpu_targets_str.split(\",\")\n+  for amdgpu_target in amdgpu_targets:\n+    if amdgpu_target[:3] != \"gfx\" or not amdgpu_target[3:].isdigit():\n+      auto_configure_fail(\"Invalid AMDGPU target: %s\" % amdgpu_target)\n+  return amdgpu_targets\n+\n+def _cpu_value(repository_ctx):\n+  \"\"\"Returns the name of the host operating system.\n+\n+  Args:\n+    repository_ctx: The repository context.\n+\n+  Returns:\n+    A string containing the name of the host operating system.\n+  \"\"\"\n+  os_name = repository_ctx.os.name.lower()\n+  if os_name.startswith(\"mac os\"):\n+    return \"Darwin\"\n+  if os_name.find(\"windows\") != -1:\n+    return \"Windows\"\n+  result = repository_ctx.execute([\"uname\", \"-s\"])\n+  return result.stdout.strip()\n+\n+def _lib_name(lib, cpu_value, version=\"\", static=False):\n+  \"\"\"Constructs the platform-specific name of a library.\n+\n+  Args:\n+    lib: The name of the library, such as \"rocmrt\"\n+    cpu_value: The name of the host operating system.\n+    version: The version of the library.\n+    static: True the library is static or False if it is a shared object.\n+\n+  Returns:\n+    The platform-specific name of the library.\n+  \"\"\"\n+  if cpu_value in (\"Linux\", \"FreeBSD\"):\n+    if static:\n+      return \"lib%s.a\" % lib\n+    else:\n+      if version:\n+        version = \".%s\" % version\n+      return \"lib%s.so%s\" % (lib, version)\n+  elif cpu_value == \"Windows\":\n+    return \"%s.lib\" % lib\n+  elif cpu_value == \"Darwin\":\n+    if static:\n+      return \"lib%s.a\" % lib\n+    else:\n+      if version:\n+        version = \".%s\" % version\n+    return \"lib%s%s.dylib\" % (lib, version)\n+  else:\n+    auto_configure_fail(\"Invalid cpu_value: %s\" % cpu_value)\n+\n+def _find_rocm_lib(lib, repository_ctx, cpu_value, basedir, version=\"\",\n+                   static=False):\n+  \"\"\"Finds the given CUDA or cuDNN library on the system.\n+\n+  Args:\n+    lib: The name of the library, such as \"rocmrt\"\n+    repository_ctx: The repository context.\n+    cpu_value: The name of the host operating system.\n+    basedir: The install directory of CUDA or cuDNN.\n+    version: The version of the library.\n+    static: True if static library, False if shared object.\n+\n+  Returns:\n+    Returns a struct with the following fields:\n+      file_name: The basename of the library found on the system.\n+      path: The full path to the library.\n+  \"\"\"\n+  file_name = _lib_name(lib, cpu_value, version, static)\n+  if cpu_value == \"Linux\":\n+    path = repository_ctx.path(\"%s/lib64/%s\" % (basedir, file_name))\n+    if path.exists:\n+      return struct(file_name=file_name, path=str(path.realpath))\n+    path = repository_ctx.path(\"%s/lib64/stubs/%s\" % (basedir, file_name))\n+    if path.exists:\n+      return struct(file_name=file_name, path=str(path.realpath))\n+    path = repository_ctx.path(\n+        \"%s/lib/x86_64-linux-gnu/%s\" % (basedir, file_name))\n+    if path.exists:\n+      return struct(file_name=file_name, path=str(path.realpath))\n+\n+  elif cpu_value == \"Windows\":\n+    path = repository_ctx.path(\"%s/lib/x64/%s\" % (basedir, file_name))\n+    if path.exists:\n+      return struct(file_name=file_name, path=str(path.realpath))\n+\n+  path = repository_ctx.path(\"%s/lib/%s\" % (basedir, file_name))\n+  if path.exists:\n+    return struct(file_name=file_name, path=str(path.realpath))\n+  path = repository_ctx.path(\"%s/%s\" % (basedir, file_name))\n+  if path.exists:\n+    return struct(file_name=file_name, path=str(path.realpath))\n+\n+  auto_configure_fail(\"Cannot find rocm library %s\" % file_name)\n+\n+def _find_libs(repository_ctx, rocm_config):\n+  \"\"\"Returns the CUDA and cuDNN libraries on the system.\n+\n+  Args:\n+    repository_ctx: The repository context.\n+    rocm_config: The CUDA config as returned by _get_rocm_config\n+\n+  Returns:\n+    Map of library names to structs of filename and path as returned by\n+    _find_rocm_lib.\n+  \"\"\"\n+  cpu_value = rocm_config.cpu_value\n+  return {\n+      \"hip\": _find_rocm_lib(\n+          \"hip_hcc\", repository_ctx, cpu_value, rocm_config.rocm_toolkit_path),\n+      \"hipblas\": _find_rocm_lib(\n+          \"hipblas\", repository_ctx, cpu_value, rocm_config.rocm_toolkit_path),\n+      \"rocfft\": _find_rocm_lib(\n+          \"rocfft\", repository_ctx, cpu_value, rocm_config.rocm_toolkit_path + \"/rocfft\"),\n+      \"hiprand\": _find_rocm_lib(\n+          \"hiprand\", repository_ctx, cpu_value, rocm_config.rocm_toolkit_path + \"/hiprand\"),\n+      \"miopen\": _find_rocm_lib(\n+          \"MIOpen\", repository_ctx, cpu_value, rocm_config.rocm_toolkit_path + \"/miopen\"),\n+  }\n+\n+def _rocmrt_static_linkopt(cpu_value):\n+  \"\"\"Returns additional platform-specific linkopts for rocmrt.\"\"\"\n+  return \"\" if cpu_value == \"Darwin\" else \"\\\"-lrt\\\",\"\n+\n+def _get_rocm_config(repository_ctx):\n+  \"\"\"Detects and returns information about the ROCm installation on the system.\n+\n+  Args:\n+    repository_ctx: The repository context.\n+\n+  Returns:\n+    A struct containing the following fields:\n+      rocm_toolkit_path: The ROCm toolkit installation directory.\n+      amdgpu_targets: A list of the system's AMDGPU targets.\n+      cpu_value: The name of the host operating system.\n+  \"\"\"\n+  cpu_value = _cpu_value(repository_ctx)\n+  rocm_toolkit_path = _rocm_toolkit_path(repository_ctx)\n+  return struct(\n+      rocm_toolkit_path = rocm_toolkit_path,\n+      amdgpu_targets = _amdgpu_targets(repository_ctx),\n+      cpu_value = cpu_value)\n+\n+def _tpl(repository_ctx, tpl, substitutions={}, out=None):\n+  if not out:\n+    out = tpl.replace(\":\", \"/\")\n+  repository_ctx.template(\n+      out,\n+      Label(\"//third_party/gpus/%s.tpl\" % tpl),\n+      substitutions)\n+\n+\n+def _file(repository_ctx, label):\n+  repository_ctx.template(\n+      label.replace(\":\", \"/\"),\n+      Label(\"//third_party/gpus/%s.tpl\" % label),\n+      {})\n+\n+\n+_DUMMY_CROSSTOOL_BZL_FILE = \"\"\"\n+def error_gpu_disabled():\n+  fail(\"ERROR: Building with --config=rocm but TensorFlow is not configured \" +\n+       \"to build with GPU support. Please re-run ./configure and enter 'Y' \" +\n+       \"at the prompt to build with GPU support.\")\n+\n+  native.genrule(\n+      name = \"error_gen_crosstool\",\n+      outs = [\"CROSSTOOL\"],\n+      cmd = \"echo 'Should not be run.' && exit 1\",\n+  )\n+\n+  native.filegroup(\n+      name = \"crosstool\",\n+      srcs = [\":CROSSTOOL\"],\n+      output_licenses = [\"unencumbered\"],\n+  )\n+\"\"\"\n+\n+\n+_DUMMY_CROSSTOOL_BUILD_FILE = \"\"\"\n+load(\"//crosstool:error_gpu_disabled.bzl\", \"error_gpu_disabled\")\n+\n+error_gpu_disabled()\n+\"\"\"\n+\n+def _create_dummy_repository(repository_ctx):\n+  cpu_value = _cpu_value(repository_ctx)\n+\n+  # Set up BUILD file for rocm/.\n+  _tpl(repository_ctx, \"rocm:build_defs.bzl\",\n+       {\n+           \"%{rocm_is_configured}\": \"False\",\n+           \"%{rocm_extra_copts}\": \"[]\"\n+       })\n+  _tpl(repository_ctx, \"rocm:BUILD\",\n+       {\n+           \"%{rocmrt_static_lib}\": _lib_name(\"rocmrt_static\", cpu_value,\n+                                             static=True),\n+           \"%{rocmrt_static_linkopt}\": _rocmrt_static_linkopt(cpu_value),\n+           \"%{rocmrt_lib}\": _lib_name(\"rocmrt\", cpu_value),\n+           \"%{rocblas_lib}\": _lib_name(\"rocblas\", cpu_value),\n+           \"%{miopen_lib}\": _lib_name(\"miopen\", cpu_value),\n+           \"%{rocfft_lib}\": _lib_name(\"rocfft\", cpu_value),\n+           \"%{hiprand_lib}\": _lib_name(\"hiprand\", cpu_value),\n+           \"%{rocm_include_genrules}\": '',\n+           \"%{rocm_headers}\": '',\n+       })\n+\n+  # Create dummy files for the ROCm toolkit since they are still required by\n+  # tensorflow/core/platform/default/build_config:rocm.\n+  repository_ctx.file(\"rocm/hip/include/hip/hip_runtime.h\", \"\")\n+\n+  # Set up rocm_config.h, which is used by\n+  # tensorflow/stream_executor/dso_loader.cc.\n+  _tpl(repository_ctx, \"rocm:rocm_config.h\",\n+       {\n+           \"%{rocm_toolkit_path}\": _DEFAULT_ROCM_TOOLKIT_PATH,\n+       }, \"rocm/rocm/rocm_config.h\")\n+\n+  # If rocm_configure is not configured to build with GPU support, and the user\n+  # attempts to build with --config=rocm, add a dummy build rule to intercept\n+  # this and fail with an actionable error message.\n+  repository_ctx.file(\"crosstool/error_gpu_disabled.bzl\",\n+                      _DUMMY_CROSSTOOL_BZL_FILE)\n+  repository_ctx.file(\"crosstool/BUILD\", _DUMMY_CROSSTOOL_BUILD_FILE)\n+\n+def _execute(repository_ctx, cmdline, error_msg=None, error_details=None,\n+             empty_stdout_fine=False):\n+  \"\"\"Executes an arbitrary shell command.\n+\n+  Args:\n+    repository_ctx: the repository_ctx object\n+    cmdline: list of strings, the command to execute\n+    error_msg: string, a summary of the error if the command fails\n+    error_details: string, details about the error or steps to fix it\n+    empty_stdout_fine: bool, if True, an empty stdout result is fine, otherwise\n+      it's an error\n+  Return:\n+    the result of repository_ctx.execute(cmdline)\n+  \"\"\"\n+  result = repository_ctx.execute(cmdline)\n+  if result.stderr or not (empty_stdout_fine or result.stdout):\n+    auto_configure_fail(\n+        \"\\n\".join([\n+            error_msg.strip() if error_msg else \"Repository command failed\",\n+            result.stderr.strip(),\n+            error_details if error_details else \"\"]))\n+  return result\n+\n+def _norm_path(path):\n+  \"\"\"Returns a path with '/' and remove the trailing slash.\"\"\"\n+  path = path.replace(\"\\\\\", \"/\")\n+  if path[-1] == \"/\":\n+    path = path[:-1]\n+  return path\n+\n+def _symlink_genrule_for_dir(repository_ctx, src_dir, dest_dir, genrule_name,\n+    src_files = [], dest_files = []):\n+  \"\"\"Returns a genrule to symlink(or copy if on Windows) a set of files.\n+\n+  If src_dir is passed, files will be read from the given directory; otherwise\n+  we assume files are in src_files and dest_files\n+  \"\"\"\n+  if src_dir != None:\n+    src_dir = _norm_path(src_dir)\n+    dest_dir = _norm_path(dest_dir)\n+    files = _read_dir(repository_ctx, src_dir)\n+    # Create a list with the src_dir stripped to use for outputs.\n+    dest_files = files.replace(src_dir, '').splitlines()\n+    src_files = files.splitlines()\n+  command = []\n+  # We clear folders that might have been generated previously to avoid\n+  # undesired inclusions\n+  command.append('if [ -d \"$(@D)/include\" ]; then rm $(@D)/include -drf; fi')\n+  command.append('if [ -d \"$(@D)/lib\" ]; then rm $(@D)/lib -drf; fi')\n+  outs = []\n+  for i in range(len(dest_files)):\n+    if dest_files[i] != \"\":\n+      # If we have only one file to link we do not want to use the dest_dir, as\n+      # $(@D) will include the full path to the file.\n+      dest = '$(@D)/' + dest_dir + dest_files[i] if len(dest_files) != 1 else '$(@D)/' + dest_files[i]\n+      # On Windows, symlink is not supported, so we just copy all the files.\n+      cmd = 'ln -s'\n+      command.append(cmd + ' \"%s\" \"%s\"' % (src_files[i] , dest))\n+      outs.append('        \"' + dest_dir + dest_files[i] + '\",')\n+  genrule = _genrule(src_dir, genrule_name, \" && \".join(command),\n+                     \"\\n\".join(outs))\n+  return genrule\n+\n+def _genrule(src_dir, genrule_name, command, outs):\n+  \"\"\"Returns a string with a genrule.\n+\n+  Genrule executes the given command and produces the given outputs.\n+  \"\"\"\n+  return (\n+      'genrule(\\n' +\n+      '    name = \"' +\n+      genrule_name + '\",\\n' +\n+      '    outs = [\\n' +\n+      outs +\n+      '\\n    ],\\n' +\n+      '    cmd = \"\"\"\\n' +\n+      command +\n+      '\\n   \"\"\",\\n' +\n+      ')\\n'\n+  )\n+\n+def _read_dir(repository_ctx, src_dir):\n+  \"\"\"Returns a string with all files in a directory.\n+\n+  Finds all files inside a directory, traversing subfolders and following\n+  symlinks. The returned string contains the full path of all files\n+  separated by line breaks.\n+  \"\"\"\n+  find_result = _execute(\n+      repository_ctx, [\"find\", src_dir, \"-follow\", \"-type\", \"f\"],\n+      empty_stdout_fine=True)\n+  result = find_result.stdout\n+  return result\n+\n+def _compute_rocm_extra_copts(repository_ctx, amdgpu_targets):\n+  if False:\n+    amdgpu_target_flags = [\"--amdgpu-target=\" +\n+        amdgpu_target for amdgpu_target in amdgpu_targets]\n+  else:\n+    # AMDGPU targets are handled in the \"crosstool_wrapper_driver_is_not_gcc\"\n+    amdgpu_target_flags = []\n+  return str(amdgpu_target_flags)\n+\n+def _create_local_rocm_repository(repository_ctx):\n+  \"\"\"Creates the repository containing files set up to build with ROCm.\"\"\"\n+  rocm_config = _get_rocm_config(repository_ctx)\n+\n+  # Set up symbolic links for the rocm toolkit by creating genrules to do\n+  # symlinking. We create one genrule for each directory we want to track under\n+  # rocm_toolkit_path\n+  rocm_toolkit_path = rocm_config.rocm_toolkit_path\n+  rocm_include_path = rocm_toolkit_path + \"/include\"\n+  genrules = [_symlink_genrule_for_dir(repository_ctx,\n+      rocm_include_path, \"rocm/include\", \"rocm-include\")]\n+  genrules.append(_symlink_genrule_for_dir(repository_ctx,\n+      rocm_toolkit_path + \"/rocfft/include\", \"rocm/include/rocfft\", \"rocfft-include\"))\n+  genrules.append(_symlink_genrule_for_dir(repository_ctx,\n+      rocm_toolkit_path + \"/hipblas/include\", \"rocm/include/hipblas\", \"hipblas-include\"))\n+  genrules.append(_symlink_genrule_for_dir(repository_ctx,\n+      rocm_toolkit_path + \"/miopen/include\", \"rocm/include/miopen\", \"miopen-include\"))\n+\n+  rocm_libs = _find_libs(repository_ctx, rocm_config)\n+  rocm_lib_src = []\n+  rocm_lib_dest = []\n+  for lib in rocm_libs.values():\n+    rocm_lib_src.append(lib.path)\n+    rocm_lib_dest.append(\"rocm/lib/\" + lib.file_name)\n+  genrules.append(_symlink_genrule_for_dir(repository_ctx, None, \"\", \"rocm-lib\",\n+                                       rocm_lib_src, rocm_lib_dest))\n+\n+  included_files = _read_dir(repository_ctx, rocm_include_path).replace(\n+      rocm_include_path, '').splitlines()\n+\n+  # Set up BUILD file for rocm/\n+  _tpl(repository_ctx, \"rocm:build_defs.bzl\",\n+       {\n+           \"%{rocm_is_configured}\": \"True\",\n+           \"%{rocm_extra_copts}\": _compute_rocm_extra_copts(\n+               repository_ctx, rocm_config.amdgpu_targets),\n+\n+       })\n+  _tpl(repository_ctx, \"rocm:BUILD\",\n+       {\n+           \"%{rocmrt_static_lib}\": rocm_libs[\"hip\"].file_name,\n+           \"%{rocmrt_static_linkopt}\": '',", "path": "third_party/gpus/rocm_configure.bzl", "position": null, "original_position": 566, "commit_id": "69d3b8faf41791834301a74a05e288964940427d", "original_commit_id": "4885f5e61c204ddc79d2a48cfe91c6c4b7688b18", "user": {"login": "whchung", "id": 1673574, "node_id": "MDQ6VXNlcjE2NzM1NzQ=", "avatar_url": "https://avatars1.githubusercontent.com/u/1673574?v=4", "gravatar_id": "", "url": "https://api.github.com/users/whchung", "html_url": "https://github.com/whchung", "followers_url": "https://api.github.com/users/whchung/followers", "following_url": "https://api.github.com/users/whchung/following{/other_user}", "gists_url": "https://api.github.com/users/whchung/gists{/gist_id}", "starred_url": "https://api.github.com/users/whchung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/whchung/subscriptions", "organizations_url": "https://api.github.com/users/whchung/orgs", "repos_url": "https://api.github.com/users/whchung/repos", "events_url": "https://api.github.com/users/whchung/events{/privacy}", "received_events_url": "https://api.github.com/users/whchung/received_events", "type": "User", "site_admin": false}, "body": "I'll remove it.", "created_at": "2018-07-17T21:46:25Z", "updated_at": "2018-09-06T00:48:23Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/20277#discussion_r203191994", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/20277", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/203191994"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/20277#discussion_r203191994"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/20277"}}, "body_html": "<p>I'll remove it.</p>", "body_text": "I'll remove it.", "in_reply_to_id": 201596640}