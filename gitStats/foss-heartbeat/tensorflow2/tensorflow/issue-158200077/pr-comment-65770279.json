{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/65770279", "pull_request_review_id": null, "id": 65770279, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1NzcwMjc5", "diff_hunk": "@@ -20,104 +20,90 @@\n import tensorflow.python.platform\n \n import numpy as np\n-from six.moves import xrange  # pylint: disable=redefined-builtin\n import tensorflow as tf\n \n-\n class AdadeltaOptimizerTest(tf.test.TestCase):\n-\n   def testBasic(self):\n+    num_updates = 4 # number of ADADELTA steps to perform\n     for dtype in [tf.half, tf.float32]:\n-      with self.test_session():\n-        var0 = tf.Variable([1.0, 2.0], dtype=dtype)\n-        var1 = tf.Variable([3.0, 4.0], dtype=dtype)\n-        grads0 = tf.constant([0.1, 0.1], dtype=dtype)\n-        grads1 = tf.constant([0.01, 0.01], dtype=dtype)\n-        lr = 1.0\n-        rho = 0.95\n-        epsilon = 1e-8\n-\n-        adadelta_opt = tf.train.AdadeltaOptimizer(lr, rho=rho, epsilon=epsilon)\n-        adadelta_update = adadelta_opt.apply_gradients(zip(\n-            [grads0, grads1], [var0, var1]))\n-        tf.initialize_all_variables().run()\n-\n-        # Check we have slots\n-        self.assertEqual([\"accum\", \"accum_update\"],\n-                         adadelta_opt.get_slot_names())\n-        slot0 = adadelta_opt.get_slot(var0, \"accum\")\n-        self.assertEquals(slot0.get_shape(), var0.get_shape())\n-        self.assertFalse(slot0 in tf.trainable_variables())\n-\n-        slot0_update = adadelta_opt.get_slot(var0, \"accum_update\")\n-        self.assertEquals(slot0_update.get_shape(), var0.get_shape())\n-        self.assertFalse(slot0_update in tf.trainable_variables())\n-\n-        slot1 = adadelta_opt.get_slot(var1, \"accum\")\n-        self.assertEquals(slot1.get_shape(), var1.get_shape())\n-        self.assertFalse(slot1 in tf.trainable_variables())\n-\n-        slot1_update = adadelta_opt.get_slot(var1, \"accum_update\")\n-        self.assertEquals(slot1_update.get_shape(), var1.get_shape())\n-        self.assertFalse(slot1_update in tf.trainable_variables())\n-\n-        # Fetch params to validate initial values\n-        self.assertAllClose([1.0, 2.0], var0.eval())\n-        self.assertAllClose([3.0, 4.0], var1.eval())\n-\n-        adadelta_update.run()\n-\n-        # Check that the accumulators have been updated.\n-        grad = 0.1\n-        accum = 0\n-        accum_update = 0\n-\n-        accum = accum * rho + (grad**2) * (1 - rho)\n-        update1 = np.sqrt(accum_update + epsilon) * (\n-            1. / np.sqrt(accum + epsilon)) * grad\n-        accum_update = accum_update * rho + (update1**2) * (1.0 - rho)\n-\n-        self.assertAllCloseAccordingToType(\n-            np.array([accum, accum]), slot0.eval())\n-        self.assertAllCloseAccordingToType(\n-            np.array([accum_update, accum_update]), slot0_update.eval())\n-\n-        # Check that the parameters have been updated.\n-        self.assertAllCloseAccordingToType(\n-            np.array([1.0 - update1 * lr, 2.0 - update1 * lr]),\n-            var0.eval(),\n-            rtol=1e-3)\n-\n-        self.assertAllCloseAccordingToType(\n-            np.array([3.0 - update1 * lr, 4.0 - update1 * lr]),\n-            var1.eval(),\n-            rtol=1e-3)\n-\n-        # Step 2: the momentum accumulators contain the previous update.\n-        accum = accum * rho + (grad**2) * (1 - rho)\n-        update2 = ((accum_update + epsilon)**0.5 *\n-                   (1. / (accum + epsilon)**0.5) * grad)\n-        accum_update = accum_update * rho + (update2**2) * (1.0 - rho)\n-\n-        adadelta_update.run()\n-\n-        # Check that the momentum accumulators have been updated.\n-        self.assertAllCloseAccordingToType(\n-            np.array([accum, accum]), slot0.eval())\n-        self.assertAllCloseAccordingToType(\n-            np.array([accum_update, accum_update]), slot0_update.eval())\n-\n-        # Check that the parameters have been updated.\n-        self.assertAllCloseAccordingToType(\n-            np.array([1.0 - update1 - update2, 2.0 - update1 - update2]),\n-            var0.eval(),\n-            rtol=1e-3)\n-\n-        self.assertAllCloseAccordingToType(\n-            np.array([3.0 - update1 - update2, 4.0 - update1 - update2]),\n-            var1.eval(),\n-            rtol=1e-3)\n-\n+        for grad in [0.2, 0.1, 0.01]:\n+            for lr in [1.0, 0.5, 0.1]:\n+              with self.test_session():\n+                var0_init = [1.0, 2.0]\n+                var1_init = [3.0, 4.0]\n+                var0 = tf.Variable(var0_init, dtype=dtype)\n+                var1 = tf.Variable(var1_init, dtype=dtype)\n+\n+                grads = tf.constant([grad, grad], dtype=dtype)\n+\n+                accum = 0.0\n+                accum_update = 0.0\n+\n+                # ADADELTA gradient optimizer\n+                rho = 0.95\n+                epsilon = 1e-8\n+                adadelta_opt = tf.train.AdadeltaOptimizer(lr, rho, epsilon)\n+                adadelta_update = adadelta_opt.apply_gradients(zip(\n+                    [grads, grads], [var0, var1]))\n+\n+                tf.initialize_all_variables().run()\n+\n+                # Assign slots\n+                slot = [None]*2", "path": "tensorflow/python/training/adadelta_test.py", "position": null, "original_position": 126, "commit_id": "4a8c29ff8152c9fc61e84abee6a6abd5a1d69ec8", "original_commit_id": "8397be9870211c7e14c8c6699e605c5d3d66d611", "user": {"login": "vrv", "id": 463737, "node_id": "MDQ6VXNlcjQ2MzczNw==", "avatar_url": "https://avatars0.githubusercontent.com/u/463737?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vrv", "html_url": "https://github.com/vrv", "followers_url": "https://api.github.com/users/vrv/followers", "following_url": "https://api.github.com/users/vrv/following{/other_user}", "gists_url": "https://api.github.com/users/vrv/gists{/gist_id}", "starred_url": "https://api.github.com/users/vrv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vrv/subscriptions", "organizations_url": "https://api.github.com/users/vrv/orgs", "repos_url": "https://api.github.com/users/vrv/repos", "events_url": "https://api.github.com/users/vrv/events{/privacy}", "received_events_url": "https://api.github.com/users/vrv/received_events", "type": "User", "site_admin": false}, "body": "space between ] and \\*  and 2 \n", "created_at": "2016-06-03T20:26:36Z", "updated_at": "2016-06-03T21:02:23Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/2624#discussion_r65770279", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/2624", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/65770279"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/2624#discussion_r65770279"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/2624"}}, "body_html": "<p>space between ] and *  and 2</p>", "body_text": "space between ] and *  and 2"}