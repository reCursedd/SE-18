{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/18920", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/18920/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/18920/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/18920/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/18920", "id": 318359847, "node_id": "MDU6SXNzdWUzMTgzNTk4NDc=", "number": 18920, "title": "Feature request: Gradient for number of loop iterations for automatic differentiation of physics simulations", "user": {"login": "AlexHarn", "id": 36734880, "node_id": "MDQ6VXNlcjM2NzM0ODgw", "avatar_url": "https://avatars3.githubusercontent.com/u/36734880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AlexHarn", "html_url": "https://github.com/AlexHarn", "followers_url": "https://api.github.com/users/AlexHarn/followers", "following_url": "https://api.github.com/users/AlexHarn/following{/other_user}", "gists_url": "https://api.github.com/users/AlexHarn/gists{/gist_id}", "starred_url": "https://api.github.com/users/AlexHarn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AlexHarn/subscriptions", "organizations_url": "https://api.github.com/users/AlexHarn/orgs", "repos_url": "https://api.github.com/users/AlexHarn/repos", "events_url": "https://api.github.com/users/AlexHarn/events{/privacy}", "received_events_url": "https://api.github.com/users/AlexHarn/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": {"login": "aselle", "id": 326106, "node_id": "MDQ6VXNlcjMyNjEwNg==", "avatar_url": "https://avatars1.githubusercontent.com/u/326106?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aselle", "html_url": "https://github.com/aselle", "followers_url": "https://api.github.com/users/aselle/followers", "following_url": "https://api.github.com/users/aselle/following{/other_user}", "gists_url": "https://api.github.com/users/aselle/gists{/gist_id}", "starred_url": "https://api.github.com/users/aselle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aselle/subscriptions", "organizations_url": "https://api.github.com/users/aselle/orgs", "repos_url": "https://api.github.com/users/aselle/repos", "events_url": "https://api.github.com/users/aselle/events{/privacy}", "received_events_url": "https://api.github.com/users/aselle/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "aselle", "id": 326106, "node_id": "MDQ6VXNlcjMyNjEwNg==", "avatar_url": "https://avatars1.githubusercontent.com/u/326106?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aselle", "html_url": "https://github.com/aselle", "followers_url": "https://api.github.com/users/aselle/followers", "following_url": "https://api.github.com/users/aselle/following{/other_user}", "gists_url": "https://api.github.com/users/aselle/gists{/gist_id}", "starred_url": "https://api.github.com/users/aselle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aselle/subscriptions", "organizations_url": "https://api.github.com/users/aselle/orgs", "repos_url": "https://api.github.com/users/aselle/repos", "events_url": "https://api.github.com/users/aselle/events{/privacy}", "received_events_url": "https://api.github.com/users/aselle/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 4, "created_at": "2018-04-27T10:34:39Z", "updated_at": "2018-07-20T21:12:39Z", "closed_at": "2018-07-20T21:12:39Z", "author_association": "NONE", "body_html": "<h2>System information</h2>\n<p><strong>Not relevant.</strong></p>\n<p>Have I written custom code <strong>yes</strong><br>\nOS Platform and Distribution <strong>different linux systems</strong><br>\nTensorFlow installed from <strong>source and pip</strong> (on different systems)<br>\nTensorFlow version <strong>different versions, all &gt;= 1.5.0</strong><br>\nBazel version <strong>different versions on different systems</strong><br>\nCUDA/cuDNN version <strong>different versions, all &gt;= 8</strong><br>\nGPU model and memory <strong>GTX 1080, GTX 1060, Tesla P40</strong> (potentially many others on our cluster, but not tested yet)<br>\nExact command to reproduce <strong>run <a href=\"https://github.com/AlexHarn/tf-ice-model-optimization/blob/1a9f9e11d55277bd595266410bf10a54bbd8b5f0/bug_test.py\">bug_test.py</a></strong></p>\n<h2>Describe the problem</h2>\n<h3>Motivation</h3>\n<p>(you might want to skip this)<br>\nTensorflow is a powerful framework that can potentially be used for much more than static computations like those needed to train neural networks. We (a couple of physicists) are trying to use Tensorflow to get a gradient on some physical parameters to fit those parameters to measured data by propagating the gradient through the entire physics simulation to replicate the data. This is extremely relevant for a lot of people and the idea is not new.  Instead of performing extremely time consuming (in terms of computational and human work time) grid searches on high dimensional parameter spaces we would like to be able to directly perform gradient descent on such spaces in an automated fashion by using Tensorflows automatic differentiation. You can find our work in progress repository <a href=\"https://github.com/AlexHarn/tf-ice-model-optimization\">here</a>.</p>\n<h3>The Problem</h3>\n<p>Like explicitly stated <a href=\"http://download.tensorflow.org/paper/white_paper_tf_control_flow_implementation_2017_11_1.pdf\" rel=\"nofollow\">here</a> on page 15 \"This means that we assume that <code>pred</code> is not trainable\", the number of loop iterations is just a constant while backpropagating the gradient. This leads to some extremely unexpected behavior like described in this <a href=\"https://github.com/AlexHarn/tf-ice-model-optimization/issues/1\" data-hovercard-type=\"issue\" data-hovercard-url=\"/AlexHarn/tf-toy-ice-model-optimization/issues/1/hovercard\">issue</a> (at least unexpected for someone who is a Tensorflow newbie like I am). For our plans to work it is mandatory for the gradient to include information on how the number of loop iterations would have changed, if the trainable variables changed.</p>\n<h3>Example</h3>\n<p>(You might want to skip this)<br>\nIn our project we have a trainable variable, which describes the mean distance between scattering events of photons. Tensorflow is able to propagate the gradient through the simulation (while loop), but the gradient only \"thinks\" that the photons will reach further points when the scattering length is longer, but \"is not aware\" of the fact that there will be less iterations.</p>\n<h3>Request</h3>\n<p>I do not know if this is even possible with how Tensorflow works, but we would love to see a way to make this work. Tensorflow would be a really great tool for us to use. So is this something you might work on in the future?</p>\n<p>Also: does anyone maybe have any idea of how to solve or get around this right now with the current implementation? We have put quite some thought into this ourselves already, but until now we have not found a working solution.</p>\n<h2>Source code</h2>\n<p>For a work in progress example of how this would be useful you can take a look at the <a href=\"https://github.com/AlexHarn/tf-ice-model-optimization\">master</a> and <a href=\"https://github.com/AlexHarn/tf-ice-model-optimization/tree/experimental\">experimental</a> branches of our repo.</p>\n<p>For a stripped down minimal one dimensional example of the simulation you can take a look at <a href=\"https://github.com/AlexHarn/tf-ice-model-optimization/blob/gradient-sign-bug/minimal_1d.py\">minimal_1d.py</a>, this in its current state however actually converges. For some more information on the unexpected behavior take a look at my <a href=\"https://github.com/AlexHarn/tf-ice-model-optimization/issues/1\" data-hovercard-type=\"issue\" data-hovercard-url=\"/AlexHarn/tf-toy-ice-model-optimization/issues/1/hovercard\">issue</a> where I reference commits, which demonstrate what's happening.</p>\n<p>A minimal example, which does not include any physics and purely demonstrates the unexpected behavior is given <a href=\"https://github.com/AlexHarn/tf-ice-model-optimization/blob/1a9f9e11d55277bd595266410bf10a54bbd8b5f0/bug_test.py\">here</a>.</p>\n<p>All of the code includes detailed comments.</p>\n<p>If you are interested in the background and general idea you can take a look at my <a href=\"https://drive.google.com/file/d/17WdIcpIzFDZmQvD-DCqonmDvz_S0-Arz/view?usp=sharing\" rel=\"nofollow\">slides</a>, even though I am not sure how much of a help those will be for someone from outside. Slides 5 to 8 might be helpful for everyone though. Especially slide 5 which shows how we fit the data using simulations. For the general concept testing right now the data is also given by the same simulation with \"true\" parameters.</p>\n<p>We really hope to get some form of feedback here and I am sorry if this is a trivial or stupid request in the eyes of someone more experienced with Tensorflow.</p>", "body_text": "System information\nNot relevant.\nHave I written custom code yes\nOS Platform and Distribution different linux systems\nTensorFlow installed from source and pip (on different systems)\nTensorFlow version different versions, all >= 1.5.0\nBazel version different versions on different systems\nCUDA/cuDNN version different versions, all >= 8\nGPU model and memory GTX 1080, GTX 1060, Tesla P40 (potentially many others on our cluster, but not tested yet)\nExact command to reproduce run bug_test.py\nDescribe the problem\nMotivation\n(you might want to skip this)\nTensorflow is a powerful framework that can potentially be used for much more than static computations like those needed to train neural networks. We (a couple of physicists) are trying to use Tensorflow to get a gradient on some physical parameters to fit those parameters to measured data by propagating the gradient through the entire physics simulation to replicate the data. This is extremely relevant for a lot of people and the idea is not new.  Instead of performing extremely time consuming (in terms of computational and human work time) grid searches on high dimensional parameter spaces we would like to be able to directly perform gradient descent on such spaces in an automated fashion by using Tensorflows automatic differentiation. You can find our work in progress repository here.\nThe Problem\nLike explicitly stated here on page 15 \"This means that we assume that pred is not trainable\", the number of loop iterations is just a constant while backpropagating the gradient. This leads to some extremely unexpected behavior like described in this issue (at least unexpected for someone who is a Tensorflow newbie like I am). For our plans to work it is mandatory for the gradient to include information on how the number of loop iterations would have changed, if the trainable variables changed.\nExample\n(You might want to skip this)\nIn our project we have a trainable variable, which describes the mean distance between scattering events of photons. Tensorflow is able to propagate the gradient through the simulation (while loop), but the gradient only \"thinks\" that the photons will reach further points when the scattering length is longer, but \"is not aware\" of the fact that there will be less iterations.\nRequest\nI do not know if this is even possible with how Tensorflow works, but we would love to see a way to make this work. Tensorflow would be a really great tool for us to use. So is this something you might work on in the future?\nAlso: does anyone maybe have any idea of how to solve or get around this right now with the current implementation? We have put quite some thought into this ourselves already, but until now we have not found a working solution.\nSource code\nFor a work in progress example of how this would be useful you can take a look at the master and experimental branches of our repo.\nFor a stripped down minimal one dimensional example of the simulation you can take a look at minimal_1d.py, this in its current state however actually converges. For some more information on the unexpected behavior take a look at my issue where I reference commits, which demonstrate what's happening.\nA minimal example, which does not include any physics and purely demonstrates the unexpected behavior is given here.\nAll of the code includes detailed comments.\nIf you are interested in the background and general idea you can take a look at my slides, even though I am not sure how much of a help those will be for someone from outside. Slides 5 to 8 might be helpful for everyone though. Especially slide 5 which shows how we fit the data using simulations. For the general concept testing right now the data is also given by the same simulation with \"true\" parameters.\nWe really hope to get some form of feedback here and I am sorry if this is a trivial or stupid request in the eyes of someone more experienced with Tensorflow.", "body": "## System information\r\n**Not relevant.**\r\n\r\nHave I written custom code **yes**\r\nOS Platform and Distribution **different linux systems**\r\nTensorFlow installed from **source and pip** (on different systems)\r\nTensorFlow version **different versions, all >= 1.5.0**\r\nBazel version **different versions on different systems**\r\nCUDA/cuDNN version **different versions, all >= 8**\r\nGPU model and memory **GTX 1080, GTX 1060, Tesla P40** (potentially many others on our cluster, but not tested yet)\r\nExact command to reproduce **run [bug_test.py](https://github.com/AlexHarn/tf-ice-model-optimization/blob/1a9f9e11d55277bd595266410bf10a54bbd8b5f0/bug_test.py)**\r\n\r\n## Describe the problem\r\n### Motivation\r\n(you might want to skip this)\r\nTensorflow is a powerful framework that can potentially be used for much more than static computations like those needed to train neural networks. We (a couple of physicists) are trying to use Tensorflow to get a gradient on some physical parameters to fit those parameters to measured data by propagating the gradient through the entire physics simulation to replicate the data. This is extremely relevant for a lot of people and the idea is not new.  Instead of performing extremely time consuming (in terms of computational and human work time) grid searches on high dimensional parameter spaces we would like to be able to directly perform gradient descent on such spaces in an automated fashion by using Tensorflows automatic differentiation. You can find our work in progress repository [here](https://github.com/AlexHarn/tf-ice-model-optimization).\r\n\r\n### The Problem\r\nLike explicitly stated [here](http://download.tensorflow.org/paper/white_paper_tf_control_flow_implementation_2017_11_1.pdf) on page 15 \"This means that we assume that `pred` is not trainable\", the number of loop iterations is just a constant while backpropagating the gradient. This leads to some extremely unexpected behavior like described in this [issue](https://github.com/AlexHarn/tf-ice-model-optimization/issues/1) (at least unexpected for someone who is a Tensorflow newbie like I am). For our plans to work it is mandatory for the gradient to include information on how the number of loop iterations would have changed, if the trainable variables changed. \r\n\r\n### Example\r\n(You might want to skip this)\r\nIn our project we have a trainable variable, which describes the mean distance between scattering events of photons. Tensorflow is able to propagate the gradient through the simulation (while loop), but the gradient only \"thinks\" that the photons will reach further points when the scattering length is longer, but \"is not aware\" of the fact that there will be less iterations. \r\n\r\n### Request\r\nI do not know if this is even possible with how Tensorflow works, but we would love to see a way to make this work. Tensorflow would be a really great tool for us to use. So is this something you might work on in the future? \r\n\r\nAlso: does anyone maybe have any idea of how to solve or get around this right now with the current implementation? We have put quite some thought into this ourselves already, but until now we have not found a working solution.\r\n\r\n## Source code\r\nFor a work in progress example of how this would be useful you can take a look at the [master](https://github.com/AlexHarn/tf-ice-model-optimization) and [experimental](https://github.com/AlexHarn/tf-ice-model-optimization/tree/experimental) branches of our repo. \r\n\r\nFor a stripped down minimal one dimensional example of the simulation you can take a look at [minimal_1d.py](https://github.com/AlexHarn/tf-ice-model-optimization/blob/gradient-sign-bug/minimal_1d.py), this in its current state however actually converges. For some more information on the unexpected behavior take a look at my [issue](https://github.com/AlexHarn/tf-ice-model-optimization/issues/1) where I reference commits, which demonstrate what's happening.\r\n\r\nA minimal example, which does not include any physics and purely demonstrates the unexpected behavior is given [here](https://github.com/AlexHarn/tf-ice-model-optimization/blob/1a9f9e11d55277bd595266410bf10a54bbd8b5f0/bug_test.py).\r\n\r\nAll of the code includes detailed comments. \r\n\r\nIf you are interested in the background and general idea you can take a look at my [slides](https://drive.google.com/file/d/17WdIcpIzFDZmQvD-DCqonmDvz_S0-Arz/view?usp=sharing), even though I am not sure how much of a help those will be for someone from outside. Slides 5 to 8 might be helpful for everyone though. Especially slide 5 which shows how we fit the data using simulations. For the general concept testing right now the data is also given by the same simulation with \"true\" parameters.\r\n\r\nWe really hope to get some form of feedback here and I am sorry if this is a trivial or stupid request in the eyes of someone more experienced with Tensorflow."}