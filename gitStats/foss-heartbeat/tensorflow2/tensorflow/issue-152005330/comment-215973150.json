{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/215973150", "html_url": "https://github.com/tensorflow/tensorflow/pull/2173#issuecomment-215973150", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2173", "id": 215973150, "node_id": "MDEyOklzc3VlQ29tbWVudDIxNTk3MzE1MA==", "user": {"login": "stephenroller", "id": 31896, "node_id": "MDQ6VXNlcjMxODk2", "avatar_url": "https://avatars2.githubusercontent.com/u/31896?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stephenroller", "html_url": "https://github.com/stephenroller", "followers_url": "https://api.github.com/users/stephenroller/followers", "following_url": "https://api.github.com/users/stephenroller/following{/other_user}", "gists_url": "https://api.github.com/users/stephenroller/gists{/gist_id}", "starred_url": "https://api.github.com/users/stephenroller/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stephenroller/subscriptions", "organizations_url": "https://api.github.com/users/stephenroller/orgs", "repos_url": "https://api.github.com/users/stephenroller/repos", "events_url": "https://api.github.com/users/stephenroller/events{/privacy}", "received_events_url": "https://api.github.com/users/stephenroller/received_events", "type": "User", "site_admin": false}, "created_at": "2016-04-30T15:25:34Z", "updated_at": "2016-04-30T15:25:34Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Yeah so this is just like some horrible edge case and part of the reason for the UNIQUE_SYMBOL mess in NumPy I guess.</p>\n<p>Anyway when you include NumPy, you have to call import_array to populate some function pointers. Each C module needs to do this separately, and is supposed to have its own housekeeping for these function pointers. With the GLOBAL flag on though, there is overlap in some of these shared symbols (the UNIQUE_SYMBOL is the same in NumPy and Scipy:  PyArray_API). The result is the initialization code generated by any f2py module will clobber the housekeeping and dereference a bad pointer. Whoops! But if you do the import <em>before</em> the GLOBAL flag is set, then there is no shared symbol conflict, so the modules happily do their own housekeeping like they expect. O_o</p>\n<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=23068\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/yaroslavvb\">@yaroslavvb</a> I have just really, really wanted to use TensorFlow on the Texas supercomputing clusters, which use too old GLIBC to use the binary distribution, so I've been stuck compiling TF myself <g-emoji class=\"g-emoji\" alias=\"stuck_out_tongue\" fallback-src=\"https://assets-cdn.github.com/images/icons/emoji/unicode/1f61b.png\">\ud83d\ude1b</g-emoji></p>", "body_text": "Yeah so this is just like some horrible edge case and part of the reason for the UNIQUE_SYMBOL mess in NumPy I guess.\nAnyway when you include NumPy, you have to call import_array to populate some function pointers. Each C module needs to do this separately, and is supposed to have its own housekeeping for these function pointers. With the GLOBAL flag on though, there is overlap in some of these shared symbols (the UNIQUE_SYMBOL is the same in NumPy and Scipy:  PyArray_API). The result is the initialization code generated by any f2py module will clobber the housekeeping and dereference a bad pointer. Whoops! But if you do the import before the GLOBAL flag is set, then there is no shared symbol conflict, so the modules happily do their own housekeeping like they expect. O_o\n@yaroslavvb I have just really, really wanted to use TensorFlow on the Texas supercomputing clusters, which use too old GLIBC to use the binary distribution, so I've been stuck compiling TF myself \ud83d\ude1b", "body": "Yeah so this is just like some horrible edge case and part of the reason for the UNIQUE_SYMBOL mess in NumPy I guess.\n\nAnyway when you include NumPy, you have to call import_array to populate some function pointers. Each C module needs to do this separately, and is supposed to have its own housekeeping for these function pointers. With the GLOBAL flag on though, there is overlap in some of these shared symbols (the UNIQUE_SYMBOL is the same in NumPy and Scipy:  PyArray_API). The result is the initialization code generated by any f2py module will clobber the housekeeping and dereference a bad pointer. Whoops! But if you do the import _before_ the GLOBAL flag is set, then there is no shared symbol conflict, so the modules happily do their own housekeeping like they expect. O_o\n\n@yaroslavvb I have just really, really wanted to use TensorFlow on the Texas supercomputing clusters, which use too old GLIBC to use the binary distribution, so I've been stuck compiling TF myself :stuck_out_tongue: \n"}