{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/19350", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/19350/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/19350/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/19350/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/19350", "id": 323991950, "node_id": "MDU6SXNzdWUzMjM5OTE5NTA=", "number": 19350, "title": "negative condition in tf.cond gets evaluated", "user": {"login": "xarion", "id": 111838, "node_id": "MDQ6VXNlcjExMTgzOA==", "avatar_url": "https://avatars0.githubusercontent.com/u/111838?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xarion", "html_url": "https://github.com/xarion", "followers_url": "https://api.github.com/users/xarion/followers", "following_url": "https://api.github.com/users/xarion/following{/other_user}", "gists_url": "https://api.github.com/users/xarion/gists{/gist_id}", "starred_url": "https://api.github.com/users/xarion/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xarion/subscriptions", "organizations_url": "https://api.github.com/users/xarion/orgs", "repos_url": "https://api.github.com/users/xarion/repos", "events_url": "https://api.github.com/users/xarion/events{/privacy}", "received_events_url": "https://api.github.com/users/xarion/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2018-05-17T11:59:34Z", "updated_at": "2018-05-17T12:35:41Z", "closed_at": "2018-05-17T12:35:31Z", "author_association": "NONE", "body_html": "<h3>System information</h3>\n<ul>\n<li><strong>Have I written custom code (as opposed to using a stock example script provided in TensorFlow)</strong>:<br>\nyes</li>\n<li><strong>OS Platform and Distribution (e.g., Linux Ubuntu 16.04)</strong>:<br>\nLinux Ubuntu 17.10</li>\n<li><strong>TensorFlow installed from (source or binary)</strong>:<br>\nBinary</li>\n<li><strong>TensorFlow version (use command below)</strong>:<br>\n1.8.0</li>\n<li><strong>Python version</strong>:<br>\n2.7.14</li>\n<li><strong>Bazel version (if compiling from source)</strong>: none</li>\n<li><strong>GCC/Compiler version (if compiling from source)</strong>: none</li>\n<li><strong>CUDA/cuDNN version</strong>: none</li>\n<li><strong>GPU model and memory</strong>: none</li>\n<li><strong>Exact command to reproduce</strong>: none</li>\n</ul>\n<h3>Describe the problem</h3>\n<p>when the output tensor of tf.cond is evaluated, it evaluates the tensors returned from both true and false conditions. This creates an unwanted behavior when used in combination with tf.data.Iterator.get_next. In such a situation both true and false tensors get iterated to the next element.</p>\n<h3>Source code / logs</h3>\n<pre><code>import tensorflow as tf\n\niterate = tf.placeholder(tf.bool, shape=())\n\ndataset = tf.data.Dataset.from_tensor_slices(range(1, 10))\niterator = dataset.make_one_shot_iterator()\n\ndata = iterator.get_next()\n\nempty_data = tf.constant(0)\n\ninput_data = tf.cond(iterate,\n                     true_fn=lambda: data,\n                     false_fn=lambda: empty_data)\n\nwith tf.Session() as sess:\n    print sess.run([input_data], feed_dict={iterate: True})\n    print sess.run([input_data], feed_dict={iterate: False})\n    print sess.run([input_data], feed_dict={iterate: False})\n    print sess.run([input_data], feed_dict={iterate: True})\n    print sess.run([input_data], feed_dict={iterate: False})\n    print sess.run([input_data], feed_dict={iterate: False})\n    print sess.run([input_data], feed_dict={iterate: False})\n    print sess.run([input_data], feed_dict={iterate: True})\n</code></pre>\n<p>Output</p>\n<pre><code>[1]\n[0]\n[0]\n[4]\n[0]\n[0]\n[0]\n[8]\n</code></pre>\n<p>Expected Output</p>\n<pre><code>[1]\n[0]\n[0]\n[2]\n[0]\n[0]\n[0]\n[3]\n</code></pre>", "body_text": "System information\n\nHave I written custom code (as opposed to using a stock example script provided in TensorFlow):\nyes\nOS Platform and Distribution (e.g., Linux Ubuntu 16.04):\nLinux Ubuntu 17.10\nTensorFlow installed from (source or binary):\nBinary\nTensorFlow version (use command below):\n1.8.0\nPython version:\n2.7.14\nBazel version (if compiling from source): none\nGCC/Compiler version (if compiling from source): none\nCUDA/cuDNN version: none\nGPU model and memory: none\nExact command to reproduce: none\n\nDescribe the problem\nwhen the output tensor of tf.cond is evaluated, it evaluates the tensors returned from both true and false conditions. This creates an unwanted behavior when used in combination with tf.data.Iterator.get_next. In such a situation both true and false tensors get iterated to the next element.\nSource code / logs\nimport tensorflow as tf\n\niterate = tf.placeholder(tf.bool, shape=())\n\ndataset = tf.data.Dataset.from_tensor_slices(range(1, 10))\niterator = dataset.make_one_shot_iterator()\n\ndata = iterator.get_next()\n\nempty_data = tf.constant(0)\n\ninput_data = tf.cond(iterate,\n                     true_fn=lambda: data,\n                     false_fn=lambda: empty_data)\n\nwith tf.Session() as sess:\n    print sess.run([input_data], feed_dict={iterate: True})\n    print sess.run([input_data], feed_dict={iterate: False})\n    print sess.run([input_data], feed_dict={iterate: False})\n    print sess.run([input_data], feed_dict={iterate: True})\n    print sess.run([input_data], feed_dict={iterate: False})\n    print sess.run([input_data], feed_dict={iterate: False})\n    print sess.run([input_data], feed_dict={iterate: False})\n    print sess.run([input_data], feed_dict={iterate: True})\n\nOutput\n[1]\n[0]\n[0]\n[4]\n[0]\n[0]\n[0]\n[8]\n\nExpected Output\n[1]\n[0]\n[0]\n[2]\n[0]\n[0]\n[0]\n[3]", "body": "### System information\r\n- **Have I written custom code (as opposed to using a stock example script provided in TensorFlow)**:\r\nyes\r\n- **OS Platform and Distribution (e.g., Linux Ubuntu 16.04)**:\r\nLinux Ubuntu 17.10\r\n- **TensorFlow installed from (source or binary)**:\r\nBinary\r\n- **TensorFlow version (use command below)**:\r\n1.8.0\r\n- **Python version**: \r\n2.7.14\r\n- **Bazel version (if compiling from source)**: none\r\n- **GCC/Compiler version (if compiling from source)**: none\r\n- **CUDA/cuDNN version**: none\r\n- **GPU model and memory**: none\r\n- **Exact command to reproduce**: none\r\n\r\n### Describe the problem\r\nwhen the output tensor of tf.cond is evaluated, it evaluates the tensors returned from both true and false conditions. This creates an unwanted behavior when used in combination with tf.data.Iterator.get_next. In such a situation both true and false tensors get iterated to the next element. \r\n\r\n### Source code / logs\r\n```\r\nimport tensorflow as tf\r\n\r\niterate = tf.placeholder(tf.bool, shape=())\r\n\r\ndataset = tf.data.Dataset.from_tensor_slices(range(1, 10))\r\niterator = dataset.make_one_shot_iterator()\r\n\r\ndata = iterator.get_next()\r\n\r\nempty_data = tf.constant(0)\r\n\r\ninput_data = tf.cond(iterate,\r\n                     true_fn=lambda: data,\r\n                     false_fn=lambda: empty_data)\r\n\r\nwith tf.Session() as sess:\r\n    print sess.run([input_data], feed_dict={iterate: True})\r\n    print sess.run([input_data], feed_dict={iterate: False})\r\n    print sess.run([input_data], feed_dict={iterate: False})\r\n    print sess.run([input_data], feed_dict={iterate: True})\r\n    print sess.run([input_data], feed_dict={iterate: False})\r\n    print sess.run([input_data], feed_dict={iterate: False})\r\n    print sess.run([input_data], feed_dict={iterate: False})\r\n    print sess.run([input_data], feed_dict={iterate: True})\r\n```\r\nOutput\r\n```\r\n[1]\r\n[0]\r\n[0]\r\n[4]\r\n[0]\r\n[0]\r\n[0]\r\n[8]\r\n```\r\nExpected Output\r\n```\r\n[1]\r\n[0]\r\n[0]\r\n[2]\r\n[0]\r\n[0]\r\n[0]\r\n[3]\r\n```\r\n"}