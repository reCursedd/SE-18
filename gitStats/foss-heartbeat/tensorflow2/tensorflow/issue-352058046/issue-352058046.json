{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/21730", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/21730/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/21730/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/21730/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/21730", "id": 352058046, "node_id": "MDU6SXNzdWUzNTIwNTgwNDY=", "number": 21730, "title": "The Hessian computation does not work for graphs using `tf.gather`.", "user": {"login": "rwolst", "id": 3892689, "node_id": "MDQ6VXNlcjM4OTI2ODk=", "avatar_url": "https://avatars2.githubusercontent.com/u/3892689?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rwolst", "html_url": "https://github.com/rwolst", "followers_url": "https://api.github.com/users/rwolst/followers", "following_url": "https://api.github.com/users/rwolst/following{/other_user}", "gists_url": "https://api.github.com/users/rwolst/gists{/gist_id}", "starred_url": "https://api.github.com/users/rwolst/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rwolst/subscriptions", "organizations_url": "https://api.github.com/users/rwolst/orgs", "repos_url": "https://api.github.com/users/rwolst/repos", "events_url": "https://api.github.com/users/rwolst/events{/privacy}", "received_events_url": "https://api.github.com/users/rwolst/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 404586594, "node_id": "MDU6TGFiZWw0MDQ1ODY1OTQ=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:awaiting%20tensorflower", "name": "stat:awaiting tensorflower", "color": "f4b400", "default": false}], "state": "open", "locked": false, "assignee": {"login": "rmlarsen", "id": 16907534, "node_id": "MDQ6VXNlcjE2OTA3NTM0", "avatar_url": "https://avatars2.githubusercontent.com/u/16907534?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rmlarsen", "html_url": "https://github.com/rmlarsen", "followers_url": "https://api.github.com/users/rmlarsen/followers", "following_url": "https://api.github.com/users/rmlarsen/following{/other_user}", "gists_url": "https://api.github.com/users/rmlarsen/gists{/gist_id}", "starred_url": "https://api.github.com/users/rmlarsen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rmlarsen/subscriptions", "organizations_url": "https://api.github.com/users/rmlarsen/orgs", "repos_url": "https://api.github.com/users/rmlarsen/repos", "events_url": "https://api.github.com/users/rmlarsen/events{/privacy}", "received_events_url": "https://api.github.com/users/rmlarsen/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "rmlarsen", "id": 16907534, "node_id": "MDQ6VXNlcjE2OTA3NTM0", "avatar_url": "https://avatars2.githubusercontent.com/u/16907534?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rmlarsen", "html_url": "https://github.com/rmlarsen", "followers_url": "https://api.github.com/users/rmlarsen/followers", "following_url": "https://api.github.com/users/rmlarsen/following{/other_user}", "gists_url": "https://api.github.com/users/rmlarsen/gists{/gist_id}", "starred_url": "https://api.github.com/users/rmlarsen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rmlarsen/subscriptions", "organizations_url": "https://api.github.com/users/rmlarsen/orgs", "repos_url": "https://api.github.com/users/rmlarsen/repos", "events_url": "https://api.github.com/users/rmlarsen/events{/privacy}", "received_events_url": "https://api.github.com/users/rmlarsen/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 2, "created_at": "2018-08-20T09:41:10Z", "updated_at": "2018-11-14T19:25:41Z", "closed_at": null, "author_association": "NONE", "body_html": "<h3>System information</h3>\n<ul>\n<li><strong>Have I written custom code (as opposed to using a stock example script provided in TensorFlow)</strong>: Yes.</li>\n<li><strong>OS Platform and Distribution (e.g., Linux Ubuntu 16.04)</strong>: Linux Ubuntu 16.04.</li>\n<li><strong>Mobile device (e.g. iPhone 8, Pixel 2, Samsung Galaxy) if the issue happens on mobile device</strong>:</li>\n<li><strong>TensorFlow installed from (source or binary)</strong>: Binary.</li>\n<li><strong>TensorFlow version (use command below)</strong>: v1.4.0-19-ga52c8d9 1.4.1</li>\n<li><strong>Python version</strong>: '3.6.5 (default, Mar 29 2018, 03:28:50) \\n[GCC 5.4.0 20160609]'</li>\n<li><strong>Bazel version (if compiling from source)</strong>:</li>\n<li><strong>GCC/Compiler version (if compiling from source)</strong>:</li>\n<li><strong>CUDA/cuDNN version</strong>:</li>\n<li><strong>GPU model and memory</strong>:</li>\n<li><strong>Exact command to reproduce</strong>:</li>\n</ul>\n<pre><code>import tensorflow as tf\nimport numpy as np\ntheta = tf.get_variable('theta', shape=[10], dtype=tf.float32, initializer=tf.zeros_initializer)\nindices = tf.placeholder(tf.int64, shape=(None, 3))\nY = tf.gather(theta, indices)\nloss = tf.reduce_sum(tf.square(Y))\ngrads = tf.gradients(loss, theta)\nwith tf.Session() as sess:\n   print(sess.run(grads, feed_dict={theta: np.arange(10), indices: np.array([[1,3,6], [2,4,5]])}))\n\nhess = tf.hessians(loss, theta)\nwith tf.Session() as sess:\n   print(sess.run(hess, feed_dict={theta: np.arange(10), indices: np.array([[1,3,6], [2,4,5]])}))\n</code></pre>\n<h3>Describe the problem</h3>\n<p>When trying to compute Hessians with a graph that uses <code>tf.gather</code>, it throws a <code>TypeError: 'IndexedSlices' object is not subscriptable</code>. This I believe is because the gradients are returned as <code>IndexedSlice</code> objects whereas Tensorflow is expecting them to be a normal array.</p>\n<p>What I would expect is a sort of 2D <code>IndexedSlice</code> object for <code>hess</code> such that <code>hess.values[i, j]</code> is the second partial derivative of <code>loss</code> with respect to the <code>theta</code> indices <code>hess.indices[i]</code> and <code>hess.indices[j]</code>.</p>\n<h3>Source code / logs</h3>\n<p>The traceback:</p>\n<pre lang=\"TypeError\" data-meta=\"                                Traceback (most recent call last)\"><code>&lt;ipython-input-11-b8b35a8e0799&gt; in &lt;module&gt;()\n----&gt; 1 hess = tf.hessians(loss, theta)\n\n~/Documents/Ravenholm/citadel/citadel_env/lib/python3.6/site-packages/tensorflow/python/ops/gradients_impl.py in hessians(ys, xs, name, colocate_gradients_with_ops, gate_gradients, aggregation_method)\n    999           lambda j, result: (j + 1,\n   1000                              result.write(j, gradients(_gradient[j], x)[0])),\n-&gt; 1001           loop_vars\n   1002       )\n   1003 \n\n~/Documents/Ravenholm/citadel/citadel_env/lib/python3.6/site-packages/tensorflow/python/ops/control_flow_ops.py in while_loop(cond, body, loop_vars, shape_invariants, parallel_iterations, back_prop, swap_memory, name)\n   2814     loop_context = WhileContext(parallel_iterations, back_prop, swap_memory)  # pylint: disable=redefined-outer-name\n   2815     ops.add_to_collection(ops.GraphKeys.WHILE_CONTEXT, loop_context)\n-&gt; 2816     result = loop_context.BuildLoop(cond, body, loop_vars, shape_invariants)\n   2817     return result\n   2818 \n\n~/Documents/Ravenholm/citadel/citadel_env/lib/python3.6/site-packages/tensorflow/python/ops/control_flow_ops.py in BuildLoop(self, pred, body, loop_vars, shape_invariants)\n   2638       self.Enter()\n   2639       original_body_result, exit_vars = self._BuildLoop(\n-&gt; 2640           pred, body, original_loop_vars, loop_vars, shape_invariants)\n   2641     finally:\n   2642       self.Exit()\n\n~/Documents/Ravenholm/citadel/citadel_env/lib/python3.6/site-packages/tensorflow/python/ops/control_flow_ops.py in _BuildLoop(self, pred, body, original_loop_vars, loop_vars, shape_invariants)\n   2588         structure=original_loop_vars,\n   2589         flat_sequence=vars_for_body_with_tensor_arrays)\n-&gt; 2590     body_result = body(*packed_vars_for_body)\n   2591     if not nest.is_sequence(body_result):\n   2592       body_result = [body_result]\n\n~/Documents/Ravenholm/citadel/citadel_env/lib/python3.6/site-packages/tensorflow/python/ops/gradients_impl.py in &lt;lambda&gt;(j, result)\n    998           lambda j, _: j &lt; n,\n    999           lambda j, result: (j + 1,\n-&gt; 1000                              result.write(j, gradients(_gradient[j], x)[0])),\n   1001           loop_vars\n   1002       )\n\nTypeError: 'IndexedSlices' object is not subscriptable\n</code></pre>", "body_text": "System information\n\nHave I written custom code (as opposed to using a stock example script provided in TensorFlow): Yes.\nOS Platform and Distribution (e.g., Linux Ubuntu 16.04): Linux Ubuntu 16.04.\nMobile device (e.g. iPhone 8, Pixel 2, Samsung Galaxy) if the issue happens on mobile device:\nTensorFlow installed from (source or binary): Binary.\nTensorFlow version (use command below): v1.4.0-19-ga52c8d9 1.4.1\nPython version: '3.6.5 (default, Mar 29 2018, 03:28:50) \\n[GCC 5.4.0 20160609]'\nBazel version (if compiling from source):\nGCC/Compiler version (if compiling from source):\nCUDA/cuDNN version:\nGPU model and memory:\nExact command to reproduce:\n\nimport tensorflow as tf\nimport numpy as np\ntheta = tf.get_variable('theta', shape=[10], dtype=tf.float32, initializer=tf.zeros_initializer)\nindices = tf.placeholder(tf.int64, shape=(None, 3))\nY = tf.gather(theta, indices)\nloss = tf.reduce_sum(tf.square(Y))\ngrads = tf.gradients(loss, theta)\nwith tf.Session() as sess:\n   print(sess.run(grads, feed_dict={theta: np.arange(10), indices: np.array([[1,3,6], [2,4,5]])}))\n\nhess = tf.hessians(loss, theta)\nwith tf.Session() as sess:\n   print(sess.run(hess, feed_dict={theta: np.arange(10), indices: np.array([[1,3,6], [2,4,5]])}))\n\nDescribe the problem\nWhen trying to compute Hessians with a graph that uses tf.gather, it throws a TypeError: 'IndexedSlices' object is not subscriptable. This I believe is because the gradients are returned as IndexedSlice objects whereas Tensorflow is expecting them to be a normal array.\nWhat I would expect is a sort of 2D IndexedSlice object for hess such that hess.values[i, j] is the second partial derivative of loss with respect to the theta indices hess.indices[i] and hess.indices[j].\nSource code / logs\nThe traceback:\n<ipython-input-11-b8b35a8e0799> in <module>()\n----> 1 hess = tf.hessians(loss, theta)\n\n~/Documents/Ravenholm/citadel/citadel_env/lib/python3.6/site-packages/tensorflow/python/ops/gradients_impl.py in hessians(ys, xs, name, colocate_gradients_with_ops, gate_gradients, aggregation_method)\n    999           lambda j, result: (j + 1,\n   1000                              result.write(j, gradients(_gradient[j], x)[0])),\n-> 1001           loop_vars\n   1002       )\n   1003 \n\n~/Documents/Ravenholm/citadel/citadel_env/lib/python3.6/site-packages/tensorflow/python/ops/control_flow_ops.py in while_loop(cond, body, loop_vars, shape_invariants, parallel_iterations, back_prop, swap_memory, name)\n   2814     loop_context = WhileContext(parallel_iterations, back_prop, swap_memory)  # pylint: disable=redefined-outer-name\n   2815     ops.add_to_collection(ops.GraphKeys.WHILE_CONTEXT, loop_context)\n-> 2816     result = loop_context.BuildLoop(cond, body, loop_vars, shape_invariants)\n   2817     return result\n   2818 \n\n~/Documents/Ravenholm/citadel/citadel_env/lib/python3.6/site-packages/tensorflow/python/ops/control_flow_ops.py in BuildLoop(self, pred, body, loop_vars, shape_invariants)\n   2638       self.Enter()\n   2639       original_body_result, exit_vars = self._BuildLoop(\n-> 2640           pred, body, original_loop_vars, loop_vars, shape_invariants)\n   2641     finally:\n   2642       self.Exit()\n\n~/Documents/Ravenholm/citadel/citadel_env/lib/python3.6/site-packages/tensorflow/python/ops/control_flow_ops.py in _BuildLoop(self, pred, body, original_loop_vars, loop_vars, shape_invariants)\n   2588         structure=original_loop_vars,\n   2589         flat_sequence=vars_for_body_with_tensor_arrays)\n-> 2590     body_result = body(*packed_vars_for_body)\n   2591     if not nest.is_sequence(body_result):\n   2592       body_result = [body_result]\n\n~/Documents/Ravenholm/citadel/citadel_env/lib/python3.6/site-packages/tensorflow/python/ops/gradients_impl.py in <lambda>(j, result)\n    998           lambda j, _: j < n,\n    999           lambda j, result: (j + 1,\n-> 1000                              result.write(j, gradients(_gradient[j], x)[0])),\n   1001           loop_vars\n   1002       )\n\nTypeError: 'IndexedSlices' object is not subscriptable", "body": "### System information\r\n- **Have I written custom code (as opposed to using a stock example script provided in TensorFlow)**: Yes.\r\n- **OS Platform and Distribution (e.g., Linux Ubuntu 16.04)**: Linux Ubuntu 16.04.\r\n- **Mobile device (e.g. iPhone 8, Pixel 2, Samsung Galaxy) if the issue happens on mobile device**:\r\n- **TensorFlow installed from (source or binary)**: Binary.\r\n- **TensorFlow version (use command below)**: v1.4.0-19-ga52c8d9 1.4.1\r\n- **Python version**: '3.6.5 (default, Mar 29 2018, 03:28:50) \\n[GCC 5.4.0 20160609]'\r\n- **Bazel version (if compiling from source)**:\r\n- **GCC/Compiler version (if compiling from source)**:\r\n- **CUDA/cuDNN version**:\r\n- **GPU model and memory**:\r\n- **Exact command to reproduce**:\r\n\r\n```\r\nimport tensorflow as tf\r\nimport numpy as np\r\ntheta = tf.get_variable('theta', shape=[10], dtype=tf.float32, initializer=tf.zeros_initializer)\r\nindices = tf.placeholder(tf.int64, shape=(None, 3))\r\nY = tf.gather(theta, indices)\r\nloss = tf.reduce_sum(tf.square(Y))\r\ngrads = tf.gradients(loss, theta)\r\nwith tf.Session() as sess:\r\n   print(sess.run(grads, feed_dict={theta: np.arange(10), indices: np.array([[1,3,6], [2,4,5]])}))\r\n\r\nhess = tf.hessians(loss, theta)\r\nwith tf.Session() as sess:\r\n   print(sess.run(hess, feed_dict={theta: np.arange(10), indices: np.array([[1,3,6], [2,4,5]])}))\r\n```\r\n\r\n### Describe the problem\r\nWhen trying to compute Hessians with a graph that uses `tf.gather`, it throws a `TypeError: 'IndexedSlices' object is not subscriptable`. This I believe is because the gradients are returned as `IndexedSlice` objects whereas Tensorflow is expecting them to be a normal array.\r\n\r\nWhat I would expect is a sort of 2D `IndexedSlice` object for `hess` such that `hess.values[i, j]` is the second partial derivative of `loss` with respect to the `theta` indices `hess.indices[i]` and `hess.indices[j]`.\r\n\r\n### Source code / logs\r\nThe traceback:\r\n\r\n```TypeError                                 Traceback (most recent call last)\r\n<ipython-input-11-b8b35a8e0799> in <module>()\r\n----> 1 hess = tf.hessians(loss, theta)\r\n\r\n~/Documents/Ravenholm/citadel/citadel_env/lib/python3.6/site-packages/tensorflow/python/ops/gradients_impl.py in hessians(ys, xs, name, colocate_gradients_with_ops, gate_gradients, aggregation_method)\r\n    999           lambda j, result: (j + 1,\r\n   1000                              result.write(j, gradients(_gradient[j], x)[0])),\r\n-> 1001           loop_vars\r\n   1002       )\r\n   1003 \r\n\r\n~/Documents/Ravenholm/citadel/citadel_env/lib/python3.6/site-packages/tensorflow/python/ops/control_flow_ops.py in while_loop(cond, body, loop_vars, shape_invariants, parallel_iterations, back_prop, swap_memory, name)\r\n   2814     loop_context = WhileContext(parallel_iterations, back_prop, swap_memory)  # pylint: disable=redefined-outer-name\r\n   2815     ops.add_to_collection(ops.GraphKeys.WHILE_CONTEXT, loop_context)\r\n-> 2816     result = loop_context.BuildLoop(cond, body, loop_vars, shape_invariants)\r\n   2817     return result\r\n   2818 \r\n\r\n~/Documents/Ravenholm/citadel/citadel_env/lib/python3.6/site-packages/tensorflow/python/ops/control_flow_ops.py in BuildLoop(self, pred, body, loop_vars, shape_invariants)\r\n   2638       self.Enter()\r\n   2639       original_body_result, exit_vars = self._BuildLoop(\r\n-> 2640           pred, body, original_loop_vars, loop_vars, shape_invariants)\r\n   2641     finally:\r\n   2642       self.Exit()\r\n\r\n~/Documents/Ravenholm/citadel/citadel_env/lib/python3.6/site-packages/tensorflow/python/ops/control_flow_ops.py in _BuildLoop(self, pred, body, original_loop_vars, loop_vars, shape_invariants)\r\n   2588         structure=original_loop_vars,\r\n   2589         flat_sequence=vars_for_body_with_tensor_arrays)\r\n-> 2590     body_result = body(*packed_vars_for_body)\r\n   2591     if not nest.is_sequence(body_result):\r\n   2592       body_result = [body_result]\r\n\r\n~/Documents/Ravenholm/citadel/citadel_env/lib/python3.6/site-packages/tensorflow/python/ops/gradients_impl.py in <lambda>(j, result)\r\n    998           lambda j, _: j < n,\r\n    999           lambda j, result: (j + 1,\r\n-> 1000                              result.write(j, gradients(_gradient[j], x)[0])),\r\n   1001           loop_vars\r\n   1002       )\r\n\r\nTypeError: 'IndexedSlices' object is not subscriptable\r\n```"}