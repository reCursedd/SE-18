{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/297514288", "html_url": "https://github.com/tensorflow/tensorflow/issues/2354#issuecomment-297514288", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2354", "id": 297514288, "node_id": "MDEyOklzc3VlQ29tbWVudDI5NzUxNDI4OA==", "user": {"login": "ebrevdo", "id": 1794715, "node_id": "MDQ6VXNlcjE3OTQ3MTU=", "avatar_url": "https://avatars0.githubusercontent.com/u/1794715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebrevdo", "html_url": "https://github.com/ebrevdo", "followers_url": "https://api.github.com/users/ebrevdo/followers", "following_url": "https://api.github.com/users/ebrevdo/following{/other_user}", "gists_url": "https://api.github.com/users/ebrevdo/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebrevdo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebrevdo/subscriptions", "organizations_url": "https://api.github.com/users/ebrevdo/orgs", "repos_url": "https://api.github.com/users/ebrevdo/repos", "events_url": "https://api.github.com/users/ebrevdo/events{/privacy}", "received_events_url": "https://api.github.com/users/ebrevdo/received_events", "type": "User", "site_admin": false}, "created_at": "2017-04-26T19:20:44Z", "updated_at": "2017-04-26T19:20:44Z", "author_association": "CONTRIBUTOR", "body_html": "<div class=\"email-fragment\">Looks like you are shuffling the *minibatches*, not the individual\nminibatch elements, with your shuffle queue (you're calling enqueue and\ndequeue, not enqueue_many and dequeue_many).  So if there's heavy\ncorrelation locally between inputs, your minibatches will still have that\ncorrelation and you lose the expected benefits of shuffling.</div>\n<span class=\"email-hidden-toggle\"><a href=\"#\">\u2026</a></span><div class=\"email-hidden-reply\">\n<div class=\"email-quoted-reply\">On Wed, Apr 26, 2017 at 11:02 AM, Giulio Petrucci ***@***.***&gt; wrote:\n Hi <a class=\"user-mention\" href=\"https://github.com/ebrevdo\">@ebrevdo</a> &lt;<a href=\"https://github.com/ebrevdo\">https://github.com/ebrevdo</a>&gt; and thanks for your reply.\n Actually I came out with this idea:\n\n    - feed my parsed protobufs into a tf.PaddingFIFOQueue\n    - feed it into a tf.RandomShuffleQueue\n    and apparently it works fine. So, here follows the code of my test\n    example (which is quite ugly, but no big deal). Hopefully I will set up\n    something more interesting in one of my projects and maybe share the link\n    here. Any comment is *more* than welcome.\n\n import random\n import tensorflow as tf\n\n MIN_LEN = 6MAX_LEN = 12NUM_EXAMPLES = 10BATCH_SIZE = 7PATH = 'ciaone.tfrecords'MIN_AFTER_DEQUEUE = 10NUM_THREADS = 2SAFETY_MARGIN = 1CAPACITY = MIN_AFTER_DEQUEUE + (NUM_THREADS + SAFETY_MARGIN) * BATCH_SIZE\n\n def generate_example():\n     \"\"\"Generate an example.\"\"\"\n     length = random.randint(MIN_LEN, MAX_LEN)\n     input_ = [random.randint(1, 10) for _ in xrange(length)]\n     avg = sum([1.0 * item for item in input_]) / len(input_)\n     output = [item for item in input_ if item &gt;= avg]\n     return input_, output\n\n def encode(input_, output):\n     \"\"\"Encode a pair of input, output tensor into a tf.train.Example.\"\"\"\n     example = tf.train.Example(\n         features=tf.train.Features(\n             feature={\n                 'input': tf.train.Feature(\n                     int64_list=tf.train.Int64List(\n                         value=input_)),\n                 'output': tf.train.Feature(\n                     int64_list=tf.train.Int64List(\n                         value=output))}))\n     return example\n\n def decode(example):\n     \"\"\"Decode an example into a tuple of input, output tensors.\"\"\"\n     features = {\n         'input': tf.VarLenFeature(tf.int64),\n         'output': tf.VarLenFeature(tf.int64)\n     }\n     parsed = tf.parse_single_example(\n         serialized=example,\n         features=features)\n     input_ = parsed['input']\n     output = parsed['output']\n     input_ = tf.sparse_tensor_to_dense(parsed['input'])\n     output = tf.sparse_tensor_to_dense(parsed['output'])\n     return input_, output\n\n def main():\n     \"\"\"Run the example.\"\"\"\n\n     # 1. decode the records from the file.\n     file_queue = tf.train.string_input_producer(\n         [PATH], shuffle=True, num_epochs=2)\n     reader = tf.TFRecordReader()\n     key, value = reader.read(file_queue)\n     input_, output = decode(value)\n\n     # 2. padding queue.\n     padding_queue = tf.PaddingFIFOQueue(\n         capacity=CAPACITY,\n         dtypes=[tf.string, tf.int64, tf.int64],\n         shapes=[[], [None], [None]])\n     padding_enqueue_op = padding_queue.enqueue([key, input_, output])\n     padding_queue_runner = tf.train.QueueRunner(\n         padding_queue, [padding_enqueue_op] * NUM_THREADS)\n     tf.train.add_queue_runner(padding_queue_runner)\n     padding_dequeue_op = padding_queue.dequeue_up_to(BATCH_SIZE)\n\n     # 3. shuffling queue that tolerates different shapes.\n     shuffle_queue = tf.RandomShuffleQueue(\n         capacity=CAPACITY,\n         min_after_dequeue=MIN_AFTER_DEQUEUE,\n         dtypes=[tf.string, tf.int64, tf.int64],\n         shapes=None)\n     shuffle_enqueue_op = shuffle_queue.enqueue(padding_dequeue_op)\n     shuffle_queue_runner = tf.train.QueueRunner(\n         shuffle_queue, [shuffle_enqueue_op] * NUM_THREADS)\n     tf.train.add_queue_runner(shuffle_queue_runner)\n     shuffle_dequeue_op = shuffle_queue.dequeue()\n     fetches = shuffle_dequeue_op\n\n     # 4. run.\n     with tf.Session() as sess:\n         sess.run(tf.local_variables_initializer())\n         sess.run(tf.global_variables_initializer())\n         coord = tf.train.Coordinator()\n         threads = tf.train.start_queue_runners(coord=coord)\n         try:\n             while True:\n                 keys, inputs, outputs = tuple(sess.run(fetches))\n                 for k, i in zip(keys, inputs):\n                     print(k + ': ' + str(i))\n                 print(inputs.shape)\n                 print\n         except tf.errors.OutOfRangeError as ex:\n             coord.request_stop(ex=ex)\n         finally:\n             coord.request_stop()\n             coord.join(threads)\n     print(' -- done -- ')\n\n if __name__ == '__main__':\n     # Before running the example, generate a bunch of examples\n     # and save them in a file as TFRecords.\n     with tf.python_io.TFRecordWriter(PATH) as writer:\n         for _ in xrange(NUM_EXAMPLES):\n             ii, oo = generate_example()\n             example = encode(ii, oo)\n             writer.write(example.SerializeToString())\n     main()\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n &lt;<a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"154788647\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/tensorflow/tensorflow/issues/2354\" href=\"https://github.com/tensorflow/tensorflow/issues/2354#issuecomment-297493018\">#2354 (comment)</a>&gt;,\n or mute the thread\n &lt;<a href=\"https://github.com/notifications/unsubscribe-auth/ABtim3CiGcASU-3oCDyW7aj2IdCB2AZYks5rz4a0gaJpZM4IeVSX\">https://github.com/notifications/unsubscribe-auth/ABtim3CiGcASU-3oCDyW7aj2IdCB2AZYks5rz4a0gaJpZM4IeVSX</a>&gt;\n .\n</div>\n<div class=\"email-fragment\"></div>\n</div>", "body_text": "Looks like you are shuffling the *minibatches*, not the individual\nminibatch elements, with your shuffle queue (you're calling enqueue and\ndequeue, not enqueue_many and dequeue_many).  So if there's heavy\ncorrelation locally between inputs, your minibatches will still have that\ncorrelation and you lose the expected benefits of shuffling.\n\u2026\nOn Wed, Apr 26, 2017 at 11:02 AM, Giulio Petrucci ***@***.***> wrote:\n Hi @ebrevdo <https://github.com/ebrevdo> and thanks for your reply.\n Actually I came out with this idea:\n\n    - feed my parsed protobufs into a tf.PaddingFIFOQueue\n    - feed it into a tf.RandomShuffleQueue\n    and apparently it works fine. So, here follows the code of my test\n    example (which is quite ugly, but no big deal). Hopefully I will set up\n    something more interesting in one of my projects and maybe share the link\n    here. Any comment is *more* than welcome.\n\n import random\n import tensorflow as tf\n\n MIN_LEN = 6MAX_LEN = 12NUM_EXAMPLES = 10BATCH_SIZE = 7PATH = 'ciaone.tfrecords'MIN_AFTER_DEQUEUE = 10NUM_THREADS = 2SAFETY_MARGIN = 1CAPACITY = MIN_AFTER_DEQUEUE + (NUM_THREADS + SAFETY_MARGIN) * BATCH_SIZE\n\n def generate_example():\n     \"\"\"Generate an example.\"\"\"\n     length = random.randint(MIN_LEN, MAX_LEN)\n     input_ = [random.randint(1, 10) for _ in xrange(length)]\n     avg = sum([1.0 * item for item in input_]) / len(input_)\n     output = [item for item in input_ if item >= avg]\n     return input_, output\n\n def encode(input_, output):\n     \"\"\"Encode a pair of input, output tensor into a tf.train.Example.\"\"\"\n     example = tf.train.Example(\n         features=tf.train.Features(\n             feature={\n                 'input': tf.train.Feature(\n                     int64_list=tf.train.Int64List(\n                         value=input_)),\n                 'output': tf.train.Feature(\n                     int64_list=tf.train.Int64List(\n                         value=output))}))\n     return example\n\n def decode(example):\n     \"\"\"Decode an example into a tuple of input, output tensors.\"\"\"\n     features = {\n         'input': tf.VarLenFeature(tf.int64),\n         'output': tf.VarLenFeature(tf.int64)\n     }\n     parsed = tf.parse_single_example(\n         serialized=example,\n         features=features)\n     input_ = parsed['input']\n     output = parsed['output']\n     input_ = tf.sparse_tensor_to_dense(parsed['input'])\n     output = tf.sparse_tensor_to_dense(parsed['output'])\n     return input_, output\n\n def main():\n     \"\"\"Run the example.\"\"\"\n\n     # 1. decode the records from the file.\n     file_queue = tf.train.string_input_producer(\n         [PATH], shuffle=True, num_epochs=2)\n     reader = tf.TFRecordReader()\n     key, value = reader.read(file_queue)\n     input_, output = decode(value)\n\n     # 2. padding queue.\n     padding_queue = tf.PaddingFIFOQueue(\n         capacity=CAPACITY,\n         dtypes=[tf.string, tf.int64, tf.int64],\n         shapes=[[], [None], [None]])\n     padding_enqueue_op = padding_queue.enqueue([key, input_, output])\n     padding_queue_runner = tf.train.QueueRunner(\n         padding_queue, [padding_enqueue_op] * NUM_THREADS)\n     tf.train.add_queue_runner(padding_queue_runner)\n     padding_dequeue_op = padding_queue.dequeue_up_to(BATCH_SIZE)\n\n     # 3. shuffling queue that tolerates different shapes.\n     shuffle_queue = tf.RandomShuffleQueue(\n         capacity=CAPACITY,\n         min_after_dequeue=MIN_AFTER_DEQUEUE,\n         dtypes=[tf.string, tf.int64, tf.int64],\n         shapes=None)\n     shuffle_enqueue_op = shuffle_queue.enqueue(padding_dequeue_op)\n     shuffle_queue_runner = tf.train.QueueRunner(\n         shuffle_queue, [shuffle_enqueue_op] * NUM_THREADS)\n     tf.train.add_queue_runner(shuffle_queue_runner)\n     shuffle_dequeue_op = shuffle_queue.dequeue()\n     fetches = shuffle_dequeue_op\n\n     # 4. run.\n     with tf.Session() as sess:\n         sess.run(tf.local_variables_initializer())\n         sess.run(tf.global_variables_initializer())\n         coord = tf.train.Coordinator()\n         threads = tf.train.start_queue_runners(coord=coord)\n         try:\n             while True:\n                 keys, inputs, outputs = tuple(sess.run(fetches))\n                 for k, i in zip(keys, inputs):\n                     print(k + ': ' + str(i))\n                 print(inputs.shape)\n                 print\n         except tf.errors.OutOfRangeError as ex:\n             coord.request_stop(ex=ex)\n         finally:\n             coord.request_stop()\n             coord.join(threads)\n     print(' -- done -- ')\n\n if __name__ == '__main__':\n     # Before running the example, generate a bunch of examples\n     # and save them in a file as TFRecords.\n     with tf.python_io.TFRecordWriter(PATH) as writer:\n         for _ in xrange(NUM_EXAMPLES):\n             ii, oo = generate_example()\n             example = encode(ii, oo)\n             writer.write(example.SerializeToString())\n     main()\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#2354 (comment)>,\n or mute the thread\n <https://github.com/notifications/unsubscribe-auth/ABtim3CiGcASU-3oCDyW7aj2IdCB2AZYks5rz4a0gaJpZM4IeVSX>\n .", "body": "Looks like you are shuffling the *minibatches*, not the individual\nminibatch elements, with your shuffle queue (you're calling enqueue and\ndequeue, not enqueue_many and dequeue_many).  So if there's heavy\ncorrelation locally between inputs, your minibatches will still have that\ncorrelation and you lose the expected benefits of shuffling.\n\nOn Wed, Apr 26, 2017 at 11:02 AM, Giulio Petrucci <notifications@github.com>\nwrote:\n\n> Hi @ebrevdo <https://github.com/ebrevdo> and thanks for your reply.\n> Actually I came out with this idea:\n>\n>    - feed my parsed protobufs into a tf.PaddingFIFOQueue\n>    - feed it into a tf.RandomShuffleQueue\n>    and apparently it works fine. So, here follows the code of my test\n>    example (which is quite ugly, but no big deal). Hopefully I will set up\n>    something more interesting in one of my projects and maybe share the link\n>    here. Any comment is *more* than welcome.\n>\n> import random\n> import tensorflow as tf\n>\n> MIN_LEN = 6MAX_LEN = 12NUM_EXAMPLES = 10BATCH_SIZE = 7PATH = 'ciaone.tfrecords'MIN_AFTER_DEQUEUE = 10NUM_THREADS = 2SAFETY_MARGIN = 1CAPACITY = MIN_AFTER_DEQUEUE + (NUM_THREADS + SAFETY_MARGIN) * BATCH_SIZE\n>\n> def generate_example():\n>     \"\"\"Generate an example.\"\"\"\n>     length = random.randint(MIN_LEN, MAX_LEN)\n>     input_ = [random.randint(1, 10) for _ in xrange(length)]\n>     avg = sum([1.0 * item for item in input_]) / len(input_)\n>     output = [item for item in input_ if item >= avg]\n>     return input_, output\n>\n> def encode(input_, output):\n>     \"\"\"Encode a pair of input, output tensor into a tf.train.Example.\"\"\"\n>     example = tf.train.Example(\n>         features=tf.train.Features(\n>             feature={\n>                 'input': tf.train.Feature(\n>                     int64_list=tf.train.Int64List(\n>                         value=input_)),\n>                 'output': tf.train.Feature(\n>                     int64_list=tf.train.Int64List(\n>                         value=output))}))\n>     return example\n>\n> def decode(example):\n>     \"\"\"Decode an example into a tuple of input, output tensors.\"\"\"\n>     features = {\n>         'input': tf.VarLenFeature(tf.int64),\n>         'output': tf.VarLenFeature(tf.int64)\n>     }\n>     parsed = tf.parse_single_example(\n>         serialized=example,\n>         features=features)\n>     input_ = parsed['input']\n>     output = parsed['output']\n>     input_ = tf.sparse_tensor_to_dense(parsed['input'])\n>     output = tf.sparse_tensor_to_dense(parsed['output'])\n>     return input_, output\n>\n> def main():\n>     \"\"\"Run the example.\"\"\"\n>\n>     # 1. decode the records from the file.\n>     file_queue = tf.train.string_input_producer(\n>         [PATH], shuffle=True, num_epochs=2)\n>     reader = tf.TFRecordReader()\n>     key, value = reader.read(file_queue)\n>     input_, output = decode(value)\n>\n>     # 2. padding queue.\n>     padding_queue = tf.PaddingFIFOQueue(\n>         capacity=CAPACITY,\n>         dtypes=[tf.string, tf.int64, tf.int64],\n>         shapes=[[], [None], [None]])\n>     padding_enqueue_op = padding_queue.enqueue([key, input_, output])\n>     padding_queue_runner = tf.train.QueueRunner(\n>         padding_queue, [padding_enqueue_op] * NUM_THREADS)\n>     tf.train.add_queue_runner(padding_queue_runner)\n>     padding_dequeue_op = padding_queue.dequeue_up_to(BATCH_SIZE)\n>\n>     # 3. shuffling queue that tolerates different shapes.\n>     shuffle_queue = tf.RandomShuffleQueue(\n>         capacity=CAPACITY,\n>         min_after_dequeue=MIN_AFTER_DEQUEUE,\n>         dtypes=[tf.string, tf.int64, tf.int64],\n>         shapes=None)\n>     shuffle_enqueue_op = shuffle_queue.enqueue(padding_dequeue_op)\n>     shuffle_queue_runner = tf.train.QueueRunner(\n>         shuffle_queue, [shuffle_enqueue_op] * NUM_THREADS)\n>     tf.train.add_queue_runner(shuffle_queue_runner)\n>     shuffle_dequeue_op = shuffle_queue.dequeue()\n>     fetches = shuffle_dequeue_op\n>\n>     # 4. run.\n>     with tf.Session() as sess:\n>         sess.run(tf.local_variables_initializer())\n>         sess.run(tf.global_variables_initializer())\n>         coord = tf.train.Coordinator()\n>         threads = tf.train.start_queue_runners(coord=coord)\n>         try:\n>             while True:\n>                 keys, inputs, outputs = tuple(sess.run(fetches))\n>                 for k, i in zip(keys, inputs):\n>                     print(k + ': ' + str(i))\n>                 print(inputs.shape)\n>                 print\n>         except tf.errors.OutOfRangeError as ex:\n>             coord.request_stop(ex=ex)\n>         finally:\n>             coord.request_stop()\n>             coord.join(threads)\n>     print(' -- done -- ')\n>\n> if __name__ == '__main__':\n>     # Before running the example, generate a bunch of examples\n>     # and save them in a file as TFRecords.\n>     with tf.python_io.TFRecordWriter(PATH) as writer:\n>         for _ in xrange(NUM_EXAMPLES):\n>             ii, oo = generate_example()\n>             example = encode(ii, oo)\n>             writer.write(example.SerializeToString())\n>     main()\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tensorflow/tensorflow/issues/2354#issuecomment-297493018>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/ABtim3CiGcASU-3oCDyW7aj2IdCB2AZYks5rz4a0gaJpZM4IeVSX>\n> .\n>\n"}