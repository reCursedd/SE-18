{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/297493018", "html_url": "https://github.com/tensorflow/tensorflow/issues/2354#issuecomment-297493018", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2354", "id": 297493018, "node_id": "MDEyOklzc3VlQ29tbWVudDI5NzQ5MzAxOA==", "user": {"login": "petrux", "id": 401919, "node_id": "MDQ6VXNlcjQwMTkxOQ==", "avatar_url": "https://avatars0.githubusercontent.com/u/401919?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrux", "html_url": "https://github.com/petrux", "followers_url": "https://api.github.com/users/petrux/followers", "following_url": "https://api.github.com/users/petrux/following{/other_user}", "gists_url": "https://api.github.com/users/petrux/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrux/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrux/subscriptions", "organizations_url": "https://api.github.com/users/petrux/orgs", "repos_url": "https://api.github.com/users/petrux/repos", "events_url": "https://api.github.com/users/petrux/events{/privacy}", "received_events_url": "https://api.github.com/users/petrux/received_events", "type": "User", "site_admin": false}, "created_at": "2017-04-26T18:01:37Z", "updated_at": "2017-04-26T18:01:37Z", "author_association": "NONE", "body_html": "<p>Hi <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=1794715\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/ebrevdo\">@ebrevdo</a> and thanks for your reply. Actually I came out with this idea:</p>\n<ul>\n<li>feed my parsed protobufs into a <code>tf.PaddingFIFOQueue</code></li>\n<li>feed it into a <code>tf.RandomShuffleQueue</code><br>\nand apparently it works fine. So, here follows the code of my test example (which is quite ugly, but no big deal). Hopefully I will set up something more interesting in one of my projects and maybe share the link here. Any comment is <em>more</em> than welcome.</li>\n</ul>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">import</span> random\n\n<span class=\"pl-k\">import</span> tensorflow <span class=\"pl-k\">as</span> tf\n\n\n<span class=\"pl-c1\">MIN_LEN</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">6</span>\n<span class=\"pl-c1\">MAX_LEN</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">12</span>\n<span class=\"pl-c1\">NUM_EXAMPLES</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">10</span>\n<span class=\"pl-c1\">BATCH_SIZE</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">7</span>\n<span class=\"pl-c1\">PATH</span> <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>ciaone.tfrecords<span class=\"pl-pds\">'</span></span>\n<span class=\"pl-c1\">MIN_AFTER_DEQUEUE</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">10</span>\n<span class=\"pl-c1\">NUM_THREADS</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">2</span>\n<span class=\"pl-c1\">SAFETY_MARGIN</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">1</span>\n<span class=\"pl-c1\">CAPACITY</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">MIN_AFTER_DEQUEUE</span> <span class=\"pl-k\">+</span> (<span class=\"pl-c1\">NUM_THREADS</span> <span class=\"pl-k\">+</span> <span class=\"pl-c1\">SAFETY_MARGIN</span>) <span class=\"pl-k\">*</span> <span class=\"pl-c1\">BATCH_SIZE</span>\n\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">generate_example</span>():\n    <span class=\"pl-s\"><span class=\"pl-pds\">\"\"\"</span>Generate an example.<span class=\"pl-pds\">\"\"\"</span></span>\n    length <span class=\"pl-k\">=</span> random.randint(<span class=\"pl-c1\">MIN_LEN</span>, <span class=\"pl-c1\">MAX_LEN</span>)\n    input_ <span class=\"pl-k\">=</span> [random.randint(<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">10</span>) <span class=\"pl-k\">for</span> _ <span class=\"pl-k\">in</span> <span class=\"pl-v\">xrange</span>(length)]\n    avg <span class=\"pl-k\">=</span> <span class=\"pl-c1\">sum</span>([<span class=\"pl-c1\">1.0</span> <span class=\"pl-k\">*</span> item <span class=\"pl-k\">for</span> item <span class=\"pl-k\">in</span> input_]) <span class=\"pl-k\">/</span> <span class=\"pl-c1\">len</span>(input_)\n    output <span class=\"pl-k\">=</span> [item <span class=\"pl-k\">for</span> item <span class=\"pl-k\">in</span> input_ <span class=\"pl-k\">if</span> item <span class=\"pl-k\">&gt;=</span> avg]\n    <span class=\"pl-k\">return</span> input_, output\n\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">encode</span>(<span class=\"pl-smi\">input_</span>, <span class=\"pl-smi\">output</span>):\n    <span class=\"pl-s\"><span class=\"pl-pds\">\"\"\"</span>Encode a pair of input, output tensor into a tf.train.Example.<span class=\"pl-pds\">\"\"\"</span></span>\n    example <span class=\"pl-k\">=</span> tf.train.Example(\n        <span class=\"pl-v\">features</span><span class=\"pl-k\">=</span>tf.train.Features(\n            <span class=\"pl-v\">feature</span><span class=\"pl-k\">=</span>{\n                <span class=\"pl-s\"><span class=\"pl-pds\">'</span>input<span class=\"pl-pds\">'</span></span>: tf.train.Feature(\n                    <span class=\"pl-v\">int64_list</span><span class=\"pl-k\">=</span>tf.train.Int64List(\n                        <span class=\"pl-v\">value</span><span class=\"pl-k\">=</span>input_)),\n                <span class=\"pl-s\"><span class=\"pl-pds\">'</span>output<span class=\"pl-pds\">'</span></span>: tf.train.Feature(\n                    <span class=\"pl-v\">int64_list</span><span class=\"pl-k\">=</span>tf.train.Int64List(\n                        <span class=\"pl-v\">value</span><span class=\"pl-k\">=</span>output))}))\n    <span class=\"pl-k\">return</span> example\n\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">decode</span>(<span class=\"pl-smi\">example</span>):\n    <span class=\"pl-s\"><span class=\"pl-pds\">\"\"\"</span>Decode an example into a tuple of input, output tensors.<span class=\"pl-pds\">\"\"\"</span></span>\n    features <span class=\"pl-k\">=</span> {\n        <span class=\"pl-s\"><span class=\"pl-pds\">'</span>input<span class=\"pl-pds\">'</span></span>: tf.VarLenFeature(tf.int64),\n        <span class=\"pl-s\"><span class=\"pl-pds\">'</span>output<span class=\"pl-pds\">'</span></span>: tf.VarLenFeature(tf.int64)\n    }\n    parsed <span class=\"pl-k\">=</span> tf.parse_single_example(\n        <span class=\"pl-v\">serialized</span><span class=\"pl-k\">=</span>example,\n        <span class=\"pl-v\">features</span><span class=\"pl-k\">=</span>features)\n    input_ <span class=\"pl-k\">=</span> parsed[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>input<span class=\"pl-pds\">'</span></span>]\n    output <span class=\"pl-k\">=</span> parsed[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>output<span class=\"pl-pds\">'</span></span>]\n    input_ <span class=\"pl-k\">=</span> tf.sparse_tensor_to_dense(parsed[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>input<span class=\"pl-pds\">'</span></span>])\n    output <span class=\"pl-k\">=</span> tf.sparse_tensor_to_dense(parsed[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>output<span class=\"pl-pds\">'</span></span>])\n    <span class=\"pl-k\">return</span> input_, output\n\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">main</span>():\n    <span class=\"pl-s\"><span class=\"pl-pds\">\"\"\"</span>Run the example.<span class=\"pl-pds\">\"\"\"</span></span>\n\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> 1. decode the records from the file.</span>\n    file_queue <span class=\"pl-k\">=</span> tf.train.string_input_producer(\n        [<span class=\"pl-c1\">PATH</span>], <span class=\"pl-v\">shuffle</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">True</span>, <span class=\"pl-v\">num_epochs</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">2</span>)\n    reader <span class=\"pl-k\">=</span> tf.TFRecordReader()\n    key, value <span class=\"pl-k\">=</span> reader.read(file_queue)\n    input_, output <span class=\"pl-k\">=</span> decode(value)\n\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> 2. padding queue.</span>\n    padding_queue <span class=\"pl-k\">=</span> tf.PaddingFIFOQueue(\n        <span class=\"pl-v\">capacity</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">CAPACITY</span>,\n        <span class=\"pl-v\">dtypes</span><span class=\"pl-k\">=</span>[tf.string, tf.int64, tf.int64],\n        <span class=\"pl-v\">shapes</span><span class=\"pl-k\">=</span>[[], [<span class=\"pl-c1\">None</span>], [<span class=\"pl-c1\">None</span>]])\n    padding_enqueue_op <span class=\"pl-k\">=</span> padding_queue.enqueue([key, input_, output])\n    padding_queue_runner <span class=\"pl-k\">=</span> tf.train.QueueRunner(\n        padding_queue, [padding_enqueue_op] <span class=\"pl-k\">*</span> <span class=\"pl-c1\">NUM_THREADS</span>)\n    tf.train.add_queue_runner(padding_queue_runner)\n    padding_dequeue_op <span class=\"pl-k\">=</span> padding_queue.dequeue_up_to(<span class=\"pl-c1\">BATCH_SIZE</span>)\n\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> 3. shuffling queue that tolerates different shapes.</span>\n    shuffle_queue <span class=\"pl-k\">=</span> tf.RandomShuffleQueue(\n        <span class=\"pl-v\">capacity</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">CAPACITY</span>,\n        <span class=\"pl-v\">min_after_dequeue</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">MIN_AFTER_DEQUEUE</span>,\n        <span class=\"pl-v\">dtypes</span><span class=\"pl-k\">=</span>[tf.string, tf.int64, tf.int64],\n        <span class=\"pl-v\">shapes</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">None</span>)\n    shuffle_enqueue_op <span class=\"pl-k\">=</span> shuffle_queue.enqueue(padding_dequeue_op)\n    shuffle_queue_runner <span class=\"pl-k\">=</span> tf.train.QueueRunner(\n        shuffle_queue, [shuffle_enqueue_op] <span class=\"pl-k\">*</span> <span class=\"pl-c1\">NUM_THREADS</span>)\n    tf.train.add_queue_runner(shuffle_queue_runner)\n    shuffle_dequeue_op <span class=\"pl-k\">=</span> shuffle_queue.dequeue()\n    fetches <span class=\"pl-k\">=</span> shuffle_dequeue_op\n\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> 4. run.</span>\n    <span class=\"pl-k\">with</span> tf.Session() <span class=\"pl-k\">as</span> sess:\n        sess.run(tf.local_variables_initializer())\n        sess.run(tf.global_variables_initializer())\n        coord <span class=\"pl-k\">=</span> tf.train.Coordinator()\n        threads <span class=\"pl-k\">=</span> tf.train.start_queue_runners(<span class=\"pl-v\">coord</span><span class=\"pl-k\">=</span>coord)\n        <span class=\"pl-k\">try</span>:\n            <span class=\"pl-k\">while</span> <span class=\"pl-c1\">True</span>:\n                keys, inputs, outputs <span class=\"pl-k\">=</span> <span class=\"pl-c1\">tuple</span>(sess.run(fetches))\n                <span class=\"pl-k\">for</span> k, i <span class=\"pl-k\">in</span> <span class=\"pl-c1\">zip</span>(keys, inputs):\n                    <span class=\"pl-c1\">print</span>(k <span class=\"pl-k\">+</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>: <span class=\"pl-pds\">'</span></span> <span class=\"pl-k\">+</span> <span class=\"pl-c1\">str</span>(i))\n                <span class=\"pl-c1\">print</span>(inputs.shape)\n                <span class=\"pl-c1\">print</span>\n        <span class=\"pl-k\">except</span> tf.errors.OutOfRangeError <span class=\"pl-k\">as</span> ex:\n            coord.request_stop(<span class=\"pl-v\">ex</span><span class=\"pl-k\">=</span>ex)\n        <span class=\"pl-k\">finally</span>:\n            coord.request_stop()\n            coord.join(threads)\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span> -- done -- <span class=\"pl-pds\">'</span></span>)\n\n\n<span class=\"pl-k\">if</span> <span class=\"pl-c1\">__name__</span> <span class=\"pl-k\">==</span> <span class=\"pl-s\"><span class=\"pl-pds\">'</span>__main__<span class=\"pl-pds\">'</span></span>:\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> Before running the example, generate a bunch of examples</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> and save them in a file as TFRecords.</span>\n    <span class=\"pl-k\">with</span> tf.python_io.TFRecordWriter(<span class=\"pl-c1\">PATH</span>) <span class=\"pl-k\">as</span> writer:\n        <span class=\"pl-k\">for</span> _ <span class=\"pl-k\">in</span> <span class=\"pl-v\">xrange</span>(<span class=\"pl-c1\">NUM_EXAMPLES</span>):\n            ii, oo <span class=\"pl-k\">=</span> generate_example()\n            example <span class=\"pl-k\">=</span> encode(ii, oo)\n            writer.write(example.SerializeToString())\n    main()</pre></div>", "body_text": "Hi @ebrevdo and thanks for your reply. Actually I came out with this idea:\n\nfeed my parsed protobufs into a tf.PaddingFIFOQueue\nfeed it into a tf.RandomShuffleQueue\nand apparently it works fine. So, here follows the code of my test example (which is quite ugly, but no big deal). Hopefully I will set up something more interesting in one of my projects and maybe share the link here. Any comment is more than welcome.\n\nimport random\n\nimport tensorflow as tf\n\n\nMIN_LEN = 6\nMAX_LEN = 12\nNUM_EXAMPLES = 10\nBATCH_SIZE = 7\nPATH = 'ciaone.tfrecords'\nMIN_AFTER_DEQUEUE = 10\nNUM_THREADS = 2\nSAFETY_MARGIN = 1\nCAPACITY = MIN_AFTER_DEQUEUE + (NUM_THREADS + SAFETY_MARGIN) * BATCH_SIZE\n\n\ndef generate_example():\n    \"\"\"Generate an example.\"\"\"\n    length = random.randint(MIN_LEN, MAX_LEN)\n    input_ = [random.randint(1, 10) for _ in xrange(length)]\n    avg = sum([1.0 * item for item in input_]) / len(input_)\n    output = [item for item in input_ if item >= avg]\n    return input_, output\n\n\ndef encode(input_, output):\n    \"\"\"Encode a pair of input, output tensor into a tf.train.Example.\"\"\"\n    example = tf.train.Example(\n        features=tf.train.Features(\n            feature={\n                'input': tf.train.Feature(\n                    int64_list=tf.train.Int64List(\n                        value=input_)),\n                'output': tf.train.Feature(\n                    int64_list=tf.train.Int64List(\n                        value=output))}))\n    return example\n\n\ndef decode(example):\n    \"\"\"Decode an example into a tuple of input, output tensors.\"\"\"\n    features = {\n        'input': tf.VarLenFeature(tf.int64),\n        'output': tf.VarLenFeature(tf.int64)\n    }\n    parsed = tf.parse_single_example(\n        serialized=example,\n        features=features)\n    input_ = parsed['input']\n    output = parsed['output']\n    input_ = tf.sparse_tensor_to_dense(parsed['input'])\n    output = tf.sparse_tensor_to_dense(parsed['output'])\n    return input_, output\n\n\ndef main():\n    \"\"\"Run the example.\"\"\"\n\n    # 1. decode the records from the file.\n    file_queue = tf.train.string_input_producer(\n        [PATH], shuffle=True, num_epochs=2)\n    reader = tf.TFRecordReader()\n    key, value = reader.read(file_queue)\n    input_, output = decode(value)\n\n    # 2. padding queue.\n    padding_queue = tf.PaddingFIFOQueue(\n        capacity=CAPACITY,\n        dtypes=[tf.string, tf.int64, tf.int64],\n        shapes=[[], [None], [None]])\n    padding_enqueue_op = padding_queue.enqueue([key, input_, output])\n    padding_queue_runner = tf.train.QueueRunner(\n        padding_queue, [padding_enqueue_op] * NUM_THREADS)\n    tf.train.add_queue_runner(padding_queue_runner)\n    padding_dequeue_op = padding_queue.dequeue_up_to(BATCH_SIZE)\n\n    # 3. shuffling queue that tolerates different shapes.\n    shuffle_queue = tf.RandomShuffleQueue(\n        capacity=CAPACITY,\n        min_after_dequeue=MIN_AFTER_DEQUEUE,\n        dtypes=[tf.string, tf.int64, tf.int64],\n        shapes=None)\n    shuffle_enqueue_op = shuffle_queue.enqueue(padding_dequeue_op)\n    shuffle_queue_runner = tf.train.QueueRunner(\n        shuffle_queue, [shuffle_enqueue_op] * NUM_THREADS)\n    tf.train.add_queue_runner(shuffle_queue_runner)\n    shuffle_dequeue_op = shuffle_queue.dequeue()\n    fetches = shuffle_dequeue_op\n\n    # 4. run.\n    with tf.Session() as sess:\n        sess.run(tf.local_variables_initializer())\n        sess.run(tf.global_variables_initializer())\n        coord = tf.train.Coordinator()\n        threads = tf.train.start_queue_runners(coord=coord)\n        try:\n            while True:\n                keys, inputs, outputs = tuple(sess.run(fetches))\n                for k, i in zip(keys, inputs):\n                    print(k + ': ' + str(i))\n                print(inputs.shape)\n                print\n        except tf.errors.OutOfRangeError as ex:\n            coord.request_stop(ex=ex)\n        finally:\n            coord.request_stop()\n            coord.join(threads)\n    print(' -- done -- ')\n\n\nif __name__ == '__main__':\n    # Before running the example, generate a bunch of examples\n    # and save them in a file as TFRecords.\n    with tf.python_io.TFRecordWriter(PATH) as writer:\n        for _ in xrange(NUM_EXAMPLES):\n            ii, oo = generate_example()\n            example = encode(ii, oo)\n            writer.write(example.SerializeToString())\n    main()", "body": "Hi @ebrevdo and thanks for your reply. Actually I came out with this idea:\r\n* feed my parsed protobufs into a `tf.PaddingFIFOQueue`\r\n* feed it into a `tf.RandomShuffleQueue`\r\nand apparently it works fine. So, here follows the code of my test example (which is quite ugly, but no big deal). Hopefully I will set up something more interesting in one of my projects and maybe share the link here. Any comment is _more_ than welcome.\r\n\r\n```python\r\nimport random\r\n\r\nimport tensorflow as tf\r\n\r\n\r\nMIN_LEN = 6\r\nMAX_LEN = 12\r\nNUM_EXAMPLES = 10\r\nBATCH_SIZE = 7\r\nPATH = 'ciaone.tfrecords'\r\nMIN_AFTER_DEQUEUE = 10\r\nNUM_THREADS = 2\r\nSAFETY_MARGIN = 1\r\nCAPACITY = MIN_AFTER_DEQUEUE + (NUM_THREADS + SAFETY_MARGIN) * BATCH_SIZE\r\n\r\n\r\ndef generate_example():\r\n    \"\"\"Generate an example.\"\"\"\r\n    length = random.randint(MIN_LEN, MAX_LEN)\r\n    input_ = [random.randint(1, 10) for _ in xrange(length)]\r\n    avg = sum([1.0 * item for item in input_]) / len(input_)\r\n    output = [item for item in input_ if item >= avg]\r\n    return input_, output\r\n\r\n\r\ndef encode(input_, output):\r\n    \"\"\"Encode a pair of input, output tensor into a tf.train.Example.\"\"\"\r\n    example = tf.train.Example(\r\n        features=tf.train.Features(\r\n            feature={\r\n                'input': tf.train.Feature(\r\n                    int64_list=tf.train.Int64List(\r\n                        value=input_)),\r\n                'output': tf.train.Feature(\r\n                    int64_list=tf.train.Int64List(\r\n                        value=output))}))\r\n    return example\r\n\r\n\r\ndef decode(example):\r\n    \"\"\"Decode an example into a tuple of input, output tensors.\"\"\"\r\n    features = {\r\n        'input': tf.VarLenFeature(tf.int64),\r\n        'output': tf.VarLenFeature(tf.int64)\r\n    }\r\n    parsed = tf.parse_single_example(\r\n        serialized=example,\r\n        features=features)\r\n    input_ = parsed['input']\r\n    output = parsed['output']\r\n    input_ = tf.sparse_tensor_to_dense(parsed['input'])\r\n    output = tf.sparse_tensor_to_dense(parsed['output'])\r\n    return input_, output\r\n\r\n\r\ndef main():\r\n    \"\"\"Run the example.\"\"\"\r\n\r\n    # 1. decode the records from the file.\r\n    file_queue = tf.train.string_input_producer(\r\n        [PATH], shuffle=True, num_epochs=2)\r\n    reader = tf.TFRecordReader()\r\n    key, value = reader.read(file_queue)\r\n    input_, output = decode(value)\r\n\r\n    # 2. padding queue.\r\n    padding_queue = tf.PaddingFIFOQueue(\r\n        capacity=CAPACITY,\r\n        dtypes=[tf.string, tf.int64, tf.int64],\r\n        shapes=[[], [None], [None]])\r\n    padding_enqueue_op = padding_queue.enqueue([key, input_, output])\r\n    padding_queue_runner = tf.train.QueueRunner(\r\n        padding_queue, [padding_enqueue_op] * NUM_THREADS)\r\n    tf.train.add_queue_runner(padding_queue_runner)\r\n    padding_dequeue_op = padding_queue.dequeue_up_to(BATCH_SIZE)\r\n\r\n    # 3. shuffling queue that tolerates different shapes.\r\n    shuffle_queue = tf.RandomShuffleQueue(\r\n        capacity=CAPACITY,\r\n        min_after_dequeue=MIN_AFTER_DEQUEUE,\r\n        dtypes=[tf.string, tf.int64, tf.int64],\r\n        shapes=None)\r\n    shuffle_enqueue_op = shuffle_queue.enqueue(padding_dequeue_op)\r\n    shuffle_queue_runner = tf.train.QueueRunner(\r\n        shuffle_queue, [shuffle_enqueue_op] * NUM_THREADS)\r\n    tf.train.add_queue_runner(shuffle_queue_runner)\r\n    shuffle_dequeue_op = shuffle_queue.dequeue()\r\n    fetches = shuffle_dequeue_op\r\n\r\n    # 4. run.\r\n    with tf.Session() as sess:\r\n        sess.run(tf.local_variables_initializer())\r\n        sess.run(tf.global_variables_initializer())\r\n        coord = tf.train.Coordinator()\r\n        threads = tf.train.start_queue_runners(coord=coord)\r\n        try:\r\n            while True:\r\n                keys, inputs, outputs = tuple(sess.run(fetches))\r\n                for k, i in zip(keys, inputs):\r\n                    print(k + ': ' + str(i))\r\n                print(inputs.shape)\r\n                print\r\n        except tf.errors.OutOfRangeError as ex:\r\n            coord.request_stop(ex=ex)\r\n        finally:\r\n            coord.request_stop()\r\n            coord.join(threads)\r\n    print(' -- done -- ')\r\n\r\n\r\nif __name__ == '__main__':\r\n    # Before running the example, generate a bunch of examples\r\n    # and save them in a file as TFRecords.\r\n    with tf.python_io.TFRecordWriter(PATH) as writer:\r\n        for _ in xrange(NUM_EXAMPLES):\r\n            ii, oo = generate_example()\r\n            example = encode(ii, oo)\r\n            writer.write(example.SerializeToString())\r\n    main()\r\n```"}