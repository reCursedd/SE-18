{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2314", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2314/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2314/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2314/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/2314", "id": 154095822, "node_id": "MDU6SXNzdWUxNTQwOTU4MjI=", "number": 2314, "title": "SparseApply* operators for the GPU", "user": {"login": "stephenroller", "id": 31896, "node_id": "MDQ6VXNlcjMxODk2", "avatar_url": "https://avatars2.githubusercontent.com/u/31896?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stephenroller", "html_url": "https://github.com/stephenroller", "followers_url": "https://api.github.com/users/stephenroller/followers", "following_url": "https://api.github.com/users/stephenroller/following{/other_user}", "gists_url": "https://api.github.com/users/stephenroller/gists{/gist_id}", "starred_url": "https://api.github.com/users/stephenroller/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stephenroller/subscriptions", "organizations_url": "https://api.github.com/users/stephenroller/orgs", "repos_url": "https://api.github.com/users/stephenroller/repos", "events_url": "https://api.github.com/users/stephenroller/events{/privacy}", "received_events_url": "https://api.github.com/users/stephenroller/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 299643928, "node_id": "MDU6TGFiZWwyOTk2NDM5Mjg=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:contributions%20welcome", "name": "stat:contributions welcome", "color": "f4b400", "default": false}, {"id": 473173272, "node_id": "MDU6TGFiZWw0NzMxNzMyNzI=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:feature", "name": "type:feature", "color": "159b2e", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 10, "created_at": "2016-05-10T20:12:28Z", "updated_at": "2017-06-16T21:11:08Z", "closed_at": "2017-06-16T17:45:59Z", "author_association": "CONTRIBUTOR", "body_html": "<p>At the moment, it appears that only GradientDescentOptimizer supports running on the GPU when there is a SparseTensor update. This is particularly relevant for any RNNs which train their embeddings, including the word2vec example (yes w2v isn't an RNN ;)</p>\n<p>So far the common workaround everyone seems to use is to force the embedding variables to be on the CPU, but there can be <em>substantial</em> speed improvements by allowing them to be stored on the GPU. For one, there is no need to transfer the vectors of embeddings to/from the GPU, and instead one can just transfer the embedding indexes, and then the gradients also don't need to be transferred backwards. In one test I've run where I implemented a version on the GPU, the difference in one epoch was roughly 1100s vs 300s. Basically anyone who doesn't freeze their embeddings can substantially benefit from this.</p>\n<p>This is related to <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"136826370\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/tensorflow/tensorflow/issues/1310\" data-hovercard-type=\"issue\" data-hovercard-url=\"/tensorflow/tensorflow/issues/1310/hovercard\" href=\"https://github.com/tensorflow/tensorflow/issues/1310\">#1310</a> and <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"121453300\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/tensorflow/tensorflow/issues/464\" data-hovercard-type=\"issue\" data-hovercard-url=\"/tensorflow/tensorflow/issues/464/hovercard\" href=\"https://github.com/tensorflow/tensorflow/issues/464\">#464</a>. In <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"136826370\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/tensorflow/tensorflow/issues/1310\" data-hovercard-type=\"issue\" data-hovercard-url=\"/tensorflow/tensorflow/issues/1310/hovercard\" href=\"https://github.com/tensorflow/tensorflow/issues/1310\">#1310</a>, there is a bug where variables are placed on the GPU, even though an op that appears later isn't available on the GPU. My understanding is a fix for this is under development, but it will only make sure variables are placed on devices which can perform the necessary ops. It will not actually include SparseApply's. This feature request would resolve the OP's reported bug in <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"136826370\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/tensorflow/tensorflow/issues/1310\" data-hovercard-type=\"issue\" data-hovercard-url=\"/tensorflow/tensorflow/issues/1310/hovercard\" href=\"https://github.com/tensorflow/tensorflow/issues/1310\">#1310</a>, but not solve the variable-operator placement issue.</p>\n<p>In <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"121453300\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/tensorflow/tensorflow/issues/464\" data-hovercard-type=\"issue\" data-hovercard-url=\"/tensorflow/tensorflow/issues/464/hovercard\" href=\"https://github.com/tensorflow/tensorflow/issues/464\">#464</a>, the issue is that no one has implemented any <code>SparseApplyRMSProp</code>, along with another bug that has since been resolved. The issue used to contain all optimizers except GDO, but since then SparseApply ops have been added for AdaGrad, yet they're currently only implemented for the CPU, not the GPU. This feature request is a rough superset of <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"121453300\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/tensorflow/tensorflow/issues/464\" data-hovercard-type=\"issue\" data-hovercard-url=\"/tensorflow/tensorflow/issues/464/hovercard\" href=\"https://github.com/tensorflow/tensorflow/issues/464\">#464</a>.</p>\n<p>One thing that is presently unclear to me, is whether these really need to be implemented as C++ operators, with all the associated book keeping. Currently that is how the CPU version of the SparseApply*'s are updated (see <a href=\"https://github.com/tensorflow/tensorflow/blob/5681406e2874a02835d34be579810a93ad74a473/tensorflow/core/kernels/training_ops.cc#L1101\">example</a>), except for <a href=\"https://github.com/tensorflow/tensorflow/blob/5681406e2874a02835d34be579810a93ad74a473/tensorflow/python/training/gradient_descent.py#L54\">GradientDescent</a>. Its <code>_sparse_apply</code> is implemented in python and uses <code>scatter_sub</code>.</p>\n<p>I already have a Python implementation of <code>_sparse_apply</code> for <code>MomentumOptimizer</code>, which uses <code>tf.gather</code>, <code>tf.scatter_update</code>, and <code>tf.scatter_sub</code>. It passes unit tests, and performs on both CPU and the GPU, though it does take about a 1% performance hit compared to the current CPU C++ <code>SparseApplyMomentum</code>. Would this be of interest, or is there a motivation behind implementing this in C++?</p>", "body_text": "At the moment, it appears that only GradientDescentOptimizer supports running on the GPU when there is a SparseTensor update. This is particularly relevant for any RNNs which train their embeddings, including the word2vec example (yes w2v isn't an RNN ;)\nSo far the common workaround everyone seems to use is to force the embedding variables to be on the CPU, but there can be substantial speed improvements by allowing them to be stored on the GPU. For one, there is no need to transfer the vectors of embeddings to/from the GPU, and instead one can just transfer the embedding indexes, and then the gradients also don't need to be transferred backwards. In one test I've run where I implemented a version on the GPU, the difference in one epoch was roughly 1100s vs 300s. Basically anyone who doesn't freeze their embeddings can substantially benefit from this.\nThis is related to #1310 and #464. In #1310, there is a bug where variables are placed on the GPU, even though an op that appears later isn't available on the GPU. My understanding is a fix for this is under development, but it will only make sure variables are placed on devices which can perform the necessary ops. It will not actually include SparseApply's. This feature request would resolve the OP's reported bug in #1310, but not solve the variable-operator placement issue.\nIn #464, the issue is that no one has implemented any SparseApplyRMSProp, along with another bug that has since been resolved. The issue used to contain all optimizers except GDO, but since then SparseApply ops have been added for AdaGrad, yet they're currently only implemented for the CPU, not the GPU. This feature request is a rough superset of #464.\nOne thing that is presently unclear to me, is whether these really need to be implemented as C++ operators, with all the associated book keeping. Currently that is how the CPU version of the SparseApply*'s are updated (see example), except for GradientDescent. Its _sparse_apply is implemented in python and uses scatter_sub.\nI already have a Python implementation of _sparse_apply for MomentumOptimizer, which uses tf.gather, tf.scatter_update, and tf.scatter_sub. It passes unit tests, and performs on both CPU and the GPU, though it does take about a 1% performance hit compared to the current CPU C++ SparseApplyMomentum. Would this be of interest, or is there a motivation behind implementing this in C++?", "body": "At the moment, it appears that only GradientDescentOptimizer supports running on the GPU when there is a SparseTensor update. This is particularly relevant for any RNNs which train their embeddings, including the word2vec example (yes w2v isn't an RNN ;)\n\nSo far the common workaround everyone seems to use is to force the embedding variables to be on the CPU, but there can be _substantial_ speed improvements by allowing them to be stored on the GPU. For one, there is no need to transfer the vectors of embeddings to/from the GPU, and instead one can just transfer the embedding indexes, and then the gradients also don't need to be transferred backwards. In one test I've run where I implemented a version on the GPU, the difference in one epoch was roughly 1100s vs 300s. Basically anyone who doesn't freeze their embeddings can substantially benefit from this.\n\nThis is related to #1310 and #464. In #1310, there is a bug where variables are placed on the GPU, even though an op that appears later isn't available on the GPU. My understanding is a fix for this is under development, but it will only make sure variables are placed on devices which can perform the necessary ops. It will not actually include SparseApply's. This feature request would resolve the OP's reported bug in #1310, but not solve the variable-operator placement issue.\n\nIn #464, the issue is that no one has implemented any `SparseApplyRMSProp`, along with another bug that has since been resolved. The issue used to contain all optimizers except GDO, but since then SparseApply ops have been added for AdaGrad, yet they're currently only implemented for the CPU, not the GPU. This feature request is a rough superset of #464.\n\nOne thing that is presently unclear to me, is whether these really need to be implemented as C++ operators, with all the associated book keeping. Currently that is how the CPU version of the SparseApply*'s are updated (see [example](https://github.com/tensorflow/tensorflow/blob/5681406e2874a02835d34be579810a93ad74a473/tensorflow/core/kernels/training_ops.cc#L1101)), except for [GradientDescent](https://github.com/tensorflow/tensorflow/blob/5681406e2874a02835d34be579810a93ad74a473/tensorflow/python/training/gradient_descent.py#L54). Its `_sparse_apply` is implemented in python and uses `scatter_sub`.\n\nI already have a Python implementation of `_sparse_apply` for `MomentumOptimizer`, which uses `tf.gather`, `tf.scatter_update`, and `tf.scatter_sub`. It passes unit tests, and performs on both CPU and the GPU, though it does take about a 1% performance hit compared to the current CPU C++ `SparseApplyMomentum`. Would this be of interest, or is there a motivation behind implementing this in C++?\n"}