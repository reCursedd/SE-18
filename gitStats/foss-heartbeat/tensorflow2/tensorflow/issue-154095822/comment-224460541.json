{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/224460541", "html_url": "https://github.com/tensorflow/tensorflow/issues/2314#issuecomment-224460541", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2314", "id": 224460541, "node_id": "MDEyOklzc3VlQ29tbWVudDIyNDQ2MDU0MQ==", "user": {"login": "vrv", "id": 463737, "node_id": "MDQ6VXNlcjQ2MzczNw==", "avatar_url": "https://avatars0.githubusercontent.com/u/463737?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vrv", "html_url": "https://github.com/vrv", "followers_url": "https://api.github.com/users/vrv/followers", "following_url": "https://api.github.com/users/vrv/following{/other_user}", "gists_url": "https://api.github.com/users/vrv/gists{/gist_id}", "starred_url": "https://api.github.com/users/vrv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vrv/subscriptions", "organizations_url": "https://api.github.com/users/vrv/orgs", "repos_url": "https://api.github.com/users/vrv/repos", "events_url": "https://api.github.com/users/vrv/events{/privacy}", "received_events_url": "https://api.github.com/users/vrv/received_events", "type": "User", "site_admin": false}, "created_at": "2016-06-08T01:14:36Z", "updated_at": "2016-06-08T01:14:36Z", "author_association": "CONTRIBUTOR", "body_html": "<p>IIRC, the reason for implementing all of these as C++ ops is due to race conditions between read/compute/update.  If you implement these as separate ops, the time between computing the various compositions of the update rule is much higher than if it is implemented in a single op.  We found this caused problems for multi-replica models due to racy updates, which is why I think most of these ops are fused.  So I'd be a bit concerned about adding the composite op version without sufficient testing.</p>\n<p>And no, I can't think of an easy way right now to do this, since we don't have a good rewrite infrastructure that's device dependent.</p>", "body_text": "IIRC, the reason for implementing all of these as C++ ops is due to race conditions between read/compute/update.  If you implement these as separate ops, the time between computing the various compositions of the update rule is much higher than if it is implemented in a single op.  We found this caused problems for multi-replica models due to racy updates, which is why I think most of these ops are fused.  So I'd be a bit concerned about adding the composite op version without sufficient testing.\nAnd no, I can't think of an easy way right now to do this, since we don't have a good rewrite infrastructure that's device dependent.", "body": "IIRC, the reason for implementing all of these as C++ ops is due to race conditions between read/compute/update.  If you implement these as separate ops, the time between computing the various compositions of the update rule is much higher than if it is implemented in a single op.  We found this caused problems for multi-replica models due to racy updates, which is why I think most of these ops are fused.  So I'd be a bit concerned about adding the composite op version without sufficient testing.\n\nAnd no, I can't think of an easy way right now to do this, since we don't have a good rewrite infrastructure that's device dependent.\n"}