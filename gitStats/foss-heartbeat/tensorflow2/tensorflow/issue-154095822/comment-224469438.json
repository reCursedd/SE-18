{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/224469438", "html_url": "https://github.com/tensorflow/tensorflow/issues/2314#issuecomment-224469438", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/2314", "id": 224469438, "node_id": "MDEyOklzc3VlQ29tbWVudDIyNDQ2OTQzOA==", "user": {"login": "stephenroller", "id": 31896, "node_id": "MDQ6VXNlcjMxODk2", "avatar_url": "https://avatars2.githubusercontent.com/u/31896?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stephenroller", "html_url": "https://github.com/stephenroller", "followers_url": "https://api.github.com/users/stephenroller/followers", "following_url": "https://api.github.com/users/stephenroller/following{/other_user}", "gists_url": "https://api.github.com/users/stephenroller/gists{/gist_id}", "starred_url": "https://api.github.com/users/stephenroller/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stephenroller/subscriptions", "organizations_url": "https://api.github.com/users/stephenroller/orgs", "repos_url": "https://api.github.com/users/stephenroller/repos", "events_url": "https://api.github.com/users/stephenroller/events{/privacy}", "received_events_url": "https://api.github.com/users/stephenroller/received_events", "type": "User", "site_admin": false}, "created_at": "2016-06-08T02:16:41Z", "updated_at": "2016-06-08T02:16:41Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Yeah I didn't think about race conditions on multiple machines; that would be a problem. I also spent a few days trying to implement the operator in C++, but my C++ is relatively weak, I don't know CUDA at all. So that wasn't fruitful.</p>\n<p>A week later I was talking to a colleague about this and I noticed that my patch probably also computes updates incorrectly if the same embedding is updated multiple times. Rather than adding all the gradients together, then updating the momentum, and then updating each var exactly once, it would repeatedly update momentum and the variable. As far as I can tell, the current CPU SparseApplyMomentum operator probably has the same bug, but I haven't tested anything; it's just thought experiments.</p>\n<p>I also haven't looked at this in a few weeks, so I'd have to rebase the patch and make sure it's still fresh anyway. I'll do that as soon as I get a chance, sometime this week.</p>", "body_text": "Yeah I didn't think about race conditions on multiple machines; that would be a problem. I also spent a few days trying to implement the operator in C++, but my C++ is relatively weak, I don't know CUDA at all. So that wasn't fruitful.\nA week later I was talking to a colleague about this and I noticed that my patch probably also computes updates incorrectly if the same embedding is updated multiple times. Rather than adding all the gradients together, then updating the momentum, and then updating each var exactly once, it would repeatedly update momentum and the variable. As far as I can tell, the current CPU SparseApplyMomentum operator probably has the same bug, but I haven't tested anything; it's just thought experiments.\nI also haven't looked at this in a few weeks, so I'd have to rebase the patch and make sure it's still fresh anyway. I'll do that as soon as I get a chance, sometime this week.", "body": "Yeah I didn't think about race conditions on multiple machines; that would be a problem. I also spent a few days trying to implement the operator in C++, but my C++ is relatively weak, I don't know CUDA at all. So that wasn't fruitful.\n\nA week later I was talking to a colleague about this and I noticed that my patch probably also computes updates incorrectly if the same embedding is updated multiple times. Rather than adding all the gradients together, then updating the momentum, and then updating each var exactly once, it would repeatedly update momentum and the variable. As far as I can tell, the current CPU SparseApplyMomentum operator probably has the same bug, but I haven't tested anything; it's just thought experiments.\n\nI also haven't looked at this in a few weeks, so I'd have to rebase the patch and make sure it's still fresh anyway. I'll do that as soon as I get a chance, sometime this week.\n"}