{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/151439558", "pull_request_review_id": 77146911, "id": 151439558, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1MTQzOTU1OA==", "diff_hunk": "@@ -115,6 +115,57 @@ void RdmaMgr::SetupChannels() {\n   }\n }\n \n+// Check connectivity by pinging every channel\n+bool RdmaMgr::ConnectivityCheck() {\n+  int i, rcnt = 0, scnt = 0;\n+\n+  for (const auto& p : channel_table_) {\n+    string worker_name = p.first;\n+    RdmaChannel* rc = p.second;\n+\n+    VLOG(2) << \"Ping to \" << worker_name;\n+    CHECK(rc->PingPostSend() == 0) << \"Couldn't post send  to \" << worker_name\n+                                   << \" with error: \" << std::strerror(errno);\n+    for (i = 0; i < rc->adapter_->params_.queue_depth - 1; i++) {\n+      rc->Recv();\n+    }\n+  }\n+\n+  while (rcnt < num_remote_workers_ || scnt < num_remote_workers_) {\n+    int ne;\n+    do {\n+      ne = ibv_poll_cq(rdma_adapter_->cq_, 2 * num_remote_workers_,\n+                       rdma_adapter_->wc_);\n+      CHECK(ne >= 0) << \"poll CQ failed \" << ne << \"with error\"\n+                     << std::strerror(errno);\n+    } while (ne < 1);\n+\n+    for (i = 0; i < ne; ++i) {\n+      ibv_wc_status s = rdma_adapter_->wc_[i].status;\n+      // recv complete\n+      if ((int)rdma_adapter_->wc_[i].wr_id == RdmaChannel::PingRecvWrid) {\n+        CHECK(s == IBV_WC_SUCCESS) << \": \" << ibv_wc_status_str(\n+                                                  rdma_adapter_->wc_[i].status)\n+                                   << \"(\" << rdma_adapter_->wc_[i].status\n+                                   << \") for PING_RECV_WRID\";\n+        ++rcnt;\n+        // send complete\n+      } else {\n+        RdmaChannel* rc =\n+            reinterpret_cast<RdmaChannel*>(rdma_adapter_->wc_[i].wr_id);\n+        CHECK(s == IBV_WC_SUCCESS) << \": \" << ibv_wc_status_str(\n+                                                  rdma_adapter_->wc_[i].status)\n+                                   << \"(\" << rdma_adapter_->wc_[i].status\n+                                   << \") to \" << rc->remote_name_;\n+        ++scnt;\n+      }\n+    }  // for\n+  }    // while", "path": "tensorflow/contrib/verbs/rdma_mgr.cc", "position": 49, "original_position": 49, "commit_id": "d43d00be13ff271eb8a2e6a14eb7ac01a51934ff", "original_commit_id": "d6b267ac78fcb6a3250c24d466e8aa478c1fc783", "user": {"login": "dariavel", "id": 32033101, "node_id": "MDQ6VXNlcjMyMDMzMTAx", "avatar_url": "https://avatars3.githubusercontent.com/u/32033101?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dariavel", "html_url": "https://github.com/dariavel", "followers_url": "https://api.github.com/users/dariavel/followers", "following_url": "https://api.github.com/users/dariavel/following{/other_user}", "gists_url": "https://api.github.com/users/dariavel/gists{/gist_id}", "starred_url": "https://api.github.com/users/dariavel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dariavel/subscriptions", "organizations_url": "https://api.github.com/users/dariavel/orgs", "repos_url": "https://api.github.com/users/dariavel/repos", "events_url": "https://api.github.com/users/dariavel/events{/privacy}", "received_events_url": "https://api.github.com/users/dariavel/received_events", "type": "User", "site_admin": false}, "body": "If the remote node is down we will get an error earlier in channel creation or when sending ping. \r\nThe only option for the loop to hang is when the remote node failes between receiving ping to sending reply.\r\nIn this case we will successfully send the ping to remote, it will receive it and go down for some reason before sending reply so we'll be polling the completion queue forever, similar to the case when remote node goes down after connectivity check and we are stuck in the while(true) [here](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/verbs/rdma.cc#L443).", "created_at": "2017-11-16T15:09:25Z", "updated_at": "2017-11-16T15:16:33Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/14290#discussion_r151439558", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/14290", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/151439558"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/14290#discussion_r151439558"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/14290"}}, "body_html": "<p>If the remote node is down we will get an error earlier in channel creation or when sending ping.<br>\nThe only option for the loop to hang is when the remote node failes between receiving ping to sending reply.<br>\nIn this case we will successfully send the ping to remote, it will receive it and go down for some reason before sending reply so we'll be polling the completion queue forever, similar to the case when remote node goes down after connectivity check and we are stuck in the while(true) <a href=\"https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/verbs/rdma.cc#L443\">here</a>.</p>", "body_text": "If the remote node is down we will get an error earlier in channel creation or when sending ping.\nThe only option for the loop to hang is when the remote node failes between receiving ping to sending reply.\nIn this case we will successfully send the ping to remote, it will receive it and go down for some reason before sending reply so we'll be polling the completion queue forever, similar to the case when remote node goes down after connectivity check and we are stuck in the while(true) here.", "in_reply_to_id": 151311193}