{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/360549857", "html_url": "https://github.com/tensorflow/tensorflow/issues/12065#issuecomment-360549857", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/12065", "id": 360549857, "node_id": "MDEyOklzc3VlQ29tbWVudDM2MDU0OTg1Nw==", "user": {"login": "RylanSchaeffer", "id": 8942987, "node_id": "MDQ6VXNlcjg5NDI5ODc=", "avatar_url": "https://avatars3.githubusercontent.com/u/8942987?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RylanSchaeffer", "html_url": "https://github.com/RylanSchaeffer", "followers_url": "https://api.github.com/users/RylanSchaeffer/followers", "following_url": "https://api.github.com/users/RylanSchaeffer/following{/other_user}", "gists_url": "https://api.github.com/users/RylanSchaeffer/gists{/gist_id}", "starred_url": "https://api.github.com/users/RylanSchaeffer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RylanSchaeffer/subscriptions", "organizations_url": "https://api.github.com/users/RylanSchaeffer/orgs", "repos_url": "https://api.github.com/users/RylanSchaeffer/repos", "events_url": "https://api.github.com/users/RylanSchaeffer/events{/privacy}", "received_events_url": "https://api.github.com/users/RylanSchaeffer/received_events", "type": "User", "site_admin": false}, "created_at": "2018-01-25T18:05:21Z", "updated_at": "2018-01-25T18:08:27Z", "author_association": "NONE", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=1088232\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/adarob\">@adarob</a> that would be helpful, but I was referring to something slightly different. I haven't looked at this in 5+ months, so maybe the module has changed, but my understanding is that the sample_fn is used to collapse the rnn cell's output tensor into a single number (either deterministically or stochastically), which is then reconstituted as an input tensor for the next step. This is useful if I want the input tensor to represent a discrete input e.g. a word, but in the context that I was using the library, I wanted the output tensor to be passed to the next step unchanged.</p>\n<p>For concreteness, my understanding of the current implementation is like this:<br>\noutput at time T is [0.5, 0.1, 0.1, 0.1] =&gt; 0th element is sampled =&gt; [1., 0., 0., 0.] is passed to time step T+1</p>\n<p>My desired behavior:<br>\noutput at time T is  [0.5, 0.1, 0.1, 0.1]  =&gt;  [0.5, 0.1, 0.1, 0.1]  is passed to time step T+1</p>", "body_text": "@adarob that would be helpful, but I was referring to something slightly different. I haven't looked at this in 5+ months, so maybe the module has changed, but my understanding is that the sample_fn is used to collapse the rnn cell's output tensor into a single number (either deterministically or stochastically), which is then reconstituted as an input tensor for the next step. This is useful if I want the input tensor to represent a discrete input e.g. a word, but in the context that I was using the library, I wanted the output tensor to be passed to the next step unchanged.\nFor concreteness, my understanding of the current implementation is like this:\noutput at time T is [0.5, 0.1, 0.1, 0.1] => 0th element is sampled => [1., 0., 0., 0.] is passed to time step T+1\nMy desired behavior:\noutput at time T is  [0.5, 0.1, 0.1, 0.1]  =>  [0.5, 0.1, 0.1, 0.1]  is passed to time step T+1", "body": "@adarob that would be helpful, but I was referring to something slightly different. I haven't looked at this in 5+ months, so maybe the module has changed, but my understanding is that the sample_fn is used to collapse the rnn cell's output tensor into a single number (either deterministically or stochastically), which is then reconstituted as an input tensor for the next step. This is useful if I want the input tensor to represent a discrete input e.g. a word, but in the context that I was using the library, I wanted the output tensor to be passed to the next step unchanged.\r\n\r\nFor concreteness, my understanding of the current implementation is like this:\r\noutput at time T is [0.5, 0.1, 0.1, 0.1] => 0th element is sampled => [1., 0., 0., 0.] is passed to time step T+1\r\n\r\nMy desired behavior:\r\noutput at time T is  [0.5, 0.1, 0.1, 0.1]  =>  [0.5, 0.1, 0.1, 0.1]  is passed to time step T+1\r\n\r\n"}