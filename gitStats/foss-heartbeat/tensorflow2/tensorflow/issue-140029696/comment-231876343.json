{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/231876343", "html_url": "https://github.com/tensorflow/tensorflow/issues/1458#issuecomment-231876343", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/1458", "id": 231876343, "node_id": "MDEyOklzc3VlQ29tbWVudDIzMTg3NjM0Mw==", "user": {"login": "kingtaurus", "id": 2761482, "node_id": "MDQ6VXNlcjI3NjE0ODI=", "avatar_url": "https://avatars1.githubusercontent.com/u/2761482?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kingtaurus", "html_url": "https://github.com/kingtaurus", "followers_url": "https://api.github.com/users/kingtaurus/followers", "following_url": "https://api.github.com/users/kingtaurus/following{/other_user}", "gists_url": "https://api.github.com/users/kingtaurus/gists{/gist_id}", "starred_url": "https://api.github.com/users/kingtaurus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kingtaurus/subscriptions", "organizations_url": "https://api.github.com/users/kingtaurus/orgs", "repos_url": "https://api.github.com/users/kingtaurus/repos", "events_url": "https://api.github.com/users/kingtaurus/events{/privacy}", "received_events_url": "https://api.github.com/users/kingtaurus/received_events", "type": "User", "site_admin": false}, "created_at": "2016-07-11T21:49:26Z", "updated_at": "2016-07-11T21:50:18Z", "author_association": "CONTRIBUTOR", "body_html": "<p>I believe that the whitening should be different on a per image basis (one because there is saturation effects that adjusting the contrast and brightness may cross, two the adjustments for data augmentation should be on a per 'image' basis). Take for example (using numpy):</p>\n<pre><code>X_batch_sample = X_train[0:256]\nX_0 = (X_train[0:256] - np.mean(X_train[0:256], axis=0))/np.std(X_train[0:256],axis=0)\n#X_0 is the whitened 'images'\n\nshift_1 = 63 * np.random.normal(size=(256,1,1,1))\nX_0_shift1 = (X_train[0:256] + shift_1 - np.mean(X_train[0:256] + shift_1, axis=0)) / np.std(X_train[0:256] + shift_1, axis=0)\n#whitening the shifted case\nshift_2 = np.random.uniform(low=0.2, high=1.8, size=(256,1,1,3))\nX_0_shift2 = (X_train[0:256]*shift_2 - np.mean(X_train[0:256]*shift_2, axis=0)) / np.std(X_train[0:256]*shift_2, axis=0)\n\n#Let's look at only the first image:\nprint(np.mean(X_0[0] - X_0_shift1[0]))\n#This should be non-zero shift (because its the difference of two independent Gaussian processes)\nprint(np.mean(X_0[0] - X_0_shift2[0]))\n</code></pre>\n<p>EDIT: forgot a line of code;</p>", "body_text": "I believe that the whitening should be different on a per image basis (one because there is saturation effects that adjusting the contrast and brightness may cross, two the adjustments for data augmentation should be on a per 'image' basis). Take for example (using numpy):\nX_batch_sample = X_train[0:256]\nX_0 = (X_train[0:256] - np.mean(X_train[0:256], axis=0))/np.std(X_train[0:256],axis=0)\n#X_0 is the whitened 'images'\n\nshift_1 = 63 * np.random.normal(size=(256,1,1,1))\nX_0_shift1 = (X_train[0:256] + shift_1 - np.mean(X_train[0:256] + shift_1, axis=0)) / np.std(X_train[0:256] + shift_1, axis=0)\n#whitening the shifted case\nshift_2 = np.random.uniform(low=0.2, high=1.8, size=(256,1,1,3))\nX_0_shift2 = (X_train[0:256]*shift_2 - np.mean(X_train[0:256]*shift_2, axis=0)) / np.std(X_train[0:256]*shift_2, axis=0)\n\n#Let's look at only the first image:\nprint(np.mean(X_0[0] - X_0_shift1[0]))\n#This should be non-zero shift (because its the difference of two independent Gaussian processes)\nprint(np.mean(X_0[0] - X_0_shift2[0]))\n\nEDIT: forgot a line of code;", "body": "I believe that the whitening should be different on a per image basis (one because there is saturation effects that adjusting the contrast and brightness may cross, two the adjustments for data augmentation should be on a per 'image' basis). Take for example (using numpy):\n\n```\nX_batch_sample = X_train[0:256]\nX_0 = (X_train[0:256] - np.mean(X_train[0:256], axis=0))/np.std(X_train[0:256],axis=0)\n#X_0 is the whitened 'images'\n\nshift_1 = 63 * np.random.normal(size=(256,1,1,1))\nX_0_shift1 = (X_train[0:256] + shift_1 - np.mean(X_train[0:256] + shift_1, axis=0)) / np.std(X_train[0:256] + shift_1, axis=0)\n#whitening the shifted case\nshift_2 = np.random.uniform(low=0.2, high=1.8, size=(256,1,1,3))\nX_0_shift2 = (X_train[0:256]*shift_2 - np.mean(X_train[0:256]*shift_2, axis=0)) / np.std(X_train[0:256]*shift_2, axis=0)\n\n#Let's look at only the first image:\nprint(np.mean(X_0[0] - X_0_shift1[0]))\n#This should be non-zero shift (because its the difference of two independent Gaussian processes)\nprint(np.mean(X_0[0] - X_0_shift2[0]))\n```\n\nEDIT: forgot a line of code;\n"}