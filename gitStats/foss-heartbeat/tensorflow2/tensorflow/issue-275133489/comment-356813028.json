{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/comments/356813028", "html_url": "https://github.com/tensorflow/tensorflow/issues/14699#issuecomment-356813028", "issue_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/14699", "id": 356813028, "node_id": "MDEyOklzc3VlQ29tbWVudDM1NjgxMzAyOA==", "user": {"login": "Multihuntr", "id": 10515040, "node_id": "MDQ6VXNlcjEwNTE1MDQw", "avatar_url": "https://avatars2.githubusercontent.com/u/10515040?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Multihuntr", "html_url": "https://github.com/Multihuntr", "followers_url": "https://api.github.com/users/Multihuntr/followers", "following_url": "https://api.github.com/users/Multihuntr/following{/other_user}", "gists_url": "https://api.github.com/users/Multihuntr/gists{/gist_id}", "starred_url": "https://api.github.com/users/Multihuntr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Multihuntr/subscriptions", "organizations_url": "https://api.github.com/users/Multihuntr/orgs", "repos_url": "https://api.github.com/users/Multihuntr/repos", "events_url": "https://api.github.com/users/Multihuntr/events{/privacy}", "received_events_url": "https://api.github.com/users/Multihuntr/received_events", "type": "User", "site_admin": false}, "created_at": "2018-01-11T03:23:51Z", "updated_at": "2018-01-11T03:23:51Z", "author_association": "NONE", "body_html": "<p>I've played around with it a little more, and it turns out that this issue only occurs when the operation is actually created inside the cond. So this will work fine:</p>\n<pre><code>a_no_op = tf.no_op()\ndef myfunc():\n  tf.add_to_collection(tf.GraphKeys.UPDATE_OPS, a_no_op)\n  return 1\ntf.cond(tf.less(2,1), myfunc, lambda: 1)\n</code></pre>\n<p>But this will break everything:</p>\n<pre><code>def myfunc():\n  tf.add_to_collection(tf.GraphKeys.UPDATE_OPS, tf.no_op())\n  return 1\ntf.cond(tf.less(2,1), myfunc, lambda: 1)\n</code></pre>\n<p>This is because the operations defined outside the <code>myfunc</code> are always executed, regardless of the result of the condition. So, you CAN use batch norm with conditionals, you just have to define the branch containing the batch norm outside the <code>tf.cond</code>. However this means that that branch will always execute. This is definitely a workaround that will only work in some cases (e.g. it does not solve the OP's problem, as the assignment operation should only be executed once).</p>\n<p>I'll definitely avoid this, but the biggest problem I can see is that it's silent and extremely easy to accidentally cause (using batch norm in a conditional is perfectly reasonable). I wonder how many people have been stung by this and not even known that it was a bug within tensorflow itself.</p>\n<p>Is there some way we can make this bug more visible? Hotfix the docs for tf.cond or something?</p>", "body_text": "I've played around with it a little more, and it turns out that this issue only occurs when the operation is actually created inside the cond. So this will work fine:\na_no_op = tf.no_op()\ndef myfunc():\n  tf.add_to_collection(tf.GraphKeys.UPDATE_OPS, a_no_op)\n  return 1\ntf.cond(tf.less(2,1), myfunc, lambda: 1)\n\nBut this will break everything:\ndef myfunc():\n  tf.add_to_collection(tf.GraphKeys.UPDATE_OPS, tf.no_op())\n  return 1\ntf.cond(tf.less(2,1), myfunc, lambda: 1)\n\nThis is because the operations defined outside the myfunc are always executed, regardless of the result of the condition. So, you CAN use batch norm with conditionals, you just have to define the branch containing the batch norm outside the tf.cond. However this means that that branch will always execute. This is definitely a workaround that will only work in some cases (e.g. it does not solve the OP's problem, as the assignment operation should only be executed once).\nI'll definitely avoid this, but the biggest problem I can see is that it's silent and extremely easy to accidentally cause (using batch norm in a conditional is perfectly reasonable). I wonder how many people have been stung by this and not even known that it was a bug within tensorflow itself.\nIs there some way we can make this bug more visible? Hotfix the docs for tf.cond or something?", "body": "I've played around with it a little more, and it turns out that this issue only occurs when the operation is actually created inside the cond. So this will work fine:\r\n\r\n```\r\na_no_op = tf.no_op()\r\ndef myfunc():\r\n  tf.add_to_collection(tf.GraphKeys.UPDATE_OPS, a_no_op)\r\n  return 1\r\ntf.cond(tf.less(2,1), myfunc, lambda: 1)\r\n```\r\n\r\nBut this will break everything:\r\n\r\n```\r\ndef myfunc():\r\n  tf.add_to_collection(tf.GraphKeys.UPDATE_OPS, tf.no_op())\r\n  return 1\r\ntf.cond(tf.less(2,1), myfunc, lambda: 1)\r\n```\r\n\r\nThis is because the operations defined outside the `myfunc` are always executed, regardless of the result of the condition. So, you CAN use batch norm with conditionals, you just have to define the branch containing the batch norm outside the `tf.cond`. However this means that that branch will always execute. This is definitely a workaround that will only work in some cases (e.g. it does not solve the OP's problem, as the assignment operation should only be executed once).\r\n\r\nI'll definitely avoid this, but the biggest problem I can see is that it's silent and extremely easy to accidentally cause (using batch norm in a conditional is perfectly reasonable). I wonder how many people have been stung by this and not even known that it was a bug within tensorflow itself.\r\n\r\nIs there some way we can make this bug more visible? Hotfix the docs for tf.cond or something?"}