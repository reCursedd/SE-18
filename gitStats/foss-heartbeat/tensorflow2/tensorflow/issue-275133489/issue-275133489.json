{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/14699", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/14699/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/14699/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/14699/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/14699", "id": 275133489, "node_id": "MDU6SXNzdWUyNzUxMzM0ODk=", "number": 14699, "title": "A very strange bug with tf.cond, update_ops and global_step", "user": {"login": "x10000year", "id": 22427780, "node_id": "MDQ6VXNlcjIyNDI3Nzgw", "avatar_url": "https://avatars0.githubusercontent.com/u/22427780?v=4", "gravatar_id": "", "url": "https://api.github.com/users/x10000year", "html_url": "https://github.com/x10000year", "followers_url": "https://api.github.com/users/x10000year/followers", "following_url": "https://api.github.com/users/x10000year/following{/other_user}", "gists_url": "https://api.github.com/users/x10000year/gists{/gist_id}", "starred_url": "https://api.github.com/users/x10000year/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/x10000year/subscriptions", "organizations_url": "https://api.github.com/users/x10000year/orgs", "repos_url": "https://api.github.com/users/x10000year/repos", "events_url": "https://api.github.com/users/x10000year/events{/privacy}", "received_events_url": "https://api.github.com/users/x10000year/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 404586594, "node_id": "MDU6TGFiZWw0MDQ1ODY1OTQ=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:awaiting%20tensorflower", "name": "stat:awaiting tensorflower", "color": "f4b400", "default": false}], "state": "open", "locked": false, "assignee": {"login": "skye", "id": 88808, "node_id": "MDQ6VXNlcjg4ODA4", "avatar_url": "https://avatars1.githubusercontent.com/u/88808?v=4", "gravatar_id": "", "url": "https://api.github.com/users/skye", "html_url": "https://github.com/skye", "followers_url": "https://api.github.com/users/skye/followers", "following_url": "https://api.github.com/users/skye/following{/other_user}", "gists_url": "https://api.github.com/users/skye/gists{/gist_id}", "starred_url": "https://api.github.com/users/skye/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/skye/subscriptions", "organizations_url": "https://api.github.com/users/skye/orgs", "repos_url": "https://api.github.com/users/skye/repos", "events_url": "https://api.github.com/users/skye/events{/privacy}", "received_events_url": "https://api.github.com/users/skye/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "skye", "id": 88808, "node_id": "MDQ6VXNlcjg4ODA4", "avatar_url": "https://avatars1.githubusercontent.com/u/88808?v=4", "gravatar_id": "", "url": "https://api.github.com/users/skye", "html_url": "https://github.com/skye", "followers_url": "https://api.github.com/users/skye/followers", "following_url": "https://api.github.com/users/skye/following{/other_user}", "gists_url": "https://api.github.com/users/skye/gists{/gist_id}", "starred_url": "https://api.github.com/users/skye/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/skye/subscriptions", "organizations_url": "https://api.github.com/users/skye/orgs", "repos_url": "https://api.github.com/users/skye/repos", "events_url": "https://api.github.com/users/skye/events{/privacy}", "received_events_url": "https://api.github.com/users/skye/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 10, "created_at": "2017-11-19T05:21:59Z", "updated_at": "2018-11-21T18:59:17Z", "closed_at": null, "author_association": "NONE", "body_html": "<p>I'm using tf.Estimator with custom model_fn. When training, the estimator usually outputs log like:</p>\n<p>INFO:tensorflow:loss = 1109.14, step = 1<br>\nINFO:tensorflow:loss = 937.876, step = 101 (6.245 sec)<br>\nINFO:tensorflow:loss = 632.192, step = 201 (6.195 sec)</p>\n<p>By default, the printed steps should be 1, 101, 201... However, when I use the following function (which is simplified to reproduce the bug) in any place of the model:</p>\n<pre><code>def my_op(inputs, name=None):\n  with tf.variable_scope(name, default_name='my_scope', reuse=False):\n    count = tf.get_variable('count', shape=[],\n      initializer=tf.zeros_initializer(), trainable=False)\n\n    def myfunc1():\n      return 1\n\n    def myfunc2():\n      tf.add_to_collection(tf.GraphKeys.UPDATE_OPS, count.assign_add(10.0))\n      return 1\n\n    tf.cond(tf.less(1, 2), myfunc1, myfunc2)\n    return inputs\n\n</code></pre>\n<p>The log becomes something like:</p>\n<p>INFO:tensorflow:loss = 1130.58, step = 0<br>\nINFO:tensorflow:loss = 940.298, step = 0 (6.352 sec)</p>\n<p>The global step is always 0. After some tests, I found that the global step is not updated if myfunc2 is not executed. For example, if I write<br>\n<code>    tf.cond(tf.less(count, 2), myfunc1, myfunc2)</code><br>\nthen the global step is always 1.</p>\n<p>I suspect that this is caused by the tf.add_to_collection(tf.GraphKeys.UPDATE_OPS, ...) in myfunc2, in which my intend is to update a variable when some condition holds. Maybe op created inside tf.cond can not be used as a dependency outside, but no error message is reported.</p>\n<p>If I cannot add ops to UPDATE_OPS inside tf.cond, does this imply that stateful operations (like tf.layers.batch_normalization) can not be used inside tf.cond? So I cannot dynamically choose a network module from a set of network modules to execute if the network modules use any stateful operations like tf.layers.batch_normalization?</p>\n<p>my tensorflow version: ('v1.4.0-rc0-10-g756a7fc', '1.4.0-rc1')</p>", "body_text": "I'm using tf.Estimator with custom model_fn. When training, the estimator usually outputs log like:\nINFO:tensorflow:loss = 1109.14, step = 1\nINFO:tensorflow:loss = 937.876, step = 101 (6.245 sec)\nINFO:tensorflow:loss = 632.192, step = 201 (6.195 sec)\nBy default, the printed steps should be 1, 101, 201... However, when I use the following function (which is simplified to reproduce the bug) in any place of the model:\ndef my_op(inputs, name=None):\n  with tf.variable_scope(name, default_name='my_scope', reuse=False):\n    count = tf.get_variable('count', shape=[],\n      initializer=tf.zeros_initializer(), trainable=False)\n\n    def myfunc1():\n      return 1\n\n    def myfunc2():\n      tf.add_to_collection(tf.GraphKeys.UPDATE_OPS, count.assign_add(10.0))\n      return 1\n\n    tf.cond(tf.less(1, 2), myfunc1, myfunc2)\n    return inputs\n\n\nThe log becomes something like:\nINFO:tensorflow:loss = 1130.58, step = 0\nINFO:tensorflow:loss = 940.298, step = 0 (6.352 sec)\nThe global step is always 0. After some tests, I found that the global step is not updated if myfunc2 is not executed. For example, if I write\n    tf.cond(tf.less(count, 2), myfunc1, myfunc2)\nthen the global step is always 1.\nI suspect that this is caused by the tf.add_to_collection(tf.GraphKeys.UPDATE_OPS, ...) in myfunc2, in which my intend is to update a variable when some condition holds. Maybe op created inside tf.cond can not be used as a dependency outside, but no error message is reported.\nIf I cannot add ops to UPDATE_OPS inside tf.cond, does this imply that stateful operations (like tf.layers.batch_normalization) can not be used inside tf.cond? So I cannot dynamically choose a network module from a set of network modules to execute if the network modules use any stateful operations like tf.layers.batch_normalization?\nmy tensorflow version: ('v1.4.0-rc0-10-g756a7fc', '1.4.0-rc1')", "body": "I'm using tf.Estimator with custom model_fn. When training, the estimator usually outputs log like:\r\n\r\nINFO:tensorflow:loss = 1109.14, step = 1\r\nINFO:tensorflow:loss = 937.876, step = 101 (6.245 sec)\r\nINFO:tensorflow:loss = 632.192, step = 201 (6.195 sec)\r\n\r\nBy default, the printed steps should be 1, 101, 201... However, when I use the following function (which is simplified to reproduce the bug) in any place of the model:\r\n\r\n```\r\ndef my_op(inputs, name=None):\r\n  with tf.variable_scope(name, default_name='my_scope', reuse=False):\r\n    count = tf.get_variable('count', shape=[],\r\n      initializer=tf.zeros_initializer(), trainable=False)\r\n\r\n    def myfunc1():\r\n      return 1\r\n\r\n    def myfunc2():\r\n      tf.add_to_collection(tf.GraphKeys.UPDATE_OPS, count.assign_add(10.0))\r\n      return 1\r\n\r\n    tf.cond(tf.less(1, 2), myfunc1, myfunc2)\r\n    return inputs\r\n\r\n```\r\n\r\nThe log becomes something like:\r\n\r\nINFO:tensorflow:loss = 1130.58, step = 0\r\nINFO:tensorflow:loss = 940.298, step = 0 (6.352 sec)\r\n\r\nThe global step is always 0. After some tests, I found that the global step is not updated if myfunc2 is not executed. For example, if I write\r\n`    tf.cond(tf.less(count, 2), myfunc1, myfunc2)`\r\nthen the global step is always 1.\r\n\r\nI suspect that this is caused by the tf.add_to_collection(tf.GraphKeys.UPDATE_OPS, ...) in myfunc2, in which my intend is to update a variable when some condition holds. Maybe op created inside tf.cond can not be used as a dependency outside, but no error message is reported.\r\n\r\nIf I cannot add ops to UPDATE_OPS inside tf.cond, does this imply that stateful operations (like tf.layers.batch_normalization) can not be used inside tf.cond? So I cannot dynamically choose a network module from a set of network modules to execute if the network modules use any stateful operations like tf.layers.batch_normalization?\r\n\r\nmy tensorflow version: ('v1.4.0-rc0-10-g756a7fc', '1.4.0-rc1')"}