{"url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/106067852", "pull_request_review_id": 26973677, "id": 106067852, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwNjA2Nzg1Mg==", "diff_hunk": "@@ -430,34 +430,23 @@ module VZ {\n     }\n \n     private resmoothDataset(dataset: Plottable.Dataset) {\n-      // When increasing the smoothing window, it smoothes a lot with the first\n-      // few points and then starts to gradually smooth slower, so using an\n-      // exponential function makes the slider more consistent. 1000^x has a\n-      // range of [1, 1000], so subtracting 1 and dividing by 999 results in a\n-      // range of [0, 1], which can be used as the percentage of the data, so\n-      // that the kernel size can be specified as a percentage instead of a\n-      // hardcoded number, what would be bad with multiple series.\n-      let factor = (Math.pow(1000, this.smoothingWeight) - 1) / 999;\n-      let data = dataset.data();\n-      let kernelRadius = Math.floor(data.length * factor / 2);\n-\n-      data.forEach((d, i) => {\n-        let actualKernelRadius = Math.min(kernelRadius, i);\n-        let start = i - actualKernelRadius;\n-        let end = i + actualKernelRadius + 1;\n-        if (end >= data.length) {\n-          // In the beginning, it's OK for the smoothing window to be small,\n-          // but this is not desirable towards the end. Rather than shrinking\n-          // the window, or extrapolating data to fill the gap, we're simply\n-          // not going to display the smoothed line towards the end.\n-          d.smoothed = Infinity;\n-        } else if (!_.isFinite(d.scalar)) {\n-          // Only smooth finite numbers.\n+      var data = dataset.data();\n+      var smoothingWeight = this.smoothingWeight;\n+      data.forEach(function (d, i) {\n+        if (!_.isFinite(d.scalar)) {\n           d.smoothed = d.scalar;\n-        } else {\n-          d.smoothed = d3.mean(\n-              data.slice(start, end).filter((d) => _.isFinite(d.scalar)),\n-              (d) => d.scalar);\n+        }\n+        else if (i == 0) {\n+          d.smoothed = d.scalar;\n+        }\n+        else {\n+          var prev_index = i - 1;\n+          if (!_.isFinite(data[prev_index].smoothed)) {\n+            d.smoothed = d.scalar\n+          }\n+          else {\n+            d.smoothed = data[prev_index].smoothed * smoothingWeight + (1.0 - smoothingWeight) * d.scalar;\n+          }", "path": "tensorflow/tensorboard/components/vz_line_chart/vz-line-chart.ts", "position": null, "original_position": 47, "commit_id": "2c8513eb63c02e33fc1dad1e69e44af6df254090", "original_commit_id": "ed5cf572896a6ed9242e34642b3c8f67839d3f17", "user": {"login": "decentralion", "id": 1400023, "node_id": "MDQ6VXNlcjE0MDAwMjM=", "avatar_url": "https://avatars2.githubusercontent.com/u/1400023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/decentralion", "html_url": "https://github.com/decentralion", "followers_url": "https://api.github.com/users/decentralion/followers", "following_url": "https://api.github.com/users/decentralion/following{/other_user}", "gists_url": "https://api.github.com/users/decentralion/gists{/gist_id}", "starred_url": "https://api.github.com/users/decentralion/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/decentralion/subscriptions", "organizations_url": "https://api.github.com/users/decentralion/orgs", "repos_url": "https://api.github.com/users/decentralion/repos", "events_url": "https://api.github.com/users/decentralion/events{/privacy}", "received_events_url": "https://api.github.com/users/decentralion/received_events", "type": "User", "site_admin": false}, "body": "I think it is cleaner as:\r\n\r\n```\r\nlet last = data.length > 0 ? data[0].scalar : NaN;\r\ndata.forEach((d) => {\r\n  if (!_.isFinite(last)) {\r\n    d.smoothed = d.scalar;\r\n  } else {\r\n    d.smoothed = last * smoothingWeight + (1 - smoothingWeight) * d.scalar;\r\n  }\r\n\r\n  last = d.smoothed;\r\n}", "created_at": "2017-03-15T01:28:22Z", "updated_at": "2017-03-23T22:46:26Z", "html_url": "https://github.com/tensorflow/tensorflow/pull/8363#discussion_r106067852", "pull_request_url": "https://api.github.com/repos/tensorflow/tensorflow/pulls/8363", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/comments/106067852"}, "html": {"href": "https://github.com/tensorflow/tensorflow/pull/8363#discussion_r106067852"}, "pull_request": {"href": "https://api.github.com/repos/tensorflow/tensorflow/pulls/8363"}}, "body_html": "<p>I think it is cleaner as:</p>\n<pre><code>let last = data.length &gt; 0 ? data[0].scalar : NaN;\ndata.forEach((d) =&gt; {\n  if (!_.isFinite(last)) {\n    d.smoothed = d.scalar;\n  } else {\n    d.smoothed = last * smoothingWeight + (1 - smoothingWeight) * d.scalar;\n  }\n\n  last = d.smoothed;\n}\n</code></pre>", "body_text": "I think it is cleaner as:\nlet last = data.length > 0 ? data[0].scalar : NaN;\ndata.forEach((d) => {\n  if (!_.isFinite(last)) {\n    d.smoothed = d.scalar;\n  } else {\n    d.smoothed = last * smoothingWeight + (1 - smoothingWeight) * d.scalar;\n  }\n\n  last = d.smoothed;\n}"}