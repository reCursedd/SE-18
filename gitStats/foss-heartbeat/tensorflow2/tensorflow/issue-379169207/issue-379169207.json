{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/23632", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/23632/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/23632/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/23632/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/23632", "id": 379169207, "node_id": "MDU6SXNzdWUzNzkxNjkyMDc=", "number": 23632, "title": "Incorrect masking in keras.backend.rnn", "user": {"login": "andhus", "id": 5502349, "node_id": "MDQ6VXNlcjU1MDIzNDk=", "avatar_url": "https://avatars2.githubusercontent.com/u/5502349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/andhus", "html_url": "https://github.com/andhus", "followers_url": "https://api.github.com/users/andhus/followers", "following_url": "https://api.github.com/users/andhus/following{/other_user}", "gists_url": "https://api.github.com/users/andhus/gists{/gist_id}", "starred_url": "https://api.github.com/users/andhus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/andhus/subscriptions", "organizations_url": "https://api.github.com/users/andhus/orgs", "repos_url": "https://api.github.com/users/andhus/repos", "events_url": "https://api.github.com/users/andhus/events{/privacy}", "received_events_url": "https://api.github.com/users/andhus/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": {"login": "qlzh727", "id": 5118881, "node_id": "MDQ6VXNlcjUxMTg4ODE=", "avatar_url": "https://avatars3.githubusercontent.com/u/5118881?v=4", "gravatar_id": "", "url": "https://api.github.com/users/qlzh727", "html_url": "https://github.com/qlzh727", "followers_url": "https://api.github.com/users/qlzh727/followers", "following_url": "https://api.github.com/users/qlzh727/following{/other_user}", "gists_url": "https://api.github.com/users/qlzh727/gists{/gist_id}", "starred_url": "https://api.github.com/users/qlzh727/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/qlzh727/subscriptions", "organizations_url": "https://api.github.com/users/qlzh727/orgs", "repos_url": "https://api.github.com/users/qlzh727/repos", "events_url": "https://api.github.com/users/qlzh727/events{/privacy}", "received_events_url": "https://api.github.com/users/qlzh727/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "qlzh727", "id": 5118881, "node_id": "MDQ6VXNlcjUxMTg4ODE=", "avatar_url": "https://avatars3.githubusercontent.com/u/5118881?v=4", "gravatar_id": "", "url": "https://api.github.com/users/qlzh727", "html_url": "https://github.com/qlzh727", "followers_url": "https://api.github.com/users/qlzh727/followers", "following_url": "https://api.github.com/users/qlzh727/following{/other_user}", "gists_url": "https://api.github.com/users/qlzh727/gists{/gist_id}", "starred_url": "https://api.github.com/users/qlzh727/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/qlzh727/subscriptions", "organizations_url": "https://api.github.com/users/qlzh727/orgs", "repos_url": "https://api.github.com/users/qlzh727/repos", "events_url": "https://api.github.com/users/qlzh727/events{/privacy}", "received_events_url": "https://api.github.com/users/qlzh727/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 5, "created_at": "2018-11-09T13:50:04Z", "updated_at": "2018-11-21T16:41:07Z", "closed_at": "2018-11-21T16:41:07Z", "author_association": "CONTRIBUTOR", "body_html": "<p><strong>System information</strong></p>\n<pre><code>python -c \"import tensorflow as tf; print(tf.GIT_VERSION, tf.VERSION)\"\n('v1.12.0-rc0-2215-g6735dd4799', '1.13.0-dev20181109')\n</code></pre>\n<p><strong>Describe the current behavior</strong><br>\nFor correct masking of <code>output</code> it is required that <code>output == states[0]</code> for  <code>keras.backend.rnn(..., unroll=False)</code>, not so with <code>unroll=True</code> or in latest version of <a href=\"https://github.com/keras-team/keras\">keras-team/keras</a>. See <a href=\"https://github.com/tensorflow/tensorflow/blob/d703f64e452f49603a244978b13239ab7aac0168/tensorflow/python/keras/backend.py#L3496\">this line</a> for the reason.</p>\n<p><strong>Describe the expected behavior</strong><br>\nAs per this <a href=\"https://github.com/keras-team/keras/pull/11499\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/keras-team/keras/pull/11499/hovercard\">PR</a> (and discussions in linked issues) it has been established that output should be independent of states. That is, it should <em>not</em> be assumed that <code>output == states[0]</code> for <code>ouput, states = step_function(inputs, previous_states)</code> in the <code>keras.backend.rnn</code> implementation. For details see test below.</p>\n<p><strong>Code to reproduce the issue</strong><br>\nSee test below (basically same as <a href=\"https://github.com/keras-team/keras/pull/11499/files#diff-e942014d73bf67b47a3b55f7f7041797R829\">this test added keras-team/keras</a>)</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">import</span> numpy <span class=\"pl-k\">as</span> np\n<span class=\"pl-k\">from</span> tensorflow <span class=\"pl-k\">import</span> keras\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">test_rnn_output_and_state_masking_independent</span>():\n    num_samples <span class=\"pl-k\">=</span> <span class=\"pl-c1\">2</span>\n    num_timesteps <span class=\"pl-k\">=</span> <span class=\"pl-c1\">4</span>\n    state_and_io_size <span class=\"pl-k\">=</span> <span class=\"pl-c1\">5</span>\n    mask_last_num_timesteps <span class=\"pl-k\">=</span> <span class=\"pl-c1\">2</span>  <span class=\"pl-c\"><span class=\"pl-c\">#</span> for second sample only</span>\n\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> a step function that just outputs inputs,</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> but increments states +1 per timestep</span>\n    <span class=\"pl-k\">def</span> <span class=\"pl-en\">step_function</span>(<span class=\"pl-smi\">inputs</span>, <span class=\"pl-smi\">states</span>):\n        <span class=\"pl-k\">return</span> inputs, [s <span class=\"pl-k\">+</span> <span class=\"pl-c1\">1</span> <span class=\"pl-k\">for</span> s <span class=\"pl-k\">in</span> states]\n\n    inputs_vals <span class=\"pl-k\">=</span> np.random.random(\n        (num_samples, num_timesteps, state_and_io_size))\n    initial_state_vals <span class=\"pl-k\">=</span> np.random.random((num_samples, state_and_io_size))\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> masking of two last timesteps for second sample only</span>\n    mask_vals <span class=\"pl-k\">=</span> np.ones((num_samples, num_timesteps))\n    mask_vals[<span class=\"pl-c1\">1</span>, <span class=\"pl-k\">-</span>mask_last_num_timesteps:] <span class=\"pl-k\">=</span> <span class=\"pl-c1\">0</span>\n\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> outputs expected to be same as inputs for the first sample</span>\n    expected_outputs <span class=\"pl-k\">=</span> inputs_vals.copy()\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> but for the second sample all outputs in masked region should be the same</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> as last output before masked region</span>\n    expected_outputs[<span class=\"pl-c1\">1</span>, <span class=\"pl-k\">-</span>mask_last_num_timesteps:] <span class=\"pl-k\">=</span> \\\n        expected_outputs[<span class=\"pl-c1\">1</span>, <span class=\"pl-k\">-</span>(mask_last_num_timesteps <span class=\"pl-k\">+</span> <span class=\"pl-c1\">1</span>)]\n\n    expected_state <span class=\"pl-k\">=</span> initial_state_vals.copy()\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> first state should be incremented for every timestep (no masking)</span>\n    expected_state[<span class=\"pl-c1\">0</span>] <span class=\"pl-k\">+=</span> num_timesteps\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> second state should not be incremented for last two timesteps</span>\n    expected_state[<span class=\"pl-c1\">1</span>] <span class=\"pl-k\">+=</span> (num_timesteps <span class=\"pl-k\">-</span> mask_last_num_timesteps)\n\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> verify same expected output for `unroll=true/false`</span>\n    inputs <span class=\"pl-k\">=</span> keras.backend.variable(inputs_vals)\n    initial_states <span class=\"pl-k\">=</span> [keras.backend.variable(initial_state_vals)]\n    mask <span class=\"pl-k\">=</span> keras.backend.variable(mask_vals)\n    <span class=\"pl-k\">for</span> unroll <span class=\"pl-k\">in</span> [<span class=\"pl-c1\">True</span>, <span class=\"pl-c1\">False</span>]:\n        last_output, outputs, last_states <span class=\"pl-k\">=</span> keras.backend.rnn(\n            step_function,\n            inputs,\n            initial_states,\n            <span class=\"pl-v\">mask</span><span class=\"pl-k\">=</span>mask,\n            <span class=\"pl-v\">unroll</span><span class=\"pl-k\">=</span>unroll,\n            <span class=\"pl-v\">input_length</span><span class=\"pl-k\">=</span>num_timesteps <span class=\"pl-k\">if</span> unroll <span class=\"pl-k\">else</span> <span class=\"pl-c1\">None</span>)\n\n        np.testing.assert_allclose(\n            keras.backend.eval(outputs), expected_outputs,\n            <span class=\"pl-v\">err_msg</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Unexpected output for unroll=<span class=\"pl-c1\">{}</span><span class=\"pl-pds\">\"</span></span>.format(unroll))\n        np.testing.assert_allclose(\n            keras.backend.eval(last_states[<span class=\"pl-c1\">0</span>]), expected_state,\n            <span class=\"pl-v\">err_msg</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Unexpected state for unroll=<span class=\"pl-c1\">{}</span><span class=\"pl-pds\">\"</span></span>.format(unroll))</pre></div>\n<p>Gives:</p>\n<pre><code>AssertionError: \nNot equal to tolerance rtol=1e-07, atol=0\nUnexpected output for unroll=False\n(mismatch 25.0%)\n x: array([0.116687, 0.622734, 0.210443, 0.662715, 0.720813, 0.654062,\n       0.936728, 0.451018, 0.471044, 0.560336, 0.133492, 0.228378,\n       2.081284, 2.415464, 2.081284, 2.415464], dtype=float32)\n y: array([0.116687, 0.622734, 0.210443, 0.662715, 0.720813, 0.654062,\n       0.936728, 0.451018, 0.471044, 0.560336, 0.133492, 0.228378,\n       0.133492, 0.228378, 0.133492, 0.228378])\n</code></pre>\n<p><strong>Other info / logs</strong><br>\nThere are a few further implications of current implementation addressed by the tests added to keras-team/keras <a href=\"https://github.com/keras-team/keras/pull/11499/files#diff-e942014d73bf67b47a3b55f7f7041797R829\">here</a>)</p>", "body_text": "System information\npython -c \"import tensorflow as tf; print(tf.GIT_VERSION, tf.VERSION)\"\n('v1.12.0-rc0-2215-g6735dd4799', '1.13.0-dev20181109')\n\nDescribe the current behavior\nFor correct masking of output it is required that output == states[0] for  keras.backend.rnn(..., unroll=False), not so with unroll=True or in latest version of keras-team/keras. See this line for the reason.\nDescribe the expected behavior\nAs per this PR (and discussions in linked issues) it has been established that output should be independent of states. That is, it should not be assumed that output == states[0] for ouput, states = step_function(inputs, previous_states) in the keras.backend.rnn implementation. For details see test below.\nCode to reproduce the issue\nSee test below (basically same as this test added keras-team/keras)\nimport numpy as np\nfrom tensorflow import keras\n\ndef test_rnn_output_and_state_masking_independent():\n    num_samples = 2\n    num_timesteps = 4\n    state_and_io_size = 5\n    mask_last_num_timesteps = 2  # for second sample only\n\n    # a step function that just outputs inputs,\n    # but increments states +1 per timestep\n    def step_function(inputs, states):\n        return inputs, [s + 1 for s in states]\n\n    inputs_vals = np.random.random(\n        (num_samples, num_timesteps, state_and_io_size))\n    initial_state_vals = np.random.random((num_samples, state_and_io_size))\n    # masking of two last timesteps for second sample only\n    mask_vals = np.ones((num_samples, num_timesteps))\n    mask_vals[1, -mask_last_num_timesteps:] = 0\n\n    # outputs expected to be same as inputs for the first sample\n    expected_outputs = inputs_vals.copy()\n    # but for the second sample all outputs in masked region should be the same\n    # as last output before masked region\n    expected_outputs[1, -mask_last_num_timesteps:] = \\\n        expected_outputs[1, -(mask_last_num_timesteps + 1)]\n\n    expected_state = initial_state_vals.copy()\n    # first state should be incremented for every timestep (no masking)\n    expected_state[0] += num_timesteps\n    # second state should not be incremented for last two timesteps\n    expected_state[1] += (num_timesteps - mask_last_num_timesteps)\n\n    # verify same expected output for `unroll=true/false`\n    inputs = keras.backend.variable(inputs_vals)\n    initial_states = [keras.backend.variable(initial_state_vals)]\n    mask = keras.backend.variable(mask_vals)\n    for unroll in [True, False]:\n        last_output, outputs, last_states = keras.backend.rnn(\n            step_function,\n            inputs,\n            initial_states,\n            mask=mask,\n            unroll=unroll,\n            input_length=num_timesteps if unroll else None)\n\n        np.testing.assert_allclose(\n            keras.backend.eval(outputs), expected_outputs,\n            err_msg=\"Unexpected output for unroll={}\".format(unroll))\n        np.testing.assert_allclose(\n            keras.backend.eval(last_states[0]), expected_state,\n            err_msg=\"Unexpected state for unroll={}\".format(unroll))\nGives:\nAssertionError: \nNot equal to tolerance rtol=1e-07, atol=0\nUnexpected output for unroll=False\n(mismatch 25.0%)\n x: array([0.116687, 0.622734, 0.210443, 0.662715, 0.720813, 0.654062,\n       0.936728, 0.451018, 0.471044, 0.560336, 0.133492, 0.228378,\n       2.081284, 2.415464, 2.081284, 2.415464], dtype=float32)\n y: array([0.116687, 0.622734, 0.210443, 0.662715, 0.720813, 0.654062,\n       0.936728, 0.451018, 0.471044, 0.560336, 0.133492, 0.228378,\n       0.133492, 0.228378, 0.133492, 0.228378])\n\nOther info / logs\nThere are a few further implications of current implementation addressed by the tests added to keras-team/keras here)", "body": "**System information**\r\n```\r\npython -c \"import tensorflow as tf; print(tf.GIT_VERSION, tf.VERSION)\"\r\n('v1.12.0-rc0-2215-g6735dd4799', '1.13.0-dev20181109')\r\n```\r\n\r\n**Describe the current behavior**\r\nFor correct masking of `output` it is required that `output == states[0]` for  `keras.backend.rnn(..., unroll=False)`, not so with `unroll=True` or in latest version of [keras-team/keras](https://github.com/keras-team/keras). See [this line](https://github.com/tensorflow/tensorflow/blob/d703f64e452f49603a244978b13239ab7aac0168/tensorflow/python/keras/backend.py#L3496) for the reason.\r\n\r\n**Describe the expected behavior**\r\nAs per this [PR](https://github.com/keras-team/keras/pull/11499) (and discussions in linked issues) it has been established that output should be independent of states. That is, it should _not_ be assumed that `output == states[0]` for `ouput, states = step_function(inputs, previous_states)` in the `keras.backend.rnn` implementation. For details see test below.\r\n\r\n**Code to reproduce the issue**\r\nSee test below (basically same as [this test added keras-team/keras](https://github.com/keras-team/keras/pull/11499/files#diff-e942014d73bf67b47a3b55f7f7041797R829))\r\n\r\n```python\r\nimport numpy as np\r\nfrom tensorflow import keras\r\n\r\ndef test_rnn_output_and_state_masking_independent():\r\n    num_samples = 2\r\n    num_timesteps = 4\r\n    state_and_io_size = 5\r\n    mask_last_num_timesteps = 2  # for second sample only\r\n\r\n    # a step function that just outputs inputs,\r\n    # but increments states +1 per timestep\r\n    def step_function(inputs, states):\r\n        return inputs, [s + 1 for s in states]\r\n\r\n    inputs_vals = np.random.random(\r\n        (num_samples, num_timesteps, state_and_io_size))\r\n    initial_state_vals = np.random.random((num_samples, state_and_io_size))\r\n    # masking of two last timesteps for second sample only\r\n    mask_vals = np.ones((num_samples, num_timesteps))\r\n    mask_vals[1, -mask_last_num_timesteps:] = 0\r\n\r\n    # outputs expected to be same as inputs for the first sample\r\n    expected_outputs = inputs_vals.copy()\r\n    # but for the second sample all outputs in masked region should be the same\r\n    # as last output before masked region\r\n    expected_outputs[1, -mask_last_num_timesteps:] = \\\r\n        expected_outputs[1, -(mask_last_num_timesteps + 1)]\r\n\r\n    expected_state = initial_state_vals.copy()\r\n    # first state should be incremented for every timestep (no masking)\r\n    expected_state[0] += num_timesteps\r\n    # second state should not be incremented for last two timesteps\r\n    expected_state[1] += (num_timesteps - mask_last_num_timesteps)\r\n\r\n    # verify same expected output for `unroll=true/false`\r\n    inputs = keras.backend.variable(inputs_vals)\r\n    initial_states = [keras.backend.variable(initial_state_vals)]\r\n    mask = keras.backend.variable(mask_vals)\r\n    for unroll in [True, False]:\r\n        last_output, outputs, last_states = keras.backend.rnn(\r\n            step_function,\r\n            inputs,\r\n            initial_states,\r\n            mask=mask,\r\n            unroll=unroll,\r\n            input_length=num_timesteps if unroll else None)\r\n\r\n        np.testing.assert_allclose(\r\n            keras.backend.eval(outputs), expected_outputs,\r\n            err_msg=\"Unexpected output for unroll={}\".format(unroll))\r\n        np.testing.assert_allclose(\r\n            keras.backend.eval(last_states[0]), expected_state,\r\n            err_msg=\"Unexpected state for unroll={}\".format(unroll))\r\n```\r\nGives:\r\n```\r\nAssertionError: \r\nNot equal to tolerance rtol=1e-07, atol=0\r\nUnexpected output for unroll=False\r\n(mismatch 25.0%)\r\n x: array([0.116687, 0.622734, 0.210443, 0.662715, 0.720813, 0.654062,\r\n       0.936728, 0.451018, 0.471044, 0.560336, 0.133492, 0.228378,\r\n       2.081284, 2.415464, 2.081284, 2.415464], dtype=float32)\r\n y: array([0.116687, 0.622734, 0.210443, 0.662715, 0.720813, 0.654062,\r\n       0.936728, 0.451018, 0.471044, 0.560336, 0.133492, 0.228378,\r\n       0.133492, 0.228378, 0.133492, 0.228378])\r\n```\r\n**Other info / logs**\r\nThere are a few further implications of current implementation addressed by the tests added to keras-team/keras [here](https://github.com/keras-team/keras/pull/11499/files#diff-e942014d73bf67b47a3b55f7f7041797R829))"}