{"url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9292", "repository_url": "https://api.github.com/repos/tensorflow/tensorflow", "labels_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9292/labels{/name}", "comments_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9292/comments", "events_url": "https://api.github.com/repos/tensorflow/tensorflow/issues/9292/events", "html_url": "https://github.com/tensorflow/tensorflow/issues/9292", "id": 222504069, "node_id": "MDU6SXNzdWUyMjI1MDQwNjk=", "number": 9292, "title": "xorshift128+ version of (stateless) random ops", "user": {"login": "girving", "id": 70511, "node_id": "MDQ6VXNlcjcwNTEx", "avatar_url": "https://avatars1.githubusercontent.com/u/70511?v=4", "gravatar_id": "", "url": "https://api.github.com/users/girving", "html_url": "https://github.com/girving", "followers_url": "https://api.github.com/users/girving/followers", "following_url": "https://api.github.com/users/girving/following{/other_user}", "gists_url": "https://api.github.com/users/girving/gists{/gist_id}", "starred_url": "https://api.github.com/users/girving/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/girving/subscriptions", "organizations_url": "https://api.github.com/users/girving/orgs", "repos_url": "https://api.github.com/users/girving/repos", "events_url": "https://api.github.com/users/girving/events{/privacy}", "received_events_url": "https://api.github.com/users/girving/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 299643928, "node_id": "MDU6TGFiZWwyOTk2NDM5Mjg=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/stat:contributions%20welcome", "name": "stat:contributions welcome", "color": "f4b400", "default": false}, {"id": 473173272, "node_id": "MDU6TGFiZWw0NzMxNzMyNzI=", "url": "https://api.github.com/repos/tensorflow/tensorflow/labels/type:feature", "name": "type:feature", "color": "159b2e", "default": false}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2017-04-18T18:25:35Z", "updated_at": "2017-04-18T18:31:03Z", "closed_at": null, "author_association": "CONTRIBUTOR", "body_html": "<p>Currently, TensorFlow's random numbers use the Philox counter mode generator, which is extremely easy to parallelize on both CPU and GPU.  This applies to both the normal stateful ops and the new <a href=\"https://github.com/tensorflow/tensorflow/commit/cc45456e4ad0eff16127d1727d0cf48afb71ca0e\"><code>tf.contrib.stateless</code></a> versions with custom seeding.</p>\n<p>xorshift128+ is a simpler generator that could conceivably speed up random number generation.  Unfortunately, it is not a counter mode generator, and is thus difficult to parallelize or use safely in a random access setting.</p>\n<p>Until now!  Commit <a class=\"commit-link\" data-hovercard-type=\"commit\" data-hovercard-url=\"https://github.com/girving/tensorflow/commit/60abb26f528f53e7692edb3e89489a69b59ae83e/hovercard\" href=\"https://github.com/girving/tensorflow/commit/60abb26f528f53e7692edb3e89489a69b59ae83e\">girving@<tt>60abb26</tt></a> on branch <a href=\"https://github.com/girving/tensorflow/tree/xorshift\">https://github.com/girving/tensorflow/tree/xorshift</a> implements random access into the xorshift128+ generator in a reasonably efficient manner, using some finite field machinery.  Specifically, jumps in xorshift128+ are represented as elements of the finite field GF(2^128), composed to produce other jumps, then mapped through linear maps to produce xorshift128+ values.</p>\n<p>However, the code is a proof of concept.  A decent amount of further work would have to be done to get committed to TensorFlow.  In particular, the parallelism code on both CPU and GPU would have to be written, by computing one jump per thread of execution (many jumps can be computed more cheaply vs. one at a time).  The current code is also nonportable: it assumes special  instructions for carryless multiplication of polynomials over GF(2).  These instructions are available on recent Intel and AMD CPUs, but a slow path would need to be written to handle everything else.</p>\n<p>Also, whether the result would actually be faster is an open question.</p>\n<p>I don't have time to do the remaining work, so I am leaving this here as a project in case someone wants to take it on with my help.</p>", "body_text": "Currently, TensorFlow's random numbers use the Philox counter mode generator, which is extremely easy to parallelize on both CPU and GPU.  This applies to both the normal stateful ops and the new tf.contrib.stateless versions with custom seeding.\nxorshift128+ is a simpler generator that could conceivably speed up random number generation.  Unfortunately, it is not a counter mode generator, and is thus difficult to parallelize or use safely in a random access setting.\nUntil now!  Commit girving@60abb26 on branch https://github.com/girving/tensorflow/tree/xorshift implements random access into the xorshift128+ generator in a reasonably efficient manner, using some finite field machinery.  Specifically, jumps in xorshift128+ are represented as elements of the finite field GF(2^128), composed to produce other jumps, then mapped through linear maps to produce xorshift128+ values.\nHowever, the code is a proof of concept.  A decent amount of further work would have to be done to get committed to TensorFlow.  In particular, the parallelism code on both CPU and GPU would have to be written, by computing one jump per thread of execution (many jumps can be computed more cheaply vs. one at a time).  The current code is also nonportable: it assumes special  instructions for carryless multiplication of polynomials over GF(2).  These instructions are available on recent Intel and AMD CPUs, but a slow path would need to be written to handle everything else.\nAlso, whether the result would actually be faster is an open question.\nI don't have time to do the remaining work, so I am leaving this here as a project in case someone wants to take it on with my help.", "body": "Currently, TensorFlow's random numbers use the Philox counter mode generator, which is extremely easy to parallelize on both CPU and GPU.  This applies to both the normal stateful ops and the new [`tf.contrib.stateless`](https://github.com/tensorflow/tensorflow/commit/cc45456e4ad0eff16127d1727d0cf48afb71ca0e) versions with custom seeding.\r\n\r\nxorshift128+ is a simpler generator that could conceivably speed up random number generation.  Unfortunately, it is not a counter mode generator, and is thus difficult to parallelize or use safely in a random access setting.\r\n\r\nUntil now!  Commit https://github.com/girving/tensorflow/commit/60abb26f528f53e7692edb3e89489a69b59ae83e on branch https://github.com/girving/tensorflow/tree/xorshift implements random access into the xorshift128+ generator in a reasonably efficient manner, using some finite field machinery.  Specifically, jumps in xorshift128+ are represented as elements of the finite field GF(2^128), composed to produce other jumps, then mapped through linear maps to produce xorshift128+ values.\r\n\r\nHowever, the code is a proof of concept.  A decent amount of further work would have to be done to get committed to TensorFlow.  In particular, the parallelism code on both CPU and GPU would have to be written, by computing one jump per thread of execution (many jumps can be computed more cheaply vs. one at a time).  The current code is also nonportable: it assumes special  instructions for carryless multiplication of polynomials over GF(2).  These instructions are available on recent Intel and AMD CPUs, but a slow path would need to be written to handle everything else.\r\n\r\nAlso, whether the result would actually be faster is an open question.\r\n\r\nI don't have time to do the remaining work, so I am leaving this here as a project in case someone wants to take it on with my help."}