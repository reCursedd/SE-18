{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/207442225", "pull_request_review_id": 143053606, "id": 207442225, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwNzQ0MjIyNQ==", "diff_hunk": "@@ -63,28 +61,124 @@ void propagateNode(Node* n) {\n   }\n }\n \n+void lowerIf(Block *body, Node * n) {\n+  auto graph = n->owningGraph();\n+  WithInsertPoint insert_point_guard { n };\n+\n+  std::unordered_map<Value*, Value*> value_map;\n+  auto get_value = [&](Value *v) {\n+    auto it = value_map.find(v);\n+    if (it != value_map.end())\n+      return it->second;\n+    return v;\n+  };\n+\n+  for (Node *orig : body->nodes()) {\n+    Node *clone = graph->insertNode(graph->createClone(orig, get_value));\n+    for (size_t i = 0; i < orig->outputs().size(); ++i) {\n+      value_map[orig->outputs()[i]] = clone->outputs()[i];\n+    }\n+  }\n+  for (size_t i = 0; i < n->outputs().size(); ++i) {\n+    n->outputs().at(i)->replaceAllUsesWith(get_value(body->outputs().at(i)));\n+  }\n+  // NB: destroy the node here, because it might contain side effects, like print\n+  n->destroy();\n+}\n+\n+bool isTrueConstant(Value *val) {\n+  at::optional<bool> maybe_value = constant_as<bool>(val);\n+  return maybe_value && *maybe_value;\n+}\n+\n+void lowerIf(Node *n) {\n+  if (isTrueConstant(n->input())) {\n+    lowerIf(n->blocks()[0], n);\n+  } else {\n+    lowerIf(n->blocks()[1], n);\n+  }\n+}\n+\n+//returns true if the mutated variables are changed\n+bool recomputeMutatedVariables(Node *n) {\n+  JIT_ASSERTM(n->kind() == prim::If, \"Only supported for If nodes\");\n+  std::unordered_set<Value*> mutated_variables;\n+  for (Block * block : n->blocks()) {\n+    for (Node *n : block->nodes()) {\n+      for (size_t i = 0; i < n->outputs().size(); ++i) {\n+        mutated_variables.insert(n->outputs()[i]);\n+      }\n+    }\n+  }\n+  auto true_block = n->blocks()[0];\n+  auto false_block = n->blocks()[1];\n+  auto initial_outputs = true_block->outputs().size();\n+  for (size_t i = 0; i < true_block->outputs().size();) {\n+    //neither block mutates output i\n+    if (!mutated_variables.count(true_block->outputs()[i]) &&\n+      !mutated_variables.count(false_block->outputs()[i])) {\n+      n->outputs().at(i)->replaceAllUsesWith(true_block->outputs()[i]);\n+      n->eraseOutput(i);\n+      true_block->eraseOutput(i);\n+      false_block->eraseOutput(i);\n+    } else {\n+      i++; //increment bc we didn't remove current index\n+    }\n+  }\n+  //an output was removed\n+  return initial_outputs != true_block->outputs().size();\n+}\n+\n } // anonymous namespace\n \n-void ConstantPropagation(Node* n, bool recurse) {\n+//returns whether the node's set of mutated variables changed\n+bool ConstantPropagation(Node* n, bool recurse) {\n   bool constant_inputs = (n->inputs().size() > 0) &&\n     std::all_of(n->inputs().begin(), n->inputs().end(), [&](Value* v) {\n       return v->node()->kind() == prim::Constant;\n     });\n   bool supported_node = skip_list.count(n->kind()) == 0;\n-  if (constant_inputs && supported_node) {\n+  auto run_blocks = [&]() {\n+    bool any_child = false;\n+    if (recurse) {\n+      for (Block * block : n->blocks()) {\n+        auto child = ConstantPropagation(block, recurse);\n+        any_child = any_child || child;\n+      }\n+    }\n+    return any_child;\n+  };\n+  if (n->kind() == prim::If) {\n+    //did a child node change\n+    bool changed = run_blocks();\n+    //inline node if we can, otherwise if a child node changed recompute\n+    //mutated variables and see if this node changed\n+    if (constant_inputs) {\n+      lowerIf(n);\n+    } else if (changed) {\n+      changed = recomputeMutatedVariables(n);", "path": "torch/csrc/jit/passes/constant_propagation.cpp", "position": null, "original_position": 113, "commit_id": "c5f2104925bec35e14f1dc48b07870f49dbabd0d", "original_commit_id": "ae421d1c66858e6588c9ade3b3e77bbc36bb99d2", "user": {"login": "zdevito", "id": 370202, "node_id": "MDQ6VXNlcjM3MDIwMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/370202?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zdevito", "html_url": "https://github.com/zdevito", "followers_url": "https://api.github.com/users/zdevito/followers", "following_url": "https://api.github.com/users/zdevito/following{/other_user}", "gists_url": "https://api.github.com/users/zdevito/gists{/gist_id}", "starred_url": "https://api.github.com/users/zdevito/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zdevito/subscriptions", "organizations_url": "https://api.github.com/users/zdevito/orgs", "repos_url": "https://api.github.com/users/zdevito/repos", "events_url": "https://api.github.com/users/zdevito/events{/privacy}", "received_events_url": "https://api.github.com/users/zdevito/received_events", "type": "User", "site_admin": false}, "body": "If it is possible to simplify recomputeMutatedVariables so it just has to check the output list of the if, then it is also ok to remove the `changed` logic and just unconditionally check for simplified outputs.", "created_at": "2018-08-03T05:10:09Z", "updated_at": "2018-11-23T15:48:41Z", "html_url": "https://github.com/pytorch/pytorch/pull/10084#discussion_r207442225", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/10084", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/207442225"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/10084#discussion_r207442225"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/10084"}}, "body_html": "<p>If it is possible to simplify recomputeMutatedVariables so it just has to check the output list of the if, then it is also ok to remove the <code>changed</code> logic and just unconditionally check for simplified outputs.</p>", "body_text": "If it is possible to simplify recomputeMutatedVariables so it just has to check the output list of the if, then it is also ok to remove the changed logic and just unconditionally check for simplified outputs."}