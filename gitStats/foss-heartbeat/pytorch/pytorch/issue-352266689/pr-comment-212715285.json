{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/212715285", "pull_request_review_id": 149411148, "id": 212715285, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMjcxNTI4NQ==", "diff_hunk": "@@ -0,0 +1,227 @@\n+#include \"torch/csrc/jit/passes/annotate_effects.h\"\n+\n+#include <set>\n+#include \"torch/csrc/jit/passes/dead_code_elimination.h\"\n+\n+namespace torch {\n+namespace jit {\n+namespace {\n+\n+/**\n+ * AnnotateEffects\n+ *\n+ * This pass annotates effectful operations (such as ones that mutate existing\n+ * values) to prevent subsequent passes from re-ordering ops in a way that\n+ * changes the meaning of the program.\n+ *\n+ * It does this by threading a \"world token\" value through nodes that use\n+ * mutable values. This models effects explicitly in the IR and forces all\n+ * annotated nodes to be linearized during optimization.\n+ *\n+ * The world token is threaded directly through any nodes that mutate values.\n+ * For purely functional operators, their node will be \"fenced\" by two\n+ * `prim::MemoryFence` nodes that take world tokens as their input.\n+ */\n+class AnnotateEffectsImpl {\n+ public:\n+  void annotateEffects(Graph* g) {\n+    // TODO(suo): We need to change this so that the world token is an input\n+    // and output of the graph. That would require changing a bunch of interop\n+    // and batching code, so leaving it out for now.\n+    //\n+    // auto curToken = g->addInput(\"world\")->setType(WorldType::get());\n+    // curToken = visitBlock(g->block(), curToken);\n+    // g->registerOutput(curToken);\n+\n+    // Generate the first world token\n+    const auto tokenGenerator = g->create(prim::Constant);\n+    g->block()->prependNode(tokenGenerator);\n+    auto curToken = tokenGenerator->output()->setType(WorldType::get());\n+\n+    visitBlock(g->block(), curToken);\n+  }\n+\n+ private:\n+  Value* visitBlock(Block* block, Value* curToken) {\n+    for (auto* node : block->nodes()) {\n+      curToken = visitNode(node, curToken);\n+    }\n+    return curToken;\n+  }\n+\n+  // If a node uses a mutable variable (or mutates a previously constant\n+  // variable), annotate it\n+  //\n+  // Returns the last world token emitted for subsequent annotations to use.\n+  Value* visitNode(Node* node, Value* curToken) {\n+    if (node->kind() == prim::MemoryFence) {\n+      return curToken;\n+    }\n+\n+    if (node->kind() == prim::If) {\n+      JIT_ASSERT(node->blocks().size() == 2);\n+\n+      auto trueBlock = node->blocks().at(0);\n+      auto falseBlock = node->blocks().at(1);\n+\n+      auto trueToken = visitBlock(trueBlock, curToken);\n+      auto falseToken = visitBlock(falseBlock, curToken);\n+\n+      // If any branch has a mutating op, this node has to output a world token\n+      if (trueToken != curToken || falseToken != curToken) {\n+        trueBlock->registerOutput(trueToken);\n+        falseBlock->registerOutput(falseToken);\n+\n+        return node->addOutput()->setType(WorldType::get());\n+      }\n+      return curToken;\n+    }\n+\n+    if (node->kind() == prim::Loop) {\n+      JIT_ASSERT(node->blocks().size() == 1);\n+      auto block = node->blocks().at(0);\n+      if (!shouldAnnotate(block)) {\n+        // Bail out early if there's no mutable variables used inside\n+        return curToken;\n+      }\n+\n+      // Register the world token as a loop carried dependency\n+      auto beginLoopToken = block->addInput()->setType(WorldType::get());\n+      auto endLoopToken = visitBlock(block, beginLoopToken);\n+      block->registerOutput(endLoopToken);\n+\n+      JIT_ASSERT(endLoopToken != beginLoopToken);\n+\n+      // Thread the world token through the loop node\n+      node->addInput(curToken);\n+      return node->addOutput()->setType(WorldType::get());\n+    }\n+\n+    // For mutating ops, just thread the world token through the node.\n+    if (isMutatingOp(node)) {\n+      node->replaceInput(0, curToken);\n+      return node->outputs().at(0);\n+    }\n+\n+    JIT_ASSERT(node->blocks().size() == 0);\n+\n+    // For pure ops that need to be annotated, fence them.\n+    if (shouldAnnotate(node)) {\n+      return addFenceForNode(node, curToken);\n+    }\n+\n+    return curToken;\n+  }\n+\n+  bool shouldAnnotate(Node* node) {\n+    // Check if this node uses a known mutable value\n+    for (auto* input : node->inputs()) {\n+      if (input->type()->kind() != TypeKind::ListType) {\n+        // TODO(suo): Right now, we only support mutable lists.\n+        // If we remove this check, it's not clear whether:\n+        //\n+        //   append(int[] a, int b)\n+        //\n+        // mutates `a` or `b`. We'll need to extend the schema language to be\n+        // able to express which argument is mutated.\n+        continue;\n+      }\n+      // First check the cache\n+      if (mutableValues_.count(input) != 0) {\n+        return true;\n+      }\n+\n+      // Check whether any mutating op uses this input\n+      for (const auto& use : input->uses()) {\n+        if (isMutatingOp(use.user)) {\n+          mutableValues_.insert(input);\n+          return true;", "path": "torch/csrc/jit/passes/annotate_effects.cpp", "position": 170, "original_position": 138, "commit_id": "fbcf02446753bff536faca7fa093af5f88fc621c", "original_commit_id": "3ab89f73ed99cbea775ac32ed1e502b081356cc5", "user": {"login": "suo", "id": 1617424, "node_id": "MDQ6VXNlcjE2MTc0MjQ=", "avatar_url": "https://avatars2.githubusercontent.com/u/1617424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/suo", "html_url": "https://github.com/suo", "followers_url": "https://api.github.com/users/suo/followers", "following_url": "https://api.github.com/users/suo/following{/other_user}", "gists_url": "https://api.github.com/users/suo/gists{/gist_id}", "starred_url": "https://api.github.com/users/suo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/suo/subscriptions", "organizations_url": "https://api.github.com/users/suo/orgs", "repos_url": "https://api.github.com/users/suo/repos", "events_url": "https://api.github.com/users/suo/events{/privacy}", "received_events_url": "https://api.github.com/users/suo/received_events", "type": "User", "site_admin": false}, "body": "Yeah, I'm going to rework the cache stuff per the comments above. I think it's reasonable to have the policy be \"only start fencing stuff after the first mutation\", but I'll see whether it's worth the extra complexity to track that. Since the the common case will probably be to create a list and immediately start appending, it doesn't seem like a huge win.", "created_at": "2018-08-24T18:23:59Z", "updated_at": "2018-11-23T15:49:59Z", "html_url": "https://github.com/pytorch/pytorch/pull/10700#discussion_r212715285", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/10700", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/212715285"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/10700#discussion_r212715285"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/10700"}}, "body_html": "<p>Yeah, I'm going to rework the cache stuff per the comments above. I think it's reasonable to have the policy be \"only start fencing stuff after the first mutation\", but I'll see whether it's worth the extra complexity to track that. Since the the common case will probably be to create a list and immediately start appending, it doesn't seem like a huge win.</p>", "body_text": "Yeah, I'm going to rework the cache stuff per the comments above. I think it's reasonable to have the policy be \"only start fencing stuff after the first mutation\", but I'll see whether it's worth the extra complexity to track that. Since the the common case will probably be to create a list and immediately start appending, it doesn't seem like a huge win.", "in_reply_to_id": 212705897}