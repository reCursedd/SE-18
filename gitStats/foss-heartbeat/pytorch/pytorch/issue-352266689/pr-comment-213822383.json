{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/213822383", "pull_request_review_id": 150702987, "id": 213822383, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzgyMjM4Mw==", "diff_hunk": "@@ -687,20 +721,27 @@ Value* emitBuiltinCall(\n   std::stringstream failure_messages;\n   //first we try to match the schema without any conversion\n   //if no schema matches then insert ImplicitTensorToNum\n-  for(bool convert_tensors_to_nums : {false, true}) {\n-    //clear previous error messages\n+  for (bool convert_tensors_to_nums : {false, true}) {\n+    // clear previous error messages\n     failure_messages.str(\"\");\n     for (const std::shared_ptr<Operator>& op : variants) {\n-      if (auto result = tryEmitBuiltin(\n-              op, failure_messages, loc, graph, name, inputs, attributes,\n-              convert_tensors_to_nums)) {\n-        return result;\n+      const auto matched_inputs = matchStrategy(", "path": "torch/csrc/jit/script/compiler.cpp", "position": null, "original_position": 149, "commit_id": "fbcf02446753bff536faca7fa093af5f88fc621c", "original_commit_id": "a7826866cb6198f2ba2c1b45d4c2dee7d38a2948", "user": {"login": "zdevito", "id": 370202, "node_id": "MDQ6VXNlcjM3MDIwMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/370202?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zdevito", "html_url": "https://github.com/zdevito", "followers_url": "https://api.github.com/users/zdevito/followers", "following_url": "https://api.github.com/users/zdevito/following{/other_user}", "gists_url": "https://api.github.com/users/zdevito/gists{/gist_id}", "starred_url": "https://api.github.com/users/zdevito/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zdevito/subscriptions", "organizations_url": "https://api.github.com/users/zdevito/orgs", "repos_url": "https://api.github.com/users/zdevito/repos", "events_url": "https://api.github.com/users/zdevito/events{/privacy}", "received_events_url": "https://api.github.com/users/zdevito/received_events", "type": "User", "site_admin": false}, "body": "This is huge code smell that we got something wrong here. We now have `Impl` variants of builtin and strategy patterns. All to just get over the fact that there are now two ways of matching schema! There should only be a single way to emit ops and check their schema is valid.\r\n\r\nHere is what I think we should do: just make emitBuiltinCall universally insert the world token if the schema is mutable. It should emit a `prim::LoadWorld` op.  `prim::LoadWorld` should just fault on use. It will then be a passes responsibility if they are emitting a mutable op to fix up the prim::LoadWorld nodes. This kicks the can down the road but I think it is better than complicated the `emit` logic in this way. We can improve this later. For instance, we can add a `std::function<Value*()> world_provider = nullptr` to emit that allows you to specify how to generate a World input if needed.", "created_at": "2018-08-29T20:27:09Z", "updated_at": "2018-11-23T15:50:16Z", "html_url": "https://github.com/pytorch/pytorch/pull/10700#discussion_r213822383", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/10700", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/213822383"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/10700#discussion_r213822383"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/10700"}}, "body_html": "<p>This is huge code smell that we got something wrong here. We now have <code>Impl</code> variants of builtin and strategy patterns. All to just get over the fact that there are now two ways of matching schema! There should only be a single way to emit ops and check their schema is valid.</p>\n<p>Here is what I think we should do: just make emitBuiltinCall universally insert the world token if the schema is mutable. It should emit a <code>prim::LoadWorld</code> op.  <code>prim::LoadWorld</code> should just fault on use. It will then be a passes responsibility if they are emitting a mutable op to fix up the prim::LoadWorld nodes. This kicks the can down the road but I think it is better than complicated the <code>emit</code> logic in this way. We can improve this later. For instance, we can add a <code>std::function&lt;Value*()&gt; world_provider = nullptr</code> to emit that allows you to specify how to generate a World input if needed.</p>", "body_text": "This is huge code smell that we got something wrong here. We now have Impl variants of builtin and strategy patterns. All to just get over the fact that there are now two ways of matching schema! There should only be a single way to emit ops and check their schema is valid.\nHere is what I think we should do: just make emitBuiltinCall universally insert the world token if the schema is mutable. It should emit a prim::LoadWorld op.  prim::LoadWorld should just fault on use. It will then be a passes responsibility if they are emitting a mutable op to fix up the prim::LoadWorld nodes. This kicks the can down the road but I think it is better than complicated the emit logic in this way. We can improve this later. For instance, we can add a std::function<Value*()> world_provider = nullptr to emit that allows you to specify how to generate a World input if needed."}