{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/212705897", "pull_request_review_id": 149397759, "id": 212705897, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMjcwNTg5Nw==", "diff_hunk": "@@ -0,0 +1,227 @@\n+#include \"torch/csrc/jit/passes/annotate_effects.h\"\n+\n+#include <set>\n+#include \"torch/csrc/jit/passes/dead_code_elimination.h\"\n+\n+namespace torch {\n+namespace jit {\n+namespace {\n+\n+/**\n+ * AnnotateEffects\n+ *\n+ * This pass annotates effectful operations (such as ones that mutate existing\n+ * values) to prevent subsequent passes from re-ordering ops in a way that\n+ * changes the meaning of the program.\n+ *\n+ * It does this by threading a \"world token\" value through nodes that use\n+ * mutable values. This models effects explicitly in the IR and forces all\n+ * annotated nodes to be linearized during optimization.\n+ *\n+ * The world token is threaded directly through any nodes that mutate values.\n+ * For purely functional operators, their node will be \"fenced\" by two\n+ * `prim::MemoryFence` nodes that take world tokens as their input.\n+ */\n+class AnnotateEffectsImpl {\n+ public:\n+  void annotateEffects(Graph* g) {\n+    // TODO(suo): We need to change this so that the world token is an input\n+    // and output of the graph. That would require changing a bunch of interop\n+    // and batching code, so leaving it out for now.\n+    //\n+    // auto curToken = g->addInput(\"world\")->setType(WorldType::get());\n+    // curToken = visitBlock(g->block(), curToken);\n+    // g->registerOutput(curToken);\n+\n+    // Generate the first world token\n+    const auto tokenGenerator = g->create(prim::Constant);\n+    g->block()->prependNode(tokenGenerator);\n+    auto curToken = tokenGenerator->output()->setType(WorldType::get());\n+\n+    visitBlock(g->block(), curToken);\n+  }\n+\n+ private:\n+  Value* visitBlock(Block* block, Value* curToken) {\n+    for (auto* node : block->nodes()) {\n+      curToken = visitNode(node, curToken);\n+    }\n+    return curToken;\n+  }\n+\n+  // If a node uses a mutable variable (or mutates a previously constant\n+  // variable), annotate it\n+  //\n+  // Returns the last world token emitted for subsequent annotations to use.\n+  Value* visitNode(Node* node, Value* curToken) {\n+    if (node->kind() == prim::MemoryFence) {\n+      return curToken;\n+    }\n+\n+    if (node->kind() == prim::If) {\n+      JIT_ASSERT(node->blocks().size() == 2);\n+\n+      auto trueBlock = node->blocks().at(0);\n+      auto falseBlock = node->blocks().at(1);\n+\n+      auto trueToken = visitBlock(trueBlock, curToken);\n+      auto falseToken = visitBlock(falseBlock, curToken);\n+\n+      // If any branch has a mutating op, this node has to output a world token\n+      if (trueToken != curToken || falseToken != curToken) {\n+        trueBlock->registerOutput(trueToken);\n+        falseBlock->registerOutput(falseToken);\n+\n+        return node->addOutput()->setType(WorldType::get());\n+      }\n+      return curToken;\n+    }\n+\n+    if (node->kind() == prim::Loop) {\n+      JIT_ASSERT(node->blocks().size() == 1);\n+      auto block = node->blocks().at(0);\n+      if (!shouldAnnotate(block)) {\n+        // Bail out early if there's no mutable variables used inside\n+        return curToken;\n+      }\n+\n+      // Register the world token as a loop carried dependency\n+      auto beginLoopToken = block->addInput()->setType(WorldType::get());\n+      auto endLoopToken = visitBlock(block, beginLoopToken);\n+      block->registerOutput(endLoopToken);\n+\n+      JIT_ASSERT(endLoopToken != beginLoopToken);\n+\n+      // Thread the world token through the loop node\n+      node->addInput(curToken);\n+      return node->addOutput()->setType(WorldType::get());\n+    }\n+\n+    // For mutating ops, just thread the world token through the node.\n+    if (isMutatingOp(node)) {\n+      node->replaceInput(0, curToken);\n+      return node->outputs().at(0);\n+    }\n+\n+    JIT_ASSERT(node->blocks().size() == 0);\n+\n+    // For pure ops that need to be annotated, fence them.\n+    if (shouldAnnotate(node)) {\n+      return addFenceForNode(node, curToken);\n+    }\n+\n+    return curToken;\n+  }\n+\n+  bool shouldAnnotate(Node* node) {\n+    // Check if this node uses a known mutable value\n+    for (auto* input : node->inputs()) {\n+      if (input->type()->kind() != TypeKind::ListType) {\n+        // TODO(suo): Right now, we only support mutable lists.\n+        // If we remove this check, it's not clear whether:\n+        //\n+        //   append(int[] a, int b)\n+        //\n+        // mutates `a` or `b`. We'll need to extend the schema language to be\n+        // able to express which argument is mutated.\n+        continue;\n+      }\n+      // First check the cache\n+      if (mutableValues_.count(input) != 0) {\n+        return true;\n+      }\n+\n+      // Check whether any mutating op uses this input\n+      for (const auto& use : input->uses()) {\n+        if (isMutatingOp(use.user)) {\n+          mutableValues_.insert(input);\n+          return true;", "path": "torch/csrc/jit/passes/annotate_effects.cpp", "position": 170, "original_position": 138, "commit_id": "fbcf02446753bff536faca7fa093af5f88fc621c", "original_commit_id": "3ab89f73ed99cbea775ac32ed1e502b081356cc5", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "body": "I don't understand this logic. It looks like the values effectively become mutable only right before they are input to the first mutable op? What if they're given to us as arguments and we won't visit them? Why don't they become mutable only when they're actually modified for the first time? It feels to me like this cache population should live somewhere in the `isMutableOp` guarded branch.", "created_at": "2018-08-24T17:51:05Z", "updated_at": "2018-11-23T15:49:58Z", "html_url": "https://github.com/pytorch/pytorch/pull/10700#discussion_r212705897", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/10700", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/212705897"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/10700#discussion_r212705897"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/10700"}}, "body_html": "<p>I don't understand this logic. It looks like the values effectively become mutable only right before they are input to the first mutable op? What if they're given to us as arguments and we won't visit them? Why don't they become mutable only when they're actually modified for the first time? It feels to me like this cache population should live somewhere in the <code>isMutableOp</code> guarded branch.</p>", "body_text": "I don't understand this logic. It looks like the values effectively become mutable only right before they are input to the first mutable op? What if they're given to us as arguments and we won't visit them? Why don't they become mutable only when they're actually modified for the first time? It feels to me like this cache population should live somewhere in the isMutableOp guarded branch."}