{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/420368612", "html_url": "https://github.com/pytorch/pytorch/pull/11510#issuecomment-420368612", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/11510", "id": 420368612, "node_id": "MDEyOklzc3VlQ29tbWVudDQyMDM2ODYxMg==", "user": {"login": "goldsborough", "id": 6429851, "node_id": "MDQ6VXNlcjY0Mjk4NTE=", "avatar_url": "https://avatars3.githubusercontent.com/u/6429851?v=4", "gravatar_id": "", "url": "https://api.github.com/users/goldsborough", "html_url": "https://github.com/goldsborough", "followers_url": "https://api.github.com/users/goldsborough/followers", "following_url": "https://api.github.com/users/goldsborough/following{/other_user}", "gists_url": "https://api.github.com/users/goldsborough/gists{/gist_id}", "starred_url": "https://api.github.com/users/goldsborough/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/goldsborough/subscriptions", "organizations_url": "https://api.github.com/users/goldsborough/orgs", "repos_url": "https://api.github.com/users/goldsborough/repos", "events_url": "https://api.github.com/users/goldsborough/events{/privacy}", "received_events_url": "https://api.github.com/users/goldsborough/received_events", "type": "User", "site_admin": false}, "created_at": "2018-09-11T18:12:46Z", "updated_at": "2018-09-11T18:14:14Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=9110200\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/fmassa\">@fmassa</a> That's a good and important question! The definite answer here, however, is that Python API and C++ API modules are currently not inter-operable at all, and so making one a submodule of the other will not work and is not intended to work right now. There could be future work of unifying them, but right now <code>nn::Module</code> and <code>nn.Module</code> are completely different things and cannot be mixed. In the future we may be able to give them a common C++ base class, along with JIT ScriptModule's too.</p>\n<p>My intention here is simply to make it easier to add Python bindings to the C++ API, but not to make the C++ API inter-operate better with the Python API. The use case here is that you have a C++ API model and would like to do something with it in Python for experimentation, for which C++ extensions have been super quick in my personal attempts at this. Another use case (which we have internally) is that you could keep two copies of your model, one in the Python API which you use for quick experiments, and one in the C++ API which you use in prod, and then have your training loop, data wrangling and visualization in Python, and instantiate either the C++ or Python model dynamically inside Python and all your training loop code will work on both.</p>\n<p>What this unification does give to <em>C++ extension users</em> is the utilities the C++ API provides, that is simple things like <code>torch::cuda::is_available()</code> or the <code>torch::NoGradGuard</code> (equivalent to <code>with torch.no_grad()</code>). So it's not super revolutionary in that sense.</p>\n<p>For us developers it is useful because we no longer have to think of the C++ extension codebase (currently torch/csrc/torch.h) and the C++ API codebase as separate.</p>", "body_text": "@fmassa That's a good and important question! The definite answer here, however, is that Python API and C++ API modules are currently not inter-operable at all, and so making one a submodule of the other will not work and is not intended to work right now. There could be future work of unifying them, but right now nn::Module and nn.Module are completely different things and cannot be mixed. In the future we may be able to give them a common C++ base class, along with JIT ScriptModule's too.\nMy intention here is simply to make it easier to add Python bindings to the C++ API, but not to make the C++ API inter-operate better with the Python API. The use case here is that you have a C++ API model and would like to do something with it in Python for experimentation, for which C++ extensions have been super quick in my personal attempts at this. Another use case (which we have internally) is that you could keep two copies of your model, one in the Python API which you use for quick experiments, and one in the C++ API which you use in prod, and then have your training loop, data wrangling and visualization in Python, and instantiate either the C++ or Python model dynamically inside Python and all your training loop code will work on both.\nWhat this unification does give to C++ extension users is the utilities the C++ API provides, that is simple things like torch::cuda::is_available() or the torch::NoGradGuard (equivalent to with torch.no_grad()). So it's not super revolutionary in that sense.\nFor us developers it is useful because we no longer have to think of the C++ extension codebase (currently torch/csrc/torch.h) and the C++ API codebase as separate.", "body": "@fmassa That's a good and important question! The definite answer here, however, is that Python API and C++ API modules are currently not inter-operable at all, and so making one a submodule of the other will not work and is not intended to work right now. There could be future work of unifying them, but right now `nn::Module` and `nn.Module` are completely different things and cannot be mixed. In the future we may be able to give them a common C++ base class, along with JIT ScriptModule's too.\r\n\r\nMy intention here is simply to make it easier to add Python bindings to the C++ API, but not to make the C++ API inter-operate better with the Python API. The use case here is that you have a C++ API model and would like to do something with it in Python for experimentation, for which C++ extensions have been super quick in my personal attempts at this. Another use case (which we have internally) is that you could keep two copies of your model, one in the Python API which you use for quick experiments, and one in the C++ API which you use in prod, and then have your training loop, data wrangling and visualization in Python, and instantiate either the C++ or Python model dynamically inside Python and all your training loop code will work on both.\r\n\r\nWhat this unification does give to *C++ extension users* is the utilities the C++ API provides, that is simple things like `torch::cuda::is_available()` or the `torch::NoGradGuard` (equivalent to `with torch.no_grad()`). So it's not super revolutionary in that sense.\r\n\r\nFor us developers it is useful because we no longer have to think of the C++ extension codebase (currently torch/csrc/torch.h) and the C++ API codebase as separate.\r\n\r\n"}