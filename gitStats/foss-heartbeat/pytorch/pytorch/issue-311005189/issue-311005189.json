{"url": "https://api.github.com/repos/pytorch/pytorch/issues/6246", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/6246/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/6246/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/6246/events", "html_url": "https://github.com/pytorch/pytorch/issues/6246", "id": 311005189, "node_id": "MDU6SXNzdWUzMTEwMDUxODk=", "number": 6246, "title": "[jit][script] Develop a plan for annotating static types for script methods", "user": {"login": "zdevito", "id": 370202, "node_id": "MDQ6VXNlcjM3MDIwMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/370202?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zdevito", "html_url": "https://github.com/zdevito", "followers_url": "https://api.github.com/users/zdevito/followers", "following_url": "https://api.github.com/users/zdevito/following{/other_user}", "gists_url": "https://api.github.com/users/zdevito/gists{/gist_id}", "starred_url": "https://api.github.com/users/zdevito/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zdevito/subscriptions", "organizations_url": "https://api.github.com/users/zdevito/orgs", "repos_url": "https://api.github.com/users/zdevito/repos", "events_url": "https://api.github.com/users/zdevito/events{/privacy}", "received_events_url": "https://api.github.com/users/zdevito/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 679953983, "node_id": "MDU6TGFiZWw2Nzk5NTM5ODM=", "url": "https://api.github.com/repos/pytorch/pytorch/labels/jit", "name": "jit", "color": "c5def5", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 11, "created_at": "2018-04-03T21:28:27Z", "updated_at": "2018-05-09T08:35:49Z", "closed_at": "2018-05-09T08:35:48Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Currently the only type the script subset supports is Tensor. In the future, we want to support additional types:</p>\n<ul>\n<li>Tuples (an immutable list of static length)</li>\n<li>Lists (a potentially mutable list of dynamic length)</li>\n<li>(maybe) Records, dicts, etc.</li>\n</ul>\n<p>Since script is used as a basis for optimizing pytorch code and for export, we want it to be statically typed. So far this static typing was easy since we just assumed <em>everything</em> was a Tensor. Once we add one of the above features (such as Tuples <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"310159593\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/6153\" data-hovercard-type=\"issue\" data-hovercard-url=\"/pytorch/pytorch/issues/6153/hovercard\" href=\"https://github.com/pytorch/pytorch/issues/6153\">#6153</a>), we need a way to annotate types for things we would otherwise not know the type for. This occurs in at least two places right now:</p>\n<ul>\n<li>the arguments to a script function or method</li>\n<li>the return values of a pure python function called from a script method.</li>\n</ul>\n<p>How we approach this problem depends on the technology we are using. In Python 3, we can use type annotations to do this (both on python functions that we want the script to call, and on our own script functions). If we use the string frontend, we can also add Python 3 style annotations. However, in Python 2 without the script frontend, we really do not have a good way to add annotations. The approach suggested by <a href=\"https://www.python.org/dev/peps/pep-0484/#suggested-syntax-for-python-2-7-and-straddling-code\" rel=\"nofollow\">PEP0484</a> requires a separate parser to parse the python code.  This is ok for optional type checking, but a non-starter for mandatory type annotations.</p>\n<p>We need to:</p>\n<ul>\n<li>decide whether we should have a consistent interface across Python 2/Python 3, or to use Python 2 and 3 act differently</li>\n<li>come up with a viable annotation strategy for python 2</li>\n<li>plan to implement these annotations when we first need them (e.g. for tuples)</li>\n</ul>", "body_text": "Currently the only type the script subset supports is Tensor. In the future, we want to support additional types:\n\nTuples (an immutable list of static length)\nLists (a potentially mutable list of dynamic length)\n(maybe) Records, dicts, etc.\n\nSince script is used as a basis for optimizing pytorch code and for export, we want it to be statically typed. So far this static typing was easy since we just assumed everything was a Tensor. Once we add one of the above features (such as Tuples #6153), we need a way to annotate types for things we would otherwise not know the type for. This occurs in at least two places right now:\n\nthe arguments to a script function or method\nthe return values of a pure python function called from a script method.\n\nHow we approach this problem depends on the technology we are using. In Python 3, we can use type annotations to do this (both on python functions that we want the script to call, and on our own script functions). If we use the string frontend, we can also add Python 3 style annotations. However, in Python 2 without the script frontend, we really do not have a good way to add annotations. The approach suggested by PEP0484 requires a separate parser to parse the python code.  This is ok for optional type checking, but a non-starter for mandatory type annotations.\nWe need to:\n\ndecide whether we should have a consistent interface across Python 2/Python 3, or to use Python 2 and 3 act differently\ncome up with a viable annotation strategy for python 2\nplan to implement these annotations when we first need them (e.g. for tuples)", "body": "Currently the only type the script subset supports is Tensor. In the future, we want to support additional types:\r\n\r\n* Tuples (an immutable list of static length)\r\n* Lists (a potentially mutable list of dynamic length)\r\n* (maybe) Records, dicts, etc.\r\n\r\nSince script is used as a basis for optimizing pytorch code and for export, we want it to be statically typed. So far this static typing was easy since we just assumed _everything_ was a Tensor. Once we add one of the above features (such as Tuples #6153), we need a way to annotate types for things we would otherwise not know the type for. This occurs in at least two places right now:\r\n\r\n* the arguments to a script function or method\r\n* the return values of a pure python function called from a script method.\r\n\r\nHow we approach this problem depends on the technology we are using. In Python 3, we can use type annotations to do this (both on python functions that we want the script to call, and on our own script functions). If we use the string frontend, we can also add Python 3 style annotations. However, in Python 2 without the script frontend, we really do not have a good way to add annotations. The approach suggested by [PEP0484](https://www.python.org/dev/peps/pep-0484/#suggested-syntax-for-python-2-7-and-straddling-code) requires a separate parser to parse the python code.  This is ok for optional type checking, but a non-starter for mandatory type annotations.  \r\n\r\nWe need to:\r\n* decide whether we should have a consistent interface across Python 2/Python 3, or to use Python 2 and 3 act differently\r\n* come up with a viable annotation strategy for python 2\r\n* plan to implement these annotations when we first need them (e.g. for tuples)\r\n"}