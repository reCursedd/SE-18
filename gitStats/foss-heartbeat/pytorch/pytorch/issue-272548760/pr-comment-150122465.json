{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/150122465", "pull_request_review_id": 75628266, "id": 150122465, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1MDEyMjQ2NQ==", "diff_hunk": "@@ -134,12 +156,9 @@ def _compile(arg):\n             # user passed in), this problem goes away, because the class\n             # __init__ is a part of is indeed Foo.\n \n-            # Make a copy of the class, with the extra _CompiledMixin base\n-            cls = type(arg.__name__, (_CompiledMixin,) + arg.__bases__, dict(arg.__dict__))\n-\n-            # Monkey-patch forward and __init__ with the compiler versions\n-            cls.init_compiler(**kwargs)\n-            return cls\n+            return type(arg.__name__,\n+                        (torch._six.with_metaclass(CompiledModuleMeta, *arg.__bases__),),", "path": "torch/jit/__init__.py", "position": 67, "original_position": 68, "commit_id": "f98292f85b7bceddb52a7e160cb94a9aef261cd2", "original_commit_id": "66aa44d2b1851587309961284cf2e5feaa37fed5", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "body": "So in Python, it's not like the class instantiates its objects by itself. Classes are regular instances themselves, and their classes are called _metaclasses_. So, just like the call operator for a regular object is implemented in its class, the call operator for a class (that you use to create objects) is implemented in its metaclass. Now, most objects have `type` as their metaclass, and the whole chain of calling `__new__`, then `__init__`, etc. is actually part of `__call__` method of `type`.\r\n\r\nI use a metaclass in here, because this allows me to override `__call__`, so I get to do all these modifications right before and after a call to `type.__call__` that actually allocates and initializes the newly created object.\r\n\r\n---\r\n\r\nAs a side note, you can also override `__init__` or `__new__` in your metaclass, and have these methods called every time someone subclasses your base class. We use this mechanism to do some magic in autograd when `torch.autograd.Function` is subclassed to create a custom op (e.g. that's when we create the `FnBackward` object that's not explicitly declared).", "created_at": "2017-11-09T23:57:28Z", "updated_at": "2018-11-23T15:36:19Z", "html_url": "https://github.com/pytorch/pytorch/pull/3597#discussion_r150122465", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/3597", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/150122465"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/3597#discussion_r150122465"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/3597"}}, "body_html": "<p>So in Python, it's not like the class instantiates its objects by itself. Classes are regular instances themselves, and their classes are called <em>metaclasses</em>. So, just like the call operator for a regular object is implemented in its class, the call operator for a class (that you use to create objects) is implemented in its metaclass. Now, most objects have <code>type</code> as their metaclass, and the whole chain of calling <code>__new__</code>, then <code>__init__</code>, etc. is actually part of <code>__call__</code> method of <code>type</code>.</p>\n<p>I use a metaclass in here, because this allows me to override <code>__call__</code>, so I get to do all these modifications right before and after a call to <code>type.__call__</code> that actually allocates and initializes the newly created object.</p>\n<hr>\n<p>As a side note, you can also override <code>__init__</code> or <code>__new__</code> in your metaclass, and have these methods called every time someone subclasses your base class. We use this mechanism to do some magic in autograd when <code>torch.autograd.Function</code> is subclassed to create a custom op (e.g. that's when we create the <code>FnBackward</code> object that's not explicitly declared).</p>", "body_text": "So in Python, it's not like the class instantiates its objects by itself. Classes are regular instances themselves, and their classes are called metaclasses. So, just like the call operator for a regular object is implemented in its class, the call operator for a class (that you use to create objects) is implemented in its metaclass. Now, most objects have type as their metaclass, and the whole chain of calling __new__, then __init__, etc. is actually part of __call__ method of type.\nI use a metaclass in here, because this allows me to override __call__, so I get to do all these modifications right before and after a call to type.__call__ that actually allocates and initializes the newly created object.\n\nAs a side note, you can also override __init__ or __new__ in your metaclass, and have these methods called every time someone subclasses your base class. We use this mechanism to do some magic in autograd when torch.autograd.Function is subclassed to create a custom op (e.g. that's when we create the FnBackward object that's not explicitly declared).", "in_reply_to_id": 150113579}