{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/405319653", "html_url": "https://github.com/pytorch/pytorch/pull/9281#issuecomment-405319653", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/9281", "id": 405319653, "node_id": "MDEyOklzc3VlQ29tbWVudDQwNTMxOTY1Mw==", "user": {"login": "gchanan", "id": 3768583, "node_id": "MDQ6VXNlcjM3Njg1ODM=", "avatar_url": "https://avatars2.githubusercontent.com/u/3768583?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gchanan", "html_url": "https://github.com/gchanan", "followers_url": "https://api.github.com/users/gchanan/followers", "following_url": "https://api.github.com/users/gchanan/following{/other_user}", "gists_url": "https://api.github.com/users/gchanan/gists{/gist_id}", "starred_url": "https://api.github.com/users/gchanan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gchanan/subscriptions", "organizations_url": "https://api.github.com/users/gchanan/orgs", "repos_url": "https://api.github.com/users/gchanan/repos", "events_url": "https://api.github.com/users/gchanan/events{/privacy}", "received_events_url": "https://api.github.com/users/gchanan/received_events", "type": "User", "site_admin": false}, "created_at": "2018-07-16T17:14:21Z", "updated_at": "2018-07-16T17:14:47Z", "author_association": "CONTRIBUTOR", "body_html": "<blockquote>\n<p>I agree with <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=4583066\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/apaszke\">@apaszke</a> on this. We shouldn\u2019t limit our much widely used<br>\nPython API by the constraint of c++, especially when the c++ API is much<br>\nless used, still experimental (i.e. c++ API can be changed much more easily<br>\nw/o considering BC), and already different with the Python API in many<br>\nways.</p>\n</blockquote>\n<p>I don't really see how the limitations of C++ forced us to adopt the <code>options</code> API except so far as it's not a kwarg argument.  We could implement <code>like</code> as an argument just as easily in C++ (again, with it lacking being a kwarg).</p>\n<blockquote>\n<p>Moreover, I don\u2019t think tensor.options() is clear either. For example, why<br>\nare strides, sizes, offsets, whether in pinned memory, requires_grad, etc.<br>\nnot considered as \u201coptions()\u201d?</p>\n</blockquote>\n<p>Because those are never included in the factory APIs (modulo requires_grad, and I'm not sure what the story is there, but IMO we shouldn't have requires_grad in any of the factory APIs anyway).  I.e. I'm imaging documentation such as:</p>\n<pre><code>ones(shape, *,  dtype, device, layout)\nones(shape, **options)\n</code></pre>\n<p>It's seems pretty clear options encapsulates the kwarg-only arguments.</p>\n<p>You could make the same argument for having a <code>like</code> kwarg-only arg except <code>like</code> usually includes the shape, so now you need to explain that <code>like</code> means different things in different contexts.</p>", "body_text": "I agree with @apaszke on this. We shouldn\u2019t limit our much widely used\nPython API by the constraint of c++, especially when the c++ API is much\nless used, still experimental (i.e. c++ API can be changed much more easily\nw/o considering BC), and already different with the Python API in many\nways.\n\nI don't really see how the limitations of C++ forced us to adopt the options API except so far as it's not a kwarg argument.  We could implement like as an argument just as easily in C++ (again, with it lacking being a kwarg).\n\nMoreover, I don\u2019t think tensor.options() is clear either. For example, why\nare strides, sizes, offsets, whether in pinned memory, requires_grad, etc.\nnot considered as \u201coptions()\u201d?\n\nBecause those are never included in the factory APIs (modulo requires_grad, and I'm not sure what the story is there, but IMO we shouldn't have requires_grad in any of the factory APIs anyway).  I.e. I'm imaging documentation such as:\nones(shape, *,  dtype, device, layout)\nones(shape, **options)\n\nIt's seems pretty clear options encapsulates the kwarg-only arguments.\nYou could make the same argument for having a like kwarg-only arg except like usually includes the shape, so now you need to explain that like means different things in different contexts.", "body": "> I agree with @apaszke on this. We shouldn\u2019t limit our much widely used\r\nPython API by the constraint of c++, especially when the c++ API is much\r\nless used, still experimental (i.e. c++ API can be changed much more easily\r\nw/o considering BC), and already different with the Python API in many\r\nways.\r\n\r\nI don't really see how the limitations of C++ forced us to adopt the `options` API except so far as it's not a kwarg argument.  We could implement `like` as an argument just as easily in C++ (again, with it lacking being a kwarg).\r\n\r\n> Moreover, I don\u2019t think tensor.options() is clear either. For example, why\r\nare strides, sizes, offsets, whether in pinned memory, requires_grad, etc.\r\nnot considered as \u201coptions()\u201d?\r\n\r\nBecause those are never included in the factory APIs (modulo requires_grad, and I'm not sure what the story is there, but IMO we shouldn't have requires_grad in any of the factory APIs anyway).  I.e. I'm imaging documentation such as:\r\n```\r\nones(shape, *,  dtype, device, layout)\r\nones(shape, **options)\r\n```\r\nIt's seems pretty clear options encapsulates the kwarg-only arguments.\r\n\r\nYou could make the same argument for having a `like` kwarg-only arg except `like` usually includes the shape, so now you need to explain that `like` means different things in different contexts."}