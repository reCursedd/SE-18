{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/405393764", "html_url": "https://github.com/pytorch/pytorch/pull/9281#issuecomment-405393764", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/9281", "id": 405393764, "node_id": "MDEyOklzc3VlQ29tbWVudDQwNTM5Mzc2NA==", "user": {"login": "SsnL", "id": 5674597, "node_id": "MDQ6VXNlcjU2NzQ1OTc=", "avatar_url": "https://avatars2.githubusercontent.com/u/5674597?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SsnL", "html_url": "https://github.com/SsnL", "followers_url": "https://api.github.com/users/SsnL/followers", "following_url": "https://api.github.com/users/SsnL/following{/other_user}", "gists_url": "https://api.github.com/users/SsnL/gists{/gist_id}", "starred_url": "https://api.github.com/users/SsnL/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SsnL/subscriptions", "organizations_url": "https://api.github.com/users/SsnL/orgs", "repos_url": "https://api.github.com/users/SsnL/repos", "events_url": "https://api.github.com/users/SsnL/events{/privacy}", "received_events_url": "https://api.github.com/users/SsnL/received_events", "type": "User", "site_admin": false}, "created_at": "2018-07-16T21:54:40Z", "updated_at": "2018-07-16T21:55:03Z", "author_association": "CONTRIBUTOR", "body_html": "<p>What I tried to say is that</p>\n<ol>\n<li><code>**t.options()</code> isn't more consistent.<br>\nIf we really want to be consistent, the Python API would be like <code>torch.randn((1, 2, 3), options=torch.TensorOptions(torch.cuda).dtype(torch.double))</code>. We should value Python API's conciseness and clarity over consistency with experimental C++ API any day.</li>\n<li><code>**t.options()</code> isn't clearer either.<br>\nAs you said, we would need to write the documentation clearly if we do this. However, didn't we decide against <code>new_*</code> because we want users to directly understand the code without being familiar with pytorch? If we want to assume that users have read the doc, why don't we just stick with the <code>new_*</code> variants, whose whole purpose is to preserve <code>dtype</code>, <code>device</code> and <code>layout</code>?</li>\n<li>Again, what's the use of <code>t.options()</code> as a public API if its use is pretty much only in kwarg expansion of tensor factory methods?</li>\n<li>\n<pre><code>ones(shape, *,  dtype, device, layout)\nones(shape, **options)\n</code></pre>\ndoesn't support overwriting <code>dtype</code>, <code>device</code> or <code>layout</code>.</li>\n</ol>\n<p>I'm not saying that additional kwargs like <code>as</code> or <code>like</code> is better. IMHO, they all require users to understand somewhat about Pytorch as they aren't immediately clear what is preserved and what is not. Given this, I still believe that <code>new_*</code> might just be better than these two because <code>new_*</code> is the existing mechanism that preserves <code>device</code>, <code>dtype</code>, and <code>layout</code> (and supporting overwriting), and is recommended in the doc and the migration guide.</p>", "body_text": "What I tried to say is that\n\n**t.options() isn't more consistent.\nIf we really want to be consistent, the Python API would be like torch.randn((1, 2, 3), options=torch.TensorOptions(torch.cuda).dtype(torch.double)). We should value Python API's conciseness and clarity over consistency with experimental C++ API any day.\n**t.options() isn't clearer either.\nAs you said, we would need to write the documentation clearly if we do this. However, didn't we decide against new_* because we want users to directly understand the code without being familiar with pytorch? If we want to assume that users have read the doc, why don't we just stick with the new_* variants, whose whole purpose is to preserve dtype, device and layout?\nAgain, what's the use of t.options() as a public API if its use is pretty much only in kwarg expansion of tensor factory methods?\n\nones(shape, *,  dtype, device, layout)\nones(shape, **options)\n\ndoesn't support overwriting dtype, device or layout.\n\nI'm not saying that additional kwargs like as or like is better. IMHO, they all require users to understand somewhat about Pytorch as they aren't immediately clear what is preserved and what is not. Given this, I still believe that new_* might just be better than these two because new_* is the existing mechanism that preserves device, dtype, and layout (and supporting overwriting), and is recommended in the doc and the migration guide.", "body": "What I tried to say is that\r\n1. `**t.options()` isn't more consistent. \r\n    If we really want to be consistent, the Python API would be like `torch.randn((1, 2, 3), options=torch.TensorOptions(torch.cuda).dtype(torch.double))`. We should value Python API's conciseness and clarity over consistency with experimental C++ API any day.\r\n2. `**t.options()` isn't clearer either. \r\n   As you said, we would need to write the documentation clearly if we do this. However, didn't we decide against `new_*` because we want users to directly understand the code without being familiar with pytorch? If we want to assume that users have read the doc, why don't we just stick with the `new_*` variants, whose whole purpose is to preserve `dtype`, `device` and `layout`?\r\n3. Again, what's the use of `t.options()` as a public API if its use is pretty much only in kwarg expansion of tensor factory methods? \r\n4.\r\n    ```\r\n    ones(shape, *,  dtype, device, layout)\r\n    ones(shape, **options)\r\n    ```\r\n    doesn't support overwriting `dtype`, `device` or `layout`.\r\n\r\nI'm not saying that additional kwargs like `as` or `like` is better. IMHO, they all require users to understand somewhat about Pytorch as they aren't immediately clear what is preserved and what is not. Given this, I still believe that `new_*` might just be better than these two because `new_*` is the existing mechanism that preserves `device`, `dtype`, and `layout` (and supporting overwriting), and is recommended in the doc and the migration guide."}