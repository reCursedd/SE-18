{"url": "https://api.github.com/repos/pytorch/pytorch/issues/5181", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/5181/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/5181/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/5181/events", "html_url": "https://github.com/pytorch/pytorch/issues/5181", "id": 296274907, "node_id": "MDU6SXNzdWUyOTYyNzQ5MDc=", "number": 5181, "title": "error: command 'gcc' failed with exit status 1", "user": {"login": "qieaaa", "id": 17093390, "node_id": "MDQ6VXNlcjE3MDkzMzkw", "avatar_url": "https://avatars1.githubusercontent.com/u/17093390?v=4", "gravatar_id": "", "url": "https://api.github.com/users/qieaaa", "html_url": "https://github.com/qieaaa", "followers_url": "https://api.github.com/users/qieaaa/followers", "following_url": "https://api.github.com/users/qieaaa/following{/other_user}", "gists_url": "https://api.github.com/users/qieaaa/gists{/gist_id}", "starred_url": "https://api.github.com/users/qieaaa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/qieaaa/subscriptions", "organizations_url": "https://api.github.com/users/qieaaa/orgs", "repos_url": "https://api.github.com/users/qieaaa/repos", "events_url": "https://api.github.com/users/qieaaa/events{/privacy}", "received_events_url": "https://api.github.com/users/qieaaa/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2018-02-12T06:07:49Z", "updated_at": "2018-02-12T18:34:56Z", "closed_at": null, "author_association": "NONE", "body_html": "<p>Hi I tried compiling from source,but it turns out <code>error: command 'gcc' failed with exit status 1</code></p>\n<ul>\n<li>OS: ubuntu 16.04lts</li>\n<li>PyTorch version: v0.3.0   <a class=\"commit-link\" data-hovercard-type=\"commit\" data-hovercard-url=\"https://github.com/pytorch/pytorch/commit/af3964a8725236c78ce969b827fdeee1c5c54110/hovercard\" href=\"https://github.com/pytorch/pytorch/commit/af3964a8725236c78ce969b827fdeee1c5c54110\"><tt>af3964a</tt></a></li>\n<li>How you installed PyTorch (conda, pip, source):source</li>\n<li>Python version: anaconda3.6</li>\n<li>CUDA/cuDNN version:CUDA9 cuDNN7</li>\n<li>GPU models and configuration: GTX1080</li>\n<li>GCC version (if compiling from source):gcc version 4.9.3 (Ubuntu 4.9.3-13ubuntu2)</li>\n</ul>\n<p>here is my compiling results</p>\n<p>-- Building with NumPy bindings<br>\n-- Detected cuDNN at /usr/local/cuda/lib64/libcudnn.so, /usr/local/cuda/include<br>\n-- Detected CUDA at /usr/local/cuda<br>\n-- Building NCCL library<br>\n-- Building with distributed package<br>\nWriting torch/csrc/generic/TensorMethods.cpp<br>\nWriting torch/csrc/autograd/generated/VariableType.h<br>\nWriting torch/csrc/autograd/generated/VariableType.cpp<br>\nWriting torch/csrc/autograd/generated/Functions.h<br>\nWriting torch/csrc/autograd/generated/Functions.cpp<br>\nWriting torch/csrc/autograd/generated/python_functions.h<br>\nWriting torch/csrc/autograd/generated/python_functions.cpp<br>\nWriting torch/csrc/autograd/generated/python_variable_methods.cpp<br>\nWriting torch/csrc/autograd/generated/python_variable_methods_dispatch.h<br>\nWriting torch/csrc/autograd/generated/python_torch_functions.cpp<br>\nWriting torch/csrc/autograd/generated/python_torch_functions_dispatch.h<br>\nWriting torch/csrc/autograd/generated/python_nn_functions.cpp<br>\nWriting torch/csrc/autograd/generated/python_nn_functions.h<br>\nWriting torch/csrc/autograd/generated/python_nn_functions_dispatch.h<br>\nWriting torch/csrc/jit/generated/aten_dispatch.h<br>\nWriting torch/csrc/jit/generated/aten_dispatch.cpp<br>\nbuilding 'torch._C' extension<br>\ncreating build/temp.linux-x86_64-3.5<br>\ncreating build/temp.linux-x86_64-3.5/torch<br>\ncreating build/temp.linux-x86_64-3.5/torch/csrc<br>\ncreating build/temp.linux-x86_64-3.5/torch/csrc/utils<br>\ncreating build/temp.linux-x86_64-3.5/torch/csrc/jit<br>\ncreating build/temp.linux-x86_64-3.5/torch/csrc/jit/passes<br>\ncreating build/temp.linux-x86_64-3.5/torch/csrc/jit/passes/onnx<br>\ncreating build/temp.linux-x86_64-3.5/torch/csrc/jit/generated<br>\ncreating build/temp.linux-x86_64-3.5/torch/csrc/jit/script<br>\ncreating build/temp.linux-x86_64-3.5/torch/csrc/autograd<br>\ncreating build/temp.linux-x86_64-3.5/torch/csrc/autograd/generated<br>\ncreating build/temp.linux-x86_64-3.5/torch/csrc/autograd/functions<br>\ncreating build/temp.linux-x86_64-3.5/torch/csrc/onnx<br>\ncreating build/temp.linux-x86_64-3.5/home<br>\ncreating build/temp.linux-x86_64-3.5/home/hzy<br>\ncreating build/temp.linux-x86_64-3.5/home/hzy/pytorch<br>\ncreating build/temp.linux-x86_64-3.5/home/hzy/pytorch/torch<br>\ncreating build/temp.linux-x86_64-3.5/home/hzy/pytorch/torch/csrc<br>\ncreating build/temp.linux-x86_64-3.5/home/hzy/pytorch/torch/csrc/generated<br>\ncreating build/temp.linux-x86_64-3.5/torch/csrc/distributed<br>\ncreating build/temp.linux-x86_64-3.5/torch/csrc/cuda<br>\ngcc -pthread -Wsign-compare -DNDEBUG -g -fwrapv -O3 -Wall -fPIC -I/usr/local/cuda/include -I/home/hzy/pytorch -I/home/hzy/pytorch/torch/csrc -I/home/hzy/pytorch/torch/lib/pybind11/include -I/home/hzy/pytorch/torch/lib/tmp_install/include -I/home/hzy/pytorch/torch/lib/tmp_install/include/TH -I/home/hzy/pytorch/torch/lib/tmp_install/include/THNN -I/home/hzy/pytorch/torch/lib/tmp_install/include/ATen -I/home/hzy/anaconda35/lib/python3.5/site-packages/numpy/core/include -I/home/hzy/pytorch/torch/lib/tmp_install/include/THD -I/usr/local/cuda/include -I/home/hzy/pytorch/torch/lib/tmp_install/include/THCUNN -I/home/hzy/anaconda35/include/python3.5m -c torch/csrc/PtrWrapper.cpp -o build/temp.linux-x86_64-3.5/torch/csrc/PtrWrapper.o -D_THP_CORE -std=c++11 -Wno-write-strings -fno-strict-aliasing -Wno-missing-braces -DWITH_NUMPY -DWITH_DISTRIBUTED -DWITH_CUDA -DCUDA_LIB_PATH=/usr/local/cuda/lib64 -DWITH_NCCL -DWITH_CUDNN -DWITH_SCALARS<br>\ngcc -pthread -Wsign-compare -DNDEBUG -g -fwrapv -O3 -Wall -fPIC -I/usr/local/cuda/include -I/home/hzy/pytorch -I/home/hzy/pytorch/torch/csrc -I/home/hzy/pytorch/torch/lib/pybind11/include -I/home/hzy/pytorch/torch/lib/tmp_install/include -I/home/hzy/pytorch/torch/lib/tmp_install/include/TH -I/home/hzy/pytorch/torch/lib/tmp_install/include/THNN -I/home/hzy/pytorch/torch/lib/tmp_install/include/ATen -I/home/hzy/anaconda35/lib/python3.5/site-packages/numpy/core/include -I/home/hzy/pytorch/torch/lib/tmp_install/include/THD -I/usr/local/cuda/include -I/home/hzy/pytorch/torch/lib/tmp_install/include/THCUNN -I/home/hzy/anaconda35/include/python3.5m -c torch/csrc/Exceptions.cpp -o build/temp.linux-x86_64-3.5/torch/csrc/Exceptions.o -D_THP_CORE -std=c++11 -Wno-write-strings -fno-strict-aliasing -Wno-missing-braces -DWITH_NUMPY -DWITH_DISTRIBUTED -DWITH_CUDA -DCUDA_LIB_PATH=/usr/local/cuda/lib64 -DWITH_NCCL -DWITH_CUDNN -DWITH_SCALARS<br>\n...</p>\n<p>and it just repeat for many times<br>\n<code>gcc -pthread -Wsign-compare -DNDEBUG -g -fwrapv -O3 -Wall -fPIC -I/usr/local/cuda/include -I/home/hzy/pytorch -I/home/hzy/pytorch/torch/csrc -I/home/hzy/pytorch/torch/lib/pybind11/include -I/home/hzy/pytorch/torch/lib/tmp_install/include -I/home/hzy/pytorch/torch/lib/tmp_install/include/TH -I/home/hzy/pytorch/torch/lib/tmp_install/include/THNN -I/home/hzy/pytorch/torch/lib/tmp_install/include/ATen -I/home/hzy/anaconda35/lib/python3.5/site-packages/numpy/core/include -I/home/hzy/pytorch/torch/lib/tmp_install/include/THD -I/usr/local/cuda/include -I/home/hzy/pytorch/torch/lib/tmp_install/include/THCUNN -I/home/hzy/anaconda35/include/python3.5m -c torch/csrc/autograd/init.cpp -o build/temp.linux-x86_64-3.5/torch/csrc/autograd/init.o -D_THP_CORE -std=c++11 -Wno-write-strings -fno-strict-aliasing -Wno-missing-braces -DWITH_NUMPY -DWITH_DISTRIBUTED -DWITH_CUDA -DCUDA_LIB_PATH=/usr/local/cuda/lib64 -DWITH_NCCL -DWITH_CUDNN -DWITH_SCALARS</code></p>\n<p>torch/csrc/jit/script/compiler.cpp:349:41: error: converting to \u2018const AttributeMap {aka const std::unordered_map&lt;std::basic_string, std::pair&lt;double, std::basic_string &gt; &gt;}\u2019 from initializer list would use explicit constructor \u2018std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::unordered_map(std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::size_type, const hasher&amp;, const key_equal&amp;, const allocator_type&amp;) [with _Key = std::basic_string; _Tp = std::pair&lt;double, std::basic_string &gt;; _Hash = std::hash&lt;std::basic_string &gt;; _Pred = std::equal_to&lt;std::basic_string &gt;; _Alloc = std::allocator&lt;std::pair&lt;const std::basic_string, std::pair&lt;double, std::basic_string &gt; &gt; &gt;; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::size_type = long unsigned int; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::hasher = std::hash&lt;std::basic_string &gt;; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::key_equal = std::equal_to&lt;std::basic_string &gt;; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::allocator_type = std::allocator&lt;std::pair&lt;const std::basic_string, std::pair&lt;double, std::basic_string &gt; &gt; &gt;]\u2019<br>\nconst AttributeMap&amp; attributes = {},<br>\n^<br>\ntorch/csrc/jit/script/compiler.cpp:350:50: error: converting to \u2018const ListAttributeMap {aka const std::unordered_map&lt;std::basic_string, std::pair&lt;const std::vector, std::basic_string &gt; &gt;}\u2019 from initializer list would use explicit constructor \u2018std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::unordered_map(std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::size_type, const hasher&amp;, const key_equal&amp;, const allocator_type&amp;) [with _Key = std::basic_string; _Tp = std::pair&lt;const std::vector, std::basic_string &gt;; _Hash = std::hash&lt;std::basic_string &gt;; _Pred = std::equal_to&lt;std::basic_string &gt;; _Alloc = std::allocator&lt;std::pair&lt;const std::basic_string, std::pair&lt;const std::vector, std::basic_string &gt; &gt; &gt;; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::size_type = long unsigned int; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::hasher = std::hash&lt;std::basic_string &gt;; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::key_equal = std::equal_to&lt;std::basic_string &gt;; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::allocator_type = std::allocator&lt;std::pair&lt;const std::basic_string, std::pair&lt;const std::vector, std::basic_string &gt; &gt; &gt;]\u2019<br>\nconst ListAttributeMap&amp; list_attributes = {}) {<br>\n^<br>\ntorch/csrc/jit/script/compiler.cpp: In member function \u2018std::vectortorch::jit::Value* torch::jit::script::to_ir::emitExpr(const TreeRef&amp;, size_t)\u2019:<br>\ntorch/csrc/jit/script/compiler.cpp:225:61: error: converting to \u2018const AttributeMap {aka const std::unordered_map&lt;std::basic_string, std::pair&lt;double, std::basic_string &gt; &gt;}\u2019 from initializer list would use explicit constructor \u2018std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::unordered_map(std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::size_type, const hasher&amp;, const key_equal&amp;, const allocator_type&amp;) [with _Key = std::basic_string; _Tp = std::pair&lt;double, std::basic_string &gt;; _Hash = std::hash&lt;std::basic_string &gt;; _Pred = std::equal_to&lt;std::basic_string &gt;; _Alloc = std::allocator&lt;std::pair&lt;const std::basic_string, std::pair&lt;double, std::basic_string &gt; &gt; &gt;; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::size_type = long unsigned int; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::hasher = std::hash&lt;std::basic_string &gt;; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::key_equal = std::equal_to&lt;std::basic_string &gt;; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::allocator_type = std::allocator&lt;std::pair&lt;const std::basic_string, std::pair&lt;double, std::basic_string &gt; &gt; &gt;]\u2019<br>\nreturn emitNode(kind, getValues(inputs), output_size)-&gt;outputs();<br>\n^<br>\ntorch/csrc/jit/script/compiler.cpp:345:9: note: in passing argument 4 of \u2018torch::jit::Node* torch::jit::script::to_ir::emitNode(torch::jit::NodeKind, std::vectortorch::jit::Value*, size_t, const AttributeMap&amp;, const ListAttributeMap&amp;)\u2019<br>\nNode* emitNode(<br>\n^<br>\ntorch/csrc/jit/script/compiler.cpp:225:61: error: converting to \u2018const ListAttributeMap {aka const std::unordered_map&lt;std::basic_string, std::pair&lt;const std::vector, std::basic_string &gt; &gt;}\u2019 from initializer list would use explicit constructor \u2018std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::unordered_map(std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::size_type, const hasher&amp;, const key_equal&amp;, const allocator_type&amp;) [with _Key = std::basic_string; _Tp = std::pair&lt;const std::vector, std::basic_string &gt;; _Hash = std::hash&lt;std::basic_string &gt;; _Pred = std::equal_to&lt;std::basic_string &gt;; _Alloc = std::allocator&lt;std::pair&lt;const std::basic_string, std::pair&lt;const std::vector, std::basic_string &gt; &gt; &gt;; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::size_type = long unsigned int; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::hasher = std::hash&lt;std::basic_string &gt;; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::key_equal = std::equal_to&lt;std::basic_string &gt;; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::allocator_type = std::allocator&lt;std::pair&lt;const std::basic_string, std::pair&lt;const std::vector, std::basic_string &gt; &gt; &gt;]\u2019<br>\nreturn emitNode(kind, getValues(inputs), output_size)-&gt;outputs();<br>\n^<br>\ntorch/csrc/jit/script/compiler.cpp:345:9: note: in passing argument 5 of \u2018torch::jit::Node* torch::jit::script::to_ir::emitNode(torch::jit::NodeKind, std::vectortorch::jit::Value*, size_t, const AttributeMap&amp;, const ListAttributeMap&amp;)\u2019<br>\nNode* emitNode(<br>\n^<br>\ntorch/csrc/jit/script/compiler.cpp:232:67: error: converting to \u2018const AttributeMap {aka const std::unordered_map&lt;std::basic_string, std::pair&lt;double, std::basic_string &gt; &gt;}\u2019 from initializer list would use explicit constructor \u2018std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::unordered_map(std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::size_type, const hasher&amp;, const key_equal&amp;, const allocator_type&amp;) [with _Key = std::basic_string; _Tp = std::pair&lt;double, std::basic_string &gt;; _Hash = std::hash&lt;std::basic_string &gt;; _Pred = std::equal_to&lt;std::basic_string &gt;; _Alloc = std::allocator&lt;std::pair&lt;const std::basic_string, std::pair&lt;double, std::basic_string &gt; &gt; &gt;; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::size_type = long unsigned int; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::hasher = std::hash&lt;std::basic_string &gt;; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::key_equal = std::equal_to&lt;std::basic_string &gt;; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::allocator_type = std::allocator&lt;std::pair&lt;const std::basic_string, std::pair&lt;double, std::basic_string &gt; &gt; &gt;]\u2019<br>\nauto* node = emitNode(kind, getValues(inputs), output_size);<br>\n^<br>\ntorch/csrc/jit/script/compiler.cpp:345:9: note: in passing argument 4 of \u2018torch::jit::Node* torch::jit::script::to_ir::emitNode(torch::jit::NodeKind, std::vectortorch::jit::Value*, size_t, const AttributeMap&amp;, const ListAttributeMap&amp;)\u2019<br>\nNode* emitNode(<br>\n^<br>\ntorch/csrc/jit/script/compiler.cpp:232:67: error: converting to \u2018const ListAttributeMap {aka const std::unordered_map&lt;std::basic_string, std::pair&lt;const std::vector, std::basic_string &gt; &gt;}\u2019 from initializer list would use explicit constructor \u2018std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::unordered_map(std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::size_type, const hasher&amp;, const key_equal&amp;, const allocator_type&amp;) [with _Key = std::basic_string; _Tp = std::pair&lt;const std::vector, std::basic_string &gt;; _Hash = std::hash&lt;std::basic_string &gt;; _Pred = std::equal_to&lt;std::basic_string &gt;; _Alloc = std::allocator&lt;std::pair&lt;const std::basic_string, std::pair&lt;const std::vector, std::basic_string &gt; &gt; &gt;; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::size_type = long unsigned int; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::hasher = std::hash&lt;std::basic_string &gt;; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::key_equal = std::equal_to&lt;std::basic_string &gt;; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::allocator_type = std::allocator&lt;std::pair&lt;const std::basic_string, std::pair&lt;const std::vector, std::basic_string &gt; &gt; &gt;]\u2019<br>\nauto* node = emitNode(kind, getValues(inputs), output_size);<br>\n^<br>\ntorch/csrc/jit/script/compiler.cpp:345:9: note: in passing argument 5 of \u2018torch::jit::Node* torch::jit::script::to_ir::emitNode(torch::jit::NodeKind, std::vectortorch::jit::Value*, size_t, const AttributeMap&amp;, const ListAttributeMap&amp;)\u2019<br>\nNode* emitNode(<br>\n^<br>\ntorch/csrc/jit/script/compiler.cpp: In member function \u2018std::vectortorch::jit::Value* torch::jit::script::to_ir::emitCast(const TreeRef&amp;, const torch::jit::script::ScalarType&amp;)\u2019:<br>\ntorch/csrc/jit/script/compiler.cpp:327:17: error: converting to \u2018const AttributeMap {aka const std::unordered_map&lt;std::basic_string, std::pair&lt;double, std::basic_string &gt; &gt;}\u2019 from initializer list would use explicit constructor \u2018std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::unordered_map(std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::size_type, const hasher&amp;, const key_equal&amp;, const allocator_type&amp;) [with _Key = std::basic_string; _Tp = std::pair&lt;double, std::basic_string &gt;; _Hash = std::hash&lt;std::basic_string &gt;; _Pred = std::equal_to&lt;std::basic_string &gt;; _Alloc = std::allocator&lt;std::pair&lt;const std::basic_string, std::pair&lt;double, std::basic_string &gt; &gt; &gt;; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::size_type = long unsigned int; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::hasher = std::hash&lt;std::basic_string &gt;; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::key_equal = std::equal_to&lt;std::basic_string &gt;; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::allocator_type = std::allocator&lt;std::pair&lt;const std::basic_string, std::pair&lt;double, std::basic_string &gt; &gt; &gt;]\u2019<br>\n1)<br>\n^<br>\ntorch/csrc/jit/script/compiler.cpp:345:9: note: in passing argument 4 of \u2018torch::jit::Node* torch::jit::script::to_ir::emitNode(torch::jit::NodeKind, std::vectortorch::jit::Value*, size_t, const AttributeMap&amp;, const ListAttributeMap&amp;)\u2019<br>\nNode* emitNode(<br>\n^<br>\ntorch/csrc/jit/script/compiler.cpp:327:17: error: converting to \u2018const ListAttributeMap {aka const std::unordered_map&lt;std::basic_string, std::pair&lt;const std::vector, std::basic_string &gt; &gt;}\u2019 from initializer list would use explicit constructor \u2018std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::unordered_map(std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::size_type, const hasher&amp;, const key_equal&amp;, const allocator_type&amp;) [with _Key = std::basic_string; _Tp = std::pair&lt;const std::vector, std::basic_string &gt;; _Hash = std::hash&lt;std::basic_string &gt;; _Pred = std::equal_to&lt;std::basic_string &gt;; _Alloc = std::allocator&lt;std::pair&lt;const std::basic_string, std::pair&lt;const std::vector, std::basic_string &gt; &gt; &gt;; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::size_type = long unsigned int; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::hasher = std::hash&lt;std::basic_string &gt;; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::key_equal = std::equal_to&lt;std::basic_string &gt;; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::allocator_type = std::allocator&lt;std::pair&lt;const std::basic_string, std::pair&lt;const std::vector, std::basic_string &gt; &gt; &gt;]\u2019<br>\n1)<br>\n^<br>\ntorch/csrc/jit/script/compiler.cpp:345:9: note: in passing argument 5 of \u2018torch::jit::Node* torch::jit::script::to_ir::emitNode(torch::jit::NodeKind, std::vectortorch::jit::Value*, size_t, const AttributeMap&amp;, const ListAttributeMap&amp;)\u2019<br>\nNode* emitNode(<br>\n^<br>\ntorch/csrc/jit/script/compiler.cpp: In member function \u2018std::vectortorch::jit::Value* torch::jit::script::to_ir::emitSlice(const torch::jit::script::SourceRange&amp;, torch::jit::script::TreeList&amp;&amp;, size_t)\u2019:<br>\ntorch/csrc/jit/script/compiler.cpp:397:38: error: converting to \u2018const ListAttributeMap {aka const std::unordered_map&lt;std::basic_string, std::pair&lt;const std::vector, std::basic_string &gt; &gt;}\u2019 from initializer list would use explicit constructor \u2018std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::unordered_map(std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::size_type, const hasher&amp;, const key_equal&amp;, const allocator_type&amp;) [with _Key = std::basic_string; _Tp = std::pair&lt;const std::vector, std::basic_string &gt;; _Hash = std::hash&lt;std::basic_string &gt;; _Pred = std::equal_to&lt;std::basic_string &gt;; _Alloc = std::allocator&lt;std::pair&lt;const std::basic_string, std::pair&lt;const std::vector, std::basic_string &gt; &gt; &gt;; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::size_type = long unsigned int; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::hasher = std::hash&lt;std::basic_string &gt;; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::key_equal = std::equal_to&lt;std::basic_string &gt;; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::allocator_type = std::allocator&lt;std::pair&lt;const std::basic_string, std::pair&lt;const std::vector, std::basic_string &gt; &gt; &gt;]\u2019<br>\n{\"end\", {end, \"LL\"}}})<br>\n^<br>\ntorch/csrc/jit/script/compiler.cpp:345:9: note: in passing argument 5 of \u2018torch::jit::Node* torch::jit::script::to_ir::emitNode(torch::jit::NodeKind, std::vectortorch::jit::Value*, size_t, const AttributeMap&amp;, const ListAttributeMap&amp;)\u2019<br>\nNode* emitNode(<br>\n^<br>\ntorch/csrc/jit/script/compiler.cpp: In member function \u2018std::vectortorch::jit::Value* torch::jit::script::to_ir::emitGather(const torch::jit::script::SourceRange&amp;, torch::jit::script::TreeList&amp;&amp;, size_t)\u2019:<br>\ntorch/csrc/jit/script/compiler.cpp:415:60: error: converting to \u2018const ListAttributeMap {aka const std::unordered_map&lt;std::basic_string, std::pair&lt;const std::vector, std::basic_string &gt; &gt;}\u2019 from initializer list would use explicit constructor \u2018std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::unordered_map(std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::size_type, const hasher&amp;, const key_equal&amp;, const allocator_type&amp;) [with _Key = std::basic_string; _Tp = std::pair&lt;const std::vector, std::basic_string &gt;; _Hash = std::hash&lt;std::basic_string &gt;; _Pred = std::equal_to&lt;std::basic_string &gt;; _Alloc = std::allocator&lt;std::pair&lt;const std::basic_string, std::pair&lt;const std::vector, std::basic_string &gt; &gt; &gt;; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::size_type = long unsigned int; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::hasher = std::hash&lt;std::basic_string &gt;; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::key_equal = std::equal_to&lt;std::basic_string &gt;; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::allocator_type = std::allocator&lt;std::pair&lt;const std::basic_string, std::pair&lt;const std::vector, std::basic_string &gt; &gt; &gt;]\u2019<br>\n{{\"dim\", {0, \"LL\"}}, {\"index\", {idx, \"LL\"}}})<br>\n^<br>\ntorch/csrc/jit/script/compiler.cpp:345:9: note: in passing argument 5 of \u2018torch::jit::Node* torch::jit::script::to_ir::emitNode(torch::jit::NodeKind, std::vectortorch::jit::Value*, size_t, const AttributeMap&amp;, const ListAttributeMap&amp;)\u2019<br>\nNode* emitNode(<br>\n^<br>\ngcc -pthread -Wsign-compare -DNDEBUG -g -fwrapv -O3 -Wall -fPIC -I/usr/local/cuda/include -I/home/hzy/pytorch -I/home/hzy/pytorch/torch/csrc -I/home/hzy/pytorch/torch/lib/pybind11/include -I/home/hzy/pytorch/torch/lib/tmp_install/include -I/home/hzy/pytorch/torch/lib/tmp_install/include/TH -I/home/hzy/pytorch/torch/lib/tmp_install/include/THNN -I/home/hzy/pytorch/torch/lib/tmp_install/include/ATen -I/home/hzy/anaconda35/lib/python3.5/site-packages/numpy/core/include -I/home/hzy/pytorch/torch/lib/tmp_install/include/THD -I/usr/local/cuda/include -I/home/hzy/pytorch/torch/lib/tmp_install/include/THCUNN -I/home/hzy/anaconda35/include/python3.5m -c /home/hzy/pytorch/torch/csrc/generated/cuda_TensorChar.cpp -o build/temp.linux-x86_64-3.5/home/hzy/pytorch/torch/csrc/generated/cuda_TensorChar.o -D_THP_CORE -std=c++11 -Wno-write-strings -fno-strict-aliasing -Wno-missing-braces -DWITH_NUMPY -DWITH_DISTRIBUTED -DWITH_CUDA -DCUDA_LIB_PATH=/usr/local/cuda/lib64 -DWITH_NCCL -DWITH_CUDNN -DWITH_SCALARS<br>\nerror: command 'gcc' failed with exit status 1</p>\n<p>I find a issue which fixed by update cuDNN, but I think my cuDNN7 is enough for compiling. thanks</p>", "body_text": "Hi I tried compiling from source,but it turns out error: command 'gcc' failed with exit status 1\n\nOS: ubuntu 16.04lts\nPyTorch version: v0.3.0   af3964a\nHow you installed PyTorch (conda, pip, source):source\nPython version: anaconda3.6\nCUDA/cuDNN version:CUDA9 cuDNN7\nGPU models and configuration: GTX1080\nGCC version (if compiling from source):gcc version 4.9.3 (Ubuntu 4.9.3-13ubuntu2)\n\nhere is my compiling results\n-- Building with NumPy bindings\n-- Detected cuDNN at /usr/local/cuda/lib64/libcudnn.so, /usr/local/cuda/include\n-- Detected CUDA at /usr/local/cuda\n-- Building NCCL library\n-- Building with distributed package\nWriting torch/csrc/generic/TensorMethods.cpp\nWriting torch/csrc/autograd/generated/VariableType.h\nWriting torch/csrc/autograd/generated/VariableType.cpp\nWriting torch/csrc/autograd/generated/Functions.h\nWriting torch/csrc/autograd/generated/Functions.cpp\nWriting torch/csrc/autograd/generated/python_functions.h\nWriting torch/csrc/autograd/generated/python_functions.cpp\nWriting torch/csrc/autograd/generated/python_variable_methods.cpp\nWriting torch/csrc/autograd/generated/python_variable_methods_dispatch.h\nWriting torch/csrc/autograd/generated/python_torch_functions.cpp\nWriting torch/csrc/autograd/generated/python_torch_functions_dispatch.h\nWriting torch/csrc/autograd/generated/python_nn_functions.cpp\nWriting torch/csrc/autograd/generated/python_nn_functions.h\nWriting torch/csrc/autograd/generated/python_nn_functions_dispatch.h\nWriting torch/csrc/jit/generated/aten_dispatch.h\nWriting torch/csrc/jit/generated/aten_dispatch.cpp\nbuilding 'torch._C' extension\ncreating build/temp.linux-x86_64-3.5\ncreating build/temp.linux-x86_64-3.5/torch\ncreating build/temp.linux-x86_64-3.5/torch/csrc\ncreating build/temp.linux-x86_64-3.5/torch/csrc/utils\ncreating build/temp.linux-x86_64-3.5/torch/csrc/jit\ncreating build/temp.linux-x86_64-3.5/torch/csrc/jit/passes\ncreating build/temp.linux-x86_64-3.5/torch/csrc/jit/passes/onnx\ncreating build/temp.linux-x86_64-3.5/torch/csrc/jit/generated\ncreating build/temp.linux-x86_64-3.5/torch/csrc/jit/script\ncreating build/temp.linux-x86_64-3.5/torch/csrc/autograd\ncreating build/temp.linux-x86_64-3.5/torch/csrc/autograd/generated\ncreating build/temp.linux-x86_64-3.5/torch/csrc/autograd/functions\ncreating build/temp.linux-x86_64-3.5/torch/csrc/onnx\ncreating build/temp.linux-x86_64-3.5/home\ncreating build/temp.linux-x86_64-3.5/home/hzy\ncreating build/temp.linux-x86_64-3.5/home/hzy/pytorch\ncreating build/temp.linux-x86_64-3.5/home/hzy/pytorch/torch\ncreating build/temp.linux-x86_64-3.5/home/hzy/pytorch/torch/csrc\ncreating build/temp.linux-x86_64-3.5/home/hzy/pytorch/torch/csrc/generated\ncreating build/temp.linux-x86_64-3.5/torch/csrc/distributed\ncreating build/temp.linux-x86_64-3.5/torch/csrc/cuda\ngcc -pthread -Wsign-compare -DNDEBUG -g -fwrapv -O3 -Wall -fPIC -I/usr/local/cuda/include -I/home/hzy/pytorch -I/home/hzy/pytorch/torch/csrc -I/home/hzy/pytorch/torch/lib/pybind11/include -I/home/hzy/pytorch/torch/lib/tmp_install/include -I/home/hzy/pytorch/torch/lib/tmp_install/include/TH -I/home/hzy/pytorch/torch/lib/tmp_install/include/THNN -I/home/hzy/pytorch/torch/lib/tmp_install/include/ATen -I/home/hzy/anaconda35/lib/python3.5/site-packages/numpy/core/include -I/home/hzy/pytorch/torch/lib/tmp_install/include/THD -I/usr/local/cuda/include -I/home/hzy/pytorch/torch/lib/tmp_install/include/THCUNN -I/home/hzy/anaconda35/include/python3.5m -c torch/csrc/PtrWrapper.cpp -o build/temp.linux-x86_64-3.5/torch/csrc/PtrWrapper.o -D_THP_CORE -std=c++11 -Wno-write-strings -fno-strict-aliasing -Wno-missing-braces -DWITH_NUMPY -DWITH_DISTRIBUTED -DWITH_CUDA -DCUDA_LIB_PATH=/usr/local/cuda/lib64 -DWITH_NCCL -DWITH_CUDNN -DWITH_SCALARS\ngcc -pthread -Wsign-compare -DNDEBUG -g -fwrapv -O3 -Wall -fPIC -I/usr/local/cuda/include -I/home/hzy/pytorch -I/home/hzy/pytorch/torch/csrc -I/home/hzy/pytorch/torch/lib/pybind11/include -I/home/hzy/pytorch/torch/lib/tmp_install/include -I/home/hzy/pytorch/torch/lib/tmp_install/include/TH -I/home/hzy/pytorch/torch/lib/tmp_install/include/THNN -I/home/hzy/pytorch/torch/lib/tmp_install/include/ATen -I/home/hzy/anaconda35/lib/python3.5/site-packages/numpy/core/include -I/home/hzy/pytorch/torch/lib/tmp_install/include/THD -I/usr/local/cuda/include -I/home/hzy/pytorch/torch/lib/tmp_install/include/THCUNN -I/home/hzy/anaconda35/include/python3.5m -c torch/csrc/Exceptions.cpp -o build/temp.linux-x86_64-3.5/torch/csrc/Exceptions.o -D_THP_CORE -std=c++11 -Wno-write-strings -fno-strict-aliasing -Wno-missing-braces -DWITH_NUMPY -DWITH_DISTRIBUTED -DWITH_CUDA -DCUDA_LIB_PATH=/usr/local/cuda/lib64 -DWITH_NCCL -DWITH_CUDNN -DWITH_SCALARS\n...\nand it just repeat for many times\ngcc -pthread -Wsign-compare -DNDEBUG -g -fwrapv -O3 -Wall -fPIC -I/usr/local/cuda/include -I/home/hzy/pytorch -I/home/hzy/pytorch/torch/csrc -I/home/hzy/pytorch/torch/lib/pybind11/include -I/home/hzy/pytorch/torch/lib/tmp_install/include -I/home/hzy/pytorch/torch/lib/tmp_install/include/TH -I/home/hzy/pytorch/torch/lib/tmp_install/include/THNN -I/home/hzy/pytorch/torch/lib/tmp_install/include/ATen -I/home/hzy/anaconda35/lib/python3.5/site-packages/numpy/core/include -I/home/hzy/pytorch/torch/lib/tmp_install/include/THD -I/usr/local/cuda/include -I/home/hzy/pytorch/torch/lib/tmp_install/include/THCUNN -I/home/hzy/anaconda35/include/python3.5m -c torch/csrc/autograd/init.cpp -o build/temp.linux-x86_64-3.5/torch/csrc/autograd/init.o -D_THP_CORE -std=c++11 -Wno-write-strings -fno-strict-aliasing -Wno-missing-braces -DWITH_NUMPY -DWITH_DISTRIBUTED -DWITH_CUDA -DCUDA_LIB_PATH=/usr/local/cuda/lib64 -DWITH_NCCL -DWITH_CUDNN -DWITH_SCALARS\ntorch/csrc/jit/script/compiler.cpp:349:41: error: converting to \u2018const AttributeMap {aka const std::unordered_map<std::basic_string, std::pair<double, std::basic_string > >}\u2019 from initializer list would use explicit constructor \u2018std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type, const hasher&, const key_equal&, const allocator_type&) [with _Key = std::basic_string; _Tp = std::pair<double, std::basic_string >; _Hash = std::hash<std::basic_string >; _Pred = std::equal_to<std::basic_string >; _Alloc = std::allocator<std::pair<const std::basic_string, std::pair<double, std::basic_string > > >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type = long unsigned int; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::hasher = std::hash<std::basic_string >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::key_equal = std::equal_to<std::basic_string >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::allocator_type = std::allocator<std::pair<const std::basic_string, std::pair<double, std::basic_string > > >]\u2019\nconst AttributeMap& attributes = {},\n^\ntorch/csrc/jit/script/compiler.cpp:350:50: error: converting to \u2018const ListAttributeMap {aka const std::unordered_map<std::basic_string, std::pair<const std::vector, std::basic_string > >}\u2019 from initializer list would use explicit constructor \u2018std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type, const hasher&, const key_equal&, const allocator_type&) [with _Key = std::basic_string; _Tp = std::pair<const std::vector, std::basic_string >; _Hash = std::hash<std::basic_string >; _Pred = std::equal_to<std::basic_string >; _Alloc = std::allocator<std::pair<const std::basic_string, std::pair<const std::vector, std::basic_string > > >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type = long unsigned int; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::hasher = std::hash<std::basic_string >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::key_equal = std::equal_to<std::basic_string >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::allocator_type = std::allocator<std::pair<const std::basic_string, std::pair<const std::vector, std::basic_string > > >]\u2019\nconst ListAttributeMap& list_attributes = {}) {\n^\ntorch/csrc/jit/script/compiler.cpp: In member function \u2018std::vectortorch::jit::Value* torch::jit::script::to_ir::emitExpr(const TreeRef&, size_t)\u2019:\ntorch/csrc/jit/script/compiler.cpp:225:61: error: converting to \u2018const AttributeMap {aka const std::unordered_map<std::basic_string, std::pair<double, std::basic_string > >}\u2019 from initializer list would use explicit constructor \u2018std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type, const hasher&, const key_equal&, const allocator_type&) [with _Key = std::basic_string; _Tp = std::pair<double, std::basic_string >; _Hash = std::hash<std::basic_string >; _Pred = std::equal_to<std::basic_string >; _Alloc = std::allocator<std::pair<const std::basic_string, std::pair<double, std::basic_string > > >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type = long unsigned int; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::hasher = std::hash<std::basic_string >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::key_equal = std::equal_to<std::basic_string >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::allocator_type = std::allocator<std::pair<const std::basic_string, std::pair<double, std::basic_string > > >]\u2019\nreturn emitNode(kind, getValues(inputs), output_size)->outputs();\n^\ntorch/csrc/jit/script/compiler.cpp:345:9: note: in passing argument 4 of \u2018torch::jit::Node* torch::jit::script::to_ir::emitNode(torch::jit::NodeKind, std::vectortorch::jit::Value*, size_t, const AttributeMap&, const ListAttributeMap&)\u2019\nNode* emitNode(\n^\ntorch/csrc/jit/script/compiler.cpp:225:61: error: converting to \u2018const ListAttributeMap {aka const std::unordered_map<std::basic_string, std::pair<const std::vector, std::basic_string > >}\u2019 from initializer list would use explicit constructor \u2018std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type, const hasher&, const key_equal&, const allocator_type&) [with _Key = std::basic_string; _Tp = std::pair<const std::vector, std::basic_string >; _Hash = std::hash<std::basic_string >; _Pred = std::equal_to<std::basic_string >; _Alloc = std::allocator<std::pair<const std::basic_string, std::pair<const std::vector, std::basic_string > > >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type = long unsigned int; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::hasher = std::hash<std::basic_string >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::key_equal = std::equal_to<std::basic_string >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::allocator_type = std::allocator<std::pair<const std::basic_string, std::pair<const std::vector, std::basic_string > > >]\u2019\nreturn emitNode(kind, getValues(inputs), output_size)->outputs();\n^\ntorch/csrc/jit/script/compiler.cpp:345:9: note: in passing argument 5 of \u2018torch::jit::Node* torch::jit::script::to_ir::emitNode(torch::jit::NodeKind, std::vectortorch::jit::Value*, size_t, const AttributeMap&, const ListAttributeMap&)\u2019\nNode* emitNode(\n^\ntorch/csrc/jit/script/compiler.cpp:232:67: error: converting to \u2018const AttributeMap {aka const std::unordered_map<std::basic_string, std::pair<double, std::basic_string > >}\u2019 from initializer list would use explicit constructor \u2018std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type, const hasher&, const key_equal&, const allocator_type&) [with _Key = std::basic_string; _Tp = std::pair<double, std::basic_string >; _Hash = std::hash<std::basic_string >; _Pred = std::equal_to<std::basic_string >; _Alloc = std::allocator<std::pair<const std::basic_string, std::pair<double, std::basic_string > > >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type = long unsigned int; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::hasher = std::hash<std::basic_string >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::key_equal = std::equal_to<std::basic_string >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::allocator_type = std::allocator<std::pair<const std::basic_string, std::pair<double, std::basic_string > > >]\u2019\nauto* node = emitNode(kind, getValues(inputs), output_size);\n^\ntorch/csrc/jit/script/compiler.cpp:345:9: note: in passing argument 4 of \u2018torch::jit::Node* torch::jit::script::to_ir::emitNode(torch::jit::NodeKind, std::vectortorch::jit::Value*, size_t, const AttributeMap&, const ListAttributeMap&)\u2019\nNode* emitNode(\n^\ntorch/csrc/jit/script/compiler.cpp:232:67: error: converting to \u2018const ListAttributeMap {aka const std::unordered_map<std::basic_string, std::pair<const std::vector, std::basic_string > >}\u2019 from initializer list would use explicit constructor \u2018std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type, const hasher&, const key_equal&, const allocator_type&) [with _Key = std::basic_string; _Tp = std::pair<const std::vector, std::basic_string >; _Hash = std::hash<std::basic_string >; _Pred = std::equal_to<std::basic_string >; _Alloc = std::allocator<std::pair<const std::basic_string, std::pair<const std::vector, std::basic_string > > >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type = long unsigned int; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::hasher = std::hash<std::basic_string >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::key_equal = std::equal_to<std::basic_string >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::allocator_type = std::allocator<std::pair<const std::basic_string, std::pair<const std::vector, std::basic_string > > >]\u2019\nauto* node = emitNode(kind, getValues(inputs), output_size);\n^\ntorch/csrc/jit/script/compiler.cpp:345:9: note: in passing argument 5 of \u2018torch::jit::Node* torch::jit::script::to_ir::emitNode(torch::jit::NodeKind, std::vectortorch::jit::Value*, size_t, const AttributeMap&, const ListAttributeMap&)\u2019\nNode* emitNode(\n^\ntorch/csrc/jit/script/compiler.cpp: In member function \u2018std::vectortorch::jit::Value* torch::jit::script::to_ir::emitCast(const TreeRef&, const torch::jit::script::ScalarType&)\u2019:\ntorch/csrc/jit/script/compiler.cpp:327:17: error: converting to \u2018const AttributeMap {aka const std::unordered_map<std::basic_string, std::pair<double, std::basic_string > >}\u2019 from initializer list would use explicit constructor \u2018std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type, const hasher&, const key_equal&, const allocator_type&) [with _Key = std::basic_string; _Tp = std::pair<double, std::basic_string >; _Hash = std::hash<std::basic_string >; _Pred = std::equal_to<std::basic_string >; _Alloc = std::allocator<std::pair<const std::basic_string, std::pair<double, std::basic_string > > >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type = long unsigned int; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::hasher = std::hash<std::basic_string >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::key_equal = std::equal_to<std::basic_string >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::allocator_type = std::allocator<std::pair<const std::basic_string, std::pair<double, std::basic_string > > >]\u2019\n1)\n^\ntorch/csrc/jit/script/compiler.cpp:345:9: note: in passing argument 4 of \u2018torch::jit::Node* torch::jit::script::to_ir::emitNode(torch::jit::NodeKind, std::vectortorch::jit::Value*, size_t, const AttributeMap&, const ListAttributeMap&)\u2019\nNode* emitNode(\n^\ntorch/csrc/jit/script/compiler.cpp:327:17: error: converting to \u2018const ListAttributeMap {aka const std::unordered_map<std::basic_string, std::pair<const std::vector, std::basic_string > >}\u2019 from initializer list would use explicit constructor \u2018std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type, const hasher&, const key_equal&, const allocator_type&) [with _Key = std::basic_string; _Tp = std::pair<const std::vector, std::basic_string >; _Hash = std::hash<std::basic_string >; _Pred = std::equal_to<std::basic_string >; _Alloc = std::allocator<std::pair<const std::basic_string, std::pair<const std::vector, std::basic_string > > >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type = long unsigned int; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::hasher = std::hash<std::basic_string >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::key_equal = std::equal_to<std::basic_string >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::allocator_type = std::allocator<std::pair<const std::basic_string, std::pair<const std::vector, std::basic_string > > >]\u2019\n1)\n^\ntorch/csrc/jit/script/compiler.cpp:345:9: note: in passing argument 5 of \u2018torch::jit::Node* torch::jit::script::to_ir::emitNode(torch::jit::NodeKind, std::vectortorch::jit::Value*, size_t, const AttributeMap&, const ListAttributeMap&)\u2019\nNode* emitNode(\n^\ntorch/csrc/jit/script/compiler.cpp: In member function \u2018std::vectortorch::jit::Value* torch::jit::script::to_ir::emitSlice(const torch::jit::script::SourceRange&, torch::jit::script::TreeList&&, size_t)\u2019:\ntorch/csrc/jit/script/compiler.cpp:397:38: error: converting to \u2018const ListAttributeMap {aka const std::unordered_map<std::basic_string, std::pair<const std::vector, std::basic_string > >}\u2019 from initializer list would use explicit constructor \u2018std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type, const hasher&, const key_equal&, const allocator_type&) [with _Key = std::basic_string; _Tp = std::pair<const std::vector, std::basic_string >; _Hash = std::hash<std::basic_string >; _Pred = std::equal_to<std::basic_string >; _Alloc = std::allocator<std::pair<const std::basic_string, std::pair<const std::vector, std::basic_string > > >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type = long unsigned int; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::hasher = std::hash<std::basic_string >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::key_equal = std::equal_to<std::basic_string >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::allocator_type = std::allocator<std::pair<const std::basic_string, std::pair<const std::vector, std::basic_string > > >]\u2019\n{\"end\", {end, \"LL\"}}})\n^\ntorch/csrc/jit/script/compiler.cpp:345:9: note: in passing argument 5 of \u2018torch::jit::Node* torch::jit::script::to_ir::emitNode(torch::jit::NodeKind, std::vectortorch::jit::Value*, size_t, const AttributeMap&, const ListAttributeMap&)\u2019\nNode* emitNode(\n^\ntorch/csrc/jit/script/compiler.cpp: In member function \u2018std::vectortorch::jit::Value* torch::jit::script::to_ir::emitGather(const torch::jit::script::SourceRange&, torch::jit::script::TreeList&&, size_t)\u2019:\ntorch/csrc/jit/script/compiler.cpp:415:60: error: converting to \u2018const ListAttributeMap {aka const std::unordered_map<std::basic_string, std::pair<const std::vector, std::basic_string > >}\u2019 from initializer list would use explicit constructor \u2018std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type, const hasher&, const key_equal&, const allocator_type&) [with _Key = std::basic_string; _Tp = std::pair<const std::vector, std::basic_string >; _Hash = std::hash<std::basic_string >; _Pred = std::equal_to<std::basic_string >; _Alloc = std::allocator<std::pair<const std::basic_string, std::pair<const std::vector, std::basic_string > > >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type = long unsigned int; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::hasher = std::hash<std::basic_string >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::key_equal = std::equal_to<std::basic_string >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::allocator_type = std::allocator<std::pair<const std::basic_string, std::pair<const std::vector, std::basic_string > > >]\u2019\n{{\"dim\", {0, \"LL\"}}, {\"index\", {idx, \"LL\"}}})\n^\ntorch/csrc/jit/script/compiler.cpp:345:9: note: in passing argument 5 of \u2018torch::jit::Node* torch::jit::script::to_ir::emitNode(torch::jit::NodeKind, std::vectortorch::jit::Value*, size_t, const AttributeMap&, const ListAttributeMap&)\u2019\nNode* emitNode(\n^\ngcc -pthread -Wsign-compare -DNDEBUG -g -fwrapv -O3 -Wall -fPIC -I/usr/local/cuda/include -I/home/hzy/pytorch -I/home/hzy/pytorch/torch/csrc -I/home/hzy/pytorch/torch/lib/pybind11/include -I/home/hzy/pytorch/torch/lib/tmp_install/include -I/home/hzy/pytorch/torch/lib/tmp_install/include/TH -I/home/hzy/pytorch/torch/lib/tmp_install/include/THNN -I/home/hzy/pytorch/torch/lib/tmp_install/include/ATen -I/home/hzy/anaconda35/lib/python3.5/site-packages/numpy/core/include -I/home/hzy/pytorch/torch/lib/tmp_install/include/THD -I/usr/local/cuda/include -I/home/hzy/pytorch/torch/lib/tmp_install/include/THCUNN -I/home/hzy/anaconda35/include/python3.5m -c /home/hzy/pytorch/torch/csrc/generated/cuda_TensorChar.cpp -o build/temp.linux-x86_64-3.5/home/hzy/pytorch/torch/csrc/generated/cuda_TensorChar.o -D_THP_CORE -std=c++11 -Wno-write-strings -fno-strict-aliasing -Wno-missing-braces -DWITH_NUMPY -DWITH_DISTRIBUTED -DWITH_CUDA -DCUDA_LIB_PATH=/usr/local/cuda/lib64 -DWITH_NCCL -DWITH_CUDNN -DWITH_SCALARS\nerror: command 'gcc' failed with exit status 1\nI find a issue which fixed by update cuDNN, but I think my cuDNN7 is enough for compiling. thanks", "body": "\r\nHi I tried compiling from source,but it turns out `error: command 'gcc' failed with exit status 1`\r\n\r\n- OS: ubuntu 16.04lts\r\n- PyTorch version: v0.3.0   af3964a\r\n- How you installed PyTorch (conda, pip, source):source\r\n- Python version: anaconda3.6\r\n- CUDA/cuDNN version:CUDA9 cuDNN7\r\n- GPU models and configuration: GTX1080 \r\n- GCC version (if compiling from source):gcc version 4.9.3 (Ubuntu 4.9.3-13ubuntu2) \r\n\r\n\r\nhere is my compiling results\r\n\r\n-- Building with NumPy bindings\r\n-- Detected cuDNN at /usr/local/cuda/lib64/libcudnn.so, /usr/local/cuda/include\r\n-- Detected CUDA at /usr/local/cuda\r\n-- Building NCCL library\r\n-- Building with distributed package \r\nWriting torch/csrc/generic/TensorMethods.cpp\r\nWriting torch/csrc/autograd/generated/VariableType.h\r\nWriting torch/csrc/autograd/generated/VariableType.cpp\r\nWriting torch/csrc/autograd/generated/Functions.h\r\nWriting torch/csrc/autograd/generated/Functions.cpp\r\nWriting torch/csrc/autograd/generated/python_functions.h\r\nWriting torch/csrc/autograd/generated/python_functions.cpp\r\nWriting torch/csrc/autograd/generated/python_variable_methods.cpp\r\nWriting torch/csrc/autograd/generated/python_variable_methods_dispatch.h\r\nWriting torch/csrc/autograd/generated/python_torch_functions.cpp\r\nWriting torch/csrc/autograd/generated/python_torch_functions_dispatch.h\r\nWriting torch/csrc/autograd/generated/python_nn_functions.cpp\r\nWriting torch/csrc/autograd/generated/python_nn_functions.h\r\nWriting torch/csrc/autograd/generated/python_nn_functions_dispatch.h\r\nWriting torch/csrc/jit/generated/aten_dispatch.h\r\nWriting torch/csrc/jit/generated/aten_dispatch.cpp\r\nbuilding 'torch._C' extension\r\ncreating build/temp.linux-x86_64-3.5\r\ncreating build/temp.linux-x86_64-3.5/torch\r\ncreating build/temp.linux-x86_64-3.5/torch/csrc\r\ncreating build/temp.linux-x86_64-3.5/torch/csrc/utils\r\ncreating build/temp.linux-x86_64-3.5/torch/csrc/jit\r\ncreating build/temp.linux-x86_64-3.5/torch/csrc/jit/passes\r\ncreating build/temp.linux-x86_64-3.5/torch/csrc/jit/passes/onnx\r\ncreating build/temp.linux-x86_64-3.5/torch/csrc/jit/generated\r\ncreating build/temp.linux-x86_64-3.5/torch/csrc/jit/script\r\ncreating build/temp.linux-x86_64-3.5/torch/csrc/autograd\r\ncreating build/temp.linux-x86_64-3.5/torch/csrc/autograd/generated\r\ncreating build/temp.linux-x86_64-3.5/torch/csrc/autograd/functions\r\ncreating build/temp.linux-x86_64-3.5/torch/csrc/onnx\r\ncreating build/temp.linux-x86_64-3.5/home\r\ncreating build/temp.linux-x86_64-3.5/home/hzy\r\ncreating build/temp.linux-x86_64-3.5/home/hzy/pytorch\r\ncreating build/temp.linux-x86_64-3.5/home/hzy/pytorch/torch\r\ncreating build/temp.linux-x86_64-3.5/home/hzy/pytorch/torch/csrc\r\ncreating build/temp.linux-x86_64-3.5/home/hzy/pytorch/torch/csrc/generated\r\ncreating build/temp.linux-x86_64-3.5/torch/csrc/distributed\r\ncreating build/temp.linux-x86_64-3.5/torch/csrc/cuda\r\ngcc -pthread -Wsign-compare -DNDEBUG -g -fwrapv -O3 -Wall -fPIC -I/usr/local/cuda/include -I/home/hzy/pytorch -I/home/hzy/pytorch/torch/csrc -I/home/hzy/pytorch/torch/lib/pybind11/include -I/home/hzy/pytorch/torch/lib/tmp_install/include -I/home/hzy/pytorch/torch/lib/tmp_install/include/TH -I/home/hzy/pytorch/torch/lib/tmp_install/include/THNN -I/home/hzy/pytorch/torch/lib/tmp_install/include/ATen -I/home/hzy/anaconda35/lib/python3.5/site-packages/numpy/core/include -I/home/hzy/pytorch/torch/lib/tmp_install/include/THD -I/usr/local/cuda/include -I/home/hzy/pytorch/torch/lib/tmp_install/include/THCUNN -I/home/hzy/anaconda35/include/python3.5m -c torch/csrc/PtrWrapper.cpp -o build/temp.linux-x86_64-3.5/torch/csrc/PtrWrapper.o -D_THP_CORE -std=c++11 -Wno-write-strings -fno-strict-aliasing -Wno-missing-braces -DWITH_NUMPY -DWITH_DISTRIBUTED -DWITH_CUDA -DCUDA_LIB_PATH=/usr/local/cuda/lib64 -DWITH_NCCL -DWITH_CUDNN -DWITH_SCALARS\r\ngcc -pthread -Wsign-compare -DNDEBUG -g -fwrapv -O3 -Wall -fPIC -I/usr/local/cuda/include -I/home/hzy/pytorch -I/home/hzy/pytorch/torch/csrc -I/home/hzy/pytorch/torch/lib/pybind11/include -I/home/hzy/pytorch/torch/lib/tmp_install/include -I/home/hzy/pytorch/torch/lib/tmp_install/include/TH -I/home/hzy/pytorch/torch/lib/tmp_install/include/THNN -I/home/hzy/pytorch/torch/lib/tmp_install/include/ATen -I/home/hzy/anaconda35/lib/python3.5/site-packages/numpy/core/include -I/home/hzy/pytorch/torch/lib/tmp_install/include/THD -I/usr/local/cuda/include -I/home/hzy/pytorch/torch/lib/tmp_install/include/THCUNN -I/home/hzy/anaconda35/include/python3.5m -c torch/csrc/Exceptions.cpp -o build/temp.linux-x86_64-3.5/torch/csrc/Exceptions.o -D_THP_CORE -std=c++11 -Wno-write-strings -fno-strict-aliasing -Wno-missing-braces -DWITH_NUMPY -DWITH_DISTRIBUTED -DWITH_CUDA -DCUDA_LIB_PATH=/usr/local/cuda/lib64 -DWITH_NCCL -DWITH_CUDNN -DWITH_SCALARS\r\n...\r\n\r\nand it just repeat for many times\r\n`gcc -pthread -Wsign-compare -DNDEBUG -g -fwrapv -O3 -Wall -fPIC -I/usr/local/cuda/include -I/home/hzy/pytorch -I/home/hzy/pytorch/torch/csrc -I/home/hzy/pytorch/torch/lib/pybind11/include -I/home/hzy/pytorch/torch/lib/tmp_install/include -I/home/hzy/pytorch/torch/lib/tmp_install/include/TH -I/home/hzy/pytorch/torch/lib/tmp_install/include/THNN -I/home/hzy/pytorch/torch/lib/tmp_install/include/ATen -I/home/hzy/anaconda35/lib/python3.5/site-packages/numpy/core/include -I/home/hzy/pytorch/torch/lib/tmp_install/include/THD -I/usr/local/cuda/include -I/home/hzy/pytorch/torch/lib/tmp_install/include/THCUNN -I/home/hzy/anaconda35/include/python3.5m -c torch/csrc/autograd/init.cpp -o build/temp.linux-x86_64-3.5/torch/csrc/autograd/init.o -D_THP_CORE -std=c++11 -Wno-write-strings -fno-strict-aliasing -Wno-missing-braces -DWITH_NUMPY -DWITH_DISTRIBUTED -DWITH_CUDA -DCUDA_LIB_PATH=/usr/local/cuda/lib64 -DWITH_NCCL -DWITH_CUDNN -DWITH_SCALARS`\r\n\r\n\r\ntorch/csrc/jit/script/compiler.cpp:349:41: error: converting to \u2018const AttributeMap {aka const std::unordered_map<std::basic_string<char>, std::pair<double, std::basic_string<char> > >}\u2019 from initializer list would use explicit constructor \u2018std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type, const hasher&, const key_equal&, const allocator_type&) [with _Key = std::basic_string<char>; _Tp = std::pair<double, std::basic_string<char> >; _Hash = std::hash<std::basic_string<char> >; _Pred = std::equal_to<std::basic_string<char> >; _Alloc = std::allocator<std::pair<const std::basic_string<char>, std::pair<double, std::basic_string<char> > > >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type = long unsigned int; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::hasher = std::hash<std::basic_string<char> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::key_equal = std::equal_to<std::basic_string<char> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::allocator_type = std::allocator<std::pair<const std::basic_string<char>, std::pair<double, std::basic_string<char> > > >]\u2019\r\n       const AttributeMap& attributes = {},\r\n                                         ^\r\ntorch/csrc/jit/script/compiler.cpp:350:50: error: converting to \u2018const ListAttributeMap {aka const std::unordered_map<std::basic_string<char>, std::pair<const std::vector<double>, std::basic_string<char> > >}\u2019 from initializer list would use explicit constructor \u2018std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type, const hasher&, const key_equal&, const allocator_type&) [with _Key = std::basic_string<char>; _Tp = std::pair<const std::vector<double>, std::basic_string<char> >; _Hash = std::hash<std::basic_string<char> >; _Pred = std::equal_to<std::basic_string<char> >; _Alloc = std::allocator<std::pair<const std::basic_string<char>, std::pair<const std::vector<double>, std::basic_string<char> > > >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type = long unsigned int; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::hasher = std::hash<std::basic_string<char> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::key_equal = std::equal_to<std::basic_string<char> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::allocator_type = std::allocator<std::pair<const std::basic_string<char>, std::pair<const std::vector<double>, std::basic_string<char> > > >]\u2019\r\n       const ListAttributeMap& list_attributes = {}) {\r\n                                                  ^\r\ntorch/csrc/jit/script/compiler.cpp: In member function \u2018std::vector<torch::jit::Value*> torch::jit::script::to_ir::emitExpr(const TreeRef&, size_t)\u2019:\r\ntorch/csrc/jit/script/compiler.cpp:225:61: error: converting to \u2018const AttributeMap {aka const std::unordered_map<std::basic_string<char>, std::pair<double, std::basic_string<char> > >}\u2019 from initializer list would use explicit constructor \u2018std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type, const hasher&, const key_equal&, const allocator_type&) [with _Key = std::basic_string<char>; _Tp = std::pair<double, std::basic_string<char> >; _Hash = std::hash<std::basic_string<char> >; _Pred = std::equal_to<std::basic_string<char> >; _Alloc = std::allocator<std::pair<const std::basic_string<char>, std::pair<double, std::basic_string<char> > > >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type = long unsigned int; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::hasher = std::hash<std::basic_string<char> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::key_equal = std::equal_to<std::basic_string<char> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::allocator_type = std::allocator<std::pair<const std::basic_string<char>, std::pair<double, std::basic_string<char> > > >]\u2019\r\n         return emitNode(kind, getValues(inputs), output_size)->outputs();\r\n                                                             ^\r\ntorch/csrc/jit/script/compiler.cpp:345:9: note: in passing argument 4 of \u2018torch::jit::Node* torch::jit::script::to_ir::emitNode(torch::jit::NodeKind, std::vector<torch::jit::Value*>, size_t, const AttributeMap&, const ListAttributeMap&)\u2019\r\n   Node* emitNode(\r\n         ^\r\ntorch/csrc/jit/script/compiler.cpp:225:61: error: converting to \u2018const ListAttributeMap {aka const std::unordered_map<std::basic_string<char>, std::pair<const std::vector<double>, std::basic_string<char> > >}\u2019 from initializer list would use explicit constructor \u2018std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type, const hasher&, const key_equal&, const allocator_type&) [with _Key = std::basic_string<char>; _Tp = std::pair<const std::vector<double>, std::basic_string<char> >; _Hash = std::hash<std::basic_string<char> >; _Pred = std::equal_to<std::basic_string<char> >; _Alloc = std::allocator<std::pair<const std::basic_string<char>, std::pair<const std::vector<double>, std::basic_string<char> > > >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type = long unsigned int; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::hasher = std::hash<std::basic_string<char> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::key_equal = std::equal_to<std::basic_string<char> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::allocator_type = std::allocator<std::pair<const std::basic_string<char>, std::pair<const std::vector<double>, std::basic_string<char> > > >]\u2019\r\n         return emitNode(kind, getValues(inputs), output_size)->outputs();\r\n                                                             ^\r\ntorch/csrc/jit/script/compiler.cpp:345:9: note: in passing argument 5 of \u2018torch::jit::Node* torch::jit::script::to_ir::emitNode(torch::jit::NodeKind, std::vector<torch::jit::Value*>, size_t, const AttributeMap&, const ListAttributeMap&)\u2019\r\n   Node* emitNode(\r\n         ^\r\ntorch/csrc/jit/script/compiler.cpp:232:67: error: converting to \u2018const AttributeMap {aka const std::unordered_map<std::basic_string<char>, std::pair<double, std::basic_string<char> > >}\u2019 from initializer list would use explicit constructor \u2018std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type, const hasher&, const key_equal&, const allocator_type&) [with _Key = std::basic_string<char>; _Tp = std::pair<double, std::basic_string<char> >; _Hash = std::hash<std::basic_string<char> >; _Pred = std::equal_to<std::basic_string<char> >; _Alloc = std::allocator<std::pair<const std::basic_string<char>, std::pair<double, std::basic_string<char> > > >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type = long unsigned int; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::hasher = std::hash<std::basic_string<char> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::key_equal = std::equal_to<std::basic_string<char> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::allocator_type = std::allocator<std::pair<const std::basic_string<char>, std::pair<double, std::basic_string<char> > > >]\u2019\r\n         auto* node = emitNode(kind, getValues(inputs), output_size);\r\n                                                                   ^\r\ntorch/csrc/jit/script/compiler.cpp:345:9: note: in passing argument 4 of \u2018torch::jit::Node* torch::jit::script::to_ir::emitNode(torch::jit::NodeKind, std::vector<torch::jit::Value*>, size_t, const AttributeMap&, const ListAttributeMap&)\u2019\r\n   Node* emitNode(\r\n         ^\r\ntorch/csrc/jit/script/compiler.cpp:232:67: error: converting to \u2018const ListAttributeMap {aka const std::unordered_map<std::basic_string<char>, std::pair<const std::vector<double>, std::basic_string<char> > >}\u2019 from initializer list would use explicit constructor \u2018std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type, const hasher&, const key_equal&, const allocator_type&) [with _Key = std::basic_string<char>; _Tp = std::pair<const std::vector<double>, std::basic_string<char> >; _Hash = std::hash<std::basic_string<char> >; _Pred = std::equal_to<std::basic_string<char> >; _Alloc = std::allocator<std::pair<const std::basic_string<char>, std::pair<const std::vector<double>, std::basic_string<char> > > >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type = long unsigned int; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::hasher = std::hash<std::basic_string<char> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::key_equal = std::equal_to<std::basic_string<char> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::allocator_type = std::allocator<std::pair<const std::basic_string<char>, std::pair<const std::vector<double>, std::basic_string<char> > > >]\u2019\r\n         auto* node = emitNode(kind, getValues(inputs), output_size);\r\n                                                                   ^\r\ntorch/csrc/jit/script/compiler.cpp:345:9: note: in passing argument 5 of \u2018torch::jit::Node* torch::jit::script::to_ir::emitNode(torch::jit::NodeKind, std::vector<torch::jit::Value*>, size_t, const AttributeMap&, const ListAttributeMap&)\u2019\r\n   Node* emitNode(\r\n         ^\r\ntorch/csrc/jit/script/compiler.cpp: In member function \u2018std::vector<torch::jit::Value*> torch::jit::script::to_ir::emitCast(const TreeRef&, const torch::jit::script::ScalarType&)\u2019:\r\ntorch/csrc/jit/script/compiler.cpp:327:17: error: converting to \u2018const AttributeMap {aka const std::unordered_map<std::basic_string<char>, std::pair<double, std::basic_string<char> > >}\u2019 from initializer list would use explicit constructor \u2018std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type, const hasher&, const key_equal&, const allocator_type&) [with _Key = std::basic_string<char>; _Tp = std::pair<double, std::basic_string<char> >; _Hash = std::hash<std::basic_string<char> >; _Pred = std::equal_to<std::basic_string<char> >; _Alloc = std::allocator<std::pair<const std::basic_string<char>, std::pair<double, std::basic_string<char> > > >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type = long unsigned int; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::hasher = std::hash<std::basic_string<char> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::key_equal = std::equal_to<std::basic_string<char> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::allocator_type = std::allocator<std::pair<const std::basic_string<char>, std::pair<double, std::basic_string<char> > > >]\u2019\r\n                1)\r\n                 ^\r\ntorch/csrc/jit/script/compiler.cpp:345:9: note: in passing argument 4 of \u2018torch::jit::Node* torch::jit::script::to_ir::emitNode(torch::jit::NodeKind, std::vector<torch::jit::Value*>, size_t, const AttributeMap&, const ListAttributeMap&)\u2019\r\n   Node* emitNode(\r\n         ^\r\ntorch/csrc/jit/script/compiler.cpp:327:17: error: converting to \u2018const ListAttributeMap {aka const std::unordered_map<std::basic_string<char>, std::pair<const std::vector<double>, std::basic_string<char> > >}\u2019 from initializer list would use explicit constructor \u2018std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type, const hasher&, const key_equal&, const allocator_type&) [with _Key = std::basic_string<char>; _Tp = std::pair<const std::vector<double>, std::basic_string<char> >; _Hash = std::hash<std::basic_string<char> >; _Pred = std::equal_to<std::basic_string<char> >; _Alloc = std::allocator<std::pair<const std::basic_string<char>, std::pair<const std::vector<double>, std::basic_string<char> > > >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type = long unsigned int; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::hasher = std::hash<std::basic_string<char> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::key_equal = std::equal_to<std::basic_string<char> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::allocator_type = std::allocator<std::pair<const std::basic_string<char>, std::pair<const std::vector<double>, std::basic_string<char> > > >]\u2019\r\n                1)\r\n                 ^\r\ntorch/csrc/jit/script/compiler.cpp:345:9: note: in passing argument 5 of \u2018torch::jit::Node* torch::jit::script::to_ir::emitNode(torch::jit::NodeKind, std::vector<torch::jit::Value*>, size_t, const AttributeMap&, const ListAttributeMap&)\u2019\r\n   Node* emitNode(\r\n         ^\r\ntorch/csrc/jit/script/compiler.cpp: In member function \u2018std::vector<torch::jit::Value*> torch::jit::script::to_ir::emitSlice(const torch::jit::script::SourceRange&, torch::jit::script::TreeList&&, size_t)\u2019:\r\ntorch/csrc/jit/script/compiler.cpp:397:38: error: converting to \u2018const ListAttributeMap {aka const std::unordered_map<std::basic_string<char>, std::pair<const std::vector<double>, std::basic_string<char> > >}\u2019 from initializer list would use explicit constructor \u2018std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type, const hasher&, const key_equal&, const allocator_type&) [with _Key = std::basic_string<char>; _Tp = std::pair<const std::vector<double>, std::basic_string<char> >; _Hash = std::hash<std::basic_string<char> >; _Pred = std::equal_to<std::basic_string<char> >; _Alloc = std::allocator<std::pair<const std::basic_string<char>, std::pair<const std::vector<double>, std::basic_string<char> > > >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type = long unsigned int; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::hasher = std::hash<std::basic_string<char> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::key_equal = std::equal_to<std::basic_string<char> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::allocator_type = std::allocator<std::pair<const std::basic_string<char>, std::pair<const std::vector<double>, std::basic_string<char> > > >]\u2019\r\n                 {\"end\", {end, \"LL\"}}})\r\n                                      ^\r\ntorch/csrc/jit/script/compiler.cpp:345:9: note: in passing argument 5 of \u2018torch::jit::Node* torch::jit::script::to_ir::emitNode(torch::jit::NodeKind, std::vector<torch::jit::Value*>, size_t, const AttributeMap&, const ListAttributeMap&)\u2019\r\n   Node* emitNode(\r\n         ^\r\ntorch/csrc/jit/script/compiler.cpp: In member function \u2018std::vector<torch::jit::Value*> torch::jit::script::to_ir::emitGather(const torch::jit::script::SourceRange&, torch::jit::script::TreeList&&, size_t)\u2019:\r\ntorch/csrc/jit/script/compiler.cpp:415:60: error: converting to \u2018const ListAttributeMap {aka const std::unordered_map<std::basic_string<char>, std::pair<const std::vector<double>, std::basic_string<char> > >}\u2019 from initializer list would use explicit constructor \u2018std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type, const hasher&, const key_equal&, const allocator_type&) [with _Key = std::basic_string<char>; _Tp = std::pair<const std::vector<double>, std::basic_string<char> >; _Hash = std::hash<std::basic_string<char> >; _Pred = std::equal_to<std::basic_string<char> >; _Alloc = std::allocator<std::pair<const std::basic_string<char>, std::pair<const std::vector<double>, std::basic_string<char> > > >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::size_type = long unsigned int; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::hasher = std::hash<std::basic_string<char> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::key_equal = std::equal_to<std::basic_string<char> >; std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::allocator_type = std::allocator<std::pair<const std::basic_string<char>, std::pair<const std::vector<double>, std::basic_string<char> > > >]\u2019\r\n                {{\"dim\", {0, \"LL\"}}, {\"index\", {idx, \"LL\"}}})\r\n                                                            ^\r\ntorch/csrc/jit/script/compiler.cpp:345:9: note: in passing argument 5 of \u2018torch::jit::Node* torch::jit::script::to_ir::emitNode(torch::jit::NodeKind, std::vector<torch::jit::Value*>, size_t, const AttributeMap&, const ListAttributeMap&)\u2019\r\n   Node* emitNode(\r\n         ^\r\ngcc -pthread -Wsign-compare -DNDEBUG -g -fwrapv -O3 -Wall -fPIC -I/usr/local/cuda/include -I/home/hzy/pytorch -I/home/hzy/pytorch/torch/csrc -I/home/hzy/pytorch/torch/lib/pybind11/include -I/home/hzy/pytorch/torch/lib/tmp_install/include -I/home/hzy/pytorch/torch/lib/tmp_install/include/TH -I/home/hzy/pytorch/torch/lib/tmp_install/include/THNN -I/home/hzy/pytorch/torch/lib/tmp_install/include/ATen -I/home/hzy/anaconda35/lib/python3.5/site-packages/numpy/core/include -I/home/hzy/pytorch/torch/lib/tmp_install/include/THD -I/usr/local/cuda/include -I/home/hzy/pytorch/torch/lib/tmp_install/include/THCUNN -I/home/hzy/anaconda35/include/python3.5m -c /home/hzy/pytorch/torch/csrc/generated/cuda_TensorChar.cpp -o build/temp.linux-x86_64-3.5/home/hzy/pytorch/torch/csrc/generated/cuda_TensorChar.o -D_THP_CORE -std=c++11 -Wno-write-strings -fno-strict-aliasing -Wno-missing-braces -DWITH_NUMPY -DWITH_DISTRIBUTED -DWITH_CUDA -DCUDA_LIB_PATH=/usr/local/cuda/lib64 -DWITH_NCCL -DWITH_CUDNN -DWITH_SCALARS\r\nerror: command 'gcc' failed with exit status 1\r\n\r\nI find a issue which fixed by update cuDNN, but I think my cuDNN7 is enough for compiling. thanks \r\n"}