{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/214759450", "pull_request_review_id": 151878403, "id": 214759450, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDc1OTQ1MA==", "diff_hunk": "@@ -142,7 +142,7 @@ bitonicSortKVInPlace(TensorInfo<K, IndexType> keys,\n                      IndexType keySliceStride,\n                      TensorInfo<V, IndexType> values,\n                      IndexType valueSliceStride,\n-                     const Comparator& comp) {\n+                     const Comparator comp) {", "path": "aten/src/THC/THCSortUtils.cuh", "position": null, "original_position": 5, "commit_id": "9853dbc715b973e03111420524f3727c024e2d50", "original_commit_id": "83d7d529dd33d80ccfa6b3c770ee37fe70a02c0e", "user": {"login": "iotamudelta", "id": 12565466, "node_id": "MDQ6VXNlcjEyNTY1NDY2", "avatar_url": "https://avatars2.githubusercontent.com/u/12565466?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iotamudelta", "html_url": "https://github.com/iotamudelta", "followers_url": "https://api.github.com/users/iotamudelta/followers", "following_url": "https://api.github.com/users/iotamudelta/following{/other_user}", "gists_url": "https://api.github.com/users/iotamudelta/gists{/gist_id}", "starred_url": "https://api.github.com/users/iotamudelta/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iotamudelta/subscriptions", "organizations_url": "https://api.github.com/users/iotamudelta/orgs", "repos_url": "https://api.github.com/users/iotamudelta/repos", "events_url": "https://api.github.com/users/iotamudelta/events{/privacy}", "received_events_url": "https://api.github.com/users/iotamudelta/received_events", "type": "User", "site_admin": false}, "body": "1. The ambiguity only affects `__global__` functions. E.g., if Comparator is a value of some ClosureType at point of call - what is the accelerator side referring to? If it would be a copy of the value, it would break the identity of the address. The original value will only work if you have HMM in this instance.\r\n2. This is theoretically only true for C++98 (but compilers did optimize this case), since C++11 passing by value is efficient. The comparators all seem either empty or have a scalar member (if not, we'd be interested to see them). However, there will be a copy - either explicitly like now or through the ambiguity outlined above. The copying of `__global__` function arguments will anyways take place for both CUDA and ROCm in the respective runtimes. They need to be available and efficient to access for the accelerator. See F.3.9.3 Function Parameters: \"__global__ function parameters are passed to the device via constant memory and are limited to 4 KB\". Lastly, there are lifetime concerns - if you truly passed by reference, your callable must live for the entire execution duration of the kernel and you must ensure that even though, e.g., a lambda would die at the end of the full expression.\r\n\r\nNone of the above are relevant for `__device__` functions, since those do not cross a host-accelerator boundary, and argument marshalling does not imply hidden runtime magic.", "created_at": "2018-09-03T22:25:07Z", "updated_at": "2018-11-23T15:50:33Z", "html_url": "https://github.com/pytorch/pytorch/pull/11198#discussion_r214759450", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/11198", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/214759450"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/11198#discussion_r214759450"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/11198"}}, "body_html": "<ol>\n<li>The ambiguity only affects <code>__global__</code> functions. E.g., if Comparator is a value of some ClosureType at point of call - what is the accelerator side referring to? If it would be a copy of the value, it would break the identity of the address. The original value will only work if you have HMM in this instance.</li>\n<li>This is theoretically only true for C++98 (but compilers did optimize this case), since C++11 passing by value is efficient. The comparators all seem either empty or have a scalar member (if not, we'd be interested to see them). However, there will be a copy - either explicitly like now or through the ambiguity outlined above. The copying of <code>__global__</code> function arguments will anyways take place for both CUDA and ROCm in the respective runtimes. They need to be available and efficient to access for the accelerator. See F.3.9.3 Function Parameters: \"<strong>global</strong> function parameters are passed to the device via constant memory and are limited to 4 KB\". Lastly, there are lifetime concerns - if you truly passed by reference, your callable must live for the entire execution duration of the kernel and you must ensure that even though, e.g., a lambda would die at the end of the full expression.</li>\n</ol>\n<p>None of the above are relevant for <code>__device__</code> functions, since those do not cross a host-accelerator boundary, and argument marshalling does not imply hidden runtime magic.</p>", "body_text": "The ambiguity only affects __global__ functions. E.g., if Comparator is a value of some ClosureType at point of call - what is the accelerator side referring to? If it would be a copy of the value, it would break the identity of the address. The original value will only work if you have HMM in this instance.\nThis is theoretically only true for C++98 (but compilers did optimize this case), since C++11 passing by value is efficient. The comparators all seem either empty or have a scalar member (if not, we'd be interested to see them). However, there will be a copy - either explicitly like now or through the ambiguity outlined above. The copying of __global__ function arguments will anyways take place for both CUDA and ROCm in the respective runtimes. They need to be available and efficient to access for the accelerator. See F.3.9.3 Function Parameters: \"global function parameters are passed to the device via constant memory and are limited to 4 KB\". Lastly, there are lifetime concerns - if you truly passed by reference, your callable must live for the entire execution duration of the kernel and you must ensure that even though, e.g., a lambda would die at the end of the full expression.\n\nNone of the above are relevant for __device__ functions, since those do not cross a host-accelerator boundary, and argument marshalling does not imply hidden runtime magic.", "in_reply_to_id": 214754338}