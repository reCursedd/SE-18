{"url": "https://api.github.com/repos/pytorch/pytorch/issues/5647", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/5647/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/5647/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/5647/events", "html_url": "https://github.com/pytorch/pytorch/pull/5647", "id": 303623607, "node_id": "MDExOlB1bGxSZXF1ZXN0MTczODQ0MjIx", "number": 5647, "title": "Fix binary operations with scalars", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2018-03-08T20:39:15Z", "updated_at": "2018-11-23T15:40:32Z", "closed_at": "2018-03-14T18:39:08Z", "author_association": "MEMBER", "pull_request": {"url": "https://api.github.com/repos/pytorch/pytorch/pulls/5647", "html_url": "https://github.com/pytorch/pytorch/pull/5647", "diff_url": "https://github.com/pytorch/pytorch/pull/5647.diff", "patch_url": "https://github.com/pytorch/pytorch/pull/5647.patch"}, "body_html": "<p>If you have a double scalar and float tensor, then we currently allow doing <code>tensor + scalar</code> (and correctly cast the scalar), while <code>scalar + tensor</code> fails and complains that the types don't match. This commit also unifies ATen C++ operators with Python operators to make sure that they will always have the same semantics (this is useful in the JIT too).</p>\n<p>There's a bit of awkwardness when dealing with these situations because we generally want to treat scalars as tensors in autograd (to record their history), but we want 0d tensors to behave like scalars in ATen (to allow implicit type casts). I've played with it for a while, but it's hard to disentangle them and come up with a good solution.</p>", "body_text": "If you have a double scalar and float tensor, then we currently allow doing tensor + scalar (and correctly cast the scalar), while scalar + tensor fails and complains that the types don't match. This commit also unifies ATen C++ operators with Python operators to make sure that they will always have the same semantics (this is useful in the JIT too).\nThere's a bit of awkwardness when dealing with these situations because we generally want to treat scalars as tensors in autograd (to record their history), but we want 0d tensors to behave like scalars in ATen (to allow implicit type casts). I've played with it for a while, but it's hard to disentangle them and come up with a good solution.", "body": "If you have a double scalar and float tensor, then we currently allow doing `tensor + scalar` (and correctly cast the scalar), while `scalar + tensor` fails and complains that the types don't match. This commit also unifies ATen C++ operators with Python operators to make sure that they will always have the same semantics (this is useful in the JIT too).\r\n\r\nThere's a bit of awkwardness when dealing with these situations because we generally want to treat scalars as tensors in autograd (to record their history), but we want 0d tensors to behave like scalars in ATen (to allow implicit type casts). I've played with it for a while, but it's hard to disentangle them and come up with a good solution."}