{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/353655058", "html_url": "https://github.com/pytorch/pytorch/pull/4304#issuecomment-353655058", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/4304", "id": 353655058, "node_id": "MDEyOklzc3VlQ29tbWVudDM1MzY1NTA1OA==", "user": {"login": "ngimel", "id": 15841449, "node_id": "MDQ6VXNlcjE1ODQxNDQ5", "avatar_url": "https://avatars3.githubusercontent.com/u/15841449?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ngimel", "html_url": "https://github.com/ngimel", "followers_url": "https://api.github.com/users/ngimel/followers", "following_url": "https://api.github.com/users/ngimel/following{/other_user}", "gists_url": "https://api.github.com/users/ngimel/gists{/gist_id}", "starred_url": "https://api.github.com/users/ngimel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ngimel/subscriptions", "organizations_url": "https://api.github.com/users/ngimel/orgs", "repos_url": "https://api.github.com/users/ngimel/repos", "events_url": "https://api.github.com/users/ngimel/events{/privacy}", "received_events_url": "https://api.github.com/users/ngimel/received_events", "type": "User", "site_admin": false}, "created_at": "2017-12-22T18:48:07Z", "updated_at": "2017-12-22T18:48:07Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=3768583\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/gchanan\">@gchanan</a>,</p>\n<ol>\n<li>lambda support is still experimental, as that compiler switch says, but it works for the most part. File bugs if something does not work</li>\n<li>The following snippet (minimally modified from yours to make it compile with g++)</li>\n</ol>\n<pre><code>#include &lt;stdint.h&gt;\n#include &lt;utility&gt;\n\ntemplate &lt;typename T&gt;\nstruct Foobar {\n  static int64_t apply() {return 0;}\n};\n\n\ntemplate&lt;typename ... Args&gt;\nauto dispatch_all(Args&amp;&amp;... args)\n  -&gt; decltype(Foobar&lt;double&gt;::apply(std::forward&lt;Args&gt;(args)...)) {\n  return 0;\n}\n\ntemplate&lt;typename F, typename T, typename ... Args&gt;\nauto dispatch_all_F(const T&amp; the_type, const char *name, Args&amp;&amp;... args)\n  -&gt; decltype(Foobar&lt;double&gt;::apply(std::forward&lt;Args&gt;(args)...)) {\n  return 0;\n\n}\n\nstruct Foo{};\n\nint main(){\ndispatch_all();\nfloat a;\nconst char * name;\ndispatch_all_F&lt;Foo, float&gt;(a,name);\n\n}\n</code></pre>\n<p>compiles for me both with g++ and nvcc (9.0). Let me know if I'm doing something wrong here or misunderstanding the patterns you need.</p>", "body_text": "@gchanan,\n\nlambda support is still experimental, as that compiler switch says, but it works for the most part. File bugs if something does not work\nThe following snippet (minimally modified from yours to make it compile with g++)\n\n#include <stdint.h>\n#include <utility>\n\ntemplate <typename T>\nstruct Foobar {\n  static int64_t apply() {return 0;}\n};\n\n\ntemplate<typename ... Args>\nauto dispatch_all(Args&&... args)\n  -> decltype(Foobar<double>::apply(std::forward<Args>(args)...)) {\n  return 0;\n}\n\ntemplate<typename F, typename T, typename ... Args>\nauto dispatch_all_F(const T& the_type, const char *name, Args&&... args)\n  -> decltype(Foobar<double>::apply(std::forward<Args>(args)...)) {\n  return 0;\n\n}\n\nstruct Foo{};\n\nint main(){\ndispatch_all();\nfloat a;\nconst char * name;\ndispatch_all_F<Foo, float>(a,name);\n\n}\n\ncompiles for me both with g++ and nvcc (9.0). Let me know if I'm doing something wrong here or misunderstanding the patterns you need.", "body": "@gchanan, \r\n1) lambda support is still experimental, as that compiler switch says, but it works for the most part. File bugs if something does not work\r\n2) The following snippet (minimally modified from yours to make it compile with g++)\r\n```\r\n#include <stdint.h>\r\n#include <utility>\r\n\r\ntemplate <typename T>\r\nstruct Foobar {\r\n  static int64_t apply() {return 0;}\r\n};\r\n\r\n\r\ntemplate<typename ... Args>\r\nauto dispatch_all(Args&&... args)\r\n  -> decltype(Foobar<double>::apply(std::forward<Args>(args)...)) {\r\n  return 0;\r\n}\r\n\r\ntemplate<typename F, typename T, typename ... Args>\r\nauto dispatch_all_F(const T& the_type, const char *name, Args&&... args)\r\n  -> decltype(Foobar<double>::apply(std::forward<Args>(args)...)) {\r\n  return 0;\r\n\r\n}\r\n\r\nstruct Foo{};\r\n\r\nint main(){\r\ndispatch_all();\r\nfloat a;\r\nconst char * name;\r\ndispatch_all_F<Foo, float>(a,name);\r\n\r\n}\r\n```\r\ncompiles for me both with g++ and nvcc (9.0). Let me know if I'm doing something wrong here or misunderstanding the patterns you need. "}