{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/121226048", "pull_request_review_id": 43261787, "id": 121226048, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEyMTIyNjA0OA==", "diff_hunk": "@@ -0,0 +1,37 @@\n+#pragma once\n+\n+#include <atomic>\n+\n+#include \"TensorLib/Scalar.h\"\n+#include \"TensorLib/Type.h\"\n+#include <iostream>\n+namespace tlib {\n+\n+class Type;\n+struct TensorImpl {", "path": "torch/lib/TensorLib/TensorImpl.h", "position": 11, "original_position": 11, "commit_id": "dadf12e892b69bca8457a4be963fece8328f2393", "original_commit_id": "e34f14280c610773902bd3bdc908c3757ec4668c", "user": {"login": "killeent", "id": 4529377, "node_id": "MDQ6VXNlcjQ1MjkzNzc=", "avatar_url": "https://avatars1.githubusercontent.com/u/4529377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/killeent", "html_url": "https://github.com/killeent", "followers_url": "https://api.github.com/users/killeent/followers", "following_url": "https://api.github.com/users/killeent/following{/other_user}", "gists_url": "https://api.github.com/users/killeent/gists{/gist_id}", "starred_url": "https://api.github.com/users/killeent/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/killeent/subscriptions", "organizations_url": "https://api.github.com/users/killeent/orgs", "repos_url": "https://api.github.com/users/killeent/repos", "events_url": "https://api.github.com/users/killeent/events{/privacy}", "received_events_url": "https://api.github.com/users/killeent/received_events", "type": "User", "site_admin": false}, "body": "We use a PIMPL pattern. In PyTorch, THPTensor is a python object, where we use reference counting to control when to free the underlying TH/THC Tensor. In TensorLib, the TensorImpl can be thought of as the underlying memory to be managed. The Tensor itself handles reference counts on TensorImpl, so we can have many Tensors for each TensorImpl. In the same vein, we forward function calls to the implementation, just as we do in PyTorch.", "created_at": "2017-06-09T21:27:10Z", "updated_at": "2018-11-23T15:33:44Z", "html_url": "https://github.com/pytorch/pytorch/pull/1766#discussion_r121226048", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/1766", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/121226048"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/1766#discussion_r121226048"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/1766"}}, "body_html": "<p>We use a PIMPL pattern. In PyTorch, THPTensor is a python object, where we use reference counting to control when to free the underlying TH/THC Tensor. In TensorLib, the TensorImpl can be thought of as the underlying memory to be managed. The Tensor itself handles reference counts on TensorImpl, so we can have many Tensors for each TensorImpl. In the same vein, we forward function calls to the implementation, just as we do in PyTorch.</p>", "body_text": "We use a PIMPL pattern. In PyTorch, THPTensor is a python object, where we use reference counting to control when to free the underlying TH/THC Tensor. In TensorLib, the TensorImpl can be thought of as the underlying memory to be managed. The Tensor itself handles reference counts on TensorImpl, so we can have many Tensors for each TensorImpl. In the same vein, we forward function calls to the implementation, just as we do in PyTorch."}