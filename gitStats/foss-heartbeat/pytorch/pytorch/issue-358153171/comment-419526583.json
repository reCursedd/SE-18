{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/419526583", "html_url": "https://github.com/pytorch/pytorch/pull/11387#issuecomment-419526583", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/11387", "id": 419526583, "node_id": "MDEyOklzc3VlQ29tbWVudDQxOTUyNjU4Mw==", "user": {"login": "pietern", "id": 9845, "node_id": "MDQ6VXNlcjk4NDU=", "avatar_url": "https://avatars3.githubusercontent.com/u/9845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietern", "html_url": "https://github.com/pietern", "followers_url": "https://api.github.com/users/pietern/followers", "following_url": "https://api.github.com/users/pietern/following{/other_user}", "gists_url": "https://api.github.com/users/pietern/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietern/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietern/subscriptions", "organizations_url": "https://api.github.com/users/pietern/orgs", "repos_url": "https://api.github.com/users/pietern/repos", "events_url": "https://api.github.com/users/pietern/events{/privacy}", "received_events_url": "https://api.github.com/users/pietern/received_events", "type": "User", "site_admin": false}, "created_at": "2018-09-07T18:27:51Z", "updated_at": "2018-09-07T18:27:51Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=8120856\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/teng-li\">@teng-li</a> In the MPI backend this is not needed as we capture it in the lambda. For the gloo backend we need to capture it because we don't have a \"run\" lambda. The operation gets kicked off and completes on the gloo device thread, not on the c10d thread pool. Then the returned work object can call <code>waitSend</code> or <code>waitRecv</code> <em>with</em> the <code>srcRank</code> pointer to wait for the operation to complete.</p>\n<p>Updated to use <code>std::make_shared</code> and it works just fine casting/constructing a base class copy.</p>", "body_text": "@teng-li In the MPI backend this is not needed as we capture it in the lambda. For the gloo backend we need to capture it because we don't have a \"run\" lambda. The operation gets kicked off and completes on the gloo device thread, not on the c10d thread pool. Then the returned work object can call waitSend or waitRecv with the srcRank pointer to wait for the operation to complete.\nUpdated to use std::make_shared and it works just fine casting/constructing a base class copy.", "body": "@teng-li In the MPI backend this is not needed as we capture it in the lambda. For the gloo backend we need to capture it because we don't have a \"run\" lambda. The operation gets kicked off and completes on the gloo device thread, not on the c10d thread pool. Then the returned work object can call `waitSend` or `waitRecv` *with* the `srcRank` pointer to wait for the operation to complete. \r\n\r\nUpdated to use `std::make_shared` and it works just fine casting/constructing a base class copy."}