{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/219627743", "pull_request_review_id": 157857334, "id": 219627743, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTYyNzc0Mw==", "diff_hunk": "@@ -1,121 +1,119 @@\n-#define CATCH_CONFIG_MAIN\n-#include \"catch_utils.hpp\"\n+#include \"gtest/gtest.h\"\n \n #include \"cuda.h\"\n #include \"cuda_runtime.h\"\n \n #include \"ATen/cuda/detail/TensorInfo.cuh\"\n \n /*\n-Tests related to tensor indexing and applying operations. \n+Tests related to tensor indexing and applying operations.\n */\n #ifndef _WIN32\n \n-CATCH_TEST_CASE(\"2D Contiguous\", \"Collapses a 2D contiguous tensor to 1D contiguous\") {\n-    int sizes[] = {4, 4};\n-    int strides[] = {4, 1};\n-    ::at::cuda::detail::TensorInfo<void, int> ti{nullptr, 2, sizes, strides};\n-    ti.collapseDims();\n-    CATCH_REQUIRE(ti.dims == 1);\n-    CATCH_REQUIRE(ti.sizes[0] == (4 * 4));\n+TEST(apply_test, Contiguous_2D) {\n+  int sizes[] = {4, 4};\n+  int strides[] = {4, 1};\n+  ::at::cuda::detail::TensorInfo<void, int> ti{nullptr, 2, sizes, strides};\n+  ti.collapseDims();\n+  EXPECT_EQ(ti.dims, 1);\n+  EXPECT_EQ(ti.sizes[0], (4 * 4));\n }\n \n-CATCH_TEST_CASE(\"3D Contiguous\", \"Collapses a 3D contiguous tensor to a 1D contiguous\") {\n-    int sizes[] = {6, 3, 7};\n-    int strides[] = {3 * 7, 7, 1};\n-    ::at::cuda::detail::TensorInfo<void, int> ti{nullptr, 3, sizes, strides};\n-    ti.collapseDims();\n-    CATCH_REQUIRE(ti.dims == 1);\n-    CATCH_REQUIRE(ti.sizes[0] == (6 * 3 * 7));\n+TEST(apply_test, Contiguous_3D) {\n+  int sizes[] = {6, 3, 7};\n+  int strides[] = {3 * 7, 7, 1};\n+  ::at::cuda::detail::TensorInfo<void, int> ti{nullptr, 3, sizes, strides};\n+  ti.collapseDims();\n+  EXPECT_EQ(ti.dims, 1);\n+  EXPECT_EQ(ti.sizes[0], (6 * 3 * 7));\n }\n \n-CATCH_TEST_CASE(\"3D Partial Collapse\", \"Collapses a 3D noncontiguous tensor to a 2D tensor\") {\n-    int sizes[] = {4, 3, 2};\n-    int strides[] = {3 * 3, 3, 1};\n-    ::at::cuda::detail::TensorInfo<void, int> ti{nullptr, 3, sizes, strides};\n-    ti.collapseDims();\n-    CATCH_REQUIRE(ti.dims == 2);\n-    CATCH_REQUIRE(ti.sizes[0] == (4 * 3));\n-    CATCH_REQUIRE(ti.sizes[1] == 2);\n+TEST(apply_test, Partial_Collapse_3D) {\n+  int sizes[] = {4, 3, 2};\n+  int strides[] = {3 * 3, 3, 1};\n+  ::at::cuda::detail::TensorInfo<void, int> ti{nullptr, 3, sizes, strides};\n+  ti.collapseDims();\n+  EXPECT_EQ(ti.dims, 2);\n+  EXPECT_EQ(ti.sizes[0], (4 * 3));\n+  EXPECT_EQ(ti.sizes[1], 2);\n }\n \n-CATCH_TEST_CASE(\"2D Strided Collapse\", \"Collapses a 2D skip contiguous tensor to a 1D skip contiguous tensor\") {\n-    int sizes[] = {3, 2};\n-    int strides[] = {2 * 2, 2};\n-    ::at::cuda::detail::TensorInfo<void, int> ti{nullptr, 2, sizes, strides};\n-    ti.collapseDims();\n-    CATCH_REQUIRE(ti.dims == 1);\n-    CATCH_REQUIRE(ti.sizes[0] == (3 * 2));\n-    CATCH_REQUIRE(ti.strides[0] == 2);\n+TEST(apply_test, Strided_Collapse_2D) {\n+  int sizes[] = {3, 2};\n+  int strides[] = {2 * 2, 2};\n+  ::at::cuda::detail::TensorInfo<void, int> ti{nullptr, 2, sizes, strides};\n+  ti.collapseDims();\n+  EXPECT_EQ(ti.dims, 1);\n+  EXPECT_EQ(ti.sizes[0], (3 * 2));\n+  EXPECT_EQ(ti.strides[0], 2);\n }\n \n-CATCH_TEST_CASE(\"4D Partial Strided Collapse\", \"Collapses a 4D tensor to a 2D tensor\"){\n-    int sizes[] = {3, 6, 5, 2};\n-    int strides[] = {6 * 22, 22, 2 * 2, 2};\n-    ::at::cuda::detail::TensorInfo<void, int> ti{nullptr, 4, sizes, strides};\n-    ti.collapseDims();\n-    CATCH_REQUIRE(ti.dims == 2);\n-    CATCH_REQUIRE(ti.sizes[0] == (3 * 6));\n-    CATCH_REQUIRE(ti.strides[0] == 22);\n-    CATCH_REQUIRE(ti.sizes[1] == (5 * 2));\n-    CATCH_REQUIRE(ti.strides[1] == 2);\n+TEST(apply_test, Partial_Strided_Collapse_4D) {\n+  int sizes[] = {3, 6, 5, 2};\n+  int strides[] = {6 * 22, 22, 2 * 2, 2};\n+  ::at::cuda::detail::TensorInfo<void, int> ti{nullptr, 4, sizes, strides};\n+  ti.collapseDims();\n+  EXPECT_EQ(ti.dims, 2);\n+  EXPECT_EQ(ti.sizes[0], (3 * 6));\n+  EXPECT_EQ(ti.strides[0], 22);\n+  EXPECT_EQ(ti.sizes[1], (5 * 2));\n+  EXPECT_EQ(ti.strides[1], 2);\n }\n \n-CATCH_TEST_CASE(\"Collapsing Zeros and Ones\", \"Collapses a 5D tensor to a 1D tensor\") {\n-    int sizes[] = {1, 10, 1, 5, 4};\n-    int strides[] = {4, 0, 16, 0, 1};\n-    ::at::cuda::detail::TensorInfo<void, int> ti{nullptr, 5, sizes, strides};\n-    ti.collapseDims();\n-    CATCH_REQUIRE(ti.dims == 2);\n-    CATCH_REQUIRE(ti.sizes[0] == (10 * 5));\n-    CATCH_REQUIRE(ti.strides[0] == 0);\n-    CATCH_REQUIRE(ti.sizes[1] == 4);\n-    CATCH_REQUIRE(ti.strides[1] == 1);\n+TEST(apply_test, Collapses_Zeros_and_Ones) {\n+  int sizes[] = {1, 10, 1, 5, 4};\n+  int strides[] = {4, 0, 16, 0, 1};\n+  ::at::cuda::detail::TensorInfo<void, int> ti{nullptr, 5, sizes, strides};\n+  ti.collapseDims();\n+  EXPECT_EQ(ti.dims, 2);\n+  EXPECT_EQ(ti.sizes[0], (10 * 5));\n+  EXPECT_EQ(ti.strides[0], 0);\n+  EXPECT_EQ(ti.sizes[1], 4);\n+  EXPECT_EQ(ti.strides[1], 1);\n }\n \n-CATCH_TEST_CASE(\"Collapsing to a Point Tensor\", \"Collapses a 3D tensor to a point tensor\") {\n-    int sizes[] = {1, 1, 1};\n-    int strides[] = {17, 12, 3};\n-    ::at::cuda::detail::TensorInfo<void, int> ti{nullptr, 3, sizes, strides};\n-    CATCH_REQUIRE(ti.collapseDims() == 0);\n-    CATCH_REQUIRE(ti.dims == 1);\n-    CATCH_REQUIRE(ti.sizes[0] == 1);\n-    CATCH_REQUIRE(ti.strides[0] == 1);\n+TEST(apply_test, Collapse_to_Point_Tensor) {\n+  int sizes[] = {1, 1, 1};\n+  int strides[] = {17, 12, 3};\n+  ::at::cuda::detail::TensorInfo<void, int> ti{nullptr, 3, sizes, strides};\n+  EXPECT_EQ(ti.collapseDims(), 0);\n+  EXPECT_EQ(ti.dims, 1);\n+  EXPECT_EQ(ti.sizes[0], 1);\n+  EXPECT_EQ(ti.strides[0], 1);\n }\n \n-CATCH_TEST_CASE(\"Excluding in a 4D Contiguous\", \"Collapses a 4D tensor to a 3D tensor\") {\n-    int sizes[] = {3, 6, 5, 2};\n-    int strides[] = {6 * 22, 22, 2 * 2, 2};\n-    ::at::cuda::detail::TensorInfo<void, int> ti{nullptr, 4, sizes, strides};\n-    CATCH_REQUIRE(ti.collapseDims(1) == 1);\n-    CATCH_REQUIRE(ti.dims == 3);\n-    CATCH_REQUIRE(ti.sizes[0] == 3);\n-    CATCH_REQUIRE(ti.strides[0] == (6 * 22));\n-    CATCH_REQUIRE(ti.sizes[1] == 6);\n-    CATCH_REQUIRE(ti.strides[1] == 22);\n-    CATCH_REQUIRE(ti.sizes[2] == (5 * 2));\n-    CATCH_REQUIRE(ti.strides[2] == 2);\n+TEST(apply_test, Excluding_in_Contiguous_4D) {\n+  int sizes[] = {3, 6, 5, 2};\n+  int strides[] = {6 * 22, 22, 2 * 2, 2};\n+  ::at::cuda::detail::TensorInfo<void, int> ti{nullptr, 4, sizes, strides};\n+  EXPECT_EQ(ti.collapseDims(1), 1);\n+  EXPECT_EQ(ti.dims, 3);\n+  EXPECT_EQ(ti.sizes[0], 3);", "path": "aten/src/ATen/test/apply_test.cpp", "position": null, "original_position": 164, "commit_id": "8a23c377aced4387451eff3650cba800836704a5", "original_commit_id": "0c9b876558ea27fa5bbd31ffe76fb61bf13bb888", "user": {"login": "goldsborough", "id": 6429851, "node_id": "MDQ6VXNlcjY0Mjk4NTE=", "avatar_url": "https://avatars3.githubusercontent.com/u/6429851?v=4", "gravatar_id": "", "url": "https://api.github.com/users/goldsborough", "html_url": "https://github.com/goldsborough", "followers_url": "https://api.github.com/users/goldsborough/followers", "following_url": "https://api.github.com/users/goldsborough/following{/other_user}", "gists_url": "https://api.github.com/users/goldsborough/gists{/gist_id}", "starred_url": "https://api.github.com/users/goldsborough/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/goldsborough/subscriptions", "organizations_url": "https://api.github.com/users/goldsborough/orgs", "repos_url": "https://api.github.com/users/goldsborough/repos", "events_url": "https://api.github.com/users/goldsborough/events{/privacy}", "received_events_url": "https://api.github.com/users/goldsborough/received_events", "type": "User", "site_admin": false}, "body": "Please do not use `EXPECT_*`. There is an important difference between `EXPECT_*` and `ASSERT_*`:\r\n- When an `EXPECT_*`  fails, it will not fail the test. The test just continues. This is usually not desired.\r\n- When an `ASSERT_*` fails, the whole test fails. This is much better  in most cases and is what Catch's `REQUIRE` also equates.\r\n\r\nYou will have to fix this throughout your PR.", "created_at": "2018-09-21T21:07:22Z", "updated_at": "2018-11-23T15:51:48Z", "html_url": "https://github.com/pytorch/pytorch/pull/11846#discussion_r219627743", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/11846", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/219627743"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/11846#discussion_r219627743"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/11846"}}, "body_html": "<p>Please do not use <code>EXPECT_*</code>. There is an important difference between <code>EXPECT_*</code> and <code>ASSERT_*</code>:</p>\n<ul>\n<li>When an <code>EXPECT_*</code>  fails, it will not fail the test. The test just continues. This is usually not desired.</li>\n<li>When an <code>ASSERT_*</code> fails, the whole test fails. This is much better  in most cases and is what Catch's <code>REQUIRE</code> also equates.</li>\n</ul>\n<p>You will have to fix this throughout your PR.</p>", "body_text": "Please do not use EXPECT_*. There is an important difference between EXPECT_* and ASSERT_*:\n\nWhen an EXPECT_*  fails, it will not fail the test. The test just continues. This is usually not desired.\nWhen an ASSERT_* fails, the whole test fails. This is much better  in most cases and is what Catch's REQUIRE also equates.\n\nYou will have to fix this throughout your PR."}