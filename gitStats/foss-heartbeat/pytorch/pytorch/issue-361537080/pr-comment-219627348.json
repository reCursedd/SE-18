{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/219627348", "pull_request_review_id": 157857334, "id": 219627348, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTYyNzM0OA==", "diff_hunk": "@@ -167,121 +165,141 @@ static void test(Type & type) {\n     std::cout << (a == 10.) << \" -- should be 1\" << std::endl;\n   }\n #endif\n+*/\n \n-  CATCH_SECTION( \"adding a value with a scalar\" ) {\n-    Tensor a = rand({4, 3}, type);\n-    CATCH_REQUIRE((ones({4,3}, type) + a).equal(add(a,1)));\n-  }\n+void test_adding_a_value_with_scalar(Type& type) {\n+  Tensor a = rand({4, 3}, type);\n+  EXPECT_TRUE((ones({4, 3}, type) + a).equal(add(a, 1)));\n+}\n \n-  CATCH_SECTION( \"select\" ) {\n-    Tensor a = rand({3, 7}, type);\n-    auto a_13 = select(a, 1, 3);\n-    auto a_13_02 = select(select(a, 1, 3), 0, 2);\n-    CATCH_REQUIRE( a[0][3].equal(a_13[0]) );\n-    CATCH_REQUIRE( a[2][3].equal(a_13_02) );\n-  }\n+void test_select(Type& type) {\n+  Tensor a = rand({3, 7}, type);\n+  auto a_13 = select(a, 1, 3);\n+  auto a_13_02 = select(select(a, 1, 3), 0, 2);\n+  EXPECT_TRUE(a[0][3].equal(a_13[0]));\n+  EXPECT_TRUE(a[2][3].equal(a_13_02));\n+}\n \n-  CATCH_SECTION( \"zero-dim\" ) {\n-    Tensor a =  type.scalarTensor(4); //rand(type, {1});\n-\n-    Tensor b = rand({3,4}, type);\n-    CATCH_REQUIRE((a + a).dim() == 0);\n-    CATCH_REQUIRE((1 + a).dim() == 0);\n-    CATCH_REQUIRE((b + a).dim() == 2);\n-    CATCH_REQUIRE((a + b).dim() == 2);\n-    auto c = rand({3,4}, type);\n-    CATCH_REQUIRE(c[1][2].dim() == 0);\n-\n-    auto f = rand({3,4}, type);\n-    f[2] = zeros({4}, type);\n-    f[1][0] = -1;\n-    CATCH_REQUIRE(f[2][0].toCDouble() == 0);\n-  }\n+void test_zero_dim(Type& type) {\n+  Tensor a = type.scalarTensor(4); // rand(type, {1});\n+\n+  Tensor b = rand({3, 4}, type);\n+  EXPECT_EQ((a + a).dim(), 0);\n+  EXPECT_EQ((1 + a).dim(), 0);\n+  EXPECT_EQ((b + a).dim(), 2);\n+  EXPECT_EQ((a + b).dim(), 2);\n+  auto c = rand({3, 4}, type);\n+  EXPECT_EQ(c[1][2].dim(), 0);\n+\n+  auto f = rand({3, 4}, type);\n+  f[2] = zeros({4}, type);\n+  f[1][0] = -1;\n+  EXPECT_EQ(f[2][0].toCDouble(), 0);\n+}\n \n-  CATCH_SECTION( \"tensor from TH\" ) {\n-    int a = 4;\n-    THFloatTensor *t = THFloatTensor_newWithSize2d(a, a);\n-    THFloatTensor_fill(t, a);\n-    Tensor tt = CPU(kFloat).unsafeTensorFromTH(t,false);\n-    CATCH_REQUIRE_NOTHROW(tt);\n-  }\n+void test_tensor_from_TH() {\n+  int a = 4;\n+  THFloatTensor* t = THFloatTensor_newWithSize2d(a, a);\n+  THFloatTensor_fill(t, a);\n+  Tensor tt = CPU(kFloat).unsafeTensorFromTH(t, false);\n+  EXPECT_NO_THROW(tt);\n+}\n \n-  CATCH_SECTION( \"toCFloat\" ) {\n-    Tensor a = zeros({3,4});\n-    Tensor b = ones({3,7});\n-    Tensor c = cat({a,b},1);\n-    CATCH_REQUIRE(c.size(1) == 11);\n+void test_toCFloat() {\n+  Tensor a = zeros({3, 4});\n+  Tensor b = ones({3, 7});\n+  Tensor c = cat({a, b}, 1);\n+  EXPECT_EQ(c.size(1), 11);\n \n-    Tensor e = rand({});\n-    CATCH_REQUIRE(*e.data<float>() == e.sum().toCFloat());\n-  }\n+  Tensor e = rand({});\n+  EXPECT_EQ(*e.data<float>(), e.sum().toCFloat());\n+}\n+\n+void test_toString() {\n+  Tensor b = ones({3, 7}) * .0000001f;\n+  std::stringstream s;\n+  s << b << \"\\n\";\n+  std::string expect = \"1e-07 *\";\n+  EXPECT_EQ(s.str().substr(0, expect.size()), expect);\n+}\n \n-  CATCH_SECTION( \"to string\" ) {\n-    Tensor b = ones({3,7})*.0000001f;\n-    std::stringstream s;\n-    s << b << \"\\n\";\n-    std::string expect = \"1e-07 *\";\n-    CATCH_REQUIRE(s.str().substr(0,expect.size()) == expect);\n+void test_indexing_by_scalar() {\n+  Tensor tensor = arange(0, 10, kInt);\n+  Tensor one = ones({}, kInt);\n+  for (int64_t i = 0; i < tensor.numel(); ++i) {\n+    EXPECT_TRUE(tensor[i].equal(one * i));\n+  }\n+  for (size_t i = 0; i < static_cast<uint64_t>(tensor.numel()); ++i) {\n+    EXPECT_TRUE(tensor[i].equal(one * static_cast<int64_t>(i)));\n   }\n-  CATCH_SECTION(\"indexing by Scalar\") {\n-    Tensor tensor = arange(0, 10, kInt);\n-    Tensor one = ones({}, kInt);\n-    for (int64_t i = 0; i < tensor.numel(); ++i) {\n-      CATCH_REQUIRE(tensor[i].equal(one * i));\n-    }\n-    for (size_t i = 0; i < static_cast<uint64_t>(tensor.numel()); ++i) {\n-      CATCH_REQUIRE(tensor[i].equal(one * static_cast<int64_t>(i)));\n-    }\n-    for (int i = 0; i < tensor.numel(); ++i) {\n-      CATCH_REQUIRE(tensor[i].equal(one * i));\n-    }\n-    for (int16_t i = 0; i < tensor.numel(); ++i) {\n-      CATCH_REQUIRE(tensor[i].equal(one * i));\n-    }\n-    for (int8_t i = 0; i < tensor.numel(); ++i) {\n-      CATCH_REQUIRE(tensor[i].equal(one * i));\n-    }\n-    CATCH_REQUIRE_THROWS_WITH(\n-        tensor[Scalar(3.14)].equal(one),\n-        StartsWith(\n-            \"Can only index tensors with integral scalars\"));\n+  for (int i = 0; i < tensor.numel(); ++i) {\n+    EXPECT_TRUE(tensor[i].equal(one * i));\n   }\n-  CATCH_SECTION(\"indexing by zero-dim tensor\") {\n-    Tensor tensor = arange(0, 10, kInt);\n-    Tensor one = ones({}, kInt);\n-    for (int i = 0; i < tensor.numel(); ++i) {\n-      CATCH_REQUIRE(tensor[one * i].equal(one * i));\n-    }\n-    CATCH_REQUIRE_THROWS_WITH(\n-        tensor[ones({}) * 3.14].equal(one),\n-        StartsWith(\n-            \"Can only index tensors with integral scalars\"));\n-    CATCH_REQUIRE_THROWS_WITH(\n-        tensor[Tensor()].equal(one),\n-        StartsWith(\"Can only index with tensors that are defined\"));\n-    CATCH_REQUIRE_THROWS_WITH(\n-        tensor[ones({2, 3, 4}, kInt)].equal(one),\n-        StartsWith(\"Can only index with tensors that are scalars (zero-dim)\"));\n+  for (int16_t i = 0; i < tensor.numel(); ++i) {\n+    EXPECT_TRUE(tensor[i].equal(one * i));\n   }\n-  CATCH_SECTION(\"dispatch\") {\n-    Tensor tensor = randn({20, 20});\n-    Tensor other = randn({20, 20});\n-    auto result = tensor.m(relu).m(mse_loss, other, Reduction::ElementwiseMean);\n-    CATCH_REQUIRE(result.allclose(mse_loss(relu(tensor), other)));\n+  for (int8_t i = 0; i < tensor.numel(); ++i) {\n+    EXPECT_TRUE(tensor[i].equal(one * i));\n   }\n-  CATCH_SECTION(\"core\") {\n-    int i = CoreTest();\n-    CATCH_REQUIRE(i + 1 == CoreTest());\n+  EXPECT_ANY_THROW(tensor[Scalar(3.14)].equal(one));\n+}\n+\n+void test_indexing_by_zerodim_tensor() {\n+  Tensor tensor = arange(0, 10, kInt);\n+  Tensor one = ones({}, kInt);\n+  for (int i = 0; i < tensor.numel(); ++i) {\n+    EXPECT_TRUE(tensor[one * i].equal(one * i));\n   }\n+  EXPECT_ANY_THROW(tensor[ones({}) * 3.14].equal(one));\n+  EXPECT_ANY_THROW(tensor[Tensor()].equal(one));\n+  EXPECT_ANY_THROW(tensor[ones({2, 3, 4}, kInt)].equal(one));\n+}\n+void test_dispatch() {\n+  Tensor tensor = randn({20, 20});\n+  Tensor other = randn({20, 20});\n+  auto result = tensor.m(relu).m(mse_loss, other, Reduction::ElementwiseMean);\n+  EXPECT_TRUE(result.allclose(mse_loss(relu(tensor), other)));\n+}\n+\n+void test_core() {\n+  int i = CoreTest();\n+  EXPECT_EQ(i + 1, CoreTest());\n+}\n+\n+void test(Type& type) {", "path": "aten/src/ATen/test/basic.cpp", "position": null, "original_position": 469, "commit_id": "8a23c377aced4387451eff3650cba800836704a5", "original_commit_id": "0c9b876558ea27fa5bbd31ffe76fb61bf13bb888", "user": {"login": "goldsborough", "id": 6429851, "node_id": "MDQ6VXNlcjY0Mjk4NTE=", "avatar_url": "https://avatars3.githubusercontent.com/u/6429851?v=4", "gravatar_id": "", "url": "https://api.github.com/users/goldsborough", "html_url": "https://github.com/goldsborough", "followers_url": "https://api.github.com/users/goldsborough/followers", "following_url": "https://api.github.com/users/goldsborough/following{/other_user}", "gists_url": "https://api.github.com/users/goldsborough/gists{/gist_id}", "starred_url": "https://api.github.com/users/goldsborough/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/goldsborough/subscriptions", "organizations_url": "https://api.github.com/users/goldsborough/orgs", "repos_url": "https://api.github.com/users/goldsborough/repos", "events_url": "https://api.github.com/users/goldsborough/events{/privacy}", "received_events_url": "https://api.github.com/users/goldsborough/received_events", "type": "User", "site_admin": false}, "body": "Generally this is not the recommended way of running a collection of tests with different parameters in gtest. If you want to be very thorough, we should rewrite these tests using \"Parameterized tests\": https://github.com/google/googletest/blob/master/googletest/docs/advanced.md#value-parameterized-tests.\r\n\r\nIt may be more work though. Up to you", "created_at": "2018-09-21T21:05:30Z", "updated_at": "2018-11-23T15:51:48Z", "html_url": "https://github.com/pytorch/pytorch/pull/11846#discussion_r219627348", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/11846", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/219627348"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/11846#discussion_r219627348"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/11846"}}, "body_html": "<p>Generally this is not the recommended way of running a collection of tests with different parameters in gtest. If you want to be very thorough, we should rewrite these tests using \"Parameterized tests\": <a href=\"https://github.com/google/googletest/blob/master/googletest/docs/advanced.md#value-parameterized-tests\">https://github.com/google/googletest/blob/master/googletest/docs/advanced.md#value-parameterized-tests</a>.</p>\n<p>It may be more work though. Up to you</p>", "body_text": "Generally this is not the recommended way of running a collection of tests with different parameters in gtest. If you want to be very thorough, we should rewrite these tests using \"Parameterized tests\": https://github.com/google/googletest/blob/master/googletest/docs/advanced.md#value-parameterized-tests.\nIt may be more work though. Up to you"}