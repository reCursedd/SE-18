{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/101395964", "pull_request_review_id": 22101301, "id": 101395964, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwMTM5NTk2NA==", "diff_hunk": "@@ -1,33 +1,72 @@\n #include \"torch/csrc/autograd/engine.h\"\n \n-#include <set>\n+#include <queue>\n #include <string>\n+#include <cstdint>\n+#include <unordered_set>\n #include <THPP/THPP.h>\n \n using thpp::Tensor;\n \n namespace torch { namespace autograd {\n \n-auto Engine::compute_dependencies(function_queue& queue, ready_queue_type& ready) -> dependencies_type {\n+namespace {\n+\n+struct function_visit {\n+  function_visit(Function* fn, bool reachable)\n+    : reachable(reachable)\n+    , fn(fn)\n+    {};\n+\n+  // Sort by (reachable, fn)\n+  bool operator<(const function_visit& other) const {\n+    int this_reachable = static_cast<int>(reachable);\n+    int other_reachble = static_cast<int>(other.reachable);\n+    if (this_reachable != other_reachble)\n+      return this_reachable < other_reachble;\n+    uintptr_t this_fn = reinterpret_cast<uintptr_t>(fn);\n+    uintptr_t other_fn = reinterpret_cast<uintptr_t>(other.fn);\n+    return this_fn < other_fn;\n+  }\n+\n+  // Reachable from any of the backward roots via a path consisting only of\n+  // Functions that require gradient\n+  bool reachable;\n+  Function* fn;\n+};\n+\n+} // anonymous namespace\n+\n+auto Engine::compute_dependencies(function_queue& roots, ready_queue_type& ready) -> dependencies_type {\n   dependencies_type dependencies;\n-  std::set<Function*> seen;\n+  std::unordered_map<Function*, bool> seen;\n+  // Priority queue ensures that functions that are reachable by gradients\n+  // will be visited first.\n+  std::priority_queue<function_visit> queue;\n+  for (auto& fn: roots)\n+    queue.emplace(fn.get(), fn->requires_grad);\n   while (queue.size() > 0) {\n-    auto fn = std::move(queue.back()); queue.pop_back();\n-    for (auto& prev_fn_pair : fn->previous_functions) {\n-      auto& prev_fn = prev_fn_pair.first;\n+    auto visit = queue.top(); queue.pop();\n+    for (auto& prev_fn_pair : visit.fn->previous_functions) {\n+      Function* prev_fn = prev_fn_pair.first.get();\n+      // If prev_fn is reachable by the gradient. Can be overriden e.g. when a\n+      // stochastic node is found.\n+      bool reachable = visit.reachable && visit.fn->requires_grad;\n       if (!prev_fn)\n         continue;\n-      if (dynamic_cast<Variable*>(prev_fn.get()))\n+      if (dynamic_cast<Variable*>(prev_fn))\n         continue;\n-      // check for stochastic function\n-      if (prev_fn->is_stochastic && seen.count(prev_fn.get()) == 0 && prev_fn->requires_grad) {\n-        ready.emplace_back(prev_fn, GradBuffer(0));\n-      } else if (fn->requires_grad && prev_fn->requires_grad) {\n-        dependencies[prev_fn.get()] += 1;\n+      // Check for stochastic function\n+      if (prev_fn->is_stochastic && seen.count(prev_fn) == 0 && prev_fn->requires_grad) {\n+        ready.emplace_back(prev_fn_pair.first, GradBuffer(0));\n+        reachable = true;\n+      } else if (reachable && visit.fn->requires_grad && prev_fn->requires_grad) {\n+        dependencies[prev_fn] += 1;\n       }\n-      if (seen.count(prev_fn.get()) == 0) {\n-        seen.insert(prev_fn.get());\n-        queue.push_back(prev_fn);\n+      auto it = seen.find(prev_fn);\n+      if (it == seen.end() || (it->second == false && reachable)) {\n+        seen[prev_fn] = reachable;\n+        queue.emplace(prev_fn, reachable);", "path": "torch/csrc/autograd/engine.cpp", "position": null, "original_position": 84, "commit_id": "77e7d725af0ac12c5442c1807257d00e0cd48c3e", "original_commit_id": "8385796ee6b1ea6aea1f3e1111459a054b408bbb", "user": {"login": "colesbury", "id": 655866, "node_id": "MDQ6VXNlcjY1NTg2Ng==", "avatar_url": "https://avatars1.githubusercontent.com/u/655866?v=4", "gravatar_id": "", "url": "https://api.github.com/users/colesbury", "html_url": "https://github.com/colesbury", "followers_url": "https://api.github.com/users/colesbury/followers", "following_url": "https://api.github.com/users/colesbury/following{/other_user}", "gists_url": "https://api.github.com/users/colesbury/gists{/gist_id}", "starred_url": "https://api.github.com/users/colesbury/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/colesbury/subscriptions", "organizations_url": "https://api.github.com/users/colesbury/orgs", "repos_url": "https://api.github.com/users/colesbury/repos", "events_url": "https://api.github.com/users/colesbury/events{/privacy}", "received_events_url": "https://api.github.com/users/colesbury/received_events", "type": "User", "site_admin": false}, "body": "This looks like the same function can be put in the queue multiple times. Is that safe?", "created_at": "2017-02-15T22:09:47Z", "updated_at": "2018-11-23T15:32:28Z", "html_url": "https://github.com/pytorch/pytorch/pull/752#discussion_r101395964", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/752", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/101395964"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/752#discussion_r101395964"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/752"}}, "body_html": "<p>This looks like the same function can be put in the queue multiple times. Is that safe?</p>", "body_text": "This looks like the same function can be put in the queue multiple times. Is that safe?"}