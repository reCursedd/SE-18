{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/359324287", "html_url": "https://github.com/pytorch/pytorch/pull/4759#issuecomment-359324287", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/4759", "id": 359324287, "node_id": "MDEyOklzc3VlQ29tbWVudDM1OTMyNDI4Nw==", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "created_at": "2018-01-22T04:47:23Z", "updated_at": "2018-01-22T04:47:23Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Reading this diff, I wanted to comment about how it's generally implemented in functional languages, since it may clarify some implementation issues here.</p>\n<p>Suppose you have some nested function like so:</p>\n<pre><code>let f x y =\n  let g a b = ... x ... y ...\n  in ... g  ...\n</code></pre>\n<p>We'd like to \"float\" g to the top level, but we cannot do that because x and y are free variables. So what we do first is abstract g w.r.t. x and y:</p>\n<pre><code>let f x y =\n  let g x y a b = ... x ... y ...\n  in ... g x y ...\n</code></pre>\n<p>Now g can be lifted unimpeded to the top level:</p>\n<pre><code>let g x y a b = ... x ... y ...\nlet f x y =\n  in ... g x y ...\n</code></pre>\n<p>And then, since g is partially applied function, when we lower it, it lowers into a bundle of both the code pointer g and the saved temporaries x and y, which might be returned from f. Since the code pointer is always constant you constant-prop it away and you're left with the extra needed outputs of g.</p>\n<p>I have not tried actually implementing this in the mutable graph world (I am not sure if it helps in our particular situation) but I feel that it nicely decomposes the problem.</p>", "body_text": "Reading this diff, I wanted to comment about how it's generally implemented in functional languages, since it may clarify some implementation issues here.\nSuppose you have some nested function like so:\nlet f x y =\n  let g a b = ... x ... y ...\n  in ... g  ...\n\nWe'd like to \"float\" g to the top level, but we cannot do that because x and y are free variables. So what we do first is abstract g w.r.t. x and y:\nlet f x y =\n  let g x y a b = ... x ... y ...\n  in ... g x y ...\n\nNow g can be lifted unimpeded to the top level:\nlet g x y a b = ... x ... y ...\nlet f x y =\n  in ... g x y ...\n\nAnd then, since g is partially applied function, when we lower it, it lowers into a bundle of both the code pointer g and the saved temporaries x and y, which might be returned from f. Since the code pointer is always constant you constant-prop it away and you're left with the extra needed outputs of g.\nI have not tried actually implementing this in the mutable graph world (I am not sure if it helps in our particular situation) but I feel that it nicely decomposes the problem.", "body": "Reading this diff, I wanted to comment about how it's generally implemented in functional languages, since it may clarify some implementation issues here.\r\n\r\nSuppose you have some nested function like so:\r\n\r\n```\r\nlet f x y =\r\n  let g a b = ... x ... y ...\r\n  in ... g  ...\r\n```\r\n\r\nWe'd like to \"float\" g to the top level, but we cannot do that because x and y are free variables. So what we do first is abstract g w.r.t. x and y:\r\n\r\n```\r\nlet f x y =\r\n  let g x y a b = ... x ... y ...\r\n  in ... g x y ...\r\n```\r\n\r\nNow g can be lifted unimpeded to the top level:\r\n\r\n```\r\nlet g x y a b = ... x ... y ...\r\nlet f x y =\r\n  in ... g x y ...\r\n```\r\n\r\nAnd then, since g is partially applied function, when we lower it, it lowers into a bundle of both the code pointer g and the saved temporaries x and y, which might be returned from f. Since the code pointer is always constant you constant-prop it away and you're left with the extra needed outputs of g.\r\n\r\nI have not tried actually implementing this in the mutable graph world (I am not sure if it helps in our particular situation) but I feel that it nicely decomposes the problem."}