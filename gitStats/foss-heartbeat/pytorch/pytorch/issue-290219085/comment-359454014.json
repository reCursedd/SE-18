{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/359454014", "html_url": "https://github.com/pytorch/pytorch/pull/4759#issuecomment-359454014", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/4759", "id": 359454014, "node_id": "MDEyOklzc3VlQ29tbWVudDM1OTQ1NDAxNA==", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "created_at": "2018-01-22T15:16:45Z", "updated_at": "2018-01-22T15:16:45Z", "author_association": "CONTRIBUTOR", "body_html": "<blockquote>\n<p>I think the problem in here is that we don't have nested declarations</p>\n</blockquote>\n<p>But we are going to add this, because we need it for control flow, right?</p>\n<blockquote>\n<p>we're effectively splitting a 2-stage generator/coroutine into two lambdas - one that computes the results of the first stage and returns the state, and the other one that consumes the state also computes the results (modulo the fact that the state implies adding more inputs to the second lambda, which makes it even worse).</p>\n</blockquote>\n<p>Yes. All I am saying is this can easily be modeled in a higher order language, because the first stage can just return a lambda which closes over the state that needs to be passed over. Then, if you don't want to actually execute a higher order language, you can lower this into explicit state passing.</p>", "body_text": "I think the problem in here is that we don't have nested declarations\n\nBut we are going to add this, because we need it for control flow, right?\n\nwe're effectively splitting a 2-stage generator/coroutine into two lambdas - one that computes the results of the first stage and returns the state, and the other one that consumes the state also computes the results (modulo the fact that the state implies adding more inputs to the second lambda, which makes it even worse).\n\nYes. All I am saying is this can easily be modeled in a higher order language, because the first stage can just return a lambda which closes over the state that needs to be passed over. Then, if you don't want to actually execute a higher order language, you can lower this into explicit state passing.", "body": "> I think the problem in here is that we don't have nested declarations\r\n\r\nBut we are going to add this, because we need it for control flow, right?\r\n\r\n> we're effectively splitting a 2-stage generator/coroutine into two lambdas - one that computes the results of the first stage and returns the state, and the other one that consumes the state also computes the results (modulo the fact that the state implies adding more inputs to the second lambda, which makes it even worse).\r\n\r\nYes. All I am saying is this can easily be modeled in a higher order language, because the first stage can just return a lambda which closes over the state that needs to be passed over. Then, if you don't want to actually execute a higher order language, you can lower this into explicit state passing."}