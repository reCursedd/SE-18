{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/162801033", "pull_request_review_id": 90321846, "id": 162801033, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2MjgwMTAzMw==", "diff_hunk": "@@ -59,4 +57,170 @@ void differentiate(std::shared_ptr<Graph>& graph) {\n   }\n }\n \n+static std::shared_ptr<Graph> splitOffStage(\n+        const std::shared_ptr<Graph>& graph,\n+        std::size_t stage,\n+        ArrayRef<Value*> inputs,\n+        ArrayRef<Value*> outputs) {\n+  auto graph_clone = std::make_shared<Graph>();\n+\n+  std::unordered_map<Value*, Value*> val_map; // values in graph -> values in graph_clone\n+  const auto lookup_val = [&](Value *v) { return val_map.at(v); };\n+\n+  for (Value *input : inputs)\n+    val_map[input] = graph_clone->addInput()->setType(input->typeOption());\n+\n+  for (Node *node : *graph) {\n+    if (node->stage() != stage) continue;\n+    Node *node_clone = graph_clone->createClone(node, lookup_val);\n+    for (std::size_t i = 0, num_outputs = node_clone->outputs().size(); i < num_outputs; ++i)\n+      val_map[node->outputs()[i]] = node_clone->outputs()[i];\n+    graph_clone->appendNode(node_clone);\n+  }\n+\n+  for (Value *output : outputs) {\n+    JIT_ASSERT(output->stage() == stage);\n+    graph_clone->registerOutput(val_map.at(output));\n+  }\n+\n+  return graph_clone;\n+}\n+\n+static std::unordered_map<Value*, int64_t> computeValueTopoOrder(const std::shared_ptr<Graph>& graph) {\n+  int64_t next_nr = 0;\n+  std::size_t stage = 0;\n+  std::unordered_map<Value*, int64_t> order;\n+  auto inputs_it = graph->inputs().begin();\n+  auto inputs_end = graph->inputs().end();\n+  auto nodes_it = graph->nodes().begin();\n+  auto nodes_end = graph->nodes().end();\n+\n+  while (inputs_it != inputs_end || nodes_it != nodes_end) {\n+    for (; inputs_it != inputs_end; ++inputs_it) {\n+      Value *input = *inputs_it;\n+      if (input->stage() != stage) break;\n+      order[input] = next_nr++;\n+    }\n+    for (; nodes_it != nodes_end; ++nodes_it) {\n+      Node *node = *nodes_it;\n+      if (node->stage() != stage) break;\n+      for (Value * output : node->outputs())\n+        order[output] = next_nr++;\n+    }\n+    // NOTE: outputs are either inputs or are produced by nodes,\n+    // so we don't need to handle them in any way.\n+    stage++;\n+  }\n+  JIT_ASSERT(stage == graph->stage() + 1);\n+  return order;\n+}\n+\n+LiftedReverse lambdaLiftReverse(std::shared_ptr<Graph>& graph) {\n+  static const auto is_stage_0 = [](Value *v) { return v->stage() == 0; };\n+  static const auto is_stage_1 = [](Value *v) { return v->stage() == 1; };\n+  // NOTE: in the comments here first stage == stage 0\n+  JIT_ASSERT(graph->stage() == 1);\n+\n+  // --------------------------------------------------------------------------\n+  // 1. Find values of stage 0 that need to ba captured.\n+  // --------------------------------------------------------------------------\n+  // First, we need to find all values that are produced in the first stage,\n+  // and used in the second one. They will need to be added as inputs of the reverse\n+  // graph, and some of them may also need to be appended as outputs of the primal graph.\n+  std::unordered_set<Value*> extra_reverse_inputs;\n+  for (Node * node : *graph) {\n+    if (node->stage() == 0) continue;\n+    for (Value * input : node->inputs()) {\n+      if (input->stage() != 0) continue;\n+      extra_reverse_inputs.insert(input);\n+    }\n+  }\n+\n+  // --------------------------------------------------------------------------\n+  // 2. Establish an ordering on inputs/outputs.\n+  // --------------------------------------------------------------------------\n+  // We will need to sort primal outputs and reverse inputs, so that they maintain\n+  // an order of:\n+  //   [primal outputs], [primal temporaries], [reverse inputs]\n+  // where each section is sorted in the same way as in the input graph.\n+  //\n+  // This corresponds exactly to taking a topological ordering on values,\n+  // but artificially boosting outputs of the first stage to precede all\n+  // other values.\n+  auto topo_order = computeValueTopoOrder(graph);\n+  auto io_compare = [&](Value *a, Value *b) { return topo_order.at(a) < topo_order.at(b); };", "path": "torch/csrc/jit/autodiff.cpp", "position": null, "original_position": 104, "commit_id": "a41b11143e2fad09918cf66d0a60216e9ab83f5a", "original_commit_id": "5914745b88ea6b541561f1889baf268a67443a17", "user": {"login": "zdevito", "id": 370202, "node_id": "MDQ6VXNlcjM3MDIwMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/370202?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zdevito", "html_url": "https://github.com/zdevito", "followers_url": "https://api.github.com/users/zdevito/followers", "following_url": "https://api.github.com/users/zdevito/following{/other_user}", "gists_url": "https://api.github.com/users/zdevito/gists{/gist_id}", "starred_url": "https://api.github.com/users/zdevito/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zdevito/subscriptions", "organizations_url": "https://api.github.com/users/zdevito/orgs", "repos_url": "https://api.github.com/users/zdevito/repos", "events_url": "https://api.github.com/users/zdevito/events{/privacy}", "received_events_url": "https://api.github.com/users/zdevito/received_events", "type": "User", "site_admin": false}, "body": "It's too confusing to encode the ordering of the outputs as a sort. I can't glance at this and know if it is correct. It would be easier if the temporaries were added to the primal as part of the process of splitting the graph rather than trying to construct one giant graph here.", "created_at": "2018-01-21T05:20:31Z", "updated_at": "2018-11-23T15:38:22Z", "html_url": "https://github.com/pytorch/pytorch/pull/4759#discussion_r162801033", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/4759", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/162801033"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/4759#discussion_r162801033"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/4759"}}, "body_html": "<p>It's too confusing to encode the ordering of the outputs as a sort. I can't glance at this and know if it is correct. It would be easier if the temporaries were added to the primal as part of the process of splitting the graph rather than trying to construct one giant graph here.</p>", "body_text": "It's too confusing to encode the ordering of the outputs as a sort. I can't glance at this and know if it is correct. It would be easier if the temporaries were added to the primal as part of the process of splitting the graph rather than trying to construct one giant graph here."}