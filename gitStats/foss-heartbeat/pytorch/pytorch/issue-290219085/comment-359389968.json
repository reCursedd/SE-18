{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/359389968", "html_url": "https://github.com/pytorch/pytorch/pull/4759#issuecomment-359389968", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/4759", "id": 359389968, "node_id": "MDEyOklzc3VlQ29tbWVudDM1OTM4OTk2OA==", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "created_at": "2018-01-22T10:57:45Z", "updated_at": "2018-01-22T10:58:24Z", "author_association": "MEMBER", "body_html": "<p>I think the problem in here is that we don't have nested declarations, and we're effectively splitting a 2-stage generator/coroutine into two lambdas - one that computes the results of the first stage <em>and returns the state</em>, and the other one that <em>consumes the state</em> also computes the results  (modulo the fact that the state implies adding more inputs to the second lambda, which makes it even worse). Our graph printing is very misleading and makes them look like regular functions whereas they really should look like this:</p>\n<pre><code>graph (%1) {\n  %3 = add(%1, %1)\n  %4 = yield (%3) -- NOTE: %4 is grad of %3\n  --- stage 1 ---\n  %5 = add(%4, %4)\n  return (%5)\n}\n</code></pre>\n<p>I don't think we can take a lot from the way it's implemented in functional languages, both because the objects we're dealing with are different, and because of how our IR is designed (e.g. it's much easier to clone the relevant parts with inputs added ahead of time instead of adding/remapping stuff inside the graph later).</p>", "body_text": "I think the problem in here is that we don't have nested declarations, and we're effectively splitting a 2-stage generator/coroutine into two lambdas - one that computes the results of the first stage and returns the state, and the other one that consumes the state also computes the results  (modulo the fact that the state implies adding more inputs to the second lambda, which makes it even worse). Our graph printing is very misleading and makes them look like regular functions whereas they really should look like this:\ngraph (%1) {\n  %3 = add(%1, %1)\n  %4 = yield (%3) -- NOTE: %4 is grad of %3\n  --- stage 1 ---\n  %5 = add(%4, %4)\n  return (%5)\n}\n\nI don't think we can take a lot from the way it's implemented in functional languages, both because the objects we're dealing with are different, and because of how our IR is designed (e.g. it's much easier to clone the relevant parts with inputs added ahead of time instead of adding/remapping stuff inside the graph later).", "body": "I think the problem in here is that we don't have nested declarations, and we're effectively splitting a 2-stage generator/coroutine into two lambdas - one that computes the results of the first stage *and returns the state*, and the other one that *consumes the state* also computes the results  (modulo the fact that the state implies adding more inputs to the second lambda, which makes it even worse). Our graph printing is very misleading and makes them look like regular functions whereas they really should look like this:\r\n```\r\ngraph (%1) {\r\n  %3 = add(%1, %1)\r\n  %4 = yield (%3) -- NOTE: %4 is grad of %3\r\n  --- stage 1 ---\r\n  %5 = add(%4, %4)\r\n  return (%5)\r\n}\r\n```\r\nI don't think we can take a lot from the way it's implemented in functional languages, both because the objects we're dealing with are different, and because of how our IR is designed (e.g. it's much easier to clone the relevant parts with inputs added ahead of time instead of adding/remapping stuff inside the graph later)."}