{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/173661337", "pull_request_review_id": 102606950, "id": 173661337, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE3MzY2MTMzNw==", "diff_hunk": "@@ -15,48 +15,200 @@ using ResolutionCallback = std::function<py::function(std::string)>;\n #define VISIBILITY_HIDDEN __attribute__((visibility(\"hidden\")))\n #endif\n \n-struct VISIBILITY_HIDDEN PythonResolver : public Resolver {\n-  PythonResolver(ResolutionCallback rcb) : rcb(rcb) {}\n-\n-  Node* resolveCall(SourceRange location, Node* n) const override {\n-    AutoGIL ag;\n-    py::function func;\n-    func = rcb(n->kind().toString());\n-    auto* py_func = func.ptr();\n-    if (py_func == Py_None) {\n-      throw ErrorReport(location)\n-          << \"Unknown function \" << n->kind().toString();\n-    }\n+\n+\n+static void ensureSizeMatches(SourceRange loc, size_t expected, size_t actual, const std::string& what) {\n+  if(expected != actual) {\n+    throw ErrorReport(loc) << \"expected \" << expected << \" \" << what << \" but found \" << actual;\n+  }\n+}\n+\n+struct VISIBILITY_HIDDEN PythonValue : public SugaredValue {\n+  PythonValue(py::object self)\n+  : self(std::move(self)) {}\n+\n+  // call it like a function, e.g. `outputs = this(inputs)`\n+  virtual std::vector<Value*> call(SourceRange loc, Method & m, at::ArrayRef<Value*> inputs, List<Attribute> attributes, size_t n_outputs) override {\n+    ensureSizeMatches(loc, 0, attributes.size(), \"keyword arguments\");\n     // Release the function object so we can wrap it in a PythonOp\n-    auto fn_ptr = THPObjectPtr(func.release().ptr());\n-    std::string cconv(n->inputs().size(), 't');\n-    Node* new_node = n->owningGraph()->createPythonOp(\n-        std::move(fn_ptr), cconv, false, {}, {}, false);\n-    return new_node;\n+    Graph& g = *m.graph();\n+    py::object func = self;\n+    std::string cconv(inputs.size(), 't');\n+    Node* new_node = g.insertNode(g.createPythonOp(\n+      THPObjectPtr(func.release().ptr()), cconv, false, {}, {}, false));\n+    for(auto i : inputs)\n+      new_node->addInput(i);\n+    std::vector<Value*> outputs;\n+    for(size_t i = 0; i < n_outputs; ++i)\n+      outputs.push_back(new_node->addOutput());\n+    return outputs;\n   }\n \n-  ResolutionCallback rcb;\n+  virtual std::string kind() const override {\n+    return py::repr(self);\n+  }\n+private:\n+  py::object self;\n };\n \n+Resolver pythonResolver(ResolutionCallback rcb) {\n+  return [=](const std::string& name) -> std::shared_ptr<SugaredValue> {\n+      AutoGIL ag;\n+      py::object obj = rcb(name);\n+      if(obj.is(py::none())) {\n+        return nullptr;\n+      }\n+      return std::make_shared<PythonValue>(obj);\n+  };\n+}\n+\n+// defines how a modules/methods behave inside the script subset.\n+// for now this does not have any interaction with python.\n+// in the future, we will add the ability to resolve `self.foo` to python\n+// {functions, modules, contants} so this SugaredValue is defined here\n+// anticipating we will eventually need to replace Module with a py::object\n+// holding the actual nn.Module class.\n+\n+// defines how a method obtained from a module behaves in script\n+struct MethodValue : public SugaredValue {\n+  MethodValue(std::shared_ptr<Module> module, Method& method)\n+  : module(std::move(module)) //insurance that method stays alive\n+  , method(method) {}\n+  std::string kind() const override {\n+    return \"method\";\n+  }\n+  virtual std::vector<Value*> call(SourceRange loc, Method & caller, at::ArrayRef<Value*> inputs, List<Attribute> attributes, size_t n_outputs) override {\n+    ensureSizeMatches(loc, 0, attributes.size(), \"keyword arguments\");\n+    ensureSizeMatches(loc, caller.num_inputs(), inputs.size(), \"inputs\");\n+    auto outputs = caller.emit_call_to(method, inputs);\n+    ensureSizeMatches(loc, outputs.size(), n_outputs, \"outputs\");\n+    return outputs;\n+  }\n+private:\n+  std::shared_ptr<Module> module;\n+  Method& method;\n+\n+};\n+\n+\n+struct ModuleValue : public SugaredValue {\n+  ModuleValue(std::shared_ptr<Module> module)\n+  : module(std::move(module)) {}\n+\n+  virtual std::string kind() const override {\n+    return \"module\";\n+  }\n+\n+  // select an attribute on it, e.g. `this.field`\n+  virtual std::shared_ptr<SugaredValue> attr(SourceRange loc, Method & m, const std::string& field) override {\n+    auto kind = module->find_attribute(field);\n+    switch(kind) {\n+      case NamedMember::None:\n+        throw ErrorReport(loc) << \"module has no attribute '\" << field << \"'\";\n+      case NamedMember::Module:\n+        return std::make_shared<ModuleValue>(module->get_module(field));\n+      case NamedMember::Method:\n+        return std::make_shared<MethodValue>(module, module->get_method(field));\n+      case NamedMember::Parameter:\n+        return std::make_shared<SimpleValue>(m.get_or_add_parameter(module->parameter_slot(field)));\n+    }\n+    return nullptr; // silence warning\n+  }\n+  // call module.forward\n+  virtual std::vector<Value*> call(SourceRange loc, Method & caller, at::ArrayRef<Value*> inputs, List<Attribute> attributes, size_t n_outputs) override {\n+    return attr(loc, caller, \"forward\")->call(loc, caller, inputs, attributes, n_outputs);\n+  }\n+private:\n+  std::shared_ptr<Module> module;\n+};\n+\n+// TODO: dedup with other init\n+\n+// we cannot use the default py:cast<autograd::Variable> because it currently\n+// unwraps the data tensor in the conversion process\n+\n+variable_tensor_list createVariableTensorList(py::tuple tuple, size_t reserve_extra_space = 0) {\n+  variable_tensor_list result;\n+  result.reserve(tuple.size() + reserve_extra_space);\n+  for(auto e : tuple) {\n+    result.push_back(py::cast<autograd::Variable>(e));\n+  }\n+  return result;\n+}\n+\n+py::object unpackVariableTensorList(std::vector<at::Tensor> outputs) {\n+  // if we don't tell pybind these are variables it chokes on the\n+  // conversion.\n+  // TODO: fix conversions to be sane and make sure this works.\n+  if(outputs.size() == 1) {\n+    return py::cast(static_cast<autograd::Variable&>(outputs[0]));\n+  } else {\n+    py::tuple tuple(outputs.size());\n+    for(size_t i = 0; i < outputs.size(); i++) {\n+      tuple[i] = py::cast(static_cast<autograd::Variable&>(outputs[i]));\n+    }\n+    return tuple;\n+  }\n+}\n+\n void initJitScriptBindings(PyObject* module) {\n   auto m = py::handle(module).cast<py::module>();\n-  py::class_<CompilationUnit>(m, \"CompilationUnit\")\n-      .def(\n-          \"get_graph\",\n-          &CompilationUnit::getGraph,\n-          py::return_value_policy::reference)\n-      .def(py::init<>())\n+  // torch.jit.ScriptModule is a subclass of this C++ object.\n+  // Methods here are prefixed with _ since they should not be\n+  // public.\n+  py::class_<Module, std::shared_ptr<Module>>(m, \"ScriptModule\")\n+      .def(py::init<bool>())\n       .def(\n-          \"define\",\n-          [](CompilationUnit* self,\n+          \"_define\",\n+          [](Module& m,\n              const std::string& script,\n-             ResolutionCallback rcb) {\n-            PythonResolver r(rcb);\n-            return self->define(script, r);\n-          });\n+             ResolutionCallback rcb, bool has_self) {\n+            auto self = has_self ? std::make_shared<ModuleValue>(m.shared_from_this()) : nullptr;\n+            return defineMethodsInModule(m, script, pythonResolver(rcb), self);\n+          })\n+      .def(\"_create_method\", [](Module& m, Def def, ResolutionCallback rcb) {\n+        defineMethodsInModule(\n+          m,\n+          { def },\n+          pythonResolver(rcb),\n+          std::make_shared<ModuleValue>(m.shared_from_this()));\n+      })\n+      .def(\"_get_method\",\n+      [](Module& self, const std::string& name) -> const Method& {\n+        return self.get_method(name);\n+      }, py::return_value_policy::reference_internal)\n+      .def(\"_register_or_set_parameter\", &Module::register_or_set_parameter)\n+      .def(\"_register_module\", &Module::register_module)\n+      .def(\"_set_parameter\", &Module::set_parameter)\n+      .def(\"_get_parameter\", &Module::get_parameter)\n+      .def(\"_get_module\", &Module::get_module)\n+      .def(\"_get_attribute\",[](Module& self, const std::string& name) -> py::object {\n+        switch(self.find_attribute(name)) {\n+          case NamedMember::Parameter:\n+            return py::cast(static_cast<const autograd::Variable&>(self.get_parameter(name)));\n+          case NamedMember::Module:\n+            return py::cast(self.get_module(name));\n+          case NamedMember::Method:\n+            return py::cast(self.get_method(name), py::return_value_policy::reference_internal, py::cast(self));\n+          case NamedMember::None:\n+          default: {\n+            return py::none();", "path": "torch/csrc/jit/script/init.cpp", "position": 215, "original_position": 211, "commit_id": "ea6aa3491a3ed3df04c89336181fc62bbae67cd7", "original_commit_id": "1c077075a28c6808727b4d63ae7ac69659ccf869", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "body": "Do we really want to return `None` in any case? Why not AttributeError? Also, I'd consider the `default` case harmful, because we really want this to be exhaustive (and want compiler warnings)", "created_at": "2018-03-11T16:47:12Z", "updated_at": "2018-11-23T15:40:35Z", "html_url": "https://github.com/pytorch/pytorch/pull/5630#discussion_r173661337", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/5630", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/173661337"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/5630#discussion_r173661337"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/5630"}}, "body_html": "<p>Do we really want to return <code>None</code> in any case? Why not AttributeError? Also, I'd consider the <code>default</code> case harmful, because we really want this to be exhaustive (and want compiler warnings)</p>", "body_text": "Do we really want to return None in any case? Why not AttributeError? Also, I'd consider the default case harmful, because we really want this to be exhaustive (and want compiler warnings)"}