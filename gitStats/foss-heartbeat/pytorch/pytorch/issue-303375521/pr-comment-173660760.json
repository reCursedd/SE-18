{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/173660760", "pull_request_review_id": 102606950, "id": 173660760, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE3MzY2MDc2MA==", "diff_hunk": "@@ -478,15 +539,63 @@ struct to_ir {\n     }\n   }\n \n-  // This will _always_ compute something, unlike 'getValue' which simply\n-  // returns an already computed reference if possible.\n+  // special rules apply when we directly call foo(a,b) when foo is an ident\n+  std::vector<Value*> emitApplyIdent(Ident ident, std::vector<Value*> inputs, List<Attribute> attributes, size_t output_size) {\n+    auto it = function_table.find(ident.name());\n+    if (it != function_table.end()) {\n+      if(inputs.size() != it->second.num_inputs())\n+        throw ErrorReport(ident) << \"expected \" << it->second.num_inputs() << \" but found \" << inputs.size();\n+      auto outputs = method.emit_call_to(it->second, inputs);\n+      expectOutputs(ident, output_size, outputs.size());\n+      return outputs;\n+    } else if (ident.name() == \"print\") {\n+      expectOutputs(ident, output_size, 0);\n+      if (!attributes.empty())\n+        throw ErrorReport(ident) << \"print doesn't accept any keyword arguments\";\n+      return emitNode(kPrint, ident.range(), inputs, 0 )->outputs();\n+    }\n+    Node* builtin = emitBuiltinCall(ident.range(), method, ident.name(), inputs, attributes, output_size);\n+    if (hasTensorOp(builtin)) {\n+      return builtin->outputs();\n+    }\n+    builtin->destroy();\n+    // it wasn't known built in, so treat it like standard apply\n+    return emitApplyExpr(Var::create(ident.range(), ident), inputs, attributes, output_size);\n+  }\n+\n+  std::vector<Value*> emitApplyExpr(Expr callee, const std::vector<Value*>& inputs, List<Attribute> attributes, size_t output_size) {\n+    // otherwise we evaluate the callee and then desugar it\n+    auto sv = emitSugaredExpr(callee);\n+    return sv->call(callee.range(), method, inputs, attributes, output_size);\n+  }\n+\n+  // any expression that can produce a SugaredValue are handled here\n+  // with emitExpr falling back to this function to handle them\n+  // the kinds handled here should be kept in sync with [SUGARED VALUES]\n+  // in emitExpr\n+  std::shared_ptr<SugaredValue> emitSugaredExpr(Expr tree) {\n+    switch(tree.kind()) {\n+      case TK_VAR:\n+        return environment_stack->getSugaredVar(Var(tree).name());\n+      case '.': {\n+        auto select = Select(tree);\n+        auto sv = emitSugaredExpr(select.value());\n+        return sv->attr(select.range(), method, select.selector().name());\n+      }\n+      default:\n+        return std::make_shared<SimpleValue>(emitExpr(tree, 1)[0]);", "path": "torch/csrc/jit/script/compiler.cpp", "position": 510, "original_position": 483, "commit_id": "ea6aa3491a3ed3df04c89336181fc62bbae67cd7", "original_commit_id": "1c077075a28c6808727b4d63ae7ac69659ccf869", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "body": "Hmm I think this function could have been structured better. From what I see it's called in two places: `emitExpr` (where it should *never hit the default case, or we'll enter infinite recursion*), or from `emitSugaredExpr` which will fail anyway if this `default` is triggered (`SimpleValue`s can't be called). Why not change it into a default that triggers a clear assertion failure? ", "created_at": "2018-03-11T16:30:25Z", "updated_at": "2018-11-23T15:40:35Z", "html_url": "https://github.com/pytorch/pytorch/pull/5630#discussion_r173660760", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/5630", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/173660760"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/5630#discussion_r173660760"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/5630"}}, "body_html": "<p>Hmm I think this function could have been structured better. From what I see it's called in two places: <code>emitExpr</code> (where it should <em>never hit the default case, or we'll enter infinite recursion</em>), or from <code>emitSugaredExpr</code> which will fail anyway if this <code>default</code> is triggered (<code>SimpleValue</code>s can't be called). Why not change it into a default that triggers a clear assertion failure?</p>", "body_text": "Hmm I think this function could have been structured better. From what I see it's called in two places: emitExpr (where it should never hit the default case, or we'll enter infinite recursion), or from emitSugaredExpr which will fail anyway if this default is triggered (SimpleValues can't be called). Why not change it into a default that triggers a clear assertion failure?"}