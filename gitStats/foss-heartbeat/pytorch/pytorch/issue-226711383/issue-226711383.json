{"url": "https://api.github.com/repos/pytorch/pytorch/issues/1493", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/1493/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/1493/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/1493/events", "html_url": "https://github.com/pytorch/pytorch/pull/1493", "id": 226711383, "node_id": "MDExOlB1bGxSZXF1ZXN0MTE5MjcyMTI5", "number": 1493, "title": "Avoid segfault when calling join_with with self as arg", "user": {"login": "lantiga", "id": 191033, "node_id": "MDQ6VXNlcjE5MTAzMw==", "avatar_url": "https://avatars2.githubusercontent.com/u/191033?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lantiga", "html_url": "https://github.com/lantiga", "followers_url": "https://api.github.com/users/lantiga/followers", "following_url": "https://api.github.com/users/lantiga/following{/other_user}", "gists_url": "https://api.github.com/users/lantiga/gists{/gist_id}", "starred_url": "https://api.github.com/users/lantiga/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lantiga/subscriptions", "organizations_url": "https://api.github.com/users/lantiga/orgs", "repos_url": "https://api.github.com/users/lantiga/repos", "events_url": "https://api.github.com/users/lantiga/events{/privacy}", "received_events_url": "https://api.github.com/users/lantiga/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 6, "created_at": "2017-05-05T22:53:30Z", "updated_at": "2017-05-09T20:31:11Z", "closed_at": "2017-05-06T22:35:11Z", "author_association": "COLLABORATOR", "pull_request": {"url": "https://api.github.com/repos/pytorch/pytorch/pulls/1493", "html_url": "https://github.com/pytorch/pytorch/pull/1493", "diff_url": "https://github.com/pytorch/pytorch/pull/1493.diff", "patch_url": "https://github.com/pytorch/pytorch/pull/1493.patch"}, "body_html": "<p>This PR solves <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"226480266\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/1480\" data-hovercard-type=\"issue\" data-hovercard-url=\"/pytorch/pytorch/issues/1480/hovercard\" href=\"https://github.com/pytorch/pytorch/issues/1480\">#1480</a> and potentially similar corner cases.</p>\n<p>With reference to <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"226480266\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/1480\" data-hovercard-type=\"issue\" data-hovercard-url=\"/pytorch/pytorch/issues/1480/hovercard\" href=\"https://github.com/pytorch/pytorch/issues/1480\">#1480</a>, when permute is called, the input and the result are marked as sharing storage (<a href=\"https://github.com/pytorch/pytorch/blob/master/torch/autograd/_functions/tensor.py#L161\">https://github.com/pytorch/pytorch/blob/master/torch/autograd/_functions/tensor.py#L161</a>).<br>\nWhen identity indices (e.g. <code>(0,1,2)</code>) are provided, <code>input</code> and <code>result</code> are the same object, i.e. marking causes the segfault.</p>\n<p>Marking leads to this call:<br>\n<a href=\"https://github.com/pytorch/pytorch/blob/master/torch/csrc/autograd/python_function.cpp#L479\">https://github.com/pytorch/pytorch/blob/master/torch/csrc/autograd/python_function.cpp#L479</a></p>\n<pre><code>v2-&gt;cdata-&gt;version_counter-&gt;join_with(*v1-&gt;cdata-&gt;version_counter);\n</code></pre>\n<p>with <code>v1</code> and <code>v2</code> now being the same object.</p>\n<p>Which in turn leads to <a href=\"https://github.com/pytorch/pytorch/blob/master/torch/csrc/autograd/variable_version.h#L20-L25\">https://github.com/pytorch/pytorch/blob/master/torch/csrc/autograd/variable_version.h#L20-L25</a></p>\n<pre><code>  void join_with(VariableVersion &amp;other) {\n    cleanup(); // &lt;------- version_block deallocated and set to null here \n    version_block = other.version_block; &lt;------- other is the same object, so other.version_block is null now\n    version_block[1]++; // &lt;------- segfault!\n    version_block[2]++;\n  }\n</code></pre>\n<p>With this PR, <code>join_with</code> simply returns (no need to increase versions, <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=4583066\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/apaszke\">@apaszke</a> <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=1310570\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/soumith\">@soumith</a> please check that my assumption is correct) when <code>this == &amp;other</code>.</p>", "body_text": "This PR solves #1480 and potentially similar corner cases.\nWith reference to #1480, when permute is called, the input and the result are marked as sharing storage (https://github.com/pytorch/pytorch/blob/master/torch/autograd/_functions/tensor.py#L161).\nWhen identity indices (e.g. (0,1,2)) are provided, input and result are the same object, i.e. marking causes the segfault.\nMarking leads to this call:\nhttps://github.com/pytorch/pytorch/blob/master/torch/csrc/autograd/python_function.cpp#L479\nv2->cdata->version_counter->join_with(*v1->cdata->version_counter);\n\nwith v1 and v2 now being the same object.\nWhich in turn leads to https://github.com/pytorch/pytorch/blob/master/torch/csrc/autograd/variable_version.h#L20-L25\n  void join_with(VariableVersion &other) {\n    cleanup(); // <------- version_block deallocated and set to null here \n    version_block = other.version_block; <------- other is the same object, so other.version_block is null now\n    version_block[1]++; // <------- segfault!\n    version_block[2]++;\n  }\n\nWith this PR, join_with simply returns (no need to increase versions, @apaszke @soumith please check that my assumption is correct) when this == &other.", "body": "This PR solves #1480 and potentially similar corner cases.\r\n\r\nWith reference to #1480, when permute is called, the input and the result are marked as sharing storage (https://github.com/pytorch/pytorch/blob/master/torch/autograd/_functions/tensor.py#L161).\r\nWhen identity indices (e.g. `(0,1,2)`) are provided, `input` and `result` are the same object, i.e. marking causes the segfault.\r\n\r\nMarking leads to this call:\r\nhttps://github.com/pytorch/pytorch/blob/master/torch/csrc/autograd/python_function.cpp#L479\r\n```\r\nv2->cdata->version_counter->join_with(*v1->cdata->version_counter);\r\n```\r\nwith `v1` and `v2` now being the same object.\r\n\r\nWhich in turn leads to https://github.com/pytorch/pytorch/blob/master/torch/csrc/autograd/variable_version.h#L20-L25\r\n```\r\n  void join_with(VariableVersion &other) {\r\n    cleanup(); // <------- version_block deallocated and set to null here \r\n    version_block = other.version_block; <------- other is the same object, so other.version_block is null now\r\n    version_block[1]++; // <------- segfault!\r\n    version_block[2]++;\r\n  }\r\n```\r\n\r\nWith this PR, `join_with` simply returns (no need to increase versions, @apaszke @soumith please check that my assumption is correct) when `this == &other`."}