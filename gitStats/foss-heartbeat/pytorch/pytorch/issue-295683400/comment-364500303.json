{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/364500303", "html_url": "https://github.com/pytorch/pytorch/pull/5145#issuecomment-364500303", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/5145", "id": 364500303, "node_id": "MDEyOklzc3VlQ29tbWVudDM2NDUwMDMwMw==", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "created_at": "2018-02-09T17:24:29Z", "updated_at": "2018-02-09T17:24:39Z", "author_association": "MEMBER", "body_html": "<blockquote>\n<p>match needs to verify the number of subtrees is correct.</p>\n</blockquote>\n<p>Can add an overload that checks it, but note that <code>subtree(i)</code> will still throw an exception if it's out of bounds, so it's not like it's unsafe at the moment. Let me know if you still think I should add it.</p>\n<blockquote>\n<p>abstract base classes like Type, Expr, and Statement need to have construction checks that the concrete type is in the class. Otherwise Expr(foo) means very little.</p>\n</blockquote>\n<p>I've actually been planning to make the constructors of those base classes protected (with public copy/move constructors), so that the only way to obtain an <code>Expr</code> is to upcast a concrete subclass.</p>\n<blockquote>\n<p>When constructing a new List from a vector, we should check each member of the list is the correct class.</p>\n</blockquote>\n<p>The only way to construct a list is to give it a <code>const std::vector&lt;T&gt;&amp;</code>, which means that it is well typed. If you meant that we should check the type in the constructor from a <code>TreeRef</code> I thought about it, but it's hard/annoying for a few reasons:</p>\n<ol>\n<li>We'll be doing those checks over and over again, as every list access also requires you to perform the same check (we do this check lazily at the moment).</li>\n<li>As long as you construct the trees using <code>::create</code> methods of tree views, it's guaranteed to be well-formed anyway.</li>\n<li>We need some kind of traits/static fields that list what kinds of tokens are valid for a particular type. This is a bit annoying to maintain, as some types (e.g. <code>Expr</code>) have a huge number of possible values.</li>\n<li>I can't use <code>T(list[i])</code> in a loop (to do the quick check), because this won't work with the strategy of making constructors of base classes protected.</li>\n<li>This would be the only node that performs \"deep\" checks, so I decided to make it consistent with all other nodes, and check the types only when you actually access members.</li>\n</ol>\n<p>Therefore, I decided to skip the type check in the constructor. Let me know what you think.</p>", "body_text": "match needs to verify the number of subtrees is correct.\n\nCan add an overload that checks it, but note that subtree(i) will still throw an exception if it's out of bounds, so it's not like it's unsafe at the moment. Let me know if you still think I should add it.\n\nabstract base classes like Type, Expr, and Statement need to have construction checks that the concrete type is in the class. Otherwise Expr(foo) means very little.\n\nI've actually been planning to make the constructors of those base classes protected (with public copy/move constructors), so that the only way to obtain an Expr is to upcast a concrete subclass.\n\nWhen constructing a new List from a vector, we should check each member of the list is the correct class.\n\nThe only way to construct a list is to give it a const std::vector<T>&, which means that it is well typed. If you meant that we should check the type in the constructor from a TreeRef I thought about it, but it's hard/annoying for a few reasons:\n\nWe'll be doing those checks over and over again, as every list access also requires you to perform the same check (we do this check lazily at the moment).\nAs long as you construct the trees using ::create methods of tree views, it's guaranteed to be well-formed anyway.\nWe need some kind of traits/static fields that list what kinds of tokens are valid for a particular type. This is a bit annoying to maintain, as some types (e.g. Expr) have a huge number of possible values.\nI can't use T(list[i]) in a loop (to do the quick check), because this won't work with the strategy of making constructors of base classes protected.\nThis would be the only node that performs \"deep\" checks, so I decided to make it consistent with all other nodes, and check the types only when you actually access members.\n\nTherefore, I decided to skip the type check in the constructor. Let me know what you think.", "body": "> match needs to verify the number of subtrees is correct.\r\n\r\nCan add an overload that checks it, but note that `subtree(i)` will still throw an exception if it's out of bounds, so it's not like it's unsafe at the moment. Let me know if you still think I should add it.\r\n\r\n> abstract base classes like Type, Expr, and Statement need to have construction checks that the concrete type is in the class. Otherwise Expr(foo) means very little.\r\n\r\nI've actually been planning to make the constructors of those base classes protected (with public copy/move constructors), so that the only way to obtain an `Expr` is to upcast a concrete subclass.\r\n\r\n> When constructing a new List from a vector, we should check each member of the list is the correct class.\r\n\r\nThe only way to construct a list is to give it a `const std::vector<T>&`, which means that it is well typed. If you meant that we should check the type in the constructor from a `TreeRef` I thought about it, but it's hard/annoying for a few reasons:\r\n1. We'll be doing those checks over and over again, as every list access also requires you to perform the same check (we do this check lazily at the moment).\r\n2. As long as you construct the trees using `::create` methods of tree views, it's guaranteed to be well-formed anyway.\r\n3. We need some kind of traits/static fields that list what kinds of tokens are valid for a particular type. This is a bit annoying to maintain, as some types (e.g. `Expr`) have a huge number of possible values.\r\n4. I can't use `T(list[i])` in a loop (to do the quick check), because this won't work with the strategy of making constructors of base classes protected.\r\n5. This would be the only node that performs \"deep\" checks, so I decided to make it consistent with all other nodes, and check the types only when you actually access members.\r\n\r\nTherefore, I decided to skip the type check in the constructor. Let me know what you think."}