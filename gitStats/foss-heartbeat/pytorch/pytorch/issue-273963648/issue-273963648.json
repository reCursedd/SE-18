{"url": "https://api.github.com/repos/pytorch/pytorch/issues/3705", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/3705/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/3705/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/3705/events", "html_url": "https://github.com/pytorch/pytorch/pull/3705", "id": 273963648, "node_id": "MDExOlB1bGxSZXF1ZXN0MTUyNjMzNDg5", "number": 3705, "title": "Refactor ir.h to distinguish Nodes and Values", "user": {"login": "zdevito", "id": 370202, "node_id": "MDQ6VXNlcjM3MDIwMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/370202?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zdevito", "html_url": "https://github.com/zdevito", "followers_url": "https://api.github.com/users/zdevito/followers", "following_url": "https://api.github.com/users/zdevito/following{/other_user}", "gists_url": "https://api.github.com/users/zdevito/gists{/gist_id}", "starred_url": "https://api.github.com/users/zdevito/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zdevito/subscriptions", "organizations_url": "https://api.github.com/users/zdevito/orgs", "repos_url": "https://api.github.com/users/zdevito/repos", "events_url": "https://api.github.com/users/zdevito/events{/privacy}", "received_events_url": "https://api.github.com/users/zdevito/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 12, "created_at": "2017-11-14T22:18:12Z", "updated_at": "2018-11-23T15:36:32Z", "closed_at": "2017-11-15T19:47:19Z", "author_association": "CONTRIBUTOR", "pull_request": {"url": "https://api.github.com/repos/pytorch/pytorch/pulls/3705", "html_url": "https://github.com/pytorch/pytorch/pull/3705", "diff_url": "https://github.com/pytorch/pytorch/pull/3705.diff", "patch_url": "https://github.com/pytorch/pytorch/pull/3705.patch"}, "body_html": "<p>This commit adds a Value type similar to the one <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=13564\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/ezyang\">@ezyang</a> suggested a while<br>\nago for handling multi-return nodes.</p>\n<p>Previously if we had a graph like:</p>\n<p>a = op1(b)<br>\nc, d = op2(a)</p>\n<p>Then its in-memory format would look like:</p>\n<p>%0 = op1(b)<br>\n%1 = op2(%0)<br>\n%2 = select(%1, 0)<br>\n%2 = select(%1, 1)</p>\n<p>Select nodes were used only to handle the multi-output case. In the<br>\nsingle-output case ops referred directly to their uses.</p>\n<p>This required special handling for the single- and multi- output cases,<br>\nand was confusing when used with ONNX which distinguishes values (the<br>\ninputs/outputs of a node) from the nodes themselves (e.g. a Conv).</p>\n<p>This commit adds the Node/Value distinction to the IR. In the example<br>\nabove, <code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code> are now Value objects, while <code>op1</code> and<br>\n<code>op2</code> are now Node objects. Inputs/Outputs to the graph are values.</p>\n<ul>\n<li>Nodes now always have multiple outputs, accessible through their <code>output()</code><br>\nmethod.</li>\n<li>Methods exist for adding/removing outputs from a node.</li>\n<li>Nodes own their output Values, destroying a node destroys its outputs and it<br>\nis only valid to destroy a node when no uses of its outputs remain.</li>\n<li>Unlike select, Values do not appear in the nodes list.</li>\n<li>The method <code>node()</code> on <code>Value</code> retrieves its defining node. Calling it<br>\nis always valid. For inputs, its kind is \"Param\". Like \"Return\" there is a single Param<br>\nnode representing all inputs.</li>\n<li>For single-output Nodes, the method <code>output()</code> retrieves the single<br>\noutput Value, asserting that the node is in-fact single output.</li>\n<li>Functions are the same, but some functions like <code>type()</code> have moved to<br>\nValue.</li>\n<li><code>replaceAllUsesWith</code> is now sanely defined for both Values and Nodes.<br>\nIn the case of Nodes, it replaces all outputs of the node with the outputs<br>\nof the replacement node.</li>\n<li>stage is defined both on Node/Value. This is because Inputs require a stage.</li>\n<li>Apart from changing data types from Node-&gt;Value most passes remain the same.<br>\nThings that previously assumed single-output nodes now have to call output()<br>\nto get the node.</li>\n<li>This removes the uses = [...] field in the outputs because it was<br>\ngetting confusing even before this commit when uses would refer to nodes,<br>\nbut we print the names of Values. The lint pass validates the use list,<br>\nso printing it out seems less necessary.</li>\n</ul>", "body_text": "This commit adds a Value type similar to the one @ezyang suggested a while\nago for handling multi-return nodes.\nPreviously if we had a graph like:\na = op1(b)\nc, d = op2(a)\nThen its in-memory format would look like:\n%0 = op1(b)\n%1 = op2(%0)\n%2 = select(%1, 0)\n%2 = select(%1, 1)\nSelect nodes were used only to handle the multi-output case. In the\nsingle-output case ops referred directly to their uses.\nThis required special handling for the single- and multi- output cases,\nand was confusing when used with ONNX which distinguishes values (the\ninputs/outputs of a node) from the nodes themselves (e.g. a Conv).\nThis commit adds the Node/Value distinction to the IR. In the example\nabove, a, b, c, and d are now Value objects, while op1 and\nop2 are now Node objects. Inputs/Outputs to the graph are values.\n\nNodes now always have multiple outputs, accessible through their output()\nmethod.\nMethods exist for adding/removing outputs from a node.\nNodes own their output Values, destroying a node destroys its outputs and it\nis only valid to destroy a node when no uses of its outputs remain.\nUnlike select, Values do not appear in the nodes list.\nThe method node() on Value retrieves its defining node. Calling it\nis always valid. For inputs, its kind is \"Param\". Like \"Return\" there is a single Param\nnode representing all inputs.\nFor single-output Nodes, the method output() retrieves the single\noutput Value, asserting that the node is in-fact single output.\nFunctions are the same, but some functions like type() have moved to\nValue.\nreplaceAllUsesWith is now sanely defined for both Values and Nodes.\nIn the case of Nodes, it replaces all outputs of the node with the outputs\nof the replacement node.\nstage is defined both on Node/Value. This is because Inputs require a stage.\nApart from changing data types from Node->Value most passes remain the same.\nThings that previously assumed single-output nodes now have to call output()\nto get the node.\nThis removes the uses = [...] field in the outputs because it was\ngetting confusing even before this commit when uses would refer to nodes,\nbut we print the names of Values. The lint pass validates the use list,\nso printing it out seems less necessary.", "body": "This commit adds a Value type similar to the one @ezyang suggested a while\r\nago for handling multi-return nodes.\r\n\r\nPreviously if we had a graph like:\r\n\r\n  a = op1(b)\r\n  c, d = op2(a)\r\n\r\nThen its in-memory format would look like:\r\n\r\n  %0 = op1(b)\r\n  %1 = op2(%0)\r\n  %2 = select(%1, 0)\r\n  %2 = select(%1, 1)\r\n\r\nSelect nodes were used only to handle the multi-output case. In the\r\nsingle-output case ops referred directly to their uses.\r\n\r\nThis required special handling for the single- and multi- output cases,\r\nand was confusing when used with ONNX which distinguishes values (the\r\ninputs/outputs of a node) from the nodes themselves (e.g. a Conv).\r\n\r\nThis commit adds the Node/Value distinction to the IR. In the example\r\nabove, `a`, `b`, `c`, and `d` are now Value objects, while `op1` and\r\n`op2` are now Node objects. Inputs/Outputs to the graph are values.\r\n\r\n* Nodes now always have multiple outputs, accessible through their `output()`\r\n  method.\r\n* Methods exist for adding/removing outputs from a node.\r\n* Nodes own their output Values, destroying a node destroys its outputs and it\r\nis only valid to destroy a node when no uses of its outputs remain.\r\n* Unlike select, Values do not appear in the nodes list.\r\n* The method `node()` on `Value` retrieves its defining node. Calling it\r\nis always valid. For inputs, its kind is \"Param\". Like \"Return\" there is a single Param\r\nnode representing all inputs.\r\n* For single-output Nodes, the method `output()` retrieves the single\r\noutput Value, asserting that the node is in-fact single output.\r\n* Functions are the same, but some functions like `type()` have moved to\r\nValue.\r\n* `replaceAllUsesWith` is now sanely defined for both Values and Nodes.\r\nIn the case of Nodes, it replaces all outputs of the node with the outputs\r\nof the replacement node.\r\n* stage is defined both on Node/Value. This is because Inputs require a stage.\r\n* Apart from changing data types from Node->Value most passes remain the same.\r\n  Things that previously assumed single-output nodes now have to call output()\r\n  to get the node.\r\n* This removes the uses = [...] field in the outputs because it was\r\ngetting confusing even before this commit when uses would refer to nodes,\r\nbut we print the names of Values. The lint pass validates the use list,\r\nso printing it out seems less necessary."}