{"url": "https://api.github.com/repos/pytorch/pytorch/issues/1631", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/1631/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/1631/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/1631/events", "html_url": "https://github.com/pytorch/pytorch/issues/1631", "id": 230809443, "node_id": "MDU6SXNzdWUyMzA4MDk0NDM=", "number": 1631, "title": "Gather backward is incorrect with repeated indices", "user": {"login": "jcjohnson", "id": 2718714, "node_id": "MDQ6VXNlcjI3MTg3MTQ=", "avatar_url": "https://avatars2.githubusercontent.com/u/2718714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jcjohnson", "html_url": "https://github.com/jcjohnson", "followers_url": "https://api.github.com/users/jcjohnson/followers", "following_url": "https://api.github.com/users/jcjohnson/following{/other_user}", "gists_url": "https://api.github.com/users/jcjohnson/gists{/gist_id}", "starred_url": "https://api.github.com/users/jcjohnson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jcjohnson/subscriptions", "organizations_url": "https://api.github.com/users/jcjohnson/orgs", "repos_url": "https://api.github.com/users/jcjohnson/repos", "events_url": "https://api.github.com/users/jcjohnson/events{/privacy}", "received_events_url": "https://api.github.com/users/jcjohnson/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 424131847, "node_id": "MDU6TGFiZWw0MjQxMzE4NDc=", "url": "https://api.github.com/repos/pytorch/pytorch/labels/bug", "name": "bug", "color": "b60205", "default": true}, {"id": 443484135, "node_id": "MDU6TGFiZWw0NDM0ODQxMzU=", "url": "https://api.github.com/repos/pytorch/pytorch/labels/high%20priority", "name": "high priority", "color": "F22613", "default": false}], "state": "closed", "locked": false, "assignee": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}], "milestone": {"url": "https://api.github.com/repos/pytorch/pytorch/milestones/2", "html_url": "https://github.com/pytorch/pytorch/milestone/2", "labels_url": "https://api.github.com/repos/pytorch/pytorch/milestones/2/labels", "id": 2536200, "node_id": "MDk6TWlsZXN0b25lMjUzNjIwMA==", "number": 2, "title": "v0.2", "description": "", "creator": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "open_issues": 2, "closed_issues": 34, "state": "closed", "created_at": "2017-05-22T18:19:28Z", "updated_at": "2018-08-06T21:16:06Z", "due_on": "2017-06-04T07:00:00Z", "closed_at": "2018-08-06T21:16:06Z"}, "comments": 3, "created_at": "2017-05-23T18:56:32Z", "updated_at": "2017-05-25T21:09:25Z", "closed_at": "2017-05-25T21:09:25Z", "author_association": "CONTRIBUTOR", "body_html": "<p>The gather function gives incorrect gradients on both CPU and GPU when using repeated indices; no warnings or errors are raised, and the documentation doesn't say anything about this. I've seen this discussed a bit on slack, but couldn't find any issues for it on GitHub.</p>\n<p>Here's a small test case (using PyTorch 0.1.12_2 on Ubuntu 16.04):</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">import</span> torch\n<span class=\"pl-k\">from</span> torch.autograd <span class=\"pl-k\">import</span> Variable\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">gather_test</span>(<span class=\"pl-smi\">dtype</span>):\n  x <span class=\"pl-k\">=</span> torch.FloatTensor([<span class=\"pl-c1\">0.1</span>])\n  i <span class=\"pl-k\">=</span> torch.LongTensor([<span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">0</span>])\n  x <span class=\"pl-k\">=</span> Variable(x.type(dtype), <span class=\"pl-v\">requires_grad</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">True</span>)\n  i <span class=\"pl-k\">=</span> Variable(i.type(dtype).long())\n  y <span class=\"pl-k\">=</span> x.gather(<span class=\"pl-c1\">0</span>, i)\n  dy <span class=\"pl-k\">=</span> torch.FloatTensor([<span class=\"pl-c1\">0.2</span>, <span class=\"pl-c1\">0.3</span>]).type(dtype)\n  y.backward(dy)\n  <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>dtype: <span class=\"pl-pds\">'</span></span>, dtype)\n  <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>x: <span class=\"pl-pds\">'</span></span>, x.data.cpu().numpy())\n  <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>i: <span class=\"pl-pds\">'</span></span>, i.data.cpu().numpy())\n  <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>y: <span class=\"pl-pds\">'</span></span>, y.data.cpu().numpy())\n  <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>dy: <span class=\"pl-pds\">'</span></span>, dy.cpu().numpy())\n  <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>dx: <span class=\"pl-pds\">'</span></span>, x.grad.data.cpu().numpy())\n\ngather_test(torch.FloatTensor)\ngather_test(torch.cuda.FloatTensor)</pre></div>\n<p>This gives the output:</p>\n<pre><code>dtype:  &lt;class 'torch.FloatTensor'&gt;\nx:  [ 0.1]\ni:  [0 0]\ny:  [ 0.1  0.1]\ndy:  [ 0.2         0.30000001]\ndx:  [ 0.30000001]\ndtype:  &lt;class 'torch.cuda.FloatTensor'&gt;\nx:  [ 0.1]\ni:  [0 0]\ny:  [ 0.1  0.1]\ndy:  [ 0.2         0.30000001]\ndx:  [ 0.30000001]\n</code></pre>\n<p>For this example I expect dx to be [0.5] since the first element of x is duplicated to both elements of y; however instead of summing the elements of dy, the gather backward pass simply chooses one of the elements of dy corresponding to the element of x.</p>\n<p>In this particular example we could use <code>index_select</code> instead of <code>gather</code>, but there are a lot of situations where <code>index_select</code> cannot substitute for <code>gather</code>; it would thus be extremely useful if <code>gather</code> could support repeated indices.</p>", "body_text": "The gather function gives incorrect gradients on both CPU and GPU when using repeated indices; no warnings or errors are raised, and the documentation doesn't say anything about this. I've seen this discussed a bit on slack, but couldn't find any issues for it on GitHub.\nHere's a small test case (using PyTorch 0.1.12_2 on Ubuntu 16.04):\nimport torch\nfrom torch.autograd import Variable\n\ndef gather_test(dtype):\n  x = torch.FloatTensor([0.1])\n  i = torch.LongTensor([0, 0])\n  x = Variable(x.type(dtype), requires_grad=True)\n  i = Variable(i.type(dtype).long())\n  y = x.gather(0, i)\n  dy = torch.FloatTensor([0.2, 0.3]).type(dtype)\n  y.backward(dy)\n  print('dtype: ', dtype)\n  print('x: ', x.data.cpu().numpy())\n  print('i: ', i.data.cpu().numpy())\n  print('y: ', y.data.cpu().numpy())\n  print('dy: ', dy.cpu().numpy())\n  print('dx: ', x.grad.data.cpu().numpy())\n\ngather_test(torch.FloatTensor)\ngather_test(torch.cuda.FloatTensor)\nThis gives the output:\ndtype:  <class 'torch.FloatTensor'>\nx:  [ 0.1]\ni:  [0 0]\ny:  [ 0.1  0.1]\ndy:  [ 0.2         0.30000001]\ndx:  [ 0.30000001]\ndtype:  <class 'torch.cuda.FloatTensor'>\nx:  [ 0.1]\ni:  [0 0]\ny:  [ 0.1  0.1]\ndy:  [ 0.2         0.30000001]\ndx:  [ 0.30000001]\n\nFor this example I expect dx to be [0.5] since the first element of x is duplicated to both elements of y; however instead of summing the elements of dy, the gather backward pass simply chooses one of the elements of dy corresponding to the element of x.\nIn this particular example we could use index_select instead of gather, but there are a lot of situations where index_select cannot substitute for gather; it would thus be extremely useful if gather could support repeated indices.", "body": "The gather function gives incorrect gradients on both CPU and GPU when using repeated indices; no warnings or errors are raised, and the documentation doesn't say anything about this. I've seen this discussed a bit on slack, but couldn't find any issues for it on GitHub.\r\n\r\nHere's a small test case (using PyTorch 0.1.12_2 on Ubuntu 16.04):\r\n\r\n```python\r\nimport torch\r\nfrom torch.autograd import Variable\r\n\r\ndef gather_test(dtype):\r\n  x = torch.FloatTensor([0.1])\r\n  i = torch.LongTensor([0, 0])\r\n  x = Variable(x.type(dtype), requires_grad=True)\r\n  i = Variable(i.type(dtype).long())\r\n  y = x.gather(0, i)\r\n  dy = torch.FloatTensor([0.2, 0.3]).type(dtype)\r\n  y.backward(dy)\r\n  print('dtype: ', dtype)\r\n  print('x: ', x.data.cpu().numpy())\r\n  print('i: ', i.data.cpu().numpy())\r\n  print('y: ', y.data.cpu().numpy())\r\n  print('dy: ', dy.cpu().numpy())\r\n  print('dx: ', x.grad.data.cpu().numpy())\r\n\r\ngather_test(torch.FloatTensor)\r\ngather_test(torch.cuda.FloatTensor)\r\n```\r\n\r\nThis gives the output:\r\n\r\n```\r\ndtype:  <class 'torch.FloatTensor'>\r\nx:  [ 0.1]\r\ni:  [0 0]\r\ny:  [ 0.1  0.1]\r\ndy:  [ 0.2         0.30000001]\r\ndx:  [ 0.30000001]\r\ndtype:  <class 'torch.cuda.FloatTensor'>\r\nx:  [ 0.1]\r\ni:  [0 0]\r\ny:  [ 0.1  0.1]\r\ndy:  [ 0.2         0.30000001]\r\ndx:  [ 0.30000001]\r\n```\r\n\r\nFor this example I expect dx to be [0.5] since the first element of x is duplicated to both elements of y; however instead of summing the elements of dy, the gather backward pass simply chooses one of the elements of dy corresponding to the element of x.\r\n\r\nIn this particular example we could use `index_select` instead of `gather`, but there are a lot of situations where `index_select` cannot substitute for `gather`; it would thus be extremely useful if `gather` could support repeated indices. "}