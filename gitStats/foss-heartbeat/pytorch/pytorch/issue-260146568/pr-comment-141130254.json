{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/141130254", "pull_request_review_id": 65300447, "id": 141130254, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE0MTEzMDI1NA==", "diff_hunk": "@@ -89,10 +93,11 @@ def test_function_as_argument(self):\n         cx = Variable(torch.randn(3, 20))\n         lstm = nn.LSTMCell(10, 20)\n \n-        def a_function(a, b):\n+        @torch.jit.trace(nderivs=0, params=lstm.parameters())", "path": "test/test_jit.py", "position": null, "original_position": 54, "commit_id": "32f59e2ce8acb246bd9091e44732a5f339e4cc4b", "original_commit_id": "720239f566d9dc62f13970a32ef4963f3ca64e8d", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "body": "Following this line of reasoning to its conclusion, the suggestion is that any time we encounter a Variable which is not an input and not a result of a traced computation, instead of turning it into a constant (as is the behavior today, but @apaszke has said they're not too keen on this behavior so it could be changed), we instead *add* another input to the compiler IR we a tracing, and *furthermore* retain a reference to a Variable on this input. If we don't have a reference to the Variable, when someone wants to interpret the trace, they wouldn't be able to find a value to fill in for the variable.\r\n\r\nI'm not sure if this is good design, but it has some good properties (user no longer has to specify parameters for functions.) There is some work we have to do to implement this correctly. One thing that is dangerous is that if a user *allocates* a Variable while within tracing, we MUST NOT treat this as an input. So moving into this regime will force us to teach the Variable allocation process to know something about whether or not we are tracing or not. Additionally, we probably don't want this logic to trigger when we are tracing backwards, so it has to be conditional on that as well. It's hard to say exactly how complicated implementing this would be, but I know at the very least these two things would have to be addressed.", "created_at": "2017-09-26T17:41:28Z", "updated_at": "2018-11-23T15:34:49Z", "html_url": "https://github.com/pytorch/pytorch/pull/2852#discussion_r141130254", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/2852", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/141130254"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/2852#discussion_r141130254"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/2852"}}, "body_html": "<p>Following this line of reasoning to its conclusion, the suggestion is that any time we encounter a Variable which is not an input and not a result of a traced computation, instead of turning it into a constant (as is the behavior today, but <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=4583066\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/apaszke\">@apaszke</a> has said they're not too keen on this behavior so it could be changed), we instead <em>add</em> another input to the compiler IR we a tracing, and <em>furthermore</em> retain a reference to a Variable on this input. If we don't have a reference to the Variable, when someone wants to interpret the trace, they wouldn't be able to find a value to fill in for the variable.</p>\n<p>I'm not sure if this is good design, but it has some good properties (user no longer has to specify parameters for functions.) There is some work we have to do to implement this correctly. One thing that is dangerous is that if a user <em>allocates</em> a Variable while within tracing, we MUST NOT treat this as an input. So moving into this regime will force us to teach the Variable allocation process to know something about whether or not we are tracing or not. Additionally, we probably don't want this logic to trigger when we are tracing backwards, so it has to be conditional on that as well. It's hard to say exactly how complicated implementing this would be, but I know at the very least these two things would have to be addressed.</p>", "body_text": "Following this line of reasoning to its conclusion, the suggestion is that any time we encounter a Variable which is not an input and not a result of a traced computation, instead of turning it into a constant (as is the behavior today, but @apaszke has said they're not too keen on this behavior so it could be changed), we instead add another input to the compiler IR we a tracing, and furthermore retain a reference to a Variable on this input. If we don't have a reference to the Variable, when someone wants to interpret the trace, they wouldn't be able to find a value to fill in for the variable.\nI'm not sure if this is good design, but it has some good properties (user no longer has to specify parameters for functions.) There is some work we have to do to implement this correctly. One thing that is dangerous is that if a user allocates a Variable while within tracing, we MUST NOT treat this as an input. So moving into this regime will force us to teach the Variable allocation process to know something about whether or not we are tracing or not. Additionally, we probably don't want this logic to trigger when we are tracing backwards, so it has to be conditional on that as well. It's hard to say exactly how complicated implementing this would be, but I know at the very least these two things would have to be addressed.", "in_reply_to_id": 140845175}