{"url": "https://api.github.com/repos/pytorch/pytorch/issues/10165", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/10165/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/10165/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/10165/events", "html_url": "https://github.com/pytorch/pytorch/issues/10165", "id": 347061346, "node_id": "MDU6SXNzdWUzNDcwNjEzNDY=", "number": 10165, "title": "torch.utils.data.random_split() returns dataset index as tensor", "user": {"login": "mariosfourn", "id": 33094229, "node_id": "MDQ6VXNlcjMzMDk0MjI5", "avatar_url": "https://avatars3.githubusercontent.com/u/33094229?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mariosfourn", "html_url": "https://github.com/mariosfourn", "followers_url": "https://api.github.com/users/mariosfourn/followers", "following_url": "https://api.github.com/users/mariosfourn/following{/other_user}", "gists_url": "https://api.github.com/users/mariosfourn/gists{/gist_id}", "starred_url": "https://api.github.com/users/mariosfourn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mariosfourn/subscriptions", "organizations_url": "https://api.github.com/users/mariosfourn/orgs", "repos_url": "https://api.github.com/users/mariosfourn/repos", "events_url": "https://api.github.com/users/mariosfourn/events{/privacy}", "received_events_url": "https://api.github.com/users/mariosfourn/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 466131885, "node_id": "MDU6TGFiZWw0NjYxMzE4ODU=", "url": "https://api.github.com/repos/pytorch/pytorch/labels/needs%20discussion", "name": "needs discussion", "color": "cc317c", "default": false}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2018-08-02T15:24:20Z", "updated_at": "2018-08-15T19:14:00Z", "closed_at": null, "author_association": "NONE", "body_html": "<h2>Issue description</h2>\n<p><code>torch.utils.data.random_split()</code> returns the index of the datapoint (idx) as a tensor rather than a float which messes up the <code>__getitem__()</code> routine of the dataset</p>\n<h2>Code example</h2>\n<pre><code>class AntsDataset(Dataset):\n    def __init__(self, root_dir, csv_file, transform=None):\n       \n        self.rotations = pd.read_csv(csv_file,header=None)\n        self.root_dir = root_dir\n        self.transform = transform\n\n    def __len__(self):\n        return len(self.rotations)\n\n    def __getitem__(self, idx):\n        import ipdb; ipdb.set_trace()\n        img_name = os.path.join(self.root_dir,\n                                self.rotations.iloc[idx, 0])\n        image = plt.imread(img_name,format='RGB')\n        rotation = self.rotations.iloc[idx, 1].astype('float')\n\n        if self.transform is not None:\n            image=self.transform(image)\n\n        return (image, rotation)\n\nants_dataset=AntsDataset(ants1_root_dir, ants1_rot_file,\n        transform=transforms.Compose([transforms.ToTensor()]))\n\ndataloader=torch.utils.data.DataLoader(ants_dataset,\n        batch_size=10, shuffle=True)\n\ntrain_length=int(0.7* len(ants_dataset))\n\ntest_length=len(ants_dataset)-train_length\n\ntrain_dataset,test_dataset=torch.utils.data.random_split(ants_dataset,(train_length,test_length))\n\ndataloader_train=torch.utils.data.DataLoader(train_dataset,\n        batch_size=10, shuffle=True)\n\nfor batch_idx, (data,rotations) in enumerate(ants_dataset):\n    print(rotations)\n\nTypeError                                 Traceback (most recent call last)\n&lt;ipython-input-101-f629e71651de&gt; in &lt;module&gt;()\n      1 dataloader_train=torch.utils.data.DataLoader(train_dataset,\n      2         batch_size=10, shuffle=True)\n----&gt; 3 for batch_idx, (data,rotations) in enumerate(dataloader_train):\n      4     print(rotations)\n\n~/anaconda3/envs/pytorch/lib/python3.6/site-packages/torch/utils/data/dataloader.py in __next__(self)\n    312         if self.num_workers == 0:  # same-process loading\n    313             indices = next(self.sample_iter)  # may raise StopIteration\n--&gt; 314             batch = self.collate_fn([self.dataset[i] for i in indices])\n    315             if self.pin_memory:\n    316                 batch = pin_memory_batch(batch)\n\n~/anaconda3/envs/pytorch/lib/python3.6/site-packages/torch/utils/data/dataloader.py in &lt;listcomp&gt;(.0)\n    312         if self.num_workers == 0:  # same-process loading\n    313             indices = next(self.sample_iter)  # may raise StopIteration\n--&gt; 314             batch = self.collate_fn([self.dataset[i] for i in indices])\n    315             if self.pin_memory:\n    316                 batch = pin_memory_batch(batch)\n\n~/anaconda3/envs/pytorch/lib/python3.6/site-packages/torch/utils/data/dataset.py in __getitem__(self, idx)\n    101 \n    102     def __getitem__(self, idx):\n--&gt; 103         return self.dataset[self.indices[idx]]\n    104 \n    105     def __len__(self):\n\n&lt;ipython-input-95-f56aceeb246b&gt; in __getitem__(self, idx)\n     19     def __getitem__(self, idx):\n     20         img_name = os.path.join(self.root_dir,\n---&gt; 21                                 self.rotations.iloc[idx, 0])\n     22         image = plt.imread(img_name,format='RGB')\n     23         rotation = self.rotations.iloc[idx, 1].astype('float')\n\n~/anaconda3/envs/pytorch/lib/python3.6/site-packages/pandas/core/indexing.py in __getitem__(self, key)\n   1470             except (KeyError, IndexError):\n   1471                 pass\n-&gt; 1472             return self._getitem_tuple(key)\n   1473         else:\n   1474             # we by definition only have the 0th axis\n\n~/anaconda3/envs/pytorch/lib/python3.6/site-packages/pandas/core/indexing.py in _getitem_tuple(self, tup)\n   2011     def _getitem_tuple(self, tup):\n   2012 \n-&gt; 2013         self._has_valid_tuple(tup)\n   2014         try:\n   2015             return self._getitem_lowerdim(tup)\n\n~/anaconda3/envs/pytorch/lib/python3.6/site-packages/pandas/core/indexing.py in _has_valid_tuple(self, key)\n    220                 raise IndexingError('Too many indexers')\n    221             try:\n--&gt; 222                 self._validate_key(k, i)\n    223             except ValueError:\n    224                 raise ValueError(\"Location based indexing can only have \"\n\n~/anaconda3/envs/pytorch/lib/python3.6/site-packages/pandas/core/indexing.py in _validate_key(self, key, axis)\n   1965             l = len(self.obj._get_axis(axis))\n   1966 \n-&gt; 1967             if len(arr) and (arr.max() &gt;= l or arr.min() &lt; -l):\n   1968                 raise IndexError(\"positional indexers are out-of-bounds\")\n   1969         else:\n\nTypeError: len() of unsized object```\n\n## System Info\n\nPyTorch version: 0.4.1\nIs debug build: No\nCUDA used to build PyTorch: None\n\nOS: Mac OSX 10.13.6\nGCC version: Could not collect\nCMake version: Could not collect\n\nPython version: 3.6\nIs CUDA available: No\nCUDA runtime version: No CUDA\nGPU models and configuration: No CUDA\nNvidia driver version: No CUDA\ncuDNN version: No CUDA\n\nVersions of relevant libraries:\n[pip] Could not collect\n[conda] torch                     0.4.1                     &lt;pip&gt;\n[conda] torchvision               0.2.1                     &lt;pip&gt;\n</code></pre>", "body_text": "Issue description\ntorch.utils.data.random_split() returns the index of the datapoint (idx) as a tensor rather than a float which messes up the __getitem__() routine of the dataset\nCode example\nclass AntsDataset(Dataset):\n    def __init__(self, root_dir, csv_file, transform=None):\n       \n        self.rotations = pd.read_csv(csv_file,header=None)\n        self.root_dir = root_dir\n        self.transform = transform\n\n    def __len__(self):\n        return len(self.rotations)\n\n    def __getitem__(self, idx):\n        import ipdb; ipdb.set_trace()\n        img_name = os.path.join(self.root_dir,\n                                self.rotations.iloc[idx, 0])\n        image = plt.imread(img_name,format='RGB')\n        rotation = self.rotations.iloc[idx, 1].astype('float')\n\n        if self.transform is not None:\n            image=self.transform(image)\n\n        return (image, rotation)\n\nants_dataset=AntsDataset(ants1_root_dir, ants1_rot_file,\n        transform=transforms.Compose([transforms.ToTensor()]))\n\ndataloader=torch.utils.data.DataLoader(ants_dataset,\n        batch_size=10, shuffle=True)\n\ntrain_length=int(0.7* len(ants_dataset))\n\ntest_length=len(ants_dataset)-train_length\n\ntrain_dataset,test_dataset=torch.utils.data.random_split(ants_dataset,(train_length,test_length))\n\ndataloader_train=torch.utils.data.DataLoader(train_dataset,\n        batch_size=10, shuffle=True)\n\nfor batch_idx, (data,rotations) in enumerate(ants_dataset):\n    print(rotations)\n\nTypeError                                 Traceback (most recent call last)\n<ipython-input-101-f629e71651de> in <module>()\n      1 dataloader_train=torch.utils.data.DataLoader(train_dataset,\n      2         batch_size=10, shuffle=True)\n----> 3 for batch_idx, (data,rotations) in enumerate(dataloader_train):\n      4     print(rotations)\n\n~/anaconda3/envs/pytorch/lib/python3.6/site-packages/torch/utils/data/dataloader.py in __next__(self)\n    312         if self.num_workers == 0:  # same-process loading\n    313             indices = next(self.sample_iter)  # may raise StopIteration\n--> 314             batch = self.collate_fn([self.dataset[i] for i in indices])\n    315             if self.pin_memory:\n    316                 batch = pin_memory_batch(batch)\n\n~/anaconda3/envs/pytorch/lib/python3.6/site-packages/torch/utils/data/dataloader.py in <listcomp>(.0)\n    312         if self.num_workers == 0:  # same-process loading\n    313             indices = next(self.sample_iter)  # may raise StopIteration\n--> 314             batch = self.collate_fn([self.dataset[i] for i in indices])\n    315             if self.pin_memory:\n    316                 batch = pin_memory_batch(batch)\n\n~/anaconda3/envs/pytorch/lib/python3.6/site-packages/torch/utils/data/dataset.py in __getitem__(self, idx)\n    101 \n    102     def __getitem__(self, idx):\n--> 103         return self.dataset[self.indices[idx]]\n    104 \n    105     def __len__(self):\n\n<ipython-input-95-f56aceeb246b> in __getitem__(self, idx)\n     19     def __getitem__(self, idx):\n     20         img_name = os.path.join(self.root_dir,\n---> 21                                 self.rotations.iloc[idx, 0])\n     22         image = plt.imread(img_name,format='RGB')\n     23         rotation = self.rotations.iloc[idx, 1].astype('float')\n\n~/anaconda3/envs/pytorch/lib/python3.6/site-packages/pandas/core/indexing.py in __getitem__(self, key)\n   1470             except (KeyError, IndexError):\n   1471                 pass\n-> 1472             return self._getitem_tuple(key)\n   1473         else:\n   1474             # we by definition only have the 0th axis\n\n~/anaconda3/envs/pytorch/lib/python3.6/site-packages/pandas/core/indexing.py in _getitem_tuple(self, tup)\n   2011     def _getitem_tuple(self, tup):\n   2012 \n-> 2013         self._has_valid_tuple(tup)\n   2014         try:\n   2015             return self._getitem_lowerdim(tup)\n\n~/anaconda3/envs/pytorch/lib/python3.6/site-packages/pandas/core/indexing.py in _has_valid_tuple(self, key)\n    220                 raise IndexingError('Too many indexers')\n    221             try:\n--> 222                 self._validate_key(k, i)\n    223             except ValueError:\n    224                 raise ValueError(\"Location based indexing can only have \"\n\n~/anaconda3/envs/pytorch/lib/python3.6/site-packages/pandas/core/indexing.py in _validate_key(self, key, axis)\n   1965             l = len(self.obj._get_axis(axis))\n   1966 \n-> 1967             if len(arr) and (arr.max() >= l or arr.min() < -l):\n   1968                 raise IndexError(\"positional indexers are out-of-bounds\")\n   1969         else:\n\nTypeError: len() of unsized object```\n\n## System Info\n\nPyTorch version: 0.4.1\nIs debug build: No\nCUDA used to build PyTorch: None\n\nOS: Mac OSX 10.13.6\nGCC version: Could not collect\nCMake version: Could not collect\n\nPython version: 3.6\nIs CUDA available: No\nCUDA runtime version: No CUDA\nGPU models and configuration: No CUDA\nNvidia driver version: No CUDA\ncuDNN version: No CUDA\n\nVersions of relevant libraries:\n[pip] Could not collect\n[conda] torch                     0.4.1                     <pip>\n[conda] torchvision               0.2.1                     <pip>", "body": "\r\n## Issue description\r\n\r\n`torch.utils.data.random_split()` returns the index of the datapoint (idx) as a tensor rather than a float which messes up the `__getitem__()` routine of the dataset\r\n\r\n## Code example\r\n```\r\nclass AntsDataset(Dataset):\r\n    def __init__(self, root_dir, csv_file, transform=None):\r\n       \r\n        self.rotations = pd.read_csv(csv_file,header=None)\r\n        self.root_dir = root_dir\r\n        self.transform = transform\r\n\r\n    def __len__(self):\r\n        return len(self.rotations)\r\n\r\n    def __getitem__(self, idx):\r\n        import ipdb; ipdb.set_trace()\r\n        img_name = os.path.join(self.root_dir,\r\n                                self.rotations.iloc[idx, 0])\r\n        image = plt.imread(img_name,format='RGB')\r\n        rotation = self.rotations.iloc[idx, 1].astype('float')\r\n\r\n        if self.transform is not None:\r\n            image=self.transform(image)\r\n\r\n        return (image, rotation)\r\n\r\nants_dataset=AntsDataset(ants1_root_dir, ants1_rot_file,\r\n        transform=transforms.Compose([transforms.ToTensor()]))\r\n\r\ndataloader=torch.utils.data.DataLoader(ants_dataset,\r\n        batch_size=10, shuffle=True)\r\n\r\ntrain_length=int(0.7* len(ants_dataset))\r\n\r\ntest_length=len(ants_dataset)-train_length\r\n\r\ntrain_dataset,test_dataset=torch.utils.data.random_split(ants_dataset,(train_length,test_length))\r\n\r\ndataloader_train=torch.utils.data.DataLoader(train_dataset,\r\n        batch_size=10, shuffle=True)\r\n\r\nfor batch_idx, (data,rotations) in enumerate(ants_dataset):\r\n    print(rotations)\r\n\r\nTypeError                                 Traceback (most recent call last)\r\n<ipython-input-101-f629e71651de> in <module>()\r\n      1 dataloader_train=torch.utils.data.DataLoader(train_dataset,\r\n      2         batch_size=10, shuffle=True)\r\n----> 3 for batch_idx, (data,rotations) in enumerate(dataloader_train):\r\n      4     print(rotations)\r\n\r\n~/anaconda3/envs/pytorch/lib/python3.6/site-packages/torch/utils/data/dataloader.py in __next__(self)\r\n    312         if self.num_workers == 0:  # same-process loading\r\n    313             indices = next(self.sample_iter)  # may raise StopIteration\r\n--> 314             batch = self.collate_fn([self.dataset[i] for i in indices])\r\n    315             if self.pin_memory:\r\n    316                 batch = pin_memory_batch(batch)\r\n\r\n~/anaconda3/envs/pytorch/lib/python3.6/site-packages/torch/utils/data/dataloader.py in <listcomp>(.0)\r\n    312         if self.num_workers == 0:  # same-process loading\r\n    313             indices = next(self.sample_iter)  # may raise StopIteration\r\n--> 314             batch = self.collate_fn([self.dataset[i] for i in indices])\r\n    315             if self.pin_memory:\r\n    316                 batch = pin_memory_batch(batch)\r\n\r\n~/anaconda3/envs/pytorch/lib/python3.6/site-packages/torch/utils/data/dataset.py in __getitem__(self, idx)\r\n    101 \r\n    102     def __getitem__(self, idx):\r\n--> 103         return self.dataset[self.indices[idx]]\r\n    104 \r\n    105     def __len__(self):\r\n\r\n<ipython-input-95-f56aceeb246b> in __getitem__(self, idx)\r\n     19     def __getitem__(self, idx):\r\n     20         img_name = os.path.join(self.root_dir,\r\n---> 21                                 self.rotations.iloc[idx, 0])\r\n     22         image = plt.imread(img_name,format='RGB')\r\n     23         rotation = self.rotations.iloc[idx, 1].astype('float')\r\n\r\n~/anaconda3/envs/pytorch/lib/python3.6/site-packages/pandas/core/indexing.py in __getitem__(self, key)\r\n   1470             except (KeyError, IndexError):\r\n   1471                 pass\r\n-> 1472             return self._getitem_tuple(key)\r\n   1473         else:\r\n   1474             # we by definition only have the 0th axis\r\n\r\n~/anaconda3/envs/pytorch/lib/python3.6/site-packages/pandas/core/indexing.py in _getitem_tuple(self, tup)\r\n   2011     def _getitem_tuple(self, tup):\r\n   2012 \r\n-> 2013         self._has_valid_tuple(tup)\r\n   2014         try:\r\n   2015             return self._getitem_lowerdim(tup)\r\n\r\n~/anaconda3/envs/pytorch/lib/python3.6/site-packages/pandas/core/indexing.py in _has_valid_tuple(self, key)\r\n    220                 raise IndexingError('Too many indexers')\r\n    221             try:\r\n--> 222                 self._validate_key(k, i)\r\n    223             except ValueError:\r\n    224                 raise ValueError(\"Location based indexing can only have \"\r\n\r\n~/anaconda3/envs/pytorch/lib/python3.6/site-packages/pandas/core/indexing.py in _validate_key(self, key, axis)\r\n   1965             l = len(self.obj._get_axis(axis))\r\n   1966 \r\n-> 1967             if len(arr) and (arr.max() >= l or arr.min() < -l):\r\n   1968                 raise IndexError(\"positional indexers are out-of-bounds\")\r\n   1969         else:\r\n\r\nTypeError: len() of unsized object```\r\n\r\n## System Info\r\n\r\nPyTorch version: 0.4.1\r\nIs debug build: No\r\nCUDA used to build PyTorch: None\r\n\r\nOS: Mac OSX 10.13.6\r\nGCC version: Could not collect\r\nCMake version: Could not collect\r\n\r\nPython version: 3.6\r\nIs CUDA available: No\r\nCUDA runtime version: No CUDA\r\nGPU models and configuration: No CUDA\r\nNvidia driver version: No CUDA\r\ncuDNN version: No CUDA\r\n\r\nVersions of relevant libraries:\r\n[pip] Could not collect\r\n[conda] torch                     0.4.1                     <pip>\r\n[conda] torchvision               0.2.1                     <pip>\r\n"}