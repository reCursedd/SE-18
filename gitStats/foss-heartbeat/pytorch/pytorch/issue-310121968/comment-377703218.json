{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/377703218", "html_url": "https://github.com/pytorch/pytorch/issues/6139#issuecomment-377703218", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/6139", "id": 377703218, "node_id": "MDEyOklzc3VlQ29tbWVudDM3NzcwMzIxOA==", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "created_at": "2018-03-31T16:01:50Z", "updated_at": "2018-03-31T16:01:50Z", "author_association": "MEMBER", "body_html": "<p>The problem lies elsewhere. Shape inference pass can execute <code>x.unsqueeze(0)</code> just fine. The initial graph looks like this:</p>\n<pre><code>graph(%x : Dynamic) {\n  %1 : Dynamic = prim::Constant[value={0}]()\n  %2 : Dynamic = aten::unsqueeze(%x, %1)\n  return (%2);\n}\n</code></pre>\n<p>You can see that the <code>0</code> gets inlined into the IR as a constant tensor, and shape inference will correctly infer that the type of <code>%1</code> is <code>Long()</code>. Then, we get to the second node, but <code>unsqueeze</code> is not a supported operation, and it has an integral input, so we can't create a dummy input, and run the op to infer the shape.</p>\n<p>I've been thinking about how to handle the viewing ops, and I'm not sure if we want to implement shape inference for them, because the way they handle strides is quite complicated (I think stride handling in <code>unsqueeze</code> changed at least 3 times), and it would be terrible if it got out of sync with the ATen impls. We should discuss that in our next meeting.</p>", "body_text": "The problem lies elsewhere. Shape inference pass can execute x.unsqueeze(0) just fine. The initial graph looks like this:\ngraph(%x : Dynamic) {\n  %1 : Dynamic = prim::Constant[value={0}]()\n  %2 : Dynamic = aten::unsqueeze(%x, %1)\n  return (%2);\n}\n\nYou can see that the 0 gets inlined into the IR as a constant tensor, and shape inference will correctly infer that the type of %1 is Long(). Then, we get to the second node, but unsqueeze is not a supported operation, and it has an integral input, so we can't create a dummy input, and run the op to infer the shape.\nI've been thinking about how to handle the viewing ops, and I'm not sure if we want to implement shape inference for them, because the way they handle strides is quite complicated (I think stride handling in unsqueeze changed at least 3 times), and it would be terrible if it got out of sync with the ATen impls. We should discuss that in our next meeting.", "body": "The problem lies elsewhere. Shape inference pass can execute `x.unsqueeze(0)` just fine. The initial graph looks like this:\r\n```\r\ngraph(%x : Dynamic) {\r\n  %1 : Dynamic = prim::Constant[value={0}]()\r\n  %2 : Dynamic = aten::unsqueeze(%x, %1)\r\n  return (%2);\r\n}\r\n```\r\nYou can see that the `0` gets inlined into the IR as a constant tensor, and shape inference will correctly infer that the type of `%1` is `Long()`. Then, we get to the second node, but `unsqueeze` is not a supported operation, and it has an integral input, so we can't create a dummy input, and run the op to infer the shape.\r\n\r\nI've been thinking about how to handle the viewing ops, and I'm not sure if we want to implement shape inference for them, because the way they handle strides is quite complicated (I think stride handling in `unsqueeze` changed at least 3 times), and it would be terrible if it got out of sync with the ATen impls. We should discuss that in our next meeting."}