{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/410107510", "html_url": "https://github.com/pytorch/pytorch/issues/10182#issuecomment-410107510", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/10182", "id": 410107510, "node_id": "MDEyOklzc3VlQ29tbWVudDQxMDEwNzUxMA==", "user": {"login": "carlosgmartin", "id": 8883917, "node_id": "MDQ6VXNlcjg4ODM5MTc=", "avatar_url": "https://avatars3.githubusercontent.com/u/8883917?v=4", "gravatar_id": "", "url": "https://api.github.com/users/carlosgmartin", "html_url": "https://github.com/carlosgmartin", "followers_url": "https://api.github.com/users/carlosgmartin/followers", "following_url": "https://api.github.com/users/carlosgmartin/following{/other_user}", "gists_url": "https://api.github.com/users/carlosgmartin/gists{/gist_id}", "starred_url": "https://api.github.com/users/carlosgmartin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/carlosgmartin/subscriptions", "organizations_url": "https://api.github.com/users/carlosgmartin/orgs", "repos_url": "https://api.github.com/users/carlosgmartin/repos", "events_url": "https://api.github.com/users/carlosgmartin/events{/privacy}", "received_events_url": "https://api.github.com/users/carlosgmartin/received_events", "type": "User", "site_admin": false}, "created_at": "2018-08-03T00:27:15Z", "updated_at": "2018-08-03T00:41:20Z", "author_association": "NONE", "body_html": "<p>In my particular case, I'm creating a graph neural network. Let <code>edges</code> be a tensor of adjacency matrices for each edge type, i.e. a tensor of shape <code>[m, n, n]</code> where <code>m</code> is the number of edge types and <code>n</code> is the number of nodes. Let <code>features</code> be a tensor of feature vectors for each node, i.e. a tensor of shape <code>[m, k]</code> where <code>k</code> is the dimensionality of the feature space. Then <code>edges @ features</code> has shape <code>[m, n, k]</code>, and it is the sum of the feature vectors of neighboring nodes for each node and for each edge type. This must be flattened to <code>[n, m * k]</code>, i.e. through <code>torch.cat(edges @ features, 1)</code>, to get a single vector for each node, which are then passed in parallel through a function to get the new feature vectors for every node in the graph.</p>\n<p>In other words, a tensor should be treated as a tensor of tensors when a sequence is expected.</p>", "body_text": "In my particular case, I'm creating a graph neural network. Let edges be a tensor of adjacency matrices for each edge type, i.e. a tensor of shape [m, n, n] where m is the number of edge types and n is the number of nodes. Let features be a tensor of feature vectors for each node, i.e. a tensor of shape [m, k] where k is the dimensionality of the feature space. Then edges @ features has shape [m, n, k], and it is the sum of the feature vectors of neighboring nodes for each node and for each edge type. This must be flattened to [n, m * k], i.e. through torch.cat(edges @ features, 1), to get a single vector for each node, which are then passed in parallel through a function to get the new feature vectors for every node in the graph.\nIn other words, a tensor should be treated as a tensor of tensors when a sequence is expected.", "body": "In my particular case, I'm creating a graph neural network. Let `edges` be a tensor of adjacency matrices for each edge type, i.e. a tensor of shape `[m, n, n]` where `m` is the number of edge types and `n` is the number of nodes. Let `features` be a tensor of feature vectors for each node, i.e. a tensor of shape `[m, k]` where `k` is the dimensionality of the feature space. Then `edges @ features` has shape `[m, n, k]`, and it is the sum of the feature vectors of neighboring nodes for each node and for each edge type. This must be flattened to `[n, m * k]`, i.e. through `torch.cat(edges @ features, 1)`, to get a single vector for each node, which are then passed in parallel through a function to get the new feature vectors for every node in the graph.\r\n\r\nIn other words, a tensor should be treated as a tensor of tensors when a sequence is expected."}