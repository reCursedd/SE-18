{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/415475411", "html_url": "https://github.com/pytorch/pytorch/issues/3814#issuecomment-415475411", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/3814", "id": 415475411, "node_id": "MDEyOklzc3VlQ29tbWVudDQxNTQ3NTQxMQ==", "user": {"login": "evarenieto", "id": 38262748, "node_id": "MDQ6VXNlcjM4MjYyNzQ4", "avatar_url": "https://avatars2.githubusercontent.com/u/38262748?v=4", "gravatar_id": "", "url": "https://api.github.com/users/evarenieto", "html_url": "https://github.com/evarenieto", "followers_url": "https://api.github.com/users/evarenieto/followers", "following_url": "https://api.github.com/users/evarenieto/following{/other_user}", "gists_url": "https://api.github.com/users/evarenieto/gists{/gist_id}", "starred_url": "https://api.github.com/users/evarenieto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/evarenieto/subscriptions", "organizations_url": "https://api.github.com/users/evarenieto/orgs", "repos_url": "https://api.github.com/users/evarenieto/repos", "events_url": "https://api.github.com/users/evarenieto/events{/privacy}", "received_events_url": "https://api.github.com/users/evarenieto/received_events", "type": "User", "site_admin": false}, "created_at": "2018-08-23T16:13:04Z", "updated_at": "2018-08-23T16:13:04Z", "author_association": "NONE", "body_html": "<p>Hello!!!<br>\nI am using :</p>\n<p>`def train_model(model, criterion, optimizer, scheduler, num_epochs=25, device = 'cuda'):<br>\nsince = time.time()</p>\n<pre><code>best_model_wts = copy.deepcopy(model.state_dict())\nbest_acc = 0.0\n\nfor epoch in range(num_epochs):\n    print('Epoch {}/{}'.format(epoch, num_epochs - 1))\n    print('-' * 10)\n\n    # Each epoch has a training and validation phase\n    for phase in ['training', 'validation']:\n        if phase == 'training':\n            scheduler.step()\n            model.train()  # Set model to training mode\n        else:\n            model.eval()   # Set model to evaluate mode\n\n        running_loss = 0.0\n        running_corrects = 0\n\n        # Iterate over data.\n        for inputs, labels in dataloaders[phase]:\n            inputs = inputs.to(device)\n            labels = labels.to(device)\n\n            # zero the parameter gradients\n            optimizer.zero_grad()\n\n            # forward\n            # track history if only in train\n            with torch.set_grad_enabled(phase == 'training'):\n                outputs = model(inputs)\n                _, preds = torch.max(outputs, 1)\n                loss = criterion(outputs, labels)\n\n                # backward + optimize only if in training phase\n                if phase == 'training':\n                    loss.backward()\n                    optimizer.step()\n\n            # statistics\n            running_loss += loss.item() * inputs.size(0)\n            running_corrects += torch.sum(preds == labels.data)\n\n        epoch_loss = running_loss / dataset_sizes[phase]\n        epoch_acc = running_corrects.double() / dataset_sizes[phase]\n\n        print('{} Loss: {:.4f} Acc: {:.4f}'.format(\n            phase, epoch_loss, epoch_acc))\n\n        # deep copy the model\n        if phase == 'validation' and epoch_acc &gt; best_acc:\n            best_acc = epoch_acc\n            best_model_wts = copy.deepcopy(model.state_dict())\n\n    print()\n\ntime_elapsed = time.time() - since\nprint('Training complete in {:.0f}m {:.0f}s'.format(\n    time_elapsed // 60, time_elapsed % 60))\nprint('Best val Acc: {:4f}'.format(best_acc))\n\n# load best model weights\nmodel.load_state_dict(best_model_wts)\nreturn model`\n</code></pre>\n<p><code>criterion = nn.NLLLoss() optimiz = optim.Adam(model.classifier.parameters(), lr = 0.001) scheduler = lr_scheduler.StepLR(optimizer, step_size=4, gamma=0.1) epoch = 10</code><br>\n<code>model_nw = train_model(model, criterion, optimizer, epoch, device = 'cuda')</code></p>\n<p>and i got this error:</p>\n<p>`---------------------------------------------------------------------------<br>\nAttributeError                            Traceback (most recent call last)<br>\n in ()<br>\n----&gt; 1 model_nw = train_model(model, criterion, optimizer, epoch, device = 'cuda')</p>\n<p> in train_model(model, criterion, optimizer, scheduler, num_epochs, device)<br>\n15         for phase in ['training', 'validation']:<br>\n16             if phase == 'training':<br>\n---&gt; 17                 scheduler.step()<br>\n18                 model.train()  # Set model to training mode<br>\n19             else:</p>\n<p>AttributeError: 'int' object has no attribute 'step'<br>\n`</p>\n<p>some help? because i don understand it</p>", "body_text": "Hello!!!\nI am using :\n`def train_model(model, criterion, optimizer, scheduler, num_epochs=25, device = 'cuda'):\nsince = time.time()\nbest_model_wts = copy.deepcopy(model.state_dict())\nbest_acc = 0.0\n\nfor epoch in range(num_epochs):\n    print('Epoch {}/{}'.format(epoch, num_epochs - 1))\n    print('-' * 10)\n\n    # Each epoch has a training and validation phase\n    for phase in ['training', 'validation']:\n        if phase == 'training':\n            scheduler.step()\n            model.train()  # Set model to training mode\n        else:\n            model.eval()   # Set model to evaluate mode\n\n        running_loss = 0.0\n        running_corrects = 0\n\n        # Iterate over data.\n        for inputs, labels in dataloaders[phase]:\n            inputs = inputs.to(device)\n            labels = labels.to(device)\n\n            # zero the parameter gradients\n            optimizer.zero_grad()\n\n            # forward\n            # track history if only in train\n            with torch.set_grad_enabled(phase == 'training'):\n                outputs = model(inputs)\n                _, preds = torch.max(outputs, 1)\n                loss = criterion(outputs, labels)\n\n                # backward + optimize only if in training phase\n                if phase == 'training':\n                    loss.backward()\n                    optimizer.step()\n\n            # statistics\n            running_loss += loss.item() * inputs.size(0)\n            running_corrects += torch.sum(preds == labels.data)\n\n        epoch_loss = running_loss / dataset_sizes[phase]\n        epoch_acc = running_corrects.double() / dataset_sizes[phase]\n\n        print('{} Loss: {:.4f} Acc: {:.4f}'.format(\n            phase, epoch_loss, epoch_acc))\n\n        # deep copy the model\n        if phase == 'validation' and epoch_acc > best_acc:\n            best_acc = epoch_acc\n            best_model_wts = copy.deepcopy(model.state_dict())\n\n    print()\n\ntime_elapsed = time.time() - since\nprint('Training complete in {:.0f}m {:.0f}s'.format(\n    time_elapsed // 60, time_elapsed % 60))\nprint('Best val Acc: {:4f}'.format(best_acc))\n\n# load best model weights\nmodel.load_state_dict(best_model_wts)\nreturn model`\n\ncriterion = nn.NLLLoss() optimiz = optim.Adam(model.classifier.parameters(), lr = 0.001) scheduler = lr_scheduler.StepLR(optimizer, step_size=4, gamma=0.1) epoch = 10\nmodel_nw = train_model(model, criterion, optimizer, epoch, device = 'cuda')\nand i got this error:\n`---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\n in ()\n----> 1 model_nw = train_model(model, criterion, optimizer, epoch, device = 'cuda')\n in train_model(model, criterion, optimizer, scheduler, num_epochs, device)\n15         for phase in ['training', 'validation']:\n16             if phase == 'training':\n---> 17                 scheduler.step()\n18                 model.train()  # Set model to training mode\n19             else:\nAttributeError: 'int' object has no attribute 'step'\n`\nsome help? because i don understand it", "body": "Hello!!!\r\nI am using :\r\n\r\n`def train_model(model, criterion, optimizer, scheduler, num_epochs=25, device = 'cuda'):\r\n    since = time.time()\r\n\r\n    best_model_wts = copy.deepcopy(model.state_dict())\r\n    best_acc = 0.0\r\n\r\n    for epoch in range(num_epochs):\r\n        print('Epoch {}/{}'.format(epoch, num_epochs - 1))\r\n        print('-' * 10)\r\n\r\n        # Each epoch has a training and validation phase\r\n        for phase in ['training', 'validation']:\r\n            if phase == 'training':\r\n                scheduler.step()\r\n                model.train()  # Set model to training mode\r\n            else:\r\n                model.eval()   # Set model to evaluate mode\r\n\r\n            running_loss = 0.0\r\n            running_corrects = 0\r\n\r\n            # Iterate over data.\r\n            for inputs, labels in dataloaders[phase]:\r\n                inputs = inputs.to(device)\r\n                labels = labels.to(device)\r\n\r\n                # zero the parameter gradients\r\n                optimizer.zero_grad()\r\n\r\n                # forward\r\n                # track history if only in train\r\n                with torch.set_grad_enabled(phase == 'training'):\r\n                    outputs = model(inputs)\r\n                    _, preds = torch.max(outputs, 1)\r\n                    loss = criterion(outputs, labels)\r\n\r\n                    # backward + optimize only if in training phase\r\n                    if phase == 'training':\r\n                        loss.backward()\r\n                        optimizer.step()\r\n\r\n                # statistics\r\n                running_loss += loss.item() * inputs.size(0)\r\n                running_corrects += torch.sum(preds == labels.data)\r\n\r\n            epoch_loss = running_loss / dataset_sizes[phase]\r\n            epoch_acc = running_corrects.double() / dataset_sizes[phase]\r\n\r\n            print('{} Loss: {:.4f} Acc: {:.4f}'.format(\r\n                phase, epoch_loss, epoch_acc))\r\n\r\n            # deep copy the model\r\n            if phase == 'validation' and epoch_acc > best_acc:\r\n                best_acc = epoch_acc\r\n                best_model_wts = copy.deepcopy(model.state_dict())\r\n\r\n        print()\r\n\r\n    time_elapsed = time.time() - since\r\n    print('Training complete in {:.0f}m {:.0f}s'.format(\r\n        time_elapsed // 60, time_elapsed % 60))\r\n    print('Best val Acc: {:4f}'.format(best_acc))\r\n\r\n    # load best model weights\r\n    model.load_state_dict(best_model_wts)\r\n    return model`\r\n`criterion = nn.NLLLoss()\r\noptimiz = optim.Adam(model.classifier.parameters(), lr = 0.001)\r\nscheduler = lr_scheduler.StepLR(optimizer, step_size=4, gamma=0.1)\r\nepoch = 10`\r\n`model_nw = train_model(model, criterion, optimizer, epoch, device = 'cuda')`\r\n\r\nand i got this error:\r\n\r\n`---------------------------------------------------------------------------\r\nAttributeError                            Traceback (most recent call last)\r\n<ipython-input-9-1a3153bc02ac> in <module>()\r\n----> 1 model_nw = train_model(model, criterion, optimizer, epoch, device = 'cuda')\r\n\r\n<ipython-input-6-ac85c67d8254> in train_model(model, criterion, optimizer, scheduler, num_epochs, device)\r\n     15         for phase in ['training', 'validation']:\r\n     16             if phase == 'training':\r\n---> 17                 scheduler.step()\r\n     18                 model.train()  # Set model to training mode\r\n     19             else:\r\n\r\nAttributeError: 'int' object has no attribute 'step'\r\n`\r\n\r\nsome help? because i don understand it"}