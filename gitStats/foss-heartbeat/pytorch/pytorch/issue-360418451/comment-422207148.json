{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/422207148", "html_url": "https://github.com/pytorch/pytorch/issues/11714#issuecomment-422207148", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/11714", "id": 422207148, "node_id": "MDEyOklzc3VlQ29tbWVudDQyMjIwNzE0OA==", "user": {"login": "SsnL", "id": 5674597, "node_id": "MDQ6VXNlcjU2NzQ1OTc=", "avatar_url": "https://avatars2.githubusercontent.com/u/5674597?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SsnL", "html_url": "https://github.com/SsnL", "followers_url": "https://api.github.com/users/SsnL/followers", "following_url": "https://api.github.com/users/SsnL/following{/other_user}", "gists_url": "https://api.github.com/users/SsnL/gists{/gist_id}", "starred_url": "https://api.github.com/users/SsnL/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SsnL/subscriptions", "organizations_url": "https://api.github.com/users/SsnL/orgs", "repos_url": "https://api.github.com/users/SsnL/repos", "events_url": "https://api.github.com/users/SsnL/events{/privacy}", "received_events_url": "https://api.github.com/users/SsnL/received_events", "type": "User", "site_admin": false}, "created_at": "2018-09-17T23:47:49Z", "updated_at": "2018-09-17T23:47:49Z", "author_association": "CONTRIBUTOR", "body_html": "<div class=\"email-fragment\">E.g. tensors hashes to their memory address locations. You asked about\ngenerally hashable values. So I answered in terms of generally hashable\nvalues.\n\nThat said, I already mentioned that we can probably relax to a larger set\nof types, but even for things like Python byte array it will be hard\nbecause there is no straightforward 1-to-1 correspondence between the\nobject and a string. So actually I don\u2019t think float qualifies as well. We\ncan certainly allow int still.</div>\n<span class=\"email-hidden-toggle\"><a href=\"#\">\u2026</a></span><div class=\"email-hidden-reply\">\n<div class=\"email-quoted-reply\">On Mon, Sep 17, 2018 at 19:29 David Mascharka ***@***.***&gt; wrote:\n Are user-defined hashes often salted/nondeterministic? I'm curious how big\n a problem that really is. Which types do we need to worry about having\n different hashes from run to run?\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n &lt;<a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"360418451\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/11714\" href=\"https://github.com/pytorch/pytorch/issues/11714#issuecomment-422204094\">#11714 (comment)</a>&gt;,\n or mute the thread\n &lt;<a href=\"https://github.com/notifications/unsubscribe-auth/AFaWZWd2AxK2nMveEKeQogt7tHCCGMc-ks5ucDBGgaJpZM4WpyMH\">https://github.com/notifications/unsubscribe-auth/AFaWZWd2AxK2nMveEKeQogt7tHCCGMc-ks5ucDBGgaJpZM4WpyMH</a>&gt;\n .\n</div>\n<div class=\"email-fragment\"></div>\n</div>", "body_text": "E.g. tensors hashes to their memory address locations. You asked about\ngenerally hashable values. So I answered in terms of generally hashable\nvalues.\n\nThat said, I already mentioned that we can probably relax to a larger set\nof types, but even for things like Python byte array it will be hard\nbecause there is no straightforward 1-to-1 correspondence between the\nobject and a string. So actually I don\u2019t think float qualifies as well. We\ncan certainly allow int still.\n\u2026\nOn Mon, Sep 17, 2018 at 19:29 David Mascharka ***@***.***> wrote:\n Are user-defined hashes often salted/nondeterministic? I'm curious how big\n a problem that really is. Which types do we need to worry about having\n different hashes from run to run?\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#11714 (comment)>,\n or mute the thread\n <https://github.com/notifications/unsubscribe-auth/AFaWZWd2AxK2nMveEKeQogt7tHCCGMc-ks5ucDBGgaJpZM4WpyMH>\n .", "body": "E.g. tensors hashes to their memory address locations. You asked about\ngenerally hashable values. So I answered in terms of generally hashable\nvalues.\n\nThat said, I already mentioned that we can probably relax to a larger set\nof types, but even for things like Python byte array it will be hard\nbecause there is no straightforward 1-to-1 correspondence between the\nobject and a string. So actually I don\u2019t think float qualifies as well. We\ncan certainly allow int still.\n\nOn Mon, Sep 17, 2018 at 19:29 David Mascharka <notifications@github.com>\nwrote:\n\n> Are user-defined hashes often salted/nondeterministic? I'm curious how big\n> a problem that really is. Which types do we need to worry about having\n> different hashes from run to run?\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/pytorch/pytorch/issues/11714#issuecomment-422204094>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AFaWZWd2AxK2nMveEKeQogt7tHCCGMc-ks5ucDBGgaJpZM4WpyMH>\n> .\n>\n"}