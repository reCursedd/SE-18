{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/163441404", "pull_request_review_id": 91051893, "id": 163441404, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2MzQ0MTQwNA==", "diff_hunk": "@@ -0,0 +1,109 @@\n+#include <cstddef>\n+#include \"torch/csrc/jit/ir.h\"\n+#include \"torch/csrc/jit/autodiff.h\"\n+\n+namespace torch { namespace jit {\n+\n+struct Graph;\n+\n+namespace {\n+\n+// Move nodes that exist in graph g into a 'group_node_kind' node.\n+// All inputs shared by the nodes become inputs to the new node.\n+// Outputs from 'nodes' are redirected to outputs of the new node,\n+// and the original nodes are removed.\n+// prereq: it is topologically valid to place the new node\n+// right before nodes[0] (i.e. it will not create cycles and all uses of\n+// new node will be after this position).\n+// prereq: nodes are in topological order\n+void mergeNodes(Graph & g, Symbol group_node_kind, ArrayRef<Node*> nodes) {\n+  JIT_ASSERT(nodes.size() > 0);\n+  std::unordered_map<Value*, Value*> value_map;\n+\n+  auto new_graph = std::make_shared<Graph>();\n+  Node * group_node = g.create(group_node_kind, 0);\n+  group_node->g_(kSubgraph, new_graph);\n+\n+  auto getOrCreateInput = [&](Value * v) {\n+    if(value_map.count(v) > 0) {\n+      return value_map[v];\n+    }\n+    Value * nv = new_graph->addInput();\n+    group_node->addInput(v);\n+    value_map[v] = nv;\n+    return nv;\n+  };\n+  std::unordered_set<Node*> group_set;\n+  for(auto n : nodes) {\n+    group_set.insert(n);\n+  }\n+  for(auto n : nodes) {\n+    auto nn = new_graph->appendNode(new_graph->createClone(n, getOrCreateInput));\n+    for(size_t i = 0; i < nn->outputs().size(); ++i) {\n+      auto old_output = n->outputs()[i];\n+      auto new_output = nn->outputs()[i];\n+      value_map[old_output] = new_output;\n+      std::vector<Use> to_replace;\n+      for(auto u : old_output->uses()) {\n+        // Uses within the set do not need to be made outputs\n+        if(group_set.count(u.user) > 0)\n+          continue;\n+        // Other uses do, but we\n+        // cannot replace them here or we invalid the uses list iterator\n+        to_replace.push_back(u);\n+      }\n+      if(to_replace.size() > 0) {\n+        new_graph->registerOutput(new_output);\n+        Value * external_output = group_node->addOutput();\n+        for(auto u : to_replace) {\n+          u.user->replaceInput(u.offset, external_output);\n+        }\n+      }\n+    }\n+  }\n+  group_node->insertBefore(nodes[0]);\n+  // delete backward, so that nodes are use-free before deletion\n+  for(size_t i = nodes.size(); i > 0; --i) {\n+    nodes[i - 1]->destroy();\n+  }\n+}\n+\n+}\n+\n+void CreateAutodiffSubgraphs(Graph & g, size_t threshold) {\n+\n+  // This implementation is not optimal, but it is simple.\n+  // It just scans through the list in order looking for runs of\n+  // differentiable ops, and then grouping them together when\n+  // it hits the first non-differentiable op.\n+  // It cannot handle things like:\n+  // a = f(x, y)\n+  // b = black_box(a)\n+  // c = g(a)\n+  // where you could group {f, g} together if the nodes were in a different\n+  // topological order", "path": "torch/csrc/jit/passes/create_autodiff_subgraphs.cpp", "position": 84, "original_position": 84, "commit_id": "287518f39717bee1673ba749753df6018e322d02", "original_commit_id": "287518f39717bee1673ba749753df6018e322d02", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "body": "It's not necessarily a good idea to find maximal runs though, right? Suppose I have:\r\n\r\n```\r\na, b = f(x)\r\nz = black_box(a)\r\nc = g(b)\r\n... lots of things with c, but a is dead ...\r\n```\r\n\r\nThen floating `z = black_box(a)` to the bottom of the topsort will keep `a` live longer than it would have been previously.", "created_at": "2018-01-24T02:48:51Z", "updated_at": "2018-11-23T15:38:30Z", "html_url": "https://github.com/pytorch/pytorch/pull/4822#discussion_r163441404", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/4822", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/163441404"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/4822#discussion_r163441404"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/4822"}}, "body_html": "<p>It's not necessarily a good idea to find maximal runs though, right? Suppose I have:</p>\n<pre><code>a, b = f(x)\nz = black_box(a)\nc = g(b)\n... lots of things with c, but a is dead ...\n</code></pre>\n<p>Then floating <code>z = black_box(a)</code> to the bottom of the topsort will keep <code>a</code> live longer than it would have been previously.</p>", "body_text": "It's not necessarily a good idea to find maximal runs though, right? Suppose I have:\na, b = f(x)\nz = black_box(a)\nc = g(b)\n... lots of things with c, but a is dead ...\n\nThen floating z = black_box(a) to the bottom of the topsort will keep a live longer than it would have been previously."}