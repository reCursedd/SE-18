{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/163550274", "pull_request_review_id": 91178330, "id": 163550274, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2MzU1MDI3NA==", "diff_hunk": "@@ -0,0 +1,109 @@\n+#include <cstddef>\n+#include \"torch/csrc/jit/ir.h\"\n+#include \"torch/csrc/jit/autodiff.h\"\n+\n+namespace torch { namespace jit {\n+\n+struct Graph;\n+\n+namespace {\n+\n+// Move nodes that exist in graph g into a 'group_node_kind' node.\n+// All inputs shared by the nodes become inputs to the new node.\n+// Outputs from 'nodes' are redirected to outputs of the new node,\n+// and the original nodes are removed.\n+// prereq: it is topologically valid to place the new node\n+// right before nodes[0] (i.e. it will not create cycles and all uses of\n+// new node will be after this position).\n+// prereq: nodes are in topological order\n+void mergeNodes(Graph & g, Symbol group_node_kind, ArrayRef<Node*> nodes) {\n+  JIT_ASSERT(nodes.size() > 0);\n+  std::unordered_map<Value*, Value*> value_map;\n+\n+  auto new_graph = std::make_shared<Graph>();\n+  Node * group_node = g.create(group_node_kind, 0);\n+  group_node->g_(kSubgraph, new_graph);\n+\n+  auto getOrCreateInput = [&](Value * v) {\n+    if(value_map.count(v) > 0) {\n+      return value_map[v];\n+    }\n+    Value * nv = new_graph->addInput();\n+    group_node->addInput(v);\n+    value_map[v] = nv;\n+    return nv;\n+  };\n+  std::unordered_set<Node*> group_set;\n+  for(auto n : nodes) {\n+    group_set.insert(n);\n+  }\n+  for(auto n : nodes) {\n+    auto nn = new_graph->appendNode(new_graph->createClone(n, getOrCreateInput));\n+    for(size_t i = 0; i < nn->outputs().size(); ++i) {\n+      auto old_output = n->outputs()[i];\n+      auto new_output = nn->outputs()[i];\n+      value_map[old_output] = new_output;\n+      std::vector<Use> to_replace;\n+      for(auto u : old_output->uses()) {\n+        // Uses within the set do not need to be made outputs\n+        if(group_set.count(u.user) > 0)\n+          continue;\n+        // Other uses do, but we\n+        // cannot replace them here or we invalid the uses list iterator\n+        to_replace.push_back(u);\n+      }\n+      if(to_replace.size() > 0) {\n+        new_graph->registerOutput(new_output);\n+        Value * external_output = group_node->addOutput();\n+        for(auto u : to_replace) {\n+          u.user->replaceInput(u.offset, external_output);\n+        }\n+      }\n+    }\n+  }\n+  group_node->insertBefore(nodes[0]);\n+  // delete backward, so that nodes are use-free before deletion\n+  for(size_t i = nodes.size(); i > 0; --i) {\n+    nodes[i - 1]->destroy();\n+  }\n+}\n+\n+}\n+\n+void CreateAutodiffSubgraphs(Graph & g, size_t threshold) {\n+\n+  // This implementation is not optimal, but it is simple.\n+  // It just scans through the list in order looking for runs of\n+  // differentiable ops, and then grouping them together when\n+  // it hits the first non-differentiable op.\n+  // It cannot handle things like:\n+  // a = f(x, y)\n+  // b = black_box(a)\n+  // c = g(a)\n+  // where you could group {f, g} together if the nodes were in a different\n+  // topological order\n+\n+  // a better strategy would be to try to treat this like a fusion problem\n+  // and group maximal groups\n+  Symbol graph_executor = \"GraphExecutor\"_sym;\n+\n+  std::vector<Node*> groupable;\n+  for(auto n : g.nodes()) { // Note: nodes() iterator stays valid since it is\n+                            // always pointing _after_ the nodes that mergeNodes\n+                            // mutates.\n+    if(isDifferentiable(n)) {\n+      groupable.push_back(n);\n+    } else {\n+      if(groupable.size() >= threshold) {\n+        mergeNodes(g, graph_executor, groupable);", "path": "torch/csrc/jit/passes/create_autodiff_subgraphs.cpp", "position": 98, "original_position": 98, "commit_id": "287518f39717bee1673ba749753df6018e322d02", "original_commit_id": "287518f39717bee1673ba749753df6018e322d02", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "body": "so we will only be merging contiguous sequences of instructions and things like\r\n```\r\ngraph (%1, %2, %3, %4) {\r\n  %10 = ... // many white-box ops\r\n  %11 = black_box(1) // irrelevant black box\r\n  %50 = ... //many white-box-ops that don't depend on 11 (e.g. it's an output)\r\n}\r\n```\r\nwill produce two groups? That doesn't seem to be too robust", "created_at": "2018-01-24T13:47:04Z", "updated_at": "2018-11-23T15:38:31Z", "html_url": "https://github.com/pytorch/pytorch/pull/4822#discussion_r163550274", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/4822", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/163550274"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/4822#discussion_r163550274"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/4822"}}, "body_html": "<p>so we will only be merging contiguous sequences of instructions and things like</p>\n<pre><code>graph (%1, %2, %3, %4) {\n  %10 = ... // many white-box ops\n  %11 = black_box(1) // irrelevant black box\n  %50 = ... //many white-box-ops that don't depend on 11 (e.g. it's an output)\n}\n</code></pre>\n<p>will produce two groups? That doesn't seem to be too robust</p>", "body_text": "so we will only be merging contiguous sequences of instructions and things like\ngraph (%1, %2, %3, %4) {\n  %10 = ... // many white-box ops\n  %11 = black_box(1) // irrelevant black box\n  %50 = ... //many white-box-ops that don't depend on 11 (e.g. it's an output)\n}\n\nwill produce two groups? That doesn't seem to be too robust"}