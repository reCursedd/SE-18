{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/171502297", "pull_request_review_id": 100361425, "id": 171502297, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE3MTUwMjI5Nw==", "diff_hunk": "@@ -1,65 +1,71 @@\n #pragma once\n \n-#include <utility>\n+#include <ATen/ATenAssert.h>\n+#include <ATen/Half.h>\n+#include <ATen/Type.h>\n \n-namespace at {\n-\n-// FIXME: nvcc can't seem to do type deduction on\n-// decltype(F<double>::apply(std::forward<Args>(args)...)) so we have to explicitly pass the return type\n+#define AT_PRIVATE_CASE_TYPE(enum_type, type, ...) \\\n+  case enum_type: {                                \\\n+    using scalar_t = type;                         \\\n+    return __VA_ARGS__();                          \\\n+  }\n \n-template<typename R, template <typename> class F, typename ... Args>\n-R dispatch_all(const Type& the_type, const char *name, Args&&... args) {\n-  switch(the_type.scalarType()) {\n-    case ScalarType::Byte:\n-      return F<uint8_t>::apply(std::forward<Args>(args)...);\n-    case ScalarType::Char:\n-      return F<int8_t>::apply(std::forward<Args>(args)...);\n-    case ScalarType::Double:\n-      return F<double>::apply(std::forward<Args>(args)...);\n-    case ScalarType::Float:\n-      return F<float>::apply(std::forward<Args>(args)...);\n-    case ScalarType::Int:\n-      return F<int>::apply(std::forward<Args>(args)...);\n-    case ScalarType::Long:\n-      return F<int64_t>::apply(std::forward<Args>(args)...);\n-    case ScalarType::Short:\n-      return F<int16_t>::apply(std::forward<Args>(args)...);\n-    case ScalarType::Half:\n-      return F<Half>::apply(std::forward<Args>(args)...);\n-    default:\n-      runtime_error(\"%s not implemented for '%s'\", name, the_type.toString());\n-    }\n-}\n+#define AT_DISPATCH_FLOATING_TYPES(TYPE, NAME, ...)                      \\\n+  [&] {                                                                  \\\n+    const at::Type& the_type = TYPE;                                     \\\n+    switch (the_type.scalarType()) {                                     \\\n+      AT_PRIVATE_CASE_TYPE(at::ScalarType::Double, double, __VA_ARGS__)  \\\n+      AT_PRIVATE_CASE_TYPE(at::ScalarType::Float, float, __VA_ARGS__)    \\\n+      default:                                                           \\\n+        at::runtime_error(                                               \\\n+            \"%s not implemented for '%s'\", (NAME), the_type.toString()); \\\n+    }                                                                    \\\n+  }()\n \n-template<typename R, template <typename> class F, typename ... Args>\n-R dispatch_floating_types(const Type& the_type, const char *name, Args&&... args) {\n-  switch(the_type.scalarType()) {\n-    case ScalarType::Double:\n-      return F<double>::apply(std::forward<Args>(args)...);\n-    case ScalarType::Float:\n-      return F<float>::apply(std::forward<Args>(args)...);\n-    case ScalarType::Half: // no native half math on either CPU or GPU.\n-    default:\n-      runtime_error(\"%s not implemented for '%s'\", name, the_type.toString());\n-  }\n-}\n+#define AT_DISPATCH_FLOATING_TYPES_AND_HALF(TYPE, NAME, ...)             \\\n+  [&] {                                                                  \\\n+    const at::Type& the_type = TYPE;                                     \\\n+    switch (the_type.scalarType()) {                                     \\\n+      AT_PRIVATE_CASE_TYPE(at::ScalarType::Double, double, __VA_ARGS__)  \\\n+      AT_PRIVATE_CASE_TYPE(at::ScalarType::Float, float, __VA_ARGS__)    \\\n+      AT_PRIVATE_CASE_TYPE(at::ScalarType::Half, Half, __VA_ARGS__)      \\\n+      default:                                                           \\\n+        at::runtime_error(                                               \\\n+            \"%s not implemented for '%s'\", (NAME), the_type.toString()); \\\n+    }                                                                    \\\n+  }()\n \n-#define DISPATCH_ALL_FLOATING_TYPES(TYPE, NAME, ...)                             \\\n-  [&]() {                                                                         \\\n-    const Type& the_type = TYPE;                                                  \\\n-    switch (the_type.scalarType()) {                                              \\\n-      case ScalarType::Double: {                                                  \\\n-        using scalar_t = double;                                                  \\\n-        return __VA_ARGS__();                                                               \\\n-      } case ScalarType::Float: {                                                 \\\n-        using scalar_t = float;                                                   \\\n-        return __VA_ARGS__();                                                               \\\n-      } case ScalarType::Half: {                                                  \\\n-        using scalar_t = half;                                                    \\\n-        return __VA_ARGS__();                                                               \\\n-      } default:                                                                  \\\n-        runtime_error(\"%s not implemented for '%s'\", NAME, the_type.toString());  \\\n-    }                                                                             \\\n+#define AT_DISPATCH_ALL_TYPES(TYPE, NAME, ...)                           \\\n+  [&] {                                                                  \\\n+    const at::Type& the_type = TYPE;                                     \\\n+    switch (the_type.scalarType()) {                                     \\\n+      AT_PRIVATE_CASE_TYPE(at::ScalarType::Byte, uint8_t, __VA_ARGS__)   \\\n+      AT_PRIVATE_CASE_TYPE(at::ScalarType::Char, uint8_t, __VA_ARGS__)   \\\n+      AT_PRIVATE_CASE_TYPE(at::ScalarType::Double, double, __VA_ARGS__)  \\\n+      AT_PRIVATE_CASE_TYPE(at::ScalarType::Float, float, __VA_ARGS__)    \\\n+      AT_PRIVATE_CASE_TYPE(at::ScalarType::Int, int32_t, __VA_ARGS__)    \\\n+      AT_PRIVATE_CASE_TYPE(at::ScalarType::Long, int64_t, __VA_ARGS__)   \\\n+      AT_PRIVATE_CASE_TYPE(at::ScalarType::Short, int16_t, __VA_ARGS__)  \\\n+      default:                                                           \\\n+        at::runtime_error(                                               \\\n+            \"%s not implemented for '%s'\", (NAME), the_type.toString()); \\\n+    }                                                                    \\\n   }()\n \n-}\n+#define AT_DISPATCH_ALL_TYPES_AND_HALF(TYPE, NAME, ...)                  \\", "path": "aten/src/ATen/Dispatch.h", "position": 112, "original_position": 112, "commit_id": "66d39ce1535d5ee784e5c9975ce3e4084e7abc74", "original_commit_id": "66d39ce1535d5ee784e5c9975ce3e4084e7abc74", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "body": "Just curious, what's the benefit of keeping it as a macro compared to a function of signature\r\n```cpp\r\ntemplate<typename fn_type>\r\ndispatch_all_types_and_half(at::Type& type, const char* name, fn_type fn) {\r\n  ...\r\n}\r\n```\r\nThe template should allow us to pass in an arbitrary lambda that could capture the enclosing scope if needed. On the other hand, the implementation would be in the header, so the compiler is likely to inline the body.", "created_at": "2018-03-01T09:30:08Z", "updated_at": "2018-11-23T15:40:11Z", "html_url": "https://github.com/pytorch/pytorch/pull/5475#discussion_r171502297", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/5475", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/171502297"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/5475#discussion_r171502297"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/5475"}}, "body_html": "<p>Just curious, what's the benefit of keeping it as a macro compared to a function of signature</p>\n<div class=\"highlight highlight-source-c++\"><pre><span class=\"pl-k\">template</span>&lt;<span class=\"pl-k\">typename</span> fn_type&gt;\n<span class=\"pl-en\">dispatch_all_types_and_half</span>(at::Type&amp; type, <span class=\"pl-k\">const</span> <span class=\"pl-k\">char</span>* name, fn_type fn) {\n  ...\n}</pre></div>\n<p>The template should allow us to pass in an arbitrary lambda that could capture the enclosing scope if needed. On the other hand, the implementation would be in the header, so the compiler is likely to inline the body.</p>", "body_text": "Just curious, what's the benefit of keeping it as a macro compared to a function of signature\ntemplate<typename fn_type>\ndispatch_all_types_and_half(at::Type& type, const char* name, fn_type fn) {\n  ...\n}\nThe template should allow us to pass in an arbitrary lambda that could capture the enclosing scope if needed. On the other hand, the implementation would be in the header, so the compiler is likely to inline the body."}