{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/171407962", "pull_request_review_id": 100256068, "id": 171407962, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE3MTQwNzk2Mg==", "diff_hunk": "@@ -1,65 +1,39 @@\n #pragma once\n \n-#include <utility>\n+#include <ATen/ATenAssert.h>\n+#include <ATen/Type.h>\n \n-namespace at {\n-\n-// FIXME: nvcc can't seem to do type deduction on\n-// decltype(F<double>::apply(std::forward<Args>(args)...)) so we have to explicitly pass the return type\n-\n-template<typename R, template <typename> class F, typename ... Args>\n-R dispatch_all(const Type& the_type, const char *name, Args&&... args) {\n-  switch(the_type.scalarType()) {\n-    case ScalarType::Byte:\n-      return F<uint8_t>::apply(std::forward<Args>(args)...);\n-    case ScalarType::Char:\n-      return F<int8_t>::apply(std::forward<Args>(args)...);\n-    case ScalarType::Double:\n-      return F<double>::apply(std::forward<Args>(args)...);\n-    case ScalarType::Float:\n-      return F<float>::apply(std::forward<Args>(args)...);\n-    case ScalarType::Int:\n-      return F<int>::apply(std::forward<Args>(args)...);\n-    case ScalarType::Long:\n-      return F<int64_t>::apply(std::forward<Args>(args)...);\n-    case ScalarType::Short:\n-      return F<int16_t>::apply(std::forward<Args>(args)...);\n-    case ScalarType::Half:\n-      return F<Half>::apply(std::forward<Args>(args)...);\n-    default:\n-      runtime_error(\"%s not implemented for '%s'\", name, the_type.toString());\n-    }\n-}\n-\n-template<typename R, template <typename> class F, typename ... Args>\n-R dispatch_floating_types(const Type& the_type, const char *name, Args&&... args) {\n-  switch(the_type.scalarType()) {\n-    case ScalarType::Double:\n-      return F<double>::apply(std::forward<Args>(args)...);\n-    case ScalarType::Float:\n-      return F<float>::apply(std::forward<Args>(args)...);\n-    case ScalarType::Half: // no native half math on either CPU or GPU.\n-    default:\n-      runtime_error(\"%s not implemented for '%s'\", name, the_type.toString());\n+#define AT_PRIVATE_CASE_TYPE(enum_type, type, function) \\\n+  case enum_type: {                                     \\\n+    using scalar_t = type;                              \\\n+    return function();                                  \\\n   }\n-}\n \n-#define DISPATCH_ALL_FLOATING_TYPES(TYPE, NAME, ...)                             \\\n-  [&]() {                                                                         \\\n-    const Type& the_type = TYPE;                                                  \\\n-    switch (the_type.scalarType()) {                                              \\\n-      case ScalarType::Double: {                                                  \\\n-        using scalar_t = double;                                                  \\\n-        return __VA_ARGS__();                                                               \\\n-      } case ScalarType::Float: {                                                 \\\n-        using scalar_t = float;                                                   \\\n-        return __VA_ARGS__();                                                               \\\n-      } case ScalarType::Half: {                                                  \\\n-        using scalar_t = half;                                                    \\\n-        return __VA_ARGS__();                                                               \\\n-      } default:                                                                  \\\n-        runtime_error(\"%s not implemented for '%s'\", NAME, the_type.toString());  \\\n-    }                                                                             \\\n+#define AT_DISPATCH_FLOATING_TYPES(TYPE, NAME, function)                 \\", "path": "aten/src/ATen/Dispatch.h", "position": null, "original_position": 69, "commit_id": "66d39ce1535d5ee784e5c9975ce3e4084e7abc74", "original_commit_id": "169ba531f7fa6e34a39289a92cd43ac995cd4fd9", "user": {"login": "goldsborough", "id": 6429851, "node_id": "MDQ6VXNlcjY0Mjk4NTE=", "avatar_url": "https://avatars3.githubusercontent.com/u/6429851?v=4", "gravatar_id": "", "url": "https://api.github.com/users/goldsborough", "html_url": "https://github.com/goldsborough", "followers_url": "https://api.github.com/users/goldsborough/followers", "following_url": "https://api.github.com/users/goldsborough/following{/other_user}", "gists_url": "https://api.github.com/users/goldsborough/gists{/gist_id}", "starred_url": "https://api.github.com/users/goldsborough/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/goldsborough/subscriptions", "organizations_url": "https://api.github.com/users/goldsborough/orgs", "repos_url": "https://api.github.com/users/goldsborough/repos", "events_url": "https://api.github.com/users/goldsborough/events{/privacy}", "received_events_url": "https://api.github.com/users/goldsborough/received_events", "type": "User", "site_admin": false}, "body": "Yeah I see your point. I think when @zdevito and I looked at it we were a bit perplexed by the need for `__VA_ARGS__` as it was a bit unintuitive. It's also [not standard](https://stackoverflow.com/questions/5588855/standard-alternative-to-gccs-va-args-trick) btw, so it'll eventually fail on some compiler...\r\nLike, what happens when you pass an argument between the `NAME` and the lambda by accident? It would get accepted right now and fail in super weird ways inside the macro", "created_at": "2018-02-28T22:34:07Z", "updated_at": "2018-11-23T15:40:10Z", "html_url": "https://github.com/pytorch/pytorch/pull/5475#discussion_r171407962", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/5475", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/171407962"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/5475#discussion_r171407962"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/5475"}}, "body_html": "<p>Yeah I see your point. I think when <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=370202\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/zdevito\">@zdevito</a> and I looked at it we were a bit perplexed by the need for <code>__VA_ARGS__</code> as it was a bit unintuitive. It's also <a href=\"https://stackoverflow.com/questions/5588855/standard-alternative-to-gccs-va-args-trick\" rel=\"nofollow\">not standard</a> btw, so it'll eventually fail on some compiler...<br>\nLike, what happens when you pass an argument between the <code>NAME</code> and the lambda by accident? It would get accepted right now and fail in super weird ways inside the macro</p>", "body_text": "Yeah I see your point. I think when @zdevito and I looked at it we were a bit perplexed by the need for __VA_ARGS__ as it was a bit unintuitive. It's also not standard btw, so it'll eventually fail on some compiler...\nLike, what happens when you pass an argument between the NAME and the lambda by accident? It would get accepted right now and fail in super weird ways inside the macro", "in_reply_to_id": 171406839}