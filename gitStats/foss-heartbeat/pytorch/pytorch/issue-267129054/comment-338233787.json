{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/338233787", "html_url": "https://github.com/pytorch/pytorch/issues/3199#issuecomment-338233787", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/3199", "id": 338233787, "node_id": "MDEyOklzc3VlQ29tbWVudDMzODIzMzc4Nw==", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "created_at": "2017-10-20T15:06:55Z", "updated_at": "2017-10-20T15:08:08Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Untested fix:</p>\n<pre><code>diff --git a/torch/lib/ATen/function_wrapper.py b/torch/lib/ATen/function_wrapper.py\nindex 006c524..0a8d0f3 100644\n--- a/torch/lib/ATen/function_wrapper.py\n+++ b/torch/lib/ATen/function_wrapper.py\n@@ -219,10 +219,10 @@ def is_mutable_formal_argument(argument, option):\n     return argument.get('output') or option['inplace'] and argument['name'] == 'self'\n \n \n-def to_return_type(arg, option):\n+def to_return_type(arg, option, multiple_return):\n     t = arg['type']\n     rt = TYPE_RETURN.get(t, t)\n-    if rt == 'Tensor' and not arg.get('allocate'):\n+    if rt == 'Tensor' and not arg.get('allocate') and not multiple_return:\n         rt = rt + ' &amp;'\n         if not is_mutable_formal_argument(arg, option):\n             rt = 'const ' + rt\n@@ -322,9 +322,9 @@ def create_generic(top_env, declarations):\n             argument_indices = ret['arguments']\n             if len(argument_indices) == 1:\n                 the_arg = option['arguments'][argument_indices[0]]\n-                return [to_return_type(the_arg, option)]\n+                return [to_return_type(the_arg, option, multiple_return=False)]\n             else:\n-                return [to_return_type(option['arguments'][idx], option)\n+                return [to_return_type(option['arguments'][idx], option, multiple_return=True)\n                         for idx in argument_indices]\n         elif ret['kind'] == 'type':\n             return [{\n@@ -767,7 +767,7 @@ def create_derived(backend_type_env, declarations):\n                 arg = arguments[0]\n                 body.append(\"return {};\".format(arg['name']))\n             else:\n-                types = [to_return_type(arg, option)['type']\n+                types = [to_return_type(arg, option, multiple_return=True)['type']\n                          for arg in arguments]\n                 # TODO: check for move semantics...\n                 names = [arg['name'] for arg in arguments]\n</code></pre>", "body_text": "Untested fix:\ndiff --git a/torch/lib/ATen/function_wrapper.py b/torch/lib/ATen/function_wrapper.py\nindex 006c524..0a8d0f3 100644\n--- a/torch/lib/ATen/function_wrapper.py\n+++ b/torch/lib/ATen/function_wrapper.py\n@@ -219,10 +219,10 @@ def is_mutable_formal_argument(argument, option):\n     return argument.get('output') or option['inplace'] and argument['name'] == 'self'\n \n \n-def to_return_type(arg, option):\n+def to_return_type(arg, option, multiple_return):\n     t = arg['type']\n     rt = TYPE_RETURN.get(t, t)\n-    if rt == 'Tensor' and not arg.get('allocate'):\n+    if rt == 'Tensor' and not arg.get('allocate') and not multiple_return:\n         rt = rt + ' &'\n         if not is_mutable_formal_argument(arg, option):\n             rt = 'const ' + rt\n@@ -322,9 +322,9 @@ def create_generic(top_env, declarations):\n             argument_indices = ret['arguments']\n             if len(argument_indices) == 1:\n                 the_arg = option['arguments'][argument_indices[0]]\n-                return [to_return_type(the_arg, option)]\n+                return [to_return_type(the_arg, option, multiple_return=False)]\n             else:\n-                return [to_return_type(option['arguments'][idx], option)\n+                return [to_return_type(option['arguments'][idx], option, multiple_return=True)\n                         for idx in argument_indices]\n         elif ret['kind'] == 'type':\n             return [{\n@@ -767,7 +767,7 @@ def create_derived(backend_type_env, declarations):\n                 arg = arguments[0]\n                 body.append(\"return {};\".format(arg['name']))\n             else:\n-                types = [to_return_type(arg, option)['type']\n+                types = [to_return_type(arg, option, multiple_return=True)['type']\n                          for arg in arguments]\n                 # TODO: check for move semantics...\n                 names = [arg['name'] for arg in arguments]", "body": "Untested fix:\r\n\r\n```\r\ndiff --git a/torch/lib/ATen/function_wrapper.py b/torch/lib/ATen/function_wrapper.py\r\nindex 006c524..0a8d0f3 100644\r\n--- a/torch/lib/ATen/function_wrapper.py\r\n+++ b/torch/lib/ATen/function_wrapper.py\r\n@@ -219,10 +219,10 @@ def is_mutable_formal_argument(argument, option):\r\n     return argument.get('output') or option['inplace'] and argument['name'] == 'self'\r\n \r\n \r\n-def to_return_type(arg, option):\r\n+def to_return_type(arg, option, multiple_return):\r\n     t = arg['type']\r\n     rt = TYPE_RETURN.get(t, t)\r\n-    if rt == 'Tensor' and not arg.get('allocate'):\r\n+    if rt == 'Tensor' and not arg.get('allocate') and not multiple_return:\r\n         rt = rt + ' &'\r\n         if not is_mutable_formal_argument(arg, option):\r\n             rt = 'const ' + rt\r\n@@ -322,9 +322,9 @@ def create_generic(top_env, declarations):\r\n             argument_indices = ret['arguments']\r\n             if len(argument_indices) == 1:\r\n                 the_arg = option['arguments'][argument_indices[0]]\r\n-                return [to_return_type(the_arg, option)]\r\n+                return [to_return_type(the_arg, option, multiple_return=False)]\r\n             else:\r\n-                return [to_return_type(option['arguments'][idx], option)\r\n+                return [to_return_type(option['arguments'][idx], option, multiple_return=True)\r\n                         for idx in argument_indices]\r\n         elif ret['kind'] == 'type':\r\n             return [{\r\n@@ -767,7 +767,7 @@ def create_derived(backend_type_env, declarations):\r\n                 arg = arguments[0]\r\n                 body.append(\"return {};\".format(arg['name']))\r\n             else:\r\n-                types = [to_return_type(arg, option)['type']\r\n+                types = [to_return_type(arg, option, multiple_return=True)['type']\r\n                          for arg in arguments]\r\n                 # TODO: check for move semantics...\r\n                 names = [arg['name'] for arg in arguments]\r\n```"}