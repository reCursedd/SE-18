{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/191520876", "pull_request_review_id": 124108701, "id": 191520876, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MTUyMDg3Ng==", "diff_hunk": "@@ -101,7 +101,7 @@ static PyObject * THPStorage_(shareFilename)(THPStorage *self)\n     ctx = (libshm_context*)allocator_obj->allocatorContext;\n   } else {\n     // TODO: retry on collision\n-    // TODO: free GIL - but remember to reacquire it when an exception is thrown\n+    AutoNoGIL no_gil;", "path": "torch/csrc/generic/StorageSharing.cpp", "position": 5, "original_position": 5, "commit_id": "e9dae6bdbe3d16a1ff5df165a1e5f306570fb1a2", "original_commit_id": "e9dae6bdbe3d16a1ff5df165a1e5f306570fb1a2", "user": {"login": "colesbury", "id": 655866, "node_id": "MDQ6VXNlcjY1NTg2Ng==", "avatar_url": "https://avatars1.githubusercontent.com/u/655866?v=4", "gravatar_id": "", "url": "https://api.github.com/users/colesbury", "html_url": "https://github.com/colesbury", "followers_url": "https://api.github.com/users/colesbury/followers", "following_url": "https://api.github.com/users/colesbury/following{/other_user}", "gists_url": "https://api.github.com/users/colesbury/gists{/gist_id}", "starred_url": "https://api.github.com/users/colesbury/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/colesbury/subscriptions", "organizations_url": "https://api.github.com/users/colesbury/orgs", "repos_url": "https://api.github.com/users/colesbury/repos", "events_url": "https://api.github.com/users/colesbury/events{/privacy}", "received_events_url": "https://api.github.com/users/colesbury/received_events", "type": "User", "site_admin": false}, "body": "It wasn't thread safe even with the GIL: any concurrent read operations on this storage would cause a data race.\r\n\r\nI'm not a huge fan of this sort of ad-hoc locking, since it gives the appearance of thread safety without the guarantees. So far we've said that concurrent read operations are thread-safe, but mutating ops (`_`-ending functions) are not safe concurrently with each other or with read ops.\r\n\r\nI also would prefer to avoid a single global mutex around these ops because that prevents threads from copying unrelated storages to shared memory in parallel.\r\n\r\nWe could narrow the AutoNoGIL to around the storage construction and copy but exclude the `swap`. That would lessen the chance of metadata corruption, although it still wouldn't be thread-safe.\r\n\r\n", "created_at": "2018-05-29T18:07:11Z", "updated_at": "2018-11-23T15:44:41Z", "html_url": "https://github.com/pytorch/pytorch/pull/7918#discussion_r191520876", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/7918", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/191520876"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/7918#discussion_r191520876"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/7918"}}, "body_html": "<p>It wasn't thread safe even with the GIL: any concurrent read operations on this storage would cause a data race.</p>\n<p>I'm not a huge fan of this sort of ad-hoc locking, since it gives the appearance of thread safety without the guarantees. So far we've said that concurrent read operations are thread-safe, but mutating ops (<code>_</code>-ending functions) are not safe concurrently with each other or with read ops.</p>\n<p>I also would prefer to avoid a single global mutex around these ops because that prevents threads from copying unrelated storages to shared memory in parallel.</p>\n<p>We could narrow the AutoNoGIL to around the storage construction and copy but exclude the <code>swap</code>. That would lessen the chance of metadata corruption, although it still wouldn't be thread-safe.</p>", "body_text": "It wasn't thread safe even with the GIL: any concurrent read operations on this storage would cause a data race.\nI'm not a huge fan of this sort of ad-hoc locking, since it gives the appearance of thread safety without the guarantees. So far we've said that concurrent read operations are thread-safe, but mutating ops (_-ending functions) are not safe concurrently with each other or with read ops.\nI also would prefer to avoid a single global mutex around these ops because that prevents threads from copying unrelated storages to shared memory in parallel.\nWe could narrow the AutoNoGIL to around the storage construction and copy but exclude the swap. That would lessen the chance of metadata corruption, although it still wouldn't be thread-safe.", "in_reply_to_id": 191499067}