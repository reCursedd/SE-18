{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/314090997", "html_url": "https://github.com/pytorch/pytorch/issues/755#issuecomment-314090997", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/755", "id": 314090997, "node_id": "MDEyOklzc3VlQ29tbWVudDMxNDA5MDk5Nw==", "user": {"login": "Roger-luo", "id": 8445510, "node_id": "MDQ6VXNlcjg0NDU1MTA=", "avatar_url": "https://avatars2.githubusercontent.com/u/8445510?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Roger-luo", "html_url": "https://github.com/Roger-luo", "followers_url": "https://api.github.com/users/Roger-luo/followers", "following_url": "https://api.github.com/users/Roger-luo/following{/other_user}", "gists_url": "https://api.github.com/users/Roger-luo/gists{/gist_id}", "starred_url": "https://api.github.com/users/Roger-luo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Roger-luo/subscriptions", "organizations_url": "https://api.github.com/users/Roger-luo/orgs", "repos_url": "https://api.github.com/users/Roger-luo/repos", "events_url": "https://api.github.com/users/Roger-luo/events{/privacy}", "received_events_url": "https://api.github.com/users/Roger-luo/received_events", "type": "User", "site_admin": false}, "created_at": "2017-07-10T12:29:25Z", "updated_at": "2017-07-10T15:35:30Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=10103420\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/elbamos\">@elbamos</a> Most of the work in <code>THNN</code> will be about implementing new complex backpropagtion methods for each existed layer. There is a WIP PR in Philipp's fork. I've listed some references.</p>\n<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=4583066\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/apaszke\">@apaszke</a> <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=1310570\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/soumith\">@soumith</a> <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=1299153\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/PhilippPelz\">@PhilippPelz</a> And there is two questions:</p>\n<ul>\n<li>\n<p>does anyone know why there is another <code>GenerateXXXTypes.h</code> file in <code>THS</code>? It looks the same with those in <code>TH</code>.</p>\n</li>\n<li>\n<p>What is the following code in <code>byte_order.cpp</code> for?</p>\n</li>\n</ul>\n<div class=\"highlight highlight-source-c++\"><pre><span class=\"pl-k\">void</span> <span class=\"pl-en\">THP_decodeFloatBuffer</span>(<span class=\"pl-k\">float</span>* dst, <span class=\"pl-k\">const</span> <span class=\"pl-c1\">uint8_t</span>* src, THPByteOrder order, <span class=\"pl-c1\">size_t</span> len)\n{\n  <span class=\"pl-k\">for</span> (<span class=\"pl-c1\">size_t</span> i = <span class=\"pl-c1\">0</span>; i &lt; len; i++) {\n    <span class=\"pl-k\">union</span> { <span class=\"pl-c1\">uint32_t</span> x; <span class=\"pl-k\">float</span> f; };\n    x = (order == THP_BIG_ENDIAN ? <span class=\"pl-c1\">decodeUInt32BE</span>(src) : <span class=\"pl-c1\">decodeUInt32LE</span>(src));\n    dst[i] = f;\n    src += <span class=\"pl-k\">sizeof</span>(<span class=\"pl-k\">float</span>);\n  }\n}\n\n<span class=\"pl-k\">void</span> <span class=\"pl-en\">THP_decodeDoubleBuffer</span>(<span class=\"pl-k\">double</span>* dst, <span class=\"pl-k\">const</span> <span class=\"pl-c1\">uint8_t</span>* src, THPByteOrder order, <span class=\"pl-c1\">size_t</span> len)\n{\n  <span class=\"pl-k\">for</span> (<span class=\"pl-c1\">size_t</span> i = <span class=\"pl-c1\">0</span>; i &lt; len; i++) {\n    <span class=\"pl-k\">union</span> { <span class=\"pl-c1\">uint64_t</span> x; <span class=\"pl-k\">double</span> d; };\n    x = (order == THP_BIG_ENDIAN ? <span class=\"pl-c1\">decodeUInt64BE</span>(src) : <span class=\"pl-c1\">decodeUInt64LE</span>(src));\n    dst[i] = d;\n    src += <span class=\"pl-k\">sizeof</span>(<span class=\"pl-k\">double</span>);\n  }\n}</pre></div>\n<p>Any suggestions on implementing its related complex version? I'm not sure if the following implementation is correct...</p>\n<div class=\"highlight highlight-source-c++\"><pre><span class=\"pl-k\">void</span> <span class=\"pl-en\">THP_decodeZFloatBuffer</span>(std::complex&lt;<span class=\"pl-k\">float</span>&gt;* dst, <span class=\"pl-k\">const</span> <span class=\"pl-c1\">uint8_t</span>* src, THPByteOrder order, <span class=\"pl-c1\">size_t</span> len)\n{\n  <span class=\"pl-k\">for</span> (<span class=\"pl-c1\">size_t</span> i = <span class=\"pl-c1\">0</span>; i &lt; len; i++) {\n    <span class=\"pl-k\">union</span> { <span class=\"pl-c1\">uint64_t</span> x; std::complex&lt;<span class=\"pl-k\">float</span>&gt; cf;};\n    x = (order == THP_BIG_ENDIAN ? <span class=\"pl-c1\">decodeUInt64BE</span>(src) : <span class=\"pl-c1\">decodeUInt64LE</span>(src));\n    dst[i] = cf;\n    src += <span class=\"pl-k\">sizeof</span>(std::complex&lt;<span class=\"pl-k\">float</span>&gt;);\n  }\n}\n\n<span class=\"pl-k\">void</span> <span class=\"pl-en\">THP_decodeDoubleBuffer</span>(std::complex&lt;<span class=\"pl-k\">double</span>&gt;* dst, <span class=\"pl-k\">const</span> <span class=\"pl-c1\">uint8_t</span>* src, THPByteOrder order, <span class=\"pl-c1\">size_t</span> len)\n{\n  <span class=\"pl-k\">for</span> (<span class=\"pl-c1\">size_t</span> i = <span class=\"pl-c1\">0</span>; i &lt; len; i++) {\n    <span class=\"pl-k\">union</span> { <span class=\"pl-c1\">uint128_t</span> x; std::complex&lt;<span class=\"pl-k\">double</span>&gt; df;};\n    x = (order == THP_BIG_ENDIAN ? <span class=\"pl-c1\">decodeUInt128BE</span>(src) : <span class=\"pl-c1\">decodeUInt128LE</span>(src));\n    dst[i] = df;\n    src += <span class=\"pl-k\">sizeof</span>(std::complex&lt;<span class=\"pl-k\">double</span>&gt;);\n  }\n}</pre></div>\n<p>Previous <code>decodeUInt128XE</code> is declared as</p>\n<div class=\"highlight highlight-source-c++\"><pre><span class=\"pl-k\">static</span> <span class=\"pl-k\">inline</span> <span class=\"pl-c1\">uint128_t</span> <span class=\"pl-en\">decodeUInt128LE</span>(<span class=\"pl-k\">const</span> <span class=\"pl-c1\">uint8_t</span> *data) {\n  <span class=\"pl-k\">return</span> (((<span class=\"pl-c1\">uint128_t</span>)data[ <span class=\"pl-c1\">0</span>])&lt;&lt;  <span class=\"pl-c1\">0</span>) | (((<span class=\"pl-c1\">uint128_t</span>)data[ <span class=\"pl-c1\">1</span>])&lt;&lt;  <span class=\"pl-c1\">8</span>)|\n         (((<span class=\"pl-c1\">uint128_t</span>)data[ <span class=\"pl-c1\">2</span>])&lt;&lt; <span class=\"pl-c1\">16</span>) | (((<span class=\"pl-c1\">uint128_t</span>)data[ <span class=\"pl-c1\">3</span>])&lt;&lt; <span class=\"pl-c1\">24</span>)|\n         (((<span class=\"pl-c1\">uint128_t</span>)data[ <span class=\"pl-c1\">4</span>])&lt;&lt; <span class=\"pl-c1\">32</span>) | (((<span class=\"pl-c1\">uint128_t</span>)data[ <span class=\"pl-c1\">5</span>])&lt;&lt; <span class=\"pl-c1\">40</span>)|\n         (((<span class=\"pl-c1\">uint128_t</span>)data[ <span class=\"pl-c1\">6</span>])&lt;&lt; <span class=\"pl-c1\">48</span>) | (((<span class=\"pl-c1\">uint128_t</span>)data[ <span class=\"pl-c1\">7</span>])&lt;&lt; <span class=\"pl-c1\">56</span>)|\n         (((<span class=\"pl-c1\">uint128_t</span>)data[ <span class=\"pl-c1\">8</span>])&lt;&lt; <span class=\"pl-c1\">64</span>) | (((<span class=\"pl-c1\">uint128_t</span>)data[ <span class=\"pl-c1\">9</span>])&lt;&lt; <span class=\"pl-c1\">72</span>)|\n         (((<span class=\"pl-c1\">uint128_t</span>)data[<span class=\"pl-c1\">10</span>])&lt;&lt; <span class=\"pl-c1\">80</span>) | (((<span class=\"pl-c1\">uint128_t</span>)data[<span class=\"pl-c1\">11</span>])&lt;&lt; <span class=\"pl-c1\">88</span>)|\n         (((<span class=\"pl-c1\">uint128_t</span>)data[<span class=\"pl-c1\">12</span>])&lt;&lt; <span class=\"pl-c1\">96</span>) | (((<span class=\"pl-c1\">uint128_t</span>)data[<span class=\"pl-c1\">13</span>])&lt;&lt;<span class=\"pl-c1\">104</span>)|\n         (((<span class=\"pl-c1\">uint128_t</span>)data[<span class=\"pl-c1\">14</span>])&lt;&lt;<span class=\"pl-c1\">112</span>) | (((<span class=\"pl-c1\">uint128_t</span>)data[<span class=\"pl-c1\">15</span>])&lt;&lt;<span class=\"pl-c1\">120</span>);\n}\n\n<span class=\"pl-k\">static</span> <span class=\"pl-k\">inline</span> <span class=\"pl-c1\">uint128_t</span> <span class=\"pl-en\">decodeUInt128BE</span>(<span class=\"pl-k\">const</span> <span class=\"pl-c1\">uint8_t</span> *data) {\n  <span class=\"pl-k\">return</span> (((<span class=\"pl-c1\">uint128_t</span>)data[<span class=\"pl-c1\">15</span>])&lt;&lt;  <span class=\"pl-c1\">0</span>) | (((<span class=\"pl-c1\">uint128_t</span>)data[<span class=\"pl-c1\">14</span>])&lt;&lt;  <span class=\"pl-c1\">8</span>)|\n         (((<span class=\"pl-c1\">uint128_t</span>)data[<span class=\"pl-c1\">13</span>])&lt;&lt; <span class=\"pl-c1\">16</span>) | (((<span class=\"pl-c1\">uint128_t</span>)data[<span class=\"pl-c1\">12</span>])&lt;&lt; <span class=\"pl-c1\">24</span>)|\n         (((<span class=\"pl-c1\">uint128_t</span>)data[<span class=\"pl-c1\">11</span>])&lt;&lt; <span class=\"pl-c1\">32</span>) | (((<span class=\"pl-c1\">uint128_t</span>)data[<span class=\"pl-c1\">10</span>])&lt;&lt; <span class=\"pl-c1\">40</span>)|\n         (((<span class=\"pl-c1\">uint128_t</span>)data[ <span class=\"pl-c1\">9</span>])&lt;&lt; <span class=\"pl-c1\">48</span>) | (((<span class=\"pl-c1\">uint128_t</span>)data[ <span class=\"pl-c1\">8</span>])&lt;&lt; <span class=\"pl-c1\">56</span>)|\n         (((<span class=\"pl-c1\">uint128_t</span>)data[ <span class=\"pl-c1\">7</span>])&lt;&lt; <span class=\"pl-c1\">64</span>) | (((<span class=\"pl-c1\">uint128_t</span>)data[ <span class=\"pl-c1\">6</span>])&lt;&lt; <span class=\"pl-c1\">72</span>)|\n         (((<span class=\"pl-c1\">uint128_t</span>)data[ <span class=\"pl-c1\">5</span>])&lt;&lt; <span class=\"pl-c1\">80</span>) | (((<span class=\"pl-c1\">uint128_t</span>)data[ <span class=\"pl-c1\">4</span>])&lt;&lt; <span class=\"pl-c1\">88</span>)|\n         (((<span class=\"pl-c1\">uint128_t</span>)data[ <span class=\"pl-c1\">3</span>])&lt;&lt; <span class=\"pl-c1\">96</span>) | (((<span class=\"pl-c1\">uint128_t</span>)data[ <span class=\"pl-c1\">2</span>])&lt;&lt;<span class=\"pl-c1\">104</span>)|\n         (((<span class=\"pl-c1\">uint128_t</span>)data[ <span class=\"pl-c1\">1</span>])&lt;&lt;<span class=\"pl-c1\">112</span>) | (((<span class=\"pl-c1\">uint128_t</span>)data[ <span class=\"pl-c1\">0</span>])&lt;&lt;<span class=\"pl-c1\">120</span>);\n}</pre></div>\n<p>I'm currently use <code>std::complex&lt;T&gt;</code> instead of <code>T _Complex</code> in <code>THPP</code>. I'm not sure this is can be used by Python yet. Or only c type <code>T _Complex</code> is usable for python. So here the type of dst is <code>std::complex&lt;T&gt;</code>.</p>\n<p>And if I'm correct for this implementation, probably we need a <code>uint128_t</code> implementation, like <a href=\"https://github.com/calccrypto/uint128_t\">https://github.com/calccrypto/uint128_t</a> ? Since it seems not all the compliers supports 128-bit integer (gcc has a int128_t and uint128_t).</p>", "body_text": "@elbamos Most of the work in THNN will be about implementing new complex backpropagtion methods for each existed layer. There is a WIP PR in Philipp's fork. I've listed some references.\n@apaszke @soumith @PhilippPelz And there is two questions:\n\n\ndoes anyone know why there is another GenerateXXXTypes.h file in THS? It looks the same with those in TH.\n\n\nWhat is the following code in byte_order.cpp for?\n\n\nvoid THP_decodeFloatBuffer(float* dst, const uint8_t* src, THPByteOrder order, size_t len)\n{\n  for (size_t i = 0; i < len; i++) {\n    union { uint32_t x; float f; };\n    x = (order == THP_BIG_ENDIAN ? decodeUInt32BE(src) : decodeUInt32LE(src));\n    dst[i] = f;\n    src += sizeof(float);\n  }\n}\n\nvoid THP_decodeDoubleBuffer(double* dst, const uint8_t* src, THPByteOrder order, size_t len)\n{\n  for (size_t i = 0; i < len; i++) {\n    union { uint64_t x; double d; };\n    x = (order == THP_BIG_ENDIAN ? decodeUInt64BE(src) : decodeUInt64LE(src));\n    dst[i] = d;\n    src += sizeof(double);\n  }\n}\nAny suggestions on implementing its related complex version? I'm not sure if the following implementation is correct...\nvoid THP_decodeZFloatBuffer(std::complex<float>* dst, const uint8_t* src, THPByteOrder order, size_t len)\n{\n  for (size_t i = 0; i < len; i++) {\n    union { uint64_t x; std::complex<float> cf;};\n    x = (order == THP_BIG_ENDIAN ? decodeUInt64BE(src) : decodeUInt64LE(src));\n    dst[i] = cf;\n    src += sizeof(std::complex<float>);\n  }\n}\n\nvoid THP_decodeDoubleBuffer(std::complex<double>* dst, const uint8_t* src, THPByteOrder order, size_t len)\n{\n  for (size_t i = 0; i < len; i++) {\n    union { uint128_t x; std::complex<double> df;};\n    x = (order == THP_BIG_ENDIAN ? decodeUInt128BE(src) : decodeUInt128LE(src));\n    dst[i] = df;\n    src += sizeof(std::complex<double>);\n  }\n}\nPrevious decodeUInt128XE is declared as\nstatic inline uint128_t decodeUInt128LE(const uint8_t *data) {\n  return (((uint128_t)data[ 0])<<  0) | (((uint128_t)data[ 1])<<  8)|\n         (((uint128_t)data[ 2])<< 16) | (((uint128_t)data[ 3])<< 24)|\n         (((uint128_t)data[ 4])<< 32) | (((uint128_t)data[ 5])<< 40)|\n         (((uint128_t)data[ 6])<< 48) | (((uint128_t)data[ 7])<< 56)|\n         (((uint128_t)data[ 8])<< 64) | (((uint128_t)data[ 9])<< 72)|\n         (((uint128_t)data[10])<< 80) | (((uint128_t)data[11])<< 88)|\n         (((uint128_t)data[12])<< 96) | (((uint128_t)data[13])<<104)|\n         (((uint128_t)data[14])<<112) | (((uint128_t)data[15])<<120);\n}\n\nstatic inline uint128_t decodeUInt128BE(const uint8_t *data) {\n  return (((uint128_t)data[15])<<  0) | (((uint128_t)data[14])<<  8)|\n         (((uint128_t)data[13])<< 16) | (((uint128_t)data[12])<< 24)|\n         (((uint128_t)data[11])<< 32) | (((uint128_t)data[10])<< 40)|\n         (((uint128_t)data[ 9])<< 48) | (((uint128_t)data[ 8])<< 56)|\n         (((uint128_t)data[ 7])<< 64) | (((uint128_t)data[ 6])<< 72)|\n         (((uint128_t)data[ 5])<< 80) | (((uint128_t)data[ 4])<< 88)|\n         (((uint128_t)data[ 3])<< 96) | (((uint128_t)data[ 2])<<104)|\n         (((uint128_t)data[ 1])<<112) | (((uint128_t)data[ 0])<<120);\n}\nI'm currently use std::complex<T> instead of T _Complex in THPP. I'm not sure this is can be used by Python yet. Or only c type T _Complex is usable for python. So here the type of dst is std::complex<T>.\nAnd if I'm correct for this implementation, probably we need a uint128_t implementation, like https://github.com/calccrypto/uint128_t ? Since it seems not all the compliers supports 128-bit integer (gcc has a int128_t and uint128_t).", "body": "@elbamos Most of the work in `THNN` will be about implementing new complex backpropagtion methods for each existed layer. There is a WIP PR in Philipp's fork. I've listed some references. \r\n\r\n\r\n @apaszke @soumith @PhilippPelz And there is two questions:\r\n\r\n- does anyone know why there is another `GenerateXXXTypes.h` file in `THS`? It looks the same with those in `TH`.\r\n\r\n- What is the following code in `byte_order.cpp` for?\r\n\r\n```cpp\r\nvoid THP_decodeFloatBuffer(float* dst, const uint8_t* src, THPByteOrder order, size_t len)\r\n{\r\n  for (size_t i = 0; i < len; i++) {\r\n    union { uint32_t x; float f; };\r\n    x = (order == THP_BIG_ENDIAN ? decodeUInt32BE(src) : decodeUInt32LE(src));\r\n    dst[i] = f;\r\n    src += sizeof(float);\r\n  }\r\n}\r\n\r\nvoid THP_decodeDoubleBuffer(double* dst, const uint8_t* src, THPByteOrder order, size_t len)\r\n{\r\n  for (size_t i = 0; i < len; i++) {\r\n    union { uint64_t x; double d; };\r\n    x = (order == THP_BIG_ENDIAN ? decodeUInt64BE(src) : decodeUInt64LE(src));\r\n    dst[i] = d;\r\n    src += sizeof(double);\r\n  }\r\n}\r\n```\r\n\r\nAny suggestions on implementing its related complex version? I'm not sure if the following implementation is correct...\r\n\r\n```cpp\r\nvoid THP_decodeZFloatBuffer(std::complex<float>* dst, const uint8_t* src, THPByteOrder order, size_t len)\r\n{\r\n  for (size_t i = 0; i < len; i++) {\r\n    union { uint64_t x; std::complex<float> cf;};\r\n    x = (order == THP_BIG_ENDIAN ? decodeUInt64BE(src) : decodeUInt64LE(src));\r\n    dst[i] = cf;\r\n    src += sizeof(std::complex<float>);\r\n  }\r\n}\r\n\r\nvoid THP_decodeDoubleBuffer(std::complex<double>* dst, const uint8_t* src, THPByteOrder order, size_t len)\r\n{\r\n  for (size_t i = 0; i < len; i++) {\r\n    union { uint128_t x; std::complex<double> df;};\r\n    x = (order == THP_BIG_ENDIAN ? decodeUInt128BE(src) : decodeUInt128LE(src));\r\n    dst[i] = df;\r\n    src += sizeof(std::complex<double>);\r\n  }\r\n}\r\n```\r\nPrevious `decodeUInt128XE` is declared as \r\n\r\n```cpp\r\nstatic inline uint128_t decodeUInt128LE(const uint8_t *data) {\r\n  return (((uint128_t)data[ 0])<<  0) | (((uint128_t)data[ 1])<<  8)|\r\n         (((uint128_t)data[ 2])<< 16) | (((uint128_t)data[ 3])<< 24)|\r\n         (((uint128_t)data[ 4])<< 32) | (((uint128_t)data[ 5])<< 40)|\r\n         (((uint128_t)data[ 6])<< 48) | (((uint128_t)data[ 7])<< 56)|\r\n         (((uint128_t)data[ 8])<< 64) | (((uint128_t)data[ 9])<< 72)|\r\n         (((uint128_t)data[10])<< 80) | (((uint128_t)data[11])<< 88)|\r\n         (((uint128_t)data[12])<< 96) | (((uint128_t)data[13])<<104)|\r\n         (((uint128_t)data[14])<<112) | (((uint128_t)data[15])<<120);\r\n}\r\n\r\nstatic inline uint128_t decodeUInt128BE(const uint8_t *data) {\r\n  return (((uint128_t)data[15])<<  0) | (((uint128_t)data[14])<<  8)|\r\n         (((uint128_t)data[13])<< 16) | (((uint128_t)data[12])<< 24)|\r\n         (((uint128_t)data[11])<< 32) | (((uint128_t)data[10])<< 40)|\r\n         (((uint128_t)data[ 9])<< 48) | (((uint128_t)data[ 8])<< 56)|\r\n         (((uint128_t)data[ 7])<< 64) | (((uint128_t)data[ 6])<< 72)|\r\n         (((uint128_t)data[ 5])<< 80) | (((uint128_t)data[ 4])<< 88)|\r\n         (((uint128_t)data[ 3])<< 96) | (((uint128_t)data[ 2])<<104)|\r\n         (((uint128_t)data[ 1])<<112) | (((uint128_t)data[ 0])<<120);\r\n}\r\n```\r\n\r\n\r\nI'm currently use `std::complex<T>` instead of `T _Complex` in `THPP`. I'm not sure this is can be used by Python yet. Or only c type `T _Complex` is usable for python. So here the type of dst is `std::complex<T>`. \r\n\r\nAnd if I'm correct for this implementation, probably we need a `uint128_t` implementation, like https://github.com/calccrypto/uint128_t ? Since it seems not all the compliers supports 128-bit integer (gcc has a int128_t and uint128_t).\r\n\r\n"}