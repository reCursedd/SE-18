{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/233104677", "pull_request_review_id": 174444398, "id": 233104677, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMzEwNDY3Nw==", "diff_hunk": "@@ -1,257 +1,293 @@\n #include \"torch/csrc/jit/passes/create_autodiff_subgraphs.h\"\n \n-#include \"torch/csrc/jit/ir.h\"\n-#include \"torch/csrc/jit/autodiff.h\"\n #include \"torch/csrc/jit/assertions.h\"\n-#include \"torch/csrc/jit/dynamic_dag.h\"\n-\n-#include <cstddef>\n-#include <limits>\n-\n-namespace torch { namespace jit {\n+#include \"torch/csrc/jit/autodiff.h\"\n+#include \"torch/csrc/jit/ir.h\"\n+#include \"torch/csrc/jit/passes/common_subexpression_elimination.h\"\n \n-struct Graph;\n+namespace torch {\n+namespace jit {\n \n namespace {\n \n-// Move nodes that exist in graph g into a 'group_node_kind' node.\n-// All inputs shared by the nodes become inputs to the new node.\n-// Outputs from 'nodes' are redirected to outputs of the new node,\n-// and the original nodes are removed.\n-// prereq: it is topologically valid to place the new node\n-// right before nodes[0] (i.e. it will not create cycles and all uses of\n-// new node will be after this position).\n-// prereq: nodes are in topological order\n-Node* mergeNodes(Block * block, Symbol group_node_kind, ArrayRef<Node*> nodes) {\n-  JIT_ASSERT(nodes.size() > 0);\n-  std::unordered_map<Value*, Value*> value_map;\n-  Graph * graph = block->owningGraph();\n-\n-  auto new_graph = std::make_shared<Graph>();\n-  Node * group_node = graph->create(group_node_kind, 0);\n-  group_node->g_(attr::Subgraph, new_graph);\n-\n-  auto getOrCreateInput = [&](Value * v) {\n-    if(value_map.count(v) > 0) {\n-      return value_map[v];\n-    }\n-    if (auto value = toIValue(v)) {\n-      Value * nv = new_graph->insertConstant(*value);\n-      value_map[v] = nv;\n-      return nv;\n+class SubgraphSlicer {\n+ public:\n+  SubgraphSlicer(Block* block, size_t minSubgraphSize)\n+      : block_(block), minSubgraphSize_(minSubgraphSize) {}\n+\n+  void run(std::vector<Node*>& diffGraphs) {\n+    bool any_changed = true;\n+    while (any_changed) {", "path": "torch/csrc/jit/passes/create_autodiff_subgraphs.cpp", "position": 97, "original_position": 54, "commit_id": "30284b6e20001a239bf4139e9488d04af3e26e9d", "original_commit_id": "a61c86c7641b139c73e0401fa99e9bdf5cb3dbd2", "user": {"login": "zou3519", "id": 5652049, "node_id": "MDQ6VXNlcjU2NTIwNDk=", "avatar_url": "https://avatars3.githubusercontent.com/u/5652049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zou3519", "html_url": "https://github.com/zou3519", "followers_url": "https://api.github.com/users/zou3519/followers", "following_url": "https://api.github.com/users/zou3519/following{/other_user}", "gists_url": "https://api.github.com/users/zou3519/gists{/gist_id}", "starred_url": "https://api.github.com/users/zou3519/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zou3519/subscriptions", "organizations_url": "https://api.github.com/users/zou3519/orgs", "repos_url": "https://api.github.com/users/zou3519/repos", "events_url": "https://api.github.com/users/zou3519/events{/privacy}", "received_events_url": "https://api.github.com/users/zou3519/received_events", "type": "User", "site_admin": false}, "body": "The previous approach scans the graph once from `rbegin` to `rend`: why does this need to scan through multiple times?", "created_at": "2018-11-13T16:00:10Z", "updated_at": "2018-11-23T15:54:43Z", "html_url": "https://github.com/pytorch/pytorch/pull/13862#discussion_r233104677", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/13862", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/233104677"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/13862#discussion_r233104677"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/13862"}}, "body_html": "<p>The previous approach scans the graph once from <code>rbegin</code> to <code>rend</code>: why does this need to scan through multiple times?</p>", "body_text": "The previous approach scans the graph once from rbegin to rend: why does this need to scan through multiple times?"}