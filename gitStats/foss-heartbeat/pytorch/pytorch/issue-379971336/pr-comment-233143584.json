{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/233143584", "pull_request_review_id": 174489640, "id": 233143584, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMzE0MzU4NA==", "diff_hunk": "@@ -1,257 +1,293 @@\n #include \"torch/csrc/jit/passes/create_autodiff_subgraphs.h\"\n \n-#include \"torch/csrc/jit/ir.h\"\n-#include \"torch/csrc/jit/autodiff.h\"\n #include \"torch/csrc/jit/assertions.h\"\n-#include \"torch/csrc/jit/dynamic_dag.h\"\n-\n-#include <cstddef>\n-#include <limits>\n-\n-namespace torch { namespace jit {\n+#include \"torch/csrc/jit/autodiff.h\"\n+#include \"torch/csrc/jit/ir.h\"\n+#include \"torch/csrc/jit/passes/common_subexpression_elimination.h\"\n \n-struct Graph;\n+namespace torch {\n+namespace jit {\n \n namespace {\n \n-// Move nodes that exist in graph g into a 'group_node_kind' node.\n-// All inputs shared by the nodes become inputs to the new node.\n-// Outputs from 'nodes' are redirected to outputs of the new node,\n-// and the original nodes are removed.\n-// prereq: it is topologically valid to place the new node\n-// right before nodes[0] (i.e. it will not create cycles and all uses of\n-// new node will be after this position).\n-// prereq: nodes are in topological order\n-Node* mergeNodes(Block * block, Symbol group_node_kind, ArrayRef<Node*> nodes) {\n-  JIT_ASSERT(nodes.size() > 0);\n-  std::unordered_map<Value*, Value*> value_map;\n-  Graph * graph = block->owningGraph();\n-\n-  auto new_graph = std::make_shared<Graph>();\n-  Node * group_node = graph->create(group_node_kind, 0);\n-  group_node->g_(attr::Subgraph, new_graph);\n-\n-  auto getOrCreateInput = [&](Value * v) {\n-    if(value_map.count(v) > 0) {\n-      return value_map[v];\n-    }\n-    if (auto value = toIValue(v)) {\n-      Value * nv = new_graph->insertConstant(*value);\n-      value_map[v] = nv;\n-      return nv;\n+class SubgraphSlicer {\n+ public:\n+  SubgraphSlicer(Block* block, size_t minSubgraphSize)\n+      : block_(block), minSubgraphSize_(minSubgraphSize) {}\n+\n+  void run(std::vector<Node*>& diffGraphs) {\n+    bool any_changed = true;\n+    while (any_changed) {\n+      any_changed = false;\n+      for (auto it = block_->nodes().rbegin(); it != block_->nodes().rend();) {\n+        bool changed;\n+        std::tie(it, changed) = scanNode(*it);\n+        any_changed |= changed;\n+      }\n     }\n-    Value * nv = new_graph->addInput()->setType(v->type());\n-    group_node->addInput(v);\n-    value_map[v] = nv;\n-    return nv;\n-  };\n-  std::unordered_set<Node*> group_set(nodes.begin(), nodes.end());\n-  for(auto n : nodes) {\n-    auto nn = new_graph->appendNode(new_graph->createClone(n, getOrCreateInput));\n-    for(size_t i = 0; i < nn->outputs().size(); ++i) {\n-      auto old_output = n->outputs()[i];\n-      auto new_output = nn->outputs()[i];\n-      value_map[old_output] = new_output;\n-      std::vector<Use> to_replace;\n-      for(auto u : old_output->uses()) {\n-        // Uses within the set do not need to be made outputs\n-        if(group_set.count(u.user) > 0)\n-          continue;\n-        // Other uses do, but we\n-        // cannot replace them here or we invalid the uses list iterator\n-        to_replace.push_back(u);\n+\n+    auto curNode = *block_->nodes().rbegin();\n+    while (curNode != *block_->nodes().rend()) {\n+      for (auto subBlock : curNode->blocks()) {\n+        SubgraphSlicer(subBlock, minSubgraphSize_).run(diffGraphs);\n       }\n-      if(to_replace.size() > 0) {\n-        new_graph->registerOutput(new_output);\n-        Value * external_output = group_node->addOutput()->setType(old_output->type());\n-        for(auto u : to_replace) {\n-          u.user->replaceInput(u.offset, external_output);\n+\n+      // Save the previous node, since we might delete `curNode` in next block\n+      auto prevNode = curNode->prev();\n+      if (curNode->kind() == prim::DifferentiableGraph) {\n+        // Inlining nodes may cause some subexpression to come back in the\n+        // subgraphs (for example, copying constants in repeatedly will generate\n+        // redundant prim::Constants). Run CSE to clean them up.\n+        EliminateCommonSubexpression(*curNode->g(attr::Subgraph));\n+\n+        if (!inlineIfTooSmall(curNode)) {\n+          diffGraphs.push_back(curNode);\n         }\n       }\n+      curNode = prevNode;\n     }\n   }\n-  group_node->insertBefore(nodes[0]);\n-  // delete backward, so that nodes are use-free before deletion\n-  for(size_t i = nodes.size(); i > 0; --i) {\n-    nodes[i - 1]->destroy();\n+\n+ private:\n+  static Graph& getSubgraph(Node* n) {\n+    JIT_ASSERT(n->kind() == prim::DifferentiableGraph);\n+    return *n->g(attr::Subgraph);\n   }\n-  JIT_ASSERT(isDifferentiable(*new_graph));\n-  return group_node;\n-}\n \n-bool shouldConsiderForMerge(detail::Vertex<Node*>* v) {\n-  if (v->data.size() >= 2) {\n+  // Inline this node's group subgraph into the outer graph if it's smaller\n+  // than the specified minimum size.\n+  //\n+  // Returns true if an inlining has occured, false otherwise.\n+  bool inlineIfTooSmall(Node* n) {\n+    JIT_ASSERT(n->kind() == prim::DifferentiableGraph);\n+    auto& subgraph = getSubgraph(n);\n+    size_t i = 0;\n+    for (const auto node __attribute__((unused)) : subgraph.nodes()) {\n+      if (++i >= minSubgraphSize_) {\n+        return false;\n+      }\n+    }\n+\n+    unmergeGroup(n);\n     return true;\n   }\n-  JIT_ASSERT(v->data.size() == 1);\n-  auto * node = *v->data.begin();\n-  if (node->kind() == prim::Constant) {\n-    return false;\n+\n+  // Move nodes from producerGroup's subgraph to the top-level graph.\n+  // This destroys `producerGroup`.\n+  std::vector<Node*> unmergeGroup(Node* producerGroup) {\n+    JIT_ASSERT(producerGroup->kind() == prim::DifferentiableGraph);\n+\n+    std::vector<Node*> temporary_nodes;\n+    auto& producerSubgraph = getSubgraph(producerGroup);\n+\n+    // Initialize a map of inner graph values to outer graph values\n+    std::unordered_map<const Value*, Value*> innerToOuter;\n+    const auto innerInputs = producerSubgraph.inputs();\n+    const auto outerInputs = producerGroup->inputs();\n+    for (size_t i = 0; i < innerInputs.size(); ++i) {\n+      innerToOuter[innerInputs[i]] = outerInputs[i];\n+    }\n+\n+    // Clone all nodes\n+    for (auto inner : producerSubgraph.nodes()) {\n+      Node* outer = block_->owningGraph()->createClone(\n+          inner, [&](Value* k) -> Value* { return innerToOuter.at(k); });\n+      outer->insertBefore(producerGroup);\n+      temporary_nodes.emplace_back(outer);\n+      const auto innerOutputs = inner->outputs();\n+      const auto outerOutputs = outer->outputs();\n+      for (size_t i = 0; i < innerOutputs.size(); ++i)\n+        innerToOuter[innerOutputs[i]] = outerOutputs[i];\n+    }\n+\n+    // Replace uses of producerGroup outputs and destroy the producer\n+    const auto subgraphOutputs = producerSubgraph.outputs();\n+    for (size_t i = 0; i < subgraphOutputs.size(); ++i) {\n+      const auto outerOutput = innerToOuter.at(subgraphOutputs[i]);\n+      producerGroup->outputs()[i]->replaceAllUsesWith(outerOutput);\n+    }\n+    producerGroup->destroy();\n+\n+    return temporary_nodes;\n   }\n-  return isDifferentiable(node);\n-}\n \n-static detail::DynamicDAG<Node*> make_dependency_graph(Block * block) {\n-  detail::DynamicDAG<Node*> dag;\n-  std::unordered_map<Node*,detail::Vertex<Node*>*> node_to_vertex;\n-  // NB: the block's param and return nodes are not in the dependency graph.\n-  for (Node * node : block->nodes()) {\n-    node_to_vertex[node] = dag.newVertex(node);\n+  // Combine the nodes in two groups together. The nodes will end up in\n+  // `consumerGroup`, and `producerGroup` will be deleted.\n+  void mergeGroups(Node* consumerGroup, Node* producerGroup) {\n+    // Extract the nodes in `producerGroup` into the outer graph\n+    const auto nodes = unmergeGroup(producerGroup);\n+    // Then merge them into `consumerGroup`\n+    for (auto it = nodes.rbegin(); it != nodes.rend(); ++it) {\n+      mergeNodeIntoGroup(consumerGroup, *it);\n+    }\n   }\n-  for (auto * node : block->nodes()) {\n-    for (auto * v : node->outputs()) {\n-      for (auto & use : v->uses()) {\n-        // [Determine data dependencies]\n-        // Consider the following code:\n-        //     y = f(x)\n-        //     if k:\n-        //        w += y\n-        //     z = g(y)\n-        // This produces a dependency graph with 3 vertices:\n-        // (0: f)   (1: if k ...)   (2: g)\n-        // We need to peek into the if Node* to determine its data dependencies\n-        // (the body depends on the output of f, so Vertex 1 depends on Vertex 0).\n-        // For each Use of y, we find an owning node of y that is a part of the\n-        // dependency graph (in this case, the Vertex containing the if Node*)\n-        // and then record the dependency.\n-        auto * owning_node = use.user;\n-        if (owning_node == block->return_node()) {\n-          // The return node is not in the dag. Carry on.\n-          continue;\n-        }\n-        while (true) {\n-          auto search = node_to_vertex.find(owning_node);\n-          if (search == node_to_vertex.end()) {\n-            owning_node = owning_node->owningBlock()->owningNode();\n-            JIT_ASSERT(owning_node != nullptr);\n-            continue;\n-          }\n-          // NB: DynamicDAG is a simple graph (no multi-edges).\n-          // addEdge is a no-op if the edge already exists.\n-          dag.addEdge(node_to_vertex[node], search->second);\n-          break;\n+\n+  // Merge node `n` into `group`'s subgraph\n+  Node* mergeNodeIntoGroup(Node* group, Node* n) {\n+    JIT_ASSERT(group->kind() == prim::DifferentiableGraph);\n+    JIT_ASSERT(n->kind() != prim::DifferentiableGraph);\n+\n+    auto& subgraph = getSubgraph(group);\n+\n+    // Map from values in the surrounding graph to inputs in the subgraph\n+    std::unordered_map<Value*, Value*> inputsMap;\n+\n+    JIT_ASSERT(group->inputs().size() == subgraph.inputs().size());\n+    size_t i = 0;\n+    for (auto input : group->inputs()) {\n+      inputsMap[input] = subgraph.inputs()[i];\n+      i++;\n+    }\n+\n+    // Add n's inputs to the group's input list if we don't already have them\n+    WithInsertPoint guard(*subgraph.nodes().begin());\n+    for (auto input : n->inputs()) {\n+      if (inputsMap.count(input) == 0) {\n+        // Clone constants inside the subgraph instead of referencing them, to\n+        // enable more optimizations\n+        if (auto value = toIValue(input)) {\n+          auto nv = subgraph.insertConstant(*value);\n+          inputsMap[input] = nv;\n+        } else {\n+          // The common case: this is a regular input, so just register it with\n+          // the group node and inner subgraph\n+          group->addInput(input);\n+          auto inputToGraph = subgraph.addInput();\n+          inputToGraph->setType(input->type());\n+          inputsMap[input] = inputToGraph;\n         }\n       }\n     }\n-  }\n-  return dag;\n-}\n \n-static void find_differentiable_groups(\n-    detail::DynamicDAG<Node*>& dep_graph,\n-    size_t distance_threshold=256,\n-    size_t producer_edge_threshold=16) {\n-  // A Vertex contains a Node* or a differentiable group of Node*.\n-  // Perform graph contraction on dep_graph: contract two vertices(x, y) if\n-  // the following conditions hold:\n-  // - x, y can be merged to form a differentiable group\n-  // - the contraction would not invalidate the dag (it creates no cycles).\n-  //\n-  // This performs a greedy algorithm. This greedy algorithm considers\n-  // dep_graph vertices in reverse topological order by reverse iterating through\n-  // ord indices. For a certain ord, we attempt to merge the vertex at that ord\n-  // with each of its parents. If the vertex at the ord cannot be merged with any\n-  // of its parents, then we move on to a smaller ord and repeat.\n-  //\n-  // Each contractEdge call is effectively constant because we limit the size\n-  // of the affected region (via the distance_threshold) and the fan in/fan out\n-  // via producer_edge_threshold.\n-  // In addition, each sort of in_edges is bounded by producer_edge threshold.\n-  // This makes the complexity of find_differential_groups effectively O(V + E).\n-\n-  // Iterate in reverse topological order\n-  int64_t ord = dep_graph.max_size() - 1;\n-  for (int64_t ord = dep_graph.max_size() - 1; ord >= 0; --ord) {\n-    if (!dep_graph.at(ord)) continue;\n-\n-    auto* consumer = dep_graph.at(ord).value();\n-    if (!shouldConsiderForMerge(consumer)) continue;\n-\n-    // To bound the complexity of the sort. Makes the algorithm less optimal.\n-    if (consumer->in_edges().size() > producer_edge_threshold) continue;\n-\n-    // Iterate through consumer->in_edges() in reverse topological order.\n-    // sort is performed once per ord in dep_graph and once per contraction.\n-    // There can be at most dep_graph.max_size() contractions, so\n-    // we do at most 2 * dep_graph.max_size() sorts.\n-    consumer->in_edges().sort();\n-\n-    for (auto it = consumer->in_edges().rbegin(); it != consumer->in_edges().rend(); ++it) {\n-      auto * producer = *it;\n-      // The distance threshold makes this algorithm \"not optimal\": it will miss\n-      // some possible contraction opportunities, but it hopefully lets us:\n-      // 1) preserve locality of tensors. We don't want to keep them alive for too long.\n-      // 2) Help bound the computation complexity for contractEdge\n-      if (consumer->ord - producer->ord > distance_threshold) continue;\n-      if (!shouldConsiderForMerge(producer)) continue;\n-\n-      // If the edge contraction is successful, dep_graph.at(ord) may have changed\n-      // as well as consumer->in_edges() so we break out of this loop\n-      if (dep_graph.contractEdge(producer, consumer)) {\n-        // Stay at the current ord until we are done considering the vertex\n-        // at this ord for contraction\n-        ++ord;\n-        break;\n+    // Merge the node into the graph\n+    auto mergedNode = subgraph.insertNode(\n+        subgraph.createClone(n, [&](Value* v) { return inputsMap[v]; }));\n+\n+    // If n's outputs were inputs to `group`, remove them since we just merged\n+    // n in.\n+    //\n+    // i.e.,\n+    // x = f(w); group(x, y, z) becomes group(w, y, z).\n+    // x, y, z = f(w); group(x, y, z) becomes group(w).\n+    auto inputs = group->inputs();\n+    for (size_t i = 0; i < n->outputs().size(); ++i) {\n+      auto it = std::find(inputs.begin(), inputs.end(), n->outputs()[i]);\n+      if (it != inputs.end()) {\n+        size_t p = it - inputs.begin();\n+        group->removeInput(p);\n+        subgraph.inputs()[p]->replaceAllUsesWith(mergedNode->outputs()[i]);\n+        subgraph.eraseInput(p);\n       }\n     }\n-  }\n-}\n \n-static void reorder_according_to_dag(Block * block, const detail::DynamicDAG<Node*>& dep_graph) {\n-  for (size_t ord = 0; ord < dep_graph.max_size(); ++ord) {\n-    const auto& vertex = dep_graph.at(ord);\n-    if (!vertex.has_value()) continue;\n+    // Add n's outputs to the group node and inner subgraph outputs.\n+    for (size_t i = 0; i < n->outputs().size(); i++) {\n+      auto oldOutput = n->outputs()[i];\n+\n+      // Only register the output in the group node if it's actually used\n+      // outside the subgraph.\n+      const auto hasUsesOutsideGroup = std::any_of(\n+          oldOutput->uses().cbegin(),\n+          oldOutput->uses().cend(),\n+          [&](const Use& use) { return use.user->isAfter(group); });\n \n-    auto& nodes = vertex.value()->data;\n-    for (Node* node : nodes) {\n-      // Move all nodes according to the topological order in dep_graph. A lot\n-      // of the moves are unnecessary but this is a quick & easy solution.\n-      node->moveBefore(block->return_node());\n+      if (hasUsesOutsideGroup) {\n+        auto newOutput = mergedNode->outputs()[i];\n+        subgraph.registerOutput(newOutput);\n+        auto groupOutput = group->addOutput();\n+        groupOutput->copyMetadata(oldOutput);\n+        oldOutput->replaceAllUsesWith(groupOutput);\n+      }\n     }\n+\n+    // Remove the original node now that the merge is complete\n+    n->destroy();\n+\n+    return mergedNode;\n   }\n-}\n \n-static void merge_differentiable_groups(\n-    Block * block,\n-    const detail::DynamicDAG<Node*>& dep_graph,\n-    size_t size_threshold,\n-    std::vector<Node*>& diff_graphs) {\n-  for (size_t ord = 0; ord < dep_graph.max_size(); ++ord) {\n-    const auto& vertex = dep_graph.at(ord);\n-    if (!vertex) continue;\n-    if (!shouldConsiderForMerge(vertex.value())) continue;\n+  // Create a group node that contains only `n`\n+  // `n` is destroyed.\n+  Node* createSingletonGroup(Node* n) {\n+    auto group = block_->owningGraph()->createDifferentiableSubgraph();\n+    group->insertBefore(n);\n+    mergeNodeIntoGroup(group, n);\n+    return group;\n+  }\n \n-    auto& nodes = vertex.value()->data;\n-    if (nodes.size() < size_threshold) continue;\n+  value_list sortReverseTopological(ArrayRef<Value*> inputs) {\n+    value_list result;\n+    for (auto i : inputs) {\n+      if (i->node()->owningBlock() == block_) {\n+        result.push_back(i);\n+      }\n+    }\n+    // Sort in reverse topological order\n+    std::sort(result.begin(), result.end(), [&](Value* a, Value* b) {\n+      return a->node()->isAfter(b->node());\n+    });\n+    return result;\n+  }\n \n-    diff_graphs.push_back(mergeNodes(block, prim::DifferentiableGraph, nodes));\n+  bool shouldConsiderForMerge(Node* node) {\n+    // if we're already in the process of merging\n+    if (node->kind() == prim::DifferentiableGraph) {\n+      return true;\n+    }\n+    if (node->kind() == prim::Constant) {\n+      return false;\n+    }\n+    return isDifferentiable(node);\n   }\n-}\n \n-void CreateAutodiffSubgraphsPK(\n-    Block * block,\n-    size_t size_threshold,\n-    std::vector<Node*>& diff_graphs) {\n-  for (auto * node : block->nodes()) {\n-    // Find subgraphs to run this on recursively.\n-    if (isDifferentiable(node)) continue;\n-    for (auto * sub_block : node->blocks()) {\n-      CreateAutodiffSubgraphsPK(sub_block, size_threshold, diff_graphs);\n+  std::pair<graph_node_list::iterator, bool> scanNode(Node* consumer) {\n+    if (shouldConsiderForMerge(consumer)) {\n+      if (consumer->kind() != prim::DifferentiableGraph) {\n+        consumer = createSingletonGroup(consumer);\n+      }\n+      auto inputs = sortReverseTopological(consumer->inputs());\n+      for (auto input : inputs) {\n+        if (auto group = tryMerge(consumer, input->node())) {\n+          // we successfully merged, so the new group's `inputs` may have\n+          // changed. So rescan the new group for more merging opportunities.\n+          return std::make_pair(group.value()->reverseIterator(), true);\n+        }\n+      }\n     }\n+\n+    return std::make_pair(++consumer->reverseIterator(), false);\n   }\n \n-  auto dep_graph = make_dependency_graph(block);\n-  find_differentiable_groups(dep_graph);\n-  reorder_according_to_dag(block, dep_graph);\n-  merge_differentiable_groups(block, dep_graph, size_threshold, diff_graphs);\n-}\n+  // Try to merge `producer` into `consumer`. If successful, this destroys\n+  // `producer` and returns the `consumer` group.\n+  c10::optional<Node*> tryMerge(Node* consumer, Node* producer) {\n+    JIT_ASSERT(consumer->kind() == prim::DifferentiableGraph);\n+    bool canMerge = shouldConsiderForMerge(producer) &&\n+        producer->moveBeforeTopologicallyValid(consumer);", "path": "torch/csrc/jit/passes/create_autodiff_subgraphs.cpp", "position": 351, "original_position": 475, "commit_id": "30284b6e20001a239bf4139e9488d04af3e26e9d", "original_commit_id": "a61c86c7641b139c73e0401fa99e9bdf5cb3dbd2", "user": {"login": "suo", "id": 1617424, "node_id": "MDQ6VXNlcjE2MTc0MjQ=", "avatar_url": "https://avatars2.githubusercontent.com/u/1617424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/suo", "html_url": "https://github.com/suo", "followers_url": "https://api.github.com/users/suo/followers", "following_url": "https://api.github.com/users/suo/following{/other_user}", "gists_url": "https://api.github.com/users/suo/gists{/gist_id}", "starred_url": "https://api.github.com/users/suo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/suo/subscriptions", "organizations_url": "https://api.github.com/users/suo/orgs", "repos_url": "https://api.github.com/users/suo/repos", "events_url": "https://api.github.com/users/suo/events{/privacy}", "received_events_url": "https://api.github.com/users/suo/received_events", "type": "User", "site_admin": false}, "body": "It can reorder any nodes between the source and destination. And nope, if a move is not possible the graph isn't changed.", "created_at": "2018-11-13T17:22:54Z", "updated_at": "2018-11-23T15:54:44Z", "html_url": "https://github.com/pytorch/pytorch/pull/13862#discussion_r233143584", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/13862", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/233143584"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/13862#discussion_r233143584"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/13862"}}, "body_html": "<p>It can reorder any nodes between the source and destination. And nope, if a move is not possible the graph isn't changed.</p>", "body_text": "It can reorder any nodes between the source and destination. And nope, if a move is not possible the graph isn't changed.", "in_reply_to_id": 233123425}