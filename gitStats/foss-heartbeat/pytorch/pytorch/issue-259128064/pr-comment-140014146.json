{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/140014146", "pull_request_review_id": 64027310, "id": 140014146, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE0MDAxNDE0Ng==", "diff_hunk": "@@ -33,4 +35,54 @@ static inline float TH_lerpf(float a, float b, float weight) {\n   return a + weight * (b-a);\n }\n \n+\n+/*\n+From https://github.com/antelopeusersgroup/antelope_contrib/blob/master/lib/location/libgenloc/erfinv.c.\n+Modified output to be inf or -inf when input is 1 or -1.\n+*/\n+\n+#define CENTRAL_RANGE 0.7\n+\n+static inline double TH_erfinv(double y) {\n+/*Function to calculate inverse error function.  Rational approximation\n+is used to generate an initial approximation, which is then improved to\n+full accuracy by two steps of Newton's method.  Code is a direct\n+translation of the erfinv m file in matlab version 2.0.\n+Author:  Gary L. Pavlis, Indiana University\n+Date:  February 1996\n+*/\n+    double x,z,num,dem; /*working variables */\n+    /* coefficients in rational expansion */\n+    double a[4]={ 0.886226899, -1.645349621,  0.914624893, -0.140543331};\n+    double b[4]={-2.118377725,  1.442710462, -0.329097515,  0.012229801};\n+    double c[4]={-1.970840454, -1.624906493,  3.429567803,  1.641345311};\n+    double d[2]={ 3.543889200,  1.637067800};\n+    if(fabs(y) > 1.0) return (atof(\"NaN\"));  /* This needs IEEE constant*/\n+    if(fabs(y) == 1.0) return((copysign(1.0,y))*atof(\"INFINITY\"));\n+    if( fabs(y) <= CENTRAL_RANGE )\n+    {\n+            z = y*y;\n+            num = (((a[3]*z + a[2])*z + a[1])*z + a[0]);\n+            dem = ((((b[3]*z + b[2])*z + b[1])*z +b[0])*z + 1.0);\n+            x = y*num/dem;\n+    }\n+    else if( (fabs(y) > CENTRAL_RANGE) && (fabs(y) < 1.0) )\n+    {\n+            z = sqrt(-log((1.0-fabs(y))/2.0));\n+            num = ((c[3]*z + c[2])*z + c[1])*z + c[0];\n+            dem = (d[1]*z + d[0])*z + 1.0;\n+            x = (copysign(1.0,y))*num/dem;\n+    }\n+    /* Two steps of Newton-Raphson correction */\n+    x = x - (erf(x) - y)/( (2.0/sqrt(M_PI))*exp(-x*x));\n+    x = x - (erf(x) - y)/( (2.0/sqrt(M_PI))*exp(-x*x));\n+\n+    return(x);\n+}\n+#undef CENTRAL_RANGE\n+\n+static inline float TH_erfinvf(float y) {\n+  return (float) TH_erfinv((double)y);\n+}", "path": "torch/lib/TH/THMath.h", "position": null, "original_position": 60, "commit_id": "e46ea42e203f655afe65b367451622d2c9f94d37", "original_commit_id": "7f88fb988b64f8ad4e0778d164cdebee9e7dda3d", "user": {"login": "fmassa", "id": 9110200, "node_id": "MDQ6VXNlcjkxMTAyMDA=", "avatar_url": "https://avatars2.githubusercontent.com/u/9110200?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fmassa", "html_url": "https://github.com/fmassa", "followers_url": "https://api.github.com/users/fmassa/followers", "following_url": "https://api.github.com/users/fmassa/following{/other_user}", "gists_url": "https://api.github.com/users/fmassa/gists{/gist_id}", "starred_url": "https://api.github.com/users/fmassa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fmassa/subscriptions", "organizations_url": "https://api.github.com/users/fmassa/orgs", "repos_url": "https://api.github.com/users/fmassa/repos", "events_url": "https://api.github.com/users/fmassa/events{/privacy}", "received_events_url": "https://api.github.com/users/fmassa/received_events", "type": "User", "site_admin": false}, "body": "That's true. A better solution would be to write this function using the float equivalents `erff`/`sqrtf` etc, so that   the code can run slightly faster for floats, but that's not necessary I think.\r\n@IraKorshunova if you remove this function, then you need to modify `THTensorMath.c` to use `TH_erfinv` instead of `TH_MATH_NAME(TH_erfinv)`", "created_at": "2017-09-20T15:57:53Z", "updated_at": "2018-11-23T15:34:41Z", "html_url": "https://github.com/pytorch/pytorch/pull/2799#discussion_r140014146", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/2799", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/140014146"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/2799#discussion_r140014146"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/2799"}}, "body_html": "<p>That's true. A better solution would be to write this function using the float equivalents <code>erff</code>/<code>sqrtf</code> etc, so that   the code can run slightly faster for floats, but that's not necessary I think.<br>\n<a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=3956298\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/IraKorshunova\">@IraKorshunova</a> if you remove this function, then you need to modify <code>THTensorMath.c</code> to use <code>TH_erfinv</code> instead of <code>TH_MATH_NAME(TH_erfinv)</code></p>", "body_text": "That's true. A better solution would be to write this function using the float equivalents erff/sqrtf etc, so that   the code can run slightly faster for floats, but that's not necessary I think.\n@IraKorshunova if you remove this function, then you need to modify THTensorMath.c to use TH_erfinv instead of TH_MATH_NAME(TH_erfinv)", "in_reply_to_id": 140005233}