{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/302138913", "html_url": "https://github.com/pytorch/pytorch/pull/1563#issuecomment-302138913", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/1563", "id": 302138913, "node_id": "MDEyOklzc3VlQ29tbWVudDMwMjEzODkxMw==", "user": {"login": "gchanan", "id": 3768583, "node_id": "MDQ6VXNlcjM3Njg1ODM=", "avatar_url": "https://avatars2.githubusercontent.com/u/3768583?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gchanan", "html_url": "https://github.com/gchanan", "followers_url": "https://api.github.com/users/gchanan/followers", "following_url": "https://api.github.com/users/gchanan/following{/other_user}", "gists_url": "https://api.github.com/users/gchanan/gists{/gist_id}", "starred_url": "https://api.github.com/users/gchanan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gchanan/subscriptions", "organizations_url": "https://api.github.com/users/gchanan/orgs", "repos_url": "https://api.github.com/users/gchanan/repos", "events_url": "https://api.github.com/users/gchanan/events{/privacy}", "received_events_url": "https://api.github.com/users/gchanan/received_events", "type": "User", "site_admin": false}, "created_at": "2017-05-17T16:06:16Z", "updated_at": "2017-05-17T16:06:16Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=6359743\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/albanD\">@albanD</a> good question and I understand the motivation for tightly controlling your own code.  What I'm not sure about is how to make the distinction between your code and library code (or if that distinction is even well defined).</p>\n<p>To support what you want as written, we'd have to ensure that our libraries work both with and without broadcasting, which will greatly increase the maintenance burden.  It's also not clear to me the distinction between user and library code is really clear anyway: let's say some NN layer is written in such a way that it e.g. multiples the input tensor by a (4,1) tensor and you pass in a (4) tensor.  Was it library or user code that caused broadcasting?</p>\n<p>What I have now is a UserWarning if your code does not broadcast, but uses the old (deprecated) 1-d pointwise operations (you previously only needed nElem to match up for many functions).  I could also add an optional warning for the backwards-incompatible case, that is, the sizes don't match, so you would have used the 1-d pointwise operations, but you are now broadcasting.</p>\n<p>It sounds like what you want is a warning if broadcasting changes the sizes at all (I'd be hestitant to make it an error, not a warning, given the argument about library code above).  That shouldn't be too difficult to implement, although I'm not sure how useful it will be if our library code broadcasts a lot (you might get a lot of warnings).  What do you think?</p>", "body_text": "@albanD good question and I understand the motivation for tightly controlling your own code.  What I'm not sure about is how to make the distinction between your code and library code (or if that distinction is even well defined).\nTo support what you want as written, we'd have to ensure that our libraries work both with and without broadcasting, which will greatly increase the maintenance burden.  It's also not clear to me the distinction between user and library code is really clear anyway: let's say some NN layer is written in such a way that it e.g. multiples the input tensor by a (4,1) tensor and you pass in a (4) tensor.  Was it library or user code that caused broadcasting?\nWhat I have now is a UserWarning if your code does not broadcast, but uses the old (deprecated) 1-d pointwise operations (you previously only needed nElem to match up for many functions).  I could also add an optional warning for the backwards-incompatible case, that is, the sizes don't match, so you would have used the 1-d pointwise operations, but you are now broadcasting.\nIt sounds like what you want is a warning if broadcasting changes the sizes at all (I'd be hestitant to make it an error, not a warning, given the argument about library code above).  That shouldn't be too difficult to implement, although I'm not sure how useful it will be if our library code broadcasts a lot (you might get a lot of warnings).  What do you think?", "body": "@albanD good question and I understand the motivation for tightly controlling your own code.  What I'm not sure about is how to make the distinction between your code and library code (or if that distinction is even well defined).\r\n\r\nTo support what you want as written, we'd have to ensure that our libraries work both with and without broadcasting, which will greatly increase the maintenance burden.  It's also not clear to me the distinction between user and library code is really clear anyway: let's say some NN layer is written in such a way that it e.g. multiples the input tensor by a (4,1) tensor and you pass in a (4) tensor.  Was it library or user code that caused broadcasting?\r\n\r\nWhat I have now is a UserWarning if your code does not broadcast, but uses the old (deprecated) 1-d pointwise operations (you previously only needed nElem to match up for many functions).  I could also add an optional warning for the backwards-incompatible case, that is, the sizes don't match, so you would have used the 1-d pointwise operations, but you are now broadcasting.\r\n\r\nIt sounds like what you want is a warning if broadcasting changes the sizes at all (I'd be hestitant to make it an error, not a warning, given the argument about library code above).  That shouldn't be too difficult to implement, although I'm not sure how useful it will be if our library code broadcasts a lot (you might get a lot of warnings).  What do you think?"}