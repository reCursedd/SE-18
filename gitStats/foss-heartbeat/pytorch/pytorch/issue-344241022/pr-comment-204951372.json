{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/204951372", "pull_request_review_id": 140125178, "id": 204951372, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwNDk1MTM3Mg==", "diff_hunk": "@@ -756,6 +757,174 @@ std::tuple<std::string, RawDataExportMap> ExportGraph(\n   return std::make_tuple(model_proto.SerializeAsString(), graph_encoder.get_raw_data_export_map());\n }\n \n+class PyTorchFileWriter {\n+public:\n+  PyTorchFileWriter(const std::string& filename){\n+    fp = std::fopen(filename.c_str(), \"wb\");\n+    writeFileHeader();\n+  }\n+\n+  // Serialize a tensor to file, then return its offset\n+  size_t serializeTensor(const std::string& name, at::Tensor t) {\n+    JIT_ASSERT(!finalized);\n+    JIT_ASSERT(cursor % kFieldAlignment == 0);\n+    // Keep track of the offset into the file for this tensor\n+    JIT_ASSERT(key_to_file_offset.count(name) == 0);\n+    key_to_file_offset[name] = cursor;\n+\n+    // Write out local \"file\" header: size of \"file\" in bytes + padding\n+    size_t copy_bytes = t.type().elementSizeInBytes() * t.numel();\n+    write64BitIntegerLittleEndian(copy_bytes);\n+    padToNextAlignmentBoundary();\n+\n+    // Write out the actual data\n+    std::fwrite(t.data_ptr(), copy_bytes, 1u, fp);\n+    cursor += copy_bytes;\n+    padToNextAlignmentBoundary();\n+\n+    return key_to_file_offset[name];\n+  }\n+\n+  size_t tensorNameToOffset(const std::string& name) const {\n+    return key_to_file_offset.at(name);\n+  }\n+\n+  size_t getModelProtoOffset() const {\n+    return key_to_file_offset.at(\"__MODEL_PROTO\");\n+  }\n+\n+  // Serialize the model proto to file, replacing the tensor names with\n+  // string verisions of their file offsets. This also finalizes the file,\n+  // and calling serializeTensor after calling this method is illegal.\n+  // NOTE: this method mutates the model proto\n+  size_t serializeModelProto(::ONNX_NAMESPACE::ModelProto *model_proto) {\n+    JIT_ASSERT(!finalized);\n+    JIT_ASSERT(cursor % kFieldAlignment == 0);\n+    // Keep track of offset into the file for the model proto\n+    JIT_ASSERT(key_to_file_offset.count(\"__MODEL_PROTO\") == 0);\n+    key_to_file_offset[\"__MODEL_PROTO\"] = cursor;\n+\n+    // Swap initializer names to string versions of their file offsets\n+    auto *graph = model_proto->mutable_graph();\n+    for (int i=0; i < graph->initializer_size(); ++i) {\n+      auto *init_proto = graph->mutable_initializer(i);\n+      if (key_to_file_offset.count(init_proto->doc_string())) {\n+        init_proto->set_doc_string(std::to_string(key_to_file_offset[init_proto->doc_string()]));\n+      }\n+    }\n+\n+    // Now swap names for tensor valued attributes to string versions of their\n+    // file offsets\n+    swapTensorAttributeNames(graph);\n+\n+    auto serialized_proto = model_proto->SerializeAsString();\n+\n+    // Write serialized proto size\n+    size_t serialized_proto_size = serialized_proto.size();\n+    write64BitIntegerLittleEndian(serialized_proto_size);\n+    padToNextAlignmentBoundary();\n+\n+    // Write serialized proto\n+    std::fwrite(serialized_proto.c_str(), serialized_proto_size, 1, fp);\n+    cursor += serialized_proto_size;\n+    padToNextAlignmentBoundary();\n+\n+    finalized = true;\n+    return key_to_file_offset.at(\"__MODEL_PROTO\");\n+  }\n+\n+  ~PyTorchFileWriter() {\n+    std::fclose(fp);\n+  }\n+private:\n+  FILE *fp;\n+  size_t cursor = 0;\n+  std::unordered_map<std::string, size_t> key_to_file_offset;\n+  bool finalized = false;\n+\n+  static constexpr uint64_t kFileFormatVersion = 0x1L;\n+  static constexpr uint64_t kFileMagicNumber = 0x314843524f545950L; // PYTORCH1\n+  static constexpr uint64_t kFieldAlignment = 64L; // 64 byte alignment supports up to AVX512 for mmap\n+  static constexpr uint8_t kPadValue = 0xEF;\n+\n+  void write64BitIntegerLittleEndian(const uint64_t value) {\n+    // TODO endian swap on platforms that need it?\n+    std::fwrite(&value, 8u, 1u, fp);\n+    cursor += 8u;\n+  }\n+\n+  void writePad(const size_t num_bytes) {\n+    uint8_t pad_val = kPadValue;\n+    // TODO is there a more efficient way to do this?\n+    for (size_t i = 0; i < num_bytes; ++i) {\n+      std::fwrite(&pad_val, 1u, 1u, fp);\n+    }\n+    cursor += num_bytes;\n+  }\n+\n+  void padToNextAlignmentBoundary() {\n+    size_t next_offset = (cursor + kFieldAlignment) - (cursor % kFieldAlignment);\n+    size_t pad_amount = next_offset - cursor;\n+    writePad(pad_amount);\n+  }\n+\n+  void writeFileHeader() {\n+    write64BitIntegerLittleEndian(kFileMagicNumber);\n+    write64BitIntegerLittleEndian(kFileFormatVersion);\n+    padToNextAlignmentBoundary();\n+  }\n+\n+  void swapTensorAttributeNames(::ONNX_NAMESPACE::GraphProto *g) {", "path": "torch/csrc/jit/export.cpp", "position": 1146, "original_position": 138, "commit_id": "a8547739734eff329ac82fcbd0e4590894267a82", "original_commit_id": "17e4045588f0b19107e92bfbc7c82ae48b205cea", "user": {"login": "zdevito", "id": 370202, "node_id": "MDQ6VXNlcjM3MDIwMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/370202?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zdevito", "html_url": "https://github.com/zdevito", "followers_url": "https://api.github.com/users/zdevito/followers", "following_url": "https://api.github.com/users/zdevito/following{/other_user}", "gists_url": "https://api.github.com/users/zdevito/gists{/gist_id}", "starred_url": "https://api.github.com/users/zdevito/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zdevito/subscriptions", "organizations_url": "https://api.github.com/users/zdevito/orgs", "repos_url": "https://api.github.com/users/zdevito/repos", "events_url": "https://api.github.com/users/zdevito/events{/privacy}", "received_events_url": "https://api.github.com/users/zdevito/received_events", "type": "User", "site_admin": false}, "body": "This is very fragile and has huge action-at-a-distance problems. Please make an abstract interface that is used to write the tensors instead.", "created_at": "2018-07-25T00:28:05Z", "updated_at": "2018-11-23T15:48:03Z", "html_url": "https://github.com/pytorch/pytorch/pull/9794#discussion_r204951372", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/9794", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/204951372"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/9794#discussion_r204951372"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/9794"}}, "body_html": "<p>This is very fragile and has huge action-at-a-distance problems. Please make an abstract interface that is used to write the tensors instead.</p>", "body_text": "This is very fragile and has huge action-at-a-distance problems. Please make an abstract interface that is used to write the tensors instead."}