{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/202237241", "pull_request_review_id": 136898347, "id": 202237241, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjIzNzI0MQ==", "diff_hunk": "@@ -3,14 +3,126 @@\n #include <memory>\n #include <stddef.h>\n \n-#include \"ATen/Retainable.h\"\n+#include <ATen/Error.h>\n+#include <ATen/Retainable.h>\n+#include <ATen/Device.h>\n \n namespace at {\n \n+// Note [Supervisor deleter]\n+// ~~~~~~~~~~~~~~~~~~~~~~~~~\n+// SupervisorPtr solves a common problem for allocators of tensor data, which\n+// is that the data pointer (e.g., float*) which you are interested in, is not\n+// the same as the metadata pointer (e.g., DLManagedTensor) which you need\n+// to actually deallocate the data.  Under a conventional deleter design, you\n+// have to store extra context in the deleter (the metadata pointer) so that\n+// you can actually delete the right thing.  Implementing this with standard\n+// C++ is somewhat error-prone: if you use a std::unique_ptr to manage tensors,\n+// the deleter will not be called if the data pointer is nullptr, which can\n+// cause a leak if the metadata pointer is non-null (and the deleter is\n+// responsible for freeing both the data pointer and the metadata pointer).\n+//\n+// We take a different approach.  The \"metadata supervisor\" situation is common\n+// enough that we have organized our deleter strategy entirely around it:\n+// instead of trying to make the deleter for the data pointer handle all the\n+// heavy lifting, the data pointer is *non-owning*, and instead there is a\n+// (type-erased) supervisor pointer which actually handles deletion.  For simple\n+// cases, the supervisor pointer is the same as the data pointer, but if\n+// there is some extra metadata, the supervisor pointer points there.\n+//\n+// There is something of a pattern to writing these; check THAllocator.{h,cpp}\n+// for some examples.\n+\n+using DeleterFnPtr = void(*)(void*);\n+using SupervisorPtr = std::unique_ptr<void, DeleterFnPtr>;\n+\n+// Does not delete anything\n+AT_API void deleteNothing(void*);\n+// Mints a SupervisorPtr that doesn't do anything.  You must\n+// use this, not a nullptr, when you want a view.\n+AT_API SupervisorPtr nonOwningSupervisorPtr();\n+\n+struct SupervisedPtr {\n+  // Lifetime tied to supervisor_\n+  void* data_;\n+  SupervisorPtr supervisor_;\n+  Device device_;\n+  SupervisedPtr() : data_(nullptr), supervisor_(nonOwningSupervisorPtr()), device_(kCPU) {}\n+  SupervisedPtr(void* data, SupervisorPtr&& supervisor, Device device)\n+    : data_(data), supervisor_(std::move(supervisor)), device_(device) {}\n+  void* operator->() const { return data_; }\n+  void* get() const { return data_; }\n+  operator bool() { return data_ || supervisor_; }\n+};\n+\n+// NB: Device is NOT tested for here; a CUDA nullptr is as much a nullptr as a\n+// CPU nullptr\n+\n+inline bool operator==(const at::SupervisedPtr& sp, std::nullptr_t) noexcept {\n+  return sp.data_ == nullptr && sp.supervisor_ == nullptr;\n+}\n+inline bool operator==(std::nullptr_t, const at::SupervisedPtr& sp) noexcept {\n+  return sp.data_ == nullptr && sp.supervisor_ == nullptr;\n+}\n+inline bool operator!=(const at::SupervisedPtr& sp, std::nullptr_t) noexcept {\n+  return sp.data_ != nullptr || sp.supervisor_ != nullptr;\n+}\n+inline bool operator!=(std::nullptr_t, const at::SupervisedPtr& sp) noexcept {\n+  return sp.data_ != nullptr || sp.supervisor_ != nullptr;\n+}\n+\n+// Note [raw_allocate/raw_deallocate and Thrust]\n+// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+// Thrust's support for custom allocators requires us to write something\n+// like this:\n+//\n+//  class ThrustAllocator {\n+//    char* allocate(size_t);\n+//    void deallocate(char*, size_t);\n+//  };\n+//\n+// This is not good for our unique_ptr based allocator interface, as\n+// there is no way to get the deleter from our allocator to the\n+// deletion site in Thrust.  Indeed, if every pointer is getting a\n+// *fresh* deleter, we truly would have no choice except to maintain\n+// a map from pointers to deleters.  This is bad.\n+//\n+// So, we observe that not *all* deleters actually have lots of\n+// different deleters; some of them actually always return the same\n+// deleter every time.  In this case, we can support the \"raw\"\n+// allocate and deallocate interface.  This is what\n+// maybeGlobalBoundDeleter signifies.  By default, it returns the\n+// default (empty) BoundDeleter, which means that the raw interface\n+// is not implemented.  Be sure to implement it whenever possible.\n+\n struct Allocator {\n   virtual ~Allocator() {}\n-  virtual void* allocate(size_t n) const = 0;\n-  virtual void deallocate(void* ptr) const = 0;\n+  virtual at::SupervisedPtr allocate(size_t n) const = 0;\n+\n+  // If this returns a non nullptr, it means that allocate()", "path": "aten/src/ATen/Allocator.h", "position": null, "original_position": 103, "commit_id": "ebbe7907bc313f1d259d85e91bcb72ebafbfd252", "original_commit_id": "1734ec171b326ee5d13adbddc1f7245c353d5e2a", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "body": "Normally, the deleter is supposed to come in the `SupervisedPtr` package (attached to the supervisor), but for the raw interface you don't have a SupervisedPtr, so you need to get it from somewhere. So `has_raw_interface` (which ostensibly returns a bool) doesn't give you enough information.\r\n\r\nBut perhaps your suggestion is that, the function pointer deleter attached to the supervisor is always the same, no matter what the supervisor itself is. This is certainly true in all of the code here, and I can't really think of a crazy situation where an allocator may return one or another function pointer. But I would claim that if an `Allocator` gives you a way to get at the deleter, it would only be used in the raw-API case.\r\n\r\nI suppose you COULD do this:\r\n\r\n```\r\nstruct Allocator {\r\n  virtual ~Allocator() {}\r\n  virtual std::pair<void*, void*> vallocate(size_t n);\r\n  virtual DeleterFnPtr get_deleter();\r\n  at::SupervisedPtr allocate(size_t n) {\r\n    std::tie(data, supervisor) = vallocate(n);\r\n    return {data, {supervisor, get_deleter()}};\r\n  }\r\n}\r\n```\r\n\r\nBut this seems a bit more oblique for no good reason.", "created_at": "2018-07-13T03:49:27Z", "updated_at": "2018-11-23T15:47:17Z", "html_url": "https://github.com/pytorch/pytorch/pull/9358#discussion_r202237241", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/9358", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/202237241"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/9358#discussion_r202237241"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/9358"}}, "body_html": "<p>Normally, the deleter is supposed to come in the <code>SupervisedPtr</code> package (attached to the supervisor), but for the raw interface you don't have a SupervisedPtr, so you need to get it from somewhere. So <code>has_raw_interface</code> (which ostensibly returns a bool) doesn't give you enough information.</p>\n<p>But perhaps your suggestion is that, the function pointer deleter attached to the supervisor is always the same, no matter what the supervisor itself is. This is certainly true in all of the code here, and I can't really think of a crazy situation where an allocator may return one or another function pointer. But I would claim that if an <code>Allocator</code> gives you a way to get at the deleter, it would only be used in the raw-API case.</p>\n<p>I suppose you COULD do this:</p>\n<pre><code>struct Allocator {\n  virtual ~Allocator() {}\n  virtual std::pair&lt;void*, void*&gt; vallocate(size_t n);\n  virtual DeleterFnPtr get_deleter();\n  at::SupervisedPtr allocate(size_t n) {\n    std::tie(data, supervisor) = vallocate(n);\n    return {data, {supervisor, get_deleter()}};\n  }\n}\n</code></pre>\n<p>But this seems a bit more oblique for no good reason.</p>", "body_text": "Normally, the deleter is supposed to come in the SupervisedPtr package (attached to the supervisor), but for the raw interface you don't have a SupervisedPtr, so you need to get it from somewhere. So has_raw_interface (which ostensibly returns a bool) doesn't give you enough information.\nBut perhaps your suggestion is that, the function pointer deleter attached to the supervisor is always the same, no matter what the supervisor itself is. This is certainly true in all of the code here, and I can't really think of a crazy situation where an allocator may return one or another function pointer. But I would claim that if an Allocator gives you a way to get at the deleter, it would only be used in the raw-API case.\nI suppose you COULD do this:\nstruct Allocator {\n  virtual ~Allocator() {}\n  virtual std::pair<void*, void*> vallocate(size_t n);\n  virtual DeleterFnPtr get_deleter();\n  at::SupervisedPtr allocate(size_t n) {\n    std::tie(data, supervisor) = vallocate(n);\n    return {data, {supervisor, get_deleter()}};\n  }\n}\n\nBut this seems a bit more oblique for no good reason.", "in_reply_to_id": 202196381}