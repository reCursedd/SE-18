{"url": "https://api.github.com/repos/pytorch/pytorch/issues/9358", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/9358/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/9358/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/9358/events", "html_url": "https://github.com/pytorch/pytorch/pull/9358", "id": 340402419, "node_id": "MDExOlB1bGxSZXF1ZXN0MjAwODIzNzI4", "number": 9358, "title": "Allocator unification, attempt three!", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2018-07-11T20:58:43Z", "updated_at": "2018-11-23T15:47:26Z", "closed_at": "2018-07-15T22:12:32Z", "author_association": "CONTRIBUTOR", "pull_request": {"url": "https://api.github.com/repos/pytorch/pytorch/pulls/9358", "html_url": "https://github.com/pytorch/pytorch/pull/9358", "diff_url": "https://github.com/pytorch/pytorch/pull/9358.diff", "patch_url": "https://github.com/pytorch/pytorch/pull/9358.patch"}, "body_html": "<pre><code>Introduce SupervisedPtr, delete THAllocator and THCDeviceAllocator\n\nSee Note [Supervisor deleter] for how SupervisedPtr works.\nThis design is not the obvious one, but there were a lot of\nconstraints feeding into it:\n\n- It must support the reallocation usage-pattern, where, given\n  an existing Storage, we allocate a new region of memory,\n  copy the existing data to it, and then deallocate the old\n  region of memory.\n\n- Creation of a deleter for memory MUST avoid dynamic allocations\n  in the common case.  We've done some benchmarking in Caffe2\n  where dynamic allocation for deleters is ruinously expensive,\n  and it's really hard to avoid these performance tarpits in\n  very general function wrappers like std::function or\n  folly::Function (while benchmarking this, we discovered that\n  folly::Function's move constructor was way more expensive\n  than it should be).\n\n- We need to be able to deallocate data that comes from external\n  sources, e.g., dlpack and numpy tensors.  Most notably,\n  you often cannot deallocate these with merely the void*\n  data pointer; you need some extra, out-of-band information\n  (e.g., the managing struct) to deallocate it.  Sometimes,\n  you may even want to resize data living in an external source!\n\n- The \"core\" allocators need to support being wrapped in a Thrust\n  allocator, so you need to be implement the following two functions:\n\n    char* allocate(size_t);\n    void deallocate(char*, size_t);\n\n- We need to support tensors which contain non-POD, non-trivially\n  copyable data; specifically tensors of std::string.  This is\n  an upcoming requirement from Caffe2.  It's dirty AF, but\n  it's really useful.\n\n- It should use C++ standard library types like std::unique_ptr\n  (which is hugely problematic because std::unique_ptr doesn't\n  call the deleter when the pointer is null.)\n\nHere is the billing of changes:\n\n- Built-in support for realloc() has been DROPPED ENTIRELY.\n  Instead, you're expected to allocate and then copy from\n  the old memory to the new memory if you want to do a\n  reallocation.  This is what you'd generally have expected\n  to occur; and axing realloc() from the design lets us avoid\n  some tricky correctness issues with std::realloc(), namely\n  the fact that we must refuse the realloc if the type of the\n  elements are not trivially copyeable.  If it really matters,\n  we can add this back, but there really needs to be a good\n  explanation WHY you need fast resizing reallocations (by in\n  large, people don't resize their storages, and it should\n  be acceptable to have a performance degradation when they\n  do).\n\n- TH_STORAGE_FREEMEM is no more; instead, if you want a\n  storage which doesn't free its result, you just give it\n  an empty deleter.\n\n- What we used to call an \"allocator\" (really, a combined\n  object for allocating/deleting) has been split into two\n  concepts, an allocator, and a smart pointer (SupervisedPtr)\n  which knows how to delete data.\n\n    - Unlike previously, where THAllocator/THCDeviceAllocator\n      could have a per-tensor context storing extra information\n      (e.g., a pointer to the metadata you need to actually\n      free the tensor), there is no context in the allocator or\n      the deleter of the smart pointer; instead, the smart\n      pointer directly holds an owning reference to the\n      metadata necessary to free the data.  This metadata\n      is *freshly manufactured* upon every allocation, which\n      permits us to resize tensors even in the absence of\n      built-in support for realloc().\n\n    - By default, allocators don't support \"raw\" allocations\n      and deallocations with raw pointers.  This is because\n      some allocations may return a different context every\n      time, in which case you need to reconstruct the context\n      at delete time (because all you got was a void*, not\n      a unique_ptr that carries the deleter).\n\n- The diff between at::Allocator and THCDeviceAllocator is a\n  bit larger:\n\n    - It used to return a cudaError_t.  Now, allocators\n      are expected to check the error status immediately and throw\n      an exception if there was an error.  It turns out that this\n      is what was immediately done after all occurrences of\n      allocate/release, so it wasn't a big deal (although some\n      subsidiary interfaces had to themselves be converted to\n      not return cudaError_t).\n\n      There is one notable exception to this, and it is how\n      we handle CUDA OOM: if this occurs, we attempt to return\n      unused memory to the system and try again.  This is now\n      handled by a catch-all try-catch block.  The cost of\n      catching the exception is probably the least of your worries\n      if you're about to OOM.\n\n    - It used to take the CUDA stream to perform the allocation\n      on as an argument.  However, it turned out that all call\n      sites, this stream was the stream for the current device.\n      So we can push this into the allocator (and the choice,\n      in the future, could be made explicitly by twiddling\n      thread local state.)\n\n    - It held two extra methods, emptyCache and cacheInfo, specifically\n      for interacting with some state in THCCachingAllocator.\n      But this \"generality\" was a lie, since THCCachingAllocator\n      was the only allocator that actually implemented these\n      methods, and there is actually a bunch of code in THC\n      which assumes that it is the caching allocator that is\n      the underlying allocator for CUDA allocations.  So I\n      folded these two methods into this interface as\n      THCCachingAllocator_emptyCache and THCCachingAllocator_cacheInfo.\n\n    - It held its context directly inside the THCDeviceAllocator\n      struct.  This context has been moved out into whatever\n      is holding the at::Allocator*.\n\n- The APIs for getting at allocators/deleters is now a little different.\n\n    - Previously there were a bunch of static variables you could get\n      the address of (e.g., &amp;THDefaultAllocator); now there is a\n      function getTHDefaultAllocator().\n\n    - Some \"allocators\" didn't actually know how to allocate (e.g.,\n      the IPC \"allocator\").  These have been deleted; instead, you\n      can wrap the produced pointers into SupervisedPtr using\n      an appropriate makeSupervisedPtr() static method.\n\n- Storage sharing was a lot of work to wrangle, but I think I've\n  tamed the beast.\n\n    - THMapAllocator and its \"subclasses\" have been refactored to\n      be proper, honest to goodness C++ classes.  I used the enum\n      argument trick to get \"named\" constructors.  We use inheritance\n      to add refcounting and management (in libshm).  What we previously\n      called the \"Context\" class (Context has been dropped from the name)\n      is now the supervisor for the data.\n\n    - Sometimes, we need to pull out the file descriptor from a\n      tensor.  Previously, it was pulled out of the allocator context.\n      Now, we pull it out of the supervisor of the SupervisorPtr,\n      using the static method fromSupervisedPtr(), which uses the\n      deleter as the typeid, and refines the type if it matches.\n\n- I renamed the std::function deleter into\n  InefficientStdFunctionSupervisor, to emphasize the fact that it does\n  a dynamic allocation to save the std::function deleter.\n\nTODO:\n\n- Windows libshm is in shambles and needs to be fixed.\n\nPerhaps for the future:\n\n- newFromFd is now unconditionally calling cudaPointerGetAttributes\n  even though this is unnecessary, because we know what the device\n  is from higher up in the callstack.  We can fix this by making\n  newWithDataAndAllocator also take an explicit device argument.\n\n- Consider statically distinguishing between allocators that\n  support raw_allocate/raw_deallocate, and those which don't.\n  The Thrust constraint applies only to the CUDA device allocator;\n  you never need to allocate CPU memory this way\n\n- Really want to get rid of storage views. Ugh.\n\nNontrivial bugs I noticed when preparing this patch:\n\n- I forgot to placement-new unique pointers and attempted to\n  assign them directly on uninitialized memory; very bad!  Sam\n  Gross has encouraged me to replace this with a proper constructor\n  but I keep putting it off, because once everything goes in\n  StorageImpl there really will be a proper constructor.\n\n- I rewrote a number of APIs to use newWithDataAndAllocator\n  instead of newWithAllocator, calling the allocator at the\n  call site (because they required \"allocation context\" which\n  we no longer give to \"allocators\").  When I did this, I forgot\n  to insert the multiplication with sizeof(real) to scale from\n  numels to number of bytes.\n\n- The implementation of swap on storages was missing it for\n  scalarType and backend.  It was benign (because the only case\n  we call swap is when these are the same), but I fixed it anyway.\n\n- I accidentally returned a nullptr unique_ptr with no deleter,\n  even though there was a legitimate one.  This matters, because\n  some code still shoves its hands in the deleter context to\n  get extra metadata about the function.\n\n- I used std::move() on a unique_ptr, and then did a boolean\n  test on the pointer aftewards (always false!)\n\nSigned-off-by: Edward Z. Yang &lt;ezyang@fb.com&gt;\n</code></pre>", "body_text": "Introduce SupervisedPtr, delete THAllocator and THCDeviceAllocator\n\nSee Note [Supervisor deleter] for how SupervisedPtr works.\nThis design is not the obvious one, but there were a lot of\nconstraints feeding into it:\n\n- It must support the reallocation usage-pattern, where, given\n  an existing Storage, we allocate a new region of memory,\n  copy the existing data to it, and then deallocate the old\n  region of memory.\n\n- Creation of a deleter for memory MUST avoid dynamic allocations\n  in the common case.  We've done some benchmarking in Caffe2\n  where dynamic allocation for deleters is ruinously expensive,\n  and it's really hard to avoid these performance tarpits in\n  very general function wrappers like std::function or\n  folly::Function (while benchmarking this, we discovered that\n  folly::Function's move constructor was way more expensive\n  than it should be).\n\n- We need to be able to deallocate data that comes from external\n  sources, e.g., dlpack and numpy tensors.  Most notably,\n  you often cannot deallocate these with merely the void*\n  data pointer; you need some extra, out-of-band information\n  (e.g., the managing struct) to deallocate it.  Sometimes,\n  you may even want to resize data living in an external source!\n\n- The \"core\" allocators need to support being wrapped in a Thrust\n  allocator, so you need to be implement the following two functions:\n\n    char* allocate(size_t);\n    void deallocate(char*, size_t);\n\n- We need to support tensors which contain non-POD, non-trivially\n  copyable data; specifically tensors of std::string.  This is\n  an upcoming requirement from Caffe2.  It's dirty AF, but\n  it's really useful.\n\n- It should use C++ standard library types like std::unique_ptr\n  (which is hugely problematic because std::unique_ptr doesn't\n  call the deleter when the pointer is null.)\n\nHere is the billing of changes:\n\n- Built-in support for realloc() has been DROPPED ENTIRELY.\n  Instead, you're expected to allocate and then copy from\n  the old memory to the new memory if you want to do a\n  reallocation.  This is what you'd generally have expected\n  to occur; and axing realloc() from the design lets us avoid\n  some tricky correctness issues with std::realloc(), namely\n  the fact that we must refuse the realloc if the type of the\n  elements are not trivially copyeable.  If it really matters,\n  we can add this back, but there really needs to be a good\n  explanation WHY you need fast resizing reallocations (by in\n  large, people don't resize their storages, and it should\n  be acceptable to have a performance degradation when they\n  do).\n\n- TH_STORAGE_FREEMEM is no more; instead, if you want a\n  storage which doesn't free its result, you just give it\n  an empty deleter.\n\n- What we used to call an \"allocator\" (really, a combined\n  object for allocating/deleting) has been split into two\n  concepts, an allocator, and a smart pointer (SupervisedPtr)\n  which knows how to delete data.\n\n    - Unlike previously, where THAllocator/THCDeviceAllocator\n      could have a per-tensor context storing extra information\n      (e.g., a pointer to the metadata you need to actually\n      free the tensor), there is no context in the allocator or\n      the deleter of the smart pointer; instead, the smart\n      pointer directly holds an owning reference to the\n      metadata necessary to free the data.  This metadata\n      is *freshly manufactured* upon every allocation, which\n      permits us to resize tensors even in the absence of\n      built-in support for realloc().\n\n    - By default, allocators don't support \"raw\" allocations\n      and deallocations with raw pointers.  This is because\n      some allocations may return a different context every\n      time, in which case you need to reconstruct the context\n      at delete time (because all you got was a void*, not\n      a unique_ptr that carries the deleter).\n\n- The diff between at::Allocator and THCDeviceAllocator is a\n  bit larger:\n\n    - It used to return a cudaError_t.  Now, allocators\n      are expected to check the error status immediately and throw\n      an exception if there was an error.  It turns out that this\n      is what was immediately done after all occurrences of\n      allocate/release, so it wasn't a big deal (although some\n      subsidiary interfaces had to themselves be converted to\n      not return cudaError_t).\n\n      There is one notable exception to this, and it is how\n      we handle CUDA OOM: if this occurs, we attempt to return\n      unused memory to the system and try again.  This is now\n      handled by a catch-all try-catch block.  The cost of\n      catching the exception is probably the least of your worries\n      if you're about to OOM.\n\n    - It used to take the CUDA stream to perform the allocation\n      on as an argument.  However, it turned out that all call\n      sites, this stream was the stream for the current device.\n      So we can push this into the allocator (and the choice,\n      in the future, could be made explicitly by twiddling\n      thread local state.)\n\n    - It held two extra methods, emptyCache and cacheInfo, specifically\n      for interacting with some state in THCCachingAllocator.\n      But this \"generality\" was a lie, since THCCachingAllocator\n      was the only allocator that actually implemented these\n      methods, and there is actually a bunch of code in THC\n      which assumes that it is the caching allocator that is\n      the underlying allocator for CUDA allocations.  So I\n      folded these two methods into this interface as\n      THCCachingAllocator_emptyCache and THCCachingAllocator_cacheInfo.\n\n    - It held its context directly inside the THCDeviceAllocator\n      struct.  This context has been moved out into whatever\n      is holding the at::Allocator*.\n\n- The APIs for getting at allocators/deleters is now a little different.\n\n    - Previously there were a bunch of static variables you could get\n      the address of (e.g., &THDefaultAllocator); now there is a\n      function getTHDefaultAllocator().\n\n    - Some \"allocators\" didn't actually know how to allocate (e.g.,\n      the IPC \"allocator\").  These have been deleted; instead, you\n      can wrap the produced pointers into SupervisedPtr using\n      an appropriate makeSupervisedPtr() static method.\n\n- Storage sharing was a lot of work to wrangle, but I think I've\n  tamed the beast.\n\n    - THMapAllocator and its \"subclasses\" have been refactored to\n      be proper, honest to goodness C++ classes.  I used the enum\n      argument trick to get \"named\" constructors.  We use inheritance\n      to add refcounting and management (in libshm).  What we previously\n      called the \"Context\" class (Context has been dropped from the name)\n      is now the supervisor for the data.\n\n    - Sometimes, we need to pull out the file descriptor from a\n      tensor.  Previously, it was pulled out of the allocator context.\n      Now, we pull it out of the supervisor of the SupervisorPtr,\n      using the static method fromSupervisedPtr(), which uses the\n      deleter as the typeid, and refines the type if it matches.\n\n- I renamed the std::function deleter into\n  InefficientStdFunctionSupervisor, to emphasize the fact that it does\n  a dynamic allocation to save the std::function deleter.\n\nTODO:\n\n- Windows libshm is in shambles and needs to be fixed.\n\nPerhaps for the future:\n\n- newFromFd is now unconditionally calling cudaPointerGetAttributes\n  even though this is unnecessary, because we know what the device\n  is from higher up in the callstack.  We can fix this by making\n  newWithDataAndAllocator also take an explicit device argument.\n\n- Consider statically distinguishing between allocators that\n  support raw_allocate/raw_deallocate, and those which don't.\n  The Thrust constraint applies only to the CUDA device allocator;\n  you never need to allocate CPU memory this way\n\n- Really want to get rid of storage views. Ugh.\n\nNontrivial bugs I noticed when preparing this patch:\n\n- I forgot to placement-new unique pointers and attempted to\n  assign them directly on uninitialized memory; very bad!  Sam\n  Gross has encouraged me to replace this with a proper constructor\n  but I keep putting it off, because once everything goes in\n  StorageImpl there really will be a proper constructor.\n\n- I rewrote a number of APIs to use newWithDataAndAllocator\n  instead of newWithAllocator, calling the allocator at the\n  call site (because they required \"allocation context\" which\n  we no longer give to \"allocators\").  When I did this, I forgot\n  to insert the multiplication with sizeof(real) to scale from\n  numels to number of bytes.\n\n- The implementation of swap on storages was missing it for\n  scalarType and backend.  It was benign (because the only case\n  we call swap is when these are the same), but I fixed it anyway.\n\n- I accidentally returned a nullptr unique_ptr with no deleter,\n  even though there was a legitimate one.  This matters, because\n  some code still shoves its hands in the deleter context to\n  get extra metadata about the function.\n\n- I used std::move() on a unique_ptr, and then did a boolean\n  test on the pointer aftewards (always false!)\n\nSigned-off-by: Edward Z. Yang <ezyang@fb.com>", "body": "```\r\nIntroduce SupervisedPtr, delete THAllocator and THCDeviceAllocator\r\n\r\nSee Note [Supervisor deleter] for how SupervisedPtr works.\r\nThis design is not the obvious one, but there were a lot of\r\nconstraints feeding into it:\r\n\r\n- It must support the reallocation usage-pattern, where, given\r\n  an existing Storage, we allocate a new region of memory,\r\n  copy the existing data to it, and then deallocate the old\r\n  region of memory.\r\n\r\n- Creation of a deleter for memory MUST avoid dynamic allocations\r\n  in the common case.  We've done some benchmarking in Caffe2\r\n  where dynamic allocation for deleters is ruinously expensive,\r\n  and it's really hard to avoid these performance tarpits in\r\n  very general function wrappers like std::function or\r\n  folly::Function (while benchmarking this, we discovered that\r\n  folly::Function's move constructor was way more expensive\r\n  than it should be).\r\n\r\n- We need to be able to deallocate data that comes from external\r\n  sources, e.g., dlpack and numpy tensors.  Most notably,\r\n  you often cannot deallocate these with merely the void*\r\n  data pointer; you need some extra, out-of-band information\r\n  (e.g., the managing struct) to deallocate it.  Sometimes,\r\n  you may even want to resize data living in an external source!\r\n\r\n- The \"core\" allocators need to support being wrapped in a Thrust\r\n  allocator, so you need to be implement the following two functions:\r\n\r\n    char* allocate(size_t);\r\n    void deallocate(char*, size_t);\r\n\r\n- We need to support tensors which contain non-POD, non-trivially\r\n  copyable data; specifically tensors of std::string.  This is\r\n  an upcoming requirement from Caffe2.  It's dirty AF, but\r\n  it's really useful.\r\n\r\n- It should use C++ standard library types like std::unique_ptr\r\n  (which is hugely problematic because std::unique_ptr doesn't\r\n  call the deleter when the pointer is null.)\r\n\r\nHere is the billing of changes:\r\n\r\n- Built-in support for realloc() has been DROPPED ENTIRELY.\r\n  Instead, you're expected to allocate and then copy from\r\n  the old memory to the new memory if you want to do a\r\n  reallocation.  This is what you'd generally have expected\r\n  to occur; and axing realloc() from the design lets us avoid\r\n  some tricky correctness issues with std::realloc(), namely\r\n  the fact that we must refuse the realloc if the type of the\r\n  elements are not trivially copyeable.  If it really matters,\r\n  we can add this back, but there really needs to be a good\r\n  explanation WHY you need fast resizing reallocations (by in\r\n  large, people don't resize their storages, and it should\r\n  be acceptable to have a performance degradation when they\r\n  do).\r\n\r\n- TH_STORAGE_FREEMEM is no more; instead, if you want a\r\n  storage which doesn't free its result, you just give it\r\n  an empty deleter.\r\n\r\n- What we used to call an \"allocator\" (really, a combined\r\n  object for allocating/deleting) has been split into two\r\n  concepts, an allocator, and a smart pointer (SupervisedPtr)\r\n  which knows how to delete data.\r\n\r\n    - Unlike previously, where THAllocator/THCDeviceAllocator\r\n      could have a per-tensor context storing extra information\r\n      (e.g., a pointer to the metadata you need to actually\r\n      free the tensor), there is no context in the allocator or\r\n      the deleter of the smart pointer; instead, the smart\r\n      pointer directly holds an owning reference to the\r\n      metadata necessary to free the data.  This metadata\r\n      is *freshly manufactured* upon every allocation, which\r\n      permits us to resize tensors even in the absence of\r\n      built-in support for realloc().\r\n\r\n    - By default, allocators don't support \"raw\" allocations\r\n      and deallocations with raw pointers.  This is because\r\n      some allocations may return a different context every\r\n      time, in which case you need to reconstruct the context\r\n      at delete time (because all you got was a void*, not\r\n      a unique_ptr that carries the deleter).\r\n\r\n- The diff between at::Allocator and THCDeviceAllocator is a\r\n  bit larger:\r\n\r\n    - It used to return a cudaError_t.  Now, allocators\r\n      are expected to check the error status immediately and throw\r\n      an exception if there was an error.  It turns out that this\r\n      is what was immediately done after all occurrences of\r\n      allocate/release, so it wasn't a big deal (although some\r\n      subsidiary interfaces had to themselves be converted to\r\n      not return cudaError_t).\r\n\r\n      There is one notable exception to this, and it is how\r\n      we handle CUDA OOM: if this occurs, we attempt to return\r\n      unused memory to the system and try again.  This is now\r\n      handled by a catch-all try-catch block.  The cost of\r\n      catching the exception is probably the least of your worries\r\n      if you're about to OOM.\r\n\r\n    - It used to take the CUDA stream to perform the allocation\r\n      on as an argument.  However, it turned out that all call\r\n      sites, this stream was the stream for the current device.\r\n      So we can push this into the allocator (and the choice,\r\n      in the future, could be made explicitly by twiddling\r\n      thread local state.)\r\n\r\n    - It held two extra methods, emptyCache and cacheInfo, specifically\r\n      for interacting with some state in THCCachingAllocator.\r\n      But this \"generality\" was a lie, since THCCachingAllocator\r\n      was the only allocator that actually implemented these\r\n      methods, and there is actually a bunch of code in THC\r\n      which assumes that it is the caching allocator that is\r\n      the underlying allocator for CUDA allocations.  So I\r\n      folded these two methods into this interface as\r\n      THCCachingAllocator_emptyCache and THCCachingAllocator_cacheInfo.\r\n\r\n    - It held its context directly inside the THCDeviceAllocator\r\n      struct.  This context has been moved out into whatever\r\n      is holding the at::Allocator*.\r\n\r\n- The APIs for getting at allocators/deleters is now a little different.\r\n\r\n    - Previously there were a bunch of static variables you could get\r\n      the address of (e.g., &THDefaultAllocator); now there is a\r\n      function getTHDefaultAllocator().\r\n\r\n    - Some \"allocators\" didn't actually know how to allocate (e.g.,\r\n      the IPC \"allocator\").  These have been deleted; instead, you\r\n      can wrap the produced pointers into SupervisedPtr using\r\n      an appropriate makeSupervisedPtr() static method.\r\n\r\n- Storage sharing was a lot of work to wrangle, but I think I've\r\n  tamed the beast.\r\n\r\n    - THMapAllocator and its \"subclasses\" have been refactored to\r\n      be proper, honest to goodness C++ classes.  I used the enum\r\n      argument trick to get \"named\" constructors.  We use inheritance\r\n      to add refcounting and management (in libshm).  What we previously\r\n      called the \"Context\" class (Context has been dropped from the name)\r\n      is now the supervisor for the data.\r\n\r\n    - Sometimes, we need to pull out the file descriptor from a\r\n      tensor.  Previously, it was pulled out of the allocator context.\r\n      Now, we pull it out of the supervisor of the SupervisorPtr,\r\n      using the static method fromSupervisedPtr(), which uses the\r\n      deleter as the typeid, and refines the type if it matches.\r\n\r\n- I renamed the std::function deleter into\r\n  InefficientStdFunctionSupervisor, to emphasize the fact that it does\r\n  a dynamic allocation to save the std::function deleter.\r\n\r\nTODO:\r\n\r\n- Windows libshm is in shambles and needs to be fixed.\r\n\r\nPerhaps for the future:\r\n\r\n- newFromFd is now unconditionally calling cudaPointerGetAttributes\r\n  even though this is unnecessary, because we know what the device\r\n  is from higher up in the callstack.  We can fix this by making\r\n  newWithDataAndAllocator also take an explicit device argument.\r\n\r\n- Consider statically distinguishing between allocators that\r\n  support raw_allocate/raw_deallocate, and those which don't.\r\n  The Thrust constraint applies only to the CUDA device allocator;\r\n  you never need to allocate CPU memory this way\r\n\r\n- Really want to get rid of storage views. Ugh.\r\n\r\nNontrivial bugs I noticed when preparing this patch:\r\n\r\n- I forgot to placement-new unique pointers and attempted to\r\n  assign them directly on uninitialized memory; very bad!  Sam\r\n  Gross has encouraged me to replace this with a proper constructor\r\n  but I keep putting it off, because once everything goes in\r\n  StorageImpl there really will be a proper constructor.\r\n\r\n- I rewrote a number of APIs to use newWithDataAndAllocator\r\n  instead of newWithAllocator, calling the allocator at the\r\n  call site (because they required \"allocation context\" which\r\n  we no longer give to \"allocators\").  When I did this, I forgot\r\n  to insert the multiplication with sizeof(real) to scale from\r\n  numels to number of bytes.\r\n\r\n- The implementation of swap on storages was missing it for\r\n  scalarType and backend.  It was benign (because the only case\r\n  we call swap is when these are the same), but I fixed it anyway.\r\n\r\n- I accidentally returned a nullptr unique_ptr with no deleter,\r\n  even though there was a legitimate one.  This matters, because\r\n  some code still shoves its hands in the deleter context to\r\n  get extra metadata about the function.\r\n\r\n- I used std::move() on a unique_ptr, and then did a boolean\r\n  test on the pointer aftewards (always false!)\r\n\r\nSigned-off-by: Edward Z. Yang <ezyang@fb.com>\r\n```"}