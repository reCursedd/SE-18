{"url": "https://api.github.com/repos/pytorch/pytorch/issues/14064", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/14064/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/14064/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/14064/events", "html_url": "https://github.com/pytorch/pytorch/pull/14064", "id": 381417872, "node_id": "MDExOlB1bGxSZXF1ZXN0MjMxMzk1MjE0", "number": 14064, "title": "Address jittering issues in python_print", "user": {"login": "zdevito", "id": 370202, "node_id": "MDQ6VXNlcjM3MDIwMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/370202?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zdevito", "html_url": "https://github.com/zdevito", "followers_url": "https://api.github.com/users/zdevito/followers", "following_url": "https://api.github.com/users/zdevito/following{/other_user}", "gists_url": "https://api.github.com/users/zdevito/gists{/gist_id}", "starred_url": "https://api.github.com/users/zdevito/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zdevito/subscriptions", "organizations_url": "https://api.github.com/users/zdevito/orgs", "repos_url": "https://api.github.com/users/zdevito/repos", "events_url": "https://api.github.com/users/zdevito/events{/privacy}", "received_events_url": "https://api.github.com/users/zdevito/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 679953983, "node_id": "MDU6TGFiZWw2Nzk5NTM5ODM=", "url": "https://api.github.com/repos/pytorch/pytorch/labels/jit", "name": "jit", "color": "c5def5", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2018-11-16T02:15:48Z", "updated_at": "2018-11-23T15:55:14Z", "closed_at": "2018-11-21T14:40:12Z", "author_association": "CONTRIBUTOR", "pull_request": {"url": "https://api.github.com/repos/pytorch/pytorch/pulls/14064", "html_url": "https://github.com/pytorch/pytorch/pull/14064", "diff_url": "https://github.com/pytorch/pytorch/pull/14064.diff", "patch_url": "https://github.com/pytorch/pytorch/pull/14064.patch"}, "body_html": "<p>export - print a method with python_print<br>\nimport - import a method with import_method</p>\n<p>We want to ensure:</p>\n<pre><code>export(g) == export(import(export(g)))\n</code></pre>\n<p>That is after after exporting/importing once, the graph will stay exactly<br>\nthe same. This is less strict that g == import(export(g)) which would<br>\nrequire us to maintain a lot more information about the structure of the<br>\nIR and about the names of debug symbols.</p>\n<p>This PR addresses this with the following fixes:</p>\n<ul>\n<li>print out double-precision numbers with high enough precision such<br>\nthat they always parse in the same way</li>\n<li>when creating loop-carried dependencies, sort them<br>\nby variable name, ensuring a consistent order</li>\n<li>parse nan correctly</li>\n<li>DCE: remove unused outputs of if statements, and loop-carried dependencies<br>\nin loops that are dead both after the loop and inside the body of the<br>\nloop.</li>\n<li>Do not set uniqueName for variables whose names are _[0-9]+, these<br>\nare probably rare in user code, and we need a way to communicate<br>\nthat we do not care about a variable name when re-parsing the graph.<br>\nOtherwise temporary variable names will jitter around.</li>\n<li>Expand the definition of a constant in printing code to None,<br>\nand family.</li>\n<li>Allow re-treeing to work as long as the only thing in its way is a<br>\nconstant node. These do not have side effects but are sometimes<br>\ninserted in a different order when tracing compared to how we print them.</li>\n<li>Print all constant nodes out first in the order in which they are used_val<br>\n(or, if they are inlined, ensure they get assigned CONSTANT.cX number<br>\nin a consistent order). Cleanup tuples (this is done in the compiler,<br>\nbut not in the tracer, leading to some tuple indexing jitter if not<br>\ndone).</li>\n<li>use strtod_l, not std::stod which can throw exceptions</li>\n</ul>\n<p>Other:</p>\n<ul>\n<li>Add REL_WITH_DEB_INFO to setup.py. It already existed for the<br>\ncmake files. Threading it into setup.py allows us to turn on<br>\ndebug symbols with optimization everywhere.</li>\n<li>enable round trip testing for all generated graphs. This only adds<br>\n~6 seconds to total build time but tests printing for every graph.</li>\n</ul>", "body_text": "export - print a method with python_print\nimport - import a method with import_method\nWe want to ensure:\nexport(g) == export(import(export(g)))\n\nThat is after after exporting/importing once, the graph will stay exactly\nthe same. This is less strict that g == import(export(g)) which would\nrequire us to maintain a lot more information about the structure of the\nIR and about the names of debug symbols.\nThis PR addresses this with the following fixes:\n\nprint out double-precision numbers with high enough precision such\nthat they always parse in the same way\nwhen creating loop-carried dependencies, sort them\nby variable name, ensuring a consistent order\nparse nan correctly\nDCE: remove unused outputs of if statements, and loop-carried dependencies\nin loops that are dead both after the loop and inside the body of the\nloop.\nDo not set uniqueName for variables whose names are _[0-9]+, these\nare probably rare in user code, and we need a way to communicate\nthat we do not care about a variable name when re-parsing the graph.\nOtherwise temporary variable names will jitter around.\nExpand the definition of a constant in printing code to None,\nand family.\nAllow re-treeing to work as long as the only thing in its way is a\nconstant node. These do not have side effects but are sometimes\ninserted in a different order when tracing compared to how we print them.\nPrint all constant nodes out first in the order in which they are used_val\n(or, if they are inlined, ensure they get assigned CONSTANT.cX number\nin a consistent order). Cleanup tuples (this is done in the compiler,\nbut not in the tracer, leading to some tuple indexing jitter if not\ndone).\nuse strtod_l, not std::stod which can throw exceptions\n\nOther:\n\nAdd REL_WITH_DEB_INFO to setup.py. It already existed for the\ncmake files. Threading it into setup.py allows us to turn on\ndebug symbols with optimization everywhere.\nenable round trip testing for all generated graphs. This only adds\n~6 seconds to total build time but tests printing for every graph.", "body": "export - print a method with python_print\r\nimport - import a method with import_method\r\n\r\nWe want to ensure:\r\n\r\n    export(g) == export(import(export(g)))\r\n\r\nThat is after after exporting/importing once, the graph will stay exactly\r\nthe same. This is less strict that g == import(export(g)) which would\r\nrequire us to maintain a lot more information about the structure of the\r\nIR and about the names of debug symbols.\r\n\r\nThis PR addresses this with the following fixes:\r\n* print out double-precision numbers with high enough precision such\r\n  that they always parse in the same way\r\n* when creating loop-carried dependencies, sort them\r\n  by variable name, ensuring a consistent order\r\n* parse nan correctly\r\n* DCE: remove unused outputs of if statements, and loop-carried dependencies\r\n  in loops that are dead both after the loop and inside the body of the\r\n  loop.\r\n* Do not set uniqueName for variables whose names are _[0-9]+, these\r\n  are probably rare in user code, and we need a way to communicate\r\n  that we do not care about a variable name when re-parsing the graph.\r\n  Otherwise temporary variable names will jitter around.\r\n* Expand the definition of a constant in printing code to None,\r\n  and family.\r\n* Allow re-treeing to work as long as the only thing in its way is a\r\n  constant node. These do not have side effects but are sometimes\r\n  inserted in a different order when tracing compared to how we print them.\r\n* Print all constant nodes out first in the order in which they are used_val\r\n (or, if they are inlined, ensure they get assigned CONSTANT.cX number\r\n  in a consistent order). Cleanup tuples (this is done in the compiler,\r\n  but not in the tracer, leading to some tuple indexing jitter if not\r\n  done).\r\n* use strtod_l, not std::stod which can throw exceptions\r\n\r\nOther:\r\n* Add REL_WITH_DEB_INFO to setup.py. It already existed for the\r\n  cmake files. Threading it into setup.py allows us to turn on\r\n  debug symbols with optimization everywhere.\r\n* enable round trip testing for all generated graphs. This only adds\r\n  ~6 seconds to total build time but tests printing for every graph.\r\n\r\n"}