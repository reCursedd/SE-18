{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/379349671", "html_url": "https://github.com/pytorch/pytorch/issues/6187#issuecomment-379349671", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/6187", "id": 379349671, "node_id": "MDEyOklzc3VlQ29tbWVudDM3OTM0OTY3MQ==", "user": {"login": "el3ment", "id": 2135235, "node_id": "MDQ6VXNlcjIxMzUyMzU=", "avatar_url": "https://avatars2.githubusercontent.com/u/2135235?v=4", "gravatar_id": "", "url": "https://api.github.com/users/el3ment", "html_url": "https://github.com/el3ment", "followers_url": "https://api.github.com/users/el3ment/followers", "following_url": "https://api.github.com/users/el3ment/following{/other_user}", "gists_url": "https://api.github.com/users/el3ment/gists{/gist_id}", "starred_url": "https://api.github.com/users/el3ment/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/el3ment/subscriptions", "organizations_url": "https://api.github.com/users/el3ment/orgs", "repos_url": "https://api.github.com/users/el3ment/repos", "events_url": "https://api.github.com/users/el3ment/events{/privacy}", "received_events_url": "https://api.github.com/users/el3ment/received_events", "type": "User", "site_admin": false}, "created_at": "2018-04-06T19:11:36Z", "updated_at": "2018-04-06T19:11:36Z", "author_association": "NONE", "body_html": "<p>As a side note - I have implemented this a few different ways, and there are some numerical properties that need to be kept in mind. Using the SVD can create nan problems for backprop when the singular values are not unique. You can use the left and right pseudoinverses (using an if statement based on the shape) which involve the true inverse of a square <code>(A.T.dot(A)).inv()</code> or <code>(A.dot(A.T)).inv()</code> which seems to be more stable for backprop. Becuase those matricies are symmetric, you can also take advantage of other inverse algorithms like <code>torch.potri</code> but in practice, this doesn't seem to work as well when doing backprop</p>", "body_text": "As a side note - I have implemented this a few different ways, and there are some numerical properties that need to be kept in mind. Using the SVD can create nan problems for backprop when the singular values are not unique. You can use the left and right pseudoinverses (using an if statement based on the shape) which involve the true inverse of a square (A.T.dot(A)).inv() or (A.dot(A.T)).inv() which seems to be more stable for backprop. Becuase those matricies are symmetric, you can also take advantage of other inverse algorithms like torch.potri but in practice, this doesn't seem to work as well when doing backprop", "body": "As a side note - I have implemented this a few different ways, and there are some numerical properties that need to be kept in mind. Using the SVD can create nan problems for backprop when the singular values are not unique. You can use the left and right pseudoinverses (using an if statement based on the shape) which involve the true inverse of a square `(A.T.dot(A)).inv()` or `(A.dot(A.T)).inv()` which seems to be more stable for backprop. Becuase those matricies are symmetric, you can also take advantage of other inverse algorithms like `torch.potri` but in practice, this doesn't seem to work as well when doing backprop"}