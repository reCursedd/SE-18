{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/188157145", "pull_request_review_id": 120077247, "id": 188157145, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4ODE1NzE0NQ==", "diff_hunk": "@@ -0,0 +1,282 @@\n+#include \"Utils.hpp\"\n+\n+#include <sys/poll.h>\n+#include <netdb.h>\n+\n+#include <arpa/inet.h>\n+#include <netinet/in.h>\n+#include <netinet/tcp.h>\n+\n+#include <fcntl.h>\n+#include <unistd.h>\n+\n+#include <cstring>\n+#include <memory>\n+#include <string>\n+#include <thread>\n+#include <algorithm>\n+\n+namespace c10d {\n+namespace tcputil {\n+\n+\n+namespace {\n+\n+constexpr int LISTEN_QUEUE_SIZE = 64;\n+\n+void setSocketNoDelay(int socket) {\n+  int flag = 1;\n+  socklen_t optlen = sizeof(flag);\n+  SYSCHECK(setsockopt(socket, IPPROTO_TCP, TCP_NODELAY, (char*)&flag, optlen));\n+}\n+\n+PortType getSocketPort(int fd) {\n+  PortType listenPort;\n+  struct ::sockaddr_storage addrStorage;\n+  socklen_t addrLen = sizeof(addrStorage);\n+  SYSCHECK(getsockname(fd,\n+        reinterpret_cast<struct ::sockaddr*>(&addrStorage), &addrLen));\n+\n+  if (addrStorage.ss_family == AF_INET) {\n+    struct ::sockaddr_in *addr =\n+      reinterpret_cast<struct ::sockaddr_in*>(&addrStorage);\n+    listenPort = ntohs(addr->sin_port);\n+\n+  } else if (addrStorage.ss_family == AF_INET6) { // AF_INET6\n+    struct ::sockaddr_in6 *addr =\n+      reinterpret_cast<struct ::sockaddr_in6*>(&addrStorage);\n+    listenPort = ntohs(addr->sin6_port);\n+\n+  } else {\n+    throw std::runtime_error(\"unsupported protocol\");\n+  }\n+  return listenPort;\n+}\n+\n+}\n+\n+std::string sockaddrToString(struct ::sockaddr *addr) {\n+  char address[INET6_ADDRSTRLEN + 1];\n+  if (addr->sa_family == AF_INET) {\n+    struct ::sockaddr_in *s = reinterpret_cast<struct ::sockaddr_in*>(addr);\n+    SYSCHECK(::inet_ntop(AF_INET, &(s->sin_addr), address, INET_ADDRSTRLEN))\n+    address[INET_ADDRSTRLEN] = '\\0';\n+  } else if (addr->sa_family == AF_INET6) {\n+    struct ::sockaddr_in6 *s = reinterpret_cast<struct ::sockaddr_in6*>(addr);\n+    SYSCHECK(::inet_ntop(AF_INET6, &(s->sin6_addr), address, INET6_ADDRSTRLEN))\n+    address[INET6_ADDRSTRLEN] = '\\0';\n+  } else {\n+    throw std::runtime_error(\"unsupported protocol\");\n+  }\n+  return address;\n+}\n+\n+// listen, connect and accept\n+std::pair<int, PortType> listen(PortType port) {\n+  struct ::addrinfo hints, *res = NULL;\n+\n+  std::memset(&hints, 0x00, sizeof(hints));\n+  hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG;\n+  hints.ai_family = AF_UNSPEC; // either IPv4 or IPv6\n+  hints.ai_socktype = SOCK_STREAM; // TCP\n+\n+  // `getaddrinfo` will sort addresses according to RFC 3484 and can be tweeked\n+  // by editing `/etc/gai.conf`. so there is no need to manual sorting\n+  // or protocol preference.\n+  int err = ::getaddrinfo(nullptr, std::to_string(port).data(), &hints, &res);\n+  if (err != 0 || !res) {\n+    throw std::invalid_argument(\"cannot find host to listen on: \" +\n+                                std::string(gai_strerror(err)));\n+  }\n+\n+  std::shared_ptr<struct ::addrinfo> addresses(res, [](struct ::addrinfo* p) {\n+    ::freeaddrinfo(p);\n+  });\n+\n+  struct ::addrinfo *nextAddr = addresses.get();\n+  int socket;\n+  while (true) {\n+    try {\n+      SYSCHECK(socket = ::socket(nextAddr->ai_family,\n+                                 nextAddr->ai_socktype,\n+                                 nextAddr->ai_protocol))\n+\n+      int optval = 1;\n+      SYSCHECK(::setsockopt(socket,\n+                            SOL_SOCKET,\n+                            SO_REUSEADDR,\n+                            &optval,\n+                            sizeof(int)))\n+\n+      SYSCHECK(::bind(socket, nextAddr->ai_addr, nextAddr->ai_addrlen))\n+      SYSCHECK(::listen(socket, LISTEN_QUEUE_SIZE))\n+      break;\n+\n+    } catch (const std::system_error& e) {\n+      ::close(socket);\n+      nextAddr = nextAddr->ai_next;\n+\n+      /**\n+       * we have tried all addresses but could not start\n+       * listening on any of them\n+       */\n+      if (!nextAddr) {\n+        throw;\n+      }\n+    }\n+  }\n+\n+  // get listen port and address\n+  return {socket, getSocketPort(socket)};\n+}\n+\n+int connect(const std::string& address,\n+            PortType port,\n+            bool wait,\n+            int timeout) {", "path": "torch/lib/c10d/Utils.cpp", "position": null, "original_position": 136, "commit_id": "ba48f051925b6a9d49113e5d8ca43ebd3f551993", "original_commit_id": "54cb0b5d4314ec282f3d813348a1069599f832b6", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "body": "We might want to start using `std::chrono` structs for this", "created_at": "2018-05-15T03:34:20Z", "updated_at": "2018-11-23T15:44:05Z", "html_url": "https://github.com/pytorch/pytorch/pull/7560#discussion_r188157145", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/7560", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/188157145"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/7560#discussion_r188157145"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/7560"}}, "body_html": "<p>We might want to start using <code>std::chrono</code> structs for this</p>", "body_text": "We might want to start using std::chrono structs for this"}