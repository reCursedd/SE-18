{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/188803527", "pull_request_review_id": 120856636, "id": 188803527, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4ODgwMzUyNw==", "diff_hunk": "@@ -200,40 +209,55 @@ void TCPStoreDaemon::addHandler(int socket) {\n   tcpStore_[key] = std::vector<uint8_t>(addValStr.begin(), addValStr.end());\n   // Now send the new value\n   tcputil::sendValue<int64_t>(socket, addVal);\n+  // On \"add\", wake up all clients that have been waiting\n+  wakeupWaitingClients(key);\n }\n \n-void TCPStoreDaemon::getHandler(int socket) {\n+void TCPStoreDaemon::getHandler(int socket) const {\n   std::string key = tcputil::recvString(socket);\n   auto data = tcpStore_.at(key);\n   tcputil::sendVector<uint8_t>(socket, data);\n }\n \n-void TCPStoreDaemon::checkHandler(int socket) {\n+void TCPStoreDaemon::checkHandler(int socket) const {\n   SizeType nargs;\n   tcputil::recvBytes<SizeType>(socket, &nargs, 1);\n   std::vector<std::string> keys(nargs);\n   for (size_t i = 0; i < nargs; i++) {\n     keys[i] = tcputil::recvString(socket);\n   }\n   // Now we have received all the keys\n-  if (checkAndUpdate(keys)) {\n+  if (checkKeys(keys)) {\n     tcputil::sendValue<CheckResponseType>(socket, CheckResponseType::READY);\n   } else {\n     tcputil::sendValue<CheckResponseType>(socket, CheckResponseType::NOT_READY);\n   }\n }\n \n-bool TCPStoreDaemon::checkAndUpdate(std::vector<std::string>& keys) const {\n-  bool ret = true;\n-  for (auto it = keys.begin(); it != keys.end();) {\n-    if (tcpStore_.count(*it) == 0) {\n-      ret = false;\n-      it++;\n-    } else {\n-      it = keys.erase(it);\n+void TCPStoreDaemon::waitHandler(int socket) {\n+  SizeType nargs;\n+  tcputil::recvBytes<SizeType>(socket, &nargs, 1);\n+  std::vector<std::string> keys(nargs);\n+  for (size_t i = 0; i < nargs; i++) {\n+    keys[i] = tcputil::recvString(socket);\n+  }\n+  if (checkKeys(keys)) {\n+    tcputil::sendValue<WaitResponseType>(socket,\n+                                         WaitResponseType::STOP_WAITING);\n+  } else {\n+    for (auto& key : keys) {\n+      waitingSockets_[key].push_back(socket);\n     }\n+    keysAwaited_[socket] = keys.size();\n   }\n-  return ret;\n+}\n+\n+bool TCPStoreDaemon::\n+checkKeys(const std::vector<std::string>& keys) const {", "path": "torch/lib/c10d/TcpStore.cpp", "position": null, "original_position": 242, "commit_id": "ba48f051925b6a9d49113e5d8ca43ebd3f551993", "original_commit_id": "d27c8ec2b5d13b43252852ea940da087dd3a6542", "user": {"login": "pietern", "id": 9845, "node_id": "MDQ6VXNlcjk4NDU=", "avatar_url": "https://avatars3.githubusercontent.com/u/9845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietern", "html_url": "https://github.com/pietern", "followers_url": "https://api.github.com/users/pietern/followers", "following_url": "https://api.github.com/users/pietern/following{/other_user}", "gists_url": "https://api.github.com/users/pietern/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietern/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietern/subscriptions", "organizations_url": "https://api.github.com/users/pietern/orgs", "repos_url": "https://api.github.com/users/pietern/repos", "events_url": "https://api.github.com/users/pietern/events{/privacy}", "received_events_url": "https://api.github.com/users/pietern/received_events", "type": "User", "site_admin": false}, "body": "One line or continuation with argument", "created_at": "2018-05-16T23:44:20Z", "updated_at": "2018-11-23T15:44:12Z", "html_url": "https://github.com/pytorch/pytorch/pull/7560#discussion_r188803527", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/7560", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/188803527"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/7560#discussion_r188803527"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/7560"}}, "body_html": "<p>One line or continuation with argument</p>", "body_text": "One line or continuation with argument"}