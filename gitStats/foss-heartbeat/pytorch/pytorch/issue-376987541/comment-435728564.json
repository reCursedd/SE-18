{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/435728564", "html_url": "https://github.com/pytorch/pytorch/issues/13524#issuecomment-435728564", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/13524", "id": 435728564, "node_id": "MDEyOklzc3VlQ29tbWVudDQzNTcyODU2NA==", "user": {"login": "nimning", "id": 7147016, "node_id": "MDQ6VXNlcjcxNDcwMTY=", "avatar_url": "https://avatars2.githubusercontent.com/u/7147016?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nimning", "html_url": "https://github.com/nimning", "followers_url": "https://api.github.com/users/nimning/followers", "following_url": "https://api.github.com/users/nimning/following{/other_user}", "gists_url": "https://api.github.com/users/nimning/gists{/gist_id}", "starred_url": "https://api.github.com/users/nimning/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nimning/subscriptions", "organizations_url": "https://api.github.com/users/nimning/orgs", "repos_url": "https://api.github.com/users/nimning/repos", "events_url": "https://api.github.com/users/nimning/events{/privacy}", "received_events_url": "https://api.github.com/users/nimning/received_events", "type": "User", "site_admin": false}, "created_at": "2018-11-05T01:22:39Z", "updated_at": "2018-11-05T01:22:39Z", "author_association": "NONE", "body_html": "<p>Hi Peter</p>\n<p>Yes, it indeed works when I rewrite the code with if protection in the following way. Thanks!</p>\n<p>My question is why the issue occurs only when I use the customized loader in the 'datasetfolder'. If I use the ImageFolders with the default loader, this is no dead loop  even without the 'if' protection  and can be successfully run within jupyter notebook.</p>\n<pre><code>\n# coding: utf-8\n\n# In[ ]:\n\n\nfrom __future__ import print_function, division\n\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\nfrom torch.optim import lr_scheduler\nimport numpy as np\nimport torchvision\nfrom torchvision import datasets, models, transforms\nfrom sklearn.utils.class_weight import compute_class_weight\nimport matplotlib.pyplot as plt\nimport torch.nn.functional as F\nimport time\nimport os\nimport copy\nimport sys\nfrom torchvision.datasets import ImageFolder\n\nplt.ion()\n\n\n# In[ ]:\n\n\ndef my_loader(path):\n    from torchvision import get_image_backend\n    from PIL import Image\n    \n                \n    def my_pil_loader(path):\n        print (\"loading {}\".format(path))\n        try:\n            with open(path, 'rb') as f:\n                img = Image.open(f)\n                return img.convert('RGB')\n        except:\n            print('fail to load {} using PIL'.format(img))\n\n    if get_image_backend() == 'accimage':\n        print('loading {} uses accimage'.format(path))\n        try:\n            return accimage_loader(path)\n        except IOError:\n            print('fail to load {} using accimage, instead using PIL'.format(path))\n            return my_pil_loader(path)\n    else:\n        print('{} uses PIL'.format(path))\n        return my_pil_loader(path)\n\n\n# In[ ]:\n\n\ndef main():\n    data_transforms = transforms.Compose([transforms.Resize(300),\n            transforms.CenterCrop(299),\n            transforms.RandomHorizontalFlip(),\n            transforms.ToTensor(),\n            transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])])\n    \n    img_extensions = ['.jpg', '.jpeg', '.png', '.ppm', '.bmp', '.pgm', '.tif', '.gif', '.octet-stream']\n    \n    data_dir = './debug/'\n    batch_size = 32\n\n    image_datasets = datasets.DatasetFolder(data_dir, my_loader, img_extensions,\n                                              data_transforms)\n    dataloaders = torch.utils.data.DataLoader(image_datasets, batch_size=batch_size, shuffle=True, num_workers=4)\n    \n    index = 0\n    for inputs, labels in dataloaders:\n        print(index)\n        print('inputs')\n        print(inputs.size())\n        print('labels')\n        print(labels.size())\n\n\n# In[ ]:\n\n\nif __name__ == '__main__':\n    main()\n\n\n</code></pre>", "body_text": "Hi Peter\nYes, it indeed works when I rewrite the code with if protection in the following way. Thanks!\nMy question is why the issue occurs only when I use the customized loader in the 'datasetfolder'. If I use the ImageFolders with the default loader, this is no dead loop  even without the 'if' protection  and can be successfully run within jupyter notebook.\n\n# coding: utf-8\n\n# In[ ]:\n\n\nfrom __future__ import print_function, division\n\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\nfrom torch.optim import lr_scheduler\nimport numpy as np\nimport torchvision\nfrom torchvision import datasets, models, transforms\nfrom sklearn.utils.class_weight import compute_class_weight\nimport matplotlib.pyplot as plt\nimport torch.nn.functional as F\nimport time\nimport os\nimport copy\nimport sys\nfrom torchvision.datasets import ImageFolder\n\nplt.ion()\n\n\n# In[ ]:\n\n\ndef my_loader(path):\n    from torchvision import get_image_backend\n    from PIL import Image\n    \n                \n    def my_pil_loader(path):\n        print (\"loading {}\".format(path))\n        try:\n            with open(path, 'rb') as f:\n                img = Image.open(f)\n                return img.convert('RGB')\n        except:\n            print('fail to load {} using PIL'.format(img))\n\n    if get_image_backend() == 'accimage':\n        print('loading {} uses accimage'.format(path))\n        try:\n            return accimage_loader(path)\n        except IOError:\n            print('fail to load {} using accimage, instead using PIL'.format(path))\n            return my_pil_loader(path)\n    else:\n        print('{} uses PIL'.format(path))\n        return my_pil_loader(path)\n\n\n# In[ ]:\n\n\ndef main():\n    data_transforms = transforms.Compose([transforms.Resize(300),\n            transforms.CenterCrop(299),\n            transforms.RandomHorizontalFlip(),\n            transforms.ToTensor(),\n            transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])])\n    \n    img_extensions = ['.jpg', '.jpeg', '.png', '.ppm', '.bmp', '.pgm', '.tif', '.gif', '.octet-stream']\n    \n    data_dir = './debug/'\n    batch_size = 32\n\n    image_datasets = datasets.DatasetFolder(data_dir, my_loader, img_extensions,\n                                              data_transforms)\n    dataloaders = torch.utils.data.DataLoader(image_datasets, batch_size=batch_size, shuffle=True, num_workers=4)\n    \n    index = 0\n    for inputs, labels in dataloaders:\n        print(index)\n        print('inputs')\n        print(inputs.size())\n        print('labels')\n        print(labels.size())\n\n\n# In[ ]:\n\n\nif __name__ == '__main__':\n    main()", "body": "Hi Peter\r\n\r\nYes, it indeed works when I rewrite the code with if protection in the following way. Thanks!\r\n\r\nMy question is why the issue occurs only when I use the customized loader in the 'datasetfolder'. If I use the ImageFolders with the default loader, this is no dead loop  even without the 'if' protection  and can be successfully run within jupyter notebook. \r\n\r\n```\r\n\r\n# coding: utf-8\r\n\r\n# In[ ]:\r\n\r\n\r\nfrom __future__ import print_function, division\r\n\r\nimport torch\r\nimport torch.nn as nn\r\nimport torch.optim as optim\r\nfrom torch.optim import lr_scheduler\r\nimport numpy as np\r\nimport torchvision\r\nfrom torchvision import datasets, models, transforms\r\nfrom sklearn.utils.class_weight import compute_class_weight\r\nimport matplotlib.pyplot as plt\r\nimport torch.nn.functional as F\r\nimport time\r\nimport os\r\nimport copy\r\nimport sys\r\nfrom torchvision.datasets import ImageFolder\r\n\r\nplt.ion()\r\n\r\n\r\n# In[ ]:\r\n\r\n\r\ndef my_loader(path):\r\n    from torchvision import get_image_backend\r\n    from PIL import Image\r\n    \r\n                \r\n    def my_pil_loader(path):\r\n        print (\"loading {}\".format(path))\r\n        try:\r\n            with open(path, 'rb') as f:\r\n                img = Image.open(f)\r\n                return img.convert('RGB')\r\n        except:\r\n            print('fail to load {} using PIL'.format(img))\r\n\r\n    if get_image_backend() == 'accimage':\r\n        print('loading {} uses accimage'.format(path))\r\n        try:\r\n            return accimage_loader(path)\r\n        except IOError:\r\n            print('fail to load {} using accimage, instead using PIL'.format(path))\r\n            return my_pil_loader(path)\r\n    else:\r\n        print('{} uses PIL'.format(path))\r\n        return my_pil_loader(path)\r\n\r\n\r\n# In[ ]:\r\n\r\n\r\ndef main():\r\n    data_transforms = transforms.Compose([transforms.Resize(300),\r\n            transforms.CenterCrop(299),\r\n            transforms.RandomHorizontalFlip(),\r\n            transforms.ToTensor(),\r\n            transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])])\r\n    \r\n    img_extensions = ['.jpg', '.jpeg', '.png', '.ppm', '.bmp', '.pgm', '.tif', '.gif', '.octet-stream']\r\n    \r\n    data_dir = './debug/'\r\n    batch_size = 32\r\n\r\n    image_datasets = datasets.DatasetFolder(data_dir, my_loader, img_extensions,\r\n                                              data_transforms)\r\n    dataloaders = torch.utils.data.DataLoader(image_datasets, batch_size=batch_size, shuffle=True, num_workers=4)\r\n    \r\n    index = 0\r\n    for inputs, labels in dataloaders:\r\n        print(index)\r\n        print('inputs')\r\n        print(inputs.size())\r\n        print('labels')\r\n        print(labels.size())\r\n\r\n\r\n# In[ ]:\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\r\n\r\n\r\n```"}