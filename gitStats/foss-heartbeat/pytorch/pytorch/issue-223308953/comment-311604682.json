{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/311604682", "html_url": "https://github.com/pytorch/pytorch/issues/1318#issuecomment-311604682", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/1318", "id": 311604682, "node_id": "MDEyOklzc3VlQ29tbWVudDMxMTYwNDY4Mg==", "user": {"login": "albanD", "id": 6359743, "node_id": "MDQ6VXNlcjYzNTk3NDM=", "avatar_url": "https://avatars3.githubusercontent.com/u/6359743?v=4", "gravatar_id": "", "url": "https://api.github.com/users/albanD", "html_url": "https://github.com/albanD", "followers_url": "https://api.github.com/users/albanD/followers", "following_url": "https://api.github.com/users/albanD/following{/other_user}", "gists_url": "https://api.github.com/users/albanD/gists{/gist_id}", "starred_url": "https://api.github.com/users/albanD/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/albanD/subscriptions", "organizations_url": "https://api.github.com/users/albanD/orgs", "repos_url": "https://api.github.com/users/albanD/repos", "events_url": "https://api.github.com/users/albanD/events{/privacy}", "received_events_url": "https://api.github.com/users/albanD/received_events", "type": "User", "site_admin": false}, "created_at": "2017-06-28T09:19:19Z", "updated_at": "2017-06-28T14:55:23Z", "author_association": "COLLABORATOR", "body_html": "<ol>\n<li>True, I removed it and fixed the comment. Thanks for that.</li>\n<li>Not sure to see what you mean here. Since <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"233282814\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/1705\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/pytorch/pytorch/pull/1705/hovercard\" href=\"https://github.com/pytorch/pytorch/pull/1705\">#1705</a> , if you have <code>f(x) -&gt; (a, b)</code>, then <code>a</code> and <code>b</code> hold two different refcount to <code>f</code> via two different <code>shared_ptr</code>s. The case where <code>var.grad_fn.use_count &gt; 1</code> is going to be when we use <code>a</code> or <code>b</code> as input in another function <a href=\"https://github.com/pytorch/pytorch/blob/4c35c630eca9a7a3fbfc8f4bc72ea2fd5ba0dd05/torch/csrc/autograd/function.cpp#L22\">here</a> and so the shared pointer will be reused.<br>\nThe problem with this solution is that it may be possible to create uncollectable cycles by linking a <code>Variable</code> which is not a direct output of a <code>Function</code> (but which is later in the cpp graph) with this Function is a cycle.<br>\nThe only to avoid this would be to traverse the whole autograd graph when visiting but that leads to a lot more troubles as discussed above.</li>\n</ol>", "body_text": "True, I removed it and fixed the comment. Thanks for that.\nNot sure to see what you mean here. Since #1705 , if you have f(x) -> (a, b), then a and b hold two different refcount to f via two different shared_ptrs. The case where var.grad_fn.use_count > 1 is going to be when we use a or b as input in another function here and so the shared pointer will be reused.\nThe problem with this solution is that it may be possible to create uncollectable cycles by linking a Variable which is not a direct output of a Function (but which is later in the cpp graph) with this Function is a cycle.\nThe only to avoid this would be to traverse the whole autograd graph when visiting but that leads to a lot more troubles as discussed above.", "body": "1. True, I removed it and fixed the comment. Thanks for that.\r\n2. Not sure to see what you mean here. Since #1705 , if you have `f(x) -> (a, b)`, then `a` and `b` hold two different refcount to `f` via two different `shared_ptr`s. The case where `var.grad_fn.use_count > 1` is going to be when we use `a` or `b` as input in another function [here](https://github.com/pytorch/pytorch/blob/4c35c630eca9a7a3fbfc8f4bc72ea2fd5ba0dd05/torch/csrc/autograd/function.cpp#L22) and so the shared pointer will be reused.\r\nThe problem with this solution is that it may be possible to create uncollectable cycles by linking a `Variable` which is not a direct output of a `Function` (but which is later in the cpp graph) with this Function is a cycle.\r\nThe only to avoid this would be to traverse the whole autograd graph when visiting but that leads to a lot more troubles as discussed above.\r\n"}