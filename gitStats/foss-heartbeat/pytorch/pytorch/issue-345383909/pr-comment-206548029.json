{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/206548029", "pull_request_review_id": 141979219, "id": 206548029, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwNjU0ODAyOQ==", "diff_hunk": "@@ -0,0 +1,780 @@\n+#include \"ATen/ATen.h\"\n+#include \"ATen/NativeFunctions.h\"\n+#include \"ATen/detail/CUDAHooksInterface.h\"\n+#include \"ATen/native/GridSampler.h\"\n+\n+#ifdef _OPENMP\n+#include <omp.h>\n+#endif\n+\n+namespace at { namespace native {\n+\n+using at::native::detail::GridSamplerInterpolation;\n+using at::native::detail::GridSamplerPadding;\n+\n+namespace {\n+  static inline int64_t clip_coordinates(int64_t in, int64_t clip_limit) {\n+    return std::min(clip_limit - 1, std::max(in, static_cast<int64_t>(0)));\n+  }\n+\n+  static inline bool within_bounds_2d(int64_t h, int64_t w, int64_t H, int64_t W) {\n+    return h >= 0 && h < H && w >= 0 && w < W;\n+  }\n+\n+  static inline bool within_bounds_3d(int64_t d, int64_t h, int64_t w, int64_t D, int64_t H, int64_t W) {\n+    return d >= 0 && d < D && h >= 0 && h < H && w >= 0 && w < W;\n+  }\n+\n+  template<typename scalar_t>\n+  static inline void safe_add_2d(scalar_t *data, int64_t h, int64_t w,\n+                                 int64_t sH, int64_t sW, int64_t H, int64_t W,\n+                                 scalar_t delta) {\n+    if (h >= 0 && h < H && w >= 0 && w < W) {\n+      data[h * sH + w * sW] += delta;\n+    }\n+  }\n+\n+  template<typename scalar_t>\n+  static inline void safe_add_3d(scalar_t *data, int64_t d, int64_t h, int64_t w,\n+                                 int64_t sD, int64_t sH, int64_t sW,\n+                                 int64_t D, int64_t H, int64_t W,\n+                                 scalar_t delta) {\n+    if (d >=0 && d < D && h >= 0 && h < H && w >= 0 && w < W) {\n+      data[d * sD + h * sH + w * sW] += delta;\n+    }\n+  }\n+\n+  template<typename scalar_t>\n+  Tensor grid_sampler2d_cpu_impl(const Tensor& input, const Tensor& grid,\n+                                 GridSamplerInterpolation interpolation_mode,\n+                                 GridSamplerPadding padding_mode) {\n+    int64_t N = input.size(0);\n+    int64_t C = input.size(1);\n+    int64_t inp_H = input.size(2);\n+    int64_t inp_W = input.size(3);\n+    int64_t out_H = grid.size(1);\n+    int64_t out_W = grid.size(2);\n+    auto output = at::empty({N, C, out_H, out_W}, input.options());\n+    int64_t inp_sN = input.stride(0);\n+    int64_t inp_sC = input.stride(1);\n+    int64_t inp_sH = input.stride(2);\n+    int64_t inp_sW = input.stride(3);\n+    int64_t grid_sN = grid.stride(0);\n+    int64_t grid_sH = grid.stride(1);\n+    int64_t grid_sW = grid.stride(2);\n+    int64_t grid_sCoor = grid.stride(3);\n+    int64_t out_sN = output.stride(0);\n+    int64_t out_sC = output.stride(1);\n+    int64_t out_sH = output.stride(2);\n+    int64_t out_sW = output.stride(3);\n+    scalar_t *inp_ptr = input.data<scalar_t>();\n+    scalar_t *out_ptr = output.data<scalar_t>();\n+    scalar_t *grid_ptr = grid.data<scalar_t>();\n+    // loop over each output pixel\n+    #ifdef _OPENMP\n+    #pragma omp parallel for\n+    #endif\n+    for (int64_t n = 0; n < N; ++n) {\n+      scalar_t *grid_ptr_N = grid_ptr + n * grid_sN;\n+      scalar_t *inp_ptr_N = inp_ptr + n * inp_sN;\n+      for (int64_t h = 0; h < out_H; ++h) {\n+        for (int64_t w = 0; w < out_W; ++w) {\n+          // get the corresponding input x, y co-ordinates from grid\n+          scalar_t ix = grid_ptr_N[h * grid_sH + w * grid_sW];\n+          scalar_t iy = grid_ptr_N[h * grid_sH + w * grid_sW + grid_sCoor];\n+\n+          // normalize ix, iy from [-1, 1] to [0, inp_W-1] & [0, inp_H-1]\n+          ix = ((ix + 1) / 2) * (inp_W - 1);\n+          iy = ((iy + 1) / 2) * (inp_H - 1);\n+\n+          // get NE, NW, SE, SW pixel values from (x, y)\n+          int64_t ix_nw = static_cast<int64_t>(std::floor(ix));\n+          int64_t iy_nw = static_cast<int64_t>(std::floor(iy));\n+          int64_t ix_ne = ix_nw + 1;\n+          int64_t iy_ne = iy_nw;\n+          int64_t ix_sw = ix_nw;\n+          int64_t iy_sw = iy_nw + 1;\n+          int64_t ix_se = ix_nw + 1;\n+          int64_t iy_se = iy_nw + 1;\n+\n+          // get surfaces to each neighbor:\n+          scalar_t nw = (ix_se - ix)    * (iy_se - iy);\n+          scalar_t ne = (ix    - ix_sw) * (iy_sw - iy);\n+          scalar_t sw = (ix_ne - ix)    * (iy    - iy_ne);\n+          scalar_t se = (ix    - ix_nw) * (iy    - iy_nw);\n+\n+          if (padding_mode == GridSamplerPadding::Border) {\n+            // clip coordinates to image borders\n+            ix_nw = clip_coordinates(ix_nw, inp_W);\n+            iy_nw = clip_coordinates(iy_nw, inp_H);\n+            ix_ne = clip_coordinates(ix_ne, inp_W);\n+            iy_ne = clip_coordinates(iy_ne, inp_H);\n+            ix_sw = clip_coordinates(ix_sw, inp_W);\n+            iy_sw = clip_coordinates(iy_sw, inp_H);\n+            ix_se = clip_coordinates(ix_se, inp_W);\n+            iy_se = clip_coordinates(iy_se, inp_H);\n+          }\n+\n+          // calculate bilinear weighted pixel value and set output pixel\n+          scalar_t *out_ptr_NCHW = out_ptr + n * out_sN + h * out_sH + w * out_sW;\n+          scalar_t *inp_ptr_NC = inp_ptr_N;\n+          for (int c = 0; c < C; ++c, out_ptr_NCHW += out_sC, inp_ptr_NC += inp_sC) {\n+            //   (c, iy_nw, ix_nw) * nw + (c, iy_ne, ix_ne) * ne\n+            // + (c, iy_sw, ix_sw) * sw + (c, iy_se, ix_se) * se\n+            *out_ptr_NCHW = static_cast<scalar_t>(0);\n+            if (padding_mode != GridSamplerPadding::Zeros || within_bounds_2d(iy_nw, ix_nw, inp_H, inp_W)) {\n+              *out_ptr_NCHW += inp_ptr_NC[iy_nw * inp_sH + ix_nw * inp_sW] * nw;\n+            }\n+            if (padding_mode != GridSamplerPadding::Zeros || within_bounds_2d(iy_ne, ix_ne, inp_H, inp_W)) {\n+              *out_ptr_NCHW += inp_ptr_NC[iy_ne * inp_sH + ix_ne * inp_sW] * ne;\n+            }\n+            if (padding_mode != GridSamplerPadding::Zeros || within_bounds_2d(iy_sw, ix_sw, inp_H, inp_W)) {\n+              *out_ptr_NCHW += inp_ptr_NC[iy_sw * inp_sH + ix_sw * inp_sW] * sw;\n+            }\n+            if (padding_mode != GridSamplerPadding::Zeros || within_bounds_2d(iy_se, ix_se, inp_H, inp_W)) {\n+              *out_ptr_NCHW += inp_ptr_NC[iy_se * inp_sH + ix_se * inp_sW] * se;\n+            }\n+          }\n+        }\n+      }\n+    }\n+    return output;\n+  }\n+\n+  template<typename scalar_t>\n+  Tensor grid_sampler3d_cpu_impl(const Tensor& input, const Tensor& grid,\n+                                 GridSamplerInterpolation interpolation_mode,\n+                                 GridSamplerPadding padding_mode) {\n+    int64_t N = input.size(0);\n+    int64_t C = input.size(1);\n+    int64_t inp_D = input.size(2);\n+    int64_t inp_H = input.size(3);\n+    int64_t inp_W = input.size(4);\n+    int64_t out_D = grid.size(1);\n+    int64_t out_H = grid.size(2);\n+    int64_t out_W = grid.size(3);\n+    auto output = at::empty({N, C, out_D, out_H, out_W}, input.options());\n+    int64_t inp_sN = input.stride(0);\n+    int64_t inp_sC = input.stride(1);\n+    int64_t inp_sD = input.stride(2);\n+    int64_t inp_sH = input.stride(3);\n+    int64_t inp_sW = input.stride(4);\n+    int64_t grid_sN = grid.stride(0);\n+    int64_t grid_sD = grid.stride(1);\n+    int64_t grid_sH = grid.stride(2);\n+    int64_t grid_sW = grid.stride(3);\n+    int64_t grid_sCoor = grid.stride(4);\n+    int64_t out_sN = output.stride(0);\n+    int64_t out_sC = output.stride(1);\n+    int64_t out_sD = output.stride(2);\n+    int64_t out_sH = output.stride(3);\n+    int64_t out_sW = output.stride(4);\n+    scalar_t *inp_ptr = input.data<scalar_t>();\n+    scalar_t *out_ptr = output.data<scalar_t>();\n+    scalar_t *grid_ptr = grid.data<scalar_t>();\n+    // loop over each output pixel\n+    #ifdef _OPENMP\n+    #pragma omp parallel for\n+    #endif\n+    for (int64_t n = 0; n < N; ++n) {\n+      scalar_t *grid_ptr_N = grid_ptr + n * grid_sN;\n+      scalar_t *inp_ptr_N = inp_ptr + n * inp_sN;\n+      for (int64_t d = 0; d < out_D; ++d) {\n+        for (int64_t h = 0; h < out_H; ++h) {\n+          for (int64_t w = 0; w < out_W; ++w) {\n+            // get the corresponding input x, y, z co-ordinates from grid\n+            scalar_t *grid_ptr_NDHW = grid_ptr_N + d * grid_sD + h * grid_sH + w * grid_sW;", "path": "aten/src/ATen/native/GridSampler.cpp", "position": 186, "original_position": 186, "commit_id": "7acb794792a691f5ebd29a6b634f917536353723", "original_commit_id": "50e624fe8ccd9545cc2bb7d0ce88a6121ac4178a", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "body": "I didn't check that all of the variable names line up.", "created_at": "2018-07-31T14:22:21Z", "updated_at": "2018-11-23T15:48:26Z", "html_url": "https://github.com/pytorch/pytorch/pull/9961#discussion_r206548029", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/9961", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/206548029"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/9961#discussion_r206548029"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/9961"}}, "body_html": "<p>I didn't check that all of the variable names line up.</p>", "body_text": "I didn't check that all of the variable names line up."}