{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/230058691", "pull_request_review_id": 170706429, "id": 230058691, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDA1ODY5MQ==", "diff_hunk": "@@ -0,0 +1,923 @@\n+#pragma once\n+\n+#include <ATen/core/ivalue.h>\n+#include <ATen/core/interned_strings.h>\n+#include <ATen/core/functional.h>\n+#include <ATen/core/Type.h>\n+#include <ATen/core/TensorMethods.h>\n+\n+#include <caffe2/core/common.h>\n+\n+#include <memory>\n+#include <iostream>\n+#include <type_traits>\n+\n+namespace c10 {\n+\n+#define C10_FORALL_TYPES(_) \\\n+_(DynamicType) \\\n+_(TensorType) \\\n+_(CompleteTensorType) \\\n+_(UndefinedTensorType) \\\n+_(TupleType) \\\n+_(ListType) \\\n+_(NumberType) \\\n+_(FloatType) \\\n+_(FutureType) \\\n+_(IntType) \\\n+_(NoneType) \\\n+_(StringType) \\\n+_(GeneratorType) \\\n+_(BoolType) \\\n+_(OptionalType) \\\n+_(VarType) \\\n+_(WorldType)\n+\n+enum class TypeKind {\n+#define DEFINE_TYPE(T) T,\n+  C10_FORALL_TYPES(DEFINE_TYPE)\n+#undef DEFINE_TYPE\n+};\n+\n+struct Type;\n+using TypePtr = std::shared_ptr<Type>;\n+\n+struct CAFFE2_API Type : std::enable_shared_from_this<Type> {\n+private:\n+  TypeKind kind_;\n+  template<typename T>\n+  static std::shared_ptr<T> sliceType(std::shared_ptr<const T> ptr) {\n+    auto result = std::make_shared<typename std::remove_const<T>::type>(*ptr);\n+    // XXX: the line above will correctly slice the struct, and make its runtype\n+    // type exactly equal to T. However, kind_ is a field of Type, so it will simply\n+    // be copied, and we need to fix it in here to match the dynamic type.\n+    result->kind_ = T::Kind;\n+    return result;\n+  }\n+\n+protected:\n+  Type(TypeKind kind)\n+    : kind_(kind) {}\n+\n+public:\n+  virtual bool operator==(const Type& rhs) const = 0;\n+\n+  // subtyping relation. By default, we return true for the case\n+  // when the type is exactly equal\n+  virtual bool isSubtypeOf(const TypePtr rhs) const {\n+    return *this == *rhs;\n+  }\n+\n+  // How this type will appear in FunctionSchema declarations\n+  virtual std::string str() const = 0;\n+\n+  // How this type will appear as if it were a type annotation in Python\n+  // which is sometimes different than how it appears in declarations (e.g. int[] vs List[int])\n+  virtual std::string python_str() const {\n+    return str();\n+  }\n+\n+  TypeKind kind() const {\n+    return kind_;\n+  }\n+\n+  virtual bool requires_grad() const { return false; }\n+\n+  // Dynamically cast this object to the subclass indicated by the\n+  // template variable, returning nullptr if the cast is invalid.\n+  // NOTE: if the cast succeeds, but the casted kind is not the\n+  // run-time kind of the type, we also slice the structure, so\n+  // that assignments of those types to values don't accidentally\n+  // inherit more detailed information from subclasses.\n+  template<typename T>\n+  std::shared_ptr<T> cast() {\n+    auto r = caffe2::dynamic_pointer_cast_if_rtti<T>(shared_from_this());", "path": "aten/src/ATen/core/jit_type.h", "position": 94, "original_position": 94, "commit_id": "d2deaff65f9f2b4fb9a7bfcaccfc4b273a6f0b7b", "original_commit_id": "d2deaff65f9f2b4fb9a7bfcaccfc4b273a6f0b7b", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "body": "I think there are two things going on here.\r\n\r\nFirst, it looks like OS X is being built without `__GXX_RTTI`, which means the non-RTTI case is being triggered, even though the platform does support RTTI.\r\n\r\nSecond, the change you made here doesn't look semantics preserving. You're only allowed to replace a dynamic cast with a `dynamic_pointer_cast_if_rtti` if the cast is unchecked; i.e., we don't check if the pointer is null. But notice immediately below we check if `r` is null or not. That means the non-RTTI case is just totally broken because `r` will never be false.", "created_at": "2018-11-01T14:24:31Z", "updated_at": "2018-11-23T15:53:58Z", "html_url": "https://github.com/pytorch/pytorch/pull/12862#discussion_r230058691", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/12862", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/230058691"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/12862#discussion_r230058691"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/12862"}}, "body_html": "<p>I think there are two things going on here.</p>\n<p>First, it looks like OS X is being built without <code>__GXX_RTTI</code>, which means the non-RTTI case is being triggered, even though the platform does support RTTI.</p>\n<p>Second, the change you made here doesn't look semantics preserving. You're only allowed to replace a dynamic cast with a <code>dynamic_pointer_cast_if_rtti</code> if the cast is unchecked; i.e., we don't check if the pointer is null. But notice immediately below we check if <code>r</code> is null or not. That means the non-RTTI case is just totally broken because <code>r</code> will never be false.</p>", "body_text": "I think there are two things going on here.\nFirst, it looks like OS X is being built without __GXX_RTTI, which means the non-RTTI case is being triggered, even though the platform does support RTTI.\nSecond, the change you made here doesn't look semantics preserving. You're only allowed to replace a dynamic cast with a dynamic_pointer_cast_if_rtti if the cast is unchecked; i.e., we don't check if the pointer is null. But notice immediately below we check if r is null or not. That means the non-RTTI case is just totally broken because r will never be false."}