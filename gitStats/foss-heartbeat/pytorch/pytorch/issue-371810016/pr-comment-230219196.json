{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/230219196", "pull_request_review_id": 170908655, "id": 230219196, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDIxOTE5Ng==", "diff_hunk": "@@ -0,0 +1,923 @@\n+#pragma once\n+\n+#include <ATen/core/ivalue.h>\n+#include <ATen/core/interned_strings.h>\n+#include <ATen/core/functional.h>\n+#include <ATen/core/Type.h>\n+#include <ATen/core/TensorMethods.h>\n+\n+#include <caffe2/core/common.h>\n+\n+#include <memory>\n+#include <iostream>\n+#include <type_traits>\n+\n+namespace c10 {\n+\n+#define C10_FORALL_TYPES(_) \\\n+_(DynamicType) \\\n+_(TensorType) \\\n+_(CompleteTensorType) \\\n+_(UndefinedTensorType) \\\n+_(TupleType) \\\n+_(ListType) \\\n+_(NumberType) \\\n+_(FloatType) \\\n+_(FutureType) \\\n+_(IntType) \\\n+_(NoneType) \\\n+_(StringType) \\\n+_(GeneratorType) \\\n+_(BoolType) \\\n+_(OptionalType) \\\n+_(VarType) \\\n+_(WorldType)\n+\n+enum class TypeKind {\n+#define DEFINE_TYPE(T) T,\n+  C10_FORALL_TYPES(DEFINE_TYPE)\n+#undef DEFINE_TYPE\n+};\n+\n+struct Type;\n+using TypePtr = std::shared_ptr<Type>;\n+\n+struct CAFFE2_API Type : std::enable_shared_from_this<Type> {\n+private:\n+  TypeKind kind_;\n+  template<typename T>\n+  static std::shared_ptr<T> sliceType(std::shared_ptr<const T> ptr) {\n+    auto result = std::make_shared<typename std::remove_const<T>::type>(*ptr);\n+    // XXX: the line above will correctly slice the struct, and make its runtype\n+    // type exactly equal to T. However, kind_ is a field of Type, so it will simply\n+    // be copied, and we need to fix it in here to match the dynamic type.\n+    result->kind_ = T::Kind;\n+    return result;\n+  }\n+\n+protected:\n+  Type(TypeKind kind)\n+    : kind_(kind) {}\n+\n+public:\n+  virtual bool operator==(const Type& rhs) const = 0;\n+\n+  // subtyping relation. By default, we return true for the case\n+  // when the type is exactly equal\n+  virtual bool isSubtypeOf(const TypePtr rhs) const {\n+    return *this == *rhs;\n+  }\n+\n+  // How this type will appear in FunctionSchema declarations\n+  virtual std::string str() const = 0;\n+\n+  // How this type will appear as if it were a type annotation in Python\n+  // which is sometimes different than how it appears in declarations (e.g. int[] vs List[int])\n+  virtual std::string python_str() const {\n+    return str();\n+  }\n+\n+  TypeKind kind() const {\n+    return kind_;\n+  }\n+\n+  virtual bool requires_grad() const { return false; }\n+\n+  // Dynamically cast this object to the subclass indicated by the\n+  // template variable, returning nullptr if the cast is invalid.\n+  // NOTE: if the cast succeeds, but the casted kind is not the\n+  // run-time kind of the type, we also slice the structure, so\n+  // that assignments of those types to values don't accidentally\n+  // inherit more detailed information from subclasses.\n+  template<typename T>\n+  std::shared_ptr<T> cast() {\n+    auto r = caffe2::dynamic_pointer_cast_if_rtti<T>(shared_from_this());", "path": "aten/src/ATen/core/jit_type.h", "position": 94, "original_position": 94, "commit_id": "d2deaff65f9f2b4fb9a7bfcaccfc4b273a6f0b7b", "original_commit_id": "d2deaff65f9f2b4fb9a7bfcaccfc4b273a6f0b7b", "user": {"login": "bwasti", "id": 4842908, "node_id": "MDQ6VXNlcjQ4NDI5MDg=", "avatar_url": "https://avatars2.githubusercontent.com/u/4842908?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bwasti", "html_url": "https://github.com/bwasti", "followers_url": "https://api.github.com/users/bwasti/followers", "following_url": "https://api.github.com/users/bwasti/following{/other_user}", "gists_url": "https://api.github.com/users/bwasti/gists{/gist_id}", "starred_url": "https://api.github.com/users/bwasti/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bwasti/subscriptions", "organizations_url": "https://api.github.com/users/bwasti/orgs", "repos_url": "https://api.github.com/users/bwasti/repos", "events_url": "https://api.github.com/users/bwasti/events{/privacy}", "received_events_url": "https://api.github.com/users/bwasti/received_events", "type": "User", "site_admin": false}, "body": "should I just explicitly check if `T::Kind == kind()` in the case of no RTTI?\r\n\r\nthis still isn't semantics preserving in the case of hierarchy -- unless `kind()` does the LLVM approach where I can write `T::Kind <= kind()`", "created_at": "2018-11-01T22:22:11Z", "updated_at": "2018-11-23T15:54:06Z", "html_url": "https://github.com/pytorch/pytorch/pull/12862#discussion_r230219196", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/12862", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/230219196"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/12862#discussion_r230219196"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/12862"}}, "body_html": "<p>should I just explicitly check if <code>T::Kind == kind()</code> in the case of no RTTI?</p>\n<p>this still isn't semantics preserving in the case of hierarchy -- unless <code>kind()</code> does the LLVM approach where I can write <code>T::Kind &lt;= kind()</code></p>", "body_text": "should I just explicitly check if T::Kind == kind() in the case of no RTTI?\nthis still isn't semantics preserving in the case of hierarchy -- unless kind() does the LLVM approach where I can write T::Kind <= kind()", "in_reply_to_id": 230058691}