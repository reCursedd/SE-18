{"url": "https://api.github.com/repos/pytorch/pytorch/issues/9151", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/9151/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/9151/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/9151/events", "html_url": "https://github.com/pytorch/pytorch/pull/9151", "id": 338079113, "node_id": "MDExOlB1bGxSZXF1ZXN0MTk5MTAyMDk3", "number": 9151, "title": "[C++ API] Make Sequential ref-counted", "user": {"login": "goldsborough", "id": 6429851, "node_id": "MDQ6VXNlcjY0Mjk4NTE=", "avatar_url": "https://avatars3.githubusercontent.com/u/6429851?v=4", "gravatar_id": "", "url": "https://api.github.com/users/goldsborough", "html_url": "https://github.com/goldsborough", "followers_url": "https://api.github.com/users/goldsborough/followers", "following_url": "https://api.github.com/users/goldsborough/following{/other_user}", "gists_url": "https://api.github.com/users/goldsborough/gists{/gist_id}", "starred_url": "https://api.github.com/users/goldsborough/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/goldsborough/subscriptions", "organizations_url": "https://api.github.com/users/goldsborough/orgs", "repos_url": "https://api.github.com/users/goldsborough/repos", "events_url": "https://api.github.com/users/goldsborough/events{/privacy}", "received_events_url": "https://api.github.com/users/goldsborough/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2018-07-03T22:54:59Z", "updated_at": "2018-11-23T15:46:56Z", "closed_at": "2018-07-12T00:26:03Z", "author_association": "CONTRIBUTOR", "pull_request": {"url": "https://api.github.com/repos/pytorch/pytorch/pulls/9151", "html_url": "https://github.com/pytorch/pytorch/pull/9151", "diff_url": "https://github.com/pytorch/pytorch/pull/9151.diff", "patch_url": "https://github.com/pytorch/pytorch/pull/9151.patch"}, "body_html": "<p>In the C++ API, <code>Sequential</code> currently was not refcounted itself, but stored <code>shared_ptr&lt;AnyModule&gt;</code> to get the reference semantics. This is unfortunate because most modules in the API are accessed via <code>-&gt;</code>, e.g. <code>Linear l(1, 2); l-&gt;forward(...);</code>. <code>Sequential</code> was different in that it had value semantics itself, thus was accessed via <code>.</code>.</p>\n<p>This PR makes <code>Sequential</code> store <code>AnyModule</code> (without extra indirection), and uses the same pImpl mechanism we use for all other modules to make <code>Sequential</code> have reference semantics itself. This makes it consistent with the rest of the library. It also removes one level of indirection inside of <code>Sequential</code>, which is cool.</p>\n<p>One thing I had to change was that the <code>ModuleHolder</code> with which the whole pImpl thing is implemented previously did some tricks to make <code>Linear(3, 4)</code> actually construct <code>Linear(LinearOptions(3, 4))</code>. This doesn't work well with <code>Sequential</code> since it takes a variadic parameter pack. Instead, I made <code>ModuleHolder</code> forward all arguments to the underlying module, and then further pushed the trick to forward parameters to modules' options types into the actual Modules. This adds one constructor per Module in the library. This is not something user modules have to do (unless they want this nice forwarding themselves). It makes the code simpler overall.</p>\n<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=13564\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/ezyang\">@ezyang</a> <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=3605224\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/ebetica\">@ebetica</a> <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=4583066\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/apaszke\">@apaszke</a></p>", "body_text": "In the C++ API, Sequential currently was not refcounted itself, but stored shared_ptr<AnyModule> to get the reference semantics. This is unfortunate because most modules in the API are accessed via ->, e.g. Linear l(1, 2); l->forward(...);. Sequential was different in that it had value semantics itself, thus was accessed via ..\nThis PR makes Sequential store AnyModule (without extra indirection), and uses the same pImpl mechanism we use for all other modules to make Sequential have reference semantics itself. This makes it consistent with the rest of the library. It also removes one level of indirection inside of Sequential, which is cool.\nOne thing I had to change was that the ModuleHolder with which the whole pImpl thing is implemented previously did some tricks to make Linear(3, 4) actually construct Linear(LinearOptions(3, 4)). This doesn't work well with Sequential since it takes a variadic parameter pack. Instead, I made ModuleHolder forward all arguments to the underlying module, and then further pushed the trick to forward parameters to modules' options types into the actual Modules. This adds one constructor per Module in the library. This is not something user modules have to do (unless they want this nice forwarding themselves). It makes the code simpler overall.\n@ezyang @ebetica @apaszke", "body": "In the C++ API, `Sequential` currently was not refcounted itself, but stored `shared_ptr<AnyModule>` to get the reference semantics. This is unfortunate because most modules in the API are accessed via `->`, e.g. `Linear l(1, 2); l->forward(...);`. `Sequential` was different in that it had value semantics itself, thus was accessed via `.`.\r\n\r\nThis PR makes `Sequential` store `AnyModule` (without extra indirection), and uses the same pImpl mechanism we use for all other modules to make `Sequential` have reference semantics itself. This makes it consistent with the rest of the library. It also removes one level of indirection inside of `Sequential`, which is cool.\r\n\r\nOne thing I had to change was that the `ModuleHolder` with which the whole pImpl thing is implemented previously did some tricks to make `Linear(3, 4)` actually construct `Linear(LinearOptions(3, 4))`. This doesn't work well with `Sequential` since it takes a variadic parameter pack. Instead, I made `ModuleHolder` forward all arguments to the underlying module, and then further pushed the trick to forward parameters to modules' options types into the actual Modules. This adds one constructor per Module in the library. This is not something user modules have to do (unless they want this nice forwarding themselves). It makes the code simpler overall.\r\n\r\n@ezyang @ebetica @apaszke "}