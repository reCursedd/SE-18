{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/217135754", "pull_request_review_id": 154777895, "id": 217135754, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNzEzNTc1NA==", "diff_hunk": "@@ -481,6 +481,8 @@ std::string encodeRHS(Node * n) {\n     {aten::add, \"${0} + ${2}*${1}\"},\n     {aten::sub, \"(${0} - ${2}*${1})\"},\n     {aten::rand_like, \"uniform(rnd())\"},\n+    //min, max\n+    {aten::clamp, \"fmaxf(fminf(${0}, ${2}), ${1})\"},", "path": "torch/csrc/jit/fusion_compiler.cpp", "position": null, "original_position": 5, "commit_id": "30be1e7983687052b37e4261489878d50e223a3b", "original_commit_id": "838e55a0027b071772c9157bf2086be6c81de708", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "body": "Well we don't need to maintain the same exact NaN semantics in the JIT I think (it's kind of UB for most of our ops), but we don't need to use the intrinsics, because they might end up compiling to code slower than one that uses simple comparisons.", "created_at": "2018-09-12T18:11:24Z", "updated_at": "2018-11-23T15:51:11Z", "html_url": "https://github.com/pytorch/pytorch/pull/11574#discussion_r217135754", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/11574", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/217135754"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/11574#discussion_r217135754"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/11574"}}, "body_html": "<p>Well we don't need to maintain the same exact NaN semantics in the JIT I think (it's kind of UB for most of our ops), but we don't need to use the intrinsics, because they might end up compiling to code slower than one that uses simple comparisons.</p>", "body_text": "Well we don't need to maintain the same exact NaN semantics in the JIT I think (it's kind of UB for most of our ops), but we don't need to use the intrinsics, because they might end up compiling to code slower than one that uses simple comparisons.", "in_reply_to_id": 217096947}