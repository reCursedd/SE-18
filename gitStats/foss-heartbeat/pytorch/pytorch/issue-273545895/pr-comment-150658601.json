{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/150658601", "pull_request_review_id": 76241804, "id": 150658601, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1MDY1ODYwMQ==", "diff_hunk": "@@ -0,0 +1,210 @@\n+#include \"ATen/native/NativeFunctions.h\"\n+#include <cfloat>\n+\n+namespace at {\n+namespace native {\n+\n+__host__ __device__ __forceinline__ float fmin(float a, float b) {\n+  return a > b ? b : a;\n+}\n+\n+__host__ __device__ __forceinline__ float fmax(float a, float b) {\n+  return a > b ? a : b;\n+}\n+\n+template <typename T>\n+__global__ void RoiPooling2d_forward_kernel(\n+  const int outputElements,\n+  const T *input,\n+  const T *rois,\n+  const T spatialScale,\n+  const int inputChannels,\n+  const int inputHeight,\n+  const int inputWidth,\n+  const int pooledHeight,\n+  const int pooledWidth,\n+  T *output,\n+  int *argmaxes)\n+{\n+  for (int linearIndex = blockIdx.x * blockDim.x + threadIdx.x;\n+       linearIndex < outputElements;\n+       linearIndex += blockDim.x * gridDim.x)\n+  {\n+    // Calculate position in output Tensor, i.e. a specific combination\n+    // of proposal, channel, pool height and pool width\n+    // TODO: write to improve performance by minimize computation\n+    int pw = linearIndex % pooledWidth;\n+    int ph = (linearIndex / pooledWidth) % pooledHeight;\n+    int ch = (linearIndex / pooledWidth / pooledHeight) % inputChannels;\n+    int proposal = linearIndex / pooledWidth / pooledHeight / inputChannels;\n+\n+    // Get particular proposal data\n+    const T *roisOffset = rois + (proposal * 5);\n+    int n = roisOffset[0];\n+    int startWidth = llrintf(roisOffset[1] * spatialScale);\n+    int startHeight = llrintf(roisOffset[2] * spatialScale);\n+    int endWidth = llrintf(roisOffset[3] * spatialScale);\n+    int endHeight = llrintf(roisOffset[4] * spatialScale);\n+\n+    // TODO: fix malformed RoIs to be 1x1\n+\n+    int roiHeight = endHeight - startHeight;\n+    int roiWidth = endWidth - startWidth;\n+\n+    // Calculate size of tile based on the size of this particular RoI and the\n+    // output size\n+    T tileHeight = static_cast<T>(roiHeight) / static_cast<T>(pooledHeight);\n+    T tileWidth = static_cast<T>(roiWidth) / static_cast<T>(pooledWidth);\n+\n+    // Calculate offset into the pooled region\n+    int tileHStart = static_cast<int>(floorf(static_cast<T>(ph) * tileHeight));\n+    int tileWStart = static_cast<int>(floorf(static_cast<T>(pw) * tileWidth));\n+    int tileHEnd = static_cast<int>(ceilf(static_cast<T>(ph + 1) * tileHeight));\n+    int tileWEnd = static_cast<int>(ceilf(static_cast<T>(pw + 1) * tileWidth));", "path": "aten/src/ATen/native/cuda/NativeFunctionsCuda.cu", "position": 63, "original_position": 63, "commit_id": "63ed778c9072b62a38365a69636e3b78e29e031f", "original_commit_id": "65aad6e9cd71f8a45579a8c85af01f8444b2c87d", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "body": "BTW using floats for indexing is a risky thing. I think it's better to coordinate integer multiplication/division to get floor and ceil out of the box. Here, you could replace it with this:\r\n```cpp\r\nint tileHStart = (ph * roiHeight) / pooledHeight;\r\n...\r\nint tileHEnd = ((ph + 1) * roiHeight + pooledHeight - 1) / pooledHeight; \r\n```", "created_at": "2017-11-13T20:41:25Z", "updated_at": "2018-11-23T15:36:27Z", "html_url": "https://github.com/pytorch/pytorch/pull/3672#discussion_r150658601", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/3672", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/150658601"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/3672#discussion_r150658601"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/3672"}}, "body_html": "<p>BTW using floats for indexing is a risky thing. I think it's better to coordinate integer multiplication/division to get floor and ceil out of the box. Here, you could replace it with this:</p>\n<div class=\"highlight highlight-source-c++\"><pre><span class=\"pl-k\">int</span> tileHStart = (ph * roiHeight) / pooledHeight;\n...\n<span class=\"pl-k\">int</span> tileHEnd = ((ph + <span class=\"pl-c1\">1</span>) * roiHeight + pooledHeight - <span class=\"pl-c1\">1</span>) / pooledHeight; </pre></div>", "body_text": "BTW using floats for indexing is a risky thing. I think it's better to coordinate integer multiplication/division to get floor and ceil out of the box. Here, you could replace it with this:\nint tileHStart = (ph * roiHeight) / pooledHeight;\n...\nint tileHEnd = ((ph + 1) * roiHeight + pooledHeight - 1) / pooledHeight;"}