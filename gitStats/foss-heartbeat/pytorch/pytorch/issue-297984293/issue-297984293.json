{"url": "https://api.github.com/repos/pytorch/pytorch/issues/5283", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/5283/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/5283/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/5283/events", "html_url": "https://github.com/pytorch/pytorch/issues/5283", "id": 297984293, "node_id": "MDU6SXNzdWUyOTc5ODQyOTM=", "number": 5283, "title": "Turn on ASAN in CI", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 1, "created_at": "2018-02-17T06:40:33Z", "updated_at": "2018-03-01T19:28:45Z", "closed_at": "2018-03-01T19:28:44Z", "author_association": "CONTRIBUTOR", "body_html": "<p>This is a tracking issue for turning on address sanitizer in our CI, so we can more easily catch memory corruption errors. These errors can be especially pernicious, because memory corruption often results in nondeterministic failures, or failures which only occur on certain platforms (e.g., Windows) because memory layout is different.</p>\n<p>As a user, it is somewhat difficult to operate address sanitizer correctly with PyTorch, because (1) PyTorch historically did not propagate <code>CFLAGS</code> to libraries (fixed in <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"297656335\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/5269\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/pytorch/pytorch/pull/5269/hovercard\" href=\"https://github.com/pytorch/pytorch/pull/5269\">#5269</a>) and (2) PyTorch compiled with ASAN will be dynamically loaded, which means you must <code>LD_PRELOAD</code> the ASAN dynamic library before running Python. This is an error-prone process because there are usually multiple copies of <code>libasan.so</code> on your system, one per compiler toolchain, and there is no obvious indication which library the compiler is expecting to be linked against (asked in <a href=\"https://stackoverflow.com/questions/48833176/get-location-of-libasan-from-gcc-clang\" rel=\"nofollow\">https://stackoverflow.com/questions/48833176/get-location-of-libasan-from-gcc-clang</a>)</p>\n<p>Supposing you overcome all of these problems. Then you will have an ASAN build of PyTorch which is sufficient to catch bugs, if you have a reproducing test case. However, if we intend to run ASAN in CI, we would like to run ASAN on the <em>entirety</em> of our test suite. However, our C code is varied and interesting enough that I have managed to cause ASAN bugs in a number of different configurations.</p>\n<p><strong>gcc 4.8.5 20150623 (Red Hat 4.8.5-16).</strong> This is the default devgpu GCC. You have to <code>yum install libasan</code> to get the shared library you need at <code>/usr/lib64/libasan.so.0</code> but it has not raised spurious problems as far as I can tell.</p>\n<p><strong>gcc (Ubuntu 4.8.5-2ubuntu1~14.04.1) 4.8.5</strong> This GCC (same version, no less) from Ubuntu triggers an CHECK failure in ASAN:</p>\n<pre><code>test_AdaptiveMaxPool1d_indices (__main__.TestNN) ... ==7948==AddressSanitizer CHECK failed: ../../../../src/libsanitizer/asan/asan_interceptors.cc:384 \"((__interception::real___cxa_throw)) != (0)\" (0x0, 0x0)\n    #0 0x7fbb6a5b0bc5  (/usr/lib/x86_64-linux-gnu/libasan.so.4+0xe4bc5)\n    #1 0x7fbb6a5cd8f5 in __sanitizer::CheckFailed(char const*, int, char const*, unsigned long long, unsigned long long) (/usr/lib/x86_64-linux-gnu/libasan.so.4+0x1018f5)\n    #2 0x7fbb6a503e8c in __interceptor___cxa_throw (/usr/lib/x86_64-linux-gnu/libasan.so.4+0x37e8c)\n    #3 0x7fbb4b31c496 in torch::autograd::SavedVariable::unpack(std::shared_ptr&lt;torch::autograd::Function&gt;) const torch/csrc/autograd/saved_variable.cpp:42\n</code></pre>\n<p>This problem also occurred with <strong>gcc-7 (Ubuntu 7.2.0-1ubuntu1~14.04) 7.2.0</strong>. Upstream bug filed at <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=84428\" rel=\"nofollow\">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=84428</a></p>\n<p><strong>gcc (Ubuntu 5.4.0-6ubuntu1~16.04.6) 5.4.0 20160609.</strong></p>\n<p>This one had troubles with the shadow mapping.</p>\n<pre><code>jenkins@ff742997f986:~/pytorch-1$ ASAN_OPTIONS=protect_shadow_gap=0 LD_PRELOAD=/usr/lib/x86_64-linux\n-gnu/libasan.so.2 python test/test_nn.py -v TestNN.test_AdaptiveMaxPool1d_indices\n==4890==Shadow memory range interleaves with an existing memory mapping. ASan cannot proceed correctly. ABORTING.\n==4890==ASan shadow was supposed to be located in the [0x00007fff7000-0x10007fff7fff] range.\n==4890==Process memory map follows:\n        0x00007fff7000-0x00008fff7000\n        0x00008fff7000-0x02008fff7000\n        0x02008fff7000-0x10007fff8000\n</code></pre>\n<p><strong>clang version 3.9.1-4ubuntu3~14.04.3 (tags/RELEASE_391/rc2)</strong></p>\n<p><code>-fsanitize=address</code> does not work at all:</p>\n<pre><code>jenkins@37ecc4612171:~/pytorch$ clang-3.9 -fsanitize=address test.c             \n                                 \n/usr/bin/ld: /usr/lib/llvm-3.9/bin/../lib/clang/3.9.1/lib/linux/libclang_rt.asan\n-x86_64.a(asan_allocator.cc.o): unrecognized relocation (0x2a) in section `.text\n'\n/usr/bin/ld: final link failed: Bad value\n</code></pre>\n<p>Filed for Ubuntu at <a href=\"https://bugs.launchpad.net/ubuntu/+source/llvm-toolchain-3.9/+bug/1750099\" rel=\"nofollow\">https://bugs.launchpad.net/ubuntu/+source/llvm-toolchain-3.9/+bug/1750099</a></p>\n<p><strong>clang version 5.0.0-3~16.04.1 (tags/RELEASE_500/final)</strong> This one also has the \"Shadow memory range interleaves with an existing memory mapping\" error if you just pass <code>CFLAGS=-fsanitize=address</code>, but I managed to diagnose the underlying issue and solve the problem: <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"298456944\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/google/sanitizers/issues/918\" data-hovercard-type=\"issue\" data-hovercard-url=\"/google/sanitizers/issues/918/hovercard\" href=\"https://github.com/google/sanitizers/issues/918\">google/sanitizers#918</a></p>\n<hr>\n<p>Based on the situation, I think the correct plan is to plan a clang build on Xenial with ASAN enabled (with the correct parameters.) This will also help us test clang on some more configurations than what our OS X builds are doing.</p>\n<p>P.S. One alternative strategy, which may be profitable considering the difficulty of getting ASAN to work on these platforms, is to roll our own poor man versions of ASAN.  This can be quite done by we can manually add redzones around all of our allocations, and then check if the redzone was clobbered when we free. This won't be able to determine the memory corruption as precisely ASAN (you'll only find out it was clobbered at free time) but it would be portable and always available, when you suspect memory corruption. Given that the clang builds seem to now be working, I don't advise going this route.</p>", "body_text": "This is a tracking issue for turning on address sanitizer in our CI, so we can more easily catch memory corruption errors. These errors can be especially pernicious, because memory corruption often results in nondeterministic failures, or failures which only occur on certain platforms (e.g., Windows) because memory layout is different.\nAs a user, it is somewhat difficult to operate address sanitizer correctly with PyTorch, because (1) PyTorch historically did not propagate CFLAGS to libraries (fixed in #5269) and (2) PyTorch compiled with ASAN will be dynamically loaded, which means you must LD_PRELOAD the ASAN dynamic library before running Python. This is an error-prone process because there are usually multiple copies of libasan.so on your system, one per compiler toolchain, and there is no obvious indication which library the compiler is expecting to be linked against (asked in https://stackoverflow.com/questions/48833176/get-location-of-libasan-from-gcc-clang)\nSupposing you overcome all of these problems. Then you will have an ASAN build of PyTorch which is sufficient to catch bugs, if you have a reproducing test case. However, if we intend to run ASAN in CI, we would like to run ASAN on the entirety of our test suite. However, our C code is varied and interesting enough that I have managed to cause ASAN bugs in a number of different configurations.\ngcc 4.8.5 20150623 (Red Hat 4.8.5-16). This is the default devgpu GCC. You have to yum install libasan to get the shared library you need at /usr/lib64/libasan.so.0 but it has not raised spurious problems as far as I can tell.\ngcc (Ubuntu 4.8.5-2ubuntu1~14.04.1) 4.8.5 This GCC (same version, no less) from Ubuntu triggers an CHECK failure in ASAN:\ntest_AdaptiveMaxPool1d_indices (__main__.TestNN) ... ==7948==AddressSanitizer CHECK failed: ../../../../src/libsanitizer/asan/asan_interceptors.cc:384 \"((__interception::real___cxa_throw)) != (0)\" (0x0, 0x0)\n    #0 0x7fbb6a5b0bc5  (/usr/lib/x86_64-linux-gnu/libasan.so.4+0xe4bc5)\n    #1 0x7fbb6a5cd8f5 in __sanitizer::CheckFailed(char const*, int, char const*, unsigned long long, unsigned long long) (/usr/lib/x86_64-linux-gnu/libasan.so.4+0x1018f5)\n    #2 0x7fbb6a503e8c in __interceptor___cxa_throw (/usr/lib/x86_64-linux-gnu/libasan.so.4+0x37e8c)\n    #3 0x7fbb4b31c496 in torch::autograd::SavedVariable::unpack(std::shared_ptr<torch::autograd::Function>) const torch/csrc/autograd/saved_variable.cpp:42\n\nThis problem also occurred with gcc-7 (Ubuntu 7.2.0-1ubuntu1~14.04) 7.2.0. Upstream bug filed at https://gcc.gnu.org/bugzilla/show_bug.cgi?id=84428\ngcc (Ubuntu 5.4.0-6ubuntu1~16.04.6) 5.4.0 20160609.\nThis one had troubles with the shadow mapping.\njenkins@ff742997f986:~/pytorch-1$ ASAN_OPTIONS=protect_shadow_gap=0 LD_PRELOAD=/usr/lib/x86_64-linux\n-gnu/libasan.so.2 python test/test_nn.py -v TestNN.test_AdaptiveMaxPool1d_indices\n==4890==Shadow memory range interleaves with an existing memory mapping. ASan cannot proceed correctly. ABORTING.\n==4890==ASan shadow was supposed to be located in the [0x00007fff7000-0x10007fff7fff] range.\n==4890==Process memory map follows:\n        0x00007fff7000-0x00008fff7000\n        0x00008fff7000-0x02008fff7000\n        0x02008fff7000-0x10007fff8000\n\nclang version 3.9.1-4ubuntu3~14.04.3 (tags/RELEASE_391/rc2)\n-fsanitize=address does not work at all:\njenkins@37ecc4612171:~/pytorch$ clang-3.9 -fsanitize=address test.c             \n                                 \n/usr/bin/ld: /usr/lib/llvm-3.9/bin/../lib/clang/3.9.1/lib/linux/libclang_rt.asan\n-x86_64.a(asan_allocator.cc.o): unrecognized relocation (0x2a) in section `.text\n'\n/usr/bin/ld: final link failed: Bad value\n\nFiled for Ubuntu at https://bugs.launchpad.net/ubuntu/+source/llvm-toolchain-3.9/+bug/1750099\nclang version 5.0.0-3~16.04.1 (tags/RELEASE_500/final) This one also has the \"Shadow memory range interleaves with an existing memory mapping\" error if you just pass CFLAGS=-fsanitize=address, but I managed to diagnose the underlying issue and solve the problem: google/sanitizers#918\n\nBased on the situation, I think the correct plan is to plan a clang build on Xenial with ASAN enabled (with the correct parameters.) This will also help us test clang on some more configurations than what our OS X builds are doing.\nP.S. One alternative strategy, which may be profitable considering the difficulty of getting ASAN to work on these platforms, is to roll our own poor man versions of ASAN.  This can be quite done by we can manually add redzones around all of our allocations, and then check if the redzone was clobbered when we free. This won't be able to determine the memory corruption as precisely ASAN (you'll only find out it was clobbered at free time) but it would be portable and always available, when you suspect memory corruption. Given that the clang builds seem to now be working, I don't advise going this route.", "body": "This is a tracking issue for turning on address sanitizer in our CI, so we can more easily catch memory corruption errors. These errors can be especially pernicious, because memory corruption often results in nondeterministic failures, or failures which only occur on certain platforms (e.g., Windows) because memory layout is different.\r\n\r\nAs a user, it is somewhat difficult to operate address sanitizer correctly with PyTorch, because (1) PyTorch historically did not propagate `CFLAGS` to libraries (fixed in https://github.com/pytorch/pytorch/pull/5269) and (2) PyTorch compiled with ASAN will be dynamically loaded, which means you must `LD_PRELOAD` the ASAN dynamic library before running Python. This is an error-prone process because there are usually multiple copies of `libasan.so` on your system, one per compiler toolchain, and there is no obvious indication which library the compiler is expecting to be linked against (asked in https://stackoverflow.com/questions/48833176/get-location-of-libasan-from-gcc-clang)\r\n\r\nSupposing you overcome all of these problems. Then you will have an ASAN build of PyTorch which is sufficient to catch bugs, if you have a reproducing test case. However, if we intend to run ASAN in CI, we would like to run ASAN on the *entirety* of our test suite. However, our C code is varied and interesting enough that I have managed to cause ASAN bugs in a number of different configurations.\r\n\r\n**gcc 4.8.5 20150623 (Red Hat 4.8.5-16).** This is the default devgpu GCC. You have to `yum install libasan` to get the shared library you need at `/usr/lib64/libasan.so.0` but it has not raised spurious problems as far as I can tell.\r\n\r\n**gcc (Ubuntu 4.8.5-2ubuntu1~14.04.1) 4.8.5** This GCC (same version, no less) from Ubuntu triggers an CHECK failure in ASAN:\r\n\r\n```\r\ntest_AdaptiveMaxPool1d_indices (__main__.TestNN) ... ==7948==AddressSanitizer CHECK failed: ../../../../src/libsanitizer/asan/asan_interceptors.cc:384 \"((__interception::real___cxa_throw)) != (0)\" (0x0, 0x0)\r\n    #0 0x7fbb6a5b0bc5  (/usr/lib/x86_64-linux-gnu/libasan.so.4+0xe4bc5)\r\n    #1 0x7fbb6a5cd8f5 in __sanitizer::CheckFailed(char const*, int, char const*, unsigned long long, unsigned long long) (/usr/lib/x86_64-linux-gnu/libasan.so.4+0x1018f5)\r\n    #2 0x7fbb6a503e8c in __interceptor___cxa_throw (/usr/lib/x86_64-linux-gnu/libasan.so.4+0x37e8c)\r\n    #3 0x7fbb4b31c496 in torch::autograd::SavedVariable::unpack(std::shared_ptr<torch::autograd::Function>) const torch/csrc/autograd/saved_variable.cpp:42\r\n```\r\n\r\nThis problem also occurred with **gcc-7 (Ubuntu 7.2.0-1ubuntu1~14.04) 7.2.0**. Upstream bug filed at https://gcc.gnu.org/bugzilla/show_bug.cgi?id=84428\r\n\r\n**gcc (Ubuntu 5.4.0-6ubuntu1~16.04.6) 5.4.0 20160609.**\r\n\r\nThis one had troubles with the shadow mapping.\r\n\r\n```\r\njenkins@ff742997f986:~/pytorch-1$ ASAN_OPTIONS=protect_shadow_gap=0 LD_PRELOAD=/usr/lib/x86_64-linux\r\n-gnu/libasan.so.2 python test/test_nn.py -v TestNN.test_AdaptiveMaxPool1d_indices\r\n==4890==Shadow memory range interleaves with an existing memory mapping. ASan cannot proceed correctly. ABORTING.\r\n==4890==ASan shadow was supposed to be located in the [0x00007fff7000-0x10007fff7fff] range.\r\n==4890==Process memory map follows:\r\n        0x00007fff7000-0x00008fff7000\r\n        0x00008fff7000-0x02008fff7000\r\n        0x02008fff7000-0x10007fff8000\r\n```\r\n\r\n**clang version 3.9.1-4ubuntu3~14.04.3 (tags/RELEASE_391/rc2)** \r\n\r\n`-fsanitize=address` does not work at all:\r\n\r\n```\r\njenkins@37ecc4612171:~/pytorch$ clang-3.9 -fsanitize=address test.c             \r\n                                 \r\n/usr/bin/ld: /usr/lib/llvm-3.9/bin/../lib/clang/3.9.1/lib/linux/libclang_rt.asan\r\n-x86_64.a(asan_allocator.cc.o): unrecognized relocation (0x2a) in section `.text\r\n'\r\n/usr/bin/ld: final link failed: Bad value\r\n```\r\n\r\nFiled for Ubuntu at https://bugs.launchpad.net/ubuntu/+source/llvm-toolchain-3.9/+bug/1750099\r\n\r\n**clang version 5.0.0-3~16.04.1 (tags/RELEASE_500/final)** This one also has the \"Shadow memory range interleaves with an existing memory mapping\" error if you just pass `CFLAGS=-fsanitize=address`, but I managed to diagnose the underlying issue and solve the problem: https://github.com/google/sanitizers/issues/918\r\n\r\n----\r\n\r\nBased on the situation, I think the correct plan is to plan a clang build on Xenial with ASAN enabled (with the correct parameters.) This will also help us test clang on some more configurations than what our OS X builds are doing.\r\n\r\nP.S. One alternative strategy, which may be profitable considering the difficulty of getting ASAN to work on these platforms, is to roll our own poor man versions of ASAN.  This can be quite done by we can manually add redzones around all of our allocations, and then check if the redzone was clobbered when we free. This won't be able to determine the memory corruption as precisely ASAN (you'll only find out it was clobbered at free time) but it would be portable and always available, when you suspect memory corruption. Given that the clang builds seem to now be working, I don't advise going this route."}