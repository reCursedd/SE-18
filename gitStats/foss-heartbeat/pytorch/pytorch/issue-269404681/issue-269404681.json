{"url": "https://api.github.com/repos/pytorch/pytorch/issues/3354", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/3354/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/3354/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/3354/events", "html_url": "https://github.com/pytorch/pytorch/issues/3354", "id": 269404681, "node_id": "MDU6SXNzdWUyNjk0MDQ2ODE=", "number": 3354, "title": "Error fluctuations with well-mixed data", "user": {"login": "gokceneraslan", "id": 1140359, "node_id": "MDQ6VXNlcjExNDAzNTk=", "avatar_url": "https://avatars2.githubusercontent.com/u/1140359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gokceneraslan", "html_url": "https://github.com/gokceneraslan", "followers_url": "https://api.github.com/users/gokceneraslan/followers", "following_url": "https://api.github.com/users/gokceneraslan/following{/other_user}", "gists_url": "https://api.github.com/users/gokceneraslan/gists{/gist_id}", "starred_url": "https://api.github.com/users/gokceneraslan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gokceneraslan/subscriptions", "organizations_url": "https://api.github.com/users/gokceneraslan/orgs", "repos_url": "https://api.github.com/users/gokceneraslan/repos", "events_url": "https://api.github.com/users/gokceneraslan/events{/privacy}", "received_events_url": "https://api.github.com/users/gokceneraslan/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 17, "created_at": "2017-10-29T14:46:52Z", "updated_at": "2017-11-03T10:53:58Z", "closed_at": "2017-11-01T13:50:03Z", "author_association": "CONTRIBUTOR", "body_html": "<p>I observe weird training error fluctuations when I train the same model with <code>shuffle=True</code> compared to <code>shuffle=False</code> argument of <code>DataLoader()</code>, even though the data is already well-mixed.</p>\n<p>Here is a reproducible example:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">import</span> torch\n<span class=\"pl-k\">from</span> torch.autograd <span class=\"pl-k\">import</span> Variable\n<span class=\"pl-k\">from</span> torch.utils.data <span class=\"pl-k\">import</span> TensorDataset, DataLoader\n<span class=\"pl-k\">import</span> numpy <span class=\"pl-k\">as</span> np\n<span class=\"pl-k\">import</span> plotnine <span class=\"pl-k\">as</span> p9\n\nnum_sample <span class=\"pl-k\">=</span> <span class=\"pl-c1\">1000</span>\nnum_feat <span class=\"pl-k\">=</span> <span class=\"pl-c1\">10</span>\nnum_out <span class=\"pl-k\">=</span> <span class=\"pl-c1\">10</span>\n\nnp.random.seed(<span class=\"pl-c1\">1923</span>)\ntorch.manual_seed(<span class=\"pl-c1\">1923</span>)\n\nX <span class=\"pl-k\">=</span> np.random.normal(<span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">0.5</span>, (num_sample, num_feat)).astype(np.float32)\nW <span class=\"pl-k\">=</span> np.random.normal(<span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">0.5</span>, (num_feat, num_out)).astype(np.float32)\nb <span class=\"pl-k\">=</span> np.random.normal(<span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">0.5</span>, (<span class=\"pl-c1\">1</span>, num_out)).astype(np.float32)\ny_mean <span class=\"pl-k\">=</span> np.dot(X, W) <span class=\"pl-k\">+</span> b\n\nY <span class=\"pl-k\">=</span> np.random.normal(y_mean, <span class=\"pl-c1\">0.5</span>)\n\nmodel <span class=\"pl-k\">=</span> torch.nn.Sequential(torch.nn.Linear(num_feat, num_out))\nloss <span class=\"pl-k\">=</span> torch.nn.MSELoss()\n\noptimizer <span class=\"pl-k\">=</span> torch.optim.RMSprop(model.parameters(), <span class=\"pl-v\">lr</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">1e-3</span>)\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> dataset</span>\nfull_data <span class=\"pl-k\">=</span> TensorDataset(torch.from_numpy(X).float(),\n                          torch.from_numpy(Y).float())\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span>#### train with shuffling</span>\n\n<span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span><span class=\"pl-cce\">\\n</span>##  With shuffle<span class=\"pl-cce\">\\n</span><span class=\"pl-pds\">'</span></span>)\nloader <span class=\"pl-k\">=</span> DataLoader(full_data, <span class=\"pl-v\">batch_size</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">16</span>, <span class=\"pl-v\">shuffle</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">True</span>)\nhist1 <span class=\"pl-k\">=</span> []\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> over epochs</span>\n<span class=\"pl-k\">for</span> i <span class=\"pl-k\">in</span> <span class=\"pl-c1\">range</span>(<span class=\"pl-c1\">300</span>):\n\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> over batches</span>\n    <span class=\"pl-k\">for</span> j, (inp, target) <span class=\"pl-k\">in</span> <span class=\"pl-c1\">enumerate</span>(loader):\n        inp_var <span class=\"pl-k\">=</span> Variable(inp)\n        target_var <span class=\"pl-k\">=</span> Variable(target)\n\n        res <span class=\"pl-k\">=</span> model(inp_var)\n        l <span class=\"pl-k\">=</span> loss(res, target_var)\n\n        <span class=\"pl-k\">if</span> i <span class=\"pl-k\">%</span> <span class=\"pl-c1\">30</span> <span class=\"pl-k\">==</span> <span class=\"pl-c1\">0</span> <span class=\"pl-k\">and</span> j <span class=\"pl-k\">==</span> <span class=\"pl-c1\">0</span>:\n            <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>Epoch:<span class=\"pl-pds\">'</span></span>, i, <span class=\"pl-s\"><span class=\"pl-pds\">'</span> loss: <span class=\"pl-pds\">'</span></span>, l.data[<span class=\"pl-c1\">0</span>])\n\n        <span class=\"pl-k\">if</span> j <span class=\"pl-k\">==</span> <span class=\"pl-c1\">0</span>:\n            hist1.append(l.data[<span class=\"pl-c1\">0</span>])\n\n        optimizer.zero_grad()\n        l.backward()\n        optimizer.step()\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span>#### now without shuffling</span>\nmodel <span class=\"pl-k\">=</span> torch.nn.Sequential(torch.nn.Linear(num_feat, num_out))\nloss <span class=\"pl-k\">=</span> torch.nn.MSELoss()\n\noptimizer <span class=\"pl-k\">=</span> torch.optim.RMSprop(model.parameters(), <span class=\"pl-v\">lr</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">1e-3</span>)\n\n<span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span><span class=\"pl-cce\">\\n</span>##  Without shuffle<span class=\"pl-cce\">\\n</span><span class=\"pl-pds\">'</span></span>)\nloader <span class=\"pl-k\">=</span> DataLoader(full_data, <span class=\"pl-v\">batch_size</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">16</span>, <span class=\"pl-v\">shuffle</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">False</span>)\nhist2 <span class=\"pl-k\">=</span> []\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> over epochs</span>\n<span class=\"pl-k\">for</span> i <span class=\"pl-k\">in</span> <span class=\"pl-c1\">range</span>(<span class=\"pl-c1\">300</span>):\n\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> over batches</span>\n    <span class=\"pl-k\">for</span> j, (inp, target) <span class=\"pl-k\">in</span> <span class=\"pl-c1\">enumerate</span>(loader):\n        inp_var <span class=\"pl-k\">=</span> Variable(inp)\n        target_var <span class=\"pl-k\">=</span> Variable(target)\n\n        res <span class=\"pl-k\">=</span> model(inp_var)\n        l <span class=\"pl-k\">=</span> loss(res, target_var)\n\n        <span class=\"pl-k\">if</span> i <span class=\"pl-k\">%</span> <span class=\"pl-c1\">30</span> <span class=\"pl-k\">==</span> <span class=\"pl-c1\">0</span> <span class=\"pl-k\">and</span> j <span class=\"pl-k\">==</span> <span class=\"pl-c1\">0</span>:\n            <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>Epoch:<span class=\"pl-pds\">'</span></span>, i, <span class=\"pl-s\"><span class=\"pl-pds\">'</span> loss: <span class=\"pl-pds\">'</span></span>, l.data[<span class=\"pl-c1\">0</span>])\n        <span class=\"pl-k\">if</span> j <span class=\"pl-k\">==</span> <span class=\"pl-c1\">0</span>:\n            hist2.append(l.data[<span class=\"pl-c1\">0</span>])\n\n        optimizer.zero_grad()\n        l.backward()\n        optimizer.step()\n\n\n(p9.qplot(<span class=\"pl-c1\">range</span>(<span class=\"pl-c1\">len</span>(hist1)), hist1, <span class=\"pl-v\">xlab</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span> <span class=\"pl-pds\">'</span></span>, <span class=\"pl-v\">ylab</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span> <span class=\"pl-pds\">'</span></span>, <span class=\"pl-v\">geom</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>path<span class=\"pl-pds\">'</span></span>, <span class=\"pl-v\">color</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>\"with shuffle\"<span class=\"pl-pds\">'</span></span>) <span class=\"pl-k\">+</span>\n    p9.geom_path(p9.aes(<span class=\"pl-v\">x</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">range</span>(<span class=\"pl-c1\">len</span>(hist2)), <span class=\"pl-v\">y</span><span class=\"pl-k\">=</span>hist2, <span class=\"pl-v\">color</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>\"w/o shuffle\"<span class=\"pl-pds\">'</span></span>)) <span class=\"pl-k\">+</span>\n    p9.theme_minimal()<span class=\"pl-k\">+</span>\n    p9.labs(<span class=\"pl-v\">color</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>Loss<span class=\"pl-pds\">'</span></span>, <span class=\"pl-v\">x</span><span class=\"pl-k\">=</span><span class=\"pl-s\"><span class=\"pl-pds\">'</span>Epoch<span class=\"pl-pds\">'</span></span>)).save(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>shuffle.png<span class=\"pl-pds\">'</span></span>)</pre></div>\n<p>Here is the output:</p>\n<pre><code>\n##  With shuffle\n\nEpoch: 0  loss:  1.0320324897766113\nEpoch: 30  loss:  0.22753222286701202\nEpoch: 60  loss:  0.2699904441833496\nEpoch: 90  loss:  0.29355287551879883\nEpoch: 120  loss:  0.19778938591480255\nEpoch: 150  loss:  0.2268659621477127\nEpoch: 180  loss:  0.2604275047779083\nEpoch: 210  loss:  0.2825251817703247\nEpoch: 240  loss:  0.23147885501384735\nEpoch: 270  loss:  0.22723357379436493\n\n##  Without shuffle\n\nEpoch: 0  loss:  1.1800202131271362\nEpoch: 30  loss:  0.2247518002986908\nEpoch: 60  loss:  0.2239338606595993\nEpoch: 90  loss:  0.22393330931663513\nEpoch: 120  loss:  0.22393333911895752\nEpoch: 150  loss:  0.22393333911895752\nEpoch: 180  loss:  0.22393333911895752\nEpoch: 210  loss:  0.22393333911895752\nEpoch: 240  loss:  0.22393333911895752\nEpoch: 270  loss:  0.22393333911895752\n</code></pre>\n<p>and the figure:</p>\n<p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://user-images.githubusercontent.com/1140359/32145381-d110ab3c-bcc7-11e7-9d99-fa54e79ca9ab.png\"><img src=\"https://user-images.githubusercontent.com/1140359/32145381-d110ab3c-bcc7-11e7-9d99-fa54e79ca9ab.png\" alt=\"shuffle\" style=\"max-width:100%;\"></a></p>\n<p>I guess this is not the intended behaviour, I don't expect to see any difference in well-mixed data. Any ideas?</p>", "body_text": "I observe weird training error fluctuations when I train the same model with shuffle=True compared to shuffle=False argument of DataLoader(), even though the data is already well-mixed.\nHere is a reproducible example:\nimport torch\nfrom torch.autograd import Variable\nfrom torch.utils.data import TensorDataset, DataLoader\nimport numpy as np\nimport plotnine as p9\n\nnum_sample = 1000\nnum_feat = 10\nnum_out = 10\n\nnp.random.seed(1923)\ntorch.manual_seed(1923)\n\nX = np.random.normal(0, 0.5, (num_sample, num_feat)).astype(np.float32)\nW = np.random.normal(0, 0.5, (num_feat, num_out)).astype(np.float32)\nb = np.random.normal(0, 0.5, (1, num_out)).astype(np.float32)\ny_mean = np.dot(X, W) + b\n\nY = np.random.normal(y_mean, 0.5)\n\nmodel = torch.nn.Sequential(torch.nn.Linear(num_feat, num_out))\nloss = torch.nn.MSELoss()\n\noptimizer = torch.optim.RMSprop(model.parameters(), lr=1e-3)\n\n# dataset\nfull_data = TensorDataset(torch.from_numpy(X).float(),\n                          torch.from_numpy(Y).float())\n\n##### train with shuffling\n\nprint('\\n##  With shuffle\\n')\nloader = DataLoader(full_data, batch_size=16, shuffle=True)\nhist1 = []\n\n# over epochs\nfor i in range(300):\n\n    # over batches\n    for j, (inp, target) in enumerate(loader):\n        inp_var = Variable(inp)\n        target_var = Variable(target)\n\n        res = model(inp_var)\n        l = loss(res, target_var)\n\n        if i % 30 == 0 and j == 0:\n            print('Epoch:', i, ' loss: ', l.data[0])\n\n        if j == 0:\n            hist1.append(l.data[0])\n\n        optimizer.zero_grad()\n        l.backward()\n        optimizer.step()\n\n##### now without shuffling\nmodel = torch.nn.Sequential(torch.nn.Linear(num_feat, num_out))\nloss = torch.nn.MSELoss()\n\noptimizer = torch.optim.RMSprop(model.parameters(), lr=1e-3)\n\nprint('\\n##  Without shuffle\\n')\nloader = DataLoader(full_data, batch_size=16, shuffle=False)\nhist2 = []\n\n# over epochs\nfor i in range(300):\n\n    # over batches\n    for j, (inp, target) in enumerate(loader):\n        inp_var = Variable(inp)\n        target_var = Variable(target)\n\n        res = model(inp_var)\n        l = loss(res, target_var)\n\n        if i % 30 == 0 and j == 0:\n            print('Epoch:', i, ' loss: ', l.data[0])\n        if j == 0:\n            hist2.append(l.data[0])\n\n        optimizer.zero_grad()\n        l.backward()\n        optimizer.step()\n\n\n(p9.qplot(range(len(hist1)), hist1, xlab=' ', ylab=' ', geom='path', color='\"with shuffle\"') +\n    p9.geom_path(p9.aes(x=range(len(hist2)), y=hist2, color='\"w/o shuffle\"')) +\n    p9.theme_minimal()+\n    p9.labs(color='Loss', x='Epoch')).save('shuffle.png')\nHere is the output:\n\n##  With shuffle\n\nEpoch: 0  loss:  1.0320324897766113\nEpoch: 30  loss:  0.22753222286701202\nEpoch: 60  loss:  0.2699904441833496\nEpoch: 90  loss:  0.29355287551879883\nEpoch: 120  loss:  0.19778938591480255\nEpoch: 150  loss:  0.2268659621477127\nEpoch: 180  loss:  0.2604275047779083\nEpoch: 210  loss:  0.2825251817703247\nEpoch: 240  loss:  0.23147885501384735\nEpoch: 270  loss:  0.22723357379436493\n\n##  Without shuffle\n\nEpoch: 0  loss:  1.1800202131271362\nEpoch: 30  loss:  0.2247518002986908\nEpoch: 60  loss:  0.2239338606595993\nEpoch: 90  loss:  0.22393330931663513\nEpoch: 120  loss:  0.22393333911895752\nEpoch: 150  loss:  0.22393333911895752\nEpoch: 180  loss:  0.22393333911895752\nEpoch: 210  loss:  0.22393333911895752\nEpoch: 240  loss:  0.22393333911895752\nEpoch: 270  loss:  0.22393333911895752\n\nand the figure:\n\nI guess this is not the intended behaviour, I don't expect to see any difference in well-mixed data. Any ideas?", "body": "I observe weird training error fluctuations when I train the same model with `shuffle=True` compared to `shuffle=False` argument of `DataLoader()`, even though the data is already well-mixed. \r\n\r\nHere is a reproducible example:\r\n\r\n```python\r\nimport torch\r\nfrom torch.autograd import Variable\r\nfrom torch.utils.data import TensorDataset, DataLoader\r\nimport numpy as np\r\nimport plotnine as p9\r\n\r\nnum_sample = 1000\r\nnum_feat = 10\r\nnum_out = 10\r\n\r\nnp.random.seed(1923)\r\ntorch.manual_seed(1923)\r\n\r\nX = np.random.normal(0, 0.5, (num_sample, num_feat)).astype(np.float32)\r\nW = np.random.normal(0, 0.5, (num_feat, num_out)).astype(np.float32)\r\nb = np.random.normal(0, 0.5, (1, num_out)).astype(np.float32)\r\ny_mean = np.dot(X, W) + b\r\n\r\nY = np.random.normal(y_mean, 0.5)\r\n\r\nmodel = torch.nn.Sequential(torch.nn.Linear(num_feat, num_out))\r\nloss = torch.nn.MSELoss()\r\n\r\noptimizer = torch.optim.RMSprop(model.parameters(), lr=1e-3)\r\n\r\n# dataset\r\nfull_data = TensorDataset(torch.from_numpy(X).float(),\r\n                          torch.from_numpy(Y).float())\r\n\r\n##### train with shuffling\r\n\r\nprint('\\n##  With shuffle\\n')\r\nloader = DataLoader(full_data, batch_size=16, shuffle=True)\r\nhist1 = []\r\n\r\n# over epochs\r\nfor i in range(300):\r\n\r\n    # over batches\r\n    for j, (inp, target) in enumerate(loader):\r\n        inp_var = Variable(inp)\r\n        target_var = Variable(target)\r\n\r\n        res = model(inp_var)\r\n        l = loss(res, target_var)\r\n\r\n        if i % 30 == 0 and j == 0:\r\n            print('Epoch:', i, ' loss: ', l.data[0])\r\n\r\n        if j == 0:\r\n            hist1.append(l.data[0])\r\n\r\n        optimizer.zero_grad()\r\n        l.backward()\r\n        optimizer.step()\r\n\r\n##### now without shuffling\r\nmodel = torch.nn.Sequential(torch.nn.Linear(num_feat, num_out))\r\nloss = torch.nn.MSELoss()\r\n\r\noptimizer = torch.optim.RMSprop(model.parameters(), lr=1e-3)\r\n\r\nprint('\\n##  Without shuffle\\n')\r\nloader = DataLoader(full_data, batch_size=16, shuffle=False)\r\nhist2 = []\r\n\r\n# over epochs\r\nfor i in range(300):\r\n\r\n    # over batches\r\n    for j, (inp, target) in enumerate(loader):\r\n        inp_var = Variable(inp)\r\n        target_var = Variable(target)\r\n\r\n        res = model(inp_var)\r\n        l = loss(res, target_var)\r\n\r\n        if i % 30 == 0 and j == 0:\r\n            print('Epoch:', i, ' loss: ', l.data[0])\r\n        if j == 0:\r\n            hist2.append(l.data[0])\r\n\r\n        optimizer.zero_grad()\r\n        l.backward()\r\n        optimizer.step()\r\n\r\n\r\n(p9.qplot(range(len(hist1)), hist1, xlab=' ', ylab=' ', geom='path', color='\"with shuffle\"') +\r\n    p9.geom_path(p9.aes(x=range(len(hist2)), y=hist2, color='\"w/o shuffle\"')) +\r\n    p9.theme_minimal()+\r\n    p9.labs(color='Loss', x='Epoch')).save('shuffle.png')\r\n```\r\n\r\nHere is the output:\r\n\r\n```\r\n\r\n##  With shuffle\r\n\r\nEpoch: 0  loss:  1.0320324897766113\r\nEpoch: 30  loss:  0.22753222286701202\r\nEpoch: 60  loss:  0.2699904441833496\r\nEpoch: 90  loss:  0.29355287551879883\r\nEpoch: 120  loss:  0.19778938591480255\r\nEpoch: 150  loss:  0.2268659621477127\r\nEpoch: 180  loss:  0.2604275047779083\r\nEpoch: 210  loss:  0.2825251817703247\r\nEpoch: 240  loss:  0.23147885501384735\r\nEpoch: 270  loss:  0.22723357379436493\r\n\r\n##  Without shuffle\r\n\r\nEpoch: 0  loss:  1.1800202131271362\r\nEpoch: 30  loss:  0.2247518002986908\r\nEpoch: 60  loss:  0.2239338606595993\r\nEpoch: 90  loss:  0.22393330931663513\r\nEpoch: 120  loss:  0.22393333911895752\r\nEpoch: 150  loss:  0.22393333911895752\r\nEpoch: 180  loss:  0.22393333911895752\r\nEpoch: 210  loss:  0.22393333911895752\r\nEpoch: 240  loss:  0.22393333911895752\r\nEpoch: 270  loss:  0.22393333911895752\r\n```\r\n\r\nand the figure:\r\n\r\n![shuffle](https://user-images.githubusercontent.com/1140359/32145381-d110ab3c-bcc7-11e7-9d99-fa54e79ca9ab.png)\r\n\r\nI guess this is not the intended behaviour, I don't expect to see any difference in well-mixed data. Any ideas?"}