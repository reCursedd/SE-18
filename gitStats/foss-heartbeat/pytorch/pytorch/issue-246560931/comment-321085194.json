{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/321085194", "html_url": "https://github.com/pytorch/pytorch/issues/2246#issuecomment-321085194", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/2246", "id": 321085194, "node_id": "MDEyOklzc3VlQ29tbWVudDMyMTA4NTE5NA==", "user": {"login": "lantiga", "id": 191033, "node_id": "MDQ6VXNlcjE5MTAzMw==", "avatar_url": "https://avatars2.githubusercontent.com/u/191033?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lantiga", "html_url": "https://github.com/lantiga", "followers_url": "https://api.github.com/users/lantiga/followers", "following_url": "https://api.github.com/users/lantiga/following{/other_user}", "gists_url": "https://api.github.com/users/lantiga/gists{/gist_id}", "starred_url": "https://api.github.com/users/lantiga/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lantiga/subscriptions", "organizations_url": "https://api.github.com/users/lantiga/orgs", "repos_url": "https://api.github.com/users/lantiga/repos", "events_url": "https://api.github.com/users/lantiga/events{/privacy}", "received_events_url": "https://api.github.com/users/lantiga/received_events", "type": "User", "site_admin": false}, "created_at": "2017-08-08T21:20:43Z", "updated_at": "2017-08-08T21:28:41Z", "author_association": "COLLABORATOR", "body_html": "<p>For the records,</p>\n<pre><code>torch.DoubleTensor(np.array([0,1,2], dtype=np.float32))\n</code></pre>\n<p>also fails. /cc <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"239756600\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/1957\" data-hovercard-type=\"issue\" data-hovercard-url=\"/pytorch/pytorch/issues/1957/hovercard\" href=\"https://github.com/pytorch/pytorch/issues/1957\">#1957</a></p>\n<p>Just to clarify: performance-wise, currently the operation is exactly equivalent to <code>torch.from_numpy</code> if the <code>dtype</code> of the array is the same as the type of the tensor, otherwise it falls back to treating the tensor as a sequence (thus iterating over every element, as <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=1041752\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/vadimkantorov\">@vadimkantorov</a> was mentioning). See <a href=\"https://github.com/pytorch/pytorch/blob/master/torch/csrc/generic/Tensor.cpp#L231\">https://github.com/pytorch/pytorch/blob/master/torch/csrc/generic/Tensor.cpp#L231</a> onwards.</p>\n<p>Given the subtlety and the resulting impact on performance, we have two options:<br>\nA. have a constructor with a numpy array as an argument throw if the numeric types do not match<br>\nB. avoid throwing an exception, but cast the array by looping over the underlying <code>PyArray_DATA(array)</code>, thus avoiding treating the array as a sequence.</p>\n<p>Although option B offers greater flexibility, option A is cleaner, as any cast has to be managed explicitly by the user.</p>\n<p>Thoughts?</p>", "body_text": "For the records,\ntorch.DoubleTensor(np.array([0,1,2], dtype=np.float32))\n\nalso fails. /cc #1957\nJust to clarify: performance-wise, currently the operation is exactly equivalent to torch.from_numpy if the dtype of the array is the same as the type of the tensor, otherwise it falls back to treating the tensor as a sequence (thus iterating over every element, as @vadimkantorov was mentioning). See https://github.com/pytorch/pytorch/blob/master/torch/csrc/generic/Tensor.cpp#L231 onwards.\nGiven the subtlety and the resulting impact on performance, we have two options:\nA. have a constructor with a numpy array as an argument throw if the numeric types do not match\nB. avoid throwing an exception, but cast the array by looping over the underlying PyArray_DATA(array), thus avoiding treating the array as a sequence.\nAlthough option B offers greater flexibility, option A is cleaner, as any cast has to be managed explicitly by the user.\nThoughts?", "body": "For the records,\r\n```\r\ntorch.DoubleTensor(np.array([0,1,2], dtype=np.float32))\r\n```\r\nalso fails. /cc #1957\r\n\r\nJust to clarify: performance-wise, currently the operation is exactly equivalent to `torch.from_numpy` if the `dtype` of the array is the same as the type of the tensor, otherwise it falls back to treating the tensor as a sequence (thus iterating over every element, as @vadimkantorov was mentioning). See https://github.com/pytorch/pytorch/blob/master/torch/csrc/generic/Tensor.cpp#L231 onwards.\r\n\r\nGiven the subtlety and the resulting impact on performance, we have two options:\r\nA. have a constructor with a numpy array as an argument throw if the numeric types do not match\r\nB. avoid throwing an exception, but cast the array by looping over the underlying `PyArray_DATA(array)`, thus avoiding treating the array as a sequence.\r\n\r\nAlthough option B offers greater flexibility, option A is cleaner, as any cast has to be managed explicitly by the user.\r\n\r\nThoughts?"}