{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/425538480", "html_url": "https://github.com/pytorch/pytorch/issues/9406#issuecomment-425538480", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/9406", "id": 425538480, "node_id": "MDEyOklzc3VlQ29tbWVudDQyNTUzODQ4MA==", "user": {"login": "erikbrinkman", "id": 858926, "node_id": "MDQ6VXNlcjg1ODkyNg==", "avatar_url": "https://avatars1.githubusercontent.com/u/858926?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erikbrinkman", "html_url": "https://github.com/erikbrinkman", "followers_url": "https://api.github.com/users/erikbrinkman/followers", "following_url": "https://api.github.com/users/erikbrinkman/following{/other_user}", "gists_url": "https://api.github.com/users/erikbrinkman/gists{/gist_id}", "starred_url": "https://api.github.com/users/erikbrinkman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erikbrinkman/subscriptions", "organizations_url": "https://api.github.com/users/erikbrinkman/orgs", "repos_url": "https://api.github.com/users/erikbrinkman/repos", "events_url": "https://api.github.com/users/erikbrinkman/events{/privacy}", "received_events_url": "https://api.github.com/users/erikbrinkman/received_events", "type": "User", "site_admin": false}, "created_at": "2018-09-28T19:15:10Z", "updated_at": "2018-09-28T19:16:11Z", "author_association": "CONTRIBUTOR", "body_html": "<ol>\n<li>\n<p>Fair point. What about for the batched version:</p>\n<p>For an input tensor <code>X</code> with shape <code>B x N x K</code> returns a condensed distance matrix <code>Y</code> with shape <code>B x D</code> where D = N * (N - 1) / 2. Each element <code>Y[b, k]</code> of the output is equal to <code>paiwise_distance(X[b, i], X[b, j])</code> where k = n * i - i * (i + 3) / 2 + j - 1. This is equivalent to the row order of the upper triangular portion of the full <code>B x N x N</code> distance matrix.</p>\n</li>\n<li>\n<p>It will. It's using broadcasting. If the first <code>X</code> is <code>B x N x K</code> and the second <code>X</code> is <code>B x M x K</code> the resulting tensor will be <code>B x M x N</code>.</p>\n</li>\n</ol>", "body_text": "Fair point. What about for the batched version:\nFor an input tensor X with shape B x N x K returns a condensed distance matrix Y with shape B x D where D = N * (N - 1) / 2. Each element Y[b, k] of the output is equal to paiwise_distance(X[b, i], X[b, j]) where k = n * i - i * (i + 3) / 2 + j - 1. This is equivalent to the row order of the upper triangular portion of the full B x N x N distance matrix.\n\n\nIt will. It's using broadcasting. If the first X is B x N x K and the second X is B x M x K the resulting tensor will be B x M x N.", "body": "1. Fair point. What about for the batched version:\r\n\r\n   For an input tensor `X` with shape `B x N x K` returns a condensed distance matrix `Y` with shape `B x D` where D = N * (N - 1) / 2. Each element `Y[b, k]` of the output is equal to `paiwise_distance(X[b, i], X[b, j])` where k = n * i - i * (i + 3) / 2 + j - 1. This is equivalent to the row order of the upper triangular portion of the full `B x N x N` distance matrix.\r\n\r\n2. It will. It's using broadcasting. If the first `X` is `B x N x K` and the second `X` is `B x M x K` the resulting tensor will be `B x M x N`."}