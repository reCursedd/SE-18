{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/100682223", "pull_request_review_id": 21398986, "id": 100682223, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwMDY4MjIyMw==", "diff_hunk": "@@ -303,45 +265,101 @@ def _check_container_source(container_type, source_file, original_source):\n                    .format(torch.typename(container_type), msg))\n             warnings.warn(msg, SourceChangeWarning)\n \n+    def legacy_load(f):\n+        deserialized_objects = {}\n+\n+        def persistent_load(saved_id):\n+            if isinstance(saved_id, tuple):\n+                # Ignore containers that don't have any sources saved\n+                if all(saved_id[1:]):\n+                    _check_container_source(*saved_id)\n+                return saved_id[0]\n+            return deserialized_objects[int(saved_id)]\n+\n+        with closing(tarfile.open(fileobj=f, mode='r:', format=tarfile.PAX_FORMAT)) as tar, \\\n+                mkdtemp() as tmpdir:\n+\n+            tar.extract('storages', path=tmpdir)\n+            with open(os.path.join(tmpdir, 'storages'), 'rb', 0) as f:\n+                num_storages = pickle_module.load(f)\n+                for i in range(num_storages):\n+                    args = pickle_module.load(f)\n+                    key, location, storage_type = args\n+                    obj = storage_type._new_with_file(f)\n+                    obj = restore_location(obj, location)\n+                    deserialized_objects[key] = obj\n+\n+                storage_views = pickle_module.load(f)\n+                for target_cdata, root_cdata, offset, size in storage_views:\n+                    root = deserialized_objects[root_cdata]\n+                    deserialized_objects[target_cdata] = root[offset:offset + size]\n+\n+            tar.extract('tensors', path=tmpdir)\n+            with open(os.path.join(tmpdir, 'tensors'), 'rb', 0) as f:\n+                num_tensors = pickle_module.load(f)\n+                for i in range(num_tensors):\n+                    args = pickle_module.load(f)\n+                    key, storage_id, original_tensor_type = args\n+                    storage = deserialized_objects[storage_id]\n+                    tensor_type = storage_to_tensor_type(storage)\n+                    tensor = tensor_type._new_with_metadata_file(f, storage)\n+                    deserialized_objects[key] = tensor\n+\n+            pickle_file = tar.extractfile('pickle')\n+            unpickler = pickle_module.Unpickler(pickle_file)\n+            unpickler.persistent_load = persistent_load\n+            result = unpickler.load()\n+            return result\n+\n+    deserialized_storages = {}\n+\n     def persistent_load(saved_id):\n-        if isinstance(saved_id, tuple):\n+        assert isinstance(saved_id, tuple)\n+        typename = saved_id[0]\n+        data = saved_id[1:]\n+\n+        if typename == 'module':\n             # Ignore containers that don't have any sources saved\n-            if all(saved_id[1:]):\n-                _check_container_source(*saved_id)\n-            return saved_id[0]\n-        return deserialized_objects[int(saved_id)]\n-\n-    with closing(tarfile.open(fileobj=f, mode='r:', format=tarfile.PAX_FORMAT)) as tar, \\\n-            mkdtemp() as tmpdir:\n-\n-        tar.extract('storages', path=tmpdir)\n-        with open(os.path.join(tmpdir, 'storages'), 'rb', 0) as f:\n-            num_storages = pickle_module.load(f)\n-            for i in range(num_storages):\n-                args = pickle_module.load(f)\n-                key, location, storage_type = args\n-                obj = storage_type._new_with_file(f)\n-                obj = restore_location(obj, location)\n-                deserialized_objects[key] = obj\n-\n-            storage_views = pickle_module.load(f)\n-            for target_cdata, root_cdata, offset, size in storage_views:\n-                root = deserialized_objects[root_cdata]\n-                deserialized_objects[target_cdata] = root[offset:offset + size]\n-\n-        tar.extract('tensors', path=tmpdir)\n-        with open(os.path.join(tmpdir, 'tensors'), 'rb', 0) as f:\n-            num_tensors = pickle_module.load(f)\n-            for i in range(num_tensors):\n-                args = pickle_module.load(f)\n-                key, storage_id, original_tensor_type = args\n-                storage = deserialized_objects[storage_id]\n-                tensor_type = storage_to_tensor_type(storage)\n-                tensor = tensor_type._new_with_metadata_file(f, storage)\n-                deserialized_objects[key] = tensor\n-\n-        pickle_file = tar.extractfile('pickle')\n-        unpickler = pickle_module.Unpickler(pickle_file)\n-        unpickler.persistent_load = persistent_load\n-        result = unpickler.load()\n-        return result\n+            if all(data[1:]):\n+                _check_container_source(*data)\n+            return data[0]\n+        elif typename == 'storage':\n+            data_type, key, location, size, is_view, offset, view_size = data\n+            if key not in deserialized_storages:\n+                deserialized_storages[key] = restore_location(\n+                    data_type(size), location)\n+            data = deserialized_storages[key]\n+            if is_view:\n+                data = data[offset:offset + view_size]\n+            return data\n+        else:\n+            raise RuntimeError(\"Unknown saved id type: %s\" % saved_id[0])\n+\n+    # try the legacy loader first, which only works if f is a tarfile\n+    try:\n+        return legacy_load(f)\n+    except tarfile.TarError:\n+        pass\n+\n+    f.seek(0)\n+    magic_number = pickle_module.load(f)\n+    if magic_number != MAGIC_NUMBER:\n+        raise RuntimeError(\"Invalid magic number; corrupt file?\")\n+    protocol_version = pickle_module.load(f)\n+    if protocol_version != PROTOCOL_VERSION:", "path": "torch/serialization.py", "position": 345, "original_position": 316, "commit_id": "35301cb6db948aa78de659c45904ff87007009f3", "original_commit_id": "7b4ec7f0831a3971a71167d8bec63e1384e2a416", "user": {"login": "adamlerer", "id": 5702157, "node_id": "MDQ6VXNlcjU3MDIxNTc=", "avatar_url": "https://avatars2.githubusercontent.com/u/5702157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/adamlerer", "html_url": "https://github.com/adamlerer", "followers_url": "https://api.github.com/users/adamlerer/followers", "following_url": "https://api.github.com/users/adamlerer/following{/other_user}", "gists_url": "https://api.github.com/users/adamlerer/gists{/gist_id}", "starred_url": "https://api.github.com/users/adamlerer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/adamlerer/subscriptions", "organizations_url": "https://api.github.com/users/adamlerer/orgs", "repos_url": "https://api.github.com/users/adamlerer/repos", "events_url": "https://api.github.com/users/adamlerer/events{/privacy}", "received_events_url": "https://api.github.com/users/adamlerer/received_events", "type": "User", "site_admin": false}, "body": "Err, maybe I misunderstand what this value means. Does it refer to the pickle protocol version? (because it is never used in that way). I thought that this is a version flag for backwards compatibility, i.e. so if we change the serialization scheme we can check the protocol version and decide which to use (which would have been a great way to ensure backwards compatibility here except that the protocol version was stored inside a nested tar file \ud83d\udc4e )", "created_at": "2017-02-12T03:04:01Z", "updated_at": "2018-11-23T15:32:25Z", "html_url": "https://github.com/pytorch/pytorch/pull/713#discussion_r100682223", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/713", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/100682223"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/713#discussion_r100682223"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/713"}}, "body_html": "<p>Err, maybe I misunderstand what this value means. Does it refer to the pickle protocol version? (because it is never used in that way). I thought that this is a version flag for backwards compatibility, i.e. so if we change the serialization scheme we can check the protocol version and decide which to use (which would have been a great way to ensure backwards compatibility here except that the protocol version was stored inside a nested tar file <g-emoji class=\"g-emoji\" alias=\"-1\" fallback-src=\"https://assets-cdn.github.com/images/icons/emoji/unicode/1f44e.png\">\ud83d\udc4e</g-emoji> )</p>", "body_text": "Err, maybe I misunderstand what this value means. Does it refer to the pickle protocol version? (because it is never used in that way). I thought that this is a version flag for backwards compatibility, i.e. so if we change the serialization scheme we can check the protocol version and decide which to use (which would have been a great way to ensure backwards compatibility here except that the protocol version was stored inside a nested tar file \ud83d\udc4e )", "in_reply_to_id": 100670941}