{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/327083909", "html_url": "https://github.com/pytorch/pytorch/pull/2622#issuecomment-327083909", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/2622", "id": 327083909, "node_id": "MDEyOklzc3VlQ29tbWVudDMyNzA4MzkwOQ==", "user": {"login": "GuillaumeLeclerc", "id": 2017051, "node_id": "MDQ6VXNlcjIwMTcwNTE=", "avatar_url": "https://avatars3.githubusercontent.com/u/2017051?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeLeclerc", "html_url": "https://github.com/GuillaumeLeclerc", "followers_url": "https://api.github.com/users/GuillaumeLeclerc/followers", "following_url": "https://api.github.com/users/GuillaumeLeclerc/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeLeclerc/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeLeclerc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeLeclerc/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeLeclerc/orgs", "repos_url": "https://api.github.com/users/GuillaumeLeclerc/repos", "events_url": "https://api.github.com/users/GuillaumeLeclerc/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeLeclerc/received_events", "type": "User", "site_admin": false}, "created_at": "2017-09-05T06:33:28Z", "updated_at": "2017-09-05T14:48:17Z", "author_association": "NONE", "body_html": "<p>Do not merge yet. I think there is a race condition somewhere. It should be a discussion for now.</p>\n<p><em>EDIT</em>: In the end everything is fine. I thought the following invariant: 'When a worker picks the <code>Collate</code> marker, the batch has been completed and all elements are in the <code>collate_queue</code>', might not always be true, But it's easy to prove:</p>\n<p>Let's assume a worker pick the <code>Collate</code> maker from the queue (we call him <code>A</code>) and suppose that there is still some work pending, we call the worker doing this work <code>B</code>. It's easy to see that a worker can only pick at most one <code>Next</code> marker (since they move to the next queue). Since this is a FIFO queue. <code>B</code> has not taken any <code>Collate</code> or <code>Next</code> marker because he is not done processing an element. <code>A</code> has taken the <code>Collate</code> marker, so he has not consumed any <code>Next</code> one (again, FIFO order). There are <code>num_workers - 1</code> <code>Next</code> markers. In this situation there is at least one remaining <code>Next</code> marker in the queue, which lead to a contradiction because <code>A</code> can't have picked the <code>Collate</code> marker if there is a <code>Next</code> left in the queue (because of FIFO order).</p>\n<p>This is safe to merge</p>", "body_text": "Do not merge yet. I think there is a race condition somewhere. It should be a discussion for now.\nEDIT: In the end everything is fine. I thought the following invariant: 'When a worker picks the Collate marker, the batch has been completed and all elements are in the collate_queue', might not always be true, But it's easy to prove:\nLet's assume a worker pick the Collate maker from the queue (we call him A) and suppose that there is still some work pending, we call the worker doing this work B. It's easy to see that a worker can only pick at most one Next marker (since they move to the next queue). Since this is a FIFO queue. B has not taken any Collate or Next marker because he is not done processing an element. A has taken the Collate marker, so he has not consumed any Next one (again, FIFO order). There are num_workers - 1 Next markers. In this situation there is at least one remaining Next marker in the queue, which lead to a contradiction because A can't have picked the Collate marker if there is a Next left in the queue (because of FIFO order).\nThis is safe to merge", "body": "Do not merge yet. I think there is a race condition somewhere. It should be a discussion for now.\r\n\r\n*EDIT*: In the end everything is fine. I thought the following invariant: 'When a worker picks the `Collate` marker, the batch has been completed and all elements are in the `collate_queue`', might not always be true, But it's easy to prove:\r\n\r\nLet's assume a worker pick the `Collate` maker from the queue (we call him `A`) and suppose that there is still some work pending, we call the worker doing this work `B`. It's easy to see that a worker can only pick at most one `Next` marker (since they move to the next queue). Since this is a FIFO queue. `B` has not taken any `Collate` or `Next` marker because he is not done processing an element. `A` has taken the `Collate` marker, so he has not consumed any `Next` one (again, FIFO order). There are `num_workers - 1` `Next` markers. In this situation there is at least one remaining `Next` marker in the queue, which lead to a contradiction because `A` can't have picked the `Collate` marker if there is a `Next` left in the queue (because of FIFO order). \r\n\r\nThis is safe to merge"}