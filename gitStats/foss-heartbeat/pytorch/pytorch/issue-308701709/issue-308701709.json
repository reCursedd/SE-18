{"url": "https://api.github.com/repos/pytorch/pytorch/issues/6006", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/6006/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/6006/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/6006/events", "html_url": "https://github.com/pytorch/pytorch/issues/6006", "id": 308701709, "node_id": "MDU6SXNzdWUzMDg3MDE3MDk=", "number": 6006, "title": "Switch autograd::Function's apply to pass tensors by value using rvalue references, and make sure all tensor lists get moved into it. ", "user": {"login": "zdevito", "id": 370202, "node_id": "MDQ6VXNlcjM3MDIwMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/370202?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zdevito", "html_url": "https://github.com/zdevito", "followers_url": "https://api.github.com/users/zdevito/followers", "following_url": "https://api.github.com/users/zdevito/following{/other_user}", "gists_url": "https://api.github.com/users/zdevito/gists{/gist_id}", "starred_url": "https://api.github.com/users/zdevito/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zdevito/subscriptions", "organizations_url": "https://api.github.com/users/zdevito/orgs", "repos_url": "https://api.github.com/users/zdevito/repos", "events_url": "https://api.github.com/users/zdevito/events{/privacy}", "received_events_url": "https://api.github.com/users/zdevito/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 679953983, "node_id": "MDU6TGFiZWw2Nzk5NTM5ODM=", "url": "https://api.github.com/repos/pytorch/pytorch/labels/jit", "name": "jit", "color": "c5def5", "default": false}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2018-03-26T19:20:14Z", "updated_at": "2018-03-28T17:50:17Z", "closed_at": null, "author_association": "CONTRIBUTOR", "body_html": "<p>Why? Large operators like those generated by the interpreter need to incrementally release tensors when they run, but they can only do this if they own the only reference to that tensor. Currently we pass the input tensors by const reference, so they cannot be release until the end of an op.</p>\n<p>Copying the input list will be necessary when there are hooks but this is the rare case, and the copy is relatively cheap.</p>\n<pre><code>// previous\ntensor_list apply(const tensor_list&amp; inputs) ...\n\n// after\ntensor_list apply(tensor_list&amp;&amp; inputs)...\n</code></pre>", "body_text": "Why? Large operators like those generated by the interpreter need to incrementally release tensors when they run, but they can only do this if they own the only reference to that tensor. Currently we pass the input tensors by const reference, so they cannot be release until the end of an op.\nCopying the input list will be necessary when there are hooks but this is the rare case, and the copy is relatively cheap.\n// previous\ntensor_list apply(const tensor_list& inputs) ...\n\n// after\ntensor_list apply(tensor_list&& inputs)...", "body": "Why? Large operators like those generated by the interpreter need to incrementally release tensors when they run, but they can only do this if they own the only reference to that tensor. Currently we pass the input tensors by const reference, so they cannot be release until the end of an op.\r\n\r\nCopying the input list will be necessary when there are hooks but this is the rare case, and the copy is relatively cheap. \r\n\r\n```\r\n// previous\r\ntensor_list apply(const tensor_list& inputs) ...\r\n\r\n// after\r\ntensor_list apply(tensor_list&& inputs)...\r\n```"}