{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/404372663", "html_url": "https://github.com/pytorch/pytorch/pull/9277#issuecomment-404372663", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/9277", "id": 404372663, "node_id": "MDEyOklzc3VlQ29tbWVudDQwNDM3MjY2Mw==", "user": {"login": "goldsborough", "id": 6429851, "node_id": "MDQ6VXNlcjY0Mjk4NTE=", "avatar_url": "https://avatars3.githubusercontent.com/u/6429851?v=4", "gravatar_id": "", "url": "https://api.github.com/users/goldsborough", "html_url": "https://github.com/goldsborough", "followers_url": "https://api.github.com/users/goldsborough/followers", "following_url": "https://api.github.com/users/goldsborough/following{/other_user}", "gists_url": "https://api.github.com/users/goldsborough/gists{/gist_id}", "starred_url": "https://api.github.com/users/goldsborough/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/goldsborough/subscriptions", "organizations_url": "https://api.github.com/users/goldsborough/orgs", "repos_url": "https://api.github.com/users/goldsborough/repos", "events_url": "https://api.github.com/users/goldsborough/events{/privacy}", "received_events_url": "https://api.github.com/users/goldsborough/received_events", "type": "User", "site_admin": false}, "created_at": "2018-07-12T02:49:07Z", "updated_at": "2018-07-12T02:49:07Z", "author_association": "CONTRIBUTOR", "body_html": "<p>After discussing a strategy with <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=38511765\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/mruberry\">@mruberry</a>, we agreed that it would be better that <code>CUDAStreamGuard</code> (formerly) not only set the current stream, but also the current device to the one associated with the stream supplied to the guard. In that sense, this kind of guard would actually be more of an extension of<code>at::DeviceGuard</code>, giving it an understanding of CUDA streams (and maybe in the future, more CUDA specific things). As such, we decided to call it <code>CUDAGuard</code> (like <code>DeviceGuard</code>, but for all CUDA things).</p>\n<p>Given the above, it might seem to make sense to inherit <code>CUDAGuard</code> from <code>DeviceGuard</code>. At the moment <code>DeviceGuard</code> is still very CUDA specific, so this would be fine. However in the future <code>DeviceGuard</code> should gain more understanding of other kinds of devices. At that point, a <code>CUDAGuard</code> would not follow an is-a relationship with <code>DeviceGuard</code> anymore (e.g. a <code>DeviceGuard</code> can accept a <code>RandomFPGADevice</code>, but it wouldn't make sense for a  <code>CUDAGuard</code> to deal with such an object). So instead of inheritance, I think it's better to use composition and implement the device-specific parts of <code>CUDAGuard</code> <em>using</em> a <code>DeviceGuard</code>. So much for my design thoughts here.</p>\n<p>NOTE: I changed <code>AT_CHECK</code> in <code>CUDAStream.cpp</code> to <code>AT_ASSERT</code>. <code>AT_ASSERT</code> should be used for asserts without a message, <code>AT_CHECK</code> for asserts with a message.</p>", "body_text": "After discussing a strategy with @mruberry, we agreed that it would be better that CUDAStreamGuard (formerly) not only set the current stream, but also the current device to the one associated with the stream supplied to the guard. In that sense, this kind of guard would actually be more of an extension ofat::DeviceGuard, giving it an understanding of CUDA streams (and maybe in the future, more CUDA specific things). As such, we decided to call it CUDAGuard (like DeviceGuard, but for all CUDA things).\nGiven the above, it might seem to make sense to inherit CUDAGuard from DeviceGuard. At the moment DeviceGuard is still very CUDA specific, so this would be fine. However in the future DeviceGuard should gain more understanding of other kinds of devices. At that point, a CUDAGuard would not follow an is-a relationship with DeviceGuard anymore (e.g. a DeviceGuard can accept a RandomFPGADevice, but it wouldn't make sense for a  CUDAGuard to deal with such an object). So instead of inheritance, I think it's better to use composition and implement the device-specific parts of CUDAGuard using a DeviceGuard. So much for my design thoughts here.\nNOTE: I changed AT_CHECK in CUDAStream.cpp to AT_ASSERT. AT_ASSERT should be used for asserts without a message, AT_CHECK for asserts with a message.", "body": "After discussing a strategy with @mruberry, we agreed that it would be better that `CUDAStreamGuard` (formerly) not only set the current stream, but also the current device to the one associated with the stream supplied to the guard. In that sense, this kind of guard would actually be more of an extension of`at::DeviceGuard`, giving it an understanding of CUDA streams (and maybe in the future, more CUDA specific things). As such, we decided to call it `CUDAGuard` (like `DeviceGuard`, but for all CUDA things).\r\n\r\nGiven the above, it might seem to make sense to inherit `CUDAGuard` from `DeviceGuard`. At the moment `DeviceGuard` is still very CUDA specific, so this would be fine. However in the future `DeviceGuard` should gain more understanding of other kinds of devices. At that point, a `CUDAGuard` would not follow an is-a relationship with `DeviceGuard` anymore (e.g. a `DeviceGuard` can accept a `RandomFPGADevice`, but it wouldn't make sense for a  `CUDAGuard` to deal with such an object). So instead of inheritance, I think it's better to use composition and implement the device-specific parts of `CUDAGuard` *using* a `DeviceGuard`. So much for my design thoughts here.\r\n\r\nNOTE: I changed `AT_CHECK` in `CUDAStream.cpp` to `AT_ASSERT`. `AT_ASSERT` should be used for asserts without a message, `AT_CHECK` for asserts with a message."}