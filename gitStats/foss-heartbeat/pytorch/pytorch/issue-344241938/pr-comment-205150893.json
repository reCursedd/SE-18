{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/205150893", "pull_request_review_id": 140363758, "id": 205150893, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwNTE1MDg5Mw==", "diff_hunk": "@@ -80,12 +84,297 @@ struct TensorInfo {\n   IndexType strides[N];\n };\n )\");\n+constexpr auto rand_support_literal = R\"(\n+  /* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n+\n+  Licensed under the Apache License, Version 2.0 (the \"License\");\n+  you may not use this file except in compliance with the License.\n+  You may obtain a copy of the License at\n+\n+      http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing, software\n+  distributed under the License is distributed on an \"AS IS\" BASIS,\n+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  See the License for the specific language governing permissions and\n+  limitations under the License.\n+  ==============================================================================*/\n+\n+  // Implement the Philox algorithm to generate random numbers in parallel.\n+  // Salmon et al. SC 2011. Parallel random numbers: as easy as 1, 2, 3.\n+  //   http://www.thesalmons.org/john/random123/papers/random123sc11.pdf\n+\n+  #ifndef TENSORFLOW_LIB_RANDOM_PHILOX_RANDOM_H_\n+  #define TENSORFLOW_LIB_RANDOM_PHILOX_RANDOM_H_\n+\n+  // #include <stdlib.h>\n+\n+  // #include \"tensorflow/core/platform/types.h\"\n+  typedef unsigned long uint32;\n+  typedef unsigned long long uint64;\n+\n+  // Function qualifiers that need to work on both CPU and GPU.\n+  #if defined(__CUDACC__)\n+  // For nvcc.\n+  #define PHILOX_DEVICE_FUNC __host__ __device__\n+  #define PHILOX_INLINE __inline__\n+  #else\n+  // For non-nvcc.\n+  #define PHILOX_DEVICE_FUNC\n+  #define PHILOX_INLINE inline\n+  #endif\n+  #define PHILOX_DEVICE_INLINE PHILOX_DEVICE_FUNC PHILOX_INLINE\n+\n+  // #include <math.h>\n+\n+  // namespace tensorflow {\n+  // namespace random {\n+\n+  // A class that represents an inline array. It can be used on both CPU and GPU,\n+  // and also trivially copyable between CPU and GPU.\n+  // Arguments:\n+  //   T: the array element type;\n+  //   ElementCount: the fixed size of the array;\n+  template <typename T, int ElementCount>\n+  class Array {\n+   public:\n+    PHILOX_DEVICE_INLINE Array() {\n+      for (int i = 0; i < ElementCount; ++i) {\n+        data_[i] = T(0);\n+      }\n+    }\n+\n+    PHILOX_DEVICE_INLINE const T& operator[](int index) const {\n+      return data_[index];\n+    }\n+\n+    PHILOX_DEVICE_INLINE T& operator[](int index) { return data_[index]; }\n+\n+    size_t size() const { return ElementCount; }\n+\n+   private:\n+    T data_[ElementCount];\n+  };\n+\n+  // A class that encapsulates all the states for a random number generator using\n+  // the philox_4x32_10 algorithm. Each invocation returns a 128-bit random bits\n+  // in the form of four uint32.\n+  // There are multiple variants of this algorithm, we picked the 4x32_10 version\n+  // that is most suited for our applications.\n+  // Since this class is meant to be copied between CPU to GPU, it maintains a\n+  // value semantics.\n+  //\n+  // For example: To use this class and populate an array of 1024 randoms on CPU\n+  // with two threads,\n+  //\n+  //  void Fill(PhiloxRandom rnd, uint32* output, int start, int limit) {\n+  //    assert(start % 4 == 0);\n+  //    assert(limit % 4 == 0);\n+  //    rnd.Skip(start / 4);\n+  //    for (int i = start; i < limit; i += 4) {\n+  //      auto sample = rnd();\n+  //      ... copy sample[0..3] to output[i..i+3]\n+  //    }\n+  //  }\n+  //\n+  //  PhiloxRandom rng(seed);\n+  //  PhiloxRandom rng_copy = rng;\n+  //  rng.Skip(1000/4);\n+  //\n+  //  ... schedule Fill(rng_copy, output, 0, 512) in thread 1;\n+  //  ... schedule Fill(rng_copy, output, 512, 1024) in thread 2;\n+  //  ... wait for thread 1 & 2 to finish executing Fill().\n+  //\n+  // NOTE:\n+  // 1. PhiloxRandom is trivially copyable.\n+  // 2. PhiloxRandom is compilable by gcc and nvcc.\n+  class PhiloxRandom {\n+   public:\n+    using ResultType = Array<uint32, 4>;\n+    using ResultElementType = uint32;\n+    // The number of elements that will be returned.\n+    static const int kResultElementCount = 4;\n+    // Cost of generation of a single element (in cycles).\n+    static const int kElementCost = 10;\n+    // The type for the 64-bit key stored in the form of two 32-bit uint\n+    // that are used in the diffusion process.\n+    using Key = Array<uint32, 2>;\n+\n+    PHILOX_DEVICE_INLINE\n+    PhiloxRandom() {}\n+\n+    PHILOX_DEVICE_INLINE\n+    explicit PhiloxRandom(uint64 seed) {\n+      key_[0] = static_cast<uint32>(seed);\n+      key_[1] = static_cast<uint32>(seed >> 32);\n+    }\n+\n+    PHILOX_DEVICE_INLINE\n+    explicit PhiloxRandom(uint64 seed_lo, uint64 seed_hi) {\n+      key_[0] = static_cast<uint32>(seed_lo);\n+      key_[1] = static_cast<uint32>(seed_lo >> 32);\n+      counter_[2] = static_cast<uint32>(seed_hi);\n+      counter_[3] = static_cast<uint32>(seed_hi >> 32);\n+    }\n+\n+    PHILOX_DEVICE_INLINE\n+    PhiloxRandom(ResultType counter, Key key) : counter_(counter), key_(key) {}\n+\n+    // Skip the specified number of samples of 128-bits in the current stream.\n+    PHILOX_DEVICE_INLINE\n+    void Skip(uint64 count) {\n+      const uint32 count_lo = static_cast<uint32>(count);\n+      uint32 count_hi = static_cast<uint32>(count >> 32);\n+\n+      counter_[0] += count_lo;\n+      if (counter_[0] < count_lo) {\n+        ++count_hi;\n+      }\n+\n+      counter_[1] += count_hi;\n+      if (counter_[1] < count_hi) {\n+        if (++counter_[2] == 0) {\n+          ++counter_[3];\n+        }\n+      }\n+    }\n \n+    // Returns a group of four random numbers using the underlying Philox\n+    // algorithm.\n+    PHILOX_DEVICE_INLINE ResultType operator()() {\n+      ResultType counter = counter_;\n+      Key key = key_;\n+\n+      // Run the single rounds for ten times. Manually unrolling the loop\n+      // for better performance.\n+      counter = ComputeSingleRound(counter, key);\n+      RaiseKey(&key);\n+      counter = ComputeSingleRound(counter, key);\n+      RaiseKey(&key);\n+      counter = ComputeSingleRound(counter, key);\n+      RaiseKey(&key);\n+      counter = ComputeSingleRound(counter, key);\n+      RaiseKey(&key);\n+      counter = ComputeSingleRound(counter, key);\n+      RaiseKey(&key);\n+      counter = ComputeSingleRound(counter, key);\n+      RaiseKey(&key);\n+      counter = ComputeSingleRound(counter, key);\n+      RaiseKey(&key);\n+      counter = ComputeSingleRound(counter, key);\n+      RaiseKey(&key);\n+      counter = ComputeSingleRound(counter, key);\n+      RaiseKey(&key);\n+      counter = ComputeSingleRound(counter, key);\n+\n+      SkipOne();\n+\n+      return counter;\n+    }\n+\n+   private:\n+    // We use the same constants as recommended by the original paper.\n+    static const uint32 kPhiloxW32A = 0x9E3779B9;\n+    static const uint32 kPhiloxW32B = 0xBB67AE85;\n+    static const uint32 kPhiloxM4x32A = 0xD2511F53;\n+    static const uint32 kPhiloxM4x32B = 0xCD9E8D57;\n+\n+    // Helper function to skip the next sample of 128-bits in the current stream.\n+    PHILOX_DEVICE_INLINE void SkipOne() {\n+      if (++counter_[0] == 0) {\n+        if (++counter_[1] == 0) {\n+          if (++counter_[2] == 0) {\n+            ++counter_[3];\n+          }\n+        }\n+      }\n+    }\n+\n+    // Helper function to return the lower and higher 32-bits from two 32-bit\n+    // integer multiplications.\n+    PHILOX_DEVICE_INLINE\n+    static void MultiplyHighLow(uint32 a, uint32 b, uint32* result_low,\n+                                uint32* result_high) {\n+  #ifndef __CUDA_ARCH__\n+      const uint64 product = static_cast<uint64>(a) * b;\n+      *result_low = static_cast<uint32>(product);\n+      *result_high = static_cast<uint32>(product >> 32);\n+  #else\n+      *result_low = a * b;\n+      *result_high = __umulhi(a, b);\n+  #endif\n+    }\n+\n+    // Helper function for a single round of the underlying Philox algorithm.\n+    PHILOX_DEVICE_INLINE static ResultType ComputeSingleRound(\n+        const ResultType& counter, const Key& key) {\n+      uint32 lo0;\n+      uint32 hi0;\n+      MultiplyHighLow(kPhiloxM4x32A, counter[0], &lo0, &hi0);\n+\n+      uint32 lo1;\n+      uint32 hi1;\n+      MultiplyHighLow(kPhiloxM4x32B, counter[2], &lo1, &hi1);\n+\n+      ResultType result;\n+      result[0] = hi1 ^ counter[1] ^ key[0];\n+      result[1] = lo1;\n+      result[2] = hi0 ^ counter[3] ^ key[1];\n+      result[3] = lo0;\n+      return result;\n+    }\n+\n+    PHILOX_DEVICE_INLINE void RaiseKey(Key* key) {\n+      (*key)[0] += kPhiloxW32A;\n+      (*key)[1] += kPhiloxW32B;\n+    }\n+\n+   private:\n+    ResultType counter_;\n+    Key key_;\n+  };\n+\n+  // A Wrapper for Philox to get one random number at a time\n+  class PhiloxWrapper {\n+  public:\n+    PHILOX_DEVICE_INLINE\n+    explicit PhiloxWrapper(uint64 seed_lo, uint64 seed_hi, uint64 offset) {\n+      philox = PhiloxRandom(seed_lo, seed_hi);\n+      philox.Skip(offset / 4);\n+      i = 0;\n+    }\n+    PHILOX_DEVICE_INLINE float operator()() {\n+      if(i == 0) buf = philox();\n+      uint32 ret = buf[i];\n+      i = (i + 1) % 4;\n+      static uint32 FLOAT_MASK = (1 << 24) - 1;\n+      static float FLOAT_DIVISOR = 1.0f / (1 << 24);\n+      return (ret & FLOAT_MASK) * FLOAT_DIVISOR;\n+    }\n+  private:\n+    PhiloxRandom philox;\n+    using ResultType = Array<uint32, 4>;\n+    ResultType buf;\n+    int i;\n+  };\n+\n+  // }  // namespace random\n+  // }  // namespace tensorflow\n+\n+  #endif  // TENSORFLOW_LIB_RANDOM_PHILOX_RANDOM_H_\n+)\";\n+\n+constexpr auto rand_param = \", uint64 seed, uint64 offset\";\n+constexpr auto rand_init = R\"(\n+  int idx = blockIdx.x*blockDim.x + threadIdx.x;\n+  PhiloxWrapper rnd(seed, idx, offset);\n+)\";\n auto cuda_compilation_unit_template = CodeTemplate(R\"(\n ${type_declarations}\n \n extern \"C\" __global__\n-void ${kernelName}(IndexType totalElements, ${formals}) {\n+void ${kernelName}(IndexType totalElements, ${formals} ${RandParam}) {", "path": "torch/csrc/jit/fusion_compiler.cpp", "position": 137, "original_position": 319, "commit_id": "d802d7a10e5ef692c0fa662605c62fc79ffc8957", "original_commit_id": "cacc6a46b63d03893f5190479c7e7d92bbdd1e97", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "body": "Nit: our template engine supports automatically inserting the comma if the parameter is non-null, using the syntax `${,RandParam}`. So you don't need to put the comma in `rand_param` above.", "created_at": "2018-07-25T15:16:28Z", "updated_at": "2018-11-23T15:48:04Z", "html_url": "https://github.com/pytorch/pytorch/pull/9795#discussion_r205150893", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/9795", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/205150893"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/9795#discussion_r205150893"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/9795"}}, "body_html": "<p>Nit: our template engine supports automatically inserting the comma if the parameter is non-null, using the syntax <code>${,RandParam}</code>. So you don't need to put the comma in <code>rand_param</code> above.</p>", "body_text": "Nit: our template engine supports automatically inserting the comma if the parameter is non-null, using the syntax ${,RandParam}. So you don't need to put the comma in rand_param above."}