{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/403362436", "html_url": "https://github.com/pytorch/pytorch/pull/9246#issuecomment-403362436", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/9246", "id": 403362436, "node_id": "MDEyOklzc3VlQ29tbWVudDQwMzM2MjQzNg==", "user": {"login": "goldsborough", "id": 6429851, "node_id": "MDQ6VXNlcjY0Mjk4NTE=", "avatar_url": "https://avatars3.githubusercontent.com/u/6429851?v=4", "gravatar_id": "", "url": "https://api.github.com/users/goldsborough", "html_url": "https://github.com/goldsborough", "followers_url": "https://api.github.com/users/goldsborough/followers", "following_url": "https://api.github.com/users/goldsborough/following{/other_user}", "gists_url": "https://api.github.com/users/goldsborough/gists{/gist_id}", "starred_url": "https://api.github.com/users/goldsborough/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/goldsborough/subscriptions", "organizations_url": "https://api.github.com/users/goldsborough/orgs", "repos_url": "https://api.github.com/users/goldsborough/repos", "events_url": "https://api.github.com/users/goldsborough/events{/privacy}", "received_events_url": "https://api.github.com/users/goldsborough/received_events", "type": "User", "site_admin": false}, "created_at": "2018-07-09T05:18:21Z", "updated_at": "2018-07-09T05:18:21Z", "author_association": "CONTRIBUTOR", "body_html": "<p>How about implementing this at the level of ATen, with a specialization of <a href=\"https://en.cppreference.com/w/cpp/utility/hash\" rel=\"nofollow\"><code>std::hash</code></a> for <a href=\"https://github.com/pytorch/pytorch/blob/master/aten/src/ATen/Device.h\"><code>at::Device</code></a>? Then the python-specific function could just return <code>std::hash&lt;at::Device&gt;{}(device)</code>. It is a tiny bit more effort, but I could imagine we'd want to hash <code>at::Device</code> in C++ at one point or another, and then we'd have to move this code into ATen anyway. If you're comfortable with building/modifying ATen I would suggest this route, otherwise we can change this in another PR at a later point in time.</p>", "body_text": "How about implementing this at the level of ATen, with a specialization of std::hash for at::Device? Then the python-specific function could just return std::hash<at::Device>{}(device). It is a tiny bit more effort, but I could imagine we'd want to hash at::Device in C++ at one point or another, and then we'd have to move this code into ATen anyway. If you're comfortable with building/modifying ATen I would suggest this route, otherwise we can change this in another PR at a later point in time.", "body": "How about implementing this at the level of ATen, with a specialization of [`std::hash`](https://en.cppreference.com/w/cpp/utility/hash) for [`at::Device`](https://github.com/pytorch/pytorch/blob/master/aten/src/ATen/Device.h)? Then the python-specific function could just return `std::hash<at::Device>{}(device)`. It is a tiny bit more effort, but I could imagine we'd want to hash `at::Device` in C++ at one point or another, and then we'd have to move this code into ATen anyway. If you're comfortable with building/modifying ATen I would suggest this route, otherwise we can change this in another PR at a later point in time."}