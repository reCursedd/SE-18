{"url": "https://api.github.com/repos/pytorch/pytorch/issues/6024", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/6024/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/6024/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/6024/events", "html_url": "https://github.com/pytorch/pytorch/issues/6024", "id": 308747687, "node_id": "MDU6SXNzdWUzMDg3NDc2ODc=", "number": 6024, "title": "Add torch.jit.const to allow for more features in script mode.", "user": {"login": "zdevito", "id": 370202, "node_id": "MDQ6VXNlcjM3MDIwMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/370202?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zdevito", "html_url": "https://github.com/zdevito", "followers_url": "https://api.github.com/users/zdevito/followers", "following_url": "https://api.github.com/users/zdevito/following{/other_user}", "gists_url": "https://api.github.com/users/zdevito/gists{/gist_id}", "starred_url": "https://api.github.com/users/zdevito/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zdevito/subscriptions", "organizations_url": "https://api.github.com/users/zdevito/orgs", "repos_url": "https://api.github.com/users/zdevito/repos", "events_url": "https://api.github.com/users/zdevito/events{/privacy}", "received_events_url": "https://api.github.com/users/zdevito/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 679953983, "node_id": "MDU6TGFiZWw2Nzk5NTM5ODM=", "url": "https://api.github.com/repos/pytorch/pytorch/labels/jit", "name": "jit", "color": "c5def5", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2018-03-26T21:48:49Z", "updated_at": "2018-04-17T18:24:11Z", "closed_at": "2018-04-17T18:24:11Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Modules in python use the following features that we should be able to support in scripting mode:</p>\n<ul>\n<li>enabling functionality based on a bool flag set at initialization time (e.g. <code>use_bias</code>)</li>\n<li>dynamically creating and using a list of submodules based on module parameters (e.g. <a href=\"https://github.com/pytorch/vision/blob/master/torchvision/models/vgg.py#L78\">https://github.com/pytorch/vision/blob/master/torchvision/models/vgg.py#L78</a>)</li>\n<li>taking the best result of an ensemble, represented as a list of modules</li>\n</ul>\n<p>To support these features in the <a class=\"user-mention\" data-hovercard-type=\"organization\" data-hovercard-url=\"/orgs/script/hovercard\" href=\"https://github.com/script\">@script</a>, we will allow a limited ability to read 'constant'<br>\nvalues for a limited set of types (numbers, list of numbers, and list of modules).<br>\nConstants will be module attributes constructed with torch.jit.constant:</p>\n<pre><code>self.use_bias = torch.jit.const(True)\nself.cfg = torch.jit.const([1,3,4])\na = submodule()\nb = submodule()\nself.ensemble = torch.jit.const([a,b])\n</code></pre>\n<p>Once assigned to the module, these values are immutable (and if they were a mutable list, the list<br>\nis made immutable). This ensures that even when not using <a class=\"user-mention\" data-hovercard-type=\"organization\" data-hovercard-url=\"/orgs/script/hovercard\" href=\"https://github.com/script\">@script</a> these<br>\nvalues cannot be changed afterward.</p>\n<p>These constants then can be used in script methods:</p>\n<pre><code>  if self.use_bias:\n    # constant propagation will eliminate unused code\n    a += self.bias\n  for m in self.ensemble:\n    # this will unroll for everything in the ensemble\n    o = m(i)\n    ...\n</code></pre>\n<p>Support for numbers can be done by implementing a SugaredValue with a <code>asValue</code> overload.<br>\nSupport for having lists and for loops can be accomplished by adding:</p>\n<pre><code> virtual std::vector&lt;SugaredValue&gt; unrolled_for(SourceRange loc, Method&amp; m);\n</code></pre>\n<p>to SugaredValue. For each value 'v' returned, the code generator will generate an instance of the<br>\nloop with the loop iterator 'i' bound to the SugaredValue 'v'.</p>", "body_text": "Modules in python use the following features that we should be able to support in scripting mode:\n\nenabling functionality based on a bool flag set at initialization time (e.g. use_bias)\ndynamically creating and using a list of submodules based on module parameters (e.g. https://github.com/pytorch/vision/blob/master/torchvision/models/vgg.py#L78)\ntaking the best result of an ensemble, represented as a list of modules\n\nTo support these features in the @script, we will allow a limited ability to read 'constant'\nvalues for a limited set of types (numbers, list of numbers, and list of modules).\nConstants will be module attributes constructed with torch.jit.constant:\nself.use_bias = torch.jit.const(True)\nself.cfg = torch.jit.const([1,3,4])\na = submodule()\nb = submodule()\nself.ensemble = torch.jit.const([a,b])\n\nOnce assigned to the module, these values are immutable (and if they were a mutable list, the list\nis made immutable). This ensures that even when not using @script these\nvalues cannot be changed afterward.\nThese constants then can be used in script methods:\n  if self.use_bias:\n    # constant propagation will eliminate unused code\n    a += self.bias\n  for m in self.ensemble:\n    # this will unroll for everything in the ensemble\n    o = m(i)\n    ...\n\nSupport for numbers can be done by implementing a SugaredValue with a asValue overload.\nSupport for having lists and for loops can be accomplished by adding:\n virtual std::vector<SugaredValue> unrolled_for(SourceRange loc, Method& m);\n\nto SugaredValue. For each value 'v' returned, the code generator will generate an instance of the\nloop with the loop iterator 'i' bound to the SugaredValue 'v'.", "body": "Modules in python use the following features that we should be able to support in scripting mode:\r\n\r\n* enabling functionality based on a bool flag set at initialization time (e.g. `use_bias`)\r\n* dynamically creating and using a list of submodules based on module parameters (e.g. https://github.com/pytorch/vision/blob/master/torchvision/models/vgg.py#L78)\r\n* taking the best result of an ensemble, represented as a list of modules\r\n\r\nTo support these features in the @script, we will allow a limited ability to read 'constant'\r\nvalues for a limited set of types (numbers, list of numbers, and list of modules). \r\nConstants will be module attributes constructed with torch.jit.constant:\r\n\r\n  ```\r\n  self.use_bias = torch.jit.const(True)\r\n  self.cfg = torch.jit.const([1,3,4])\r\n  a = submodule()\r\n  b = submodule()\r\n  self.ensemble = torch.jit.const([a,b])\r\n  ```\r\n\r\nOnce assigned to the module, these values are immutable (and if they were a mutable list, the list\r\nis made immutable). This ensures that even when not using @script these\r\nvalues cannot be changed afterward.\r\n\r\nThese constants then can be used in script methods:\r\n\r\n\r\n```\r\n  if self.use_bias:\r\n    # constant propagation will eliminate unused code\r\n    a += self.bias\r\n  for m in self.ensemble:\r\n    # this will unroll for everything in the ensemble\r\n    o = m(i)\r\n    ...\r\n```\r\n\r\nSupport for numbers can be done by implementing a SugaredValue with a `asValue` overload.\r\nSupport for having lists and for loops can be accomplished by adding:\r\n\r\n```\r\n virtual std::vector<SugaredValue> unrolled_for(SourceRange loc, Method& m);\r\n```\r\n\r\nto SugaredValue. For each value 'v' returned, the code generator will generate an instance of the \r\nloop with the loop iterator 'i' bound to the SugaredValue 'v'. "}