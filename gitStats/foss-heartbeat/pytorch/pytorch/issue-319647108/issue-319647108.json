{"url": "https://api.github.com/repos/pytorch/pytorch/issues/7181", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/7181/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/7181/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/7181/events", "html_url": "https://github.com/pytorch/pytorch/issues/7181", "id": 319647108, "node_id": "MDU6SXNzdWUzMTk2NDcxMDg=", "number": 7181, "title": "Connection refused with torch.multiprocessing", "user": {"login": "zou3519", "id": 5652049, "node_id": "MDQ6VXNlcjU2NTIwNDk=", "avatar_url": "https://avatars3.githubusercontent.com/u/5652049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zou3519", "html_url": "https://github.com/zou3519", "followers_url": "https://api.github.com/users/zou3519/followers", "following_url": "https://api.github.com/users/zou3519/following{/other_user}", "gists_url": "https://api.github.com/users/zou3519/gists{/gist_id}", "starred_url": "https://api.github.com/users/zou3519/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zou3519/subscriptions", "organizations_url": "https://api.github.com/users/zou3519/orgs", "repos_url": "https://api.github.com/users/zou3519/repos", "events_url": "https://api.github.com/users/zou3519/events{/privacy}", "received_events_url": "https://api.github.com/users/zou3519/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 6, "created_at": "2018-05-02T17:39:19Z", "updated_at": "2018-10-30T18:57:19Z", "closed_at": "2018-05-04T15:32:09Z", "author_association": "CONTRIBUTOR", "body_html": "<p>The below code works on a Mac I tested but not on a Linux box. What it does at a high level is:</p>\n<ol>\n<li>create a (CPU) tensor, put it into a queue</li>\n<li>on second process: take the tensor from the queue. Send another (different) tensor through the queue.</li>\n<li>on third process: take the tensor from the queue. Send another (different) tensor through the queue</li>\n<li>on original process: take the tensor from the queue.</li>\n</ol>\n<p>On step (3), taking the tensor for the queue, the program crashes with \"ConnectionRefusedError: [Errno 111] Connection refused\".</p>\n<p>Repro:</p>\n<pre><code>import torch\nimport torch.multiprocessing as mp\nimport os\n\ndevice = 'cpu'\n\ndef check(tensor):\n    print(\"[{}] Checking tensor:\".format(os.getpid()))\n    print(tensor)\n    if (tensor - torch.ones(10, device=device)).norm() &gt; 0.0001:\n        raise RuntimeError(\"bad tensor\")\n\ndef run(queue):\n    print(\"[{}] spawned\".format(os.getpid()))\n    tensor = queue.get()\n    check(tensor)\n    queue.put(torch.ones(10, device=device))\n\nif __name__ == \"__main__\":\n    # mp.set_sharing_strategy('file_system')\n    mp.set_start_method('spawn')\n    a = torch.ones(100, device=device)\n\n    q = mp.Queue()\n    tensor = torch.ones(10, device=device)\n    q.put(tensor)\n\n    p = mp.Process(target=run, args=(q,))\n    p.start()\n    p.join(10)\n\n    p2 = mp.Process(target=run, args=(q,))\n    p2.start()\n    p2.join(10)\n\n    print(\"original process\")\n    t2 = q.get()\n    check(t2)\n</code></pre>\n<p>Output:</p>\n<pre><code>[37604] reduce_storage\n[37673] spawned\n[37673] Checking tensor:\ntensor([ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.])\n[37673] reduce_storage\n[37741] spawned\nProcess Process-2:\nTraceback (most recent call last):\n  File \"/private/home/rzou/local/miniconda3/lib/python3.6/multiprocessing/process.py\", line 258, in _bootstrap\n    self.run()\n  File \"/private/home/rzou/local/miniconda3/lib/python3.6/multiprocessing/process.py\", line 93, in run\n    self._target(*self._args, **self._kwargs)\n  File \"/private/home/rzou/pytorch/pytorch/cuda3.py\", line 18, in run\n    tensor = queue.get()\n  File \"/private/home/rzou/local/miniconda3/lib/python3.6/multiprocessing/queues.py\", line 113, in get\n    return _ForkingPickler.loads(res)\n  File \"/private/home/rzou/pytorch/pytorch/torch/multiprocessing/reductions.py\", line 70, in rebuild_storage_fd\n    fd = df.detach()\n  File \"/private/home/rzou/local/miniconda3/lib/python3.6/multiprocessing/resource_sharer.py\", line 57, in detach\n    with _resource_sharer.get_connection(self._id) as conn:\n  File \"/private/home/rzou/local/miniconda3/lib/python3.6/multiprocessing/resource_sharer.py\", line 87, in get_connection\n    c = Client(address, authkey=process.current_process().authkey)\n  File \"/private/home/rzou/local/miniconda3/lib/python3.6/multiprocessing/connection.py\", line 487, in Client\n    c = SocketClient(address)\n  File \"/private/home/rzou/local/miniconda3/lib/python3.6/multiprocessing/connection.py\", line 614, in SocketClient\n    s.connect(address)\nConnectionRefusedError: [Errno 111] Connection refused\noriginal process\n</code></pre>", "body_text": "The below code works on a Mac I tested but not on a Linux box. What it does at a high level is:\n\ncreate a (CPU) tensor, put it into a queue\non second process: take the tensor from the queue. Send another (different) tensor through the queue.\non third process: take the tensor from the queue. Send another (different) tensor through the queue\non original process: take the tensor from the queue.\n\nOn step (3), taking the tensor for the queue, the program crashes with \"ConnectionRefusedError: [Errno 111] Connection refused\".\nRepro:\nimport torch\nimport torch.multiprocessing as mp\nimport os\n\ndevice = 'cpu'\n\ndef check(tensor):\n    print(\"[{}] Checking tensor:\".format(os.getpid()))\n    print(tensor)\n    if (tensor - torch.ones(10, device=device)).norm() > 0.0001:\n        raise RuntimeError(\"bad tensor\")\n\ndef run(queue):\n    print(\"[{}] spawned\".format(os.getpid()))\n    tensor = queue.get()\n    check(tensor)\n    queue.put(torch.ones(10, device=device))\n\nif __name__ == \"__main__\":\n    # mp.set_sharing_strategy('file_system')\n    mp.set_start_method('spawn')\n    a = torch.ones(100, device=device)\n\n    q = mp.Queue()\n    tensor = torch.ones(10, device=device)\n    q.put(tensor)\n\n    p = mp.Process(target=run, args=(q,))\n    p.start()\n    p.join(10)\n\n    p2 = mp.Process(target=run, args=(q,))\n    p2.start()\n    p2.join(10)\n\n    print(\"original process\")\n    t2 = q.get()\n    check(t2)\n\nOutput:\n[37604] reduce_storage\n[37673] spawned\n[37673] Checking tensor:\ntensor([ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.])\n[37673] reduce_storage\n[37741] spawned\nProcess Process-2:\nTraceback (most recent call last):\n  File \"/private/home/rzou/local/miniconda3/lib/python3.6/multiprocessing/process.py\", line 258, in _bootstrap\n    self.run()\n  File \"/private/home/rzou/local/miniconda3/lib/python3.6/multiprocessing/process.py\", line 93, in run\n    self._target(*self._args, **self._kwargs)\n  File \"/private/home/rzou/pytorch/pytorch/cuda3.py\", line 18, in run\n    tensor = queue.get()\n  File \"/private/home/rzou/local/miniconda3/lib/python3.6/multiprocessing/queues.py\", line 113, in get\n    return _ForkingPickler.loads(res)\n  File \"/private/home/rzou/pytorch/pytorch/torch/multiprocessing/reductions.py\", line 70, in rebuild_storage_fd\n    fd = df.detach()\n  File \"/private/home/rzou/local/miniconda3/lib/python3.6/multiprocessing/resource_sharer.py\", line 57, in detach\n    with _resource_sharer.get_connection(self._id) as conn:\n  File \"/private/home/rzou/local/miniconda3/lib/python3.6/multiprocessing/resource_sharer.py\", line 87, in get_connection\n    c = Client(address, authkey=process.current_process().authkey)\n  File \"/private/home/rzou/local/miniconda3/lib/python3.6/multiprocessing/connection.py\", line 487, in Client\n    c = SocketClient(address)\n  File \"/private/home/rzou/local/miniconda3/lib/python3.6/multiprocessing/connection.py\", line 614, in SocketClient\n    s.connect(address)\nConnectionRefusedError: [Errno 111] Connection refused\noriginal process", "body": "The below code works on a Mac I tested but not on a Linux box. What it does at a high level is:\r\n1) create a (CPU) tensor, put it into a queue\r\n2) on second process: take the tensor from the queue. Send another (different) tensor through the queue.\r\n3) on third process: take the tensor from the queue. Send another (different) tensor through the queue\r\n4) on original process: take the tensor from the queue.\r\n\r\nOn step (3), taking the tensor for the queue, the program crashes with \"ConnectionRefusedError: [Errno 111] Connection refused\".\r\n\r\nRepro:\r\n```\r\nimport torch\r\nimport torch.multiprocessing as mp\r\nimport os\r\n\r\ndevice = 'cpu'\r\n\r\ndef check(tensor):\r\n    print(\"[{}] Checking tensor:\".format(os.getpid()))\r\n    print(tensor)\r\n    if (tensor - torch.ones(10, device=device)).norm() > 0.0001:\r\n        raise RuntimeError(\"bad tensor\")\r\n\r\ndef run(queue):\r\n    print(\"[{}] spawned\".format(os.getpid()))\r\n    tensor = queue.get()\r\n    check(tensor)\r\n    queue.put(torch.ones(10, device=device))\r\n\r\nif __name__ == \"__main__\":\r\n    # mp.set_sharing_strategy('file_system')\r\n    mp.set_start_method('spawn')\r\n    a = torch.ones(100, device=device)\r\n\r\n    q = mp.Queue()\r\n    tensor = torch.ones(10, device=device)\r\n    q.put(tensor)\r\n\r\n    p = mp.Process(target=run, args=(q,))\r\n    p.start()\r\n    p.join(10)\r\n\r\n    p2 = mp.Process(target=run, args=(q,))\r\n    p2.start()\r\n    p2.join(10)\r\n\r\n    print(\"original process\")\r\n    t2 = q.get()\r\n    check(t2)\r\n```\r\n\r\nOutput:\r\n```\r\n[37604] reduce_storage\r\n[37673] spawned\r\n[37673] Checking tensor:\r\ntensor([ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.])\r\n[37673] reduce_storage\r\n[37741] spawned\r\nProcess Process-2:\r\nTraceback (most recent call last):\r\n  File \"/private/home/rzou/local/miniconda3/lib/python3.6/multiprocessing/process.py\", line 258, in _bootstrap\r\n    self.run()\r\n  File \"/private/home/rzou/local/miniconda3/lib/python3.6/multiprocessing/process.py\", line 93, in run\r\n    self._target(*self._args, **self._kwargs)\r\n  File \"/private/home/rzou/pytorch/pytorch/cuda3.py\", line 18, in run\r\n    tensor = queue.get()\r\n  File \"/private/home/rzou/local/miniconda3/lib/python3.6/multiprocessing/queues.py\", line 113, in get\r\n    return _ForkingPickler.loads(res)\r\n  File \"/private/home/rzou/pytorch/pytorch/torch/multiprocessing/reductions.py\", line 70, in rebuild_storage_fd\r\n    fd = df.detach()\r\n  File \"/private/home/rzou/local/miniconda3/lib/python3.6/multiprocessing/resource_sharer.py\", line 57, in detach\r\n    with _resource_sharer.get_connection(self._id) as conn:\r\n  File \"/private/home/rzou/local/miniconda3/lib/python3.6/multiprocessing/resource_sharer.py\", line 87, in get_connection\r\n    c = Client(address, authkey=process.current_process().authkey)\r\n  File \"/private/home/rzou/local/miniconda3/lib/python3.6/multiprocessing/connection.py\", line 487, in Client\r\n    c = SocketClient(address)\r\n  File \"/private/home/rzou/local/miniconda3/lib/python3.6/multiprocessing/connection.py\", line 614, in SocketClient\r\n    s.connect(address)\r\nConnectionRefusedError: [Errno 111] Connection refused\r\noriginal process\r\n```"}