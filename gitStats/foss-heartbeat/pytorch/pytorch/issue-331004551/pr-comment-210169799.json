{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/210169799", "pull_request_review_id": 146328591, "id": 210169799, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDE2OTc5OQ==", "diff_hunk": "@@ -8347,6 +8351,392 @@ def __call__(self, input):\n     fullname='AdaptiveLogSoftmax'))\n \n \n+# The following are helpers for TestAffine, below.\n+if torch.cuda.is_available():\n+    def device_():\n+        return ['cpu', 'cuda']\n+else:\n+    def device_():\n+        return ['cpu']\n+\n+\n+def angle_rad_():\n+    return [r * math.pi * 2 for r in [0.0, 0.5, 0.25, 0.125, random.random()]]\n+\n+\n+def axis_vector_():\n+    t = (random.random(), random.random(), random.random())\n+    l = sum(x ** 2 for x in t) ** 0.5\n+\n+    return [(1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0), tuple(x / l for x in t)]\n+\n+\n+def input_size2d_():\n+    return [[1, 1, 3, 5], [1, 1, 3, 3], [1, 1, 4, 4], [1, 1, 3, 4]]\n+\n+\n+def output_size2d_():\n+    return [[1, 1, 5, 3], [1, 1, 3, 5], [1, 1, 4, 3], [1, 1, 5, 5], [1, 1, 6, 6]]\n+\n+\n+def input_size2dsq_():\n+    return [[1, 1, 2, 2], [1, 1, 3, 3], [1, 1, 4, 4], [1, 1, 6, 6]]\n+\n+\n+def output_size2dsq_():\n+    return [[1, 1, 2, 2], [1, 1, 3, 3], [1, 1, 4, 4], [1, 1, 5, 5], [1, 1, 6, 6]]\n+\n+\n+def input_size3d_():\n+    return [[1, 1, 2, 2, 2], [1, 1, 2, 3, 4], [1, 1, 3, 3, 3], [1, 1, 4, 4, 4], [1, 1, 3, 4, 5]]\n+\n+\n+def input_size3dsq_():\n+    return [[1, 1, 2, 2, 2], [1, 1, 3, 3, 3], [1, 1, 4, 4, 4], [1, 1, 6, 6, 6]]\n+\n+\n+def output_size3dsq_():\n+    return [[1, 1, 2, 2, 2], [1, 1, 3, 3, 3], [1, 1, 4, 4, 4], [1, 1, 5, 5, 5], [1, 1, 6, 6, 6]]\n+\n+\n+def output_size3d_():\n+    return [[1, 1, 2, 2, 2], [1, 1, 3, 3, 3], [1, 1, 3, 4, 5], [1, 1, 4, 3, 2], [1, 1, 5, 5, 5], [1, 1, 6, 6, 6]]\n+\n+\n+def _buildEquivalentAffineTransforms2d(device, input_size, output_size, angle_rad):\n+    input_center = [(x - 1) / 2.0 for x in input_size]\n+    output_center = [(x - 1) / 2.0 for x in output_size]\n+\n+    s = math.sin(angle_rad)\n+    c = math.cos(angle_rad)\n+\n+    intrans_ary = np.array([\n+        [1, 0, input_center[2]],\n+        [0, 1, input_center[3]],\n+        [0, 0, 1],\n+    ], dtype=np.float64)\n+\n+    inscale_ary = np.array([\n+        [input_center[2], 0, 0],\n+        [0, input_center[3], 0],\n+        [0, 0, 1],\n+    ], dtype=np.float64)\n+\n+    rotation_ary = np.array([\n+        [c, -s, 0],\n+        [s, c, 0],\n+        [0, 0, 1],\n+    ], dtype=np.float64)\n+\n+    outscale_ary = np.array([\n+        [1.0 / output_center[2], 0, 0],\n+        [0, 1.0 / output_center[3], 0],\n+        [0, 0, 1],\n+    ], dtype=np.float64)\n+\n+    outtrans_ary = np.array([\n+        [1, 0, -output_center[2]],\n+        [0, 1, -output_center[3]],\n+        [0, 0, 1],\n+    ], dtype=np.float64)\n+\n+    reorder_ary = np.array([\n+        [0, 1, 0],\n+        [1, 0, 0],\n+        [0, 0, 1],\n+    ], dtype=np.float64)\n+\n+    transform_ary = np.dot(np.dot(np.dot(np.dot(\n+        intrans_ary,\n+        inscale_ary),\n+        rotation_ary.T),\n+        outscale_ary),\n+        outtrans_ary)\n+    grid_ary = np.dot(np.dot(np.dot(reorder_ary, rotation_ary.T), outscale_ary), outtrans_ary)\n+\n+    transform_tensor = torch.from_numpy((rotation_ary)).to(device, torch.float32)\n+    transform_tensor = transform_tensor[:2].unsqueeze(0)\n+\n+    return transform_tensor, transform_ary, grid_ary\n+\n+\n+def _buildEquivalentAffineTransforms3d(device, input_size, output_size, angle_rad, axis_vector):\n+    input_center = [(x - 1) / 2.0 for x in input_size]\n+    output_center = [(x - 1) / 2.0 for x in output_size]\n+\n+    s = math.sin(angle_rad)\n+    c = math.cos(angle_rad)\n+    c1 = 1 - c\n+\n+    intrans_ary = np.array([\n+        [1, 0, 0, input_center[2]],\n+        [0, 1, 0, input_center[3]],\n+        [0, 0, 1, input_center[4]],\n+        [0, 0, 0, 1],\n+    ], dtype=np.float64)\n+\n+    inscale_ary = np.array([\n+        [input_center[2], 0, 0, 0],\n+        [0, input_center[3], 0, 0],\n+        [0, 0, input_center[4], 0],\n+        [0, 0, 0, 1],\n+    ], dtype=np.float64)\n+\n+    l, m, n = axis_vector\n+    scipyRotation_ary = np.array([\n+        [l * l * c1 + c, m * l * c1 - n * s, n * l * c1 + m * s, 0],\n+        [l * m * c1 + n * s, m * m * c1 + c, n * m * c1 - l * s, 0],\n+        [l * n * c1 - m * s, m * n * c1 + l * s, n * n * c1 + c, 0],\n+        [0, 0, 0, 1],\n+    ], dtype=np.float64)\n+\n+    z, y, x = axis_vector\n+    torchRotation_ary = np.array([\n+        [x * x * c1 + c, y * x * c1 - z * s, z * x * c1 + y * s, 0],\n+        [x * y * c1 + z * s, y * y * c1 + c, z * y * c1 - x * s, 0],\n+        [x * z * c1 - y * s, y * z * c1 + x * s, z * z * c1 + c, 0],\n+        [0, 0, 0, 1],\n+    ], dtype=np.float64)\n+\n+    outscale_ary = np.array([\n+        [1.0 / output_center[2], 0, 0, 0],\n+        [0, 1.0 / output_center[3], 0, 0],\n+        [0, 0, 1.0 / output_center[4], 0],\n+        [0, 0, 0, 1],\n+    ], dtype=np.float64)\n+\n+    outtrans_ary = np.array([\n+        [1, 0, 0, -output_center[2]],\n+        [0, 1, 0, -output_center[3]],\n+        [0, 0, 1, -output_center[4]],\n+        [0, 0, 0, 1],\n+    ], dtype=np.float64)\n+\n+    reorder_ary = np.array([\n+        [0, 0, 1, 0],\n+        [0, 1, 0, 0],\n+        [1, 0, 0, 0],\n+        [0, 0, 0, 1],\n+    ], dtype=np.float64)\n+\n+    transform_ary = np.dot(np.dot(np.dot(np.dot(\n+        intrans_ary,\n+        inscale_ary),\n+        np.linalg.inv(scipyRotation_ary)),\n+        outscale_ary),\n+        outtrans_ary)\n+    grid_ary = np.dot(np.dot(np.dot(reorder_ary, np.linalg.inv(scipyRotation_ary)), outscale_ary), outtrans_ary)\n+\n+    transform_tensor = torch.from_numpy((torchRotation_ary)).to(device, torch.float32)\n+    transform_tensor = transform_tensor[:3].unsqueeze(0)\n+\n+    return transform_tensor, transform_ary, grid_ary\n+\n+\n+class TestAffine(TestCase):", "path": "test/test_nn.py", "position": null, "original_position": 206, "commit_id": "b74a18beaf09cc711516acc6e9b88ca97b0bb2cf", "original_commit_id": "76d61c76e7edb0445e73f26d8e433ef4b09685ec", "user": {"login": "SsnL", "id": 5674597, "node_id": "MDQ6VXNlcjU2NzQ1OTc=", "avatar_url": "https://avatars2.githubusercontent.com/u/5674597?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SsnL", "html_url": "https://github.com/SsnL", "followers_url": "https://api.github.com/users/SsnL/followers", "following_url": "https://api.github.com/users/SsnL/following{/other_user}", "gists_url": "https://api.github.com/users/SsnL/gists{/gist_id}", "starred_url": "https://api.github.com/users/SsnL/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SsnL/subscriptions", "organizations_url": "https://api.github.com/users/SsnL/orgs", "repos_url": "https://api.github.com/users/SsnL/repos", "events_url": "https://api.github.com/users/SsnL/events{/privacy}", "received_events_url": "https://api.github.com/users/SsnL/received_events", "type": "User", "site_admin": false}, "body": "Can this just be methods of `TestNN` instead of a new TestCase?", "created_at": "2018-08-15T04:41:19Z", "updated_at": "2018-11-23T15:49:23Z", "html_url": "https://github.com/pytorch/pytorch/pull/8322#discussion_r210169799", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/8322", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/210169799"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/8322#discussion_r210169799"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/8322"}}, "body_html": "<p>Can this just be methods of <code>TestNN</code> instead of a new TestCase?</p>", "body_text": "Can this just be methods of TestNN instead of a new TestCase?"}