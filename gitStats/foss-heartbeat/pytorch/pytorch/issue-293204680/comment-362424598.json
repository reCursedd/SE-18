{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/362424598", "html_url": "https://github.com/pytorch/pytorch/issues/4959#issuecomment-362424598", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/4959", "id": 362424598, "node_id": "MDEyOklzc3VlQ29tbWVudDM2MjQyNDU5OA==", "user": {"login": "fmassa", "id": 9110200, "node_id": "MDQ6VXNlcjkxMTAyMDA=", "avatar_url": "https://avatars2.githubusercontent.com/u/9110200?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fmassa", "html_url": "https://github.com/fmassa", "followers_url": "https://api.github.com/users/fmassa/followers", "following_url": "https://api.github.com/users/fmassa/following{/other_user}", "gists_url": "https://api.github.com/users/fmassa/gists{/gist_id}", "starred_url": "https://api.github.com/users/fmassa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fmassa/subscriptions", "organizations_url": "https://api.github.com/users/fmassa/orgs", "repos_url": "https://api.github.com/users/fmassa/repos", "events_url": "https://api.github.com/users/fmassa/events{/privacy}", "received_events_url": "https://api.github.com/users/fmassa/received_events", "type": "User", "site_admin": false}, "created_at": "2018-02-01T22:32:52Z", "updated_at": "2018-02-01T22:32:52Z", "author_association": "MEMBER", "body_html": "<p>If your dataset already supports indexing by lists and performs the <code>collate_fn</code> internally, one possibility is to let the user write their own <code>Sampler</code> that returns a tuple of indices at a time.<br>\nSo the <code>__iter__</code> method would look something like</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">def</span> <span class=\"pl-c1\">__iter__</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>):\n        <span class=\"pl-k\">return</span> <span class=\"pl-c1\">iter</span>(torch.randperm(<span class=\"pl-c1\">len</span>(<span class=\"pl-c1\">self</span>.data_source)).long().split(batch_size))</pre></div>\n<p>And then you can just add the batch size in the <code>DataLoader</code> to 1.<br>\nWhat do you think?</p>", "body_text": "If your dataset already supports indexing by lists and performs the collate_fn internally, one possibility is to let the user write their own Sampler that returns a tuple of indices at a time.\nSo the __iter__ method would look something like\ndef __iter__(self):\n        return iter(torch.randperm(len(self.data_source)).long().split(batch_size))\nAnd then you can just add the batch size in the DataLoader to 1.\nWhat do you think?", "body": "If your dataset already supports indexing by lists and performs the `collate_fn` internally, one possibility is to let the user write their own `Sampler` that returns a tuple of indices at a time.\r\nSo the `__iter__` method would look something like\r\n```python\r\ndef __iter__(self):\r\n        return iter(torch.randperm(len(self.data_source)).long().split(batch_size))\r\n```\r\nAnd then you can just add the batch size in the `DataLoader` to 1.\r\nWhat do you think?"}