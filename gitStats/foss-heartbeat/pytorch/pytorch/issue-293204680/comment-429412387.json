{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/429412387", "html_url": "https://github.com/pytorch/pytorch/issues/4959#issuecomment-429412387", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/4959", "id": 429412387, "node_id": "MDEyOklzc3VlQ29tbWVudDQyOTQxMjM4Nw==", "user": {"login": "mboratko", "id": 611553, "node_id": "MDQ6VXNlcjYxMTU1Mw==", "avatar_url": "https://avatars1.githubusercontent.com/u/611553?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mboratko", "html_url": "https://github.com/mboratko", "followers_url": "https://api.github.com/users/mboratko/followers", "following_url": "https://api.github.com/users/mboratko/following{/other_user}", "gists_url": "https://api.github.com/users/mboratko/gists{/gist_id}", "starred_url": "https://api.github.com/users/mboratko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mboratko/subscriptions", "organizations_url": "https://api.github.com/users/mboratko/orgs", "repos_url": "https://api.github.com/users/mboratko/repos", "events_url": "https://api.github.com/users/mboratko/events{/privacy}", "received_events_url": "https://api.github.com/users/mboratko/received_events", "type": "User", "site_admin": false}, "created_at": "2018-10-12T18:09:28Z", "updated_at": "2018-10-12T18:28:11Z", "author_association": "NONE", "body_html": "<p>I think a better architecture would be for the collate_fn functionality to be attached to the <code>Dataset</code> object itself, like so:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">class</span> <span class=\"pl-en\">Dataset</span>(<span class=\"pl-c1\">object</span>):\n    <span class=\"pl-k\">def</span> <span class=\"pl-c1\">__getitem__</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>, <span class=\"pl-smi\">index</span>):\n        <span class=\"pl-k\">if</span> <span class=\"pl-c1\">type</span>(index) <span class=\"pl-k\">is</span> <span class=\"pl-c1\">int</span>:\n            <span class=\"pl-k\">raise</span> <span class=\"pl-c1\">NotImplementedError</span>\n        <span class=\"pl-k\">else</span>:\n            requested_elements <span class=\"pl-k\">=</span> [<span class=\"pl-c1\">self</span>[i] <span class=\"pl-k\">for</span> i <span class=\"pl-k\">in</span> index]\n            <span class=\"pl-k\">return</span> default_collate(requested_elements)</pre></div>\n<p>and the call within the <code>DataLoader</code> should be replaced as <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=1499555\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/colinfang\">@colinfang</a> described:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-c\"><span class=\"pl-c\">#</span> batch = self.collate_fn([self.dataset[i] for i in indices])</span>\nbatch <span class=\"pl-k\">=</span> <span class=\"pl-c1\">self</span>.dataset[indices]</pre></div>\n<p>This isn't completely backwards-compatible with the current API, however it's a simple fix. Exising implementations which are working can just change their overridden <code>__getitem__</code> method to</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">if</span> <span class=\"pl-c1\">type</span>(index) <span class=\"pl-k\">is</span> <span class=\"pl-c1\">int</span>:\n    (<span class=\"pl-c1\">...</span> existing implementation<span class=\"pl-c1\">...</span>)\n<span class=\"pl-k\">else</span>:\n    <span class=\"pl-c1\">super</span>().<span class=\"pl-c1\">__getitem__</span>(<span class=\"pl-c1\">self</span>, index)</pre></div>\n<p>I agree that tensorizing the data and using it directly is a workaround for now, however there are libraries built expecting <code>DataLoader</code> objects to be fed into them as well and this solution doesn't work in that case.</p>", "body_text": "I think a better architecture would be for the collate_fn functionality to be attached to the Dataset object itself, like so:\nclass Dataset(object):\n    def __getitem__(self, index):\n        if type(index) is int:\n            raise NotImplementedError\n        else:\n            requested_elements = [self[i] for i in index]\n            return default_collate(requested_elements)\nand the call within the DataLoader should be replaced as @colinfang described:\n# batch = self.collate_fn([self.dataset[i] for i in indices])\nbatch = self.dataset[indices]\nThis isn't completely backwards-compatible with the current API, however it's a simple fix. Exising implementations which are working can just change their overridden __getitem__ method to\nif type(index) is int:\n    (... existing implementation...)\nelse:\n    super().__getitem__(self, index)\nI agree that tensorizing the data and using it directly is a workaround for now, however there are libraries built expecting DataLoader objects to be fed into them as well and this solution doesn't work in that case.", "body": "I think a better architecture would be for the collate_fn functionality to be attached to the `Dataset` object itself, like so:\r\n\r\n```python\r\nclass Dataset(object):\r\n    def __getitem__(self, index):\r\n        if type(index) is int:\r\n            raise NotImplementedError\r\n        else:\r\n            requested_elements = [self[i] for i in index]\r\n            return default_collate(requested_elements)\r\n```\r\n\r\nand the call within the `DataLoader` should be replaced as @colinfang described:\r\n\r\n```python\r\n# batch = self.collate_fn([self.dataset[i] for i in indices])\r\nbatch = self.dataset[indices]\r\n```\r\n\r\nThis isn't completely backwards-compatible with the current API, however it's a simple fix. Exising implementations which are working can just change their overridden `__getitem__` method to\r\n```python\r\nif type(index) is int:\r\n    (... existing implementation...)\r\nelse:\r\n    super().__getitem__(self, index)\r\n```\r\n\r\nI agree that tensorizing the data and using it directly is a workaround for now, however there are libraries built expecting `DataLoader` objects to be fed into them as well and this solution doesn't work in that case."}