{"url": "https://api.github.com/repos/pytorch/pytorch/issues/13442", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/13442/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/13442/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/13442/events", "html_url": "https://github.com/pytorch/pytorch/issues/13442", "id": 376268852, "node_id": "MDU6SXNzdWUzNzYyNjg4NTI=", "number": 13442, "title": "a problem about convert-caffe2-to-onnx tool: some external_input with same name result in conversion failure!", "user": {"login": "hankchuan", "id": 44661896, "node_id": "MDQ6VXNlcjQ0NjYxODk2", "avatar_url": "https://avatars1.githubusercontent.com/u/44661896?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hankchuan", "html_url": "https://github.com/hankchuan", "followers_url": "https://api.github.com/users/hankchuan/followers", "following_url": "https://api.github.com/users/hankchuan/following{/other_user}", "gists_url": "https://api.github.com/users/hankchuan/gists{/gist_id}", "starred_url": "https://api.github.com/users/hankchuan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hankchuan/subscriptions", "organizations_url": "https://api.github.com/users/hankchuan/orgs", "repos_url": "https://api.github.com/users/hankchuan/repos", "events_url": "https://api.github.com/users/hankchuan/events{/privacy}", "received_events_url": "https://api.github.com/users/hankchuan/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2018-11-01T06:22:44Z", "updated_at": "2018-11-01T06:22:44Z", "closed_at": null, "author_association": "NONE", "body_html": "<h2><g-emoji class=\"g-emoji\" alias=\"bug\" fallback-src=\"https://assets-cdn.github.com/images/icons/emoji/unicode/1f41b.png\">\ud83d\udc1b</g-emoji> Bug</h2>\n<p>sometimes, OP may contain input with the same name as another OP  in caffe2(or caffe), but in fact, they represent different tensor. for example as follows, the first and the third OP contains input 'conv1_w', But they represent different weights. this is allowed in caffe2, but should be forbidden in onnx.<br>\nop {<br>\ninput: \"data\"<br>\n<strong>input: \"conv1_w\"</strong><br>\ninput: \"conv1_b\"<br>\noutput: \"conv1\"<br>\ntype: \"Conv\"<br>\narg {<br>\nname: \"stride\"<br>\ni: 2<br>\n}<br>\narg {<br>\nname: \"pad\"<br>\ni: 3<br>\n}<br>\narg {<br>\nname: \"kernel\"<br>\ni: 7<br>\n}<br>\n}<br>\nop {<br>\ninput: \"conv1\"<br>\ninput: \"conv1_scale\"<br>\ninput: \"conv1_bias\"<br>\ninput: \"conv1_mean\"<br>\ninput: \"conv1_var\"<br>\noutput: \"conv1\"<br>\ntype: \"SpatialBN\"<br>\narg {<br>\nname: \"is_test\"<br>\ni: 1<br>\n}<br>\narg {<br>\nname: \"epsilon\"<br>\nf: 9.99999974738e-06<br>\n}<br>\narg {<br>\nname: \"order\"<br>\ns: \"NCHW\"<br>\n}<br>\n}<br>\nop {<br>\ninput: \"conv1\"<br>\n<strong>input: \"conv1_w\"</strong><br>\noutput: \"conv1_internal\"<br>\ntype: \"Mul\"<br>\narg {<br>\nname: \"axis\"<br>\ni: 1<br>\n}<br>\narg {<br>\nname: \"broadcast\"<br>\ni: 1<br>\n}<br>\n}</p>\n<h2>code review</h2>\n<p>I noticed that the OP's input/output name was actually handled to ensure it's uniqueness, but only for input/output generated in the middle of the network, not for the name of external_input.</p>\n<p>pytorch/caffe2/python/core.py:</p>\n<pre><code>def get_ssa(net, blob_versions=None):\n    \"\"\"\n    Given a net, return a structure containing the version of each input and\n    output blob used by each operator.\n    Args:\n        net:            either a Net or a NetDef\n        blob_versions:  (optional) map with current version number for given\n                        blob names. If not provided or blob not found, start\n                        from version 0.\n    Returns:\n        Tuple (ssa, blob_versions)\n        ssa:            list of tuples (versioned_inputs, versioned_outputs)\n                        for each op in the net. A versioned input is a tuple\n                        (blob_name, version).\n        blob_versions:  updated map with latest version of each blob found in\n                        the net.\n    \"\"\"\n    proto = net.Proto() if isinstance(net, Net) else net\n    assert isinstance(proto, caffe2_pb2.NetDef)\n    if blob_versions is None:\n        blob_versions = {}\n    if isinstance(net, list):\n        return [get_ssa(n, blob_versions) for n in net], blob_versions\n    for i in proto.external_input:\n        if i not in blob_versions:\n            blob_versions[str(i)] = 0\n    ssa = []\n    for op in proto.op:\n        if not proto.external_input:\n            for i in op.input:\n                if i not in blob_versions:\n                    blob_versions[i] = 0\n        inputs = [(str(i), blob_versions.get(str(i), 0)) for i in op.input]    \n        for o in op.output:\n            blob_versions[str(o)] = blob_versions.get(str(o), 0) + 1   **//only handle output of last OP**\n        outputs = [(str(o), blob_versions[str(o)]) for o in op.output]\n        ssa.append((inputs, outputs))\n    return ssa, blob_versions\n</code></pre>", "body_text": "\ud83d\udc1b Bug\nsometimes, OP may contain input with the same name as another OP  in caffe2(or caffe), but in fact, they represent different tensor. for example as follows, the first and the third OP contains input 'conv1_w', But they represent different weights. this is allowed in caffe2, but should be forbidden in onnx.\nop {\ninput: \"data\"\ninput: \"conv1_w\"\ninput: \"conv1_b\"\noutput: \"conv1\"\ntype: \"Conv\"\narg {\nname: \"stride\"\ni: 2\n}\narg {\nname: \"pad\"\ni: 3\n}\narg {\nname: \"kernel\"\ni: 7\n}\n}\nop {\ninput: \"conv1\"\ninput: \"conv1_scale\"\ninput: \"conv1_bias\"\ninput: \"conv1_mean\"\ninput: \"conv1_var\"\noutput: \"conv1\"\ntype: \"SpatialBN\"\narg {\nname: \"is_test\"\ni: 1\n}\narg {\nname: \"epsilon\"\nf: 9.99999974738e-06\n}\narg {\nname: \"order\"\ns: \"NCHW\"\n}\n}\nop {\ninput: \"conv1\"\ninput: \"conv1_w\"\noutput: \"conv1_internal\"\ntype: \"Mul\"\narg {\nname: \"axis\"\ni: 1\n}\narg {\nname: \"broadcast\"\ni: 1\n}\n}\ncode review\nI noticed that the OP's input/output name was actually handled to ensure it's uniqueness, but only for input/output generated in the middle of the network, not for the name of external_input.\npytorch/caffe2/python/core.py:\ndef get_ssa(net, blob_versions=None):\n    \"\"\"\n    Given a net, return a structure containing the version of each input and\n    output blob used by each operator.\n    Args:\n        net:            either a Net or a NetDef\n        blob_versions:  (optional) map with current version number for given\n                        blob names. If not provided or blob not found, start\n                        from version 0.\n    Returns:\n        Tuple (ssa, blob_versions)\n        ssa:            list of tuples (versioned_inputs, versioned_outputs)\n                        for each op in the net. A versioned input is a tuple\n                        (blob_name, version).\n        blob_versions:  updated map with latest version of each blob found in\n                        the net.\n    \"\"\"\n    proto = net.Proto() if isinstance(net, Net) else net\n    assert isinstance(proto, caffe2_pb2.NetDef)\n    if blob_versions is None:\n        blob_versions = {}\n    if isinstance(net, list):\n        return [get_ssa(n, blob_versions) for n in net], blob_versions\n    for i in proto.external_input:\n        if i not in blob_versions:\n            blob_versions[str(i)] = 0\n    ssa = []\n    for op in proto.op:\n        if not proto.external_input:\n            for i in op.input:\n                if i not in blob_versions:\n                    blob_versions[i] = 0\n        inputs = [(str(i), blob_versions.get(str(i), 0)) for i in op.input]    \n        for o in op.output:\n            blob_versions[str(o)] = blob_versions.get(str(o), 0) + 1   **//only handle output of last OP**\n        outputs = [(str(o), blob_versions[str(o)]) for o in op.output]\n        ssa.append((inputs, outputs))\n    return ssa, blob_versions", "body": "## \ud83d\udc1b Bug\r\n  sometimes, OP may contain input with the same name as another OP  in caffe2(or caffe), but in fact, they represent different tensor. for example as follows, the first and the third OP contains input 'conv1_w', But they represent different weights. this is allowed in caffe2, but should be forbidden in onnx.\r\nop {\r\n  input: \"data\"\r\n  **input: \"conv1_w\"**\r\n  input: \"conv1_b\"\r\n  output: \"conv1\"\r\n  type: \"Conv\"\r\n  arg {\r\n    name: \"stride\"\r\n    i: 2\r\n  }\r\n  arg {\r\n    name: \"pad\"\r\n    i: 3\r\n  }\r\n  arg {\r\n    name: \"kernel\"\r\n    i: 7\r\n  }\r\n}\r\nop {\r\n  input: \"conv1\"\r\n  input: \"conv1_scale\"\r\n  input: \"conv1_bias\"\r\n  input: \"conv1_mean\"\r\n  input: \"conv1_var\"\r\n  output: \"conv1\"\r\n  type: \"SpatialBN\"\r\n  arg {\r\n    name: \"is_test\"\r\n    i: 1\r\n  }\r\n  arg {\r\n    name: \"epsilon\"\r\n    f: 9.99999974738e-06\r\n  }\r\n  arg {\r\n    name: \"order\"\r\n    s: \"NCHW\"\r\n  }\r\n}\r\nop {\r\n  input: \"conv1\"\r\n  **input: \"conv1_w\"**\r\n  output: \"conv1_internal\"\r\n  type: \"Mul\"\r\n  arg {\r\n    name: \"axis\"\r\n    i: 1\r\n  }\r\n  arg {\r\n    name: \"broadcast\"\r\n    i: 1\r\n  }\r\n}\r\n## code review\r\n\r\n  I noticed that the OP's input/output name was actually handled to ensure it's uniqueness, but only for input/output generated in the middle of the network, not for the name of external_input.\r\n\r\npytorch/caffe2/python/core.py:\r\n```\r\ndef get_ssa(net, blob_versions=None):\r\n    \"\"\"\r\n    Given a net, return a structure containing the version of each input and\r\n    output blob used by each operator.\r\n    Args:\r\n        net:            either a Net or a NetDef\r\n        blob_versions:  (optional) map with current version number for given\r\n                        blob names. If not provided or blob not found, start\r\n                        from version 0.\r\n    Returns:\r\n        Tuple (ssa, blob_versions)\r\n        ssa:            list of tuples (versioned_inputs, versioned_outputs)\r\n                        for each op in the net. A versioned input is a tuple\r\n                        (blob_name, version).\r\n        blob_versions:  updated map with latest version of each blob found in\r\n                        the net.\r\n    \"\"\"\r\n    proto = net.Proto() if isinstance(net, Net) else net\r\n    assert isinstance(proto, caffe2_pb2.NetDef)\r\n    if blob_versions is None:\r\n        blob_versions = {}\r\n    if isinstance(net, list):\r\n        return [get_ssa(n, blob_versions) for n in net], blob_versions\r\n    for i in proto.external_input:\r\n        if i not in blob_versions:\r\n            blob_versions[str(i)] = 0\r\n    ssa = []\r\n    for op in proto.op:\r\n        if not proto.external_input:\r\n            for i in op.input:\r\n                if i not in blob_versions:\r\n                    blob_versions[i] = 0\r\n        inputs = [(str(i), blob_versions.get(str(i), 0)) for i in op.input]    \r\n        for o in op.output:\r\n            blob_versions[str(o)] = blob_versions.get(str(o), 0) + 1   **//only handle output of last OP**\r\n        outputs = [(str(o), blob_versions[str(o)]) for o in op.output]\r\n        ssa.append((inputs, outputs))\r\n    return ssa, blob_versions\r\n```\r\n\r\n\r\n\r\n\r\n"}