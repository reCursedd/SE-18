{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/230946497", "pull_request_review_id": 171801494, "id": 230946497, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDk0NjQ5Nw==", "diff_hunk": "@@ -6,131 +6,180 @@\n #include <ATen/detail/CUDAHooksInterface.h>\n #include <c10/util/Exception.h>\n #include \"c10/util/Optional.h\"\n+#include <c10/detail/DeviceGuardImplInterface.h>\n \n #include <cstddef>\n \n namespace at {\n+\n /// RAII guard that sets a certain default device in its constructor, and\n-/// changes it back to the device that was originally active upon destruction.\n+/// changes it back to the device (for that device type) that was originally\n+/// active upon destruction.\n ///\n-/// The device is always reset to the one that was active at the time of\n-/// construction of the guard. Even if you `set_device` after construction, the\n-/// destructor will still reset the device to the one that was active at\n-/// construction time.\n-struct DeviceGuard {\n-  /// Default constructor, does nothing.\n-  DeviceGuard() = default;\n-\n+/// If a DeviceGuard is constructed without specifying a device type (this can\n+/// occur if you, e.g., pass a nullopt to the constructor), it behaves as if it\n+/// were a no-op \"CPU\" guard; e.g., current_device() reports that the current\n+/// device is kCPU.  This is different from passing Device(kCUDA, -1), which\n+/// says to use the current CUDA device; in this case, we will correctly query\n+/// what the current CUDA device is, won't change it, but WILL reset it\n+/// at the end of DeviceGuard.\n+class DeviceGuard {\n+public:\n   /// Set the current device to the passed Device.\n   explicit DeviceGuard(Device device) {\n-    set_device(device);\n+    init_device(device);\n   }\n \n-  explicit DeviceGuard(c10::optional<Device> device_opt) {\n+  /// Set the current device to the passed Device, if not nullopt;\n+  /// otherwise do nothing.\n+  explicit DeviceGuard(optional<Device> device_opt) {\n     if (device_opt.has_value()) {\n-      set_device(device_opt.value());\n+      init_device(device_opt.value());\n     }\n   }\n \n   /// Sets the current device to the device on which the given tensor is located.\n   explicit DeviceGuard(const Tensor& tensor) {\n-    set_device_from(tensor);\n+    init_device_from(tensor);\n   }\n \n   /// Sets the current device to the device on which the first tensor in the list is\n   /// located. If the list is empty, does nothing.\n   explicit DeviceGuard(const TensorList& tensors) {\n     if (!tensors.empty()) {\n-      set_device_from(tensors.front());\n+      init_device_from(tensors.front());\n     }\n   }\n \n+  /// A constructor for testing; permits explicitly passing in the\n+  /// DeviceGuardImpl.\n+  explicit DeviceGuard(Device device, const detail::DeviceGuardImplInterface* impl) {\n+    init_device(device, impl);\n+  }\n+\n   /// Copy is disallowed.\n   DeviceGuard(const DeviceGuard&) = delete;\n   DeviceGuard& operator=(const DeviceGuard&) = delete;\n \n-  /// Move-constructs this `DeviceGuard` from another `DeviceGuard`. The\n-  /// moved-from `DeviceGuard` is modified such that its destruction has no\n-  /// effect (does not reset the device).\n+  /// Move-constructs this `DeviceGuard` from another `DeviceGuard`.", "path": "aten/src/ATen/DeviceGuard.h", "position": null, "original_position": 76, "commit_id": "a8e5332de1ad3210b489c0d15b9f62a4097fe8b3", "original_commit_id": "a17b2ff1c5b440e20e06e6d2e43a6e8f215c8483", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "body": "You mean \"defusing\" :)\r\n\r\nThe move constructor is occasionally useful. It's currently used here:\r\n\r\n```\r\n  // NB: We don't need to hold the device guard when calling from TH\r\n  c10::optional<cuda::CUDAGuard> guard(\r\n    device_guard ?\r\n      make_optional(cuda::CUDAGuard(self->storage().device().index())) :\r\n      nullopt);\r\n```\r\n\r\nThis won't compile without the move constructor. Also, this is not equivalent to the optional constructor on CUDAGuard, since that constructor will still query the current device and restore it on exit.", "created_at": "2018-11-05T23:01:19Z", "updated_at": "2018-11-23T15:54:21Z", "html_url": "https://github.com/pytorch/pytorch/pull/13342#discussion_r230946497", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/13342", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/230946497"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/13342#discussion_r230946497"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/13342"}}, "body_html": "<p>You mean \"defusing\" :)</p>\n<p>The move constructor is occasionally useful. It's currently used here:</p>\n<pre><code>  // NB: We don't need to hold the device guard when calling from TH\n  c10::optional&lt;cuda::CUDAGuard&gt; guard(\n    device_guard ?\n      make_optional(cuda::CUDAGuard(self-&gt;storage().device().index())) :\n      nullopt);\n</code></pre>\n<p>This won't compile without the move constructor. Also, this is not equivalent to the optional constructor on CUDAGuard, since that constructor will still query the current device and restore it on exit.</p>", "body_text": "You mean \"defusing\" :)\nThe move constructor is occasionally useful. It's currently used here:\n  // NB: We don't need to hold the device guard when calling from TH\n  c10::optional<cuda::CUDAGuard> guard(\n    device_guard ?\n      make_optional(cuda::CUDAGuard(self->storage().device().index())) :\n      nullopt);\n\nThis won't compile without the move constructor. Also, this is not equivalent to the optional constructor on CUDAGuard, since that constructor will still query the current device and restore it on exit.", "in_reply_to_id": 230913352}