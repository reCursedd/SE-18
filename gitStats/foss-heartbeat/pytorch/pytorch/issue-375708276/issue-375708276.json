{"url": "https://api.github.com/repos/pytorch/pytorch/issues/13342", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/13342/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/13342/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/13342/events", "html_url": "https://github.com/pytorch/pytorch/pull/13342", "id": 375708276, "node_id": "MDExOlB1bGxSZXF1ZXN0MjI3MDkzMzI2", "number": 13342, "title": "Generalize DeviceGuard to work with arbitrary DeviceType, add InlineDeviceGuard for specialized use", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2018-10-30T21:49:40Z", "updated_at": "2018-11-23T15:54:36Z", "closed_at": "2018-11-11T20:12:36Z", "author_association": "CONTRIBUTOR", "pull_request": {"url": "https://api.github.com/repos/pytorch/pytorch/pulls/13342", "html_url": "https://github.com/pytorch/pytorch/pull/13342", "diff_url": "https://github.com/pytorch/pytorch/pull/13342.diff", "patch_url": "https://github.com/pytorch/pytorch/pull/13342.patch"}, "body_html": "<p>Stack:<br>\n\u00a0\u00a0\u00a0\u00a0<g-emoji class=\"g-emoji\" alias=\"black_circle\" fallback-src=\"https://assets-cdn.github.com/images/icons/emoji/unicode/26ab.png\">\u26ab\ufe0f</g-emoji>\u00a0 <strong><a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"375708276\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/13342\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/pytorch/pytorch/pull/13342/hovercard\" href=\"https://github.com/pytorch/pytorch/pull/13342\">#13342</a> Generalize DeviceGuard to work with arbitrary DeviceType, add InlineDeviceGuard for specialized use</strong>\u00a0\u00a0<a href=\"https://our.internmc.facebook.com/intern/diff/D12849620/\" rel=\"nofollow\"><g-emoji class=\"g-emoji\" alias=\"green_heart\" fallback-src=\"https://assets-cdn.github.com/images/icons/emoji/unicode/1f49a.png\">\ud83d\udc9a</g-emoji></a></p>\n<p>A requirement from the Caffe2 project is that DeviceGuard<br>\nwork with devices beyond CPU and CUDA.  Our previous implementation<br>\nof DeviceGuard was CPU/CUDA specialized.  This new implementation<br>\nnow properly generalizes for anything in c10::DeviceType.</p>\n<p>However, there is something very tricky about doing this: if you take<br>\nthe old API for DeviceGuard and generalize it to work on non-CUDA<br>\ntypes, it permits a very strange usage pattern:</p>\n<pre><code>DeviceGuard g({kCUDA, 1});\ng.set_device({kHIP, 2});\n</code></pre>\n<p>In this case, it would not be sufficient to reset the CUDA device at the end of the guard;<br>\nwe would ALSO have to reset the HIP device. This would substantially complicate the<br>\nimplementation of DeviceGuard, so I just got rid of set_device from DeviceGuard.<br>\nInstead, you should use CUDAGuard or, more generally, InlineDeviceGuard, which supports<br>\nthis use case, because it only works with a single device type.</p>\n<p>Finally, there is a semantic change. Previously, if you passed the CUDA device -1, this<br>\nwould no-op. Now, we require that you actually have CUDA loaded if you do this.</p>\n<p>Differential Revision: <a href=\"https://our.internmc.facebook.com/intern/diff/D12849620/\" rel=\"nofollow\">D12849620</a></p>", "body_text": "Stack:\n\u00a0\u00a0\u00a0\u00a0\u26ab\ufe0f\u00a0 #13342 Generalize DeviceGuard to work with arbitrary DeviceType, add InlineDeviceGuard for specialized use\u00a0\u00a0\ud83d\udc9a\nA requirement from the Caffe2 project is that DeviceGuard\nwork with devices beyond CPU and CUDA.  Our previous implementation\nof DeviceGuard was CPU/CUDA specialized.  This new implementation\nnow properly generalizes for anything in c10::DeviceType.\nHowever, there is something very tricky about doing this: if you take\nthe old API for DeviceGuard and generalize it to work on non-CUDA\ntypes, it permits a very strange usage pattern:\nDeviceGuard g({kCUDA, 1});\ng.set_device({kHIP, 2});\n\nIn this case, it would not be sufficient to reset the CUDA device at the end of the guard;\nwe would ALSO have to reset the HIP device. This would substantially complicate the\nimplementation of DeviceGuard, so I just got rid of set_device from DeviceGuard.\nInstead, you should use CUDAGuard or, more generally, InlineDeviceGuard, which supports\nthis use case, because it only works with a single device type.\nFinally, there is a semantic change. Previously, if you passed the CUDA device -1, this\nwould no-op. Now, we require that you actually have CUDA loaded if you do this.\nDifferential Revision: D12849620", "body": "Stack:\n&nbsp;&nbsp;&nbsp;&nbsp;:black_circle:&nbsp; **#13342 Generalize DeviceGuard to work with arbitrary DeviceType, add InlineDeviceGuard for specialized use**&nbsp;&nbsp;[:green_heart:](https://our.internmc.facebook.com/intern/diff/D12849620/)\n\nA requirement from the Caffe2 project is that DeviceGuard\nwork with devices beyond CPU and CUDA.  Our previous implementation\nof DeviceGuard was CPU/CUDA specialized.  This new implementation\nnow properly generalizes for anything in c10::DeviceType.\n\nHowever, there is something very tricky about doing this: if you take\nthe old API for DeviceGuard and generalize it to work on non-CUDA\ntypes, it permits a very strange usage pattern:\n\n```\nDeviceGuard g({kCUDA, 1});\ng.set_device({kHIP, 2});\n```\n\nIn this case, it would not be sufficient to reset the CUDA device at the end of the guard;\nwe would ALSO have to reset the HIP device. This would substantially complicate the\nimplementation of DeviceGuard, so I just got rid of set_device from DeviceGuard.\nInstead, you should use CUDAGuard or, more generally, InlineDeviceGuard, which supports\nthis use case, because it only works with a single device type.\n\nFinally, there is a semantic change. Previously, if you passed the CUDA device -1, this\nwould no-op. Now, we require that you actually have CUDA loaded if you do this.\n\nDifferential Revision: [D12849620](https://our.internmc.facebook.com/intern/diff/D12849620/)"}