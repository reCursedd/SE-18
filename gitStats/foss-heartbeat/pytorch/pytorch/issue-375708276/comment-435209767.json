{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/435209767", "html_url": "https://github.com/pytorch/pytorch/pull/13342#issuecomment-435209767", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/13342", "id": 435209767, "node_id": "MDEyOklzc3VlQ29tbWVudDQzNTIwOTc2Nw==", "user": {"login": "mruberry", "id": 38511765, "node_id": "MDQ6VXNlcjM4NTExNzY1", "avatar_url": "https://avatars3.githubusercontent.com/u/38511765?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mruberry", "html_url": "https://github.com/mruberry", "followers_url": "https://api.github.com/users/mruberry/followers", "following_url": "https://api.github.com/users/mruberry/following{/other_user}", "gists_url": "https://api.github.com/users/mruberry/gists{/gist_id}", "starred_url": "https://api.github.com/users/mruberry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mruberry/subscriptions", "organizations_url": "https://api.github.com/users/mruberry/orgs", "repos_url": "https://api.github.com/users/mruberry/repos", "events_url": "https://api.github.com/users/mruberry/events{/privacy}", "received_events_url": "https://api.github.com/users/mruberry/received_events", "type": "User", "site_admin": false}, "created_at": "2018-11-01T22:33:53Z", "updated_at": "2018-11-01T22:33:53Z", "author_association": "CONTRIBUTOR", "body_html": "<blockquote>\n<blockquote>\n<p>While we're at it, we also apply a new optimization: if, according to<br>\nthe DeviceGuard, we didn't actually change the device, we don't<br>\nbother calling setDevice at destruction time.</p>\n</blockquote>\n<p>Just had a chat with <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=38511765\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/mruberry\">@mruberry</a> about this. If you end up doing some DIY device setting this means you're hosed when the guard goes out of scope. The only way this can work reliably if there is some guarantee that custom device setting is NOT allowed.</p>\n</blockquote>\n<p>Custom device setting can be straightforward (actual calls to setDevice() in C++) or insidious, too, like if the code executes some user-written Python that sets the device. Maybe it's OK to say that those programs are in error, but that might be a breaking change.</p>", "body_text": "While we're at it, we also apply a new optimization: if, according to\nthe DeviceGuard, we didn't actually change the device, we don't\nbother calling setDevice at destruction time.\n\nJust had a chat with @mruberry about this. If you end up doing some DIY device setting this means you're hosed when the guard goes out of scope. The only way this can work reliably if there is some guarantee that custom device setting is NOT allowed.\n\nCustom device setting can be straightforward (actual calls to setDevice() in C++) or insidious, too, like if the code executes some user-written Python that sets the device. Maybe it's OK to say that those programs are in error, but that might be a breaking change.", "body": "> > While we're at it, we also apply a new optimization: if, according to\r\n> > the DeviceGuard, we didn't actually change the device, we don't\r\n> > bother calling setDevice at destruction time.\r\n> \r\n> Just had a chat with @mruberry about this. If you end up doing some DIY device setting this means you're hosed when the guard goes out of scope. The only way this can work reliably if there is some guarantee that custom device setting is NOT allowed.\r\n\r\nCustom device setting can be straightforward (actual calls to setDevice() in C++) or insidious, too, like if the code executes some user-written Python that sets the device. Maybe it's OK to say that those programs are in error, but that might be a breaking change. "}