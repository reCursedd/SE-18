{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/184906404", "pull_request_review_id": 116190966, "id": 184906404, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NDkwNjQwNA==", "diff_hunk": "@@ -106,6 +106,111 @@ def test_optional(self):\n         has_value = cpp_extension.function_taking_optional(None)\n         self.assertFalse(has_value)\n \n+    def test_inline_jit_compile_extension_with_functions_as_list(self):\n+        cpp_source = '''\n+        at::Tensor tanh_add(at::Tensor x, at::Tensor y) {\n+          return x.tanh() + y.tanh();\n+        }\n+        '''\n+\n+        module = torch.utils.cpp_extension.load_inline(\n+            name='inline_jit_extension_with_functions_list',\n+            cpp_sources=cpp_source,\n+            functions='tanh_add',\n+            verbose=True)\n+\n+        self.assertEqual(module.tanh_add.__doc__.split('\\n')[2], 'tanh_add')\n+\n+        x = torch.randn(4, 4)\n+        y = torch.randn(4, 4)\n+\n+        z = module.tanh_add(x, y)\n+        self.assertEqual(z, x.tanh() + y.tanh())\n+\n+    def test_inline_jit_compile_extension_with_functions_as_dict(self):\n+        cpp_source = '''\n+        at::Tensor tanh_add(at::Tensor x, at::Tensor y) {\n+          return x.tanh() + y.tanh();\n+        }\n+        '''\n+\n+        module = torch.utils.cpp_extension.load_inline(\n+            name='inline_jit_extension_with_functions_dict',\n+            cpp_sources=cpp_source,\n+            functions={'tanh_add': 'Tanh and then sum :D'},\n+            verbose=True)\n+\n+        self.assertEqual(\n+            module.tanh_add.__doc__.split('\\n')[2], 'Tanh and then sum :D')\n+\n+    def test_inline_jit_compile_extension_multiple_sources_and_no_functions(self):\n+        cpp_source1 = '''\n+        at::Tensor sin_add(at::Tensor x, at::Tensor y) {\n+          return x.sin() + y.sin();\n+        }\n+        '''\n+\n+        cpp_source2 = '''\n+        #include <torch/torch.h>\n+        at::Tensor sin_add(at::Tensor x, at::Tensor y);\n+        PYBIND11_MODULE(TORCH_EXTENSION_NAME, m) {\n+          m.def(\"sin_add\", &sin_add, \"sin(x) + sin(y)\");", "path": "test/test_cpp_extensions.py", "position": 74, "original_position": 74, "commit_id": "6a5cda0edd38b23627b86930ca7bf7632a87b69b", "original_commit_id": "6a5cda0edd38b23627b86930ca7bf7632a87b69b", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "body": "This is a bit late to ask this question (since the code for this has already been merged) but I'll ask it anyway: are we sure we want pybind11 to be part of the public interface of C++ extensions? If it is, then we are (1) always on the hook to ship pybind11 as part of PyTorch (we cannot ever decide \"oh, let's use another binding library\", because that will break userspace), and (2) every upgrade of pybind11 is a potentially user-visible BC-breaking change, because any BC-breakage in pybind11 is BC breakage for extension code. (Similarly, it looks like we are installing pybind11 headers as part of PyTorch, which is not very good OSS citizenship, because a downstream project might want to be using their own version of pybind11, and the headers will clobber each other.)\r\n\r\nIf we don't have concrete use-cases for letting people directly write pybind11 in the extension code, then it seems safer to (1) move our installed pybind11 headers under a private prefix (so they don't clash with a user) and (2) don't expose the functionality to directly write bindings. It's not a big loss; after all, the user can use whatever they want to get bindings, if they really want to.", "created_at": "2018-04-30T02:56:46Z", "updated_at": "2018-11-23T15:43:24Z", "html_url": "https://github.com/pytorch/pytorch/pull/7059#discussion_r184906404", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/7059", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/184906404"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/7059#discussion_r184906404"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/7059"}}, "body_html": "<p>This is a bit late to ask this question (since the code for this has already been merged) but I'll ask it anyway: are we sure we want pybind11 to be part of the public interface of C++ extensions? If it is, then we are (1) always on the hook to ship pybind11 as part of PyTorch (we cannot ever decide \"oh, let's use another binding library\", because that will break userspace), and (2) every upgrade of pybind11 is a potentially user-visible BC-breaking change, because any BC-breakage in pybind11 is BC breakage for extension code. (Similarly, it looks like we are installing pybind11 headers as part of PyTorch, which is not very good OSS citizenship, because a downstream project might want to be using their own version of pybind11, and the headers will clobber each other.)</p>\n<p>If we don't have concrete use-cases for letting people directly write pybind11 in the extension code, then it seems safer to (1) move our installed pybind11 headers under a private prefix (so they don't clash with a user) and (2) don't expose the functionality to directly write bindings. It's not a big loss; after all, the user can use whatever they want to get bindings, if they really want to.</p>", "body_text": "This is a bit late to ask this question (since the code for this has already been merged) but I'll ask it anyway: are we sure we want pybind11 to be part of the public interface of C++ extensions? If it is, then we are (1) always on the hook to ship pybind11 as part of PyTorch (we cannot ever decide \"oh, let's use another binding library\", because that will break userspace), and (2) every upgrade of pybind11 is a potentially user-visible BC-breaking change, because any BC-breakage in pybind11 is BC breakage for extension code. (Similarly, it looks like we are installing pybind11 headers as part of PyTorch, which is not very good OSS citizenship, because a downstream project might want to be using their own version of pybind11, and the headers will clobber each other.)\nIf we don't have concrete use-cases for letting people directly write pybind11 in the extension code, then it seems safer to (1) move our installed pybind11 headers under a private prefix (so they don't clash with a user) and (2) don't expose the functionality to directly write bindings. It's not a big loss; after all, the user can use whatever they want to get bindings, if they really want to."}