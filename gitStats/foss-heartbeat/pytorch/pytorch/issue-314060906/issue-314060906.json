{"url": "https://api.github.com/repos/pytorch/pytorch/issues/6584", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/6584/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/6584/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/6584/events", "html_url": "https://github.com/pytorch/pytorch/issues/6584", "id": 314060906, "node_id": "MDU6SXNzdWUzMTQwNjA5MDY=", "number": 6584, "title": "[feature request] smarter module matching for model.load_state_dict()", "user": {"login": "Quasimondo", "id": 182098, "node_id": "MDQ6VXNlcjE4MjA5OA==", "avatar_url": "https://avatars1.githubusercontent.com/u/182098?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Quasimondo", "html_url": "https://github.com/Quasimondo", "followers_url": "https://api.github.com/users/Quasimondo/followers", "following_url": "https://api.github.com/users/Quasimondo/following{/other_user}", "gists_url": "https://api.github.com/users/Quasimondo/gists{/gist_id}", "starred_url": "https://api.github.com/users/Quasimondo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Quasimondo/subscriptions", "organizations_url": "https://api.github.com/users/Quasimondo/orgs", "repos_url": "https://api.github.com/users/Quasimondo/repos", "events_url": "https://api.github.com/users/Quasimondo/events{/privacy}", "received_events_url": "https://api.github.com/users/Quasimondo/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2018-04-13T10:52:17Z", "updated_at": "2018-04-13T11:24:19Z", "closed_at": "2018-04-13T11:24:19Z", "author_association": "NONE", "body_html": "<p>I often deal with pretrained models that do not have meaningful keys for the module names (e.g. multiple Resnet blocks that are made from a template), so when adding another module into that block or changing the order, load_state_dict fails to match the old structure's modules to the new one and drops the unknown ones.</p>\n<p>It would be useful if there was a second pass in the matching routine that compares the signature of all the ignored modules (e.g. number of input/output filters, kernel size) and then tries to find identical matches in the  loaded state_dict and load that one. In case of multiple matches for the same module it could either pick the one that is closest in the graph or ignore it like it does so far.</p>", "body_text": "I often deal with pretrained models that do not have meaningful keys for the module names (e.g. multiple Resnet blocks that are made from a template), so when adding another module into that block or changing the order, load_state_dict fails to match the old structure's modules to the new one and drops the unknown ones.\nIt would be useful if there was a second pass in the matching routine that compares the signature of all the ignored modules (e.g. number of input/output filters, kernel size) and then tries to find identical matches in the  loaded state_dict and load that one. In case of multiple matches for the same module it could either pick the one that is closest in the graph or ignore it like it does so far.", "body": "I often deal with pretrained models that do not have meaningful keys for the module names (e.g. multiple Resnet blocks that are made from a template), so when adding another module into that block or changing the order, load_state_dict fails to match the old structure's modules to the new one and drops the unknown ones.\r\n\r\nIt would be useful if there was a second pass in the matching routine that compares the signature of all the ignored modules (e.g. number of input/output filters, kernel size) and then tries to find identical matches in the  loaded state_dict and load that one. In case of multiple matches for the same module it could either pick the one that is closest in the graph or ignore it like it does so far."}