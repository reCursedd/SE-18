{"url": "https://api.github.com/repos/pytorch/pytorch/issues/563", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/563/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/563/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/563/events", "html_url": "https://github.com/pytorch/pytorch/issues/563", "id": 202638938, "node_id": "MDU6SXNzdWUyMDI2Mzg5Mzg=", "number": 563, "title": "CrossEntropyLoss masking", "user": {"login": "alrojo", "id": 12167999, "node_id": "MDQ6VXNlcjEyMTY3OTk5", "avatar_url": "https://avatars1.githubusercontent.com/u/12167999?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alrojo", "html_url": "https://github.com/alrojo", "followers_url": "https://api.github.com/users/alrojo/followers", "following_url": "https://api.github.com/users/alrojo/following{/other_user}", "gists_url": "https://api.github.com/users/alrojo/gists{/gist_id}", "starred_url": "https://api.github.com/users/alrojo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alrojo/subscriptions", "organizations_url": "https://api.github.com/users/alrojo/orgs", "repos_url": "https://api.github.com/users/alrojo/repos", "events_url": "https://api.github.com/users/alrojo/events{/privacy}", "received_events_url": "https://api.github.com/users/alrojo/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 424131849, "node_id": "MDU6TGFiZWw0MjQxMzE4NDk=", "url": "https://api.github.com/repos/pytorch/pytorch/labels/enhancement", "name": "enhancement", "color": "84b6eb", "default": true}, {"id": 466131885, "node_id": "MDU6TGFiZWw0NjYxMzE4ODU=", "url": "https://api.github.com/repos/pytorch/pytorch/labels/needs%20discussion", "name": "needs discussion", "color": "cc317c", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 29, "created_at": "2017-01-23T20:15:19Z", "updated_at": "2017-12-07T17:16:16Z", "closed_at": "2017-12-07T17:16:16Z", "author_association": "NONE", "body_html": "<p>The <a href=\"http://pytorch.org/docs/nn.html?highlight=crossentropyloss#torch.nn.CrossEntropyLoss\" rel=\"nofollow\">CrossEntropyLoss</a> class and function uses inputs (unscaled probabilities), targets and class weights to calculate the loss.<br>\nThe reason for using class weights is to help with imbalanced datasets.<br>\nHowever, with this setup you are not allowed to handle masking, which is a core issue in time-series (RNN, NLP) training with imbalanced sequence length.</p>\n<p>I propose two alternative approaches that would solve this problem, while still allowing weighting class imbalances.</p>\n<p><strong>1.</strong> have the weights as a function argument at every execution. Such as <a href=\"https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/seq2seq/python/ops/loss.py\">TensorFlow</a> is doing. Such that the weights is the same size as the target tensor, with a weighting on each of the samples. This would still allow the user to supply increased weight sizes at the indices of their imbalanced classes, while masking would be putting ones at wanted samples and zeros everywhere else.</p>\n<p><strong>2.</strong> A perhaps more elegant solution would be to have the CrossEntropyLoss exactly the same as tensorflows <a href=\"https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/ops/nn_ops.py#L1637\">cross entropy loss function</a>, which seems to be the same as PyTorch's, but without averaging the loss of every sample. This would allow the user to average how they see fit and produce similar functions to the one in proposal (1).</p>", "body_text": "The CrossEntropyLoss class and function uses inputs (unscaled probabilities), targets and class weights to calculate the loss.\nThe reason for using class weights is to help with imbalanced datasets.\nHowever, with this setup you are not allowed to handle masking, which is a core issue in time-series (RNN, NLP) training with imbalanced sequence length.\nI propose two alternative approaches that would solve this problem, while still allowing weighting class imbalances.\n1. have the weights as a function argument at every execution. Such as TensorFlow is doing. Such that the weights is the same size as the target tensor, with a weighting on each of the samples. This would still allow the user to supply increased weight sizes at the indices of their imbalanced classes, while masking would be putting ones at wanted samples and zeros everywhere else.\n2. A perhaps more elegant solution would be to have the CrossEntropyLoss exactly the same as tensorflows cross entropy loss function, which seems to be the same as PyTorch's, but without averaging the loss of every sample. This would allow the user to average how they see fit and produce similar functions to the one in proposal (1).", "body": "The [CrossEntropyLoss](http://pytorch.org/docs/nn.html?highlight=crossentropyloss#torch.nn.CrossEntropyLoss) class and function uses inputs (unscaled probabilities), targets and class weights to calculate the loss.\r\nThe reason for using class weights is to help with imbalanced datasets.\r\nHowever, with this setup you are not allowed to handle masking, which is a core issue in time-series (RNN, NLP) training with imbalanced sequence length.\r\n\r\nI propose two alternative approaches that would solve this problem, while still allowing weighting class imbalances.\r\n\r\n**1.** have the weights as a function argument at every execution. Such as [TensorFlow](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/contrib/seq2seq/python/ops/loss.py) is doing. Such that the weights is the same size as the target tensor, with a weighting on each of the samples. This would still allow the user to supply increased weight sizes at the indices of their imbalanced classes, while masking would be putting ones at wanted samples and zeros everywhere else.\r\n\r\n**2.** A perhaps more elegant solution would be to have the CrossEntropyLoss exactly the same as tensorflows [cross entropy loss function](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/ops/nn_ops.py#L1637), which seems to be the same as PyTorch's, but without averaging the loss of every sample. This would allow the user to average how they see fit and produce similar functions to the one in proposal (1)."}