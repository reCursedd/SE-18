{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/347813708", "html_url": "https://github.com/pytorch/pytorch/issues/3930#issuecomment-347813708", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/3930", "id": 347813708, "node_id": "MDEyOklzc3VlQ29tbWVudDM0NzgxMzcwOA==", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "created_at": "2017-11-29T10:12:06Z", "updated_at": "2017-11-29T10:16:54Z", "author_association": "MEMBER", "body_html": "<p>I did some CPU-only benchmarking (no nvprof, just <code>time.time()</code>), and here are the results. If you look at the <a href=\"https://github.com/pytorch/pytorch/blob/master/torch/nn/parallel/replicate.py#L4\">code of replicate</a>, you can see that it has 4 main parts:</p>\n<ol>\n<li>Broadcasting parameters</li>\n<li>Broadacsting buffers</li>\n<li>Cloning modules</li>\n<li>Assigning parameters after cloning</li>\n</ol>\n<p>The costs of each of these parts look like this:</p>\n<ol>\n<li>47.58 ms (drop from 58ms before <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=15841449\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/ngimel\">@ngimel</a>'s patch)</li>\n<li>25.30 ms (drom frop 33ms before <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=15841449\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/ngimel\">@ngimel</a>'s patch)</li>\n<li>54.28 ms</li>\n<li>13.26 ms</li>\n</ol>\n<p><strong>TOTAL: 140.42ms</strong></p>\n<p>So even though the patch helps a bit, there's still a long way to go. I think I have an idea that would let us cache the modules so we could avoid the expensive cloning, and the remaining logic just needs to be moved to C++.</p>", "body_text": "I did some CPU-only benchmarking (no nvprof, just time.time()), and here are the results. If you look at the code of replicate, you can see that it has 4 main parts:\n\nBroadcasting parameters\nBroadacsting buffers\nCloning modules\nAssigning parameters after cloning\n\nThe costs of each of these parts look like this:\n\n47.58 ms (drop from 58ms before @ngimel's patch)\n25.30 ms (drom frop 33ms before @ngimel's patch)\n54.28 ms\n13.26 ms\n\nTOTAL: 140.42ms\nSo even though the patch helps a bit, there's still a long way to go. I think I have an idea that would let us cache the modules so we could avoid the expensive cloning, and the remaining logic just needs to be moved to C++.", "body": "I did some CPU-only benchmarking (no nvprof, just `time.time()`), and here are the results. If you look at the [code of replicate](https://github.com/pytorch/pytorch/blob/master/torch/nn/parallel/replicate.py#L4), you can see that it has 4 main parts:\r\n1. Broadcasting parameters\r\n2. Broadacsting buffers\r\n3. Cloning modules\r\n4. Assigning parameters after cloning\r\n\r\nThe costs of each of these parts look like this:\r\n1. 47.58 ms (drop from 58ms before @ngimel's patch)\r\n2. 25.30 ms (drom frop 33ms before @ngimel's patch)\r\n3. 54.28 ms \r\n4. 13.26 ms \r\n\r\n**TOTAL: 140.42ms**\r\n\r\nSo even though the patch helps a bit, there's still a long way to go. I think I have an idea that would let us cache the modules so we could avoid the expensive cloning, and the remaining logic just needs to be moved to C++."}