{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/341928286", "html_url": "https://github.com/pytorch/pytorch/issues/3277#issuecomment-341928286", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/3277", "id": 341928286, "node_id": "MDEyOklzc3VlQ29tbWVudDM0MTkyODI4Ng==", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "created_at": "2017-11-04T20:39:57Z", "updated_at": "2017-11-04T20:39:57Z", "author_association": "MEMBER", "body_html": "<p>Thanks a lot for investigating that. Today I learned that casting integral types to unsigned integral types is always well defined (in modulo arithmetic), but in case of floating point types you can cast it to any integral type, but result is only well defined if it can be represented as a truncated value (even when the destination type is unsigned!!!). An excerpt from C++ standard:</p>\n<blockquote>\n<h4>Floating\u2013integral conversions</h4>\n<p>...<br>\nIf the value cannot fit into the destination type, the behavior is undefined (even when the destination type is unsigned, modulo arithmetic does not apply).<br>\n...</p>\n</blockquote>\n<p>To sum up, the test is incorrect. Can you please send a PR making it ignore these floating point -&gt; unsigned conversions, but do additional integral -&gt; unsigned to make sure that works?</p>", "body_text": "Thanks a lot for investigating that. Today I learned that casting integral types to unsigned integral types is always well defined (in modulo arithmetic), but in case of floating point types you can cast it to any integral type, but result is only well defined if it can be represented as a truncated value (even when the destination type is unsigned!!!). An excerpt from C++ standard:\n\nFloating\u2013integral conversions\n...\nIf the value cannot fit into the destination type, the behavior is undefined (even when the destination type is unsigned, modulo arithmetic does not apply).\n...\n\nTo sum up, the test is incorrect. Can you please send a PR making it ignore these floating point -> unsigned conversions, but do additional integral -> unsigned to make sure that works?", "body": "Thanks a lot for investigating that. Today I learned that casting integral types to unsigned integral types is always well defined (in modulo arithmetic), but in case of floating point types you can cast it to any integral type, but result is only well defined if it can be represented as a truncated value (even when the destination type is unsigned!!!). An excerpt from C++ standard:\r\n\r\n> #### Floating\u2013integral conversions\r\n> ...\r\n> If the value cannot fit into the destination type, the behavior is undefined (even when the destination type is unsigned, modulo arithmetic does not apply).\r\n> ...\r\n\r\nTo sum up, the test is incorrect. Can you please send a PR making it ignore these floating point -> unsigned conversions, but do additional integral -> unsigned to make sure that works?"}