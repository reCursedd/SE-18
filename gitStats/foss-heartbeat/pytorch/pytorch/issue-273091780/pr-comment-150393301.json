{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/150393301", "pull_request_review_id": 75941306, "id": 150393301, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1MDM5MzMwMQ==", "diff_hunk": "@@ -0,0 +1,288 @@\n+#include \"interpreter.h\"\n+#include \"torch/csrc/jit/ir.h\"\n+#include \"torch/csrc/jit/generated/aten_dispatch.h\"\n+#ifdef WITH_CUDA\n+#include \"torch/csrc/jit/fusion_compiler.h\"\n+#endif\n+\n+namespace torch { namespace jit {\n+\n+using InputList = const std::vector<at::Tensor> &;\n+using OutputList = std::vector<at::Tensor>&;\n+using Callback = std::function<void(InputList, OutputList)>;\n+// Returns a function implementing functionality of a given node,\n+// or nullptr if it's a no-op for autograd.\n+Callback getCallback(Node *node) {\n+  IR_IFM(node, PythonOp)\n+    throw NotImplementedException();\n+  IR_ELSEIFM(CppOp)\n+    throw NotImplementedException();\n+  IR_ELSEIF(Select)\n+    barf(\"getCallback() on select?\");\n+  IR_ELSEIF(FusionGroup)\n+#ifdef WITH_CUDA\n+    auto fusion_fn = sharedFusionCompiler().getOrCompile(*value->g(kSubgraph));\n+    return [fusion_fn](InputList inputs, OutputList outputs) {\n+      fusion_fn->launch(inputs, outputs);\n+    };\n+#else\n+    throw std::runtime_error(\"don't know how to execute FusionGroups without CUDA\");\n+#endif\n+  IR_ELSEIF(Constant)\n+    auto t = value->t(kvalue);\n+    return [t](InputList inputs, OutputList outputs) {\n+      outputs.push_back(t);\n+    };\n+  IR_ELSEIF(Undefined)\n+    return [](InputList inputs, OutputList outputs) {\n+      outputs.push_back(at::Tensor());\n+    };\n+  IR_ELSE()\n+    return getTensorOp(node).op;\n+  IR_END()\n+}\n+\n+\n+// We need some lists for inputs and outputs. To keep all the memory\n+// contiguous we allocate a single vector and use offsets into the vector\n+// which are stored in the RegList struct\n+// start is an offset into int_data of Function if this list is integers\n+// and bool_data of Function if this list is booleans (only free_flags)", "path": "torch/csrc/jit/interpreter.cpp", "position": null, "original_position": 50, "commit_id": "8421d51b4f4545fc569a2522ca31ebdb0796a7ac", "original_commit_id": "71f42be9e2351f659845bfda434e4d5b303f49e5", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "body": "How about a `Slice` or `ArraySlice`? BTW it seems to me that the solution with allocator + using `Array<int>` and `Array<bool>` as \"indirect pointers\" to the area held by the allocator would be much more natural than using those slices. Still, it's not such big of a deal to be a blocker in any way.\r\n\r\nProposal:\r\n```cpp\r\ntemplate<typename T>\r\nstruct FlatArrayAllocator {\r\n  struct FlatArray {\r\n    // make the constructor private - it can only be created by the allocator\r\n    // can have things like begin(), end(), indexing operators, etc.\r\n    FlatArrayAllocator& base;\r\n    size_t offset;\r\n    size_t len;\r\n  };\r\n\r\n  FlatArray reserve(size_t numel); // Get a new FlatArray. Fill it using the indexing operator\r\n\r\n  std::unique_ptr<T> data;\r\n};\r\n```\r\n\r\nI can implement that in a subsequent PR if you like that. I really don't like that you have this global state and you have to coordinate calls to `intListBegin` and `intListPush`", "created_at": "2017-11-11T20:53:23Z", "updated_at": "2018-11-23T15:36:23Z", "html_url": "https://github.com/pytorch/pytorch/pull/3634#discussion_r150393301", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/3634", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/150393301"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/3634#discussion_r150393301"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/3634"}}, "body_html": "<p>How about a <code>Slice</code> or <code>ArraySlice</code>? BTW it seems to me that the solution with allocator + using <code>Array&lt;int&gt;</code> and <code>Array&lt;bool&gt;</code> as \"indirect pointers\" to the area held by the allocator would be much more natural than using those slices. Still, it's not such big of a deal to be a blocker in any way.</p>\n<p>Proposal:</p>\n<div class=\"highlight highlight-source-c++\"><pre><span class=\"pl-k\">template</span>&lt;<span class=\"pl-k\">typename</span> T&gt;\n<span class=\"pl-k\">struct</span> <span class=\"pl-en\">FlatArrayAllocator</span> {\n  <span class=\"pl-k\">struct</span> <span class=\"pl-en\">FlatArray</span> {\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span> make the constructor private - it can only be created by the allocator</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span> can have things like begin(), end(), indexing operators, etc.</span>\n    FlatArrayAllocator&amp; base;\n    <span class=\"pl-c1\">size_t</span> offset;\n    <span class=\"pl-c1\">size_t</span> len;\n  };\n\n  FlatArray <span class=\"pl-en\">reserve</span>(<span class=\"pl-c1\">size_t</span> numel); <span class=\"pl-c\"><span class=\"pl-c\">//</span> Get a new FlatArray. Fill it using the indexing operator</span>\n\n  std::unique_ptr&lt;T&gt; data;\n};</pre></div>\n<p>I can implement that in a subsequent PR if you like that. I really don't like that you have this global state and you have to coordinate calls to <code>intListBegin</code> and <code>intListPush</code></p>", "body_text": "How about a Slice or ArraySlice? BTW it seems to me that the solution with allocator + using Array<int> and Array<bool> as \"indirect pointers\" to the area held by the allocator would be much more natural than using those slices. Still, it's not such big of a deal to be a blocker in any way.\nProposal:\ntemplate<typename T>\nstruct FlatArrayAllocator {\n  struct FlatArray {\n    // make the constructor private - it can only be created by the allocator\n    // can have things like begin(), end(), indexing operators, etc.\n    FlatArrayAllocator& base;\n    size_t offset;\n    size_t len;\n  };\n\n  FlatArray reserve(size_t numel); // Get a new FlatArray. Fill it using the indexing operator\n\n  std::unique_ptr<T> data;\n};\nI can implement that in a subsequent PR if you like that. I really don't like that you have this global state and you have to coordinate calls to intListBegin and intListPush", "in_reply_to_id": 150382553}