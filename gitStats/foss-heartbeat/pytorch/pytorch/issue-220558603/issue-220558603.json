{"url": "https://api.github.com/repos/pytorch/pytorch/issues/1221", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/1221/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/1221/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/1221/events", "html_url": "https://github.com/pytorch/pytorch/issues/1221", "id": 220558603, "node_id": "MDU6SXNzdWUyMjA1NTg2MDM=", "number": 1221, "title": "memory leak problem?", "user": {"login": "jzthree", "id": 8333155, "node_id": "MDQ6VXNlcjgzMzMxNTU=", "avatar_url": "https://avatars0.githubusercontent.com/u/8333155?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jzthree", "html_url": "https://github.com/jzthree", "followers_url": "https://api.github.com/users/jzthree/followers", "following_url": "https://api.github.com/users/jzthree/following{/other_user}", "gists_url": "https://api.github.com/users/jzthree/gists{/gist_id}", "starred_url": "https://api.github.com/users/jzthree/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jzthree/subscriptions", "organizations_url": "https://api.github.com/users/jzthree/orgs", "repos_url": "https://api.github.com/users/jzthree/repos", "events_url": "https://api.github.com/users/jzthree/events{/privacy}", "received_events_url": "https://api.github.com/users/jzthree/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 424131847, "node_id": "MDU6TGFiZWw0MjQxMzE4NDc=", "url": "https://api.github.com/repos/pytorch/pytorch/labels/bug", "name": "bug", "color": "b60205", "default": true}, {"id": 443484135, "node_id": "MDU6TGFiZWw0NDM0ODQxMzU=", "url": "https://api.github.com/repos/pytorch/pytorch/labels/high%20priority", "name": "high priority", "color": "F22613", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2017-04-10T07:26:31Z", "updated_at": "2017-04-10T22:09:52Z", "closed_at": "2017-04-10T22:09:52Z", "author_association": "NONE", "body_html": "<pre><code>import torch\n\ndef batched_inverse(x):\n    \"\"\"Calculate matrix inverse for each channel separately. The input size should be C*M*M\"\"\"\n    A_LU = torch.btrifact(x)\n    b = torch.eye(x.size(1)).cuda().unsqueeze(0).expand(x.size())\n\n    xinverse = x.clone()\n    for i in range(x.size(1)):\n        xinverse[:, :, i] = torch.btrisolve(b[:, :, i], *A_LU)\n    return xinverse\n\n\nx=torch.cuda.FloatTensor(10000,10,10).normal_()\ny=torch.bmm(x,x)\nwhile True:\n    z = batched_inverse(y)\n</code></pre>\n<p>This code gives RuntimeError: cuda runtime error (2) : out of memory at /tigress/jzthree/pgm/pytorch/torch/lib/THC/generic/THCTensorMathBlas.cu:797</p>\n<p>It fills memory faster when it is given many batches of small matrices (large first dimension).  Calling torch.btrifact line and torch.eye line alone seems to cause no problem. It looks like using b together with btrisolve is the cause.</p>", "body_text": "import torch\n\ndef batched_inverse(x):\n    \"\"\"Calculate matrix inverse for each channel separately. The input size should be C*M*M\"\"\"\n    A_LU = torch.btrifact(x)\n    b = torch.eye(x.size(1)).cuda().unsqueeze(0).expand(x.size())\n\n    xinverse = x.clone()\n    for i in range(x.size(1)):\n        xinverse[:, :, i] = torch.btrisolve(b[:, :, i], *A_LU)\n    return xinverse\n\n\nx=torch.cuda.FloatTensor(10000,10,10).normal_()\ny=torch.bmm(x,x)\nwhile True:\n    z = batched_inverse(y)\n\nThis code gives RuntimeError: cuda runtime error (2) : out of memory at /tigress/jzthree/pgm/pytorch/torch/lib/THC/generic/THCTensorMathBlas.cu:797\nIt fills memory faster when it is given many batches of small matrices (large first dimension).  Calling torch.btrifact line and torch.eye line alone seems to cause no problem. It looks like using b together with btrisolve is the cause.", "body": "```\r\nimport torch\r\n\r\ndef batched_inverse(x):\r\n    \"\"\"Calculate matrix inverse for each channel separately. The input size should be C*M*M\"\"\"\r\n    A_LU = torch.btrifact(x)\r\n    b = torch.eye(x.size(1)).cuda().unsqueeze(0).expand(x.size())\r\n\r\n    xinverse = x.clone()\r\n    for i in range(x.size(1)):\r\n        xinverse[:, :, i] = torch.btrisolve(b[:, :, i], *A_LU)\r\n    return xinverse\r\n\r\n\r\nx=torch.cuda.FloatTensor(10000,10,10).normal_()\r\ny=torch.bmm(x,x)\r\nwhile True:\r\n    z = batched_inverse(y)\r\n```\r\n\r\n\r\nThis code gives RuntimeError: cuda runtime error (2) : out of memory at /tigress/jzthree/pgm/pytorch/torch/lib/THC/generic/THCTensorMathBlas.cu:797\r\n\r\n\r\nIt fills memory faster when it is given many batches of small matrices (large first dimension).  Calling torch.btrifact line and torch.eye line alone seems to cause no problem. It looks like using b together with btrisolve is the cause.  "}