{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/255418744", "html_url": "https://github.com/pytorch/pytorch/issues/143#issuecomment-255418744", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/143", "id": 255418744, "node_id": "MDEyOklzc3VlQ29tbWVudDI1NTQxODc0NA==", "user": {"login": "colesbury", "id": 655866, "node_id": "MDQ6VXNlcjY1NTg2Ng==", "avatar_url": "https://avatars1.githubusercontent.com/u/655866?v=4", "gravatar_id": "", "url": "https://api.github.com/users/colesbury", "html_url": "https://github.com/colesbury", "followers_url": "https://api.github.com/users/colesbury/followers", "following_url": "https://api.github.com/users/colesbury/following{/other_user}", "gists_url": "https://api.github.com/users/colesbury/gists{/gist_id}", "starred_url": "https://api.github.com/users/colesbury/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/colesbury/subscriptions", "organizations_url": "https://api.github.com/users/colesbury/orgs", "repos_url": "https://api.github.com/users/colesbury/repos", "events_url": "https://api.github.com/users/colesbury/events{/privacy}", "received_events_url": "https://api.github.com/users/colesbury/received_events", "type": "User", "site_admin": false}, "created_at": "2016-10-21T16:10:46Z", "updated_at": "2016-10-21T16:10:46Z", "author_association": "MEMBER", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=4583066\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/apaszke\">@apaszke</a>, I think we change how we handle parameter assignments. <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=8885556\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/glample\">@glample</a>'s example seems like a reasonable way to write an stateful RNN class. Here's my suggestion, which mostly mirrors what <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=8885556\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/glample\">@glample</a> is saying</p>\n<ol>\n<li>The correct way to add a parameter to a Module is through a new function <code>add_parameter(self, name, param)</code>. This function ensures that the Variable is a leaf. We can also keep the Module constructor behavior, which can delegate to <code>add_parameter</code></li>\n<li>We keep the <code>Module.__getattr_</code> parameter behavior</li>\n<li><code>Module.__setattr__</code> with a Variable does the default behavior -- it's not added to <code>_parameters</code> and no special checks are performed.</li>\n<li>We keep the <code>Container.__setattr__</code> and <code>Container.__getattr__</code> behavior (module assignment)</li>\n</ol>\n<p>As you said, holding on to Variables will hold on to the computation graph. I no longer think we should disallow this because it's sometimes what you really want (i.e. the stateful RNN).</p>\n<p>The workarounds with the current behavior don't seem great. The StatelessRNN is not a module, so you can't add it to as part of a larger Container. And if we disallow non leaf Variable assignment, people are going to go for even uglier hacks to work around the checks, such as:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-c1\">self</span>.param <span class=\"pl-k\">=</span> [my_variable]</pre></div>", "body_text": "@apaszke, I think we change how we handle parameter assignments. @glample's example seems like a reasonable way to write an stateful RNN class. Here's my suggestion, which mostly mirrors what @glample is saying\n\nThe correct way to add a parameter to a Module is through a new function add_parameter(self, name, param). This function ensures that the Variable is a leaf. We can also keep the Module constructor behavior, which can delegate to add_parameter\nWe keep the Module.__getattr_ parameter behavior\nModule.__setattr__ with a Variable does the default behavior -- it's not added to _parameters and no special checks are performed.\nWe keep the Container.__setattr__ and Container.__getattr__ behavior (module assignment)\n\nAs you said, holding on to Variables will hold on to the computation graph. I no longer think we should disallow this because it's sometimes what you really want (i.e. the stateful RNN).\nThe workarounds with the current behavior don't seem great. The StatelessRNN is not a module, so you can't add it to as part of a larger Container. And if we disallow non leaf Variable assignment, people are going to go for even uglier hacks to work around the checks, such as:\nself.param = [my_variable]", "body": "@apaszke, I think we change how we handle parameter assignments. @glample's example seems like a reasonable way to write an stateful RNN class. Here's my suggestion, which mostly mirrors what @glample is saying\n1. The correct way to add a parameter to a Module is through a new function `add_parameter(self, name, param)`. This function ensures that the Variable is a leaf. We can also keep the Module constructor behavior, which can delegate to `add_parameter`\n2. We keep the `Module.__getattr_` parameter behavior\n3. `Module.__setattr__` with a Variable does the default behavior -- it's not added to `_parameters` and no special checks are performed.\n4. We keep the `Container.__setattr__` and `Container.__getattr__` behavior (module assignment)\n\nAs you said, holding on to Variables will hold on to the computation graph. I no longer think we should disallow this because it's sometimes what you really want (i.e. the stateful RNN). \n\nThe workarounds with the current behavior don't seem great. The StatelessRNN is not a module, so you can't add it to as part of a larger Container. And if we disallow non leaf Variable assignment, people are going to go for even uglier hacks to work around the checks, such as:\n\n``` python\nself.param = [my_variable]\n```\n"}