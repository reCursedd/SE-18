{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/225886085", "pull_request_review_id": 165580947, "id": 225886085, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTg4NjA4NQ==", "diff_hunk": "@@ -0,0 +1,178 @@\n+#pragma once\n+\n+#include <torch/csrc/utils/variadic.h>\n+#include <torch/tensor.h>\n+\n+#include <ATen/core/Error.h>\n+\n+#include <functional>\n+#include <iterator>\n+#include <memory>\n+#include <type_traits>\n+#include <utility>\n+\n+namespace torch {\n+namespace data {\n+namespace detail {\n+// For increased safety and more separated logic, this implementation of\n+// `Iterator` consists of a `ValidIterator` and a `SentinelIterator`. A\n+// `ValidIterator` yields new batches until the `DataLoader` is exhausted. While\n+// the `DataLoader` is not exhausted, `ValidIterator`s compare equal if they are\n+// the same object. When the `ValidIterator` becomes exhauted, it compares equal\n+// to the `SentinelIterator`, but not before. Half the code here is to implement\n+// double dispatch for the comparison. Got damnit, C++.\n+\n+template <typename Batch>\n+struct ValidIterator;\n+\n+template <typename Batch>\n+struct SentinelIterator;\n+\n+/// Base class for the `ValidIterator` and `SentinelIterator`\n+template <typename Batch>\n+struct IteratorImpl {\n+  virtual ~IteratorImpl() = default;\n+  virtual void next() = 0;\n+  virtual Batch& get() = 0;\n+  virtual bool operator==(const IteratorImpl& other) const = 0;\n+  virtual bool operator==(const ValidIterator<Batch>& other) const = 0;\n+  virtual bool operator==(const SentinelIterator<Batch>& other) const = 0;\n+};\n+\n+template <typename Batch>\n+struct ValidIterator : public IteratorImpl<Batch> {\n+  using BatchProducer = std::function<optional<Batch>()>;\n+\n+  explicit ValidIterator(BatchProducer next_batch)\n+      : next_batch_(std::move(next_batch)) {}\n+\n+  /// Fetches the next batch.\n+  void next() override {\n+    // If we didn't get the very first batch yet, get it now.\n+    lazy_initialize();", "path": "torch/csrc/api/include/torch/data/iterator.h", "position": 52, "original_position": 52, "commit_id": "2fabdad63c0bc48b26af6bf8d2e74513b09c97da", "original_commit_id": "0cf5d795bd8b96ac542039a8f612df1ce84602f2", "user": {"login": "goldsborough", "id": 6429851, "node_id": "MDQ6VXNlcjY0Mjk4NTE=", "avatar_url": "https://avatars3.githubusercontent.com/u/6429851?v=4", "gravatar_id": "", "url": "https://api.github.com/users/goldsborough", "html_url": "https://github.com/goldsborough", "followers_url": "https://api.github.com/users/goldsborough/followers", "following_url": "https://api.github.com/users/goldsborough/following{/other_user}", "gists_url": "https://api.github.com/users/goldsborough/gists{/gist_id}", "starred_url": "https://api.github.com/users/goldsborough/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/goldsborough/subscriptions", "organizations_url": "https://api.github.com/users/goldsborough/orgs", "repos_url": "https://api.github.com/users/goldsborough/repos", "events_url": "https://api.github.com/users/goldsborough/events{/privacy}", "received_events_url": "https://api.github.com/users/goldsborough/received_events", "type": "User", "site_admin": false}, "body": "The contract with `Iterator` is that when you call `auto iter = begin()`, then `iter` either points to the first valid item, or equals the end. `next()` fetches the next item. The lazy initialization is so that only the first dereference actually fetches the item (if you start using `iter` a couple lines after creating it). If I write:\r\n\r\n```cpp\r\nauto iter = begin();\r\niter.next();\r\n```\r\n\r\nThen the user should not know about the lazy initialization of course, and since `iter` first pointed at the first item, the call to `next()` should make it point at the second item. Therefore we first need to (lazily) fetch the first item, and then increment to the second item. Hope this makes sense.", "created_at": "2018-10-17T11:31:20Z", "updated_at": "2018-11-23T15:53:08Z", "html_url": "https://github.com/pytorch/pytorch/pull/11918#discussion_r225886085", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/11918", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/225886085"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/11918#discussion_r225886085"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/11918"}}, "body_html": "<p>The contract with <code>Iterator</code> is that when you call <code>auto iter = begin()</code>, then <code>iter</code> either points to the first valid item, or equals the end. <code>next()</code> fetches the next item. The lazy initialization is so that only the first dereference actually fetches the item (if you start using <code>iter</code> a couple lines after creating it). If I write:</p>\n<div class=\"highlight highlight-source-c++\"><pre><span class=\"pl-k\">auto</span> iter = begin();\niter.next();</pre></div>\n<p>Then the user should not know about the lazy initialization of course, and since <code>iter</code> first pointed at the first item, the call to <code>next()</code> should make it point at the second item. Therefore we first need to (lazily) fetch the first item, and then increment to the second item. Hope this makes sense.</p>", "body_text": "The contract with Iterator is that when you call auto iter = begin(), then iter either points to the first valid item, or equals the end. next() fetches the next item. The lazy initialization is so that only the first dereference actually fetches the item (if you start using iter a couple lines after creating it). If I write:\nauto iter = begin();\niter.next();\nThen the user should not know about the lazy initialization of course, and since iter first pointed at the first item, the call to next() should make it point at the second item. Therefore we first need to (lazily) fetch the first item, and then increment to the second item. Hope this makes sense.", "in_reply_to_id": 223749528}