{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/348165408", "html_url": "https://github.com/pytorch/pytorch/issues/3420#issuecomment-348165408", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/3420", "id": 348165408, "node_id": "MDEyOklzc3VlQ29tbWVudDM0ODE2NTQwOA==", "user": {"login": "mittagessen", "id": 3780295, "node_id": "MDQ6VXNlcjM3ODAyOTU=", "avatar_url": "https://avatars2.githubusercontent.com/u/3780295?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mittagessen", "html_url": "https://github.com/mittagessen", "followers_url": "https://api.github.com/users/mittagessen/followers", "following_url": "https://api.github.com/users/mittagessen/following{/other_user}", "gists_url": "https://api.github.com/users/mittagessen/gists{/gist_id}", "starred_url": "https://api.github.com/users/mittagessen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mittagessen/subscriptions", "organizations_url": "https://api.github.com/users/mittagessen/orgs", "repos_url": "https://api.github.com/users/mittagessen/repos", "events_url": "https://api.github.com/users/mittagessen/events{/privacy}", "received_events_url": "https://api.github.com/users/mittagessen/received_events", "type": "User", "site_admin": false}, "created_at": "2017-11-30T11:45:03Z", "updated_at": "2017-11-30T11:45:48Z", "author_association": "NONE", "body_html": "<p>After spending a few days on a CTC loss in THNN, I came to the conclusion that it isn't really feasable without wrapping it in an amount of python code that makes it unmergable. The main reason is that gradients and loss are calculated concurrently in CTC but they are separate function calls without data sharing in THNN.<br>\nRetaining the gradient through a python wrapper class is possible but wrapper class functionality for THNN kernels were moved from python to C a while back and doing it differently for a single loss function seems wrong. Running CTC twice, once for the loss and once for the gradients is also unacceptable.<br>\nI've updated an old python CTC implementation for my requirements, if you or the people you're shipping software to are fine with compiling and need the performance I'd suggest using warp-ctc (with pytorch bindings), cctc or similar. As my main requirement is 'works out of box' I have to live with a slower python CTC.</p>", "body_text": "After spending a few days on a CTC loss in THNN, I came to the conclusion that it isn't really feasable without wrapping it in an amount of python code that makes it unmergable. The main reason is that gradients and loss are calculated concurrently in CTC but they are separate function calls without data sharing in THNN.\nRetaining the gradient through a python wrapper class is possible but wrapper class functionality for THNN kernels were moved from python to C a while back and doing it differently for a single loss function seems wrong. Running CTC twice, once for the loss and once for the gradients is also unacceptable.\nI've updated an old python CTC implementation for my requirements, if you or the people you're shipping software to are fine with compiling and need the performance I'd suggest using warp-ctc (with pytorch bindings), cctc or similar. As my main requirement is 'works out of box' I have to live with a slower python CTC.", "body": "After spending a few days on a CTC loss in THNN, I came to the conclusion that it isn't really feasable without wrapping it in an amount of python code that makes it unmergable. The main reason is that gradients and loss are calculated concurrently in CTC but they are separate function calls without data sharing in THNN. \r\nRetaining the gradient through a python wrapper class is possible but wrapper class functionality for THNN kernels were moved from python to C a while back and doing it differently for a single loss function seems wrong. Running CTC twice, once for the loss and once for the gradients is also unacceptable.\r\nI've updated an old python CTC implementation for my requirements, if you or the people you're shipping software to are fine with compiling and need the performance I'd suggest using warp-ctc (with pytorch bindings), cctc or similar. As my main requirement is 'works out of box' I have to live with a slower python CTC."}