{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/343130359", "html_url": "https://github.com/pytorch/pytorch/issues/3420#issuecomment-343130359", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/3420", "id": 343130359, "node_id": "MDEyOklzc3VlQ29tbWVudDM0MzEzMDM1OQ==", "user": {"login": "mittagessen", "id": 3780295, "node_id": "MDQ6VXNlcjM3ODAyOTU=", "avatar_url": "https://avatars2.githubusercontent.com/u/3780295?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mittagessen", "html_url": "https://github.com/mittagessen", "followers_url": "https://api.github.com/users/mittagessen/followers", "following_url": "https://api.github.com/users/mittagessen/following{/other_user}", "gists_url": "https://api.github.com/users/mittagessen/gists{/gist_id}", "starred_url": "https://api.github.com/users/mittagessen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mittagessen/subscriptions", "organizations_url": "https://api.github.com/users/mittagessen/orgs", "repos_url": "https://api.github.com/users/mittagessen/repos", "events_url": "https://api.github.com/users/mittagessen/events{/privacy}", "received_events_url": "https://api.github.com/users/mittagessen/received_events", "type": "User", "site_admin": false}, "created_at": "2017-11-09T11:43:14Z", "updated_at": "2017-11-09T11:43:30Z", "author_association": "NONE", "body_html": "<blockquote>\n<p>cuda + cudnn is fairly common though so it's not  adding much of a requirement as it is typically strongly recommended if  you have a gpu. That'd be my ideal option as that would both give a  nicely optimized gpu implementation and as it is part of cudnn it'll  likely remain actively maintained.</p>\n</blockquote>\n<p>Most of the people using the software I need CTC in pytorch for are using CPUs so my focus is there. I've looked at the code and adding a cuDNN wrapper to the existing ones should be fairly easy, although I am fairly sure the CPU implementation is producing different results from cuDNN (or most other CTC implementations) which is another reason not to transparently switch between both.</p>\n<blockquote>\n<p>As a related note, in actually using ctc one useful function besides the loss would be a way of doing the beam search to find the most likely sequence.</p>\n</blockquote>\n<p>Does it actually improve output accuracy? I know ocropy/clstm CTC trains robust networks (more so than other CTCs) for OCR that tend to perform equally well with either greedy or beam search and most serious stuff I've seen in the wild use either greedy or some model like WFST and RNN-LM for decoding.</p>", "body_text": "cuda + cudnn is fairly common though so it's not  adding much of a requirement as it is typically strongly recommended if  you have a gpu. That'd be my ideal option as that would both give a  nicely optimized gpu implementation and as it is part of cudnn it'll  likely remain actively maintained.\n\nMost of the people using the software I need CTC in pytorch for are using CPUs so my focus is there. I've looked at the code and adding a cuDNN wrapper to the existing ones should be fairly easy, although I am fairly sure the CPU implementation is producing different results from cuDNN (or most other CTC implementations) which is another reason not to transparently switch between both.\n\nAs a related note, in actually using ctc one useful function besides the loss would be a way of doing the beam search to find the most likely sequence.\n\nDoes it actually improve output accuracy? I know ocropy/clstm CTC trains robust networks (more so than other CTCs) for OCR that tend to perform equally well with either greedy or beam search and most serious stuff I've seen in the wild use either greedy or some model like WFST and RNN-LM for decoding.", "body": "> cuda + cudnn is fairly common though so it's not  adding much of a requirement as it is typically strongly recommended if  you have a gpu. That'd be my ideal option as that would both give a  nicely optimized gpu implementation and as it is part of cudnn it'll  likely remain actively maintained.\r\n\r\nMost of the people using the software I need CTC in pytorch for are using CPUs so my focus is there. I've looked at the code and adding a cuDNN wrapper to the existing ones should be fairly easy, although I am fairly sure the CPU implementation is producing different results from cuDNN (or most other CTC implementations) which is another reason not to transparently switch between both.\r\n\r\n>  As a related note, in actually using ctc one useful function besides the loss would be a way of doing the beam search to find the most likely sequence.\r\n\r\nDoes it actually improve output accuracy? I know ocropy/clstm CTC trains robust networks (more so than other CTCs) for OCR that tend to perform equally well with either greedy or beam search and most serious stuff I've seen in the wild use either greedy or some model like WFST and RNN-LM for decoding."}