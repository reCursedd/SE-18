{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/371491441", "html_url": "https://github.com/pytorch/pytorch/pull/5585#issuecomment-371491441", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/5585", "id": 371491441, "node_id": "MDEyOklzc3VlQ29tbWVudDM3MTQ5MTQ0MQ==", "user": {"login": "peterjc123", "id": 9998726, "node_id": "MDQ6VXNlcjk5OTg3MjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/9998726?v=4", "gravatar_id": "", "url": "https://api.github.com/users/peterjc123", "html_url": "https://github.com/peterjc123", "followers_url": "https://api.github.com/users/peterjc123/followers", "following_url": "https://api.github.com/users/peterjc123/following{/other_user}", "gists_url": "https://api.github.com/users/peterjc123/gists{/gist_id}", "starred_url": "https://api.github.com/users/peterjc123/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/peterjc123/subscriptions", "organizations_url": "https://api.github.com/users/peterjc123/orgs", "repos_url": "https://api.github.com/users/peterjc123/repos", "events_url": "https://api.github.com/users/peterjc123/events{/privacy}", "received_events_url": "https://api.github.com/users/peterjc123/received_events", "type": "User", "site_admin": false}, "created_at": "2018-03-08T13:49:10Z", "updated_at": "2018-03-08T14:04:26Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=4583066\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/apaszke\">@apaszke</a> It's my fault for not having explained it clearly. <code>FileMapping</code> is a kernel object on Windows. A kernel object will be released when all references to it are released. When we use <code>FileMapping</code>, we first create it in the child process using <code>CreateFileMapping</code>, and then the parent process will try to open it using <code>OpenFileMapping</code>. The current question is when refcount is down to zero, only one side really closes the <code>FileMapping</code> using <code>CloseHandle</code>, because when the other side tries to close it previously, the refcount of it is nonzero, so the <code>CloseHandle</code> is not triggered. In order to fully release the <code>FileMapping</code>, we need to call <code>CloseHandle</code> on both sides.<br>\nYou may ask this question. Why don't we close it when the free function is called, since the kernel object is reserved when another reference is not closed? Because when we call <code>CloseHandle</code>, the handle is invalid afterwards. So we cannot use it anymore. But the <code>multiprocessing</code> lib of Python uses Pipe and overlapped I/O (similar to asynchronous IO), so we don't know exactly when the use of the handle is completed. So I think it's safe to close both handles when the refcount of the <code>FileMapping</code> decreases to zero, because this means the transfer process is done.<br>\nAs for the death of the process, it can be classified into 2 types: child process dies first or parent process dies first.<br>\nFor the first circumstance, it's actually safe because the parent process will be stuck (or exit on error) and the error message will be printed so that user will know there're problems and try to kill it. If parent process dies first, then the child process will die too. Because the pipe is not usable anymore, the exception will be thrown and the process will be stopped. And after both process are killed, <code>Event</code>s are also released. (Because <code>Event</code> is a kernel object too.)</p>", "body_text": "@apaszke It's my fault for not having explained it clearly. FileMapping is a kernel object on Windows. A kernel object will be released when all references to it are released. When we use FileMapping, we first create it in the child process using CreateFileMapping, and then the parent process will try to open it using OpenFileMapping. The current question is when refcount is down to zero, only one side really closes the FileMapping using CloseHandle, because when the other side tries to close it previously, the refcount of it is nonzero, so the CloseHandle is not triggered. In order to fully release the FileMapping, we need to call CloseHandle on both sides.\nYou may ask this question. Why don't we close it when the free function is called, since the kernel object is reserved when another reference is not closed? Because when we call CloseHandle, the handle is invalid afterwards. So we cannot use it anymore. But the multiprocessing lib of Python uses Pipe and overlapped I/O (similar to asynchronous IO), so we don't know exactly when the use of the handle is completed. So I think it's safe to close both handles when the refcount of the FileMapping decreases to zero, because this means the transfer process is done.\nAs for the death of the process, it can be classified into 2 types: child process dies first or parent process dies first.\nFor the first circumstance, it's actually safe because the parent process will be stuck (or exit on error) and the error message will be printed so that user will know there're problems and try to kill it. If parent process dies first, then the child process will die too. Because the pipe is not usable anymore, the exception will be thrown and the process will be stopped. And after both process are killed, Events are also released. (Because Event is a kernel object too.)", "body": "@apaszke It's my fault for not having explained it clearly. `FileMapping` is a kernel object on Windows. A kernel object will be released when all references to it are released. When we use `FileMapping`, we first create it in the child process using `CreateFileMapping`, and then the parent process will try to open it using `OpenFileMapping`. The current question is when refcount is down to zero, only one side really closes the `FileMapping` using `CloseHandle`, because when the other side tries to close it previously, the refcount of it is nonzero, so the `CloseHandle` is not triggered. In order to fully release the `FileMapping`, we need to call `CloseHandle` on both sides.\r\nYou may ask this question. Why don't we close it when the free function is called, since the kernel object is reserved when another reference is not closed? Because when we call `CloseHandle`, the handle is invalid afterwards. So we cannot use it anymore. But the `multiprocessing` lib of Python uses Pipe and overlapped I/O (similar to asynchronous IO), so we don't know exactly when the use of the handle is completed. So I think it's safe to close both handles when the refcount of the `FileMapping` decreases to zero, because this means the transfer process is done.\r\nAs for the death of the process, it can be classified into 2 types: child process dies first or parent process dies first.\r\nFor the first circumstance, it's actually safe because the parent process will be stuck (or exit on error) and the error message will be printed so that user will know there're problems and try to kill it. If parent process dies first, then the child process will die too. Because the pipe is not usable anymore, the exception will be thrown and the process will be stopped. And after both process are killed, `Event`s are also released. (Because `Event` is a kernel object too.)"}