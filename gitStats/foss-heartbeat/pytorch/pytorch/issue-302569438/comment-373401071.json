{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/373401071", "html_url": "https://github.com/pytorch/pytorch/pull/5585#issuecomment-373401071", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/5585", "id": 373401071, "node_id": "MDEyOklzc3VlQ29tbWVudDM3MzQwMTA3MQ==", "user": {"login": "peterjc123", "id": 9998726, "node_id": "MDQ6VXNlcjk5OTg3MjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/9998726?v=4", "gravatar_id": "", "url": "https://api.github.com/users/peterjc123", "html_url": "https://github.com/peterjc123", "followers_url": "https://api.github.com/users/peterjc123/followers", "following_url": "https://api.github.com/users/peterjc123/following{/other_user}", "gists_url": "https://api.github.com/users/peterjc123/gists{/gist_id}", "starred_url": "https://api.github.com/users/peterjc123/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/peterjc123/subscriptions", "organizations_url": "https://api.github.com/users/peterjc123/orgs", "repos_url": "https://api.github.com/users/peterjc123/repos", "events_url": "https://api.github.com/users/peterjc123/events{/privacy}", "received_events_url": "https://api.github.com/users/peterjc123/received_events", "type": "User", "site_admin": false}, "created_at": "2018-03-15T14:46:02Z", "updated_at": "2018-03-15T14:46:02Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=4583066\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/apaszke\">@apaszke</a><br>\nI think there's still some confusion in your understanding towards the issue, so I'll explain it clearly again.</p>\n<h2>Explanation</h2>\n<p>The release for the FileMapping is described in <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/aa366532(v=vs.85).aspx\" rel=\"nofollow\">this</a> MSDN document.<br>\nThat is to say to fully release a <code>FileMapping</code>, we should do the following for all the processes.</p>\n<div class=\"highlight highlight-source-c++\"><pre><span class=\"pl-en\">CloseHandle</span>(handle);\n<span class=\"pl-en\">UnmapViewOfFile</span>(data);</pre></div>\n<p>However, currently we do it using refcount. That is</p>\n<div class=\"highlight highlight-source-c++\"><pre><span class=\"pl-k\">if</span> (THAtomicDecrementRef(&amp;info-&gt;refcount)) {\n  <span class=\"pl-c1\">CloseHandle</span>(ctx-&gt;<span class=\"pl-smi\">handle</span>);\n}\n<span class=\"pl-en\">UnmapViewOfFile</span>(data);</pre></div>\n<p>The refcount is the global count for the <strong>all</strong> the processes that hold <code>data</code>, not the local refcount for <code>data</code> inside the process. So when the global refcount is down to zero, it certainly only happen on <strong>only one process</strong>. One thing to state is that the <code>FileMapping</code> is used on a per tensor basis, which is not a process-level object. Thus the memory leak happens. The <code>FileMapping</code> is not released because the other processes still own the handle to the <code>FileMapping</code>.</p>\n<h2>About the simplified solution</h2>\n<p>Yes, you may argue that this implementation is not good enough. However, this issue is really existent. The memory are actually eaten up when you use multiple workers. One way to solve it more elegantly may be to delay the <code>ctx_context_free</code> of the shared tensor and call it when the transfer process of the data is over. But it's really hard to implement. As an alternative, we can use threadpool or sth like that. However, I don't know whether it's enough.</p>", "body_text": "@apaszke\nI think there's still some confusion in your understanding towards the issue, so I'll explain it clearly again.\nExplanation\nThe release for the FileMapping is described in this MSDN document.\nThat is to say to fully release a FileMapping, we should do the following for all the processes.\nCloseHandle(handle);\nUnmapViewOfFile(data);\nHowever, currently we do it using refcount. That is\nif (THAtomicDecrementRef(&info->refcount)) {\n  CloseHandle(ctx->handle);\n}\nUnmapViewOfFile(data);\nThe refcount is the global count for the all the processes that hold data, not the local refcount for data inside the process. So when the global refcount is down to zero, it certainly only happen on only one process. One thing to state is that the FileMapping is used on a per tensor basis, which is not a process-level object. Thus the memory leak happens. The FileMapping is not released because the other processes still own the handle to the FileMapping.\nAbout the simplified solution\nYes, you may argue that this implementation is not good enough. However, this issue is really existent. The memory are actually eaten up when you use multiple workers. One way to solve it more elegantly may be to delay the ctx_context_free of the shared tensor and call it when the transfer process of the data is over. But it's really hard to implement. As an alternative, we can use threadpool or sth like that. However, I don't know whether it's enough.", "body": "@apaszke \r\nI think there's still some confusion in your understanding towards the issue, so I'll explain it clearly again.\r\n## Explanation\r\nThe release for the FileMapping is described in [this](https://msdn.microsoft.com/en-us/library/windows/desktop/aa366532(v=vs.85).aspx) MSDN document.\r\nThat is to say to fully release a `FileMapping`, we should do the following for all the processes.\r\n```c++\r\nCloseHandle(handle);\r\nUnmapViewOfFile(data);\r\n```\r\nHowever, currently we do it using refcount. That is\r\n```C++\r\nif (THAtomicDecrementRef(&info->refcount)) {\r\n  CloseHandle(ctx->handle);\r\n}\r\nUnmapViewOfFile(data);\r\n```\r\nThe refcount is the global count for the __all__ the processes that hold `data`, not the local refcount for `data` inside the process. So when the global refcount is down to zero, it certainly only happen on __only one process__. One thing to state is that the `FileMapping` is used on a per tensor basis, which is not a process-level object. Thus the memory leak happens. The `FileMapping` is not released because the other processes still own the handle to the `FileMapping`.\r\n\r\n## About the simplified solution\r\nYes, you may argue that this implementation is not good enough. However, this issue is really existent. The memory are actually eaten up when you use multiple workers. One way to solve it more elegantly may be to delay the `ctx_context_free` of the shared tensor and call it when the transfer process of the data is over. But it's really hard to implement. As an alternative, we can use threadpool or sth like that. However, I don't know whether it's enough."}