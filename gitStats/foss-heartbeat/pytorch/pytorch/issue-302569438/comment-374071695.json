{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/374071695", "html_url": "https://github.com/pytorch/pytorch/pull/5585#issuecomment-374071695", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/5585", "id": 374071695, "node_id": "MDEyOklzc3VlQ29tbWVudDM3NDA3MTY5NQ==", "user": {"login": "peterjc123", "id": 9998726, "node_id": "MDQ6VXNlcjk5OTg3MjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/9998726?v=4", "gravatar_id": "", "url": "https://api.github.com/users/peterjc123", "html_url": "https://github.com/peterjc123", "followers_url": "https://api.github.com/users/peterjc123/followers", "following_url": "https://api.github.com/users/peterjc123/following{/other_user}", "gists_url": "https://api.github.com/users/peterjc123/gists{/gist_id}", "starred_url": "https://api.github.com/users/peterjc123/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/peterjc123/subscriptions", "organizations_url": "https://api.github.com/users/peterjc123/orgs", "repos_url": "https://api.github.com/users/peterjc123/repos", "events_url": "https://api.github.com/users/peterjc123/events{/privacy}", "received_events_url": "https://api.github.com/users/peterjc123/received_events", "type": "User", "site_admin": false}, "created_at": "2018-03-19T00:41:53Z", "updated_at": "2018-03-19T00:41:53Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=4583066\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/apaszke\">@apaszke</a> Thanks for your review. Yes, we can use <code>THMapAllocator</code> instead of <code>THRefMapAllocator</code> to get rid of the <code>refcount</code> but actually that is not the point. There is sth that blocks the use of this, too. The multiprocessing lib of Python uses Pipe to transfer data across processes under Windows. During this process, the <code>FileMapping</code> must not be closed. But it uses asynchronous IO so the correct closing timing of <code>FileMapping</code> is not easy to get. (Insert code to multiprocessing?)<br>\nAs an alternative, we can use <code>THRefMapAllocator</code> to confirm the IO process is actually finished when its refcount is down to zero. That is what this PR is currently doing.<br>\nPlease let me know what you think.</p>", "body_text": "@apaszke Thanks for your review. Yes, we can use THMapAllocator instead of THRefMapAllocator to get rid of the refcount but actually that is not the point. There is sth that blocks the use of this, too. The multiprocessing lib of Python uses Pipe to transfer data across processes under Windows. During this process, the FileMapping must not be closed. But it uses asynchronous IO so the correct closing timing of FileMapping is not easy to get. (Insert code to multiprocessing?)\nAs an alternative, we can use THRefMapAllocator to confirm the IO process is actually finished when its refcount is down to zero. That is what this PR is currently doing.\nPlease let me know what you think.", "body": "@apaszke Thanks for your review. Yes, we can use `THMapAllocator` instead of `THRefMapAllocator` to get rid of the `refcount` but actually that is not the point. There is sth that blocks the use of this, too. The multiprocessing lib of Python uses Pipe to transfer data across processes under Windows. During this process, the `FileMapping` must not be closed. But it uses asynchronous IO so the correct closing timing of `FileMapping` is not easy to get. (Insert code to multiprocessing?)\r\nAs an alternative, we can use `THRefMapAllocator` to confirm the IO process is actually finished when its refcount is down to zero. That is what this PR is currently doing.\r\nPlease let me know what you think."}