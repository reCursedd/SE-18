{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/102782307", "pull_request_review_id": 23549946, "id": 102782307, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwMjc4MjMwNw==", "diff_hunk": "@@ -1450,6 +1458,233 @@ def test_batchnorm_eval(self):\n             self.assertEqual(grad1, grad2)\n \n \n+class TestNNInit(unittest.TestCase):\n+    def setUp(self):\n+        np.random.seed(123)\n+        torch.manual_seed(123)\n+\n+    def _is_normal(self, tensor, mean, std):\n+        if isinstance(tensor, Variable):\n+            tensor = tensor.data\n+        p_value = stats.kstest(tensor.numpy().flatten(), 'norm', args=(mean, std)).pvalue\n+        return p_value > 0.0001\n+\n+    def _is_uniform(self, tensor, a, b):\n+        if isinstance(tensor, Variable):\n+            tensor = tensor.data\n+        p_value = stats.kstest(tensor.numpy().flatten(), 'uniform', args=(a, (b - a))).pvalue\n+        return p_value > 0.0001\n+\n+    def _create_random_nd_tensor(self, dims, size_min, size_max, as_variable):\n+        size = [randint(size_min, size_max + 1) for _ in range(dims)]\n+        tensor = torch.zeros(size)\n+        if as_variable:\n+            tensor = Variable(tensor)\n+        return tensor\n+\n+    def _random_float(self, a, b):\n+        return (b - a) * random_sample() + a\n+\n+    def test_uniform(self):\n+        for as_variable in [True, False]:\n+            for dims in [1, 2, 4]:\n+                input_tensor = self._create_random_nd_tensor(dims, size_min=30, size_max=50, as_variable=as_variable)\n+                a = self._random_float(-3, 3)\n+                b = a + self._random_float(1, 5)\n+                init.uniform(input_tensor, a=a, b=b)\n+                assert self._is_uniform(input_tensor, a, b)\n+\n+    def test_normal(self):\n+        for as_variable in [True, False]:\n+            for dims in [1, 2, 4]:\n+                input_tensor = self._create_random_nd_tensor(dims, size_min=30, size_max=50, as_variable=as_variable)\n+                mean = self._random_float(-3, 3)\n+                std = self._random_float(1, 5)\n+                init.normal(input_tensor, mean=mean, std=std)\n+\n+                assert self._is_normal(input_tensor, mean, std)\n+\n+    def test_constant(self):\n+        for as_variable in [True, False]:\n+            for dims in [1, 2, 4]:\n+                input_tensor = self._create_random_nd_tensor(dims, size_min=1, size_max=5, as_variable=as_variable)\n+                val = self._random_float(1, 10)\n+                init.constant(input_tensor, val)\n+                if as_variable:\n+                    input_tensor = input_tensor.data\n+\n+                assert np.allclose(input_tensor.numpy(), input_tensor.clone().fill_(val).numpy())\n+\n+    def test_xavier_uniform_errors_on_inputs_smaller_than_2d(self):\n+        for as_variable in [True, False]:\n+            for dims in [0, 1]:\n+                tensor = self._create_random_nd_tensor(dims, size_min=1, size_max=1, as_variable=as_variable)\n+                with self.assertRaises(ValueError):\n+                    init.xavier_uniform(tensor)\n+\n+    def test_xavier_normal_errors_on_inputs_smaller_than_2d(self):\n+        for as_variable in [True, False]:\n+            for dims in [0, 1]:\n+                tensor = self._create_random_nd_tensor(dims, size_min=1, size_max=1, as_variable=as_variable)\n+                with self.assertRaises(ValueError):\n+                    init.xavier_normal(tensor)\n+\n+    def test_xavier_uniform(self):\n+        for as_variable in [True, False]:\n+            for use_gain in [True, False]:\n+                for dims in [2, 4]:\n+                    input_tensor = self._create_random_nd_tensor(dims, size_min=20, size_max=25, as_variable=as_variable)\n+                    gain = 1\n+\n+                    if use_gain:\n+                        gain = self._random_float(0.1, 2)\n+                        init.xavier_uniform(input_tensor, gain=gain)\n+                    else:\n+                        init.xavier_uniform(input_tensor)\n+\n+                    if as_variable:\n+                        input_tensor = input_tensor.data\n+\n+                    tensor_shape = input_tensor.numpy().shape\n+                    receptive_field = np.prod(tensor_shape[2:])\n+                    expected_std = gain * np.sqrt(2.0 / ((tensor_shape[1] + tensor_shape[0]) * receptive_field))\n+                    bounds = expected_std * np.sqrt(3)\n+                    assert self._is_uniform(input_tensor, -bounds, bounds)\n+\n+    def test_xavier_normal(self):\n+        for as_variable in [True, False]:\n+            for use_gain in [True, False]:\n+                for dims in [2, 4]:\n+                    input_tensor = self._create_random_nd_tensor(dims, size_min=20, size_max=25, as_variable=as_variable)\n+                    gain = 1\n+\n+                    if use_gain:\n+                        gain = self._random_float(0.1, 2)\n+                        init.xavier_normal(input_tensor, gain=gain)\n+                    else:\n+                        init.xavier_normal(input_tensor)\n+\n+                    if as_variable:\n+                        input_tensor = input_tensor.data\n+\n+                    tensor_shape = input_tensor.numpy().shape\n+                    receptive_field = np.prod(tensor_shape[2:])\n+\n+                    expected_std = gain * np.sqrt(2.0 / ((tensor_shape[1] + tensor_shape[0]) * receptive_field))\n+                    assert self._is_normal(input_tensor, 0, expected_std)\n+\n+    def test_kaiming_unifrom_errors_on_inputs_smaller_than_2d(self):", "path": "test/test_nn.py", "position": null, "original_position": 286, "commit_id": "7d979075cc3167a956b14cd3cfd05a56fde264fa", "original_commit_id": "6c88e7dd4785e16b1d26766c09b12808bc7e2f82", "user": {"login": "alykhantejani", "id": 687194, "node_id": "MDQ6VXNlcjY4NzE5NA==", "avatar_url": "https://avatars1.githubusercontent.com/u/687194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alykhantejani", "html_url": "https://github.com/alykhantejani", "followers_url": "https://api.github.com/users/alykhantejani/followers", "following_url": "https://api.github.com/users/alykhantejani/following{/other_user}", "gists_url": "https://api.github.com/users/alykhantejani/gists{/gist_id}", "starred_url": "https://api.github.com/users/alykhantejani/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alykhantejani/subscriptions", "organizations_url": "https://api.github.com/users/alykhantejani/orgs", "repos_url": "https://api.github.com/users/alykhantejani/repos", "events_url": "https://api.github.com/users/alykhantejani/events{/privacy}", "received_events_url": "https://api.github.com/users/alykhantejani/received_events", "type": "User", "site_admin": false}, "body": "fix typo: unifrom -> uniform", "created_at": "2017-02-23T18:27:02Z", "updated_at": "2018-11-23T15:32:30Z", "html_url": "https://github.com/pytorch/pytorch/pull/833#discussion_r102782307", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/833", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/102782307"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/833#discussion_r102782307"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/833"}}, "body_html": "<p>fix typo: unifrom -&gt; uniform</p>", "body_text": "fix typo: unifrom -> uniform"}