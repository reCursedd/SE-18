{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/103101750", "pull_request_review_id": 23879106, "id": 103101750, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwMzEwMTc1MA==", "diff_hunk": "@@ -1450,6 +1457,261 @@ def test_batchnorm_eval(self):\n             self.assertEqual(grad1, grad2)\n \n \n+class TestNNInit(TestCase):\n+    def setUp(self):\n+        random.seed(123)\n+        torch.manual_seed(123)\n+\n+    def _is_normal(self, tensor, mean, std):\n+        if isinstance(tensor, Variable):\n+            tensor = tensor.data\n+        samples = list(tensor.view(-1))\n+        p_value = stats.kstest(samples, 'norm', args=(mean, std)).pvalue\n+        return p_value > 0.0001\n+\n+    def _is_uniform(self, tensor, a, b):\n+        if isinstance(tensor, Variable):\n+            tensor = tensor.data\n+        samples = list(tensor.view(-1))\n+        p_value = stats.kstest(samples, 'uniform', args=(a, (b - a))).pvalue\n+        return p_value > 0.0001\n+\n+    def _create_random_nd_tensor(self, dims, size_min, size_max, as_variable):\n+        size = [random.randint(size_min, size_max) for _ in range(dims)]\n+        tensor = torch.zeros(size)\n+        if as_variable:\n+            tensor = Variable(tensor)\n+        return tensor\n+\n+    def _random_float(self, a, b):\n+        return (b - a) * random.random() + a\n+\n+    @unittest.skipIf(not TEST_SCIPY, \"Scipy not found.\")\n+    def test_uniform(self):\n+        for as_variable in [True, False]:\n+            for dims in [1, 2, 4]:\n+                input_tensor = self._create_random_nd_tensor(dims, size_min=30, size_max=50, as_variable=as_variable)\n+                a = self._random_float(-3, 3)\n+                b = a + self._random_float(1, 5)\n+                init.uniform(input_tensor, a=a, b=b)\n+                assert self._is_uniform(input_tensor, a, b)\n+\n+    @unittest.skipIf(not TEST_SCIPY, \"Scipy not found.\")\n+    def test_normal(self):\n+        for as_variable in [True, False]:\n+            for dims in [1, 2, 4]:\n+                input_tensor = self._create_random_nd_tensor(dims, size_min=30, size_max=50, as_variable=as_variable)\n+                mean = self._random_float(-3, 3)\n+                std = self._random_float(1, 5)\n+                init.normal(input_tensor, mean=mean, std=std)\n+\n+                assert self._is_normal(input_tensor, mean, std)\n+\n+    def test_constant(self):\n+        for as_variable in [True, False]:\n+            for dims in [1, 2, 4]:\n+                input_tensor = self._create_random_nd_tensor(dims, size_min=1, size_max=5, as_variable=as_variable)\n+                val = self._random_float(1, 10)\n+                init.constant(input_tensor, val)\n+                if as_variable:\n+                    input_tensor = input_tensor.data\n+\n+                self.assertEqual(input_tensor, input_tensor.clone().fill_(val))\n+\n+    def test_xavier_uniform_errors_on_inputs_smaller_than_2d(self):\n+        for as_variable in [True, False]:\n+            for dims in [0, 1]:\n+                tensor = self._create_random_nd_tensor(dims, size_min=1, size_max=1, as_variable=as_variable)\n+                with self.assertRaises(ValueError):\n+                    init.xavier_uniform(tensor)\n+\n+    def test_xavier_normal_errors_on_inputs_smaller_than_2d(self):\n+        for as_variable in [True, False]:\n+            for dims in [0, 1]:\n+                tensor = self._create_random_nd_tensor(dims, size_min=1, size_max=1, as_variable=as_variable)\n+                with self.assertRaises(ValueError):\n+                    init.xavier_normal(tensor)\n+\n+    @unittest.skipIf(not TEST_SCIPY, \"Scipy not found.\")\n+    def test_xavier_uniform(self):\n+        for as_variable in [True, False]:\n+            for use_gain in [True, False]:\n+                for dims in [2, 4]:\n+                    input_tensor = self._create_random_nd_tensor(dims, size_min=20, size_max=25,\n+                                                                 as_variable=as_variable)\n+                    gain = 1\n+\n+                    if use_gain:\n+                        gain = self._random_float(0.1, 2)\n+                        init.xavier_uniform(input_tensor, gain=gain)\n+                    else:\n+                        init.xavier_uniform(input_tensor)\n+\n+                    if as_variable:\n+                        input_tensor = input_tensor.data\n+\n+                    fan_in = input_tensor.size(1)\n+                    fan_out = input_tensor.size(0)\n+                    if input_tensor.dim() > 2:\n+                        fan_in *= input_tensor[0][0].numel()\n+                        fan_out *= input_tensor[0][0].numel()\n+\n+                    expected_std = gain * math.sqrt(2.0 / (fan_in + fan_out))\n+                    bounds = expected_std * math.sqrt(3)\n+                    assert self._is_uniform(input_tensor, -bounds, bounds)\n+\n+    @unittest.skipIf(not TEST_SCIPY, \"Scipy not found.\")\n+    def test_xavier_normal(self):\n+        for as_variable in [True, False]:\n+            for use_gain in [True, False]:\n+                for dims in [2, 4]:\n+                    input_tensor = self._create_random_nd_tensor(dims, size_min=20, size_max=25,\n+                                                                 as_variable=as_variable)\n+                    gain = 1\n+\n+                    if use_gain:\n+                        gain = self._random_float(0.1, 2)\n+                        init.xavier_normal(input_tensor, gain=gain)\n+                    else:\n+                        init.xavier_normal(input_tensor)\n+\n+                    if as_variable:\n+                        input_tensor = input_tensor.data\n+\n+                    fan_in = input_tensor.size(1)\n+                    fan_out = input_tensor.size(0)\n+                    if input_tensor.dim() > 2:\n+                        fan_in *= input_tensor[0][0].numel()\n+                        fan_out *= input_tensor[0][0].numel()\n+\n+                    expected_std = gain * math.sqrt(2.0 / (fan_in + fan_out))\n+                    assert self._is_normal(input_tensor, 0, expected_std)\n+\n+    def test_kaiming_uniform_errors_on_inputs_smaller_than_2d(self):\n+        for as_variable in [True, False]:\n+            for dims in [0, 1]:\n+                with self.assertRaises(ValueError):\n+                    tensor = self._create_random_nd_tensor(dims, size_min=1, size_max=1, as_variable=as_variable)\n+                    init.kaiming_uniform(tensor)\n+\n+    def test_kaiming_normal_errors_on_inputs_smaller_than_2d(self):\n+        for as_variable in [True, False]:\n+            for dims in [0, 1]:\n+                with self.assertRaises(ValueError):\n+                    tensor = self._create_random_nd_tensor(dims, size_min=1, size_max=1, as_variable=as_variable)\n+                    init.kaiming_normal(tensor)\n+\n+    @unittest.skipIf(not TEST_SCIPY, \"Scipy not found.\")\n+    def test_kaiming_uniform(self):\n+        for as_variable in [True, False]:\n+            for use_a in [True, False]:\n+                for dims in [2, 4]:\n+                    input_tensor = self._create_random_nd_tensor(dims, size_min=20, size_max=25,\n+                                                                 as_variable=as_variable)\n+                    if use_a:\n+                        a = self._random_float(0.1, 2)\n+                        init.kaiming_uniform(input_tensor, a=a)\n+                    else:\n+                        a = 0\n+                        init.kaiming_uniform(input_tensor)\n+\n+                    if as_variable:\n+                        input_tensor = input_tensor.data\n+\n+                    fan_in = input_tensor.size(1)\n+                    if input_tensor.dim() > 2:\n+                        fan_in *= input_tensor[0][0].numel()", "path": "test/test_nn.py", "position": null, "original_position": 339, "commit_id": "7d979075cc3167a956b14cd3cfd05a56fde264fa", "original_commit_id": "850137b0f2d5d3e567ee517c67da3eb95a07b71c", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "body": "nit: you can do that index in one step: `input_tensor[0, 0]`. You don't have to fix that right now, but keep that in mind.", "created_at": "2017-02-26T11:13:29Z", "updated_at": "2018-11-23T15:32:33Z", "html_url": "https://github.com/pytorch/pytorch/pull/833#discussion_r103101750", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/833", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/103101750"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/833#discussion_r103101750"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/833"}}, "body_html": "<p>nit: you can do that index in one step: <code>input_tensor[0, 0]</code>. You don't have to fix that right now, but keep that in mind.</p>", "body_text": "nit: you can do that index in one step: input_tensor[0, 0]. You don't have to fix that right now, but keep that in mind."}