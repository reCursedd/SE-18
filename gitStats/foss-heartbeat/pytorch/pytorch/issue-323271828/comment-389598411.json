{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/389598411", "html_url": "https://github.com/pytorch/pytorch/issues/7580#issuecomment-389598411", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/7580", "id": 389598411, "node_id": "MDEyOklzc3VlQ29tbWVudDM4OTU5ODQxMQ==", "user": {"login": "zasdfgbnm", "id": 1032377, "node_id": "MDQ6VXNlcjEwMzIzNzc=", "avatar_url": "https://avatars2.githubusercontent.com/u/1032377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zasdfgbnm", "html_url": "https://github.com/zasdfgbnm", "followers_url": "https://api.github.com/users/zasdfgbnm/followers", "following_url": "https://api.github.com/users/zasdfgbnm/following{/other_user}", "gists_url": "https://api.github.com/users/zasdfgbnm/gists{/gist_id}", "starred_url": "https://api.github.com/users/zasdfgbnm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zasdfgbnm/subscriptions", "organizations_url": "https://api.github.com/users/zasdfgbnm/orgs", "repos_url": "https://api.github.com/users/zasdfgbnm/repos", "events_url": "https://api.github.com/users/zasdfgbnm/events{/privacy}", "received_events_url": "https://api.github.com/users/zasdfgbnm/received_events", "type": "User", "site_admin": false}, "created_at": "2018-05-16T17:20:18Z", "updated_at": "2018-05-16T17:43:31Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=9110200\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/fmassa\">@fmassa</a> Also, the first index list of <code>combination_range</code>, and <code>combination_range_with_replacement </code>, i.e. the <code>[ 0,  0,  1]</code> and <code>[ 0,  0,  0,  1,  1,  2]</code>, can be easily generated by <code>numpy.repeat</code>, for example:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> a <span class=\"pl-k\">=</span> numpy.arange(<span class=\"pl-c1\">3</span>)\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> repeat <span class=\"pl-k\">=</span> numpy.arange(<span class=\"pl-c1\">3</span>,<span class=\"pl-c1\">0</span>,<span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>)\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> a.repeat(repeat)\narray([<span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">2</span>])</pre></div>\n<p>But I don't think pytorch has similar thing, right?</p>\n<p>So, would it be helpful if we create a <code>torch.repeat2</code> to support numpy like API? This sounds more useful than <code>combination_range</code> and <code>combination_range_with_replacement</code>.</p>\n<p>Generally, <code>torch.repeat</code> does repeat like <code>[1,2]--&gt;[1,2,1,2,1,2]</code> and has torch-like API, and <code>torch.repeat2</code> does the repeat like <code>[1,2]--&gt;[1,1,1,2,2,2]</code> and has numpy-like API. Then cartesian product, combinations, and combinations with replacement can all be easily implemented with the two version of repeat.  And also, the implementation of cartesian product using <code>repeat</code> and <code>repeat2</code> is more straightforward to me than meshgrid.</p>", "body_text": "@fmassa Also, the first index list of combination_range, and combination_range_with_replacement , i.e. the [ 0,  0,  1] and [ 0,  0,  0,  1,  1,  2], can be easily generated by numpy.repeat, for example:\n>>> a = numpy.arange(3)\n>>> repeat = numpy.arange(3,0,-1)\n>>> a.repeat(repeat)\narray([0, 0, 0, 1, 1, 2])\nBut I don't think pytorch has similar thing, right?\nSo, would it be helpful if we create a torch.repeat2 to support numpy like API? This sounds more useful than combination_range and combination_range_with_replacement.\nGenerally, torch.repeat does repeat like [1,2]-->[1,2,1,2,1,2] and has torch-like API, and torch.repeat2 does the repeat like [1,2]-->[1,1,1,2,2,2] and has numpy-like API. Then cartesian product, combinations, and combinations with replacement can all be easily implemented with the two version of repeat.  And also, the implementation of cartesian product using repeat and repeat2 is more straightforward to me than meshgrid.", "body": "@fmassa Also, the first index list of `combination_range`, and `combination_range_with_replacement `, i.e. the `[ 0,  0,  1]` and `[ 0,  0,  0,  1,  1,  2]`, can be easily generated by `numpy.repeat`, for example:\r\n```python\r\n>>> a = numpy.arange(3)\r\n>>> repeat = numpy.arange(3,0,-1)\r\n>>> a.repeat(repeat)\r\narray([0, 0, 0, 1, 1, 2])\r\n```\r\nBut I don't think pytorch has similar thing, right?\r\n\r\nSo, would it be helpful if we create a `torch.repeat2` to support numpy like API? This sounds more useful than `combination_range` and `combination_range_with_replacement`.\r\n\r\nGenerally, `torch.repeat` does repeat like `[1,2]-->[1,2,1,2,1,2]` and has torch-like API, and `torch.repeat2` does the repeat like `[1,2]-->[1,1,1,2,2,2]` and has numpy-like API. Then cartesian product, combinations, and combinations with replacement can all be easily implemented with the two version of repeat.  And also, the implementation of cartesian product using `repeat` and `repeat2` is more straightforward to me than meshgrid."}