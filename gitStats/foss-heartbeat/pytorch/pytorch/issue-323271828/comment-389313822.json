{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/389313822", "html_url": "https://github.com/pytorch/pytorch/issues/7580#issuecomment-389313822", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/7580", "id": 389313822, "node_id": "MDEyOklzc3VlQ29tbWVudDM4OTMxMzgyMg==", "user": {"login": "fmassa", "id": 9110200, "node_id": "MDQ6VXNlcjkxMTAyMDA=", "avatar_url": "https://avatars2.githubusercontent.com/u/9110200?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fmassa", "html_url": "https://github.com/fmassa", "followers_url": "https://api.github.com/users/fmassa/followers", "following_url": "https://api.github.com/users/fmassa/following{/other_user}", "gists_url": "https://api.github.com/users/fmassa/gists{/gist_id}", "starred_url": "https://api.github.com/users/fmassa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fmassa/subscriptions", "organizations_url": "https://api.github.com/users/fmassa/orgs", "repos_url": "https://api.github.com/users/fmassa/repos", "events_url": "https://api.github.com/users/fmassa/events{/privacy}", "received_events_url": "https://api.github.com/users/fmassa/received_events", "type": "User", "site_admin": false}, "created_at": "2018-05-15T21:07:47Z", "updated_at": "2018-05-15T21:07:47Z", "author_association": "MEMBER", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=1032377\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/zasdfgbnm\">@zasdfgbnm</a> I think I understand the use-case. I misused the work \"sampling\" to express what I meant earlier on.<br>\nMaybe a small (and untested) code snippet can better express what I meant:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-c\"><span class=\"pl-c\">#</span> helper function</span>\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">meshgrid</span>(<span class=\"pl-smi\">x</span>, <span class=\"pl-smi\">y</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">None</span>):\n    <span class=\"pl-k\">if</span> y <span class=\"pl-k\">is</span> <span class=\"pl-c1\">None</span>:\n        y <span class=\"pl-k\">=</span> x\n    x <span class=\"pl-k\">=</span> torch.as_tensor(x)\n    y <span class=\"pl-k\">=</span> torch.as_tensor(y)\n    m, n <span class=\"pl-k\">=</span> x.size(<span class=\"pl-c1\">0</span>), y.size(<span class=\"pl-c1\">0</span>)\n    grid_x <span class=\"pl-k\">=</span> x[<span class=\"pl-c1\">None</span>].expand(n, m)\n    grid_y <span class=\"pl-k\">=</span> y[:, <span class=\"pl-c1\">None</span>].expand(n, m)\n    <span class=\"pl-k\">return</span> grid_x, grid_y\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">combinations</span>(<span class=\"pl-smi\">x</span>, <span class=\"pl-smi\">y</span>, <span class=\"pl-smi\">dim</span>, <span class=\"pl-smi\">n</span>):\n    <span class=\"pl-s\"><span class=\"pl-pds\">\"\"\"</span></span>\n<span class=\"pl-s\">    Given tensors x and y, get a random combination</span>\n<span class=\"pl-s\">    of the elements of x and y over dimension dim</span>\n<span class=\"pl-s\">    <span class=\"pl-pds\">\"\"\"</span></span>\n    xs <span class=\"pl-k\">=</span> torch.arange(x.shape[dim])\n    ys <span class=\"pl-k\">=</span> torch.arange(y.shape[dim])\n    grid_x, grid_y <span class=\"pl-k\">=</span> meshgrid(xs, ys)\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> select n random elements from the</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> cartesian product</span>\n    sampled <span class=\"pl-k\">=</span> torch.randperm(grid_x.numel())[:n]\n    indices_x <span class=\"pl-k\">=</span> grid_x.take(sampled)\n    indices_y <span class=\"pl-k\">=</span> grid_y.take(sampled)\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> get from the indices</span>\n    <span class=\"pl-k\">return</span> x.index_select(dim, indices_x), y.index_select(dim, indices_y) </pre></div>\n<p>There might be value in adding something like that in pytorch, but as I said before, it might be good to have the opinion from the others from the team.</p>", "body_text": "@zasdfgbnm I think I understand the use-case. I misused the work \"sampling\" to express what I meant earlier on.\nMaybe a small (and untested) code snippet can better express what I meant:\n# helper function\ndef meshgrid(x, y=None):\n    if y is None:\n        y = x\n    x = torch.as_tensor(x)\n    y = torch.as_tensor(y)\n    m, n = x.size(0), y.size(0)\n    grid_x = x[None].expand(n, m)\n    grid_y = y[:, None].expand(n, m)\n    return grid_x, grid_y\n\ndef combinations(x, y, dim, n):\n    \"\"\"\n    Given tensors x and y, get a random combination\n    of the elements of x and y over dimension dim\n    \"\"\"\n    xs = torch.arange(x.shape[dim])\n    ys = torch.arange(y.shape[dim])\n    grid_x, grid_y = meshgrid(xs, ys)\n    # select n random elements from the\n    # cartesian product\n    sampled = torch.randperm(grid_x.numel())[:n]\n    indices_x = grid_x.take(sampled)\n    indices_y = grid_y.take(sampled)\n    # get from the indices\n    return x.index_select(dim, indices_x), y.index_select(dim, indices_y) \nThere might be value in adding something like that in pytorch, but as I said before, it might be good to have the opinion from the others from the team.", "body": "@zasdfgbnm I think I understand the use-case. I misused the work \"sampling\" to express what I meant earlier on.\r\nMaybe a small (and untested) code snippet can better express what I meant:\r\n```python\r\n# helper function\r\ndef meshgrid(x, y=None):\r\n    if y is None:\r\n        y = x\r\n    x = torch.as_tensor(x)\r\n    y = torch.as_tensor(y)\r\n    m, n = x.size(0), y.size(0)\r\n    grid_x = x[None].expand(n, m)\r\n    grid_y = y[:, None].expand(n, m)\r\n    return grid_x, grid_y\r\n\r\ndef combinations(x, y, dim, n):\r\n    \"\"\"\r\n    Given tensors x and y, get a random combination\r\n    of the elements of x and y over dimension dim\r\n    \"\"\"\r\n    xs = torch.arange(x.shape[dim])\r\n    ys = torch.arange(y.shape[dim])\r\n    grid_x, grid_y = meshgrid(xs, ys)\r\n    # select n random elements from the\r\n    # cartesian product\r\n    sampled = torch.randperm(grid_x.numel())[:n]\r\n    indices_x = grid_x.take(sampled)\r\n    indices_y = grid_y.take(sampled)\r\n    # get from the indices\r\n    return x.index_select(dim, indices_x), y.index_select(dim, indices_y) \r\n```\r\n\r\nThere might be value in adding something like that in pytorch, but as I said before, it might be good to have the opinion from the others from the team."}