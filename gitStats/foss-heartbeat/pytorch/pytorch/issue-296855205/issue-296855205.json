{"url": "https://api.github.com/repos/pytorch/pytorch/issues/5220", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/5220/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/5220/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/5220/events", "html_url": "https://github.com/pytorch/pytorch/issues/5220", "id": 296855205, "node_id": "MDU6SXNzdWUyOTY4NTUyMDU=", "number": 5220, "title": "[JIT] Add named tuples (a.k.a. records) to the JIT IR", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 679953983, "node_id": "MDU6TGFiZWw2Nzk5NTM5ODM=", "url": "https://api.github.com/repos/pytorch/pytorch/labels/jit", "name": "jit", "color": "c5def5", "default": false}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 6, "created_at": "2018-02-13T19:21:55Z", "updated_at": "2018-02-16T07:36:22Z", "closed_at": null, "author_association": "CONTRIBUTOR", "body_html": "<p><strong>Motivation.</strong> Today, in the JIT, our data model is that only all operators take a flat list of variables and produce a flat list of variables. This is a very uniform model which makes it easy to do code generation, but it makes our internal operations more difficult to understand, because we have to decode a flat list of variables into their semantic meaning when we want to perform optimizations that know about the semantics of operations.</p>\n<p><strong>Proposal.</strong> Here is the design principle for adding named tuples to the JIT IR: data structures should be desugarable into our existing flat model at compile time without requiring any runtime code. This means statically sized data structures like named tuples are permissible, while dynamically sized structures like vectors and recursive tuples are not. The type of a data structure unambiguously determines the number of elements in the corresponding flat list.</p>\n<p>Thus, our IR representation will be stratified into two languages: a higher-level language with data structures, and a lower-level one that operates on flat lists (same as before.)</p>\n<p>Concretely, we extend types:</p>\n<pre><code>// The type of named tuples\nstruct TupleType : public Type {\n  TupleType(at::ArrayRef&lt;Symbol&gt; labels, at::ArrayRef&lt;Type&gt; types);\n  // The number of Tensor entries when this type is flattened.\n  size_t flatSize();\n}\n</code></pre>\n<p>I will notate a named tuple as <code>(l1: t1, ..., ln: tn)</code>, where <code>l</code> ranges over the symbol labels, and <code>t</code> ranges over types. Order matters.  We define the following operators:</p>\n<ul>\n<li><code>%t = Tuple[labels :: strings] %0, ... %n</code>: takes n labels as attributes, and n inputs of types t0 ... tn , and constructs a tuple of type <code>(l0: t0, ..., ln: tn)</code>. If labels are omitted, this is equivalent to having specified <code>[\"0\", \"1\", ... \"n\"]</code> as the labels.</li>\n<li><code>%0, ... %n = Untuple %t</code>: takes a tuple of type <code>Tuple&lt;l1: t1, ... , ln: tn&gt;</code> and produces n outputs of types t1 ... tn.</li>\n<li><code>%r = Proj[label :: string] %t</code>: takes a tuple of type <code>Tuple&lt;n1: t1, ... nn : tn&gt;</code> and a string label <code>i</code>, and produces an output of type <code>ti</code>.</li>\n</ul>\n<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=370202\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/zdevito\">@zdevito</a> <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=4583066\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/apaszke\">@apaszke</a> <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=4685384\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/jamesr66a\">@jamesr66a</a> <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=9300575\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/bddppq\">@bddppq</a></p>", "body_text": "Motivation. Today, in the JIT, our data model is that only all operators take a flat list of variables and produce a flat list of variables. This is a very uniform model which makes it easy to do code generation, but it makes our internal operations more difficult to understand, because we have to decode a flat list of variables into their semantic meaning when we want to perform optimizations that know about the semantics of operations.\nProposal. Here is the design principle for adding named tuples to the JIT IR: data structures should be desugarable into our existing flat model at compile time without requiring any runtime code. This means statically sized data structures like named tuples are permissible, while dynamically sized structures like vectors and recursive tuples are not. The type of a data structure unambiguously determines the number of elements in the corresponding flat list.\nThus, our IR representation will be stratified into two languages: a higher-level language with data structures, and a lower-level one that operates on flat lists (same as before.)\nConcretely, we extend types:\n// The type of named tuples\nstruct TupleType : public Type {\n  TupleType(at::ArrayRef<Symbol> labels, at::ArrayRef<Type> types);\n  // The number of Tensor entries when this type is flattened.\n  size_t flatSize();\n}\n\nI will notate a named tuple as (l1: t1, ..., ln: tn), where l ranges over the symbol labels, and t ranges over types. Order matters.  We define the following operators:\n\n%t = Tuple[labels :: strings] %0, ... %n: takes n labels as attributes, and n inputs of types t0 ... tn , and constructs a tuple of type (l0: t0, ..., ln: tn). If labels are omitted, this is equivalent to having specified [\"0\", \"1\", ... \"n\"] as the labels.\n%0, ... %n = Untuple %t: takes a tuple of type Tuple<l1: t1, ... , ln: tn> and produces n outputs of types t1 ... tn.\n%r = Proj[label :: string] %t: takes a tuple of type Tuple<n1: t1, ... nn : tn> and a string label i, and produces an output of type ti.\n\n@zdevito @apaszke @jamesr66a @bddppq", "body": "**Motivation.** Today, in the JIT, our data model is that only all operators take a flat list of variables and produce a flat list of variables. This is a very uniform model which makes it easy to do code generation, but it makes our internal operations more difficult to understand, because we have to decode a flat list of variables into their semantic meaning when we want to perform optimizations that know about the semantics of operations.\r\n\r\n**Proposal.** Here is the design principle for adding named tuples to the JIT IR: data structures should be desugarable into our existing flat model at compile time without requiring any runtime code. This means statically sized data structures like named tuples are permissible, while dynamically sized structures like vectors and recursive tuples are not. The type of a data structure unambiguously determines the number of elements in the corresponding flat list.\r\n\r\nThus, our IR representation will be stratified into two languages: a higher-level language with data structures, and a lower-level one that operates on flat lists (same as before.)\r\n\r\nConcretely, we extend types:\r\n\r\n```\r\n// The type of named tuples\r\nstruct TupleType : public Type {\r\n  TupleType(at::ArrayRef<Symbol> labels, at::ArrayRef<Type> types);\r\n  // The number of Tensor entries when this type is flattened.\r\n  size_t flatSize();\r\n}\r\n```\r\n\r\nI will notate a named tuple as `(l1: t1, ..., ln: tn)`, where `l` ranges over the symbol labels, and `t` ranges over types. Order matters.  We define the following operators:\r\n\r\n* `%t = Tuple[labels :: strings] %0, ... %n`: takes n labels as attributes, and n inputs of types t0 ... tn , and constructs a tuple of type `(l0: t0, ..., ln: tn)`. If labels are omitted, this is equivalent to having specified `[\"0\", \"1\", ... \"n\"]` as the labels.\r\n* `%0, ... %n = Untuple %t`: takes a tuple of type `Tuple<l1: t1, ... , ln: tn>` and produces n outputs of types t1 ... tn.\r\n* `%r = Proj[label :: string] %t`: takes a tuple of type `Tuple<n1: t1, ... nn : tn>` and a string label `i`, and produces an output of type `ti`.\r\n\r\n@zdevito @apaszke @jamesr66a @bddppq "}