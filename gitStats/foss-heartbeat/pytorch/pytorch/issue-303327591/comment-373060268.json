{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/373060268", "html_url": "https://github.com/pytorch/pytorch/pull/5624#issuecomment-373060268", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/5624", "id": 373060268, "node_id": "MDEyOklzc3VlQ29tbWVudDM3MzA2MDI2OA==", "user": {"login": "perone", "id": 412328, "node_id": "MDQ6VXNlcjQxMjMyOA==", "avatar_url": "https://avatars0.githubusercontent.com/u/412328?v=4", "gravatar_id": "", "url": "https://api.github.com/users/perone", "html_url": "https://github.com/perone", "followers_url": "https://api.github.com/users/perone/followers", "following_url": "https://api.github.com/users/perone/following{/other_user}", "gists_url": "https://api.github.com/users/perone/gists{/gist_id}", "starred_url": "https://api.github.com/users/perone/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/perone/subscriptions", "organizations_url": "https://api.github.com/users/perone/orgs", "repos_url": "https://api.github.com/users/perone/repos", "events_url": "https://api.github.com/users/perone/events{/privacy}", "received_events_url": "https://api.github.com/users/perone/received_events", "type": "User", "site_admin": false}, "created_at": "2018-03-14T15:21:32Z", "updated_at": "2018-03-14T15:21:32Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Thanks for taking a look at that <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=5652049\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/zou3519\">@zou3519</a>. I understand the problem, however, I would say that in many applications this can be useful in long-term, because it will allow us to propagate complex structured objects that aren't easily wrapped in a Tensor.<br>\nI can accomplish the same using a custom <code>collate_fn</code>, however, in my case, I'm trying to write a user-facing API, which will then force users to instantiate DataLoader with this custom <code>collate_fn</code> or as an alternative, to use a custom <code>DataLoader</code> where I already have my default <code>collate_fn</code> defined, so neither options are elegant.<br>\nThere is also another minor issue, the <code>default_collate</code> is using nowadays a global <code>_use_shared_memory</code> variable that would force you to add reference to it when replicating it outside of the module or setting manually, which is also not very elegant (this makes me think if <code>default_collate</code> shouldn't be a custom class object that is initialized with context).</p>\n<p>Apart from that, the <code>default_collate</code> that we have today is arbitrarily selective: it allows you to have not only tensors but also strings. On the other side, I understand your concern about usability, however, if the user receives a batch that isn't a tensor, it would raise another exception later when feeding to the model, so this isn't a problem that will silently pass. My only concern is: you have more than one worker and you start passing complex objects that wouldn't allow shared memory, making copies very inefficient. This is indeed a usability issue.</p>\n<p>As you mentioned, it would allow flexibility but it would hurt a little the usability, but in my opinion, the long-term gains would be worth the change. What do you think ? (Sorry for the long comment).</p>", "body_text": "Thanks for taking a look at that @zou3519. I understand the problem, however, I would say that in many applications this can be useful in long-term, because it will allow us to propagate complex structured objects that aren't easily wrapped in a Tensor.\nI can accomplish the same using a custom collate_fn, however, in my case, I'm trying to write a user-facing API, which will then force users to instantiate DataLoader with this custom collate_fn or as an alternative, to use a custom DataLoader where I already have my default collate_fn defined, so neither options are elegant.\nThere is also another minor issue, the default_collate is using nowadays a global _use_shared_memory variable that would force you to add reference to it when replicating it outside of the module or setting manually, which is also not very elegant (this makes me think if default_collate shouldn't be a custom class object that is initialized with context).\nApart from that, the default_collate that we have today is arbitrarily selective: it allows you to have not only tensors but also strings. On the other side, I understand your concern about usability, however, if the user receives a batch that isn't a tensor, it would raise another exception later when feeding to the model, so this isn't a problem that will silently pass. My only concern is: you have more than one worker and you start passing complex objects that wouldn't allow shared memory, making copies very inefficient. This is indeed a usability issue.\nAs you mentioned, it would allow flexibility but it would hurt a little the usability, but in my opinion, the long-term gains would be worth the change. What do you think ? (Sorry for the long comment).", "body": "Thanks for taking a look at that @zou3519. I understand the problem, however, I would say that in many applications this can be useful in long-term, because it will allow us to propagate complex structured objects that aren't easily wrapped in a Tensor.\r\nI can accomplish the same using a custom `collate_fn`, however, in my case, I'm trying to write a user-facing API, which will then force users to instantiate DataLoader with this custom `collate_fn` or as an alternative, to use a custom `DataLoader` where I already have my default `collate_fn` defined, so neither options are elegant.\r\nThere is also another minor issue, the `default_collate` is using nowadays a global `_use_shared_memory` variable that would force you to add reference to it when replicating it outside of the module or setting manually, which is also not very elegant (this makes me think if `default_collate` shouldn't be a custom class object that is initialized with context).\r\n\r\nApart from that, the `default_collate` that we have today is arbitrarily selective: it allows you to have not only tensors but also strings. On the other side, I understand your concern about usability, however, if the user receives a batch that isn't a tensor, it would raise another exception later when feeding to the model, so this isn't a problem that will silently pass. My only concern is: you have more than one worker and you start passing complex objects that wouldn't allow shared memory, making copies very inefficient. This is indeed a usability issue. \r\n\r\nAs you mentioned, it would allow flexibility but it would hurt a little the usability, but in my opinion, the long-term gains would be worth the change. What do you think ? (Sorry for the long comment)."}