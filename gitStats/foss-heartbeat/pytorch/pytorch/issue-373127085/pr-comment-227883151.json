{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/227883151", "pull_request_review_id": 168025029, "id": 227883151, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNzg4MzE1MQ==", "diff_hunk": "@@ -59,195 +63,271 @@ namespace torch { namespace jit {\n //         been written. We place the variable-length index at the end and do\n //         not put any indicies into the header to fulfill this constraint.\n \n+// The serialized model, which contains all the metadata information,\n+// should be stored as the last record. Because the size of tensor data is\n+// usually stable. As long as the shape and type of the tensor do not change,\n+// the size of the data won't change. On the other sied, the size of the\n+// serialized model is likely to change, so we store it as the last record, and\n+// we don't need to move previous records when updating the model data.\n+\n namespace {\n-  struct RecordTags {\n-    enum {\n-      STORAGE = 1,\n-      FOOTER = 2,\n-    };\n-  };\n \n-  // Common constants\n-  static constexpr uint64_t kFileMagicNumber = 0x314843524f545950L; // PYTORCH1\n-  static constexpr uint64_t kFieldAlignment = 64L; // 64 byte alignment supports up to AVX512 for mmap\n+enum RecordTags {\n+  STORAGE = 1,\n+  FOOTER = 2,\n+};\n+\n+// Common constants\n+constexpr uint64_t kFileMagicNumber = 0x314843524f545950L; // PYTORCH1\n+constexpr uint64_t kFieldAlignment =\n+    64L; // 64 byte alignment supports up to AVX512 for mmap\n \n-  // Reader-specific constants\n-  static constexpr uint64_t kMaxSupportedFileFormatVersion = 0x1L;\n+// Reader-specific constants\n+constexpr uint64_t kMaxSupportedFileFormatVersion = 0x1L;\n \n-  // Writer-specific constants\n-  static constexpr uint64_t kFileFormatVersion = 0x1L;\n-  static constexpr uint8_t kPadValue = 0xEF;\n+// Writer-specific constants\n+constexpr uint64_t kFileFormatVersion = 0x1L;\n+constexpr char kPadValue = -17; // 0xEF", "path": "caffe2/serialize/inline_container.h", "position": 58, "original_position": 53, "commit_id": "8beeb484bf4d149767c4ea9d1d376a4c3d0b7c3e", "original_commit_id": "fe3d6f2fdbf89d9f8393150b3fff4673b94c8c57", "user": {"login": "houseroad", "id": 30275821, "node_id": "MDQ6VXNlcjMwMjc1ODIx", "avatar_url": "https://avatars0.githubusercontent.com/u/30275821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/houseroad", "html_url": "https://github.com/houseroad", "followers_url": "https://api.github.com/users/houseroad/followers", "following_url": "https://api.github.com/users/houseroad/following{/other_user}", "gists_url": "https://api.github.com/users/houseroad/gists{/gist_id}", "starred_url": "https://api.github.com/users/houseroad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/houseroad/subscriptions", "organizations_url": "https://api.github.com/users/houseroad/orgs", "repos_url": "https://api.github.com/users/houseroad/repos", "events_url": "https://api.github.com/users/houseroad/events{/privacy}", "received_events_url": "https://api.github.com/users/houseroad/received_events", "type": "User", "site_admin": false}, "body": "because ostream write char, and 0xEF is out of range, converting 0xEF to char is implementation based (kind of undefined behavior). When we split .h to .cc, we will solve this problem by using static array.", "created_at": "2018-10-24T17:19:25Z", "updated_at": "2018-11-23T15:53:30Z", "html_url": "https://github.com/pytorch/pytorch/pull/12993#discussion_r227883151", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/12993", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/227883151"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/12993#discussion_r227883151"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/12993"}}, "body_html": "<p>because ostream write char, and 0xEF is out of range, converting 0xEF to char is implementation based (kind of undefined behavior). When we split .h to .cc, we will solve this problem by using static array.</p>", "body_text": "because ostream write char, and 0xEF is out of range, converting 0xEF to char is implementation based (kind of undefined behavior). When we split .h to .cc, we will solve this problem by using static array.", "in_reply_to_id": 227644405}