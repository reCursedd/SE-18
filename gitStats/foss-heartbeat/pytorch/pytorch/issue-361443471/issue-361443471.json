{"url": "https://api.github.com/repos/pytorch/pytorch/issues/11813", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/11813/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/11813/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/11813/events", "html_url": "https://github.com/pytorch/pytorch/issues/11813", "id": 361443471, "node_id": "MDU6SXNzdWUzNjE0NDM0NzE=", "number": 11813, "title": "[feature request] Savable data loader/iterator", "user": {"login": "w-hc", "id": 17956191, "node_id": "MDQ6VXNlcjE3OTU2MTkx", "avatar_url": "https://avatars2.githubusercontent.com/u/17956191?v=4", "gravatar_id": "", "url": "https://api.github.com/users/w-hc", "html_url": "https://github.com/w-hc", "followers_url": "https://api.github.com/users/w-hc/followers", "following_url": "https://api.github.com/users/w-hc/following{/other_user}", "gists_url": "https://api.github.com/users/w-hc/gists{/gist_id}", "starred_url": "https://api.github.com/users/w-hc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/w-hc/subscriptions", "organizations_url": "https://api.github.com/users/w-hc/orgs", "repos_url": "https://api.github.com/users/w-hc/repos", "events_url": "https://api.github.com/users/w-hc/events{/privacy}", "received_events_url": "https://api.github.com/users/w-hc/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2018-09-18T19:13:33Z", "updated_at": "2018-09-25T04:39:02Z", "closed_at": "2018-09-19T19:27:02Z", "author_association": "NONE", "body_html": "<p>For large jobs with long epochs, it is necessary to checkpoint during the middle of an epoch, especially in a shared cluster setting with job time limit. It would be nice to be able to start at exactly where the training stopped and continue sampling for data afterwards.</p>\n<p>I can see that directly trying to checkpoint dataloader involves lots of problems that's tied to saving the underlying dataset, etc. It's not a maintainable solution.</p>\n<p>A compromise could be to save and retrieve the information as to which indices have already been sampled, and use those as part of the dataloder constructor, so that when the new iterator starts it avoids sampling the consumed data points.</p>\n<p>I have searched through the forums for a few Q&amp;As and it seems there is no clean solution.</p>", "body_text": "For large jobs with long epochs, it is necessary to checkpoint during the middle of an epoch, especially in a shared cluster setting with job time limit. It would be nice to be able to start at exactly where the training stopped and continue sampling for data afterwards.\nI can see that directly trying to checkpoint dataloader involves lots of problems that's tied to saving the underlying dataset, etc. It's not a maintainable solution.\nA compromise could be to save and retrieve the information as to which indices have already been sampled, and use those as part of the dataloder constructor, so that when the new iterator starts it avoids sampling the consumed data points.\nI have searched through the forums for a few Q&As and it seems there is no clean solution.", "body": "For large jobs with long epochs, it is necessary to checkpoint during the middle of an epoch, especially in a shared cluster setting with job time limit. It would be nice to be able to start at exactly where the training stopped and continue sampling for data afterwards. \r\n\r\nI can see that directly trying to checkpoint dataloader involves lots of problems that's tied to saving the underlying dataset, etc. It's not a maintainable solution. \r\n\r\nA compromise could be to save and retrieve the information as to which indices have already been sampled, and use those as part of the dataloder constructor, so that when the new iterator starts it avoids sampling the consumed data points. \r\n\r\nI have searched through the forums for a few Q&As and it seems there is no clean solution. \r\n"}