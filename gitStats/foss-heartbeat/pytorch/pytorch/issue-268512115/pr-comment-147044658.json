{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/147044658", "pull_request_review_id": 72077630, "id": 147044658, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE0NzA0NDY1OA==", "diff_hunk": "@@ -0,0 +1,122 @@\n+import os\n+import argparse\n+from collections import defaultdict\n+from tools.shared.module_loader import import_module\n+from itertools import count\n+from ..autograd.gen_variable_type import load_aten_declarations, CodeTemplate, write, \\\n+    FALLTHROUGH_RETURN_TYPES, FALLTHROUGH_FUNCTIONS, GENERATED_COMMENT\n+\n+template_path = os.path.join(os.path.dirname(__file__), 'templates')\n+\n+ATEN_DISPATCH_H = CodeTemplate.from_file(template_path + '/aten_dispatch.h')\n+ATEN_DISPATCH_CPP = CodeTemplate.from_file(template_path + '/aten_dispatch.cpp')\n+\n+ATTR_METHOD_MAP = {\n+    'int64_t': 'i',\n+    'IntList': 'is',\n+    'Scalar': 't',\n+    'bool': 'i',\n+    'double': 'f',\n+    'std::array<bool, 2>': 'is',\n+    'std::array<bool, 3>': 'is',\n+}\n+\n+TYPE_CASTS = {\n+    'std::array<bool, 2>': 'as_bool_array<2>',\n+    'std::array<bool, 3>': 'as_bool_array<3>',\n+    'Scalar': 'Scalar',\n+}\n+\n+ATTR_ASSIGNMENT = CodeTemplate(\"\"\"\\\n+${type} ${name} = ${type_cast}(node->${method}(stringToSymbol(\"${name}\")));\\\n+\"\"\")\n+\n+CALL_NAMESPACE = CodeTemplate(\"at::${name}(${args})\")\n+CALL_METHOD = CodeTemplate(\"vars[0].${name}(${args})\")\n+\n+CONSTRUCTOR = CodeTemplate(\"\"\"\\\n+{\"${descriptor}\", [](Node *node) {\n+  ${assignments}\n+  return TensorOp([=](const variable_list& vars) -> variable_list {\n+    return pack_list(${call});\n+  }, \"${name}\", ${num_inputs});\n+}},\n+\"\"\")\n+\n+\n+def is_jit_op(decl):\n+    return (not decl['api_name'].endswith('_') and\n+            not decl['name'].endswith('_out') and\n+            not decl['name'].endswith('_forward') and\n+            not any(arg['simple_type'] == 'Generator' for arg in decl['arguments']) and\n+            not any(arg['simple_type'] == 'SparseTensor' for arg in decl['arguments']) and\n+            not decl['return_type'] in FALLTHROUGH_RETURN_TYPES and\n+            not decl['name'] in FALLTHROUGH_FUNCTIONS)\n+\n+\n+def gen_jit_dispatch(declarations, out):\n+    aten_decls = load_aten_declarations(declarations)\n+    jit_decls = [d for d in aten_decls if is_jit_op(d)]\n+\n+    def is_tensor_arg(arg):\n+        return arg['simple_type'] in {'Tensor', 'TensorList'}\n+\n+    ops = {}\n+    for decl in jit_decls:\n+        arguments = decl['arguments']\n+        name = decl['name']\n+        scalar_args = [arg for arg in arguments if not is_tensor_arg(arg)]\n+\n+        # Descriptor is a unique identified for a particular overload of an op\n+        attr_names = sorted([arg['name'] for arg in scalar_args])\n+        num_inputs = len(arguments) - len(scalar_args)\n+        descriptor = '-'.join([decl['name'], str(num_inputs)] + attr_names)\n+\n+        # All scalar args need to be assigned, so they can be captured by a lambda\n+        assignments = [ATTR_ASSIGNMENT.substitute(type=arg['simple_type'],\n+                                                  type_cast=TYPE_CASTS.get(arg['simple_type'], ''),\n+                                                  name=arg['name'],\n+                                                  method=ATTR_METHOD_MAP[arg['simple_type']])\n+                       for arg in scalar_args]\n+\n+        # Generate the actuall ATen call. This gets a bit tricky because of\n+        # TensorList arguments, and functions that are only available as methods.\n+        if 'namespace' in decl['method_of']:\n+            if any(arg['simple_type'] == 'TensorList' for arg in arguments):\n+                assert sum(map(is_tensor_arg, arguments)) == 1\n+                args = ['as_tensor_list(vars)' if is_tensor_arg(arg) else arg['name']\n+                        for arg in arguments]\n+            else:\n+                tensor_id = iter(count(start=0))\n+                args = ['vars[{}]'.format(next(tensor_id)) if is_tensor_arg(arg) else arg['name']\n+                        for arg in arguments]\n+            call = CALL_NAMESPACE.substitute(locals())", "path": "tools/jit/gen_jit_dispatch.py", "position": null, "original_position": 93, "commit_id": "b1e0e1e5bf6e445960776c6eb92c4db0a0ad336a", "original_commit_id": "5966b0b1f81ca29d0722ae1450bda89ca70e5cb4", "user": {"login": "zdevito", "id": 370202, "node_id": "MDQ6VXNlcjM3MDIwMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/370202?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zdevito", "html_url": "https://github.com/zdevito", "followers_url": "https://api.github.com/users/zdevito/followers", "following_url": "https://api.github.com/users/zdevito/following{/other_user}", "gists_url": "https://api.github.com/users/zdevito/gists{/gist_id}", "starred_url": "https://api.github.com/users/zdevito/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zdevito/subscriptions", "organizations_url": "https://api.github.com/users/zdevito/orgs", "repos_url": "https://api.github.com/users/zdevito/repos", "events_url": "https://api.github.com/users/zdevito/events{/privacy}", "received_events_url": "https://api.github.com/users/zdevito/received_events", "type": "User", "site_admin": false}, "body": "nit `locals()`:  this makes it really hard to figure out which things matter in the template. Maybe just list them verbosely.", "created_at": "2017-10-26T04:44:00Z", "updated_at": "2018-11-23T15:35:42Z", "html_url": "https://github.com/pytorch/pytorch/pull/3291#discussion_r147044658", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/3291", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/147044658"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/3291#discussion_r147044658"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/3291"}}, "body_html": "<p>nit <code>locals()</code>:  this makes it really hard to figure out which things matter in the template. Maybe just list them verbosely.</p>", "body_text": "nit locals():  this makes it really hard to figure out which things matter in the template. Maybe just list them verbosely."}