{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/150411479", "pull_request_review_id": 75959992, "id": 150411479, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1MDQxMTQ3OQ==", "diff_hunk": "@@ -60,6 +61,67 @@ static inline bool operator==(const Use & a, const Use & b) {\n // Graph holds a list of parameters.\n struct Param;\n \n+// Scope is a node of a trie that represents the tree of nested scopes.\n+// Individual scopes are pushed and popped from Graph, which hold a\n+// pointer to the current scope. Each Node in Graph holds a pointer\n+// to the scope that was current when the node was created.\n+// The trie never needs to shrink, it only grows until it is disposed\n+// of when Graph is deallocated. Hence, pointers to scopes held by nodes\n+// will always be valid.\n+// Note that the ownership model as specified in the destructor implies \n+// that you cannot share common subtries between tries.\n+struct Scope {\n+private:\n+  Scope* parent_;\n+  Symbol name_;\n+  std::unordered_set<const Scope*> children_;", "path": "torch/csrc/jit/ir.h", "position": null, "original_position": 25, "commit_id": "1ef21e12c8ecdbfde2a5ac10e2ab8f5b4c5cc7f7", "original_commit_id": "c2696ac36766c188609deacc6358c3422a393179", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "body": "It seems to me that using a `unique_ptr` for the root, and `Scope*` for current scope, while having `unique_ptr`s in the scope trie for children will be safe - current scope is guaranteed to stay alive, because it is present in the subtree rooted in `root_scope_`, so there exists a chain of `unique_ptr`s leading to that `Scope`. I think it's exactly the same ownership model as proposed in this PR.\r\n\r\nCalling `.get()` is safe is you can ensure that the pointer you received will be alive as long as you'll be using the result, which is the case here.", "created_at": "2017-11-12T14:01:43Z", "updated_at": "2018-11-23T15:36:25Z", "html_url": "https://github.com/pytorch/pytorch/pull/3016#discussion_r150411479", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/3016", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/150411479"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/3016#discussion_r150411479"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/3016"}}, "body_html": "<p>It seems to me that using a <code>unique_ptr</code> for the root, and <code>Scope*</code> for current scope, while having <code>unique_ptr</code>s in the scope trie for children will be safe - current scope is guaranteed to stay alive, because it is present in the subtree rooted in <code>root_scope_</code>, so there exists a chain of <code>unique_ptr</code>s leading to that <code>Scope</code>. I think it's exactly the same ownership model as proposed in this PR.</p>\n<p>Calling <code>.get()</code> is safe is you can ensure that the pointer you received will be alive as long as you'll be using the result, which is the case here.</p>", "body_text": "It seems to me that using a unique_ptr for the root, and Scope* for current scope, while having unique_ptrs in the scope trie for children will be safe - current scope is guaranteed to stay alive, because it is present in the subtree rooted in root_scope_, so there exists a chain of unique_ptrs leading to that Scope. I think it's exactly the same ownership model as proposed in this PR.\nCalling .get() is safe is you can ensure that the pointer you received will be alive as long as you'll be using the result, which is the case here.", "in_reply_to_id": 150395330}