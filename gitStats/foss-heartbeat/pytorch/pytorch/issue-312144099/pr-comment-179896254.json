{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/179896254", "pull_request_review_id": 110233234, "id": 179896254, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE3OTg5NjI1NA==", "diff_hunk": "@@ -0,0 +1,416 @@\n+#include \"caffe2/opt/backend_cutting.h\"\n+#include \"caffe2/core/logging.h\"\n+#include \"nomnigraph/Converters/Caffe2.h\"\n+#include \"nomnigraph/Converters/Dot.h\"\n+#include \"nomnigraph/Representations/NeuralNet.h\"\n+\n+#include <algorithm>\n+#include <fstream>\n+#include <queue>\n+\n+namespace caffe2 {\n+namespace opt {\n+\n+namespace {\n+\n+using NodeRef = nom::repr::NNGraph::NodeRef;\n+using EdgeRef = nom::repr::NNGraph::EdgeRef;\n+\n+class GroupAnnotation {\n+ public:\n+  GroupAnnotation(int i, int g = -1) : group(g), in_degree(i) {}\n+  int group;\n+  int in_degree;\n+  bool needs_transform{true};\n+};\n+\n+struct VisitorContext {\n+  VisitorContext(std::function<bool(const caffe2::OperatorDef&)> func)\n+      : predicate(func) {}\n+  std::unordered_map<NodeRef, GroupAnnotation> infos;\n+  std::unordered_set<NodeRef> frontier;\n+  std::vector<NodeRef> current_group;\n+  std::function<bool(const caffe2::OperatorDef&)> predicate;\n+\n+  int group{0};\n+  bool find_supported{true};\n+};\n+\n+std::string ShowNode(NodeRef node) {\n+  auto* node_data = node->data().get();\n+  if (isa<nom::repr::NeuralNetData>(node_data)) {\n+    const auto* nn_tensor = dyn_cast<const nom::repr::NeuralNetData>(node_data);\n+    return MakeString(\"Tensor: \", nn_tensor->getName());\n+  } else if (isa<nom::repr::NeuralNetOperator>(node_data)) {\n+    const auto* nn_op = dyn_cast<const nom::repr::NeuralNetOperator>(node_data);\n+    const auto* op_def = reinterpret_cast<const caffe2::OperatorDef*>(\n+        nn_op->getAnnotation()->getSaved());\n+    CAFFE_ENFORCE(op_def);\n+    return MakeString(\"Op: \", op_def->type());\n+  } else {\n+    CAFFE_THROW(\"Known node\");\n+  }\n+}\n+\n+void DumpGraph(nom::repr::NNGraph* g) {\n+  auto nnprinter = [](typename nom::repr::NNGraph::NodeRef node) {\n+    std::map<std::string, std::string> labelMap;\n+    assert(node->data() && \"Node doesn't have data, can't render it\");\n+    if (isa<nom::repr::NeuralNetOperator>(node->data())) {\n+      auto* op = dyn_cast<nom::repr::NeuralNetOperator>(node->data().get());\n+      labelMap[\"label\"] =\n+          op->getName() + \" (\" + std::to_string((unsigned long long)node) + \")\";\n+      auto* annotation = op->getAnnotation();\n+      if (annotation && isa<nom::repr::DeviceAnnotation>(annotation)) {\n+        auto device_annotation =\n+            dyn_cast<nom::repr::DeviceAnnotation>(annotation);\n+        labelMap[\"label\"] += \"\\\\n[\" + device_annotation->getDevice() + \"]\";\n+        auto hash = std::hash<std::string>{}(device_annotation->getDevice());\n+        std::stringstream hex_stream;\n+        hex_stream << std::hex << hash;\n+        labelMap[\"color\"] = \"#\" + hex_stream.str().substr(0, 6);\n+        labelMap[\"fontcolor\"] = labelMap[\"color\"];\n+      }\n+      labelMap[\"shape\"] = \"box\";\n+    } else if (isa<nom::repr::Data>(node->data())) {\n+      auto tensor = dyn_cast<nom::repr::NeuralNetData>(node->data().get());\n+      labelMap[\"label\"] = tensor->getName();\n+      labelMap[\"label\"] += \"_\" + std::to_string(tensor->getVersion()) + \" \" +\n+          std::to_string((unsigned long long)node);\n+    }\n+    return labelMap;\n+  };\n+\n+  std::ofstream out(\"dump.dot\");\n+  out << nom::converters::convertToDotString(g, nnprinter);\n+  out.close();\n+}\n+\n+// Explore the graph in topological order until we hit stopping nodes. This is", "path": "caffe2/opt/backend_cutting.cc", "position": 89, "original_position": 89, "commit_id": "1ee73c81942d0c6028cb697cbce6d1bc59ddf91b", "original_commit_id": "530f829b767352cd263d16d8bd7850e1bea61953", "user": {"login": "bwasti", "id": 4842908, "node_id": "MDQ6VXNlcjQ4NDI5MDg=", "avatar_url": "https://avatars2.githubusercontent.com/u/4842908?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bwasti", "html_url": "https://github.com/bwasti", "followers_url": "https://api.github.com/users/bwasti/followers", "following_url": "https://api.github.com/users/bwasti/following{/other_user}", "gists_url": "https://api.github.com/users/bwasti/gists{/gist_id}", "starred_url": "https://api.github.com/users/bwasti/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bwasti/subscriptions", "organizations_url": "https://api.github.com/users/bwasti/orgs", "repos_url": "https://api.github.com/users/bwasti/repos", "events_url": "https://api.github.com/users/bwasti/events{/privacy}", "received_events_url": "https://api.github.com/users/bwasti/received_events", "type": "User", "site_admin": false}, "body": "might be nice to eventually add this to `Graph/Algorithms.h` in a slightly more generic fashion", "created_at": "2018-04-06T23:21:55Z", "updated_at": "2018-11-23T15:41:58Z", "html_url": "https://github.com/pytorch/pytorch/pull/6368#discussion_r179896254", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/6368", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/179896254"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/6368#discussion_r179896254"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/6368"}}, "body_html": "<p>might be nice to eventually add this to <code>Graph/Algorithms.h</code> in a slightly more generic fashion</p>", "body_text": "might be nice to eventually add this to Graph/Algorithms.h in a slightly more generic fashion"}