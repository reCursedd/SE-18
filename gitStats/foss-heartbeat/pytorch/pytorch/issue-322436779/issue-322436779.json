{"url": "https://api.github.com/repos/pytorch/pytorch/issues/7508", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/7508/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/7508/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/7508/events", "html_url": "https://github.com/pytorch/pytorch/pull/7508", "id": 322436779, "node_id": "MDExOlB1bGxSZXF1ZXN0MTg3NTcxNTY4", "number": 7508, "title": "[C++ API] Remove virtual forward and implement Sequential based on Any(Module)", "user": {"login": "goldsborough", "id": 6429851, "node_id": "MDQ6VXNlcjY0Mjk4NTE=", "avatar_url": "https://avatars3.githubusercontent.com/u/6429851?v=4", "gravatar_id": "", "url": "https://api.github.com/users/goldsborough", "html_url": "https://github.com/goldsborough", "followers_url": "https://api.github.com/users/goldsborough/followers", "following_url": "https://api.github.com/users/goldsborough/following{/other_user}", "gists_url": "https://api.github.com/users/goldsborough/gists{/gist_id}", "starred_url": "https://api.github.com/users/goldsborough/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/goldsborough/subscriptions", "organizations_url": "https://api.github.com/users/goldsborough/orgs", "repos_url": "https://api.github.com/users/goldsborough/repos", "events_url": "https://api.github.com/users/goldsborough/events{/privacy}", "received_events_url": "https://api.github.com/users/goldsborough/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2018-05-11T21:14:55Z", "updated_at": "2018-11-23T15:44:39Z", "closed_at": "2018-05-24T19:46:52Z", "author_association": "CONTRIBUTOR", "pull_request": {"url": "https://api.github.com/repos/pytorch/pytorch/pulls/7508", "html_url": "https://github.com/pytorch/pytorch/pull/7508", "diff_url": "https://github.com/pytorch/pytorch/pull/7508.diff", "patch_url": "https://github.com/pytorch/pytorch/pull/7508.patch"}, "body_html": "<p>This PR removes the virtual <code>forward()</code> method from the base module class, thus freeing submodules from any constraints w.r.t. the signature of their <code>forward()</code> method. This will enable the majority of modules to give their <code>forward()</code> a signature that best matches their module.</p>\n<p>Of course, a virtual <code>forward()</code> has its merits: one can call a module's <code>forward()</code> when one only has a pointer to a <code>Module</code> (the base class). In our API, this is useful in one and only one case: <code>Sequential</code>. To work around the fact that we have no <code>forward()</code> to call on a <code>Module*</code>, we employ type erasure techniques borrowed from <code>std::any</code>. More precisely:</p>\n<ol>\n<li>I've created an <code>Any</code> abstraction that models <code>std::any</code> (C++17) and allows type erasure of a single plain value.</li>\n<li>I've then created an <code>AnyModule</code> class, that:\n<ol>\n<li>Uses the same type erasure technique to erase the concrete type of a module,</li>\n<li>Erases but stores the parameter types of the concrete module's <code>forward()</code>, and casts <code>Any</code>s passed at runtime to these stored types.</li>\n</ol>\n</li>\n</ol>\n<p>This leads to the following API:</p>\n<pre><code>Sequential model(Linear(2, 3), Linear(3, 4), Linear(4, 5));\nmodel.forward&lt;Variable&gt;(variable);\n</code></pre>\n<p>Here, <code>forward</code> accepts any arguments and forwards them to the first module. The types are checked at runtime. Because the return type of the last module passed to <code>Sequential</code> is also erased, <code>forward</code> is templatized over the return type  of the last module. This is somewhat unfortunate, but is the only intrusion to the user API besides the dynamic type checking. It may be a good idea to let the return type default to <code>Variable</code>, but I fear lots of users will run into exceptions when they don't know this and return something else instead, so maybe being explicit is more helpful.</p>\n<p>I've written lots of tests for <code>Any</code>, <code>AnyModule</code> and <code>Sequential</code>, that also give you an idea of what the API looks like. Note that:</p>\n<ol>\n<li><code>Sequential</code> and <code>AnyModule</code> are part of the public API,</li>\n<li><code>Any</code> would ideally not be public, but has to be because it's returned by <code>Sequential</code>. I limit this fact by making <code>Any</code>'s constructor private and making construction possible only via a friend function in the <code>detail</code> namespace, which should hopefully deter users from using this for their own code.</li>\n</ol>\n<p>I have also removed all existing containers from autogradpp.</p>\n<p>Note: even though there is a shit ton of template programming going on, I believe the final <code>Sequential</code> container hides most of this complexity. Please suggest where more <code>static_assert</code>s or other things that can prevent template error spew could be placed.</p>\n<p><strong>Bonus</strong>: if you have any suggestions on how to simplify the code, especially the templaty parts, please suggest away!</p>\n<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=4583066\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/apaszke\">@apaszke</a> <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=370202\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/zdevito\">@zdevito</a> <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=3605224\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/ebetica\">@ebetica</a> <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=88510\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/jgehring\">@jgehring</a><br>\n<a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=2373925\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/smessmer\">@smessmer</a> please take a look at the template metaprogramming parts.</p>\n<h3>Future PRs</h3>\n<ol>\n<li>Change the core modules to have more sensible <code>forward()</code>s instead of just <code>variable_list</code></li>\n<li>Right now, all except the first module in the <code>Sequential</code> have to take a single argument. It would be nice if we could implement something so that when you return an <code>std::tuple</code> or some other type, we can automatically destructure it and thus allow multiple arguments in modules other than the first. Note that you can already take a <code>std::tuple</code> as the first argument, you'll just have to destructure it yourself.</li>\n</ol>", "body_text": "This PR removes the virtual forward() method from the base module class, thus freeing submodules from any constraints w.r.t. the signature of their forward() method. This will enable the majority of modules to give their forward() a signature that best matches their module.\nOf course, a virtual forward() has its merits: one can call a module's forward() when one only has a pointer to a Module (the base class). In our API, this is useful in one and only one case: Sequential. To work around the fact that we have no forward() to call on a Module*, we employ type erasure techniques borrowed from std::any. More precisely:\n\nI've created an Any abstraction that models std::any (C++17) and allows type erasure of a single plain value.\nI've then created an AnyModule class, that:\n\nUses the same type erasure technique to erase the concrete type of a module,\nErases but stores the parameter types of the concrete module's forward(), and casts Anys passed at runtime to these stored types.\n\n\n\nThis leads to the following API:\nSequential model(Linear(2, 3), Linear(3, 4), Linear(4, 5));\nmodel.forward<Variable>(variable);\n\nHere, forward accepts any arguments and forwards them to the first module. The types are checked at runtime. Because the return type of the last module passed to Sequential is also erased, forward is templatized over the return type  of the last module. This is somewhat unfortunate, but is the only intrusion to the user API besides the dynamic type checking. It may be a good idea to let the return type default to Variable, but I fear lots of users will run into exceptions when they don't know this and return something else instead, so maybe being explicit is more helpful.\nI've written lots of tests for Any, AnyModule and Sequential, that also give you an idea of what the API looks like. Note that:\n\nSequential and AnyModule are part of the public API,\nAny would ideally not be public, but has to be because it's returned by Sequential. I limit this fact by making Any's constructor private and making construction possible only via a friend function in the detail namespace, which should hopefully deter users from using this for their own code.\n\nI have also removed all existing containers from autogradpp.\nNote: even though there is a shit ton of template programming going on, I believe the final Sequential container hides most of this complexity. Please suggest where more static_asserts or other things that can prevent template error spew could be placed.\nBonus: if you have any suggestions on how to simplify the code, especially the templaty parts, please suggest away!\n@apaszke @zdevito @ebetica @jgehring\n@smessmer please take a look at the template metaprogramming parts.\nFuture PRs\n\nChange the core modules to have more sensible forward()s instead of just variable_list\nRight now, all except the first module in the Sequential have to take a single argument. It would be nice if we could implement something so that when you return an std::tuple or some other type, we can automatically destructure it and thus allow multiple arguments in modules other than the first. Note that you can already take a std::tuple as the first argument, you'll just have to destructure it yourself.", "body": "This PR removes the virtual `forward()` method from the base module class, thus freeing submodules from any constraints w.r.t. the signature of their `forward()` method. This will enable the majority of modules to give their `forward()` a signature that best matches their module.\r\n\r\nOf course, a virtual `forward()` has its merits: one can call a module's `forward()` when one only has a pointer to a `Module` (the base class). In our API, this is useful in one and only one case: `Sequential`. To work around the fact that we have no `forward()` to call on a `Module*`, we employ type erasure techniques borrowed from `std::any`. More precisely:\r\n\r\n1. I've created an `Any` abstraction that models `std::any` (C++17) and allows type erasure of a single plain value.\r\n2. I've then created an `AnyModule` class, that:\r\n    1. Uses the same type erasure technique to erase the concrete type of a module,\r\n    2. Erases but stores the parameter types of the concrete module's `forward()`, and casts `Any`s passed at runtime to these stored types. \r\n\r\nThis leads to the following API:\r\n\r\n```\r\nSequential model(Linear(2, 3), Linear(3, 4), Linear(4, 5));\r\nmodel.forward<Variable>(variable);\r\n```\r\n\r\nHere, `forward` accepts any arguments and forwards them to the first module. The types are checked at runtime. Because the return type of the last module passed to `Sequential` is also erased, `forward` is templatized over the return type  of the last module. This is somewhat unfortunate, but is the only intrusion to the user API besides the dynamic type checking. It may be a good idea to let the return type default to `Variable`, but I fear lots of users will run into exceptions when they don't know this and return something else instead, so maybe being explicit is more helpful.\r\n\r\nI've written lots of tests for `Any`, `AnyModule` and `Sequential`, that also give you an idea of what the API looks like. Note that:\r\n\r\n1. `Sequential` and `AnyModule` are part of the public API,\r\n2. `Any` would ideally not be public, but has to be because it's returned by `Sequential`. I limit this fact by making `Any`'s constructor private and making construction possible only via a friend function in the `detail` namespace, which should hopefully deter users from using this for their own code.\r\n\r\nI have also removed all existing containers from autogradpp.\r\n\r\nNote: even though there is a shit ton of template programming going on, I believe the final `Sequential` container hides most of this complexity. Please suggest where more `static_assert`s or other things that can prevent template error spew could be placed.\r\n\r\n__Bonus__: if you have any suggestions on how to simplify the code, especially the templaty parts, please suggest away!\r\n\r\n@apaszke @zdevito @ebetica @jgehring \r\n@smessmer please take a look at the template metaprogramming parts.\r\n\r\n### Future PRs\r\n\r\n1. Change the core modules to have more sensible `forward()`s instead of just `variable_list`\r\n2. Right now, all except the first module in the `Sequential` have to take a single argument. It would be nice if we could implement something so that when you return an `std::tuple` or some other type, we can automatically destructure it and thus allow multiple arguments in modules other than the first. Note that you can already take a `std::tuple` as the first argument, you'll just have to destructure it yourself."}