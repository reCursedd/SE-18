{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/204907148", "pull_request_review_id": 140074721, "id": 204907148, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwNDkwNzE0OA==", "diff_hunk": "@@ -65,7 +65,7 @@ Tensor ${Type}::unsafeTensorFromTH(void * th_pointer, bool retain) const {\n std::unique_ptr<Storage> ${Type}::unsafeStorageFromTH(void * th_pointer, bool retain) const {\n   if (retain)\n     ${THStorage}_retain(${state,} (${THStorage}*) th_pointer);\n-  return std::unique_ptr<Storage>(new ${Storage}((${THStorage}*) th_pointer));\n+  return std::unique_ptr<Storage>((${THStorage}*) th_pointer);", "path": "aten/src/ATen/templates/TypeDerived.cpp", "position": null, "original_position": 5, "commit_id": "49a54a1620c5046ea3c1b3025214ca9c21385a37", "original_commit_id": "2c878e33da9fb1fa7d0fa2db174e015415658e02", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "body": "This looks wrong. The standard deleter for a `unique_ptr` will call `delete` on the enclosed object. So when `std::unique_ptr<Storage>` becomes dead it will delete it. But what this function used to do is return a `unique_ptr` to Storage, **which is owning only for a single decrement of the reference count**; i.e., when the unique pointer dies, we merely decrement the refcount, and free the storage only if it's dead.\r\n\r\nThis interface is bad and confusing, but to fix it you would have to first refactor the `storage()` interface to not use unique pointers anymore, and have some sort of wrapper class `Storage` to `StorageImpl` (the same way we have `Tensor` to `TensorImpl`). I would prefer not to have to do it in this PR, but I am not sure if there is a way to fix this without changing the interface of unsafeStorageFromTH\r\n\r\nHow many use sites of unsafeStorageFromTH are there?", "created_at": "2018-07-24T20:52:18Z", "updated_at": "2018-11-23T15:48:00Z", "html_url": "https://github.com/pytorch/pytorch/pull/9772#discussion_r204907148", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/9772", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/204907148"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/9772#discussion_r204907148"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/9772"}}, "body_html": "<p>This looks wrong. The standard deleter for a <code>unique_ptr</code> will call <code>delete</code> on the enclosed object. So when <code>std::unique_ptr&lt;Storage&gt;</code> becomes dead it will delete it. But what this function used to do is return a <code>unique_ptr</code> to Storage, <strong>which is owning only for a single decrement of the reference count</strong>; i.e., when the unique pointer dies, we merely decrement the refcount, and free the storage only if it's dead.</p>\n<p>This interface is bad and confusing, but to fix it you would have to first refactor the <code>storage()</code> interface to not use unique pointers anymore, and have some sort of wrapper class <code>Storage</code> to <code>StorageImpl</code> (the same way we have <code>Tensor</code> to <code>TensorImpl</code>). I would prefer not to have to do it in this PR, but I am not sure if there is a way to fix this without changing the interface of unsafeStorageFromTH</p>\n<p>How many use sites of unsafeStorageFromTH are there?</p>", "body_text": "This looks wrong. The standard deleter for a unique_ptr will call delete on the enclosed object. So when std::unique_ptr<Storage> becomes dead it will delete it. But what this function used to do is return a unique_ptr to Storage, which is owning only for a single decrement of the reference count; i.e., when the unique pointer dies, we merely decrement the refcount, and free the storage only if it's dead.\nThis interface is bad and confusing, but to fix it you would have to first refactor the storage() interface to not use unique pointers anymore, and have some sort of wrapper class Storage to StorageImpl (the same way we have Tensor to TensorImpl). I would prefer not to have to do it in this PR, but I am not sure if there is a way to fix this without changing the interface of unsafeStorageFromTH\nHow many use sites of unsafeStorageFromTH are there?"}