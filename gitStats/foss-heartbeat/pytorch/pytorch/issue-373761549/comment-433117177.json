{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/433117177", "html_url": "https://github.com/pytorch/pytorch/pull/13108#issuecomment-433117177", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/13108", "id": 433117177, "node_id": "MDEyOklzc3VlQ29tbWVudDQzMzExNzE3Nw==", "user": {"login": "mruberry", "id": 38511765, "node_id": "MDQ6VXNlcjM4NTExNzY1", "avatar_url": "https://avatars3.githubusercontent.com/u/38511765?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mruberry", "html_url": "https://github.com/mruberry", "followers_url": "https://api.github.com/users/mruberry/followers", "following_url": "https://api.github.com/users/mruberry/following{/other_user}", "gists_url": "https://api.github.com/users/mruberry/gists{/gist_id}", "starred_url": "https://api.github.com/users/mruberry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mruberry/subscriptions", "organizations_url": "https://api.github.com/users/mruberry/orgs", "repos_url": "https://api.github.com/users/mruberry/repos", "events_url": "https://api.github.com/users/mruberry/events{/privacy}", "received_events_url": "https://api.github.com/users/mruberry/received_events", "type": "User", "site_admin": false}, "created_at": "2018-10-25T16:25:12Z", "updated_at": "2018-10-25T16:25:12Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Thanks Adam, this is an incredibly helpful start to the review. I'll add a description of the code organization shortly (running around atm).</p>\n<p>Good question about future direction, too. You're right that there was a missed opportunity to do this when refactoring the code for the split, which is unfortunate. But I think this hierarchical approach from DI -&gt; DS code let's us have our cake and eat it, too, on fuser independence and logic sharing. The previous PR where I added supported for NAN and INF to the fusers is a good simple example, I think. Often the logic is common and the implementation is different. For cases where the logic is different, like if we were to consider putting CUDA graphs into the CUDA fuser, then we still have the flexibility to defer to the DS code after the DI code has run.</p>\n<p>In the short term the plan is definitely to work on common logical features, like extended fusion logic and scalar support, that both the CPU and CUDA fusers will participate in. So the new model is common logic possibly extended by device-specific logic with device-specific implementation.</p>", "body_text": "Thanks Adam, this is an incredibly helpful start to the review. I'll add a description of the code organization shortly (running around atm).\nGood question about future direction, too. You're right that there was a missed opportunity to do this when refactoring the code for the split, which is unfortunate. But I think this hierarchical approach from DI -> DS code let's us have our cake and eat it, too, on fuser independence and logic sharing. The previous PR where I added supported for NAN and INF to the fusers is a good simple example, I think. Often the logic is common and the implementation is different. For cases where the logic is different, like if we were to consider putting CUDA graphs into the CUDA fuser, then we still have the flexibility to defer to the DS code after the DI code has run.\nIn the short term the plan is definitely to work on common logical features, like extended fusion logic and scalar support, that both the CPU and CUDA fusers will participate in. So the new model is common logic possibly extended by device-specific logic with device-specific implementation.", "body": "Thanks Adam, this is an incredibly helpful start to the review. I'll add a description of the code organization shortly (running around atm). \r\n\r\nGood question about future direction, too. You're right that there was a missed opportunity to do this when refactoring the code for the split, which is unfortunate. But I think this hierarchical approach from DI -> DS code let's us have our cake and eat it, too, on fuser independence and logic sharing. The previous PR where I added supported for NAN and INF to the fusers is a good simple example, I think. Often the logic is common and the implementation is different. For cases where the logic is different, like if we were to consider putting CUDA graphs into the CUDA fuser, then we still have the flexibility to defer to the DS code after the DI code has run. \r\n\r\nIn the short term the plan is definitely to work on common logical features, like extended fusion logic and scalar support, that both the CPU and CUDA fusers will participate in. So the new model is common logic possibly extended by device-specific logic with device-specific implementation. \r\n\r\n"}