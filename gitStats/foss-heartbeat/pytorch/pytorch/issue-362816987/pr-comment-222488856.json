{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/222488856", "pull_request_review_id": 161388613, "id": 222488856, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMjQ4ODg1Ng==", "diff_hunk": "@@ -316,6 +316,17 @@ std::shared_ptr<SugaredValue> toSugaredValue(\n   } else if (py::isinstance<py::module>(obj)) {\n     return std::make_shared<PythonModuleValue>(obj);\n   }\n+\n+  bool is_weak = py::hasattr(obj, \"_jit_is_weak_script\") &&\n+      py::cast<bool>(py::getattr(obj, \"_jit_is_weak_script\"));\n+\n+  if (is_weak) {\n+    auto compiled_fn =\n+        py::module::import(\"torch.jit\").attr(\"script\")(obj, true, 0, true);", "path": "torch/csrc/jit/script/init.cpp", "position": null, "original_position": 10, "commit_id": "d356b035e17caebb2c5677087164bc339641fa7e", "original_commit_id": "9bf1d156d51f3d71e43654bb2441b26727afe7f3", "user": {"login": "zdevito", "id": 370202, "node_id": "MDQ6VXNlcjM3MDIwMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/370202?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zdevito", "html_url": "https://github.com/zdevito", "followers_url": "https://api.github.com/users/zdevito/followers", "following_url": "https://api.github.com/users/zdevito/following{/other_user}", "gists_url": "https://api.github.com/users/zdevito/gists{/gist_id}", "starred_url": "https://api.github.com/users/zdevito/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zdevito/subscriptions", "organizations_url": "https://api.github.com/users/zdevito/orgs", "repos_url": "https://api.github.com/users/zdevito/repos", "events_url": "https://api.github.com/users/zdevito/events{/privacy}", "received_events_url": "https://api.github.com/users/zdevito/received_events", "type": "User", "site_admin": false}, "body": "Yeah, I told David to go with the lazy design so that we feel ok using it across our standard library without incurring startup overhead. It does have weird variable capture problems, but weak_script will at least start out as an internal annotation, and we can avoid variable capture problems. When we make it a public API, we can figure out how to make sure it works fast enough to use it everywhere.", "created_at": "2018-10-03T22:33:04Z", "updated_at": "2018-11-23T15:52:17Z", "html_url": "https://github.com/pytorch/pytorch/pull/11963#discussion_r222488856", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/11963", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/222488856"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/11963#discussion_r222488856"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/11963"}}, "body_html": "<p>Yeah, I told David to go with the lazy design so that we feel ok using it across our standard library without incurring startup overhead. It does have weird variable capture problems, but weak_script will at least start out as an internal annotation, and we can avoid variable capture problems. When we make it a public API, we can figure out how to make sure it works fast enough to use it everywhere.</p>", "body_text": "Yeah, I told David to go with the lazy design so that we feel ok using it across our standard library without incurring startup overhead. It does have weird variable capture problems, but weak_script will at least start out as an internal annotation, and we can avoid variable capture problems. When we make it a public API, we can figure out how to make sure it works fast enough to use it everywhere.", "in_reply_to_id": 221041486}