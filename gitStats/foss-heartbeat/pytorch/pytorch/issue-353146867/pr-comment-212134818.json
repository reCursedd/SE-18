{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/212134818", "pull_request_review_id": 148703118, "id": 212134818, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMjEzNDgxOA==", "diff_hunk": "@@ -446,6 +446,15 @@ def leaky_relu(g, input, negative_slope, inplace=False):\n     return g.op(\"LeakyRelu\", input, alpha_f=_scalar(negative_slope))\n \n \n+def linear(g, input, weight, bias=None):\n+    if input.dim() == 2 and bias is not None:", "path": "torch/onnx/symbolic.py", "position": null, "original_position": 5, "commit_id": "5602f7378a6ab416bf7e9e8726d15da779dde9a3", "original_commit_id": "214cbd18f3444e2bca1b381f04f88e0036a6762b", "user": {"login": "goldsborough", "id": 6429851, "node_id": "MDQ6VXNlcjY0Mjk4NTE=", "avatar_url": "https://avatars3.githubusercontent.com/u/6429851?v=4", "gravatar_id": "", "url": "https://api.github.com/users/goldsborough", "html_url": "https://github.com/goldsborough", "followers_url": "https://api.github.com/users/goldsborough/followers", "following_url": "https://api.github.com/users/goldsborough/following{/other_user}", "gists_url": "https://api.github.com/users/goldsborough/gists{/gist_id}", "starred_url": "https://api.github.com/users/goldsborough/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/goldsborough/subscriptions", "organizations_url": "https://api.github.com/users/goldsborough/orgs", "repos_url": "https://api.github.com/users/goldsborough/repos", "events_url": "https://api.github.com/users/goldsborough/events{/privacy}", "received_events_url": "https://api.github.com/users/goldsborough/received_events", "type": "User", "site_admin": false}, "body": "1. I assume `@parse_args('v', 'v', 'v')` will do this?\r\n2. > you'll need to emit a generic, rank-invariant version\r\n    \r\n    That's the second part of this function right?\r\n3. > Btw I'm not sure if bias will be none here, can you try it out passing tensor() as the third argument to aten::linear and tracing it?\r\n    \r\n    Can you be more explicit in what you want me try here? Do you mean Python or C++? Do you mean `at::linear`?\r\n\r\nI have no idea about this symbolic stuff, so please bear with me", "created_at": "2018-08-22T22:50:17Z", "updated_at": "2018-11-23T15:49:48Z", "html_url": "https://github.com/pytorch/pytorch/pull/10799#discussion_r212134818", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/10799", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/212134818"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/10799#discussion_r212134818"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/10799"}}, "body_html": "<ol>\n<li>\n<p>I assume <code>@parse_args('v', 'v', 'v')</code> will do this?</p>\n</li>\n<li>\n<blockquote>\n<p>you'll need to emit a generic, rank-invariant version</p>\n</blockquote>\n<p>That's the second part of this function right?</p>\n</li>\n<li>\n<blockquote>\n<p>Btw I'm not sure if bias will be none here, can you try it out passing tensor() as the third argument to aten::linear and tracing it?</p>\n</blockquote>\n<p>Can you be more explicit in what you want me try here? Do you mean Python or C++? Do you mean <code>at::linear</code>?</p>\n</li>\n</ol>\n<p>I have no idea about this symbolic stuff, so please bear with me</p>", "body_text": "I assume @parse_args('v', 'v', 'v') will do this?\n\n\n\nyou'll need to emit a generic, rank-invariant version\n\nThat's the second part of this function right?\n\n\n\nBtw I'm not sure if bias will be none here, can you try it out passing tensor() as the third argument to aten::linear and tracing it?\n\nCan you be more explicit in what you want me try here? Do you mean Python or C++? Do you mean at::linear?\n\n\nI have no idea about this symbolic stuff, so please bear with me", "in_reply_to_id": 212131052}