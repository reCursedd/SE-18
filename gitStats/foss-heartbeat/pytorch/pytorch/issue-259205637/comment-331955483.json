{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/331955483", "html_url": "https://github.com/pytorch/pytorch/pull/2803#issuecomment-331955483", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/2803", "id": 331955483, "node_id": "MDEyOklzc3VlQ29tbWVudDMzMTk1NTQ4Mw==", "user": {"login": "squidgetx", "id": 6618711, "node_id": "MDQ6VXNlcjY2MTg3MTE=", "avatar_url": "https://avatars2.githubusercontent.com/u/6618711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/squidgetx", "html_url": "https://github.com/squidgetx", "followers_url": "https://api.github.com/users/squidgetx/followers", "following_url": "https://api.github.com/users/squidgetx/following{/other_user}", "gists_url": "https://api.github.com/users/squidgetx/gists{/gist_id}", "starred_url": "https://api.github.com/users/squidgetx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/squidgetx/subscriptions", "organizations_url": "https://api.github.com/users/squidgetx/orgs", "repos_url": "https://api.github.com/users/squidgetx/repos", "events_url": "https://api.github.com/users/squidgetx/events{/privacy}", "received_events_url": "https://api.github.com/users/squidgetx/received_events", "type": "User", "site_admin": false}, "created_at": "2017-09-25T17:34:48Z", "updated_at": "2017-09-25T17:44:40Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Correctness tested by comparing to CPU embedding module using dimensions of [[22,7],[22,8],[22,9],[129,127],[129,129],[1001,255],[1001,256],[100000,511],[100000,513]] with random input vectors. Accuracy to the 1e-14/15 level using the following test script. It's a bit kludgily written (betraying my unfamiliarity with tensor ops/python but it gets the job done:</p>\n<pre><code>  1 import torch\n  2\n  3 dims = [[22,7],[22,8],[22,9],[129,127],[129,129],[1001,255],[1001,256],[100000,511],[100000,513]]\n  4\n  5 for dim in dims:\n  6     n = dim[0]\n  7     m = dim[1]\n  8     inputa = torch.autograd.Variable((torch.rand(int(m/2)) *m).long())\n  9     torch.manual_seed(1)\n 10     embedding = torch.nn.Embedding(n, m, max_norm=1.0).cuda()\n 11     output = embedding(inputa.cuda())\n 12\n 13     torch.manual_seed(1)\n 14     cpuembedding = torch.nn.Embedding(n, m, max_norm=1.0)\n 15     cpuoutput = cpuembedding(inputa)\n 16     test = 1e-15\n 17     threshold = 1e-7\n 18     while test &lt; threshold:\n 19         result = (cpuoutput.data.cuda() - output.data).le(test).equal(output.data.fill_(1).byte())\n 20         if result:\n 21             print(\"{0}x{1}: precision {2}\".format(n,m,test))\n 22             break\n 23         else:\n 24             test *= 10\n 25     if (test &gt; threshold):\n 26         print(\"{0}x{1}: test failed\".format(n,m,test))\n</code></pre>", "body_text": "Correctness tested by comparing to CPU embedding module using dimensions of [[22,7],[22,8],[22,9],[129,127],[129,129],[1001,255],[1001,256],[100000,511],[100000,513]] with random input vectors. Accuracy to the 1e-14/15 level using the following test script. It's a bit kludgily written (betraying my unfamiliarity with tensor ops/python but it gets the job done:\n  1 import torch\n  2\n  3 dims = [[22,7],[22,8],[22,9],[129,127],[129,129],[1001,255],[1001,256],[100000,511],[100000,513]]\n  4\n  5 for dim in dims:\n  6     n = dim[0]\n  7     m = dim[1]\n  8     inputa = torch.autograd.Variable((torch.rand(int(m/2)) *m).long())\n  9     torch.manual_seed(1)\n 10     embedding = torch.nn.Embedding(n, m, max_norm=1.0).cuda()\n 11     output = embedding(inputa.cuda())\n 12\n 13     torch.manual_seed(1)\n 14     cpuembedding = torch.nn.Embedding(n, m, max_norm=1.0)\n 15     cpuoutput = cpuembedding(inputa)\n 16     test = 1e-15\n 17     threshold = 1e-7\n 18     while test < threshold:\n 19         result = (cpuoutput.data.cuda() - output.data).le(test).equal(output.data.fill_(1).byte())\n 20         if result:\n 21             print(\"{0}x{1}: precision {2}\".format(n,m,test))\n 22             break\n 23         else:\n 24             test *= 10\n 25     if (test > threshold):\n 26         print(\"{0}x{1}: test failed\".format(n,m,test))", "body": "Correctness tested by comparing to CPU embedding module using dimensions of [[22,7],[22,8],[22,9],[129,127],[129,129],[1001,255],[1001,256],[100000,511],[100000,513]] with random input vectors. Accuracy to the 1e-14/15 level using the following test script. It's a bit kludgily written (betraying my unfamiliarity with tensor ops/python but it gets the job done: \r\n\r\n```\r\n  1 import torch\r\n  2\r\n  3 dims = [[22,7],[22,8],[22,9],[129,127],[129,129],[1001,255],[1001,256],[100000,511],[100000,513]]\r\n  4\r\n  5 for dim in dims:\r\n  6     n = dim[0]\r\n  7     m = dim[1]\r\n  8     inputa = torch.autograd.Variable((torch.rand(int(m/2)) *m).long())\r\n  9     torch.manual_seed(1)\r\n 10     embedding = torch.nn.Embedding(n, m, max_norm=1.0).cuda()\r\n 11     output = embedding(inputa.cuda())\r\n 12\r\n 13     torch.manual_seed(1)\r\n 14     cpuembedding = torch.nn.Embedding(n, m, max_norm=1.0)\r\n 15     cpuoutput = cpuembedding(inputa)\r\n 16     test = 1e-15\r\n 17     threshold = 1e-7\r\n 18     while test < threshold:\r\n 19         result = (cpuoutput.data.cuda() - output.data).le(test).equal(output.data.fill_(1).byte())\r\n 20         if result:\r\n 21             print(\"{0}x{1}: precision {2}\".format(n,m,test))\r\n 22             break\r\n 23         else:\r\n 24             test *= 10\r\n 25     if (test > threshold):\r\n 26         print(\"{0}x{1}: test failed\".format(n,m,test))"}