{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/429478395", "html_url": "https://github.com/pytorch/pytorch/pull/12502#issuecomment-429478395", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/12502", "id": 429478395, "node_id": "MDEyOklzc3VlQ29tbWVudDQyOTQ3ODM5NQ==", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "created_at": "2018-10-12T22:19:32Z", "updated_at": "2018-10-12T22:19:32Z", "author_association": "MEMBER", "body_html": "<p>So while your argument is very convincing, I still think there are some edge cases that might need extra care. The reason why views are special is exactly <em>because they are views</em>. This means that in-place modification made to them can have non-trivial globally visible effects. For example, consider this operation, and assume the <code>y.requires_grad is True</code> :</p>\n<div class=\"highlight highlight-source-python\"><pre>x[i] <span class=\"pl-k\">=</span> y</pre></div>\n<p>Now, if <code>x</code> is a base variable, then it doesn't matter too much that we'll set its requires grad to true, because all views based on it will generally get updated (unless they are created in a no-grad block, which you convinced me is ok).</p>\n<p>On the other hand, if <code>x</code> is a view onto a different tensor (let's call it <code>z</code>), which has been created outside of a no-grad block, then data of <code>y</code> will be present in <code>z</code> as well, and so usages of that variable should count towards its gradient as well! Your patch however will happily drop the aliasing information. This is exactly the situation I'm talking about:</p>\n<div class=\"highlight highlight-source-python\"><pre>z <span class=\"pl-k\">=</span> torch.ones(<span class=\"pl-c1\">...</span>)\n<span class=\"pl-k\">with</span> torch.no_grad():\n  x <span class=\"pl-k\">=</span> z[<span class=\"pl-c1\">0</span>]\nx[i] <span class=\"pl-k\">=</span> y</pre></div>\n<p>Note all use sites of the data of <code>z</code> (not its metadata) are outside of <code>no_grad</code> blocks.</p>", "body_text": "So while your argument is very convincing, I still think there are some edge cases that might need extra care. The reason why views are special is exactly because they are views. This means that in-place modification made to them can have non-trivial globally visible effects. For example, consider this operation, and assume the y.requires_grad is True :\nx[i] = y\nNow, if x is a base variable, then it doesn't matter too much that we'll set its requires grad to true, because all views based on it will generally get updated (unless they are created in a no-grad block, which you convinced me is ok).\nOn the other hand, if x is a view onto a different tensor (let's call it z), which has been created outside of a no-grad block, then data of y will be present in z as well, and so usages of that variable should count towards its gradient as well! Your patch however will happily drop the aliasing information. This is exactly the situation I'm talking about:\nz = torch.ones(...)\nwith torch.no_grad():\n  x = z[0]\nx[i] = y\nNote all use sites of the data of z (not its metadata) are outside of no_grad blocks.", "body": "So while your argument is very convincing, I still think there are some edge cases that might need extra care. The reason why views are special is exactly *because they are views*. This means that in-place modification made to them can have non-trivial globally visible effects. For example, consider this operation, and assume the `y.requires_grad is True` :\r\n```py\r\nx[i] = y\r\n```\r\n\r\nNow, if `x` is a base variable, then it doesn't matter too much that we'll set its requires grad to true, because all views based on it will generally get updated (unless they are created in a no-grad block, which you convinced me is ok).\r\n\r\nOn the other hand, if `x` is a view onto a different tensor (let's call it `z`), which has been created outside of a no-grad block, then data of `y` will be present in `z` as well, and so usages of that variable should count towards its gradient as well! Your patch however will happily drop the aliasing information. This is exactly the situation I'm talking about:\r\n```py\r\nz = torch.ones(...)\r\nwith torch.no_grad():\r\n  x = z[0]\r\nx[i] = y\r\n```\r\nNote all use sites of the data of `z` (not its metadata) are outside of `no_grad` blocks."}