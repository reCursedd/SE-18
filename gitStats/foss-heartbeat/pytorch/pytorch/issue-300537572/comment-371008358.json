{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/371008358", "html_url": "https://github.com/pytorch/pytorch/issues/5430#issuecomment-371008358", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/5430", "id": 371008358, "node_id": "MDEyOklzc3VlQ29tbWVudDM3MTAwODM1OA==", "user": {"login": "SsnL", "id": 5674597, "node_id": "MDQ6VXNlcjU2NzQ1OTc=", "avatar_url": "https://avatars2.githubusercontent.com/u/5674597?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SsnL", "html_url": "https://github.com/SsnL", "followers_url": "https://api.github.com/users/SsnL/followers", "following_url": "https://api.github.com/users/SsnL/following{/other_user}", "gists_url": "https://api.github.com/users/SsnL/gists{/gist_id}", "starred_url": "https://api.github.com/users/SsnL/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SsnL/subscriptions", "organizations_url": "https://api.github.com/users/SsnL/orgs", "repos_url": "https://api.github.com/users/SsnL/repos", "events_url": "https://api.github.com/users/SsnL/events{/privacy}", "received_events_url": "https://api.github.com/users/SsnL/received_events", "type": "User", "site_admin": false}, "created_at": "2018-03-07T03:12:57Z", "updated_at": "2018-03-07T03:14:41Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Okay, the problem is that</p>\n<ol>\n<li>worker processes are initialized at <code>super(CustomDataLoaderIter, self).__init__(loader)</code>, so are the bookkeeping data structure in c++ side.</li>\n<li>then you set <code>self.num_workers = 0</code>.</li>\n<li>in <code>__del__</code> (<a href=\"https://github.com/pytorch/pytorch/blob/master/torch/utils/data/dataloader.py#L339-L342\">https://github.com/pytorch/pytorch/blob/master/torch/utils/data/dataloader.py#L339-L342</a>), when it checks <code>self.num_workers != 0</code> before removing the bookkeeping c++ data structure, it fails the check and didn't clean up correctly.</li>\n</ol>\n<p>There are a couple of issues with your approach:</p>\n<ol>\n<li><code>DataLoaderIter</code> isn't meant to be subclassed.</li>\n<li>this doesn't give you the same current batch when called, but rather advances the iterator before returned the batch:</li>\n</ol>\n<pre><code>    def cur_batch(self):\n        return self.__next__()\n</code></pre>\n<ol start=\"3\">\n<li>you can achieve what you want by just applying the different crops/transformations to <code>input</code> in <code>for inputs, labels in eval_loader:</code> block.</li>\n</ol>", "body_text": "Okay, the problem is that\n\nworker processes are initialized at super(CustomDataLoaderIter, self).__init__(loader), so are the bookkeeping data structure in c++ side.\nthen you set self.num_workers = 0.\nin __del__ (https://github.com/pytorch/pytorch/blob/master/torch/utils/data/dataloader.py#L339-L342), when it checks self.num_workers != 0 before removing the bookkeeping c++ data structure, it fails the check and didn't clean up correctly.\n\nThere are a couple of issues with your approach:\n\nDataLoaderIter isn't meant to be subclassed.\nthis doesn't give you the same current batch when called, but rather advances the iterator before returned the batch:\n\n    def cur_batch(self):\n        return self.__next__()\n\n\nyou can achieve what you want by just applying the different crops/transformations to input in for inputs, labels in eval_loader: block.", "body": "Okay, the problem is that \r\n1. worker processes are initialized at `super(CustomDataLoaderIter, self).__init__(loader)`, so are the bookkeeping data structure in c++ side.\r\n2. then you set `self.num_workers = 0`.\r\n3. in `__del__` (https://github.com/pytorch/pytorch/blob/master/torch/utils/data/dataloader.py#L339-L342), when it checks `self.num_workers != 0` before removing the bookkeeping c++ data structure, it fails the check and didn't clean up correctly.\r\n\r\nThere are a couple of issues with your approach:\r\n1. `DataLoaderIter` isn't meant to be subclassed. \r\n2. this doesn't give you the same current batch when called, but rather advances the iterator before returned the batch:\r\n```\r\n    def cur_batch(self):\r\n        return self.__next__()\r\n```\r\n3. you can achieve what you want by just applying the different crops/transformations to `input` in `for inputs, labels in eval_loader:` block."}