{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/164621051", "pull_request_review_id": 92420886, "id": 164621051, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2NDYyMTA1MQ==", "diff_hunk": "@@ -68,7 +68,7 @@ _PS256_CONST_TYPE(min_norm_pos, int, 0x00800000);\n _PS256_CONST_TYPE(mant_mask, int, 0x7f800000);\n _PS256_CONST_TYPE(inv_mant_mask, int, ~0x7f800000);\n \n-_PS256_CONST_TYPE(sign_mask, int, 0x80000000);\n+_PS256_CONST_TYPE(sign_mask, int, (int)0x80000000);", "path": "aten/src/TH/vector/avx_mathfun.h", "position": 5, "original_position": 5, "commit_id": "4028540d217200a9ded3ea020ae8fc8cf40dde2f", "original_commit_id": "2b648a6cbd09f92f3002e0bf413955bdb250157e", "user": {"login": "colesbury", "id": 655866, "node_id": "MDQ6VXNlcjY1NTg2Ng==", "avatar_url": "https://avatars1.githubusercontent.com/u/655866?v=4", "gravatar_id": "", "url": "https://api.github.com/users/colesbury", "html_url": "https://github.com/colesbury", "followers_url": "https://api.github.com/users/colesbury/followers", "following_url": "https://api.github.com/users/colesbury/following{/other_user}", "gists_url": "https://api.github.com/users/colesbury/gists{/gist_id}", "starred_url": "https://api.github.com/users/colesbury/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/colesbury/subscriptions", "organizations_url": "https://api.github.com/users/colesbury/orgs", "repos_url": "https://api.github.com/users/colesbury/repos", "events_url": "https://api.github.com/users/colesbury/events{/privacy}", "received_events_url": "https://api.github.com/users/colesbury/received_events", "type": "User", "site_admin": false}, "body": "This is fine, but you can use `-0x80000000` if you prefer.\r\n\r\nThe narrowing conversion `(int)0x80000000` is implementation defined (not undefined), which means it's up to the compiler, but well defined and (ostensibly) documented. All the implementations we care about preserve the bit pattern here.\r\n\r\nI'm not sure `-0x80000000` is actually any more \"portable\". Either way, it depends on two's complement representation with the high order sign bit extracted via bitwise and. And, of course, the rest of the file depends on Intel's AVX intrinsics.", "created_at": "2018-01-30T01:50:35Z", "updated_at": "2018-11-23T15:38:43Z", "html_url": "https://github.com/pytorch/pytorch/pull/4041#discussion_r164621051", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/4041", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/164621051"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/4041#discussion_r164621051"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/4041"}}, "body_html": "<p>This is fine, but you can use <code>-0x80000000</code> if you prefer.</p>\n<p>The narrowing conversion <code>(int)0x80000000</code> is implementation defined (not undefined), which means it's up to the compiler, but well defined and (ostensibly) documented. All the implementations we care about preserve the bit pattern here.</p>\n<p>I'm not sure <code>-0x80000000</code> is actually any more \"portable\". Either way, it depends on two's complement representation with the high order sign bit extracted via bitwise and. And, of course, the rest of the file depends on Intel's AVX intrinsics.</p>", "body_text": "This is fine, but you can use -0x80000000 if you prefer.\nThe narrowing conversion (int)0x80000000 is implementation defined (not undefined), which means it's up to the compiler, but well defined and (ostensibly) documented. All the implementations we care about preserve the bit pattern here.\nI'm not sure -0x80000000 is actually any more \"portable\". Either way, it depends on two's complement representation with the high order sign bit extracted via bitwise and. And, of course, the rest of the file depends on Intel's AVX intrinsics.", "in_reply_to_id": 164542043}