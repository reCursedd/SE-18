{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/165835468", "pull_request_review_id": 93836963, "id": 165835468, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2NTgzNTQ2OA==", "diff_hunk": "@@ -0,0 +1,26 @@\n+#include \"torch/csrc/autograd/function_port.h\"\n+\n+#include \"torch/csrc/autograd/function.h\"\n+\n+#include <cstdint>\n+#include <functional>\n+#include <memory>\n+\n+namespace torch {\n+namespace autograd {\n+FunctionPort::FunctionPort(\n+    const std::shared_ptr<Function>& function_,\n+    uint32_t port_)\n+    : function(function_), port(port_) {}\n+\n+FunctionPort::~FunctionPort() = default;\n+\n+bool FunctionPort::operator==(const FunctionPort& other) const noexcept {\n+  return this->function == other.function && this->port == other.port;\n+}\n+\n+bool FunctionPort::operator!=(const FunctionPort& other) const noexcept {\n+  return !(*this == other);\n+}", "path": "torch/csrc/autograd/function_port.cpp", "position": null, "original_position": 24, "commit_id": "62b9f8f91783f6a3fc51a5447e0e94e49d8e15de", "original_commit_id": "f3c56996533b5bf895961eeaac3385111db769d1", "user": {"login": "goldsborough", "id": 6429851, "node_id": "MDQ6VXNlcjY0Mjk4NTE=", "avatar_url": "https://avatars3.githubusercontent.com/u/6429851?v=4", "gravatar_id": "", "url": "https://api.github.com/users/goldsborough", "html_url": "https://github.com/goldsborough", "followers_url": "https://api.github.com/users/goldsborough/followers", "following_url": "https://api.github.com/users/goldsborough/following{/other_user}", "gists_url": "https://api.github.com/users/goldsborough/gists{/gist_id}", "starred_url": "https://api.github.com/users/goldsborough/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/goldsborough/subscriptions", "organizations_url": "https://api.github.com/users/goldsborough/orgs", "repos_url": "https://api.github.com/users/goldsborough/repos", "events_url": "https://api.github.com/users/goldsborough/events{/privacy}", "received_events_url": "https://api.github.com/users/goldsborough/received_events", "type": "User", "site_admin": false}, "body": "I've put it into the header. But just a note/thought: I think whether or not a function inlines is premature optimization at this point. I'm very passionate about keeping header files clean and dependency (header) free unless absolutely necessary, and forward declaring as much as possible. I've worked on a few pretty large-scale, ancient C++ projects like clang/LLVM or Scribe (FB) where I experienced first-hand what bad header sanity and gradual \"header rot\" leads to. Including things in headers leads to people forgetting to include those headers elsewhere, creating an implicit dependency chain between header files which can span dozens of files. In the worst case, and I've spent many, many hours debugging these issues, you have something like `X.h`  including a header, then `A.h`->`B.h`->`C.h`->`D.h`->`E.h`->`F.h`->`F.cpp`. Now two horrors can occur: (1) the header `X.h` includes, happens to include `F.h`, then you get a billion line error message about undefined classes, due to cyclic includes or (2), which is *much* more common, the header `X.h` included was `<vector>` because `struct X;` uses `vector`; now `F.cpp`also uses `<vector>` and forgets to include it, relying on the dependency on `X.h`; then the implementation of `X` changes to no longer use `<vector>` and whoops suddenly `F.cpp` doesn't compile anymore. Beyond that, you have things like increased build times. `X.h` includes `Y.h` even though it could forward declare it. Now every time I change `Y.h` I have to recompile everything that includes `X.h`. In the small, all these problems seem trivial and indeed having the function and declaration in the header removes the effort of having two files open (although arguably having a \"documentation/interface specification\" file and a separate \"implementation\" file is something I always liked), but over time you get things like T23516398 where you have teams having to invest effort into untangling years of bad header hygiene. This is 100% a fault of C++ not (yet) having a module system, but until then I value header hygiene a lot. And just to give you the big picture, I ran a tool called [include-what-you-use](http://include-what-you-use.org/), a tool which checks for forgotten includes (i.e relying on other files supplying headers), over ATen and it spits out like 4000 lines of warnings: P58972845. So this is just my rationale for putting things into implementation files. That said, I get that the style in our codebase is to prefer headers, so I'll try my best to stick to that! @zdevito ", "created_at": "2018-02-04T07:07:14Z", "updated_at": "2018-11-23T15:39:05Z", "html_url": "https://github.com/pytorch/pytorch/pull/5030#discussion_r165835468", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/5030", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/165835468"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/5030#discussion_r165835468"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/5030"}}, "body_html": "<p>I've put it into the header. But just a note/thought: I think whether or not a function inlines is premature optimization at this point. I'm very passionate about keeping header files clean and dependency (header) free unless absolutely necessary, and forward declaring as much as possible. I've worked on a few pretty large-scale, ancient C++ projects like clang/LLVM or Scribe (FB) where I experienced first-hand what bad header sanity and gradual \"header rot\" leads to. Including things in headers leads to people forgetting to include those headers elsewhere, creating an implicit dependency chain between header files which can span dozens of files. In the worst case, and I've spent many, many hours debugging these issues, you have something like <code>X.h</code>  including a header, then <code>A.h</code>-&gt;<code>B.h</code>-&gt;<code>C.h</code>-&gt;<code>D.h</code>-&gt;<code>E.h</code>-&gt;<code>F.h</code>-&gt;<code>F.cpp</code>. Now two horrors can occur: (1) the header <code>X.h</code> includes, happens to include <code>F.h</code>, then you get a billion line error message about undefined classes, due to cyclic includes or (2), which is <em>much</em> more common, the header <code>X.h</code> included was <code>&lt;vector&gt;</code> because <code>struct X;</code> uses <code>vector</code>; now <code>F.cpp</code>also uses <code>&lt;vector&gt;</code> and forgets to include it, relying on the dependency on <code>X.h</code>; then the implementation of <code>X</code> changes to no longer use <code>&lt;vector&gt;</code> and whoops suddenly <code>F.cpp</code> doesn't compile anymore. Beyond that, you have things like increased build times. <code>X.h</code> includes <code>Y.h</code> even though it could forward declare it. Now every time I change <code>Y.h</code> I have to recompile everything that includes <code>X.h</code>. In the small, all these problems seem trivial and indeed having the function and declaration in the header removes the effort of having two files open (although arguably having a \"documentation/interface specification\" file and a separate \"implementation\" file is something I always liked), but over time you get things like T23516398 where you have teams having to invest effort into untangling years of bad header hygiene. This is 100% a fault of C++ not (yet) having a module system, but until then I value header hygiene a lot. And just to give you the big picture, I ran a tool called <a href=\"http://include-what-you-use.org/\" rel=\"nofollow\">include-what-you-use</a>, a tool which checks for forgotten includes (i.e relying on other files supplying headers), over ATen and it spits out like 4000 lines of warnings: P58972845. So this is just my rationale for putting things into implementation files. That said, I get that the style in our codebase is to prefer headers, so I'll try my best to stick to that! <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=370202\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/zdevito\">@zdevito</a></p>", "body_text": "I've put it into the header. But just a note/thought: I think whether or not a function inlines is premature optimization at this point. I'm very passionate about keeping header files clean and dependency (header) free unless absolutely necessary, and forward declaring as much as possible. I've worked on a few pretty large-scale, ancient C++ projects like clang/LLVM or Scribe (FB) where I experienced first-hand what bad header sanity and gradual \"header rot\" leads to. Including things in headers leads to people forgetting to include those headers elsewhere, creating an implicit dependency chain between header files which can span dozens of files. In the worst case, and I've spent many, many hours debugging these issues, you have something like X.h  including a header, then A.h->B.h->C.h->D.h->E.h->F.h->F.cpp. Now two horrors can occur: (1) the header X.h includes, happens to include F.h, then you get a billion line error message about undefined classes, due to cyclic includes or (2), which is much more common, the header X.h included was <vector> because struct X; uses vector; now F.cppalso uses <vector> and forgets to include it, relying on the dependency on X.h; then the implementation of X changes to no longer use <vector> and whoops suddenly F.cpp doesn't compile anymore. Beyond that, you have things like increased build times. X.h includes Y.h even though it could forward declare it. Now every time I change Y.h I have to recompile everything that includes X.h. In the small, all these problems seem trivial and indeed having the function and declaration in the header removes the effort of having two files open (although arguably having a \"documentation/interface specification\" file and a separate \"implementation\" file is something I always liked), but over time you get things like T23516398 where you have teams having to invest effort into untangling years of bad header hygiene. This is 100% a fault of C++ not (yet) having a module system, but until then I value header hygiene a lot. And just to give you the big picture, I ran a tool called include-what-you-use, a tool which checks for forgotten includes (i.e relying on other files supplying headers), over ATen and it spits out like 4000 lines of warnings: P58972845. So this is just my rationale for putting things into implementation files. That said, I get that the style in our codebase is to prefer headers, so I'll try my best to stick to that! @zdevito", "in_reply_to_id": 165811168}