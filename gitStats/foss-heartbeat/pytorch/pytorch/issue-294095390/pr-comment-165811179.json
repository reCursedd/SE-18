{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/165811179", "pull_request_review_id": 93813123, "id": 165811179, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2NTgxMTE3OQ==", "diff_hunk": "@@ -0,0 +1,59 @@\n+#pragma once\n+\n+#include <cstdint>\n+#include <functional>\n+#include <memory>\n+\n+namespace torch {\n+namespace autograd {\n+\n+class Function;\n+\n+/// Represents an input or \"port\" of a function.\n+struct FunctionPort {\n+  explicit FunctionPort(\n+      const std::shared_ptr<Function>& function_ = nullptr,\n+      uint32_t port_ = 0);\n+\n+  // See https://stackoverflow.com/questions/13414652/forward-declaration-with-unique-ptr\n+  // for why this destructor is needed.\n+  ~FunctionPort();\n+\n+  // Required for use in associative containers.\n+  bool operator==(const FunctionPort& other) const noexcept;\n+  bool operator!=(const FunctionPort& other) const noexcept;\n+\n+  /// The function this `FunctionPort` points to.\n+  std::shared_ptr<Function> function;\n+\n+  /// The identifier of a particular input to the function.\n+  uint32_t port;\n+};\n+} // namespace autograd\n+} // namespace torch\n+\n+// The idiomatic way of enabling use of a custom type as the key of hash\n+// containers in C++11. This method removes the requirement of having to pass\n+// a custom hasher to std::unordered_{map, set}.\n+// See http://en.cppreference.com/w/cpp/utility/hash for more information.\n+namespace std {\n+template <>\n+struct hash<torch::autograd::FunctionPort> {\n+  // These type aliases are required by the standard.\n+  using argument_type = torch::autograd::FunctionPort;\n+  using return_type = size_t;\n+\n+  return_type operator()(const argument_type& function_port) const noexcept {\n+    const auto first = hash_value(function_port.function);\n+    const auto second = hash_value(function_port.port);\n+    // See http://www.boost.org/doc/libs/1_35_0/doc/html/hash/combine.html.\n+    return first ^ (second + 0x9e3779b9 + (first << 6) + (first >> 2));", "path": "torch/csrc/autograd/function_port.h", "position": null, "original_position": 50, "commit_id": "62b9f8f91783f6a3fc51a5447e0e94e49d8e15de", "original_commit_id": "f3c56996533b5bf895961eeaac3385111db769d1", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "body": "nit: use `torch/csrc/utils/hash.h`. You can `std::tie` to make a tuple out of members and hash that in one go (it uses `hash_combine` under the hood)", "created_at": "2018-02-03T10:32:15Z", "updated_at": "2018-11-23T15:39:04Z", "html_url": "https://github.com/pytorch/pytorch/pull/5030#discussion_r165811179", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/5030", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/165811179"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/5030#discussion_r165811179"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/5030"}}, "body_html": "<p>nit: use <code>torch/csrc/utils/hash.h</code>. You can <code>std::tie</code> to make a tuple out of members and hash that in one go (it uses <code>hash_combine</code> under the hood)</p>", "body_text": "nit: use torch/csrc/utils/hash.h. You can std::tie to make a tuple out of members and hash that in one go (it uses hash_combine under the hood)"}