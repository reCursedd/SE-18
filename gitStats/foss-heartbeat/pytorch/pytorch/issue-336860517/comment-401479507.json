{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/401479507", "html_url": "https://github.com/pytorch/pytorch/pull/9018#issuecomment-401479507", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/9018", "id": 401479507, "node_id": "MDEyOklzc3VlQ29tbWVudDQwMTQ3OTUwNw==", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "created_at": "2018-06-29T21:32:17Z", "updated_at": "2018-06-29T21:32:17Z", "author_association": "CONTRIBUTOR", "body_html": "<p>I think my primary objection to the changes in this patch is that it makes it easier to do the wrong thing.</p>\n<p>In the previous world, namespaces were mandatory. If you called a function <code>f(Symbol)</code> from Python, and forgot to attach a namespace, the parser would shout at you. In this PR, if you pass in an un-namespaced symbol, we will happily accept it, and you won't learn about the error of your ways until much later in the pipeline, at which point the backtrace when the bad symbol was passed in is lost. The Python typechecker is not going to give you any help here. (I guess you can fix this by removing the implicit Python string to Symbol conversion from the interface.)</p>\n<p>In the previous world, you could have whatever junk you wanted after the namespace. <code>attr::blah::baz</code> is OK; because the <code>xxx::</code> prefix is mandatory, there is never any ambiguity: everything after the first <code>::</code> is the actual string in question. So you don't have to worry about accepting strings from users, because they cannot introduce ambiguity by passing you something weird you don't expect. In the new world, if you accept an unqualified name, you had better check it doesn't contain any <code>::</code>, because if it does, you will get a symbol that is in the wrong namespace (it \"should\" have been in the none namespace, but it's actually in some random namespace \"xxx::\").</p>\n<p>In the previous world, the mandatory namespace was used as a way to say what strings <em>mean</em>. Yes, technically <code>attr</code> didn't need to be namespaced, but you were never confused about what an attr-namespace string was: it was a key for an attribute key map. Now there's a pile of non-namespaced identifiers. What do they mean? Who knows: you have to look at the call sites.</p>\n<p>(I remember in our original discussion, you were not 100% pleased with the namespacing refactor, and suggested we refactor Symbol into an interned string concept, which is just plain interned strings with no semantics, and a symbol concept, where we have semantics. I still think this is a good idea; a definite improvement over the old design. Though, I'm not sure you need it for your use case.)</p>", "body_text": "I think my primary objection to the changes in this patch is that it makes it easier to do the wrong thing.\nIn the previous world, namespaces were mandatory. If you called a function f(Symbol) from Python, and forgot to attach a namespace, the parser would shout at you. In this PR, if you pass in an un-namespaced symbol, we will happily accept it, and you won't learn about the error of your ways until much later in the pipeline, at which point the backtrace when the bad symbol was passed in is lost. The Python typechecker is not going to give you any help here. (I guess you can fix this by removing the implicit Python string to Symbol conversion from the interface.)\nIn the previous world, you could have whatever junk you wanted after the namespace. attr::blah::baz is OK; because the xxx:: prefix is mandatory, there is never any ambiguity: everything after the first :: is the actual string in question. So you don't have to worry about accepting strings from users, because they cannot introduce ambiguity by passing you something weird you don't expect. In the new world, if you accept an unqualified name, you had better check it doesn't contain any ::, because if it does, you will get a symbol that is in the wrong namespace (it \"should\" have been in the none namespace, but it's actually in some random namespace \"xxx::\").\nIn the previous world, the mandatory namespace was used as a way to say what strings mean. Yes, technically attr didn't need to be namespaced, but you were never confused about what an attr-namespace string was: it was a key for an attribute key map. Now there's a pile of non-namespaced identifiers. What do they mean? Who knows: you have to look at the call sites.\n(I remember in our original discussion, you were not 100% pleased with the namespacing refactor, and suggested we refactor Symbol into an interned string concept, which is just plain interned strings with no semantics, and a symbol concept, where we have semantics. I still think this is a good idea; a definite improvement over the old design. Though, I'm not sure you need it for your use case.)", "body": "I think my primary objection to the changes in this patch is that it makes it easier to do the wrong thing.\r\n\r\nIn the previous world, namespaces were mandatory. If you called a function `f(Symbol)` from Python, and forgot to attach a namespace, the parser would shout at you. In this PR, if you pass in an un-namespaced symbol, we will happily accept it, and you won't learn about the error of your ways until much later in the pipeline, at which point the backtrace when the bad symbol was passed in is lost. The Python typechecker is not going to give you any help here. (I guess you can fix this by removing the implicit Python string to Symbol conversion from the interface.)\r\n\r\nIn the previous world, you could have whatever junk you wanted after the namespace. `attr::blah::baz` is OK; because the `xxx::` prefix is mandatory, there is never any ambiguity: everything after the first `::` is the actual string in question. So you don't have to worry about accepting strings from users, because they cannot introduce ambiguity by passing you something weird you don't expect. In the new world, if you accept an unqualified name, you had better check it doesn't contain any `::`, because if it does, you will get a symbol that is in the wrong namespace (it \"should\" have been in the none namespace, but it's actually in some random namespace \"xxx::\").\r\n\r\nIn the previous world, the mandatory namespace was used as a way to say what strings *mean*. Yes, technically `attr` didn't need to be namespaced, but you were never confused about what an attr-namespace string was: it was a key for an attribute key map. Now there's a pile of non-namespaced identifiers. What do they mean? Who knows: you have to look at the call sites.\r\n\r\n(I remember in our original discussion, you were not 100% pleased with the namespacing refactor, and suggested we refactor Symbol into an interned string concept, which is just plain interned strings with no semantics, and a symbol concept, where we have semantics. I still think this is a good idea; a definite improvement over the old design. Though, I'm not sure you need it for your use case.)"}