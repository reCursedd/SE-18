{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/433114244", "html_url": "https://github.com/pytorch/pytorch/pull/12959#issuecomment-433114244", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/12959", "id": 433114244, "node_id": "MDEyOklzc3VlQ29tbWVudDQzMzExNDI0NA==", "user": {"login": "goldsborough", "id": 6429851, "node_id": "MDQ6VXNlcjY0Mjk4NTE=", "avatar_url": "https://avatars3.githubusercontent.com/u/6429851?v=4", "gravatar_id": "", "url": "https://api.github.com/users/goldsborough", "html_url": "https://github.com/goldsborough", "followers_url": "https://api.github.com/users/goldsborough/followers", "following_url": "https://api.github.com/users/goldsborough/following{/other_user}", "gists_url": "https://api.github.com/users/goldsborough/gists{/gist_id}", "starred_url": "https://api.github.com/users/goldsborough/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/goldsborough/subscriptions", "organizations_url": "https://api.github.com/users/goldsborough/orgs", "repos_url": "https://api.github.com/users/goldsborough/repos", "events_url": "https://api.github.com/users/goldsborough/events{/privacy}", "received_events_url": "https://api.github.com/users/goldsborough/received_events", "type": "User", "site_admin": false}, "created_at": "2018-10-25T16:16:28Z", "updated_at": "2018-10-25T16:19:39Z", "author_association": "CONTRIBUTOR", "body_html": "<blockquote>\n<p>Instead of helping find bugs this seems to insert code that implies some non-existent invariants.</p>\n</blockquote>\n<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=4583066\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/apaszke\">@apaszke</a> I think the general discussion point in all your comments is: is the garbage state better than a null/zero/empty state? I don't know about you, but I've debugged dozens of cases where an integer was initialized to garbage values (negative, very large, non-determnistic, random!) and shit randomly broke, sometimes, after you shipped the code and it happened to be initialized to zero most of the time. IMO it's much better to deterministically pin values to zero than to let them be garbage values. The clang tidy check is very smart about determining whether there is any constructor initializing the value or not, and it's raised only if there is at least one constructor that would leave the value in a garbage state.</p>", "body_text": "Instead of helping find bugs this seems to insert code that implies some non-existent invariants.\n\n@apaszke I think the general discussion point in all your comments is: is the garbage state better than a null/zero/empty state? I don't know about you, but I've debugged dozens of cases where an integer was initialized to garbage values (negative, very large, non-determnistic, random!) and shit randomly broke, sometimes, after you shipped the code and it happened to be initialized to zero most of the time. IMO it's much better to deterministically pin values to zero than to let them be garbage values. The clang tidy check is very smart about determining whether there is any constructor initializing the value or not, and it's raised only if there is at least one constructor that would leave the value in a garbage state.", "body": "> Instead of helping find bugs this seems to insert code that implies some non-existent invariants.\r\n\r\n@apaszke I think the general discussion point in all your comments is: is the garbage state better than a null/zero/empty state? I don't know about you, but I've debugged dozens of cases where an integer was initialized to garbage values (negative, very large, non-determnistic, random!) and shit randomly broke, sometimes, after you shipped the code and it happened to be initialized to zero most of the time. IMO it's much better to deterministically pin values to zero than to let them be garbage values. The clang tidy check is very smart about determining whether there is any constructor initializing the value or not, and it's raised only if there is at least one constructor that would leave the value in a garbage state."}