{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/433902685", "html_url": "https://github.com/pytorch/pytorch/issues/13234#issuecomment-433902685", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/13234", "id": 433902685, "node_id": "MDEyOklzc3VlQ29tbWVudDQzMzkwMjY4NQ==", "user": {"login": "davidmascharka", "id": 5611862, "node_id": "MDQ6VXNlcjU2MTE4NjI=", "avatar_url": "https://avatars1.githubusercontent.com/u/5611862?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmascharka", "html_url": "https://github.com/davidmascharka", "followers_url": "https://api.github.com/users/davidmascharka/followers", "following_url": "https://api.github.com/users/davidmascharka/following{/other_user}", "gists_url": "https://api.github.com/users/davidmascharka/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmascharka/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmascharka/subscriptions", "organizations_url": "https://api.github.com/users/davidmascharka/orgs", "repos_url": "https://api.github.com/users/davidmascharka/repos", "events_url": "https://api.github.com/users/davidmascharka/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmascharka/received_events", "type": "User", "site_admin": false}, "created_at": "2018-10-29T13:07:01Z", "updated_at": "2018-10-29T13:07:27Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Calling <code>DataParallel</code> wraps the model:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">import</span> torch\n\nnet <span class=\"pl-k\">=</span> torch.nn.Sequential(\n    torch.nn.Conv2d(<span class=\"pl-c1\">3</span>, <span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">3</span>)\n)\n<span class=\"pl-c1\">print</span>(net)\n\nSequential(\n  (<span class=\"pl-c1\">0</span>): Conv2d(<span class=\"pl-c1\">3</span>, <span class=\"pl-c1\">1</span>, <span class=\"pl-v\">kernel_size</span><span class=\"pl-k\">=</span>(<span class=\"pl-c1\">3</span>, <span class=\"pl-c1\">3</span>), <span class=\"pl-v\">stride</span><span class=\"pl-k\">=</span>(<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">1</span>))\n)</pre></div>\n<p>When you wrap it in <code>DataParallel</code>, it becomes:</p>\n<div class=\"highlight highlight-source-python\"><pre>net <span class=\"pl-k\">=</span> torch.nn.Sequential(\n    torch.nn.Conv2d(<span class=\"pl-c1\">3</span>, <span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">3</span>)\n)\n\nnet <span class=\"pl-k\">=</span> torch.nn.DataParallel(net)\n<span class=\"pl-c1\">print</span>(net)\n\nDataParallel(\n  (module): Sequential(\n    (<span class=\"pl-c1\">0</span>): Conv2d(<span class=\"pl-c1\">3</span>, <span class=\"pl-c1\">1</span>, <span class=\"pl-v\">kernel_size</span><span class=\"pl-k\">=</span>(<span class=\"pl-c1\">3</span>, <span class=\"pl-c1\">3</span>), <span class=\"pl-v\">stride</span><span class=\"pl-k\">=</span>(<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">1</span>))\n  )\n)</pre></div>\n<p>When you make your <code>checkpoint_sequential</code> call, you aren't passing in a <code>Sequential</code> model; you're passing in a <code>DataParallel</code> model. You can call <code>checkpoint_sequential(net.module, 1, data)</code> to get that functionality.</p>", "body_text": "Calling DataParallel wraps the model:\nimport torch\n\nnet = torch.nn.Sequential(\n    torch.nn.Conv2d(3, 1, 3)\n)\nprint(net)\n\nSequential(\n  (0): Conv2d(3, 1, kernel_size=(3, 3), stride=(1, 1))\n)\nWhen you wrap it in DataParallel, it becomes:\nnet = torch.nn.Sequential(\n    torch.nn.Conv2d(3, 1, 3)\n)\n\nnet = torch.nn.DataParallel(net)\nprint(net)\n\nDataParallel(\n  (module): Sequential(\n    (0): Conv2d(3, 1, kernel_size=(3, 3), stride=(1, 1))\n  )\n)\nWhen you make your checkpoint_sequential call, you aren't passing in a Sequential model; you're passing in a DataParallel model. You can call checkpoint_sequential(net.module, 1, data) to get that functionality.", "body": "Calling `DataParallel` wraps the model:\r\n\r\n``` python\r\nimport torch\r\n\r\nnet = torch.nn.Sequential(\r\n    torch.nn.Conv2d(3, 1, 3)\r\n)\r\nprint(net)\r\n\r\nSequential(\r\n  (0): Conv2d(3, 1, kernel_size=(3, 3), stride=(1, 1))\r\n)\r\n```\r\n\r\nWhen you wrap it in `DataParallel`, it becomes:\r\n\r\n``` python\r\nnet = torch.nn.Sequential(\r\n    torch.nn.Conv2d(3, 1, 3)\r\n)\r\n\r\nnet = torch.nn.DataParallel(net)\r\nprint(net)\r\n\r\nDataParallel(\r\n  (module): Sequential(\r\n    (0): Conv2d(3, 1, kernel_size=(3, 3), stride=(1, 1))\r\n  )\r\n)\r\n```\r\n\r\nWhen you make your `checkpoint_sequential` call, you aren't passing in a `Sequential` model; you're passing in a `DataParallel` model. You can call `checkpoint_sequential(net.module, 1, data)` to get that functionality."}