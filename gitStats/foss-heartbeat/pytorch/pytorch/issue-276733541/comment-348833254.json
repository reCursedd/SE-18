{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/348833254", "html_url": "https://github.com/pytorch/pytorch/issues/3867#issuecomment-348833254", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/3867", "id": 348833254, "node_id": "MDEyOklzc3VlQ29tbWVudDM0ODgzMzI1NA==", "user": {"login": "qbx2", "id": 5977817, "node_id": "MDQ6VXNlcjU5Nzc4MTc=", "avatar_url": "https://avatars1.githubusercontent.com/u/5977817?v=4", "gravatar_id": "", "url": "https://api.github.com/users/qbx2", "html_url": "https://github.com/qbx2", "followers_url": "https://api.github.com/users/qbx2/followers", "following_url": "https://api.github.com/users/qbx2/following{/other_user}", "gists_url": "https://api.github.com/users/qbx2/gists{/gist_id}", "starred_url": "https://api.github.com/users/qbx2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/qbx2/subscriptions", "organizations_url": "https://api.github.com/users/qbx2/orgs", "repos_url": "https://api.github.com/users/qbx2/repos", "events_url": "https://api.github.com/users/qbx2/events{/privacy}", "received_events_url": "https://api.github.com/users/qbx2/received_events", "type": "User", "site_admin": false}, "created_at": "2017-12-04T00:27:41Z", "updated_at": "2017-12-04T00:39:38Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Thank you for indicating the issue and the reference.<br>\nTo resolve the issue stated by <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=9110200\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/fmassa\">@fmassa</a>, I propose two interfaces.<br>\nFirst, as @soutmith mentioned, the first interface would be like<code>nn.Conv*d(..., padding=\"same\")</code>, calculating the padding every <code>forward()</code> call.<br>\nHowever, it would be an inefficient way when the input shape is known in the initialization phase. Therefore, I suggest an interface like <code>nn.CalcPadConv*d(&lt;almost same parameters as Conv*d&gt;)</code>. Using it, a user can calculate the padding using known width and height in initialization, and pass the output (the shape of padding) to the padding parameter of <code>nn.Conv2d(...)</code><br>\nI'm not sure if the second proposal could be a premature optimization.<br>\nHow do you think about these? Is there any idea of a better name?</p>", "body_text": "Thank you for indicating the issue and the reference.\nTo resolve the issue stated by @fmassa, I propose two interfaces.\nFirst, as @soutmith mentioned, the first interface would be likenn.Conv*d(..., padding=\"same\"), calculating the padding every forward() call.\nHowever, it would be an inefficient way when the input shape is known in the initialization phase. Therefore, I suggest an interface like nn.CalcPadConv*d(<almost same parameters as Conv*d>). Using it, a user can calculate the padding using known width and height in initialization, and pass the output (the shape of padding) to the padding parameter of nn.Conv2d(...)\nI'm not sure if the second proposal could be a premature optimization.\nHow do you think about these? Is there any idea of a better name?", "body": "Thank you for indicating the issue and the reference.\r\nTo resolve the issue stated by @fmassa, I propose two interfaces.\r\nFirst, as @soutmith mentioned, the first interface would be like`nn.Conv*d(..., padding=\"same\")`, calculating the padding every `forward()` call.\r\nHowever, it would be an inefficient way when the input shape is known in the initialization phase. Therefore, I suggest an interface like `nn.CalcPadConv*d(<almost same parameters as Conv*d>)`. Using it, a user can calculate the padding using known width and height in initialization, and pass the output (the shape of padding) to the padding parameter of `nn.Conv2d(...)`\r\nI'm not sure if the second proposal could be a premature optimization.\r\nHow do you think about these? Is there any idea of a better name?"}