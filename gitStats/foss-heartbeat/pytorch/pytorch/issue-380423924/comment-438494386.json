{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/438494386", "html_url": "https://github.com/pytorch/pytorch/issues/13929#issuecomment-438494386", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/13929", "id": 438494386, "node_id": "MDEyOklzc3VlQ29tbWVudDQzODQ5NDM4Ng==", "user": {"login": "ArmenAg", "id": 4429794, "node_id": "MDQ6VXNlcjQ0Mjk3OTQ=", "avatar_url": "https://avatars0.githubusercontent.com/u/4429794?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArmenAg", "html_url": "https://github.com/ArmenAg", "followers_url": "https://api.github.com/users/ArmenAg/followers", "following_url": "https://api.github.com/users/ArmenAg/following{/other_user}", "gists_url": "https://api.github.com/users/ArmenAg/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArmenAg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArmenAg/subscriptions", "organizations_url": "https://api.github.com/users/ArmenAg/orgs", "repos_url": "https://api.github.com/users/ArmenAg/repos", "events_url": "https://api.github.com/users/ArmenAg/events{/privacy}", "received_events_url": "https://api.github.com/users/ArmenAg/received_events", "type": "User", "site_admin": false}, "created_at": "2018-11-14T00:43:34Z", "updated_at": "2018-11-14T00:43:34Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=370202\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/zdevito\">@zdevito</a> This makes sense for pass managers. But for things like fixed point optimization where we require some form of pass analysis to implement efficiently how would we go about it with the current framework? Without any form of pass analysis it's impossible to do non-trivial ordering of passes.</p>\n<p>Implementing types of passes (e.g. PredicateBasedPass) helps simplify the code by removing code reuse and providing a clean implementation for the optimization pass (a good example is the ONNX codebase).</p>\n<p>Thank you for your detailed reply!</p>", "body_text": "@zdevito This makes sense for pass managers. But for things like fixed point optimization where we require some form of pass analysis to implement efficiently how would we go about it with the current framework? Without any form of pass analysis it's impossible to do non-trivial ordering of passes.\nImplementing types of passes (e.g. PredicateBasedPass) helps simplify the code by removing code reuse and providing a clean implementation for the optimization pass (a good example is the ONNX codebase).\nThank you for your detailed reply!", "body": "@zdevito This makes sense for pass managers. But for things like fixed point optimization where we require some form of pass analysis to implement efficiently how would we go about it with the current framework? Without any form of pass analysis it's impossible to do non-trivial ordering of passes. \r\n\r\nImplementing types of passes (e.g. PredicateBasedPass) helps simplify the code by removing code reuse and providing a clean implementation for the optimization pass (a good example is the ONNX codebase).\r\n\r\nThank you for your detailed reply!"}