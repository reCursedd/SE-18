{"url": "https://api.github.com/repos/pytorch/pytorch/issues/4524", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/4524/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/4524/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/4524/events", "html_url": "https://github.com/pytorch/pytorch/pull/4524", "id": 286570426, "node_id": "MDExOlB1bGxSZXF1ZXN0MTYxNTIyNDg4", "number": 4524, "title": "Fix tracking of tracing scopes during ONNX pass", "user": {"login": "lantiga", "id": 191033, "node_id": "MDQ6VXNlcjE5MTAzMw==", "avatar_url": "https://avatars2.githubusercontent.com/u/191033?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lantiga", "html_url": "https://github.com/lantiga", "followers_url": "https://api.github.com/users/lantiga/followers", "following_url": "https://api.github.com/users/lantiga/following{/other_user}", "gists_url": "https://api.github.com/users/lantiga/gists{/gist_id}", "starred_url": "https://api.github.com/users/lantiga/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lantiga/subscriptions", "organizations_url": "https://api.github.com/users/lantiga/orgs", "repos_url": "https://api.github.com/users/lantiga/repos", "events_url": "https://api.github.com/users/lantiga/events{/privacy}", "received_events_url": "https://api.github.com/users/lantiga/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2018-01-07T13:49:04Z", "updated_at": "2018-11-23T15:37:56Z", "closed_at": "2018-01-08T17:20:53Z", "author_association": "COLLABORATOR", "pull_request": {"url": "https://api.github.com/repos/pytorch/pytorch/pulls/4524", "html_url": "https://github.com/pytorch/pytorch/pull/4524", "diff_url": "https://github.com/pytorch/pytorch/pull/4524.diff", "patch_url": "https://github.com/pytorch/pytorch/pull/4524.patch"}, "body_html": "<p>This PR addresses <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"286277055\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/4495\" data-hovercard-type=\"issue\" data-hovercard-url=\"/pytorch/pytorch/issues/4495/hovercard\" href=\"https://github.com/pytorch/pytorch/issues/4495\">#4495</a></p>\n<p>During the ONNX pass, the strategy for preserving correct scopes in the new symbolic nodes was to copy the scope from the original nodes to the outputs. This lead to two issues:</p>\n<ul>\n<li>intermediate nodes did not have a chance to receive a scope (see <code>log_softmax</code> issue in <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"286277055\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/4495\" data-hovercard-type=\"issue\" data-hovercard-url=\"/pytorch/pytorch/issues/4495/hovercard\" href=\"https://github.com/pytorch/pytorch/issues/4495\">#4495</a>)</li>\n<li>short-circuited symbolic functions (i.e. <code>_forward</code> symbolic functions simply returning their inputs) were effectively returning the output of the previous op, so copying the scope to those outputs ended up overwriting the scope of the previous op.</li>\n</ul>\n<p>This PR introduces a <code>set_current_scope</code> method in <code>Graph</code>, which first checks that the scope trie node being set as current belongs to the scope trie of the Graph, and then sets it as current.</p>\n<p>We use this mechanism to set the current scope of the symbolic graph (which already inherited the scope trie of the previous graph) before calling the symbolic functions, so all nodes created within those functions (outputs or intermediate) will get the same scope of the corresponding non-symbolic node.</p>\n<p>Also, if no nodes are created (like in the short-circuited functions), no scopes are set, thus preserving the scope of the node preceding a short-circuited function (i.e. <code>Conv</code> in <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"286277055\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/4495\" data-hovercard-type=\"issue\" data-hovercard-url=\"/pytorch/pytorch/issues/4495/hovercard\" href=\"https://github.com/pytorch/pytorch/issues/4495\">#4495</a>).</p>", "body_text": "This PR addresses #4495\nDuring the ONNX pass, the strategy for preserving correct scopes in the new symbolic nodes was to copy the scope from the original nodes to the outputs. This lead to two issues:\n\nintermediate nodes did not have a chance to receive a scope (see log_softmax issue in #4495)\nshort-circuited symbolic functions (i.e. _forward symbolic functions simply returning their inputs) were effectively returning the output of the previous op, so copying the scope to those outputs ended up overwriting the scope of the previous op.\n\nThis PR introduces a set_current_scope method in Graph, which first checks that the scope trie node being set as current belongs to the scope trie of the Graph, and then sets it as current.\nWe use this mechanism to set the current scope of the symbolic graph (which already inherited the scope trie of the previous graph) before calling the symbolic functions, so all nodes created within those functions (outputs or intermediate) will get the same scope of the corresponding non-symbolic node.\nAlso, if no nodes are created (like in the short-circuited functions), no scopes are set, thus preserving the scope of the node preceding a short-circuited function (i.e. Conv in #4495).", "body": "This PR addresses #4495 \r\n\r\nDuring the ONNX pass, the strategy for preserving correct scopes in the new symbolic nodes was to copy the scope from the original nodes to the outputs. This lead to two issues:\r\n- intermediate nodes did not have a chance to receive a scope (see `log_softmax` issue in #4495)\r\n- short-circuited symbolic functions (i.e. `_forward` symbolic functions simply returning their inputs) were effectively returning the output of the previous op, so copying the scope to those outputs ended up overwriting the scope of the previous op.\r\n\r\nThis PR introduces a `set_current_scope` method in `Graph`, which first checks that the scope trie node being set as current belongs to the scope trie of the Graph, and then sets it as current.\r\n\r\nWe use this mechanism to set the current scope of the symbolic graph (which already inherited the scope trie of the previous graph) before calling the symbolic functions, so all nodes created within those functions (outputs or intermediate) will get the same scope of the corresponding non-symbolic node.\r\n\r\nAlso, if no nodes are created (like in the short-circuited functions), no scopes are set, thus preserving the scope of the node preceding a short-circuited function (i.e. `Conv` in #4495)."}