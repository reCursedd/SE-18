{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/215978983", "pull_request_review_id": 153367599, "id": 215978983, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNTk3ODk4Mw==", "diff_hunk": "@@ -9,4 +9,19 @@ LegacyTypeDispatch & globalLegacyTypeDispatch() {\n   return singleton;\n }\n \n+AT_DEFINE_REGISTRY(LegacyTypeInitRegistry, LegacyTypeInitInterface, LegacyTypeInitArgs)\n+\n+const LegacyTypeInitInterface& getLegacyTypeInit() {\n+  static std::unique_ptr<LegacyTypeInitInterface> legacy_type_init;\n+  static std::once_flag once;\n+  std::call_once(once, [] {", "path": "aten/src/ATen/core/LegacyTypeDispatch.cpp", "position": 9, "original_position": 9, "commit_id": "606bd66fc2771e10f8b835fd1f49a39c3be09bac", "original_commit_id": "959a424b57eee0f9537290de44c514d2ab3ba163", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "body": "This is the \"standard\" boilerplate we've been using for the other hooks mechanisms (e.g., CUDAHooks and VariableHooks). The setting is this: you have been given a registry which, when invoked, constructs an object (whose constructor was specified out of band by some other source). So using this you can construct an object. But you only want to construct the object once, and then reuse it later! Thus `call_once`.", "created_at": "2018-09-07T14:32:21Z", "updated_at": "2018-11-23T15:50:45Z", "html_url": "https://github.com/pytorch/pytorch/pull/11331#discussion_r215978983", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/11331", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/215978983"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/11331#discussion_r215978983"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/11331"}}, "body_html": "<p>This is the \"standard\" boilerplate we've been using for the other hooks mechanisms (e.g., CUDAHooks and VariableHooks). The setting is this: you have been given a registry which, when invoked, constructs an object (whose constructor was specified out of band by some other source). So using this you can construct an object. But you only want to construct the object once, and then reuse it later! Thus <code>call_once</code>.</p>", "body_text": "This is the \"standard\" boilerplate we've been using for the other hooks mechanisms (e.g., CUDAHooks and VariableHooks). The setting is this: you have been given a registry which, when invoked, constructs an object (whose constructor was specified out of band by some other source). So using this you can construct an object. But you only want to construct the object once, and then reuse it later! Thus call_once.", "in_reply_to_id": 215713052}