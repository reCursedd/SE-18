{"url": "https://api.github.com/repos/pytorch/pytorch/issues/11520", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/11520/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/11520/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/11520/events", "html_url": "https://github.com/pytorch/pytorch/pull/11520", "id": 359118161, "node_id": "MDExOlB1bGxSZXF1ZXN0MjE0Njg2OTkw", "number": 11520, "title": "Split Type into TypeExtendedInterface and Type", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 890282107, "node_id": "MDU6TGFiZWw4OTAyODIxMDc=", "url": "https://api.github.com/repos/pytorch/pytorch/labels/caffe2", "name": "caffe2", "color": "210aa8", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2018-09-11T16:11:16Z", "updated_at": "2018-11-23T15:51:02Z", "closed_at": "2018-09-12T03:17:36Z", "author_association": "CONTRIBUTOR", "pull_request": {"url": "https://api.github.com/repos/pytorch/pytorch/pulls/11520", "html_url": "https://github.com/pytorch/pytorch/pull/11520", "diff_url": "https://github.com/pytorch/pytorch/pull/11520.diff", "patch_url": "https://github.com/pytorch/pytorch/pull/11520.patch"}, "body_html": "<p>Stack:<br>\n\u00a0\u00a0\u00a0\u00a0<g-emoji class=\"g-emoji\" alias=\"black_circle\" fallback-src=\"https://assets-cdn.github.com/images/icons/emoji/unicode/26ab.png\">\u26ab\ufe0f</g-emoji>\u00a0 <strong><a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"359118161\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/11520\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/pytorch/pytorch/pull/11520/hovercard\" href=\"https://github.com/pytorch/pytorch/pull/11520\">#11520</a> Split Type into TypeExtendedInterface and Type</strong>\u00a0\u00a0<a href=\"https://our.internmc.facebook.com/intern/diff/D9771708/\" rel=\"nofollow\"><g-emoji class=\"g-emoji\" alias=\"green_heart\" fallback-src=\"https://assets-cdn.github.com/images/icons/emoji/unicode/1f49a.png\">\ud83d\udc9a</g-emoji></a></p>\n<p>Previously, we had Type which was a catch all interface for all<br>\nfunctions and methods we could possibly want to do dynamic dispatch<br>\non. However, we want to check in a non-autogenerated Tensor class<br>\nto ATen/core, and to do this, we must also check in a non-autogenerated<br>\nType class which we can do dispatch on. In principle, we could<br>\nput the full Type interface in ATen/core, but this would be<br>\na bad developer experience, since any time you add a new free<br>\nfunction, you'd have to regenerate the checked in Type header.</p>\n<p>For a better dev experience, we split Type into a two parts,<br>\nType, which will be checked in (though not in this diff), and<br>\nTypeExtendedInterface, which will NOT be checked in. Type contains<br>\njust enough methods to let Tensor be defined, and leaves the<br>\nrest to TypeExtendedInterface.</p>\n<p>Some complications:</p>\n<ul>\n<li>\n<p>We (very unfortunately) have overloaded virtual methods. Because<br>\nof C++'s rules, we cannot move one overload without doing some<br>\nextra work to make sure that overload in a superclass and an<br>\noverload in a subclass resolve together. I've chosen to resolve<br>\nthis problem simply by moving ALL overloads of a method which<br>\noccurs in Tensor to Type.</p>\n</li>\n<li>\n<p>There are some places where we take a type() object and call<br>\na method on it, which is not a Tensor base method. I've eliminated<br>\nsome where possible, but in other cases calling the method on type<br>\nis the ONLY way to invoke it; in that case, I've just inserted<br>\na cast. Further refactoring is necessary.</p>\n</li>\n</ul>\n<p>Differential Revision: <a href=\"https://our.internmc.facebook.com/intern/diff/D9771708/\" rel=\"nofollow\">D9771708</a></p>", "body_text": "Stack:\n\u00a0\u00a0\u00a0\u00a0\u26ab\ufe0f\u00a0 #11520 Split Type into TypeExtendedInterface and Type\u00a0\u00a0\ud83d\udc9a\nPreviously, we had Type which was a catch all interface for all\nfunctions and methods we could possibly want to do dynamic dispatch\non. However, we want to check in a non-autogenerated Tensor class\nto ATen/core, and to do this, we must also check in a non-autogenerated\nType class which we can do dispatch on. In principle, we could\nput the full Type interface in ATen/core, but this would be\na bad developer experience, since any time you add a new free\nfunction, you'd have to regenerate the checked in Type header.\nFor a better dev experience, we split Type into a two parts,\nType, which will be checked in (though not in this diff), and\nTypeExtendedInterface, which will NOT be checked in. Type contains\njust enough methods to let Tensor be defined, and leaves the\nrest to TypeExtendedInterface.\nSome complications:\n\n\nWe (very unfortunately) have overloaded virtual methods. Because\nof C++'s rules, we cannot move one overload without doing some\nextra work to make sure that overload in a superclass and an\noverload in a subclass resolve together. I've chosen to resolve\nthis problem simply by moving ALL overloads of a method which\noccurs in Tensor to Type.\n\n\nThere are some places where we take a type() object and call\na method on it, which is not a Tensor base method. I've eliminated\nsome where possible, but in other cases calling the method on type\nis the ONLY way to invoke it; in that case, I've just inserted\na cast. Further refactoring is necessary.\n\n\nDifferential Revision: D9771708", "body": "Stack:\n&nbsp;&nbsp;&nbsp;&nbsp;:black_circle:&nbsp; **#11520 Split Type into TypeExtendedInterface and Type**&nbsp;&nbsp;[:green_heart:](https://our.internmc.facebook.com/intern/diff/D9771708/)\n\nPreviously, we had Type which was a catch all interface for all\nfunctions and methods we could possibly want to do dynamic dispatch\non. However, we want to check in a non-autogenerated Tensor class\nto ATen/core, and to do this, we must also check in a non-autogenerated\nType class which we can do dispatch on. In principle, we could\nput the full Type interface in ATen/core, but this would be\na bad developer experience, since any time you add a new free\nfunction, you'd have to regenerate the checked in Type header.\n\nFor a better dev experience, we split Type into a two parts,\nType, which will be checked in (though not in this diff), and\nTypeExtendedInterface, which will NOT be checked in. Type contains\njust enough methods to let Tensor be defined, and leaves the\nrest to TypeExtendedInterface.\n\nSome complications:\n\n- We (very unfortunately) have overloaded virtual methods. Because\nof C++'s rules, we cannot move one overload without doing some\nextra work to make sure that overload in a superclass and an\noverload in a subclass resolve together. I've chosen to resolve\nthis problem simply by moving ALL overloads of a method which\noccurs in Tensor to Type.\n\n- There are some places where we take a type() object and call\na method on it, which is not a Tensor base method. I've eliminated\nsome where possible, but in other cases calling the method on type\nis the ONLY way to invoke it; in that case, I've just inserted\na cast. Further refactoring is necessary.\n\nDifferential Revision: [D9771708](https://our.internmc.facebook.com/intern/diff/D9771708/)"}