{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/202508735", "pull_request_review_id": 137231632, "id": 202508735, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjUwODczNQ==", "diff_hunk": "@@ -1443,6 +1456,113 @@ def test_normal_sample(self):\n                                         scipy.stats.norm(loc=loc, scale=scale),\n                                         'Normal(mean={}, std={})'.format(loc, scale))\n \n+    def test_lowrank_multivariate_normal_shape(self):\n+        mean = torch.randn(5, 3, requires_grad=True)\n+        mean_no_batch = torch.randn(3, requires_grad=True)\n+        mean_multi_batch = torch.randn(6, 5, 3, requires_grad=True)\n+\n+        # construct PSD covariance\n+        cov_factor = torch.randn(3, 1, requires_grad=True)\n+        cov_diag = torch.tensor(torch.randn(3).abs(), requires_grad=True)\n+\n+        # construct batch of PSD covariances\n+        cov_factor_batched = torch.randn(6, 5, 3, 2, requires_grad=True)\n+        cov_diag_batched = torch.tensor(torch.randn(6, 5, 3).abs(), requires_grad=True)\n+\n+        # ensure that sample, batch, event shapes all handled correctly\n+        self.assertEqual(LowRankMultivariateNormal(mean, cov_factor, cov_diag)\n+                         .sample().size(), (5, 3))\n+        self.assertEqual(LowRankMultivariateNormal(mean_no_batch, cov_factor, cov_diag)\n+                         .sample().size(), (3,))\n+        self.assertEqual(LowRankMultivariateNormal(mean_multi_batch, cov_factor, cov_diag)\n+                         .sample().size(), (6, 5, 3))\n+        self.assertEqual(LowRankMultivariateNormal(mean, cov_factor, cov_diag)\n+                         .sample((2,)).size(), (2, 5, 3))\n+        self.assertEqual(LowRankMultivariateNormal(mean_no_batch, cov_factor, cov_diag)\n+                         .sample((2,)).size(), (2, 3))\n+        self.assertEqual(LowRankMultivariateNormal(mean_multi_batch, cov_factor, cov_diag)\n+                         .sample((2,)).size(), (2, 6, 5, 3))\n+        self.assertEqual(LowRankMultivariateNormal(mean, cov_factor, cov_diag)\n+                         .sample((2, 7)).size(), (2, 7, 5, 3))\n+        self.assertEqual(LowRankMultivariateNormal(mean_no_batch, cov_factor, cov_diag)\n+                         .sample((2, 7)).size(), (2, 7, 3))\n+        self.assertEqual(LowRankMultivariateNormal(mean_multi_batch, cov_factor, cov_diag)\n+                         .sample((2, 7)).size(), (2, 7, 6, 5, 3))\n+        self.assertEqual(LowRankMultivariateNormal(mean, cov_factor_batched, cov_diag_batched)\n+                         .sample((2, 7)).size(), (2, 7, 6, 5, 3))\n+        self.assertEqual(LowRankMultivariateNormal(mean_no_batch, cov_factor_batched, cov_diag_batched)\n+                         .sample((2, 7)).size(), (2, 7, 6, 5, 3))\n+        self.assertEqual(LowRankMultivariateNormal(mean_multi_batch, cov_factor_batched, cov_diag_batched)\n+                         .sample((2, 7)).size(), (2, 7, 6, 5, 3))\n+\n+        # check gradients\n+        self._gradcheck_log_prob(LowRankMultivariateNormal,\n+                                 (mean, cov_factor, cov_diag))\n+        self._gradcheck_log_prob(LowRankMultivariateNormal,\n+                                 (mean_multi_batch, cov_factor, cov_diag))\n+        self._gradcheck_log_prob(LowRankMultivariateNormal,\n+                                 (mean_multi_batch, cov_factor_batched, cov_diag_batched))\n+\n+    @unittest.skipIf(not TEST_NUMPY, \"Numpy not found\")\n+    def test_lowrank_multivariate_normal_log_prob(self):\n+        mean = torch.randn(3, requires_grad=True)\n+        cov_factor = torch.randn(3, 1, requires_grad=True)\n+        cov_diag = torch.tensor(torch.randn(3).abs(), requires_grad=True)\n+        cov = cov_factor.matmul(cov_factor.t()) + cov_diag.diag()\n+\n+        # check that logprob values match scipy logpdf,\n+        # and that covariance and scale_tril parameters are equivalent\n+        dist1 = LowRankMultivariateNormal(mean, cov_factor, cov_diag)\n+        ref_dist = scipy.stats.multivariate_normal(mean.detach().numpy(), cov.detach().numpy())\n+\n+        x = dist1.sample((10,))\n+        expected = ref_dist.logpdf(x.numpy())\n+\n+        self.assertAlmostEqual(0.0, np.mean((dist1.log_prob(x).detach().numpy() - expected)**2), places=3)\n+\n+        # Double-check that batched versions behave the same as unbatched\n+        mean = torch.randn(5, 3, requires_grad=True)\n+        cov_factor = torch.randn(5, 3, 2, requires_grad=True)\n+        cov_diag = torch.tensor(torch.randn(5, 3).abs(), requires_grad=True)\n+\n+        dist_batched = LowRankMultivariateNormal(mean, cov_factor, cov_diag)\n+        dist_unbatched = [LowRankMultivariateNormal(mean[i], cov_factor[i], cov_diag[i])\n+                          for i in range(mean.size(0))]\n+\n+        x = dist_batched.sample((10,))\n+        batched_prob = dist_batched.log_prob(x)\n+        unbatched_prob = torch.stack([dist_unbatched[i].log_prob(x[:, i]) for i in range(5)]).t()\n+\n+        self.assertEqual(batched_prob.shape, unbatched_prob.shape)\n+        self.assertAlmostEqual(0.0, (batched_prob - unbatched_prob).abs().max(), places=3)\n+\n+    @unittest.skipIf(not TEST_NUMPY, \"NumPy not found\")\n+    def test_lowrank_multivariate_normal_sample(self):\n+        set_rng_seed(0)  # see Note [Randomized statistical tests]\n+        mean = torch.randn(5, requires_grad=True)\n+        cov_factor = torch.randn(5, 1, requires_grad=True)\n+        cov_diag = torch.tensor(torch.randn(5).abs(), requires_grad=True)\n+        cov = cov_factor.matmul(cov_factor.t()) + cov_diag.diag()\n+\n+        self._check_sampler_sampler(LowRankMultivariateNormal(mean, cov_factor, cov_diag),\n+                                    scipy.stats.multivariate_normal(mean.detach().numpy(), cov.detach().numpy()),\n+                                    'LowRankMultivariateNormal(loc={}, cov_factor={}, cov_diag={})'\n+                                    .format(mean, cov_factor, cov_diag), multivariate=True)\n+\n+    def test_lowrank_multivariate_normal_properties(self):", "path": "test/test_distributions.py", "position": 126, "original_position": 126, "commit_id": "36d6044c64e07c795b8f2b8c9a88df25a407e025", "original_commit_id": "750342c9b945bfc8ece0e9fa8ce8342dcf9e6532", "user": {"login": "fritzo", "id": 648532, "node_id": "MDQ6VXNlcjY0ODUzMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/648532?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fritzo", "html_url": "https://github.com/fritzo", "followers_url": "https://api.github.com/users/fritzo/followers", "following_url": "https://api.github.com/users/fritzo/following{/other_user}", "gists_url": "https://api.github.com/users/fritzo/gists{/gist_id}", "starred_url": "https://api.github.com/users/fritzo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fritzo/subscriptions", "organizations_url": "https://api.github.com/users/fritzo/orgs", "repos_url": "https://api.github.com/users/fritzo/repos", "events_url": "https://api.github.com/users/fritzo/events{/privacy}", "received_events_url": "https://api.github.com/users/fritzo/received_events", "type": "User", "site_admin": false}, "body": "@fehiepsi This tests agreement between `LowRankMultivariateNormal` and `MultivariateNormal` moments, but does not actually tests moments of the generated samples. Could you add a test that checks agreement between `.rsample` and `(.mean, .variance)` with say 100000 samples? Something like this:\r\n```py\r\ndef test_lowrank_multivariate_normal_moments(self):\r\n    mean = torch.randn(5, requires_grad=True)\r\n    cov_factor = torch.randn(5, 2, requires_grad=True)\r\n    cov_diag = torch.tensor(torch.randn(5).abs(), requires_grad=True)\r\n    d = LowRankMultivariateNormal(mean, cov_factor, cov_diag)\r\n    samples = d.rsample((100000,))\r\n    empirical_mean = samples.mean(0)\r\n    self.assertEqual(d.mean, empirical_mean, prec=0.01)\r\n    empirical_var = samples.var(0)\r\n    self.assertEqual(d.variance, empirical_var, prec=0.01)\r\n```", "created_at": "2018-07-14T07:23:55Z", "updated_at": "2018-11-23T15:47:25Z", "html_url": "https://github.com/pytorch/pytorch/pull/8635#discussion_r202508735", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/8635", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/202508735"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/8635#discussion_r202508735"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/8635"}}, "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=4736342\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/fehiepsi\">@fehiepsi</a> This tests agreement between <code>LowRankMultivariateNormal</code> and <code>MultivariateNormal</code> moments, but does not actually tests moments of the generated samples. Could you add a test that checks agreement between <code>.rsample</code> and <code>(.mean, .variance)</code> with say 100000 samples? Something like this:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">def</span> <span class=\"pl-en\">test_lowrank_multivariate_normal_moments</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>):\n    mean <span class=\"pl-k\">=</span> torch.randn(<span class=\"pl-c1\">5</span>, <span class=\"pl-v\">requires_grad</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">True</span>)\n    cov_factor <span class=\"pl-k\">=</span> torch.randn(<span class=\"pl-c1\">5</span>, <span class=\"pl-c1\">2</span>, <span class=\"pl-v\">requires_grad</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">True</span>)\n    cov_diag <span class=\"pl-k\">=</span> torch.tensor(torch.randn(<span class=\"pl-c1\">5</span>).abs(), <span class=\"pl-v\">requires_grad</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">True</span>)\n    d <span class=\"pl-k\">=</span> LowRankMultivariateNormal(mean, cov_factor, cov_diag)\n    samples <span class=\"pl-k\">=</span> d.rsample((<span class=\"pl-c1\">100000</span>,))\n    empirical_mean <span class=\"pl-k\">=</span> samples.mean(<span class=\"pl-c1\">0</span>)\n    <span class=\"pl-c1\">self</span>.assertEqual(d.mean, empirical_mean, <span class=\"pl-v\">prec</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">0.01</span>)\n    empirical_var <span class=\"pl-k\">=</span> samples.var(<span class=\"pl-c1\">0</span>)\n    <span class=\"pl-c1\">self</span>.assertEqual(d.variance, empirical_var, <span class=\"pl-v\">prec</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">0.01</span>)</pre></div>", "body_text": "@fehiepsi This tests agreement between LowRankMultivariateNormal and MultivariateNormal moments, but does not actually tests moments of the generated samples. Could you add a test that checks agreement between .rsample and (.mean, .variance) with say 100000 samples? Something like this:\ndef test_lowrank_multivariate_normal_moments(self):\n    mean = torch.randn(5, requires_grad=True)\n    cov_factor = torch.randn(5, 2, requires_grad=True)\n    cov_diag = torch.tensor(torch.randn(5).abs(), requires_grad=True)\n    d = LowRankMultivariateNormal(mean, cov_factor, cov_diag)\n    samples = d.rsample((100000,))\n    empirical_mean = samples.mean(0)\n    self.assertEqual(d.mean, empirical_mean, prec=0.01)\n    empirical_var = samples.var(0)\n    self.assertEqual(d.variance, empirical_var, prec=0.01)"}