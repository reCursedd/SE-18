{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/216865330", "pull_request_review_id": 154447333, "id": 216865330, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNjg2NTMzMA==", "diff_hunk": "@@ -0,0 +1,335 @@\n+#include \"torch/csrc/jit/attributes.h\"\n+#include \"torch/csrc/jit/passes/pretty_print.h\"\n+\n+namespace torch {\n+namespace jit {\n+\n+static std::ostream& indent(std::ostream& out, size_t level) {\n+  for (size_t  i = 0; i < level; ++i) {\n+    out << \"  \";\n+  }\n+  return out;\n+}\n+\n+class PrettyPrintPass {\n+  const Graph& graph_;\n+\n+  // When printing a name if there is a conflict with an existing name in the\n+  // graph, record the value -> new generated name mapping\n+  std::unordered_map<const Value*, const Value*> aliases_;\n+\n+  // The Graph already tracks unique_names_, this is just for additional ones\n+  // generated during printing\n+  std::unordered_map<std::string, const Value*> generated_names_;\n+\n+  // Cache of value names\n+  std::unordered_map<const Value*, std::string> value_names_;\n+\n+  template <class T>\n+  void zipWith(\n+      at::ArrayRef<T> list_a,\n+      at::ArrayRef<T> list_b,\n+      std::function<void(T, T)> action) const {\n+    auto it_a = list_a.begin();\n+    auto it_b = list_b.begin();\n+\n+    if (list_a.size() != list_b.size()) {\n+      AT_ERROR(\"Pretty printer expected 2 lists of same size\");\n+    }\n+\n+    for (; it_a != list_a.end(); ++it_a, ++it_b) {\n+      action(*it_a, *it_b);\n+    }\n+  }\n+\n+  std::ostream& printValueList(\n+      std::ostream& out,\n+      at::ArrayRef<const Value*> list) {\n+    out << \"(\";\n+    auto delimiter = \"\";\n+    for (const auto* value : list) {\n+      out << delimiter;\n+      printValue(out, value);\n+      delimiter = \", \";\n+    }\n+    out << \")\";\n+    return out;\n+  }\n+\n+  void printAssignment(\n+      std::ostream& out,\n+      const Value* lhs,\n+      const Value* rhs,\n+      const size_t level) {\n+    indent(out, level);\n+    printValue(out, lhs);\n+    out << \" = \";\n+    printValue(out, rhs);\n+    out << \"\\n\";\n+  }\n+\n+  std::ostream& printIf(\n+      std::ostream& out,\n+      const Node* node,\n+      const size_t level) {\n+    indent(out, level);\n+    out << \"if \";\n+    const auto if_block = node->blocks()[0];\n+    const auto else_block = node->blocks()[1];\n+    printValue(out, node->inputs()[0]);\n+    out << \":\"\n+        << \"\\n\";\n+\n+    // Print node contents\n+    printBlock(out, if_block, level + 1);\n+\n+    // Print if block output\n+    zipWith<const Value*>(\n+        node->outputs(),\n+        if_block->outputs(),\n+        [&](const Value* node_output, const Value* return_input) {\n+          printAssignment(out, node_output, return_input, level + 1);\n+        });\n+\n+    indent(out, level);\n+    out << \"else:\\n\";\n+    printBlock(out, else_block, level + 1);\n+    zipWith<const Value*>(\n+        node->outputs(),\n+        else_block->outputs(),\n+        [&](const Value* node_output, const Value* return_input) {\n+          printAssignment(out, node_output, return_input, level + 1);\n+        });\n+\n+    return out;\n+  }\n+\n+  bool isValueUsedLater(const Value* val) const {\n+    if (aliases_.find(val) != aliases_.end()) {\n+      return true;\n+    }\n+    return val->uses().size() > 0;\n+  }\n+\n+  std::ostream& printLoop(\n+      std::ostream& out,\n+      const Node* node,\n+      const size_t level) {\n+    const auto body_block = node->blocks()[0];\n+    aliases_[body_block->inputs()[0]] = body_block->inputs()[0];\n+\n+    // Add temporaries for loop-carried dependencies\n+    zipWith<const Value*>(", "path": "torch/csrc/jit/passes/pretty_print.cpp", "position": null, "original_position": 122, "commit_id": "18b69e2bcd43668ecfbec43f1f39c956378a9608", "original_commit_id": "65a7eadd9b1ed5079dfe07a3ca50d253d79c66e3", "user": {"login": "zdevito", "id": 370202, "node_id": "MDQ6VXNlcjM3MDIwMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/370202?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zdevito", "html_url": "https://github.com/zdevito", "followers_url": "https://api.github.com/users/zdevito/followers", "following_url": "https://api.github.com/users/zdevito/following{/other_user}", "gists_url": "https://api.github.com/users/zdevito/gists{/gist_id}", "starred_url": "https://api.github.com/users/zdevito/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zdevito/subscriptions", "organizations_url": "https://api.github.com/users/zdevito/orgs", "repos_url": "https://api.github.com/users/zdevito/repos", "events_url": "https://api.github.com/users/zdevito/events{/privacy}", "received_events_url": "https://api.github.com/users/zdevito/received_events", "type": "User", "site_admin": false}, "body": "Discussed in person: This should be possible to do by using only the `node->outputs()` names to represent the loop-carried dependencies and aliasing the `block->inputs()` names to be the `node->outputs()` name in the loop:\r\n\r\n```\r\nx1 = 6\r\ny1 = 5\r\nt = 4\r\n\r\nx,y = Loop(x1, y1) \r\n         block(x2, y2)\r\n         -> (t, x2)        \r\n            \r\n\r\ncurrent:\r\n            \r\n  x2 = x1\r\n  y2 = y1\r\n  x = x2\r\n  y = y2\r\n  while ...:\r\n    <body>\r\n    x2 = t\r\n    y2 = x2\r\n    x = x2\r\n    y = y2\r\n  \r\n  \r\nx = x1\r\ny = y1  \r\nwhile ...:\r\n    <body>\r\n    x = t\r\n    y = x2\r\n```", "created_at": "2018-09-12T00:28:58Z", "updated_at": "2018-11-23T15:51:06Z", "html_url": "https://github.com/pytorch/pytorch/pull/10319#discussion_r216865330", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/10319", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/216865330"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/10319#discussion_r216865330"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/10319"}}, "body_html": "<p>Discussed in person: This should be possible to do by using only the <code>node-&gt;outputs()</code> names to represent the loop-carried dependencies and aliasing the <code>block-&gt;inputs()</code> names to be the <code>node-&gt;outputs()</code> name in the loop:</p>\n<pre><code>x1 = 6\ny1 = 5\nt = 4\n\nx,y = Loop(x1, y1) \n         block(x2, y2)\n         -&gt; (t, x2)        \n            \n\ncurrent:\n            \n  x2 = x1\n  y2 = y1\n  x = x2\n  y = y2\n  while ...:\n    &lt;body&gt;\n    x2 = t\n    y2 = x2\n    x = x2\n    y = y2\n  \n  \nx = x1\ny = y1  \nwhile ...:\n    &lt;body&gt;\n    x = t\n    y = x2\n</code></pre>", "body_text": "Discussed in person: This should be possible to do by using only the node->outputs() names to represent the loop-carried dependencies and aliasing the block->inputs() names to be the node->outputs() name in the loop:\nx1 = 6\ny1 = 5\nt = 4\n\nx,y = Loop(x1, y1) \n         block(x2, y2)\n         -> (t, x2)        \n            \n\ncurrent:\n            \n  x2 = x1\n  y2 = y1\n  x = x2\n  y = y2\n  while ...:\n    <body>\n    x2 = t\n    y2 = x2\n    x = x2\n    y = y2\n  \n  \nx = x1\ny = y1  \nwhile ...:\n    <body>\n    x = t\n    y = x2"}