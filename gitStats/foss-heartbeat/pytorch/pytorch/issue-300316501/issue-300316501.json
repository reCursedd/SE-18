{"url": "https://api.github.com/repos/pytorch/pytorch/issues/5411", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/5411/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/5411/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/5411/events", "html_url": "https://github.com/pytorch/pytorch/issues/5411", "id": 300316501, "node_id": "MDU6SXNzdWUzMDAzMTY1MDE=", "number": 5411, "title": "Integer division behavior is different from Python and NumPy", "user": {"login": "mdraw", "id": 6719909, "node_id": "MDQ6VXNlcjY3MTk5MDk=", "avatar_url": "https://avatars3.githubusercontent.com/u/6719909?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mdraw", "html_url": "https://github.com/mdraw", "followers_url": "https://api.github.com/users/mdraw/followers", "following_url": "https://api.github.com/users/mdraw/following{/other_user}", "gists_url": "https://api.github.com/users/mdraw/gists{/gist_id}", "starred_url": "https://api.github.com/users/mdraw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mdraw/subscriptions", "organizations_url": "https://api.github.com/users/mdraw/orgs", "repos_url": "https://api.github.com/users/mdraw/repos", "events_url": "https://api.github.com/users/mdraw/events{/privacy}", "received_events_url": "https://api.github.com/users/mdraw/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 424131847, "node_id": "MDU6TGFiZWw0MjQxMzE4NDc=", "url": "https://api.github.com/repos/pytorch/pytorch/labels/bug", "name": "bug", "color": "b60205", "default": true}, {"id": 443484050, "node_id": "MDU6TGFiZWw0NDM0ODQwNTA=", "url": "https://api.github.com/repos/pytorch/pytorch/labels/medium%20priority", "name": "medium priority", "color": "fbca04", "default": false}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 9, "created_at": "2018-02-26T16:57:22Z", "updated_at": "2018-09-14T17:06:42Z", "closed_at": null, "author_association": "CONTRIBUTOR", "body_html": "<ul>\n<li>PyTorch version: current master (10fd27)</li>\n<li>How you installed PyTorch (conda, pip, source): from source</li>\n<li>Python version: 3.6</li>\n</ul>\n<p>When dividing two ints in pure Python, the result is always a float, e.g.</p>\n<pre><code>&gt;&gt;&gt; x = 5 / 3\n&gt;&gt;&gt; print(x)\n1.6666666666666667\n&gt;&gt;&gt; print(type(x))\n&lt;class 'float'&gt;\n</code></pre>\n<p>NumPy shares this behavior:</p>\n<pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; x = np.array([5], dtype=np.int64) / np.array([3], dtype=np.int64)\n&gt;&gt;&gt; print(x)\n[1.66666667]\n&gt;&gt;&gt; print(x.dtype)\nfloat64\n</code></pre>\n<p>PyTorch uses floor division if both operands have integer types:</p>\n<pre><code>&gt;&gt;&gt; from torch import LongTensor\n&gt;&gt;&gt; x = torch.LongTensor([5]) / torch.LongTensor([3])\n&gt;&gt;&gt; print(x)\n\n1\n[torch.LongTensor of size (1,)]\n&gt;&gt;&gt; print(x.type())\ntorch.LongTensor\n</code></pre>\n<p>I find it confusing that PyTorch uses different division semantics than NumPy and Python. It is a potential source of bugs for users coming from a NumPy background and for users who want to port their code from NumPy to PyTorch.</p>\n<p>For floor division that keeps the integer type, Python already has the dedicated <code>//</code> operator (which is also understood by NumPy). I would propose that PyTorch changes its handling of division so that the <code>/</code> operator always performs true division and introduces the <code>//</code> operator that explicitly means floor division.</p>\n<p>I see two potential problems with changing PyTorch's division behavior like this:</p>\n<ul>\n<li>This is quite a fundamental change that can break exisiting code.</li>\n<li>There is still the open question on how to behave on Python 2 with/without <code>from __future__ import division</code>. NumPy also respects this future import, so depending on the future imports, Python 2 code can either cause the old floor-division behavior (where dividing two <code>np.*int*</code> types results in a floor division) or the new one (always perform true division). I don't know how hard it would be to mimic this behavior and if it's worth the effort.</li>\n</ul>\n<p>Despite these problems, I still believe this change is important in the long run. What do you think?</p>", "body_text": "PyTorch version: current master (10fd27)\nHow you installed PyTorch (conda, pip, source): from source\nPython version: 3.6\n\nWhen dividing two ints in pure Python, the result is always a float, e.g.\n>>> x = 5 / 3\n>>> print(x)\n1.6666666666666667\n>>> print(type(x))\n<class 'float'>\n\nNumPy shares this behavior:\n>>> import numpy as np\n>>> x = np.array([5], dtype=np.int64) / np.array([3], dtype=np.int64)\n>>> print(x)\n[1.66666667]\n>>> print(x.dtype)\nfloat64\n\nPyTorch uses floor division if both operands have integer types:\n>>> from torch import LongTensor\n>>> x = torch.LongTensor([5]) / torch.LongTensor([3])\n>>> print(x)\n\n1\n[torch.LongTensor of size (1,)]\n>>> print(x.type())\ntorch.LongTensor\n\nI find it confusing that PyTorch uses different division semantics than NumPy and Python. It is a potential source of bugs for users coming from a NumPy background and for users who want to port their code from NumPy to PyTorch.\nFor floor division that keeps the integer type, Python already has the dedicated // operator (which is also understood by NumPy). I would propose that PyTorch changes its handling of division so that the / operator always performs true division and introduces the // operator that explicitly means floor division.\nI see two potential problems with changing PyTorch's division behavior like this:\n\nThis is quite a fundamental change that can break exisiting code.\nThere is still the open question on how to behave on Python 2 with/without from __future__ import division. NumPy also respects this future import, so depending on the future imports, Python 2 code can either cause the old floor-division behavior (where dividing two np.*int* types results in a floor division) or the new one (always perform true division). I don't know how hard it would be to mimic this behavior and if it's worth the effort.\n\nDespite these problems, I still believe this change is important in the long run. What do you think?", "body": "- PyTorch version: current master (10fd27)\r\n- How you installed PyTorch (conda, pip, source): from source\r\n- Python version: 3.6\r\n\r\nWhen dividing two ints in pure Python, the result is always a float, e.g.\r\n\r\n    >>> x = 5 / 3\r\n    >>> print(x)\r\n    1.6666666666666667\r\n    >>> print(type(x))\r\n    <class 'float'>\r\n\r\nNumPy shares this behavior:\r\n\r\n    >>> import numpy as np\r\n    >>> x = np.array([5], dtype=np.int64) / np.array([3], dtype=np.int64)\r\n    >>> print(x)\r\n    [1.66666667]\r\n    >>> print(x.dtype)\r\n    float64\r\n\r\nPyTorch uses floor division if both operands have integer types:\r\n\r\n    >>> from torch import LongTensor\r\n    >>> x = torch.LongTensor([5]) / torch.LongTensor([3])\r\n    >>> print(x)\r\n\r\n    1\r\n    [torch.LongTensor of size (1,)]\r\n    >>> print(x.type())\r\n    torch.LongTensor\r\n\r\nI find it confusing that PyTorch uses different division semantics than NumPy and Python. It is a potential source of bugs for users coming from a NumPy background and for users who want to port their code from NumPy to PyTorch.\r\n\r\nFor floor division that keeps the integer type, Python already has the dedicated `//` operator (which is also understood by NumPy). I would propose that PyTorch changes its handling of division so that the `/` operator always performs true division and introduces the `//` operator that explicitly means floor division.\r\n\r\nI see two potential problems with changing PyTorch's division behavior like this:\r\n- This is quite a fundamental change that can break exisiting code.\r\n- There is still the open question on how to behave on Python 2 with/without `from __future__ import division`. NumPy also respects this future import, so depending on the future imports, Python 2 code can either cause the old floor-division behavior (where dividing two `np.*int*` types results in a floor division) or the new one (always perform true division). I don't know how hard it would be to mimic this behavior and if it's worth the effort.\r\n\r\nDespite these problems, I still believe this change is important in the long run. What do you think?"}