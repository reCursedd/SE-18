{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/362296090", "html_url": "https://github.com/pytorch/pytorch/pull/4594#issuecomment-362296090", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/4594", "id": 362296090, "node_id": "MDEyOklzc3VlQ29tbWVudDM2MjI5NjA5MA==", "user": {"login": "prigoyal", "id": 13488275, "node_id": "MDQ6VXNlcjEzNDg4Mjc1", "avatar_url": "https://avatars0.githubusercontent.com/u/13488275?v=4", "gravatar_id": "", "url": "https://api.github.com/users/prigoyal", "html_url": "https://github.com/prigoyal", "followers_url": "https://api.github.com/users/prigoyal/followers", "following_url": "https://api.github.com/users/prigoyal/following{/other_user}", "gists_url": "https://api.github.com/users/prigoyal/gists{/gist_id}", "starred_url": "https://api.github.com/users/prigoyal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/prigoyal/subscriptions", "organizations_url": "https://api.github.com/users/prigoyal/orgs", "repos_url": "https://api.github.com/users/prigoyal/repos", "events_url": "https://api.github.com/users/prigoyal/events{/privacy}", "received_events_url": "https://api.github.com/users/prigoyal/received_events", "type": "User", "site_admin": false}, "created_at": "2018-02-01T15:14:31Z", "updated_at": "2018-02-01T15:15:07Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=4583066\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/apaszke\">@apaszke</a> <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=13564\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/ezyang\">@ezyang</a> thanks for the discussion, should we go ahead with the imperative() backward? given the issues we are discussing here need to be addressed and out of the scope of adding this feature of checkpointing models.</p>\n<p>It makes sense to me that checkpointing() does imperative backward() if the non-checkpointed a.k.a. original model does imperative backward too.</p>\n<p>If we have an agreement on this, I can update the PR to have <code>torch.autograd.backward</code></p>", "body_text": "@apaszke @ezyang thanks for the discussion, should we go ahead with the imperative() backward? given the issues we are discussing here need to be addressed and out of the scope of adding this feature of checkpointing models.\nIt makes sense to me that checkpointing() does imperative backward() if the non-checkpointed a.k.a. original model does imperative backward too.\nIf we have an agreement on this, I can update the PR to have torch.autograd.backward", "body": "@apaszke @ezyang thanks for the discussion, should we go ahead with the imperative() backward? given the issues we are discussing here need to be addressed and out of the scope of adding this feature of checkpointing models. \r\n\r\nIt makes sense to me that checkpointing() does imperative backward() if the non-checkpointed a.k.a. original model does imperative backward too. \r\n\r\nIf we have an agreement on this, I can update the PR to have `torch.autograd.backward`"}