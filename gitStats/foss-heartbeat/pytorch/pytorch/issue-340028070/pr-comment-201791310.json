{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/201791310", "pull_request_review_id": 136352248, "id": 201791310, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMTc5MTMxMA==", "diff_hunk": "@@ -182,11 +185,58 @@ struct Parser {\n       L.expect(end);\n     return List<T>::create(r, elements);\n   }\n+\n   Const parseConst() {\n     auto range = L.cur().range;\n     auto t = L.expect(TK_NUMBER);\n     return Const::create(t.range, t.text());\n   }\n+\n+  bool isCharCount(char c, const std::string& str, size_t start, int len) {\n+    //count checks from [start, start + len) \n+    return start + len <= str.size() && std::count(str.begin() + start, str.begin() + start + len, c) == len; \n+  }\n+\n+  std::string parseLexedString(const std::string &str, size_t start) {", "path": "torch/csrc/jit/script/parser.h", "position": null, "original_position": 26, "commit_id": "e905658d61f902d3c9b75bf08d2504eb7e7b3e6f", "original_commit_id": "b2decb1ecffef6120bd76460622caa004bf0bac0", "user": {"login": "zdevito", "id": 370202, "node_id": "MDQ6VXNlcjM3MDIwMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/370202?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zdevito", "html_url": "https://github.com/zdevito", "followers_url": "https://api.github.com/users/zdevito/followers", "following_url": "https://api.github.com/users/zdevito/following{/other_user}", "gists_url": "https://api.github.com/users/zdevito/gists{/gist_id}", "starred_url": "https://api.github.com/users/zdevito/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zdevito/subscriptions", "organizations_url": "https://api.github.com/users/zdevito/orgs", "repos_url": "https://api.github.com/users/zdevito/repos", "events_url": "https://api.github.com/users/zdevito/events{/privacy}", "received_events_url": "https://api.github.com/users/zdevito/received_events", "type": "User", "site_admin": false}, "body": "There are two separate things here:\r\n\r\n1. We need to parse the literal quotation into the string it represents. The lexer only returns ranges into the original token stream, so it is impossible for the lexer to handle this. So it has to be done here.\r\n2. We need to handle multiple adjacent strings. I think this is best handled by representing each string as a separate token:\r\n\r\n```\r\nstd::string parseStringLiteral() {\r\n  std::stringstream ss;\r\n  while(L.cur().kind == TK_STRING_LITERAL)\r\n     ss << parseString(L.next().text());\r\n  return ss.str();\r\n} \r\n```", "created_at": "2018-07-11T18:13:08Z", "updated_at": "2018-11-23T15:47:09Z", "html_url": "https://github.com/pytorch/pytorch/pull/9324#discussion_r201791310", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/9324", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/201791310"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/9324#discussion_r201791310"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/9324"}}, "body_html": "<p>There are two separate things here:</p>\n<ol>\n<li>We need to parse the literal quotation into the string it represents. The lexer only returns ranges into the original token stream, so it is impossible for the lexer to handle this. So it has to be done here.</li>\n<li>We need to handle multiple adjacent strings. I think this is best handled by representing each string as a separate token:</li>\n</ol>\n<pre><code>std::string parseStringLiteral() {\n  std::stringstream ss;\n  while(L.cur().kind == TK_STRING_LITERAL)\n     ss &lt;&lt; parseString(L.next().text());\n  return ss.str();\n} \n</code></pre>", "body_text": "There are two separate things here:\n\nWe need to parse the literal quotation into the string it represents. The lexer only returns ranges into the original token stream, so it is impossible for the lexer to handle this. So it has to be done here.\nWe need to handle multiple adjacent strings. I think this is best handled by representing each string as a separate token:\n\nstd::string parseStringLiteral() {\n  std::stringstream ss;\n  while(L.cur().kind == TK_STRING_LITERAL)\n     ss << parseString(L.next().text());\n  return ss.str();\n}", "in_reply_to_id": 201761678}