{"url": "https://api.github.com/repos/pytorch/pytorch/issues/6055", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/6055/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/6055/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/6055/events", "html_url": "https://github.com/pytorch/pytorch/issues/6055", "id": 309149162, "node_id": "MDU6SXNzdWUzMDkxNDkxNjI=", "number": 6055, "title": "Better debug info from C++", "user": {"login": "goldsborough", "id": 6429851, "node_id": "MDQ6VXNlcjY0Mjk4NTE=", "avatar_url": "https://avatars3.githubusercontent.com/u/6429851?v=4", "gravatar_id": "", "url": "https://api.github.com/users/goldsborough", "html_url": "https://github.com/goldsborough", "followers_url": "https://api.github.com/users/goldsborough/followers", "following_url": "https://api.github.com/users/goldsborough/following{/other_user}", "gists_url": "https://api.github.com/users/goldsborough/gists{/gist_id}", "starred_url": "https://api.github.com/users/goldsborough/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/goldsborough/subscriptions", "organizations_url": "https://api.github.com/users/goldsborough/orgs", "repos_url": "https://api.github.com/users/goldsborough/repos", "events_url": "https://api.github.com/users/goldsborough/events{/privacy}", "received_events_url": "https://api.github.com/users/goldsborough/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2018-03-27T21:59:33Z", "updated_at": "2018-03-31T14:39:13Z", "closed_at": "2018-03-31T14:39:13Z", "author_association": "CONTRIBUTOR", "body_html": "<h2>TL;DR: We would like more informative stack traces from exceptions thrown on the C++ side.</h2>\n<h3>Problem Description</h3>\n<p>The autograd engine launches 1 + #gpus threads to execute functions. This has the downside that when an exception gets thrown in any of the functions running in one of these threads, we currently have to catch that exception and rethrow it from the main thread. The unfortunate consequence of this is that all stack traces point back to <a href=\"https://github.com/pytorch/pytorch/blob/b37aa2bf0e1d0fc62a7a924c0b50fe06870c1bce/torch/csrc/autograd/engine.cpp#L358\">the line where the exception is rethrown</a>.</p>\n<h3>Possible Solutions</h3>\n<ol>\n<li>Change the autograd engine to have a mode where it executes all tasks on the main thread,</li>\n<li>Use custom exception objects everywhere and capture either:\n<ol>\n<li>The <code>__LINE__</code> and <code>__FILE__</code> info or,</li>\n<li>The full call stack (likely preferred) using <a href=\"http://man7.org/linux/man-pages/man3/backtrace.3.html\" rel=\"nofollow\">the kernel's relevant facilities for this</a></li>\n</ol>\n</li>\n<li>Tell people to use <code>catch throw</code></li>\n</ol>\n<h3>Goal</h3>\n<p>In the end, the experience should really be as smooth as possible for the end user. <code>catch throw</code> will work most of the time, but people might not know about it or it may not help with debugging. Having to change the autograd execution and re-run the graph is a bit annoying. Giving the full call stack in the exception is likely the most user-friendly option, but <code>__LINE__</code> et al. is a good start.</p>\n<p>CC <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=3605224\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/ebetica\">@ebetica</a></p>", "body_text": "TL;DR: We would like more informative stack traces from exceptions thrown on the C++ side.\nProblem Description\nThe autograd engine launches 1 + #gpus threads to execute functions. This has the downside that when an exception gets thrown in any of the functions running in one of these threads, we currently have to catch that exception and rethrow it from the main thread. The unfortunate consequence of this is that all stack traces point back to the line where the exception is rethrown.\nPossible Solutions\n\nChange the autograd engine to have a mode where it executes all tasks on the main thread,\nUse custom exception objects everywhere and capture either:\n\nThe __LINE__ and __FILE__ info or,\nThe full call stack (likely preferred) using the kernel's relevant facilities for this\n\n\nTell people to use catch throw\n\nGoal\nIn the end, the experience should really be as smooth as possible for the end user. catch throw will work most of the time, but people might not know about it or it may not help with debugging. Having to change the autograd execution and re-run the graph is a bit annoying. Giving the full call stack in the exception is likely the most user-friendly option, but __LINE__ et al. is a good start.\nCC @ebetica", "body": "## TL;DR: We would like more informative stack traces from exceptions thrown on the C++ side. \r\n\r\n### Problem Description\r\n\r\nThe autograd engine launches 1 + #gpus threads to execute functions. This has the downside that when an exception gets thrown in any of the functions running in one of these threads, we currently have to catch that exception and rethrow it from the main thread. The unfortunate consequence of this is that all stack traces point back to [the line where the exception is rethrown](https://github.com/pytorch/pytorch/blob/b37aa2bf0e1d0fc62a7a924c0b50fe06870c1bce/torch/csrc/autograd/engine.cpp#L358).\r\n\r\n### Possible Solutions\r\n\r\n1. Change the autograd engine to have a mode where it executes all tasks on the main thread,\r\n2. Use custom exception objects everywhere and capture either:\r\n    1. The `__LINE__` and `__FILE__` info or,\r\n    2. The full call stack (likely preferred) using [the kernel's relevant facilities for this](http://man7.org/linux/man-pages/man3/backtrace.3.html)\r\n3. Tell people to use `catch throw`\r\n\r\n### Goal\r\n\r\nIn the end, the experience should really be as smooth as possible for the end user. `catch throw` will work most of the time, but people might not know about it or it may not help with debugging. Having to change the autograd execution and re-run the graph is a bit annoying. Giving the full call stack in the exception is likely the most user-friendly option, but `__LINE__` et al. is a good start.\r\n\r\nCC @ebetica "}