{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/234108618", "pull_request_review_id": 175680060, "id": 234108618, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNDEwODYxOA==", "diff_hunk": "@@ -0,0 +1,212 @@\n+#pragma once\n+\n+#include <c10/util/ArrayRef.h>\n+#include <c10/Half.h>\n+#include <c10/util/typeid.h>\n+\n+#include <cstdint>\n+#include <iostream>\n+#include <complex>\n+\n+namespace at {\n+class Tensor;\n+}\n+\n+namespace c10 {\n+\n+// NB: Order matters for this macro; it is relied upon in\n+// _promoteTypesLookup and the serialization format.\n+#define AT_FORALL_SCALAR_TYPES_WITH_COMPLEX(_) \\\n+_(uint8_t,Byte,i)  /* 0 */ \\\n+_(int8_t,Char,i)   /* 1 */ \\\n+_(int16_t,Short,i) /* 2 */ \\\n+_(int,Int,i)       /* 3 */ \\\n+_(int64_t,Long,i)  /* 4 */ \\\n+_(at::Half,Half,d) /* 5 */ \\\n+_(float,Float,d)   /* 6 */ \\\n+_(double,Double,d) /* 7 */ \\\n+_(at::ComplexHalf,ComplexHalf,z)        /* 8 */ \\\n+_(std::complex<float>,ComplexFloat,z)   /* 9 */ \\\n+_(std::complex<double>,ComplexDouble,z) /* 10 */\n+\n+// If you want to support ComplexHalf for real, replace occurrences\n+// of this macro with AT_FORALL_SCALAR_TYPES_WITH_COMPLEX.  But\n+// beware: convert() doesn't work for all the conversions you need...\n+#define AT_FORALL_SCALAR_TYPES_WITH_COMPLEX_EXCEPT_COMPLEX_HALF(_) \\\n+_(uint8_t,Byte,i)  \\\n+_(int8_t,Char,i)   \\\n+_(int16_t,Short,i) \\\n+_(int,Int,i)       \\\n+_(int64_t,Long,i)  \\\n+_(at::Half,Half,d) \\\n+_(float,Float,d)   \\\n+_(double,Double,d) \\\n+_(std::complex<float>,ComplexFloat,z) \\\n+_(std::complex<double>,ComplexDouble,z)\n+\n+#define AT_FORALL_SCALAR_TYPES(_) \\\n+_(uint8_t,Byte,i)  \\\n+_(int8_t,Char,i)   \\\n+_(int16_t,Short,i) \\\n+_(int,Int,i)       \\\n+_(int64_t,Long,i)  \\\n+_(at::Half,Half,d) \\\n+_(float,Float,d)   \\\n+_(double,Double,d)\n+\n+#define AT_FORALL_SCALAR_TYPES_EXCEPT_HALF(_) \\\n+_(uint8_t,Byte,i) \\\n+_(int8_t,Char,i) \\\n+_(int16_t,Short,i) \\\n+_(int,Int,i) \\\n+_(int64_t,Long,i) \\\n+_(float,Float,d) \\\n+_(double,Double,d)\n+\n+enum class ScalarType : int8_t {\n+#define DEFINE_ENUM(_1,n,_2) \\\n+  n,\n+  AT_FORALL_SCALAR_TYPES_WITH_COMPLEX(DEFINE_ENUM)\n+#undef DEFINE_ENUM\n+  Undefined,\n+  NumOptions\n+};\n+\n+static inline at::DataType scalarTypeToDataType(ScalarType scalar_type) {\n+#define DEFINE_CASE(ctype, name, _) \\\n+  case ScalarType::name:            \\\n+    return caffe2::TypeIdentifier::Get<ctype>();\n+\n+  switch(scalar_type) {\n+    AT_FORALL_SCALAR_TYPES_WITH_COMPLEX(DEFINE_CASE)\n+    case ScalarType::Undefined: return at::DataType::uninitialized();\n+    default: AT_ERROR(\"Unrecognized Scalartype \", scalar_type, \" (please report this error)\");\n+  }\n+#undef DEFINE_CASE\n+}\n+\n+static inline caffe2::TypeMeta scalarTypeToTypeMeta(ScalarType scalar_type) {\n+#define DEFINE_CASE(ctype,name,_) \\\n+  case ScalarType:: name : return caffe2::TypeMeta::Make<ctype>();\n+\n+  switch(scalar_type) {\n+    AT_FORALL_SCALAR_TYPES_WITH_COMPLEX(DEFINE_CASE)\n+    case ScalarType::Undefined: return caffe2::TypeMeta();\n+    default: AT_ERROR(\"Unrecognized Scalartype \", scalar_type, \" (please report this error)\");\n+  }\n+#undef DEFINE_CASE\n+}\n+\n+static inline ScalarType typeMetaToScalarType(caffe2::TypeMeta dtype) {\n+#define DEFINE_IF(ctype, name, _)                      \\\n+  if (dtype == caffe2::TypeMeta::Make<ctype>()) { \\\n+    return ScalarType::name;                           \\\n+  }\n+  AT_FORALL_SCALAR_TYPES_WITH_COMPLEX(DEFINE_IF)\n+#undef DEFINE_IF\n+  if (dtype == caffe2::TypeMeta()) {\n+    return ScalarType::Undefined;\n+  }\n+  AT_ERROR(\"Unsupported TypeMeta in ATen: \", dtype, \" (please report this error)\");\n+}\n+\n+static inline bool operator==(ScalarType t, caffe2::TypeMeta m) {\n+  return typeMetaToScalarType(m) == t;\n+}\n+\n+static inline bool operator==(caffe2::TypeMeta m, ScalarType t) {\n+  return typeMetaToScalarType(m) == t;\n+}\n+\n+#define DEFINE_CONSTANT(_,name,_2) \\\n+constexpr ScalarType k##name = ScalarType::name;\n+\n+AT_FORALL_SCALAR_TYPES_WITH_COMPLEX(DEFINE_CONSTANT)\n+#undef DEFINE_CONSTANT\n+\n+static inline const char * toString(ScalarType t) {\n+#define DEFINE_CASE(_,name,_2) \\\n+  case ScalarType:: name : return #name;\n+\n+  switch(t) {\n+    AT_FORALL_SCALAR_TYPES_WITH_COMPLEX(DEFINE_CASE)\n+    default:\n+      return \"UNKNOWN_SCALAR\";\n+  }\n+#undef DEFINE_CASE\n+}\n+\n+static inline size_t elementSize(ScalarType t) {\n+#define CASE_ELEMENTSIZE_CASE(ctype,name,_2) \\\n+  case ScalarType:: name : return sizeof(ctype);\n+\n+  switch(t) {\n+    AT_FORALL_SCALAR_TYPES_WITH_COMPLEX(CASE_ELEMENTSIZE_CASE)\n+    default:\n+      AT_ERROR(\"Unknown ScalarType\");\n+  }\n+#undef CASE_ELEMENTSIZE_CASE\n+}\n+\n+static inline bool isIntegralType(ScalarType t) {\n+  return (t == ScalarType::Byte ||\n+          t == ScalarType::Char ||\n+          t == ScalarType::Int ||\n+          t == ScalarType::Long ||\n+          t == ScalarType::Short);\n+}\n+\n+static inline bool isFloatingType(ScalarType t) {\n+  return (t == ScalarType::Double ||\n+          t == ScalarType::Float ||\n+          t == ScalarType::Half);\n+}\n+\n+static inline bool isComplexType(ScalarType t) {\n+  return (t == ScalarType::ComplexHalf ||\n+          t == ScalarType::ComplexFloat ||\n+          t == ScalarType::ComplexDouble);\n+}\n+\n+static inline ScalarType promoteTypes(ScalarType a, ScalarType b) {\n+  // This is generated according to NumPy's promote_types\n+  constexpr auto u1 = ScalarType::Byte;\n+  constexpr auto i1 = ScalarType::Char;\n+  constexpr auto i2 = ScalarType::Short;\n+  constexpr auto i4 = ScalarType::Int;\n+  constexpr auto i8 = ScalarType::Long;\n+  constexpr auto f2 = ScalarType::Half;\n+  constexpr auto f4 = ScalarType::Float;\n+  constexpr auto f8 = ScalarType::Double;\n+  constexpr auto ud = ScalarType::Undefined;\n+  if (a == ud || b == ud) {\n+    return ScalarType::Undefined;\n+  }\n+  if (isComplexType(a) || isComplexType(b)) {\n+    AT_ERROR(\"promoteTypes with complex numbers is not handled yet; figure out what the correct rules should be\");\n+  }\n+  static constexpr ScalarType _promoteTypesLookup\n+      [static_cast<int>(ScalarType::NumOptions)]\n+      [static_cast<int>(ScalarType::NumOptions)] = {\n+            /* u1  i1  i2  i4  i8  f2  f4  f8 */\n+    /* u1 */ { u1, i2, i2, i4, i8, f2, f4, f8 },\n+    /* i1 */ { i2, i1, i2, i4, i8, f2, f4, f8 },\n+    /* i2 */ { i2, i2, i2, i4, i8, f2, f4, f8 },\n+    /* i4 */ { i4, i4, i4, i4, i8, f2, f4, f8 },\n+    /* i8 */ { i8, i8, i8, i8, i8, f2, f4, f8 },\n+    /* f2 */ { f2, f2, f2, f2, f2, f2, f4, f8 },\n+    /* f4 */ { f4, f4, f4, f4, f4, f4, f4, f8 },\n+    /* f8 */ { f8, f8, f8, f8, f8, f8, f8, f8 },\n+  };\n+  return _promoteTypesLookup[static_cast<int>(a)][static_cast<int>(b)];\n+}\n+\n+typedef ArrayRef<at::Tensor> TensorList;", "path": "c10/core/ScalarType.h", "position": 204, "original_position": 204, "commit_id": "71eeab644d0e7509ed409f31683ec3dfadf57e3a", "original_commit_id": "f264d6fbb034f8e0112d3337deeb7538c67788c5", "user": {"login": "dzhulgakov", "id": 17890620, "node_id": "MDQ6VXNlcjE3ODkwNjIw", "avatar_url": "https://avatars2.githubusercontent.com/u/17890620?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dzhulgakov", "html_url": "https://github.com/dzhulgakov", "followers_url": "https://api.github.com/users/dzhulgakov/followers", "following_url": "https://api.github.com/users/dzhulgakov/following{/other_user}", "gists_url": "https://api.github.com/users/dzhulgakov/gists{/gist_id}", "starred_url": "https://api.github.com/users/dzhulgakov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dzhulgakov/subscriptions", "organizations_url": "https://api.github.com/users/dzhulgakov/orgs", "repos_url": "https://api.github.com/users/dzhulgakov/repos", "events_url": "https://api.github.com/users/dzhulgakov/events{/privacy}", "received_events_url": "https://api.github.com/users/dzhulgakov/received_events", "type": "User", "site_admin": false}, "body": "btw, why is it in ScalarType.h?", "created_at": "2018-11-16T07:16:53Z", "updated_at": "2018-11-23T15:55:00Z", "html_url": "https://github.com/pytorch/pytorch/pull/14022#discussion_r234108618", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/14022", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/234108618"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/14022#discussion_r234108618"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/14022"}}, "body_html": "<p>btw, why is it in ScalarType.h?</p>", "body_text": "btw, why is it in ScalarType.h?"}