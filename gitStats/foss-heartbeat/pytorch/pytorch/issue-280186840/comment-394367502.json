{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/394367502", "html_url": "https://github.com/pytorch/pytorch/issues/4073#issuecomment-394367502", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/4073", "id": 394367502, "node_id": "MDEyOklzc3VlQ29tbWVudDM5NDM2NzUwMg==", "user": {"login": "ClementPinard", "id": 4380424, "node_id": "MDQ6VXNlcjQzODA0MjQ=", "avatar_url": "https://avatars2.githubusercontent.com/u/4380424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ClementPinard", "html_url": "https://github.com/ClementPinard", "followers_url": "https://api.github.com/users/ClementPinard/followers", "following_url": "https://api.github.com/users/ClementPinard/following{/other_user}", "gists_url": "https://api.github.com/users/ClementPinard/gists{/gist_id}", "starred_url": "https://api.github.com/users/ClementPinard/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ClementPinard/subscriptions", "organizations_url": "https://api.github.com/users/ClementPinard/orgs", "repos_url": "https://api.github.com/users/ClementPinard/repos", "events_url": "https://api.github.com/users/ClementPinard/events{/privacy}", "received_events_url": "https://api.github.com/users/ClementPinard/received_events", "type": "User", "site_admin": false}, "created_at": "2018-06-04T14:08:17Z", "updated_at": "2018-06-04T14:10:38Z", "author_association": "NONE", "body_html": "<p>Here is a pytorch way of seeing how can things be done, displacement diameter is D, kernel size is K, padding and stride are ignored for clarity<br>\nOutput is of size BxD^2xHxW but I think  giving an output of size BxDxDxHxW would be semantically better if this module is to be used in other application than FlowNetC</p>\n<p>1st solution :</p>\n<div class=\"highlight highlight-source-python\"><pre>d <span class=\"pl-k\">=</span> (D<span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>)<span class=\"pl-k\">/</span><span class=\"pl-c1\">2</span>\n<span class=\"pl-k\">for</span> i <span class=\"pl-k\">in</span> <span class=\"pl-c1\">range</span>(<span class=\"pl-k\">-</span>d, d):\n    <span class=\"pl-k\">for</span> j <span class=\"pl-k\">in</span> <span class=\"pl-c1\">range</span>(<span class=\"pl-k\">-</span>d, d):\n        output[:, i<span class=\"pl-k\">+</span> D<span class=\"pl-k\">*</span>j, :, :] <span class=\"pl-k\">=</span> torch.sum(input1 <span class=\"pl-k\">*</span> input2[:, :, i:, j:], <span class=\"pl-v\">dim</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">1</span>)  <span class=\"pl-c\"><span class=\"pl-c\">#</span> [B, D^2, H, W]</span>\nfinal_output <span class=\"pl-k\">=</span> F.avgpool2d(output, <span class=\"pl-v\">kernel_size</span> <span class=\"pl-k\">=</span> K, <span class=\"pl-v\">stride</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">1</span>)  <span class=\"pl-c\"><span class=\"pl-c\">#</span> padding ignored for clarity</span></pre></div>\n<p>2nd solution :</p>\n<div class=\"highlight highlight-source-python\"><pre>rinput1 <span class=\"pl-k\">=</span> input1.transpose(<span class=\"pl-c1\">0</span>,<span class=\"pl-c1\">2</span>,<span class=\"pl-c1\">3</span>,<span class=\"pl-c1\">1</span>)  <span class=\"pl-c\"><span class=\"pl-c\">#</span> [B, H, W, C]</span>\nrinput2 <span class=\"pl-k\">=</span> input2.transpose(<span class=\"pl-c1\">0</span>,<span class=\"pl-c1\">2</span>,<span class=\"pl-c1\">3</span>,<span class=\"pl-c1\">1</span>)  <span class=\"pl-c\"><span class=\"pl-c\">#</span> [B, H, W, C]</span>\n\n<span class=\"pl-k\">for</span> b <span class=\"pl-k\">in</span> <span class=\"pl-c1\">range</span>(B):\n    <span class=\"pl-k\">for</span> i <span class=\"pl-k\">in</span> <span class=\"pl-c1\">range</span>(H):\n        <span class=\"pl-k\">for</span> j <span class=\"pl-k\">in</span> <span class=\"pl-c1\">range</span>(W):\n            <span class=\"pl-k\">for</span> k <span class=\"pl-k\">in</span> <span class=\"pl-c1\">range</span>(<span class=\"pl-k\">-</span>d, d):\n                <span class=\"pl-k\">for</span> l <span class=\"pl-k\">in</span> <span class=\"pl-c1\">range</span>(<span class=\"pl-k\">-</span>d, d):\n                    <span class=\"pl-c\"><span class=\"pl-c\">#</span> rinput1[b, i:i+K, j:j+K] is a patch of size [K, K, C]</span>\n                    output[b, k <span class=\"pl-k\">+</span> D<span class=\"pl-k\">*</span>l, i, j] <span class=\"pl-k\">=</span> torch.sum(rinput1[b, i:i<span class=\"pl-k\">+</span>K, j:j<span class=\"pl-k\">+</span>K] <span class=\"pl-k\">*</span> rinput2[b, i<span class=\"pl-k\">+</span>k:i<span class=\"pl-k\">+</span>k<span class=\"pl-k\">+</span>K, j<span class=\"pl-k\">+</span>l:j<span class=\"pl-k\">+</span>l<span class=\"pl-k\">+</span>K])</pre></div>", "body_text": "Here is a pytorch way of seeing how can things be done, displacement diameter is D, kernel size is K, padding and stride are ignored for clarity\nOutput is of size BxD^2xHxW but I think  giving an output of size BxDxDxHxW would be semantically better if this module is to be used in other application than FlowNetC\n1st solution :\nd = (D-1)/2\nfor i in range(-d, d):\n    for j in range(-d, d):\n        output[:, i+ D*j, :, :] = torch.sum(input1 * input2[:, :, i:, j:], dim=1)  # [B, D^2, H, W]\nfinal_output = F.avgpool2d(output, kernel_size = K, stride=1)  # padding ignored for clarity\n2nd solution :\nrinput1 = input1.transpose(0,2,3,1)  # [B, H, W, C]\nrinput2 = input2.transpose(0,2,3,1)  # [B, H, W, C]\n\nfor b in range(B):\n    for i in range(H):\n        for j in range(W):\n            for k in range(-d, d):\n                for l in range(-d, d):\n                    # rinput1[b, i:i+K, j:j+K] is a patch of size [K, K, C]\n                    output[b, k + D*l, i, j] = torch.sum(rinput1[b, i:i+K, j:j+K] * rinput2[b, i+k:i+k+K, j+l:j+l+K])", "body": "Here is a pytorch way of seeing how can things be done, displacement diameter is D, kernel size is K, padding and stride are ignored for clarity\r\nOutput is of size BxD^2xHxW but I think  giving an output of size BxDxDxHxW would be semantically better if this module is to be used in other application than FlowNetC\r\n\r\n1st solution :\r\n```python\r\nd = (D-1)/2\r\nfor i in range(-d, d):\r\n    for j in range(-d, d):\r\n        output[:, i+ D*j, :, :] = torch.sum(input1 * input2[:, :, i:, j:], dim=1)  # [B, D^2, H, W]\r\nfinal_output = F.avgpool2d(output, kernel_size = K, stride=1)  # padding ignored for clarity\r\n```\r\n\r\n2nd solution :\r\n```python\r\nrinput1 = input1.transpose(0,2,3,1)  # [B, H, W, C]\r\nrinput2 = input2.transpose(0,2,3,1)  # [B, H, W, C]\r\n\r\nfor b in range(B):\r\n    for i in range(H):\r\n        for j in range(W):\r\n            for k in range(-d, d):\r\n                for l in range(-d, d):\r\n                    # rinput1[b, i:i+K, j:j+K] is a patch of size [K, K, C]\r\n                    output[b, k + D*l, i, j] = torch.sum(rinput1[b, i:i+K, j:j+K] * rinput2[b, i+k:i+k+K, j+l:j+l+K])\r\n```"}