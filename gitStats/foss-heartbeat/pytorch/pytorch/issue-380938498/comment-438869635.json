{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/438869635", "html_url": "https://github.com/pytorch/pytorch/issues/14000#issuecomment-438869635", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/14000", "id": 438869635, "node_id": "MDEyOklzc3VlQ29tbWVudDQzODg2OTYzNQ==", "user": {"login": "goldsborough", "id": 6429851, "node_id": "MDQ6VXNlcjY0Mjk4NTE=", "avatar_url": "https://avatars3.githubusercontent.com/u/6429851?v=4", "gravatar_id": "", "url": "https://api.github.com/users/goldsborough", "html_url": "https://github.com/goldsborough", "followers_url": "https://api.github.com/users/goldsborough/followers", "following_url": "https://api.github.com/users/goldsborough/following{/other_user}", "gists_url": "https://api.github.com/users/goldsborough/gists{/gist_id}", "starred_url": "https://api.github.com/users/goldsborough/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/goldsborough/subscriptions", "organizations_url": "https://api.github.com/users/goldsborough/orgs", "repos_url": "https://api.github.com/users/goldsborough/repos", "events_url": "https://api.github.com/users/goldsborough/events{/privacy}", "received_events_url": "https://api.github.com/users/goldsborough/received_events", "type": "User", "site_admin": false}, "created_at": "2018-11-15T00:27:35Z", "updated_at": "2018-11-15T00:27:35Z", "author_association": "CONTRIBUTOR", "body_html": "<p>I will add documentation for it. In the meantime, the definition for it is <a href=\"https://github.com/pytorch/pytorch/blob/master/tools/autograd/templates/variable_factories.h#L41\">here</a>. The first argument is a <code>void*</code> and should point to a flat region of memory. You could first convert your nested vector into a flat vector by looping through each element and copying it into the new vector, and then use <code>from_blob</code> by passing it <code>flat_vector.data()</code> where <code>flat_vector</code> is your flattened C++ <code>std::vector</code>. Although if you're already going to copy, you're probably better off just creating an empty tensor and copying into it:</p>\n<div class=\"highlight highlight-source-c++\"><pre><span class=\"pl-k\">auto</span> blob = j.get&lt;vector&lt;vector&lt;vector&lt;vector&lt;<span class=\"pl-k\">float</span>&gt;&gt;&gt;&gt;&gt;();\n<span class=\"pl-k\">auto</span> tensor = torch::empty(<span class=\"pl-c1\">1</span> * <span class=\"pl-c1\">3</span> * <span class=\"pl-c1\">28</span> * <span class=\"pl-c1\">28</span>);\n<span class=\"pl-k\">float</span>* data = tensor.data&lt;<span class=\"pl-k\">float</span>&gt;();\n<span class=\"pl-k\">for</span> (<span class=\"pl-k\">const</span> <span class=\"pl-k\">auto</span>&amp; i : blob) {\n    (<span class=\"pl-k\">for</span> <span class=\"pl-k\">const</span> <span class=\"pl-k\">auto</span>&amp; j : i) {\n        <span class=\"pl-k\">for</span> (<span class=\"pl-k\">const</span> <span class=\"pl-k\">auto</span>&amp; k : j) {\n            <span class=\"pl-k\">for</span> (<span class=\"pl-k\">const</span> <span class=\"pl-k\">auto</span>&amp; l : k) {\n                *data++ = l;\n            }\n        }\n    }\n}\n\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> do things with tensor</span></pre></div>", "body_text": "I will add documentation for it. In the meantime, the definition for it is here. The first argument is a void* and should point to a flat region of memory. You could first convert your nested vector into a flat vector by looping through each element and copying it into the new vector, and then use from_blob by passing it flat_vector.data() where flat_vector is your flattened C++ std::vector. Although if you're already going to copy, you're probably better off just creating an empty tensor and copying into it:\nauto blob = j.get<vector<vector<vector<vector<float>>>>>();\nauto tensor = torch::empty(1 * 3 * 28 * 28);\nfloat* data = tensor.data<float>();\nfor (const auto& i : blob) {\n    (for const auto& j : i) {\n        for (const auto& k : j) {\n            for (const auto& l : k) {\n                *data++ = l;\n            }\n        }\n    }\n}\n\n// do things with tensor", "body": "I will add documentation for it. In the meantime, the definition for it is [here](https://github.com/pytorch/pytorch/blob/master/tools/autograd/templates/variable_factories.h#L41). The first argument is a `void*` and should point to a flat region of memory. You could first convert your nested vector into a flat vector by looping through each element and copying it into the new vector, and then use `from_blob` by passing it `flat_vector.data()` where `flat_vector` is your flattened C++ `std::vector`. Although if you're already going to copy, you're probably better off just creating an empty tensor and copying into it:\r\n\r\n```cpp\r\nauto blob = j.get<vector<vector<vector<vector<float>>>>>();\r\nauto tensor = torch::empty(1 * 3 * 28 * 28);\r\nfloat* data = tensor.data<float>();\r\nfor (const auto& i : blob) {\r\n    (for const auto& j : i) {\r\n        for (const auto& k : j) {\r\n            for (const auto& l : k) {\r\n                *data++ = l;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// do things with tensor\r\n```"}