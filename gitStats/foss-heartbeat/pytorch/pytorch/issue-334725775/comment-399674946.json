{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/399674946", "html_url": "https://github.com/pytorch/pytorch/issues/8781#issuecomment-399674946", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/8781", "id": 399674946, "node_id": "MDEyOklzc3VlQ29tbWVudDM5OTY3NDk0Ng==", "user": {"login": "zasdfgbnm", "id": 1032377, "node_id": "MDQ6VXNlcjEwMzIzNzc=", "avatar_url": "https://avatars2.githubusercontent.com/u/1032377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zasdfgbnm", "html_url": "https://github.com/zasdfgbnm", "followers_url": "https://api.github.com/users/zasdfgbnm/followers", "following_url": "https://api.github.com/users/zasdfgbnm/following{/other_user}", "gists_url": "https://api.github.com/users/zasdfgbnm/gists{/gist_id}", "starred_url": "https://api.github.com/users/zasdfgbnm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zasdfgbnm/subscriptions", "organizations_url": "https://api.github.com/users/zasdfgbnm/orgs", "repos_url": "https://api.github.com/users/zasdfgbnm/repos", "events_url": "https://api.github.com/users/zasdfgbnm/events{/privacy}", "received_events_url": "https://api.github.com/users/zasdfgbnm/received_events", "type": "User", "site_admin": false}, "created_at": "2018-06-23T12:38:23Z", "updated_at": "2018-06-23T13:39:50Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=23639302\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/vishwakftw\">@vishwakftw</a> building with <code>export CUDA_NVCC_EXECUTABLE=$(which nvcc)</code> do make it able to find CUDA correctly, but then I get a different problem if using gcc-6 (no problem with gcc-5)</p>\n<pre><code>[1/261] Building NVCC (Device) object caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/caffe2_gpu_generated_THCStorageCopy.cu.o\nFAILED: caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/caffe2_gpu_generated_THCStorageCopy.cu.o \ncd /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC &amp;&amp; /home/gaoxiang/anaconda3/bin/cmake -E make_directory /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/. &amp;&amp; /home/gaoxiang/anaconda3/bin/cmake -D verbose:BOOL=OFF -D build_configuration:STRING=Release -D generated_file:STRING=/home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/./caffe2_gpu_generated_THCStorageCopy.cu.o -D generated_cubin_file:STRING=/home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/./caffe2_gpu_generated_THCStorageCopy.cu.o.cubin.txt -P /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/caffe2_gpu_generated_THCStorageCopy.cu.o.Release.cmake\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_MoveConstructibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template&lt;class ... _UElements, typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (3ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(_UElements&amp;&amp; ...) [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor&gt;}; typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (3ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible&lt;_Elements, _UElements&amp;&amp;&gt;\u2019\n       return __and_&lt;is_constructible&lt;_Elements, _UElements&amp;&amp;&gt;...&gt;::value;\n                                                                   ^~~~~\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_MoveConstructibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template&lt;class ... _UElements, typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (3ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(_UElements&amp;&amp; ...) [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor&gt;}; typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (3ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible&lt;_UElements&amp;&amp;, _Elements&gt;\u2019\n       return __and_&lt;is_convertible&lt;_UElements&amp;&amp;, _Elements&gt;...&gt;::value;\n                                                                 ^~~~~\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = const std::tuple&lt;at::Tensor, at::Tensor, at::Tensor&gt;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template&lt;class ... _UElements, class _Dummy, typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_ConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;const tuple&lt;_Elements ...&gt;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(const std::tuple&lt;_Args1 ...&gt;&amp;) [with _UElements = {at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_ConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;const tuple&lt;_Elements ...&gt;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\n       return  __and_&lt;__not_&lt;is_same&lt;tuple&lt;_Elements...&gt;,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template&lt;class _From, class _To&gt; struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = const std::tuple&lt;at::Tensor, at::Tensor, at::Tensor&gt;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = std::tuple&lt;at::Tensor, at::Tensor, at::Tensor&gt;&amp;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template&lt;class ... _UElements, class _Dummy, typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;tuple&lt;_Elements ...&gt;&amp;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(std::tuple&lt;_Args1 ...&gt;&amp;&amp;) [with _UElements = {at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;tuple&lt;_Elements ...&gt;&amp;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\n       return  __and_&lt;__not_&lt;is_same&lt;tuple&lt;_Elements...&gt;,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template&lt;class _From, class _To&gt; struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = std::tuple&lt;at::Tensor, at::Tensor, at::Tensor&gt;&amp;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_MoveConstructibleTuple() [with _UElements = {std::tuple&lt;at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;}]\u2019:\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template&lt;class ... _UElements, typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (3ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(_UElements&amp;&amp; ...) [with _UElements = {std::tuple&lt;at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;}; typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (3ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible&lt;_Elements, _UElements&amp;&amp;&gt;\u2019\n       return __and_&lt;is_constructible&lt;_Elements, _UElements&amp;&amp;&gt;...&gt;::value;\n                                                                   ^~~~~\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_MoveConstructibleTuple() [with _UElements = {std::tuple&lt;at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple&lt;at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;}]\u2019:\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template&lt;class ... _UElements, typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (3ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(_UElements&amp;&amp; ...) [with _UElements = {std::tuple&lt;at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;}; typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (3ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible&lt;_UElements&amp;&amp;, _Elements&gt;\u2019\n       return __and_&lt;is_convertible&lt;_UElements&amp;&amp;, _Elements&gt;...&gt;::value;\n                                                                 ^~~~~\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple&lt;at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = const std::tuple&lt;at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;}]\u2019:\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template&lt;class ... _UElements, class _Dummy, typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_ConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_ImplicitlyConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_NonNestedTuple&lt;const tuple&lt;_Elements ...&gt;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(const std::tuple&lt;_Args1 ...&gt;&amp;) [with _UElements = {at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;}; _Dummy = void; typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_ConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_ImplicitlyConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_NonNestedTuple&lt;const tuple&lt;_Elements ...&gt;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\n       return  __and_&lt;__not_&lt;is_same&lt;tuple&lt;_Elements...&gt;,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template&lt;class _From, class _To&gt; struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = const std::tuple&lt;at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = std::tuple&lt;at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;&amp;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;}]\u2019:\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template&lt;class ... _UElements, class _Dummy, typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_NonNestedTuple&lt;tuple&lt;_Elements ...&gt;&amp;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(std::tuple&lt;_Args1 ...&gt;&amp;&amp;) [with _UElements = {at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;}; _Dummy = void; typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_NonNestedTuple&lt;tuple&lt;_Elements ...&gt;&amp;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\n       return  __and_&lt;__not_&lt;is_same&lt;tuple&lt;_Elements...&gt;,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template&lt;class _From, class _To&gt; struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = std::tuple&lt;at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;&amp;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_MoveConstructibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template&lt;class ... _UElements, typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (5ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(_UElements&amp;&amp; ...) [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (5ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible&lt;_Elements, _UElements&amp;&amp;&gt;\u2019\n       return __and_&lt;is_constructible&lt;_Elements, _UElements&amp;&amp;&gt;...&gt;::value;\n                                                                   ^~~~~\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_MoveConstructibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template&lt;class ... _UElements, typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (5ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(_UElements&amp;&amp; ...) [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (5ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible&lt;_UElements&amp;&amp;, _Elements&gt;\u2019\n       return __and_&lt;is_convertible&lt;_UElements&amp;&amp;, _Elements&gt;...&gt;::value;\n                                                                 ^~~~~\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = const std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template&lt;class ... _UElements, class _Dummy, typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;const tuple&lt;_Elements ...&gt;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(const std::tuple&lt;_Args1 ...&gt;&amp;) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;const tuple&lt;_Elements ...&gt;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (6, should be 2)\n       return  __and_&lt;__not_&lt;is_same&lt;tuple&lt;_Elements...&gt;,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template&lt;class _From, class _To&gt; struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = const std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;&amp;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template&lt;class ... _UElements, class _Dummy, typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;tuple&lt;_Elements ...&gt;&amp;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(std::tuple&lt;_Args1 ...&gt;&amp;&amp;) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;tuple&lt;_Elements ...&gt;&amp;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (6, should be 2)\n       return  __and_&lt;__not_&lt;is_same&lt;tuple&lt;_Elements...&gt;,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template&lt;class _From, class _To&gt; struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;&amp;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_MoveConstructibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt;}]\u2019:\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template&lt;class ... _UElements, typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (4ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(_UElements&amp;&amp; ...) [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;}; typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (4ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible&lt;_Elements, _UElements&amp;&amp;&gt;\u2019\n       return __and_&lt;is_constructible&lt;_Elements, _UElements&amp;&amp;&gt;...&gt;::value;\n                                                                   ^~~~~\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_MoveConstructibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt;}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt;}]\u2019:\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template&lt;class ... _UElements, typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (4ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(_UElements&amp;&amp; ...) [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;}; typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (4ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible&lt;_UElements&amp;&amp;, _Elements&gt;\u2019\n       return __and_&lt;is_convertible&lt;_UElements&amp;&amp;, _Elements&gt;...&gt;::value;\n                                                                 ^~~~~\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt;}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = const std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt;}]\u2019:\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template&lt;class ... _UElements, class _Dummy, typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_ConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_ImplicitlyConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_NonNestedTuple&lt;const tuple&lt;_Elements ...&gt;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(const std::tuple&lt;_Args1 ...&gt;&amp;) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt;}; _Dummy = void; typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_ConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_ImplicitlyConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_NonNestedTuple&lt;const tuple&lt;_Elements ...&gt;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\n       return  __and_&lt;__not_&lt;is_same&lt;tuple&lt;_Elements...&gt;,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template&lt;class _From, class _To&gt; struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = const std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt;}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;&amp;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt;}]\u2019:\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template&lt;class ... _UElements, class _Dummy, typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_NonNestedTuple&lt;tuple&lt;_Elements ...&gt;&amp;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(std::tuple&lt;_Args1 ...&gt;&amp;&amp;) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt;}; _Dummy = void; typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_NonNestedTuple&lt;tuple&lt;_Elements ...&gt;&amp;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\n       return  __and_&lt;__not_&lt;is_same&lt;tuple&lt;_Elements...&gt;,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template&lt;class _From, class _To&gt; struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;&amp;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt;}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_MoveConstructibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template&lt;class ... _UElements, typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (4ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(_UElements&amp;&amp; ...) [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (4ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible&lt;_Elements, _UElements&amp;&amp;&gt;\u2019\n       return __and_&lt;is_constructible&lt;_Elements, _UElements&amp;&amp;&gt;...&gt;::value;\n                                                                   ^~~~~\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_MoveConstructibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template&lt;class ... _UElements, typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (4ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(_UElements&amp;&amp; ...) [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (4ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible&lt;_UElements&amp;&amp;, _Elements&gt;\u2019\n       return __and_&lt;is_convertible&lt;_UElements&amp;&amp;, _Elements&gt;...&gt;::value;\n                                                                 ^~~~~\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = const std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template&lt;class ... _UElements, class _Dummy, typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;const tuple&lt;_Elements ...&gt;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(const std::tuple&lt;_Args1 ...&gt;&amp;) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;const tuple&lt;_Elements ...&gt;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\n       return  __and_&lt;__not_&lt;is_same&lt;tuple&lt;_Elements...&gt;,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template&lt;class _From, class _To&gt; struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = const std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;&amp;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template&lt;class ... _UElements, class _Dummy, typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;tuple&lt;_Elements ...&gt;&amp;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(std::tuple&lt;_Args1 ...&gt;&amp;&amp;) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;tuple&lt;_Elements ...&gt;&amp;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\n       return  __and_&lt;__not_&lt;is_same&lt;tuple&lt;_Elements...&gt;,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template&lt;class _From, class _To&gt; struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;&amp;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\ncc1plus: warning: unrecognized command line option \u2018-Wno-aligned-allocation-unavailable\u2019\ncc1plus: warning: unrecognized command line option \u2018-Wno-inconsistent-missing-override\u2019\ncc1plus: warning: unrecognized command line option \u2018-Wno-unused-private-field\u2019\ncc1plus: warning: unrecognized command line option \u2018-Wno-unknown-warning-option\u2019\ncc1plus: warning: unrecognized command line option \u2018-Wno-typedef-redefinition\u2019\ncc1plus: warning: unrecognized command line option \u2018-Wno-invalid-partial-specialization\u2019\nCMake Error at caffe2_gpu_generated_THCStorageCopy.cu.o.Release.cmake:279 (message):\n  Error generating file\n  /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/./caffe2_gpu_generated_THCStorageCopy.cu.o\n\n\n[2/261] Building NVCC (Device) object caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/caffe2_gpu_generated_THCSortUtils.cu.o\nFAILED: caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/caffe2_gpu_generated_THCSortUtils.cu.o \ncd /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC &amp;&amp; /home/gaoxiang/anaconda3/bin/cmake -E make_directory /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/. &amp;&amp; /home/gaoxiang/anaconda3/bin/cmake -D verbose:BOOL=OFF -D build_configuration:STRING=Release -D generated_file:STRING=/home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/./caffe2_gpu_generated_THCSortUtils.cu.o -D generated_cubin_file:STRING=/home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/./caffe2_gpu_generated_THCSortUtils.cu.o.cubin.txt -P /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/caffe2_gpu_generated_THCSortUtils.cu.o.Release.cmake\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_MoveConstructibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template&lt;class ... _UElements, typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (3ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(_UElements&amp;&amp; ...) [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor&gt;}; typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (3ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible&lt;_Elements, _UElements&amp;&amp;&gt;\u2019\n       return __and_&lt;is_constructible&lt;_Elements, _UElements&amp;&amp;&gt;...&gt;::value;\n                                                                   ^~~~~\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_MoveConstructibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template&lt;class ... _UElements, typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (3ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(_UElements&amp;&amp; ...) [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor&gt;}; typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (3ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible&lt;_UElements&amp;&amp;, _Elements&gt;\u2019\n       return __and_&lt;is_convertible&lt;_UElements&amp;&amp;, _Elements&gt;...&gt;::value;\n                                                                 ^~~~~\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = const std::tuple&lt;at::Tensor, at::Tensor, at::Tensor&gt;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template&lt;class ... _UElements, class _Dummy, typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_ConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;const tuple&lt;_Elements ...&gt;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(const std::tuple&lt;_Args1 ...&gt;&amp;) [with _UElements = {at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_ConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;const tuple&lt;_Elements ...&gt;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\n       return  __and_&lt;__not_&lt;is_same&lt;tuple&lt;_Elements...&gt;,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template&lt;class _From, class _To&gt; struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = const std::tuple&lt;at::Tensor, at::Tensor, at::Tensor&gt;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = std::tuple&lt;at::Tensor, at::Tensor, at::Tensor&gt;&amp;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template&lt;class ... _UElements, class _Dummy, typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;tuple&lt;_Elements ...&gt;&amp;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(std::tuple&lt;_Args1 ...&gt;&amp;&amp;) [with _UElements = {at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;tuple&lt;_Elements ...&gt;&amp;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\n       return  __and_&lt;__not_&lt;is_same&lt;tuple&lt;_Elements...&gt;,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template&lt;class _From, class _To&gt; struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = std::tuple&lt;at::Tensor, at::Tensor, at::Tensor&gt;&amp;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_MoveConstructibleTuple() [with _UElements = {std::tuple&lt;at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;}]\u2019:\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template&lt;class ... _UElements, typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (3ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(_UElements&amp;&amp; ...) [with _UElements = {std::tuple&lt;at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;}; typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (3ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible&lt;_Elements, _UElements&amp;&amp;&gt;\u2019\n       return __and_&lt;is_constructible&lt;_Elements, _UElements&amp;&amp;&gt;...&gt;::value;\n                                                                   ^~~~~\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_MoveConstructibleTuple() [with _UElements = {std::tuple&lt;at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple&lt;at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;}]\u2019:\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template&lt;class ... _UElements, typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (3ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(_UElements&amp;&amp; ...) [with _UElements = {std::tuple&lt;at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;}; typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (3ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible&lt;_UElements&amp;&amp;, _Elements&gt;\u2019\n       return __and_&lt;is_convertible&lt;_UElements&amp;&amp;, _Elements&gt;...&gt;::value;\n                                                                 ^~~~~\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple&lt;at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = const std::tuple&lt;at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;}]\u2019:\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template&lt;class ... _UElements, class _Dummy, typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_ConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_ImplicitlyConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_NonNestedTuple&lt;const tuple&lt;_Elements ...&gt;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(const std::tuple&lt;_Args1 ...&gt;&amp;) [with _UElements = {at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;}; _Dummy = void; typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_ConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_ImplicitlyConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_NonNestedTuple&lt;const tuple&lt;_Elements ...&gt;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\n       return  __and_&lt;__not_&lt;is_same&lt;tuple&lt;_Elements...&gt;,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template&lt;class _From, class _To&gt; struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = const std::tuple&lt;at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = std::tuple&lt;at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;&amp;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;}]\u2019:\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template&lt;class ... _UElements, class _Dummy, typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_NonNestedTuple&lt;tuple&lt;_Elements ...&gt;&amp;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(std::tuple&lt;_Args1 ...&gt;&amp;&amp;) [with _UElements = {at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;}; _Dummy = void; typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_NonNestedTuple&lt;tuple&lt;_Elements ...&gt;&amp;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\n       return  __and_&lt;__not_&lt;is_same&lt;tuple&lt;_Elements...&gt;,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template&lt;class _From, class _To&gt; struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = std::tuple&lt;at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;&amp;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_MoveConstructibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template&lt;class ... _UElements, typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (5ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(_UElements&amp;&amp; ...) [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (5ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible&lt;_Elements, _UElements&amp;&amp;&gt;\u2019\n       return __and_&lt;is_constructible&lt;_Elements, _UElements&amp;&amp;&gt;...&gt;::value;\n                                                                   ^~~~~\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_MoveConstructibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template&lt;class ... _UElements, typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (5ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(_UElements&amp;&amp; ...) [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (5ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible&lt;_UElements&amp;&amp;, _Elements&gt;\u2019\n       return __and_&lt;is_convertible&lt;_UElements&amp;&amp;, _Elements&gt;...&gt;::value;\n                                                                 ^~~~~\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = const std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template&lt;class ... _UElements, class _Dummy, typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;const tuple&lt;_Elements ...&gt;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(const std::tuple&lt;_Args1 ...&gt;&amp;) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;const tuple&lt;_Elements ...&gt;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (6, should be 2)\n       return  __and_&lt;__not_&lt;is_same&lt;tuple&lt;_Elements...&gt;,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template&lt;class _From, class _To&gt; struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = const std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;&amp;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template&lt;class ... _UElements, class _Dummy, typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;tuple&lt;_Elements ...&gt;&amp;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(std::tuple&lt;_Args1 ...&gt;&amp;&amp;) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;tuple&lt;_Elements ...&gt;&amp;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (6, should be 2)\n       return  __and_&lt;__not_&lt;is_same&lt;tuple&lt;_Elements...&gt;,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template&lt;class _From, class _To&gt; struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;&amp;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_MoveConstructibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt;}]\u2019:\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template&lt;class ... _UElements, typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (4ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(_UElements&amp;&amp; ...) [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;}; typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (4ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible&lt;_Elements, _UElements&amp;&amp;&gt;\u2019\n       return __and_&lt;is_constructible&lt;_Elements, _UElements&amp;&amp;&gt;...&gt;::value;\n                                                                   ^~~~~\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_MoveConstructibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt;}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt;}]\u2019:\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template&lt;class ... _UElements, typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (4ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(_UElements&amp;&amp; ...) [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;}; typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (4ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible&lt;_UElements&amp;&amp;, _Elements&gt;\u2019\n       return __and_&lt;is_convertible&lt;_UElements&amp;&amp;, _Elements&gt;...&gt;::value;\n                                                                 ^~~~~\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt;}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = const std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt;}]\u2019:\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template&lt;class ... _UElements, class _Dummy, typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_ConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_ImplicitlyConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_NonNestedTuple&lt;const tuple&lt;_Elements ...&gt;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(const std::tuple&lt;_Args1 ...&gt;&amp;) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt;}; _Dummy = void; typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_ConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_ImplicitlyConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_NonNestedTuple&lt;const tuple&lt;_Elements ...&gt;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\n       return  __and_&lt;__not_&lt;is_same&lt;tuple&lt;_Elements...&gt;,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template&lt;class _From, class _To&gt; struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = const std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt;}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;&amp;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt;}]\u2019:\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template&lt;class ... _UElements, class _Dummy, typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_NonNestedTuple&lt;tuple&lt;_Elements ...&gt;&amp;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(std::tuple&lt;_Args1 ...&gt;&amp;&amp;) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt;}; _Dummy = void; typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_NonNestedTuple&lt;tuple&lt;_Elements ...&gt;&amp;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\n       return  __and_&lt;__not_&lt;is_same&lt;tuple&lt;_Elements...&gt;,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template&lt;class _From, class _To&gt; struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;&amp;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt;}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_MoveConstructibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template&lt;class ... _UElements, typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (4ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(_UElements&amp;&amp; ...) [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (4ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible&lt;_Elements, _UElements&amp;&amp;&gt;\u2019\n       return __and_&lt;is_constructible&lt;_Elements, _UElements&amp;&amp;&gt;...&gt;::value;\n                                                                   ^~~~~\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_MoveConstructibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template&lt;class ... _UElements, typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (4ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(_UElements&amp;&amp; ...) [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (4ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible&lt;_UElements&amp;&amp;, _Elements&gt;\u2019\n       return __and_&lt;is_convertible&lt;_UElements&amp;&amp;, _Elements&gt;...&gt;::value;\n                                                                 ^~~~~\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = const std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template&lt;class ... _UElements, class _Dummy, typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;const tuple&lt;_Elements ...&gt;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(const std::tuple&lt;_Args1 ...&gt;&amp;) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;const tuple&lt;_Elements ...&gt;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\n       return  __and_&lt;__not_&lt;is_same&lt;tuple&lt;_Elements...&gt;,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template&lt;class _From, class _To&gt; struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = const std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;&amp;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template&lt;class ... _UElements, class _Dummy, typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;tuple&lt;_Elements ...&gt;&amp;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(std::tuple&lt;_Args1 ...&gt;&amp;&amp;) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;tuple&lt;_Elements ...&gt;&amp;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\n       return  __and_&lt;__not_&lt;is_same&lt;tuple&lt;_Elements...&gt;,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template&lt;class _From, class _To&gt; struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;&amp;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\ncc1plus: warning: unrecognized command line option \u2018-Wno-aligned-allocation-unavailable\u2019\ncc1plus: warning: unrecognized command line option \u2018-Wno-inconsistent-missing-override\u2019\ncc1plus: warning: unrecognized command line option \u2018-Wno-unused-private-field\u2019\ncc1plus: warning: unrecognized command line option \u2018-Wno-unknown-warning-option\u2019\ncc1plus: warning: unrecognized command line option \u2018-Wno-typedef-redefinition\u2019\ncc1plus: warning: unrecognized command line option \u2018-Wno-invalid-partial-specialization\u2019\nCMake Error at caffe2_gpu_generated_THCSortUtils.cu.o.Release.cmake:279 (message):\n  Error generating file\n  /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/./caffe2_gpu_generated_THCSortUtils.cu.o\n\n\n[3/261] Building NVCC (Device) object caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/caffe2_gpu_generated_THCTensorMathBlas.cu.o\nFAILED: caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/caffe2_gpu_generated_THCTensorMathBlas.cu.o \ncd /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC &amp;&amp; /home/gaoxiang/anaconda3/bin/cmake -E make_directory /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/. &amp;&amp; /home/gaoxiang/anaconda3/bin/cmake -D verbose:BOOL=OFF -D build_configuration:STRING=Release -D generated_file:STRING=/home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/./caffe2_gpu_generated_THCTensorMathBlas.cu.o -D generated_cubin_file:STRING=/home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/./caffe2_gpu_generated_THCTensorMathBlas.cu.o.cubin.txt -P /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/caffe2_gpu_generated_THCTensorMathBlas.cu.o.Release.cmake\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_MoveConstructibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template&lt;class ... _UElements, typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (3ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(_UElements&amp;&amp; ...) [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor&gt;}; typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (3ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible&lt;_Elements, _UElements&amp;&amp;&gt;\u2019\n       return __and_&lt;is_constructible&lt;_Elements, _UElements&amp;&amp;&gt;...&gt;::value;\n                                                                   ^~~~~\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_MoveConstructibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template&lt;class ... _UElements, typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (3ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(_UElements&amp;&amp; ...) [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor&gt;}; typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (3ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible&lt;_UElements&amp;&amp;, _Elements&gt;\u2019\n       return __and_&lt;is_convertible&lt;_UElements&amp;&amp;, _Elements&gt;...&gt;::value;\n                                                                 ^~~~~\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = const std::tuple&lt;at::Tensor, at::Tensor, at::Tensor&gt;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template&lt;class ... _UElements, class _Dummy, typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_ConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;const tuple&lt;_Elements ...&gt;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(const std::tuple&lt;_Args1 ...&gt;&amp;) [with _UElements = {at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_ConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;const tuple&lt;_Elements ...&gt;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\n       return  __and_&lt;__not_&lt;is_same&lt;tuple&lt;_Elements...&gt;,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template&lt;class _From, class _To&gt; struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = const std::tuple&lt;at::Tensor, at::Tensor, at::Tensor&gt;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = std::tuple&lt;at::Tensor, at::Tensor, at::Tensor&gt;&amp;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template&lt;class ... _UElements, class _Dummy, typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;tuple&lt;_Elements ...&gt;&amp;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(std::tuple&lt;_Args1 ...&gt;&amp;&amp;) [with _UElements = {at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;tuple&lt;_Elements ...&gt;&amp;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\n       return  __and_&lt;__not_&lt;is_same&lt;tuple&lt;_Elements...&gt;,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template&lt;class _From, class _To&gt; struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = std::tuple&lt;at::Tensor, at::Tensor, at::Tensor&gt;&amp;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_MoveConstructibleTuple() [with _UElements = {std::tuple&lt;at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;}]\u2019:\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template&lt;class ... _UElements, typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (3ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(_UElements&amp;&amp; ...) [with _UElements = {std::tuple&lt;at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;}; typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (3ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible&lt;_Elements, _UElements&amp;&amp;&gt;\u2019\n       return __and_&lt;is_constructible&lt;_Elements, _UElements&amp;&amp;&gt;...&gt;::value;\n                                                                   ^~~~~\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_MoveConstructibleTuple() [with _UElements = {std::tuple&lt;at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple&lt;at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;}]\u2019:\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template&lt;class ... _UElements, typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (3ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(_UElements&amp;&amp; ...) [with _UElements = {std::tuple&lt;at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;}; typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (3ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible&lt;_UElements&amp;&amp;, _Elements&gt;\u2019\n       return __and_&lt;is_convertible&lt;_UElements&amp;&amp;, _Elements&gt;...&gt;::value;\n                                                                 ^~~~~\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple&lt;at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = const std::tuple&lt;at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;}]\u2019:\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template&lt;class ... _UElements, class _Dummy, typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_ConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_ImplicitlyConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_NonNestedTuple&lt;const tuple&lt;_Elements ...&gt;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(const std::tuple&lt;_Args1 ...&gt;&amp;) [with _UElements = {at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;}; _Dummy = void; typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_ConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_ImplicitlyConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_NonNestedTuple&lt;const tuple&lt;_Elements ...&gt;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\n       return  __and_&lt;__not_&lt;is_same&lt;tuple&lt;_Elements...&gt;,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template&lt;class _From, class _To&gt; struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = const std::tuple&lt;at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = std::tuple&lt;at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;&amp;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;}]\u2019:\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template&lt;class ... _UElements, class _Dummy, typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_NonNestedTuple&lt;tuple&lt;_Elements ...&gt;&amp;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(std::tuple&lt;_Args1 ...&gt;&amp;&amp;) [with _UElements = {at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;}; _Dummy = void; typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_NonNestedTuple&lt;tuple&lt;_Elements ...&gt;&amp;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\n       return  __and_&lt;__not_&lt;is_same&lt;tuple&lt;_Elements...&gt;,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template&lt;class _From, class _To&gt; struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = std::tuple&lt;at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;&amp;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_MoveConstructibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template&lt;class ... _UElements, typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (5ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(_UElements&amp;&amp; ...) [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (5ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible&lt;_Elements, _UElements&amp;&amp;&gt;\u2019\n       return __and_&lt;is_constructible&lt;_Elements, _UElements&amp;&amp;&gt;...&gt;::value;\n                                                                   ^~~~~\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_MoveConstructibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template&lt;class ... _UElements, typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (5ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(_UElements&amp;&amp; ...) [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (5ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible&lt;_UElements&amp;&amp;, _Elements&gt;\u2019\n       return __and_&lt;is_convertible&lt;_UElements&amp;&amp;, _Elements&gt;...&gt;::value;\n                                                                 ^~~~~\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = const std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template&lt;class ... _UElements, class _Dummy, typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;const tuple&lt;_Elements ...&gt;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(const std::tuple&lt;_Args1 ...&gt;&amp;) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;const tuple&lt;_Elements ...&gt;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (6, should be 2)\n       return  __and_&lt;__not_&lt;is_same&lt;tuple&lt;_Elements...&gt;,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template&lt;class _From, class _To&gt; struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = const std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;&amp;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template&lt;class ... _UElements, class _Dummy, typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;tuple&lt;_Elements ...&gt;&amp;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(std::tuple&lt;_Args1 ...&gt;&amp;&amp;) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;tuple&lt;_Elements ...&gt;&amp;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (6, should be 2)\n       return  __and_&lt;__not_&lt;is_same&lt;tuple&lt;_Elements...&gt;,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template&lt;class _From, class _To&gt; struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;&amp;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_MoveConstructibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt;}]\u2019:\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template&lt;class ... _UElements, typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (4ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(_UElements&amp;&amp; ...) [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;}; typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (4ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible&lt;_Elements, _UElements&amp;&amp;&gt;\u2019\n       return __and_&lt;is_constructible&lt;_Elements, _UElements&amp;&amp;&gt;...&gt;::value;\n                                                                   ^~~~~\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_MoveConstructibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt;}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt;}]\u2019:\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template&lt;class ... _UElements, typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (4ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(_UElements&amp;&amp; ...) [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;}; typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (4ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible&lt;_UElements&amp;&amp;, _Elements&gt;\u2019\n       return __and_&lt;is_convertible&lt;_UElements&amp;&amp;, _Elements&gt;...&gt;::value;\n                                                                 ^~~~~\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt;}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = const std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt;}]\u2019:\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template&lt;class ... _UElements, class _Dummy, typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_ConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_ImplicitlyConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_NonNestedTuple&lt;const tuple&lt;_Elements ...&gt;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(const std::tuple&lt;_Args1 ...&gt;&amp;) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt;}; _Dummy = void; typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_ConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_ImplicitlyConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_NonNestedTuple&lt;const tuple&lt;_Elements ...&gt;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\n       return  __and_&lt;__not_&lt;is_same&lt;tuple&lt;_Elements...&gt;,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template&lt;class _From, class _To&gt; struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = const std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt;}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;&amp;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt;}]\u2019:\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template&lt;class ... _UElements, class _Dummy, typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_NonNestedTuple&lt;tuple&lt;_Elements ...&gt;&amp;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(std::tuple&lt;_Args1 ...&gt;&amp;&amp;) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt;}; _Dummy = void; typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_NonNestedTuple&lt;tuple&lt;_Elements ...&gt;&amp;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\n       return  __and_&lt;__not_&lt;is_same&lt;tuple&lt;_Elements...&gt;,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template&lt;class _From, class _To&gt; struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;&amp;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt;}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_MoveConstructibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template&lt;class ... _UElements, typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (4ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(_UElements&amp;&amp; ...) [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (4ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible&lt;_Elements, _UElements&amp;&amp;&gt;\u2019\n       return __and_&lt;is_constructible&lt;_Elements, _UElements&amp;&amp;&gt;...&gt;::value;\n                                                                   ^~~~~\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_MoveConstructibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template&lt;class ... _UElements, typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (4ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(_UElements&amp;&amp; ...) [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (4ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible&lt;_UElements&amp;&amp;, _Elements&gt;\u2019\n       return __and_&lt;is_convertible&lt;_UElements&amp;&amp;, _Elements&gt;...&gt;::value;\n                                                                 ^~~~~\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = const std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template&lt;class ... _UElements, class _Dummy, typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;const tuple&lt;_Elements ...&gt;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(const std::tuple&lt;_Args1 ...&gt;&amp;) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;const tuple&lt;_Elements ...&gt;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\n       return  __and_&lt;__not_&lt;is_same&lt;tuple&lt;_Elements...&gt;,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template&lt;class _From, class _To&gt; struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = const std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;&amp;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template&lt;class ... _UElements, class _Dummy, typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;tuple&lt;_Elements ...&gt;&amp;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(std::tuple&lt;_Args1 ...&gt;&amp;&amp;) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;tuple&lt;_Elements ...&gt;&amp;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\n       return  __and_&lt;__not_&lt;is_same&lt;tuple&lt;_Elements...&gt;,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template&lt;class _From, class _To&gt; struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;&amp;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\ncc1plus: warning: unrecognized command line option \u2018-Wno-aligned-allocation-unavailable\u2019\ncc1plus: warning: unrecognized command line option \u2018-Wno-inconsistent-missing-override\u2019\ncc1plus: warning: unrecognized command line option \u2018-Wno-unused-private-field\u2019\ncc1plus: warning: unrecognized command line option \u2018-Wno-unknown-warning-option\u2019\ncc1plus: warning: unrecognized command line option \u2018-Wno-typedef-redefinition\u2019\ncc1plus: warning: unrecognized command line option \u2018-Wno-invalid-partial-specialization\u2019\nCMake Error at caffe2_gpu_generated_THCTensorMathBlas.cu.o.Release.cmake:279 (message):\n  Error generating file\n  /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/./caffe2_gpu_generated_THCTensorMathBlas.cu.o\n\n\n[4/261] Building NVCC (Device) object caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/caffe2_gpu_generated_THCTensor.cu.o\nFAILED: caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/caffe2_gpu_generated_THCTensor.cu.o \ncd /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC &amp;&amp; /home/gaoxiang/anaconda3/bin/cmake -E make_directory /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/. &amp;&amp; /home/gaoxiang/anaconda3/bin/cmake -D verbose:BOOL=OFF -D build_configuration:STRING=Release -D generated_file:STRING=/home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/./caffe2_gpu_generated_THCTensor.cu.o -D generated_cubin_file:STRING=/home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/./caffe2_gpu_generated_THCTensor.cu.o.cubin.txt -P /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/caffe2_gpu_generated_THCTensor.cu.o.Release.cmake\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_MoveConstructibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template&lt;class ... _UElements, typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (3ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(_UElements&amp;&amp; ...) [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor&gt;}; typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (3ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible&lt;_Elements, _UElements&amp;&amp;&gt;\u2019\n       return __and_&lt;is_constructible&lt;_Elements, _UElements&amp;&amp;&gt;...&gt;::value;\n                                                                   ^~~~~\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_MoveConstructibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template&lt;class ... _UElements, typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (3ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(_UElements&amp;&amp; ...) [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor&gt;}; typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (3ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible&lt;_UElements&amp;&amp;, _Elements&gt;\u2019\n       return __and_&lt;is_convertible&lt;_UElements&amp;&amp;, _Elements&gt;...&gt;::value;\n                                                                 ^~~~~\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = const std::tuple&lt;at::Tensor, at::Tensor, at::Tensor&gt;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template&lt;class ... _UElements, class _Dummy, typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_ConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;const tuple&lt;_Elements ...&gt;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(const std::tuple&lt;_Args1 ...&gt;&amp;) [with _UElements = {at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_ConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;const tuple&lt;_Elements ...&gt;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\n       return  __and_&lt;__not_&lt;is_same&lt;tuple&lt;_Elements...&gt;,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template&lt;class _From, class _To&gt; struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = const std::tuple&lt;at::Tensor, at::Tensor, at::Tensor&gt;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = std::tuple&lt;at::Tensor, at::Tensor, at::Tensor&gt;&amp;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template&lt;class ... _UElements, class _Dummy, typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;tuple&lt;_Elements ...&gt;&amp;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(std::tuple&lt;_Args1 ...&gt;&amp;&amp;) [with _UElements = {at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;tuple&lt;_Elements ...&gt;&amp;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\n       return  __and_&lt;__not_&lt;is_same&lt;tuple&lt;_Elements...&gt;,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template&lt;class _From, class _To&gt; struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = std::tuple&lt;at::Tensor, at::Tensor, at::Tensor&gt;&amp;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_MoveConstructibleTuple() [with _UElements = {std::tuple&lt;at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;}]\u2019:\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template&lt;class ... _UElements, typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (3ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(_UElements&amp;&amp; ...) [with _UElements = {std::tuple&lt;at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;}; typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (3ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible&lt;_Elements, _UElements&amp;&amp;&gt;\u2019\n       return __and_&lt;is_constructible&lt;_Elements, _UElements&amp;&amp;&gt;...&gt;::value;\n                                                                   ^~~~~\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_MoveConstructibleTuple() [with _UElements = {std::tuple&lt;at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple&lt;at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;}]\u2019:\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template&lt;class ... _UElements, typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (3ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(_UElements&amp;&amp; ...) [with _UElements = {std::tuple&lt;at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;}; typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (3ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible&lt;_UElements&amp;&amp;, _Elements&gt;\u2019\n       return __and_&lt;is_convertible&lt;_UElements&amp;&amp;, _Elements&gt;...&gt;::value;\n                                                                 ^~~~~\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple&lt;at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = const std::tuple&lt;at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;}]\u2019:\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template&lt;class ... _UElements, class _Dummy, typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_ConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_ImplicitlyConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_NonNestedTuple&lt;const tuple&lt;_Elements ...&gt;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(const std::tuple&lt;_Args1 ...&gt;&amp;) [with _UElements = {at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;}; _Dummy = void; typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_ConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_ImplicitlyConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_NonNestedTuple&lt;const tuple&lt;_Elements ...&gt;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\n       return  __and_&lt;__not_&lt;is_same&lt;tuple&lt;_Elements...&gt;,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template&lt;class _From, class _To&gt; struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = const std::tuple&lt;at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = std::tuple&lt;at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;&amp;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;}]\u2019:\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template&lt;class ... _UElements, class _Dummy, typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_NonNestedTuple&lt;tuple&lt;_Elements ...&gt;&amp;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(std::tuple&lt;_Args1 ...&gt;&amp;&amp;) [with _UElements = {at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;}; _Dummy = void; typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;::_NonNestedTuple&lt;tuple&lt;_Elements ...&gt;&amp;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\n       return  __and_&lt;__not_&lt;is_same&lt;tuple&lt;_Elements...&gt;,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template&lt;class _From, class _To&gt; struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = std::tuple&lt;at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;&gt;&amp;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor&amp;, at::Tensor&amp;, at::Tensor&amp;}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_MoveConstructibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template&lt;class ... _UElements, typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (5ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(_UElements&amp;&amp; ...) [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (5ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible&lt;_Elements, _UElements&amp;&amp;&gt;\u2019\n       return __and_&lt;is_constructible&lt;_Elements, _UElements&amp;&amp;&gt;...&gt;::value;\n                                                                   ^~~~~\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_MoveConstructibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template&lt;class ... _UElements, typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (5ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(_UElements&amp;&amp; ...) [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (5ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible&lt;_UElements&amp;&amp;, _Elements&gt;\u2019\n       return __and_&lt;is_convertible&lt;_UElements&amp;&amp;, _Elements&gt;...&gt;::value;\n                                                                 ^~~~~\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = const std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template&lt;class ... _UElements, class _Dummy, typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;const tuple&lt;_Elements ...&gt;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(const std::tuple&lt;_Args1 ...&gt;&amp;) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;const tuple&lt;_Elements ...&gt;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (6, should be 2)\n       return  __and_&lt;__not_&lt;is_same&lt;tuple&lt;_Elements...&gt;,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template&lt;class _From, class _To&gt; struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = const std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;&amp;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template&lt;class ... _UElements, class _Dummy, typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;tuple&lt;_Elements ...&gt;&amp;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(std::tuple&lt;_Args1 ...&gt;&amp;&amp;) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;tuple&lt;_Elements ...&gt;&amp;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (6, should be 2)\n       return  __and_&lt;__not_&lt;is_same&lt;tuple&lt;_Elements...&gt;,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template&lt;class _From, class _To&gt; struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;&amp;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_MoveConstructibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt;}]\u2019:\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template&lt;class ... _UElements, typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (4ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(_UElements&amp;&amp; ...) [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;}; typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (4ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible&lt;_Elements, _UElements&amp;&amp;&gt;\u2019\n       return __and_&lt;is_constructible&lt;_Elements, _UElements&amp;&amp;&gt;...&gt;::value;\n                                                                   ^~~~~\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_MoveConstructibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt;}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt;}]\u2019:\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template&lt;class ... _UElements, typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (4ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(_UElements&amp;&amp; ...) [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;}; typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (4ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible&lt;_UElements&amp;&amp;, _Elements&gt;\u2019\n       return __and_&lt;is_convertible&lt;_UElements&amp;&amp;, _Elements&gt;...&gt;::value;\n                                                                 ^~~~~\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt;}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = const std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt;}]\u2019:\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template&lt;class ... _UElements, class _Dummy, typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_ConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_ImplicitlyConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_NonNestedTuple&lt;const tuple&lt;_Elements ...&gt;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(const std::tuple&lt;_Args1 ...&gt;&amp;) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt;}; _Dummy = void; typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_ConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_ImplicitlyConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_NonNestedTuple&lt;const tuple&lt;_Elements ...&gt;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\n       return  __and_&lt;__not_&lt;is_same&lt;tuple&lt;_Elements...&gt;,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template&lt;class _From, class _To&gt; struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = const std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt;}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;&amp;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt;}]\u2019:\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template&lt;class ... _UElements, class _Dummy, typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_NonNestedTuple&lt;tuple&lt;_Elements ...&gt;&amp;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(std::tuple&lt;_Args1 ...&gt;&amp;&amp;) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt;}; _Dummy = void; typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;::_NonNestedTuple&lt;tuple&lt;_Elements ...&gt;&amp;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\n       return  __and_&lt;__not_&lt;is_same&lt;tuple&lt;_Elements...&gt;,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template&lt;class _From, class _To&gt; struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt; &gt;&amp;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector&lt;at::Tensor, std::allocator&lt;at::Tensor&gt; &gt;}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_MoveConstructibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template&lt;class ... _UElements, typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (4ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(_UElements&amp;&amp; ...) [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (4ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible&lt;_Elements, _UElements&amp;&amp;&gt;\u2019\n       return __and_&lt;is_constructible&lt;_Elements, _UElements&amp;&amp;&gt;...&gt;::value;\n                                                                   ^~~~~\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_MoveConstructibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template&lt;class ... _UElements, typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (4ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(_UElements&amp;&amp; ...) [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; typename std::enable_if&lt;(((std::_TC&lt;(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NotSameTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; (4ul &gt;= 1)), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible&lt;_UElements&amp;&amp;, _Elements&gt;\u2019\n       return __and_&lt;is_convertible&lt;_UElements&amp;&amp;, _Elements&gt;...&gt;::value;\n                                                                 ^~~~~\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;}; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = const std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template&lt;class ... _UElements, class _Dummy, typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;const tuple&lt;_Elements ...&gt;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(const std::tuple&lt;_Args1 ...&gt;&amp;) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;const tuple&lt;_Elements ...&gt;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\n       return  __and_&lt;__not_&lt;is_same&lt;tuple&lt;_Elements...&gt;,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template&lt;class _From, class _To&gt; struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = const std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;&amp;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template&lt;class ... _UElements, class _Dummy, typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;tuple&lt;_Elements ...&gt;&amp;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; &gt; constexpr std::tuple&lt; &lt;template-parameter-1-1&gt; &gt;::tuple(std::tuple&lt;_Args1 ...&gt;&amp;&amp;) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if&lt;((std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_MoveConstructibleTuple&lt;_UElements ...&gt;() &amp;&amp; std::_TC&lt;(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_ImplicitlyMoveConvertibleTuple&lt;_UElements ...&gt;()) &amp;&amp; std::_TC&lt;(std::is_same&lt;_Dummy, void&gt;::value &amp;&amp; (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;::_NonNestedTuple&lt;tuple&lt;_Elements ...&gt;&amp;&amp;&gt;()), bool&gt;::type &lt;anonymous&gt; = &lt;missing&gt;]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\n       return  __and_&lt;__not_&lt;is_same&lt;tuple&lt;_Elements...&gt;,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template&lt;class _From, class _To&gt; struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC&lt;&lt;anonymous&gt;, _Elements&gt;::_NonNestedTuple() [with _SrcTuple = std::tuple&lt;at::Tensor, at::Tensor, at::Tensor, at::Tensor&gt;&amp;&amp;; bool &lt;anonymous&gt; = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\ncc1plus: warning: unrecognized command line option \u2018-Wno-aligned-allocation-unavailable\u2019\ncc1plus: warning: unrecognized command line option \u2018-Wno-inconsistent-missing-override\u2019\ncc1plus: warning: unrecognized command line option \u2018-Wno-unused-private-field\u2019\ncc1plus: warning: unrecognized command line option \u2018-Wno-unknown-warning-option\u2019\ncc1plus: warning: unrecognized command line option \u2018-Wno-typedef-redefinition\u2019\ncc1plus: warning: unrecognized command line option \u2018-Wno-invalid-partial-specialization\u2019\nCMake Error at caffe2_gpu_generated_THCTensor.cu.o.Release.cmake:279 (message):\n  Error generating file\n  /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/./caffe2_gpu_generated_THCTensor.cu.o\n</code></pre>", "body_text": "@vishwakftw building with export CUDA_NVCC_EXECUTABLE=$(which nvcc) do make it able to find CUDA correctly, but then I get a different problem if using gcc-6 (no problem with gcc-5)\n[1/261] Building NVCC (Device) object caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/caffe2_gpu_generated_THCStorageCopy.cu.o\nFAILED: caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/caffe2_gpu_generated_THCStorageCopy.cu.o \ncd /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC && /home/gaoxiang/anaconda3/bin/cmake -E make_directory /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/. && /home/gaoxiang/anaconda3/bin/cmake -D verbose:BOOL=OFF -D build_configuration:STRING=Release -D generated_file:STRING=/home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/./caffe2_gpu_generated_THCStorageCopy.cu.o -D generated_cubin_file:STRING=/home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/./caffe2_gpu_generated_THCStorageCopy.cu.o.cubin.txt -P /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/caffe2_gpu_generated_THCStorageCopy.cu.o.Release.cmake\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible<_Elements, _UElements&&>\u2019\n       return __and_<is_constructible<_Elements, _UElements&&>...>::value;\n                                                                   ^~~~~\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible<_UElements&&, _Elements>\u2019\n       return __and_<is_convertible<_UElements&&, _Elements>...>::value;\n                                                                 ^~~~~\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(const std::tuple<_Args1 ...>&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\n       return  __and_<__not_<is_same<tuple<_Elements...>,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(std::tuple<_Args1 ...>&&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\n       return  __and_<__not_<is_same<tuple<_Elements...>,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019:\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor&, at::Tensor&, at::Tensor&>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor&, at::Tensor&, at::Tensor&>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible<_Elements, _UElements&&>\u2019\n       return __and_<is_constructible<_Elements, _UElements&&>...>::value;\n                                                                   ^~~~~\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019:\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor&, at::Tensor&, at::Tensor&>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor&, at::Tensor&, at::Tensor&>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible<_UElements&&, _Elements>\u2019\n       return __and_<is_convertible<_UElements&&, _Elements>...>::value;\n                                                                 ^~~~~\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>&; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019:\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor&, at::Tensor&, at::Tensor&>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(const std::tuple<_Args1 ...>&) [with _UElements = {at::Tensor&, at::Tensor&, at::Tensor&}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor&, at::Tensor&, at::Tensor&>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\n       return  __and_<__not_<is_same<tuple<_Elements...>,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>&; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>&&; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019:\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor&, at::Tensor&, at::Tensor&>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(std::tuple<_Args1 ...>&&) [with _UElements = {at::Tensor&, at::Tensor&, at::Tensor&}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor&, at::Tensor&, at::Tensor&>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\n       return  __and_<__not_<is_same<tuple<_Elements...>,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>&&; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (5ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (5ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible<_Elements, _UElements&&>\u2019\n       return __and_<is_constructible<_Elements, _UElements&&>...>::value;\n                                                                   ^~~~~\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (5ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (5ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible<_UElements&&, _Elements>\u2019\n       return __and_<is_convertible<_UElements&&, _Elements>...>::value;\n                                                                 ^~~~~\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(const std::tuple<_Args1 ...>&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (6, should be 2)\n       return  __and_<__not_<is_same<tuple<_Elements...>,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(std::tuple<_Args1 ...>&&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (6, should be 2)\n       return  __and_<__not_<is_same<tuple<_Elements...>,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019:\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible<_Elements, _UElements&&>\u2019\n       return __and_<is_constructible<_Elements, _UElements&&>...>::value;\n                                                                   ^~~~~\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019:\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible<_UElements&&, _Elements>\u2019\n       return __and_<is_convertible<_UElements&&, _Elements>...>::value;\n                                                                 ^~~~~\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019:\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(const std::tuple<_Args1 ...>&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\n       return  __and_<__not_<is_same<tuple<_Elements...>,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019:\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(std::tuple<_Args1 ...>&&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\n       return  __and_<__not_<is_same<tuple<_Elements...>,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible<_Elements, _UElements&&>\u2019\n       return __and_<is_constructible<_Elements, _UElements&&>...>::value;\n                                                                   ^~~~~\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible<_UElements&&, _Elements>\u2019\n       return __and_<is_convertible<_UElements&&, _Elements>...>::value;\n                                                                 ^~~~~\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(const std::tuple<_Args1 ...>&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\n       return  __and_<__not_<is_same<tuple<_Elements...>,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(std::tuple<_Args1 ...>&&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\n       return  __and_<__not_<is_same<tuple<_Elements...>,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\ncc1plus: warning: unrecognized command line option \u2018-Wno-aligned-allocation-unavailable\u2019\ncc1plus: warning: unrecognized command line option \u2018-Wno-inconsistent-missing-override\u2019\ncc1plus: warning: unrecognized command line option \u2018-Wno-unused-private-field\u2019\ncc1plus: warning: unrecognized command line option \u2018-Wno-unknown-warning-option\u2019\ncc1plus: warning: unrecognized command line option \u2018-Wno-typedef-redefinition\u2019\ncc1plus: warning: unrecognized command line option \u2018-Wno-invalid-partial-specialization\u2019\nCMake Error at caffe2_gpu_generated_THCStorageCopy.cu.o.Release.cmake:279 (message):\n  Error generating file\n  /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/./caffe2_gpu_generated_THCStorageCopy.cu.o\n\n\n[2/261] Building NVCC (Device) object caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/caffe2_gpu_generated_THCSortUtils.cu.o\nFAILED: caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/caffe2_gpu_generated_THCSortUtils.cu.o \ncd /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC && /home/gaoxiang/anaconda3/bin/cmake -E make_directory /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/. && /home/gaoxiang/anaconda3/bin/cmake -D verbose:BOOL=OFF -D build_configuration:STRING=Release -D generated_file:STRING=/home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/./caffe2_gpu_generated_THCSortUtils.cu.o -D generated_cubin_file:STRING=/home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/./caffe2_gpu_generated_THCSortUtils.cu.o.cubin.txt -P /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/caffe2_gpu_generated_THCSortUtils.cu.o.Release.cmake\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible<_Elements, _UElements&&>\u2019\n       return __and_<is_constructible<_Elements, _UElements&&>...>::value;\n                                                                   ^~~~~\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible<_UElements&&, _Elements>\u2019\n       return __and_<is_convertible<_UElements&&, _Elements>...>::value;\n                                                                 ^~~~~\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(const std::tuple<_Args1 ...>&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\n       return  __and_<__not_<is_same<tuple<_Elements...>,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(std::tuple<_Args1 ...>&&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\n       return  __and_<__not_<is_same<tuple<_Elements...>,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019:\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor&, at::Tensor&, at::Tensor&>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor&, at::Tensor&, at::Tensor&>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible<_Elements, _UElements&&>\u2019\n       return __and_<is_constructible<_Elements, _UElements&&>...>::value;\n                                                                   ^~~~~\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019:\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor&, at::Tensor&, at::Tensor&>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor&, at::Tensor&, at::Tensor&>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible<_UElements&&, _Elements>\u2019\n       return __and_<is_convertible<_UElements&&, _Elements>...>::value;\n                                                                 ^~~~~\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>&; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019:\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor&, at::Tensor&, at::Tensor&>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(const std::tuple<_Args1 ...>&) [with _UElements = {at::Tensor&, at::Tensor&, at::Tensor&}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor&, at::Tensor&, at::Tensor&>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\n       return  __and_<__not_<is_same<tuple<_Elements...>,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>&; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>&&; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019:\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor&, at::Tensor&, at::Tensor&>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(std::tuple<_Args1 ...>&&) [with _UElements = {at::Tensor&, at::Tensor&, at::Tensor&}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor&, at::Tensor&, at::Tensor&>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\n       return  __and_<__not_<is_same<tuple<_Elements...>,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>&&; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (5ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (5ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible<_Elements, _UElements&&>\u2019\n       return __and_<is_constructible<_Elements, _UElements&&>...>::value;\n                                                                   ^~~~~\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (5ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (5ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible<_UElements&&, _Elements>\u2019\n       return __and_<is_convertible<_UElements&&, _Elements>...>::value;\n                                                                 ^~~~~\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(const std::tuple<_Args1 ...>&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (6, should be 2)\n       return  __and_<__not_<is_same<tuple<_Elements...>,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(std::tuple<_Args1 ...>&&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (6, should be 2)\n       return  __and_<__not_<is_same<tuple<_Elements...>,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019:\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible<_Elements, _UElements&&>\u2019\n       return __and_<is_constructible<_Elements, _UElements&&>...>::value;\n                                                                   ^~~~~\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019:\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible<_UElements&&, _Elements>\u2019\n       return __and_<is_convertible<_UElements&&, _Elements>...>::value;\n                                                                 ^~~~~\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019:\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(const std::tuple<_Args1 ...>&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\n       return  __and_<__not_<is_same<tuple<_Elements...>,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019:\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(std::tuple<_Args1 ...>&&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\n       return  __and_<__not_<is_same<tuple<_Elements...>,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible<_Elements, _UElements&&>\u2019\n       return __and_<is_constructible<_Elements, _UElements&&>...>::value;\n                                                                   ^~~~~\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible<_UElements&&, _Elements>\u2019\n       return __and_<is_convertible<_UElements&&, _Elements>...>::value;\n                                                                 ^~~~~\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(const std::tuple<_Args1 ...>&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\n       return  __and_<__not_<is_same<tuple<_Elements...>,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(std::tuple<_Args1 ...>&&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\n       return  __and_<__not_<is_same<tuple<_Elements...>,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\ncc1plus: warning: unrecognized command line option \u2018-Wno-aligned-allocation-unavailable\u2019\ncc1plus: warning: unrecognized command line option \u2018-Wno-inconsistent-missing-override\u2019\ncc1plus: warning: unrecognized command line option \u2018-Wno-unused-private-field\u2019\ncc1plus: warning: unrecognized command line option \u2018-Wno-unknown-warning-option\u2019\ncc1plus: warning: unrecognized command line option \u2018-Wno-typedef-redefinition\u2019\ncc1plus: warning: unrecognized command line option \u2018-Wno-invalid-partial-specialization\u2019\nCMake Error at caffe2_gpu_generated_THCSortUtils.cu.o.Release.cmake:279 (message):\n  Error generating file\n  /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/./caffe2_gpu_generated_THCSortUtils.cu.o\n\n\n[3/261] Building NVCC (Device) object caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/caffe2_gpu_generated_THCTensorMathBlas.cu.o\nFAILED: caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/caffe2_gpu_generated_THCTensorMathBlas.cu.o \ncd /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC && /home/gaoxiang/anaconda3/bin/cmake -E make_directory /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/. && /home/gaoxiang/anaconda3/bin/cmake -D verbose:BOOL=OFF -D build_configuration:STRING=Release -D generated_file:STRING=/home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/./caffe2_gpu_generated_THCTensorMathBlas.cu.o -D generated_cubin_file:STRING=/home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/./caffe2_gpu_generated_THCTensorMathBlas.cu.o.cubin.txt -P /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/caffe2_gpu_generated_THCTensorMathBlas.cu.o.Release.cmake\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible<_Elements, _UElements&&>\u2019\n       return __and_<is_constructible<_Elements, _UElements&&>...>::value;\n                                                                   ^~~~~\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible<_UElements&&, _Elements>\u2019\n       return __and_<is_convertible<_UElements&&, _Elements>...>::value;\n                                                                 ^~~~~\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(const std::tuple<_Args1 ...>&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\n       return  __and_<__not_<is_same<tuple<_Elements...>,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(std::tuple<_Args1 ...>&&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\n       return  __and_<__not_<is_same<tuple<_Elements...>,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019:\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor&, at::Tensor&, at::Tensor&>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor&, at::Tensor&, at::Tensor&>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible<_Elements, _UElements&&>\u2019\n       return __and_<is_constructible<_Elements, _UElements&&>...>::value;\n                                                                   ^~~~~\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019:\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor&, at::Tensor&, at::Tensor&>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor&, at::Tensor&, at::Tensor&>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible<_UElements&&, _Elements>\u2019\n       return __and_<is_convertible<_UElements&&, _Elements>...>::value;\n                                                                 ^~~~~\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>&; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019:\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor&, at::Tensor&, at::Tensor&>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(const std::tuple<_Args1 ...>&) [with _UElements = {at::Tensor&, at::Tensor&, at::Tensor&}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor&, at::Tensor&, at::Tensor&>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\n       return  __and_<__not_<is_same<tuple<_Elements...>,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>&; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>&&; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019:\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor&, at::Tensor&, at::Tensor&>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(std::tuple<_Args1 ...>&&) [with _UElements = {at::Tensor&, at::Tensor&, at::Tensor&}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor&, at::Tensor&, at::Tensor&>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\n       return  __and_<__not_<is_same<tuple<_Elements...>,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>&&; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (5ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (5ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible<_Elements, _UElements&&>\u2019\n       return __and_<is_constructible<_Elements, _UElements&&>...>::value;\n                                                                   ^~~~~\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (5ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (5ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible<_UElements&&, _Elements>\u2019\n       return __and_<is_convertible<_UElements&&, _Elements>...>::value;\n                                                                 ^~~~~\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(const std::tuple<_Args1 ...>&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (6, should be 2)\n       return  __and_<__not_<is_same<tuple<_Elements...>,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(std::tuple<_Args1 ...>&&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (6, should be 2)\n       return  __and_<__not_<is_same<tuple<_Elements...>,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019:\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible<_Elements, _UElements&&>\u2019\n       return __and_<is_constructible<_Elements, _UElements&&>...>::value;\n                                                                   ^~~~~\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019:\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible<_UElements&&, _Elements>\u2019\n       return __and_<is_convertible<_UElements&&, _Elements>...>::value;\n                                                                 ^~~~~\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019:\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(const std::tuple<_Args1 ...>&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\n       return  __and_<__not_<is_same<tuple<_Elements...>,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019:\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(std::tuple<_Args1 ...>&&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\n       return  __and_<__not_<is_same<tuple<_Elements...>,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible<_Elements, _UElements&&>\u2019\n       return __and_<is_constructible<_Elements, _UElements&&>...>::value;\n                                                                   ^~~~~\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible<_UElements&&, _Elements>\u2019\n       return __and_<is_convertible<_UElements&&, _Elements>...>::value;\n                                                                 ^~~~~\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(const std::tuple<_Args1 ...>&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\n       return  __and_<__not_<is_same<tuple<_Elements...>,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(std::tuple<_Args1 ...>&&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\n       return  __and_<__not_<is_same<tuple<_Elements...>,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\ncc1plus: warning: unrecognized command line option \u2018-Wno-aligned-allocation-unavailable\u2019\ncc1plus: warning: unrecognized command line option \u2018-Wno-inconsistent-missing-override\u2019\ncc1plus: warning: unrecognized command line option \u2018-Wno-unused-private-field\u2019\ncc1plus: warning: unrecognized command line option \u2018-Wno-unknown-warning-option\u2019\ncc1plus: warning: unrecognized command line option \u2018-Wno-typedef-redefinition\u2019\ncc1plus: warning: unrecognized command line option \u2018-Wno-invalid-partial-specialization\u2019\nCMake Error at caffe2_gpu_generated_THCTensorMathBlas.cu.o.Release.cmake:279 (message):\n  Error generating file\n  /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/./caffe2_gpu_generated_THCTensorMathBlas.cu.o\n\n\n[4/261] Building NVCC (Device) object caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/caffe2_gpu_generated_THCTensor.cu.o\nFAILED: caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/caffe2_gpu_generated_THCTensor.cu.o \ncd /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC && /home/gaoxiang/anaconda3/bin/cmake -E make_directory /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/. && /home/gaoxiang/anaconda3/bin/cmake -D verbose:BOOL=OFF -D build_configuration:STRING=Release -D generated_file:STRING=/home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/./caffe2_gpu_generated_THCTensor.cu.o -D generated_cubin_file:STRING=/home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/./caffe2_gpu_generated_THCTensor.cu.o.cubin.txt -P /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/caffe2_gpu_generated_THCTensor.cu.o.Release.cmake\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible<_Elements, _UElements&&>\u2019\n       return __and_<is_constructible<_Elements, _UElements&&>...>::value;\n                                                                   ^~~~~\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible<_UElements&&, _Elements>\u2019\n       return __and_<is_convertible<_UElements&&, _Elements>...>::value;\n                                                                 ^~~~~\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(const std::tuple<_Args1 ...>&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\n       return  __and_<__not_<is_same<tuple<_Elements...>,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(std::tuple<_Args1 ...>&&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\n       return  __and_<__not_<is_same<tuple<_Elements...>,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019:\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor&, at::Tensor&, at::Tensor&>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor&, at::Tensor&, at::Tensor&>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible<_Elements, _UElements&&>\u2019\n       return __and_<is_constructible<_Elements, _UElements&&>...>::value;\n                                                                   ^~~~~\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019:\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor&, at::Tensor&, at::Tensor&>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor&, at::Tensor&, at::Tensor&>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible<_UElements&&, _Elements>\u2019\n       return __and_<is_convertible<_UElements&&, _Elements>...>::value;\n                                                                 ^~~~~\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>&; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019:\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor&, at::Tensor&, at::Tensor&>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(const std::tuple<_Args1 ...>&) [with _UElements = {at::Tensor&, at::Tensor&, at::Tensor&}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor&, at::Tensor&, at::Tensor&>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\n       return  __and_<__not_<is_same<tuple<_Elements...>,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>&; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>&&; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019:\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor&, at::Tensor&, at::Tensor&>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(std::tuple<_Args1 ...>&&) [with _UElements = {at::Tensor&, at::Tensor&, at::Tensor&}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor&, at::Tensor&, at::Tensor&>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\n       return  __and_<__not_<is_same<tuple<_Elements...>,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>&&; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (5ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (5ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible<_Elements, _UElements&&>\u2019\n       return __and_<is_constructible<_Elements, _UElements&&>...>::value;\n                                                                   ^~~~~\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (5ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (5ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible<_UElements&&, _Elements>\u2019\n       return __and_<is_convertible<_UElements&&, _Elements>...>::value;\n                                                                 ^~~~~\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(const std::tuple<_Args1 ...>&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (6, should be 2)\n       return  __and_<__not_<is_same<tuple<_Elements...>,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(std::tuple<_Args1 ...>&&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (6, should be 2)\n       return  __and_<__not_<is_same<tuple<_Elements...>,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019:\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible<_Elements, _UElements&&>\u2019\n       return __and_<is_constructible<_Elements, _UElements&&>...>::value;\n                                                                   ^~~~~\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019:\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible<_UElements&&, _Elements>\u2019\n       return __and_<is_convertible<_UElements&&, _Elements>...>::value;\n                                                                 ^~~~~\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019:\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(const std::tuple<_Args1 ...>&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\n       return  __and_<__not_<is_same<tuple<_Elements...>,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019:\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(std::tuple<_Args1 ...>&&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\n       return  __and_<__not_<is_same<tuple<_Elements...>,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible<_Elements, _UElements&&>\u2019\n       return __and_<is_constructible<_Elements, _UElements&&>...>::value;\n                                                                   ^~~~~\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible<_UElements&&, _Elements>\u2019\n       return __and_<is_convertible<_UElements&&, _Elements>...>::value;\n                                                                 ^~~~~\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(const std::tuple<_Args1 ...>&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\n       return  __and_<__not_<is_same<tuple<_Elements...>,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(std::tuple<_Args1 ...>&&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> = <missing>]\u2019\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\n       return  __and_<__not_<is_same<tuple<_Elements...>,\n                                                                                                                                                                                                                                                    ^    \n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\n     struct is_convertible\n        ^~~~~~~~~~~~~~\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\n     }\n ^\ncc1plus: warning: unrecognized command line option \u2018-Wno-aligned-allocation-unavailable\u2019\ncc1plus: warning: unrecognized command line option \u2018-Wno-inconsistent-missing-override\u2019\ncc1plus: warning: unrecognized command line option \u2018-Wno-unused-private-field\u2019\ncc1plus: warning: unrecognized command line option \u2018-Wno-unknown-warning-option\u2019\ncc1plus: warning: unrecognized command line option \u2018-Wno-typedef-redefinition\u2019\ncc1plus: warning: unrecognized command line option \u2018-Wno-invalid-partial-specialization\u2019\nCMake Error at caffe2_gpu_generated_THCTensor.cu.o.Release.cmake:279 (message):\n  Error generating file\n  /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/./caffe2_gpu_generated_THCTensor.cu.o", "body": "@vishwakftw building with `export CUDA_NVCC_EXECUTABLE=$(which nvcc)` do make it able to find CUDA correctly, but then I get a different problem if using gcc-6 (no problem with gcc-5)\r\n\r\n```\r\n[1/261] Building NVCC (Device) object caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/caffe2_gpu_generated_THCStorageCopy.cu.o\r\nFAILED: caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/caffe2_gpu_generated_THCStorageCopy.cu.o \r\ncd /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC && /home/gaoxiang/anaconda3/bin/cmake -E make_directory /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/. && /home/gaoxiang/anaconda3/bin/cmake -D verbose:BOOL=OFF -D build_configuration:STRING=Release -D generated_file:STRING=/home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/./caffe2_gpu_generated_THCStorageCopy.cu.o -D generated_cubin_file:STRING=/home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/./caffe2_gpu_generated_THCStorageCopy.cu.o.cubin.txt -P /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/caffe2_gpu_generated_THCStorageCopy.cu.o.Release.cmake\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\r\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible<_Elements, _UElements&&>\u2019\r\n       return __and_<is_constructible<_Elements, _UElements&&>...>::value;\r\n                                                                   ^~~~~\r\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\r\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible<_UElements&&, _Elements>\u2019\r\n       return __and_<is_convertible<_UElements&&, _Elements>...>::value;\r\n                                                                 ^~~~~\r\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(const std::tuple<_Args1 ...>&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\r\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\r\n       return  __and_<__not_<is_same<tuple<_Elements...>,\r\n                                                                                                                                                                                                                                                    ^    \r\n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\r\n     struct is_convertible\r\n        ^~~~~~~~~~~~~~\r\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(std::tuple<_Args1 ...>&&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\r\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\r\n       return  __and_<__not_<is_same<tuple<_Elements...>,\r\n                                                                                                                                                                                                                                                    ^    \r\n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\r\n     struct is_convertible\r\n        ^~~~~~~~~~~~~~\r\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019:\r\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor&, at::Tensor&, at::Tensor&>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor&, at::Tensor&, at::Tensor&>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\r\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible<_Elements, _UElements&&>\u2019\r\n       return __and_<is_constructible<_Elements, _UElements&&>...>::value;\r\n                                                                   ^~~~~\r\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019:\r\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor&, at::Tensor&, at::Tensor&>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor&, at::Tensor&, at::Tensor&>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\r\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible<_UElements&&, _Elements>\u2019\r\n       return __and_<is_convertible<_UElements&&, _Elements>...>::value;\r\n                                                                 ^~~~~\r\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>&; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019:\r\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor&, at::Tensor&, at::Tensor&>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(const std::tuple<_Args1 ...>&) [with _UElements = {at::Tensor&, at::Tensor&, at::Tensor&}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor&, at::Tensor&, at::Tensor&>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\r\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\r\n       return  __and_<__not_<is_same<tuple<_Elements...>,\r\n                                                                                                                                                                                                                                                    ^    \r\n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\r\n     struct is_convertible\r\n        ^~~~~~~~~~~~~~\r\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>&; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>&&; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019:\r\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor&, at::Tensor&, at::Tensor&>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(std::tuple<_Args1 ...>&&) [with _UElements = {at::Tensor&, at::Tensor&, at::Tensor&}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor&, at::Tensor&, at::Tensor&>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\r\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\r\n       return  __and_<__not_<is_same<tuple<_Elements...>,\r\n                                                                                                                                                                                                                                                    ^    \r\n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\r\n     struct is_convertible\r\n        ^~~~~~~~~~~~~~\r\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>&&; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (5ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (5ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\r\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible<_Elements, _UElements&&>\u2019\r\n       return __and_<is_constructible<_Elements, _UElements&&>...>::value;\r\n                                                                   ^~~~~\r\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (5ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (5ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\r\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible<_UElements&&, _Elements>\u2019\r\n       return __and_<is_convertible<_UElements&&, _Elements>...>::value;\r\n                                                                 ^~~~~\r\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(const std::tuple<_Args1 ...>&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\r\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (6, should be 2)\r\n       return  __and_<__not_<is_same<tuple<_Elements...>,\r\n                                                                                                                                                                                                                                                    ^    \r\n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\r\n     struct is_convertible\r\n        ^~~~~~~~~~~~~~\r\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(std::tuple<_Args1 ...>&&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\r\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (6, should be 2)\r\n       return  __and_<__not_<is_same<tuple<_Elements...>,\r\n                                                                                                                                                                                                                                                    ^    \r\n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\r\n     struct is_convertible\r\n        ^~~~~~~~~~~~~~\r\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019:\r\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\r\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible<_Elements, _UElements&&>\u2019\r\n       return __and_<is_constructible<_Elements, _UElements&&>...>::value;\r\n                                                                   ^~~~~\r\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019:\r\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\r\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible<_UElements&&, _Elements>\u2019\r\n       return __and_<is_convertible<_UElements&&, _Elements>...>::value;\r\n                                                                 ^~~~~\r\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019:\r\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(const std::tuple<_Args1 ...>&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\r\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\r\n       return  __and_<__not_<is_same<tuple<_Elements...>,\r\n                                                                                                                                                                                                                                                    ^    \r\n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\r\n     struct is_convertible\r\n        ^~~~~~~~~~~~~~\r\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019:\r\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(std::tuple<_Args1 ...>&&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\r\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\r\n       return  __and_<__not_<is_same<tuple<_Elements...>,\r\n                                                                                                                                                                                                                                                    ^    \r\n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\r\n     struct is_convertible\r\n        ^~~~~~~~~~~~~~\r\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\r\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible<_Elements, _UElements&&>\u2019\r\n       return __and_<is_constructible<_Elements, _UElements&&>...>::value;\r\n                                                                   ^~~~~\r\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\r\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible<_UElements&&, _Elements>\u2019\r\n       return __and_<is_convertible<_UElements&&, _Elements>...>::value;\r\n                                                                 ^~~~~\r\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(const std::tuple<_Args1 ...>&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\r\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\r\n       return  __and_<__not_<is_same<tuple<_Elements...>,\r\n                                                                                                                                                                                                                                                    ^    \r\n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\r\n     struct is_convertible\r\n        ^~~~~~~~~~~~~~\r\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(std::tuple<_Args1 ...>&&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\r\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\r\n       return  __and_<__not_<is_same<tuple<_Elements...>,\r\n                                                                                                                                                                                                                                                    ^    \r\n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\r\n     struct is_convertible\r\n        ^~~~~~~~~~~~~~\r\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\ncc1plus: warning: unrecognized command line option \u2018-Wno-aligned-allocation-unavailable\u2019\r\ncc1plus: warning: unrecognized command line option \u2018-Wno-inconsistent-missing-override\u2019\r\ncc1plus: warning: unrecognized command line option \u2018-Wno-unused-private-field\u2019\r\ncc1plus: warning: unrecognized command line option \u2018-Wno-unknown-warning-option\u2019\r\ncc1plus: warning: unrecognized command line option \u2018-Wno-typedef-redefinition\u2019\r\ncc1plus: warning: unrecognized command line option \u2018-Wno-invalid-partial-specialization\u2019\r\nCMake Error at caffe2_gpu_generated_THCStorageCopy.cu.o.Release.cmake:279 (message):\r\n  Error generating file\r\n  /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/./caffe2_gpu_generated_THCStorageCopy.cu.o\r\n\r\n\r\n[2/261] Building NVCC (Device) object caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/caffe2_gpu_generated_THCSortUtils.cu.o\r\nFAILED: caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/caffe2_gpu_generated_THCSortUtils.cu.o \r\ncd /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC && /home/gaoxiang/anaconda3/bin/cmake -E make_directory /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/. && /home/gaoxiang/anaconda3/bin/cmake -D verbose:BOOL=OFF -D build_configuration:STRING=Release -D generated_file:STRING=/home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/./caffe2_gpu_generated_THCSortUtils.cu.o -D generated_cubin_file:STRING=/home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/./caffe2_gpu_generated_THCSortUtils.cu.o.cubin.txt -P /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/caffe2_gpu_generated_THCSortUtils.cu.o.Release.cmake\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\r\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible<_Elements, _UElements&&>\u2019\r\n       return __and_<is_constructible<_Elements, _UElements&&>...>::value;\r\n                                                                   ^~~~~\r\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\r\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible<_UElements&&, _Elements>\u2019\r\n       return __and_<is_convertible<_UElements&&, _Elements>...>::value;\r\n                                                                 ^~~~~\r\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(const std::tuple<_Args1 ...>&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\r\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\r\n       return  __and_<__not_<is_same<tuple<_Elements...>,\r\n                                                                                                                                                                                                                                                    ^    \r\n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\r\n     struct is_convertible\r\n        ^~~~~~~~~~~~~~\r\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(std::tuple<_Args1 ...>&&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\r\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\r\n       return  __and_<__not_<is_same<tuple<_Elements...>,\r\n                                                                                                                                                                                                                                                    ^    \r\n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\r\n     struct is_convertible\r\n        ^~~~~~~~~~~~~~\r\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019:\r\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor&, at::Tensor&, at::Tensor&>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor&, at::Tensor&, at::Tensor&>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\r\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible<_Elements, _UElements&&>\u2019\r\n       return __and_<is_constructible<_Elements, _UElements&&>...>::value;\r\n                                                                   ^~~~~\r\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019:\r\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor&, at::Tensor&, at::Tensor&>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor&, at::Tensor&, at::Tensor&>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\r\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible<_UElements&&, _Elements>\u2019\r\n       return __and_<is_convertible<_UElements&&, _Elements>...>::value;\r\n                                                                 ^~~~~\r\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>&; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019:\r\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor&, at::Tensor&, at::Tensor&>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(const std::tuple<_Args1 ...>&) [with _UElements = {at::Tensor&, at::Tensor&, at::Tensor&}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor&, at::Tensor&, at::Tensor&>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\r\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\r\n       return  __and_<__not_<is_same<tuple<_Elements...>,\r\n                                                                                                                                                                                                                                                    ^    \r\n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\r\n     struct is_convertible\r\n        ^~~~~~~~~~~~~~\r\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>&; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>&&; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019:\r\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor&, at::Tensor&, at::Tensor&>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(std::tuple<_Args1 ...>&&) [with _UElements = {at::Tensor&, at::Tensor&, at::Tensor&}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor&, at::Tensor&, at::Tensor&>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\r\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\r\n       return  __and_<__not_<is_same<tuple<_Elements...>,\r\n                                                                                                                                                                                                                                                    ^    \r\n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\r\n     struct is_convertible\r\n        ^~~~~~~~~~~~~~\r\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>&&; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (5ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (5ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\r\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible<_Elements, _UElements&&>\u2019\r\n       return __and_<is_constructible<_Elements, _UElements&&>...>::value;\r\n                                                                   ^~~~~\r\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (5ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (5ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\r\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible<_UElements&&, _Elements>\u2019\r\n       return __and_<is_convertible<_UElements&&, _Elements>...>::value;\r\n                                                                 ^~~~~\r\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(const std::tuple<_Args1 ...>&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\r\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (6, should be 2)\r\n       return  __and_<__not_<is_same<tuple<_Elements...>,\r\n                                                                                                                                                                                                                                                    ^    \r\n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\r\n     struct is_convertible\r\n        ^~~~~~~~~~~~~~\r\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(std::tuple<_Args1 ...>&&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\r\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (6, should be 2)\r\n       return  __and_<__not_<is_same<tuple<_Elements...>,\r\n                                                                                                                                                                                                                                                    ^    \r\n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\r\n     struct is_convertible\r\n        ^~~~~~~~~~~~~~\r\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019:\r\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\r\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible<_Elements, _UElements&&>\u2019\r\n       return __and_<is_constructible<_Elements, _UElements&&>...>::value;\r\n                                                                   ^~~~~\r\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019:\r\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\r\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible<_UElements&&, _Elements>\u2019\r\n       return __and_<is_convertible<_UElements&&, _Elements>...>::value;\r\n                                                                 ^~~~~\r\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019:\r\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(const std::tuple<_Args1 ...>&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\r\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\r\n       return  __and_<__not_<is_same<tuple<_Elements...>,\r\n                                                                                                                                                                                                                                                    ^    \r\n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\r\n     struct is_convertible\r\n        ^~~~~~~~~~~~~~\r\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019:\r\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(std::tuple<_Args1 ...>&&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\r\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\r\n       return  __and_<__not_<is_same<tuple<_Elements...>,\r\n                                                                                                                                                                                                                                                    ^    \r\n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\r\n     struct is_convertible\r\n        ^~~~~~~~~~~~~~\r\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\r\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible<_Elements, _UElements&&>\u2019\r\n       return __and_<is_constructible<_Elements, _UElements&&>...>::value;\r\n                                                                   ^~~~~\r\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\r\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible<_UElements&&, _Elements>\u2019\r\n       return __and_<is_convertible<_UElements&&, _Elements>...>::value;\r\n                                                                 ^~~~~\r\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(const std::tuple<_Args1 ...>&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\r\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\r\n       return  __and_<__not_<is_same<tuple<_Elements...>,\r\n                                                                                                                                                                                                                                                    ^    \r\n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\r\n     struct is_convertible\r\n        ^~~~~~~~~~~~~~\r\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(std::tuple<_Args1 ...>&&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\r\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\r\n       return  __and_<__not_<is_same<tuple<_Elements...>,\r\n                                                                                                                                                                                                                                                    ^    \r\n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\r\n     struct is_convertible\r\n        ^~~~~~~~~~~~~~\r\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\ncc1plus: warning: unrecognized command line option \u2018-Wno-aligned-allocation-unavailable\u2019\r\ncc1plus: warning: unrecognized command line option \u2018-Wno-inconsistent-missing-override\u2019\r\ncc1plus: warning: unrecognized command line option \u2018-Wno-unused-private-field\u2019\r\ncc1plus: warning: unrecognized command line option \u2018-Wno-unknown-warning-option\u2019\r\ncc1plus: warning: unrecognized command line option \u2018-Wno-typedef-redefinition\u2019\r\ncc1plus: warning: unrecognized command line option \u2018-Wno-invalid-partial-specialization\u2019\r\nCMake Error at caffe2_gpu_generated_THCSortUtils.cu.o.Release.cmake:279 (message):\r\n  Error generating file\r\n  /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/./caffe2_gpu_generated_THCSortUtils.cu.o\r\n\r\n\r\n[3/261] Building NVCC (Device) object caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/caffe2_gpu_generated_THCTensorMathBlas.cu.o\r\nFAILED: caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/caffe2_gpu_generated_THCTensorMathBlas.cu.o \r\ncd /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC && /home/gaoxiang/anaconda3/bin/cmake -E make_directory /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/. && /home/gaoxiang/anaconda3/bin/cmake -D verbose:BOOL=OFF -D build_configuration:STRING=Release -D generated_file:STRING=/home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/./caffe2_gpu_generated_THCTensorMathBlas.cu.o -D generated_cubin_file:STRING=/home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/./caffe2_gpu_generated_THCTensorMathBlas.cu.o.cubin.txt -P /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/caffe2_gpu_generated_THCTensorMathBlas.cu.o.Release.cmake\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\r\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible<_Elements, _UElements&&>\u2019\r\n       return __and_<is_constructible<_Elements, _UElements&&>...>::value;\r\n                                                                   ^~~~~\r\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\r\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible<_UElements&&, _Elements>\u2019\r\n       return __and_<is_convertible<_UElements&&, _Elements>...>::value;\r\n                                                                 ^~~~~\r\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(const std::tuple<_Args1 ...>&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\r\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\r\n       return  __and_<__not_<is_same<tuple<_Elements...>,\r\n                                                                                                                                                                                                                                                    ^    \r\n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\r\n     struct is_convertible\r\n        ^~~~~~~~~~~~~~\r\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(std::tuple<_Args1 ...>&&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\r\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\r\n       return  __and_<__not_<is_same<tuple<_Elements...>,\r\n                                                                                                                                                                                                                                                    ^    \r\n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\r\n     struct is_convertible\r\n        ^~~~~~~~~~~~~~\r\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019:\r\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor&, at::Tensor&, at::Tensor&>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor&, at::Tensor&, at::Tensor&>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\r\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible<_Elements, _UElements&&>\u2019\r\n       return __and_<is_constructible<_Elements, _UElements&&>...>::value;\r\n                                                                   ^~~~~\r\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019:\r\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor&, at::Tensor&, at::Tensor&>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor&, at::Tensor&, at::Tensor&>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\r\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible<_UElements&&, _Elements>\u2019\r\n       return __and_<is_convertible<_UElements&&, _Elements>...>::value;\r\n                                                                 ^~~~~\r\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>&; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019:\r\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor&, at::Tensor&, at::Tensor&>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(const std::tuple<_Args1 ...>&) [with _UElements = {at::Tensor&, at::Tensor&, at::Tensor&}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor&, at::Tensor&, at::Tensor&>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\r\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\r\n       return  __and_<__not_<is_same<tuple<_Elements...>,\r\n                                                                                                                                                                                                                                                    ^    \r\n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\r\n     struct is_convertible\r\n        ^~~~~~~~~~~~~~\r\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>&; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>&&; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019:\r\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor&, at::Tensor&, at::Tensor&>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(std::tuple<_Args1 ...>&&) [with _UElements = {at::Tensor&, at::Tensor&, at::Tensor&}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor&, at::Tensor&, at::Tensor&>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\r\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\r\n       return  __and_<__not_<is_same<tuple<_Elements...>,\r\n                                                                                                                                                                                                                                                    ^    \r\n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\r\n     struct is_convertible\r\n        ^~~~~~~~~~~~~~\r\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>&&; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (5ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (5ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\r\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible<_Elements, _UElements&&>\u2019\r\n       return __and_<is_constructible<_Elements, _UElements&&>...>::value;\r\n                                                                   ^~~~~\r\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (5ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (5ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\r\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible<_UElements&&, _Elements>\u2019\r\n       return __and_<is_convertible<_UElements&&, _Elements>...>::value;\r\n                                                                 ^~~~~\r\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(const std::tuple<_Args1 ...>&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\r\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (6, should be 2)\r\n       return  __and_<__not_<is_same<tuple<_Elements...>,\r\n                                                                                                                                                                                                                                                    ^    \r\n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\r\n     struct is_convertible\r\n        ^~~~~~~~~~~~~~\r\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(std::tuple<_Args1 ...>&&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\r\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (6, should be 2)\r\n       return  __and_<__not_<is_same<tuple<_Elements...>,\r\n                                                                                                                                                                                                                                                    ^    \r\n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\r\n     struct is_convertible\r\n        ^~~~~~~~~~~~~~\r\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019:\r\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\r\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible<_Elements, _UElements&&>\u2019\r\n       return __and_<is_constructible<_Elements, _UElements&&>...>::value;\r\n                                                                   ^~~~~\r\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019:\r\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\r\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible<_UElements&&, _Elements>\u2019\r\n       return __and_<is_convertible<_UElements&&, _Elements>...>::value;\r\n                                                                 ^~~~~\r\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019:\r\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(const std::tuple<_Args1 ...>&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\r\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\r\n       return  __and_<__not_<is_same<tuple<_Elements...>,\r\n                                                                                                                                                                                                                                                    ^    \r\n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\r\n     struct is_convertible\r\n        ^~~~~~~~~~~~~~\r\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019:\r\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(std::tuple<_Args1 ...>&&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\r\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\r\n       return  __and_<__not_<is_same<tuple<_Elements...>,\r\n                                                                                                                                                                                                                                                    ^    \r\n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\r\n     struct is_convertible\r\n        ^~~~~~~~~~~~~~\r\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\r\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible<_Elements, _UElements&&>\u2019\r\n       return __and_<is_constructible<_Elements, _UElements&&>...>::value;\r\n                                                                   ^~~~~\r\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\r\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible<_UElements&&, _Elements>\u2019\r\n       return __and_<is_convertible<_UElements&&, _Elements>...>::value;\r\n                                                                 ^~~~~\r\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(const std::tuple<_Args1 ...>&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\r\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\r\n       return  __and_<__not_<is_same<tuple<_Elements...>,\r\n                                                                                                                                                                                                                                                    ^    \r\n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\r\n     struct is_convertible\r\n        ^~~~~~~~~~~~~~\r\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(std::tuple<_Args1 ...>&&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\r\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\r\n       return  __and_<__not_<is_same<tuple<_Elements...>,\r\n                                                                                                                                                                                                                                                    ^    \r\n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\r\n     struct is_convertible\r\n        ^~~~~~~~~~~~~~\r\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\ncc1plus: warning: unrecognized command line option \u2018-Wno-aligned-allocation-unavailable\u2019\r\ncc1plus: warning: unrecognized command line option \u2018-Wno-inconsistent-missing-override\u2019\r\ncc1plus: warning: unrecognized command line option \u2018-Wno-unused-private-field\u2019\r\ncc1plus: warning: unrecognized command line option \u2018-Wno-unknown-warning-option\u2019\r\ncc1plus: warning: unrecognized command line option \u2018-Wno-typedef-redefinition\u2019\r\ncc1plus: warning: unrecognized command line option \u2018-Wno-invalid-partial-specialization\u2019\r\nCMake Error at caffe2_gpu_generated_THCTensorMathBlas.cu.o.Release.cmake:279 (message):\r\n  Error generating file\r\n  /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/./caffe2_gpu_generated_THCTensorMathBlas.cu.o\r\n\r\n\r\n[4/261] Building NVCC (Device) object caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/caffe2_gpu_generated_THCTensor.cu.o\r\nFAILED: caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/caffe2_gpu_generated_THCTensor.cu.o \r\ncd /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC && /home/gaoxiang/anaconda3/bin/cmake -E make_directory /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/. && /home/gaoxiang/anaconda3/bin/cmake -D verbose:BOOL=OFF -D build_configuration:STRING=Release -D generated_file:STRING=/home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/./caffe2_gpu_generated_THCTensor.cu.o -D generated_cubin_file:STRING=/home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/./caffe2_gpu_generated_THCTensor.cu.o.cubin.txt -P /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/caffe2_gpu_generated_THCTensor.cu.o.Release.cmake\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\r\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible<_Elements, _UElements&&>\u2019\r\n       return __and_<is_constructible<_Elements, _UElements&&>...>::value;\r\n                                                                   ^~~~~\r\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\r\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible<_UElements&&, _Elements>\u2019\r\n       return __and_<is_convertible<_UElements&&, _Elements>...>::value;\r\n                                                                 ^~~~~\r\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(const std::tuple<_Args1 ...>&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\r\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\r\n       return  __and_<__not_<is_same<tuple<_Elements...>,\r\n                                                                                                                                                                                                                                                    ^    \r\n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\r\n     struct is_convertible\r\n        ^~~~~~~~~~~~~~\r\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(std::tuple<_Args1 ...>&&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/TensorMethods.h:649:36:   required from here\r\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\r\n       return  __and_<__not_<is_same<tuple<_Elements...>,\r\n                                                                                                                                                                                                                                                    ^    \r\n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\r\n     struct is_convertible\r\n        ^~~~~~~~~~~~~~\r\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019:\r\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor&, at::Tensor&, at::Tensor&>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor&, at::Tensor&, at::Tensor&>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\r\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible<_Elements, _UElements&&>\u2019\r\n       return __and_<is_constructible<_Elements, _UElements&&>...>::value;\r\n                                                                   ^~~~~\r\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019:\r\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor&, at::Tensor&, at::Tensor&>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor&, at::Tensor&, at::Tensor&>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (3ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\r\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible<_UElements&&, _Elements>\u2019\r\n       return __and_<is_convertible<_UElements&&, _Elements>...>::value;\r\n                                                                 ^~~~~\r\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>}; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>&; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019:\r\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor&, at::Tensor&, at::Tensor&>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(const std::tuple<_Args1 ...>&) [with _UElements = {at::Tensor&, at::Tensor&, at::Tensor&}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor&, at::Tensor&, at::Tensor&>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\r\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\r\n       return  __and_<__not_<is_same<tuple<_Elements...>,\r\n                                                                                                                                                                                                                                                    ^    \r\n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\r\n     struct is_convertible\r\n        ^~~~~~~~~~~~~~\r\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>&; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>&&; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019:\r\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor&, at::Tensor&, at::Tensor&>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(std::tuple<_Args1 ...>&&) [with _UElements = {at::Tensor&, at::Tensor&, at::Tensor&}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor&, at::Tensor&, at::Tensor&>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor&, at::Tensor&, at::Tensor&>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:1953:61:   required from here\r\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (4, should be 2)\r\n       return  __and_<__not_<is_same<tuple<_Elements...>,\r\n                                                                                                                                                                                                                                                    ^    \r\n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\r\n     struct is_convertible\r\n        ^~~~~~~~~~~~~~\r\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor&, at::Tensor&, at::Tensor&>&&; bool <anonymous> = true; _Elements = {at::Tensor&, at::Tensor&, at::Tensor&}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (5ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (5ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\r\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible<_Elements, _UElements&&>\u2019\r\n       return __and_<is_constructible<_Elements, _UElements&&>...>::value;\r\n                                                                   ^~~~~\r\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (5ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (5ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\r\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible<_UElements&&, _Elements>\u2019\r\n       return __and_<is_convertible<_UElements&&, _Elements>...>::value;\r\n                                                                 ^~~~~\r\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(const std::tuple<_Args1 ...>&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\r\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (6, should be 2)\r\n       return  __and_<__not_<is_same<tuple<_Elements...>,\r\n                                                                                                                                                                                                                                                    ^    \r\n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\r\n     struct is_convertible\r\n        ^~~~~~~~~~~~~~\r\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(std::tuple<_Args1 ...>&&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3117:189:   required from here\r\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (6, should be 2)\r\n       return  __and_<__not_<is_same<tuple<_Elements...>,\r\n                                                                                                                                                                                                                                                    ^    \r\n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\r\n     struct is_convertible\r\n        ^~~~~~~~~~~~~~\r\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019:\r\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\r\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible<_Elements, _UElements&&>\u2019\r\n       return __and_<is_constructible<_Elements, _UElements&&>...>::value;\r\n                                                                   ^~~~~\r\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019:\r\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\r\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible<_UElements&&, _Elements>\u2019\r\n       return __and_<is_convertible<_UElements&&, _Elements>...>::value;\r\n                                                                 ^~~~~\r\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019:\r\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(const std::tuple<_Args1 ...>&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\r\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\r\n       return  __and_<__not_<is_same<tuple<_Elements...>,\r\n                                                                                                                                                                                                                                                    ^    \r\n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\r\n     struct is_convertible\r\n        ^~~~~~~~~~~~~~\r\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019:\r\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(std::tuple<_Args1 ...>&&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3120:259:   required from here\r\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\r\n       return  __and_<__not_<is_same<tuple<_Elements...>,\r\n                                                                                                                                                                                                                                                    ^    \r\n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\r\n     struct is_convertible\r\n        ^~~~~~~~~~~~~~\r\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> > >&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, std::vector<at::Tensor, std::allocator<at::Tensor> >}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:626:248:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\r\n/usr/include/c++/6/tuple:483:67: error: mismatched argument pack lengths while expanding \u2018std::is_constructible<_Elements, _UElements&&>\u2019\r\n       return __and_<is_constructible<_Elements, _UElements&&>...>::value;\r\n                                                                   ^~~~~\r\n/usr/include/c++/6/tuple:484:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_MoveConstructibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:626:362:   required by substitution of \u2018template<class ... _UElements, typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; typename std::enable_if<(((std::_TC<(sizeof... (_UElements) == 1), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NotSameTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>()) && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && (4ul >= 1)), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\r\n/usr/include/c++/6/tuple:489:65: error: mismatched argument pack lengths while expanding \u2018std::is_convertible<_UElements&&, _Elements>\u2019\r\n       return __and_<is_convertible<_UElements&&, _Elements>...>::value;\r\n                                                                 ^~~~~\r\n/usr/include/c++/6/tuple:490:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_ImplicitlyMoveConvertibleTuple() [with _UElements = {std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>}; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:662:419:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(const std::tuple<_Args1 ...>&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<const tuple<_Elements ...>&>()), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\r\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\r\n       return  __and_<__not_<is_same<tuple<_Elements...>,\r\n                                                                                                                                                                                                                                                    ^    \r\n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\r\n     struct is_convertible\r\n        ^~~~~~~~~~~~~~\r\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = const std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\n/usr/include/c++/6/tuple: In instantiation of \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019:\r\n/usr/include/c++/6/tuple:686:422:   required by substitution of \u2018template<class ... _UElements, class _Dummy, typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> > constexpr std::tuple< <template-parameter-1-1> >::tuple(std::tuple<_Args1 ...>&&) [with _UElements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}; _Dummy = void; typename std::enable_if<((std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_MoveConstructibleTuple<_UElements ...>() && std::_TC<(1ul == sizeof... (_UElements)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_ImplicitlyMoveConvertibleTuple<_UElements ...>()) && std::_TC<(std::is_same<_Dummy, void>::value && (1ul == 1)), at::Tensor, at::Tensor, at::Tensor, at::Tensor>::_NonNestedTuple<tuple<_Elements ...>&&>()), bool>::type <anonymous> = <missing>]\u2019\r\n/home/gaoxiang/pytorch/build/aten/src/ATen/Functions.h:3460:99:   required from here\r\n/usr/include/c++/6/tuple:495:244: error: wrong number of template arguments (5, should be 2)\r\n       return  __and_<__not_<is_same<tuple<_Elements...>,\r\n                                                                                                                                                                                                                                                    ^    \r\n/usr/include/c++/6/type_traits:1558:8: note: provided for \u2018template<class _From, class _To> struct std::is_convertible\u2019\r\n     struct is_convertible\r\n        ^~~~~~~~~~~~~~\r\n/usr/include/c++/6/tuple:502:1: error: body of constexpr function \u2018static constexpr bool std::_TC<<anonymous>, _Elements>::_NonNestedTuple() [with _SrcTuple = std::tuple<at::Tensor, at::Tensor, at::Tensor, at::Tensor>&&; bool <anonymous> = true; _Elements = {at::Tensor, at::Tensor, at::Tensor, at::Tensor}]\u2019 not a return-statement\r\n     }\r\n ^\r\ncc1plus: warning: unrecognized command line option \u2018-Wno-aligned-allocation-unavailable\u2019\r\ncc1plus: warning: unrecognized command line option \u2018-Wno-inconsistent-missing-override\u2019\r\ncc1plus: warning: unrecognized command line option \u2018-Wno-unused-private-field\u2019\r\ncc1plus: warning: unrecognized command line option \u2018-Wno-unknown-warning-option\u2019\r\ncc1plus: warning: unrecognized command line option \u2018-Wno-typedef-redefinition\u2019\r\ncc1plus: warning: unrecognized command line option \u2018-Wno-invalid-partial-specialization\u2019\r\nCMake Error at caffe2_gpu_generated_THCTensor.cu.o.Release.cmake:279 (message):\r\n  Error generating file\r\n  /home/gaoxiang/pytorch/build/caffe2/CMakeFiles/caffe2_gpu.dir/__/aten/src/THC/./caffe2_gpu_generated_THCTensor.cu.o\r\n```"}