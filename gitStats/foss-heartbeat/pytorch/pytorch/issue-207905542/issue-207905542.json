{"url": "https://api.github.com/repos/pytorch/pytorch/issues/751", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/751/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/751/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/751/events", "html_url": "https://github.com/pytorch/pytorch/issues/751", "id": 207905542, "node_id": "MDU6SXNzdWUyMDc5MDU1NDI=", "number": 751, "title": "Feature Request: Add BCELossWithLogits to replace BCELoss for numerical stability.", "user": {"login": "yzgao", "id": 3638353, "node_id": "MDQ6VXNlcjM2MzgzNTM=", "avatar_url": "https://avatars3.githubusercontent.com/u/3638353?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yzgao", "html_url": "https://github.com/yzgao", "followers_url": "https://api.github.com/users/yzgao/followers", "following_url": "https://api.github.com/users/yzgao/following{/other_user}", "gists_url": "https://api.github.com/users/yzgao/gists{/gist_id}", "starred_url": "https://api.github.com/users/yzgao/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yzgao/subscriptions", "organizations_url": "https://api.github.com/users/yzgao/orgs", "repos_url": "https://api.github.com/users/yzgao/repos", "events_url": "https://api.github.com/users/yzgao/events{/privacy}", "received_events_url": "https://api.github.com/users/yzgao/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 586698444, "node_id": "MDU6TGFiZWw1ODY2OTg0NDQ=", "url": "https://api.github.com/repos/pytorch/pytorch/labels/1hr", "name": "1hr", "color": "d4c5f9", "default": false}, {"id": 424131847, "node_id": "MDU6TGFiZWw0MjQxMzE4NDc=", "url": "https://api.github.com/repos/pytorch/pytorch/labels/bug", "name": "bug", "color": "b60205", "default": true}, {"id": 443484050, "node_id": "MDU6TGFiZWw0NDM0ODQwNTA=", "url": "https://api.github.com/repos/pytorch/pytorch/labels/medium%20priority", "name": "medium priority", "color": "fbca04", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 7, "created_at": "2017-02-15T19:36:30Z", "updated_at": "2017-07-04T21:30:01Z", "closed_at": "2017-07-04T21:30:01Z", "author_association": "NONE", "body_html": "<p>Hi,</p>\n<p>I recently switched my codebase from tensorflow to pytorch. After watching the tutorials as well as some example projects, I felt quite excited about pytorch. It is way more easier to use and more transparent than tensorflow. The source code is very enjoyable to read. Thanks for making it public.</p>\n<p>I have a feature request stated as follows.</p>\n<p>I am using BCELoss for training discriminator in GANs. However, I noticed that BCELoss is built on top of sigmoid layer, which is numerically unstable. In my tensorflow implementation, I used sigmoid_cross_entropy_with_logits, which can prevent the overflow situation that often happens when we start to train from scratch.</p>\n<p>I wrote a very basic module to replace BCELoss in my code. The code below illustrates the idea, and is definitely not a very formal code. I feel that it is necessary to add similar loss modules to address this numerical stability issue.</p>\n<pre><code>class StableBCELoss(nn.modules.Module):\n       def __init__(self):\n             super(StableBCELoss, self).__init__()\n       def forward(self, input, target):\n             neg_abs = - input.abs()\n             loss = input.clamp(min=0) - input * target + (1 + neg_abs.exp()).log()\n             return loss.mean()\n</code></pre>", "body_text": "Hi,\nI recently switched my codebase from tensorflow to pytorch. After watching the tutorials as well as some example projects, I felt quite excited about pytorch. It is way more easier to use and more transparent than tensorflow. The source code is very enjoyable to read. Thanks for making it public.\nI have a feature request stated as follows.\nI am using BCELoss for training discriminator in GANs. However, I noticed that BCELoss is built on top of sigmoid layer, which is numerically unstable. In my tensorflow implementation, I used sigmoid_cross_entropy_with_logits, which can prevent the overflow situation that often happens when we start to train from scratch.\nI wrote a very basic module to replace BCELoss in my code. The code below illustrates the idea, and is definitely not a very formal code. I feel that it is necessary to add similar loss modules to address this numerical stability issue.\nclass StableBCELoss(nn.modules.Module):\n       def __init__(self):\n             super(StableBCELoss, self).__init__()\n       def forward(self, input, target):\n             neg_abs = - input.abs()\n             loss = input.clamp(min=0) - input * target + (1 + neg_abs.exp()).log()\n             return loss.mean()", "body": "Hi, \r\n\r\nI recently switched my codebase from tensorflow to pytorch. After watching the tutorials as well as some example projects, I felt quite excited about pytorch. It is way more easier to use and more transparent than tensorflow. The source code is very enjoyable to read. Thanks for making it public.\r\n\r\nI have a feature request stated as follows.\r\n\r\nI am using BCELoss for training discriminator in GANs. However, I noticed that BCELoss is built on top of sigmoid layer, which is numerically unstable. In my tensorflow implementation, I used sigmoid_cross_entropy_with_logits, which can prevent the overflow situation that often happens when we start to train from scratch. \r\n\r\nI wrote a very basic module to replace BCELoss in my code. The code below illustrates the idea, and is definitely not a very formal code. I feel that it is necessary to add similar loss modules to address this numerical stability issue.\r\n\r\n```\r\nclass StableBCELoss(nn.modules.Module):\r\n       def __init__(self):\r\n             super(StableBCELoss, self).__init__()\r\n       def forward(self, input, target):\r\n             neg_abs = - input.abs()\r\n             loss = input.clamp(min=0) - input * target + (1 + neg_abs.exp()).log()\r\n             return loss.mean()\r\n```\r\n\r\n"}