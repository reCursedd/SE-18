{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/180153874", "pull_request_review_id": 110525250, "id": 180153874, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4MDE1Mzg3NA==", "diff_hunk": "@@ -0,0 +1,50 @@\n+#pragma once\n+\n+#include <torch/nn/module.h>\n+#include <torch/nn/rnn.h>\n+#include <torch/tensor.h>\n+\n+#include <ATen/ATen.h>\n+\n+#include <vector>\n+\n+namespace torch { namespace nn {\n+\n+// This is largely just a proof-of-concept of the interface.\n+class LSTM : public torch::nn::CloneableModule<LSTM> {\n+ public:\n+  LSTM(long input_features, long state_size)\n+      : CloneableModule<LSTM>(\"LSTM\"),\n+        weights_(at::randn(\n+            torch::CPU(at::kFloat),\n+            {3 * state_size, input_features * state_size})),\n+        bias_(at::randn(torch::CPU(at::kFloat), {3 * state_size})) {\n+    register_parameters({{\"weights\", weights_}, {\"bias\", bias_}});\n+  }\n+\n+  std::vector<torch::Tensor> forward(\n+      const std::vector<torch::Tensor>& inputs) override {", "path": "torch/csrc/api/include/torch/nn/rnn.h", "position": 26, "original_position": 26, "commit_id": "0b7918bf1a5cb58c7ec4aeff0e6dd310b30ec134", "original_commit_id": "159082394a77aac7544a262384f1fd77725a24c1", "user": {"login": "ebetica", "id": 3605224, "node_id": "MDQ6VXNlcjM2MDUyMjQ=", "avatar_url": "https://avatars3.githubusercontent.com/u/3605224?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebetica", "html_url": "https://github.com/ebetica", "followers_url": "https://api.github.com/users/ebetica/followers", "following_url": "https://api.github.com/users/ebetica/following{/other_user}", "gists_url": "https://api.github.com/users/ebetica/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebetica/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebetica/subscriptions", "organizations_url": "https://api.github.com/users/ebetica/orgs", "repos_url": "https://api.github.com/users/ebetica/repos", "events_url": "https://api.github.com/users/ebetica/events{/privacy}", "received_events_url": "https://api.github.com/users/ebetica/received_events", "type": "User", "site_admin": false}, "body": "It's pretty impossible to get varadic functions in C++. Even if you do use hacks to get it to accept different function signatures, if you have two models that output the same type of output and has different input types, and they both subclass a common super class, the compiler will be confused on which one to call.\r\n\r\nI feel that a good compromise in this case is to use variants. I suggest we shoot for C++17 to make the code simpler, using structured bindings:\r\n\r\n```c++\r\nstd::vector<torch::Variant> forward(const std::vector<torch::Variant>& inputs) override {\r\nauto [ x, y, z ] = this->decode<int, torch::Tensor, std::string>(inputs);\r\n}\r\n```\r\n\r\nhttps://skebanga.github.io/structured-bindings/", "created_at": "2018-04-09T16:29:14Z", "updated_at": "2018-11-23T15:42:04Z", "html_url": "https://github.com/pytorch/pytorch/pull/6345#discussion_r180153874", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/6345", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/180153874"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/6345#discussion_r180153874"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/6345"}}, "body_html": "<p>It's pretty impossible to get varadic functions in C++. Even if you do use hacks to get it to accept different function signatures, if you have two models that output the same type of output and has different input types, and they both subclass a common super class, the compiler will be confused on which one to call.</p>\n<p>I feel that a good compromise in this case is to use variants. I suggest we shoot for C++17 to make the code simpler, using structured bindings:</p>\n<div class=\"highlight highlight-source-c++\"><pre>std::vector&lt;torch::Variant&gt; <span class=\"pl-en\">forward</span>(<span class=\"pl-k\">const</span> std::vector&lt;torch::Variant&gt;&amp; inputs) <span class=\"pl-k\">override</span> {\n<span class=\"pl-k\">auto</span> [ x, y, z ] = <span class=\"pl-c1\">this</span>-&gt;<span class=\"pl-smi\">decode</span>&lt;<span class=\"pl-k\">int</span>, torch::Tensor, std::string&gt;(inputs);\n}</pre></div>\n<p><a href=\"https://skebanga.github.io/structured-bindings/\" rel=\"nofollow\">https://skebanga.github.io/structured-bindings/</a></p>", "body_text": "It's pretty impossible to get varadic functions in C++. Even if you do use hacks to get it to accept different function signatures, if you have two models that output the same type of output and has different input types, and they both subclass a common super class, the compiler will be confused on which one to call.\nI feel that a good compromise in this case is to use variants. I suggest we shoot for C++17 to make the code simpler, using structured bindings:\nstd::vector<torch::Variant> forward(const std::vector<torch::Variant>& inputs) override {\nauto [ x, y, z ] = this->decode<int, torch::Tensor, std::string>(inputs);\n}\nhttps://skebanga.github.io/structured-bindings/", "in_reply_to_id": 179962103}