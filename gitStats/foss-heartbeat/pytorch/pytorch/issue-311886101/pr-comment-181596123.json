{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/181596123", "pull_request_review_id": 112250441, "id": 181596123, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4MTU5NjEyMw==", "diff_hunk": "@@ -0,0 +1,157 @@\n+#pragma once\n+\n+#include <torch/tensor.h>\n+\n+#include <cstdint>\n+#include <iterator>\n+#include <limits>\n+#include <string>\n+#include <type_traits>\n+\n+// Forward declarations.\n+namespace torch { namespace nn {\n+class Module;\n+}} // namespace torch::nn\n+\n+namespace torch {\n+namespace detail {\n+/// Provides hierarchical iteration support, with convenient iterator functions\n+/// like `map` or `find`.\n+template <typename T>\n+class CursorBase {\n+ public:\n+  // NOTE: This is a template class, but we explicitly instantiate it in the\n+  // .cpp file for every type necessary, so we can define it in the .cpp file.\n+  // Hooray!\n+\n+  /// A `(key, value)` pair exposed by cursor iterators.\n+  struct Item {\n+    Item(const std::string& key_, T& module_);\n+\n+    T& operator*();\n+    T* operator->();\n+\n+    // These are references into a `Module`'s containers\n+    const std::string& key;\n+    T& value;\n+  };\n+\n+  // Picks either `const_iterator` or `iterator` as the iterator type, depending\n+  // on whether `T` is const.\n+  using Iterator = typename std::conditional<\n+      std::is_const<T>::value,\n+      typename std::vector<Item>::const_iterator,\n+      typename std::vector<Item>::iterator>::type;\n+\n+  // No need for a virtual destructor, as cursors are not intended to be used\n+  // polymorhpically (i.e. we are relying on non-virtual inheritance).\n+\n+  // Note that these functions may only be called on lvalues (that's the\n+  // ampersand next to the function)! This prevents code like `auto iterator =\n+  // module.modules().begin()`, since `iterator` would be pointing to a `vector`\n+  // that gets destructed at the end of the expression. This is not a problem\n+  // for range loops, as they capture the range expression (the thing to the\n+  // right of the colon in `for (auto x : ...)`) before iteration.\n+  Iterator begin() & noexcept;\n+  Iterator end() & noexcept;\n+\n+  /// Applies a function to every *value* available. The function should accept\n+  /// a single argument, that is a reference to the value type (e.g. `Module&`).\n+  template <typename Function>\n+  void apply(const Function& function) {\n+    for (auto module : *this) {\n+      function(*module);\n+    }\n+  }\n+\n+  /// Applies a function to every *item* available. The function should accept\n+  /// two arguments, one taking a reference to the key type (always `const\n+  /// std::string&`) and the other taking a reference to the value type (e.g.\n+  /// `Module&`).\n+  template <typename Function>\n+  void apply_items(const Function& function) {\n+    for (auto module : *this) {\n+      function(module.key, *module);\n+    }\n+  }\n+\n+  /// Applies a function to every *value* available, and stores the return value\n+  /// of the function into the iterator. The function should accept\n+  /// a single argument, that is a reference to the value type (e.g. `Module&`).\n+  template <typename Iterator, typename Function>\n+  void map(Iterator output_iterator, Function function) {\n+    for (auto module : *this) {\n+      *output_iterator = function(*module);\n+    }\n+  }\n+\n+  /// Applies a function to every *value* available, and stores the return value\n+  /// of the function into the iterator. The function should accept\n+  /// two arguments, one taking a reference to the key type (always `const\n+  /// std::string&`) and the other taking a referen\n+  template <typename Iterator, typename Function>\n+  void map_items(Iterator output_iterator, Function function) {\n+    for (auto module : *this) {\n+      *output_iterator = function(module.key, *module);\n+    }\n+  }\n+\n+  /// Attempts to find a value for the given `key`. If found, returns a pointer\n+  /// to the value. If not, returns a null pointer.\n+  T* find(const std::string& key) noexcept;\n+\n+  /// Returns true if an item with the given `key` exists.\n+  bool contains(const std::string& key) noexcept;\n+\n+  /// Counts the number of items available.\n+  size_t size() const noexcept;\n+\n+ protected:\n+  std::vector<Item> items_;", "path": "torch/csrc/api/include/torch/nn/cursor.h", "position": 110, "original_position": 110, "commit_id": "0b7918bf1a5cb58c7ec4aeff0e6dd310b30ec134", "original_commit_id": "0b7918bf1a5cb58c7ec4aeff0e6dd310b30ec134", "user": {"login": "goldsborough", "id": 6429851, "node_id": "MDQ6VXNlcjY0Mjk4NTE=", "avatar_url": "https://avatars3.githubusercontent.com/u/6429851?v=4", "gravatar_id": "", "url": "https://api.github.com/users/goldsborough", "html_url": "https://github.com/goldsborough", "followers_url": "https://api.github.com/users/goldsborough/followers", "following_url": "https://api.github.com/users/goldsborough/following{/other_user}", "gists_url": "https://api.github.com/users/goldsborough/gists{/gist_id}", "starred_url": "https://api.github.com/users/goldsborough/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/goldsborough/subscriptions", "organizations_url": "https://api.github.com/users/goldsborough/orgs", "repos_url": "https://api.github.com/users/goldsborough/repos", "events_url": "https://api.github.com/users/goldsborough/events{/privacy}", "received_events_url": "https://api.github.com/users/goldsborough/received_events", "type": "User", "site_admin": false}, "body": "So I had this first, but it adds some complication. Primarily, doing iterative DFS requires parent pointers, and that makes it super hard/dangerous to do things like moves (since all the parent pointers have to be updated). I discussed this with Zach, and we'll never really have more than, say, 100 elements in the hierarchy right (and maybe 10 in practice)? So highly likely this will be fast enough for anyone (and the code is so much simpler). So I figured we'll start with the simple solution, and can always add back the more complex one if it's unbearable (I still have the code)", "created_at": "2018-04-15T20:36:43Z", "updated_at": "2018-11-23T15:42:29Z", "html_url": "https://github.com/pytorch/pytorch/pull/6345#discussion_r181596123", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/6345", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/181596123"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/6345#discussion_r181596123"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/6345"}}, "body_html": "<p>So I had this first, but it adds some complication. Primarily, doing iterative DFS requires parent pointers, and that makes it super hard/dangerous to do things like moves (since all the parent pointers have to be updated). I discussed this with Zach, and we'll never really have more than, say, 100 elements in the hierarchy right (and maybe 10 in practice)? So highly likely this will be fast enough for anyone (and the code is so much simpler). So I figured we'll start with the simple solution, and can always add back the more complex one if it's unbearable (I still have the code)</p>", "body_text": "So I had this first, but it adds some complication. Primarily, doing iterative DFS requires parent pointers, and that makes it super hard/dangerous to do things like moves (since all the parent pointers have to be updated). I discussed this with Zach, and we'll never really have more than, say, 100 elements in the hierarchy right (and maybe 10 in practice)? So highly likely this will be fast enough for anyone (and the code is so much simpler). So I figured we'll start with the simple solution, and can always add back the more complex one if it's unbearable (I still have the code)", "in_reply_to_id": 181595538}