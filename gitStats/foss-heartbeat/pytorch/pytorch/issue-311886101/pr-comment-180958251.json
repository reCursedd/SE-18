{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/180958251", "pull_request_review_id": 111471830, "id": 180958251, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4MDk1ODI1MQ==", "diff_hunk": "@@ -245,28 +186,28 @@ struct Module : public std::enable_shared_from_this<Module> {\n     return methods.values();\n   }\n \n-\n-  at::optional<NamedParameter&> find_parameter(const std::string& name) {\n+  NamedParameter* find_parameter(const std::string& name) {\n     return parameters.find(name);\n   }\n-  at::optional<NamedModule&> find_module(const std::string& name) {\n+  NamedModule* find_module(const std::string& name) {\n     return modules.find(name);\n   }\n-  at::optional<Method&> find_method(const std::string& name) {\n-    if(auto pm = methods.find(name))\n-      return at::optional<Method&>(**pm);\n-    return at::nullopt;\n+  Method* find_method(const std::string& name) {\n+    if (auto method = methods.find(name)) {\n+      return method->get();\n+    }\n+    return nullptr;", "path": "torch/csrc/jit/script/module.h", "position": 121, "original_position": 105, "commit_id": "0b7918bf1a5cb58c7ec4aeff0e6dd310b30ec134", "original_commit_id": "cae76cd6041dbd56cadcdcc50f55380a21df08e7", "user": {"login": "goldsborough", "id": 6429851, "node_id": "MDQ6VXNlcjY0Mjk4NTE=", "avatar_url": "https://avatars3.githubusercontent.com/u/6429851?v=4", "gravatar_id": "", "url": "https://api.github.com/users/goldsborough", "html_url": "https://github.com/goldsborough", "followers_url": "https://api.github.com/users/goldsborough/followers", "following_url": "https://api.github.com/users/goldsborough/following{/other_user}", "gists_url": "https://api.github.com/users/goldsborough/gists{/gist_id}", "starred_url": "https://api.github.com/users/goldsborough/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/goldsborough/subscriptions", "organizations_url": "https://api.github.com/users/goldsborough/orgs", "repos_url": "https://api.github.com/users/goldsborough/repos", "events_url": "https://api.github.com/users/goldsborough/events{/privacy}", "received_events_url": "https://api.github.com/users/goldsborough/received_events", "type": "User", "site_admin": false}, "body": "Sooo the thing is, it's technically not valid to have an `optional<&T>` (it's usually not ever valid to store a reference in a container, and `optional` is a container). There is an explanation [here](https://stackoverflow.com/questions/26858034/stdoptional-specialization-for-reference-types), and it is also mentioned in [cppreference.com](http://en.cppreference.com/w/cpp/utility/optional):\r\n\r\n> There are no optional references; a program is ill-formed if it instantiates an optional with a reference type. Alternatively, an optional of a std::reference_wrapper of type T may be used to hold a reference.\r\n\r\nIt worked here because we weren't using the `optional<T&>` in a way that breaks it, e.g.\r\n\r\n```\r\nint x = 5;\r\nat::optional<int&> o;\r\no.emplace(x);\r\no = x; // should work according to API of std::optional, works for references, but compiler error!\r\n\r\ne.cpp:90:5: error: use of deleted function \u2018typename std::enable_if<(! std::is_same<typename std::decay<_Tp>::type, at::optional<T&> >::value), at::optional<T&>&>::type at::optional<T&>::operator=(U&&) [with U = int&; T = int; typename std::enable_if<(! std::is_same<typename std::decay<_Tp>::type, at::optional<T&> >::value), at::optional<T&>&>::type = at::optional<int&>&]\u2019\r\n   o = x;\r\n     ^\r\n```\r\n\r\nThe solutions are:\r\n1. Continue illegal use of `at::optional` in this way, hoping we won't use it in a way that breaks\r\n2. Use `at::optional<std::reference_wrapper<T>>`, but it makes accessing the value harder (`*o` doesn't give you a `T` directly ...)\r\n3. Use the original type responsible for representing \"a nullable reference to something\": pointers, old school pointers\r\n\r\n@zdevito (author of said code)\r\n\r\n", "created_at": "2018-04-12T03:47:44Z", "updated_at": "2018-11-23T15:42:17Z", "html_url": "https://github.com/pytorch/pytorch/pull/6345#discussion_r180958251", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/6345", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/180958251"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/6345#discussion_r180958251"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/6345"}}, "body_html": "<p>Sooo the thing is, it's technically not valid to have an <code>optional&lt;&amp;T&gt;</code> (it's usually not ever valid to store a reference in a container, and <code>optional</code> is a container). There is an explanation <a href=\"https://stackoverflow.com/questions/26858034/stdoptional-specialization-for-reference-types\" rel=\"nofollow\">here</a>, and it is also mentioned in <a href=\"http://en.cppreference.com/w/cpp/utility/optional\" rel=\"nofollow\">cppreference.com</a>:</p>\n<blockquote>\n<p>There are no optional references; a program is ill-formed if it instantiates an optional with a reference type. Alternatively, an optional of a std::reference_wrapper of type T may be used to hold a reference.</p>\n</blockquote>\n<p>It worked here because we weren't using the <code>optional&lt;T&amp;&gt;</code> in a way that breaks it, e.g.</p>\n<pre><code>int x = 5;\nat::optional&lt;int&amp;&gt; o;\no.emplace(x);\no = x; // should work according to API of std::optional, works for references, but compiler error!\n\ne.cpp:90:5: error: use of deleted function \u2018typename std::enable_if&lt;(! std::is_same&lt;typename std::decay&lt;_Tp&gt;::type, at::optional&lt;T&amp;&gt; &gt;::value), at::optional&lt;T&amp;&gt;&amp;&gt;::type at::optional&lt;T&amp;&gt;::operator=(U&amp;&amp;) [with U = int&amp;; T = int; typename std::enable_if&lt;(! std::is_same&lt;typename std::decay&lt;_Tp&gt;::type, at::optional&lt;T&amp;&gt; &gt;::value), at::optional&lt;T&amp;&gt;&amp;&gt;::type = at::optional&lt;int&amp;&gt;&amp;]\u2019\n   o = x;\n     ^\n</code></pre>\n<p>The solutions are:</p>\n<ol>\n<li>Continue illegal use of <code>at::optional</code> in this way, hoping we won't use it in a way that breaks</li>\n<li>Use <code>at::optional&lt;std::reference_wrapper&lt;T&gt;&gt;</code>, but it makes accessing the value harder (<code>*o</code> doesn't give you a <code>T</code> directly ...)</li>\n<li>Use the original type responsible for representing \"a nullable reference to something\": pointers, old school pointers</li>\n</ol>\n<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=370202\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/zdevito\">@zdevito</a> (author of said code)</p>", "body_text": "Sooo the thing is, it's technically not valid to have an optional<&T> (it's usually not ever valid to store a reference in a container, and optional is a container). There is an explanation here, and it is also mentioned in cppreference.com:\n\nThere are no optional references; a program is ill-formed if it instantiates an optional with a reference type. Alternatively, an optional of a std::reference_wrapper of type T may be used to hold a reference.\n\nIt worked here because we weren't using the optional<T&> in a way that breaks it, e.g.\nint x = 5;\nat::optional<int&> o;\no.emplace(x);\no = x; // should work according to API of std::optional, works for references, but compiler error!\n\ne.cpp:90:5: error: use of deleted function \u2018typename std::enable_if<(! std::is_same<typename std::decay<_Tp>::type, at::optional<T&> >::value), at::optional<T&>&>::type at::optional<T&>::operator=(U&&) [with U = int&; T = int; typename std::enable_if<(! std::is_same<typename std::decay<_Tp>::type, at::optional<T&> >::value), at::optional<T&>&>::type = at::optional<int&>&]\u2019\n   o = x;\n     ^\n\nThe solutions are:\n\nContinue illegal use of at::optional in this way, hoping we won't use it in a way that breaks\nUse at::optional<std::reference_wrapper<T>>, but it makes accessing the value harder (*o doesn't give you a T directly ...)\nUse the original type responsible for representing \"a nullable reference to something\": pointers, old school pointers\n\n@zdevito (author of said code)", "in_reply_to_id": 180578139}