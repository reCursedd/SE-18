{"url": "https://api.github.com/repos/pytorch/pytorch/issues/3844", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/3844/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/3844/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/3844/events", "html_url": "https://github.com/pytorch/pytorch/issues/3844", "id": 276200228, "node_id": "MDU6SXNzdWUyNzYyMDAyMjg=", "number": 3844, "title": "Indexing Variable with repeated indices", "user": {"login": "trypag", "id": 13003839, "node_id": "MDQ6VXNlcjEzMDAzODM5", "avatar_url": "https://avatars1.githubusercontent.com/u/13003839?v=4", "gravatar_id": "", "url": "https://api.github.com/users/trypag", "html_url": "https://github.com/trypag", "followers_url": "https://api.github.com/users/trypag/followers", "following_url": "https://api.github.com/users/trypag/following{/other_user}", "gists_url": "https://api.github.com/users/trypag/gists{/gist_id}", "starred_url": "https://api.github.com/users/trypag/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/trypag/subscriptions", "organizations_url": "https://api.github.com/users/trypag/orgs", "repos_url": "https://api.github.com/users/trypag/repos", "events_url": "https://api.github.com/users/trypag/events{/privacy}", "received_events_url": "https://api.github.com/users/trypag/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2017-11-22T20:48:45Z", "updated_at": "2017-11-23T07:47:51Z", "closed_at": "2017-11-23T07:47:51Z", "author_association": "NONE", "body_html": "<p>Hey,<br>\nI have been thinking about this problem for a few days now, trying to get some help from the forum <a href=\"https://discuss.pytorch.org/t/indexing-with-repeating-indices-numpy-add-at/10223/6\" rel=\"nofollow\">also</a>, but none seems to work. The problem might seem simple, I found no solution to it :</p>\n<p>let's say you have a first index tensor <code>m</code> containing indices between 0 and 5 :</p>\n<pre><code>Variable containing:\n(0 ,.,.) = \n  4  4  3  0\n  3  4  2  3\n  2  3  1  1\n  1  4  3  1\n[torch.LongTensor of size 1x4x4]\n</code></pre>\n<p>and a second index tensor <code>p</code> of same size, containing indices between 0 and 5 :</p>\n<pre><code>Variable containing:\n(0 ,.,.) = \n  1  1  1  1\n  1  1  1  1\n  1  1  1  1\n  1  1  1  1\n[torch.LongTensor of size 1x4x4]\n</code></pre>\n<p>finally a matrix <code>g</code> of size 5x5 initially set to 0.</p>\n<pre><code>g = torch.LongTensor(5,5).zero_()\n</code></pre>\n<p>The indexing would proceed like this, pair each index from tensor <code>m</code> and <code>p</code> and increment the <code>g</code> matrix at each index pair.</p>\n<pre><code>g[m, p] += 1\n</code></pre>\n<p>For example for the first row of <code>m</code> and <code>p</code>, I would want this behaviour:</p>\n<pre><code>g[1, 4] += 1\ng[1, 4] += 1 # same index as previous\ng[1, 3] += 1\ng[1, 0] += 1\n</code></pre>\n<p>you will notice however that the output of <code>g</code> is :</p>\n<pre><code>(0 ,.,.) = \n  0  1  0  0  0\n  0  1  0  0  0\n  0  1  0  0  0\n  0  1  0  0  0\n  0  1  0  0  0\n[torch.LongTensor of size 1x5x5]\n</code></pre>\n<p>The current indexing only increases g[1, 4] by 1 instead of 2 (because of repeated indices). There is an equivalent to this in numpy with <a href=\"https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ufunc.at.html\" rel=\"nofollow\">https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ufunc.at.html</a></p>\n<p>Soumith pointed me to <code>index_add_</code>, not sure this would be a good candidate however it's an inplace op, not compatible with autograd.</p>\n<p>Thanks :)</p>", "body_text": "Hey,\nI have been thinking about this problem for a few days now, trying to get some help from the forum also, but none seems to work. The problem might seem simple, I found no solution to it :\nlet's say you have a first index tensor m containing indices between 0 and 5 :\nVariable containing:\n(0 ,.,.) = \n  4  4  3  0\n  3  4  2  3\n  2  3  1  1\n  1  4  3  1\n[torch.LongTensor of size 1x4x4]\n\nand a second index tensor p of same size, containing indices between 0 and 5 :\nVariable containing:\n(0 ,.,.) = \n  1  1  1  1\n  1  1  1  1\n  1  1  1  1\n  1  1  1  1\n[torch.LongTensor of size 1x4x4]\n\nfinally a matrix g of size 5x5 initially set to 0.\ng = torch.LongTensor(5,5).zero_()\n\nThe indexing would proceed like this, pair each index from tensor m and p and increment the g matrix at each index pair.\ng[m, p] += 1\n\nFor example for the first row of m and p, I would want this behaviour:\ng[1, 4] += 1\ng[1, 4] += 1 # same index as previous\ng[1, 3] += 1\ng[1, 0] += 1\n\nyou will notice however that the output of g is :\n(0 ,.,.) = \n  0  1  0  0  0\n  0  1  0  0  0\n  0  1  0  0  0\n  0  1  0  0  0\n  0  1  0  0  0\n[torch.LongTensor of size 1x5x5]\n\nThe current indexing only increases g[1, 4] by 1 instead of 2 (because of repeated indices). There is an equivalent to this in numpy with https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ufunc.at.html\nSoumith pointed me to index_add_, not sure this would be a good candidate however it's an inplace op, not compatible with autograd.\nThanks :)", "body": "Hey,\r\nI have been thinking about this problem for a few days now, trying to get some help from the forum [also](https://discuss.pytorch.org/t/indexing-with-repeating-indices-numpy-add-at/10223/6), but none seems to work. The problem might seem simple, I found no solution to it :\r\n\r\nlet's say you have a first index tensor `m` containing indices between 0 and 5 : \r\n```\r\nVariable containing:\r\n(0 ,.,.) = \r\n  4  4  3  0\r\n  3  4  2  3\r\n  2  3  1  1\r\n  1  4  3  1\r\n[torch.LongTensor of size 1x4x4]\r\n```\r\n\r\nand a second index tensor `p` of same size, containing indices between 0 and 5 : \r\n```\r\nVariable containing:\r\n(0 ,.,.) = \r\n  1  1  1  1\r\n  1  1  1  1\r\n  1  1  1  1\r\n  1  1  1  1\r\n[torch.LongTensor of size 1x4x4]\r\n```\r\n\r\nfinally a matrix `g` of size 5x5 initially set to 0.\r\n```\r\ng = torch.LongTensor(5,5).zero_()\r\n```\r\n\r\nThe indexing would proceed like this, pair each index from tensor `m` and `p` and increment the `g` matrix at each index pair.\r\n```\r\ng[m, p] += 1\r\n```\r\n\r\nFor example for the first row of `m` and `p`, I would want this behaviour:\r\n```\r\ng[1, 4] += 1\r\ng[1, 4] += 1 # same index as previous\r\ng[1, 3] += 1\r\ng[1, 0] += 1\r\n```\r\n\r\nyou will notice however that the output of `g` is :\r\n```\r\n(0 ,.,.) = \r\n  0  1  0  0  0\r\n  0  1  0  0  0\r\n  0  1  0  0  0\r\n  0  1  0  0  0\r\n  0  1  0  0  0\r\n[torch.LongTensor of size 1x5x5]\r\n```\r\n\r\nThe current indexing only increases g[1, 4] by 1 instead of 2 (because of repeated indices). There is an equivalent to this in numpy with https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ufunc.at.html\r\n\r\nSoumith pointed me to `index_add_`, not sure this would be a good candidate however it's an inplace op, not compatible with autograd.\r\n\r\nThanks :)"}