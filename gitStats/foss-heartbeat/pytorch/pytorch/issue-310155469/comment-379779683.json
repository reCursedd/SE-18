{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/379779683", "html_url": "https://github.com/pytorch/pytorch/pull/6152#issuecomment-379779683", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/6152", "id": 379779683, "node_id": "MDEyOklzc3VlQ29tbWVudDM3OTc3OTY4Mw==", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "created_at": "2018-04-09T14:51:39Z", "updated_at": "2018-04-09T14:51:50Z", "author_association": "MEMBER", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=9110200\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/fmassa\">@fmassa</a> good point, the current implementation requires that the function is effectively a commutative and associative, but it is ok for <code>sum</code>.  From some very limited benchmarks it seems like we really want to take the current path for operations that have this property:</p>\n<pre><code>In [1]: x = torch.randn(10, 20, 100, 10, 100, 10)\n\nIn [2]: %timeit x.sum(2).sum(4)\n37 ms \u00b1 30.3 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n\nIn [3]: %timeit x.permute(0, 1, 3, 5, 2, 4).sum(-1).sum(-1)\n96.8 ms \u00b1 96 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n\nIn [4]: %timeit x.permute(0, 1, 3, 5, 2, 4).contiguous().view(10, 20, 10, 10, -1).sum(-1)\n188 ms \u00b1 2.1 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n</code></pre>", "body_text": "@fmassa good point, the current implementation requires that the function is effectively a commutative and associative, but it is ok for sum.  From some very limited benchmarks it seems like we really want to take the current path for operations that have this property:\nIn [1]: x = torch.randn(10, 20, 100, 10, 100, 10)\n\nIn [2]: %timeit x.sum(2).sum(4)\n37 ms \u00b1 30.3 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n\nIn [3]: %timeit x.permute(0, 1, 3, 5, 2, 4).sum(-1).sum(-1)\n96.8 ms \u00b1 96 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n\nIn [4]: %timeit x.permute(0, 1, 3, 5, 2, 4).contiguous().view(10, 20, 10, 10, -1).sum(-1)\n188 ms \u00b1 2.1 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)", "body": "@fmassa good point, the current implementation requires that the function is effectively a commutative and associative, but it is ok for `sum`.  From some very limited benchmarks it seems like we really want to take the current path for operations that have this property:\r\n```\r\nIn [1]: x = torch.randn(10, 20, 100, 10, 100, 10)\r\n\r\nIn [2]: %timeit x.sum(2).sum(4)\r\n37 ms \u00b1 30.3 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\r\n\r\nIn [3]: %timeit x.permute(0, 1, 3, 5, 2, 4).sum(-1).sum(-1)\r\n96.8 ms \u00b1 96 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\r\n\r\nIn [4]: %timeit x.permute(0, 1, 3, 5, 2, 4).contiguous().view(10, 20, 10, 10, -1).sum(-1)\r\n188 ms \u00b1 2.1 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\r\n```"}