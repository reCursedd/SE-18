{"url": "https://api.github.com/repos/pytorch/pytorch/issues/4559", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/4559/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/4559/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/4559/events", "html_url": "https://github.com/pytorch/pytorch/pull/4559", "id": 287134447, "node_id": "MDExOlB1bGxSZXF1ZXN0MTYxOTA1NDgy", "number": 4559, "title": "Fix use after free when advanced indexing tensors with tensors", "user": {"login": "zou3519", "id": 5652049, "node_id": "MDQ6VXNlcjU2NTIwNDk=", "avatar_url": "https://avatars3.githubusercontent.com/u/5652049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zou3519", "html_url": "https://github.com/zou3519", "followers_url": "https://api.github.com/users/zou3519/followers", "following_url": "https://api.github.com/users/zou3519/following{/other_user}", "gists_url": "https://api.github.com/users/zou3519/gists{/gist_id}", "starred_url": "https://api.github.com/users/zou3519/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zou3519/subscriptions", "organizations_url": "https://api.github.com/users/zou3519/orgs", "repos_url": "https://api.github.com/users/zou3519/repos", "events_url": "https://api.github.com/users/zou3519/events{/privacy}", "received_events_url": "https://api.github.com/users/zou3519/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 825466279, "node_id": "MDU6TGFiZWw4MjU0NjYyNzk=", "url": "https://api.github.com/repos/pytorch/pytorch/labels/0.3.1", "name": "0.3.1", "color": "aefcae", "default": false}, {"id": 797012849, "node_id": "MDU6TGFiZWw3OTcwMTI4NDk=", "url": "https://api.github.com/repos/pytorch/pytorch/labels/in%20progress", "name": "in progress", "color": "ededed", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2018-01-09T15:46:57Z", "updated_at": "2018-11-23T15:38:04Z", "closed_at": "2018-01-11T21:21:36Z", "author_association": "CONTRIBUTOR", "pull_request": {"url": "https://api.github.com/repos/pytorch/pytorch/pulls/4559", "html_url": "https://github.com/pytorch/pytorch/pull/4559", "diff_url": "https://github.com/pytorch/pytorch/pull/4559.diff", "patch_url": "https://github.com/pytorch/pytorch/pull/4559.patch"}, "body_html": "<p>When indexing tensors with tensors, like the following code, a use after free occurs. This doesn't actually impact anything in practice (nothing crashes or errors out) but is theoretically undefined behavior.</p>\n<p>Advanced indexing on Variables doesn't exhibit this behavior because it's a different codepath.</p>\n<p>Sample code:</p>\n<pre><code>import torch\nx = torch.randn(2, 2)\ni = torch.Tensor([1]).long()\nx[i,:]\n</code></pre>\n<h3>Explanation</h3>\n<p>In <code>THPTensor_(_convertToTensorIndexers)</code>, a <code>vector&lt;THPIndexTensor&gt;</code> is created by constructing <code>THPTensor</code>s from sequences/tensors/etc. Each <code>THPIndexTensor</code> is then freed with the following:</p>\n<pre><code>for (auto&amp; idx : indexers) {\n  THIndexTensor_(free)(LIBRARY_STATE idx-&gt;cdata);\n  Py_DECREF(idx);\n}\n</code></pre>\n<p>This is a problem because <code>Py_DECREF(idx)</code> will turn <code>idx-&gt;ob_refcnt</code> to 0 since this function created the relevant <code>THPIndexTensor</code>s and owns them, causing <code>THPTensor_(dealloc)</code> to be called. <code>THPTensor_(dealloc)</code> already has a line that calls <code>THIndexTensor_(free)(LIBRARY_STATE idx-&gt;cdata)</code>.</p>\n<p>So <code>THIndexTensor_(free)(LIBRARY_STATE idx-&gt;cdata)</code> gets called twice on the same <code>cdata</code>. After the first call frees <code>cdata</code>, the second attempts to access flags/members of <code>cdata</code> to determine if it should free it.</p>", "body_text": "When indexing tensors with tensors, like the following code, a use after free occurs. This doesn't actually impact anything in practice (nothing crashes or errors out) but is theoretically undefined behavior.\nAdvanced indexing on Variables doesn't exhibit this behavior because it's a different codepath.\nSample code:\nimport torch\nx = torch.randn(2, 2)\ni = torch.Tensor([1]).long()\nx[i,:]\n\nExplanation\nIn THPTensor_(_convertToTensorIndexers), a vector<THPIndexTensor> is created by constructing THPTensors from sequences/tensors/etc. Each THPIndexTensor is then freed with the following:\nfor (auto& idx : indexers) {\n  THIndexTensor_(free)(LIBRARY_STATE idx->cdata);\n  Py_DECREF(idx);\n}\n\nThis is a problem because Py_DECREF(idx) will turn idx->ob_refcnt to 0 since this function created the relevant THPIndexTensors and owns them, causing THPTensor_(dealloc) to be called. THPTensor_(dealloc) already has a line that calls THIndexTensor_(free)(LIBRARY_STATE idx->cdata).\nSo THIndexTensor_(free)(LIBRARY_STATE idx->cdata) gets called twice on the same cdata. After the first call frees cdata, the second attempts to access flags/members of cdata to determine if it should free it.", "body": "When indexing tensors with tensors, like the following code, a use after free occurs. This doesn't actually impact anything in practice (nothing crashes or errors out) but is theoretically undefined behavior.\r\n\r\nAdvanced indexing on Variables doesn't exhibit this behavior because it's a different codepath.\r\n\r\nSample code:\r\n```\r\nimport torch\r\nx = torch.randn(2, 2)\r\ni = torch.Tensor([1]).long()\r\nx[i,:]\r\n```\r\n\r\n### Explanation\r\nIn `THPTensor_(_convertToTensorIndexers)`, a `vector<THPIndexTensor>` is created by constructing `THPTensor`s from sequences/tensors/etc. Each `THPIndexTensor` is then freed with the following:\r\n\r\n```\r\nfor (auto& idx : indexers) {\r\n  THIndexTensor_(free)(LIBRARY_STATE idx->cdata);\r\n  Py_DECREF(idx);\r\n}\r\n```\r\n\r\nThis is a problem because `Py_DECREF(idx)` will turn `idx->ob_refcnt` to 0 since this function created the relevant `THPIndexTensor`s and owns them, causing `THPTensor_(dealloc)` to be called. `THPTensor_(dealloc)` already has a line that calls `THIndexTensor_(free)(LIBRARY_STATE idx->cdata)`.\r\n\r\nSo `THIndexTensor_(free)(LIBRARY_STATE idx->cdata)` gets called twice on the same `cdata`. After the first call frees `cdata`, the second attempts to access flags/members of `cdata` to determine if it should free it.\r\n  "}