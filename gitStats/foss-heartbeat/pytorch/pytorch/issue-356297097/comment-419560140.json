{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/419560140", "html_url": "https://github.com/pytorch/pytorch/issues/11186#issuecomment-419560140", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/11186", "id": 419560140, "node_id": "MDEyOklzc3VlQ29tbWVudDQxOTU2MDE0MA==", "user": {"login": "ngimel", "id": 15841449, "node_id": "MDQ6VXNlcjE1ODQxNDQ5", "avatar_url": "https://avatars3.githubusercontent.com/u/15841449?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ngimel", "html_url": "https://github.com/ngimel", "followers_url": "https://api.github.com/users/ngimel/followers", "following_url": "https://api.github.com/users/ngimel/following{/other_user}", "gists_url": "https://api.github.com/users/ngimel/gists{/gist_id}", "starred_url": "https://api.github.com/users/ngimel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ngimel/subscriptions", "organizations_url": "https://api.github.com/users/ngimel/orgs", "repos_url": "https://api.github.com/users/ngimel/repos", "events_url": "https://api.github.com/users/ngimel/events{/privacy}", "received_events_url": "https://api.github.com/users/ngimel/received_events", "type": "User", "site_admin": false}, "created_at": "2018-09-07T20:42:29Z", "updated_at": "2018-09-07T20:42:29Z", "author_association": "CONTRIBUTOR", "body_html": "<p>script and trace produce different graphs for the following function:</p>\n<pre><code>def constant_mul_add(x, y):\n    return (2 * x + 3 + y) &gt; 4\n</code></pre>\n<pre><code>trace output graph(%0 : Float(10240, 1024)\n      %1 : Float(10240, 1024)) {\n  %2 : Long() = prim::Constant[value={2}]()\n  %3 : Float(10240, 1024) = aten::mul(%0, %2)\n  %4 : Long() = prim::Constant[value={3}]()\n  %5 : int = prim::Constant[value=1]()\n  %6 : Float(10240, 1024) = aten::add(%3, %4, %5)\n  %7 : int = prim::Constant[value=1]()\n  %8 : Float(10240, 1024) = aten::add(%6, %1, %7)\n  %9 : int = prim::Constant[value=4]()\n  %10 : Byte(10240, 1024) = aten::gt(%8, %9)\n  return (%10);\n}\n\nscript output graph(%x : Dynamic\n      %y : Dynamic) {\n  %9 : int = prim::Constant[value=4]()\n  %4 : int = prim::Constant[value=3]()\n  %2 : int = prim::Constant[value=2]()\n  %3 : Dynamic = aten::mul(%2, %x)\n  %5 : int = prim::Constant[value=1]()\n  %6 : Dynamic = aten::add(%3, %4, %5)\n  %7 : int = prim::Constant[value=1]()\n  %8 : Dynamic = aten::add(%6, %y, %7)\n  %10 : Dynamic = aten::gt(%8, %9)\n  return (%10);\n}\n</code></pre>\n<p>Note how trace treats constants as scalars (<code>Long() = prim::Constant[value={2}]()</code>) and script treats them as numbers: <code> int = prim::Constant[value=2]()</code> if constants are used in arithmetic operations (<code>+,-,/,*</code>). Constants used in e.g. comparison operators are treated as numbers by both script and trace (<code>%9 : int = prim::Constant[value=4]()</code>. This results in fuser being able to fuse graph produced by script, but not by trace. Trace is creating scalars for constants after <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=655866\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/colesbury\">@colesbury</a>'s TensorIterator PR. I think the plan is to move all binary and unary operators to use it, so I think the proper fix would be to modify script to match trace types, and fix fuser to be able to properly fuse them.</p>", "body_text": "script and trace produce different graphs for the following function:\ndef constant_mul_add(x, y):\n    return (2 * x + 3 + y) > 4\n\ntrace output graph(%0 : Float(10240, 1024)\n      %1 : Float(10240, 1024)) {\n  %2 : Long() = prim::Constant[value={2}]()\n  %3 : Float(10240, 1024) = aten::mul(%0, %2)\n  %4 : Long() = prim::Constant[value={3}]()\n  %5 : int = prim::Constant[value=1]()\n  %6 : Float(10240, 1024) = aten::add(%3, %4, %5)\n  %7 : int = prim::Constant[value=1]()\n  %8 : Float(10240, 1024) = aten::add(%6, %1, %7)\n  %9 : int = prim::Constant[value=4]()\n  %10 : Byte(10240, 1024) = aten::gt(%8, %9)\n  return (%10);\n}\n\nscript output graph(%x : Dynamic\n      %y : Dynamic) {\n  %9 : int = prim::Constant[value=4]()\n  %4 : int = prim::Constant[value=3]()\n  %2 : int = prim::Constant[value=2]()\n  %3 : Dynamic = aten::mul(%2, %x)\n  %5 : int = prim::Constant[value=1]()\n  %6 : Dynamic = aten::add(%3, %4, %5)\n  %7 : int = prim::Constant[value=1]()\n  %8 : Dynamic = aten::add(%6, %y, %7)\n  %10 : Dynamic = aten::gt(%8, %9)\n  return (%10);\n}\n\nNote how trace treats constants as scalars (Long() = prim::Constant[value={2}]()) and script treats them as numbers:  int = prim::Constant[value=2]() if constants are used in arithmetic operations (+,-,/,*). Constants used in e.g. comparison operators are treated as numbers by both script and trace (%9 : int = prim::Constant[value=4](). This results in fuser being able to fuse graph produced by script, but not by trace. Trace is creating scalars for constants after @colesbury's TensorIterator PR. I think the plan is to move all binary and unary operators to use it, so I think the proper fix would be to modify script to match trace types, and fix fuser to be able to properly fuse them.", "body": "script and trace produce different graphs for the following function:\r\n```\r\ndef constant_mul_add(x, y):\r\n    return (2 * x + 3 + y) > 4\r\n```\r\n```\r\ntrace output graph(%0 : Float(10240, 1024)\r\n      %1 : Float(10240, 1024)) {\r\n  %2 : Long() = prim::Constant[value={2}]()\r\n  %3 : Float(10240, 1024) = aten::mul(%0, %2)\r\n  %4 : Long() = prim::Constant[value={3}]()\r\n  %5 : int = prim::Constant[value=1]()\r\n  %6 : Float(10240, 1024) = aten::add(%3, %4, %5)\r\n  %7 : int = prim::Constant[value=1]()\r\n  %8 : Float(10240, 1024) = aten::add(%6, %1, %7)\r\n  %9 : int = prim::Constant[value=4]()\r\n  %10 : Byte(10240, 1024) = aten::gt(%8, %9)\r\n  return (%10);\r\n}\r\n\r\nscript output graph(%x : Dynamic\r\n      %y : Dynamic) {\r\n  %9 : int = prim::Constant[value=4]()\r\n  %4 : int = prim::Constant[value=3]()\r\n  %2 : int = prim::Constant[value=2]()\r\n  %3 : Dynamic = aten::mul(%2, %x)\r\n  %5 : int = prim::Constant[value=1]()\r\n  %6 : Dynamic = aten::add(%3, %4, %5)\r\n  %7 : int = prim::Constant[value=1]()\r\n  %8 : Dynamic = aten::add(%6, %y, %7)\r\n  %10 : Dynamic = aten::gt(%8, %9)\r\n  return (%10);\r\n}\r\n```\r\nNote how trace treats constants as scalars (`Long() = prim::Constant[value={2}]()`) and script treats them as numbers: ` int = prim::Constant[value=2]()` if constants are used in arithmetic operations (`+,-,/,*`). Constants used in e.g. comparison operators are treated as numbers by both script and trace (`%9 : int = prim::Constant[value=4]()`. This results in fuser being able to fuse graph produced by script, but not by trace. Trace is creating scalars for constants after @colesbury's TensorIterator PR. I think the plan is to move all binary and unary operators to use it, so I think the proper fix would be to modify script to match trace types, and fix fuser to be able to properly fuse them. "}