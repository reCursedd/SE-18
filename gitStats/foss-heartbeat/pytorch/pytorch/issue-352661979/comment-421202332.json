{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/421202332", "html_url": "https://github.com/pytorch/pytorch/issues/10742#issuecomment-421202332", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/10742", "id": 421202332, "node_id": "MDEyOklzc3VlQ29tbWVudDQyMTIwMjMzMg==", "user": {"login": "ragulpr", "id": 10998266, "node_id": "MDQ6VXNlcjEwOTk4MjY2", "avatar_url": "https://avatars3.githubusercontent.com/u/10998266?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ragulpr", "html_url": "https://github.com/ragulpr", "followers_url": "https://api.github.com/users/ragulpr/followers", "following_url": "https://api.github.com/users/ragulpr/following{/other_user}", "gists_url": "https://api.github.com/users/ragulpr/gists{/gist_id}", "starred_url": "https://api.github.com/users/ragulpr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ragulpr/subscriptions", "organizations_url": "https://api.github.com/users/ragulpr/orgs", "repos_url": "https://api.github.com/users/ragulpr/repos", "events_url": "https://api.github.com/users/ragulpr/events{/privacy}", "received_events_url": "https://api.github.com/users/ragulpr/received_events", "type": "User", "site_admin": false}, "created_at": "2018-09-14T01:31:00Z", "updated_at": "2018-09-14T01:38:29Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Would be great. I guess it's important to get this right as it would be basis for future test-infrastructure. Numpy finfo <a href=\"https://github.com/numpy/numpy/blob/master/numpy/core/getlimits.py\">currently contains</a>:</p>\n<pre><code>    bits : int\n        The number of bits occupied by the type.\n    eps : float\n        The smallest representable positive number such that\n        ``1.0 + eps != 1.0``.  Type of `eps` is an appropriate floating\n        point type.\n    epsneg : floating point number of the appropriate type\n        The smallest representable positive number such that\n        ``1.0 - epsneg != 1.0``.\n    iexp : int\n        The number of bits in the exponent portion of the floating point\n        representation.\n    machar : MachAr\n        The object which calculated these parameters and holds more\n        detailed information.\n    machep : int\n        The exponent that yields `eps`.\n    max : floating point number of the appropriate type\n        The largest representable number.\n    maxexp : int\n        The smallest positive power of the base (2) that causes overflow.\n    min : floating point number of the appropriate type\n        The smallest representable number, typically ``-max``.\n    minexp : int\n        The most negative power of the base (2) consistent with there\n        being no leading 0's in the mantissa.\n    negep : int\n        The exponent that yields `epsneg`.\n    nexp : int\n        The number of bits in the exponent including its sign and bias.\n    nmant : int\n        The number of bits in the mantissa.\n    precision : int\n        The approximate number of decimal digits to which this kind of\n        float is precise.\n    resolution : floating point number of the appropriate type\n        The approximate decimal resolution of this type, i.e.,\n        ``10**-precision``.\n    tiny : float\n        The smallest positive usable number.  Type of `tiny` is an\n        appropriate floating point type.\n</code></pre>\n<p>For me;</p>\n<ul>\n<li>eps</li>\n<li>tiny</li>\n<li>max</li>\n</ul>\n<p>Does just fine for now upon review because I assume something like <code>x.new(1).fill_(torch.finfo(x).max).log()</code> for example would give <code>maxexp</code> but at relevant base.</p>\n<p>Relevant:<br>\nOngoing changes to finfo in <a href=\"https://github.com/numpy/numpy/pull/8504\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/numpy/numpy/pull/8504/hovercard\">numpy</a> and of course <a href=\"https://en.cppreference.com/w/cpp/types/numeric_limits\" rel=\"nofollow\">https://en.cppreference.com/w/cpp/types/numeric_limits</a></p>\n<p>I could look into this. I'd just move <code>torch.utils._finfo</code> from <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"287298054\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/4572\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/pytorch/pytorch/pull/4572/hovercard\" href=\"https://github.com/pytorch/pytorch/pull/4572\">#4572</a> into <code>torch.finfo</code> and add more data.</p>", "body_text": "Would be great. I guess it's important to get this right as it would be basis for future test-infrastructure. Numpy finfo currently contains:\n    bits : int\n        The number of bits occupied by the type.\n    eps : float\n        The smallest representable positive number such that\n        ``1.0 + eps != 1.0``.  Type of `eps` is an appropriate floating\n        point type.\n    epsneg : floating point number of the appropriate type\n        The smallest representable positive number such that\n        ``1.0 - epsneg != 1.0``.\n    iexp : int\n        The number of bits in the exponent portion of the floating point\n        representation.\n    machar : MachAr\n        The object which calculated these parameters and holds more\n        detailed information.\n    machep : int\n        The exponent that yields `eps`.\n    max : floating point number of the appropriate type\n        The largest representable number.\n    maxexp : int\n        The smallest positive power of the base (2) that causes overflow.\n    min : floating point number of the appropriate type\n        The smallest representable number, typically ``-max``.\n    minexp : int\n        The most negative power of the base (2) consistent with there\n        being no leading 0's in the mantissa.\n    negep : int\n        The exponent that yields `epsneg`.\n    nexp : int\n        The number of bits in the exponent including its sign and bias.\n    nmant : int\n        The number of bits in the mantissa.\n    precision : int\n        The approximate number of decimal digits to which this kind of\n        float is precise.\n    resolution : floating point number of the appropriate type\n        The approximate decimal resolution of this type, i.e.,\n        ``10**-precision``.\n    tiny : float\n        The smallest positive usable number.  Type of `tiny` is an\n        appropriate floating point type.\n\nFor me;\n\neps\ntiny\nmax\n\nDoes just fine for now upon review because I assume something like x.new(1).fill_(torch.finfo(x).max).log() for example would give maxexp but at relevant base.\nRelevant:\nOngoing changes to finfo in numpy and of course https://en.cppreference.com/w/cpp/types/numeric_limits\nI could look into this. I'd just move torch.utils._finfo from #4572 into torch.finfo and add more data.", "body": "Would be great. I guess it's important to get this right as it would be basis for future test-infrastructure. Numpy finfo [currently contains](https://github.com/numpy/numpy/blob/master/numpy/core/getlimits.py):\r\n\r\n```\r\n    bits : int\r\n        The number of bits occupied by the type.\r\n    eps : float\r\n        The smallest representable positive number such that\r\n        ``1.0 + eps != 1.0``.  Type of `eps` is an appropriate floating\r\n        point type.\r\n    epsneg : floating point number of the appropriate type\r\n        The smallest representable positive number such that\r\n        ``1.0 - epsneg != 1.0``.\r\n    iexp : int\r\n        The number of bits in the exponent portion of the floating point\r\n        representation.\r\n    machar : MachAr\r\n        The object which calculated these parameters and holds more\r\n        detailed information.\r\n    machep : int\r\n        The exponent that yields `eps`.\r\n    max : floating point number of the appropriate type\r\n        The largest representable number.\r\n    maxexp : int\r\n        The smallest positive power of the base (2) that causes overflow.\r\n    min : floating point number of the appropriate type\r\n        The smallest representable number, typically ``-max``.\r\n    minexp : int\r\n        The most negative power of the base (2) consistent with there\r\n        being no leading 0's in the mantissa.\r\n    negep : int\r\n        The exponent that yields `epsneg`.\r\n    nexp : int\r\n        The number of bits in the exponent including its sign and bias.\r\n    nmant : int\r\n        The number of bits in the mantissa.\r\n    precision : int\r\n        The approximate number of decimal digits to which this kind of\r\n        float is precise.\r\n    resolution : floating point number of the appropriate type\r\n        The approximate decimal resolution of this type, i.e.,\r\n        ``10**-precision``.\r\n    tiny : float\r\n        The smallest positive usable number.  Type of `tiny` is an\r\n        appropriate floating point type.\r\n```\r\nFor me; \r\n\r\n* eps\r\n* tiny\r\n* max\r\n\r\nDoes just fine for now upon review because I assume something like `x.new(1).fill_(torch.finfo(x).max).log()` for example would give `maxexp` but at relevant base. \r\n\r\nRelevant: \r\nOngoing changes to finfo in [numpy](https://github.com/numpy/numpy/pull/8504) and of course https://en.cppreference.com/w/cpp/types/numeric_limits\r\n\r\nI could look into this. I'd just move `torch.utils._finfo` from #4572 into `torch.finfo` and add more data.\r\n"}