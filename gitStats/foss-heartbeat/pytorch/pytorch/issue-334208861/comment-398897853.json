{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/398897853", "html_url": "https://github.com/pytorch/pytorch/pull/8704#issuecomment-398897853", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/8704", "id": 398897853, "node_id": "MDEyOklzc3VlQ29tbWVudDM5ODg5Nzg1Mw==", "user": {"login": "jamesr66a", "id": 4685384, "node_id": "MDQ6VXNlcjQ2ODUzODQ=", "avatar_url": "https://avatars2.githubusercontent.com/u/4685384?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamesr66a", "html_url": "https://github.com/jamesr66a", "followers_url": "https://api.github.com/users/jamesr66a/followers", "following_url": "https://api.github.com/users/jamesr66a/following{/other_user}", "gists_url": "https://api.github.com/users/jamesr66a/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamesr66a/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamesr66a/subscriptions", "organizations_url": "https://api.github.com/users/jamesr66a/orgs", "repos_url": "https://api.github.com/users/jamesr66a/repos", "events_url": "https://api.github.com/users/jamesr66a/events{/privacy}", "received_events_url": "https://api.github.com/users/jamesr66a/received_events", "type": "User", "site_admin": false}, "created_at": "2018-06-20T21:09:48Z", "updated_at": "2018-06-20T21:34:31Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=4583066\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/apaszke\">@apaszke</a> idk I tried writing it like that but it looks pretty ugly:</p>\n<pre><code>import torch\n\nfrontend_types = ['Python', 'Traced', 'Script']\ninstance_types = ['function', 'module']\n\nmodule_template = '''\nclass {module_name}({base_class}):\n    def __init__(self):\n        super({module_name}, self).__init__()\n        self.param = torch.nn.Parameter(torch.rand(3, 3))\n\n    {script_decorator}\n    def forward(self, x):\n        return torch.mm({input_expr}, self.param)\n'''\n\nfn_template = '''\n{fn_decorator}\ndef {fn_name}(x):\n    return torch.neg({input_expr})\n'''\n\nbase_class_lut = {\n    'Python': 'torch.nn.Module',\n    'Traced': 'torch.nn.Module',\n    'Script': 'torch.jit.ScriptModule',\n}\n\nprint('import torch')\n\nfor ft_from in frontend_types:\n    if ft_from == 'Python':\n        continue\n    for it_from in instance_types:\n        for ft_to in frontend_types:\n            for it_to in instance_types:\n                to_name = ft_to + 'ModTo' if it_to == 'module' else ft_to + 'FnTo'\n                if it_to == 'function':\n                    to_maybe_instantiate = ''\n                    if ft_to == 'Script':\n                        fn_decorator = '@torch.jit.script'\n                    elif ft_to == 'Traced':\n                        fn_decorator = '@torch.jit.trace(torch.rand(3, 3))'\n                    else:\n                        fn_decorator=''\n                    to_str = fn_template.format(fn_name=to_name,\n                                                fn_decorator=fn_decorator,\n                                                input_expr='x')\n                    to_invocation = to_name + '(x)'\n                elif it_to == 'module':\n                    to_str = module_template.format(module_name=to_name,\n                                                    base_class=base_class_lut[ft_to],\n                                                    script_decorator='@torch.jit.script_method' if ft_to=='Script' else '',\n                                                    input_expr='x')\n                    if ft_to == 'Script' or ft_to == 'Python':\n                        to_maybe_instantiate = 'mod_to = ' + to_name + '()'\n                    elif ft_to == 'Traced':\n                        to_maybe_instantiate = 'mod_to = torch.jit.trace(torch.rand(3, 3))(' + to_name + '())'\n                    to_invocation = 'mod_to(x)'\n\n                if it_from == 'function':\n                    if ft_from == 'Script':\n                        fn_decorator = '@torch.jit.script'\n                    elif ft_from == 'Traced':\n                        fn_decorator = '@torch.jit.trace(torch.rand(3, 3))'\n                    else:\n                        fn_decorator=''\n                    from_name = ft_from + 'FnFrom'\n                    from_str = fn_template.format(fn_name=from_name,\n                                                  fn_decorator=fn_decorator,\n                                                  input_expr=to_invocation)\n                elif it_from == 'module':\n                    from_name = ft_from + 'ModFrom'\n                    from_str = module_template.format(module_name=from_name,\n                                                      base_class=base_class_lut[ft_from],\n                                                      script_decorator='@torch.jit.script_method' if ft_from=='Script' else '',\n                                                      input_expr=to_invocation)\n\n                if it_from == 'module':\n                    instantiation = 'torch.jit.trace(torch.rand(3, 3))(' + from_name + '())' if ft_from == 'Traced' else from_name + '()'\n                    invocation_string = 'mod = ' + instantiation + '\\nprint(mod.__getattr__(\\'forward\\').graph)'\n                elif it_from == 'function':\n                    invocation_string = 'print(' + from_name + '.graph)'\n\n                program = to_str + to_maybe_instantiate + from_str + invocation_string\n                print(program)\n\n</code></pre>\n<p>I'm actually less confident the tests generated here don't have faults than with this version. How do I go about actually running these, as well? And the way we have it in this PR, I can put in explicit comments explaining what's expected and what's broken and people can go in and read the offline</p>", "body_text": "@apaszke idk I tried writing it like that but it looks pretty ugly:\nimport torch\n\nfrontend_types = ['Python', 'Traced', 'Script']\ninstance_types = ['function', 'module']\n\nmodule_template = '''\nclass {module_name}({base_class}):\n    def __init__(self):\n        super({module_name}, self).__init__()\n        self.param = torch.nn.Parameter(torch.rand(3, 3))\n\n    {script_decorator}\n    def forward(self, x):\n        return torch.mm({input_expr}, self.param)\n'''\n\nfn_template = '''\n{fn_decorator}\ndef {fn_name}(x):\n    return torch.neg({input_expr})\n'''\n\nbase_class_lut = {\n    'Python': 'torch.nn.Module',\n    'Traced': 'torch.nn.Module',\n    'Script': 'torch.jit.ScriptModule',\n}\n\nprint('import torch')\n\nfor ft_from in frontend_types:\n    if ft_from == 'Python':\n        continue\n    for it_from in instance_types:\n        for ft_to in frontend_types:\n            for it_to in instance_types:\n                to_name = ft_to + 'ModTo' if it_to == 'module' else ft_to + 'FnTo'\n                if it_to == 'function':\n                    to_maybe_instantiate = ''\n                    if ft_to == 'Script':\n                        fn_decorator = '@torch.jit.script'\n                    elif ft_to == 'Traced':\n                        fn_decorator = '@torch.jit.trace(torch.rand(3, 3))'\n                    else:\n                        fn_decorator=''\n                    to_str = fn_template.format(fn_name=to_name,\n                                                fn_decorator=fn_decorator,\n                                                input_expr='x')\n                    to_invocation = to_name + '(x)'\n                elif it_to == 'module':\n                    to_str = module_template.format(module_name=to_name,\n                                                    base_class=base_class_lut[ft_to],\n                                                    script_decorator='@torch.jit.script_method' if ft_to=='Script' else '',\n                                                    input_expr='x')\n                    if ft_to == 'Script' or ft_to == 'Python':\n                        to_maybe_instantiate = 'mod_to = ' + to_name + '()'\n                    elif ft_to == 'Traced':\n                        to_maybe_instantiate = 'mod_to = torch.jit.trace(torch.rand(3, 3))(' + to_name + '())'\n                    to_invocation = 'mod_to(x)'\n\n                if it_from == 'function':\n                    if ft_from == 'Script':\n                        fn_decorator = '@torch.jit.script'\n                    elif ft_from == 'Traced':\n                        fn_decorator = '@torch.jit.trace(torch.rand(3, 3))'\n                    else:\n                        fn_decorator=''\n                    from_name = ft_from + 'FnFrom'\n                    from_str = fn_template.format(fn_name=from_name,\n                                                  fn_decorator=fn_decorator,\n                                                  input_expr=to_invocation)\n                elif it_from == 'module':\n                    from_name = ft_from + 'ModFrom'\n                    from_str = module_template.format(module_name=from_name,\n                                                      base_class=base_class_lut[ft_from],\n                                                      script_decorator='@torch.jit.script_method' if ft_from=='Script' else '',\n                                                      input_expr=to_invocation)\n\n                if it_from == 'module':\n                    instantiation = 'torch.jit.trace(torch.rand(3, 3))(' + from_name + '())' if ft_from == 'Traced' else from_name + '()'\n                    invocation_string = 'mod = ' + instantiation + '\\nprint(mod.__getattr__(\\'forward\\').graph)'\n                elif it_from == 'function':\n                    invocation_string = 'print(' + from_name + '.graph)'\n\n                program = to_str + to_maybe_instantiate + from_str + invocation_string\n                print(program)\n\n\nI'm actually less confident the tests generated here don't have faults than with this version. How do I go about actually running these, as well? And the way we have it in this PR, I can put in explicit comments explaining what's expected and what's broken and people can go in and read the offline", "body": "@apaszke idk I tried writing it like that but it looks pretty ugly:\r\n\r\n```\r\nimport torch\r\n\r\nfrontend_types = ['Python', 'Traced', 'Script']\r\ninstance_types = ['function', 'module']\r\n\r\nmodule_template = '''\r\nclass {module_name}({base_class}):\r\n    def __init__(self):\r\n        super({module_name}, self).__init__()\r\n        self.param = torch.nn.Parameter(torch.rand(3, 3))\r\n\r\n    {script_decorator}\r\n    def forward(self, x):\r\n        return torch.mm({input_expr}, self.param)\r\n'''\r\n\r\nfn_template = '''\r\n{fn_decorator}\r\ndef {fn_name}(x):\r\n    return torch.neg({input_expr})\r\n'''\r\n\r\nbase_class_lut = {\r\n    'Python': 'torch.nn.Module',\r\n    'Traced': 'torch.nn.Module',\r\n    'Script': 'torch.jit.ScriptModule',\r\n}\r\n\r\nprint('import torch')\r\n\r\nfor ft_from in frontend_types:\r\n    if ft_from == 'Python':\r\n        continue\r\n    for it_from in instance_types:\r\n        for ft_to in frontend_types:\r\n            for it_to in instance_types:\r\n                to_name = ft_to + 'ModTo' if it_to == 'module' else ft_to + 'FnTo'\r\n                if it_to == 'function':\r\n                    to_maybe_instantiate = ''\r\n                    if ft_to == 'Script':\r\n                        fn_decorator = '@torch.jit.script'\r\n                    elif ft_to == 'Traced':\r\n                        fn_decorator = '@torch.jit.trace(torch.rand(3, 3))'\r\n                    else:\r\n                        fn_decorator=''\r\n                    to_str = fn_template.format(fn_name=to_name,\r\n                                                fn_decorator=fn_decorator,\r\n                                                input_expr='x')\r\n                    to_invocation = to_name + '(x)'\r\n                elif it_to == 'module':\r\n                    to_str = module_template.format(module_name=to_name,\r\n                                                    base_class=base_class_lut[ft_to],\r\n                                                    script_decorator='@torch.jit.script_method' if ft_to=='Script' else '',\r\n                                                    input_expr='x')\r\n                    if ft_to == 'Script' or ft_to == 'Python':\r\n                        to_maybe_instantiate = 'mod_to = ' + to_name + '()'\r\n                    elif ft_to == 'Traced':\r\n                        to_maybe_instantiate = 'mod_to = torch.jit.trace(torch.rand(3, 3))(' + to_name + '())'\r\n                    to_invocation = 'mod_to(x)'\r\n\r\n                if it_from == 'function':\r\n                    if ft_from == 'Script':\r\n                        fn_decorator = '@torch.jit.script'\r\n                    elif ft_from == 'Traced':\r\n                        fn_decorator = '@torch.jit.trace(torch.rand(3, 3))'\r\n                    else:\r\n                        fn_decorator=''\r\n                    from_name = ft_from + 'FnFrom'\r\n                    from_str = fn_template.format(fn_name=from_name,\r\n                                                  fn_decorator=fn_decorator,\r\n                                                  input_expr=to_invocation)\r\n                elif it_from == 'module':\r\n                    from_name = ft_from + 'ModFrom'\r\n                    from_str = module_template.format(module_name=from_name,\r\n                                                      base_class=base_class_lut[ft_from],\r\n                                                      script_decorator='@torch.jit.script_method' if ft_from=='Script' else '',\r\n                                                      input_expr=to_invocation)\r\n\r\n                if it_from == 'module':\r\n                    instantiation = 'torch.jit.trace(torch.rand(3, 3))(' + from_name + '())' if ft_from == 'Traced' else from_name + '()'\r\n                    invocation_string = 'mod = ' + instantiation + '\\nprint(mod.__getattr__(\\'forward\\').graph)'\r\n                elif it_from == 'function':\r\n                    invocation_string = 'print(' + from_name + '.graph)'\r\n\r\n                program = to_str + to_maybe_instantiate + from_str + invocation_string\r\n                print(program)\r\n\r\n```\r\n\r\nI'm actually less confident the tests generated here don't have faults than with this version. How do I go about actually running these, as well? And the way we have it in this PR, I can put in explicit comments explaining what's expected and what's broken and people can go in and read the offline"}