{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/220652952", "pull_request_review_id": 159110545, "id": 220652952, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMDY1Mjk1Mg==", "diff_hunk": "@@ -1,53 +1,81 @@\n-#include \"TensorIterator.h\"\n+#include <ATen/native/TensorIterator.h>\n \n+#include <array>\n #include <ATen/ExpandUtils.h>\n #include <ATen/Parallel.h>\n \n namespace at {\n \n-void TensorIterator::reorder_dimensions() {\n-  // Sort the dimensions based on the sum-of-strides in ascending order. NOTE:\n-  // that this inverts the order of C-contiguous tensors. strides[0] is the\n-  // fastest moving dimension instead of strides[ndim - 1].\n+struct DimCounter {\n+  DimCounter(IntList shape, Range range);\n \n-  auto sum_of_strides = SmallVector<double, 6>(ndim(), 0.0);\n-  for (int dim = 0; dim < ndim(); dim++) {\n-    double sum = 0.0;\n-    for (const auto& op : operands_) {\n-      if (op.stride_bytes.size() == 0) continue;\n-      sum += op.stride_bytes[dim];\n-    }\n+  void increment(const std::array<int64_t, 2>& step);\n+  bool is_done() const;\n+  std::array<int64_t, 2> max_step() const;\n \n-    // Weight each dimension by its index. Given two dimensions with equal\n-    // some of strides, this preserves the given relative ordering.\n-    sum += (ndim() - dim - 1) / (double)ndim();\n+  IntList shape;\n+  Range range;\n+  DimVector values;\n+  int64_t offset;\n+};\n \n-    sum_of_strides[dim] = sum;\n-  }\n+using DimMask = TensorIterator::DimMask;\n+using PtrVector = TensorIterator::PtrVector;\n+using loop_t = TensorIterator::loop_t;\n+using loop2d_t = TensorIterator::loop2d_t;\n \n-  // initialize perm with 0, 1, 2, ...\n-  perm_.resize(ndim());\n-  std::iota(std::begin(perm_), std::end(perm_), 0);\n-\n-  std::sort(std::begin(perm_), std::end(perm_), [&](size_t i1, size_t i2) {\n-    return sum_of_strides[i1] < sum_of_strides[i2];\n-  });\n+void TensorIterator::reorder_dimensions() {\n+  // Sort the dimensions based on strides in ascending order with reduced dims", "path": "aten/src/ATen/native/TensorIterator.cpp", "position": 52, "original_position": 52, "commit_id": "85757031de20ad93e21ea7bf68d7c39e9698899d", "original_commit_id": "aeb0b9dd17ddef7b46d0ace6bcd42be2cbedbc0d", "user": {"login": "colesbury", "id": 655866, "node_id": "MDQ6VXNlcjY1NTg2Ng==", "avatar_url": "https://avatars1.githubusercontent.com/u/655866?v=4", "gravatar_id": "", "url": "https://api.github.com/users/colesbury", "html_url": "https://github.com/colesbury", "followers_url": "https://api.github.com/users/colesbury/followers", "following_url": "https://api.github.com/users/colesbury/following{/other_user}", "gists_url": "https://api.github.com/users/colesbury/gists{/gist_id}", "starred_url": "https://api.github.com/users/colesbury/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/colesbury/subscriptions", "organizations_url": "https://api.github.com/users/colesbury/orgs", "repos_url": "https://api.github.com/users/colesbury/repos", "events_url": "https://api.github.com/users/colesbury/events{/privacy}", "received_events_url": "https://api.github.com/users/colesbury/received_events", "type": "User", "site_admin": false}, "body": "> What if the first argument is the single one that has strides different than the (possibly many) other arguments?\r\n\r\nIn that case it won't reorder the strides if it makes the first argument worse, even if it makes all the other arguments better. I'm not sure what the best strategy for that case is, but I think a good solution will involve some sort of [blocked](https://en.wikipedia.org/wiki/Loop_nest_optimization) transpose in TensorIterator.", "created_at": "2018-09-26T17:24:00Z", "updated_at": "2018-11-23T15:52:02Z", "html_url": "https://github.com/pytorch/pytorch/pull/11908#discussion_r220652952", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/11908", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/220652952"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/11908#discussion_r220652952"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/11908"}}, "body_html": "<blockquote>\n<p>What if the first argument is the single one that has strides different than the (possibly many) other arguments?</p>\n</blockquote>\n<p>In that case it won't reorder the strides if it makes the first argument worse, even if it makes all the other arguments better. I'm not sure what the best strategy for that case is, but I think a good solution will involve some sort of <a href=\"https://en.wikipedia.org/wiki/Loop_nest_optimization\" rel=\"nofollow\">blocked</a> transpose in TensorIterator.</p>", "body_text": "What if the first argument is the single one that has strides different than the (possibly many) other arguments?\n\nIn that case it won't reorder the strides if it makes the first argument worse, even if it makes all the other arguments better. I'm not sure what the best strategy for that case is, but I think a good solution will involve some sort of blocked transpose in TensorIterator.", "in_reply_to_id": 219666795}