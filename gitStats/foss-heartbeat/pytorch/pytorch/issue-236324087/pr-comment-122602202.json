{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/122602202", "pull_request_review_id": 44431314, "id": 122602202, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEyMjYwMjIwMg==", "diff_hunk": "@@ -1055,3 +1069,67 @@ std::shared_ptr<PyFunction> THPFunction_asFunction(THPFunction* self)\n   Py_INCREF((PyObject*)self);\n   return std::shared_ptr<PyFunction>(&self->cdata, Decref());\n }\n+\n+namespace torch { namespace autograd {\n+\n+using memo_map = std::unordered_map<Node*, variable_list>;\n+\n+variable_list interpret_node(std::shared_ptr<Node>, input_map&, memo_map&);\n+\n+std::shared_ptr<Variable> interpret_output(Output output, input_map& inputs, memo_map& memo) {\n+    auto vs = interpret_node(output.node, inputs, memo);\n+    return vs.at(output.output_nr);\n+}\n+\n+variable_list interpret_node(std::shared_ptr<Node> node, input_map& inputs, memo_map& memo) {\n+    variable_list input_vars;\n+    auto num_args = node->inputs.size();\n+    input_vars.reserve(num_args);\n+    for (auto input : node->inputs) {\n+        input_vars.emplace_back(interpret_output(input, inputs, memo));\n+    }\n+    if (auto n = dynamic_cast<InputNode*>(node.get())) {\n+        return {inputs.at(n)};\n+    } else if (auto n = dynamic_cast<PyNode*>(node.get())) {\n+        auto& cls = n->pyobj;\n+        // Massage variables into form where we can THPFunction_apply it.\n+        // While in principle we can avoid putting things into Python\n+        // and then taking them out again, doing so seems to require an excess\n+        // of faffing about to optimize a codepath that is already going to\n+        // fundamentally be slow (since it calls into Python.) NOT. WORTH. IT.\n+\n+        PyObject* input_objs = PyTuple_New(num_args);\n+        for (size_t i = 0; i < num_args; i++) {\n+          PyTuple_SET_ITEM(input_objs, i, THPVariable_Wrap(input_vars.at(i)));\n+        }", "path": "torch/csrc/autograd/python_function.cpp", "position": null, "original_position": 140, "commit_id": "44aacf730f0dd790657257a7a5ea23fe7cf648ee", "original_commit_id": "0a1c901e80e7ad7f4cb340047d4a2cc271a08efc", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "body": "You seem to assume that functions only take in Variable arguments, but it's not really the case. New-style functions also accept regular Python objects (say a dim along which to perform the op). You might want to cache some additional info computed in `apply`. One of the objects remembers which inputs were Variables, and you can assume that remaining args are parametrizing the op", "created_at": "2017-06-18T22:20:41Z", "updated_at": "2018-11-23T15:33:56Z", "html_url": "https://github.com/pytorch/pytorch/pull/1815#discussion_r122602202", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/1815", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/122602202"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/1815#discussion_r122602202"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/1815"}}, "body_html": "<p>You seem to assume that functions only take in Variable arguments, but it's not really the case. New-style functions also accept regular Python objects (say a dim along which to perform the op). You might want to cache some additional info computed in <code>apply</code>. One of the objects remembers which inputs were Variables, and you can assume that remaining args are parametrizing the op</p>", "body_text": "You seem to assume that functions only take in Variable arguments, but it's not really the case. New-style functions also accept regular Python objects (say a dim along which to perform the op). You might want to cache some additional info computed in apply. One of the objects remembers which inputs were Variables, and you can assume that remaining args are parametrizing the op"}