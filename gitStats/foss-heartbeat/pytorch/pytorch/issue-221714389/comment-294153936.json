{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/294153936", "html_url": "https://github.com/pytorch/pytorch/issues/1257#issuecomment-294153936", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/1257", "id": 294153936, "node_id": "MDEyOklzc3VlQ29tbWVudDI5NDE1MzkzNg==", "user": {"login": "andrewgiessel", "id": 1160997, "node_id": "MDQ6VXNlcjExNjA5OTc=", "avatar_url": "https://avatars0.githubusercontent.com/u/1160997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/andrewgiessel", "html_url": "https://github.com/andrewgiessel", "followers_url": "https://api.github.com/users/andrewgiessel/followers", "following_url": "https://api.github.com/users/andrewgiessel/following{/other_user}", "gists_url": "https://api.github.com/users/andrewgiessel/gists{/gist_id}", "starred_url": "https://api.github.com/users/andrewgiessel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/andrewgiessel/subscriptions", "organizations_url": "https://api.github.com/users/andrewgiessel/orgs", "repos_url": "https://api.github.com/users/andrewgiessel/repos", "events_url": "https://api.github.com/users/andrewgiessel/events{/privacy}", "received_events_url": "https://api.github.com/users/andrewgiessel/received_events", "type": "User", "site_admin": false}, "created_at": "2017-04-14T13:31:40Z", "updated_at": "2017-04-14T13:44:10Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=9110200\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/fmassa\">@fmassa</a> <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=1310570\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/soumith\">@soumith</a> Thanks for commenting.  In particular, I appreciate your feedback, <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=9110200\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/fmassa\">@fmassa</a>!</p>\n<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=9110200\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/fmassa\">@fmassa</a> Indeed, I tried to use that first.  In my case, I'm building my architecture programmatically, and so am building a <code>ModuleList</code> in the constructor that I can compose in<code>foward</code>.   I think the only way I could mix modular and functional approaches would be to use partial function application to bake in the parameters for the functions, which is part of the role of Modules, as far as I can tell.</p>\n<p>More generally, my use case is a bit peculiar (not pixel-level predictions), but rather an autoencoder architecture where I max pool in only in one dimension through the encoder net.  The max pooling kernel can be asymmetric, but the current implementation of UpsamplingBilinear is not.</p>\n<p>Finally, I completely agree that the scaling factor can not give you arbitrary output images.  It makes sense to me to still constrain the scaling factors to integers&gt;=1, but for each dimension instead of one.</p>\n<p>Anyway, I'll open a PR soon and we can continue discussion there once I have a concrete set of changes.  (edit, finished sentence)</p>", "body_text": "@fmassa @soumith Thanks for commenting.  In particular, I appreciate your feedback, @fmassa!\n@fmassa Indeed, I tried to use that first.  In my case, I'm building my architecture programmatically, and so am building a ModuleList in the constructor that I can compose infoward.   I think the only way I could mix modular and functional approaches would be to use partial function application to bake in the parameters for the functions, which is part of the role of Modules, as far as I can tell.\nMore generally, my use case is a bit peculiar (not pixel-level predictions), but rather an autoencoder architecture where I max pool in only in one dimension through the encoder net.  The max pooling kernel can be asymmetric, but the current implementation of UpsamplingBilinear is not.\nFinally, I completely agree that the scaling factor can not give you arbitrary output images.  It makes sense to me to still constrain the scaling factors to integers>=1, but for each dimension instead of one.\nAnyway, I'll open a PR soon and we can continue discussion there once I have a concrete set of changes.  (edit, finished sentence)", "body": "@fmassa @soumith Thanks for commenting.  In particular, I appreciate your feedback, @fmassa!\r\n\r\n@fmassa Indeed, I tried to use that first.  In my case, I'm building my architecture programmatically, and so am building a `ModuleList` in the constructor that I can compose in`foward`.   I think the only way I could mix modular and functional approaches would be to use partial function application to bake in the parameters for the functions, which is part of the role of Modules, as far as I can tell.\r\n\r\nMore generally, my use case is a bit peculiar (not pixel-level predictions), but rather an autoencoder architecture where I max pool in only in one dimension through the encoder net.  The max pooling kernel can be asymmetric, but the current implementation of UpsamplingBilinear is not.  \r\n\r\nFinally, I completely agree that the scaling factor can not give you arbitrary output images.  It makes sense to me to still constrain the scaling factors to integers>=1, but for each dimension instead of one.\r\n\r\nAnyway, I'll open a PR soon and we can continue discussion there once I have a concrete set of changes.  (edit, finished sentence)"}