{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/178601465", "pull_request_review_id": 108683491, "id": 178601465, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE3ODYwMTQ2NQ==", "diff_hunk": "@@ -0,0 +1,224 @@\n+#include \"caffe2/contrib/tensorrt/tensorrt_op_trt.h\"\n+#include \"caffe2/core/logging.h\"\n+\n+#include <numeric>\n+#include <unordered_map>\n+\n+namespace caffe2 {\n+\n+namespace {\n+// Note that input of trt tensor is in CHW format, while our tensor is NCHW\n+// \\return -1 if there is dimension mismatch between C2 tensor and trt tensor.\n+// Otherwise, return the multiplicaton of CHW dimensions\n+int64_t CheckDims(\n+    const nvinfer1::Dims& nv_dims,\n+    const std::vector<TIndex>& c2_dims) {\n+  if (nv_dims.nbDims + 1 != c2_dims.size()) {\n+    return -1;\n+  }\n+  int64_t chw = 1;\n+  for (int i = 0; i < nv_dims.nbDims; ++i) {\n+    if (nv_dims.d[i] != c2_dims[i + 1]) {\n+      return -1;\n+    }\n+    chw *= nv_dims.d[i];\n+  }\n+  return chw;\n+}\n+\n+} // namespace\n+\n+// Upon construction, we build the inference enigne by deserializing from\n+// protobuf string. And since we know the input/output blobs, we can do the\n+// binding here too.\n+TensorRTOp::TensorRTOp(const OperatorDef& operator_def, Workspace* ws)\n+    : Operator<CUDAContext>(operator_def, ws),\n+      logger_((nvinfer1::ILogger::Severity)(\n+          OperatorBase::GetSingleArgument<int>(\"log_verbosity\", 2))),\n+      max_batch_size_(OperatorBase::GetSingleArgument<int>(\"max_batch_size\", 1)) {\n+  {\n+    auto engine_string =\n+        OperatorBase::GetSingleArgument<std::string>(\"serialized_engine\", \"\");\n+    CAFFE_ENFORCE(!engine_string.empty(), \"Empty serialized TensorRT engine!\");\n+    auto trt_runtime = InferObject(nvinfer1::createInferRuntime(logger_));\n+    // TODO(support trt plugin factory)\n+    trt_engine_ = InferObject(trt_runtime->deserializeCudaEngine(\n+        engine_string.data(), engine_string.size(), nullptr));\n+  }\n+\n+  if(!trt_engine_) {\n+    CAFFE_THROW(\"Cannot deserialize TensorRT engine!\");\n+  }\n+\n+  std::unordered_map<std::string, int> inputs;\n+  std::unordered_map<std::string, int> outputs;\n+  for (int i = 0; i < operator_def.input_size(); ++i) {", "path": "caffe2/contrib/tensorrt/tensorrt_op_trt.cc", "position": null, "original_position": 55, "commit_id": "66758cc2919a2a6add56c6bcda8e33f50c94044b", "original_commit_id": "1051f2359f3ec0a4d7c28794d4a3ea67360bcd3d", "user": {"login": "dzhulgakov", "id": 17890620, "node_id": "MDQ6VXNlcjE3ODkwNjIw", "avatar_url": "https://avatars2.githubusercontent.com/u/17890620?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dzhulgakov", "html_url": "https://github.com/dzhulgakov", "followers_url": "https://api.github.com/users/dzhulgakov/followers", "following_url": "https://api.github.com/users/dzhulgakov/following{/other_user}", "gists_url": "https://api.github.com/users/dzhulgakov/gists{/gist_id}", "starred_url": "https://api.github.com/users/dzhulgakov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dzhulgakov/subscriptions", "organizations_url": "https://api.github.com/users/dzhulgakov/orgs", "repos_url": "https://api.github.com/users/dzhulgakov/repos", "events_url": "https://api.github.com/users/dzhulgakov/events{/privacy}", "received_events_url": "https://api.github.com/users/dzhulgakov/received_events", "type": "User", "site_admin": false}, "body": "you can pass names of bindings as arguments of the op if you want. My point is that blob names are *not* part of the op (and the fact that op has access to them is kind of a leaky abstraction). Op should be self contained and I should be able to go to the protobuf, prepend 'bla' to each blob name and stuff should still work", "created_at": "2018-04-02T17:46:36Z", "updated_at": "2018-11-23T15:41:30Z", "html_url": "https://github.com/pytorch/pytorch/pull/6150#discussion_r178601465", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/6150", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/178601465"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/6150#discussion_r178601465"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/6150"}}, "body_html": "<p>you can pass names of bindings as arguments of the op if you want. My point is that blob names are <em>not</em> part of the op (and the fact that op has access to them is kind of a leaky abstraction). Op should be self contained and I should be able to go to the protobuf, prepend 'bla' to each blob name and stuff should still work</p>", "body_text": "you can pass names of bindings as arguments of the op if you want. My point is that blob names are not part of the op (and the fact that op has access to them is kind of a leaky abstraction). Op should be self contained and I should be able to go to the protobuf, prepend 'bla' to each blob name and stuff should still work", "in_reply_to_id": 178410057}