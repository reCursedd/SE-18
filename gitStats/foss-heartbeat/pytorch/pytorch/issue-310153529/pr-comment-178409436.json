{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/178409436", "pull_request_review_id": 108469788, "id": 178409436, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE3ODQwOTQzNg==", "diff_hunk": "@@ -0,0 +1,423 @@\n+#include \"caffe2/contrib/tensorrt/tensorrt_tranformer.h\"\n+#include \"caffe2/contrib/tensorrt/trt_utils.h\"\n+#include \"caffe2/core/logging.h\"\n+#include \"caffe2/core/operator.h\"\n+#include \"caffe2/onnx/onnx_exporter.h\"\n+#include <onnx2trt.hpp>\n+#include <NvInfer.h>\n+\n+#include <google/protobuf/text_format.h>\n+#include <iostream>\n+#include <unordered_set>\n+\n+namespace caffe2 {\n+\n+namespace {\n+\n+// TODO(yinghai): Remove the awkward conversion between unordered_map and map\n+std::unordered_map<std::string, TensorShape> InferShapes(\n+    NetDef* init_net,\n+    NetDef* pred_net,\n+    const std::unordered_map<std::string, TensorShape>& input_shape_hints) {\n+  CaffeMap<std::string, TensorShape> shape_hints_ordered;\n+  for (const auto& kv : input_shape_hints) {\n+    shape_hints_ordered.emplace(kv.first, kv.second);\n+  }\n+  std::vector<std::unique_ptr<NetDef>> nets;\n+  nets.emplace_back(init_net);\n+  nets.emplace_back(pred_net);\n+  InferBlobShapesAndTypes(shape_hints_ordered, nets);\n+  for (auto& net : nets) {\n+    net.release();\n+  }\n+  std::unordered_map<std::string, TensorShape> shape_hints;\n+  for (const auto& kv : shape_hints_ordered) {\n+    shape_hints.emplace(kv.first, kv.second);\n+  }\n+\n+  return shape_hints;\n+}\n+\n+std::vector<std::string> FigureInputs(", "path": "caffe2/contrib/tensorrt/tensorrt_tranformer.cc", "position": null, "original_position": 41, "commit_id": "66758cc2919a2a6add56c6bcda8e33f50c94044b", "original_commit_id": "1051f2359f3ec0a4d7c28794d4a3ea67360bcd3d", "user": {"login": "yinghai", "id": 1100089, "node_id": "MDQ6VXNlcjExMDAwODk=", "avatar_url": "https://avatars1.githubusercontent.com/u/1100089?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yinghai", "html_url": "https://github.com/yinghai", "followers_url": "https://api.github.com/users/yinghai/followers", "following_url": "https://api.github.com/users/yinghai/following{/other_user}", "gists_url": "https://api.github.com/users/yinghai/gists{/gist_id}", "starred_url": "https://api.github.com/users/yinghai/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yinghai/subscriptions", "organizations_url": "https://api.github.com/users/yinghai/orgs", "repos_url": "https://api.github.com/users/yinghai/repos", "events_url": "https://api.github.com/users/yinghai/events{/privacy}", "received_events_url": "https://api.github.com/users/yinghai/received_events", "type": "User", "site_admin": false}, "body": "`start` and `end` defines the continuous chunk of ops that can be readily converted into an TensorRT op. And this function tries to figure out what's the inputs of the to be converted TesnorRT op. What it does is that it collects the outputs from previous ops, which forms a cut boundary, and they can potential input of the TensorRT op (if referenced).  \r\n\r\nBut yes, let me add the explanation into the comment. ", "created_at": "2018-03-30T23:53:06Z", "updated_at": "2018-11-23T15:41:25Z", "html_url": "https://github.com/pytorch/pytorch/pull/6150#discussion_r178409436", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/6150", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/178409436"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/6150#discussion_r178409436"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/6150"}}, "body_html": "<p><code>start</code> and <code>end</code> defines the continuous chunk of ops that can be readily converted into an TensorRT op. And this function tries to figure out what's the inputs of the to be converted TesnorRT op. What it does is that it collects the outputs from previous ops, which forms a cut boundary, and they can potential input of the TensorRT op (if referenced).</p>\n<p>But yes, let me add the explanation into the comment.</p>", "body_text": "start and end defines the continuous chunk of ops that can be readily converted into an TensorRT op. And this function tries to figure out what's the inputs of the to be converted TesnorRT op. What it does is that it collects the outputs from previous ops, which forms a cut boundary, and they can potential input of the TensorRT op (if referenced).\nBut yes, let me add the explanation into the comment.", "in_reply_to_id": 178408805}