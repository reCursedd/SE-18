{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/83736963", "pull_request_review_id": 4561259, "id": 83736963, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDgzNzM2OTYz", "diff_hunk": "@@ -0,0 +1,107 @@\n+import ctypes\n+import torch\n+from . import clib\n+\n+\n+SUCCESS = 0\n+ERROR_NOT_READY = 34\n+\n+\n+class CudaError(RuntimeError):\n+    def __init__(self, code):\n+        msg = clib().cudaGetErrorString(code).decode('utf-8')\n+        super(CudaError, self).__init__('{0} ({1})'.format(msg, code))\n+\n+\n+def check_error(res):\n+    if res != SUCCESS:\n+        raise CudaError(res)\n+\n+\n+class Stream(torch._C.CudaStreamBase):\n+    def __new__(cls, device=None, **kwargs):\n+        with torch.cuda.device(device or torch.cuda.current_device()):\n+            return super(Stream, cls).__new__(cls, **kwargs)\n+\n+    def wait_event(self, event):\n+        check_error(clib().cudaStreamWaitEvent(self, event, ctypes.c_int(0)))\n+\n+    def wait_stream(self, stream):\n+        self.wait_event(stream.record_event())\n+\n+    def record_event(self, event=None):\n+        if event is None:\n+            event = Event()\n+        check_error(clib().cudaEventRecord(event, self))\n+        return event\n+\n+    def query(self):\n+        res = clib().cudaStreamQuery(self)\n+        if res == ERROR_NOT_READY:\n+            return False\n+        check_error(res)\n+        return True\n+\n+    def synchronize(self):\n+        check_error(clib().cudaStreamSynchronize(self))\n+\n+    @property\n+    def _as_parameter_(self):\n+        return ctypes.c_void_p(self.cuda_stream)\n+\n+    def __eq__(self, o):\n+        if isinstance(o, Stream):\n+            return o.device == self.device and o.cuda_stream == self.cuda_stream\n+        return False\n+\n+    def __hash__(self):\n+        return hash((self.cuda_stream, self.device))\n+\n+    def __repr__(self):\n+        return ('<torch.cuda.Stream device={0} cuda_stream={1:#x}>'\n+                .format(self.device, self.cuda_stream))\n+\n+\n+class Event(object):\n+    DEFAULT = 0x0\n+    BLOCKING_SYNC = 0x1\n+    DISABLE_TIMING = 0x2\n+    INTERPROCESS = 0x4\n+\n+    def __init__(self, enable_timing=False, blocking=False, interprocess=False):\n+        flags = Event.DEFAULT\n+        if not enable_timing:\n+            flags |= Event.DISABLE_TIMING\n+        if blocking:\n+            flags |= Event.BLOCKING_SYNC\n+        if interprocess:\n+            flags |= Event.INTERPROCESS\n+\n+        ptr = ctypes.c_void_p()\n+        check_error(clib().cudaEventCreateWithFlags(ctypes.byref(ptr), flags))\n+        self._as_parameter_ = ptr\n+\n+    def __del__(self):\n+        check_error(clib().cudaEventDestroy(self))\n+\n+    def record(self, stream):", "path": "torch/cuda/streams.py", "position": null, "original_position": 87, "commit_id": "99e6af86d4f2a8dab34145eb2d96b6ee3a6bee80", "original_commit_id": "108434e385bd888df8e4a9c6d30ab1d3282778ff", "user": {"login": "colesbury", "id": 655866, "node_id": "MDQ6VXNlcjY1NTg2Ng==", "avatar_url": "https://avatars1.githubusercontent.com/u/655866?v=4", "gravatar_id": "", "url": "https://api.github.com/users/colesbury", "html_url": "https://github.com/colesbury", "followers_url": "https://api.github.com/users/colesbury/followers", "following_url": "https://api.github.com/users/colesbury/following{/other_user}", "gists_url": "https://api.github.com/users/colesbury/gists{/gist_id}", "starred_url": "https://api.github.com/users/colesbury/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/colesbury/subscriptions", "organizations_url": "https://api.github.com/users/colesbury/orgs", "repos_url": "https://api.github.com/users/colesbury/repos", "events_url": "https://api.github.com/users/colesbury/events{/privacy}", "received_events_url": "https://api.github.com/users/colesbury/received_events", "type": "User", "site_admin": false}, "body": "Oh, I meant to make stream optional here. I like both APIs for depending on what you're trying to do.\n\nI like the `Stream.record_event` because it seems more natural to me to express the operation on the Stream.\n\nThe Event API is nice to operate implicitly on the current stream (like we do for Tensor ops, etc.)\n\n``` python\ne = torch.cuda.Event()\ncpuTensor.copy(cudaTensor, async=True)\ne.record()\n...\ne.synchronize()\n```\n", "created_at": "2016-10-17T21:22:03Z", "updated_at": "2018-11-23T15:31:44Z", "html_url": "https://github.com/pytorch/pytorch/pull/133#discussion_r83736963", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/133", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/83736963"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/133#discussion_r83736963"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/133"}}, "body_html": "<p>Oh, I meant to make stream optional here. I like both APIs for depending on what you're trying to do.</p>\n<p>I like the <code>Stream.record_event</code> because it seems more natural to me to express the operation on the Stream.</p>\n<p>The Event API is nice to operate implicitly on the current stream (like we do for Tensor ops, etc.)</p>\n<div class=\"highlight highlight-source-python\"><pre>e <span class=\"pl-k\">=</span> torch.cuda.Event()\ncpuTensor.copy(cudaTensor, <span class=\"pl-k\">async</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">True</span>)\ne.record()\n<span class=\"pl-c1\">...</span>\ne.synchronize()</pre></div>", "body_text": "Oh, I meant to make stream optional here. I like both APIs for depending on what you're trying to do.\nI like the Stream.record_event because it seems more natural to me to express the operation on the Stream.\nThe Event API is nice to operate implicitly on the current stream (like we do for Tensor ops, etc.)\ne = torch.cuda.Event()\ncpuTensor.copy(cudaTensor, async=True)\ne.record()\n...\ne.synchronize()", "in_reply_to_id": 83727189}