{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/387216823", "html_url": "https://github.com/pytorch/pytorch/pull/7160#issuecomment-387216823", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/7160", "id": 387216823, "node_id": "MDEyOklzc3VlQ29tbWVudDM4NzIxNjgyMw==", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "created_at": "2018-05-07T21:45:47Z", "updated_at": "2018-05-07T21:45:47Z", "author_association": "CONTRIBUTOR", "body_html": "<blockquote>\n<p>Sorry I don't know what whole archive is (does it mean that you enforce linking all of object files on the compiler, even if they're not used directly?).</p>\n</blockquote>\n<p>Basically, I'm alluding to the fact that in a few situations, widely used compiler/linker toolchains will drop your static initializers on the floor when linking. Fortunately, there are only finitely many of these:</p>\n<ul>\n<li>If you build a static library, and link it into a dynamic library without <code>-Wl,--whole-archive</code></li>\n<li>If you set a dependency against a dynamic library but don't use any of its symbols without <code>-Wl,--no-as-needed</code> on a sufficiently new Ubuntu distro</li>\n</ul>\n<p>The point is that (1) when compiling an object file, no compiler will ever drop the static initializer (because it doesn't know what the compilation unit is) and (2) when assembling object files into a library, there is usually some linker flags you can pass to make sure it preserves static initializers, and (3) when depending on a shared library, there is usually some linker flags you can pass to make sure it loads the library.</p>\n<p>Granted, (2) and (3) mean that sometimes, clients have to be more careful when pulling in libraries. This is not so great. So for example, we may often write code on top of <code>Registry</code> to automatically <code>dlopen</code> the library necessary if the user didn't do (3) correctly.</p>", "body_text": "Sorry I don't know what whole archive is (does it mean that you enforce linking all of object files on the compiler, even if they're not used directly?).\n\nBasically, I'm alluding to the fact that in a few situations, widely used compiler/linker toolchains will drop your static initializers on the floor when linking. Fortunately, there are only finitely many of these:\n\nIf you build a static library, and link it into a dynamic library without -Wl,--whole-archive\nIf you set a dependency against a dynamic library but don't use any of its symbols without -Wl,--no-as-needed on a sufficiently new Ubuntu distro\n\nThe point is that (1) when compiling an object file, no compiler will ever drop the static initializer (because it doesn't know what the compilation unit is) and (2) when assembling object files into a library, there is usually some linker flags you can pass to make sure it preserves static initializers, and (3) when depending on a shared library, there is usually some linker flags you can pass to make sure it loads the library.\nGranted, (2) and (3) mean that sometimes, clients have to be more careful when pulling in libraries. This is not so great. So for example, we may often write code on top of Registry to automatically dlopen the library necessary if the user didn't do (3) correctly.", "body": "> Sorry I don't know what whole archive is (does it mean that you enforce linking all of object files on the compiler, even if they're not used directly?).\r\n\r\nBasically, I'm alluding to the fact that in a few situations, widely used compiler/linker toolchains will drop your static initializers on the floor when linking. Fortunately, there are only finitely many of these:\r\n\r\n- If you build a static library, and link it into a dynamic library without `-Wl,--whole-archive`\r\n- If you set a dependency against a dynamic library but don't use any of its symbols without `-Wl,--no-as-needed` on a sufficiently new Ubuntu distro\r\n\r\nThe point is that (1) when compiling an object file, no compiler will ever drop the static initializer (because it doesn't know what the compilation unit is) and (2) when assembling object files into a library, there is usually some linker flags you can pass to make sure it preserves static initializers, and (3) when depending on a shared library, there is usually some linker flags you can pass to make sure it loads the library.\r\n\r\nGranted, (2) and (3) mean that sometimes, clients have to be more careful when pulling in libraries. This is not so great. So for example, we may often write code on top of `Registry` to automatically `dlopen` the library necessary if the user didn't do (3) correctly."}