{"url": "https://api.github.com/repos/pytorch/pytorch/issues/6010", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/6010/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/6010/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/6010/events", "html_url": "https://github.com/pytorch/pytorch/issues/6010", "id": 308702746, "node_id": "MDU6SXNzdWUzMDg3MDI3NDY=", "number": 6010, "title": "Develop a strategy for writing leak tests for pytorch. ", "user": {"login": "zdevito", "id": 370202, "node_id": "MDQ6VXNlcjM3MDIwMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/370202?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zdevito", "html_url": "https://github.com/zdevito", "followers_url": "https://api.github.com/users/zdevito/followers", "following_url": "https://api.github.com/users/zdevito/following{/other_user}", "gists_url": "https://api.github.com/users/zdevito/gists{/gist_id}", "starred_url": "https://api.github.com/users/zdevito/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zdevito/subscriptions", "organizations_url": "https://api.github.com/users/zdevito/orgs", "repos_url": "https://api.github.com/users/zdevito/repos", "events_url": "https://api.github.com/users/zdevito/events{/privacy}", "received_events_url": "https://api.github.com/users/zdevito/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 679953983, "node_id": "MDU6TGFiZWw2Nzk5NTM5ODM=", "url": "https://api.github.com/repos/pytorch/pytorch/labels/jit", "name": "jit", "color": "c5def5", "default": false}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2018-03-26T19:23:32Z", "updated_at": "2018-03-28T17:50:31Z", "closed_at": null, "author_association": "CONTRIBUTOR", "body_html": "<p>Use it to test for leaks in the graph executor/interpreter, etc.</p>\n<p>Ideas:</p>\n<ul>\n<li>Add an api to create a tensor, hold a weak reference to it, and assert after a certain point that it is not longer present. Use this tensor as an input to various things that might accidentally hold references to it.</li>\n<li>Add a function like <code>should_be_freed(x)</code> that can go in the middle of the network, and adds <code>x</code> to a list of tensors that should only be temporaries. A later call <code>assert_freed()</code> should check that all those tensors have disappeared.</li>\n<li>Make <code>should_be_freed</code> work during tracing and in the script so that intermediates in that code path are checked as well.</li>\n</ul>\n<p>Why? Currently our tests will not find when a major leak occurs unless it causes some test to completely run out of GPU memory. This means we often find leaks weeks later when the cause is harder to find. Pybind and python's APIs make introducing leaks very easy, so this happens frequently.</p>", "body_text": "Use it to test for leaks in the graph executor/interpreter, etc.\nIdeas:\n\nAdd an api to create a tensor, hold a weak reference to it, and assert after a certain point that it is not longer present. Use this tensor as an input to various things that might accidentally hold references to it.\nAdd a function like should_be_freed(x) that can go in the middle of the network, and adds x to a list of tensors that should only be temporaries. A later call assert_freed() should check that all those tensors have disappeared.\nMake should_be_freed work during tracing and in the script so that intermediates in that code path are checked as well.\n\nWhy? Currently our tests will not find when a major leak occurs unless it causes some test to completely run out of GPU memory. This means we often find leaks weeks later when the cause is harder to find. Pybind and python's APIs make introducing leaks very easy, so this happens frequently.", "body": "Use it to test for leaks in the graph executor/interpreter, etc. \r\n\r\nIdeas:\r\n* Add an api to create a tensor, hold a weak reference to it, and assert after a certain point that it is not longer present. Use this tensor as an input to various things that might accidentally hold references to it. \r\n* Add a function like `should_be_freed(x)` that can go in the middle of the network, and adds `x` to a list of tensors that should only be temporaries. A later call `assert_freed()` should check that all those tensors have disappeared.\r\n* Make `should_be_freed` work during tracing and in the script so that intermediates in that code path are checked as well.\r\n\r\n\r\nWhy? Currently our tests will not find when a major leak occurs unless it causes some test to completely run out of GPU memory. This means we often find leaks weeks later when the cause is harder to find. Pybind and python's APIs make introducing leaks very easy, so this happens frequently.\r\n"}