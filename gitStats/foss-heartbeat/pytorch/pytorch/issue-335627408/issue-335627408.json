{"url": "https://api.github.com/repos/pytorch/pytorch/issues/8885", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/8885/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/8885/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/8885/events", "html_url": "https://github.com/pytorch/pytorch/pull/8885", "id": 335627408, "node_id": "MDExOlB1bGxSZXF1ZXN0MTk3Mjc5NzA3", "number": 8885, "title": "Unify aten_dispatch and aten_schema into a single operator abstraction with human-readable schema.", "user": {"login": "zdevito", "id": 370202, "node_id": "MDQ6VXNlcjM3MDIwMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/370202?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zdevito", "html_url": "https://github.com/zdevito", "followers_url": "https://api.github.com/users/zdevito/followers", "following_url": "https://api.github.com/users/zdevito/following{/other_user}", "gists_url": "https://api.github.com/users/zdevito/gists{/gist_id}", "starred_url": "https://api.github.com/users/zdevito/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zdevito/subscriptions", "organizations_url": "https://api.github.com/users/zdevito/orgs", "repos_url": "https://api.github.com/users/zdevito/repos", "events_url": "https://api.github.com/users/zdevito/events{/privacy}", "received_events_url": "https://api.github.com/users/zdevito/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 6, "created_at": "2018-06-26T01:45:19Z", "updated_at": "2018-11-23T15:46:51Z", "closed_at": "2018-07-10T17:25:46Z", "author_association": "CONTRIBUTOR", "pull_request": {"url": "https://api.github.com/repos/pytorch/pytorch/pulls/8885", "html_url": "https://github.com/pytorch/pytorch/pull/8885", "diff_url": "https://github.com/pytorch/pytorch/pull/8885.diff", "patch_url": "https://github.com/pytorch/pytorch/pull/8885.patch"}, "body_html": "<p>This is a series of two commits that should probably be read separately. They are stacked on top of <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"336860517\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/9018\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/pytorch/pytorch/pull/9018/hovercard\" href=\"https://github.com/pytorch/pytorch/pull/9018\">#9018</a> since the second commit requires it for correctness.</p>\n<h1>Commit 1</h1>\n<p>This commit is the first in a series that will clean up how we handle declaring operators and intrinsics in the JIT to make it more modular and readable. This introduces readable declarations that can be used to register operators and switches gen_jit_dispatch to generate this schema. A follow up PR will remove the dispatch keys like \"add-3\" and resolve ops directly based on the registered schema, further simplifying the generation process.</p>\n<ul>\n<li>Switches schema over to parsed declarations, in the future this will allow something like:</li>\n</ul>\n<pre><code>  registry.register_intrinsic(\"foo(Tensor a, Tensor b) -&gt; Tensor\", [](Stack&amp; stack) {\n    ...\n  })\n</code></pre>\n<p>This will allow the scalable registration of intrinsics for lists, tuples, and other ops, as long as meta-data for these ops (e.g. derivatives and size propagation routines).</p>\n<p>The declarations resemble those used by PythonArgParser but have been singificantly cleaned up to minimize the number of types that can appear in the declaration. We should strive to get the other parts of PyTorch switched over to this restricted declaration set when possible, but it is too much to do in a single PR. My hope is that eventually we will use a very similar language to describe declarations in C10, and this can serve as a guide for that.</p>\n<p>Parsing is done using the script lexer, so it is very robust to whitespace and extensible for future types.</p>\n<p>This removes the other way we encoded schema, and makes it easier to see what schema are registered.</p>\n<p>Current generated declarations: <a href=\"https://gist.github.com/zdevito/a96a17766fb3a098d69a91ee00abaaf6\">https://gist.github.com/zdevito/a96a17766fb3a098d69a91ee00abaaf6</a></p>\n<ul>\n<li>\n<p>Switches how we handle attempting to use an integer in the place of a fixed-sized int list, such as in conv (e.g. 'int[3] stride=1'). Now that we can statically distinguish between int and Tensor, we handle the expansion as an implicit conversion in the compiler. This allows us to simplify the interpreter since it no longer needs to handle the conversion itself.</p>\n</li>\n<li>\n<p>Schema declarations have been changed so that they match the type system in the IR exactly. In particular, attribute_info which was used by liftConstantAttributes has been dropped and constant attributes are lifted purely based on the type of the input. Type conversions in compiler have been simplified due to this change.</p>\n</li>\n<li>\n<p>Error highlighting in ErrorReport now only reports at most 20 lines of code, to make reading where an error occurred easier.</p>\n</li>\n</ul>\n<h1>Commit 2</h1>\n<p>This commit unifies aten_dispatch and aten_schema into a single Operator object that both contains schema and implementation information. In the future we can use this object to also contain functionality like shape prop and autodiff needed by all operators. Operators are registered globally, and dispatch logic uses the schema information to figure out which variant to use. Descriptor keys, a frequent source of inscrutable debug errors, have been removed.</p>\n<ul>\n<li>\n<p>Introduce Operator, to replace TensorOp. Unlike TensorOp, we use Operator for all op implementations, including primitives that may occur in the graphs. The only exceptions are ops that are only known to the interpreter like jumps, and GraphExecutors where we need to record additional debug info.</p>\n</li>\n<li>\n<p>Adds a global registry for Operator implementations. aten_dispatch.cpp turns into register_aten_ops.cpp, which registers all the Operators for aten with the operator registry. register_prim_ops.cpp now contains the implementations for primitive operators that used to be in the interpreter. This means that it is now safe to use <code>getOperation(node)</code> to lookup the true interpreter function for the node, which will simplify const-propagation passes.</p>\n</li>\n<li>\n<p>Remove addInterpreterOpHandler in favor of global operator registry.</p>\n</li>\n<li>\n<p>Instead of descriptors, we match Node arguments directly against FunctionSchema describing expected inputs in <code>matchSchema</code>. <code>matchSchema</code> knows how parse both attributes and positional inputs from a node and match it to the appropriate registered operator. Debug error messages when we try to run an invalid operator are significantly improved: they now automatically display the schema for the op with the same name that are registered.</p>\n</li>\n<li>\n<p>Merge aten_schema into regsiter_aten_ops. Each Operator takes a string schema which is parsed to determine when to dispatch to that op.</p>\n</li>\n<li>\n<p>Cleans up gen_jit_dispatch.py now that we do not need to write out descriptors.  In particular, skip_scalar_overloads can be removed since Richard's code sorts declarations to put Tensor, Tensor declarations first.</p>\n</li>\n<li>\n<p>remove matchSchemaAndLiftConstantAttributes and use emitBuiltinCall instead to remove code duplication</p>\n</li>\n<li>\n<p>refactor stack manipulation functions into a separate header file.</p>\n</li>\n</ul>", "body_text": "This is a series of two commits that should probably be read separately. They are stacked on top of #9018 since the second commit requires it for correctness.\nCommit 1\nThis commit is the first in a series that will clean up how we handle declaring operators and intrinsics in the JIT to make it more modular and readable. This introduces readable declarations that can be used to register operators and switches gen_jit_dispatch to generate this schema. A follow up PR will remove the dispatch keys like \"add-3\" and resolve ops directly based on the registered schema, further simplifying the generation process.\n\nSwitches schema over to parsed declarations, in the future this will allow something like:\n\n  registry.register_intrinsic(\"foo(Tensor a, Tensor b) -> Tensor\", [](Stack& stack) {\n    ...\n  })\n\nThis will allow the scalable registration of intrinsics for lists, tuples, and other ops, as long as meta-data for these ops (e.g. derivatives and size propagation routines).\nThe declarations resemble those used by PythonArgParser but have been singificantly cleaned up to minimize the number of types that can appear in the declaration. We should strive to get the other parts of PyTorch switched over to this restricted declaration set when possible, but it is too much to do in a single PR. My hope is that eventually we will use a very similar language to describe declarations in C10, and this can serve as a guide for that.\nParsing is done using the script lexer, so it is very robust to whitespace and extensible for future types.\nThis removes the other way we encoded schema, and makes it easier to see what schema are registered.\nCurrent generated declarations: https://gist.github.com/zdevito/a96a17766fb3a098d69a91ee00abaaf6\n\n\nSwitches how we handle attempting to use an integer in the place of a fixed-sized int list, such as in conv (e.g. 'int[3] stride=1'). Now that we can statically distinguish between int and Tensor, we handle the expansion as an implicit conversion in the compiler. This allows us to simplify the interpreter since it no longer needs to handle the conversion itself.\n\n\nSchema declarations have been changed so that they match the type system in the IR exactly. In particular, attribute_info which was used by liftConstantAttributes has been dropped and constant attributes are lifted purely based on the type of the input. Type conversions in compiler have been simplified due to this change.\n\n\nError highlighting in ErrorReport now only reports at most 20 lines of code, to make reading where an error occurred easier.\n\n\nCommit 2\nThis commit unifies aten_dispatch and aten_schema into a single Operator object that both contains schema and implementation information. In the future we can use this object to also contain functionality like shape prop and autodiff needed by all operators. Operators are registered globally, and dispatch logic uses the schema information to figure out which variant to use. Descriptor keys, a frequent source of inscrutable debug errors, have been removed.\n\n\nIntroduce Operator, to replace TensorOp. Unlike TensorOp, we use Operator for all op implementations, including primitives that may occur in the graphs. The only exceptions are ops that are only known to the interpreter like jumps, and GraphExecutors where we need to record additional debug info.\n\n\nAdds a global registry for Operator implementations. aten_dispatch.cpp turns into register_aten_ops.cpp, which registers all the Operators for aten with the operator registry. register_prim_ops.cpp now contains the implementations for primitive operators that used to be in the interpreter. This means that it is now safe to use getOperation(node) to lookup the true interpreter function for the node, which will simplify const-propagation passes.\n\n\nRemove addInterpreterOpHandler in favor of global operator registry.\n\n\nInstead of descriptors, we match Node arguments directly against FunctionSchema describing expected inputs in matchSchema. matchSchema knows how parse both attributes and positional inputs from a node and match it to the appropriate registered operator. Debug error messages when we try to run an invalid operator are significantly improved: they now automatically display the schema for the op with the same name that are registered.\n\n\nMerge aten_schema into regsiter_aten_ops. Each Operator takes a string schema which is parsed to determine when to dispatch to that op.\n\n\nCleans up gen_jit_dispatch.py now that we do not need to write out descriptors.  In particular, skip_scalar_overloads can be removed since Richard's code sorts declarations to put Tensor, Tensor declarations first.\n\n\nremove matchSchemaAndLiftConstantAttributes and use emitBuiltinCall instead to remove code duplication\n\n\nrefactor stack manipulation functions into a separate header file.", "body": "This is a series of two commits that should probably be read separately. They are stacked on top of #9018 since the second commit requires it for correctness. \r\n\r\n\r\nCommit 1\r\n=======\r\n\r\nThis commit is the first in a series that will clean up how we handle declaring operators and intrinsics in the JIT to make it more modular and readable. This introduces readable declarations that can be used to register operators and switches gen_jit_dispatch to generate this schema. A follow up PR will remove the dispatch keys like \"add-3\" and resolve ops directly based on the registered schema, further simplifying the generation process.\r\n\r\n* Switches schema over to parsed declarations, in the future this will allow something like:\r\n\r\n```\r\n  registry.register_intrinsic(\"foo(Tensor a, Tensor b) -> Tensor\", [](Stack& stack) {\r\n    ...\r\n  })\r\n```\r\n\r\nThis will allow the scalable registration of intrinsics for lists, tuples, and other ops, as long as meta-data for these ops (e.g. derivatives and size propagation routines).\r\n\r\nThe declarations resemble those used by PythonArgParser but have been singificantly cleaned up to minimize the number of types that can appear in the declaration. We should strive to get the other parts of PyTorch switched over to this restricted declaration set when possible, but it is too much to do in a single PR. My hope is that eventually we will use a very similar language to describe declarations in C10, and this can serve as a guide for that.\r\n\r\nParsing is done using the script lexer, so it is very robust to whitespace and extensible for future types.\r\n\r\nThis removes the other way we encoded schema, and makes it easier to see what schema are registered.\r\n\r\nCurrent generated declarations: https://gist.github.com/zdevito/a96a17766fb3a098d69a91ee00abaaf6\r\n\r\n* Switches how we handle attempting to use an integer in the place of a fixed-sized int list, such as in conv (e.g. 'int[3] stride=1'). Now that we can statically distinguish between int and Tensor, we handle the expansion as an implicit conversion in the compiler. This allows us to simplify the interpreter since it no longer needs to handle the conversion itself.\r\n\r\n* Schema declarations have been changed so that they match the type system in the IR exactly. In particular, attribute_info which was used by liftConstantAttributes has been dropped and constant attributes are lifted purely based on the type of the input. Type conversions in compiler have been simplified due to this change.\r\n\r\n* Error highlighting in ErrorReport now only reports at most 20 lines of code, to make reading where an error occurred easier.\r\n\r\nCommit 2\r\n=======\r\n\r\nThis commit unifies aten_dispatch and aten_schema into a single Operator object that both contains schema and implementation information. In the future we can use this object to also contain functionality like shape prop and autodiff needed by all operators. Operators are registered globally, and dispatch logic uses the schema information to figure out which variant to use. Descriptor keys, a frequent source of inscrutable debug errors, have been removed.\r\n\r\n* Introduce Operator, to replace TensorOp. Unlike TensorOp, we use Operator for all op implementations, including primitives that may occur in the graphs. The only exceptions are ops that are only known to the interpreter like jumps, and GraphExecutors where we need to record additional debug info.\r\n\r\n* Adds a global registry for Operator implementations. aten_dispatch.cpp turns into register_aten_ops.cpp, which registers all the Operators for aten with the operator registry. register_prim_ops.cpp now contains the implementations for primitive operators that used to be in the interpreter. This means that it is now safe to use `getOperation(node)` to lookup the true interpreter function for the node, which will simplify const-propagation passes.\r\n\r\n* Remove addInterpreterOpHandler in favor of global operator registry.\r\n\r\n* Instead of descriptors, we match Node arguments directly against FunctionSchema describing expected inputs in `matchSchema`. `matchSchema` knows how parse both attributes and positional inputs from a node and match it to the appropriate registered operator. Debug error messages when we try to run an invalid operator are significantly improved: they now automatically display the schema for the op with the same name that are registered.\r\n\r\n* Merge aten_schema into regsiter_aten_ops. Each Operator takes a string schema which is parsed to determine when to dispatch to that op.\r\n\r\n* Cleans up gen_jit_dispatch.py now that we do not need to write out descriptors.  In particular, skip_scalar_overloads can be removed since Richard's code sorts declarations to put Tensor, Tensor declarations first.\r\n\r\n* remove matchSchemaAndLiftConstantAttributes and use emitBuiltinCall instead to remove code duplication\r\n\r\n* refactor stack manipulation functions into a separate header file.\r\n"}