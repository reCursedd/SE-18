{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/433492762", "html_url": "https://github.com/pytorch/pytorch/issues/13041#issuecomment-433492762", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/13041", "id": 433492762, "node_id": "MDEyOklzc3VlQ29tbWVudDQzMzQ5Mjc2Mg==", "user": {"login": "CarlosYeverino", "id": 25825048, "node_id": "MDQ6VXNlcjI1ODI1MDQ4", "avatar_url": "https://avatars0.githubusercontent.com/u/25825048?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CarlosYeverino", "html_url": "https://github.com/CarlosYeverino", "followers_url": "https://api.github.com/users/CarlosYeverino/followers", "following_url": "https://api.github.com/users/CarlosYeverino/following{/other_user}", "gists_url": "https://api.github.com/users/CarlosYeverino/gists{/gist_id}", "starred_url": "https://api.github.com/users/CarlosYeverino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CarlosYeverino/subscriptions", "organizations_url": "https://api.github.com/users/CarlosYeverino/orgs", "repos_url": "https://api.github.com/users/CarlosYeverino/repos", "events_url": "https://api.github.com/users/CarlosYeverino/events{/privacy}", "received_events_url": "https://api.github.com/users/CarlosYeverino/received_events", "type": "User", "site_admin": false}, "created_at": "2018-10-26T17:57:36Z", "updated_at": "2018-10-26T17:57:36Z", "author_association": "NONE", "body_html": "<p>Hi <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=7837172\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/BIGBALLON\">@BIGBALLON</a> ,</p>\n<p>thanks for your replay!</p>\n<p>How would you handle the input feeding in training if you use brew.db_input? Would you call the add_input function for each desired input?</p>\n<pre><code>def add_input(self, model, batch_size, db, db_type, device_opts):\n        with core.DeviceScope(device_opts):\n            # load the data\n            data_uint8, label = brew.db_input(\n                model,\n                blobs_out=[\"data_uint8\", \"label\"],\n                batch_size=batch_size,\n                db=db,\n                db_type=db_type,\n            )\n            # cast the data to float\n            data = model.Cast(data_uint8, \"data\", to=core.DataType.FLOAT)\n\n            # scale data from [0,255] down to [0,1]\n            data = model.Scale(data, data, scale=float(1./256))\n\n            # don't need the gradient for the backward pass\n            data = model.StopGradient(data, data)\n            return data, label\n</code></pre>", "body_text": "Hi @BIGBALLON ,\nthanks for your replay!\nHow would you handle the input feeding in training if you use brew.db_input? Would you call the add_input function for each desired input?\ndef add_input(self, model, batch_size, db, db_type, device_opts):\n        with core.DeviceScope(device_opts):\n            # load the data\n            data_uint8, label = brew.db_input(\n                model,\n                blobs_out=[\"data_uint8\", \"label\"],\n                batch_size=batch_size,\n                db=db,\n                db_type=db_type,\n            )\n            # cast the data to float\n            data = model.Cast(data_uint8, \"data\", to=core.DataType.FLOAT)\n\n            # scale data from [0,255] down to [0,1]\n            data = model.Scale(data, data, scale=float(1./256))\n\n            # don't need the gradient for the backward pass\n            data = model.StopGradient(data, data)\n            return data, label", "body": "Hi @BIGBALLON ,\r\n\r\nthanks for your replay!\r\n\r\nHow would you handle the input feeding in training if you use brew.db_input? Would you call the add_input function for each desired input?\r\n\r\n```\r\ndef add_input(self, model, batch_size, db, db_type, device_opts):\r\n        with core.DeviceScope(device_opts):\r\n            # load the data\r\n            data_uint8, label = brew.db_input(\r\n                model,\r\n                blobs_out=[\"data_uint8\", \"label\"],\r\n                batch_size=batch_size,\r\n                db=db,\r\n                db_type=db_type,\r\n            )\r\n            # cast the data to float\r\n            data = model.Cast(data_uint8, \"data\", to=core.DataType.FLOAT)\r\n\r\n            # scale data from [0,255] down to [0,1]\r\n            data = model.Scale(data, data, scale=float(1./256))\r\n\r\n            # don't need the gradient for the backward pass\r\n            data = model.StopGradient(data, data)\r\n            return data, label\r\n```"}