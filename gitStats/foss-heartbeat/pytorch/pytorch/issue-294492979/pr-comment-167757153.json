{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/167757153", "pull_request_review_id": 96021568, "id": 167757153, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2Nzc1NzE1Mw==", "diff_hunk": "@@ -0,0 +1,274 @@\n+#ifndef THC_OFFSET_INFO_INC\n+#define THC_OFFSET_INFO_INC\n+\n+#include \"THCIntegerDivider.cuh\"\n+#include \"THCTensorInfo.cuh\"\n+\n+// A faster implementation of IndexToOffset that pre-computes the increments to\n+// the indices along each dimension.\n+//\n+// Consider a kernel with the following loop:\n+//\n+//      for (IndexType linearIndex = blockIdx.x * blockDim.x + threadIdx.x;\n+//           linearIndex < totalElements;\n+//           linearIndex += gridDim.x * blockDim.x) { ... }\n+//\n+// Note that the increment value (gridDim.x * blockDim.x) is fixed and known\n+// before the kernel starts.  Hence, we can pre-compute how the coordinates\n+// change.  For example, assume that the increment is 1024 and the tensor has\n+// size [5, 70, 10] and strides [2000, 20, 1].  During the execution of a\n+// particular thread, linearIndex may change from 1205 to 2229:\n+//\n+//      Before: linear index 1205 = 1 * 70 * 10 + 50 * 10 + 5\n+//              coordinate (1, 50, 5)\n+//              offset = 1 * 2000 + 50 * 20 + 5 * 1 = 3005\n+//\n+//      Linear index increment = 1024 = 1 * 70 * 10 + 32 * 10 + 4\n+//      Coordinate increment = (1, 32, 4)\n+//\n+//      After: linear index 2029\n+//             coordinate (1, 50, 5) + (1, 32, 4) = (2, 82, 9)\n+//                        = (3, 12, 9)   // Handle carry over.\n+//             offset = 3 * 2000 + 12 * 20 + 9 * 1 = 6249\n+//\n+// Thus, by pre-computing \"coordinate increment\" (1, 32, 4), we can compute the\n+// next coordinate and offset without costly division.  We also pre-compute the\n+// following values, for each dimension k (0 <= k < Dims):\n+//\n+//      increments[k] == (increment to coordinate #k at each step)\n+//      scaledIncrs[k] == increments[k] * strides[k]\n+//      carryDelta[k] == strides[k - 1] - (size[k] * strides[k])  (for k > 0)\n+//\n+// (carryDelta[k] is the change of offset when the addition to dimension #k\n+// \"carries over\" to #k-1.  In general, carryDelta can be \"negative\" even though\n+// IndexType is unsigned: it is always added to the offset, so the result will\n+// be correct.)\n+//\n+// So, the example shown above will be stored as:\n+//\n+//      increments  = (1, 32, 4)\n+//      scaledIncrs = (2000, 640, 4)\n+//      carryDelta  = (_, 600, 10)\n+//\n+// Finally, we can also optimize the initial coordinate computation by\n+// pre-computing \"magic dividers\", thus replacing the initial div/mod operations\n+// by multiplication.  (See IntDivider for details.)\n+\n+// Helper function that increments 'indices' and returns the updated offset.\n+template <typename IndexType>\n+__host__ __device__ __forceinline__\n+IndexType incrementIdx(int dims, IndexType offset,\n+                       const IntDivider<IndexType> sizes[],\n+                       const IndexType increments[],\n+                       const IndexType scaledIncrs[],\n+                       const IndexType carryDelta[],\n+                       IndexType indices[])\n+{\n+  bool carry = false;\n+\n+  for (int i = dims - 1; i > 0; --i) {\n+    IndexType index = indices[i] + increments[i] + (IndexType) carry;", "path": "aten/src/THC/THCOffsetInfo.cuh", "position": null, "original_position": 70, "commit_id": "68723f3fd0b2a826fa4cd71878db24f40e99b2cf", "original_commit_id": "d8961cb8cf9f8cecc749b7c0d9cb833dbce96a56", "user": {"login": "yongjik", "id": 31876421, "node_id": "MDQ6VXNlcjMxODc2NDIx", "avatar_url": "https://avatars2.githubusercontent.com/u/31876421?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yongjik", "html_url": "https://github.com/yongjik", "followers_url": "https://api.github.com/users/yongjik/followers", "following_url": "https://api.github.com/users/yongjik/following{/other_user}", "gists_url": "https://api.github.com/users/yongjik/gists{/gist_id}", "starred_url": "https://api.github.com/users/yongjik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yongjik/subscriptions", "organizations_url": "https://api.github.com/users/yongjik/orgs", "repos_url": "https://api.github.com/users/yongjik/repos", "events_url": "https://api.github.com/users/yongjik/events{/privacy}", "received_events_url": "https://api.github.com/users/yongjik/received_events", "type": "User", "site_admin": false}, "body": "Done.", "created_at": "2018-02-13T04:14:46Z", "updated_at": "2018-11-23T15:39:30Z", "html_url": "https://github.com/pytorch/pytorch/pull/5054#discussion_r167757153", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/5054", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/167757153"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/5054#discussion_r167757153"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/5054"}}, "body_html": "<p>Done.</p>", "body_text": "Done.", "in_reply_to_id": 166389809}