{"url": "https://api.github.com/repos/pytorch/pytorch/issues/5054", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/5054/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/5054/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/5054/events", "html_url": "https://github.com/pytorch/pytorch/pull/5054", "id": 294492979, "node_id": "MDExOlB1bGxSZXF1ZXN0MTY3MjE4MzU1", "number": 5054, "title": "Use fast integer division algorithm to avoid division ops inside kernels.", "user": {"login": "yongjik", "id": 31876421, "node_id": "MDQ6VXNlcjMxODc2NDIx", "avatar_url": "https://avatars2.githubusercontent.com/u/31876421?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yongjik", "html_url": "https://github.com/yongjik", "followers_url": "https://api.github.com/users/yongjik/followers", "following_url": "https://api.github.com/users/yongjik/following{/other_user}", "gists_url": "https://api.github.com/users/yongjik/gists{/gist_id}", "starred_url": "https://api.github.com/users/yongjik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yongjik/subscriptions", "organizations_url": "https://api.github.com/users/yongjik/orgs", "repos_url": "https://api.github.com/users/yongjik/repos", "events_url": "https://api.github.com/users/yongjik/events{/privacy}", "received_events_url": "https://api.github.com/users/yongjik/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 18, "created_at": "2018-02-05T18:20:37Z", "updated_at": "2018-11-23T15:40:18Z", "closed_at": "2018-03-04T05:39:58Z", "author_association": "CONTRIBUTOR", "pull_request": {"url": "https://api.github.com/repos/pytorch/pytorch/pulls/5054", "html_url": "https://github.com/pytorch/pytorch/pull/5054", "diff_url": "https://github.com/pytorch/pytorch/pull/5054.diff", "patch_url": "https://github.com/pytorch/pytorch/pull/5054.patch"}, "body_html": "<ul>\n<li>\n<p>OffsetInfo and OffsetIterator pre-computes the necessary coordinate<br>\nchange along each dimension, so that each successive offset can be<br>\ncomputed using only addition/subtraction/comparisons.</p>\n</li>\n<li>\n<p>Added IntDivider which supports \"magic division\" for uint32_t, thus<br>\neliminating integer divisions altogether for offset calculation, as<br>\nlong as indices fit in 32 bits.</p>\n</li>\n<li>\n<p>In code paths with statically determined dimensions (Dims=1 or 2),<br>\nkernel arguments now contain only the necessary data (instead of<br>\nMAX_CUTORCH_DIMS of everything).</p>\n</li>\n<li>\n<p>Fixed index overflow errors: for tensors with &gt;= 2G elements, we used<br>\nto have incorrect results or an infinite loop inside the kernel.</p>\n</li>\n</ul>\n<p>TODO: The following pattern is broken for tensors with &gt;= 2G elements.<br>\nIt will result in overflow, even if IndexType is uint64_t.  Need<br>\nto search and replace them.</p>\n<blockquote>\n<p>for (IndexType linearIndex = blockIdx.x * blockDim.x + threadIdx.x;<br>\nlinearIndex &lt; totalElements;<br>\nlinearIndex += gridDim.x * blockDim.x) {</p>\n</blockquote>", "body_text": "OffsetInfo and OffsetIterator pre-computes the necessary coordinate\nchange along each dimension, so that each successive offset can be\ncomputed using only addition/subtraction/comparisons.\n\n\nAdded IntDivider which supports \"magic division\" for uint32_t, thus\neliminating integer divisions altogether for offset calculation, as\nlong as indices fit in 32 bits.\n\n\nIn code paths with statically determined dimensions (Dims=1 or 2),\nkernel arguments now contain only the necessary data (instead of\nMAX_CUTORCH_DIMS of everything).\n\n\nFixed index overflow errors: for tensors with >= 2G elements, we used\nto have incorrect results or an infinite loop inside the kernel.\n\n\nTODO: The following pattern is broken for tensors with >= 2G elements.\nIt will result in overflow, even if IndexType is uint64_t.  Need\nto search and replace them.\n\nfor (IndexType linearIndex = blockIdx.x * blockDim.x + threadIdx.x;\nlinearIndex < totalElements;\nlinearIndex += gridDim.x * blockDim.x) {", "body": "- OffsetInfo and OffsetIterator pre-computes the necessary coordinate\r\n  change along each dimension, so that each successive offset can be\r\n  computed using only addition/subtraction/comparisons.\r\n\r\n- Added IntDivider which supports \"magic division\" for uint32_t, thus\r\n  eliminating integer divisions altogether for offset calculation, as\r\n  long as indices fit in 32 bits.\r\n\r\n- In code paths with statically determined dimensions (Dims=1 or 2),\r\n  kernel arguments now contain only the necessary data (instead of\r\n  MAX_CUTORCH_DIMS of everything).\r\n\r\n- Fixed index overflow errors: for tensors with >= 2G elements, we used\r\n  to have incorrect results or an infinite loop inside the kernel.\r\n\r\nTODO: The following pattern is broken for tensors with >= 2G elements.\r\n      It will result in overflow, even if IndexType is uint64_t.  Need\r\n      to search and replace them.\r\n\r\n  > for (IndexType linearIndex = blockIdx.x * blockDim.x + threadIdx.x;\r\n  >      linearIndex < totalElements;\r\n  >      linearIndex += gridDim.x * blockDim.x) {"}