{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/166389809", "pull_request_review_id": 94440694, "id": 166389809, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2NjM4OTgwOQ==", "diff_hunk": "@@ -0,0 +1,274 @@\n+#ifndef THC_OFFSET_INFO_INC\n+#define THC_OFFSET_INFO_INC\n+\n+#include \"THCIntegerDivider.cuh\"\n+#include \"THCTensorInfo.cuh\"\n+\n+// A faster implementation of IndexToOffset that pre-computes the increments to\n+// the indices along each dimension.\n+//\n+// Consider a kernel with the following loop:\n+//\n+//      for (IndexType linearIndex = blockIdx.x * blockDim.x + threadIdx.x;\n+//           linearIndex < totalElements;\n+//           linearIndex += gridDim.x * blockDim.x) { ... }\n+//\n+// Note that the increment value (gridDim.x * blockDim.x) is fixed and known\n+// before the kernel starts.  Hence, we can pre-compute how the coordinates\n+// change.  For example, assume that the increment is 1024 and the tensor has\n+// size [5, 70, 10] and strides [2000, 20, 1].  During the execution of a\n+// particular thread, linearIndex may change from 1205 to 2229:\n+//\n+//      Before: linear index 1205 = 1 * 70 * 10 + 50 * 10 + 5\n+//              coordinate (1, 50, 5)\n+//              offset = 1 * 2000 + 50 * 20 + 5 * 1 = 3005\n+//\n+//      Linear index increment = 1024 = 1 * 70 * 10 + 32 * 10 + 4\n+//      Coordinate increment = (1, 32, 4)\n+//\n+//      After: linear index 2029\n+//             coordinate (1, 50, 5) + (1, 32, 4) = (2, 82, 9)\n+//                        = (3, 12, 9)   // Handle carry over.\n+//             offset = 3 * 2000 + 12 * 20 + 9 * 1 = 6249\n+//\n+// Thus, by pre-computing \"coordinate increment\" (1, 32, 4), we can compute the\n+// next coordinate and offset without costly division.  We also pre-compute the\n+// following values, for each dimension k (0 <= k < Dims):\n+//\n+//      increments[k] == (increment to coordinate #k at each step)\n+//      scaledIncrs[k] == increments[k] * strides[k]\n+//      carryDelta[k] == strides[k - 1] - (size[k] * strides[k])  (for k > 0)\n+//\n+// (carryDelta[k] is the change of offset when the addition to dimension #k\n+// \"carries over\" to #k-1.  In general, carryDelta can be \"negative\" even though\n+// IndexType is unsigned: it is always added to the offset, so the result will\n+// be correct.)\n+//\n+// So, the example shown above will be stored as:\n+//\n+//      increments  = (1, 32, 4)\n+//      scaledIncrs = (2000, 640, 4)\n+//      carryDelta  = (_, 600, 10)\n+//\n+// Finally, we can also optimize the initial coordinate computation by\n+// pre-computing \"magic dividers\", thus replacing the initial div/mod operations\n+// by multiplication.  (See IntDivider for details.)\n+\n+// Helper function that increments 'indices' and returns the updated offset.\n+template <typename IndexType>\n+__host__ __device__ __forceinline__\n+IndexType incrementIdx(int dims, IndexType offset,\n+                       const IntDivider<IndexType> sizes[],\n+                       const IndexType increments[],\n+                       const IndexType scaledIncrs[],\n+                       const IndexType carryDelta[],\n+                       IndexType indices[])\n+{\n+  bool carry = false;\n+\n+  for (int i = dims - 1; i > 0; --i) {\n+    IndexType index = indices[i] + increments[i] + (IndexType) carry;", "path": "aten/src/THC/THCOffsetInfo.cuh", "position": null, "original_position": 70, "commit_id": "68723f3fd0b2a826fa4cd71878db24f40e99b2cf", "original_commit_id": "d8961cb8cf9f8cecc749b7c0d9cb833dbce96a56", "user": {"login": "wickedfoo", "id": 1911637, "node_id": "MDQ6VXNlcjE5MTE2Mzc=", "avatar_url": "https://avatars0.githubusercontent.com/u/1911637?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wickedfoo", "html_url": "https://github.com/wickedfoo", "followers_url": "https://api.github.com/users/wickedfoo/followers", "following_url": "https://api.github.com/users/wickedfoo/following{/other_user}", "gists_url": "https://api.github.com/users/wickedfoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/wickedfoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wickedfoo/subscriptions", "organizations_url": "https://api.github.com/users/wickedfoo/orgs", "repos_url": "https://api.github.com/users/wickedfoo/repos", "events_url": "https://api.github.com/users/wickedfoo/events{/privacy}", "received_events_url": "https://api.github.com/users/wickedfoo/received_events", "type": "User", "site_admin": false}, "body": "I'm not convinced that maintaining the increment this way is faster than it was before, or especially if you simplify the integer div/mod as above and just calculate the index each time.\r\n\r\nThis is a lot of instructions to go through, plus the predicate at line 81. I have to imagine that this will bloat out the register count as well, as you're maintaining per-dimension increment state.\r\n\r\nThe kernels are not as easy to read as before either.\r\n\r\nCan you try this code without adding these iterator operators, and have it as before, just by modifying the linear index -> offset code?\r\n", "created_at": "2018-02-06T18:00:32Z", "updated_at": "2018-11-23T15:39:10Z", "html_url": "https://github.com/pytorch/pytorch/pull/5054#discussion_r166389809", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/5054", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/166389809"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/5054#discussion_r166389809"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/5054"}}, "body_html": "<p>I'm not convinced that maintaining the increment this way is faster than it was before, or especially if you simplify the integer div/mod as above and just calculate the index each time.</p>\n<p>This is a lot of instructions to go through, plus the predicate at line 81. I have to imagine that this will bloat out the register count as well, as you're maintaining per-dimension increment state.</p>\n<p>The kernels are not as easy to read as before either.</p>\n<p>Can you try this code without adding these iterator operators, and have it as before, just by modifying the linear index -&gt; offset code?</p>", "body_text": "I'm not convinced that maintaining the increment this way is faster than it was before, or especially if you simplify the integer div/mod as above and just calculate the index each time.\nThis is a lot of instructions to go through, plus the predicate at line 81. I have to imagine that this will bloat out the register count as well, as you're maintaining per-dimension increment state.\nThe kernels are not as easy to read as before either.\nCan you try this code without adding these iterator operators, and have it as before, just by modifying the linear index -> offset code?"}