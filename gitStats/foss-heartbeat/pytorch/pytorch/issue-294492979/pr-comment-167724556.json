{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/167724556", "pull_request_review_id": 95986038, "id": 167724556, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2NzcyNDU1Ng==", "diff_hunk": "@@ -0,0 +1,120 @@\n+#ifndef THC_INTEGER_DIVIDER_INC\n+#define THC_INTEGER_DIVIDER_INC\n+\n+#include <assert.h>\n+\n+// A utility class to implement integer division by muliplication, given a fixed\n+// divisor.\n+//\n+// (NOTE: Below, \"2^k\" denotes exponentiation, i.e., 1<<k.)\n+//\n+// For any N-bit unsigned integer d (> 0), we can find a \"magic number\" m (2^N\n+// <= m < 2^(N+1)) and shift s such that:\n+//\n+//    \\floor(n / d) = \\floor((m * n) / 2^(N+s)).\n+//\n+// Given such m and s, the integer division can be then implemented as:\n+//\n+//    let m' = m - 2^N  // 0 <= m' < 2^N\n+//        s1 = (s == 0) ? 0 : 1\n+//        s2 = s - s1\n+//\n+//    fast_integer_division(n):\n+//      // Multiply two N-bit unsigned integers: the result is a 2N-bit unsigned\n+//      // integer.  Then take the higher N bits.\n+//      t = (m' * n) >> N\n+//\n+//      // The return value is simply (t + n) >> s, but computing this directly\n+//      // may overflow, so we shift twice.\n+//      t2 = t + ((n - t) >> s1)\n+//      return t2 >> s2\n+//\n+// We have to be careful with (t + n) because it may overflow.  Finding such a\n+// magic number is surprisingly easy:\n+//\n+//    s  = \\ceil(\\log_2 d)\n+//    m' = \\floor(2^N * (2^s - d) / d) + 1  // Need 2N-bit integer arithmetic.\n+//\n+// See also:\n+//    - Division by Invariant Integers Using Multiplication,\n+//      Torbj\u00f6rn Granlund and Peter L. Montgomery, 1994.\n+//\n+//    - http://www.hackersdelight.org/magic.htm\n+//\n+//    - http://ridiculousfish.com/blog/posts/labor-of-division-episode-i.html\n+\n+// Result of div/mod operation stored together.\n+template <typename Value>\n+struct DivMod {\n+  Value div, mod;\n+\n+  __host__ __device__ DivMod(Value div, Value mod) : div(div), mod(mod) { }\n+};\n+\n+// Base case: we only have an implementation for uint32_t for now.  For\n+// everything else, we use plain division.\n+template <typename Value>\n+struct IntDivider {\n+  IntDivider() { }  // Dummy constructor for arrays.\n+  IntDivider(Value d) : divisor(d) { }\n+\n+  __host__ __device__ inline Value div(Value n) const { return n / divisor; }\n+  __host__ __device__ inline Value mod(Value n) const { return n % divisor; }\n+  __host__ __device__ inline DivMod<Value> divmod(Value n) const {\n+    return DivMod<Value>(n / divisor, n % divisor);\n+  }\n+\n+  Value divisor;\n+};\n+\n+// Implement fast integer division.\n+template <>\n+struct IntDivider<unsigned int> {\n+  static_assert(sizeof(unsigned int) == 4, \"Assumes 32-bit unsigned int.\");\n+\n+  IntDivider() { }  // Dummy constructor for arrays.\n+\n+  IntDivider(unsigned int d) : divisor(d) {\n+    assert(divisor != 0);\n+\n+    // TODO: gcc/clang has __builtin_clz() but it's not portable.\n+    unsigned int shift;\n+    for (shift = 0; shift < 32; shift++) if ((1U << shift) >= divisor) break;\n+    s1 = (shift == 0) ? 0 : 1;\n+    s2 = shift - s1;\n+\n+    uint64_t one = 1;\n+    uint64_t magic = ((one << 32) * ((one << shift) - divisor)) / divisor + 1;\n+    m1 = magic;\n+    assert(m1 > 0 && m1 == magic);  // m1 must fit in 32 bits.\n+  }\n+\n+  __host__ __device__ inline unsigned int div(unsigned int n) const {\n+#ifdef __CUDA_ARCH__\n+    // 't' is the higher 32-bits of unsigned 32-bit multiplication of 'n' and\n+    // 'm1'.\n+    unsigned int t = __umulhi(n, m1);", "path": "aten/src/THC/THCIntegerDivider.cuh", "position": 97, "original_position": 96, "commit_id": "68723f3fd0b2a826fa4cd71878db24f40e99b2cf", "original_commit_id": "d8961cb8cf9f8cecc749b7c0d9cb833dbce96a56", "user": {"login": "yongjik", "id": 31876421, "node_id": "MDQ6VXNlcjMxODc2NDIx", "avatar_url": "https://avatars2.githubusercontent.com/u/31876421?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yongjik", "html_url": "https://github.com/yongjik", "followers_url": "https://api.github.com/users/yongjik/followers", "following_url": "https://api.github.com/users/yongjik/following{/other_user}", "gists_url": "https://api.github.com/users/yongjik/gists{/gist_id}", "starred_url": "https://api.github.com/users/yongjik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yongjik/subscriptions", "organizations_url": "https://api.github.com/users/yongjik/orgs", "repos_url": "https://api.github.com/users/yongjik/repos", "events_url": "https://api.github.com/users/yongjik/events{/privacy}", "received_events_url": "https://api.github.com/users/yongjik/received_events", "type": "User", "site_admin": false}, "body": "(Sorry for the late reply: have been busy with other stuff.  I'll upload the updated code by tonight.)\r\n\r\nSo I checked signed versions, and signed 32-bit multiplication is identical to unsigned version.\r\n\r\n(It threw me off at first, but when you think about it, the lower 32 bits are the same for signed/unsigned 32-bit multiplications.)\r\n\r\nHigher 32-bits for signed multiplication:\r\n\r\n    // *data = __mulhi(*data, a);\r\n\r\n        ...\r\n        /*0028*/ LDG.E R0, [R2];\r\n        /*0030*/ XMAD R5, R0.reuse, c[0x0] [0x148], RZ;\r\n        /*0038*/ XMAD.U16.S16 R4, R0.reuse, c[0x0] [0x148].H1, RZ;\r\n\r\n        /*0048*/ XMAD.S16.S16.CSFU R6, R0.H1, c[0x0] [0x148].H1, RZ;\r\n        /*0050*/ XMAD.S16.U16.CHI R5, R0.H1, c[0x0] [0x148], R5;\r\n        /*0058*/ IADD3.RS R0, R5, R4, R6;\r\n\r\n        /*0068*/ STG.E [R2], R0;\r\n        ...\r\n\r\nStill 3 XMAD (fused multiply-add) ops and one IADD3, so it's basically the same as the unsigned version.\r\n\r\nJust for fun, I tried signed/unsigned divisions, and they have:\r\n\r\n    unsigned division: 14 XMAD ops, 8 IADD/IADD3/IADD32I ops, a few others.\r\n    signed division: 14 XMAD ops, 9 IADD/IADD3/IADD32I ops, a few others.\r\n", "created_at": "2018-02-12T23:56:57Z", "updated_at": "2018-11-23T15:39:30Z", "html_url": "https://github.com/pytorch/pytorch/pull/5054#discussion_r167724556", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/5054", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/167724556"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/5054#discussion_r167724556"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/5054"}}, "body_html": "<p>(Sorry for the late reply: have been busy with other stuff.  I'll upload the updated code by tonight.)</p>\n<p>So I checked signed versions, and signed 32-bit multiplication is identical to unsigned version.</p>\n<p>(It threw me off at first, but when you think about it, the lower 32 bits are the same for signed/unsigned 32-bit multiplications.)</p>\n<p>Higher 32-bits for signed multiplication:</p>\n<pre><code>// *data = __mulhi(*data, a);\n\n    ...\n    /*0028*/ LDG.E R0, [R2];\n    /*0030*/ XMAD R5, R0.reuse, c[0x0] [0x148], RZ;\n    /*0038*/ XMAD.U16.S16 R4, R0.reuse, c[0x0] [0x148].H1, RZ;\n\n    /*0048*/ XMAD.S16.S16.CSFU R6, R0.H1, c[0x0] [0x148].H1, RZ;\n    /*0050*/ XMAD.S16.U16.CHI R5, R0.H1, c[0x0] [0x148], R5;\n    /*0058*/ IADD3.RS R0, R5, R4, R6;\n\n    /*0068*/ STG.E [R2], R0;\n    ...\n</code></pre>\n<p>Still 3 XMAD (fused multiply-add) ops and one IADD3, so it's basically the same as the unsigned version.</p>\n<p>Just for fun, I tried signed/unsigned divisions, and they have:</p>\n<pre><code>unsigned division: 14 XMAD ops, 8 IADD/IADD3/IADD32I ops, a few others.\nsigned division: 14 XMAD ops, 9 IADD/IADD3/IADD32I ops, a few others.\n</code></pre>", "body_text": "(Sorry for the late reply: have been busy with other stuff.  I'll upload the updated code by tonight.)\nSo I checked signed versions, and signed 32-bit multiplication is identical to unsigned version.\n(It threw me off at first, but when you think about it, the lower 32 bits are the same for signed/unsigned 32-bit multiplications.)\nHigher 32-bits for signed multiplication:\n// *data = __mulhi(*data, a);\n\n    ...\n    /*0028*/ LDG.E R0, [R2];\n    /*0030*/ XMAD R5, R0.reuse, c[0x0] [0x148], RZ;\n    /*0038*/ XMAD.U16.S16 R4, R0.reuse, c[0x0] [0x148].H1, RZ;\n\n    /*0048*/ XMAD.S16.S16.CSFU R6, R0.H1, c[0x0] [0x148].H1, RZ;\n    /*0050*/ XMAD.S16.U16.CHI R5, R0.H1, c[0x0] [0x148], R5;\n    /*0058*/ IADD3.RS R0, R5, R4, R6;\n\n    /*0068*/ STG.E [R2], R0;\n    ...\n\nStill 3 XMAD (fused multiply-add) ops and one IADD3, so it's basically the same as the unsigned version.\nJust for fun, I tried signed/unsigned divisions, and they have:\nunsigned division: 14 XMAD ops, 8 IADD/IADD3/IADD32I ops, a few others.\nsigned division: 14 XMAD ops, 9 IADD/IADD3/IADD32I ops, a few others.", "in_reply_to_id": 166386897}