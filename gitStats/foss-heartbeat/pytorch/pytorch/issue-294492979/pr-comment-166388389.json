{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/166388389", "pull_request_review_id": 94440694, "id": 166388389, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2NjM4ODM4OQ==", "diff_hunk": "@@ -0,0 +1,120 @@\n+#ifndef THC_INTEGER_DIVIDER_INC\n+#define THC_INTEGER_DIVIDER_INC\n+\n+#include <assert.h>\n+\n+// A utility class to implement integer division by muliplication, given a fixed\n+// divisor.\n+//\n+// (NOTE: Below, \"2^k\" denotes exponentiation, i.e., 1<<k.)\n+//\n+// For any N-bit unsigned integer d (> 0), we can find a \"magic number\" m (2^N\n+// <= m < 2^(N+1)) and shift s such that:\n+//\n+//    \\floor(n / d) = \\floor((m * n) / 2^(N+s)).\n+//\n+// Given such m and s, the integer division can be then implemented as:\n+//\n+//    let m' = m - 2^N  // 0 <= m' < 2^N\n+//        s1 = (s == 0) ? 0 : 1\n+//        s2 = s - s1\n+//\n+//    fast_integer_division(n):\n+//      // Multiply two N-bit unsigned integers: the result is a 2N-bit unsigned\n+//      // integer.  Then take the higher N bits.\n+//      t = (m' * n) >> N\n+//\n+//      // The return value is simply (t + n) >> s, but computing this directly\n+//      // may overflow, so we shift twice.\n+//      t2 = t + ((n - t) >> s1)\n+//      return t2 >> s2\n+//\n+// We have to be careful with (t + n) because it may overflow.  Finding such a\n+// magic number is surprisingly easy:\n+//\n+//    s  = \\ceil(\\log_2 d)\n+//    m' = \\floor(2^N * (2^s - d) / d) + 1  // Need 2N-bit integer arithmetic.\n+//\n+// See also:\n+//    - Division by Invariant Integers Using Multiplication,\n+//      Torbj\u00f6rn Granlund and Peter L. Montgomery, 1994.\n+//\n+//    - http://www.hackersdelight.org/magic.htm\n+//\n+//    - http://ridiculousfish.com/blog/posts/labor-of-division-episode-i.html\n+\n+// Result of div/mod operation stored together.\n+template <typename Value>\n+struct DivMod {\n+  Value div, mod;\n+\n+  __host__ __device__ DivMod(Value div, Value mod) : div(div), mod(mod) { }\n+};\n+\n+// Base case: we only have an implementation for uint32_t for now.  For\n+// everything else, we use plain division.\n+template <typename Value>\n+struct IntDivider {\n+  IntDivider() { }  // Dummy constructor for arrays.\n+  IntDivider(Value d) : divisor(d) { }\n+\n+  __host__ __device__ inline Value div(Value n) const { return n / divisor; }\n+  __host__ __device__ inline Value mod(Value n) const { return n % divisor; }\n+  __host__ __device__ inline DivMod<Value> divmod(Value n) const {\n+    return DivMod<Value>(n / divisor, n % divisor);\n+  }\n+\n+  Value divisor;\n+};\n+\n+// Implement fast integer division.\n+template <>\n+struct IntDivider<unsigned int> {\n+  static_assert(sizeof(unsigned int) == 4, \"Assumes 32-bit unsigned int.\");\n+\n+  IntDivider() { }  // Dummy constructor for arrays.\n+\n+  IntDivider(unsigned int d) : divisor(d) {\n+    assert(divisor != 0);\n+\n+    // TODO: gcc/clang has __builtin_clz() but it's not portable.\n+    unsigned int shift;\n+    for (shift = 0; shift < 32; shift++) if ((1U << shift) >= divisor) break;\n+    s1 = (shift == 0) ? 0 : 1;\n+    s2 = shift - s1;\n+\n+    uint64_t one = 1;\n+    uint64_t magic = ((one << 32) * ((one << shift) - divisor)) / divisor + 1;\n+    m1 = magic;\n+    assert(m1 > 0 && m1 == magic);  // m1 must fit in 32 bits.\n+  }\n+\n+  __host__ __device__ inline unsigned int div(unsigned int n) const {\n+#ifdef __CUDA_ARCH__\n+    // 't' is the higher 32-bits of unsigned 32-bit multiplication of 'n' and\n+    // 'm1'.\n+    unsigned int t = __umulhi(n, m1);\n+    unsigned int t2 = t + ((n - t) >> s1);", "path": "aten/src/THC/THCIntegerDivider.cuh", "position": null, "original_position": 97, "commit_id": "68723f3fd0b2a826fa4cd71878db24f40e99b2cf", "original_commit_id": "d8961cb8cf9f8cecc749b7c0d9cb833dbce96a56", "user": {"login": "wickedfoo", "id": 1911637, "node_id": "MDQ6VXNlcjE5MTE2Mzc=", "avatar_url": "https://avatars0.githubusercontent.com/u/1911637?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wickedfoo", "html_url": "https://github.com/wickedfoo", "followers_url": "https://api.github.com/users/wickedfoo/followers", "following_url": "https://api.github.com/users/wickedfoo/following{/other_user}", "gists_url": "https://api.github.com/users/wickedfoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/wickedfoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wickedfoo/subscriptions", "organizations_url": "https://api.github.com/users/wickedfoo/orgs", "repos_url": "https://api.github.com/users/wickedfoo/repos", "events_url": "https://api.github.com/users/wickedfoo/events{/privacy}", "received_events_url": "https://api.github.com/users/wickedfoo/received_events", "type": "User", "site_admin": false}, "body": "I think the math can be much simplified if the range is restricted to signed integers (e.g., 2 to INT_MAX). This just involves one mulhi and a single shift, versus your mulhi, two adds, and two shifts.\r\n\r\nCode that you can reference is here:\r\n\r\nhttps://github.com/caffe2/caffe2/blob/master/caffe2/utils/fixed_divisor.h#L53\r\n\r\nThat code works for the range 1 to INT_MAX, but involves 64 bit integer math. Since you have a mulhi instruction and to avoid super-slow 64-bit integer math, I believe you'd have to limit this code to work for the range 2 to INT_MAX (i.e., the case at line 76-79 can't be handled). shift_ needs 32 to be subtracted from it as well.\r\n", "created_at": "2018-02-06T17:55:37Z", "updated_at": "2018-11-23T15:39:10Z", "html_url": "https://github.com/pytorch/pytorch/pull/5054#discussion_r166388389", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/5054", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/166388389"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/5054#discussion_r166388389"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/5054"}}, "body_html": "<p>I think the math can be much simplified if the range is restricted to signed integers (e.g., 2 to INT_MAX). This just involves one mulhi and a single shift, versus your mulhi, two adds, and two shifts.</p>\n<p>Code that you can reference is here:</p>\n<p><a href=\"https://github.com/caffe2/caffe2/blob/master/caffe2/utils/fixed_divisor.h#L53\">https://github.com/caffe2/caffe2/blob/master/caffe2/utils/fixed_divisor.h#L53</a></p>\n<p>That code works for the range 1 to INT_MAX, but involves 64 bit integer math. Since you have a mulhi instruction and to avoid super-slow 64-bit integer math, I believe you'd have to limit this code to work for the range 2 to INT_MAX (i.e., the case at line 76-79 can't be handled). shift_ needs 32 to be subtracted from it as well.</p>", "body_text": "I think the math can be much simplified if the range is restricted to signed integers (e.g., 2 to INT_MAX). This just involves one mulhi and a single shift, versus your mulhi, two adds, and two shifts.\nCode that you can reference is here:\nhttps://github.com/caffe2/caffe2/blob/master/caffe2/utils/fixed_divisor.h#L53\nThat code works for the range 1 to INT_MAX, but involves 64 bit integer math. Since you have a mulhi instruction and to avoid super-slow 64-bit integer math, I believe you'd have to limit this code to work for the range 2 to INT_MAX (i.e., the case at line 76-79 can't be handled). shift_ needs 32 to be subtracted from it as well."}