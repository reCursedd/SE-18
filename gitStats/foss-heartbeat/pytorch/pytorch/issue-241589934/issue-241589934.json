{"url": "https://api.github.com/repos/pytorch/pytorch/issues/2031", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/2031/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/2031/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/2031/events", "html_url": "https://github.com/pytorch/pytorch/issues/2031", "id": 241589934, "node_id": "MDU6SXNzdWUyNDE1ODk5MzQ=", "number": 2031, "title": "[Feature request] unique operation", "user": {"login": "brenoarosa", "id": 6242862, "node_id": "MDQ6VXNlcjYyNDI4NjI=", "avatar_url": "https://avatars2.githubusercontent.com/u/6242862?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brenoarosa", "html_url": "https://github.com/brenoarosa", "followers_url": "https://api.github.com/users/brenoarosa/followers", "following_url": "https://api.github.com/users/brenoarosa/following{/other_user}", "gists_url": "https://api.github.com/users/brenoarosa/gists{/gist_id}", "starred_url": "https://api.github.com/users/brenoarosa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brenoarosa/subscriptions", "organizations_url": "https://api.github.com/users/brenoarosa/orgs", "repos_url": "https://api.github.com/users/brenoarosa/repos", "events_url": "https://api.github.com/users/brenoarosa/events{/privacy}", "received_events_url": "https://api.github.com/users/brenoarosa/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 424131849, "node_id": "MDU6TGFiZWw0MjQxMzE4NDk=", "url": "https://api.github.com/repos/pytorch/pytorch/labels/enhancement", "name": "enhancement", "color": "84b6eb", "default": true}, {"id": 443484050, "node_id": "MDU6TGFiZWw0NDM0ODQwNTA=", "url": "https://api.github.com/repos/pytorch/pytorch/labels/medium%20priority", "name": "medium priority", "color": "fbca04", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2017-07-10T03:26:37Z", "updated_at": "2018-03-07T23:17:09Z", "closed_at": "2018-03-07T23:17:09Z", "author_association": "NONE", "body_html": "<p>Hi,<br>\nI'm missing an operation like <a href=\"https://www.tensorflow.org/api_docs/python/tf/unique\" rel=\"nofollow\">tensorflow's unique</a>.</p>\n<p>I'm trying to build minibatch weights for very skewed datasets.<br>\nMy current code looks like the following snippet.</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">def</span> <span class=\"pl-en\">get_loss_weights</span>(<span class=\"pl-smi\">target</span>, <span class=\"pl-smi\">num_classes</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">2</span>, <span class=\"pl-smi\">eps</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">1e-08</span>):\n    <span class=\"pl-s\"><span class=\"pl-pds\">\"\"\"</span> </span>\n<span class=\"pl-s\">    Gets loss weights by counting target classes examples</span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">    To help with skewed datasets we need to weight the gradient.</span>\n<span class=\"pl-s\">    Each class need to have the same influence in gradient.</span>\n<span class=\"pl-s\">    So, each example will have weight equal to 1/num_classes * 1/class_count</span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">    Usage:</span>\n<span class=\"pl-s\">    <span class=\"pl-k\">&gt;&gt;&gt; </span>tensor = Variable(torch.FloatTensor([1, 0, 0, 0]))                                                                                            </span>\n<span class=\"pl-s\">    <span class=\"pl-k\">&gt;&gt;&gt; </span>get_loss_weights(tensor)</span>\n<span class=\"pl-s\">        0.5000</span>\n<span class=\"pl-s\">        0.1667</span>\n<span class=\"pl-s\">        0.1667</span>\n<span class=\"pl-s\">        0.1667</span>\n<span class=\"pl-s\">        [torch.FloatTensor of size 4]</span>\n<span class=\"pl-s\">    <span class=\"pl-pds\">\"\"\"</span></span>\n\n    weights <span class=\"pl-k\">=</span> Variable(torch.zeros(target.data.size()))\n\n    <span class=\"pl-k\">for</span> <span class=\"pl-c1\">cls</span> <span class=\"pl-k\">in</span> <span class=\"pl-c1\">range</span>(num_classes):\n        cls_members <span class=\"pl-k\">=</span> (target.data <span class=\"pl-k\">==</span> <span class=\"pl-c1\">cls</span>).float()\n        weights <span class=\"pl-k\">+=</span> Variable(<span class=\"pl-c1\">1</span> <span class=\"pl-k\">/</span> (torch.sum(cls_members) <span class=\"pl-k\">+</span> eps) <span class=\"pl-k\">*</span> cls_members)\n\n    weights <span class=\"pl-k\">/=</span> num_classes\n    <span class=\"pl-k\">return</span> weights.data</pre></div>\n<p>I would like to build a more robust approach using unique operation.<br>\nI'm happy to hear different approaches or optimizations.</p>\n<p>Thanks for the package!</p>\n<p>Edit:<br>\nFor anyone interested, the code to compute samples weights as sent as <a href=\"https://github.com/pytorch/pytorch/pull/2549\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/pytorch/pytorch/pull/2549/hovercard\">PR #2549 </a></p>", "body_text": "Hi,\nI'm missing an operation like tensorflow's unique.\nI'm trying to build minibatch weights for very skewed datasets.\nMy current code looks like the following snippet.\ndef get_loss_weights(target, num_classes=2, eps=1e-08):\n    \"\"\" \n    Gets loss weights by counting target classes examples\n\n    To help with skewed datasets we need to weight the gradient.\n    Each class need to have the same influence in gradient.\n    So, each example will have weight equal to 1/num_classes * 1/class_count\n\n    Usage:\n    >>> tensor = Variable(torch.FloatTensor([1, 0, 0, 0]))                                                                                            \n    >>> get_loss_weights(tensor)\n        0.5000\n        0.1667\n        0.1667\n        0.1667\n        [torch.FloatTensor of size 4]\n    \"\"\"\n\n    weights = Variable(torch.zeros(target.data.size()))\n\n    for cls in range(num_classes):\n        cls_members = (target.data == cls).float()\n        weights += Variable(1 / (torch.sum(cls_members) + eps) * cls_members)\n\n    weights /= num_classes\n    return weights.data\nI would like to build a more robust approach using unique operation.\nI'm happy to hear different approaches or optimizations.\nThanks for the package!\nEdit:\nFor anyone interested, the code to compute samples weights as sent as PR #2549", "body": "Hi,  \r\nI'm missing an operation like [tensorflow's unique](https://www.tensorflow.org/api_docs/python/tf/unique).  \r\n\r\nI'm trying to build minibatch weights for very skewed datasets.  \r\nMy current code looks like the following snippet.\r\n```python\r\ndef get_loss_weights(target, num_classes=2, eps=1e-08):\r\n    \"\"\" \r\n    Gets loss weights by counting target classes examples\r\n\r\n    To help with skewed datasets we need to weight the gradient.\r\n    Each class need to have the same influence in gradient.\r\n    So, each example will have weight equal to 1/num_classes * 1/class_count\r\n\r\n    Usage:\r\n    >>> tensor = Variable(torch.FloatTensor([1, 0, 0, 0]))                                                                                            \r\n    >>> get_loss_weights(tensor)\r\n        0.5000\r\n        0.1667\r\n        0.1667\r\n        0.1667\r\n        [torch.FloatTensor of size 4]\r\n    \"\"\"\r\n\r\n    weights = Variable(torch.zeros(target.data.size()))\r\n\r\n    for cls in range(num_classes):\r\n        cls_members = (target.data == cls).float()\r\n        weights += Variable(1 / (torch.sum(cls_members) + eps) * cls_members)\r\n\r\n    weights /= num_classes\r\n    return weights.data\r\n```\r\n\r\nI would like to build a more robust approach using unique operation.  \r\nI'm happy to hear different approaches or optimizations. \r\n\r\nThanks for the package!\r\n\r\nEdit:\r\nFor anyone interested, the code to compute samples weights as sent as [PR #2549 ](https://github.com/pytorch/pytorch/pull/2549)"}