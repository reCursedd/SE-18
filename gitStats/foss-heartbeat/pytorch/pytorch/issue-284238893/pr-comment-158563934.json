{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/158563934", "pull_request_review_id": 85402732, "id": 158563934, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1ODU2MzkzNA==", "diff_hunk": "@@ -42,5 +42,22 @@ auto dispatch_floating_types(const Type& the_type, const char *name, Args&&... a\n     }\n }\n \n+#define DISPATCH_ALL_FLOATING_TYPES(TYPE, NAME, F...)                            \\\n+  [&]() {                                                                         \\", "path": "aten/src/ATen/Dispatch.h", "position": null, "original_position": 5, "commit_id": "8dab6c62f8e579ea93f407aeeafc57bedfb0ca37", "original_commit_id": "ce025518fdbbabc7074e4038d7a6e3e75cd626d9", "user": {"login": "colesbury", "id": 655866, "node_id": "MDQ6VXNlcjY1NTg2Ng==", "avatar_url": "https://avatars1.githubusercontent.com/u/655866?v=4", "gravatar_id": "", "url": "https://api.github.com/users/colesbury", "html_url": "https://github.com/colesbury", "followers_url": "https://api.github.com/users/colesbury/followers", "following_url": "https://api.github.com/users/colesbury/following{/other_user}", "gists_url": "https://api.github.com/users/colesbury/gists{/gist_id}", "starred_url": "https://api.github.com/users/colesbury/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/colesbury/subscriptions", "organizations_url": "https://api.github.com/users/colesbury/orgs", "repos_url": "https://api.github.com/users/colesbury/repos", "events_url": "https://api.github.com/users/colesbury/events{/privacy}", "received_events_url": "https://api.github.com/users/colesbury/received_events", "type": "User", "site_admin": false}, "body": "1. Not sure what you're referring to. You can capture `unique_ptr` by reference.\r\n2. It's not much more magical than assuming your templated struct takes a the scalar type as the first parameter. It just standardizes the name.\r\n\r\nC++14 won't help. We don't really want lambdas with `auto` here because the lambdas don't typically take anything of type `scalar`. They just take `Tensor`s.\r\n\r\nIt's substantially less boiler plate because you can capture the relevant tensors by reference. With a struct functor you have to pass all argument through your lambda, as well as possibly the grid, dim, and stream.", "created_at": "2017-12-22T22:11:38Z", "updated_at": "2018-11-23T15:37:38Z", "html_url": "https://github.com/pytorch/pytorch/pull/4322#discussion_r158563934", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/4322", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/158563934"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/4322#discussion_r158563934"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/4322"}}, "body_html": "<ol>\n<li>Not sure what you're referring to. You can capture <code>unique_ptr</code> by reference.</li>\n<li>It's not much more magical than assuming your templated struct takes a the scalar type as the first parameter. It just standardizes the name.</li>\n</ol>\n<p>C++14 won't help. We don't really want lambdas with <code>auto</code> here because the lambdas don't typically take anything of type <code>scalar</code>. They just take <code>Tensor</code>s.</p>\n<p>It's substantially less boiler plate because you can capture the relevant tensors by reference. With a struct functor you have to pass all argument through your lambda, as well as possibly the grid, dim, and stream.</p>", "body_text": "Not sure what you're referring to. You can capture unique_ptr by reference.\nIt's not much more magical than assuming your templated struct takes a the scalar type as the first parameter. It just standardizes the name.\n\nC++14 won't help. We don't really want lambdas with auto here because the lambdas don't typically take anything of type scalar. They just take Tensors.\nIt's substantially less boiler plate because you can capture the relevant tensors by reference. With a struct functor you have to pass all argument through your lambda, as well as possibly the grid, dim, and stream.", "in_reply_to_id": 158558475}