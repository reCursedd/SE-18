{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/351081440", "html_url": "https://github.com/pytorch/pytorch/pull/4127#issuecomment-351081440", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/4127", "id": 351081440, "node_id": "MDEyOklzc3VlQ29tbWVudDM1MTA4MTQ0MA==", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "created_at": "2017-12-12T15:16:09Z", "updated_at": "2017-12-12T15:16:09Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=370202\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/zdevito\">@zdevito</a> The crux of the issue is that if a function is how we differentiate native functions: it's not implemented by source-to-source differentiating the native forward implementation; instead, we just rely on the constituent differentiable functions to make the composition differentiable. This was true even before this patch:</p>\n<pre><code>-        if not is_implemented(declaration) and declaration['mode'] == 'native':\t\t\n-            # native functionsthat aren't implemented don't need Type implementations\t\t\n-            # because they should dispatch to implemented functions.\t\t\n-            return\n</code></pre>\n<p>If we want to make native a true internal implementation detail, we will have to differentiate native functions in a very different way, since we will need to synthesize backward implementations of them for the codepath. This does seem to be consistent with where you want us to be headed (adding a source-to-source differentiator to PyTorch), but that will be another voyage and I am already at yak stack = 2 for epic voyages ;)</p>", "body_text": "@zdevito The crux of the issue is that if a function is how we differentiate native functions: it's not implemented by source-to-source differentiating the native forward implementation; instead, we just rely on the constituent differentiable functions to make the composition differentiable. This was true even before this patch:\n-        if not is_implemented(declaration) and declaration['mode'] == 'native':\t\t\n-            # native functionsthat aren't implemented don't need Type implementations\t\t\n-            # because they should dispatch to implemented functions.\t\t\n-            return\n\nIf we want to make native a true internal implementation detail, we will have to differentiate native functions in a very different way, since we will need to synthesize backward implementations of them for the codepath. This does seem to be consistent with where you want us to be headed (adding a source-to-source differentiator to PyTorch), but that will be another voyage and I am already at yak stack = 2 for epic voyages ;)", "body": "@zdevito The crux of the issue is that if a function is how we differentiate native functions: it's not implemented by source-to-source differentiating the native forward implementation; instead, we just rely on the constituent differentiable functions to make the composition differentiable. This was true even before this patch:\r\n\r\n```\r\n-        if not is_implemented(declaration) and declaration['mode'] == 'native':\t\t\r\n-            # native functionsthat aren't implemented don't need Type implementations\t\t\r\n-            # because they should dispatch to implemented functions.\t\t\r\n-            return\r\n```\r\n\r\nIf we want to make native a true internal implementation detail, we will have to differentiate native functions in a very different way, since we will need to synthesize backward implementations of them for the codepath. This does seem to be consistent with where you want us to be headed (adding a source-to-source differentiator to PyTorch), but that will be another voyage and I am already at yak stack = 2 for epic voyages ;)"}