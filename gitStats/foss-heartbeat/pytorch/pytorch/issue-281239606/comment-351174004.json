{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/351174004", "html_url": "https://github.com/pytorch/pytorch/pull/4127#issuecomment-351174004", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/4127", "id": 351174004, "node_id": "MDEyOklzc3VlQ29tbWVudDM1MTE3NDAwNA==", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "created_at": "2017-12-12T19:51:55Z", "updated_at": "2017-12-12T19:51:55Z", "author_association": "CONTRIBUTOR", "body_html": "<blockquote>\n<p>I don't think native vs. not-native is the right way to distinguish how to take a derivative in the first place. You can have a native function in ATen that needs a derivative to be defined, we probably just haven't written one yet. I think it is up to derivatives.yaml to say which functions are just compositions and should be fallthroughs.</p>\n</blockquote>\n<p>OK, this sounds good to me. And then we can remove 'native' from the conditional test here. Anywhere I said <code>emit_native_body</code>, really it's <code>emit_composition_body</code> (or some better name).</p>\n<blockquote>\n<p>The code to insert the RecordFunction should go through one codepath, otherwise we are going to start introducing partial fixes.</p>\n</blockquote>\n<p>OK, so you just want to push more of the logic into <code>emit_record_trace</code>? In my code comment above I suggested one possible way to reduce the amount of logic around <code>emit_record_trace</code>. But at the end of the day you are going to have to do <em>some</em> impedance matching, because the \"composition\" and \"derivative implemented directly\" codepaths are different.</p>\n<blockquote>\n<p>In fact, some native functions would greatly benefit from custom derivatives - right now when differentiating split, we treat it as a bunch of narrows, so for each of them we have to allocate a full sized tensor, fill it with zeros, copy the grad into a slice, and then add all of these huge arrays together.</p>\n</blockquote>\n<p>Yes but the code handles this correctly, because the <code>not_implemented</code> conditional evaluates to <code>False</code> when you add a <code>derivatives.yaml</code> entry. So really what we should do is add more entries to <code>derivatives.yaml</code>.</p>", "body_text": "I don't think native vs. not-native is the right way to distinguish how to take a derivative in the first place. You can have a native function in ATen that needs a derivative to be defined, we probably just haven't written one yet. I think it is up to derivatives.yaml to say which functions are just compositions and should be fallthroughs.\n\nOK, this sounds good to me. And then we can remove 'native' from the conditional test here. Anywhere I said emit_native_body, really it's emit_composition_body (or some better name).\n\nThe code to insert the RecordFunction should go through one codepath, otherwise we are going to start introducing partial fixes.\n\nOK, so you just want to push more of the logic into emit_record_trace? In my code comment above I suggested one possible way to reduce the amount of logic around emit_record_trace. But at the end of the day you are going to have to do some impedance matching, because the \"composition\" and \"derivative implemented directly\" codepaths are different.\n\nIn fact, some native functions would greatly benefit from custom derivatives - right now when differentiating split, we treat it as a bunch of narrows, so for each of them we have to allocate a full sized tensor, fill it with zeros, copy the grad into a slice, and then add all of these huge arrays together.\n\nYes but the code handles this correctly, because the not_implemented conditional evaluates to False when you add a derivatives.yaml entry. So really what we should do is add more entries to derivatives.yaml.", "body": "> I don't think native vs. not-native is the right way to distinguish how to take a derivative in the first place. You can have a native function in ATen that needs a derivative to be defined, we probably just haven't written one yet. I think it is up to derivatives.yaml to say which functions are just compositions and should be fallthroughs. \r\n\r\nOK, this sounds good to me. And then we can remove 'native' from the conditional test here. Anywhere I said `emit_native_body`, really it's `emit_composition_body` (or some better name).\r\n\r\n>  The code to insert the RecordFunction should go through one codepath, otherwise we are going to start introducing partial fixes.\r\n\r\nOK, so you just want to push more of the logic into `emit_record_trace`? In my code comment above I suggested one possible way to reduce the amount of logic around `emit_record_trace`. But at the end of the day you are going to have to do *some* impedance matching, because the \"composition\" and \"derivative implemented directly\" codepaths are different.\r\n\r\n> In fact, some native functions would greatly benefit from custom derivatives - right now when differentiating split, we treat it as a bunch of narrows, so for each of them we have to allocate a full sized tensor, fill it with zeros, copy the grad into a slice, and then add all of these huge arrays together.\r\n\r\nYes but the code handles this correctly, because the `not_implemented` conditional evaluates to `False` when you add a `derivatives.yaml` entry. So really what we should do is add more entries to `derivatives.yaml`."}