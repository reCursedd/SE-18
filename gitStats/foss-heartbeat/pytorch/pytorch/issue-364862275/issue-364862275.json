{"url": "https://api.github.com/repos/pytorch/pytorch/issues/12167", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/12167/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/12167/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/12167/events", "html_url": "https://github.com/pytorch/pytorch/issues/12167", "id": 364862275, "node_id": "MDU6SXNzdWUzNjQ4NjIyNzU=", "number": 12167, "title": "Add `LNLSTMCell`: current API does not support combining `nn.LayerNorm` and LSTMCell", "user": {"login": "zuoxingdong", "id": 18168681, "node_id": "MDQ6VXNlcjE4MTY4Njgx", "avatar_url": "https://avatars0.githubusercontent.com/u/18168681?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zuoxingdong", "html_url": "https://github.com/zuoxingdong", "followers_url": "https://api.github.com/users/zuoxingdong/followers", "following_url": "https://api.github.com/users/zuoxingdong/following{/other_user}", "gists_url": "https://api.github.com/users/zuoxingdong/gists{/gist_id}", "starred_url": "https://api.github.com/users/zuoxingdong/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zuoxingdong/subscriptions", "organizations_url": "https://api.github.com/users/zuoxingdong/orgs", "repos_url": "https://api.github.com/users/zuoxingdong/repos", "events_url": "https://api.github.com/users/zuoxingdong/events{/privacy}", "received_events_url": "https://api.github.com/users/zuoxingdong/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2018-09-28T12:09:18Z", "updated_at": "2018-10-17T02:54:28Z", "closed_at": "2018-10-17T02:54:28Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a href=\"https://github.com/pytorch/pytorch/blob/04c0971679374148aa4105e2e998de6478eca1eb/torch/nn/modules/rnn.py#L723-L727\">Current implementation</a> of LSTMCell calls internal C function which makes it infeasible to write a layer normalization of LSTM cell by wrapping it with <code>nn.LayerNorm</code>.</p>\n<p>It would be great to add this feature.</p>\n<p>We could add trainable parameters inside <code>RNNCellBase</code> as follows</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">class</span> <span class=\"pl-en\">RNNCellBase</span>(<span class=\"pl-e\">nn</span>.<span class=\"pl-e\">Module</span>):\n    <span class=\"pl-k\">def</span> <span class=\"pl-c1\">__init__</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>, <span class=\"pl-smi\">input_size</span>, <span class=\"pl-smi\">hidden_size</span>, <span class=\"pl-smi\">bias</span>, <span class=\"pl-smi\">num_chunks</span>):\n        <span class=\"pl-c1\">super</span>(RNNCellBase, <span class=\"pl-c1\">self</span>).<span class=\"pl-c1\">__init__</span>()\n        <span class=\"pl-c1\">self</span>.input_size <span class=\"pl-k\">=</span> input_size\n        <span class=\"pl-c1\">self</span>.hidden_size <span class=\"pl-k\">=</span> hidden_size\n        <span class=\"pl-c1\">self</span>.bias <span class=\"pl-k\">=</span> bias\n        <span class=\"pl-c1\">self</span>.weight_ih <span class=\"pl-k\">=</span> Parameter(torch.Tensor(num_chunks <span class=\"pl-k\">*</span> hidden_size, input_size))\n        <span class=\"pl-c1\">self</span>.weight_hh <span class=\"pl-k\">=</span> Parameter(torch.Tensor(num_chunks <span class=\"pl-k\">*</span> hidden_size, hidden_size))\n        <span class=\"pl-c1\">self</span>.ln_ih <span class=\"pl-k\">=</span> nn.LayerNorm(num_chunks <span class=\"pl-k\">*</span> hidden_size)\n        <span class=\"pl-c1\">self</span>.ln_hh <span class=\"pl-k\">=</span> nn.LayerNorm(num_chunks <span class=\"pl-k\">*</span> hidden_size)\n        <span class=\"pl-c1\">self</span>.ln_c <span class=\"pl-k\">=</span> nn.LayerNorm(hidden_size)</pre></div>\n<p>However, the it is impossible to use it for the computation</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">return</span> <span class=\"pl-c1\">_VF</span>.lstm_cell(\n            <span class=\"pl-c1\">input</span>, hx,\n            <span class=\"pl-c1\">self</span>.weight_ih, <span class=\"pl-c1\">self</span>.weight_hh,\n            <span class=\"pl-c1\">self</span>.bias_ih, <span class=\"pl-c1\">self</span>.bias_hh,\n        )</pre></div>\n<p>as it calls C functions.</p>\n<p>And writing it purely in Python, the speed would be too slow.</p>", "body_text": "Current implementation of LSTMCell calls internal C function which makes it infeasible to write a layer normalization of LSTM cell by wrapping it with nn.LayerNorm.\nIt would be great to add this feature.\nWe could add trainable parameters inside RNNCellBase as follows\nclass RNNCellBase(nn.Module):\n    def __init__(self, input_size, hidden_size, bias, num_chunks):\n        super(RNNCellBase, self).__init__()\n        self.input_size = input_size\n        self.hidden_size = hidden_size\n        self.bias = bias\n        self.weight_ih = Parameter(torch.Tensor(num_chunks * hidden_size, input_size))\n        self.weight_hh = Parameter(torch.Tensor(num_chunks * hidden_size, hidden_size))\n        self.ln_ih = nn.LayerNorm(num_chunks * hidden_size)\n        self.ln_hh = nn.LayerNorm(num_chunks * hidden_size)\n        self.ln_c = nn.LayerNorm(hidden_size)\nHowever, the it is impossible to use it for the computation\nreturn _VF.lstm_cell(\n            input, hx,\n            self.weight_ih, self.weight_hh,\n            self.bias_ih, self.bias_hh,\n        )\nas it calls C functions.\nAnd writing it purely in Python, the speed would be too slow.", "body": "[Current implementation](https://github.com/pytorch/pytorch/blob/04c0971679374148aa4105e2e998de6478eca1eb/torch/nn/modules/rnn.py#L723-L727) of LSTMCell calls internal C function which makes it infeasible to write a layer normalization of LSTM cell by wrapping it with `nn.LayerNorm`. \r\n\r\nIt would be great to add this feature. \r\n\r\nWe could add trainable parameters inside `RNNCellBase` as follows\r\n```python\r\nclass RNNCellBase(nn.Module):\r\n    def __init__(self, input_size, hidden_size, bias, num_chunks):\r\n        super(RNNCellBase, self).__init__()\r\n        self.input_size = input_size\r\n        self.hidden_size = hidden_size\r\n        self.bias = bias\r\n        self.weight_ih = Parameter(torch.Tensor(num_chunks * hidden_size, input_size))\r\n        self.weight_hh = Parameter(torch.Tensor(num_chunks * hidden_size, hidden_size))\r\n        self.ln_ih = nn.LayerNorm(num_chunks * hidden_size)\r\n        self.ln_hh = nn.LayerNorm(num_chunks * hidden_size)\r\n        self.ln_c = nn.LayerNorm(hidden_size)\r\n```\r\nHowever, the it is impossible to use it for the computation \r\n```python\r\nreturn _VF.lstm_cell(\r\n            input, hx,\r\n            self.weight_ih, self.weight_hh,\r\n            self.bias_ih, self.bias_hh,\r\n        )\r\n```\r\nas it calls C functions. \r\n\r\nAnd writing it purely in Python, the speed would be too slow. "}