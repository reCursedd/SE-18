{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/197213563", "pull_request_review_id": 130913481, "id": 197213563, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NzIxMzU2Mw==", "diff_hunk": "@@ -230,30 +236,35 @@ static value_set findAllRequiresGradNodes(\n   return requires_grad_set;\n }\n \n-static Value* createZerosLike(Value *v) {\n-  JIT_EXPECTM(v->isTensor(), \"can't allocate zero gradient for a value without a type\");\n-  Graph *graph = v->owningGraph();\n-  auto type = v->type()->expect<TensorType>();\n-  at::DeviceGuard device_guard(type->device());\n-\n-  auto & at_type = type->device() == -1 ? at::CPU(type->scalarType()) : at::CUDA(type->scalarType());\n-  auto zeros = at::zeros({}, at_type).expand(type->sizes());\n-  Node *constant = graph->createConstant(zeros)\n-                        ->i_(attr::is_zero, 1);\n-  graph->insertNode(constant);\n-  return constant->output();\n-}\n \n-// any vjp input may be undefined, and we need to potentially replace it\n-// with a zero tensor of the right size if required.\n-// this function inserts a guard into the graph that does this replacement.\n-// ReplaceIfUndef(dv,c) replaces dv with c if dv is undef.\n-// During Graph specialization these guards will get removed when\n-// 'dv' is known to be undef, and the zeros will be propagated if possible.\n-static Value* createUndefGuard(Value * dv, Value * alternative) {\n-  Graph* graph = dv->owningGraph();\n-  Node * n = graph->create(prim::ReplaceIfUndef, {dv, alternative});\n-  return graph->insertNode(n)->output();\n+// If we have a function y = f(x) with jacobian J, the backwards of f is dx = J^t dy.\n+// Note that because the backwards always implements this matrix multiply,\n+// we know that it maps an input vector of zeros to an output vector of zero\n+// regardless of what operations it choses to do inside to actually implement\n+// the matrix multiply (most use some optimized form and never generate J^t).\n+// More generally, we know that all of the backward computations are linear and\n+// can use this property to do more aggressive optimizations later.\n+// It is ok to replace any backward function with known-zero inputs with something\n+// that produces known-zero outputs. This function encloses each know-linear\n+// backward function in a 'LinearBlock' sub-block so that we can perform optimizations\n+// using this information. In particular, specializeUndef will observe if\n+// all the inputs to the linear block are Undef, which the autograd uses to represent\n+// zeros, and then propagate the undefs to the outputs of the block.\n+static std::vector<Value*> linearGradientForNode(Node* node, ArrayRef<Value*> grad_values) {\n+  auto & graph = *node->owningGraph();\n+  auto linear = graph.insertNode(graph.create(prim::LinearBlock, {grad_values}, 0));\n+  // to make reading gradient graphs easier, remember the name of the forward op", "path": "torch/csrc/jit/autodiff.cpp", "position": null, "original_position": 91, "commit_id": "e2b3828276930eaf208705eb3d91047bc109eca1", "original_commit_id": "3a4b65f33f2eccef207875e60b0f7e22646bbdb7", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "body": "+1 for `backward_of` or `grad_of`, which takes up less space", "created_at": "2018-06-21T17:20:29Z", "updated_at": "2018-11-23T15:46:00Z", "html_url": "https://github.com/pytorch/pytorch/pull/8641#discussion_r197213563", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/8641", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/197213563"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/8641#discussion_r197213563"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/8641"}}, "body_html": "<p>+1 for <code>backward_of</code> or <code>grad_of</code>, which takes up less space</p>", "body_text": "+1 for backward_of or grad_of, which takes up less space", "in_reply_to_id": 196951417}