{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/206913489", "pull_request_review_id": 142418995, "id": 206913489, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwNjkxMzQ4OQ==", "diff_hunk": "@@ -223,6 +223,72 @@ target_include_directories(caffe2 SYSTEM PRIVATE \"${Caffe2_DEPENDENCY_INCLUDE}\")\n aten_set_target_props(caffe2)\n target_compile_options(caffe2 INTERFACE \"-std=c++11\")\n target_compile_options(caffe2 PRIVATE \"-DCAFFE2_BUILD_MAIN_LIB\")\n+if (MSVC AND NOT BUILD_SHARED_LIBS)\n+  # Note [Supporting both static and dynamic libraries on Window]\n+  # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+  # A Windows library may be distributed as either a static or dynamic\n+  # library.  The chosen distribution mechanism affects how you setup\n+  # the headers for the library: if you statically link a function,\n+  # all you need is an ordinary signature:\n+  #\n+  #     void f();\n+  #\n+  # But if you *dynamically* link it, then you must provide a __declspec\n+  # specifying that it should be imported from a DLL:\n+  #\n+  #     __declspec(dllimport) void f();\n+  #\n+  # Mixing the two situations will not work: if you specify dllimport\n+  # while statically linking, the linker will complain it cannot find\n+  # the __imp_f symbol (which serve as the DLL entrypoint); if you\n+  # fail to specify dllimport for a symbol that's coming from a DLL,\n+  # the linker will complain that it can't find f.  Joy!\n+  #\n+  # Most places on the Internet, you will find people have written\n+  # their headers under the assumption that the application will\n+  # only ever be dynamically linked, as they define a macro which\n+  # tags a function as __declspec(dllexport) if you are actually\n+  # building the library, and __declspec(dllimport) otherwise.  But\n+  # if you want these headers to also work if you are linking against\n+  # a static library, you need a way to avoid adding these __declspec's\n+  # at all.  And that \"mechanism\" needs to apply to any downstream\n+  # libraries/executables which are going to link against your library.\n+  #\n+  #   As an aside, why do we need to support both modes?\n+  #   For historical reasons, PyTorch ATen on Windows is built dynamically,\n+  #   while Caffe2 on Windows is built statically (mostly because if\n+  #   we build it dynamically, we are over the DLL exported symbol limit--and\n+  #   that is because Caffe2 hasn't comprehensively annotated all symbols\n+  #   which cross the DLL boundary with CAFFE_API).  So any code\n+  #   which is used by both PyTorch and Caffe2 needs to support both\n+  #   modes of linking.\n+  #\n+  # So, you have a macro (call it AT_CORE_STATIC_WINDOWS) which you need to have\n+  # set for any downstream library/executable that transitively includes your\n+  # headers.  How are you going to do this?  You have two options:\n+  #\n+  #   1. Write out a config.h header which stores whether or not\n+  #      you are linking statically or dynamically.\n+  #\n+  #   2. Force all of users to set the the macro themselves.  If they\n+  #      use cmake, you can set -DAT_CORE_STATIC_WINDOWS=1 as a PUBLIC\n+  #      compile option, in which case cmake will automatically\n+  #      add the macro for you.\n+  #\n+  # Which one is better? Well, it depends: they trade off implementor\n+  # ease versus user ease: (1) is more work for the library author\n+  # but the user doesn't have to worry about it; (2) requires the user\n+  # to set the macro themselves... but only if they don't use cmake.\n+  #\n+  # So, which is appropriate in our situation?  One thing I do want", "path": "caffe2/CMakeLists.txt", "position": 61, "original_position": 61, "commit_id": "6f0c7c6c58aed5a9f002b7f86042008ee409da05", "original_commit_id": "6f0c7c6c58aed5a9f002b7f86042008ee409da05", "user": {"login": "gchanan", "id": 3768583, "node_id": "MDQ6VXNlcjM3Njg1ODM=", "avatar_url": "https://avatars2.githubusercontent.com/u/3768583?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gchanan", "html_url": "https://github.com/gchanan", "followers_url": "https://api.github.com/users/gchanan/followers", "following_url": "https://api.github.com/users/gchanan/following{/other_user}", "gists_url": "https://api.github.com/users/gchanan/gists{/gist_id}", "starred_url": "https://api.github.com/users/gchanan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gchanan/subscriptions", "organizations_url": "https://api.github.com/users/gchanan/orgs", "repos_url": "https://api.github.com/users/gchanan/repos", "events_url": "https://api.github.com/users/gchanan/events{/privacy}", "received_events_url": "https://api.github.com/users/gchanan/received_events", "type": "User", "site_admin": false}, "body": "nit: don't use 'One' when in an unrelated way when discussing options 1 and 2.", "created_at": "2018-08-01T14:56:53Z", "updated_at": "2018-11-23T15:48:32Z", "html_url": "https://github.com/pytorch/pytorch/pull/10092#discussion_r206913489", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/10092", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/206913489"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/10092#discussion_r206913489"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/10092"}}, "body_html": "<p>nit: don't use 'One' when in an unrelated way when discussing options 1 and 2.</p>", "body_text": "nit: don't use 'One' when in an unrelated way when discussing options 1 and 2."}