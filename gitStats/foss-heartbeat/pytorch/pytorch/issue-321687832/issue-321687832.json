{"url": "https://api.github.com/repos/pytorch/pytorch/issues/7434", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/7434/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/7434/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/7434/events", "html_url": "https://github.com/pytorch/pytorch/issues/7434", "id": 321687832, "node_id": "MDU6SXNzdWUzMjE2ODc4MzI=", "number": 7434, "title": "THD refactoring", "user": {"login": "pietern", "id": 9845, "node_id": "MDQ6VXNlcjk4NDU=", "avatar_url": "https://avatars3.githubusercontent.com/u/9845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietern", "html_url": "https://github.com/pietern", "followers_url": "https://api.github.com/users/pietern/followers", "following_url": "https://api.github.com/users/pietern/following{/other_user}", "gists_url": "https://api.github.com/users/pietern/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietern/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietern/subscriptions", "organizations_url": "https://api.github.com/users/pietern/orgs", "repos_url": "https://api.github.com/users/pietern/repos", "events_url": "https://api.github.com/users/pietern/events{/privacy}", "received_events_url": "https://api.github.com/users/pietern/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 679953883, "node_id": "MDU6TGFiZWw2Nzk5NTM4ODM=", "url": "https://api.github.com/repos/pytorch/pytorch/labels/distributed", "name": "distributed", "color": "c2e0c6", "default": false}], "state": "closed", "locked": false, "assignee": {"login": "pietern", "id": 9845, "node_id": "MDQ6VXNlcjk4NDU=", "avatar_url": "https://avatars3.githubusercontent.com/u/9845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietern", "html_url": "https://github.com/pietern", "followers_url": "https://api.github.com/users/pietern/followers", "following_url": "https://api.github.com/users/pietern/following{/other_user}", "gists_url": "https://api.github.com/users/pietern/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietern/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietern/subscriptions", "organizations_url": "https://api.github.com/users/pietern/orgs", "repos_url": "https://api.github.com/users/pietern/repos", "events_url": "https://api.github.com/users/pietern/events{/privacy}", "received_events_url": "https://api.github.com/users/pietern/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "pietern", "id": 9845, "node_id": "MDQ6VXNlcjk4NDU=", "avatar_url": "https://avatars3.githubusercontent.com/u/9845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietern", "html_url": "https://github.com/pietern", "followers_url": "https://api.github.com/users/pietern/followers", "following_url": "https://api.github.com/users/pietern/following{/other_user}", "gists_url": "https://api.github.com/users/pietern/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietern/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietern/subscriptions", "organizations_url": "https://api.github.com/users/pietern/orgs", "repos_url": "https://api.github.com/users/pietern/repos", "events_url": "https://api.github.com/users/pietern/events{/privacy}", "received_events_url": "https://api.github.com/users/pietern/received_events", "type": "User", "site_admin": false}, {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, {"login": "ailzhang", "id": 5248122, "node_id": "MDQ6VXNlcjUyNDgxMjI=", "avatar_url": "https://avatars2.githubusercontent.com/u/5248122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ailzhang", "html_url": "https://github.com/ailzhang", "followers_url": "https://api.github.com/users/ailzhang/followers", "following_url": "https://api.github.com/users/ailzhang/following{/other_user}", "gists_url": "https://api.github.com/users/ailzhang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ailzhang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ailzhang/subscriptions", "organizations_url": "https://api.github.com/users/ailzhang/orgs", "repos_url": "https://api.github.com/users/ailzhang/repos", "events_url": "https://api.github.com/users/ailzhang/events{/privacy}", "received_events_url": "https://api.github.com/users/ailzhang/received_events", "type": "User", "site_admin": false}, {"login": "teng-li", "id": 8120856, "node_id": "MDQ6VXNlcjgxMjA4NTY=", "avatar_url": "https://avatars2.githubusercontent.com/u/8120856?v=4", "gravatar_id": "", "url": "https://api.github.com/users/teng-li", "html_url": "https://github.com/teng-li", "followers_url": "https://api.github.com/users/teng-li/followers", "following_url": "https://api.github.com/users/teng-li/following{/other_user}", "gists_url": "https://api.github.com/users/teng-li/gists{/gist_id}", "starred_url": "https://api.github.com/users/teng-li/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/teng-li/subscriptions", "organizations_url": "https://api.github.com/users/teng-li/orgs", "repos_url": "https://api.github.com/users/teng-li/repos", "events_url": "https://api.github.com/users/teng-li/events{/privacy}", "received_events_url": "https://api.github.com/users/teng-li/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 2, "created_at": "2018-05-09T19:00:38Z", "updated_at": "2018-10-25T03:21:42Z", "closed_at": "2018-10-25T03:21:42Z", "author_association": "CONTRIBUTOR", "body_html": "<p>This is a master issue for tracking THD refactoring work that is going on.</p>\n<p>To prevent breaking current THD users this will happen in a parallel directory tree until we're at feature parity and can make a compatibility layer.</p>\n<p>Issues/features that this refactor will address:</p>\n<ul>\n<li>Currently, THD exposes a process group (data channel) as a global variable. To subdivide the group and have collectives apply to subgroups you have to include a group argument on the C++ side. Different groups may have different sets of connections/state/algorithm choices so this will be implemented with different process group instances. Allowing for multiple process group instances also means they'll have independent lifecycle, which will makes testing easier, allows for some form of failure recovery, etc.</li>\n<li>The TCP/env init methods require knowledge of a master address. If processes are dynamically scheduled this is not known up front. There is still a need for sharing state between processes though. To allow for dynamic scheduling without upfront knowledge of network address information, I propose using a set/get/wait key/value interface like the one used in Caffe2 and Gloo. This allows for exchange of socket information either by hosting a daemon thread on the master process, or by delegating to a separate key/value server that is running outside the process group. For dynamically scheduled processes to work they only need to know the address of the key/value server.</li>\n<li>The collectives are currently handled in place, requiring threading for parallelism to happen on the Python side. Instead, the collectives should execute asynchronously and return some kind of future object. For the common case where allreduce runs for all layers (or batches of layers) during a backwards pass, we can issue all collectives, and wait on all of them at the end of the pass. A thread pool associated with the process group can then be responsible for executing this work. To still allow chaining these async allreduce operations with weight updates for CUDA tensors, we can execute the work on a separate CUDA stream and wait on a completion event in the primary stream. All work queued after this (e.g. the weight updates) will execute upon completion of the async operation.</li>\n<li>Currently, Gloo collectives are cached by signature (collective type, input devices, input size, etc). This does not allow for multiple instances with the same signature. I propose we use a mechanism by which we can tune the number of algorithm instances such that we can increase the level of parallelism even for collectives with the same signature. This has lower priority than the other items though.</li>\n</ul>\n<p>cc <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=8120856\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/teng-li\">@teng-li</a> <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=5248122\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/ailzhang\">@ailzhang</a> <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=4583066\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/apaszke\">@apaszke</a></p>", "body_text": "This is a master issue for tracking THD refactoring work that is going on.\nTo prevent breaking current THD users this will happen in a parallel directory tree until we're at feature parity and can make a compatibility layer.\nIssues/features that this refactor will address:\n\nCurrently, THD exposes a process group (data channel) as a global variable. To subdivide the group and have collectives apply to subgroups you have to include a group argument on the C++ side. Different groups may have different sets of connections/state/algorithm choices so this will be implemented with different process group instances. Allowing for multiple process group instances also means they'll have independent lifecycle, which will makes testing easier, allows for some form of failure recovery, etc.\nThe TCP/env init methods require knowledge of a master address. If processes are dynamically scheduled this is not known up front. There is still a need for sharing state between processes though. To allow for dynamic scheduling without upfront knowledge of network address information, I propose using a set/get/wait key/value interface like the one used in Caffe2 and Gloo. This allows for exchange of socket information either by hosting a daemon thread on the master process, or by delegating to a separate key/value server that is running outside the process group. For dynamically scheduled processes to work they only need to know the address of the key/value server.\nThe collectives are currently handled in place, requiring threading for parallelism to happen on the Python side. Instead, the collectives should execute asynchronously and return some kind of future object. For the common case where allreduce runs for all layers (or batches of layers) during a backwards pass, we can issue all collectives, and wait on all of them at the end of the pass. A thread pool associated with the process group can then be responsible for executing this work. To still allow chaining these async allreduce operations with weight updates for CUDA tensors, we can execute the work on a separate CUDA stream and wait on a completion event in the primary stream. All work queued after this (e.g. the weight updates) will execute upon completion of the async operation.\nCurrently, Gloo collectives are cached by signature (collective type, input devices, input size, etc). This does not allow for multiple instances with the same signature. I propose we use a mechanism by which we can tune the number of algorithm instances such that we can increase the level of parallelism even for collectives with the same signature. This has lower priority than the other items though.\n\ncc @teng-li @ailzhang @apaszke", "body": "This is a master issue for tracking THD refactoring work that is going on.\r\n\r\nTo prevent breaking current THD users this will happen in a parallel directory tree until we're at feature parity and can make a compatibility layer.\r\n\r\nIssues/features that this refactor will address:\r\n* Currently, THD exposes a process group (data channel) as a global variable. To subdivide the group and have collectives apply to subgroups you have to include a group argument on the C++ side. Different groups may have different sets of connections/state/algorithm choices so this will be implemented with different process group instances. Allowing for multiple process group instances also means they'll have independent lifecycle, which will makes testing easier, allows for some form of failure recovery, etc. \r\n* The TCP/env init methods require knowledge of a master address. If processes are dynamically scheduled this is not known up front. There is still a need for sharing state between processes though. To allow for dynamic scheduling without upfront knowledge of network address information, I propose using a set/get/wait key/value interface like the one used in Caffe2 and Gloo. This allows for exchange of socket information either by hosting a daemon thread on the master process, or by delegating to a separate key/value server that is running outside the process group. For dynamically scheduled processes to work they only need to know the address of the key/value server.\r\n* The collectives are currently handled in place, requiring threading for parallelism to happen on the Python side. Instead, the collectives should execute asynchronously and return some kind of future object. For the common case where allreduce runs for all layers (or batches of layers) during a backwards pass, we can issue all collectives, and wait on all of them at the end of the pass. A thread pool associated with the process group can then be responsible for executing this work. To still allow chaining these async allreduce operations with weight updates for CUDA tensors, we can execute the work on a separate CUDA stream and wait on a completion event in the primary stream. All work queued after this (e.g. the weight updates) will execute upon completion of the async operation.\r\n* Currently, Gloo collectives are cached by signature (collective type, input devices, input size, etc). This does not allow for multiple instances with the same signature. I propose we use a mechanism by which we can tune the number of algorithm instances such that we can increase the level of parallelism even for collectives with the same signature. This has lower priority than the other items though.\r\n\r\ncc @teng-li @ailzhang @apaszke "}