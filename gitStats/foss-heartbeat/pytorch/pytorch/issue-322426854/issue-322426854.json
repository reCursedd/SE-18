{"url": "https://api.github.com/repos/pytorch/pytorch/issues/7507", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/7507/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/7507/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/7507/events", "html_url": "https://github.com/pytorch/pytorch/issues/7507", "id": 322426854, "node_id": "MDU6SXNzdWUzMjI0MjY4NTQ=", "number": 7507, "title": "[jit] refactor and document the ways the graph executor will optimize/run programs", "user": {"login": "zdevito", "id": 370202, "node_id": "MDQ6VXNlcjM3MDIwMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/370202?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zdevito", "html_url": "https://github.com/zdevito", "followers_url": "https://api.github.com/users/zdevito/followers", "following_url": "https://api.github.com/users/zdevito/following{/other_user}", "gists_url": "https://api.github.com/users/zdevito/gists{/gist_id}", "starred_url": "https://api.github.com/users/zdevito/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zdevito/subscriptions", "organizations_url": "https://api.github.com/users/zdevito/orgs", "repos_url": "https://api.github.com/users/zdevito/repos", "events_url": "https://api.github.com/users/zdevito/events{/privacy}", "received_events_url": "https://api.github.com/users/zdevito/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 679953983, "node_id": "MDU6TGFiZWw2Nzk5NTM5ODM=", "url": "https://api.github.com/repos/pytorch/pytorch/labels/jit", "name": "jit", "color": "c5def5", "default": false}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2018-05-11T20:37:40Z", "updated_at": "2018-05-11T20:37:40Z", "closed_at": null, "author_association": "CONTRIBUTOR", "body_html": "<p>Graph executor logic has gotten complicated due to many properties:</p>\n<ul>\n<li>Can we symbolically differentiate this graph?</li>\n<li>Can we compute static sizes for the graph (effects the above but is not checked)?</li>\n<li>Can the graph ever require us to compute a gradient? (Including graphs that have blackbox python ops and no grad-aware inputs)?</li>\n</ul>\n<p>Each of these properties make certain approaches to execution invalid. We need to define more clearly what properties must hold along each pathway int the graph executor and when possible add dynamic checks to the slow paths that these properties are not violated.</p>\n<p>We also need to consider what JIT should do in the presence of control flow. Right now we optimize per-size, per-block, but for loops with truly dynamic sizes in the body this may produce an infinite number of options.</p>", "body_text": "Graph executor logic has gotten complicated due to many properties:\n\nCan we symbolically differentiate this graph?\nCan we compute static sizes for the graph (effects the above but is not checked)?\nCan the graph ever require us to compute a gradient? (Including graphs that have blackbox python ops and no grad-aware inputs)?\n\nEach of these properties make certain approaches to execution invalid. We need to define more clearly what properties must hold along each pathway int the graph executor and when possible add dynamic checks to the slow paths that these properties are not violated.\nWe also need to consider what JIT should do in the presence of control flow. Right now we optimize per-size, per-block, but for loops with truly dynamic sizes in the body this may produce an infinite number of options.", "body": "Graph executor logic has gotten complicated due to many properties:\r\n\r\n* Can we symbolically differentiate this graph?\r\n* Can we compute static sizes for the graph (effects the above but is not checked)?\r\n* Can the graph ever require us to compute a gradient? (Including graphs that have blackbox python ops and no grad-aware inputs)?\r\n\r\nEach of these properties make certain approaches to execution invalid. We need to define more clearly what properties must hold along each pathway int the graph executor and when possible add dynamic checks to the slow paths that these properties are not violated. \r\n\r\nWe also need to consider what JIT should do in the presence of control flow. Right now we optimize per-size, per-block, but for loops with truly dynamic sizes in the body this may produce an infinite number of options. "}