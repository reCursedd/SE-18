{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/155939239", "pull_request_review_id": 82342324, "id": 155939239, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1NTkzOTIzOQ==", "diff_hunk": "@@ -355,6 +355,50 @@ def lookup_pred(pred, xs):\n         \"\"\"Return the index of the first element of xs matching pred.\"\"\"\n         return next((i, x) for i, x in enumerate(xs) if pred(x))\n \n+    def is_nn_fwd(defn_name, declarations_by_name):", "path": "tools/autograd/gen_variable_type.py", "position": null, "original_position": 13, "commit_id": "f806cacd7c92d2f8205a73bfdaad3ddfa93d79f4", "original_commit_id": "a017bdd9b28f6d350f16eab7c4f7a860c10b337c", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "body": "They are explicitly declared: when I look in Declarations.yaml I see avg_pool2d_forward and get function stubs in Function.h.\r\n\r\nThe root cause of this problem is the ugly buffers design. In some cases THNN could be refactored to eliminate them (since we have a caching allocator now) but this doesn't apply universally. Perhaps we can annotate the buffers in the argument list in `derivatives.yaml` (so it doesn't look like the variables in backwards pop out of no where), but with some sort of syntax like `foo=BUFFER` making it clear that we will generate an API that doesn't take this buffer. A more parsimonious mechanism to deal with buffers would be to return the buffers as legit output tuples, but then you need another mechanism to not *actually* return the buffers from user facing code. Today's design of arguments seems easier.", "created_at": "2017-12-10T06:10:53Z", "updated_at": "2018-11-23T15:37:14Z", "html_url": "https://github.com/pytorch/pytorch/pull/4096#discussion_r155939239", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/4096", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/155939239"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/4096#discussion_r155939239"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/4096"}}, "body_html": "<p>They are explicitly declared: when I look in Declarations.yaml I see avg_pool2d_forward and get function stubs in Function.h.</p>\n<p>The root cause of this problem is the ugly buffers design. In some cases THNN could be refactored to eliminate them (since we have a caching allocator now) but this doesn't apply universally. Perhaps we can annotate the buffers in the argument list in <code>derivatives.yaml</code> (so it doesn't look like the variables in backwards pop out of no where), but with some sort of syntax like <code>foo=BUFFER</code> making it clear that we will generate an API that doesn't take this buffer. A more parsimonious mechanism to deal with buffers would be to return the buffers as legit output tuples, but then you need another mechanism to not <em>actually</em> return the buffers from user facing code. Today's design of arguments seems easier.</p>", "body_text": "They are explicitly declared: when I look in Declarations.yaml I see avg_pool2d_forward and get function stubs in Function.h.\nThe root cause of this problem is the ugly buffers design. In some cases THNN could be refactored to eliminate them (since we have a caching allocator now) but this doesn't apply universally. Perhaps we can annotate the buffers in the argument list in derivatives.yaml (so it doesn't look like the variables in backwards pop out of no where), but with some sort of syntax like foo=BUFFER making it clear that we will generate an API that doesn't take this buffer. A more parsimonious mechanism to deal with buffers would be to return the buffers as legit output tuples, but then you need another mechanism to not actually return the buffers from user facing code. Today's design of arguments seems easier.", "in_reply_to_id": 155932189}