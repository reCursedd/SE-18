{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/357134597", "html_url": "https://github.com/pytorch/pytorch/pull/4453#issuecomment-357134597", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/4453", "id": 357134597, "node_id": "MDEyOklzc3VlQ29tbWVudDM1NzEzNDU5Nw==", "user": {"login": "peterjc123", "id": 9998726, "node_id": "MDQ6VXNlcjk5OTg3MjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/9998726?v=4", "gravatar_id": "", "url": "https://api.github.com/users/peterjc123", "html_url": "https://github.com/peterjc123", "followers_url": "https://api.github.com/users/peterjc123/followers", "following_url": "https://api.github.com/users/peterjc123/following{/other_user}", "gists_url": "https://api.github.com/users/peterjc123/gists{/gist_id}", "starred_url": "https://api.github.com/users/peterjc123/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/peterjc123/subscriptions", "organizations_url": "https://api.github.com/users/peterjc123/orgs", "repos_url": "https://api.github.com/users/peterjc123/repos", "events_url": "https://api.github.com/users/peterjc123/events{/privacy}", "received_events_url": "https://api.github.com/users/peterjc123/received_events", "type": "User", "site_admin": false}, "created_at": "2018-01-12T03:37:01Z", "updated_at": "2018-01-12T03:40:05Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=5674597\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/SsnL\">@SsnL</a> Sorry, I messup that up with <code>test_cuda_bad_call</code>. As for <code>test_segfault</code>,the process should be <code>test_segfault</code> starting a new process to process function <code>_test_segfault</code>, the new process called the DataLoader and the processed was finally closed because there's an exception in the DataLoader. I guess you're asking about the timeout of the data_queue.get() right?<br>\nHere is full traceback:</p>\n<div class=\"highlight highlight-text-python-traceback\"><pre>Process Process-1:\nTraceback (most recent call last):\n  File <span class=\"pl-s\">\"C:\\Anaconda2\\envs\\test_new\\lib\\multiprocessing\\process.py\"</span>, line <span class=\"pl-c1\">258</span>, in <span class=\"pl-en\">_bootstrap</span>\n    <span class=\"pl-c1\">self</span>.run()\n  File <span class=\"pl-s\">\"C:\\Anaconda2\\envs\\test_new\\lib\\multiprocessing\\process.py\"</span>, line <span class=\"pl-c1\">93</span>, in <span class=\"pl-en\">run</span>\n    <span class=\"pl-c1\">self</span>._target(<span class=\"pl-k\">*</span><span class=\"pl-c1\">self</span>._args, <span class=\"pl-k\">**</span><span class=\"pl-c1\">self</span>._kwargs)\n  File <span class=\"pl-s\">\"D:\\pytorch\\mp_dl_test.py\"</span>, line <span class=\"pl-c1\">107</span>, in <span class=\"pl-en\">_test_segfault</span>\n    _ <span class=\"pl-k\">=</span> <span class=\"pl-c1\">next</span>(<span class=\"pl-c1\">iter</span>(dataloader))\n  File <span class=\"pl-s\">\"C:\\Anaconda2\\envs\\test_new\\lib\\site-packages\\torch\\utils\\data\\dataloader.py\"</span>, line <span class=\"pl-c1\">273</span>, in <span class=\"pl-en\">__next__</span>\n    <span class=\"pl-k\">return</span> <span class=\"pl-c1\">self</span>._process_next_batch(batch)\n  File <span class=\"pl-s\">\"C:\\Anaconda2\\envs\\test_new\\lib\\site-packages\\torch\\utils\\data\\dataloader.py\"</span>, line <span class=\"pl-c1\">293</span>, in <span class=\"pl-en\">_process_next_batch</span>\n    <span class=\"pl-k\">raise</span> batch.exc_type(batch.exc_msg)\n<span class=\"pl-en\">OSError</span>: <span class=\"pl-s\">Traceback (most recent call last):</span>\n  File <span class=\"pl-s\">\"C:\\Anaconda2\\envs\\test_new\\lib\\site-packages\\torch\\utils\\data\\dataloader.py\"</span>, line <span class=\"pl-c1\">56</span>, in <span class=\"pl-en\">_worker_loop</span>\n    samples <span class=\"pl-k\">=</span> collate_fn([dataset[i] <span class=\"pl-k\">for</span> i <span class=\"pl-k\">in</span> batch_indices])\n  File <span class=\"pl-s\">\"C:\\Anaconda2\\envs\\test_new\\lib\\site-packages\\torch\\utils\\data\\dataloader.py\"</span>, line <span class=\"pl-c1\">56</span>, in <span class=\"pl-en\">&lt;listcomp&gt;</span>\n    samples <span class=\"pl-k\">=</span> collate_fn([dataset[i] <span class=\"pl-k\">for</span> i <span class=\"pl-k\">in</span> batch_indices])\n  File <span class=\"pl-s\">\"D:\\pytorch\\mp_dl_test.py\"</span>, line <span class=\"pl-c1\">48</span>, in <span class=\"pl-en\">__getitem__</span>\n    <span class=\"pl-k\">return</span> ctypes.string_at(<span class=\"pl-c1\">0</span>)\n  File <span class=\"pl-s\">\"C:\\Anaconda2\\envs\\test_new\\lib\\ctypes\\__init__.py\"</span>, line <span class=\"pl-c1\">492</span>, in <span class=\"pl-en\">string_at</span>\n    <span class=\"pl-k\">return</span> _string_at(ptr, size)\n<span class=\"pl-en\">OSError</span>: <span class=\"pl-s\">exception: access violation reading 0x0000000000000000</span></pre></div>\n<p>The <code>data_queue</code> in the child process is wrapped in the try..catch block, as commented below:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">def</span> <span class=\"pl-en\">_worker_loop</span>(<span class=\"pl-smi\">dataset</span>, <span class=\"pl-smi\">index_queue</span>, <span class=\"pl-smi\">data_queue</span>, <span class=\"pl-smi\">collate_fn</span>, <span class=\"pl-smi\">seed</span>, <span class=\"pl-smi\">init_fn</span>, <span class=\"pl-smi\">worker_id</span>):\n    <span class=\"pl-k\">global</span> _use_shared_memory\n    _use_shared_memory <span class=\"pl-k\">=</span> <span class=\"pl-c1\">True</span>\n\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> Intialize C side signal handlers for SIGBUS and SIGSEGV. Python signal</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> module's handlers are executed after Python returns from C low-level</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> handlers, likely when the same fatal signal happened again already.</span>\n    <span class=\"pl-c\"><span class=\"pl-c\">#</span> https://docs.python.org/3/library/signal.html Sec. 18.8.1.1</span>\n    _set_worker_signal_handlers()\n\n    torch.set_num_threads(<span class=\"pl-c1\">1</span>)\n    torch.manual_seed(seed)\n\n    <span class=\"pl-k\">if</span> init_fn <span class=\"pl-k\">is</span> <span class=\"pl-k\">not</span> <span class=\"pl-c1\">None</span>:\n        init_fn(worker_id)\n\n    <span class=\"pl-k\">while</span> <span class=\"pl-c1\">True</span>:\n        r <span class=\"pl-k\">=</span> index_queue.get()\n        <span class=\"pl-k\">if</span> r <span class=\"pl-k\">is</span> <span class=\"pl-c1\">None</span>:\n            <span class=\"pl-k\">break</span>\n        idx, batch_indices <span class=\"pl-k\">=</span> r\n        <span class=\"pl-k\">try</span>:\n            samples <span class=\"pl-k\">=</span> collate_fn([dataset[i] <span class=\"pl-k\">for</span> i <span class=\"pl-k\">in</span> batch_indices])   <span class=\"pl-k\">&lt;</span><span class=\"pl-k\">-</span> throw exception\n        <span class=\"pl-k\">except</span> <span class=\"pl-c1\">Exception</span>:\n            data_queue.put((idx, ExceptionWrapper(sys.exc_info()))) <span class=\"pl-k\">&lt;</span><span class=\"pl-k\">-</span> exception returns here\n        <span class=\"pl-k\">else</span>:\n            data_queue.put((idx, samples))</pre></div>\n<p>After the exception was thrown, the <code>data_queue.get()</code> receives this and after that, the function <code>process_next_batch</code> checks this and stops the new process. So it should be passing without problem.</p>", "body_text": "@SsnL Sorry, I messup that up with test_cuda_bad_call. As for test_segfault,the process should be test_segfault starting a new process to process function _test_segfault, the new process called the DataLoader and the processed was finally closed because there's an exception in the DataLoader. I guess you're asking about the timeout of the data_queue.get() right?\nHere is full traceback:\nProcess Process-1:\nTraceback (most recent call last):\n  File \"C:\\Anaconda2\\envs\\test_new\\lib\\multiprocessing\\process.py\", line 258, in _bootstrap\n    self.run()\n  File \"C:\\Anaconda2\\envs\\test_new\\lib\\multiprocessing\\process.py\", line 93, in run\n    self._target(*self._args, **self._kwargs)\n  File \"D:\\pytorch\\mp_dl_test.py\", line 107, in _test_segfault\n    _ = next(iter(dataloader))\n  File \"C:\\Anaconda2\\envs\\test_new\\lib\\site-packages\\torch\\utils\\data\\dataloader.py\", line 273, in __next__\n    return self._process_next_batch(batch)\n  File \"C:\\Anaconda2\\envs\\test_new\\lib\\site-packages\\torch\\utils\\data\\dataloader.py\", line 293, in _process_next_batch\n    raise batch.exc_type(batch.exc_msg)\nOSError: Traceback (most recent call last):\n  File \"C:\\Anaconda2\\envs\\test_new\\lib\\site-packages\\torch\\utils\\data\\dataloader.py\", line 56, in _worker_loop\n    samples = collate_fn([dataset[i] for i in batch_indices])\n  File \"C:\\Anaconda2\\envs\\test_new\\lib\\site-packages\\torch\\utils\\data\\dataloader.py\", line 56, in <listcomp>\n    samples = collate_fn([dataset[i] for i in batch_indices])\n  File \"D:\\pytorch\\mp_dl_test.py\", line 48, in __getitem__\n    return ctypes.string_at(0)\n  File \"C:\\Anaconda2\\envs\\test_new\\lib\\ctypes\\__init__.py\", line 492, in string_at\n    return _string_at(ptr, size)\nOSError: exception: access violation reading 0x0000000000000000\nThe data_queue in the child process is wrapped in the try..catch block, as commented below:\ndef _worker_loop(dataset, index_queue, data_queue, collate_fn, seed, init_fn, worker_id):\n    global _use_shared_memory\n    _use_shared_memory = True\n\n    # Intialize C side signal handlers for SIGBUS and SIGSEGV. Python signal\n    # module's handlers are executed after Python returns from C low-level\n    # handlers, likely when the same fatal signal happened again already.\n    # https://docs.python.org/3/library/signal.html Sec. 18.8.1.1\n    _set_worker_signal_handlers()\n\n    torch.set_num_threads(1)\n    torch.manual_seed(seed)\n\n    if init_fn is not None:\n        init_fn(worker_id)\n\n    while True:\n        r = index_queue.get()\n        if r is None:\n            break\n        idx, batch_indices = r\n        try:\n            samples = collate_fn([dataset[i] for i in batch_indices])   <- throw exception\n        except Exception:\n            data_queue.put((idx, ExceptionWrapper(sys.exc_info()))) <- exception returns here\n        else:\n            data_queue.put((idx, samples))\nAfter the exception was thrown, the data_queue.get() receives this and after that, the function process_next_batch checks this and stops the new process. So it should be passing without problem.", "body": "@SsnL Sorry, I messup that up with `test_cuda_bad_call`. As for `test_segfault`,the process should be `test_segfault` starting a new process to process function `_test_segfault`, the new process called the DataLoader and the processed was finally closed because there's an exception in the DataLoader. I guess you're asking about the timeout of the data_queue.get() right? \r\nHere is full traceback:\r\n```pytb\r\nProcess Process-1:\r\nTraceback (most recent call last):\r\n  File \"C:\\Anaconda2\\envs\\test_new\\lib\\multiprocessing\\process.py\", line 258, in _bootstrap\r\n    self.run()\r\n  File \"C:\\Anaconda2\\envs\\test_new\\lib\\multiprocessing\\process.py\", line 93, in run\r\n    self._target(*self._args, **self._kwargs)\r\n  File \"D:\\pytorch\\mp_dl_test.py\", line 107, in _test_segfault\r\n    _ = next(iter(dataloader))\r\n  File \"C:\\Anaconda2\\envs\\test_new\\lib\\site-packages\\torch\\utils\\data\\dataloader.py\", line 273, in __next__\r\n    return self._process_next_batch(batch)\r\n  File \"C:\\Anaconda2\\envs\\test_new\\lib\\site-packages\\torch\\utils\\data\\dataloader.py\", line 293, in _process_next_batch\r\n    raise batch.exc_type(batch.exc_msg)\r\nOSError: Traceback (most recent call last):\r\n  File \"C:\\Anaconda2\\envs\\test_new\\lib\\site-packages\\torch\\utils\\data\\dataloader.py\", line 56, in _worker_loop\r\n    samples = collate_fn([dataset[i] for i in batch_indices])\r\n  File \"C:\\Anaconda2\\envs\\test_new\\lib\\site-packages\\torch\\utils\\data\\dataloader.py\", line 56, in <listcomp>\r\n    samples = collate_fn([dataset[i] for i in batch_indices])\r\n  File \"D:\\pytorch\\mp_dl_test.py\", line 48, in __getitem__\r\n    return ctypes.string_at(0)\r\n  File \"C:\\Anaconda2\\envs\\test_new\\lib\\ctypes\\__init__.py\", line 492, in string_at\r\n    return _string_at(ptr, size)\r\nOSError: exception: access violation reading 0x0000000000000000\r\n```\r\nThe `data_queue` in the child process is wrapped in the try..catch block, as commented below:\r\n```Python\r\ndef _worker_loop(dataset, index_queue, data_queue, collate_fn, seed, init_fn, worker_id):\r\n    global _use_shared_memory\r\n    _use_shared_memory = True\r\n\r\n    # Intialize C side signal handlers for SIGBUS and SIGSEGV. Python signal\r\n    # module's handlers are executed after Python returns from C low-level\r\n    # handlers, likely when the same fatal signal happened again already.\r\n    # https://docs.python.org/3/library/signal.html Sec. 18.8.1.1\r\n    _set_worker_signal_handlers()\r\n\r\n    torch.set_num_threads(1)\r\n    torch.manual_seed(seed)\r\n\r\n    if init_fn is not None:\r\n        init_fn(worker_id)\r\n\r\n    while True:\r\n        r = index_queue.get()\r\n        if r is None:\r\n            break\r\n        idx, batch_indices = r\r\n        try:\r\n            samples = collate_fn([dataset[i] for i in batch_indices])   <- throw exception\r\n        except Exception:\r\n            data_queue.put((idx, ExceptionWrapper(sys.exc_info()))) <- exception returns here\r\n        else:\r\n            data_queue.put((idx, samples))\r\n```\r\nAfter the exception was thrown, the `data_queue.get()` receives this and after that, the function `process_next_batch` checks this and stops the new process. So it should be passing without problem."}