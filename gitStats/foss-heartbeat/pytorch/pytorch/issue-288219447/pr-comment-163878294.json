{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/163878294", "pull_request_review_id": 91563568, "id": 163878294, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2Mzg3ODI5NA==", "diff_hunk": "@@ -0,0 +1,71 @@\n+import sys\n+import traceback\n+\n+if sys.version_info[0] == 2:\n+    import Queue as queue\n+else:\n+    import queue\n+\n+\n+class ExceptionWrapper(object):\n+    r\"Wraps an exception plus traceback to communicate across threads\"\n+\n+    def __init__(self, exc_info):\n+        self.exc_type = exc_info[0]\n+        self.exc_msg = \"\".join(traceback.format_exception(*exc_info))\n+\n+\n+# Queue get and put methods may fail if the underlying syscalls are interrupted\n+# (EINTR). So we need to wrap them to retry automatically if needed.\n+#\n+# Syscalls are automatically retried upon encountering EINTR since Python 3.5\n+# https://www.python.org/dev/peps/pep-0475/\n+# EINTR is not available on Windows.\n+if sys.platform == 'win32' or sys.version_info >= (3, 5):\n+    def QueueWrapper(queue):\n+        return queue\n+else:\n+    import time\n+    import errno\n+\n+    if sys.version_info >= (3, 3):\n+        time_fn = time.perf_counter\n+    else:\n+        time_fn = time.time\n+\n+    class QueueWrapper(object):\n+        r\"\"\"Wraps a queue object that conforms to following interface:\n+\n+            .get()  or  .get(timeout=timeout)\n+            .put(value)\n+        \"\"\"\n+\n+        def __init__(self, queue):\n+            self.queue = queue\n+\n+        def get(self, timeout=None):\n+            while True:\n+                try:\n+                    if timeout is None:\n+                        return self.queue.get()\n+                    else:\n+                        t0 = time_fn()\n+                        return self.queue.get(timeout=timeout)\n+                except IOError as e:\n+                    if e.errno != errno.EINTR:\n+                        raise\n+                    if timeout is not None:\n+                        timeout -= time_fn() - t0\n+                        if timeout <= 0:\n+                            raise queue.Empty\n+\n+        def put(self, val):\n+            while True:\n+                try:\n+                    return self.queue.put(val)", "path": "torch/utils/data/utils.py", "position": null, "original_position": 65, "commit_id": "d4882230052d14432fd34e0aa2f5fc0f73977352", "original_commit_id": "d3c3a952d30abc86b300a3deb507d1184c4d892a", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "body": "Aren't queues implemented around pipes? If so they are using `read` and `write`. What I'm concerned about is that if I were writing such a queue I would do it like this:\r\n```cpp\r\nstd::size_t remaining_bytes = ...;\r\nwhile (remaining_bytes > 0) {\r\n  ssize_t read_bytes = read(fd, &buffer, remaining_bytes);\r\n  if (read_bytes == -1) throw some_error();\r\n  remaining_bytes -= read_bytes;\r\n  buffer += read_bytes;\r\n}\r\n```\r\nThis is because `read` is not guaranteed to return you exactly `remaining_bytes`, but *at most* `remaining_bytes` so you might need to loop. Now, if Python implements read in this way, but breaks out of the loop if it sees EINTR, then by the time we call `get()` again, some of the data could have still been left in the pipe, and it will be corrupted.", "created_at": "2018-01-25T15:37:24Z", "updated_at": "2018-11-23T15:38:34Z", "html_url": "https://github.com/pytorch/pytorch/pull/4643#discussion_r163878294", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/4643", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/163878294"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/4643#discussion_r163878294"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/4643"}}, "body_html": "<p>Aren't queues implemented around pipes? If so they are using <code>read</code> and <code>write</code>. What I'm concerned about is that if I were writing such a queue I would do it like this:</p>\n<div class=\"highlight highlight-source-c++\"><pre>std::<span class=\"pl-c1\">size_t</span> remaining_bytes = ...;\n<span class=\"pl-k\">while</span> (remaining_bytes &gt; <span class=\"pl-c1\">0</span>) {\n  <span class=\"pl-c1\">ssize_t</span> read_bytes = <span class=\"pl-c1\">read</span>(fd, &amp;buffer, remaining_bytes);\n  <span class=\"pl-k\">if</span> (read_bytes == -<span class=\"pl-c1\">1</span>) <span class=\"pl-k\">throw</span> <span class=\"pl-smi\">some_error</span>();\n  remaining_bytes -= read_bytes;\n  buffer += read_bytes;\n}</pre></div>\n<p>This is because <code>read</code> is not guaranteed to return you exactly <code>remaining_bytes</code>, but <em>at most</em> <code>remaining_bytes</code> so you might need to loop. Now, if Python implements read in this way, but breaks out of the loop if it sees EINTR, then by the time we call <code>get()</code> again, some of the data could have still been left in the pipe, and it will be corrupted.</p>", "body_text": "Aren't queues implemented around pipes? If so they are using read and write. What I'm concerned about is that if I were writing such a queue I would do it like this:\nstd::size_t remaining_bytes = ...;\nwhile (remaining_bytes > 0) {\n  ssize_t read_bytes = read(fd, &buffer, remaining_bytes);\n  if (read_bytes == -1) throw some_error();\n  remaining_bytes -= read_bytes;\n  buffer += read_bytes;\n}\nThis is because read is not guaranteed to return you exactly remaining_bytes, but at most remaining_bytes so you might need to loop. Now, if Python implements read in this way, but breaks out of the loop if it sees EINTR, then by the time we call get() again, some of the data could have still been left in the pipe, and it will be corrupted.", "in_reply_to_id": 163797146}