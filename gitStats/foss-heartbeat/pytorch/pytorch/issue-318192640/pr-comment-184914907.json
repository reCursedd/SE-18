{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/184914907", "pull_request_review_id": 116199984, "id": 184914907, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NDkxNDkwNw==", "diff_hunk": "@@ -0,0 +1,227 @@\n+import sys\n+import ast\n+import inspect\n+import torch\n+from torch._C import DynamicType, TupleType\n+from textwrap import dedent\n+\n+\n+PY35 = sys.version_info >= (3, 5)\n+\n+\n+try:\n+    import typing\n+    from typing import Tuple\n+\n+    def is_tuple(ann):\n+        return ann.__module__ == 'typing' and getattr(ann, '__origin__', None) is typing.Tuple\n+except ImportError:\n+    # A minimal polyfill for versions of Python that don't have typing.\n+    # Note that this means that they also don't support the fancy annotation syntax, so\n+    # those instances will only be used in our tiny `type: ` comment interpreter.\n+\n+    # The __getitem__ in typing is implemented using metaclasses, but I'm too lazy for that.\n+    class TupleCls(object):\n+        def __getitem__(self, types):\n+            return TupleInstance(types)\n+\n+    class TupleInstance(object):\n+        def __init__(self, types):\n+            setattr(self, '__args__', types)\n+\n+    Tuple = TupleCls()\n+\n+    def is_tuple(ann):\n+        return isinstance(ann, TupleInstance)\n+\n+\n+def get_signature(fn, _n_arguments=None, _n_binders=None):\n+    # Python 3.5 adds support for the nice annotation syntax, so try that first.\n+    if PY35:\n+        sig = try_real_annotations(fn)\n+        if sig is not None:\n+            return sig\n+\n+    type_line, source = None, None\n+    try:\n+        source = dedent(inspect.getsource(fn))\n+        type_line = get_type_line(source)\n+    except TypeError:\n+        pass\n+    # This might happen both because we failed to get the source of fn, or\n+    # because it didn't have any annotations.\n+    if type_line is None:\n+        return default_signature(fn, source, _n_arguments, _n_binders)\n+\n+    return parse_type_line(type_line)\n+\n+\n+def parse_type_line(type_line):\n+    \"\"\"Parses a type annotation specified as a comment.\n+\n+    Example inputs:\n+        # type: (Tensor, torch.Tensor) -> Tuple[Tensor]\n+        # type: (Tensor, Tuple[Tensor, Tensor]) -> Tensor\n+    \"\"\"\n+    arg_ann_str, ret_ann_str = split_type_line(type_line)\n+\n+    try:\n+        arg_ann = ast.parse(arg_ann_str, mode='eval').body\n+    except SyntaxError:\n+        raise RuntimeError(\"Failed to parse the argument list of a type annotation\")\n+\n+    if type(arg_ann) is ast.Tuple:\n+        arg_ann = arg_ann.elts\n+    else:\n+        arg_ann = (arg_ann,)\n+\n+    try:\n+        ret_ann = ast.parse(ret_ann_str, mode='eval').body\n+    except SyntaxError:\n+        raise RuntimeError(\"Failed to parse the return type of a the annotation\")\n+\n+    arg_types = [ann_to_type(interpret_ann(ann)) for ann in arg_ann]\n+    ret_type = ann_to_type(interpret_ann(ret_ann))\n+    return arg_types, ret_type\n+\n+\n+def default_signature(fn, source, _n_arguments, _n_binders):\n+    \"\"\"Returns the default signature for fn.\n+\n+    The current formula is to use the source (if available) to determine the\n+    number of inputs and outputs, and set all their types as tensors.\n+    If the source is missing, we fall back to the numbers provided by the compiler,\n+    to make sure we don't cause an error there (although type mismatches can still happen).\n+\n+    This method also accounts for the self argument if fn is a method.\n+    \"\"\"\n+    if _n_binders is None:\n+        raise RuntimeError(\"default_signature needs to know the number of binders\")\n+    if source is None and _n_arguments is None:\n+        raise RuntimeError(\"default_signature needs either the source or the number of arguments\")\n+\n+    ret_type = TupleType([DynamicType() for _ in range(_n_binders)])\n+    if source is not None:\n+        py_ast = ast.parse(source)\n+        if len(py_ast.body) != 1 or not isinstance(py_ast.body[0], ast.FunctionDef):\n+            raise RuntimeError(\"expected a single top-level function\")\n+        py_def = py_ast.body[0]\n+        arg_types = [DynamicType() for _ in py_def.args.args]\n+        if inspect.ismethod(fn):\n+            arg_types = arg_types[1:]\n+    else:\n+        arg_types = [DynamicType()] * _n_arguments\n+\n+    return arg_types, ret_type\n+\n+\n+def get_type_line(source):\n+    \"\"\"Tries to find the line containing a comment with the type annotation.\"\"\"\n+    lines = source.split('\\n')\n+\n+    def strip_comment(line):\n+        return line[:line.index('#') if '#' in line else None]\n+\n+    i = 0\n+    while '):' not in strip_comment(lines[i]):\n+        i += 1\n+    i += 1\n+\n+    type_line = lines[i].strip()\n+    if not type_line.startswith('# type:'):\n+        return None\n+    return type_line\n+\n+\n+def split_type_line(type_line):\n+    \"\"\"Splits the comment with the type annotation into parts for argument and return types.\n+\n+    For example, for an input of:\n+        # type: (Tensor, torch.Tensor) -> Tuple[Tensor, Tensor]\n+\n+    This function will return:\n+        (\"(Tensor, torch.Tensor)\", \"Tuple[Tensor, Tensor]\")\n+\n+    \"\"\"\n+    start_offset = len('# type:')\n+    try:\n+        arrow_pos = type_line.index('->')\n+    except ValueError:\n+        raise RuntimeError(\"Syntax error in type annotation (cound't find `->`)\")\n+    return type_line[start_offset:arrow_pos].strip(), type_line[arrow_pos + 2:].strip()\n+\n+\n+def try_real_annotations(fn):\n+    \"\"\"Tries to use the Py3.5+ annotation syntax to get the type.\"\"\"\n+    try:\n+        sig = inspect.signature(fn)\n+    except ValueError:\n+        return None\n+\n+    all_annots = [sig.return_annotation] + [p.annotation for p in sig.parameters.values()]\n+    if all(ann is sig.empty for ann in all_annots):\n+        return None\n+\n+    def as_ann(ann):\n+        # sig.empty is really annoying so convert it to None\n+        return ann if ann is not sig.empty else None\n+\n+    param_types = [ann_to_type(as_ann(p.annotation))\n+                   for p in sig.parameters.values()]\n+    return_type = ann_to_type(as_ann(sig.return_annotation))\n+    return param_types, return_type\n+\n+\n+def ann_to_type(ann):\n+    if ann is None:\n+        return DynamicType()\n+    elif ann is torch.Tensor:\n+        return DynamicType()\n+    elif is_tuple(ann):\n+        return TupleType([ann_to_type(a) for a in ann.__args__])\n+    raise ValueError(\"The only supported annotations kinds are Tensor and Tuple[...]\")\n+\n+\n+class Module(object):\n+    def __init__(self, name, members):\n+        self.name = name\n+        self.members = members\n+\n+    def __getattr__(self, name):\n+        try:\n+            return self.members[name]\n+        except KeyError:\n+            raise RuntimeError(\"Module {} has no member called {}\".format(self.name, name))\n+\n+\n+env = {\n+    'torch': Module('torch', {'Tensor': torch.Tensor}),\n+    'Tensor': torch.Tensor,\n+    'typing': Module('typing', {'Tuple': Tuple}),\n+    'Tuple': Tuple,\n+}\n+\n+\n+def interpret_ann(expr):", "path": "torch/jit/annotations.py", "position": null, "original_position": 205, "commit_id": "aec2b0cecca4007a9302ad0f9e844c4ffca06e28", "original_commit_id": "0d9d62e3c71e31a14939f8b104c9de2db18255d2", "user": {"login": "zdevito", "id": 370202, "node_id": "MDQ6VXNlcjM3MDIwMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/370202?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zdevito", "html_url": "https://github.com/zdevito", "followers_url": "https://api.github.com/users/zdevito/followers", "following_url": "https://api.github.com/users/zdevito/following{/other_user}", "gists_url": "https://api.github.com/users/zdevito/gists{/gist_id}", "starred_url": "https://api.github.com/users/zdevito/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zdevito/subscriptions", "organizations_url": "https://api.github.com/users/zdevito/orgs", "repos_url": "https://api.github.com/users/zdevito/repos", "events_url": "https://api.github.com/users/zdevito/events{/privacy}", "received_events_url": "https://api.github.com/users/zdevito/received_events", "type": "User", "site_admin": false}, "body": "What is the reason to prefer using a mini-interpreter to using the Python interpreter here?", "created_at": "2018-04-30T05:58:14Z", "updated_at": "2018-11-23T15:43:24Z", "html_url": "https://github.com/pytorch/pytorch/pull/7009#discussion_r184914907", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/7009", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/184914907"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/7009#discussion_r184914907"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/7009"}}, "body_html": "<p>What is the reason to prefer using a mini-interpreter to using the Python interpreter here?</p>", "body_text": "What is the reason to prefer using a mini-interpreter to using the Python interpreter here?"}