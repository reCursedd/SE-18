{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/184914486", "pull_request_review_id": 116199984, "id": 184914486, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NDkxNDQ4Ng==", "diff_hunk": "@@ -0,0 +1,227 @@\n+import sys\n+import ast\n+import inspect\n+import torch\n+from torch._C import DynamicType, TupleType\n+from textwrap import dedent\n+\n+\n+PY35 = sys.version_info >= (3, 5)\n+\n+\n+try:\n+    import typing\n+    from typing import Tuple\n+\n+    def is_tuple(ann):\n+        return ann.__module__ == 'typing' and getattr(ann, '__origin__', None) is typing.Tuple\n+except ImportError:\n+    # A minimal polyfill for versions of Python that don't have typing.\n+    # Note that this means that they also don't support the fancy annotation syntax, so\n+    # those instances will only be used in our tiny `type: ` comment interpreter.\n+\n+    # The __getitem__ in typing is implemented using metaclasses, but I'm too lazy for that.\n+    class TupleCls(object):\n+        def __getitem__(self, types):\n+            return TupleInstance(types)\n+\n+    class TupleInstance(object):\n+        def __init__(self, types):\n+            setattr(self, '__args__', types)\n+\n+    Tuple = TupleCls()\n+\n+    def is_tuple(ann):\n+        return isinstance(ann, TupleInstance)\n+\n+\n+def get_signature(fn, _n_arguments=None, _n_binders=None):\n+    # Python 3.5 adds support for the nice annotation syntax, so try that first.\n+    if PY35:\n+        sig = try_real_annotations(fn)\n+        if sig is not None:\n+            return sig\n+\n+    type_line, source = None, None\n+    try:\n+        source = dedent(inspect.getsource(fn))\n+        type_line = get_type_line(source)\n+    except TypeError:\n+        pass\n+    # This might happen both because we failed to get the source of fn, or\n+    # because it didn't have any annotations.\n+    if type_line is None:\n+        return default_signature(fn, source, _n_arguments, _n_binders)\n+\n+    return parse_type_line(type_line)\n+\n+\n+def parse_type_line(type_line):\n+    \"\"\"Parses a type annotation specified as a comment.\n+\n+    Example inputs:\n+        # type: (Tensor, torch.Tensor) -> Tuple[Tensor]\n+        # type: (Tensor, Tuple[Tensor, Tensor]) -> Tensor\n+    \"\"\"\n+    arg_ann_str, ret_ann_str = split_type_line(type_line)\n+\n+    try:\n+        arg_ann = ast.parse(arg_ann_str, mode='eval').body\n+    except SyntaxError:\n+        raise RuntimeError(\"Failed to parse the argument list of a type annotation\")\n+\n+    if type(arg_ann) is ast.Tuple:\n+        arg_ann = arg_ann.elts\n+    else:\n+        arg_ann = (arg_ann,)\n+\n+    try:\n+        ret_ann = ast.parse(ret_ann_str, mode='eval').body\n+    except SyntaxError:\n+        raise RuntimeError(\"Failed to parse the return type of a the annotation\")\n+\n+    arg_types = [ann_to_type(interpret_ann(ann)) for ann in arg_ann]\n+    ret_type = ann_to_type(interpret_ann(ret_ann))\n+    return arg_types, ret_type\n+\n+\n+def default_signature(fn, source, _n_arguments, _n_binders):\n+    \"\"\"Returns the default signature for fn.\n+\n+    The current formula is to use the source (if available) to determine the\n+    number of inputs and outputs, and set all their types as tensors.\n+    If the source is missing, we fall back to the numbers provided by the compiler,\n+    to make sure we don't cause an error there (although type mismatches can still happen).\n+\n+    This method also accounts for the self argument if fn is a method.\n+    \"\"\"\n+    if _n_binders is None:\n+        raise RuntimeError(\"default_signature needs to know the number of binders\")\n+    if source is None and _n_arguments is None:\n+        raise RuntimeError(\"default_signature needs either the source or the number of arguments\")\n+\n+    ret_type = TupleType([DynamicType() for _ in range(_n_binders)])\n+    if source is not None:\n+        py_ast = ast.parse(source)\n+        if len(py_ast.body) != 1 or not isinstance(py_ast.body[0], ast.FunctionDef):\n+            raise RuntimeError(\"expected a single top-level function\")\n+        py_def = py_ast.body[0]\n+        arg_types = [DynamicType() for _ in py_def.args.args]\n+        if inspect.ismethod(fn):\n+            arg_types = arg_types[1:]\n+    else:\n+        arg_types = [DynamicType()] * _n_arguments\n+\n+    return arg_types, ret_type\n+\n+\n+def get_type_line(source):\n+    \"\"\"Tries to find the line containing a comment with the type annotation.\"\"\"\n+    lines = source.split('\\n')\n+\n+    def strip_comment(line):\n+        return line[:line.index('#') if '#' in line else None]\n+\n+    i = 0\n+    while '):' not in strip_comment(lines[i]):", "path": "torch/jit/annotations.py", "position": null, "original_position": 126, "commit_id": "aec2b0cecca4007a9302ad0f9e844c4ffca06e28", "original_commit_id": "0d9d62e3c71e31a14939f8b104c9de2db18255d2", "user": {"login": "zdevito", "id": 370202, "node_id": "MDQ6VXNlcjM3MDIwMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/370202?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zdevito", "html_url": "https://github.com/zdevito", "followers_url": "https://api.github.com/users/zdevito/followers", "following_url": "https://api.github.com/users/zdevito/following{/other_user}", "gists_url": "https://api.github.com/users/zdevito/gists{/gist_id}", "starred_url": "https://api.github.com/users/zdevito/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zdevito/subscriptions", "organizations_url": "https://api.github.com/users/zdevito/orgs", "repos_url": "https://api.github.com/users/zdevito/repos", "events_url": "https://api.github.com/users/zdevito/events{/privacy}", "received_events_url": "https://api.github.com/users/zdevito/received_events", "type": "User", "site_admin": false}, "body": "I don't think it is safe to look for `):`,  e.g. `def foo(a)     :`", "created_at": "2018-04-30T05:51:09Z", "updated_at": "2018-11-23T15:43:24Z", "html_url": "https://github.com/pytorch/pytorch/pull/7009#discussion_r184914486", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/7009", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/184914486"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/7009#discussion_r184914486"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/7009"}}, "body_html": "<p>I don't think it is safe to look for <code>):</code>,  e.g. <code>def foo(a)     :</code></p>", "body_text": "I don't think it is safe to look for ):,  e.g. def foo(a)     :"}