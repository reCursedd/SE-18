{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/184625755", "pull_request_review_id": 115860376, "id": 184625755, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NDYyNTc1NQ==", "diff_hunk": "@@ -0,0 +1,559 @@\n+#include \"torch/csrc/jit/ir_import.h\"\n+#include \"torch/csrc/onnx/onnx.pb.h\"\n+#include \"torch/csrc/jit/ir.h\"\n+\n+#include <ATen/ATen.h>\n+\n+#include <unordered_map>\n+#include <vector>\n+#include <string>\n+\n+#include \"third_party/nanopb/pb_decode.h\"\n+\n+namespace torch { namespace jit {\n+\n+namespace {\n+\n+// Deserialized data\n+\n+struct Tensor_ {\n+  std::vector<int64_t> dims;\n+  std::vector<uint8_t> raw_data;\n+  onnx_TensorProto_DataType data_type;\n+};\n+\n+struct AttributeValue_ {\n+  std::string name;\n+  onnx_AttributeProto_AttributeType type;\n+  double f;\n+  int64_t i;\n+  std::string s;\n+  Tensor_ t;\n+  std::string g;\n+  std::vector<double> fs;\n+  std::vector<int64_t> is;\n+  std::vector<std::string> ss;\n+  std::vector<Tensor_> ts;\n+  std::vector<std::string> gs;\n+};\n+\n+struct Value_ {\n+  std::string name;\n+};\n+\n+struct Node_ {\n+  std::string op_type;\n+  std::vector<std::string> inputs;\n+  std::vector<std::string> outputs;\n+  std::vector<AttributeValue_> attrs;\n+};\n+\n+struct Graph_ {\n+  std::vector<Value_> inputs;\n+  std::vector<Value_> outputs;\n+  std::vector<Node_> nodes;\n+  std::vector<Tensor_> initializers;\n+};\n+\n+struct Model_ {\n+  Graph_ graph;\n+};\n+\n+\n+// Readers\n+\n+struct ReaderBase {\n+  ReaderBase() {}\n+  ReaderBase(pb_callback_t& cb) {\n+    initialize_callback(cb);\n+  }\n+\n+  void initialize_callback(pb_callback_t& cb) {\n+    cb.funcs.decode = ReaderBase::decode;\n+    cb.arg = this;\n+  }\n+\n+  virtual void decode(pb_istream_t *stream) = 0;\n+\n+  static bool decode(pb_istream_t *stream, const pb_field_t *, void **_self) {\n+    ReaderBase* self = *reinterpret_cast<ReaderBase* const *>(_self);\n+    try {\n+      self->decode(stream);\n+    }\n+    catch (const std::runtime_error& error) {\n+      return false;\n+    }\n+    return true;\n+  }\n+};\n+\n+\n+template<typename T>\n+struct Reader : ReaderBase {};\n+\n+template<typename T>\n+struct Reader<std::vector<T>> : Reader<T> {\n+  Reader(pb_callback_t& cb) : Reader<T>(cb) {}\n+  virtual void decode(pb_istream_t *stream) override {\n+    Reader<T>::decode(stream);\n+    values.push_back(std::move(Reader<T>::value));\n+  }\n+  std::vector<T> values;\n+};\n+\n+template<>\n+struct Reader<std::string> : ReaderBase {\n+  Reader(pb_callback_t& cb) : ReaderBase(cb) {}\n+  virtual void decode(pb_istream_t *stream) override {\n+    std::vector<uint8_t> res(stream->bytes_left);\n+    if (!pb_read(stream, res.data(), stream->bytes_left)) {\n+      throw std::runtime_error(\"Decoding failed\");\n+    }\n+    value.assign(res.begin(), res.end());\n+  }\n+  std::string value;\n+};\n+\n+template<>\n+struct Reader<double> : ReaderBase {\n+  Reader(pb_callback_t& cb) : ReaderBase(cb) {}\n+  virtual void decode(pb_istream_t *stream) override {\n+    double val;\n+    if (!pb_decode_fixed32(stream, &val)) {\n+      throw std::runtime_error(\"Decoding failed\");\n+    }\n+    value = val;\n+  }\n+  double value;\n+};\n+\n+template<>\n+struct Reader<int64_t> : ReaderBase {\n+  Reader(pb_callback_t& cb) : ReaderBase(cb) {}\n+  virtual void decode(pb_istream_t *stream) override {\n+    uint64_t val;\n+    if (!pb_decode_varint(stream, &val)) {\n+      throw std::runtime_error(\"Decoding failed\");\n+    }\n+    value = val;\n+  }\n+  int64_t value;\n+};\n+\n+template<>\n+struct Reader<std::vector<uint8_t>> : ReaderBase {\n+  Reader(pb_callback_t& cb) : ReaderBase(cb) {}\n+  virtual void decode(pb_istream_t *stream) override {\n+    value.resize(stream->bytes_left);\n+    if (!pb_read(stream, value.data(), stream->bytes_left)) {\n+      throw std::runtime_error(\"Decoding failed\");\n+    }\n+  }\n+  std::vector<uint8_t> value;\n+};\n+\n+template<>\n+struct Reader<Tensor_> : ReaderBase {\n+  Reader()\n+    : proto(onnx_TensorProto_init_default)\n+    , dims_reader(proto.dims)\n+    , raw_data_reader(proto.raw_data)\n+  {}\n+\n+  Reader(pb_callback_t& cb)\n+    : Reader() { initialize_callback(cb); }\n+\n+  virtual void decode(pb_istream_t *stream) override {\n+    if (!pb_decode(stream, onnx_TensorProto_fields, &proto)) {\n+      throw std::runtime_error(\"Decoding failed\");\n+    }\n+\n+    value.dims = std::move(dims_reader.values);\n+    value.raw_data = std::move(raw_data_reader.value);\n+    value.data_type = proto.data_type;\n+  }\n+\n+  onnx_TensorProto proto;\n+  Reader<std::vector<int64_t>> dims_reader;\n+  Reader<std::vector<uint8_t>> raw_data_reader;\n+  Tensor_ value;\n+};\n+\n+template<>\n+struct Reader<AttributeValue_> : ReaderBase {\n+  Reader()\n+    : proto(onnx_AttributeProto_init_default)\n+    , name_reader(proto.name)\n+    , str_reader(proto.s)\n+    , tensor_reader(proto.t)\n+    , graph_reader(proto.g)\n+    , floats_reader(proto.floats)\n+    , ints_reader(proto.ints)\n+    , strings_reader(proto.strings)\n+    , tensors_reader(proto.tensors)\n+    , graphs_reader(proto.graphs) {}\n+\n+  Reader(pb_callback_t& cb)\n+    : Reader() { initialize_callback(cb); }\n+\n+  virtual void decode(pb_istream_t *stream) override {\n+    if (!pb_decode(stream, onnx_AttributeProto_fields, &proto)) {\n+      throw std::runtime_error(\"Decoding failed\");\n+    }\n+\n+    value.name = std::move(name_reader.value);\n+    value.type = proto.type;\n+    value.f = proto.f;\n+    value.i = proto.i;\n+    value.s = std::move(str_reader.value);\n+    value.t = std::move(tensor_reader.value);\n+    value.g = std::move(graph_reader.value);\n+    value.fs = std::move(floats_reader.values);\n+    value.is = std::move(ints_reader.values);\n+    value.ss = std::move(strings_reader.values);\n+    value.ts = std::move(tensors_reader.values);\n+    value.gs = std::move(graphs_reader.values);\n+  }\n+\n+  onnx_AttributeProto proto;\n+  Reader<std::string> name_reader;\n+  Reader<std::string> str_reader;\n+  Reader<Tensor_> tensor_reader;\n+  Reader<std::string> graph_reader;\n+  Reader<std::vector<double>> floats_reader;\n+  Reader<std::vector<int64_t>> ints_reader;\n+  Reader<std::vector<std::string>> strings_reader;\n+  Reader<std::vector<Tensor_>> tensors_reader;\n+  Reader<std::vector<std::string>> graphs_reader;\n+  AttributeValue_ value;\n+};\n+\n+template<>\n+struct Reader<Value_> : ReaderBase {\n+  Reader()\n+    : proto(onnx_ValueInfoProto_init_default)\n+    , name_reader(proto.name) {}\n+  Reader(pb_callback_t& cb)\n+    : Reader() { initialize_callback(cb); }\n+\n+  virtual void decode(pb_istream_t *stream) override {\n+    if (!pb_decode(stream, onnx_ValueInfoProto_fields, &proto)) {\n+      throw std::runtime_error(\"Decoding failed\");\n+    }\n+\n+    value.name = std::move(name_reader.value);\n+  }\n+\n+  onnx_ValueInfoProto proto;\n+  Reader<std::string> name_reader;\n+  Value_ value;\n+};\n+\n+\n+template<>\n+struct Reader<Node_> : ReaderBase {\n+  Reader()\n+    : proto(onnx_NodeProto_init_default)\n+    , op_type_reader(proto.op_type)\n+    , inputs_reader(proto.input)\n+    , outputs_reader(proto.output)\n+    , attrs_reader(proto.attribute)\n+  {}\n+  Reader(pb_callback_t& cb)\n+    : Reader() { initialize_callback(cb); }\n+\n+  virtual void decode(pb_istream_t *stream) override {\n+    if (!pb_decode(stream, onnx_NodeProto_fields, &proto)) {\n+      throw std::runtime_error(\"Decoding failed\");\n+    }\n+\n+    value.op_type = std::move(op_type_reader.value);\n+    value.inputs = std::move(inputs_reader.values);\n+    value.outputs = std::move(outputs_reader.values);\n+    value.attrs = std::move(attrs_reader.values);\n+  }\n+\n+  onnx_NodeProto proto;\n+  Reader<std::string> op_type_reader;\n+  Reader<std::vector<std::string>> inputs_reader;\n+  Reader<std::vector<std::string>> outputs_reader;\n+  Reader<std::vector<AttributeValue_>> attrs_reader;\n+  Node_ value;\n+};\n+\n+\n+template<>\n+struct Reader<Graph_> : ReaderBase {\n+  Reader()\n+    : proto(onnx_GraphProto_init_default)\n+    , input_reader(proto.input)\n+    , output_reader(proto.output)\n+    , node_reader(proto.node)\n+    , initializer_reader(proto.initializer)\n+  {}\n+  Reader(pb_callback_t& cb)\n+    : Reader() { initialize_callback(cb); }\n+\n+  virtual void decode(pb_istream_t *stream) override {\n+    if (!pb_decode(stream, onnx_GraphProto_fields, &proto)) {\n+      throw std::runtime_error(\"Decoding failed\");\n+    }\n+\n+    value.inputs = std::move(input_reader.values);\n+    value.outputs = std::move(output_reader.values);\n+    value.nodes = std::move(node_reader.values);\n+    value.initializers = std::move(initializer_reader.values);\n+  }\n+\n+  static Graph_ read(pb_istream_t *stream) {\n+    Reader<Graph_> reader;\n+    reader.decode(stream);\n+    return reader.value;\n+  }\n+\n+  onnx_GraphProto proto;\n+  Reader<std::vector<Value_>> input_reader;\n+  Reader<std::vector<Value_>> output_reader;\n+  Reader<std::vector<Node_>> node_reader;\n+  Reader<std::vector<Tensor_>> initializer_reader;\n+  Graph_ value;\n+};\n+\n+\n+template<>\n+struct Reader<Model_> : ReaderBase {\n+  Reader()\n+    : proto(onnx_ModelProto_init_default)\n+    , graph_reader(proto.graph) {}\n+  Reader(pb_callback_t& cb)\n+    : Reader() { initialize_callback(cb); }\n+\n+  virtual void decode(pb_istream_t *stream) override {\n+    if (!pb_decode(stream, onnx_ModelProto_fields, &proto)) {\n+      throw std::runtime_error(\"Decoding failed\");\n+    }\n+\n+    value.graph = std::move(graph_reader.value);\n+  }\n+\n+  static Model_ read(pb_istream_t *stream) {\n+    Reader<Model_> reader;\n+    reader.decode(stream);\n+    return reader.value;\n+  }\n+\n+  onnx_ModelProto proto;\n+  Reader<Graph_> graph_reader;\n+  Model_ value;\n+};\n+\n+\n+// IR graph construction\n+\n+at::Tensor buildTensor(const Tensor_& tensor_) {\n+\n+  at::Tensor tensor;\n+\n+  switch(tensor_.data_type) {\n+    case onnx_TensorProto_DataType_UINT8:\n+      tensor = at::CPU(at::kByte).tensor();\n+      break;\n+    case onnx_TensorProto_DataType_INT8:\n+      tensor = at::CPU(at::kChar).tensor();\n+      break;\n+    case onnx_TensorProto_DataType_INT16:\n+      tensor = at::CPU(at::kShort).tensor();\n+      break;\n+    case onnx_TensorProto_DataType_INT32:\n+      tensor = at::CPU(at::kInt).tensor();\n+      break;\n+    case onnx_TensorProto_DataType_INT64:\n+      tensor = at::CPU(at::kLong).tensor();\n+      break;\n+    case onnx_TensorProto_DataType_FLOAT16:\n+      tensor = at::CPU(at::kHalf).tensor();\n+      break;\n+    case onnx_TensorProto_DataType_FLOAT:\n+      tensor = at::CPU(at::kFloat).tensor();\n+      break;\n+    case onnx_TensorProto_DataType_DOUBLE:\n+      tensor = at::CPU(at::kDouble).tensor();\n+      break;\n+    default:\n+      throw std::runtime_error(\"Unsupported data type\");\n+  }\n+\n+  tensor.resize_(tensor_.dims);\n+\n+  TORCH_ASSERT(tensor.storage()->size() * tensor.storage()->elementSize() == tensor_.raw_data.size());\n+\n+  std::memcpy(tensor.data_ptr(), tensor_.raw_data.data(), tensor_.raw_data.size());\n+\n+  return tensor;\n+}\n+\n+std::vector<at::Tensor> buildTensors(const std::vector<Tensor_>& tensors_) {\n+  std::vector<at::Tensor> tensors;\n+  for (auto t : tensors_) {\n+    tensors.push_back(buildTensor(t));\n+  }\n+  return tensors;\n+}\n+\n+Graph_ readSubgraph(const std::string& serialized_subgraph) {\n+  pb_istream_t istream = pb_istream_from_buffer(reinterpret_cast<const pb_byte_t *>(serialized_subgraph.data()), serialized_subgraph.size());\n+\n+  return Reader<Graph_>::read(&istream);\n+}\n+\n+std::vector<Graph_> readSubgraphs(const std::vector<std::string>& serialized_subgraphs) {\n+  std::vector<Graph_> subgraphs;\n+  for (auto serialized_subgraph : serialized_subgraphs) {\n+    pb_istream_t istream = pb_istream_from_buffer(reinterpret_cast<const pb_byte_t *>(serialized_subgraph.data()), serialized_subgraph.size());\n+\n+    auto subgraph = Reader<Graph_>::read(&istream);\n+\n+    subgraphs.push_back(std::move(subgraph));\n+  }\n+\n+  return subgraphs;\n+}\n+\n+std::shared_ptr<Graph> buildGraph(const Graph_& graph_);\n+\n+std::vector<std::shared_ptr<Graph>> buildGraphs(const std::vector<Graph_>& graphs_);\n+\n+void buildBlocks(const std::vector<Graph_>& graphs_, Node* node,\n+                 std::unordered_map<std::string, Value*>& value_map);\n+\n+void buildBlock(const Graph_& graph_, Block* block,\n+                std::unordered_map<std::string, Value*>& value_map) {\n+\n+  for (auto input : graph_.inputs) {\n+    value_map[input.name] = block->addInput();\n+  }\n+\n+  for (auto node_ : graph_.nodes) {\n+    TORCH_ASSERT(node_.op_type != \"CppOp\");\n+    TORCH_ASSERT(node_.op_type != \"PythonOp\");\n+\n+    auto node = block->owningGraph()->create(Symbol::fromQualString(node_.op_type),\n+                                             node_.outputs.size());\n+\n+    for (auto attr : node_.attrs) {\n+      Symbol name = Symbol::attr(attr.name);\n+\n+      if (attr.type && onnx_AttributeProto_AttributeType_GRAPHS &&\n+          attr.name == \"_blocks\") {\n+        buildBlocks(readSubgraphs(attr.gs), node, value_map);\n+        continue;\n+      }\n+\n+      switch(attr.type) {\n+        case onnx_AttributeProto_AttributeType_UNDEFINED:\n+          throw std::runtime_error(\"UNDEFINED attribute unsupported\");\n+          break;\n+        case onnx_AttributeProto_AttributeType_FLOAT:\n+          node->f_(name, attr.f);\n+          break;\n+        case onnx_AttributeProto_AttributeType_INT:\n+          node->i_(name, attr.i);\n+          break;\n+        case onnx_AttributeProto_AttributeType_STRING:\n+          node->s_(name, std::move(attr.s));\n+          break;\n+        case onnx_AttributeProto_AttributeType_TENSOR:\n+          node->t_(name, buildTensor(attr.t));\n+          break;\n+        case onnx_AttributeProto_AttributeType_GRAPH:\n+          node->g_(name, buildGraph(readSubgraph(attr.g)));\n+          break;\n+        case onnx_AttributeProto_AttributeType_FLOATS:\n+          node->fs_(name, std::move(attr.fs));\n+          break;\n+        case onnx_AttributeProto_AttributeType_INTS:\n+          node->is_(name, std::move(attr.is));\n+          break;\n+        case onnx_AttributeProto_AttributeType_STRINGS:\n+          node->ss_(name, std::move(attr.ss));\n+          break;\n+        case onnx_AttributeProto_AttributeType_TENSORS:\n+          node->ts_(name, buildTensors(attr.ts));\n+          break;\n+        case onnx_AttributeProto_AttributeType_GRAPHS:\n+          node->gs_(name, buildGraphs(readSubgraphs(attr.gs)));\n+          break;\n+      }\n+    }\n+\n+    for (auto input : node_.inputs) {\n+      auto v = value_map[input];\n+      node->addInput(v);\n+    }\n+\n+    for (size_t i=0; i<node_.outputs.size(); i++) {\n+      value_map[node_.outputs[i]] = node->outputs()[i];\n+    }\n+\n+    block->appendNode(node);\n+  }\n+\n+  for (auto output : graph_.outputs) {\n+    if (value_map.find(output.name) != value_map.end()) {\n+      Value* v = value_map.at(output.name);\n+      block->registerOutput(v);\n+    }\n+  }\n+}\n+\n+void buildBlocks(const std::vector<Graph_>& graphs_, Node* node,\n+                 std::unordered_map<std::string, Value*>& value_map) {\n+  for (auto g_ : graphs_) {\n+    auto block = node->addBlock();\n+    buildBlock(g_, block, value_map);\n+  }\n+}\n+\n+std::shared_ptr<Graph> buildGraph(const Graph_& graph_) {\n+  auto graph = std::make_shared<Graph>();\n+  std::unordered_map<std::string, Value*> value_map;\n+\n+  buildBlock(graph_, graph->block(), value_map);\n+\n+  return graph;\n+}\n+\n+std::vector<std::shared_ptr<Graph>> buildGraphs(const std::vector<Graph_>& graphs_) {\n+  std::vector<std::shared_ptr<Graph>> graphs;\n+  for (auto g_ : graphs_) {\n+    graphs.push_back(buildGraph(g_));\n+  }\n+  return graphs;\n+}\n+\n+std::shared_ptr<Graph> buildGraph(const Graph_& graph_, std::vector<at::Tensor>& initializers) {\n+\n+  auto graph = buildGraph(graph_);\n+\n+  for (auto tensor_ : graph_.initializers) {\n+    initializers.push_back(buildTensor(tensor_));\n+  }\n+\n+  return graph;\n+}\n+\n+}\n+\n+std::shared_ptr<Graph> ImportIRGraph(const std::string& serialized_graph,\n+                                     std::vector<at::Tensor>& initializers) {", "path": "torch/csrc/jit/ir_import.cpp", "position": null, "original_position": 548, "commit_id": "a907ce98f4875f10b0c45be77ec3556236be5ee3", "original_commit_id": "53affa23d5100a2209c5a0396baef511ca5c4cc5", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "body": "Do we use them for anything though? Are they ever non-empty?", "created_at": "2018-04-27T08:40:00Z", "updated_at": "2018-11-23T15:43:17Z", "html_url": "https://github.com/pytorch/pytorch/pull/6392#discussion_r184625755", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/6392", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/184625755"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/6392#discussion_r184625755"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/6392"}}, "body_html": "<p>Do we use them for anything though? Are they ever non-empty?</p>", "body_text": "Do we use them for anything though? Are they ever non-empty?", "in_reply_to_id": 184355871}