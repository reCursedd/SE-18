{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/439918911", "html_url": "https://github.com/pytorch/pytorch/pull/13915#issuecomment-439918911", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/13915", "id": 439918911, "node_id": "MDEyOklzc3VlQ29tbWVudDQzOTkxODkxMQ==", "user": {"login": "nairbv", "id": 582713, "node_id": "MDQ6VXNlcjU4MjcxMw==", "avatar_url": "https://avatars1.githubusercontent.com/u/582713?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nairbv", "html_url": "https://github.com/nairbv", "followers_url": "https://api.github.com/users/nairbv/followers", "following_url": "https://api.github.com/users/nairbv/following{/other_user}", "gists_url": "https://api.github.com/users/nairbv/gists{/gist_id}", "starred_url": "https://api.github.com/users/nairbv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nairbv/subscriptions", "organizations_url": "https://api.github.com/users/nairbv/orgs", "repos_url": "https://api.github.com/users/nairbv/repos", "events_url": "https://api.github.com/users/nairbv/events{/privacy}", "received_events_url": "https://api.github.com/users/nairbv/received_events", "type": "User", "site_admin": false}, "created_at": "2018-11-19T14:52:08Z", "updated_at": "2018-11-19T14:52:08Z", "author_association": "CONTRIBUTOR", "body_html": "<blockquote>\n<p>Can an overflow result in a positive value or even a zero? Probably not? (depends on how many times the overflow rolls - probably not more than 1?)</p>\n</blockquote>\n<p>hm... it seems that the behavior we're seeing is in the cast from double to int64_t (or actually, to ptrdiff_t). From what I can tell the behavior for an out of range cast is undefined, but in practice it doesn't seem to be wrapping. You saw this -9223372036854775808 value in tests (the minimum long value, or max long + 1).</p>\n<p>We could try a range check on the double first. That's tricky though because ptrdiff_t's max value isn't exactly representable in floating point, and could differ in 32 bit systems. I'm not sure if there is actually a system that would wrap it, but I'm also pretty new to C++.</p>\n<p>I'm a bit skeptical of the floating point arithmetic in general of <code>(max-min)/step</code>, but I don't see a specific issue with it yet, and we might be getting beyond the scope of the original ticket. Maybe we should get this merged, and file another ticket if we find another specific failure case?</p>", "body_text": "Can an overflow result in a positive value or even a zero? Probably not? (depends on how many times the overflow rolls - probably not more than 1?)\n\nhm... it seems that the behavior we're seeing is in the cast from double to int64_t (or actually, to ptrdiff_t). From what I can tell the behavior for an out of range cast is undefined, but in practice it doesn't seem to be wrapping. You saw this -9223372036854775808 value in tests (the minimum long value, or max long + 1).\nWe could try a range check on the double first. That's tricky though because ptrdiff_t's max value isn't exactly representable in floating point, and could differ in 32 bit systems. I'm not sure if there is actually a system that would wrap it, but I'm also pretty new to C++.\nI'm a bit skeptical of the floating point arithmetic in general of (max-min)/step, but I don't see a specific issue with it yet, and we might be getting beyond the scope of the original ticket. Maybe we should get this merged, and file another ticket if we find another specific failure case?", "body": "> Can an overflow result in a positive value or even a zero? Probably not? (depends on how many times the overflow rolls - probably not more than 1?)\r\n\r\nhm... it seems that the behavior we're seeing is in the cast from double to int64_t (or actually, to ptrdiff_t). From what I can tell the behavior for an out of range cast is undefined, but in practice it doesn't seem to be wrapping. You saw this -9223372036854775808 value in tests (the minimum long value, or max long + 1).\r\n\r\nWe could try a range check on the double first. That's tricky though because ptrdiff_t's max value isn't exactly representable in floating point, and could differ in 32 bit systems. I'm not sure if there is actually a system that would wrap it, but I'm also pretty new to C++.\r\n\r\nI'm a bit skeptical of the floating point arithmetic in general of `(max-min)/step`, but I don't see a specific issue with it yet, and we might be getting beyond the scope of the original ticket. Maybe we should get this merged, and file another ticket if we find another specific failure case?\r\n"}