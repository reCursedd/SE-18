{"url": "https://api.github.com/repos/pytorch/pytorch/issues/1369", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/1369/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/1369/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/1369/events", "html_url": "https://github.com/pytorch/pytorch/issues/1369", "id": 224611346, "node_id": "MDU6SXNzdWUyMjQ2MTEzNDY=", "number": 1369, "title": "\"Sparsified\" mathematical operations", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 15, "created_at": "2017-04-26T21:56:10Z", "updated_at": "2017-05-02T15:43:14Z", "closed_at": null, "author_association": "CONTRIBUTOR", "body_html": "<p>I had a discussion with <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=1310570\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/soumith\">@soumith</a> about this on Friday, but I wanted to record things down here so that I don't forget.</p>\n<p><strong>Background.</strong> Imagine that you are <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=2560662\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/martinraison\">@martinraison</a> and you are implementing sparse Adagrad. You end up writing this code:</p>\n<pre><code>            if p.grad.data.is_sparse:\n                grad_indices = grad.indices()\n                grad_values = grad.values()\n                size = torch.Size([x for x in grad.size()])\n\n                def make_sparse(values):\n                    constructor = type(p.grad.data)\n                    if grad_indices.dim() == 0 or values.dim() == 0:\n                        return constructor()\n                    return constructor(grad_indices, values, size)\n                state['sum'].add_(make_sparse(grad_values.pow(2)))\n                std = state['sum'].sparse_mask(grad)\n                std_values = std.values().sqrt_().add_(1e-10)\n                p.data.add_(-clr, make_sparse(grad_values / std_values))\n            else:\n                state['sum'].addcmul_(1, grad, grad)\n                std = state['sum'].sqrt().add_(1e-10)\n                p.data.addcdiv_(-clr, grad, std)\n</code></pre>\n<p>So, as you can see, the sparse version of this code is four times as long as the non-sparse version. Why? There are a few contributory factors:</p>\n<ol>\n<li>\n<p><code>addcmul_</code> doesn't understand how to handle sparse arguments, so we have to compute the sparse tensor we want to add, and then add it in. In the code above, this is done by projecting out the underlying values, performing the necessary operations, and then constructing a new sparse tensor (using <code>make_sparse</code>)</p>\n</li>\n<li>\n<p>The line <code>state['sum'].sqrt().add_(1e-10)</code> works in both the sparse and dense settings, because <code>state['sum']</code> is always a dense tensor. However, we can see that we will subsequently use this to divide the gradient, which means we don't actually need to compute all of the entries, only those which will divide non-zero coefficients of gradient. Once again, this is done by pulling out the values you need, doing the necessary ops, and then turning it back into a sparse vector.</p>\n</li>\n</ol>\n<p>OK, so what can we do about this.</p>\n<p><strong>Proposal 1: Nothing is wrong, carry on.</strong> The code above is wordy, but some of it can be simplified by clone()'ing the sparse tensor, and then performing the updates on values in place. (<a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=1310570\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/soumith\">@soumith</a> suggested this to me.) For example, it's an easy matter to rewrite <code>state['sum'].add_(make_sparse(grad_values.pow(2)))</code> to:</p>\n<pre><code>s = grad.clone()\ns.values().pow_(2)\nstate['sum'].add_(s)\n</code></pre>\n<p>Which avoids making use of the <code>make_sparse</code> function.</p>\n<p>There are some downsides to this approach:</p>\n<ol>\n<li>\n<p>You have to be careful to make sure your sparse tensor is coalesced; an uncoalesced tensor may have multiple entries for an index in its values array; if we naively apply an operation to the values tensor of an uncoalesced tensor, that is bad. Indeed, the adagrad code initially got this wrong, and it was fixed in <a class=\"commit-link\" data-hovercard-type=\"commit\" data-hovercard-url=\"https://github.com/pytorch/pytorch/commit/1018b238acf2ecfc836484f3153c2864e9f4e963/hovercard\" href=\"https://github.com/pytorch/pytorch/commit/1018b238acf2ecfc836484f3153c2864e9f4e963\"><tt>1018b23</tt></a>/</p>\n</li>\n<li>\n<p>There are two minor performance hits to doing things this way. By running <code>grad.clone()</code> you are forced to make a copy of values and indexes. The values copy is wasted, because you're going to immediately do an inplace update; you should have just directly written in the updated values. Depending on what you do to the sparse tensor, the index copy may also be wasted, because you may not ever actually change the shape of the tensor (as far as I can tell, we don't have any copy on write.)</p>\n</li>\n<li>\n<p>I get really nervous when performing mutations on tensors which are part of the internal representations of others, e.g., as occurs in <code>s.values().pow_()</code>. Yes, it is pretty clear what the intent is in this code snippet, but I think when there is an indirection, it's easier to accidentally end up sharing state when you don't want to. Then eek!</p>\n</li>\n</ol>\n<p><strong>Proposal 2: Add lots of methods.</strong> If we want to get users to avoid mucking about <code>values()</code> manually, the next obvious thing to do is add methods to sparse tensor to let them do the things they want to do. This is a clear win for well defined, easy-to-compute operations on sparse tensors like <code>pow(scalar)</code> and <code>sqrt</code>. We could implement them in Python or hand-write kernels for them (my personal inclination is to implement them in Python, since that reduces the TCB, but <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=1310570\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/soumith\">@soumith</a> tells me there are good reasons to implement kernels for each of them.)</p>\n<p>However, there are some pitfalls.</p>\n<ol>\n<li>\n<p>Consider <code>std_values = std.values().sqrt_().add_(1e-10)</code>.  It is tempting to say that we should replace this line with <code>std.sqrt_().add_(1e-10)</code>, implementing appropriate sparse versions of sqrt_ and add_. But now there is a problem: the \"sparse\" version of add... isn't an add at all! If you add a scalar to a sparse tensor, the result isn't going to be sparse anymore! The operation you <em>really</em> wanted here was \"add scalar if we actually have an entry for it in the sparse vector\" which is a kind of weird operation, and in any case really shouldn't be called add. (To add insult to injury, it's not even \"add scalar if entry is nonzero\" because, prior to coalescing, we might very well have redundant zero entries in our sparse tensor!) So really, if we add a method for this operation, we should not call it add; perhaps we should name it <code>sadd</code> (\"sparse add\"). This highlights a merit of Proposal 1, which is that we didn't have to come up with new names for the operations.</p>\n</li>\n<li>\n<p>Let's look more closely at <code>grad_values / std_values</code>. We can do this division because we know that the indexes of grad and std are the same. If we are defining a (sparse!) division between two sparse tensors, we do not necessarily know if this is the case: the sparse tensors might be on completely different indexes. (Actually, I don't even know what the intended semantics of division should be in this case.) Nor can I think of a cheap way of testing that this is the case, since if you were using <code>clone()</code> object equality no longer holds between the indexes.</p>\n</li>\n</ol>\n<p><strong>Proposal 3: A lifting operator (or two).</strong> One final possibility is to define a lifting function, which takes a method invocation on dense tensors, and lifts it into a sparse variant. For example, we might  rewrite <code>std_values = std.values().sqrt_().add_(1e-10)</code> as <code>std.lift_sparse(lambda x: x.sqrt_().add_(1e-10))</code>. Similarly, <code>torch.lift_sparse(torch.div, std, grad)</code> would take division on dense tensors and lift it to apply on sparse vectors, handling the necessary unwrapping and wrapping, and ensuring that the inputs are coalesced.</p>\n<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=1310570\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/soumith\">@soumith</a> didn't really like this idea, because when you provide an operator like this, users may end up using it in ways that you don't expect, leading to strange errors on their end. I know lifting operators like this work quite nicely in Haskell, but it is certainly true that Python is not Haskell.</p>\n<p>Thanks for reading. Interested to hear your thoughts.</p>", "body_text": "I had a discussion with @soumith about this on Friday, but I wanted to record things down here so that I don't forget.\nBackground. Imagine that you are @martinraison and you are implementing sparse Adagrad. You end up writing this code:\n            if p.grad.data.is_sparse:\n                grad_indices = grad.indices()\n                grad_values = grad.values()\n                size = torch.Size([x for x in grad.size()])\n\n                def make_sparse(values):\n                    constructor = type(p.grad.data)\n                    if grad_indices.dim() == 0 or values.dim() == 0:\n                        return constructor()\n                    return constructor(grad_indices, values, size)\n                state['sum'].add_(make_sparse(grad_values.pow(2)))\n                std = state['sum'].sparse_mask(grad)\n                std_values = std.values().sqrt_().add_(1e-10)\n                p.data.add_(-clr, make_sparse(grad_values / std_values))\n            else:\n                state['sum'].addcmul_(1, grad, grad)\n                std = state['sum'].sqrt().add_(1e-10)\n                p.data.addcdiv_(-clr, grad, std)\n\nSo, as you can see, the sparse version of this code is four times as long as the non-sparse version. Why? There are a few contributory factors:\n\n\naddcmul_ doesn't understand how to handle sparse arguments, so we have to compute the sparse tensor we want to add, and then add it in. In the code above, this is done by projecting out the underlying values, performing the necessary operations, and then constructing a new sparse tensor (using make_sparse)\n\n\nThe line state['sum'].sqrt().add_(1e-10) works in both the sparse and dense settings, because state['sum'] is always a dense tensor. However, we can see that we will subsequently use this to divide the gradient, which means we don't actually need to compute all of the entries, only those which will divide non-zero coefficients of gradient. Once again, this is done by pulling out the values you need, doing the necessary ops, and then turning it back into a sparse vector.\n\n\nOK, so what can we do about this.\nProposal 1: Nothing is wrong, carry on. The code above is wordy, but some of it can be simplified by clone()'ing the sparse tensor, and then performing the updates on values in place. (@soumith suggested this to me.) For example, it's an easy matter to rewrite state['sum'].add_(make_sparse(grad_values.pow(2))) to:\ns = grad.clone()\ns.values().pow_(2)\nstate['sum'].add_(s)\n\nWhich avoids making use of the make_sparse function.\nThere are some downsides to this approach:\n\n\nYou have to be careful to make sure your sparse tensor is coalesced; an uncoalesced tensor may have multiple entries for an index in its values array; if we naively apply an operation to the values tensor of an uncoalesced tensor, that is bad. Indeed, the adagrad code initially got this wrong, and it was fixed in 1018b23/\n\n\nThere are two minor performance hits to doing things this way. By running grad.clone() you are forced to make a copy of values and indexes. The values copy is wasted, because you're going to immediately do an inplace update; you should have just directly written in the updated values. Depending on what you do to the sparse tensor, the index copy may also be wasted, because you may not ever actually change the shape of the tensor (as far as I can tell, we don't have any copy on write.)\n\n\nI get really nervous when performing mutations on tensors which are part of the internal representations of others, e.g., as occurs in s.values().pow_(). Yes, it is pretty clear what the intent is in this code snippet, but I think when there is an indirection, it's easier to accidentally end up sharing state when you don't want to. Then eek!\n\n\nProposal 2: Add lots of methods. If we want to get users to avoid mucking about values() manually, the next obvious thing to do is add methods to sparse tensor to let them do the things they want to do. This is a clear win for well defined, easy-to-compute operations on sparse tensors like pow(scalar) and sqrt. We could implement them in Python or hand-write kernels for them (my personal inclination is to implement them in Python, since that reduces the TCB, but @soumith tells me there are good reasons to implement kernels for each of them.)\nHowever, there are some pitfalls.\n\n\nConsider std_values = std.values().sqrt_().add_(1e-10).  It is tempting to say that we should replace this line with std.sqrt_().add_(1e-10), implementing appropriate sparse versions of sqrt_ and add_. But now there is a problem: the \"sparse\" version of add... isn't an add at all! If you add a scalar to a sparse tensor, the result isn't going to be sparse anymore! The operation you really wanted here was \"add scalar if we actually have an entry for it in the sparse vector\" which is a kind of weird operation, and in any case really shouldn't be called add. (To add insult to injury, it's not even \"add scalar if entry is nonzero\" because, prior to coalescing, we might very well have redundant zero entries in our sparse tensor!) So really, if we add a method for this operation, we should not call it add; perhaps we should name it sadd (\"sparse add\"). This highlights a merit of Proposal 1, which is that we didn't have to come up with new names for the operations.\n\n\nLet's look more closely at grad_values / std_values. We can do this division because we know that the indexes of grad and std are the same. If we are defining a (sparse!) division between two sparse tensors, we do not necessarily know if this is the case: the sparse tensors might be on completely different indexes. (Actually, I don't even know what the intended semantics of division should be in this case.) Nor can I think of a cheap way of testing that this is the case, since if you were using clone() object equality no longer holds between the indexes.\n\n\nProposal 3: A lifting operator (or two). One final possibility is to define a lifting function, which takes a method invocation on dense tensors, and lifts it into a sparse variant. For example, we might  rewrite std_values = std.values().sqrt_().add_(1e-10) as std.lift_sparse(lambda x: x.sqrt_().add_(1e-10)). Similarly, torch.lift_sparse(torch.div, std, grad) would take division on dense tensors and lift it to apply on sparse vectors, handling the necessary unwrapping and wrapping, and ensuring that the inputs are coalesced.\n@soumith didn't really like this idea, because when you provide an operator like this, users may end up using it in ways that you don't expect, leading to strange errors on their end. I know lifting operators like this work quite nicely in Haskell, but it is certainly true that Python is not Haskell.\nThanks for reading. Interested to hear your thoughts.", "body": "I had a discussion with @soumith about this on Friday, but I wanted to record things down here so that I don't forget.\r\n\r\n**Background.** Imagine that you are @martinraison and you are implementing sparse Adagrad. You end up writing this code:\r\n\r\n                if p.grad.data.is_sparse:\r\n                    grad_indices = grad.indices()\r\n                    grad_values = grad.values()\r\n                    size = torch.Size([x for x in grad.size()])\r\n\r\n                    def make_sparse(values):\r\n                        constructor = type(p.grad.data)\r\n                        if grad_indices.dim() == 0 or values.dim() == 0:\r\n                            return constructor()\r\n                        return constructor(grad_indices, values, size)\r\n                    state['sum'].add_(make_sparse(grad_values.pow(2)))\r\n                    std = state['sum'].sparse_mask(grad)\r\n                    std_values = std.values().sqrt_().add_(1e-10)\r\n                    p.data.add_(-clr, make_sparse(grad_values / std_values))\r\n                else:\r\n                    state['sum'].addcmul_(1, grad, grad)\r\n                    std = state['sum'].sqrt().add_(1e-10)\r\n                    p.data.addcdiv_(-clr, grad, std)\r\n\r\nSo, as you can see, the sparse version of this code is four times as long as the non-sparse version. Why? There are a few contributory factors:\r\n\r\n1. `addcmul_` doesn't understand how to handle sparse arguments, so we have to compute the sparse tensor we want to add, and then add it in. In the code above, this is done by projecting out the underlying values, performing the necessary operations, and then constructing a new sparse tensor (using `make_sparse`)\r\n\r\n2. The line `state['sum'].sqrt().add_(1e-10)` works in both the sparse and dense settings, because `state['sum']` is always a dense tensor. However, we can see that we will subsequently use this to divide the gradient, which means we don't actually need to compute all of the entries, only those which will divide non-zero coefficients of gradient. Once again, this is done by pulling out the values you need, doing the necessary ops, and then turning it back into a sparse vector.\r\n\r\nOK, so what can we do about this.\r\n\r\n**Proposal 1: Nothing is wrong, carry on.** The code above is wordy, but some of it can be simplified by clone()'ing the sparse tensor, and then performing the updates on values in place. (@soumith suggested this to me.) For example, it's an easy matter to rewrite `state['sum'].add_(make_sparse(grad_values.pow(2)))` to:\r\n\r\n    s = grad.clone()\r\n    s.values().pow_(2)\r\n    state['sum'].add_(s)\r\n\r\nWhich avoids making use of the `make_sparse` function.\r\n\r\nThere are some downsides to this approach:\r\n\r\n1. You have to be careful to make sure your sparse tensor is coalesced; an uncoalesced tensor may have multiple entries for an index in its values array; if we naively apply an operation to the values tensor of an uncoalesced tensor, that is bad. Indeed, the adagrad code initially got this wrong, and it was fixed in 1018b238acf2ecfc836484f3153c2864e9f4e963/\r\n\r\n2. There are two minor performance hits to doing things this way. By running `grad.clone()` you are forced to make a copy of values and indexes. The values copy is wasted, because you're going to immediately do an inplace update; you should have just directly written in the updated values. Depending on what you do to the sparse tensor, the index copy may also be wasted, because you may not ever actually change the shape of the tensor (as far as I can tell, we don't have any copy on write.)\r\n\r\n3. I get really nervous when performing mutations on tensors which are part of the internal representations of others, e.g., as occurs in `s.values().pow_()`. Yes, it is pretty clear what the intent is in this code snippet, but I think when there is an indirection, it's easier to accidentally end up sharing state when you don't want to. Then eek!\r\n\r\n**Proposal 2: Add lots of methods.** If we want to get users to avoid mucking about `values()` manually, the next obvious thing to do is add methods to sparse tensor to let them do the things they want to do. This is a clear win for well defined, easy-to-compute operations on sparse tensors like `pow(scalar)` and `sqrt`. We could implement them in Python or hand-write kernels for them (my personal inclination is to implement them in Python, since that reduces the TCB, but @soumith tells me there are good reasons to implement kernels for each of them.)\r\n\r\nHowever, there are some pitfalls.\r\n\r\n1. Consider `std_values = std.values().sqrt_().add_(1e-10)`.  It is tempting to say that we should replace this line with `std.sqrt_().add_(1e-10)`, implementing appropriate sparse versions of sqrt_ and add_. But now there is a problem: the \"sparse\" version of add... isn't an add at all! If you add a scalar to a sparse tensor, the result isn't going to be sparse anymore! The operation you *really* wanted here was \"add scalar if we actually have an entry for it in the sparse vector\" which is a kind of weird operation, and in any case really shouldn't be called add. (To add insult to injury, it's not even \"add scalar if entry is nonzero\" because, prior to coalescing, we might very well have redundant zero entries in our sparse tensor!) So really, if we add a method for this operation, we should not call it add; perhaps we should name it `sadd` (\"sparse add\"). This highlights a merit of Proposal 1, which is that we didn't have to come up with new names for the operations.\r\n\r\n2. Let's look more closely at `grad_values / std_values`. We can do this division because we know that the indexes of grad and std are the same. If we are defining a (sparse!) division between two sparse tensors, we do not necessarily know if this is the case: the sparse tensors might be on completely different indexes. (Actually, I don't even know what the intended semantics of division should be in this case.) Nor can I think of a cheap way of testing that this is the case, since if you were using `clone()` object equality no longer holds between the indexes.\r\n\r\n**Proposal 3: A lifting operator (or two).** One final possibility is to define a lifting function, which takes a method invocation on dense tensors, and lifts it into a sparse variant. For example, we might  rewrite `std_values = std.values().sqrt_().add_(1e-10)` as `std.lift_sparse(lambda x: x.sqrt_().add_(1e-10))`. Similarly, `torch.lift_sparse(torch.div, std, grad)` would take division on dense tensors and lift it to apply on sparse vectors, handling the necessary unwrapping and wrapping, and ensuring that the inputs are coalesced.\r\n\r\n@soumith didn't really like this idea, because when you provide an operator like this, users may end up using it in ways that you don't expect, leading to strange errors on their end. I know lifting operators like this work quite nicely in Haskell, but it is certainly true that Python is not Haskell.\r\n\r\nThanks for reading. Interested to hear your thoughts."}