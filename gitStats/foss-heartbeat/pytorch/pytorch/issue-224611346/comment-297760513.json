{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/297760513", "html_url": "https://github.com/pytorch/pytorch/issues/1369#issuecomment-297760513", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/1369", "id": 297760513, "node_id": "MDEyOklzc3VlQ29tbWVudDI5Nzc2MDUxMw==", "user": {"login": "ebetica", "id": 3605224, "node_id": "MDQ6VXNlcjM2MDUyMjQ=", "avatar_url": "https://avatars3.githubusercontent.com/u/3605224?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebetica", "html_url": "https://github.com/ebetica", "followers_url": "https://api.github.com/users/ebetica/followers", "following_url": "https://api.github.com/users/ebetica/following{/other_user}", "gists_url": "https://api.github.com/users/ebetica/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebetica/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebetica/subscriptions", "organizations_url": "https://api.github.com/users/ebetica/orgs", "repos_url": "https://api.github.com/users/ebetica/repos", "events_url": "https://api.github.com/users/ebetica/events{/privacy}", "received_events_url": "https://api.github.com/users/ebetica/received_events", "type": "User", "site_admin": false}, "created_at": "2017-04-27T16:05:21Z", "updated_at": "2017-04-27T16:05:21Z", "author_association": "CONTRIBUTOR", "body_html": "<p>For proposal 2, wouldn't both be solved by simply overloading sparse div to be <code>x / (y + eps)</code> in all cases? This way would not add new names, and simply the code in one go. The only difference is that the user has to remember this detail (but it's seems like this would be the only sane way to do element-wise division anyway). pow can also be implemented, the same way.</p>\n<p>The sparse route now becomes:</p>\n<pre><code>if p.grad.data.is_sparse:\n  grad.contiguous()  # or coalesce\n  state['sum'].add_(grad.pow(2))  # This just pow's on the values\n  std = state['sum'].sparse_mask(grad)\n  p.data.add_(-clr, grad.cdiv(std.sqrt_(), 1e-10))\n</code></pre>\n<p>I think the extra copy is sort of \"unavoidable\", since it's the same as trying to implement kernel fusion in a sense.</p>", "body_text": "For proposal 2, wouldn't both be solved by simply overloading sparse div to be x / (y + eps) in all cases? This way would not add new names, and simply the code in one go. The only difference is that the user has to remember this detail (but it's seems like this would be the only sane way to do element-wise division anyway). pow can also be implemented, the same way.\nThe sparse route now becomes:\nif p.grad.data.is_sparse:\n  grad.contiguous()  # or coalesce\n  state['sum'].add_(grad.pow(2))  # This just pow's on the values\n  std = state['sum'].sparse_mask(grad)\n  p.data.add_(-clr, grad.cdiv(std.sqrt_(), 1e-10))\n\nI think the extra copy is sort of \"unavoidable\", since it's the same as trying to implement kernel fusion in a sense.", "body": "For proposal 2, wouldn't both be solved by simply overloading sparse div to be `x / (y + eps)` in all cases? This way would not add new names, and simply the code in one go. The only difference is that the user has to remember this detail (but it's seems like this would be the only sane way to do element-wise division anyway). pow can also be implemented, the same way.\r\n\r\nThe sparse route now becomes:\r\n```\r\nif p.grad.data.is_sparse:\r\n  grad.contiguous()  # or coalesce\r\n  state['sum'].add_(grad.pow(2))  # This just pow's on the values\r\n  std = state['sum'].sparse_mask(grad)\r\n  p.data.add_(-clr, grad.cdiv(std.sqrt_(), 1e-10))\r\n```\r\n\r\nI think the extra copy is sort of \"unavoidable\", since it's the same as trying to implement kernel fusion in a sense."}