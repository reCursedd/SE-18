{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/194010848", "pull_request_review_id": 127102164, "id": 194010848, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NDAxMDg0OA==", "diff_hunk": "@@ -227,6 +228,12 @@ auto Engine::thread_main(GraphTask *graph_task) -> void {\n   // Why the test on graph_task->outstanding_tasks?  See\n   // Note [Reentrant backwards]\n   while (!graph_task || graph_task->outstanding_tasks > 0) {\n+\n+    // NO_DEVICE worker will wait for tasks generated by other device while graph_task is not done\n+    if (worker_device == NO_DEVICE && queue->heap.empty()) {", "path": "torch/csrc/autograd/engine.cpp", "position": 16, "original_position": 16, "commit_id": "3a1995d13daa4ac0901dd544c8a33bf9273e377c", "original_commit_id": "0a45bacc8ce5bb7c8e2bc8aabaaf9e441eb180e1", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "body": "This is unsafe. Access to `queue->heap` should be protected by the mutex. Right now you can prematurely break because some task might take a job from the queue and be in the middle of processing it, you'll see that it's empty and break out, while the other thread will finish processing and push more tasks into the queue.", "created_at": "2018-06-08T10:03:12Z", "updated_at": "2018-11-23T15:45:15Z", "html_url": "https://github.com/pytorch/pytorch/pull/8278#discussion_r194010848", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/8278", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/194010848"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/8278#discussion_r194010848"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/8278"}}, "body_html": "<p>This is unsafe. Access to <code>queue-&gt;heap</code> should be protected by the mutex. Right now you can prematurely break because some task might take a job from the queue and be in the middle of processing it, you'll see that it's empty and break out, while the other thread will finish processing and push more tasks into the queue.</p>", "body_text": "This is unsafe. Access to queue->heap should be protected by the mutex. Right now you can prematurely break because some task might take a job from the queue and be in the middle of processing it, you'll see that it's empty and break out, while the other thread will finish processing and push more tasks into the queue."}