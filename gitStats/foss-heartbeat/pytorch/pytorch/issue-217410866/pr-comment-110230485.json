{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/110230485", "pull_request_review_id": 31389263, "id": 110230485, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDExMDIzMDQ4NQ==", "diff_hunk": "@@ -0,0 +1,963 @@\n+#ifndef THC_GENERIC_FILE\n+#define THC_GENERIC_FILE \"generic/FusedRNNKernel.cu\"\n+#else\n+#include <cstdarg>\n+\n+#include \"../common.h\"\n+\n+#define DATATYPE TensorUtils<THCTensor>::DataType\n+\n+//factor will be 3 for GRU and 4 for LSTM\n+void THNN_(FusedRNNAssertSizes)(THCState *state, int factor, int count ...)\n+{\n+  va_list list;\n+  va_start(list, count);\n+  THCTensor *input = va_arg(list, THCTensor*);\n+  THCTensor *hidden = va_arg(list, THCTensor*);\n+  THArgCheck(THCTensor_(nElement)(state, input) ==\n+\t     THCTensor_(nElement)(state, hidden),\n+\t     3, \"Input and Hidden tensor sizes should be the same.\");\n+\n+  THAssertMsg(TensorUtils<THCTensor>::getDims(state, input) <= MAX_CUTORCH_DIMS,\n+\t\t \"Tensor dimension is too large.\");\n+\n+  THAssertMsg(TensorUtils<THCTensor>::getDims(state, hidden) <= MAX_CUTORCH_DIMS,\n+\t\t \"Tensor dimension is too large.\");\n+\n+  for (int arg=2; arg < count; ++arg){\n+    THCTensor *tens = va_arg(list, THCTensor*);\n+    THArgCheck(THCTensor_(nElement)(state, input) ==\n+\t       THCTensor_(nElement)(state, tens)*factor,\n+\t       3, \"A pointwise tensor was not the right size, should have 1/%u the elements of input/hidden tensor.\", arg, factor);\n+    THAssertMsg(TensorUtils<THCTensor>::getDims(state, tens) <= MAX_CUTORCH_DIMS,\n+\t\t \"Tensor dimension is too large.\");\n+  }\n+\n+  va_end(list);\n+}\n+\n+int THNN_(minIndexType)(THCState *state, int count, ...)\n+{\n+  va_list list;\n+  va_start(list, count);\n+\n+  int maxDim = -2;\n+  for (int arg=0; arg < count; ++arg){\n+    THCTensor* tens = va_arg(list, THCTensor*);\n+    if(THCTensor_(isContiguous)(state, tens)) continue;\n+    int tensdims = TensorUtils<THCTensor>::getDims(state, tens);\n+    maxDim = (( tensdims> maxDim) ? tensdims : maxDim);\n+  }\n+\n+  va_end(list);\n+  return maxDim;\n+}\n+\n+bool THNN_(canUse32BitIndexMath)(THCState *state, int count, ...)\n+{\n+  va_list list;\n+  va_start(list, count);\n+\n+  for (int arg=0; arg < count; ++arg){\n+    THCTensor *tens = va_arg(list, THCTensor*);\n+    if (!TensorUtils<THCTensor>::canUse32BitIndexMath(state, tens)){\n+\tva_end(list);\n+\treturn false;\n+      }\n+  }\n+  va_end(list);\n+  return true;\n+}\n+\n+#define DEVICE_LINEAR_GET(D_TENSOR, INDEX)\t\t\t\t\\\n+  D_TENSOR.data[IndexToOffset<T, IndexType, Dims>::get(INDEX, D_TENSOR)]\n+\n+#define H2F(input) __half2float(input)\n+#define F2H(input) __float2half(input)", "path": "torch/lib/THCUNN/generic/FusedRNNKernel.cu", "position": null, "original_position": 76, "commit_id": "4b269de7bd2dc272edfb456696a1552bf575bace", "original_commit_id": "c058a4c0cceccc54a2e0cdf67ecfe47b90bb0d3d", "user": {"login": "csarofeen", "id": 22205833, "node_id": "MDQ6VXNlcjIyMjA1ODMz", "avatar_url": "https://avatars2.githubusercontent.com/u/22205833?v=4", "gravatar_id": "", "url": "https://api.github.com/users/csarofeen", "html_url": "https://github.com/csarofeen", "followers_url": "https://api.github.com/users/csarofeen/followers", "following_url": "https://api.github.com/users/csarofeen/following{/other_user}", "gists_url": "https://api.github.com/users/csarofeen/gists{/gist_id}", "starred_url": "https://api.github.com/users/csarofeen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/csarofeen/subscriptions", "organizations_url": "https://api.github.com/users/csarofeen/orgs", "repos_url": "https://api.github.com/users/csarofeen/repos", "events_url": "https://api.github.com/users/csarofeen/events{/privacy}", "received_events_url": "https://api.github.com/users/csarofeen/received_events", "type": "User", "site_admin": false}, "body": "@apaszke Would be more accurate to leave everything in floating point and only convert once at beginning and end. Using THCNumerics in half mode would constantly convert back and forth.", "created_at": "2017-04-06T18:12:24Z", "updated_at": "2018-11-23T15:33:04Z", "html_url": "https://github.com/pytorch/pytorch/pull/1119#discussion_r110230485", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/1119", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/110230485"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/1119#discussion_r110230485"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/1119"}}, "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=4583066\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/apaszke\">@apaszke</a> Would be more accurate to leave everything in floating point and only convert once at beginning and end. Using THCNumerics in half mode would constantly convert back and forth.</p>", "body_text": "@apaszke Would be more accurate to leave everything in floating point and only convert once at beginning and end. Using THCNumerics in half mode would constantly convert back and forth.", "in_reply_to_id": 110110783}