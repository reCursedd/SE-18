{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/382153295", "html_url": "https://github.com/pytorch/pytorch/pull/6119#issuecomment-382153295", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/6119", "id": 382153295, "node_id": "MDEyOklzc3VlQ29tbWVudDM4MjE1MzI5NQ==", "user": {"login": "cpuhrsch", "id": 1716488, "node_id": "MDQ6VXNlcjE3MTY0ODg=", "avatar_url": "https://avatars1.githubusercontent.com/u/1716488?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cpuhrsch", "html_url": "https://github.com/cpuhrsch", "followers_url": "https://api.github.com/users/cpuhrsch/followers", "following_url": "https://api.github.com/users/cpuhrsch/following{/other_user}", "gists_url": "https://api.github.com/users/cpuhrsch/gists{/gist_id}", "starred_url": "https://api.github.com/users/cpuhrsch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cpuhrsch/subscriptions", "organizations_url": "https://api.github.com/users/cpuhrsch/orgs", "repos_url": "https://api.github.com/users/cpuhrsch/repos", "events_url": "https://api.github.com/users/cpuhrsch/events{/privacy}", "received_events_url": "https://api.github.com/users/cpuhrsch/received_events", "type": "User", "site_admin": false}, "created_at": "2018-04-17T21:28:22Z", "updated_at": "2018-04-17T21:28:22Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=9110200\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/fmassa\">@fmassa</a> I've been wondering that as well. I think there might be some speed advantages for the 2-ary case. Since the result tensor is contiguous by default, we could sort the strides of self and then run apply2. However afterwards you'd have to permute the strides of the result. Now, it's not clear to me whether this is worth it, since lots of ops benefit from contiguity. The same could be said about the n-ary case if all strides and sizes match.</p>\n<p>In general, _out could be called with result as a non-contiguous tensor as far as I know. If all strides and sizes match, then we could apply this sort for free. So this is something that I can easily add. Maybe there are other cases like this.</p>", "body_text": "@fmassa I've been wondering that as well. I think there might be some speed advantages for the 2-ary case. Since the result tensor is contiguous by default, we could sort the strides of self and then run apply2. However afterwards you'd have to permute the strides of the result. Now, it's not clear to me whether this is worth it, since lots of ops benefit from contiguity. The same could be said about the n-ary case if all strides and sizes match.\nIn general, _out could be called with result as a non-contiguous tensor as far as I know. If all strides and sizes match, then we could apply this sort for free. So this is something that I can easily add. Maybe there are other cases like this.", "body": "@fmassa I've been wondering that as well. I think there might be some speed advantages for the 2-ary case. Since the result tensor is contiguous by default, we could sort the strides of self and then run apply2. However afterwards you'd have to permute the strides of the result. Now, it's not clear to me whether this is worth it, since lots of ops benefit from contiguity. The same could be said about the n-ary case if all strides and sizes match.\r\n\r\nIn general, _out could be called with result as a non-contiguous tensor as far as I know. If all strides and sizes match, then we could apply this sort for free. So this is something that I can easily add. Maybe there are other cases like this."}