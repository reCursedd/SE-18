{"url": "https://api.github.com/repos/pytorch/pytorch/issues/4480", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/4480/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/4480/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/4480/events", "html_url": "https://github.com/pytorch/pytorch/issues/4480", "id": 286080116, "node_id": "MDU6SXNzdWUyODYwODAxMTY=", "number": 4480, "title": "DCE trick for inplace tracing doesn't work", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 679953983, "node_id": "MDU6TGFiZWw2Nzk5NTM5ODM=", "url": "https://api.github.com/repos/pytorch/pytorch/labels/jit", "name": "jit", "color": "c5def5", "default": false}, {"id": 693805995, "node_id": "MDU6TGFiZWw2OTM4MDU5OTU=", "url": "https://api.github.com/repos/pytorch/pytorch/labels/onnx", "name": "onnx", "color": "e99695", "default": false}], "state": "closed", "locked": false, "assignee": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 0, "created_at": "2018-01-04T18:53:25Z", "updated_at": "2018-01-23T23:07:08Z", "closed_at": "2018-01-23T23:07:08Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Exposed by <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"284996690\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/4395\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/pytorch/pytorch/pull/4395/hovercard\" href=\"https://github.com/pytorch/pytorch/pull/4395\">#4395</a>, hotpatched in <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"285898958\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/4471\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/pytorch/pytorch/pull/4471/hovercard\" href=\"https://github.com/pytorch/pytorch/pull/4471\">#4471</a>.</p>\n<p>The DCE trick says that if I have <code>y = f(x)</code>, and <code>f</code> is internally implemented as <code>g</code>, it's OK to trace both <code>g</code> and <code>f</code>. Recall the tracing algorithm is:</p>\n<ol>\n<li>enter f(x)</li>\n<li>compute its result y (recursively calling other possibly tracing functions)</li>\n<li>trace y = f(x) (use the mapping to figure out the identity of x, and writing in a mapping that y binds to the result JIT IR value of this trace)</li>\n<li>return from f</li>\n</ol>\n<p>So when you run the example above, you'll do this:</p>\n<pre><code># suppose x is mapped to %1\nenter f(x)\nenter g(x)\nresult of g is y\ntrace y = g(x a.k.a. %1) (mapping y to %2)\nreturn from g\nresult of f is y\ntrace y = f(x a.k.a. %1) (remapping y to %3)\nreturn from f\n</code></pre>\n<p>and end up with a trace like this:</p>\n<pre><code>%2 = g(%1)\n%3 = f(%1)\n... only %3 is live, because %2 was killed from the mapping...\n</code></pre>\n<p>Subsequent DCE will eliminate the invocation of <code>g</code> and you'll only see <code>f</code> in the final trace.</p>\n<p>However, if f and g are inplace functions, the machinery breaks:</p>\n<pre><code># suppose x is mapped to %1\nenter f(x)\nenter g(x)\nresult of g is x\ntrace x = g(x a.k.a. %1) (remapping x to %2)\nreturn from g\nresult of f is x\ntrace x = f(x a.k.a. %2) (remapping x to %3)\nreturn from f\n</code></pre>\n<p>resulting in:</p>\n<pre><code>%2 = g(%1)\n%3 = f(%2) # OOPS\n</code></pre>\n<p>Proper TLS tracing will solve this problem. But maybe a more robust stopgap than <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"285898958\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/4471\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/pytorch/pytorch/pull/4471/hovercard\" href=\"https://github.com/pytorch/pytorch/pull/4471\">#4471</a> is to add a little bit of extra logic for inplace functions. Essentially, what we need to do is save the original Value for a function before we make the inner recursive call, and use that as the Value when we determine the arguments of tracing, rather than doing it after we do the inner recursive call (in which case <code>x</code> could have been overwritten). In fact, I originally implemented the tracer this way but <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=655866\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/colesbury\">@colesbury</a> convinced me that it wasn't necessary (and it was true, in the code at the time, it was not necessary.)</p>\n<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=30275821\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/houseroad\">@houseroad</a>, when you fix this, please work this discussion into a comment somewhere in the code.</p>\n<p>CC <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=4583066\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/apaszke\">@apaszke</a></p>", "body_text": "Exposed by #4395, hotpatched in #4471.\nThe DCE trick says that if I have y = f(x), and f is internally implemented as g, it's OK to trace both g and f. Recall the tracing algorithm is:\n\nenter f(x)\ncompute its result y (recursively calling other possibly tracing functions)\ntrace y = f(x) (use the mapping to figure out the identity of x, and writing in a mapping that y binds to the result JIT IR value of this trace)\nreturn from f\n\nSo when you run the example above, you'll do this:\n# suppose x is mapped to %1\nenter f(x)\nenter g(x)\nresult of g is y\ntrace y = g(x a.k.a. %1) (mapping y to %2)\nreturn from g\nresult of f is y\ntrace y = f(x a.k.a. %1) (remapping y to %3)\nreturn from f\n\nand end up with a trace like this:\n%2 = g(%1)\n%3 = f(%1)\n... only %3 is live, because %2 was killed from the mapping...\n\nSubsequent DCE will eliminate the invocation of g and you'll only see f in the final trace.\nHowever, if f and g are inplace functions, the machinery breaks:\n# suppose x is mapped to %1\nenter f(x)\nenter g(x)\nresult of g is x\ntrace x = g(x a.k.a. %1) (remapping x to %2)\nreturn from g\nresult of f is x\ntrace x = f(x a.k.a. %2) (remapping x to %3)\nreturn from f\n\nresulting in:\n%2 = g(%1)\n%3 = f(%2) # OOPS\n\nProper TLS tracing will solve this problem. But maybe a more robust stopgap than #4471 is to add a little bit of extra logic for inplace functions. Essentially, what we need to do is save the original Value for a function before we make the inner recursive call, and use that as the Value when we determine the arguments of tracing, rather than doing it after we do the inner recursive call (in which case x could have been overwritten). In fact, I originally implemented the tracer this way but @colesbury convinced me that it wasn't necessary (and it was true, in the code at the time, it was not necessary.)\n@houseroad, when you fix this, please work this discussion into a comment somewhere in the code.\nCC @apaszke", "body": "Exposed by #4395, hotpatched in #4471.\r\n\r\nThe DCE trick says that if I have `y = f(x)`, and `f` is internally implemented as `g`, it's OK to trace both `g` and `f`. Recall the tracing algorithm is:\r\n\r\n1. enter f(x)\r\n2. compute its result y (recursively calling other possibly tracing functions)\r\n3. trace y = f(x) (use the mapping to figure out the identity of x, and writing in a mapping that y binds to the result JIT IR value of this trace)\r\n4. return from f\r\n\r\nSo when you run the example above, you'll do this:\r\n\r\n```\r\n# suppose x is mapped to %1\r\nenter f(x)\r\nenter g(x)\r\nresult of g is y\r\ntrace y = g(x a.k.a. %1) (mapping y to %2)\r\nreturn from g\r\nresult of f is y\r\ntrace y = f(x a.k.a. %1) (remapping y to %3)\r\nreturn from f\r\n```\r\n\r\nand end up with a trace like this:\r\n\r\n```\r\n%2 = g(%1)\r\n%3 = f(%1)\r\n... only %3 is live, because %2 was killed from the mapping...\r\n```\r\n\r\nSubsequent DCE will eliminate the invocation of `g` and you'll only see `f` in the final trace.\r\n\r\nHowever, if f and g are inplace functions, the machinery breaks:\r\n\r\n```\r\n# suppose x is mapped to %1\r\nenter f(x)\r\nenter g(x)\r\nresult of g is x\r\ntrace x = g(x a.k.a. %1) (remapping x to %2)\r\nreturn from g\r\nresult of f is x\r\ntrace x = f(x a.k.a. %2) (remapping x to %3)\r\nreturn from f\r\n```\r\n\r\nresulting in:\r\n\r\n```\r\n%2 = g(%1)\r\n%3 = f(%2) # OOPS\r\n```\r\n\r\nProper TLS tracing will solve this problem. But maybe a more robust stopgap than #4471 is to add a little bit of extra logic for inplace functions. Essentially, what we need to do is save the original Value for a function before we make the inner recursive call, and use that as the Value when we determine the arguments of tracing, rather than doing it after we do the inner recursive call (in which case `x` could have been overwritten). In fact, I originally implemented the tracer this way but @colesbury convinced me that it wasn't necessary (and it was true, in the code at the time, it was not necessary.)\r\n\r\n@houseroad, when you fix this, please work this discussion into a comment somewhere in the code.\r\n\r\nCC @apaszke \r\n  \r\n  "}