{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/406619944", "html_url": "https://github.com/pytorch/pytorch/pull/9539#issuecomment-406619944", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/9539", "id": 406619944, "node_id": "MDEyOklzc3VlQ29tbWVudDQwNjYxOTk0NA==", "user": {"login": "SsnL", "id": 5674597, "node_id": "MDQ6VXNlcjU2NzQ1OTc=", "avatar_url": "https://avatars2.githubusercontent.com/u/5674597?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SsnL", "html_url": "https://github.com/SsnL", "followers_url": "https://api.github.com/users/SsnL/followers", "following_url": "https://api.github.com/users/SsnL/following{/other_user}", "gists_url": "https://api.github.com/users/SsnL/gists{/gist_id}", "starred_url": "https://api.github.com/users/SsnL/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SsnL/subscriptions", "organizations_url": "https://api.github.com/users/SsnL/orgs", "repos_url": "https://api.github.com/users/SsnL/repos", "events_url": "https://api.github.com/users/SsnL/events{/privacy}", "received_events_url": "https://api.github.com/users/SsnL/received_events", "type": "User", "site_admin": false}, "created_at": "2018-07-20T14:36:46Z", "updated_at": "2018-07-20T14:36:46Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=22205833\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/csarofeen\">@csarofeen</a> Here are some interesting behavior I saw:</p>\n<ol>\n<li>Moving the <code>super().get</code> call outside <code>with self.get_lock</code> passes the test, i.e., with change\n<div class=\"highlight highlight-source-python\"><pre> <span class=\"pl-k\">def</span> <span class=\"pl-en\">get</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>, <span class=\"pl-smi\">block</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">True</span>, <span class=\"pl-smi\">timeout</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">None</span>):\n     <span class=\"pl-k\">if</span> <span class=\"pl-c1\">self</span>.is_shutdown():\n         <span class=\"pl-k\">return</span> <span class=\"pl-c1\">None</span>\n     <span class=\"pl-k\">return</span> <span class=\"pl-c1\">super</span>(Queue, <span class=\"pl-c1\">self</span>).get(block, timeout)</pre></div>\n</li>\n<li>With the above change, directly using <code>worker_result_queue</code> as <code>data_queue</code> when <code>timeout &gt; 0</code> fails the test, i.e., with above change and\n<div class=\"highlight highlight-source-python\"><pre>    <span class=\"pl-k\">-</span>  <span class=\"pl-k\">if</span> <span class=\"pl-c1\">self</span>.pin_memory <span class=\"pl-k\">or</span> <span class=\"pl-c1\">self</span>.timeout <span class=\"pl-k\">&gt;</span> <span class=\"pl-c1\">0</span>:\n    <span class=\"pl-k\">+</span>  <span class=\"pl-k\">if</span> <span class=\"pl-c1\">self</span>.pin_memory:\n            <span class=\"pl-c1\">self</span>.data_queue <span class=\"pl-k\">=</span> queue.Queue()\n            <span class=\"pl-c1\">...</span>.. <span class=\"pl-c\"><span class=\"pl-c\">#</span> init worker_manager_thread thread</span>\n        <span class=\"pl-k\">else</span>:\n            <span class=\"pl-c1\">self</span>.data_queue <span class=\"pl-k\">=</span> <span class=\"pl-c1\">self</span>.worker_result_queue</pre></div>\nDirectly using <code>worker_result_queue</code> should be fine when <code>timeout &gt; 0</code> because it is now a <code>mp.Queue</code> rather than a <code>SimpleQueue</code>.</li>\n</ol>", "body_text": "@csarofeen Here are some interesting behavior I saw:\n\nMoving the super().get call outside with self.get_lock passes the test, i.e., with change\n def get(self, block=True, timeout=None):\n     if self.is_shutdown():\n         return None\n     return super(Queue, self).get(block, timeout)\n\nWith the above change, directly using worker_result_queue as data_queue when timeout > 0 fails the test, i.e., with above change and\n    -  if self.pin_memory or self.timeout > 0:\n    +  if self.pin_memory:\n            self.data_queue = queue.Queue()\n            ..... # init worker_manager_thread thread\n        else:\n            self.data_queue = self.worker_result_queue\nDirectly using worker_result_queue should be fine when timeout > 0 because it is now a mp.Queue rather than a SimpleQueue.", "body": "@csarofeen Here are some interesting behavior I saw:\r\n1. Moving the `super().get` call outside `with self.get_lock` passes the test, i.e., with change \r\n   ```py\r\n    def get(self, block=True, timeout=None):\r\n        if self.is_shutdown():\r\n            return None\r\n        return super(Queue, self).get(block, timeout)\r\n   ````\r\n2. With the above change, directly using `worker_result_queue` as `data_queue` when `timeout > 0` fails the test, i.e., with above change and \r\n    ```py\r\n        -  if self.pin_memory or self.timeout > 0:\r\n        +  if self.pin_memory:\r\n                self.data_queue = queue.Queue()\r\n                ..... # init worker_manager_thread thread\r\n            else:\r\n                self.data_queue = self.worker_result_queue\r\n    ```\r\n    Directly using `worker_result_queue` should be fine when `timeout > 0` because it is now a `mp.Queue` rather than a `SimpleQueue`.\r\n"}