{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/153808434", "pull_request_review_id": 79871201, "id": 153808434, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1MzgwODQzNA==", "diff_hunk": "@@ -204,24 +448,35 @@ struct InterpreterStateImpl {\n   void runOneStage(\n     const std::vector<at::Tensor> & inputs,\n     std::vector<at::Tensor> & outputs) {\n-      //std::cout << \"running stage: \" << current_stage << \" of \" << function->stages.size() << \"\\n\";\n+      // std::cout << \"running stage: \" << current_stage << \" of \" << function->stages.size() << \"\\n\";\n       JIT_ASSERT(current_stage < function->stages.size());\n       auto & stage = function->stages[current_stage++];\n       JIT_ASSERT((int)inputs.size() == stage.inputs.size);\n       for(int i = 0; i < stage.inputs.size; i++) {\n         int reg = get(stage.inputs,i);\n         if(reg >= 0) { // otherwise this input is dead, and we do not store it to avoid holding the reference\n-          registers[reg] = inputs[i];\n+          registers.takeOwnership(reg, toRetainableShare(inputs[i]));\n         }\n-        //std::cout << \"registers[\" << reg << \"] = inputs[\" << i << \"](\" << inputs[i].defined() << \")\\n\";\n+        // std::cout << \"registers[\" << reg << \"] = inputs[\" << i << \"](\" << registers[reg] << \")\\n\";\n       }\n       for(auto & inst : stage.instructions) {\n-        loadTensorsFromRegisters(inst.inputs, input_buffer);\n+        auto & inputs = inst.inputs.values;\n+        for(int i = 0; i < inputs.size; i++) {\n+          int reg = get(inputs,i);\n+          input_buffer.push_back(registers[reg]);", "path": "torch/csrc/jit/interpreter.cpp", "position": 358, "original_position": 358, "commit_id": "9ed71c792b2ea33bbc30a18bd9b0bc7cc7ea5c84", "original_commit_id": "0354127c52b21be07d61d7441a8babcc1c35d529", "user": {"login": "zdevito", "id": 370202, "node_id": "MDQ6VXNlcjM3MDIwMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/370202?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zdevito", "html_url": "https://github.com/zdevito", "followers_url": "https://api.github.com/users/zdevito/followers", "following_url": "https://api.github.com/users/zdevito/following{/other_user}", "gists_url": "https://api.github.com/users/zdevito/gists{/gist_id}", "starred_url": "https://api.github.com/users/zdevito/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zdevito/subscriptions", "organizations_url": "https://api.github.com/users/zdevito/orgs", "repos_url": "https://api.github.com/users/zdevito/repos", "events_url": "https://api.github.com/users/zdevito/events{/privacy}", "received_events_url": "https://api.github.com/users/zdevito/received_events", "type": "User", "site_admin": false}, "body": "Yes, the input/output buffers are just short term places where inputs/outputs get stored before moving into registers. The output list is unmanaged, but during the time it is unempty the only things that happen are appending to the output list and writting the outputs back into registers.", "created_at": "2017-11-29T14:51:16Z", "updated_at": "2018-11-23T15:36:56Z", "html_url": "https://github.com/pytorch/pytorch/pull/3866#discussion_r153808434", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/3866", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/153808434"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/3866#discussion_r153808434"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/3866"}}, "body_html": "<p>Yes, the input/output buffers are just short term places where inputs/outputs get stored before moving into registers. The output list is unmanaged, but during the time it is unempty the only things that happen are appending to the output list and writting the outputs back into registers.</p>", "body_text": "Yes, the input/output buffers are just short term places where inputs/outputs get stored before moving into registers. The output list is unmanaged, but during the time it is unempty the only things that happen are appending to the output list and writting the outputs back into registers.", "in_reply_to_id": 153647139}