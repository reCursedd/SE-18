{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/179903449", "pull_request_review_id": 110241331, "id": 179903449, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE3OTkwMzQ0OQ==", "diff_hunk": "@@ -1219,13 +1219,15 @@ void addGlobalMethods(py::module& m) {\n \n         // Parse protobuffers to NetDefs\n         std::vector<std::unique_ptr<caffe2::NetDef>> nets;", "path": "caffe2/python/pybind_state.cc", "position": 3, "original_position": 3, "commit_id": "d6eb5729b9fda03962796a12d14e09d7bc74c013", "original_commit_id": "d6eb5729b9fda03962796a12d14e09d7bc74c013", "user": {"login": "Swetko", "id": 11769173, "node_id": "MDQ6VXNlcjExNzY5MTcz", "avatar_url": "https://avatars3.githubusercontent.com/u/11769173?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Swetko", "html_url": "https://github.com/Swetko", "followers_url": "https://api.github.com/users/Swetko/followers", "following_url": "https://api.github.com/users/Swetko/following{/other_user}", "gists_url": "https://api.github.com/users/Swetko/gists{/gist_id}", "starred_url": "https://api.github.com/users/Swetko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Swetko/subscriptions", "organizations_url": "https://api.github.com/users/Swetko/orgs", "repos_url": "https://api.github.com/users/Swetko/repos", "events_url": "https://api.github.com/users/Swetko/events{/privacy}", "received_events_url": "https://api.github.com/users/Swetko/received_events", "type": "User", "site_admin": false}, "body": "shared_ptr would have the same problem as unique_ptr. Those smart pointers are concerned with ownership. In the current context we are talking about the interface of the InferTensorShape function and that function doesn't have anything to do with the ownership of the object. It just does operation on them.\r\n[https://stackoverflow.com/questions/6675651/when-should-i-use-raw-pointers-over-smart-pointers?utm_medium=organic&utm_source=google_rich_qa&utm_campaign=google_rich_qa](url)\r\n\r\nThe proper way to have the interface would be  const T& or const T*, with reference preferable, but in this case it's complicated because we are passing a vector of those. So options are:\r\n\r\nvector<T>&  (this would require creating the vector and copying of data, in case your objects are not already stored in a vector. Since this is not a performance critical place, it's a fine solution).\r\n\r\nvector<T*> (what I changed it to be, requires creation of just a vector of lightweight pointers)\r\n\r\nvector<unique_ptr<T>> ( how it was before, has the same disadvantage of having to copy/create objects just so we pass them to the function, but the idea is less clear and more verbose)\r\n\r\nvector<T&> (C++ doesn't allow vector of references).\r\n\r\nNone of those options is inherently risky. The only issue is how clear is the code, and the more clear the less space for bugs. The option of passing vector<shared_ptr<T>> is actually the least clear. Let me explain:\r\n\r\nSuppose we have objects (a and b):\r\n\r\nT a,b;\r\n\r\nWe want to pass them to this function F:\r\n\r\nvoid F(vector<shared_ptr<T>>);\r\n\r\nwe can call like this:\r\n\r\nF({make_shared(&a),make_shared(&b)})\r\n\r\nUpon exit it will segfault because destroying the temporary vector<shared_ptr> would cause destruction of stack allocated objects.\r\n\r\nOr we can call like this:\r\n\r\nF({make_shared(new T(a)),make_shared(new T(b))})\r\n\r\nin this case we are creating new objects just for the purpose of calling the function.\r\nAlternatively there's also weak_ptr but that is used in conjunction with shared_ptr.\r\nBasically we are going to have this problem with any function that expects a smart pointer as an input as outlined in the stack overflow link.\r\n\r\n\r\nThe Caffe2 codebase is filled with all possible combinations of references, pointers, and smart pointers. Not sure if there's official guidelines about coding styles in caffe2.\r\n\r\nSo let me know which interface you'd prefer to use and I'll make the calling functions respect that.\r\n\r\n", "created_at": "2018-04-07T01:03:14Z", "updated_at": "2018-11-23T15:41:59Z", "html_url": "https://github.com/pytorch/pytorch/pull/6335#discussion_r179903449", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/6335", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/179903449"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/6335#discussion_r179903449"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/6335"}}, "body_html": "<p>shared_ptr would have the same problem as unique_ptr. Those smart pointers are concerned with ownership. In the current context we are talking about the interface of the InferTensorShape function and that function doesn't have anything to do with the ownership of the object. It just does operation on them.<br>\n<a href=\"url\">https://stackoverflow.com/questions/6675651/when-should-i-use-raw-pointers-over-smart-pointers?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa</a></p>\n<p>The proper way to have the interface would be  const T&amp; or const T*, with reference preferable, but in this case it's complicated because we are passing a vector of those. So options are:</p>\n<p>vector&amp;  (this would require creating the vector and copying of data, in case your objects are not already stored in a vector. Since this is not a performance critical place, it's a fine solution).</p>\n<p>vector&lt;T*&gt; (what I changed it to be, requires creation of just a vector of lightweight pointers)</p>\n<p>vector&lt;unique_ptr&gt; ( how it was before, has the same disadvantage of having to copy/create objects just so we pass them to the function, but the idea is less clear and more verbose)</p>\n<p>vector&lt;T&amp;&gt; (C++ doesn't allow vector of references).</p>\n<p>None of those options is inherently risky. The only issue is how clear is the code, and the more clear the less space for bugs. The option of passing vector&lt;shared_ptr&gt; is actually the least clear. Let me explain:</p>\n<p>Suppose we have objects (a and b):</p>\n<p>T a,b;</p>\n<p>We want to pass them to this function F:</p>\n<p>void F(vector&lt;shared_ptr&gt;);</p>\n<p>we can call like this:</p>\n<p>F({make_shared(&amp;a),make_shared(&amp;b)})</p>\n<p>Upon exit it will segfault because destroying the temporary vector&lt;shared_ptr&gt; would cause destruction of stack allocated objects.</p>\n<p>Or we can call like this:</p>\n<p>F({make_shared(new T(a)),make_shared(new T(b))})</p>\n<p>in this case we are creating new objects just for the purpose of calling the function.<br>\nAlternatively there's also weak_ptr but that is used in conjunction with shared_ptr.<br>\nBasically we are going to have this problem with any function that expects a smart pointer as an input as outlined in the stack overflow link.</p>\n<p>The Caffe2 codebase is filled with all possible combinations of references, pointers, and smart pointers. Not sure if there's official guidelines about coding styles in caffe2.</p>\n<p>So let me know which interface you'd prefer to use and I'll make the calling functions respect that.</p>", "body_text": "shared_ptr would have the same problem as unique_ptr. Those smart pointers are concerned with ownership. In the current context we are talking about the interface of the InferTensorShape function and that function doesn't have anything to do with the ownership of the object. It just does operation on them.\nhttps://stackoverflow.com/questions/6675651/when-should-i-use-raw-pointers-over-smart-pointers?utm_medium=organic&utm_source=google_rich_qa&utm_campaign=google_rich_qa\nThe proper way to have the interface would be  const T& or const T*, with reference preferable, but in this case it's complicated because we are passing a vector of those. So options are:\nvector&  (this would require creating the vector and copying of data, in case your objects are not already stored in a vector. Since this is not a performance critical place, it's a fine solution).\nvector<T*> (what I changed it to be, requires creation of just a vector of lightweight pointers)\nvector<unique_ptr> ( how it was before, has the same disadvantage of having to copy/create objects just so we pass them to the function, but the idea is less clear and more verbose)\nvector<T&> (C++ doesn't allow vector of references).\nNone of those options is inherently risky. The only issue is how clear is the code, and the more clear the less space for bugs. The option of passing vector<shared_ptr> is actually the least clear. Let me explain:\nSuppose we have objects (a and b):\nT a,b;\nWe want to pass them to this function F:\nvoid F(vector<shared_ptr>);\nwe can call like this:\nF({make_shared(&a),make_shared(&b)})\nUpon exit it will segfault because destroying the temporary vector<shared_ptr> would cause destruction of stack allocated objects.\nOr we can call like this:\nF({make_shared(new T(a)),make_shared(new T(b))})\nin this case we are creating new objects just for the purpose of calling the function.\nAlternatively there's also weak_ptr but that is used in conjunction with shared_ptr.\nBasically we are going to have this problem with any function that expects a smart pointer as an input as outlined in the stack overflow link.\nThe Caffe2 codebase is filled with all possible combinations of references, pointers, and smart pointers. Not sure if there's official guidelines about coding styles in caffe2.\nSo let me know which interface you'd prefer to use and I'll make the calling functions respect that.", "in_reply_to_id": 179662182}