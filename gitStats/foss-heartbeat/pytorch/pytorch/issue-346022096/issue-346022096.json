{"url": "https://api.github.com/repos/pytorch/pytorch/issues/10051", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/10051/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/10051/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/10051/events", "html_url": "https://github.com/pytorch/pytorch/pull/10051", "id": 346022096, "node_id": "MDExOlB1bGxSZXF1ZXN0MjA0OTg2NTYx", "number": 10051, "title": "Grid sampler: nearest interpolation & reflection padding", "user": {"login": "SsnL", "id": 5674597, "node_id": "MDQ6VXNlcjU2NzQ1OTc=", "avatar_url": "https://avatars2.githubusercontent.com/u/5674597?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SsnL", "html_url": "https://github.com/SsnL", "followers_url": "https://api.github.com/users/SsnL/followers", "following_url": "https://api.github.com/users/SsnL/following{/other_user}", "gists_url": "https://api.github.com/users/SsnL/gists{/gist_id}", "starred_url": "https://api.github.com/users/SsnL/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SsnL/subscriptions", "organizations_url": "https://api.github.com/users/SsnL/orgs", "repos_url": "https://api.github.com/users/SsnL/repos", "events_url": "https://api.github.com/users/SsnL/events{/privacy}", "received_events_url": "https://api.github.com/users/SsnL/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2018-07-31T03:31:28Z", "updated_at": "2018-11-23T15:48:36Z", "closed_at": "2018-08-10T19:44:34Z", "author_association": "CONTRIBUTOR", "pull_request": {"url": "https://api.github.com/repos/pytorch/pytorch/pulls/10051", "html_url": "https://github.com/pytorch/pytorch/pull/10051", "diff_url": "https://github.com/pytorch/pytorch/pull/10051.diff", "patch_url": "https://github.com/pytorch/pytorch/pull/10051.patch"}, "body_html": "<p><span class=\"issue-keyword tooltipped tooltipped-se\" aria-label=\"This pull request closes issue #9702.\">closes</span> <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"343483817\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/9702\" data-hovercard-type=\"issue\" data-hovercard-url=\"/pytorch/pytorch/issues/9702/hovercard\" href=\"https://github.com/pytorch/pytorch/issues/9702\">#9702</a> .</p>\n<p>cc <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=346999\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/jph00\">@jph00</a></p>\n<p>Commit structure:</p>\n<ol>\n<li>\n<p>Change the index calculation logic. I will explain using 1-D for simplicity.</p>\n<p>Previously we have (in pseudo code):</p>\n<pre><code>// 1. get the float locations from grid\nscalar_t x = from_grid()\n\n// 2. find the integral surrounding indices\nint x_left = floor(x)\nint x_right = x_left + 1\n\n// 3. calculate the linear interpolate weights\nscalar_t w_left = x_right - x\nscalar_t w_right = x - x_left\n\n// 4. manipulate the integral surrounding indices if needed\n// (e.g., clip for border padding_mode)\nx_left = manipulate(x_left, padding_mode)\nx_right = manipulate(x_right, padding_mode)\n\n// 5. interpolate\noutput_val = interpolate(w_left, w_right, x_left, x_right)\n</code></pre>\n<p>This is actually incorrect (and also unintuitive) because it calculates the<br>\nweights before manipulate out-of-boundary indices. Fortunately, this<br>\nisn't manifested in both of the current supported modes, <code>'zeros'</code> and<br>\n<code>'border'</code> padding:</p>\n<ul>\n<li><code>'zeros'</code>: doesn't clip</li>\n<li><code>'border'</code>: clips, but for out-of-bound <code>x</code> both <code>x_left</code> and <code>x_right</code> are<br>\nclipped to the same value, so weights don't matter</li>\n</ul>\n<p>But this is a problem with reflection padding, since after each time we reflect,<br>\nthe values of <code>w_left</code> and <code>w_right</code> should be swapped.</p>\n<p>So in this commit I change the algorithm to (numbers corresponding to the<br>\nordering in the above pseudo-code)</p>\n<pre><code>1. get float location\n4. clip the float location \n2. find the integral surrounding indices\n3. calculate the linear interpolate weights\n</code></pre>\n<p>In the backward, because of this change, I need to add new variables to track<br>\n<code>d manipulate_output / d manipulate_input</code>, which is basically a multiplier<br>\non the gradient calculated for <code>grid</code>. From benchmarking this addition doesn't<br>\ncause obvious slow downs.</p>\n</li>\n<li>\n<p>Implement reflection padding. The indices will keep being reflected until<br>\nthey become within boundary.</p>\n<p>Added variant of <code>clip_coordinates</code> and <code>reflect_coordinates</code> to be used in<br>\nbackward. E.g.,</p>\n<div class=\"highlight highlight-source-c++\"><pre><span class=\"pl-c\"><span class=\"pl-c\">//</span> clip_coordinates_set_grad works similarly to clip_coordinates except that</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> it also returns the `d output / d input` via pointer argument `grad_in`.</span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span> This is useful in the backward pass of grid_sampler.</span>\n<span class=\"pl-c1\">scalar_t</span> <span class=\"pl-en\">clip_coordinates_set_grad</span>(<span class=\"pl-c1\">scalar_t</span> in, <span class=\"pl-c1\">int64_t</span> clip_limit, <span class=\"pl-c1\">scalar_t</span> *grad_in)</pre></div>\n<p>For example, if <code>in</code> is clipped in <code>'border'</code> mode, <code>grad_in</code> is set to <code>0</code>.<br>\nIf <code>in</code> is reflected <strong>odd</strong> times in <code>'reflection'</code> mode, <code>grad_in</code><br>\nis set to <code>-1</code>.</p>\n</li>\n<li>\n<p>Implement nearest interpolation.</p>\n</li>\n<li>\n<p>Add test cases</p>\n</li>\n<li>\n<p>Add better input checking<br>\nDiscussed with <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=6429851\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/goldsborough\">@goldsborough</a> for moving <code>operator&lt;&lt;</code> of <code>at::Device</code>,<br>\n<code>at::DeviceType</code> and <code>at::Layout</code> into <code>at</code> namespace. (Otherwise<br>\n<code>AT_CHECK</code> can't find them.)</p>\n</li>\n<li>\n<p>Support empty tensors. cc <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=3768583\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/gchanan\">@gchanan</a></p>\n<ul>\n<li>Make empty tensors not acceptable by cudnn.</li>\n<li>Add <code>AT_ASSERT(kernel block size  &gt; 0)</code> if using <code>GET_BLOCKS</code></li>\n<li>Cache <code>numel</code> in <code>TensorGeometry</code><br>\nI was going to use <code>numel</code> to test if cudnn descriptor should accept a<br>\ntensor, but it isn't used eventually. I can revert this if needed.</li>\n</ul>\n</li>\n<li>\n<p>Add more test cases, including on input checking and empty tensors</p>\n</li>\n<li>\n<p>Remove an obsolete comment</p>\n</li>\n<li>\n<p>Update docs. Manually tested by generating docs.</p>\n</li>\n</ol>", "body_text": "closes #9702 .\ncc @jph00\nCommit structure:\n\n\nChange the index calculation logic. I will explain using 1-D for simplicity.\nPreviously we have (in pseudo code):\n// 1. get the float locations from grid\nscalar_t x = from_grid()\n\n// 2. find the integral surrounding indices\nint x_left = floor(x)\nint x_right = x_left + 1\n\n// 3. calculate the linear interpolate weights\nscalar_t w_left = x_right - x\nscalar_t w_right = x - x_left\n\n// 4. manipulate the integral surrounding indices if needed\n// (e.g., clip for border padding_mode)\nx_left = manipulate(x_left, padding_mode)\nx_right = manipulate(x_right, padding_mode)\n\n// 5. interpolate\noutput_val = interpolate(w_left, w_right, x_left, x_right)\n\nThis is actually incorrect (and also unintuitive) because it calculates the\nweights before manipulate out-of-boundary indices. Fortunately, this\nisn't manifested in both of the current supported modes, 'zeros' and\n'border' padding:\n\n'zeros': doesn't clip\n'border': clips, but for out-of-bound x both x_left and x_right are\nclipped to the same value, so weights don't matter\n\nBut this is a problem with reflection padding, since after each time we reflect,\nthe values of w_left and w_right should be swapped.\nSo in this commit I change the algorithm to (numbers corresponding to the\nordering in the above pseudo-code)\n1. get float location\n4. clip the float location \n2. find the integral surrounding indices\n3. calculate the linear interpolate weights\n\nIn the backward, because of this change, I need to add new variables to track\nd manipulate_output / d manipulate_input, which is basically a multiplier\non the gradient calculated for grid. From benchmarking this addition doesn't\ncause obvious slow downs.\n\n\nImplement reflection padding. The indices will keep being reflected until\nthey become within boundary.\nAdded variant of clip_coordinates and reflect_coordinates to be used in\nbackward. E.g.,\n// clip_coordinates_set_grad works similarly to clip_coordinates except that\n// it also returns the `d output / d input` via pointer argument `grad_in`.\n// This is useful in the backward pass of grid_sampler.\nscalar_t clip_coordinates_set_grad(scalar_t in, int64_t clip_limit, scalar_t *grad_in)\nFor example, if in is clipped in 'border' mode, grad_in is set to 0.\nIf in is reflected odd times in 'reflection' mode, grad_in\nis set to -1.\n\n\nImplement nearest interpolation.\n\n\nAdd test cases\n\n\nAdd better input checking\nDiscussed with @goldsborough for moving operator<< of at::Device,\nat::DeviceType and at::Layout into at namespace. (Otherwise\nAT_CHECK can't find them.)\n\n\nSupport empty tensors. cc @gchanan\n\nMake empty tensors not acceptable by cudnn.\nAdd AT_ASSERT(kernel block size  > 0) if using GET_BLOCKS\nCache numel in TensorGeometry\nI was going to use numel to test if cudnn descriptor should accept a\ntensor, but it isn't used eventually. I can revert this if needed.\n\n\n\nAdd more test cases, including on input checking and empty tensors\n\n\nRemove an obsolete comment\n\n\nUpdate docs. Manually tested by generating docs.", "body": "closes #9702 .\r\n\r\ncc @jph00 \r\n\r\nCommit structure:\r\n\r\n1. Change the index calculation logic. I will explain using 1-D for simplicity.\r\n\r\n\tPreviously we have (in pseudo code):\r\n\r\n\t```\r\n\t// 1. get the float locations from grid\r\n\tscalar_t x = from_grid()\r\n\r\n\t// 2. find the integral surrounding indices\r\n\tint x_left = floor(x)\r\n\tint x_right = x_left + 1\r\n\r\n\t// 3. calculate the linear interpolate weights\r\n\tscalar_t w_left = x_right - x\r\n\tscalar_t w_right = x - x_left\r\n\r\n\t// 4. manipulate the integral surrounding indices if needed\r\n\t// (e.g., clip for border padding_mode)\r\n\tx_left = manipulate(x_left, padding_mode)\r\n\tx_right = manipulate(x_right, padding_mode)\r\n\r\n\t// 5. interpolate\r\n\toutput_val = interpolate(w_left, w_right, x_left, x_right)\r\n\t```\r\n\r\n\tThis is actually incorrect (and also unintuitive) because it calculates the \r\n\tweights before manipulate out-of-boundary indices. Fortunately, this \r\n\tisn't manifested in both of the current supported modes, `'zeros'` and \r\n\t`'border'` padding:\r\n\r\n\t+ `'zeros'`: doesn't clip\r\n\t+ `'border'`: clips, but for out-of-bound `x` both `x_left` and `x_right` are \r\n\t  clipped to the same value, so weights don't matter\r\n\r\n\tBut this is a problem with reflection padding, since after each time we reflect,\r\n\tthe values of `w_left` and `w_right` should be swapped.\r\n\r\n\tSo in this commit I change the algorithm to (numbers corresponding to the \r\n        ordering in the above pseudo-code)\r\n\r\n\t```\r\n\t1. get float location\r\n\t4. clip the float location \r\n\t2. find the integral surrounding indices\r\n\t3. calculate the linear interpolate weights\r\n\t```\r\n\r\n\tIn the backward, because of this change, I need to add new variables to track\r\n\t`d manipulate_output / d manipulate_input`, which is basically a multiplier\r\n\ton the gradient calculated for `grid`. From benchmarking this addition doesn't\r\n\tcause obvious slow downs.\r\n\r\n2. Implement reflection padding. The indices will keep being reflected until \r\n\tthey become within boundary.\r\n\r\n\tAdded variant of `clip_coordinates` and `reflect_coordinates` to be used in \r\n\tbackward. E.g.,\r\n\t```cpp\r\n\t// clip_coordinates_set_grad works similarly to clip_coordinates except that\r\n\t// it also returns the `d output / d input` via pointer argument `grad_in`.\r\n\t// This is useful in the backward pass of grid_sampler.\r\n\tscalar_t clip_coordinates_set_grad(scalar_t in, int64_t clip_limit, scalar_t *grad_in)\r\n\t```\r\n\tFor example, if `in` is clipped in `'border'` mode, `grad_in` is set to `0`.\r\n\tIf `in` is reflected **odd** times in `'reflection'` mode, `grad_in` \r\n\tis set to `-1`.\r\n\r\n3. Implement nearest interpolation.\r\n\r\n4. Add test cases\r\n\r\n5. Add better input checking\r\n  Discussed with @goldsborough for moving `operator<<` of `at::Device`, \r\n  `at::DeviceType` and `at::Layout` into `at` namespace. (Otherwise \r\n  `AT_CHECK` can't find them.)\r\n\r\n6. Support empty tensors. cc @gchanan\r\n\r\n    + Make empty tensors not acceptable by cudnn. \r\n    + Add `AT_ASSERT(kernel block size  > 0)` if using `GET_BLOCKS`\r\n   + Cache `numel` in `TensorGeometry`\r\n      I was going to use `numel` to test if cudnn descriptor should accept a\r\n      tensor, but it isn't used eventually. I can revert this if needed.\r\n\r\n7. Add more test cases, including on input checking and empty tensors\r\n\r\n8. Remove an obsolete comment\r\n\r\n9. Update docs. Manually tested by generating docs.\r\n\r\n"}