{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/366138753", "html_url": "https://github.com/pytorch/pytorch/issues/830#issuecomment-366138753", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/830", "id": 366138753, "node_id": "MDEyOklzc3VlQ29tbWVudDM2NjEzODc1Mw==", "user": {"login": "jekbradbury", "id": 11729078, "node_id": "MDQ6VXNlcjExNzI5MDc4", "avatar_url": "https://avatars2.githubusercontent.com/u/11729078?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jekbradbury", "html_url": "https://github.com/jekbradbury", "followers_url": "https://api.github.com/users/jekbradbury/followers", "following_url": "https://api.github.com/users/jekbradbury/following{/other_user}", "gists_url": "https://api.github.com/users/jekbradbury/gists{/gist_id}", "starred_url": "https://api.github.com/users/jekbradbury/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jekbradbury/subscriptions", "organizations_url": "https://api.github.com/users/jekbradbury/orgs", "repos_url": "https://api.github.com/users/jekbradbury/repos", "events_url": "https://api.github.com/users/jekbradbury/events{/privacy}", "received_events_url": "https://api.github.com/users/jekbradbury/received_events", "type": "User", "site_admin": false}, "created_at": "2018-02-16T04:02:42Z", "updated_at": "2018-02-16T04:02:42Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Yes, hoping to open source soon. Something like this works, allowing <code>x</code> to be either a <code>Variable</code> with batch size 1 or a <code>Batch</code> object where dimension 1 is variable-length; we statically analyze the loops (because different examples need to run through it different numbers of times) and have method overloads for everything else:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">class</span> <span class=\"pl-en\">BiRNN</span>(<span class=\"pl-e\">nn</span>.<span class=\"pl-e\">Module</span>):\n   <span class=\"pl-k\">def</span> <span class=\"pl-c1\">__init__</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>, <span class=\"pl-smi\">size</span>):\n      <span class=\"pl-c1\">super</span>().<span class=\"pl-c1\">__init__</span>()\n      <span class=\"pl-c1\">self</span>.fwd <span class=\"pl-k\">=</span> nn.RNNCell(size, size)\n      <span class=\"pl-c1\">self</span>.bwd <span class=\"pl-k\">=</span> nn.RNNCell(size, size)\n\n   <span class=\"pl-en\">@batch</span>\n   <span class=\"pl-k\">def</span> <span class=\"pl-en\">forward</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>, <span class=\"pl-smi\">x</span>):\n      h0 <span class=\"pl-k\">=</span> x.new(<span class=\"pl-c1\">1</span>, x.size(<span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>)).zero_()\n      h, fwd <span class=\"pl-k\">=</span> h0, []\n      <span class=\"pl-k\">for</span> xt <span class=\"pl-k\">in</span> x.unbind(<span class=\"pl-c1\">1</span>):\n         h <span class=\"pl-k\">=</span> <span class=\"pl-c1\">self</span>.fwd(xt, h)\n         fwd.append(h)\n      fwd <span class=\"pl-k\">=</span> F.stack(fwd, <span class=\"pl-c1\">1</span>)\n      h, bwd <span class=\"pl-k\">=</span> h0, []\n      <span class=\"pl-k\">for</span> xt <span class=\"pl-k\">in</span> <span class=\"pl-c1\">reversed</span>(x.unbind(<span class=\"pl-c1\">1</span>)):\n         h <span class=\"pl-k\">=</span> <span class=\"pl-c1\">self</span>.bwd(xt, h)\n         bwd.append(h)\n      bwd <span class=\"pl-k\">=</span> F.stack(<span class=\"pl-c1\">reversed</span>(bwd), <span class=\"pl-c1\">1</span>)\n      <span class=\"pl-k\">return</span> F.cat((fwd, bwd), <span class=\"pl-c1\">2</span>)</pre></div>", "body_text": "Yes, hoping to open source soon. Something like this works, allowing x to be either a Variable with batch size 1 or a Batch object where dimension 1 is variable-length; we statically analyze the loops (because different examples need to run through it different numbers of times) and have method overloads for everything else:\nclass BiRNN(nn.Module):\n   def __init__(self, size):\n      super().__init__()\n      self.fwd = nn.RNNCell(size, size)\n      self.bwd = nn.RNNCell(size, size)\n\n   @batch\n   def forward(self, x):\n      h0 = x.new(1, x.size(-1)).zero_()\n      h, fwd = h0, []\n      for xt in x.unbind(1):\n         h = self.fwd(xt, h)\n         fwd.append(h)\n      fwd = F.stack(fwd, 1)\n      h, bwd = h0, []\n      for xt in reversed(x.unbind(1)):\n         h = self.bwd(xt, h)\n         bwd.append(h)\n      bwd = F.stack(reversed(bwd), 1)\n      return F.cat((fwd, bwd), 2)", "body": "Yes, hoping to open source soon. Something like this works, allowing `x` to be either a `Variable` with batch size 1 or a `Batch` object where dimension 1 is variable-length; we statically analyze the loops (because different examples need to run through it different numbers of times) and have method overloads for everything else:\r\n```python\r\nclass BiRNN(nn.Module):\r\n   def __init__(self, size):\r\n      super().__init__()\r\n      self.fwd = nn.RNNCell(size, size)\r\n      self.bwd = nn.RNNCell(size, size)\r\n\r\n   @batch\r\n   def forward(self, x):\r\n      h0 = x.new(1, x.size(-1)).zero_()\r\n      h, fwd = h0, []\r\n      for xt in x.unbind(1):\r\n         h = self.fwd(xt, h)\r\n         fwd.append(h)\r\n      fwd = F.stack(fwd, 1)\r\n      h, bwd = h0, []\r\n      for xt in reversed(x.unbind(1)):\r\n         h = self.bwd(xt, h)\r\n         bwd.append(h)\r\n      bwd = F.stack(reversed(bwd), 1)\r\n      return F.cat((fwd, bwd), 2)\r\n```"}