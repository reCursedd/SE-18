{"url": "https://api.github.com/repos/pytorch/pytorch/issues/5820", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/5820/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/5820/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/5820/events", "html_url": "https://github.com/pytorch/pytorch/pull/5820", "id": 305697141, "node_id": "MDExOlB1bGxSZXF1ZXN0MTc1MzYxNjgx", "number": 5820, "title": "Namespaced symbols", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 679953983, "node_id": "MDU6TGFiZWw2Nzk5NTM5ODM=", "url": "https://api.github.com/repos/pytorch/pytorch/labels/jit", "name": "jit", "color": "c5def5", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2018-03-15T19:53:47Z", "updated_at": "2018-11-23T15:40:53Z", "closed_at": "2018-03-16T17:36:12Z", "author_association": "CONTRIBUTOR", "pull_request": {"url": "https://api.github.com/repos/pytorch/pytorch/pulls/5820", "html_url": "https://github.com/pytorch/pytorch/pull/5820", "diff_url": "https://github.com/pytorch/pytorch/pull/5820.diff", "patch_url": "https://github.com/pytorch/pytorch/pull/5820.patch"}, "body_html": "<ul>\n<li>\n<p>Our interned strings now have structure, \"ns::symname\" rather than just<br>\n\"symname\" before.  We support efficient namespace testing for uniques<br>\nby encoding the namespace in one byte in the Symbol internal representation.<br>\nSee torch/csrc/jit/interned_strings.h for a more in-depth implementation<br>\ndiscussion.</p>\n</li>\n<li>\n<p>All uses of ksymbol are now attr::symbol (or some appropriate namespace).<br>\nThe valid namespaces are prim, attr, onnx and aten.</p>\n</li>\n<li>\n<p>Symbol is bound in Python as a qualified string \"attr::symbol\", EXCEPT for the<br>\nattribute setting/getting API, whose symbols must always be attr<br>\nsymbols; they get special cased to assume strings are passed.<br>\nThere's a little bit of naughtiness in the implementation, maybe you know<br>\nhow to solve it.</p>\n</li>\n<li>\n<p>All ATen operators and nodes have built-in interned strings generated<br>\nfor them, so you should never have to write a string literal ever again.<br>\nThe tracing code is adjusted to use it.</p>\n</li>\n<li>\n<p>ONNX exporter now properly tests to see that all operators are in<br>\nonnx namespace before accepting the export.  This is way more<br>\nrobust than the previous exporter, which would be willing to<br>\nexport capitalized operators which were not actually ONNX operators.</p>\n</li>\n<li>\n<p>A slight organizational change for symbolic.py; this module now ONLY<br>\ncontains aten operators.  In particular, the exporter for Constant<br>\nhas moved into utils.py (along with Undefined, from the C++ side),<br>\nsince primitive ops get \"special treatment.\"</p>\n</li>\n<li>\n<p>The un-inplacing logic in recording is more robust, so that we don't<br>\ndelete a trailing underscore from <strong>and</strong>.  This never affected us<br>\nbefore because we didn't have any tests for it.</p>\n</li>\n</ul>\n<p>Signed-off-by: Edward Z. Yang <a href=\"mailto:ezyang@fb.com\">ezyang@fb.com</a></p>", "body_text": "Our interned strings now have structure, \"ns::symname\" rather than just\n\"symname\" before.  We support efficient namespace testing for uniques\nby encoding the namespace in one byte in the Symbol internal representation.\nSee torch/csrc/jit/interned_strings.h for a more in-depth implementation\ndiscussion.\n\n\nAll uses of ksymbol are now attr::symbol (or some appropriate namespace).\nThe valid namespaces are prim, attr, onnx and aten.\n\n\nSymbol is bound in Python as a qualified string \"attr::symbol\", EXCEPT for the\nattribute setting/getting API, whose symbols must always be attr\nsymbols; they get special cased to assume strings are passed.\nThere's a little bit of naughtiness in the implementation, maybe you know\nhow to solve it.\n\n\nAll ATen operators and nodes have built-in interned strings generated\nfor them, so you should never have to write a string literal ever again.\nThe tracing code is adjusted to use it.\n\n\nONNX exporter now properly tests to see that all operators are in\nonnx namespace before accepting the export.  This is way more\nrobust than the previous exporter, which would be willing to\nexport capitalized operators which were not actually ONNX operators.\n\n\nA slight organizational change for symbolic.py; this module now ONLY\ncontains aten operators.  In particular, the exporter for Constant\nhas moved into utils.py (along with Undefined, from the C++ side),\nsince primitive ops get \"special treatment.\"\n\n\nThe un-inplacing logic in recording is more robust, so that we don't\ndelete a trailing underscore from and.  This never affected us\nbefore because we didn't have any tests for it.\n\n\nSigned-off-by: Edward Z. Yang ezyang@fb.com", "body": "- Our interned strings now have structure, \"ns::symname\" rather than just\r\n  \"symname\" before.  We support efficient namespace testing for uniques\r\n  by encoding the namespace in one byte in the Symbol internal representation.\r\n  See torch/csrc/jit/interned_strings.h for a more in-depth implementation\r\n  discussion.\r\n\r\n- All uses of ksymbol are now attr::symbol (or some appropriate namespace).\r\n  The valid namespaces are prim, attr, onnx and aten.\r\n\r\n- Symbol is bound in Python as a qualified string \"attr::symbol\", EXCEPT for the\r\n  attribute setting/getting API, whose symbols must always be attr\r\n  symbols; they get special cased to assume strings are passed.\r\n  There's a little bit of naughtiness in the implementation, maybe you know\r\n  how to solve it.\r\n\r\n- All ATen operators and nodes have built-in interned strings generated\r\n  for them, so you should never have to write a string literal ever again.\r\n  The tracing code is adjusted to use it.\r\n\r\n- ONNX exporter now properly tests to see that all operators are in\r\n  onnx namespace before accepting the export.  This is way more\r\n  robust than the previous exporter, which would be willing to\r\n  export capitalized operators which were not actually ONNX operators.\r\n\r\n- A slight organizational change for symbolic.py; this module now ONLY\r\n  contains aten operators.  In particular, the exporter for Constant\r\n  has moved into utils.py (along with Undefined, from the C++ side),\r\n  since primitive ops get \"special treatment.\"\r\n\r\n- The un-inplacing logic in recording is more robust, so that we don't\r\n  delete a trailing underscore from __and__.  This never affected us\r\n  before because we didn't have any tests for it.\r\n\r\nSigned-off-by: Edward Z. Yang <ezyang@fb.com>"}