{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/313146257", "html_url": "https://github.com/pytorch/pytorch/pull/1912#issuecomment-313146257", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/1912", "id": 313146257, "node_id": "MDEyOklzc3VlQ29tbWVudDMxMzE0NjI1Nw==", "user": {"login": "colesbury", "id": 655866, "node_id": "MDQ6VXNlcjY1NTg2Ng==", "avatar_url": "https://avatars1.githubusercontent.com/u/655866?v=4", "gravatar_id": "", "url": "https://api.github.com/users/colesbury", "html_url": "https://github.com/colesbury", "followers_url": "https://api.github.com/users/colesbury/followers", "following_url": "https://api.github.com/users/colesbury/following{/other_user}", "gists_url": "https://api.github.com/users/colesbury/gists{/gist_id}", "starred_url": "https://api.github.com/users/colesbury/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/colesbury/subscriptions", "organizations_url": "https://api.github.com/users/colesbury/orgs", "repos_url": "https://api.github.com/users/colesbury/repos", "events_url": "https://api.github.com/users/colesbury/events{/privacy}", "received_events_url": "https://api.github.com/users/colesbury/received_events", "type": "User", "site_admin": false}, "created_at": "2017-07-05T15:55:57Z", "updated_at": "2017-07-05T15:56:33Z", "author_association": "MEMBER", "body_html": "<p>This looks generally good, but introduces a new pattern for connecting C++ objects and Python wrappers. The pattern in variable.h/python_variable.h is to have a \"weak\" <a href=\"https://github.com/pytorch/pytorch/blob/3748b6d3ebf3e7132453db61b25666d32e774e65/torch/csrc/autograd/variable.h#L100\">pointer</a> to the PyObject* and the Python object has a \"strong\" (owning) <a href=\"https://github.com/pytorch/pytorch/blob/3748b6d3ebf3e7132453db61b25666d32e774e65/torch/csrc/autograd/python_variable.h#L12\">reference</a> back to the C++ object.</p>\n<p>There's a few small differences between these patterns. For example, in the variable pattern, the wrapper object can be freed once there are no Python references to it. I'm not sure one pattern is overall better than the other.</p>\n<p>Mostly, I'm ambivalent about adding a new pattern for connecting C++ objects and their wrappers, when doing something different is not strictly necessary.</p>", "body_text": "This looks generally good, but introduces a new pattern for connecting C++ objects and Python wrappers. The pattern in variable.h/python_variable.h is to have a \"weak\" pointer to the PyObject* and the Python object has a \"strong\" (owning) reference back to the C++ object.\nThere's a few small differences between these patterns. For example, in the variable pattern, the wrapper object can be freed once there are no Python references to it. I'm not sure one pattern is overall better than the other.\nMostly, I'm ambivalent about adding a new pattern for connecting C++ objects and their wrappers, when doing something different is not strictly necessary.", "body": "This looks generally good, but introduces a new pattern for connecting C++ objects and Python wrappers. The pattern in variable.h/python_variable.h is to have a \"weak\" [pointer](https://github.com/pytorch/pytorch/blob/3748b6d3ebf3e7132453db61b25666d32e774e65/torch/csrc/autograd/variable.h#L100) to the PyObject* and the Python object has a \"strong\" (owning) [reference](https://github.com/pytorch/pytorch/blob/3748b6d3ebf3e7132453db61b25666d32e774e65/torch/csrc/autograd/python_variable.h#L12) back to the C++ object.\r\n\r\nThere's a few small differences between these patterns. For example, in the variable pattern, the wrapper object can be freed once there are no Python references to it. I'm not sure one pattern is overall better than the other.\r\n\r\nMostly, I'm ambivalent about adding a new pattern for connecting C++ objects and their wrappers, when doing something different is not strictly necessary."}