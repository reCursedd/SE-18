{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/293476384", "html_url": "https://github.com/pytorch/pytorch/issues/1240#issuecomment-293476384", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/1240", "id": 293476384, "node_id": "MDEyOklzc3VlQ29tbWVudDI5MzQ3NjM4NA==", "user": {"login": "eklitzke", "id": 2734, "node_id": "MDQ6VXNlcjI3MzQ=", "avatar_url": "https://avatars0.githubusercontent.com/u/2734?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eklitzke", "html_url": "https://github.com/eklitzke", "followers_url": "https://api.github.com/users/eklitzke/followers", "following_url": "https://api.github.com/users/eklitzke/following{/other_user}", "gists_url": "https://api.github.com/users/eklitzke/gists{/gist_id}", "starred_url": "https://api.github.com/users/eklitzke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eklitzke/subscriptions", "organizations_url": "https://api.github.com/users/eklitzke/orgs", "repos_url": "https://api.github.com/users/eklitzke/repos", "events_url": "https://api.github.com/users/eklitzke/events{/privacy}", "received_events_url": "https://api.github.com/users/eklitzke/received_events", "type": "User", "site_admin": false}, "created_at": "2017-04-12T05:17:51Z", "updated_at": "2017-04-12T05:17:51Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Earlier I posted a comment to <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"221029518\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/1233\" data-hovercard-type=\"issue\" data-hovercard-url=\"/pytorch/pytorch/issues/1233/hovercard\" href=\"https://github.com/pytorch/pytorch/issues/1233\">#1233</a> about a segfault I was seeing, but it now seems like the segfault I was seeing there is actually related to the Intel MKL bug I see here. I'm deleting the comment in the other issue since I now think it's unrelated to the glibc deadlock issue. For reference though, here's the backtrace I had posted in that comment:</p>\n<pre><code>(gdb) bt\n#0  0x00007f9aefb09125 in _int_malloc (av=av@entry=0x7f9ac4000020, bytes=bytes@entry=32) at malloc.c:3449\n#1  0x00007f9aefb0c9f8 in __GI___libc_malloc (bytes=32) at malloc.c:2890\n#2  0x00007f9af0eac455 in allocate_dtv_entry (size=32, alignment=8) at dl-tls.c:591\n#3  allocate_and_init (map=0x1fa0e30) at dl-tls.c:616\n#4  tls_get_addr_tail (ti=0x7f9adf7124a8, dtv=0x23f4e10, the_map=0x1fa0e30) at dl-tls.c:796\n#5  0x00007f9adf47100c in __cxa_get_globals () from /home/evan/miniconda3/lib/libstdc++.so.6\n#6  0x00007f9adf472009 in __cxa_current_exception_type () from /home/evan/miniconda3/lib/libstdc++.so.6\n#7  0x00007f9adf473a81 in __gnu_cxx::__verbose_terminate_handler() () from /home/evan/miniconda3/lib/libstdc++.so.6\n#8  0x00007f9adf471d56 in ?? () from /home/evan/miniconda3/lib/libstdc++.so.6\n#9  0x00007f9adf471d83 in std::terminate() () from /home/evan/miniconda3/lib/libstdc++.so.6\n#10 0x00007f9adf4719d7 in __gxx_personality_v0 () from /home/evan/miniconda3/lib/libstdc++.so.6\n#11 0x00007f9ae3c25974 in _Unwind_ForcedUnwind_Phase2 (exc=exc@entry=0x7f9ad8d57d70, context=context@entry=0x7f9ad8d56ce0) at ../.././libgcc/unwind.inc:175\n#12 0x00007f9ae3c25cc4 in _Unwind_ForcedUnwind (exc=0x7f9ad8d57d70, stop=stop@entry=0x7f9af0786bc0 &lt;unwind_stop&gt;, stop_argument=&lt;optimized out&gt;)\n    at ../.././libgcc/unwind.inc:207\n#13 0x00007f9af0786d50 in __GI___pthread_unwind (buf=&lt;optimized out&gt;) at unwind.c:121\n#14 0x00007f9af077e6e5 in __do_cancel () at pthreadP.h:297\n#15 __pthread_exit (value=&lt;optimized out&gt;) at pthread_exit.c:28\n#16 0x00007f9af0b25f3f in PyThread_exit_thread () at Python/thread_pthread.h:266\n#17 0x00007f9af0adb129 in PyEval_RestoreThread (tstate=0x7f9ac40008c0) at Python/ceval.c:372\n#18 0x00007f9af0b0c870 in PyGILState_Ensure () at Python/pystate.c:849\n#19 0x00007f9ae0b28a1f in AutoGIL::AutoGIL (this=&lt;synthetic pointer&gt;) at /home/evan/code/pytorch/torch/csrc/utils/auto_gil.h:9\n#20 Decref::operator() (this=&lt;optimized out&gt;, p=0x7f9ad8d73878) at torch/csrc/autograd/python_function.cpp:836\n#21 std::_Sp_counted_deleter&lt;torch::autograd::PyFunction*, Decref, std::allocator&lt;int&gt;, (__gnu_cxx::_Lock_policy)2&gt;::_M_dispose (this=&lt;optimized out&gt;)\n    at /home/evan/miniconda3/gcc/include/c++/bits/shared_ptr_base.h:347\n#22 0x00007f9ae0b1de24 in std::_Sp_counted_base&lt;(__gnu_cxx::_Lock_policy)2&gt;::_M_release (this=0x24104c0)\n    at /home/evan/miniconda3/gcc/include/c++/bits/shared_ptr_base.h:144\n#23 std::__shared_count&lt;(__gnu_cxx::_Lock_policy)2&gt;::~__shared_count (this=0x7f9ad8d56eb0, __in_chrg=&lt;optimized out&gt;)\n    at /home/evan/miniconda3/gcc/include/c++/bits/shared_ptr_base.h:546\n#24 std::__shared_ptr&lt;torch::autograd::Function, (__gnu_cxx::_Lock_policy)2&gt;::~__shared_ptr (this=0x7f9ad8d56ea8, __in_chrg=&lt;optimized out&gt;)\n    at /home/evan/miniconda3/gcc/include/c++/bits/shared_ptr_base.h:781\n#25 std::shared_ptr&lt;torch::autograd::Function&gt;::~shared_ptr (this=0x7f9ad8d56ea8, __in_chrg=&lt;optimized out&gt;) at /home/evan/miniconda3/gcc/include/c++/bits/shared_ptr.h:93\n#26 torch::autograd::FunctionTask::~FunctionTask (this=0x7f9ad8d56ea0, __in_chrg=&lt;optimized out&gt;) at torch/csrc/autograd/engine.cpp:25\n#27 torch::autograd::Engine::thread_main (this=this@entry=0x7f9ae0e5a1c0 &lt;engine&gt;, queue=...) at torch/csrc/autograd/engine.cpp:104\n#28 0x00007f9ae0b2dd3a in PythonEngine::thread_main (this=0x7f9ae0e5a1c0 &lt;engine&gt;, queue=...) at torch/csrc/autograd/python_engine.cpp:21\n#29 0x00007f9adf4c8920 in ?? () from /home/evan/miniconda3/lib/libstdc++.so.6\n#30 0x00007f9af077d36d in start_thread (arg=0x7f9ad8d57700) at pthread_create.c:456\n</code></pre>\n<p>I don't have the source code for the original program at hand but caused this issue, but here's what makes me think it's the same thing I reported above. First, they are both segfaulting in malloc. Second, right before the malloc segfault there is a line about <code>allocate_dtv_entry</code> attributed to <code>dl-tls.c</code>. This matches with the segfault for the test case I showed above, where Valgrind is reporting accesses to uninitialized memory from a code path using <code>libdl.so</code>. So I suspect that if I were to valgrind the model I had that caused the backtrace shown here, it would also show uninitialized memory accesses coming from <code>libdl.so</code>.</p>\n<p>Pure speculation here, but can you confirm that Intel MKL is exception safe? Both of these backtraces involve C++ exceptions, which is why I ask.</p>", "body_text": "Earlier I posted a comment to #1233 about a segfault I was seeing, but it now seems like the segfault I was seeing there is actually related to the Intel MKL bug I see here. I'm deleting the comment in the other issue since I now think it's unrelated to the glibc deadlock issue. For reference though, here's the backtrace I had posted in that comment:\n(gdb) bt\n#0  0x00007f9aefb09125 in _int_malloc (av=av@entry=0x7f9ac4000020, bytes=bytes@entry=32) at malloc.c:3449\n#1  0x00007f9aefb0c9f8 in __GI___libc_malloc (bytes=32) at malloc.c:2890\n#2  0x00007f9af0eac455 in allocate_dtv_entry (size=32, alignment=8) at dl-tls.c:591\n#3  allocate_and_init (map=0x1fa0e30) at dl-tls.c:616\n#4  tls_get_addr_tail (ti=0x7f9adf7124a8, dtv=0x23f4e10, the_map=0x1fa0e30) at dl-tls.c:796\n#5  0x00007f9adf47100c in __cxa_get_globals () from /home/evan/miniconda3/lib/libstdc++.so.6\n#6  0x00007f9adf472009 in __cxa_current_exception_type () from /home/evan/miniconda3/lib/libstdc++.so.6\n#7  0x00007f9adf473a81 in __gnu_cxx::__verbose_terminate_handler() () from /home/evan/miniconda3/lib/libstdc++.so.6\n#8  0x00007f9adf471d56 in ?? () from /home/evan/miniconda3/lib/libstdc++.so.6\n#9  0x00007f9adf471d83 in std::terminate() () from /home/evan/miniconda3/lib/libstdc++.so.6\n#10 0x00007f9adf4719d7 in __gxx_personality_v0 () from /home/evan/miniconda3/lib/libstdc++.so.6\n#11 0x00007f9ae3c25974 in _Unwind_ForcedUnwind_Phase2 (exc=exc@entry=0x7f9ad8d57d70, context=context@entry=0x7f9ad8d56ce0) at ../.././libgcc/unwind.inc:175\n#12 0x00007f9ae3c25cc4 in _Unwind_ForcedUnwind (exc=0x7f9ad8d57d70, stop=stop@entry=0x7f9af0786bc0 <unwind_stop>, stop_argument=<optimized out>)\n    at ../.././libgcc/unwind.inc:207\n#13 0x00007f9af0786d50 in __GI___pthread_unwind (buf=<optimized out>) at unwind.c:121\n#14 0x00007f9af077e6e5 in __do_cancel () at pthreadP.h:297\n#15 __pthread_exit (value=<optimized out>) at pthread_exit.c:28\n#16 0x00007f9af0b25f3f in PyThread_exit_thread () at Python/thread_pthread.h:266\n#17 0x00007f9af0adb129 in PyEval_RestoreThread (tstate=0x7f9ac40008c0) at Python/ceval.c:372\n#18 0x00007f9af0b0c870 in PyGILState_Ensure () at Python/pystate.c:849\n#19 0x00007f9ae0b28a1f in AutoGIL::AutoGIL (this=<synthetic pointer>) at /home/evan/code/pytorch/torch/csrc/utils/auto_gil.h:9\n#20 Decref::operator() (this=<optimized out>, p=0x7f9ad8d73878) at torch/csrc/autograd/python_function.cpp:836\n#21 std::_Sp_counted_deleter<torch::autograd::PyFunction*, Decref, std::allocator<int>, (__gnu_cxx::_Lock_policy)2>::_M_dispose (this=<optimized out>)\n    at /home/evan/miniconda3/gcc/include/c++/bits/shared_ptr_base.h:347\n#22 0x00007f9ae0b1de24 in std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::_M_release (this=0x24104c0)\n    at /home/evan/miniconda3/gcc/include/c++/bits/shared_ptr_base.h:144\n#23 std::__shared_count<(__gnu_cxx::_Lock_policy)2>::~__shared_count (this=0x7f9ad8d56eb0, __in_chrg=<optimized out>)\n    at /home/evan/miniconda3/gcc/include/c++/bits/shared_ptr_base.h:546\n#24 std::__shared_ptr<torch::autograd::Function, (__gnu_cxx::_Lock_policy)2>::~__shared_ptr (this=0x7f9ad8d56ea8, __in_chrg=<optimized out>)\n    at /home/evan/miniconda3/gcc/include/c++/bits/shared_ptr_base.h:781\n#25 std::shared_ptr<torch::autograd::Function>::~shared_ptr (this=0x7f9ad8d56ea8, __in_chrg=<optimized out>) at /home/evan/miniconda3/gcc/include/c++/bits/shared_ptr.h:93\n#26 torch::autograd::FunctionTask::~FunctionTask (this=0x7f9ad8d56ea0, __in_chrg=<optimized out>) at torch/csrc/autograd/engine.cpp:25\n#27 torch::autograd::Engine::thread_main (this=this@entry=0x7f9ae0e5a1c0 <engine>, queue=...) at torch/csrc/autograd/engine.cpp:104\n#28 0x00007f9ae0b2dd3a in PythonEngine::thread_main (this=0x7f9ae0e5a1c0 <engine>, queue=...) at torch/csrc/autograd/python_engine.cpp:21\n#29 0x00007f9adf4c8920 in ?? () from /home/evan/miniconda3/lib/libstdc++.so.6\n#30 0x00007f9af077d36d in start_thread (arg=0x7f9ad8d57700) at pthread_create.c:456\n\nI don't have the source code for the original program at hand but caused this issue, but here's what makes me think it's the same thing I reported above. First, they are both segfaulting in malloc. Second, right before the malloc segfault there is a line about allocate_dtv_entry attributed to dl-tls.c. This matches with the segfault for the test case I showed above, where Valgrind is reporting accesses to uninitialized memory from a code path using libdl.so. So I suspect that if I were to valgrind the model I had that caused the backtrace shown here, it would also show uninitialized memory accesses coming from libdl.so.\nPure speculation here, but can you confirm that Intel MKL is exception safe? Both of these backtraces involve C++ exceptions, which is why I ask.", "body": "Earlier I posted a comment to #1233 about a segfault I was seeing, but it now seems like the segfault I was seeing there is actually related to the Intel MKL bug I see here. I'm deleting the comment in the other issue since I now think it's unrelated to the glibc deadlock issue. For reference though, here's the backtrace I had posted in that comment:\r\n\r\n```\r\n(gdb) bt\r\n#0  0x00007f9aefb09125 in _int_malloc (av=av@entry=0x7f9ac4000020, bytes=bytes@entry=32) at malloc.c:3449\r\n#1  0x00007f9aefb0c9f8 in __GI___libc_malloc (bytes=32) at malloc.c:2890\r\n#2  0x00007f9af0eac455 in allocate_dtv_entry (size=32, alignment=8) at dl-tls.c:591\r\n#3  allocate_and_init (map=0x1fa0e30) at dl-tls.c:616\r\n#4  tls_get_addr_tail (ti=0x7f9adf7124a8, dtv=0x23f4e10, the_map=0x1fa0e30) at dl-tls.c:796\r\n#5  0x00007f9adf47100c in __cxa_get_globals () from /home/evan/miniconda3/lib/libstdc++.so.6\r\n#6  0x00007f9adf472009 in __cxa_current_exception_type () from /home/evan/miniconda3/lib/libstdc++.so.6\r\n#7  0x00007f9adf473a81 in __gnu_cxx::__verbose_terminate_handler() () from /home/evan/miniconda3/lib/libstdc++.so.6\r\n#8  0x00007f9adf471d56 in ?? () from /home/evan/miniconda3/lib/libstdc++.so.6\r\n#9  0x00007f9adf471d83 in std::terminate() () from /home/evan/miniconda3/lib/libstdc++.so.6\r\n#10 0x00007f9adf4719d7 in __gxx_personality_v0 () from /home/evan/miniconda3/lib/libstdc++.so.6\r\n#11 0x00007f9ae3c25974 in _Unwind_ForcedUnwind_Phase2 (exc=exc@entry=0x7f9ad8d57d70, context=context@entry=0x7f9ad8d56ce0) at ../.././libgcc/unwind.inc:175\r\n#12 0x00007f9ae3c25cc4 in _Unwind_ForcedUnwind (exc=0x7f9ad8d57d70, stop=stop@entry=0x7f9af0786bc0 <unwind_stop>, stop_argument=<optimized out>)\r\n    at ../.././libgcc/unwind.inc:207\r\n#13 0x00007f9af0786d50 in __GI___pthread_unwind (buf=<optimized out>) at unwind.c:121\r\n#14 0x00007f9af077e6e5 in __do_cancel () at pthreadP.h:297\r\n#15 __pthread_exit (value=<optimized out>) at pthread_exit.c:28\r\n#16 0x00007f9af0b25f3f in PyThread_exit_thread () at Python/thread_pthread.h:266\r\n#17 0x00007f9af0adb129 in PyEval_RestoreThread (tstate=0x7f9ac40008c0) at Python/ceval.c:372\r\n#18 0x00007f9af0b0c870 in PyGILState_Ensure () at Python/pystate.c:849\r\n#19 0x00007f9ae0b28a1f in AutoGIL::AutoGIL (this=<synthetic pointer>) at /home/evan/code/pytorch/torch/csrc/utils/auto_gil.h:9\r\n#20 Decref::operator() (this=<optimized out>, p=0x7f9ad8d73878) at torch/csrc/autograd/python_function.cpp:836\r\n#21 std::_Sp_counted_deleter<torch::autograd::PyFunction*, Decref, std::allocator<int>, (__gnu_cxx::_Lock_policy)2>::_M_dispose (this=<optimized out>)\r\n    at /home/evan/miniconda3/gcc/include/c++/bits/shared_ptr_base.h:347\r\n#22 0x00007f9ae0b1de24 in std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::_M_release (this=0x24104c0)\r\n    at /home/evan/miniconda3/gcc/include/c++/bits/shared_ptr_base.h:144\r\n#23 std::__shared_count<(__gnu_cxx::_Lock_policy)2>::~__shared_count (this=0x7f9ad8d56eb0, __in_chrg=<optimized out>)\r\n    at /home/evan/miniconda3/gcc/include/c++/bits/shared_ptr_base.h:546\r\n#24 std::__shared_ptr<torch::autograd::Function, (__gnu_cxx::_Lock_policy)2>::~__shared_ptr (this=0x7f9ad8d56ea8, __in_chrg=<optimized out>)\r\n    at /home/evan/miniconda3/gcc/include/c++/bits/shared_ptr_base.h:781\r\n#25 std::shared_ptr<torch::autograd::Function>::~shared_ptr (this=0x7f9ad8d56ea8, __in_chrg=<optimized out>) at /home/evan/miniconda3/gcc/include/c++/bits/shared_ptr.h:93\r\n#26 torch::autograd::FunctionTask::~FunctionTask (this=0x7f9ad8d56ea0, __in_chrg=<optimized out>) at torch/csrc/autograd/engine.cpp:25\r\n#27 torch::autograd::Engine::thread_main (this=this@entry=0x7f9ae0e5a1c0 <engine>, queue=...) at torch/csrc/autograd/engine.cpp:104\r\n#28 0x00007f9ae0b2dd3a in PythonEngine::thread_main (this=0x7f9ae0e5a1c0 <engine>, queue=...) at torch/csrc/autograd/python_engine.cpp:21\r\n#29 0x00007f9adf4c8920 in ?? () from /home/evan/miniconda3/lib/libstdc++.so.6\r\n#30 0x00007f9af077d36d in start_thread (arg=0x7f9ad8d57700) at pthread_create.c:456\r\n```\r\n\r\nI don't have the source code for the original program at hand but caused this issue, but here's what makes me think it's the same thing I reported above. First, they are both segfaulting in malloc. Second, right before the malloc segfault there is a line about `allocate_dtv_entry` attributed to `dl-tls.c`. This matches with the segfault for the test case I showed above, where Valgrind is reporting accesses to uninitialized memory from a code path using `libdl.so`. So I suspect that if I were to valgrind the model I had that caused the backtrace shown here, it would also show uninitialized memory accesses coming from `libdl.so`.\r\n\r\nPure speculation here, but can you confirm that Intel MKL is exception safe? Both of these backtraces involve C++ exceptions, which is why I ask."}