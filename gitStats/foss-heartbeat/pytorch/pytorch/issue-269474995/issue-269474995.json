{"url": "https://api.github.com/repos/pytorch/pytorch/issues/3359", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/3359/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/3359/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/3359/events", "html_url": "https://github.com/pytorch/pytorch/pull/3359", "id": 269474995, "node_id": "MDExOlB1bGxSZXF1ZXN0MTQ5NDMxNzE0", "number": 3359, "title": "Improve const-correctness of JIT / fix bug where ONNX verbose=1 export says the wrong thing", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 679953983, "node_id": "MDU6TGFiZWw2Nzk5NTM5ODM=", "url": "https://api.github.com/repos/pytorch/pytorch/labels/jit", "name": "jit", "color": "c5def5", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 7, "created_at": "2017-10-30T03:55:24Z", "updated_at": "2018-11-23T15:35:51Z", "closed_at": "2017-11-01T13:49:54Z", "author_association": "CONTRIBUTOR", "pull_request": {"url": "https://api.github.com/repos/pytorch/pytorch/pulls/3359", "html_url": "https://github.com/pytorch/pytorch/pull/3359", "diff_url": "https://github.com/pytorch/pytorch/pull/3359.diff", "patch_url": "https://github.com/pytorch/pytorch/pull/3359.patch"}, "body_html": "<p>This started off as a minor fix based on Adam's question, \"why is printing<br>\na graph not const\" and snowballed into a giant yak shaving exercise.</p>\n<ul>\n<li>\n<p>The Graph and Node APIs now uniformly enforce deep constness; e.g., if you<br>\nget a const Node* or const Graph*, it is not possible to get a non-const<br>\nNode*/Graph* somewhere else in the graph (even though the member variables<br>\nof these are non-const.  Hooray for private access specifier.)</p>\n</li>\n<li>\n<p>A big pile of functions got const versions, most notably the printing<br>\nfunctions, and functions for accessing inputs().</p>\n</li>\n<li>\n<p>REALLY IMPORTANT, BC-BREAKING CHANGE: inputs() now returns a COPY of the<br>\ninputs, rather than a reference to the underlying.  I was forced to do this<br>\nbecause there is no way to portably turn a std::vector&lt;Node*&gt; into a<br>\nstd::vector&lt;const Node*&gt;, which is necessary to provide a const-correct<br>\nversion of inputs() that enforces deep const-correctness.  I then justified<br>\nthis choice to myself with the observation that outputs() returned a<br>\ncopy (by necessity), so this makes the API more uniform.</p>\n<p>But making this change uncovered two very subtle bugs:</p>\n<ol>\n<li>\n<p>If you change functions from returning a reference to returning a copy,<br>\nthe idiom node-&gt;inputs().begin() is no longer valid, because the memory<br>\nthe iterator points to immediately becomes invalid.  THIS SUCKS.<br>\nHonestly, we should add a lint rule rejecting calling begin()/end() on<br>\ntemporaries because this is very dangerous.  To excise this pattern from<br>\nthe codebase, I added begin() and end() methods to Graph, so that we got<br>\nrid of the graph-&gt;nodes().begin() idiom, which happens to be sound,<br>\ndespite not returning a reference, because graph_node_list is a<br>\nnon-owning reference.</p>\n</li>\n<li>\n<p>pybind11 doesn't handle std::vector&lt;Node*&gt; cast out of the box.<br>\nFortunately, I found a simple fix in the GitHub issues tracker<br>\nthat involved adding an extra type converter.  And yes, this<br>\ndoes mean that outputs() in Python never worked correctly.</p>\n</li>\n</ol>\n</li>\n<li>\n<p>New const_graph_node_list, which is a graph_node_list that gives you const<br>\nNode*</p>\n</li>\n</ul>\n<p>There are some more miscellaneous improvements:</p>\n<ul>\n<li>\n<p>Applied CR comment fixes on export.cpp; using replaceInput, and renaming<br>\nvariables for clarity.</p>\n</li>\n<li>\n<p>assertValidInput helper method added, and applied to replaceInput</p>\n</li>\n</ul>\n<p>Signed-off-by: Edward Z. Yang <a href=\"mailto:ezyang@fb.com\">ezyang@fb.com</a></p>", "body_text": "This started off as a minor fix based on Adam's question, \"why is printing\na graph not const\" and snowballed into a giant yak shaving exercise.\n\n\nThe Graph and Node APIs now uniformly enforce deep constness; e.g., if you\nget a const Node* or const Graph*, it is not possible to get a non-const\nNode*/Graph* somewhere else in the graph (even though the member variables\nof these are non-const.  Hooray for private access specifier.)\n\n\nA big pile of functions got const versions, most notably the printing\nfunctions, and functions for accessing inputs().\n\n\nREALLY IMPORTANT, BC-BREAKING CHANGE: inputs() now returns a COPY of the\ninputs, rather than a reference to the underlying.  I was forced to do this\nbecause there is no way to portably turn a std::vector<Node*> into a\nstd::vector<const Node*>, which is necessary to provide a const-correct\nversion of inputs() that enforces deep const-correctness.  I then justified\nthis choice to myself with the observation that outputs() returned a\ncopy (by necessity), so this makes the API more uniform.\nBut making this change uncovered two very subtle bugs:\n\n\nIf you change functions from returning a reference to returning a copy,\nthe idiom node->inputs().begin() is no longer valid, because the memory\nthe iterator points to immediately becomes invalid.  THIS SUCKS.\nHonestly, we should add a lint rule rejecting calling begin()/end() on\ntemporaries because this is very dangerous.  To excise this pattern from\nthe codebase, I added begin() and end() methods to Graph, so that we got\nrid of the graph->nodes().begin() idiom, which happens to be sound,\ndespite not returning a reference, because graph_node_list is a\nnon-owning reference.\n\n\npybind11 doesn't handle std::vector<Node*> cast out of the box.\nFortunately, I found a simple fix in the GitHub issues tracker\nthat involved adding an extra type converter.  And yes, this\ndoes mean that outputs() in Python never worked correctly.\n\n\n\n\nNew const_graph_node_list, which is a graph_node_list that gives you const\nNode*\n\n\nThere are some more miscellaneous improvements:\n\n\nApplied CR comment fixes on export.cpp; using replaceInput, and renaming\nvariables for clarity.\n\n\nassertValidInput helper method added, and applied to replaceInput\n\n\nSigned-off-by: Edward Z. Yang ezyang@fb.com", "body": "This started off as a minor fix based on Adam's question, \"why is printing\r\na graph not const\" and snowballed into a giant yak shaving exercise.\r\n\r\n- The Graph and Node APIs now uniformly enforce deep constness; e.g., if you\r\n  get a const Node* or const Graph*, it is not possible to get a non-const\r\n  Node*/Graph* somewhere else in the graph (even though the member variables\r\n  of these are non-const.  Hooray for private access specifier.)\r\n\r\n- A big pile of functions got const versions, most notably the printing\r\n  functions, and functions for accessing inputs().\r\n\r\n- REALLY IMPORTANT, BC-BREAKING CHANGE: inputs() now returns a COPY of the\r\n  inputs, rather than a reference to the underlying.  I was forced to do this\r\n  because there is no way to portably turn a std::vector<Node*> into a\r\n  std::vector<const Node*>, which is necessary to provide a const-correct\r\n  version of inputs() that enforces deep const-correctness.  I then justified\r\n  this choice to myself with the observation that outputs() returned a\r\n  copy (by necessity), so this makes the API more uniform.\r\n\r\n  But making this change uncovered two very subtle bugs:\r\n\r\n    1. If you change functions from returning a reference to returning a copy,\r\n       the idiom node->inputs().begin() is no longer valid, because the memory\r\n       the iterator points to immediately becomes invalid.  THIS SUCKS.\r\n       Honestly, we should add a lint rule rejecting calling begin()/end() on\r\n       temporaries because this is very dangerous.  To excise this pattern from\r\n       the codebase, I added begin() and end() methods to Graph, so that we got\r\n       rid of the graph->nodes().begin() idiom, which happens to be sound,\r\n       despite not returning a reference, because graph_node_list is a\r\n       non-owning reference.\r\n\r\n    2. pybind11 doesn't handle std::vector<Node*> cast out of the box.\r\n       Fortunately, I found a simple fix in the GitHub issues tracker\r\n       that involved adding an extra type converter.  And yes, this\r\n       does mean that outputs() in Python never worked correctly.\r\n\r\n- New const_graph_node_list, which is a graph_node_list that gives you const\r\n  Node*\r\n\r\nThere are some more miscellaneous improvements:\r\n\r\n- Applied CR comment fixes on export.cpp; using replaceInput, and renaming\r\n  variables for clarity.\r\n\r\n- assertValidInput helper method added, and applied to replaceInput\r\n\r\nSigned-off-by: Edward Z. Yang <ezyang@fb.com>"}