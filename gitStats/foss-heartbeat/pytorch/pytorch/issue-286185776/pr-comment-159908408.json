{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/159908408", "pull_request_review_id": 86934790, "id": 159908408, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1OTkwODQwOA==", "diff_hunk": "@@ -66,21 +66,30 @@ __global__ void indexCopySmallIndex(TensorInfo<T, IndexType> dst,\n // the number of indices chosen is small, then the\n // indexCopySmallIndex kernel is a better choice to reduce memory\n // accesses.\n-template <typename T, typename IndexType, int DstDim, int SrcDim, int IdxDim>\n+template <typename T, typename IndexType, int DstDim, int SrcDim, int IdxDim,\n+          bool IndexIsMajor>\n __global__ void indexCopyLargeIndex(TensorInfo<T, IndexType> dst,\n                                     TensorInfo<T, IndexType> src,\n                                     TensorInfo<int64_t, IndexType> indices,\n                                     int dstCopyDim,\n                                     int srcCopyDim,\n+                                    IndexType totalSize,\n                                     IndexType innerSize,\n                                     int64_t dstCopyDimSize) {\n   // We stride over the output including the indexed dimension\n   // (totalSize), and calculate the destination index point based on that\n   for (IndexType linearIndex = blockIdx.x * blockDim.x + threadIdx.x;\n-       linearIndex < innerSize * indices.sizes[0];\n+       linearIndex < totalSize;\n        linearIndex += gridDim.x * blockDim.x) {\n-    IndexType srcIndex = linearIndex / innerSize;\n-    IndexType elementInSlice = linearIndex % innerSize;\n+    IndexType srcIndex, elementInSlice;\n+    if (IndexIsMajor) {\n+      srcIndex = linearIndex / innerSize;\n+      elementInSlice = linearIndex % innerSize;\n+    }\n+    else {\n+      elementInSlice = linearIndex / innerSize;\n+      srcIndex = linearIndex % innerSize;", "path": "aten/src/THC/THCTensorIndex.cu", "position": 30, "original_position": 30, "commit_id": "4cc9ebb982e6d1b9764f6c9e7e5202819e0133f3", "original_commit_id": "4cc9ebb982e6d1b9764f6c9e7e5202819e0133f3", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "body": "If you're looking for more speedups in these kernels then removing this division and modulo will go a long way. I've seen that have a huge impact on (Log)Softmax kernels I wrote. A 2D grid with bounds check ended up being much faster.", "created_at": "2018-01-05T15:52:06Z", "updated_at": "2018-11-23T15:37:51Z", "html_url": "https://github.com/pytorch/pytorch/pull/4493#discussion_r159908408", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/4493", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/159908408"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/4493#discussion_r159908408"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/4493"}}, "body_html": "<p>If you're looking for more speedups in these kernels then removing this division and modulo will go a long way. I've seen that have a huge impact on (Log)Softmax kernels I wrote. A 2D grid with bounds check ended up being much faster.</p>", "body_text": "If you're looking for more speedups in these kernels then removing this division and modulo will go a long way. I've seen that have a huge impact on (Log)Softmax kernels I wrote. A 2D grid with bounds check ended up being much faster."}