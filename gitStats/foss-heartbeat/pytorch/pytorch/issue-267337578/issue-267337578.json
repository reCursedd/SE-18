{"url": "https://api.github.com/repos/pytorch/pytorch/issues/3213", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/3213/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/3213/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/3213/events", "html_url": "https://github.com/pytorch/pytorch/issues/3213", "id": 267337578, "node_id": "MDU6SXNzdWUyNjczMzc1Nzg=", "number": 3213, "title": "Weird semantics for torch.diag()", "user": {"login": "w4nderlust", "id": 349256, "node_id": "MDQ6VXNlcjM0OTI1Ng==", "avatar_url": "https://avatars1.githubusercontent.com/u/349256?v=4", "gravatar_id": "", "url": "https://api.github.com/users/w4nderlust", "html_url": "https://github.com/w4nderlust", "followers_url": "https://api.github.com/users/w4nderlust/followers", "following_url": "https://api.github.com/users/w4nderlust/following{/other_user}", "gists_url": "https://api.github.com/users/w4nderlust/gists{/gist_id}", "starred_url": "https://api.github.com/users/w4nderlust/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/w4nderlust/subscriptions", "organizations_url": "https://api.github.com/users/w4nderlust/orgs", "repos_url": "https://api.github.com/users/w4nderlust/repos", "events_url": "https://api.github.com/users/w4nderlust/events{/privacy}", "received_events_url": "https://api.github.com/users/w4nderlust/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2017-10-21T00:43:19Z", "updated_at": "2018-03-10T04:46:43Z", "closed_at": "2018-03-10T04:46:43Z", "author_association": "NONE", "body_html": "<p>The semantics of the function <code>torch.diag()</code> changes completely depending on the size of the inputs.<br>\nIt the input is a vector, it creates a matrix with that vector as diagonal. It the input is a matrix, it extracts it's diagonal and returns a vector.<br>\nThis is pretty weird to me, those should be two different functions. Also this doesn't consider a more than bi-dimensional case.</p>\n<p>Ideally one function would take a tensor of any dimension and return its diagonal. This could be called <code>extract_diag</code>.<br>\nThe other function should take a vector and a number of dimensions and should create a tensor with the number of dimensions specified with that vector as its diagonal. It should include also the actual offset parameter diagonal, maybe calling it offset would be easy to understand. This could be called <code>diag</code>.</p>", "body_text": "The semantics of the function torch.diag() changes completely depending on the size of the inputs.\nIt the input is a vector, it creates a matrix with that vector as diagonal. It the input is a matrix, it extracts it's diagonal and returns a vector.\nThis is pretty weird to me, those should be two different functions. Also this doesn't consider a more than bi-dimensional case.\nIdeally one function would take a tensor of any dimension and return its diagonal. This could be called extract_diag.\nThe other function should take a vector and a number of dimensions and should create a tensor with the number of dimensions specified with that vector as its diagonal. It should include also the actual offset parameter diagonal, maybe calling it offset would be easy to understand. This could be called diag.", "body": "The semantics of the function `torch.diag()` changes completely depending on the size of the inputs.\r\nIt the input is a vector, it creates a matrix with that vector as diagonal. It the input is a matrix, it extracts it's diagonal and returns a vector.\r\nThis is pretty weird to me, those should be two different functions. Also this doesn't consider a more than bi-dimensional case.\r\n\r\nIdeally one function would take a tensor of any dimension and return its diagonal. This could be called `extract_diag`.\r\nThe other function should take a vector and a number of dimensions and should create a tensor with the number of dimensions specified with that vector as its diagonal. It should include also the actual offset parameter diagonal, maybe calling it offset would be easy to understand. This could be called `diag`."}