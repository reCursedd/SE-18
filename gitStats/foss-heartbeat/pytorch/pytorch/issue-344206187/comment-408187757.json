{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/408187757", "html_url": "https://github.com/pytorch/pytorch/pull/9786#issuecomment-408187757", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/9786", "id": 408187757, "node_id": "MDEyOklzc3VlQ29tbWVudDQwODE4Nzc1Nw==", "user": {"login": "wanchaol", "id": 9443650, "node_id": "MDQ6VXNlcjk0NDM2NTA=", "avatar_url": "https://avatars2.githubusercontent.com/u/9443650?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wanchaol", "html_url": "https://github.com/wanchaol", "followers_url": "https://api.github.com/users/wanchaol/followers", "following_url": "https://api.github.com/users/wanchaol/following{/other_user}", "gists_url": "https://api.github.com/users/wanchaol/gists{/gist_id}", "starred_url": "https://api.github.com/users/wanchaol/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wanchaol/subscriptions", "organizations_url": "https://api.github.com/users/wanchaol/orgs", "repos_url": "https://api.github.com/users/wanchaol/repos", "events_url": "https://api.github.com/users/wanchaol/events{/privacy}", "received_events_url": "https://api.github.com/users/wanchaol/received_events", "type": "User", "site_admin": false}, "created_at": "2018-07-26T18:16:00Z", "updated_at": "2018-07-26T18:16:00Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=4583066\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/apaszke\">@apaszke</a> As of today in JIT, I am seeing everywhere we are using <code>std::make_shared&lt;Type&gt;</code>  for Tensor, List and Tuple type, and not using reference. Exposing both raw pointer and shared pointer is not ideal since it will cause undefined behaviors if we don't do it carefully, I think that's the main motivation we want to move to a single shared_pointer semantic. So for the issues:</p>\n<ol>\n<li>The only place we are using reference is when we have <code>isSubtypeOf</code>, and before the pr, we need to put * for most of the case like <code>x-&gt;isSubtypeOf(*NumberType::get())</code> , most arguments we used is a typePtr, so it's easy for us to just accept the typePtr instead. I think there's not too much equality concern since even for isSubtypeOf we are using the object to test the equality (which use the <code>operator==</code>) rather than pointer.</li>\n<li>I don't think we are singletons for different types, in fact we are creating a new type object and let a new shared pointer point to it whenever we need a type. So the lifetime of the object and the shared pointer is bounded by the usage of <code>XType::get()</code> .</li>\n<li>Yes they are nullable but people are using <code>make_shared</code> or <code>type::get()</code> everywhere for different types and they are nullable too.</li>\n</ol>", "body_text": "@apaszke As of today in JIT, I am seeing everywhere we are using std::make_shared<Type>  for Tensor, List and Tuple type, and not using reference. Exposing both raw pointer and shared pointer is not ideal since it will cause undefined behaviors if we don't do it carefully, I think that's the main motivation we want to move to a single shared_pointer semantic. So for the issues:\n\nThe only place we are using reference is when we have isSubtypeOf, and before the pr, we need to put * for most of the case like x->isSubtypeOf(*NumberType::get()) , most arguments we used is a typePtr, so it's easy for us to just accept the typePtr instead. I think there's not too much equality concern since even for isSubtypeOf we are using the object to test the equality (which use the operator==) rather than pointer.\nI don't think we are singletons for different types, in fact we are creating a new type object and let a new shared pointer point to it whenever we need a type. So the lifetime of the object and the shared pointer is bounded by the usage of XType::get() .\nYes they are nullable but people are using make_shared or type::get() everywhere for different types and they are nullable too.", "body": "@apaszke As of today in JIT, I am seeing everywhere we are using `std::make_shared<Type>`  for Tensor, List and Tuple type, and not using reference. Exposing both raw pointer and shared pointer is not ideal since it will cause undefined behaviors if we don't do it carefully, I think that's the main motivation we want to move to a single shared_pointer semantic. So for the issues:\r\n\r\n1. The only place we are using reference is when we have `isSubtypeOf`, and before the pr, we need to put * for most of the case like `x->isSubtypeOf(*NumberType::get())` , most arguments we used is a typePtr, so it's easy for us to just accept the typePtr instead. I think there's not too much equality concern since even for isSubtypeOf we are using the object to test the equality (which use the `operator==`) rather than pointer. \r\n2. I don't think we are singletons for different types, in fact we are creating a new type object and let a new shared pointer point to it whenever we need a type. So the lifetime of the object and the shared pointer is bounded by the usage of `XType::get()` . \r\n3. Yes they are nullable but people are using `make_shared` or `type::get()` everywhere for different types and they are nullable too. "}