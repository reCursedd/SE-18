{"url": "https://api.github.com/repos/pytorch/pytorch/issues/9214", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/9214/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/9214/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/9214/events", "html_url": "https://github.com/pytorch/pytorch/pull/9214", "id": 339048834, "node_id": "MDExOlB1bGxSZXF1ZXN0MTk5ODI5OTQ3", "number": 9214, "title": "Improving THCReduce.cuh's performance on latency-bound non-contiguous reductions", "user": {"login": "mcarilli", "id": 7799218, "node_id": "MDQ6VXNlcjc3OTkyMTg=", "avatar_url": "https://avatars0.githubusercontent.com/u/7799218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarilli", "html_url": "https://github.com/mcarilli", "followers_url": "https://api.github.com/users/mcarilli/followers", "following_url": "https://api.github.com/users/mcarilli/following{/other_user}", "gists_url": "https://api.github.com/users/mcarilli/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarilli/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarilli/subscriptions", "organizations_url": "https://api.github.com/users/mcarilli/orgs", "repos_url": "https://api.github.com/users/mcarilli/repos", "events_url": "https://api.github.com/users/mcarilli/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarilli/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": {"login": "colesbury", "id": 655866, "node_id": "MDQ6VXNlcjY1NTg2Ng==", "avatar_url": "https://avatars1.githubusercontent.com/u/655866?v=4", "gravatar_id": "", "url": "https://api.github.com/users/colesbury", "html_url": "https://github.com/colesbury", "followers_url": "https://api.github.com/users/colesbury/followers", "following_url": "https://api.github.com/users/colesbury/following{/other_user}", "gists_url": "https://api.github.com/users/colesbury/gists{/gist_id}", "starred_url": "https://api.github.com/users/colesbury/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/colesbury/subscriptions", "organizations_url": "https://api.github.com/users/colesbury/orgs", "repos_url": "https://api.github.com/users/colesbury/repos", "events_url": "https://api.github.com/users/colesbury/events{/privacy}", "received_events_url": "https://api.github.com/users/colesbury/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "colesbury", "id": 655866, "node_id": "MDQ6VXNlcjY1NTg2Ng==", "avatar_url": "https://avatars1.githubusercontent.com/u/655866?v=4", "gravatar_id": "", "url": "https://api.github.com/users/colesbury", "html_url": "https://github.com/colesbury", "followers_url": "https://api.github.com/users/colesbury/followers", "following_url": "https://api.github.com/users/colesbury/following{/other_user}", "gists_url": "https://api.github.com/users/colesbury/gists{/gist_id}", "starred_url": "https://api.github.com/users/colesbury/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/colesbury/subscriptions", "organizations_url": "https://api.github.com/users/colesbury/orgs", "repos_url": "https://api.github.com/users/colesbury/repos", "events_url": "https://api.github.com/users/colesbury/events{/privacy}", "received_events_url": "https://api.github.com/users/colesbury/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 4, "created_at": "2018-07-06T19:30:07Z", "updated_at": "2018-07-13T18:11:49Z", "closed_at": "2018-07-13T18:11:49Z", "author_association": "CONTRIBUTOR", "pull_request": {"url": "https://api.github.com/repos/pytorch/pytorch/pulls/9214", "html_url": "https://github.com/pytorch/pytorch/pull/9214", "diff_url": "https://github.com/pytorch/pytorch/pull/9214.diff", "patch_url": "https://github.com/pytorch/pytorch/pull/9214.patch"}, "body_html": "<p>This PR improves perfomance of (formerly) latency-bound non-contig-dim reduction kernels by up to 20X, while maintaining determinism.</p>\n<p>Currently, reducing across a non-contiguous dimension uses the parallelism exposed across the number of output elements.  This means that performance suffers if the number of output elements is small.  Example:</p>\n<pre><code>a = torch.cuda.FloatTensor(32768, 32)\na.sum(dim=0)\n</code></pre>\n<p>Before this PR, <code>a.sum</code>'s kernel (kernelReduceNoncontigDim_shared) took 138 microseconds on my machine.  The speed-of-light estimate (based on a bandwidth of 700 GB/s) should be around 6 microseconds.  After this PR's changes, <code>a.sum(dim=0)</code>'s kernel takes 6.9 microseconds on my machine.</p>\n<p>Christian implemented some nice logic to squeeze out better performance for cases like <code>a.sum</code> using intra-block and instruction-level parallelism across the dimension being reduced, but his kernel still only launched one block for every 32 output elements.  This was insufficient to saturate the device in many cases, like <code>a.sum</code> here (where only one block is launched).</p>\n<p>My PR adds block cooperation across the dimension being reduced.  Many blocks, instead of one block, help to reduce into each 32 output elements.  Internally, each block leverages all of Christian's nice logic to compute a partial reduction into a per-block staging buffer, then the last block to finish combines the results to compute the final output.</p>\n<p>Block cooperation does require THCudaMalloc-ing staging and semaphore buffers, so it's not always worthwhile.  I included a set of rough heuristics to decide when the kernel should choose to use block cooperation.  These heuristics are based on Python-side timings of calling sum() many times in a loop, and comparing to the old implementation.</p>\n<p>I tested a wide range of sizes (to determine heuristics) and as long as the number of output elements is greater than 16ish, I don't think there are any remaining pathological sizes where users will encounter unexpectedly poor performance.</p>", "body_text": "This PR improves perfomance of (formerly) latency-bound non-contig-dim reduction kernels by up to 20X, while maintaining determinism.\nCurrently, reducing across a non-contiguous dimension uses the parallelism exposed across the number of output elements.  This means that performance suffers if the number of output elements is small.  Example:\na = torch.cuda.FloatTensor(32768, 32)\na.sum(dim=0)\n\nBefore this PR, a.sum's kernel (kernelReduceNoncontigDim_shared) took 138 microseconds on my machine.  The speed-of-light estimate (based on a bandwidth of 700 GB/s) should be around 6 microseconds.  After this PR's changes, a.sum(dim=0)'s kernel takes 6.9 microseconds on my machine.\nChristian implemented some nice logic to squeeze out better performance for cases like a.sum using intra-block and instruction-level parallelism across the dimension being reduced, but his kernel still only launched one block for every 32 output elements.  This was insufficient to saturate the device in many cases, like a.sum here (where only one block is launched).\nMy PR adds block cooperation across the dimension being reduced.  Many blocks, instead of one block, help to reduce into each 32 output elements.  Internally, each block leverages all of Christian's nice logic to compute a partial reduction into a per-block staging buffer, then the last block to finish combines the results to compute the final output.\nBlock cooperation does require THCudaMalloc-ing staging and semaphore buffers, so it's not always worthwhile.  I included a set of rough heuristics to decide when the kernel should choose to use block cooperation.  These heuristics are based on Python-side timings of calling sum() many times in a loop, and comparing to the old implementation.\nI tested a wide range of sizes (to determine heuristics) and as long as the number of output elements is greater than 16ish, I don't think there are any remaining pathological sizes where users will encounter unexpectedly poor performance.", "body": "This PR improves perfomance of (formerly) latency-bound non-contig-dim reduction kernels by up to 20X, while maintaining determinism.\r\n\r\nCurrently, reducing across a non-contiguous dimension uses the parallelism exposed across the number of output elements.  This means that performance suffers if the number of output elements is small.  Example:\r\n```\r\na = torch.cuda.FloatTensor(32768, 32)\r\na.sum(dim=0)\r\n```\r\nBefore this PR, `a.sum`'s kernel (kernelReduceNoncontigDim_shared) took 138 microseconds on my machine.  The speed-of-light estimate (based on a bandwidth of 700 GB/s) should be around 6 microseconds.  After this PR's changes, `a.sum(dim=0)`'s kernel takes 6.9 microseconds on my machine. \r\n\r\nChristian implemented some nice logic to squeeze out better performance for cases like `a.sum` using intra-block and instruction-level parallelism across the dimension being reduced, but his kernel still only launched one block for every 32 output elements.  This was insufficient to saturate the device in many cases, like `a.sum` here (where only one block is launched).\r\n\r\nMy PR adds block cooperation across the dimension being reduced.  Many blocks, instead of one block, help to reduce into each 32 output elements.  Internally, each block leverages all of Christian's nice logic to compute a partial reduction into a per-block staging buffer, then the last block to finish combines the results to compute the final output. \r\n\r\nBlock cooperation does require THCudaMalloc-ing staging and semaphore buffers, so it's not always worthwhile.  I included a set of rough heuristics to decide when the kernel should choose to use block cooperation.  These heuristics are based on Python-side timings of calling sum() many times in a loop, and comparing to the old implementation.\r\n\r\n I tested a wide range of sizes (to determine heuristics) and as long as the number of output elements is greater than 16ish, I don't think there are any remaining pathological sizes where users will encounter unexpectedly poor performance."}