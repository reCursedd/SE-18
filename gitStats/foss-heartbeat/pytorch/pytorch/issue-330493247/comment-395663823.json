{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/395663823", "html_url": "https://github.com/pytorch/pytorch/issues/8268#issuecomment-395663823", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/8268", "id": 395663823, "node_id": "MDEyOklzc3VlQ29tbWVudDM5NTY2MzgyMw==", "user": {"login": "tgamblin", "id": 299842, "node_id": "MDQ6VXNlcjI5OTg0Mg==", "avatar_url": "https://avatars3.githubusercontent.com/u/299842?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tgamblin", "html_url": "https://github.com/tgamblin", "followers_url": "https://api.github.com/users/tgamblin/followers", "following_url": "https://api.github.com/users/tgamblin/following{/other_user}", "gists_url": "https://api.github.com/users/tgamblin/gists{/gist_id}", "starred_url": "https://api.github.com/users/tgamblin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tgamblin/subscriptions", "organizations_url": "https://api.github.com/users/tgamblin/orgs", "repos_url": "https://api.github.com/users/tgamblin/repos", "events_url": "https://api.github.com/users/tgamblin/events{/privacy}", "received_events_url": "https://api.github.com/users/tgamblin/received_events", "type": "User", "site_admin": false}, "created_at": "2018-06-08T06:40:57Z", "updated_at": "2018-06-08T06:40:57Z", "author_association": "NONE", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=1310570\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/soumith\">@soumith</a>: Submodules are a convenience for developers who are using git, but they probably shouldn't even be in a release tarball, specifically for the reasons you mention above.  They're pointers to your dependencies, but they're brittle -- a URL and a commit, where the URL might change.</p>\n<p>People packaging your code (e.g. in <a href=\"https://github.com/spack/spack\">spack</a> or <a href=\"https://github.com/easybuilders/easybuild\">easybuild</a>) may not even use your submodules to build your code -- we typically get the dependencies by installing <em>their</em> packages.  Does your build system rely on dependencies built from submodules?  It seems like if you are building a wheel, you should rely on your dependencies <em>built as wheels</em>.  Is that not possible in this case (e.g., b/c eigen is vendored)?</p>\n<p>Seems like in this case you could, if you must, just issue a patch release with the updated submodules.  This would make things easier on the poor packagers who have to keep up with changing checksums.  Or, even better, just don't consider the submodules part of the release.  It's the installer or packager's job to get eigen -- it doesn't have to affect release hashes.  The old version might not build with a git checkout, but package managers can likely still install it as <em>they</em> still know how to install the dependencies.</p>", "body_text": "@soumith: Submodules are a convenience for developers who are using git, but they probably shouldn't even be in a release tarball, specifically for the reasons you mention above.  They're pointers to your dependencies, but they're brittle -- a URL and a commit, where the URL might change.\nPeople packaging your code (e.g. in spack or easybuild) may not even use your submodules to build your code -- we typically get the dependencies by installing their packages.  Does your build system rely on dependencies built from submodules?  It seems like if you are building a wheel, you should rely on your dependencies built as wheels.  Is that not possible in this case (e.g., b/c eigen is vendored)?\nSeems like in this case you could, if you must, just issue a patch release with the updated submodules.  This would make things easier on the poor packagers who have to keep up with changing checksums.  Or, even better, just don't consider the submodules part of the release.  It's the installer or packager's job to get eigen -- it doesn't have to affect release hashes.  The old version might not build with a git checkout, but package managers can likely still install it as they still know how to install the dependencies.", "body": "@soumith: Submodules are a convenience for developers who are using git, but they probably shouldn't even be in a release tarball, specifically for the reasons you mention above.  They're pointers to your dependencies, but they're brittle -- a URL and a commit, where the URL might change.\r\n\r\nPeople packaging your code (e.g. in [spack](https://github.com/spack/spack) or [easybuild](https://github.com/easybuilders/easybuild)) may not even use your submodules to build your code -- we typically get the dependencies by installing *their* packages.  Does your build system rely on dependencies built from submodules?  It seems like if you are building a wheel, you should rely on your dependencies *built as wheels*.  Is that not possible in this case (e.g., b/c eigen is vendored)?\r\n\r\nSeems like in this case you could, if you must, just issue a patch release with the updated submodules.  This would make things easier on the poor packagers who have to keep up with changing checksums.  Or, even better, just don't consider the submodules part of the release.  It's the installer or packager's job to get eigen -- it doesn't have to affect release hashes.  The old version might not build with a git checkout, but package managers can likely still install it as *they* still know how to install the dependencies."}