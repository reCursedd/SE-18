{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/164306954", "pull_request_review_id": 92060809, "id": 164306954, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2NDMwNjk1NA==", "diff_hunk": "@@ -0,0 +1,422 @@\n+import torch\n+from torch.autograd import Variable\n+from torch.distributions import constraints\n+from torch.distributions.utils import broadcast_all, lazy_property\n+from torch.nn.functional import sigmoid\n+\n+__all__ = [\n+    'AbsTransform',\n+    'AffineTransform',\n+    'BoltzmannTransform',\n+    'ComposeTransform',\n+    'ExpTransform',\n+    'LowerCholeskyTransform',\n+    'SigmoidTransform',\n+    'StickBreakingTransform',\n+    'Transform',\n+    'identity_transform',\n+]\n+\n+\n+class Transform(object):\n+    \"\"\"\n+    Abstract class for invertable transformations with computable log\n+    det jacobians. They are primarily used in\n+    :class:`torch.distributions.TransformedDistribution`.\n+\n+    Caching is useful for tranforms whose inverses are either expensive or\n+    numerically unstable. Note that care must be taken with memoized values\n+    since the autograd graph may be reversed. For example while the following\n+    works with or without caching::\n+\n+        y = t(x)\n+        t.log_abs_det_jacobian(x, y).backward()  # x will receive gradients.\n+\n+    However the following will error when caching due to dependency reversal::\n+\n+        y = t(x)\n+        z = t.inv(y)\n+        grad(z.sum(), [y])  # error because z is x\n+\n+    Derived classes should implement one or both of :meth:`_call` or\n+    :meth:`_inverse`. Derived classes that set `bijective=True` should also\n+    implement :meth:`log_abs_det_jacobian`.\n+\n+    Args:\n+        cache_size (int): Size of cache. If zero, no caching is done. If one,\n+            the latest single value is cached. Only 0 and 1 are supported.\n+\n+    Attributes:\n+        domain (:class:`~torch.distributions.constraints.Constraint`):\n+            The constraint representing valid inputs to this transform.\n+        codomain (:class:`~torch.distributions.constraints.Constraint`):\n+            The constraint representing valid outputs to this transform\n+            which are inputs to the inverse transform.\n+        bijective (bool): Whether this transform is bijective. A transform\n+            ``t`` is bijective iff ``t.inv(t(x)) == x`` and\n+            ``t(t.inv(y)) == y`` for every ``x`` in the domain and ``y`` in\n+            the codomain. Transforms that are not bijective should at least\n+            maintain the weaker pseudoinverse properties\n+            ``t(t.inv(t(x)) == t(x)`` and ``t.inv(t(t.inv(y))) == t.inv(y)``.\n+    \"\"\"\n+    bijective = False\n+\n+    def __init__(self, cache_size=0):\n+        if cache_size == 0:\n+            pass  # default behavior\n+        elif cache_size == 1:\n+            self._cached_x_y = None, None\n+            self.__call__ = self._cached_call\n+            self._inv_call = self._cached_inverse\n+        else:\n+            raise NotImplementedError('cache_size must be 0 or 1')\n+\n+    @lazy_property", "path": "torch/distributions/transforms.py", "position": null, "original_position": 74, "commit_id": "244932097058605559f6baa57da01c50b32a4131", "original_commit_id": "6360a3ee8a3f1755e48abb2bdef01dd269f1e90c", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "body": "Why would it break that property? We only ensure that inverse transforms have reference to the base one (and return it when asked for their inverse), while the base transform never holds any inverses. So `t.inv.inv is t`, it's just no longer true that `t.inv is t.inv` (not the same object by identity, but I'd say that comparing transforms by identity isn't a very good idea either).", "created_at": "2018-01-28T18:08:02Z", "updated_at": "2018-11-23T15:38:40Z", "html_url": "https://github.com/pytorch/pytorch/pull/4771#discussion_r164306954", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/4771", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/164306954"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/4771#discussion_r164306954"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/4771"}}, "body_html": "<p>Why would it break that property? We only ensure that inverse transforms have reference to the base one (and return it when asked for their inverse), while the base transform never holds any inverses. So <code>t.inv.inv is t</code>, it's just no longer true that <code>t.inv is t.inv</code> (not the same object by identity, but I'd say that comparing transforms by identity isn't a very good idea either).</p>", "body_text": "Why would it break that property? We only ensure that inverse transforms have reference to the base one (and return it when asked for their inverse), while the base transform never holds any inverses. So t.inv.inv is t, it's just no longer true that t.inv is t.inv (not the same object by identity, but I'd say that comparing transforms by identity isn't a very good idea either).", "in_reply_to_id": 164296814}