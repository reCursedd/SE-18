{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/438837311", "html_url": "https://github.com/pytorch/pytorch/issues/13254#issuecomment-438837311", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/13254", "id": 438837311, "node_id": "MDEyOklzc3VlQ29tbWVudDQzODgzNzMxMQ==", "user": {"login": "ArmenAg", "id": 4429794, "node_id": "MDQ6VXNlcjQ0Mjk3OTQ=", "avatar_url": "https://avatars0.githubusercontent.com/u/4429794?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArmenAg", "html_url": "https://github.com/ArmenAg", "followers_url": "https://api.github.com/users/ArmenAg/followers", "following_url": "https://api.github.com/users/ArmenAg/following{/other_user}", "gists_url": "https://api.github.com/users/ArmenAg/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArmenAg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArmenAg/subscriptions", "organizations_url": "https://api.github.com/users/ArmenAg/orgs", "repos_url": "https://api.github.com/users/ArmenAg/repos", "events_url": "https://api.github.com/users/ArmenAg/events{/privacy}", "received_events_url": "https://api.github.com/users/ArmenAg/received_events", "type": "User", "site_admin": false}, "created_at": "2018-11-14T22:09:36Z", "updated_at": "2018-11-14T22:09:36Z", "author_association": "CONTRIBUTOR", "body_html": "<p>I was taking a look at this and I wanted to start of by making <a href=\"https://github.com/pytorch/pytorch/blob/master/torch/csrc/jit/argument_spec.h\">ArgumentInfo and ArgumentSpec</a> use at::Device. The problem is there is a static assertion that ArgumentInfo is POD:</p>\n<pre><code>static_assert(std::is_pod&lt;ArgumentInfo&gt;::value,\n  \"ArgumentInfo is to be a POD struct\");\nstatic_assert(sizeof(ArgumentInfo) == sizeof(ArgumentInfo::plain_data_type),\n  \"ArgumentInfo is expected to be a 32-bit struct\");\n</code></pre>\n<p>This assumption will be broken if we introduce <code>at::Device</code> into <code>ArgumentInfo</code>. It also seems like we need this assertion since we do:</p>\n<pre><code>  void combineHash(const ArgumentInfo &amp;arg) {\n    ArgumentInfo::plain_data_type arg_data;\n    std::memcpy(&amp;arg_data, &amp;arg, sizeof(ArgumentInfo));\n    hash_code = hash_combine(hash_code, arg_data);\n  }\n</code></pre>\n<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=370202\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/zdevito\">@zdevito</a> any advice on what I should do?</p>", "body_text": "I was taking a look at this and I wanted to start of by making ArgumentInfo and ArgumentSpec use at::Device. The problem is there is a static assertion that ArgumentInfo is POD:\nstatic_assert(std::is_pod<ArgumentInfo>::value,\n  \"ArgumentInfo is to be a POD struct\");\nstatic_assert(sizeof(ArgumentInfo) == sizeof(ArgumentInfo::plain_data_type),\n  \"ArgumentInfo is expected to be a 32-bit struct\");\n\nThis assumption will be broken if we introduce at::Device into ArgumentInfo. It also seems like we need this assertion since we do:\n  void combineHash(const ArgumentInfo &arg) {\n    ArgumentInfo::plain_data_type arg_data;\n    std::memcpy(&arg_data, &arg, sizeof(ArgumentInfo));\n    hash_code = hash_combine(hash_code, arg_data);\n  }\n\n@zdevito any advice on what I should do?", "body": "I was taking a look at this and I wanted to start of by making [ArgumentInfo and ArgumentSpec](https://github.com/pytorch/pytorch/blob/master/torch/csrc/jit/argument_spec.h) use at::Device. The problem is there is a static assertion that ArgumentInfo is POD:\r\n\r\n```\r\nstatic_assert(std::is_pod<ArgumentInfo>::value,\r\n  \"ArgumentInfo is to be a POD struct\");\r\nstatic_assert(sizeof(ArgumentInfo) == sizeof(ArgumentInfo::plain_data_type),\r\n  \"ArgumentInfo is expected to be a 32-bit struct\");\r\n```\r\n\r\nThis assumption will be broken if we introduce `at::Device` into `ArgumentInfo`. It also seems like we need this assertion since we do:\r\n```\r\n  void combineHash(const ArgumentInfo &arg) {\r\n    ArgumentInfo::plain_data_type arg_data;\r\n    std::memcpy(&arg_data, &arg, sizeof(ArgumentInfo));\r\n    hash_code = hash_combine(hash_code, arg_data);\r\n  }\r\n```\r\n@zdevito any advice on what I should do?"}