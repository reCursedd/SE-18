{"url": "https://api.github.com/repos/pytorch/pytorch/issues/3874", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/3874/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/3874/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/3874/events", "html_url": "https://github.com/pytorch/pytorch/issues/3874", "id": 276752103, "node_id": "MDU6SXNzdWUyNzY3NTIxMDM=", "number": 3874, "title": "Reconsider strategy for implicitly generating NN derivatives", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "open", "locked": false, "assignee": {"login": "lantiga", "id": 191033, "node_id": "MDQ6VXNlcjE5MTAzMw==", "avatar_url": "https://avatars2.githubusercontent.com/u/191033?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lantiga", "html_url": "https://github.com/lantiga", "followers_url": "https://api.github.com/users/lantiga/followers", "following_url": "https://api.github.com/users/lantiga/following{/other_user}", "gists_url": "https://api.github.com/users/lantiga/gists{/gist_id}", "starred_url": "https://api.github.com/users/lantiga/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lantiga/subscriptions", "organizations_url": "https://api.github.com/users/lantiga/orgs", "repos_url": "https://api.github.com/users/lantiga/repos", "events_url": "https://api.github.com/users/lantiga/events{/privacy}", "received_events_url": "https://api.github.com/users/lantiga/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "lantiga", "id": 191033, "node_id": "MDQ6VXNlcjE5MTAzMw==", "avatar_url": "https://avatars2.githubusercontent.com/u/191033?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lantiga", "html_url": "https://github.com/lantiga", "followers_url": "https://api.github.com/users/lantiga/followers", "following_url": "https://api.github.com/users/lantiga/following{/other_user}", "gists_url": "https://api.github.com/users/lantiga/gists{/gist_id}", "starred_url": "https://api.github.com/users/lantiga/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lantiga/subscriptions", "organizations_url": "https://api.github.com/users/lantiga/orgs", "repos_url": "https://api.github.com/users/lantiga/repos", "events_url": "https://api.github.com/users/lantiga/events{/privacy}", "received_events_url": "https://api.github.com/users/lantiga/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 12, "created_at": "2017-11-25T13:52:42Z", "updated_at": "2018-01-07T14:34:03Z", "closed_at": null, "author_association": "CONTRIBUTOR", "body_html": "<p>At the moment, the NN story looks something like this:</p>\n<pre><code># LOOKING FOR AN THNN DEFINITION?  These are implicitly defined by\n# preprocess_nn_functions, because THNN functions follow a specific\n# convention; thus, you don't have to explicitly write it down in\n# derivatives.yaml (in fact, you MUST NOT write it down, because then\n# you'll have two derivative definitions!)\n</code></pre>\n<p>As I have been working on CuDNN bindings, I've found that the implicit generation of NN derivatives has been getting in my way more than it has been helping. The two big things I've noticed:</p>\n<ul>\n<li>It's easy to \"forget\" that an NN definition is being implicitly generated, and accidentally specify its derivative redundantly in <code>derivatives.yaml</code>. Right now the generator code silently accepts this and generates two classes in this case.</li>\n<li>It's easy to accidentally trigger the NN derivative generation behavior when you don't want to; it's sufficient to have two functions <code>foo</code> and <code>foo_backward</code> and blam, NN definitions get generated. But the native function parsing machinery is not setup to handle this yet, since the NN autogen code assumes outputs are named, but the native parser doesn't exercise this at all. Also, you need to define BOTH <code>foo</code> and <code>foo_forward</code> for the codepath to work. In short, there are some pretty stringent assumptions about what \"NN\" things look like, which are not very friendly to native function writers.</li>\n</ul>\n<p>So you end up with things like RoiPooling \"near-missing\" the NN autogen behavior by naming their forward function <code>RoiPooling2D_forward</code> (and thus getting a backwards class named <code>RoiPooling2DForward</code>), avoiding the NN codepath by a hair.</p>\n<p>This just seems bad.</p>\n<p>Here are two possible proposals:</p>\n<ul>\n<li>\n<p>Remove NN autogen behavior. We explicitly write down derivatives for all the NN classes; none of this magic stuff. Codegen gets simpler.</p>\n</li>\n<li>\n<p>Make the NN autogeneration behavior more widely applicable. For example, today, for the bindings to work you must define both <code>foo</code>, <code>foo_forward</code>, and <code>foo_backward</code>; if you're missing any of these the tooling chokes. But this is fairly unfriendly for native functions.</p>\n</li>\n</ul>", "body_text": "At the moment, the NN story looks something like this:\n# LOOKING FOR AN THNN DEFINITION?  These are implicitly defined by\n# preprocess_nn_functions, because THNN functions follow a specific\n# convention; thus, you don't have to explicitly write it down in\n# derivatives.yaml (in fact, you MUST NOT write it down, because then\n# you'll have two derivative definitions!)\n\nAs I have been working on CuDNN bindings, I've found that the implicit generation of NN derivatives has been getting in my way more than it has been helping. The two big things I've noticed:\n\nIt's easy to \"forget\" that an NN definition is being implicitly generated, and accidentally specify its derivative redundantly in derivatives.yaml. Right now the generator code silently accepts this and generates two classes in this case.\nIt's easy to accidentally trigger the NN derivative generation behavior when you don't want to; it's sufficient to have two functions foo and foo_backward and blam, NN definitions get generated. But the native function parsing machinery is not setup to handle this yet, since the NN autogen code assumes outputs are named, but the native parser doesn't exercise this at all. Also, you need to define BOTH foo and foo_forward for the codepath to work. In short, there are some pretty stringent assumptions about what \"NN\" things look like, which are not very friendly to native function writers.\n\nSo you end up with things like RoiPooling \"near-missing\" the NN autogen behavior by naming their forward function RoiPooling2D_forward (and thus getting a backwards class named RoiPooling2DForward), avoiding the NN codepath by a hair.\nThis just seems bad.\nHere are two possible proposals:\n\n\nRemove NN autogen behavior. We explicitly write down derivatives for all the NN classes; none of this magic stuff. Codegen gets simpler.\n\n\nMake the NN autogeneration behavior more widely applicable. For example, today, for the bindings to work you must define both foo, foo_forward, and foo_backward; if you're missing any of these the tooling chokes. But this is fairly unfriendly for native functions.", "body": "At the moment, the NN story looks something like this:\r\n\r\n```\r\n# LOOKING FOR AN THNN DEFINITION?  These are implicitly defined by\r\n# preprocess_nn_functions, because THNN functions follow a specific\r\n# convention; thus, you don't have to explicitly write it down in\r\n# derivatives.yaml (in fact, you MUST NOT write it down, because then\r\n# you'll have two derivative definitions!)\r\n```\r\n\r\nAs I have been working on CuDNN bindings, I've found that the implicit generation of NN derivatives has been getting in my way more than it has been helping. The two big things I've noticed:\r\n\r\n* It's easy to \"forget\" that an NN definition is being implicitly generated, and accidentally specify its derivative redundantly in `derivatives.yaml`. Right now the generator code silently accepts this and generates two classes in this case.\r\n* It's easy to accidentally trigger the NN derivative generation behavior when you don't want to; it's sufficient to have two functions `foo` and `foo_backward` and blam, NN definitions get generated. But the native function parsing machinery is not setup to handle this yet, since the NN autogen code assumes outputs are named, but the native parser doesn't exercise this at all. Also, you need to define BOTH `foo` and `foo_forward` for the codepath to work. In short, there are some pretty stringent assumptions about what \"NN\" things look like, which are not very friendly to native function writers.\r\n\r\nSo you end up with things like RoiPooling \"near-missing\" the NN autogen behavior by naming their forward function `RoiPooling2D_forward` (and thus getting a backwards class named `RoiPooling2DForward`), avoiding the NN codepath by a hair.\r\n\r\nThis just seems bad.\r\n\r\nHere are two possible proposals:\r\n\r\n* Remove NN autogen behavior. We explicitly write down derivatives for all the NN classes; none of this magic stuff. Codegen gets simpler.\r\n\r\n* Make the NN autogeneration behavior more widely applicable. For example, today, for the bindings to work you must define both `foo`, `foo_forward`, and `foo_backward`; if you're missing any of these the tooling chokes. But this is fairly unfriendly for native functions."}