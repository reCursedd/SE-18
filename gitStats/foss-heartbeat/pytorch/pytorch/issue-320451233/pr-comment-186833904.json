{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/186833904", "pull_request_review_id": 118443026, "id": 186833904, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NjgzMzkwNA==", "diff_hunk": "@@ -260,97 +263,272 @@ at::Tensor getAttributeValue(const NamedValue& nv) {\n   return getConstantValue(nv.loc, v);\n }\n \n-std::shared_ptr<SugaredValue> emitBuiltinCall(\n+Value* createConstant(Graph& g, const SourceRange& loc, const at::Tensor& val) {\n+  auto n = g.createConstant(val);\n+  n->setSourceLocation(std::make_shared<SourceRange>(loc));\n+  return g.insertNode(n)->output();\n+}\n+\n+Value* createStack(Graph& g, const SourceRange& loc, at::ArrayRef<Value*> inputs) {\n+  // bake in constant propagation for the all-constant case because it is\n+  // common to see constant lists like [1, 2] passed to attributes\n+  bool all_constant = std::all_of(inputs.begin(), inputs.end(), [&](Value* v) {\n+    return v->node()->kind() == prim::Constant;\n+  });\n+  if(all_constant) {\n+    auto values = fmap(inputs, [&](Value* v) {\n+      return v->node()->t(attr::value);\n+    });\n+    return createConstant(g, loc, at::stack(values));\n+  }\n+  return g.insertNode(g.create(aten::stack, inputs)\n+                      ->i_(attr::dim, 0)\n+                      ->setSourceLocation(std::make_shared<SourceRange>(loc)))->output();\n+}\n+\n+static bool isTensorSubtype(Value* v) {\n+  return v->type()->isSubtypeOf(*DynamicType::get());\n+}\n+\n+// if a value is a constant then try to turn into type T using the\n+// same rules as the interpreter\n+template<typename T>\n+at::optional<T> constant_as(Value* v) {\n+  if(v->node()->kind() != prim::Constant)\n+    return at::nullopt;\n+  auto tensor = v->node()->t(attr::value);\n+  try {\n+    return tensor_as<T>(std::move(tensor));\n+  } catch (tensor_conversion_error& err) {\n+    return at::nullopt;\n+  }\n+}\n+\n+// try to turn constant inputs into attributes\n+void liftConstantAttributes(const FunctionSchema& schema, Node* node) {\n+  // we shouldn't start with attributes, just inputs\n+  JIT_ASSERT(!node->hasAttributes());\n+  std::vector<Value*> new_inputs;\n+  Attributes<Node> attributes;\n+  for(size_t i = 0; i < node->inputs().size(); ++i) {\n+    const auto& arg = schema.arguments[i];\n+    auto input = node->input(i);\n+    if(arg.attribute_kind) {\n+      switch(*arg.attribute_kind) {\n+        case AttributeKind::i: {\n+          auto r = constant_as<int64_t>(input);\n+          if(!r)\n+            return;\n+          attributes.i_(Symbol::attr(arg.name), *r);\n+        } break;\n+        case AttributeKind::is: {\n+          auto r = constant_as<at::IntList>(input);\n+          if(!r)\n+            return;\n+          attributes.is_(Symbol::attr(arg.name), *r);\n+        } break;\n+        case AttributeKind::f: {\n+          auto r = constant_as<double>(input);\n+          if(!r)\n+            return;\n+          attributes.f_(Symbol::attr(arg.name), *r);\n+        } break;\n+        case AttributeKind::t: {\n+          auto r = constant_as<at::Tensor>(input);\n+          if(!r)\n+            return;\n+          attributes.t_(Symbol::attr(arg.name), *r);\n+        } break;\n+        default:\n+          barf(\"AttributeKind not handled in LiftConstantAttributes file a bug report.\");\n+          return;\n+      }\n+    } else {\n+      new_inputs.push_back(input);\n+    }\n+  }\n+  // nothing changed no need to modify the node\n+  if(!attributes.hasAttributes())\n+    return;\n+\n+  node->removeAllInputs();\n+  for(Value* input : new_inputs) {\n+    node->addInput(input);\n+  }\n+  node->copyAttributes(attributes);\n+}\n+\n+\n+static std::shared_ptr<SugaredValue> tryEmitSchema(\n+  const FunctionSchema& schema,\n+  std::stringstream& failure_messages,", "path": "torch/csrc/jit/script/compiler.cpp", "position": null, "original_position": 116, "commit_id": "ed702bbdd1400a0d0865f59a9e69828337b447d9", "original_commit_id": "548698dbc6c03485edf11f5f07f04b796302d448", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "body": "nit: `ostringstream`", "created_at": "2018-05-08T19:01:59Z", "updated_at": "2018-11-23T15:43:42Z", "html_url": "https://github.com/pytorch/pytorch/pull/7311#discussion_r186833904", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/7311", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/186833904"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/7311#discussion_r186833904"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/7311"}}, "body_html": "<p>nit: <code>ostringstream</code></p>", "body_text": "nit: ostringstream"}