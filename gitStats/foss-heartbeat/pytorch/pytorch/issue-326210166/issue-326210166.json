{"url": "https://api.github.com/repos/pytorch/pytorch/issues/7812", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/7812/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/7812/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/7812/events", "html_url": "https://github.com/pytorch/pytorch/issues/7812", "id": 326210166, "node_id": "MDU6SXNzdWUzMjYyMTAxNjY=", "number": 7812, "title": "Can't get attribute 'Net' on <module '__main__' from 'D:/demo/cnn/test1.py'>", "user": {"login": "xiaopengguo1406", "id": 24312469, "node_id": "MDQ6VXNlcjI0MzEyNDY5", "avatar_url": "https://avatars3.githubusercontent.com/u/24312469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xiaopengguo1406", "html_url": "https://github.com/xiaopengguo1406", "followers_url": "https://api.github.com/users/xiaopengguo1406/followers", "following_url": "https://api.github.com/users/xiaopengguo1406/following{/other_user}", "gists_url": "https://api.github.com/users/xiaopengguo1406/gists{/gist_id}", "starred_url": "https://api.github.com/users/xiaopengguo1406/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xiaopengguo1406/subscriptions", "organizations_url": "https://api.github.com/users/xiaopengguo1406/orgs", "repos_url": "https://api.github.com/users/xiaopengguo1406/repos", "events_url": "https://api.github.com/users/xiaopengguo1406/events{/privacy}", "received_events_url": "https://api.github.com/users/xiaopengguo1406/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2018-05-24T17:01:51Z", "updated_at": "2018-05-25T17:49:33Z", "closed_at": "2018-05-24T17:24:16Z", "author_association": "NONE", "body_html": "<p>I run Pytorch0.4 on the platform of Win10. The training process works well and I saved the model using torch.save(model, net_g_model_out_path); However, it will cause a error \"Can't get attribute 'Net' on &lt;module '<strong>main</strong>' from 'D:/demo/cnn/test1.py'&gt;\" when I try to load the model through \"net=torch.load('checkpoint/multi/netG_model_epoch_3.pth')\".<br>\nThe train.py is as follows:<br>\nfrom <strong>future</strong> import print_function<br>\nimport argparse<br>\nimport torch<br>\nimport torch.nn as nn<br>\nimport torch.nn.functional as F<br>\nimport torch.optim as optim</p>\n<p>import torch.tensor<br>\nimport torch.backends.cudnn as cudn<br>\nfrom PIL import Image<br>\nimport os<br>\nimport scipy.io as sio<br>\nimport torch.utils.data as Data<br>\nfrom torch.utils.data import DataLoader</p>\n<p>from dataset import multi_focusdata</p>\n<p>parser = argparse.ArgumentParser(description='PyTorch face Example')</p>\n<p>parser.add_argument('--batchSize', type=int, default=64, metavar='N',<br>\nhelp='input batch size for training (default: 64)')<br>\nparser.add_argument('--test-batch-size', type=int, default=1000, metavar='N',<br>\nhelp='input batch size for testing (default: 1000)')<br>\nparser.add_argument('--epochs', type=int, default=1000, metavar='N',<br>\nhelp='number of epochs to train (default: 10)')<br>\nparser.add_argument('--lr', type=float, default=0.01, metavar='LR',<br>\nhelp='learning rate (default: 0.01)')<br>\nparser.add_argument('--momentum', type=float, default=0.5, metavar='M',<br>\nhelp='SGD momentum (default: 0.5)')<br>\nparser.add_argument('--no-cuda', action='store_true', default=False,<br>\nhelp='disables CUDA training')<br>\nparser.add_argument('--seed', type=int, default=1, metavar='S',<br>\nhelp='random seed (default: 1)')<br>\nparser.add_argument('--log-interval', type=int, default=10, metavar='N',<br>\nhelp='how many batches to wait before logging training status')<br>\nparser.add_argument('--dataset', type=str, default='multi', metavar='N',<br>\nhelp='how many batches to wait before logging training status')<br>\nopt = parser.parse_args()<br>\nuse_cuda = not opt.no_cuda and torch.cuda.is_available()<br>\nopt.cuda = not opt.no_cuda and torch.cuda.is_available()</p>\n<p>root_path = \"dataset\"<br>\n#dataset = multi_focusdata(os.path.join(root_path,'train'))<br>\ndataset = multi_focusdata(os.path.join(root_path,'train'))<br>\ntrain_loader = DataLoader(dataset=dataset, batch_size=opt.batchSize, shuffle=True, num_workers=1)<br>\ndef weights_init(m):<br>\nclassname = m.<strong>class</strong>.<strong>name</strong><br>\nif classname.find('Conv') != -1:<br>\nm.weight.data.normal_(0.0, 0.02)<br>\nelif classname.find('BatchNorm2d') != -1 or classname.find('InstanceNorm2d') != -1:<br>\nm.weight.data.normal_(1.0, 0.02)<br>\nm.bias.data.fill_(0)</p>\n<p>def net_module(in_channels,out_channels,kernel_size,stride,padding):<br>\nreturn nn.Sequential(<br>\nnn.Conv2d(in_channels=in_channels,out_channels=out_channels,kernel_size=kernel_size,stride=stride,padding=padding),<br>\nnn.ReLU()<br>\n)</p>\n<p>class Net(nn.Module):<br>\ndef <strong>init</strong>(self):<br>\nsuper(Net,self).<strong>init</strong>()<br>\nself.conv1=net_module(6,32,3,1,2)<br>\nself.conv2=net_module(32,64,3,1,2)<br>\nself.conv3=net_module(64,128,3,1,2)<br>\nself.conv3_drop = nn.Dropout2d()<br>\nself.fc1 = nn.Linear(128<em>3</em>3,512)<a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"201990703\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/512\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/pytorch/pytorch/pull/512/hovercard\" href=\"https://github.com/pytorch/pytorch/pull/512\">#512</a>=2^x<br>\nself.fc2 = nn.Linear(512,2)</p>\n<pre><code>def forward(self,x):\n    x=F.relu(F.max_pool2d(self.conv1(x),2))\n    x=F.relu(F.max_pool2d(self.conv2(x),2))\n    x=F.relu(F.max_pool2d(self.conv3_drop(self.conv3(x)),2))\n    \n    x=x.view(-1,128*3*3)\n\n    x=F.relu(self.fc1(x))\n\n    x=F.dropout(x,training=self.training)\n    x=self.fc2(x)##?\n  \n    return F.log_softmax(x,dim=1)\n</code></pre>\n<p>device = torch.device(\"cuda\")<br>\nloss_func=nn.NLLLoss()<br>\nimg = torch.FloatTensor(opt.batchSize,3, 256, 256)</p>\n<p>gt=torch.LongTensor(opt.batchSize,1, 256, 256)<br>\nmodel=Net().to(device)<br>\nmodel.apply(weights_init)</p>\n<p>img=img.to(device)<br>\ngt=gt.to(device)<br>\nloss_func=loss_func.to(device)<br>\noptimizer =torch.optim.SGD(model.parameters(), lr=0.001, momentum=0.9)</p>\n<p>def train(epoch):</p>\n<pre><code>model.train()\nfor step,(img_cat,gt1)in enumerate(train_loader):\n    img.resize_(img_cat.size()).copy_(img_cat)\n    gt.resize_(gt1.size()).copy_(gt1)\n    \n    optimizer.zero_grad() \n    output=model(img)\n    loss=loss_func(output,gt.view(-1))\n    loss.backward()\n    optimizer.step()\n    if step % opt.log_interval == 0:\n        print('Train Epoch: {} [{}/{} ({:.0f}%)]\\tLoss: {:.6f}'.format( epoch, step * len(img_cat), len(train_loader.dataset),\n            100. * step / len(train_loader), loss.data[0]))\n</code></pre>\n<p>def checkpoint(epoch):<br>\nif not os.path.exists(\"checkpoint\"):os.mkdir(\"checkpoint\")<br>\nif not os.path.exists(os.path.join(\"checkpoint\", opt.dataset)):<br>\nos.mkdir(os.path.join(\"checkpoint\", opt.dataset))<br>\nnet_g_model_out_path = \"checkpoint/{}/netG_model_epoch_{}.pth\".format(opt.dataset, epoch)</p>\n<pre><code>torch.save(model, net_g_model_out_path)\nprint(\"Checkpoint saved to {}\".format(\"checkpoint/\" + opt.dataset))           \n</code></pre>\n<p>if <strong>name</strong> == '<strong>main</strong>':<br>\nfor epoch in range(1, opt.epochs + 1):<br>\ntrain(epoch)<br>\n#test()<br>\nif epoch % 1 == 0:<br>\ncheckpoint(epoch)</p>\n<p>When I run the \"net=torch.load('checkpoint/multi/netG_model_epoch_3.pth')\" error happens.</p>\n<p>I am very confused with it! Could you give me a idear how to debug it? Thank you very much!</p>", "body_text": "I run Pytorch0.4 on the platform of Win10. The training process works well and I saved the model using torch.save(model, net_g_model_out_path); However, it will cause a error \"Can't get attribute 'Net' on <module 'main' from 'D:/demo/cnn/test1.py'>\" when I try to load the model through \"net=torch.load('checkpoint/multi/netG_model_epoch_3.pth')\".\nThe train.py is as follows:\nfrom future import print_function\nimport argparse\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.optim as optim\nimport torch.tensor\nimport torch.backends.cudnn as cudn\nfrom PIL import Image\nimport os\nimport scipy.io as sio\nimport torch.utils.data as Data\nfrom torch.utils.data import DataLoader\nfrom dataset import multi_focusdata\nparser = argparse.ArgumentParser(description='PyTorch face Example')\nparser.add_argument('--batchSize', type=int, default=64, metavar='N',\nhelp='input batch size for training (default: 64)')\nparser.add_argument('--test-batch-size', type=int, default=1000, metavar='N',\nhelp='input batch size for testing (default: 1000)')\nparser.add_argument('--epochs', type=int, default=1000, metavar='N',\nhelp='number of epochs to train (default: 10)')\nparser.add_argument('--lr', type=float, default=0.01, metavar='LR',\nhelp='learning rate (default: 0.01)')\nparser.add_argument('--momentum', type=float, default=0.5, metavar='M',\nhelp='SGD momentum (default: 0.5)')\nparser.add_argument('--no-cuda', action='store_true', default=False,\nhelp='disables CUDA training')\nparser.add_argument('--seed', type=int, default=1, metavar='S',\nhelp='random seed (default: 1)')\nparser.add_argument('--log-interval', type=int, default=10, metavar='N',\nhelp='how many batches to wait before logging training status')\nparser.add_argument('--dataset', type=str, default='multi', metavar='N',\nhelp='how many batches to wait before logging training status')\nopt = parser.parse_args()\nuse_cuda = not opt.no_cuda and torch.cuda.is_available()\nopt.cuda = not opt.no_cuda and torch.cuda.is_available()\nroot_path = \"dataset\"\n#dataset = multi_focusdata(os.path.join(root_path,'train'))\ndataset = multi_focusdata(os.path.join(root_path,'train'))\ntrain_loader = DataLoader(dataset=dataset, batch_size=opt.batchSize, shuffle=True, num_workers=1)\ndef weights_init(m):\nclassname = m.class.name\nif classname.find('Conv') != -1:\nm.weight.data.normal_(0.0, 0.02)\nelif classname.find('BatchNorm2d') != -1 or classname.find('InstanceNorm2d') != -1:\nm.weight.data.normal_(1.0, 0.02)\nm.bias.data.fill_(0)\ndef net_module(in_channels,out_channels,kernel_size,stride,padding):\nreturn nn.Sequential(\nnn.Conv2d(in_channels=in_channels,out_channels=out_channels,kernel_size=kernel_size,stride=stride,padding=padding),\nnn.ReLU()\n)\nclass Net(nn.Module):\ndef init(self):\nsuper(Net,self).init()\nself.conv1=net_module(6,32,3,1,2)\nself.conv2=net_module(32,64,3,1,2)\nself.conv3=net_module(64,128,3,1,2)\nself.conv3_drop = nn.Dropout2d()\nself.fc1 = nn.Linear(12833,512)#512=2^x\nself.fc2 = nn.Linear(512,2)\ndef forward(self,x):\n    x=F.relu(F.max_pool2d(self.conv1(x),2))\n    x=F.relu(F.max_pool2d(self.conv2(x),2))\n    x=F.relu(F.max_pool2d(self.conv3_drop(self.conv3(x)),2))\n    \n    x=x.view(-1,128*3*3)\n\n    x=F.relu(self.fc1(x))\n\n    x=F.dropout(x,training=self.training)\n    x=self.fc2(x)##?\n  \n    return F.log_softmax(x,dim=1)\n\ndevice = torch.device(\"cuda\")\nloss_func=nn.NLLLoss()\nimg = torch.FloatTensor(opt.batchSize,3, 256, 256)\ngt=torch.LongTensor(opt.batchSize,1, 256, 256)\nmodel=Net().to(device)\nmodel.apply(weights_init)\nimg=img.to(device)\ngt=gt.to(device)\nloss_func=loss_func.to(device)\noptimizer =torch.optim.SGD(model.parameters(), lr=0.001, momentum=0.9)\ndef train(epoch):\nmodel.train()\nfor step,(img_cat,gt1)in enumerate(train_loader):\n    img.resize_(img_cat.size()).copy_(img_cat)\n    gt.resize_(gt1.size()).copy_(gt1)\n    \n    optimizer.zero_grad() \n    output=model(img)\n    loss=loss_func(output,gt.view(-1))\n    loss.backward()\n    optimizer.step()\n    if step % opt.log_interval == 0:\n        print('Train Epoch: {} [{}/{} ({:.0f}%)]\\tLoss: {:.6f}'.format( epoch, step * len(img_cat), len(train_loader.dataset),\n            100. * step / len(train_loader), loss.data[0]))\n\ndef checkpoint(epoch):\nif not os.path.exists(\"checkpoint\"):os.mkdir(\"checkpoint\")\nif not os.path.exists(os.path.join(\"checkpoint\", opt.dataset)):\nos.mkdir(os.path.join(\"checkpoint\", opt.dataset))\nnet_g_model_out_path = \"checkpoint/{}/netG_model_epoch_{}.pth\".format(opt.dataset, epoch)\ntorch.save(model, net_g_model_out_path)\nprint(\"Checkpoint saved to {}\".format(\"checkpoint/\" + opt.dataset))           \n\nif name == 'main':\nfor epoch in range(1, opt.epochs + 1):\ntrain(epoch)\n#test()\nif epoch % 1 == 0:\ncheckpoint(epoch)\nWhen I run the \"net=torch.load('checkpoint/multi/netG_model_epoch_3.pth')\" error happens.\nI am very confused with it! Could you give me a idear how to debug it? Thank you very much!", "body": "I run Pytorch0.4 on the platform of Win10. The training process works well and I saved the model using torch.save(model, net_g_model_out_path); However, it will cause a error \"Can't get attribute 'Net' on <module '__main__' from 'D:/demo/cnn/test1.py'>\" when I try to load the model through \"net=torch.load('checkpoint/multi/netG_model_epoch_3.pth')\". \r\nThe train.py is as follows:\r\nfrom __future__ import print_function\r\nimport argparse\r\nimport torch\r\nimport torch.nn as nn\r\nimport torch.nn.functional as F\r\nimport torch.optim as optim\r\n\r\nimport torch.tensor\r\nimport torch.backends.cudnn as cudn\r\nfrom PIL import Image\r\nimport os\r\nimport scipy.io as sio  \r\nimport torch.utils.data as Data\r\nfrom torch.utils.data import DataLoader\r\n\r\n\r\nfrom dataset import multi_focusdata\r\n\r\nparser = argparse.ArgumentParser(description='PyTorch face Example')\r\n\r\nparser.add_argument('--batchSize', type=int, default=64, metavar='N',\r\n                    help='input batch size for training (default: 64)')\r\nparser.add_argument('--test-batch-size', type=int, default=1000, metavar='N',\r\n                    help='input batch size for testing (default: 1000)')\r\nparser.add_argument('--epochs', type=int, default=1000, metavar='N',\r\n                    help='number of epochs to train (default: 10)')\r\nparser.add_argument('--lr', type=float, default=0.01, metavar='LR',\r\n                    help='learning rate (default: 0.01)')\r\nparser.add_argument('--momentum', type=float, default=0.5, metavar='M',\r\n                    help='SGD momentum (default: 0.5)')\r\nparser.add_argument('--no-cuda', action='store_true', default=False,\r\n                    help='disables CUDA training')\r\nparser.add_argument('--seed', type=int, default=1, metavar='S',\r\n                    help='random seed (default: 1)')\r\nparser.add_argument('--log-interval', type=int, default=10, metavar='N',\r\n                    help='how many batches to wait before logging training status')\r\nparser.add_argument('--dataset', type=str, default='multi', metavar='N',\r\n                    help='how many batches to wait before logging training status')\r\nopt = parser.parse_args()\r\nuse_cuda = not opt.no_cuda and torch.cuda.is_available()\r\nopt.cuda = not opt.no_cuda and torch.cuda.is_available()\r\n\r\nroot_path = \"dataset\"\r\n#dataset = multi_focusdata(os.path.join(root_path,'train'))\r\ndataset = multi_focusdata(os.path.join(root_path,'train'))\r\ntrain_loader = DataLoader(dataset=dataset, batch_size=opt.batchSize, shuffle=True, num_workers=1)\r\ndef weights_init(m):\r\n    classname = m.__class__.__name__\r\n    if classname.find('Conv') != -1:\r\n        m.weight.data.normal_(0.0, 0.02)\r\n    elif classname.find('BatchNorm2d') != -1 or classname.find('InstanceNorm2d') != -1:\r\n        m.weight.data.normal_(1.0, 0.02)\r\n        m.bias.data.fill_(0)\r\n        \r\n        \r\n        \r\ndef net_module(in_channels,out_channels,kernel_size,stride,padding):\r\n    return nn.Sequential(\r\n            nn.Conv2d(in_channels=in_channels,out_channels=out_channels,kernel_size=kernel_size,stride=stride,padding=padding),\r\n            nn.ReLU()\r\n           )\r\n \r\n\r\nclass Net(nn.Module):\r\n    def __init__(self):\r\n        super(Net,self).__init__()\r\n        self.conv1=net_module(6,32,3,1,2)\r\n        self.conv2=net_module(32,64,3,1,2)\r\n        self.conv3=net_module(64,128,3,1,2)\r\n        self.conv3_drop = nn.Dropout2d()\r\n        self.fc1 = nn.Linear(128*3*3,512)#512=2^x\r\n        self.fc2 = nn.Linear(512,2)\r\n    \r\n    def forward(self,x):\r\n        x=F.relu(F.max_pool2d(self.conv1(x),2))\r\n        x=F.relu(F.max_pool2d(self.conv2(x),2))\r\n        x=F.relu(F.max_pool2d(self.conv3_drop(self.conv3(x)),2))\r\n        \r\n        x=x.view(-1,128*3*3)\r\n\r\n        x=F.relu(self.fc1(x))\r\n\r\n        x=F.dropout(x,training=self.training)\r\n        x=self.fc2(x)##?\r\n      \r\n        return F.log_softmax(x,dim=1)\r\n    \r\ndevice = torch.device(\"cuda\")\r\nloss_func=nn.NLLLoss()\r\nimg = torch.FloatTensor(opt.batchSize,3, 256, 256)\r\n\r\ngt=torch.LongTensor(opt.batchSize,1, 256, 256)\r\nmodel=Net().to(device)\r\nmodel.apply(weights_init)\r\n\r\nimg=img.to(device)\r\ngt=gt.to(device)\r\nloss_func=loss_func.to(device)\r\noptimizer =torch.optim.SGD(model.parameters(), lr=0.001, momentum=0.9)\r\n\r\n\r\ndef train(epoch):\r\n    \r\n    model.train()\r\n    for step,(img_cat,gt1)in enumerate(train_loader):\r\n        img.resize_(img_cat.size()).copy_(img_cat)\r\n        gt.resize_(gt1.size()).copy_(gt1)\r\n        \r\n        optimizer.zero_grad() \r\n        output=model(img)\r\n        loss=loss_func(output,gt.view(-1))\r\n        loss.backward()\r\n        optimizer.step()\r\n        if step % opt.log_interval == 0:\r\n            print('Train Epoch: {} [{}/{} ({:.0f}%)]\\tLoss: {:.6f}'.format( epoch, step * len(img_cat), len(train_loader.dataset),\r\n                100. * step / len(train_loader), loss.data[0]))\r\n            \r\ndef checkpoint(epoch):\r\n    if not os.path.exists(\"checkpoint\"):os.mkdir(\"checkpoint\")\r\n    if not os.path.exists(os.path.join(\"checkpoint\", opt.dataset)):\r\n        os.mkdir(os.path.join(\"checkpoint\", opt.dataset))\r\n    net_g_model_out_path = \"checkpoint/{}/netG_model_epoch_{}.pth\".format(opt.dataset, epoch)\r\n\r\n    torch.save(model, net_g_model_out_path)\r\n    print(\"Checkpoint saved to {}\".format(\"checkpoint/\" + opt.dataset))           \r\n\r\n\r\nif __name__ == '__main__':\r\n    for epoch in range(1, opt.epochs + 1):\r\n        train(epoch)\r\n        #test()\r\n        if epoch % 1 == 0:\r\n            checkpoint(epoch)\r\n\r\nWhen I run the \"net=torch.load('checkpoint/multi/netG_model_epoch_3.pth')\" error happens.\r\n\r\nI am very confused with it! Could you give me a idear how to debug it? Thank you very much!\r\n"}