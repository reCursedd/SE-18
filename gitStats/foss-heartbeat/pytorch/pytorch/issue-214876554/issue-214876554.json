{"url": "https://api.github.com/repos/pytorch/pytorch/issues/1020", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/1020/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/1020/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/1020/events", "html_url": "https://github.com/pytorch/pytorch/issues/1020", "id": 214876554, "node_id": "MDU6SXNzdWUyMTQ4NzY1NTQ=", "number": 1020, "title": "Ambiguous docs+confusing behavior of softmax for 3+ dimensions", "user": {"login": "jekbradbury", "id": 11729078, "node_id": "MDQ6VXNlcjExNzI5MDc4", "avatar_url": "https://avatars2.githubusercontent.com/u/11729078?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jekbradbury", "html_url": "https://github.com/jekbradbury", "followers_url": "https://api.github.com/users/jekbradbury/followers", "following_url": "https://api.github.com/users/jekbradbury/following{/other_user}", "gists_url": "https://api.github.com/users/jekbradbury/gists{/gist_id}", "starred_url": "https://api.github.com/users/jekbradbury/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jekbradbury/subscriptions", "organizations_url": "https://api.github.com/users/jekbradbury/orgs", "repos_url": "https://api.github.com/users/jekbradbury/repos", "events_url": "https://api.github.com/users/jekbradbury/events{/privacy}", "received_events_url": "https://api.github.com/users/jekbradbury/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 424131849, "node_id": "MDU6TGFiZWw0MjQxMzE4NDk=", "url": "https://api.github.com/repos/pytorch/pytorch/labels/enhancement", "name": "enhancement", "color": "84b6eb", "default": true}, {"id": 443484135, "node_id": "MDU6TGFiZWw0NDM0ODQxMzU=", "url": "https://api.github.com/repos/pytorch/pytorch/labels/high%20priority", "name": "high priority", "color": "F22613", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 14, "created_at": "2017-03-17T00:28:19Z", "updated_at": "2017-12-06T23:25:45Z", "closed_at": "2017-10-31T21:08:53Z", "author_association": "CONTRIBUTOR", "body_html": "<p>The docs for <code>nn.Softmax</code>, which are essentially copied over from Torch7's <code>nn.Softmax</code>, say \"Applies the SoftMax function to an n-dimensional input Tensor, rescaling them so that the elements of the n-dimensional output Tensor lie in the range (0, 1) and sum to 1.\" This is ambiguous with respect to what exactly should sum to 1 (what dimension/s the softmax should be performed over). What in fact happens, also a holdover from Torch7, is:</p>\n<ul>\n<li>For a 1D input, the softmax takes place over dimension 0 (this was needed in Torch7 to support inputs without a batch dimension, which are not allowed in PyTorch). This is still reasonable default behavior, because there's no reason to use <code>nn.Softmax</code> when you have a batch of scalars.</li>\n<li>For a 2D input, the softmax takes place over dimension 1. This is the most common case, and the desired behavior.</li>\n<li>For a 3D input, the softmax takes place over dimension 0. This is usually wrong in PyTorch, since dimension 0 is usually the batch dimension. It may, however, be the right thing to do if dimension 0 is the timestep dimension of a timestep x batch x feature tensor; this is the desired behavior in RNNs with attention.</li>\n<li>For a 4D input, the softmax again takes place over dimension 1.</li>\n<li>For a 5D+ input, THNN gives a RuntimeError.</li>\n</ul>\n<p>If all of this is intentional, then we should document it. The ideal solution is probably to keep this behavior and document it but add an optional <code>dim</code> argument, as in TensorFlow, that lets the user pick a dimension to softmax over. For reference, the default behavior in TF is to softmax over the last dimension, while the default behavior in Chainer (which can also IIRC be overridden by the user as of v2) is to softmax over dimension 1. It is occasionally also useful to be able to softmax over multiple dimensions at once, but this is easy to emulate with <code>.view()</code> so it's not necessary to have in core.<br>\nIt may also be useful to add a <code>torch.softmax</code> with the same behavior as <code>F.softmax</code>, to apply the softmax operation to Tensors.</p>", "body_text": "The docs for nn.Softmax, which are essentially copied over from Torch7's nn.Softmax, say \"Applies the SoftMax function to an n-dimensional input Tensor, rescaling them so that the elements of the n-dimensional output Tensor lie in the range (0, 1) and sum to 1.\" This is ambiguous with respect to what exactly should sum to 1 (what dimension/s the softmax should be performed over). What in fact happens, also a holdover from Torch7, is:\n\nFor a 1D input, the softmax takes place over dimension 0 (this was needed in Torch7 to support inputs without a batch dimension, which are not allowed in PyTorch). This is still reasonable default behavior, because there's no reason to use nn.Softmax when you have a batch of scalars.\nFor a 2D input, the softmax takes place over dimension 1. This is the most common case, and the desired behavior.\nFor a 3D input, the softmax takes place over dimension 0. This is usually wrong in PyTorch, since dimension 0 is usually the batch dimension. It may, however, be the right thing to do if dimension 0 is the timestep dimension of a timestep x batch x feature tensor; this is the desired behavior in RNNs with attention.\nFor a 4D input, the softmax again takes place over dimension 1.\nFor a 5D+ input, THNN gives a RuntimeError.\n\nIf all of this is intentional, then we should document it. The ideal solution is probably to keep this behavior and document it but add an optional dim argument, as in TensorFlow, that lets the user pick a dimension to softmax over. For reference, the default behavior in TF is to softmax over the last dimension, while the default behavior in Chainer (which can also IIRC be overridden by the user as of v2) is to softmax over dimension 1. It is occasionally also useful to be able to softmax over multiple dimensions at once, but this is easy to emulate with .view() so it's not necessary to have in core.\nIt may also be useful to add a torch.softmax with the same behavior as F.softmax, to apply the softmax operation to Tensors.", "body": "The docs for `nn.Softmax`, which are essentially copied over from Torch7's `nn.Softmax`, say \"Applies the SoftMax function to an n-dimensional input Tensor, rescaling them so that the elements of the n-dimensional output Tensor lie in the range (0, 1) and sum to 1.\" This is ambiguous with respect to what exactly should sum to 1 (what dimension/s the softmax should be performed over). What in fact happens, also a holdover from Torch7, is:\r\n- For a 1D input, the softmax takes place over dimension 0 (this was needed in Torch7 to support inputs without a batch dimension, which are not allowed in PyTorch). This is still reasonable default behavior, because there's no reason to use `nn.Softmax` when you have a batch of scalars.\r\n- For a 2D input, the softmax takes place over dimension 1. This is the most common case, and the desired behavior.\r\n- For a 3D input, the softmax takes place over dimension 0. This is usually wrong in PyTorch, since dimension 0 is usually the batch dimension. It may, however, be the right thing to do if dimension 0 is the timestep dimension of a timestep x batch x feature tensor; this is the desired behavior in RNNs with attention.\r\n- For a 4D input, the softmax again takes place over dimension 1.\r\n- For a 5D+ input, THNN gives a RuntimeError.\r\n\r\nIf all of this is intentional, then we should document it. The ideal solution is probably to keep this behavior and document it but add an optional `dim` argument, as in TensorFlow, that lets the user pick a dimension to softmax over. For reference, the default behavior in TF is to softmax over the last dimension, while the default behavior in Chainer (which can also IIRC be overridden by the user as of v2) is to softmax over dimension 1. It is occasionally also useful to be able to softmax over multiple dimensions at once, but this is easy to emulate with `.view()` so it's not necessary to have in core.\r\nIt may also be useful to add a `torch.softmax` with the same behavior as `F.softmax`, to apply the softmax operation to Tensors."}