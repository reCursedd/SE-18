{"url": "https://api.github.com/repos/pytorch/pytorch/issues/9089", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/9089/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/9089/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/9089/events", "html_url": "https://github.com/pytorch/pytorch/pull/9089", "id": 337353767, "node_id": "MDExOlB1bGxSZXF1ZXN0MTk4NTYxOTYw", "number": 9089, "title": "Unify THAllocator and THCDeviceAllocator with at::Allocator ", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2018-07-02T03:00:14Z", "updated_at": "2018-11-23T15:46:40Z", "closed_at": "2018-07-08T23:38:32Z", "author_association": "CONTRIBUTOR", "pull_request": {"url": "https://api.github.com/repos/pytorch/pytorch/pulls/9089", "html_url": "https://github.com/pytorch/pytorch/pull/9089", "diff_url": "https://github.com/pytorch/pytorch/pull/9089.diff", "patch_url": "https://github.com/pytorch/pytorch/pull/9089.patch"}, "body_html": "<p>Stacked on <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"337343084\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/9087\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/pytorch/pytorch/pull/9087/hovercard\" href=\"https://github.com/pytorch/pytorch/pull/9087\">#9087</a></p>\n<pre><code>    Unify THAllocator and THCDeviceAllocator with at::Allocator\n    \n    - at::Allocator is the type that \"survived\" this refactor, but\n      it grew a void* ctx argument.  This brings it in line\n      with the THAllocator interface.  Arguably, one might say that\n      void* ctx is bad design.  But...\n    \n        - We definitely need some sort of context for deleters,\n          because sometimes we need more information than the data\n          pointer itself to properly deallocate.  A simple example\n          is a dlpack tensor; to free the data, we need an\n          enclosing struct which contains the actual function pointer\n          to perform deletion.\n    \n        - So, it's quite plausible we can pack the deleter together\n          with its context data (e.g., an object with a function\n          pointer and its context).  This is not a bad idea, but this\n          patch is pretty long already, so we leave it for later.\n    \n    - THCDeviceAllocator has a few differences from at::Allocator:\n    \n        - It used to return a cudaError_t.  Now, allocators\n          are expected to check the error status immediately and throw\n          an exception if there was an error.  It turns out that this\n          is what was immediately done after all occurrences of\n          allocate/release, so it wasn't a big deal (although some\n          subsidiary interfaces had to themselves be converted to\n          not return cudaError_t).\n    \n          There is one notable exception to this, and it is how\n          we handle CUDA OOM: if this occurs, we attempt to return\n          unused memory to the system and try again.  This is now\n          handled by a catch-all try-catch block.\n    \n        - It used to take the CUDA stream to perform the allocation\n          on as an argument.  However, it turned out that all call\n          sites, this stream was the stream for the current device.\n          So we can push this into the allocator (and the choice,\n          in the future, could be made explicitly by twiddling\n          thread local state.)\n    \n        - It held two extra methods, emptyCache and cacheInfo, specifically\n          for interacting with some state in THCCachingAllocator.\n          But this \"generality\" was a lie, since THCCachingAllocator\n          was the only allocator that actually implemented these\n          methods, and there is actually a bunch of code in THC\n          which assumes that it is the caching allocator that is\n          the underlying allocator for CUDA allocations.  So I\n          folded these two methods into this interface as\n          THCCachingAllocator_emptyCache and THCCachingAllocator_cacheInfo.\n    \n        - It held its context directly inside the THCDeviceAllocator\n          struct.  This context has been moved out into whatever\n          is holding the at::Allocator*.\n\n    - I took the opportunity to replace all global variables with\n      getter functions; e.g., where you had &amp;THCudaHostAllocator,\n      you now have getTHCudaHostAllocator()\n    \n    - Realloc is no more.  (I'm not sure how important it was for\n      the CPU case.  However, if it was important, we have to add\n      it back very carefully. There is no way to write a \"default\"\n      implementation of realloc using malloc and free, because some\n      mechanism of copying data from the old region to the new\n      region is needed, and \"how to copy data\" is definitely not\n      in the purview of an allocator.  Furthermore, implementations\n      of realloc usually have side conditions: they usually only\n      work on plain-old-data, because the reallocator doesn't know\n      what the type of the data it is copying are.)  It's a lot\n      simpler for the design if we give up the slight optimization\n      we get in the CPU case from deferring the reallocation to the\n      system malloc() implementation, so I've dropped it for now.\n    \n    - allocatorVoidPtr is no more!  Now it's just an at::Allocator*\n    \n    I tried not to make big semantic changes to any of the downstream\n    allocators in this patch (as it was getting big), but a lot of the\n    downstream allocators are designed a bit strangely, since they\n    were built under the assumption that TH/THC could not be changed.\n    They definitely merit refactoring.\n   \n</code></pre>", "body_text": "Stacked on #9087\n    Unify THAllocator and THCDeviceAllocator with at::Allocator\n    \n    - at::Allocator is the type that \"survived\" this refactor, but\n      it grew a void* ctx argument.  This brings it in line\n      with the THAllocator interface.  Arguably, one might say that\n      void* ctx is bad design.  But...\n    \n        - We definitely need some sort of context for deleters,\n          because sometimes we need more information than the data\n          pointer itself to properly deallocate.  A simple example\n          is a dlpack tensor; to free the data, we need an\n          enclosing struct which contains the actual function pointer\n          to perform deletion.\n    \n        - So, it's quite plausible we can pack the deleter together\n          with its context data (e.g., an object with a function\n          pointer and its context).  This is not a bad idea, but this\n          patch is pretty long already, so we leave it for later.\n    \n    - THCDeviceAllocator has a few differences from at::Allocator:\n    \n        - It used to return a cudaError_t.  Now, allocators\n          are expected to check the error status immediately and throw\n          an exception if there was an error.  It turns out that this\n          is what was immediately done after all occurrences of\n          allocate/release, so it wasn't a big deal (although some\n          subsidiary interfaces had to themselves be converted to\n          not return cudaError_t).\n    \n          There is one notable exception to this, and it is how\n          we handle CUDA OOM: if this occurs, we attempt to return\n          unused memory to the system and try again.  This is now\n          handled by a catch-all try-catch block.\n    \n        - It used to take the CUDA stream to perform the allocation\n          on as an argument.  However, it turned out that all call\n          sites, this stream was the stream for the current device.\n          So we can push this into the allocator (and the choice,\n          in the future, could be made explicitly by twiddling\n          thread local state.)\n    \n        - It held two extra methods, emptyCache and cacheInfo, specifically\n          for interacting with some state in THCCachingAllocator.\n          But this \"generality\" was a lie, since THCCachingAllocator\n          was the only allocator that actually implemented these\n          methods, and there is actually a bunch of code in THC\n          which assumes that it is the caching allocator that is\n          the underlying allocator for CUDA allocations.  So I\n          folded these two methods into this interface as\n          THCCachingAllocator_emptyCache and THCCachingAllocator_cacheInfo.\n    \n        - It held its context directly inside the THCDeviceAllocator\n          struct.  This context has been moved out into whatever\n          is holding the at::Allocator*.\n\n    - I took the opportunity to replace all global variables with\n      getter functions; e.g., where you had &THCudaHostAllocator,\n      you now have getTHCudaHostAllocator()\n    \n    - Realloc is no more.  (I'm not sure how important it was for\n      the CPU case.  However, if it was important, we have to add\n      it back very carefully. There is no way to write a \"default\"\n      implementation of realloc using malloc and free, because some\n      mechanism of copying data from the old region to the new\n      region is needed, and \"how to copy data\" is definitely not\n      in the purview of an allocator.  Furthermore, implementations\n      of realloc usually have side conditions: they usually only\n      work on plain-old-data, because the reallocator doesn't know\n      what the type of the data it is copying are.)  It's a lot\n      simpler for the design if we give up the slight optimization\n      we get in the CPU case from deferring the reallocation to the\n      system malloc() implementation, so I've dropped it for now.\n    \n    - allocatorVoidPtr is no more!  Now it's just an at::Allocator*\n    \n    I tried not to make big semantic changes to any of the downstream\n    allocators in this patch (as it was getting big), but a lot of the\n    downstream allocators are designed a bit strangely, since they\n    were built under the assumption that TH/THC could not be changed.\n    They definitely merit refactoring.", "body": "Stacked on #9087\r\n\r\n```\r\n    Unify THAllocator and THCDeviceAllocator with at::Allocator\r\n    \r\n    - at::Allocator is the type that \"survived\" this refactor, but\r\n      it grew a void* ctx argument.  This brings it in line\r\n      with the THAllocator interface.  Arguably, one might say that\r\n      void* ctx is bad design.  But...\r\n    \r\n        - We definitely need some sort of context for deleters,\r\n          because sometimes we need more information than the data\r\n          pointer itself to properly deallocate.  A simple example\r\n          is a dlpack tensor; to free the data, we need an\r\n          enclosing struct which contains the actual function pointer\r\n          to perform deletion.\r\n    \r\n        - So, it's quite plausible we can pack the deleter together\r\n          with its context data (e.g., an object with a function\r\n          pointer and its context).  This is not a bad idea, but this\r\n          patch is pretty long already, so we leave it for later.\r\n    \r\n    - THCDeviceAllocator has a few differences from at::Allocator:\r\n    \r\n        - It used to return a cudaError_t.  Now, allocators\r\n          are expected to check the error status immediately and throw\r\n          an exception if there was an error.  It turns out that this\r\n          is what was immediately done after all occurrences of\r\n          allocate/release, so it wasn't a big deal (although some\r\n          subsidiary interfaces had to themselves be converted to\r\n          not return cudaError_t).\r\n    \r\n          There is one notable exception to this, and it is how\r\n          we handle CUDA OOM: if this occurs, we attempt to return\r\n          unused memory to the system and try again.  This is now\r\n          handled by a catch-all try-catch block.\r\n    \r\n        - It used to take the CUDA stream to perform the allocation\r\n          on as an argument.  However, it turned out that all call\r\n          sites, this stream was the stream for the current device.\r\n          So we can push this into the allocator (and the choice,\r\n          in the future, could be made explicitly by twiddling\r\n          thread local state.)\r\n    \r\n        - It held two extra methods, emptyCache and cacheInfo, specifically\r\n          for interacting with some state in THCCachingAllocator.\r\n          But this \"generality\" was a lie, since THCCachingAllocator\r\n          was the only allocator that actually implemented these\r\n          methods, and there is actually a bunch of code in THC\r\n          which assumes that it is the caching allocator that is\r\n          the underlying allocator for CUDA allocations.  So I\r\n          folded these two methods into this interface as\r\n          THCCachingAllocator_emptyCache and THCCachingAllocator_cacheInfo.\r\n    \r\n        - It held its context directly inside the THCDeviceAllocator\r\n          struct.  This context has been moved out into whatever\r\n          is holding the at::Allocator*.\r\n\r\n    - I took the opportunity to replace all global variables with\r\n      getter functions; e.g., where you had &THCudaHostAllocator,\r\n      you now have getTHCudaHostAllocator()\r\n    \r\n    - Realloc is no more.  (I'm not sure how important it was for\r\n      the CPU case.  However, if it was important, we have to add\r\n      it back very carefully. There is no way to write a \"default\"\r\n      implementation of realloc using malloc and free, because some\r\n      mechanism of copying data from the old region to the new\r\n      region is needed, and \"how to copy data\" is definitely not\r\n      in the purview of an allocator.  Furthermore, implementations\r\n      of realloc usually have side conditions: they usually only\r\n      work on plain-old-data, because the reallocator doesn't know\r\n      what the type of the data it is copying are.)  It's a lot\r\n      simpler for the design if we give up the slight optimization\r\n      we get in the CPU case from deferring the reallocation to the\r\n      system malloc() implementation, so I've dropped it for now.\r\n    \r\n    - allocatorVoidPtr is no more!  Now it's just an at::Allocator*\r\n    \r\n    I tried not to make big semantic changes to any of the downstream\r\n    allocators in this patch (as it was getting big), but a lot of the\r\n    downstream allocators are designed a bit strangely, since they\r\n    were built under the assumption that TH/THC could not be changed.\r\n    They definitely merit refactoring.\r\n   \r\n```"}