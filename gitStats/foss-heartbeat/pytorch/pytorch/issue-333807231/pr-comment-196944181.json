{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/196944181", "pull_request_review_id": 130590935, "id": 196944181, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5Njk0NDE4MQ==", "diff_hunk": "@@ -0,0 +1,233 @@\n+#pragma once\n+\n+#include \"caffe2/core/dispatch/DispatchKey.h\"\n+#include \"caffe2/utils/Metaprogramming.h\"\n+#include \"caffe2/utils/Array.h\"\n+\n+namespace caffe2 {\n+template<class Context> class Tensor;\n+class CPUContext;\n+class CUDAContext;\n+}  // namespace caffe2\n+\n+namespace c10 {\n+\n+namespace details {\n+\n+/**\n+ * If Arg is a Tensor or reference to a Tensor, provide the member constant value equal to true.  Otherwise\n+ * return false.\n+ */\n+template<class Arg> using is_tensor_arg = guts::is_instantiation_of<caffe2::Tensor, guts::remove_cv_t<guts::remove_reference_t<Arg>>>;\n+\n+// TODO get rid of tensor_to_dispatch_key once c2::Tensor is de-templatized. This then fits into a template lambda instead of a functor.\n+template<class TensorType, class Enable = void> struct tensor_to_dispatch_key_ final {};\n+template<class TensorType>\n+struct tensor_to_dispatch_key_<TensorType, guts::enable_if_t<std::is_same<TensorType, caffe2::Tensor<caffe2::CPUContext>>::value>> final {\n+    static TensorParameterDispatchKey call(const TensorType& tensor) {\n+      return TensorParameterDispatchKey{DeviceTypeId::CPU, LayoutId(0), tensor.meta().id()};\n+    }\n+};\n+template<class TensorType>\n+struct tensor_to_dispatch_key_<TensorType, guts::enable_if_t<std::is_same<TensorType, caffe2::Tensor<caffe2::CUDAContext>>::value>> final {\n+    static TensorParameterDispatchKey call(const TensorType& tensor) {\n+      return TensorParameterDispatchKey{DeviceTypeId::CUDA, LayoutId(0), tensor.meta().id()};\n+    }\n+};\n+struct tensor_to_dispatch_key final {\n+    template<class TensorType>\n+    TensorParameterDispatchKey operator()(const TensorType& tensor) const {\n+      return tensor_to_dispatch_key_<TensorType, void>::call(tensor);\n+    }\n+};\n+\n+/**\n+ * Extract the type ids of all tensors in a variadic list of arguments\n+ *\n+ * @tparam Args Inferred variadic list of argument types\n+ * @param args List of arguments to get type ids from\n+ * @return guts::array<TensorParameterDispatchKey, n>, where n is the number of tensor arguments (is_tensor_arg) in the class\n+ */\n+template<class... Args> auto getTensorTypeIds_(const Args&... args)\n+-> guts::array<TensorParameterDispatchKey, guts::typelist::count_if<is_tensor_arg, guts::typelist::typelist<Args...>>::value> {\n+  return guts::filter_map<TensorParameterDispatchKey, is_tensor_arg>(tensor_to_dispatch_key(), args...);\n+}\n+\n+// TODO Test getTensorTypeIds_\n+\n+/**\n+ * If T is a struct with a type field Signature, provides the member constant\n+ * @tparam T\n+ */\n+template<class T, typename = void>\n+struct has_signature_defined : std::false_type {};\n+template<class T>\n+struct has_signature_defined<T, guts::void_t<\n+  typename T::Signature\n+>> : std::true_type {};\n+\n+// TODO Test has_signature_defined\n+\n+template<class T, typename = void>\n+struct has_parameter_names_defined : std::false_type {};\n+template<class T>\n+struct has_parameter_names_defined<T, guts::void_t<\n+  decltype(T::parameter_names)\n+>> : std::true_type {};\n+\n+// TODO Test has_parameter_names_defined\n+\n+/**\n+ * Wrapper class around a user-provided schema definition some useful information about the schema.\n+ *\n+ * @tparam OpSchemaDef Operator schema definition.  See OpSchema for more details.\n+ */\n+template<class OpSchemaDef> class OpSignatureSchema final {\n+  static_assert(details::has_signature_defined<OpSchemaDef>::value, \"Operator schema doesn't define a valid Signature member type.\");\n+  static_assert(guts::is_function_type<typename OpSchemaDef::Signature>::value, \"Signature member of operator schema must be a function type.\");\n+\n+  using signature_traits = guts::function_traits<typename OpSchemaDef::Signature>;\n+public:\n+  /**\n+   * The function type OpSchemaDef::Signature\n+   */\n+  using func_type = typename signature_traits::func_type;\n+  /**\n+   * The return type of the function OpSchemaDef::Signature\n+   */\n+  using return_type = typename signature_traits::return_type;\n+  /**\n+   * A type list of the parameter types of OpSchemaDef::Signature\n+   */\n+  using parameter_types = typename signature_traits::parameter_types;\n+\n+  /**\n+   * The number of arguments of OpSchemaDef::Signature\n+   */\n+  static constexpr size_t num_args = guts::typelist::size<parameter_types>::value;\n+  /**\n+   * The number of tensor arguments (as per is_tensor_arg) in OpSchemaDef::Signature\n+   */\n+  static constexpr size_t num_tensor_args = guts::typelist::count_if<details::is_tensor_arg, parameter_types>::value;\n+\n+private:\n+  static_assert(details::has_parameter_names_defined<OpSchemaDef>::value, \"Operator schema doesn't define parameter_names member.\");\n+  // TODO Allow simpler definition of parameter_names without having to spell out the guts::array type in the schema def.\n+  static_assert(std::is_same<const guts::array<const char*, num_args>, decltype(OpSchemaDef::parameter_names)>::value, \"Operator schema defines parameter_names member, but it isn't the correct type. Must be a static constexpr guts::array of const char* with one entry for each parameter.\");\n+\n+public:\n+  /**\n+   * The names of the parameters (as per OpSchemaDef::parameter_names)\n+   * @return Array\n+   */\n+  static constexpr const guts::array<const char*, num_args>& parameter_names() {\n+    return OpSchemaDef::parameter_names;\n+  }\n+};\n+\n+/**\n+ * If T has a method dispatch_key, provide a member constant value equal to true.  Otherwise return false.\n+ * @tparam T\n+ */\n+template<class T, typename = void>\n+struct has_function_dispatch_key_defined : std::false_type {};\n+template<class T>\n+struct has_function_dispatch_key_defined<T, guts::void_t<\n+  decltype(&T::dispatch_key)\n+>> : std::true_type {};\n+\n+/**\n+ * Wrapper class around a user-defined schema definition providing a way of computing a dispatch key\n+ * from arguments matching the signature of that schema.\n+ *\n+ * @tparam OpSchemaDef Operator schema definition.  See OpSchema for more details.\n+ * @tparam Enable Inferred, used to control specialization\n+ */\n+template<class OpSchemaDef, class Enable = void> class OpDispatchKeySchema final {};\n+\n+// General case. Operator doesn't overwrite DispatchKey generation. Use default.\n+template<class OpSchemaDef>\n+class OpDispatchKeySchema<OpSchemaDef, guts::enable_if_t<!has_function_dispatch_key_defined<OpSchemaDef>::value>> final {\n+  using signature = OpSignatureSchema<OpSchemaDef>;\n+\n+public:\n+  using dispatch_key_type = DispatchKey<signature::num_tensor_args>;\n+\n+  template<class... Args>\n+  static inline dispatch_key_type dispatch_key(const Args&... args) {\n+    using guts::typelist::map_t;\n+    using guts::typelist::typelist;\n+    static_assert(std::is_same<\n+      map_t<guts::remove_cv_t, map_t<guts::remove_reference_t, typelist<Args...>>>,\n+      map_t<guts::remove_cv_t, map_t<guts::remove_reference_t, typename signature::parameter_types>>\n+      >::value, \"Invalid argument types passed to OpSchema::dispatch_key()\");\n+    return dispatch_key_type {\n+      details::getTensorTypeIds_(args...)\n+    };\n+  }\n+};\n+\n+// Special case. Operator overwrites DispatchKey generation. Use that.\n+template<class OpSchemaDef>\n+class OpDispatchKeySchema<OpSchemaDef, guts::enable_if_t<has_function_dispatch_key_defined<OpSchemaDef>::value>> final {\n+  using signature = OpSignatureSchema<OpSchemaDef>;\n+\n+  static_assert(guts::is_function_type<decltype(OpSchemaDef::dispatch_key)>::value, \"Operator schema defines dispatch_key member, but it isn't a function.\");\n+\n+  using dispatch_key_traits = guts::function_traits<decltype(OpSchemaDef::dispatch_key)>;\n+\n+public:\n+  using dispatch_key_type = typename dispatch_key_traits::return_type;\n+\n+private:\n+\n+  static_assert(guts::is_equality_comparable<dispatch_key_type>::value, \"Operator schema specified custom dispatch_key() derivation function, but the returned dispatch key type doesn't have the equality operator defined. Please define it.\");\n+  static_assert(guts::is_hashable<dispatch_key_type>::value, \"Operator schema specified custom dispatch_key() derivation function, but the returned dispatch key type doesn't have an overload for std::hash. Please define it.\");\n+\n+  static_assert(std::is_same<\n+    guts::typelist::map_t<guts::remove_cv_t, guts::typelist::map_t<guts::remove_reference_t, typename dispatch_key_traits::parameter_types>>,\n+    guts::typelist::map_t<guts::remove_cv_t, guts::typelist::map_t<guts::remove_reference_t, typename signature::parameter_types>>\n+    >::value, \"Operator schema defines custom dispatch_key() derivation function, but the arguments don't match the operator signature.\");\n+\n+public:\n+\n+  template<class... Args>\n+  static inline dispatch_key_type dispatch_key(const Args&... args) {\n+    using guts::typelist::map_t;\n+    using guts::typelist::typelist;\n+    static_assert(std::is_same<\n+      map_t<guts::remove_cv_t, map_t<guts::remove_reference_t, typelist<Args...>>>,\n+      map_t<guts::remove_cv_t, map_t<guts::remove_reference_t, typename signature::parameter_types>>\n+      >::value, \"Invalid argument types passed to OpSchema::dispatch_key()\");\n+    return OpSchemaDef::dispatch_key(args...);\n+  }\n+};\n+\n+}  // namespace details\n+\n+/**\n+ * Wrapper class for user-defined OpSchemaDef, providing functionality for determining\n+ * information about the signature and dispatching on that signature.  This is the\n+ * \"public\" facing class.\n+ *\n+ * @tparam OpSchemaDef User-defined OpSchemaDef.\n+ *   This struct is expected to define:\n+ *      - a function type Signature\n+ *      - a constexpr guts<const char*, n_args> parameter_names field (where n_args is\n+ *        the number of arguments in Signature)", "path": "caffe2/core/dispatch/OpSchema.h", "position": 217, "original_position": 217, "commit_id": "dc0577c9f521b81b236c172357c8522af30c68b0", "original_commit_id": "ef14f37bd6952e3d71fb910c2aba78fe88d0b331", "user": {"login": "smessmer", "id": 2373925, "node_id": "MDQ6VXNlcjIzNzM5MjU=", "avatar_url": "https://avatars3.githubusercontent.com/u/2373925?v=4", "gravatar_id": "", "url": "https://api.github.com/users/smessmer", "html_url": "https://github.com/smessmer", "followers_url": "https://api.github.com/users/smessmer/followers", "following_url": "https://api.github.com/users/smessmer/following{/other_user}", "gists_url": "https://api.github.com/users/smessmer/gists{/gist_id}", "starred_url": "https://api.github.com/users/smessmer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/smessmer/subscriptions", "organizations_url": "https://api.github.com/users/smessmer/orgs", "repos_url": "https://api.github.com/users/smessmer/repos", "events_url": "https://api.github.com/users/smessmer/events{/privacy}", "received_events_url": "https://api.github.com/users/smessmer/received_events", "type": "User", "site_admin": false}, "body": "What do you mean UI changes? Changes to how OpSchemaDef has to be written or changes to how OpSchema exposes the parsed structure?", "created_at": "2018-06-20T21:11:54Z", "updated_at": "2018-11-23T15:45:57Z", "html_url": "https://github.com/pytorch/pytorch/pull/8662#discussion_r196944181", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/8662", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/196944181"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/8662#discussion_r196944181"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/8662"}}, "body_html": "<p>What do you mean UI changes? Changes to how OpSchemaDef has to be written or changes to how OpSchema exposes the parsed structure?</p>", "body_text": "What do you mean UI changes? Changes to how OpSchemaDef has to be written or changes to how OpSchema exposes the parsed structure?", "in_reply_to_id": 196621052}