{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/184411891", "pull_request_review_id": 115602829, "id": 184411891, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4NDQxMTg5MQ==", "diff_hunk": "@@ -88,7 +88,7 @@ struct THPFunction {\n \n     // The C++ wrapper for this Python function.\n     // See a comment in THPFunction_asFunction for details about this field.\n-    torch::autograd::PyFunction cdata;\n+    torch::autograd::PyFunction* cdata;", "path": "torch/csrc/autograd/python_function.h", "position": null, "original_position": 5, "commit_id": "92adc80cb73a1748ab2cb0cbe4eb50df38b7b051", "original_commit_id": "2bc1f600394d258546418040c895dafe7c972cbd", "user": {"login": "zou3519", "id": 5652049, "node_id": "MDQ6VXNlcjU2NTIwNDk=", "avatar_url": "https://avatars3.githubusercontent.com/u/5652049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zou3519", "html_url": "https://github.com/zou3519", "followers_url": "https://api.github.com/users/zou3519/followers", "following_url": "https://api.github.com/users/zou3519/following{/other_user}", "gists_url": "https://api.github.com/users/zou3519/gists{/gist_id}", "starred_url": "https://api.github.com/users/zou3519/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zou3519/subscriptions", "organizations_url": "https://api.github.com/users/zou3519/orgs", "repos_url": "https://api.github.com/users/zou3519/repos", "events_url": "https://api.github.com/users/zou3519/events{/privacy}", "received_events_url": "https://api.github.com/users/zou3519/received_events", "type": "User", "site_admin": false}, "body": "Still strong. A THPFunction owns the underlying PyFunction (should I make this into a std::unique_ptr to make this clearer, or add more comments?)\r\n\r\nHere's the reason why I made it into a pointer. Let's say we have the following computation graph:\r\n\r\n```\r\n(1) shared_ptr<PyFunction> -> (2) Edge -> \r\n(3) shared_ptr<Function> -> (4) Edge -> \r\n(5) shared_ptr<Function> -> ...\r\n```\r\n\r\nWhen this computation graph gets freed, what first happens is that the use_count of (1) goes to 0. When that happens:\r\n- The PyFunction doesn't get destroyed yet. Each PyFunction shared_ptr has a special destructor that does one thing: decref the python refcount on the THPFunction that owns the PyFunction.\r\n- The THPFunction's python refcount goes to 0 if there are no more references. When that happens, the THPFunction's deleter gets called.\r\n- THPFunction's deleter calls cdata (a PyFunction)'s deleter. cdata is the wrapped PyFunction in the shared_ptr of (1). This deleter will trigger the deletion of the Edge (2) and trigger the chain of deletions.\r\n\r\nWhat we would like here is to use the custom deleter with the PyFunction. However, the THPFunction object owns the PyFunction (and because the PyFunction is a member of THPFunction, when the THPFunction struct gets freed, the PyFunction can't exist by itself). So the solution I had was to make THPFunction own a `PyFunction*`.  The following steps happen now:\r\n1) The use_count of (1) goes to 0\r\n2) Py_DECREF is called on the THPFunction that owns the underlying PyFunction\r\n3) THPFunction's refcount goes to 0\r\n4) THPFunction's deleter is called\r\n5) The PyFunction* is deleted with the custom deleter that either deletes the PyFunction on the spot OR queues it into our thread-local delete queue\r\n", "created_at": "2018-04-26T14:33:43Z", "updated_at": "2018-11-23T15:43:15Z", "html_url": "https://github.com/pytorch/pytorch/pull/6873#discussion_r184411891", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/6873", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/184411891"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/6873#discussion_r184411891"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/6873"}}, "body_html": "<p>Still strong. A THPFunction owns the underlying PyFunction (should I make this into a std::unique_ptr to make this clearer, or add more comments?)</p>\n<p>Here's the reason why I made it into a pointer. Let's say we have the following computation graph:</p>\n<pre><code>(1) shared_ptr&lt;PyFunction&gt; -&gt; (2) Edge -&gt; \n(3) shared_ptr&lt;Function&gt; -&gt; (4) Edge -&gt; \n(5) shared_ptr&lt;Function&gt; -&gt; ...\n</code></pre>\n<p>When this computation graph gets freed, what first happens is that the use_count of (1) goes to 0. When that happens:</p>\n<ul>\n<li>The PyFunction doesn't get destroyed yet. Each PyFunction shared_ptr has a special destructor that does one thing: decref the python refcount on the THPFunction that owns the PyFunction.</li>\n<li>The THPFunction's python refcount goes to 0 if there are no more references. When that happens, the THPFunction's deleter gets called.</li>\n<li>THPFunction's deleter calls cdata (a PyFunction)'s deleter. cdata is the wrapped PyFunction in the shared_ptr of (1). This deleter will trigger the deletion of the Edge (2) and trigger the chain of deletions.</li>\n</ul>\n<p>What we would like here is to use the custom deleter with the PyFunction. However, the THPFunction object owns the PyFunction (and because the PyFunction is a member of THPFunction, when the THPFunction struct gets freed, the PyFunction can't exist by itself). So the solution I had was to make THPFunction own a <code>PyFunction*</code>.  The following steps happen now:</p>\n<ol>\n<li>The use_count of (1) goes to 0</li>\n<li>Py_DECREF is called on the THPFunction that owns the underlying PyFunction</li>\n<li>THPFunction's refcount goes to 0</li>\n<li>THPFunction's deleter is called</li>\n<li>The PyFunction* is deleted with the custom deleter that either deletes the PyFunction on the spot OR queues it into our thread-local delete queue</li>\n</ol>", "body_text": "Still strong. A THPFunction owns the underlying PyFunction (should I make this into a std::unique_ptr to make this clearer, or add more comments?)\nHere's the reason why I made it into a pointer. Let's say we have the following computation graph:\n(1) shared_ptr<PyFunction> -> (2) Edge -> \n(3) shared_ptr<Function> -> (4) Edge -> \n(5) shared_ptr<Function> -> ...\n\nWhen this computation graph gets freed, what first happens is that the use_count of (1) goes to 0. When that happens:\n\nThe PyFunction doesn't get destroyed yet. Each PyFunction shared_ptr has a special destructor that does one thing: decref the python refcount on the THPFunction that owns the PyFunction.\nThe THPFunction's python refcount goes to 0 if there are no more references. When that happens, the THPFunction's deleter gets called.\nTHPFunction's deleter calls cdata (a PyFunction)'s deleter. cdata is the wrapped PyFunction in the shared_ptr of (1). This deleter will trigger the deletion of the Edge (2) and trigger the chain of deletions.\n\nWhat we would like here is to use the custom deleter with the PyFunction. However, the THPFunction object owns the PyFunction (and because the PyFunction is a member of THPFunction, when the THPFunction struct gets freed, the PyFunction can't exist by itself). So the solution I had was to make THPFunction own a PyFunction*.  The following steps happen now:\n\nThe use_count of (1) goes to 0\nPy_DECREF is called on the THPFunction that owns the underlying PyFunction\nTHPFunction's refcount goes to 0\nTHPFunction's deleter is called\nThe PyFunction* is deleted with the custom deleter that either deletes the PyFunction on the spot OR queues it into our thread-local delete queue", "in_reply_to_id": 184331741}