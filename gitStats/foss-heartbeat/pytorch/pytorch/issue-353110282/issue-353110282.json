{"url": "https://api.github.com/repos/pytorch/pytorch/issues/10793", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/10793/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/10793/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/10793/events", "html_url": "https://github.com/pytorch/pytorch/issues/10793", "id": 353110282, "node_id": "MDU6SXNzdWUzNTMxMTAyODI=", "number": 10793, "title": "[JIT] Fixing split/chunk and other operators that return lists", "user": {"login": "zdevito", "id": 370202, "node_id": "MDQ6VXNlcjM3MDIwMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/370202?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zdevito", "html_url": "https://github.com/zdevito", "followers_url": "https://api.github.com/users/zdevito/followers", "following_url": "https://api.github.com/users/zdevito/following{/other_user}", "gists_url": "https://api.github.com/users/zdevito/gists{/gist_id}", "starred_url": "https://api.github.com/users/zdevito/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zdevito/subscriptions", "organizations_url": "https://api.github.com/users/zdevito/orgs", "repos_url": "https://api.github.com/users/zdevito/repos", "events_url": "https://api.github.com/users/zdevito/events{/privacy}", "received_events_url": "https://api.github.com/users/zdevito/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 679953983, "node_id": "MDU6TGFiZWw2Nzk5NTM5ODM=", "url": "https://api.github.com/repos/pytorch/pytorch/labels/jit", "name": "jit", "color": "c5def5", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2018-08-22T20:24:19Z", "updated_at": "2018-09-10T23:33:37Z", "closed_at": "2018-09-10T23:33:37Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Fixing split/chunk and other operators that return lists:</p>\n<p>Operators that return tensor list (e.g. chunk, split) currently flatten the list into outputs.<br>\nThe tracer explicitly calls flatten_tensor_args to do this. And the <code>pack</code> function also flatten these args. This makes these functions unusable from script (and often there are problems with tracing as well, e.g. split does  not trace correctly according to TestJitGenerated.test_split_dim).<br>\nThey are unusable in script because script excepts there to be a single list returned from the op, and has no way to know how many elements would be created in the list. Chunk works because of a special case in the compiler that teaches it how to know if there is a constant number of outputs.</p>\n<p>To fix this behavior, we need to change the behavior in operators to actually return a single list object. For operators, this means changing <code>pack(std::vector&lt;Tensor&gt;)</code> to push a single TensorList rather than individual tensors as outputs.</p>\n<p>This will then break fusion/differentiation of chunk nodes which is important for lstms. To fix chunk node differentiation/fusion, we need to replace <code>aten::chunk</code> with a different op (lets call it <code>prim::ConstantChunk</code>) when the number of chunks is known in the compiler. The differentiator and fuser should then be switched to work with <code>prim::ConstantChunk</code>.</p>\n<p>This will also break tracing, which calls <code>flatten_tensor_args</code> on lists. We need to change this so that when the tracer runs, it<br>\nrecords a list as:</p>\n<p>before:</p>\n<pre><code>output_0, output_1, output_2 = aten::split(x)\n</code></pre>\n<p>after:</p>\n<pre><code>output_list = aten::split(x)\noutput_0, output_1, output_2 = prim::UnpackList(output_list)\n</code></pre>\n<p><code>prim::UnpackList</code> is like <code>UnpackTuple</code> but is required to check that the list has an expected number of elements that<br>\nmatches the number of outputs in the op.</p>\n<p>At the end we will have:</p>\n<ul>\n<li>ability to call split, chunk, and any other operator from script</li>\n<li>continued ability to call chunk from tracing, and fixing the bugs with split in tracing</li>\n<li>continued ability for lstm code which includes chunk calls to be differentiated and fused because of introducing prim::ConstantChunk in place of chunk in the cases where<br>\nwe know it is constant.</li>\n</ul>", "body_text": "Fixing split/chunk and other operators that return lists:\nOperators that return tensor list (e.g. chunk, split) currently flatten the list into outputs.\nThe tracer explicitly calls flatten_tensor_args to do this. And the pack function also flatten these args. This makes these functions unusable from script (and often there are problems with tracing as well, e.g. split does  not trace correctly according to TestJitGenerated.test_split_dim).\nThey are unusable in script because script excepts there to be a single list returned from the op, and has no way to know how many elements would be created in the list. Chunk works because of a special case in the compiler that teaches it how to know if there is a constant number of outputs.\nTo fix this behavior, we need to change the behavior in operators to actually return a single list object. For operators, this means changing pack(std::vector<Tensor>) to push a single TensorList rather than individual tensors as outputs.\nThis will then break fusion/differentiation of chunk nodes which is important for lstms. To fix chunk node differentiation/fusion, we need to replace aten::chunk with a different op (lets call it prim::ConstantChunk) when the number of chunks is known in the compiler. The differentiator and fuser should then be switched to work with prim::ConstantChunk.\nThis will also break tracing, which calls flatten_tensor_args on lists. We need to change this so that when the tracer runs, it\nrecords a list as:\nbefore:\noutput_0, output_1, output_2 = aten::split(x)\n\nafter:\noutput_list = aten::split(x)\noutput_0, output_1, output_2 = prim::UnpackList(output_list)\n\nprim::UnpackList is like UnpackTuple but is required to check that the list has an expected number of elements that\nmatches the number of outputs in the op.\nAt the end we will have:\n\nability to call split, chunk, and any other operator from script\ncontinued ability to call chunk from tracing, and fixing the bugs with split in tracing\ncontinued ability for lstm code which includes chunk calls to be differentiated and fused because of introducing prim::ConstantChunk in place of chunk in the cases where\nwe know it is constant.", "body": "Fixing split/chunk and other operators that return lists:\r\n\r\nOperators that return tensor list (e.g. chunk, split) currently flatten the list into outputs.\r\nThe tracer explicitly calls flatten_tensor_args to do this. And the `pack` function also flatten these args. This makes these functions unusable from script (and often there are problems with tracing as well, e.g. split does  not trace correctly according to TestJitGenerated.test_split_dim). \r\nThey are unusable in script because script excepts there to be a single list returned from the op, and has no way to know how many elements would be created in the list. Chunk works because of a special case in the compiler that teaches it how to know if there is a constant number of outputs.\r\n\r\n\r\nTo fix this behavior, we need to change the behavior in operators to actually return a single list object. For operators, this means changing `pack(std::vector<Tensor>)` to push a single TensorList rather than individual tensors as outputs.\r\n\r\nThis will then break fusion/differentiation of chunk nodes which is important for lstms. To fix chunk node differentiation/fusion, we need to replace `aten::chunk` with a different op (lets call it `prim::ConstantChunk`) when the number of chunks is known in the compiler. The differentiator and fuser should then be switched to work with `prim::ConstantChunk`.\r\n\r\nThis will also break tracing, which calls `flatten_tensor_args` on lists. We need to change this so that when the tracer runs, it \r\nrecords a list as:\r\n\r\nbefore:\r\n\r\n```\r\noutput_0, output_1, output_2 = aten::split(x)\r\n```\r\n\r\nafter:\r\n\r\n```\r\noutput_list = aten::split(x)\r\noutput_0, output_1, output_2 = prim::UnpackList(output_list)\r\n```\r\n\r\n`prim::UnpackList` is like `UnpackTuple` but is required to check that the list has an expected number of elements that \r\nmatches the number of outputs in the op.\r\n\r\nAt the end we will have:\r\n* ability to call split, chunk, and any other operator from script\r\n* continued ability to call chunk from tracing, and fixing the bugs with split in tracing\r\n* continued ability for lstm code which includes chunk calls to be differentiated and fused because of introducing prim::ConstantChunk in place of chunk in the cases where\r\n  we know it is constant.\r\n"}