{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/143834449", "pull_request_review_id": 68403569, "id": 143834449, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE0MzgzNDQ0OQ==", "diff_hunk": "@@ -551,6 +551,81 @@ def __repr__(self):\n         tmpstr = tmpstr + ')'\n         return tmpstr\n \n+    def summary(self, input_size):\n+        def register_hook(module):\n+            def hook(module, input, output):\n+                class_name = str(module.__class__).split('.')[-1].split(\"'\")[0]\n+                module_idx = len(summary)\n+                m_key = '%s-%i' % (class_name, module_idx + 1)\n+                summary[m_key] = OrderedDict()\n+                summary[m_key]['input_shape'] = list(input[0].size())\n+                summary[m_key]['input_shape'][0] = None\n+                summary[m_key]['output_shape'] = list(output.size())\n+                summary[m_key]['output_shape'][0] = None\n+\n+                params = 0\n+                # iterate through parameters and count num params\n+                for name, p in module._parameters.items():\n+                    params += torch.numel(p.data)\n+                    if p.requires_grad:\n+                        summary[m_key]['trainable'] = True\n+                    else:\n+                        summary[m_key]['trainable'] = False\n+\n+                summary[m_key]['nb_params'] = params\n+\n+            if not isinstance(module, torch.nn.Sequential) and \\\n+               not isinstance(module, torch.nn.ModuleList) and \\\n+               not (module == self):\n+                hooks.append(module.register_forward_hook(hook))\n+\n+        # check if there are multiple inputs to the network\n+        if isinstance(input_size[0], (list, tuple)):\n+            x = [Variable(torch.rand(1, *in_size)) for in_size in input_size]\n+        else:\n+            x = Variable(torch.randn(1, *input_size))\n+\n+        # create properties\n+        summary = OrderedDict()\n+        hooks = []\n+        # register hook\n+        self.apply(register_hook)\n+        # make a forward pass\n+        self(x)\n+        # remove these hooks\n+        for h in hooks:\n+            h.remove()\n+\n+        # print out neatly\n+        names = list(self._modules.keys())\n+        col_width = 25  # should be >= 12\n+        summary_width = 61\n+\n+        def crop(s):\n+            return s[:col_width] if len(s) > col_width else s\n+\n+        print('_' * summary_width)\n+        print('{0: <{3}} {1: <{3}} {2: <{3}}'.format(\n+            'Layer (type)', 'Output Shape', 'Param #', col_width))\n+        print('=' * summary_width)\n+        total_params = 0\n+        trainable_params = 0\n+        for (i, l_type), l_name in zip(enumerate(summary), names):", "path": "torch/nn/modules/module.py", "position": 74, "original_position": 63, "commit_id": "b7b04c276b0cf406e327d1192f61489b78267488", "original_commit_id": "b3af05aad38f53f0b67713f1313537d16f0479b7", "user": {"login": "fmassa", "id": 9110200, "node_id": "MDQ6VXNlcjkxMTAyMDA=", "avatar_url": "https://avatars2.githubusercontent.com/u/9110200?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fmassa", "html_url": "https://github.com/fmassa", "followers_url": "https://api.github.com/users/fmassa/followers", "following_url": "https://api.github.com/users/fmassa/following{/other_user}", "gists_url": "https://api.github.com/users/fmassa/gists{/gist_id}", "starred_url": "https://api.github.com/users/fmassa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fmassa/subscriptions", "organizations_url": "https://api.github.com/users/fmassa/orgs", "repos_url": "https://api.github.com/users/fmassa/repos", "events_url": "https://api.github.com/users/fmassa/events{/privacy}", "received_events_url": "https://api.github.com/users/fmassa/received_events", "type": "User", "site_admin": false}, "body": "Because of the mismatch I mentioned earlier, `zip` will terminate once `names` are finished. But if imagine the following (updated) example:\r\n```python\r\nclass Model0(nn.Module):\r\n    def __init__(self):\r\n        super(Model0, self).__init__()\r\n        self.conv00 = nn.Conv2d(1, 1, 1)\r\n        self.conv01 = nn.Conv2d(1, 1, 1)\r\n    def forward(self, input):\r\n        return self.conv01(self.conv00(input))\r\n\r\nclass Model(nn.Module):\r\n    def __init__(self):\r\n        super(Model, self).__init__()\r\n        self.mod = Model0()\r\n        self.conv1 = nn.Conv2d(1, 1, 1)\r\n    def forward(self, input):\r\n        return self.conv1(self.mod(input))\r\n```\r\nBecause of the order of the execution, the modules in `mod` will first be registered in `summary`, and then `conv1` will be registered. But, `names`correspond to only `mod` and `conv1`, which means that the summary that is printed is not correct.", "created_at": "2017-10-10T19:53:22Z", "updated_at": "2018-11-23T15:35:13Z", "html_url": "https://github.com/pytorch/pytorch/pull/3043#discussion_r143834449", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/3043", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/143834449"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/3043#discussion_r143834449"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/3043"}}, "body_html": "<p>Because of the mismatch I mentioned earlier, <code>zip</code> will terminate once <code>names</code> are finished. But if imagine the following (updated) example:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">class</span> <span class=\"pl-en\">Model0</span>(<span class=\"pl-e\">nn</span>.<span class=\"pl-e\">Module</span>):\n    <span class=\"pl-k\">def</span> <span class=\"pl-c1\">__init__</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>):\n        <span class=\"pl-c1\">super</span>(Model0, <span class=\"pl-c1\">self</span>).<span class=\"pl-c1\">__init__</span>()\n        <span class=\"pl-c1\">self</span>.conv00 <span class=\"pl-k\">=</span> nn.Conv2d(<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">1</span>)\n        <span class=\"pl-c1\">self</span>.conv01 <span class=\"pl-k\">=</span> nn.Conv2d(<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">1</span>)\n    <span class=\"pl-k\">def</span> <span class=\"pl-en\">forward</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>, <span class=\"pl-smi\">input</span>):\n        <span class=\"pl-k\">return</span> <span class=\"pl-c1\">self</span>.conv01(<span class=\"pl-c1\">self</span>.conv00(<span class=\"pl-c1\">input</span>))\n\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">Model</span>(<span class=\"pl-e\">nn</span>.<span class=\"pl-e\">Module</span>):\n    <span class=\"pl-k\">def</span> <span class=\"pl-c1\">__init__</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>):\n        <span class=\"pl-c1\">super</span>(Model, <span class=\"pl-c1\">self</span>).<span class=\"pl-c1\">__init__</span>()\n        <span class=\"pl-c1\">self</span>.mod <span class=\"pl-k\">=</span> Model0()\n        <span class=\"pl-c1\">self</span>.conv1 <span class=\"pl-k\">=</span> nn.Conv2d(<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">1</span>)\n    <span class=\"pl-k\">def</span> <span class=\"pl-en\">forward</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>, <span class=\"pl-smi\">input</span>):\n        <span class=\"pl-k\">return</span> <span class=\"pl-c1\">self</span>.conv1(<span class=\"pl-c1\">self</span>.mod(<span class=\"pl-c1\">input</span>))</pre></div>\n<p>Because of the order of the execution, the modules in <code>mod</code> will first be registered in <code>summary</code>, and then <code>conv1</code> will be registered. But, <code>names</code>correspond to only <code>mod</code> and <code>conv1</code>, which means that the summary that is printed is not correct.</p>", "body_text": "Because of the mismatch I mentioned earlier, zip will terminate once names are finished. But if imagine the following (updated) example:\nclass Model0(nn.Module):\n    def __init__(self):\n        super(Model0, self).__init__()\n        self.conv00 = nn.Conv2d(1, 1, 1)\n        self.conv01 = nn.Conv2d(1, 1, 1)\n    def forward(self, input):\n        return self.conv01(self.conv00(input))\n\nclass Model(nn.Module):\n    def __init__(self):\n        super(Model, self).__init__()\n        self.mod = Model0()\n        self.conv1 = nn.Conv2d(1, 1, 1)\n    def forward(self, input):\n        return self.conv1(self.mod(input))\nBecause of the order of the execution, the modules in mod will first be registered in summary, and then conv1 will be registered. But, namescorrespond to only mod and conv1, which means that the summary that is printed is not correct."}