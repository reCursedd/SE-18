{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/388609622", "html_url": "https://github.com/pytorch/pytorch/issues/7313#issuecomment-388609622", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/7313", "id": 388609622, "node_id": "MDEyOklzc3VlQ29tbWVudDM4ODYwOTYyMg==", "user": {"login": "t-vi", "id": 20787943, "node_id": "MDQ6VXNlcjIwNzg3OTQz", "avatar_url": "https://avatars2.githubusercontent.com/u/20787943?v=4", "gravatar_id": "", "url": "https://api.github.com/users/t-vi", "html_url": "https://github.com/t-vi", "followers_url": "https://api.github.com/users/t-vi/followers", "following_url": "https://api.github.com/users/t-vi/following{/other_user}", "gists_url": "https://api.github.com/users/t-vi/gists{/gist_id}", "starred_url": "https://api.github.com/users/t-vi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/t-vi/subscriptions", "organizations_url": "https://api.github.com/users/t-vi/orgs", "repos_url": "https://api.github.com/users/t-vi/repos", "events_url": "https://api.github.com/users/t-vi/events{/privacy}", "received_events_url": "https://api.github.com/users/t-vi/received_events", "type": "User", "site_admin": false}, "created_at": "2018-05-13T08:17:06Z", "updated_at": "2018-05-13T08:17:06Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=15841449\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/ngimel\">@ngimel</a> Nice, that looks like a clean variant of how weight_norm is currently done in master.</p>\n<p>One thing I am wondering (and I think that is the main difference to my proposed implementation strategy): Is this something that works at module or at parameter level. I see it more naturally at the parameter level, while the other solutions seem to look more at the module level.</p>\n<p>One thing that isn't easily achieved with my demo implementation is having multiple parameters that need to be calculated jointly. This could be achieved by returning a dict and have getattr check for that.</p>\n<p>In terms of usability (\"less boilerplate code\") I think that allowing the parameter computation to be in a nn.Module subclass is a more natural solution than wrappers.</p>", "body_text": "@ngimel Nice, that looks like a clean variant of how weight_norm is currently done in master.\nOne thing I am wondering (and I think that is the main difference to my proposed implementation strategy): Is this something that works at module or at parameter level. I see it more naturally at the parameter level, while the other solutions seem to look more at the module level.\nOne thing that isn't easily achieved with my demo implementation is having multiple parameters that need to be calculated jointly. This could be achieved by returning a dict and have getattr check for that.\nIn terms of usability (\"less boilerplate code\") I think that allowing the parameter computation to be in a nn.Module subclass is a more natural solution than wrappers.", "body": "@ngimel Nice, that looks like a clean variant of how weight_norm is currently done in master.\r\n\r\nOne thing I am wondering (and I think that is the main difference to my proposed implementation strategy): Is this something that works at module or at parameter level. I see it more naturally at the parameter level, while the other solutions seem to look more at the module level.\r\n\r\nOne thing that isn't easily achieved with my demo implementation is having multiple parameters that need to be calculated jointly. This could be achieved by returning a dict and have getattr check for that.\r\n\r\nIn terms of usability (\"less boilerplate code\") I think that allowing the parameter computation to be in a nn.Module subclass is a more natural solution than wrappers."}