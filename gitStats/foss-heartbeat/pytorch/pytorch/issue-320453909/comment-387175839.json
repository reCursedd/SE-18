{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/387175839", "html_url": "https://github.com/pytorch/pytorch/issues/7313#issuecomment-387175839", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/7313", "id": 387175839, "node_id": "MDEyOklzc3VlQ29tbWVudDM4NzE3NTgzOQ==", "user": {"login": "t-vi", "id": 20787943, "node_id": "MDQ6VXNlcjIwNzg3OTQz", "avatar_url": "https://avatars2.githubusercontent.com/u/20787943?v=4", "gravatar_id": "", "url": "https://api.github.com/users/t-vi", "html_url": "https://github.com/t-vi", "followers_url": "https://api.github.com/users/t-vi/followers", "following_url": "https://api.github.com/users/t-vi/following{/other_user}", "gists_url": "https://api.github.com/users/t-vi/gists{/gist_id}", "starred_url": "https://api.github.com/users/t-vi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/t-vi/subscriptions", "organizations_url": "https://api.github.com/users/t-vi/orgs", "repos_url": "https://api.github.com/users/t-vi/repos", "events_url": "https://api.github.com/users/t-vi/events{/privacy}", "received_events_url": "https://api.github.com/users/t-vi/received_events", "type": "User", "site_admin": false}, "created_at": "2018-05-07T19:27:24Z", "updated_at": "2018-05-07T19:31:18Z", "author_association": "CONTRIBUTOR", "body_html": "<p>So what it looks like to me as a user is that I would want to have \"computed parameters\".</p>\n<ul>\n<li>They have raw parameters as inputs.</li>\n<li>They are updated when the inputs change.</li>\n<li>They are cached after they are updated and can be used just like other tensors.</li>\n</ul>\n<p>I would propose to</p>\n<ul>\n<li>Have a ParameterModel class that actually is a Module subclass and is initialized with the name(s) of the parameter(?) that is computes. It can have parameters just like a model. It's forward computes the parameters. It should optionally also have a way to set parameters (i.e. doing the inverse transform), e.g. for initialization.</li>\n<li>Have a \"parameters were updated hook\" that is called by the optimizer which invalidates the computed parameters, e.g. by setting them to None or so.</li>\n<li>Have a thing in Module.getitem that calls the ParameterModel instance when a computed parameter is None and is accessed.</li>\n</ul>\n<p>This does not solve how to call the hook when someone else overwrites the parameter, but hey. I'm not set on any of the specifics. I can whip up a prototype if that helps.</p>\n<p>So the main functional difference to how spectral normalization is currently implemented is that it replaces the forward_pre hook with an update hook. The advantage to the user is that she can see this as a modification of parameters rather than the modules having the parameters.</p>", "body_text": "So what it looks like to me as a user is that I would want to have \"computed parameters\".\n\nThey have raw parameters as inputs.\nThey are updated when the inputs change.\nThey are cached after they are updated and can be used just like other tensors.\n\nI would propose to\n\nHave a ParameterModel class that actually is a Module subclass and is initialized with the name(s) of the parameter(?) that is computes. It can have parameters just like a model. It's forward computes the parameters. It should optionally also have a way to set parameters (i.e. doing the inverse transform), e.g. for initialization.\nHave a \"parameters were updated hook\" that is called by the optimizer which invalidates the computed parameters, e.g. by setting them to None or so.\nHave a thing in Module.getitem that calls the ParameterModel instance when a computed parameter is None and is accessed.\n\nThis does not solve how to call the hook when someone else overwrites the parameter, but hey. I'm not set on any of the specifics. I can whip up a prototype if that helps.\nSo the main functional difference to how spectral normalization is currently implemented is that it replaces the forward_pre hook with an update hook. The advantage to the user is that she can see this as a modification of parameters rather than the modules having the parameters.", "body": "So what it looks like to me as a user is that I would want to have \"computed parameters\".\r\n- They have raw parameters as inputs.\r\n- They are updated when the inputs change.\r\n- They are cached after they are updated and can be used just like other tensors.\r\n\r\nI would propose to\r\n- Have a ParameterModel class that actually is a Module subclass and is initialized with the name(s) of the parameter(?) that is computes. It can have parameters just like a model. It's forward computes the parameters. It should optionally also have a way to set parameters (i.e. doing the inverse transform), e.g. for initialization.\r\n- Have a \"parameters were updated hook\" that is called by the optimizer which invalidates the computed parameters, e.g. by setting them to None or so.\r\n- Have a thing in Module.getitem that calls the ParameterModel instance when a computed parameter is None and is accessed.\r\n\r\nThis does not solve how to call the hook when someone else overwrites the parameter, but hey. I'm not set on any of the specifics. I can whip up a prototype if that helps.\r\n\r\nSo the main functional difference to how spectral normalization is currently implemented is that it replaces the forward_pre hook with an update hook. The advantage to the user is that she can see this as a modification of parameters rather than the modules having the parameters."}