{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/209987610", "pull_request_review_id": 146108935, "id": 209987610, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwOTk4NzYxMA==", "diff_hunk": "@@ -158,7 +158,8 @@ class Registerer {\n \n #define CAFFE_DEFINE_TYPED_REGISTRY(                                         \\\n     RegistryName, SrcType, ObjectType, PtrType, ...)                         \\\n-  Registry<SrcType, PtrType<ObjectType>, ##__VA_ARGS__>* RegistryName() {    \\\n+  CAFFE2_EXPORT Registry<SrcType, PtrType<ObjectType>, ##__VA_ARGS__>*       \\", "path": "caffe2/core/registry.h", "position": 5, "original_position": 5, "commit_id": "35a62fa287bc81b45265ba27f87bed56c42dded5", "original_commit_id": "425b62ac546a315ce59c279b1bbb221dc5fc94c0", "user": {"login": "Yangqing", "id": 551151, "node_id": "MDQ6VXNlcjU1MTE1MQ==", "avatar_url": "https://avatars1.githubusercontent.com/u/551151?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Yangqing", "html_url": "https://github.com/Yangqing", "followers_url": "https://api.github.com/users/Yangqing/followers", "following_url": "https://api.github.com/users/Yangqing/following{/other_user}", "gists_url": "https://api.github.com/users/Yangqing/gists{/gist_id}", "starred_url": "https://api.github.com/users/Yangqing/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Yangqing/subscriptions", "organizations_url": "https://api.github.com/users/Yangqing/orgs", "repos_url": "https://api.github.com/users/Yangqing/repos", "events_url": "https://api.github.com/users/Yangqing/events{/privacy}", "received_events_url": "https://api.github.com/users/Yangqing/received_events", "type": "User", "site_admin": false}, "body": "Ah yeah, so basically, the choice of API (which at build time adapts to IMPORT or EXPORT), EXPORT and IMPORT are as follows:\r\n\r\n(1) for function and class declarations in header files: always use API. This will then be routed at compile time: when we are building the main library, because we set CAFFE2_BUILD_MAIN_LIB, it routes us to EXPORT, allowing the definition in the .cc files to be exported. When we are using the headers in a dependent library (someone that uses Caffe2/pytorch), then because CAFFE2_BUILD_MAIN_LIB is not set, it routes to IMPORT, which tells the compiler the function definitions are going to be elsewhere.\r\n\r\n(2) in .cc files where we actually define the variables (global variables, static variables and functions), explicitly using EXPORT is safer because it avoid programming error.\r\n\r\n(3) in header files when defining macros, and if the macro is going to be used in cc files for global variable definition (such as this line) - explicitly use EXPORT. The reason is that, such lines may be used in dependent libraries too (imagine a dependent library defining a new registry for a new device) - and when they do so, they want to explicitly EXPORT the registry.", "created_at": "2018-08-14T15:04:17Z", "updated_at": "2018-11-23T15:49:17Z", "html_url": "https://github.com/pytorch/pytorch/pull/10504#discussion_r209987610", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/10504", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/209987610"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/10504#discussion_r209987610"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/10504"}}, "body_html": "<p>Ah yeah, so basically, the choice of API (which at build time adapts to IMPORT or EXPORT), EXPORT and IMPORT are as follows:</p>\n<p>(1) for function and class declarations in header files: always use API. This will then be routed at compile time: when we are building the main library, because we set CAFFE2_BUILD_MAIN_LIB, it routes us to EXPORT, allowing the definition in the .cc files to be exported. When we are using the headers in a dependent library (someone that uses Caffe2/pytorch), then because CAFFE2_BUILD_MAIN_LIB is not set, it routes to IMPORT, which tells the compiler the function definitions are going to be elsewhere.</p>\n<p>(2) in .cc files where we actually define the variables (global variables, static variables and functions), explicitly using EXPORT is safer because it avoid programming error.</p>\n<p>(3) in header files when defining macros, and if the macro is going to be used in cc files for global variable definition (such as this line) - explicitly use EXPORT. The reason is that, such lines may be used in dependent libraries too (imagine a dependent library defining a new registry for a new device) - and when they do so, they want to explicitly EXPORT the registry.</p>", "body_text": "Ah yeah, so basically, the choice of API (which at build time adapts to IMPORT or EXPORT), EXPORT and IMPORT are as follows:\n(1) for function and class declarations in header files: always use API. This will then be routed at compile time: when we are building the main library, because we set CAFFE2_BUILD_MAIN_LIB, it routes us to EXPORT, allowing the definition in the .cc files to be exported. When we are using the headers in a dependent library (someone that uses Caffe2/pytorch), then because CAFFE2_BUILD_MAIN_LIB is not set, it routes to IMPORT, which tells the compiler the function definitions are going to be elsewhere.\n(2) in .cc files where we actually define the variables (global variables, static variables and functions), explicitly using EXPORT is safer because it avoid programming error.\n(3) in header files when defining macros, and if the macro is going to be used in cc files for global variable definition (such as this line) - explicitly use EXPORT. The reason is that, such lines may be used in dependent libraries too (imagine a dependent library defining a new registry for a new device) - and when they do so, they want to explicitly EXPORT the registry.", "in_reply_to_id": 209983433}