{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/171015569", "pull_request_review_id": 99794832, "id": 171015569, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE3MTAxNTU2OQ==", "diff_hunk": "@@ -456,7 +457,163 @@ def trace(*args, **kwargs):\n         >>> def f(x):\n         >>>     return x * 2\n     \"\"\"\n-    return lambda func: torch._C.GraphExecutor(func, args, kwargs.pop('optimize', True))\n+    def wrapper(func):\n+        executor_options = {'optimize': True}\n+        for name in executor_options:\n+            executor_options[name] = kwargs.pop(name, executor_options[name])\n+        if isinstance(func, torch.nn.Module):\n+            captures = list(func.state_dict(keep_vars=True).values())\n+            # TODO: support shared parameters\n+            if len(set(map(id, captures))) != len(list(map(id, captures))):\n+                raise ValueError(\"TracedModules don't support parameter sharing between modules\")\n+            executor = torch._C.GraphExecutor(func, args, captures=captures, **executor_options)\n+            return TracedModule(func, executor)\n+        else:\n+            return torch._C.GraphExecutor(func, args, **executor_options)\n+    return wrapper\n+\n+\n+class TracedModule(torch.nn.Module):\n+    __class_cache = {}\n+    __frozen = False\n+\n+    def __new__(cls, orig, executor=None, root=None):\n+        orig_type = type(orig)\n+        if cls is TracedModule:\n+            if orig_type not in TracedModule.__class_cache:\n+                compiled_type = type('Compiled' + type(orig).__name__,\n+                                     (TracedModule, type(orig)),\n+                                     {})\n+                # NB: we don't block methods of subclasses. They are sometimes necessary\n+                # as helpers (e.g. for indexing in Sequential), and we block any writes\n+                # to attributes. The only way someone could mess with the logic here is\n+                # by modifying _parameters, but this is a private attribute, and we'll never\n+                # block this fully anyway.\n+                TracedModule.__class_cache[orig_type] = compiled_type\n+            else:\n+                compiled_type = TracedModule.__class_cache[orig_type]\n+            # XXX: we call __new__ instead of cls(), because the returned object will be\n+            # an instance of TracedModule, and so we don't want Python to call __init__ again.\n+            return compiled_type.__new__(compiled_type, orig, executor, root)\n+        return super(TracedModule, cls).__new__(cls)\n+\n+    def __init__(self, orig, executor=None, root=None):\n+        Module.__init__(self)  # Skip initialization of the user class\n+\n+        if not ((executor is None) ^ (root is None)):\n+            raise ValueError(\"Exaclty one of executor or root has to be specified\")\n+\n+        self.training = orig.training\n+        for name, param in orig._parameters.items():\n+            if param is not None:\n+                self._parameters[name] = param\n+        for name, buf in orig._buffers.items():\n+            if param is not None:\n+                self._buffers[name] = buf\n+        self._orig_class = type(orig)\n+\n+        for name, submodule in orig._modules.items():\n+            self._modules[name] = TracedModule(submodule,\n+                                                 root=root if root is not None else self)\n+\n+        if orig._backward_hooks or orig._forward_hooks or orig._forward_pre_hooks:\n+            raise ValueError(\"Modules that have hooks assigned can't be compiled\")\n+\n+        if executor is not None:\n+            self._is_root = True\n+            self._executor = executor\n+            self._recompute_captures()\n+        else:\n+            self._is_root = False\n+            self._root = weakref.ref(root)\n+\n+        self.__frozen = True\n+\n+    def __setattr__(self, name, value):\n+        if not self.__frozen:\n+            return super(TracedModule, self).__setattr__(name, value)\n+        if name in self._parameters or name in self._buffers:\n+            self._recompute_captures()\n+            return super(TracedModule, self).__setattr__(name, value)\n+        raise RuntimeError(\"Only parameters and buffers of compiled modules can be re-assigned.\")\n+\n+    def __delattr__(self, name):\n+        raise RuntimeError(\"Deleting attributes of TracedModules isn't supported\")\n+\n+    def __getstate__(self):\n+        raise RuntimeError(\"TracedModules aren't picklable\")\n+\n+    def __call__(self, *args):\n+        try:\n+            return self._executor(*args)\n+        except AttributeError:\n+            raise RuntimeError(\"Only the top-level compiled module can be called\")\n+\n+    def _recompute_captures(self):\n+        if self._is_root:\n+            self._executor.set_captures(*self.state_dict().values())\n+        else:\n+            root = self._root()\n+            if root is None:\n+                raise RuntimeError(\"Submodules of TracedModule can't work without keeping \"\n+                                   \"the main one in scope\")\n+            root._recompute_captures()\n+\n+    def _apply(self, fn):\n+        if not self._is_root:\n+            raise RuntimeError(\"Only the top-level compiled module supports type casts\")\n+        for module in itertools.chain((self,), self.modules()):\n+            for param in module._parameters.values():\n+                param.data = fn(param.data)\n+                if param._grad is not None:\n+                    param._grad.data = fn(param._grad.data)\n+\n+            for key, buf in module._buffers.items():\n+                module._buffers[key] = fn(buf)\n+        self._recompute_captures()\n+        return self\n+\n+    def register_parameter(self, name, param):\n+        if name not in self._parameters:\n+            raise RuntimeError(\"Can't add new parameters to TracedModules\")\n+        if param is None:\n+            raise RuntimeError(\"Can't set parameters to None in TracedModules\")\n+        super(TracedModule, self).register_parameter(name, param)\n+\n+    def load_state_dict(self, state):\n+        super(TracedModule, self).load_state_dict(state)\n+        # NB: this is not strictly necessary, because load_state_dict is copying, but\n+        # that's an implementation detail that I don't want to depend on\n+        self._recompute_captures()\n+\n+    def _get_name(self):\n+        return 'TracedModule[' + self._orig_class.__name__ + ']'\n+\n+    def __repr__(self):\n+        # Subclasses usually print some extra info like num_features, but this needs\n+        # to have them saved as attributes, which TracedModules lack.\n+        return Module.__repr__(self)\n+\n+def _get_methods(cls):\n+    import inspect\n+    # In Python 3 unbound methods are functions, but in Python 2 they are methods\n+    return inspect.getmembers(cls, predicate=lambda x: inspect.isfunction(x) or inspect.ismethod(x))\n+\n+# NOTE: only need include those that aren't implemented above\n+_compiled_methods_whitelist = {\n+    'cpu', 'cuda', 'double', 'float', 'half', 'modules', 'named_children',\n+    'named_modules', 'named_parameters', 'parameters', 'state_dict', 'type',\n+    'zero_grad',\n+}\n+def _make_fail(name):", "path": "torch/jit/__init__.py", "position": null, "original_position": 182, "commit_id": "b02df12699d14cb04dbff311dc363d43e6abae5a", "original_commit_id": "d8c1a075b4cbe38900687adf3e74327bf8a638e9", "user": {"login": "zdevito", "id": 370202, "node_id": "MDQ6VXNlcjM3MDIwMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/370202?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zdevito", "html_url": "https://github.com/zdevito", "followers_url": "https://api.github.com/users/zdevito/followers", "following_url": "https://api.github.com/users/zdevito/following{/other_user}", "gists_url": "https://api.github.com/users/zdevito/gists{/gist_id}", "starred_url": "https://api.github.com/users/zdevito/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zdevito/subscriptions", "organizations_url": "https://api.github.com/users/zdevito/orgs", "repos_url": "https://api.github.com/users/zdevito/repos", "events_url": "https://api.github.com/users/zdevito/events{/privacy}", "received_events_url": "https://api.github.com/users/zdevito/received_events", "type": "User", "site_admin": false}, "body": "The way to keep nn.Module future proof is do define its abstract API in a way that TracedModule can implement, rather than have TracedModule hack around the default implementation of module. If there was an abstract base class that showed which methods needed to be filled in, then inheriting from that would give you the correct futureproof behavior, and would be idiomatic python. We need to do something like this anyway to support C++ modules, and CompiledModules. If we don't have an abstract list of functionality these modules must provide then I don't know how we will implement them correctly.", "created_at": "2018-02-27T18:11:10Z", "updated_at": "2018-11-23T15:40:04Z", "html_url": "https://github.com/pytorch/pytorch/pull/5409#discussion_r171015569", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/5409", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/171015569"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/5409#discussion_r171015569"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/5409"}}, "body_html": "<p>The way to keep nn.Module future proof is do define its abstract API in a way that TracedModule can implement, rather than have TracedModule hack around the default implementation of module. If there was an abstract base class that showed which methods needed to be filled in, then inheriting from that would give you the correct futureproof behavior, and would be idiomatic python. We need to do something like this anyway to support C++ modules, and CompiledModules. If we don't have an abstract list of functionality these modules must provide then I don't know how we will implement them correctly.</p>", "body_text": "The way to keep nn.Module future proof is do define its abstract API in a way that TracedModule can implement, rather than have TracedModule hack around the default implementation of module. If there was an abstract base class that showed which methods needed to be filled in, then inheriting from that would give you the correct futureproof behavior, and would be idiomatic python. We need to do something like this anyway to support C++ modules, and CompiledModules. If we don't have an abstract list of functionality these modules must provide then I don't know how we will implement them correctly.", "in_reply_to_id": 170765200}