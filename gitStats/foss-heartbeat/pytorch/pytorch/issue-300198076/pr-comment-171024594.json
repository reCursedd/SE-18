{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/171024594", "pull_request_review_id": 99805503, "id": 171024594, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE3MTAyNDU5NA==", "diff_hunk": "@@ -456,7 +457,163 @@ def trace(*args, **kwargs):\n         >>> def f(x):\n         >>>     return x * 2\n     \"\"\"\n-    return lambda func: torch._C.GraphExecutor(func, args, kwargs.pop('optimize', True))\n+    def wrapper(func):\n+        executor_options = {'optimize': True}\n+        for name in executor_options:\n+            executor_options[name] = kwargs.pop(name, executor_options[name])\n+        if isinstance(func, torch.nn.Module):\n+            captures = list(func.state_dict(keep_vars=True).values())\n+            # TODO: support shared parameters\n+            if len(set(map(id, captures))) != len(list(map(id, captures))):\n+                raise ValueError(\"TracedModules don't support parameter sharing between modules\")\n+            executor = torch._C.GraphExecutor(func, args, captures=captures, **executor_options)\n+            return TracedModule(func, executor)\n+        else:\n+            return torch._C.GraphExecutor(func, args, **executor_options)\n+    return wrapper\n+\n+\n+class TracedModule(torch.nn.Module):\n+    __class_cache = {}\n+    __frozen = False\n+\n+    def __new__(cls, orig, executor=None, root=None):\n+        orig_type = type(orig)\n+        if cls is TracedModule:\n+            if orig_type not in TracedModule.__class_cache:", "path": "torch/jit/__init__.py", "position": null, "original_position": 57, "commit_id": "b02df12699d14cb04dbff311dc363d43e6abae5a", "original_commit_id": "d8c1a075b4cbe38900687adf3e74327bf8a638e9", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "body": "The only reasons I can see above is that the `isinstance` can be confusing (can be easily fixed), and that the methods implemented by the subclasses might stop working (although it's impossible for them to corrupt the state unless they mess with `_modules` and `_parameters`, which they shouldn't do). Is there anything I'm missing?\r\n\r\nOn the other hand, I think that adding support for indexing with **integers and arbitrary string** keys to **all** `TracedModule`s, even when the original modules didn't support that, is a bit weird, and would result in unnecessarily complicated code. Why would you simulate the behaviour of all possible subclasses in a single one?\r\n\r\nShould we have a VC to discuss those things?", "created_at": "2018-02-27T18:42:09Z", "updated_at": "2018-11-23T15:40:04Z", "html_url": "https://github.com/pytorch/pytorch/pull/5409#discussion_r171024594", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/5409", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/171024594"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/5409#discussion_r171024594"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/5409"}}, "body_html": "<p>The only reasons I can see above is that the <code>isinstance</code> can be confusing (can be easily fixed), and that the methods implemented by the subclasses might stop working (although it's impossible for them to corrupt the state unless they mess with <code>_modules</code> and <code>_parameters</code>, which they shouldn't do). Is there anything I'm missing?</p>\n<p>On the other hand, I think that adding support for indexing with <strong>integers and arbitrary string</strong> keys to <strong>all</strong> <code>TracedModule</code>s, even when the original modules didn't support that, is a bit weird, and would result in unnecessarily complicated code. Why would you simulate the behaviour of all possible subclasses in a single one?</p>\n<p>Should we have a VC to discuss those things?</p>", "body_text": "The only reasons I can see above is that the isinstance can be confusing (can be easily fixed), and that the methods implemented by the subclasses might stop working (although it's impossible for them to corrupt the state unless they mess with _modules and _parameters, which they shouldn't do). Is there anything I'm missing?\nOn the other hand, I think that adding support for indexing with integers and arbitrary string keys to all TracedModules, even when the original modules didn't support that, is a bit weird, and would result in unnecessarily complicated code. Why would you simulate the behaviour of all possible subclasses in a single one?\nShould we have a VC to discuss those things?", "in_reply_to_id": 170762475}