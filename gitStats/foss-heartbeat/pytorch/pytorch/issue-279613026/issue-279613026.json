{"url": "https://api.github.com/repos/pytorch/pytorch/issues/4048", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/4048/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/4048/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/4048/events", "html_url": "https://github.com/pytorch/pytorch/issues/4048", "id": 279613026, "node_id": "MDU6SXNzdWUyNzk2MTMwMjY=", "number": 4048, "title": "Feature request: ModuleDict, like ModuleList", "user": {"login": "rkaplan", "id": 1389330, "node_id": "MDQ6VXNlcjEzODkzMzA=", "avatar_url": "https://avatars0.githubusercontent.com/u/1389330?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rkaplan", "html_url": "https://github.com/rkaplan", "followers_url": "https://api.github.com/users/rkaplan/followers", "following_url": "https://api.github.com/users/rkaplan/following{/other_user}", "gists_url": "https://api.github.com/users/rkaplan/gists{/gist_id}", "starred_url": "https://api.github.com/users/rkaplan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rkaplan/subscriptions", "organizations_url": "https://api.github.com/users/rkaplan/orgs", "repos_url": "https://api.github.com/users/rkaplan/repos", "events_url": "https://api.github.com/users/rkaplan/events{/privacy}", "received_events_url": "https://api.github.com/users/rkaplan/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 23, "created_at": "2017-12-06T03:22:51Z", "updated_at": "2018-07-18T02:02:24Z", "closed_at": "2018-07-18T02:02:24Z", "author_association": "NONE", "body_html": "<p>Self-explanatory. Currently there is no easy way to maintain a dictionary as an attribute of a Module whose values are themselves Modules that need to be registered. Introducing a ModuleDict class that functions the same as a ModuleList, except it exposes a dictionary interface, would resolve this. This has the following practical benefits for users:</p>\n<ol>\n<li>\n<p>Checkpointing is much better with a ModuleDict that has strings as keys and Modules as values than a ModuleList. I have personally run into problems when I change the order of modules in my ModuleList and try to load old checkpoints, because the checkpoint key names are order-dependent with ModuleLists, so it breaks my code.</p>\n</li>\n<li>\n<p>It combines the advantages of a ModuleList (dynamic assignment of Modules to a class) with the advantages of using named attributes (documentation / readability / sane module names in checkpoints).</p>\n</li>\n</ol>\n<p>Another pro is that this is very simple to implement. Here is a first pass, if there is support for this feature I will clean it up and submit this as a PR:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">class</span> <span class=\"pl-en\">ModuleDict</span>(<span class=\"pl-e\">Module</span>):\n    <span class=\"pl-s\"><span class=\"pl-k\">r</span><span class=\"pl-pds\">\"\"\"</span>Holds submodules in a dict.</span>\n<span class=\"pl-s\">    ModuleDict can be indexed like a regular Python dict, but modules it</span>\n<span class=\"pl-s\">    contains are properly registered, and will be visible by all Module methods.</span>\n<span class=\"pl-s\">    Arguments:</span>\n<span class=\"pl-s\">        modules (dict, optional): a list of modules to add</span>\n<span class=\"pl-s\">    Example::</span>\n<span class=\"pl-s\">        <span class=\"pl-k\">TODO</span>.</span>\n<span class=\"pl-s\">    <span class=\"pl-pds\">\"\"\"</span></span>\n\n    <span class=\"pl-k\">def</span> <span class=\"pl-c1\">__init__</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>, <span class=\"pl-smi\">modules</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">None</span>):\n        <span class=\"pl-c1\">super</span>(ModuleDict, <span class=\"pl-c1\">self</span>).<span class=\"pl-c1\">__init__</span>()\n        <span class=\"pl-k\">if</span> modules <span class=\"pl-k\">is</span> <span class=\"pl-k\">not</span> <span class=\"pl-c1\">None</span>:\n            <span class=\"pl-c1\">self</span>.update(modules)\n\n    <span class=\"pl-k\">def</span> <span class=\"pl-c1\">__getitem__</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>, <span class=\"pl-smi\">key</span>):\n        <span class=\"pl-k\">return</span> <span class=\"pl-c1\">self</span>._modules[key]\n\n    <span class=\"pl-k\">def</span> <span class=\"pl-c1\">__setitem__</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>, <span class=\"pl-smi\">key</span>, <span class=\"pl-smi\">module</span>):\n        <span class=\"pl-k\">return</span> <span class=\"pl-c1\">setattr</span>(<span class=\"pl-c1\">self</span>, key, module)\n\n    <span class=\"pl-k\">def</span> <span class=\"pl-c1\">__len__</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>):\n        <span class=\"pl-k\">return</span> <span class=\"pl-c1\">len</span>(<span class=\"pl-c1\">self</span>._modules)\n\n    <span class=\"pl-k\">def</span> <span class=\"pl-c1\">__iter__</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>):\n        <span class=\"pl-k\">return</span> <span class=\"pl-c1\">iter</span>(<span class=\"pl-c1\">self</span>._modules)\n\n    <span class=\"pl-k\">def</span> <span class=\"pl-en\">keys</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>):\n        <span class=\"pl-k\">return</span> <span class=\"pl-c1\">self</span>._modules.keys()\n\n    <span class=\"pl-k\">def</span> <span class=\"pl-en\">items</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>):\n        <span class=\"pl-k\">return</span> <span class=\"pl-c1\">self</span>._modules.items()\n\n    <span class=\"pl-k\">def</span> <span class=\"pl-en\">values</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>):\n        <span class=\"pl-k\">return</span> <span class=\"pl-c1\">self</span>._modules.values()\n\n    <span class=\"pl-k\">def</span> <span class=\"pl-en\">get</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>, <span class=\"pl-smi\">key</span>, <span class=\"pl-smi\">default</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">None</span>):\n        <span class=\"pl-k\">if</span> default <span class=\"pl-k\">is</span> <span class=\"pl-k\">not</span> <span class=\"pl-c1\">None</span>:\n            <span class=\"pl-k\">return</span> <span class=\"pl-c1\">self</span>._modules.get(key, default)\n        <span class=\"pl-k\">return</span> <span class=\"pl-c1\">self</span>._modules.get(key)\n\n    <span class=\"pl-k\">def</span> <span class=\"pl-en\">update</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>, <span class=\"pl-smi\">modules</span>):\n        <span class=\"pl-s\"><span class=\"pl-k\">r</span><span class=\"pl-pds\">\"\"\"</span>Updates modules from a Python dict.</span>\n<span class=\"pl-s\">        Arguments:</span>\n<span class=\"pl-s\">            modules (dict): dict of modules to append</span>\n<span class=\"pl-s\">        <span class=\"pl-pds\">\"\"\"</span></span>\n        <span class=\"pl-k\">if</span> <span class=\"pl-k\">not</span> <span class=\"pl-c1\">isinstance</span>(modules, <span class=\"pl-c1\">dict</span>):\n            <span class=\"pl-k\">raise</span> <span class=\"pl-c1\">TypeError</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>ModuleDict.update should be called with a <span class=\"pl-pds\">\"</span></span>\n                            <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>dict, but got <span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">+</span> <span class=\"pl-c1\">type</span>(modules).<span class=\"pl-c1\">__name__</span>)\n        <span class=\"pl-k\">for</span> key, module <span class=\"pl-k\">in</span> modules.items():\n            <span class=\"pl-c1\">self</span>.add_module(key, module)\n        <span class=\"pl-k\">return</span> <span class=\"pl-c1\">self</span></pre></div>", "body_text": "Self-explanatory. Currently there is no easy way to maintain a dictionary as an attribute of a Module whose values are themselves Modules that need to be registered. Introducing a ModuleDict class that functions the same as a ModuleList, except it exposes a dictionary interface, would resolve this. This has the following practical benefits for users:\n\n\nCheckpointing is much better with a ModuleDict that has strings as keys and Modules as values than a ModuleList. I have personally run into problems when I change the order of modules in my ModuleList and try to load old checkpoints, because the checkpoint key names are order-dependent with ModuleLists, so it breaks my code.\n\n\nIt combines the advantages of a ModuleList (dynamic assignment of Modules to a class) with the advantages of using named attributes (documentation / readability / sane module names in checkpoints).\n\n\nAnother pro is that this is very simple to implement. Here is a first pass, if there is support for this feature I will clean it up and submit this as a PR:\nclass ModuleDict(Module):\n    r\"\"\"Holds submodules in a dict.\n    ModuleDict can be indexed like a regular Python dict, but modules it\n    contains are properly registered, and will be visible by all Module methods.\n    Arguments:\n        modules (dict, optional): a list of modules to add\n    Example::\n        TODO.\n    \"\"\"\n\n    def __init__(self, modules=None):\n        super(ModuleDict, self).__init__()\n        if modules is not None:\n            self.update(modules)\n\n    def __getitem__(self, key):\n        return self._modules[key]\n\n    def __setitem__(self, key, module):\n        return setattr(self, key, module)\n\n    def __len__(self):\n        return len(self._modules)\n\n    def __iter__(self):\n        return iter(self._modules)\n\n    def keys(self):\n        return self._modules.keys()\n\n    def items(self):\n        return self._modules.items()\n\n    def values(self):\n        return self._modules.values()\n\n    def get(self, key, default=None):\n        if default is not None:\n            return self._modules.get(key, default)\n        return self._modules.get(key)\n\n    def update(self, modules):\n        r\"\"\"Updates modules from a Python dict.\n        Arguments:\n            modules (dict): dict of modules to append\n        \"\"\"\n        if not isinstance(modules, dict):\n            raise TypeError(\"ModuleDict.update should be called with a \"\n                            \"dict, but got \" + type(modules).__name__)\n        for key, module in modules.items():\n            self.add_module(key, module)\n        return self", "body": "Self-explanatory. Currently there is no easy way to maintain a dictionary as an attribute of a Module whose values are themselves Modules that need to be registered. Introducing a ModuleDict class that functions the same as a ModuleList, except it exposes a dictionary interface, would resolve this. This has the following practical benefits for users:\r\n\r\n1) Checkpointing is much better with a ModuleDict that has strings as keys and Modules as values than a ModuleList. I have personally run into problems when I change the order of modules in my ModuleList and try to load old checkpoints, because the checkpoint key names are order-dependent with ModuleLists, so it breaks my code.\r\n\r\n2) It combines the advantages of a ModuleList (dynamic assignment of Modules to a class) with the advantages of using named attributes (documentation / readability / sane module names in checkpoints).\r\n\r\nAnother pro is that this is very simple to implement. Here is a first pass, if there is support for this feature I will clean it up and submit this as a PR:\r\n\r\n```python\r\nclass ModuleDict(Module):\r\n    r\"\"\"Holds submodules in a dict.\r\n    ModuleDict can be indexed like a regular Python dict, but modules it\r\n    contains are properly registered, and will be visible by all Module methods.\r\n    Arguments:\r\n        modules (dict, optional): a list of modules to add\r\n    Example::\r\n        TODO.\r\n    \"\"\"\r\n\r\n    def __init__(self, modules=None):\r\n        super(ModuleDict, self).__init__()\r\n        if modules is not None:\r\n            self.update(modules)\r\n\r\n    def __getitem__(self, key):\r\n        return self._modules[key]\r\n\r\n    def __setitem__(self, key, module):\r\n        return setattr(self, key, module)\r\n\r\n    def __len__(self):\r\n        return len(self._modules)\r\n\r\n    def __iter__(self):\r\n        return iter(self._modules)\r\n\r\n    def keys(self):\r\n        return self._modules.keys()\r\n\r\n    def items(self):\r\n        return self._modules.items()\r\n\r\n    def values(self):\r\n        return self._modules.values()\r\n\r\n    def get(self, key, default=None):\r\n        if default is not None:\r\n            return self._modules.get(key, default)\r\n        return self._modules.get(key)\r\n\r\n    def update(self, modules):\r\n        r\"\"\"Updates modules from a Python dict.\r\n        Arguments:\r\n            modules (dict): dict of modules to append\r\n        \"\"\"\r\n        if not isinstance(modules, dict):\r\n            raise TypeError(\"ModuleDict.update should be called with a \"\r\n                            \"dict, but got \" + type(modules).__name__)\r\n        for key, module in modules.items():\r\n            self.add_module(key, module)\r\n        return self\r\n```"}