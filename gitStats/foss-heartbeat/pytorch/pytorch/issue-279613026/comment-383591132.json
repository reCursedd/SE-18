{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/383591132", "html_url": "https://github.com/pytorch/pytorch/issues/4048#issuecomment-383591132", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/4048", "id": 383591132, "node_id": "MDEyOklzc3VlQ29tbWVudDM4MzU5MTEzMg==", "user": {"login": "aa1607", "id": 25442895, "node_id": "MDQ6VXNlcjI1NDQyODk1", "avatar_url": "https://avatars1.githubusercontent.com/u/25442895?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aa1607", "html_url": "https://github.com/aa1607", "followers_url": "https://api.github.com/users/aa1607/followers", "following_url": "https://api.github.com/users/aa1607/following{/other_user}", "gists_url": "https://api.github.com/users/aa1607/gists{/gist_id}", "starred_url": "https://api.github.com/users/aa1607/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aa1607/subscriptions", "organizations_url": "https://api.github.com/users/aa1607/orgs", "repos_url": "https://api.github.com/users/aa1607/repos", "events_url": "https://api.github.com/users/aa1607/events{/privacy}", "received_events_url": "https://api.github.com/users/aa1607/received_events", "type": "User", "site_admin": false}, "created_at": "2018-04-23T14:16:34Z", "updated_at": "2018-04-23T15:36:36Z", "author_association": "NONE", "body_html": "<p>Hi, personally was looking for something like this when creating a custom  bidirectional rnn so that I could store an arbitrary number of dicts consisting of pairs of forwards and backwards cells in a modulelist and iterate over it in the forward loop.</p>\n<pre><code>num_layers = 10\nlayers = nn.ModuleList()\n\nfor layer in range(num_layers):\n    final_layer =   layer == num_layers-1\n    paired_layerdict =  ModuleDict(\n                       {  'forw' : nn.LSTMCell( in_feats ,  hid_feats)  ,  \n                          'back' : nn.LSTMCell( in_feats ,  hid_feats)  }\n    ) \n    paired_layerdict.is_final_layer = final_layer \n    layers.append( paired_layerdict )\n</code></pre>\n<p>I worked around not having it by using zip and two module lists but then had to get round some issues later on that wouldnt normally be a problem  (eg the forward function wasnt certain whether we were currently in a forwards cell or a backwards cell and whether we were in the final layer). Got around it but overall  felt the final solution was a bit clunky and inelegant, and would have been cleaner with something like ModuleDict</p>", "body_text": "Hi, personally was looking for something like this when creating a custom  bidirectional rnn so that I could store an arbitrary number of dicts consisting of pairs of forwards and backwards cells in a modulelist and iterate over it in the forward loop.\nnum_layers = 10\nlayers = nn.ModuleList()\n\nfor layer in range(num_layers):\n    final_layer =   layer == num_layers-1\n    paired_layerdict =  ModuleDict(\n                       {  'forw' : nn.LSTMCell( in_feats ,  hid_feats)  ,  \n                          'back' : nn.LSTMCell( in_feats ,  hid_feats)  }\n    ) \n    paired_layerdict.is_final_layer = final_layer \n    layers.append( paired_layerdict )\n\nI worked around not having it by using zip and two module lists but then had to get round some issues later on that wouldnt normally be a problem  (eg the forward function wasnt certain whether we were currently in a forwards cell or a backwards cell and whether we were in the final layer). Got around it but overall  felt the final solution was a bit clunky and inelegant, and would have been cleaner with something like ModuleDict", "body": "Hi, personally was looking for something like this when creating a custom  bidirectional rnn so that I could store an arbitrary number of dicts consisting of pairs of forwards and backwards cells in a modulelist and iterate over it in the forward loop.\r\n\r\n\r\n```\r\nnum_layers = 10\r\nlayers = nn.ModuleList()\r\n\r\nfor layer in range(num_layers):\r\n    final_layer =   layer == num_layers-1\r\n    paired_layerdict =  ModuleDict(\r\n                       {  'forw' : nn.LSTMCell( in_feats ,  hid_feats)  ,  \r\n                          'back' : nn.LSTMCell( in_feats ,  hid_feats)  }\r\n    ) \r\n    paired_layerdict.is_final_layer = final_layer \r\n    layers.append( paired_layerdict )\r\n```\r\nI worked around not having it by using zip and two module lists but then had to get round some issues later on that wouldnt normally be a problem  (eg the forward function wasnt certain whether we were currently in a forwards cell or a backwards cell and whether we were in the final layer). Got around it but overall  felt the final solution was a bit clunky and inelegant, and would have been cleaner with something like ModuleDict"}