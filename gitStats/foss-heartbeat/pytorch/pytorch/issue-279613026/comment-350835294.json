{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/350835294", "html_url": "https://github.com/pytorch/pytorch/issues/4048#issuecomment-350835294", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/4048", "id": 350835294, "node_id": "MDEyOklzc3VlQ29tbWVudDM1MDgzNTI5NA==", "user": {"login": "fmassa", "id": 9110200, "node_id": "MDQ6VXNlcjkxMTAyMDA=", "avatar_url": "https://avatars2.githubusercontent.com/u/9110200?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fmassa", "html_url": "https://github.com/fmassa", "followers_url": "https://api.github.com/users/fmassa/followers", "following_url": "https://api.github.com/users/fmassa/following{/other_user}", "gists_url": "https://api.github.com/users/fmassa/gists{/gist_id}", "starred_url": "https://api.github.com/users/fmassa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fmassa/subscriptions", "organizations_url": "https://api.github.com/users/fmassa/orgs", "repos_url": "https://api.github.com/users/fmassa/repos", "events_url": "https://api.github.com/users/fmassa/events{/privacy}", "received_events_url": "https://api.github.com/users/fmassa/received_events", "type": "User", "site_admin": false}, "created_at": "2017-12-11T19:42:52Z", "updated_at": "2017-12-11T19:42:52Z", "author_association": "MEMBER", "body_html": "<p>Implementation-wise this would be very similar to what we currently have for <code>nn.ModuleList</code>, eventually bookeeping the type of the iterable that was passed so that we can provide <em>nice</em> printings and indexing access.</p>\n<p>This solves the problem because every iterable that you want to pass you just need to pass that you want to record in the model (for <code>.parameters()</code>, <code>.cuda()</code>, etc) to this common module.</p>\n<p>Is such a thing necessary? Not necessarily, but <a href=\"https://discuss.pytorch.org/t/list-of-nn-module-in-a-nn-module/219\" rel=\"nofollow\">it was already handy in the past</a>.</p>\n<p>Do we need such abstraction? Maybe not, as we can subclass a <code>nn.Module</code> to implement such funcionality. But for users, might be better to do</p>\n<div class=\"highlight highlight-source-python\"><pre>branch1 <span class=\"pl-k\">=</span> {}\nbranch1[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>conv1<span class=\"pl-pds\">'</span></span>] <span class=\"pl-k\">=</span> nn.Conv2d(<span class=\"pl-c1\">...</span>)\nbranch1[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>conv2<span class=\"pl-pds\">'</span></span>] <span class=\"pl-k\">=</span> nn.Conv2d(<span class=\"pl-c1\">...</span>)\nbranch1[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>conv3<span class=\"pl-pds\">'</span></span>] <span class=\"pl-k\">=</span> nn.Conv2d(<span class=\"pl-c1\">...</span>)\n<span class=\"pl-c1\">self</span>.branch1 <span class=\"pl-k\">=</span> nn.FromIterable(branch1)\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> and then later on</span>\n<span class=\"pl-k\">for</span> module_name <span class=\"pl-k\">in</span> [<span class=\"pl-s\"><span class=\"pl-pds\">'</span>conv1<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>conv2<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>conv3<span class=\"pl-pds\">'</span></span>]:\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> or for module in self.branch1 if we branch1 was OrderedDict</span>\n    output <span class=\"pl-k\">=</span> F.relu(<span class=\"pl-c1\">self</span>.branch1[module_name]) <span class=\"pl-k\">+</span> <span class=\"pl-c1\">1.0</span></pre></div>\n<p>instead of having to write a class just for holding the <code>conv1</code>/<code>conv2</code>/<code>conv3</code>.</p>\n<p>Let me know if I wasn't clear.</p>", "body_text": "Implementation-wise this would be very similar to what we currently have for nn.ModuleList, eventually bookeeping the type of the iterable that was passed so that we can provide nice printings and indexing access.\nThis solves the problem because every iterable that you want to pass you just need to pass that you want to record in the model (for .parameters(), .cuda(), etc) to this common module.\nIs such a thing necessary? Not necessarily, but it was already handy in the past.\nDo we need such abstraction? Maybe not, as we can subclass a nn.Module to implement such funcionality. But for users, might be better to do\nbranch1 = {}\nbranch1['conv1'] = nn.Conv2d(...)\nbranch1['conv2'] = nn.Conv2d(...)\nbranch1['conv3'] = nn.Conv2d(...)\nself.branch1 = nn.FromIterable(branch1)\n\n# and then later on\nfor module_name in ['conv1', 'conv2', 'conv3']:\n# or for module in self.branch1 if we branch1 was OrderedDict\n    output = F.relu(self.branch1[module_name]) + 1.0\ninstead of having to write a class just for holding the conv1/conv2/conv3.\nLet me know if I wasn't clear.", "body": "Implementation-wise this would be very similar to what we currently have for `nn.ModuleList`, eventually bookeeping the type of the iterable that was passed so that we can provide *nice* printings and indexing access.\r\n\r\nThis solves the problem because every iterable that you want to pass you just need to pass that you want to record in the model (for `.parameters()`, `.cuda()`, etc) to this common module.\r\n\r\nIs such a thing necessary? Not necessarily, but [it was already handy in the past](https://discuss.pytorch.org/t/list-of-nn-module-in-a-nn-module/219).\r\n\r\nDo we need such abstraction? Maybe not, as we can subclass a `nn.Module` to implement such funcionality. But for users, might be better to do\r\n```python\r\nbranch1 = {}\r\nbranch1['conv1'] = nn.Conv2d(...)\r\nbranch1['conv2'] = nn.Conv2d(...)\r\nbranch1['conv3'] = nn.Conv2d(...)\r\nself.branch1 = nn.FromIterable(branch1)\r\n\r\n# and then later on\r\nfor module_name in ['conv1', 'conv2', 'conv3']:\r\n# or for module in self.branch1 if we branch1 was OrderedDict\r\n    output = F.relu(self.branch1[module_name]) + 1.0\r\n```\r\n\r\ninstead of having to write a class just for holding the `conv1`/`conv2`/`conv3`.\r\n\r\nLet me know if I wasn't clear."}