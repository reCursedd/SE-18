{"url": "https://api.github.com/repos/pytorch/pytorch/issues/11369", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/11369/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/11369/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/11369/events", "html_url": "https://github.com/pytorch/pytorch/pull/11369", "id": 357922085, "node_id": "MDExOlB1bGxSZXF1ZXN0MjEzODE4MTUz", "number": 11369, "title": "Conversions to and from complex numbers.", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2018-09-07T05:12:16Z", "updated_at": "2018-11-23T15:50:49Z", "closed_at": "2018-09-09T03:03:53Z", "author_association": "CONTRIBUTOR", "pull_request": {"url": "https://api.github.com/repos/pytorch/pytorch/pulls/11369", "html_url": "https://github.com/pytorch/pytorch/pull/11369", "diff_url": "https://github.com/pytorch/pytorch/pull/11369.diff", "patch_url": "https://github.com/pytorch/pytorch/pull/11369.patch"}, "body_html": "<p>Surprisingly tricky!  Here are the major pieces:</p>\n<ul>\n<li>\n<p>We grow a even yet more ludicrous macro<br>\nAT_FORALL_SCALAR_TYPES_WITH_COMPLEX_EXCEPT_COMPLEX_HALF<br>\nwhich does what it says on the tin.  This is because I was<br>\ntoo lazy to figure out how to define the necessary conversions<br>\nin and out of ComplexHalf without triggering ambiguity problems.<br>\nIt doesn't seem to be as simple as just Half.  Leave it for<br>\nwhen someone actually wants this.</p>\n</li>\n<li>\n<p>Scalar now can hold std::complex.  Internally, it is<br>\nstored as double[2] because nvcc chokes on a non-POD type<br>\ninside a union.</p>\n</li>\n<li>\n<p>overflow() checking is generalized to work with complex.<br>\nWhen converting <em>to</em> std::complex, all we need to do is check<br>\nfor overflow against T.  When converting <em>from</em> complex, we<br>\nmust check (1) if To is not complex, that imag() == 0<br>\nand (2) for overflow componentwise.</p>\n</li>\n<li>\n<p>convert() is generalized to work with complex&lt;-&gt;real conversions.<br>\nComplex to real drops the imaginary component; we rely on<br>\noverflow checking to tell if this actually loses fidelity.</p>\n</li>\n<li>\n<p>Complex scalars convert into Python complex numbers</p>\n</li>\n<li>\n<p>This probably fixes complex tensor printing, but there is no way<br>\nto test this right now.</p>\n</li>\n</ul>\n<p>TODO: This somehow breaks the CUDA build.  Needs further investigating.</p>\n<p>Signed-off-by: Edward Z. Yang <a href=\"mailto:ezyang@fb.com\">ezyang@fb.com</a></p>\n<p>CC <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=8445510\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/Roger-luo\">@Roger-luo</a></p>", "body_text": "Surprisingly tricky!  Here are the major pieces:\n\n\nWe grow a even yet more ludicrous macro\nAT_FORALL_SCALAR_TYPES_WITH_COMPLEX_EXCEPT_COMPLEX_HALF\nwhich does what it says on the tin.  This is because I was\ntoo lazy to figure out how to define the necessary conversions\nin and out of ComplexHalf without triggering ambiguity problems.\nIt doesn't seem to be as simple as just Half.  Leave it for\nwhen someone actually wants this.\n\n\nScalar now can hold std::complex.  Internally, it is\nstored as double[2] because nvcc chokes on a non-POD type\ninside a union.\n\n\noverflow() checking is generalized to work with complex.\nWhen converting to std::complex, all we need to do is check\nfor overflow against T.  When converting from complex, we\nmust check (1) if To is not complex, that imag() == 0\nand (2) for overflow componentwise.\n\n\nconvert() is generalized to work with complex<->real conversions.\nComplex to real drops the imaginary component; we rely on\noverflow checking to tell if this actually loses fidelity.\n\n\nComplex scalars convert into Python complex numbers\n\n\nThis probably fixes complex tensor printing, but there is no way\nto test this right now.\n\n\nTODO: This somehow breaks the CUDA build.  Needs further investigating.\nSigned-off-by: Edward Z. Yang ezyang@fb.com\nCC @Roger-luo", "body": "Surprisingly tricky!  Here are the major pieces:\r\n\r\n- We grow a even yet more ludicrous macro\r\n  AT_FORALL_SCALAR_TYPES_WITH_COMPLEX_EXCEPT_COMPLEX_HALF\r\n  which does what it says on the tin.  This is because I was\r\n  too lazy to figure out how to define the necessary conversions\r\n  in and out of ComplexHalf without triggering ambiguity problems.\r\n  It doesn't seem to be as simple as just Half.  Leave it for\r\n  when someone actually wants this.\r\n\r\n- Scalar now can hold std::complex<double>.  Internally, it is\r\n  stored as double[2] because nvcc chokes on a non-POD type\r\n  inside a union.\r\n\r\n- overflow() checking is generalized to work with complex.\r\n  When converting *to* std::complex<T>, all we need to do is check\r\n  for overflow against T.  When converting *from* complex, we\r\n  must check (1) if To is not complex, that imag() == 0\r\n  and (2) for overflow componentwise.\r\n\r\n- convert() is generalized to work with complex<->real conversions.\r\n  Complex to real drops the imaginary component; we rely on\r\n  overflow checking to tell if this actually loses fidelity.\r\n\r\n- Complex scalars convert into Python complex numbers\r\n\r\n- This probably fixes complex tensor printing, but there is no way\r\n  to test this right now.\r\n\r\nTODO: This somehow breaks the CUDA build.  Needs further investigating.\r\n\r\nSigned-off-by: Edward Z. Yang <ezyang@fb.com>\r\n\r\nCC @Roger-luo\r\n"}