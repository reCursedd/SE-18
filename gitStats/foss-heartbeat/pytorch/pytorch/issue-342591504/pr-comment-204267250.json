{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/204267250", "pull_request_review_id": 139314829, "id": 204267250, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwNDI2NzI1MA==", "diff_hunk": "@@ -568,159 +569,43 @@ Value* Value::setUniqueName(const std::string & name) {\n   return this;\n }\n \n-template<typename T>\n-Value* Graph::insertConstant(T value) {\n-  Node *n = create(prim::Constant);\n-  insertNode(n);\n-  auto t_value = as_tensor(value);\n-  n->t_(attr::value, t_value.clone());\n-  n->output()->inferTypeFrom(t_value);\n-  return n->output();\n-}\n-\n-// This is necessary, because integral literals are of type int by default,\n-// and will dispatch to this function.\n-template<>\n-Value * Graph::insertConstant(int value) {\n-  return insertConstant(static_cast<int64_t>(value));\n-}\n-\n-template Value* Graph::insertConstant(int64_t value);\n-template Value* Graph::insertConstant(double value);\n-template Value* Graph::insertConstant(at::Tensor value);\n-template Value* Graph::insertConstant(at::IntList value);\n-template Value* Graph::insertConstant(at::Scalar value);\n-\n-namespace {\n-\n-// Of course any sane person would define this thing as a templated function, but\n-// it so happens that clang 3.8 has a pretty annoying bug which makes it complain that\n-// specializations are redefinitions of themselves, and so here we are.\n-template<typename T>\n-struct getattr {};\n-\n-template<>\n-struct getattr<int64_t> {\n-  int64_t operator()(Node *n, Symbol name) {\n-    return n->i(name);\n-  }\n-};\n-\n-template<>\n-struct getattr<double> {\n-  double operator()(Node *n, Symbol name) {\n-    return n->f(name);\n-  }\n-};\n-\n-template<>\n-struct getattr<at::Tensor> {\n-  at::Tensor operator()(Node *n, Symbol name) {\n-    return n->t(name);\n-  }\n-};\n-\n-template<>\n-struct getattr<std::vector<int64_t>> {\n-  std::vector<int64_t> operator()(Node *n, Symbol name) {\n-    return n->is(name);\n-  }\n-};\n-\n-} // anonymous namespace\n-\n-template<typename T>\n-at::optional<T> Node::get(Symbol name) {\n+at::optional<IValue> Node::get(Symbol name) const {\n   // TODO (apaszke): remove. this is in here for now just so that we can ensure\n   // we always use this in places where the node has a valid schema already\n   // (will make next commits easier).\n-  if (!schema_) findSchema();\n-  // TODO (apaszke): remove once tracer and compiler stop emitting attributes\n-  if (hasAttributes()) {\n-    // If it has an attribute, then it is a constant. If it's missing, it means we're\n-    // doing an invalid lookup and it should throw anyway.\n-    return getattr<T>()(this, name);\n-  }\n-  auto inp = findInput(name);\n-  const Argument & arg = inp.second;\n-  if (!inp.first) {\n-    return tensor_as<T>(arg.default_value.value());\n-  }\n-  Node *producer = inp.first->node();\n-  if (producer->kind() != prim::Constant) return at::nullopt;\n-  auto value = producer->t(attr::value);\n-  return tensor_as<T>(std::move(value));\n-}\n-\n-template at::optional<int64_t> Node::get(Symbol name);\n-template at::optional<double> Node::get(Symbol name);\n-template at::optional<at::Tensor> Node::get(Symbol name);\n-template at::optional<std::vector<int64_t>> Node::get(Symbol name);\n-\n-at::optional<IValue> Node::get(Symbol name) {\n-  // TODO (apaszke): remove once tracer and compiler stop emitting attributes\n   if (hasAttribute(name)) {\n     switch (kindOf(name)) {\n       case AttributeKind::i:\n-        return IValue{as_tensor(i(name))};\n+        return IValue(i(name));\n+      case AttributeKind::f:\n+        return IValue(f(name));\n       case AttributeKind::t:\n-        return IValue{as_tensor(t(name))};\n+        return IValue(t(name));\n       case AttributeKind::is:\n-        return IValue{as_tensor(is(name))};\n+        return IValue(is(name));\n       default:\n         throw std::runtime_error(\"get() NYI\");\n     }\n   }\n-  auto inp = findInput(name);\n-  const Argument & arg = inp.second;\n-  if (!inp.first) {\n-    return IValue{arg.default_value.value()};\n-  }\n-  Node * producer = inp.first->node();\n-  if (producer->kind() != prim::Constant) return at::nullopt;\n-  auto value = producer->t(attr::value);\n-  return IValue{std::move(value)};\n+  return toIValue(namedInput(name));\n }\n \n-Value* Node::input(Symbol name) {\n-  // TODO (apaszke): remove once tracer and compiler stop emitting attributes\n-  if (hasAttribute(name)) {\n-    switch (kindOf(name)) {\n-      case AttributeKind::i:\n-        return owningGraph()->insertConstant(i(name));\n-      case AttributeKind::is:\n-        return owningGraph()->insertConstant(is(name));\n-      case AttributeKind::t:\n-        return owningGraph()->insertConstant(t(name));\n-      default:\n-        throw std::runtime_error(\"getValue() NYI\");\n-    }\n-  }\n-  auto inp = findInput(name);\n-  if (inp.first) return inp.first;\n-  return owningGraph()->insertConstant(inp.second.default_value.value());\n-}\n-\n-// XXX: the first coordinate can be a nullptr, which means that you should use\n-// the default value for this arg, because it's optional and missing\n-std::pair<Value*, const Argument&> Node::findInput(Symbol name) {\n-  if (!schema_) {\n-    findSchema();\n+Value* Node::namedInput(Symbol name) const {\n+  if(hasAttribute(name)) {\n+    // XXX - const cast because this really should not be modifying graph\n+    // and once we remove attributes it no longer will\n+    Value* v = insertConstant(const_cast<Graph&>(*owningGraph()), get(name).value());\n+    // XXX - insert point can be anywhere since modifying the graph is unexpected,\n+    // so this is completely unsafe and needs to be gone as soon as possible.", "path": "torch/csrc/jit/ir.cpp", "position": 184, "original_position": 163, "commit_id": "6a9e59de5c6c7e7821e48863cd70d8fee3fc1870", "original_commit_id": "63bc34a152d3d9259c71b5c2318e335b2f6c25db", "user": {"login": "zdevito", "id": 370202, "node_id": "MDQ6VXNlcjM3MDIwMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/370202?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zdevito", "html_url": "https://github.com/zdevito", "followers_url": "https://api.github.com/users/zdevito/followers", "following_url": "https://api.github.com/users/zdevito/following{/other_user}", "gists_url": "https://api.github.com/users/zdevito/gists{/gist_id}", "starred_url": "https://api.github.com/users/zdevito/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zdevito/subscriptions", "organizations_url": "https://api.github.com/users/zdevito/orgs", "repos_url": "https://api.github.com/users/zdevito/repos", "events_url": "https://api.github.com/users/zdevito/events{/privacy}", "received_events_url": "https://api.github.com/users/zdevito/received_events", "type": "User", "site_admin": false}, "body": "Surprisingly no, because that is what I tried. Then it gets split by autodiff across forward and backward. It then fails because graph executor outputs must be primitives.", "created_at": "2018-07-23T02:02:35Z", "updated_at": "2018-11-23T15:47:52Z", "html_url": "https://github.com/pytorch/pytorch/pull/9584#discussion_r204267250", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/9584", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/204267250"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/9584#discussion_r204267250"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/9584"}}, "body_html": "<p>Surprisingly no, because that is what I tried. Then it gets split by autodiff across forward and backward. It then fails because graph executor outputs must be primitives.</p>", "body_text": "Surprisingly no, because that is what I tried. Then it gets split by autodiff across forward and backward. It then fails because graph executor outputs must be primitives.", "in_reply_to_id": 204262038}