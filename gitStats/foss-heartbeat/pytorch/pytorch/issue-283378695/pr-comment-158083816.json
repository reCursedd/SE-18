{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/158083816", "pull_request_review_id": 84835593, "id": 158083816, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1ODA4MzgxNg==", "diff_hunk": "@@ -109,6 +109,12 @@\n \n - func: matmul(Tensor self, Tensor other) -> Tensor\n \n+# we define both of these because 'where' does the broadcast and '_s_where' doesn't;\n+# this allows us to implicitly calculate the broadcast derivative, while only dealing with the\n+# _s_where derivative.\n+- func: where(BoolTensor condition, Tensor self, Tensor other) -> Tensor\n+- func: _s_where(BoolTensor condition, Tensor self, Tensor other) -> Tensor", "path": "aten/src/ATen/native/native_functions.yaml", "position": 8, "original_position": 8, "commit_id": "045dffca6c21cd3afdb1912b86eb2119c54348fb", "original_commit_id": "045dffca6c21cd3afdb1912b86eb2119c54348fb", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "body": "`_s_where` won't show up, because currently (after trace native functions) only trace the outermost native function. With scopes you'll also get to see the unfolding. I don't think there is any downside for tracing.\r\n\r\nMore generally, it seems the problem is that we're currently automatically generating the broadcast/non-broadcast versions of code, but in a way that is not easy to make use of from native. It seems to me that broadcasting is common enough that there should be an affordance for it, also for native.", "created_at": "2017-12-20T17:17:05Z", "updated_at": "2018-11-23T15:37:34Z", "html_url": "https://github.com/pytorch/pytorch/pull/4259#discussion_r158083816", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/4259", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/158083816"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/4259#discussion_r158083816"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/4259"}}, "body_html": "<p><code>_s_where</code> won't show up, because currently (after trace native functions) only trace the outermost native function. With scopes you'll also get to see the unfolding. I don't think there is any downside for tracing.</p>\n<p>More generally, it seems the problem is that we're currently automatically generating the broadcast/non-broadcast versions of code, but in a way that is not easy to make use of from native. It seems to me that broadcasting is common enough that there should be an affordance for it, also for native.</p>", "body_text": "_s_where won't show up, because currently (after trace native functions) only trace the outermost native function. With scopes you'll also get to see the unfolding. I don't think there is any downside for tracing.\nMore generally, it seems the problem is that we're currently automatically generating the broadcast/non-broadcast versions of code, but in a way that is not easy to make use of from native. It seems to me that broadcasting is common enough that there should be an affordance for it, also for native.", "in_reply_to_id": 157985913}