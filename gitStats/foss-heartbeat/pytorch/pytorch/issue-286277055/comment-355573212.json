{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/355573212", "html_url": "https://github.com/pytorch/pytorch/issues/4495#issuecomment-355573212", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/4495", "id": 355573212, "node_id": "MDEyOklzc3VlQ29tbWVudDM1NTU3MzIxMg==", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "created_at": "2018-01-05T14:53:27Z", "updated_at": "2018-01-05T14:53:27Z", "author_association": "CONTRIBUTOR", "body_html": "<p>So, there are a few bugs here.</p>\n<ol>\n<li>In the first case, the problem is that we are not correctly propagating scopes to <em>all</em> of the nodes generated by a symbolic definition, only one the output (<code>torch/csrc/jit/passes/onnx.cpp</code>):</li>\n</ol>\n<pre><code>      if (outputs[i]) {\n        // Allow symbolic() to skip specifying the type of the return node.\n        // Unfortunately, they are on the hook for all internal nodes\n        // (though in practice, the types are not computed.)\n        if (!outputs[i]-&gt;hasType()) {\n          outputs[i]-&gt;setType(old-&gt;typeOption());\n        }\n        // Copy over source location information to all nodes created by\n        // the symbolic\n        outputs[i]-&gt;node()-&gt;setSourceLocation(node-&gt;getSourceLocation());\n        outputs[i]-&gt;node()-&gt;setScope(node-&gt;scope());\n        env[old] = outputs[i];\n</code></pre>\n<p>This probably should be a simple fix; we should just adjust the default scope of newly added nodes before running the symbolic (assuming this is how it works... haven't double checked)</p>\n<ol start=\"2\">\n<li>I'm not sure why this case is getting a nonsense scope, but it's definitely not the same bug as (1).</li>\n</ol>\n<p>BTW, why does the workaround work? When <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=191033\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/lantiga\">@lantiga</a> initially added scopes in <a class=\"commit-link\" data-hovercard-type=\"commit\" data-hovercard-url=\"https://github.com/pytorch/pytorch/commit/4eb8e1276511a07ced781e7b36da39cedc4f15cc/hovercard\" href=\"https://github.com/pytorch/pytorch/commit/4eb8e1276511a07ced781e7b36da39cedc4f15cc\"><tt>4eb8e12</tt></a>, we added scopes to Module (which has an obvious \"hook\" point) but not the functional API (which doesn't have a place to easily interpose.)  So probably the workaround is preventing us from setting a scope.</p>", "body_text": "So, there are a few bugs here.\n\nIn the first case, the problem is that we are not correctly propagating scopes to all of the nodes generated by a symbolic definition, only one the output (torch/csrc/jit/passes/onnx.cpp):\n\n      if (outputs[i]) {\n        // Allow symbolic() to skip specifying the type of the return node.\n        // Unfortunately, they are on the hook for all internal nodes\n        // (though in practice, the types are not computed.)\n        if (!outputs[i]->hasType()) {\n          outputs[i]->setType(old->typeOption());\n        }\n        // Copy over source location information to all nodes created by\n        // the symbolic\n        outputs[i]->node()->setSourceLocation(node->getSourceLocation());\n        outputs[i]->node()->setScope(node->scope());\n        env[old] = outputs[i];\n\nThis probably should be a simple fix; we should just adjust the default scope of newly added nodes before running the symbolic (assuming this is how it works... haven't double checked)\n\nI'm not sure why this case is getting a nonsense scope, but it's definitely not the same bug as (1).\n\nBTW, why does the workaround work? When @lantiga initially added scopes in 4eb8e12, we added scopes to Module (which has an obvious \"hook\" point) but not the functional API (which doesn't have a place to easily interpose.)  So probably the workaround is preventing us from setting a scope.", "body": "So, there are a few bugs here.\r\n\r\n1. In the first case, the problem is that we are not correctly propagating scopes to *all* of the nodes generated by a symbolic definition, only one the output (`torch/csrc/jit/passes/onnx.cpp`):\r\n\r\n```\r\n      if (outputs[i]) {\r\n        // Allow symbolic() to skip specifying the type of the return node.\r\n        // Unfortunately, they are on the hook for all internal nodes\r\n        // (though in practice, the types are not computed.)\r\n        if (!outputs[i]->hasType()) {\r\n          outputs[i]->setType(old->typeOption());\r\n        }\r\n        // Copy over source location information to all nodes created by\r\n        // the symbolic\r\n        outputs[i]->node()->setSourceLocation(node->getSourceLocation());\r\n        outputs[i]->node()->setScope(node->scope());\r\n        env[old] = outputs[i];\r\n```\r\n\r\nThis probably should be a simple fix; we should just adjust the default scope of newly added nodes before running the symbolic (assuming this is how it works... haven't double checked)\r\n\r\n2. I'm not sure why this case is getting a nonsense scope, but it's definitely not the same bug as (1).\r\n\r\nBTW, why does the workaround work? When @lantiga initially added scopes in 4eb8e1276511a07ced781e7b36da39cedc4f15cc, we added scopes to Module (which has an obvious \"hook\" point) but not the functional API (which doesn't have a place to easily interpose.)  So probably the workaround is preventing us from setting a scope."}