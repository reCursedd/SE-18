{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/175540380", "pull_request_review_id": 105086063, "id": 175540380, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE3NTU0MDM4MA==", "diff_hunk": "@@ -148,6 +149,15 @@ def TypedDict(name, attrs, total=True):  # type: ignore\n     ${initializer}\n }\"\"\")\n \n+UNIFY_ACTUAL = CodeTemplate(\"\"\"\\\n+${actual}.type() != (**new_type) ? (**new_type).copy(${actual}) : ${actual}\\\n+\"\"\")\n+UNIFY_TYPES = CodeTemplate(\"\"\"\\\n+    if (auto new_type = unifyTypes(${to_unify_actuals})) {\n+        return (*new_type)->${api_name}(${unified_actuals});", "path": "aten/src/ATen/function_wrapper.py", "position": 17, "original_position": 17, "commit_id": "5163c7781bcf0893776eb97f7c851040228c101c", "original_commit_id": "24b7c7dfbedfeb2d8cf3e57fc6945c15c9479a55", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "body": "Because once you arrive at this method you are in a concrete `at::Type` implementation, which means that it has already been determined what the `s_add` below will dispatch to. This is bad, because e.g. the type of `self` can change because of the unification (or even all arguments can get promoted!), so we need to re-dispatch to the new type.", "created_at": "2018-03-19T18:28:35Z", "updated_at": "2018-11-23T15:40:57Z", "html_url": "https://github.com/pytorch/pytorch/pull/5864#discussion_r175540380", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/5864", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/175540380"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/5864#discussion_r175540380"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/5864"}}, "body_html": "<p>Because once you arrive at this method you are in a concrete <code>at::Type</code> implementation, which means that it has already been determined what the <code>s_add</code> below will dispatch to. This is bad, because e.g. the type of <code>self</code> can change because of the unification (or even all arguments can get promoted!), so we need to re-dispatch to the new type.</p>", "body_text": "Because once you arrive at this method you are in a concrete at::Type implementation, which means that it has already been determined what the s_add below will dispatch to. This is bad, because e.g. the type of self can change because of the unification (or even all arguments can get promoted!), so we need to re-dispatch to the new type.", "in_reply_to_id": 175515586}