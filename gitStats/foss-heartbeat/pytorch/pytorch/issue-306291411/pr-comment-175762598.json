{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/175762598", "pull_request_review_id": 105343930, "id": 175762598, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE3NTc2MjU5OA==", "diff_hunk": "@@ -148,6 +149,15 @@ def TypedDict(name, attrs, total=True):  # type: ignore\n     ${initializer}\n }\"\"\")\n \n+UNIFY_ACTUAL = CodeTemplate(\"\"\"\\\n+${actual}.type() != (**new_type) ? (**new_type).copy(${actual}) : ${actual}\\\n+\"\"\")\n+UNIFY_TYPES = CodeTemplate(\"\"\"\\\n+    if (auto new_type = unifyTypes(${to_unify_actuals})) {\n+        return (*new_type)->${api_name}(${unified_actuals});", "path": "aten/src/ATen/function_wrapper.py", "position": 17, "original_position": 17, "commit_id": "5163c7781bcf0893776eb97f7c851040228c101c", "original_commit_id": "24b7c7dfbedfeb2d8cf3e57fc6945c15c9479a55", "user": {"login": "gchanan", "id": 3768583, "node_id": "MDQ6VXNlcjM3Njg1ODM=", "avatar_url": "https://avatars2.githubusercontent.com/u/3768583?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gchanan", "html_url": "https://github.com/gchanan", "followers_url": "https://api.github.com/users/gchanan/followers", "following_url": "https://api.github.com/users/gchanan/following{/other_user}", "gists_url": "https://api.github.com/users/gchanan/gists{/gist_id}", "starred_url": "https://api.github.com/users/gchanan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gchanan/subscriptions", "organizations_url": "https://api.github.com/users/gchanan/orgs", "repos_url": "https://api.github.com/users/gchanan/repos", "events_url": "https://api.github.com/users/gchanan/events{/privacy}", "received_events_url": "https://api.github.com/users/gchanan/received_events", "type": "User", "site_admin": false}, "body": "I see.  Looking at it now -- it does seem a little strange to change the type dispatch inside of Type -- why didn't we dispatch to Type \"correctly\" in the first place?\r\n\r\nTypically we put functionality in Type for two reasons (as opposed to functional + method API):\r\n1) it was used as an API itself, so if we didn't put functionality in Type it wouldn't work via the Type API correctly.  This isn't true anymore, at least in Variable we no longer dispatch directly to Type (folks may still be using these APIs though, but they should use the functional or method API instead).\r\n2) Both the functional and method API dispatch to Type, so you only have to do the implementation once.  This still exists.\r\n\r\nIt does seem nicer to move this functionality to the functional + method API, because it seems like it would work for native functions as well (I'm assuming here that it is easier than implementing it in both non-native and native Type methods, but maybe that's wrong).  And it's nicer to have Type implementations be as simple as possible, because inheriting in Variable is complex.  Unlike broadcasting (which has a number of different implementations based on the function), I can't see a reason why we wouldn't want to have this functionality with native functions -- do you agree?\r\n\r\nWhat do you think @colesbury?", "created_at": "2018-03-20T13:26:28Z", "updated_at": "2018-11-23T15:40:58Z", "html_url": "https://github.com/pytorch/pytorch/pull/5864#discussion_r175762598", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/5864", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/175762598"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/5864#discussion_r175762598"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/5864"}}, "body_html": "<p>I see.  Looking at it now -- it does seem a little strange to change the type dispatch inside of Type -- why didn't we dispatch to Type \"correctly\" in the first place?</p>\n<p>Typically we put functionality in Type for two reasons (as opposed to functional + method API):</p>\n<ol>\n<li>it was used as an API itself, so if we didn't put functionality in Type it wouldn't work via the Type API correctly.  This isn't true anymore, at least in Variable we no longer dispatch directly to Type (folks may still be using these APIs though, but they should use the functional or method API instead).</li>\n<li>Both the functional and method API dispatch to Type, so you only have to do the implementation once.  This still exists.</li>\n</ol>\n<p>It does seem nicer to move this functionality to the functional + method API, because it seems like it would work for native functions as well (I'm assuming here that it is easier than implementing it in both non-native and native Type methods, but maybe that's wrong).  And it's nicer to have Type implementations be as simple as possible, because inheriting in Variable is complex.  Unlike broadcasting (which has a number of different implementations based on the function), I can't see a reason why we wouldn't want to have this functionality with native functions -- do you agree?</p>\n<p>What do you think <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=655866\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/colesbury\">@colesbury</a>?</p>", "body_text": "I see.  Looking at it now -- it does seem a little strange to change the type dispatch inside of Type -- why didn't we dispatch to Type \"correctly\" in the first place?\nTypically we put functionality in Type for two reasons (as opposed to functional + method API):\n\nit was used as an API itself, so if we didn't put functionality in Type it wouldn't work via the Type API correctly.  This isn't true anymore, at least in Variable we no longer dispatch directly to Type (folks may still be using these APIs though, but they should use the functional or method API instead).\nBoth the functional and method API dispatch to Type, so you only have to do the implementation once.  This still exists.\n\nIt does seem nicer to move this functionality to the functional + method API, because it seems like it would work for native functions as well (I'm assuming here that it is easier than implementing it in both non-native and native Type methods, but maybe that's wrong).  And it's nicer to have Type implementations be as simple as possible, because inheriting in Variable is complex.  Unlike broadcasting (which has a number of different implementations based on the function), I can't see a reason why we wouldn't want to have this functionality with native functions -- do you agree?\nWhat do you think @colesbury?", "in_reply_to_id": 175515586}