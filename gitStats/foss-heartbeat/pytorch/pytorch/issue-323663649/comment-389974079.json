{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/389974079", "html_url": "https://github.com/pytorch/pytorch/issues/7615#issuecomment-389974079", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/7615", "id": 389974079, "node_id": "MDEyOklzc3VlQ29tbWVudDM4OTk3NDA3OQ==", "user": {"login": "avmgithub", "id": 9083746, "node_id": "MDQ6VXNlcjkwODM3NDY=", "avatar_url": "https://avatars1.githubusercontent.com/u/9083746?v=4", "gravatar_id": "", "url": "https://api.github.com/users/avmgithub", "html_url": "https://github.com/avmgithub", "followers_url": "https://api.github.com/users/avmgithub/followers", "following_url": "https://api.github.com/users/avmgithub/following{/other_user}", "gists_url": "https://api.github.com/users/avmgithub/gists{/gist_id}", "starred_url": "https://api.github.com/users/avmgithub/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/avmgithub/subscriptions", "organizations_url": "https://api.github.com/users/avmgithub/orgs", "repos_url": "https://api.github.com/users/avmgithub/repos", "events_url": "https://api.github.com/users/avmgithub/events{/privacy}", "received_events_url": "https://api.github.com/users/avmgithub/received_events", "type": "User", "site_admin": false}, "created_at": "2018-05-17T19:01:57Z", "updated_at": "2018-05-17T19:06:03Z", "author_association": "CONTRIBUTOR", "body_html": "<p>I looked into this further. I found the following:<br>\nsetting OMP_NUM_THREADS to 2 or 1 makes the problem go away (at least in the numerous runs I did).<br>\nexport OMP_NUM_THREADS=2<br>\nI also looked at changing affinity_partitioner @ <a href=\"https://github.com/pytorch/pytorch/blob/master/aten/src/ATen/native/cpu/SoftMaxKernel.cpp#L25\">https://github.com/pytorch/pytorch/blob/master/aten/src/ATen/native/cpu/SoftMaxKernel.cpp#L25</a>    to other types of partitioners mentioned in <a href=\"https://software.intel.com/en-us/node/506149\" rel=\"nofollow\">https://software.intel.com/en-us/node/506149</a>.   When using OMP_NUM_THREADS &gt; 2 and using other types of partitioners, the problem is alleviated but still either aborts or SEGV.   I also noticed that using OMP_NUM_THREADS &gt; 1 seem to slow the operation.    I believe this is a race condition where a dangling pointer is called (see <a href=\"https://www.artima.com/cppsource/pure_virtual.html\" rel=\"nofollow\">https://www.artima.com/cppsource/pure_virtual.html</a>). And for some reason it shows more on ppc64le architecture due to differences in threading and caching architecture with x86</p>", "body_text": "I looked into this further. I found the following:\nsetting OMP_NUM_THREADS to 2 or 1 makes the problem go away (at least in the numerous runs I did).\nexport OMP_NUM_THREADS=2\nI also looked at changing affinity_partitioner @ https://github.com/pytorch/pytorch/blob/master/aten/src/ATen/native/cpu/SoftMaxKernel.cpp#L25    to other types of partitioners mentioned in https://software.intel.com/en-us/node/506149.   When using OMP_NUM_THREADS > 2 and using other types of partitioners, the problem is alleviated but still either aborts or SEGV.   I also noticed that using OMP_NUM_THREADS > 1 seem to slow the operation.    I believe this is a race condition where a dangling pointer is called (see https://www.artima.com/cppsource/pure_virtual.html). And for some reason it shows more on ppc64le architecture due to differences in threading and caching architecture with x86", "body": "I looked into this further. I found the following:\r\nsetting OMP_NUM_THREADS to 2 or 1 makes the problem go away (at least in the numerous runs I did).\r\nexport OMP_NUM_THREADS=2\r\nI also looked at changing affinity_partitioner @ https://github.com/pytorch/pytorch/blob/master/aten/src/ATen/native/cpu/SoftMaxKernel.cpp#L25    to other types of partitioners mentioned in https://software.intel.com/en-us/node/506149.   When using OMP_NUM_THREADS > 2 and using other types of partitioners, the problem is alleviated but still either aborts or SEGV.   I also noticed that using OMP_NUM_THREADS > 1 seem to slow the operation.    I believe this is a race condition where a dangling pointer is called (see https://www.artima.com/cppsource/pure_virtual.html). And for some reason it shows more on ppc64le architecture due to differences in threading and caching architecture with x86"}