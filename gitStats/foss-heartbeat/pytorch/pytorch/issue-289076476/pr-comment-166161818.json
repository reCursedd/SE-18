{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/166161818", "pull_request_review_id": 94198319, "id": 166161818, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2NjE2MTgxOA==", "diff_hunk": "@@ -167,6 +172,66 @@ void fuseTransposeIntoGemm(std::shared_ptr<Graph>& graph) {\n   }\n }\n \n+void pushPackingPastRnn(std::shared_ptr<Graph>& graph) {\n+  for (auto it = graph->nodes().begin(); it != graph->nodes().end(); ++it) {\n+    auto* n = *it;\n+\n+    if (n->kind() != kPackPadded) {\n+      continue;\n+    }\n+    if (n->outputs()[0]->uses().size() != 1) {\n+      // For now, only handle the case where there is one consumer.\n+      continue;\n+    }\n+    Node * rnn = n->outputs()[0]->uses()[0].user;\n+    if (!isRNN(rnn)) {\n+      continue;\n+    }\n+\n+    // remove PackPadded from in front of the RNN\n+    n->outputs()[0]->replaceFirstUseWith(n->inputs()[0]);\n+    n->outputs()[1]->replaceFirstUseWith(n->inputs()[1]);\n+\n+    // and insert new PackPadded after the RNN\n+    Node * newPackPadded = graph->create(kPackPadded, 2);\n+    newPackPadded->insertAfter(rnn);\n+\n+    // make things consume from the new PackPadded\n+    rnn->outputs()[0]->replaceAllUsesWith(newPackPadded->outputs()[0]);\n+    n->outputs()[1]->replaceAllUsesWith(newPackPadded->outputs()[1]);\n+\n+    // setup the new PackPadded's inputs\n+    newPackPadded->addInput(rnn->outputs()[0]);\n+    newPackPadded->addInput(n->inputs()[1]);\n+\n+    it.destroyCurrent();\n+  }\n+}\n+\n+void removeNopPacking(std::shared_ptr<Graph>& graph) {\n+  for (auto it = graph->nodes().begin(); it != graph->nodes().end(); ++it) {\n+    auto* n = *it;\n+\n+    if (n->kind() != kPadPacked) {\n+      continue;\n+    }\n+    Node* input = n->inputs()[0]->node();\n+    if (input->kind() != kPackPadded) {\n+      continue;\n+    }\n+    if (input != n->inputs()[1]->node()) {", "path": "torch/csrc/jit/passes/onnx/peephole.cpp", "position": null, "original_position": 63, "commit_id": "c9c0a5924fdbb682f43d1e499db132b5babdba72", "original_commit_id": "a617fe07a346a29e64ce35e7e75f1ffc4acf47f7", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "body": "Mmmm... this is not exactly the right way to do this test (although it is unlikely to matter in practice).\r\n\r\nWhat you have said here is that *any* output of `n` is acceptable as the 1-index `input`. That means if I, for example, say:\r\n\r\n```\r\n%0, %1 = PackPadded\r\n%2 = PadPacked %1, %0\r\n```\r\n\r\nYou would accept this as a no-op and optimize it away. But what you really wanted to say is that the first input is the first output of `PackPadded`, and the second input is the second output of `PackPadded`.", "created_at": "2018-02-06T01:07:57Z", "updated_at": "2018-11-23T15:39:07Z", "html_url": "https://github.com/pytorch/pytorch/pull/4695#discussion_r166161818", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/4695", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/166161818"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/4695#discussion_r166161818"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/4695"}}, "body_html": "<p>Mmmm... this is not exactly the right way to do this test (although it is unlikely to matter in practice).</p>\n<p>What you have said here is that <em>any</em> output of <code>n</code> is acceptable as the 1-index <code>input</code>. That means if I, for example, say:</p>\n<pre><code>%0, %1 = PackPadded\n%2 = PadPacked %1, %0\n</code></pre>\n<p>You would accept this as a no-op and optimize it away. But what you really wanted to say is that the first input is the first output of <code>PackPadded</code>, and the second input is the second output of <code>PackPadded</code>.</p>", "body_text": "Mmmm... this is not exactly the right way to do this test (although it is unlikely to matter in practice).\nWhat you have said here is that any output of n is acceptable as the 1-index input. That means if I, for example, say:\n%0, %1 = PackPadded\n%2 = PadPacked %1, %0\n\nYou would accept this as a no-op and optimize it away. But what you really wanted to say is that the first input is the first output of PackPadded, and the second input is the second output of PackPadded."}