{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/220602979", "pull_request_review_id": 159047444, "id": 220602979, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMDYwMjk3OQ==", "diff_hunk": "@@ -126,92 +125,83 @@ class CAFFE2_API Registerer {\n \n   template <class DerivedType>\n   static ObjectPtrType DefaultCreator(Args... args) {\n-    // TODO(jiayq): old versions of NVCC does not handle make_unique well\n-    // so we are forced to use a unique_ptr constructor here. Check if it is\n-    // fine to use make_unique in the future.\n-    // return make_unique<DerivedType>(args...);\n     return ObjectPtrType(new DerivedType(args...));\n   }\n };\n \n /**\n- * AT_ANONYMOUS_VARIABLE(str) introduces an identifier starting with\n+ * C10_ANONYMOUS_VARIABLE(str) introduces an identifier starting with\n  * str and ending with a number that varies with the line.\n- * Pretty much a copy from 'folly/Preprocessor.h'\n  */\n-#define AT_CONCATENATE_IMPL(s1, s2) s1##s2\n-#define AT_CONCATENATE(s1, s2) AT_CONCATENATE_IMPL(s1, s2)\n+#define C10_CONCATENATE_IMPL(s1, s2) s1##s2\n+#define C10_CONCATENATE(s1, s2) C10_CONCATENATE_IMPL(s1, s2)\n #ifdef __COUNTER__\n-#define AT_ANONYMOUS_VARIABLE(str) AT_CONCATENATE(str, __COUNTER__)\n+#define C10_ANONYMOUS_VARIABLE(str) C10_CONCATENATE(str, __COUNTER__)\n #else\n-#define AT_ANONYMOUS_VARIABLE(str) AT_CONCATENATE(str, __LINE__)\n+#define C10_ANONYMOUS_VARIABLE(str) C10_CONCATENATE(str, __LINE__)\n #endif\n \n /**\n- * AT_DECLARE_TYPED_REGISTRY is a macro that expands to a function\n+ * C10_DECLARE_TYPED_REGISTRY is a macro that expands to a function\n  * declaration, as well as creating a convenient typename for its corresponding\n  * registerer.\n  */\n-#define AT_DECLARE_TYPED_REGISTRY(                                \\\n+#define C10_DECLARE_TYPED_REGISTRY(                                \\\n     RegistryName, SrcType, ObjectType, PtrType, ...)              \\\n-  CAFFE2_API Registry<SrcType, PtrType<ObjectType>, __VA_ARGS__>* \\\n+  C10_IMPORT ::c10::Registry<SrcType, PtrType<ObjectType>, ##__VA_ARGS__>* \\", "path": "c10/util/Registry.h", "position": 129, "original_position": 116, "commit_id": "0f4377afed19a4bc5b8444255394bff97fbe9559", "original_commit_id": "e393dc538498133938629877101c1a4814b67a32", "user": {"login": "Yangqing", "id": 551151, "node_id": "MDQ6VXNlcjU1MTE1MQ==", "avatar_url": "https://avatars1.githubusercontent.com/u/551151?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Yangqing", "html_url": "https://github.com/Yangqing", "followers_url": "https://api.github.com/users/Yangqing/followers", "following_url": "https://api.github.com/users/Yangqing/following{/other_user}", "gists_url": "https://api.github.com/users/Yangqing/gists{/gist_id}", "starred_url": "https://api.github.com/users/Yangqing/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Yangqing/subscriptions", "organizations_url": "https://api.github.com/users/Yangqing/orgs", "repos_url": "https://api.github.com/users/Yangqing/repos", "events_url": "https://api.github.com/users/Yangqing/events{/privacy}", "received_events_url": "https://api.github.com/users/Yangqing/received_events", "type": "User", "site_admin": false}, "body": "Pasting explanation here:\r\n\r\n```\r\n// Note on C10_IMPORT and C10_EXPORT below: we need to explicitly mark DECLARE\r\n// as import and DEFINE as export, because these registry macros will be used\r\n// in downstream shared libraries as well, and one cannot use *_API - the API\r\n// macro will be defined on a per-shared-library basis. Semantically, when one\r\n// declares a typed registry it is always going to be IMPORT, and when one\r\n// defines a registry (which should happen ONLY ONCE and ONLY IN SOURCE FILE),\r\n// the instantiation unit is always going to be exported.\r\n//\r\n// The only unique condition is when in the same file one does DECLARE and\r\n// DEFINE - in Windows compilers, this generates a warning that dllimport and\r\n// dllexport are mixed, but the warning is fine and linker will be properly\r\n// exporting the symbol. Same thing happens in the gflags flag declaration and\r\n// definition caes.\r\n```", "created_at": "2018-09-26T15:05:06Z", "updated_at": "2018-11-23T15:52:02Z", "html_url": "https://github.com/pytorch/pytorch/pull/12077#discussion_r220602979", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/12077", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/220602979"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/12077#discussion_r220602979"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/12077"}}, "body_html": "<p>Pasting explanation here:</p>\n<pre><code>// Note on C10_IMPORT and C10_EXPORT below: we need to explicitly mark DECLARE\n// as import and DEFINE as export, because these registry macros will be used\n// in downstream shared libraries as well, and one cannot use *_API - the API\n// macro will be defined on a per-shared-library basis. Semantically, when one\n// declares a typed registry it is always going to be IMPORT, and when one\n// defines a registry (which should happen ONLY ONCE and ONLY IN SOURCE FILE),\n// the instantiation unit is always going to be exported.\n//\n// The only unique condition is when in the same file one does DECLARE and\n// DEFINE - in Windows compilers, this generates a warning that dllimport and\n// dllexport are mixed, but the warning is fine and linker will be properly\n// exporting the symbol. Same thing happens in the gflags flag declaration and\n// definition caes.\n</code></pre>", "body_text": "Pasting explanation here:\n// Note on C10_IMPORT and C10_EXPORT below: we need to explicitly mark DECLARE\n// as import and DEFINE as export, because these registry macros will be used\n// in downstream shared libraries as well, and one cannot use *_API - the API\n// macro will be defined on a per-shared-library basis. Semantically, when one\n// declares a typed registry it is always going to be IMPORT, and when one\n// defines a registry (which should happen ONLY ONCE and ONLY IN SOURCE FILE),\n// the instantiation unit is always going to be exported.\n//\n// The only unique condition is when in the same file one does DECLARE and\n// DEFINE - in Windows compilers, this generates a warning that dllimport and\n// dllexport are mixed, but the warning is fine and linker will be properly\n// exporting the symbol. Same thing happens in the gflags flag declaration and\n// definition caes.", "in_reply_to_id": 220568222}