{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/376668691", "html_url": "https://github.com/pytorch/pytorch/pull/6042#issuecomment-376668691", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/6042", "id": 376668691, "node_id": "MDEyOklzc3VlQ29tbWVudDM3NjY2ODY5MQ==", "user": {"login": "avmgithub", "id": 9083746, "node_id": "MDQ6VXNlcjkwODM3NDY=", "avatar_url": "https://avatars1.githubusercontent.com/u/9083746?v=4", "gravatar_id": "", "url": "https://api.github.com/users/avmgithub", "html_url": "https://github.com/avmgithub", "followers_url": "https://api.github.com/users/avmgithub/followers", "following_url": "https://api.github.com/users/avmgithub/following{/other_user}", "gists_url": "https://api.github.com/users/avmgithub/gists{/gist_id}", "starred_url": "https://api.github.com/users/avmgithub/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/avmgithub/subscriptions", "organizations_url": "https://api.github.com/users/avmgithub/orgs", "repos_url": "https://api.github.com/users/avmgithub/repos", "events_url": "https://api.github.com/users/avmgithub/events{/privacy}", "received_events_url": "https://api.github.com/users/avmgithub/received_events", "type": "User", "site_admin": false}, "created_at": "2018-03-27T20:43:52Z", "updated_at": "2018-03-27T20:43:52Z", "author_association": "CONTRIBUTOR", "body_html": "<p>yeah, I think Adam had the same conclusion in this <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"268260572\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/3277\" data-hovercard-type=\"issue\" data-hovercard-url=\"/pytorch/pytorch/issues/3277/hovercard\" href=\"https://github.com/pytorch/pytorch/issues/3277\">#3277</a>.<br>\ncasting integral types to unsigned integral types is always well defined (in modulo arithmetic), but in case of floating point types you can cast it to any integral type, but result is only well defined if it can be represented as a truncated value (even when the destination type is unsigned!!!). An excerpt from C++ standard:</p>\n<pre><code>Floating\u2013integral conversions\n\n...\nIf the value cannot fit into the destination type, the behavior is undefined (even when the destination type is unsigned, modulo arithmetic does not apply).\n...\n</code></pre>", "body_text": "yeah, I think Adam had the same conclusion in this #3277.\ncasting integral types to unsigned integral types is always well defined (in modulo arithmetic), but in case of floating point types you can cast it to any integral type, but result is only well defined if it can be represented as a truncated value (even when the destination type is unsigned!!!). An excerpt from C++ standard:\nFloating\u2013integral conversions\n\n...\nIf the value cannot fit into the destination type, the behavior is undefined (even when the destination type is unsigned, modulo arithmetic does not apply).\n...", "body": "yeah, I think Adam had the same conclusion in this https://github.com/pytorch/pytorch/issues/3277.\r\ncasting integral types to unsigned integral types is always well defined (in modulo arithmetic), but in case of floating point types you can cast it to any integral type, but result is only well defined if it can be represented as a truncated value (even when the destination type is unsigned!!!). An excerpt from C++ standard:\r\n\r\n    Floating\u2013integral conversions\r\n\r\n    ...\r\n    If the value cannot fit into the destination type, the behavior is undefined (even when the destination type is unsigned, modulo arithmetic does not apply).\r\n    ...\r\n"}