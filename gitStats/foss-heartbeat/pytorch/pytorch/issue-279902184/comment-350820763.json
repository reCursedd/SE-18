{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/350820763", "html_url": "https://github.com/pytorch/pytorch/pull/4058#issuecomment-350820763", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/4058", "id": 350820763, "node_id": "MDEyOklzc3VlQ29tbWVudDM1MDgyMDc2Mw==", "user": {"login": "zou3519", "id": 5652049, "node_id": "MDQ6VXNlcjU2NTIwNDk=", "avatar_url": "https://avatars3.githubusercontent.com/u/5652049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zou3519", "html_url": "https://github.com/zou3519", "followers_url": "https://api.github.com/users/zou3519/followers", "following_url": "https://api.github.com/users/zou3519/following{/other_user}", "gists_url": "https://api.github.com/users/zou3519/gists{/gist_id}", "starred_url": "https://api.github.com/users/zou3519/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zou3519/subscriptions", "organizations_url": "https://api.github.com/users/zou3519/orgs", "repos_url": "https://api.github.com/users/zou3519/repos", "events_url": "https://api.github.com/users/zou3519/events{/privacy}", "received_events_url": "https://api.github.com/users/zou3519/received_events", "type": "User", "site_admin": false}, "created_at": "2017-12-11T18:53:09Z", "updated_at": "2017-12-11T18:53:09Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Scalar checks for review:</p>\n<pre><code>Tensor SparseCPUFloatType::_indices(const Tensor &amp; self) const {\n    auto self_ = checked_cast_tensor&lt;SparseCPUFloatTensor&gt;(self.pImpl,\"self\",1, false);\n    if (self_-&gt;isScalar()) {\n      // Empty tensor\n      return self_-&gt;type().toScalarType(kLong).zeros({});\n    }\n    return Tensor((new CPULongTensor(context, THSFloatTensor_newIndices(self_-&gt;tensor))),false);\n}\nTensor SparseCPUFloatType::_values(const Tensor &amp; self) const {\n    auto self_ = checked_cast_tensor&lt;SparseCPUFloatTensor&gt;(self.pImpl,\"self\",1, false);\n    return Tensor((new CPUFloatTensor(context, THSFloatTensor_newValues(self_-&gt;tensor)))-&gt;maybeScalar(self_-\n&gt;isScalar()),false);\n}\n</code></pre>\n<p><code>_values</code> should return a scalar if the sparse tensor is scalar; <code>_indices</code> should return an empty tensor (or maybe I should have it return a tensor with size (0, 1)?). I don't think there's a way to make a scalar sparse tensor right now so I haven't tested these</p>", "body_text": "Scalar checks for review:\nTensor SparseCPUFloatType::_indices(const Tensor & self) const {\n    auto self_ = checked_cast_tensor<SparseCPUFloatTensor>(self.pImpl,\"self\",1, false);\n    if (self_->isScalar()) {\n      // Empty tensor\n      return self_->type().toScalarType(kLong).zeros({});\n    }\n    return Tensor((new CPULongTensor(context, THSFloatTensor_newIndices(self_->tensor))),false);\n}\nTensor SparseCPUFloatType::_values(const Tensor & self) const {\n    auto self_ = checked_cast_tensor<SparseCPUFloatTensor>(self.pImpl,\"self\",1, false);\n    return Tensor((new CPUFloatTensor(context, THSFloatTensor_newValues(self_->tensor)))->maybeScalar(self_-\n>isScalar()),false);\n}\n\n_values should return a scalar if the sparse tensor is scalar; _indices should return an empty tensor (or maybe I should have it return a tensor with size (0, 1)?). I don't think there's a way to make a scalar sparse tensor right now so I haven't tested these", "body": "Scalar checks for review:\r\n\r\n```\r\nTensor SparseCPUFloatType::_indices(const Tensor & self) const {\r\n    auto self_ = checked_cast_tensor<SparseCPUFloatTensor>(self.pImpl,\"self\",1, false);\r\n    if (self_->isScalar()) {\r\n      // Empty tensor\r\n      return self_->type().toScalarType(kLong).zeros({});\r\n    }\r\n    return Tensor((new CPULongTensor(context, THSFloatTensor_newIndices(self_->tensor))),false);\r\n}\r\nTensor SparseCPUFloatType::_values(const Tensor & self) const {\r\n    auto self_ = checked_cast_tensor<SparseCPUFloatTensor>(self.pImpl,\"self\",1, false);\r\n    return Tensor((new CPUFloatTensor(context, THSFloatTensor_newValues(self_->tensor)))->maybeScalar(self_-\r\n>isScalar()),false);\r\n}\r\n```\r\n\r\n`_values` should return a scalar if the sparse tensor is scalar; `_indices` should return an empty tensor (or maybe I should have it return a tensor with size (0, 1)?). I don't think there's a way to make a scalar sparse tensor right now so I haven't tested these"}