{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/407104844", "html_url": "https://github.com/pytorch/pytorch/pull/9651#issuecomment-407104844", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/9651", "id": 407104844, "node_id": "MDEyOklzc3VlQ29tbWVudDQwNzEwNDg0NA==", "user": {"login": "t-vi", "id": 20787943, "node_id": "MDQ6VXNlcjIwNzg3OTQz", "avatar_url": "https://avatars2.githubusercontent.com/u/20787943?v=4", "gravatar_id": "", "url": "https://api.github.com/users/t-vi", "html_url": "https://github.com/t-vi", "followers_url": "https://api.github.com/users/t-vi/followers", "following_url": "https://api.github.com/users/t-vi/following{/other_user}", "gists_url": "https://api.github.com/users/t-vi/gists{/gist_id}", "starred_url": "https://api.github.com/users/t-vi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/t-vi/subscriptions", "organizations_url": "https://api.github.com/users/t-vi/orgs", "repos_url": "https://api.github.com/users/t-vi/repos", "events_url": "https://api.github.com/users/t-vi/events{/privacy}", "received_events_url": "https://api.github.com/users/t-vi/received_events", "type": "User", "site_admin": false}, "created_at": "2018-07-23T15:46:40Z", "updated_at": "2018-07-23T15:46:40Z", "author_association": "CONTRIBUTOR", "body_html": "<p>So we passed a tensor to scipy.stat.binom.<br>\nPreviously, that would be cast to an array whenever a binary operator with an array was used.<br>\nNow things become tensors in these cases - except when we define the op, as is the case for \"&amp;\".<br>\nSo some check failed because it passed an array to scipy and that tried \"array &amp; tensor\".</p>\n<p>Now if you look at <a href=\"https://github.com/scipy/scipy/blob/master/scipy/stats/_distn_infrastructure.py\">https://github.com/scipy/scipy/blob/master/scipy/stats/_distn_infrastructure.py</a>, you see that most functions use <code>asarray</code> on their inputs. Apparently we managed to hit one that doesn't. However, it seems that that not using <code>asarray</code> is considered a scipy bug - the latest commit is from June and changes that for a particular instance with a comment indicating that it is considered a bugfix.</p>\n<p>So in the the spectrum of \"mixing non-tensor and tensor\" you could have these options</p>\n<ul>\n<li>depend on who's left and right of a binary op (current behaviour - but highly inconsistent),</li>\n<li>always yield to the other, (setting a strongly negative array_priority),</li>\n<li>return a tensor for scalar + tensor but an array for array + tensor (setting a slightly negative array priority),</li>\n<li>always return a tensor (setting a positive array priority - this is what this patch does).</li>\n</ul>\n<p>That means that functions who didn't use asarray and relied on some binary op doing an implicit conversion and actually need an array now fail.</p>\n<p>So in summary, I'm not terribly worried about the backwards compatibility - it was more than fragile before - if scipy decided to do <code>a * b</code> instead of <code>b * a</code> somewhere, code would suddenly fail. In fact, I think any consistent behaviour would be better, setting a positive array_priority just is PyTorch vanity. ;)</p>", "body_text": "So we passed a tensor to scipy.stat.binom.\nPreviously, that would be cast to an array whenever a binary operator with an array was used.\nNow things become tensors in these cases - except when we define the op, as is the case for \"&\".\nSo some check failed because it passed an array to scipy and that tried \"array & tensor\".\nNow if you look at https://github.com/scipy/scipy/blob/master/scipy/stats/_distn_infrastructure.py, you see that most functions use asarray on their inputs. Apparently we managed to hit one that doesn't. However, it seems that that not using asarray is considered a scipy bug - the latest commit is from June and changes that for a particular instance with a comment indicating that it is considered a bugfix.\nSo in the the spectrum of \"mixing non-tensor and tensor\" you could have these options\n\ndepend on who's left and right of a binary op (current behaviour - but highly inconsistent),\nalways yield to the other, (setting a strongly negative array_priority),\nreturn a tensor for scalar + tensor but an array for array + tensor (setting a slightly negative array priority),\nalways return a tensor (setting a positive array priority - this is what this patch does).\n\nThat means that functions who didn't use asarray and relied on some binary op doing an implicit conversion and actually need an array now fail.\nSo in summary, I'm not terribly worried about the backwards compatibility - it was more than fragile before - if scipy decided to do a * b instead of b * a somewhere, code would suddenly fail. In fact, I think any consistent behaviour would be better, setting a positive array_priority just is PyTorch vanity. ;)", "body": "So we passed a tensor to scipy.stat.binom. \r\nPreviously, that would be cast to an array whenever a binary operator with an array was used.\r\nNow things become tensors in these cases - except when we define the op, as is the case for \"&\".\r\nSo some check failed because it passed an array to scipy and that tried \"array & tensor\".\r\n\r\nNow if you look at https://github.com/scipy/scipy/blob/master/scipy/stats/_distn_infrastructure.py, you see that most functions use `asarray` on their inputs. Apparently we managed to hit one that doesn't. However, it seems that that not using `asarray` is considered a scipy bug - the latest commit is from June and changes that for a particular instance with a comment indicating that it is considered a bugfix.\r\n\r\nSo in the the spectrum of \"mixing non-tensor and tensor\" you could have these options\r\n- depend on who's left and right of a binary op (current behaviour - but highly inconsistent),\r\n- always yield to the other, (setting a strongly negative array_priority),\r\n- return a tensor for scalar + tensor but an array for array + tensor (setting a slightly negative array priority),\r\n- always return a tensor (setting a positive array priority - this is what this patch does).\r\n\r\nThat means that functions who didn't use asarray and relied on some binary op doing an implicit conversion and actually need an array now fail.\r\n\r\nSo in summary, I'm not terribly worried about the backwards compatibility - it was more than fragile before - if scipy decided to do `a * b` instead of `b * a` somewhere, code would suddenly fail. In fact, I think any consistent behaviour would be better, setting a positive array_priority just is PyTorch vanity. ;)\r\n"}