{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/103802073", "pull_request_review_id": 24603483, "id": 103802073, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwMzgwMjA3Mw==", "diff_hunk": "@@ -3,13 +3,33 @@\n #include \"torch/csrc/autograd/engine.h\"\n #include \"torch/csrc/THP.h\"\n #include \"torch/csrc/DynamicTypes.h\"\n+#include \"torch/csrc/utils/auto_gil.h\"\n \n using namespace torch::autograd;\n \n struct THPEngine {\n     PyObject_HEAD\n };\n \n+struct PythonEngine : public Engine {\n+  virtual void thread_main(ReadyQueue& queue) override {\n+    AutoGIL gil;\n+    AutoNoGIL no_gil;", "path": "torch/csrc/autograd/python_engine.cpp", "position": null, "original_position": 15, "commit_id": "6336300880349038c5bf6f5dfe3b37864eb39acb", "original_commit_id": "a2e0187c8406e17538e725595606f510394b2303", "user": {"login": "colesbury", "id": 655866, "node_id": "MDQ6VXNlcjY1NTg2Ng==", "avatar_url": "https://avatars1.githubusercontent.com/u/655866?v=4", "gravatar_id": "", "url": "https://api.github.com/users/colesbury", "html_url": "https://github.com/colesbury", "followers_url": "https://api.github.com/users/colesbury/followers", "following_url": "https://api.github.com/users/colesbury/following{/other_user}", "gists_url": "https://api.github.com/users/colesbury/gists{/gist_id}", "starred_url": "https://api.github.com/users/colesbury/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/colesbury/subscriptions", "organizations_url": "https://api.github.com/users/colesbury/orgs", "repos_url": "https://api.github.com/users/colesbury/repos", "events_url": "https://api.github.com/users/colesbury/events{/privacy}", "received_events_url": "https://api.github.com/users/colesbury/received_events", "type": "User", "site_admin": false}, "body": "Yes. From the Python source code it looked like the first and last calls to `PyGILState_Ensure` and  `PyGILState_Release` are more expensive since they create and delete `PyThreadState` objects. Without this, internal calls will create and delete `PyThreadState` objects instead of just acquiring and releasing the lock.  It would still be correct without these two lines, but may be more expensive.\r\n\r\nI'm not entirely sure about the cost -- I haven't measured it without these lines.", "created_at": "2017-03-01T22:08:15Z", "updated_at": "2018-11-23T15:32:39Z", "html_url": "https://github.com/pytorch/pytorch/pull/881#discussion_r103802073", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/881", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/103802073"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/881#discussion_r103802073"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/881"}}, "body_html": "<p>Yes. From the Python source code it looked like the first and last calls to <code>PyGILState_Ensure</code> and  <code>PyGILState_Release</code> are more expensive since they create and delete <code>PyThreadState</code> objects. Without this, internal calls will create and delete <code>PyThreadState</code> objects instead of just acquiring and releasing the lock.  It would still be correct without these two lines, but may be more expensive.</p>\n<p>I'm not entirely sure about the cost -- I haven't measured it without these lines.</p>", "body_text": "Yes. From the Python source code it looked like the first and last calls to PyGILState_Ensure and  PyGILState_Release are more expensive since they create and delete PyThreadState objects. Without this, internal calls will create and delete PyThreadState objects instead of just acquiring and releasing the lock.  It would still be correct without these two lines, but may be more expensive.\nI'm not entirely sure about the cost -- I haven't measured it without these lines.", "in_reply_to_id": 103797687}