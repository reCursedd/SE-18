{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/397462293", "html_url": "https://github.com/pytorch/pytorch/pull/8475#issuecomment-397462293", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/8475", "id": 397462293, "node_id": "MDEyOklzc3VlQ29tbWVudDM5NzQ2MjI5Mw==", "user": {"login": "goldsborough", "id": 6429851, "node_id": "MDQ6VXNlcjY0Mjk4NTE=", "avatar_url": "https://avatars3.githubusercontent.com/u/6429851?v=4", "gravatar_id": "", "url": "https://api.github.com/users/goldsborough", "html_url": "https://github.com/goldsborough", "followers_url": "https://api.github.com/users/goldsborough/followers", "following_url": "https://api.github.com/users/goldsborough/following{/other_user}", "gists_url": "https://api.github.com/users/goldsborough/gists{/gist_id}", "starred_url": "https://api.github.com/users/goldsborough/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/goldsborough/subscriptions", "organizations_url": "https://api.github.com/users/goldsborough/orgs", "repos_url": "https://api.github.com/users/goldsborough/repos", "events_url": "https://api.github.com/users/goldsborough/events{/privacy}", "received_events_url": "https://api.github.com/users/goldsborough/received_events", "type": "User", "site_admin": false}, "created_at": "2018-06-14T22:53:57Z", "updated_at": "2018-06-14T22:55:01Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=655866\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/colesbury\">@colesbury</a> I ran into a lot of trouble around ambiguous constructors for <code>ArrayRef</code>. Having two functions with <code>ArrayRef&lt;double&gt;</code> and <code>ArrayRef&lt;int&gt;</code> causes <code>{1, 2, 3}</code> to be ambiguous because it doesn't know whether to call <code>ArrayRef&lt;double&gt;({1, 2, 3})</code> or <code>ArrayRef&lt;int&gt;({1, 2, 3})</code>. Of course, only one would be preferred during overload resolution, but the compiler can't think that far (the ambiguity comes from knowing whether to invoke the constructor of <code>ArrayRef&lt;double&gt;</code> or <code>ArrayRef&lt;int&gt;</code>.</p>\n<p>Instead I've made the methods templated. This way, at least you can write <code>at::tensor&lt;int64_t&gt;({1, 2, 3})</code>. It's still not as nice as <code>ScalarList</code>, which solved the whole ambiguity problem, but I guess it doesn't incur a copy and is less code ...</p>", "body_text": "@colesbury I ran into a lot of trouble around ambiguous constructors for ArrayRef. Having two functions with ArrayRef<double> and ArrayRef<int> causes {1, 2, 3} to be ambiguous because it doesn't know whether to call ArrayRef<double>({1, 2, 3}) or ArrayRef<int>({1, 2, 3}). Of course, only one would be preferred during overload resolution, but the compiler can't think that far (the ambiguity comes from knowing whether to invoke the constructor of ArrayRef<double> or ArrayRef<int>.\nInstead I've made the methods templated. This way, at least you can write at::tensor<int64_t>({1, 2, 3}). It's still not as nice as ScalarList, which solved the whole ambiguity problem, but I guess it doesn't incur a copy and is less code ...", "body": "@colesbury I ran into a lot of trouble around ambiguous constructors for `ArrayRef`. Having two functions with `ArrayRef<double>` and `ArrayRef<int>` causes `{1, 2, 3}` to be ambiguous because it doesn't know whether to call `ArrayRef<double>({1, 2, 3})` or `ArrayRef<int>({1, 2, 3})`. Of course, only one would be preferred during overload resolution, but the compiler can't think that far (the ambiguity comes from knowing whether to invoke the constructor of `ArrayRef<double>` or `ArrayRef<int>`.\r\n\r\nInstead I've made the methods templated. This way, at least you can write `at::tensor<int64_t>({1, 2, 3})`. It's still not as nice as `ScalarList`, which solved the whole ambiguity problem, but I guess it doesn't incur a copy and is less code ... "}