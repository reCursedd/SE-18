{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/398231495", "html_url": "https://github.com/pytorch/pytorch/pull/8475#issuecomment-398231495", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/8475", "id": 398231495, "node_id": "MDEyOklzc3VlQ29tbWVudDM5ODIzMTQ5NQ==", "user": {"login": "goldsborough", "id": 6429851, "node_id": "MDQ6VXNlcjY0Mjk4NTE=", "avatar_url": "https://avatars3.githubusercontent.com/u/6429851?v=4", "gravatar_id": "", "url": "https://api.github.com/users/goldsborough", "html_url": "https://github.com/goldsborough", "followers_url": "https://api.github.com/users/goldsborough/followers", "following_url": "https://api.github.com/users/goldsborough/following{/other_user}", "gists_url": "https://api.github.com/users/goldsborough/gists{/gist_id}", "starred_url": "https://api.github.com/users/goldsborough/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/goldsborough/subscriptions", "organizations_url": "https://api.github.com/users/goldsborough/orgs", "repos_url": "https://api.github.com/users/goldsborough/repos", "events_url": "https://api.github.com/users/goldsborough/events{/privacy}", "received_events_url": "https://api.github.com/users/goldsborough/received_events", "type": "User", "site_admin": false}, "created_at": "2018-06-18T23:57:38Z", "updated_at": "2018-06-18T23:57:38Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=655866\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/colesbury\">@colesbury</a> <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=13564\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/ezyang\">@ezyang</a> please take another look. I used the <code>FORALL_SCALAR_TYPES</code> macro and it works very well now. I'm omitting half support because it would require a more complicated separate implementation, and we don't need it urgently.</p>\n<p>Added lots of tests.</p>\n<p>My local test case:</p>\n<pre><code>std::vector&lt;int&gt; v = {1, 2, 3, 5, 6};\n  std::vector&lt;float&gt; w = {1, 2, 3, 5, 6};\n  std::cout &lt;&lt; at::tensor(123.456) + 0.5 &lt;&lt; std::endl;\n  std::cout &lt;&lt; at::tensor({1, 2, 3}) + 0.5 &lt;&lt; std::endl;\n  std::cout &lt;&lt; at::tensor(v) + 0.5 &lt;&lt; std::endl;\n  std::cout &lt;&lt; at::tensor(w) + 0.5 &lt;&lt; std::endl;\n  std::cout &lt;&lt; at::tensor({1.0, 2.0, 3.0}) + 0.5 &lt;&lt; std::endl;\n  std::cout &lt;&lt; at::tensor({1.5, 2.6, 3.7}, at::kInt) + 0.5 &lt;&lt; std::endl;\n  std::cout &lt;&lt; at::tensor(123, at::kByte) + 0.5 &lt;&lt; std::endl;\n</code></pre>\n<p>prints</p>\n<pre><code> 123.9560\n[ CPUDoubleTensor{1} ]\n 1\n 2\n 3\n[ CPUIntTensor{3} ]\n 1\n 2\n 3\n 5\n 6\n[ CPUIntTensor{5} ]\n 1.5000\n 2.5000\n 3.5000\n 5.5000\n 6.5000\n[ CPUFloatTensor{5} ]\n 1.5000\n 2.5000\n 3.5000\n[ CPUDoubleTensor{3} ]\n 1\n 2\n 3\n[ CPUIntTensor{3} ]\n 123\n[ CPUByteTensor{1} ]\n</code></pre>", "body_text": "@colesbury @ezyang please take another look. I used the FORALL_SCALAR_TYPES macro and it works very well now. I'm omitting half support because it would require a more complicated separate implementation, and we don't need it urgently.\nAdded lots of tests.\nMy local test case:\nstd::vector<int> v = {1, 2, 3, 5, 6};\n  std::vector<float> w = {1, 2, 3, 5, 6};\n  std::cout << at::tensor(123.456) + 0.5 << std::endl;\n  std::cout << at::tensor({1, 2, 3}) + 0.5 << std::endl;\n  std::cout << at::tensor(v) + 0.5 << std::endl;\n  std::cout << at::tensor(w) + 0.5 << std::endl;\n  std::cout << at::tensor({1.0, 2.0, 3.0}) + 0.5 << std::endl;\n  std::cout << at::tensor({1.5, 2.6, 3.7}, at::kInt) + 0.5 << std::endl;\n  std::cout << at::tensor(123, at::kByte) + 0.5 << std::endl;\n\nprints\n 123.9560\n[ CPUDoubleTensor{1} ]\n 1\n 2\n 3\n[ CPUIntTensor{3} ]\n 1\n 2\n 3\n 5\n 6\n[ CPUIntTensor{5} ]\n 1.5000\n 2.5000\n 3.5000\n 5.5000\n 6.5000\n[ CPUFloatTensor{5} ]\n 1.5000\n 2.5000\n 3.5000\n[ CPUDoubleTensor{3} ]\n 1\n 2\n 3\n[ CPUIntTensor{3} ]\n 123\n[ CPUByteTensor{1} ]", "body": "@colesbury @ezyang please take another look. I used the `FORALL_SCALAR_TYPES` macro and it works very well now. I'm omitting half support because it would require a more complicated separate implementation, and we don't need it urgently.\r\n\r\nAdded lots of tests.\r\n\r\nMy local test case:\r\n\r\n```\r\nstd::vector<int> v = {1, 2, 3, 5, 6};\r\n  std::vector<float> w = {1, 2, 3, 5, 6};\r\n  std::cout << at::tensor(123.456) + 0.5 << std::endl;\r\n  std::cout << at::tensor({1, 2, 3}) + 0.5 << std::endl;\r\n  std::cout << at::tensor(v) + 0.5 << std::endl;\r\n  std::cout << at::tensor(w) + 0.5 << std::endl;\r\n  std::cout << at::tensor({1.0, 2.0, 3.0}) + 0.5 << std::endl;\r\n  std::cout << at::tensor({1.5, 2.6, 3.7}, at::kInt) + 0.5 << std::endl;\r\n  std::cout << at::tensor(123, at::kByte) + 0.5 << std::endl;\r\n```\r\n\r\nprints\r\n\r\n```\r\n 123.9560\r\n[ CPUDoubleTensor{1} ]\r\n 1\r\n 2\r\n 3\r\n[ CPUIntTensor{3} ]\r\n 1\r\n 2\r\n 3\r\n 5\r\n 6\r\n[ CPUIntTensor{5} ]\r\n 1.5000\r\n 2.5000\r\n 3.5000\r\n 5.5000\r\n 6.5000\r\n[ CPUFloatTensor{5} ]\r\n 1.5000\r\n 2.5000\r\n 3.5000\r\n[ CPUDoubleTensor{3} ]\r\n 1\r\n 2\r\n 3\r\n[ CPUIntTensor{3} ]\r\n 123\r\n[ CPUByteTensor{1} ]\r\n```"}