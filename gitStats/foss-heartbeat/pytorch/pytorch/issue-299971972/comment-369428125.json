{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/369428125", "html_url": "https://github.com/pytorch/pytorch/issues/5400#issuecomment-369428125", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/5400", "id": 369428125, "node_id": "MDEyOklzc3VlQ29tbWVudDM2OTQyODEyNQ==", "user": {"login": "soumith", "id": 1310570, "node_id": "MDQ6VXNlcjEzMTA1NzA=", "avatar_url": "https://avatars0.githubusercontent.com/u/1310570?v=4", "gravatar_id": "", "url": "https://api.github.com/users/soumith", "html_url": "https://github.com/soumith", "followers_url": "https://api.github.com/users/soumith/followers", "following_url": "https://api.github.com/users/soumith/following{/other_user}", "gists_url": "https://api.github.com/users/soumith/gists{/gist_id}", "starred_url": "https://api.github.com/users/soumith/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/soumith/subscriptions", "organizations_url": "https://api.github.com/users/soumith/orgs", "repos_url": "https://api.github.com/users/soumith/repos", "events_url": "https://api.github.com/users/soumith/events{/privacy}", "received_events_url": "https://api.github.com/users/soumith/received_events", "type": "User", "site_admin": false}, "created_at": "2018-03-01T00:08:39Z", "updated_at": "2018-03-01T00:08:39Z", "author_association": "MEMBER", "body_html": "<p>So, the invalid free is a bit of a side-effect of the wheel binaries that we have.<br>\nYour original issue is what <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=8813817\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/li-roy\">@li-roy</a> reported, i.e.</p>\n<pre><code>RuntimeError: invalid argument 2: pad should be smaller than half of kernel size, but got kT: 1 kW: 3, kH: 3, padT: 1, padW: 0, padH: 0 at /data/users/royboy/pytorch/torch/lib/THNN/generic/VolumetricDilatedMaxPooling.c:52\n</code></pre>\n<p>He couldn't reproduce it probably because of using conda binaries or source installs.</p>\n<p>the rabbit-hole is deep, but the happens roughly because of this:</p>\n<ul>\n<li>we statically link stdc++ with binaries (because old OSes usually dont have  a sufficiently recent stdc++ shipped)</li>\n<li>additionally because a bug in the libstdc++ shipped with RHEL6, we also statically link weak symbols (that includes destructors)</li>\n<li>the consequence of statically linking destructors of libstdc++ is a bit iffy. For certain internal data structures like std::string, each instance of libstdc++ symbols (my understanding / speculation) do their own book-keeping for construction/destruction, i.e. each string is sort of interned in a sense, internal to the library.</li>\n</ul>\n<p>So what actually is happening is</p>\n<ul>\n<li>a std::string  was passed from the THNN extension side over to _C land</li>\n<li>_C, after finishing using the string, calls the destructor on it</li>\n<li>but because _C didn't actually allocate the string, it's internal table doesn't have a reference to the pointer, so it sees it as an invalid free</li>\n</ul>\n<p>In the next binary release, I'll figure out a solution for this.</p>\n<p>Thanks a lot for the issue and the repro.</p>", "body_text": "So, the invalid free is a bit of a side-effect of the wheel binaries that we have.\nYour original issue is what @li-roy reported, i.e.\nRuntimeError: invalid argument 2: pad should be smaller than half of kernel size, but got kT: 1 kW: 3, kH: 3, padT: 1, padW: 0, padH: 0 at /data/users/royboy/pytorch/torch/lib/THNN/generic/VolumetricDilatedMaxPooling.c:52\n\nHe couldn't reproduce it probably because of using conda binaries or source installs.\nthe rabbit-hole is deep, but the happens roughly because of this:\n\nwe statically link stdc++ with binaries (because old OSes usually dont have  a sufficiently recent stdc++ shipped)\nadditionally because a bug in the libstdc++ shipped with RHEL6, we also statically link weak symbols (that includes destructors)\nthe consequence of statically linking destructors of libstdc++ is a bit iffy. For certain internal data structures like std::string, each instance of libstdc++ symbols (my understanding / speculation) do their own book-keeping for construction/destruction, i.e. each string is sort of interned in a sense, internal to the library.\n\nSo what actually is happening is\n\na std::string  was passed from the THNN extension side over to _C land\n_C, after finishing using the string, calls the destructor on it\nbut because _C didn't actually allocate the string, it's internal table doesn't have a reference to the pointer, so it sees it as an invalid free\n\nIn the next binary release, I'll figure out a solution for this.\nThanks a lot for the issue and the repro.", "body": "So, the invalid free is a bit of a side-effect of the wheel binaries that we have.\r\nYour original issue is what @li-roy reported, i.e. \r\n```\r\nRuntimeError: invalid argument 2: pad should be smaller than half of kernel size, but got kT: 1 kW: 3, kH: 3, padT: 1, padW: 0, padH: 0 at /data/users/royboy/pytorch/torch/lib/THNN/generic/VolumetricDilatedMaxPooling.c:52\r\n```\r\nHe couldn't reproduce it probably because of using conda binaries or source installs.\r\n\r\nthe rabbit-hole is deep, but the happens roughly because of this:\r\n- we statically link stdc++ with binaries (because old OSes usually dont have  a sufficiently recent stdc++ shipped)\r\n- additionally because a bug in the libstdc++ shipped with RHEL6, we also statically link weak symbols (that includes destructors)\r\n- the consequence of statically linking destructors of libstdc++ is a bit iffy. For certain internal data structures like std::string, each instance of libstdc++ symbols (my understanding / speculation) do their own book-keeping for construction/destruction, i.e. each string is sort of interned in a sense, internal to the library.\r\n\r\nSo what actually is happening is\r\n- a std::string  was passed from the THNN extension side over to _C land\r\n- _C, after finishing using the string, calls the destructor on it\r\n- but because _C didn't actually allocate the string, it's internal table doesn't have a reference to the pointer, so it sees it as an invalid free\r\n\r\nIn the next binary release, I'll figure out a solution for this.\r\n\r\nThanks a lot for the issue and the repro."}