{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/311817870", "html_url": "https://github.com/pytorch/pytorch/issues/1927#issuecomment-311817870", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/1927", "id": 311817870, "node_id": "MDEyOklzc3VlQ29tbWVudDMxMTgxNzg3MA==", "user": {"login": "jekbradbury", "id": 11729078, "node_id": "MDQ6VXNlcjExNzI5MDc4", "avatar_url": "https://avatars2.githubusercontent.com/u/11729078?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jekbradbury", "html_url": "https://github.com/jekbradbury", "followers_url": "https://api.github.com/users/jekbradbury/followers", "following_url": "https://api.github.com/users/jekbradbury/following{/other_user}", "gists_url": "https://api.github.com/users/jekbradbury/gists{/gist_id}", "starred_url": "https://api.github.com/users/jekbradbury/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jekbradbury/subscriptions", "organizations_url": "https://api.github.com/users/jekbradbury/orgs", "repos_url": "https://api.github.com/users/jekbradbury/repos", "events_url": "https://api.github.com/users/jekbradbury/events{/privacy}", "received_events_url": "https://api.github.com/users/jekbradbury/received_events", "type": "User", "site_admin": false}, "created_at": "2017-06-28T23:14:38Z", "updated_at": "2017-06-28T23:14:38Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Here is a generic TimeDistributed mixin (the name for the same idea in Torch7 was <code>nn.Bottle</code>):</p>\n<pre><code>class Bottle(nn.Module):\n    def forward(self, input):\n        if len(input.size()) &lt;= 2:\n            return super(Bottle, self).forward(input)\n        size = input.size()[:2]\n        out = super(Bottle, self).forward(input.view(size[0]*size[1], -1))\n        return out.view(*size, -1)\n#example:\nclass Linear(Bottle, nn.Linear):\n    pass\n</code></pre>\n<p>That, or a wrapper like the one above, covers your case 2. For your case 1, we've felt so far that using a native Python <code>for</code> or <code>while</code> loop is the most straightforward and clear way to do this. That's how the decoder in OpenNMT-py is implemented, for instance. Basically, Theano and TensorFlow have to introduce a custom operator like <code>scan</code> or <code>while_loop</code> because they can't use native Python control flow -- but we can, and there's no reason not to.</p>", "body_text": "Here is a generic TimeDistributed mixin (the name for the same idea in Torch7 was nn.Bottle):\nclass Bottle(nn.Module):\n    def forward(self, input):\n        if len(input.size()) <= 2:\n            return super(Bottle, self).forward(input)\n        size = input.size()[:2]\n        out = super(Bottle, self).forward(input.view(size[0]*size[1], -1))\n        return out.view(*size, -1)\n#example:\nclass Linear(Bottle, nn.Linear):\n    pass\n\nThat, or a wrapper like the one above, covers your case 2. For your case 1, we've felt so far that using a native Python for or while loop is the most straightforward and clear way to do this. That's how the decoder in OpenNMT-py is implemented, for instance. Basically, Theano and TensorFlow have to introduce a custom operator like scan or while_loop because they can't use native Python control flow -- but we can, and there's no reason not to.", "body": "Here is a generic TimeDistributed mixin (the name for the same idea in Torch7 was `nn.Bottle`):\r\n```\r\nclass Bottle(nn.Module):\r\n    def forward(self, input):\r\n        if len(input.size()) <= 2:\r\n            return super(Bottle, self).forward(input)\r\n        size = input.size()[:2]\r\n        out = super(Bottle, self).forward(input.view(size[0]*size[1], -1))\r\n        return out.view(*size, -1)\r\n#example:\r\nclass Linear(Bottle, nn.Linear):\r\n    pass\r\n```\r\nThat, or a wrapper like the one above, covers your case 2. For your case 1, we've felt so far that using a native Python `for` or `while` loop is the most straightforward and clear way to do this. That's how the decoder in OpenNMT-py is implemented, for instance. Basically, Theano and TensorFlow have to introduce a custom operator like `scan` or `while_loop` because they can't use native Python control flow -- but we can, and there's no reason not to."}