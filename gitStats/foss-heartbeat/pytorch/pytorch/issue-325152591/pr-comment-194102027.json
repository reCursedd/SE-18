{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/194102027", "pull_request_review_id": 127217531, "id": 194102027, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NDEwMjAyNw==", "diff_hunk": "@@ -453,14 +453,31 @@ def persistent_load(saved_id):\n             raise RuntimeError(\"Unknown saved id type: %s\" % saved_id[0])\n \n     f_is_real_file = _is_real_file(f)\n-    if f_is_real_file and f.tell() == 0:\n+\n+    def raise_load_err_msg(pattern, e):\n+        if pattern in str(e):\n+            msg = (str(e) + \". You can only torch.load from a file that is seekable.\" +\n+                            \" Please pre-load the data into a buffer like io.BytesIO and try to load from it instead.\")\n+            raise type(e)(msg)\n+        else:\n+            raise e\n+\n+    try:\n+        f_tell_is_0 = True if f.tell() == 0 else False\n+    except AttributeError as e:\n+        raise_load_err_msg(\"instance has no attribute 'tell'\", e)\n+", "path": "torch/serialization.py", "position": null, "original_position": 18, "commit_id": "8bfa74dd6e54176745fa849b9fee65bd652ed034", "original_commit_id": "23b66d0d54db65ad4c5327844ed7d8512ebb7253", "user": {"login": "zou3519", "id": 5652049, "node_id": "MDQ6VXNlcjU2NTIwNDk=", "avatar_url": "https://avatars3.githubusercontent.com/u/5652049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zou3519", "html_url": "https://github.com/zou3519", "followers_url": "https://api.github.com/users/zou3519/followers", "following_url": "https://api.github.com/users/zou3519/following{/other_user}", "gists_url": "https://api.github.com/users/zou3519/gists{/gist_id}", "starred_url": "https://api.github.com/users/zou3519/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zou3519/subscriptions", "organizations_url": "https://api.github.com/users/zou3519/orgs", "repos_url": "https://api.github.com/users/zou3519/repos", "events_url": "https://api.github.com/users/zou3519/events{/privacy}", "received_events_url": "https://api.github.com/users/zou3519/received_events", "type": "User", "site_admin": false}, "body": "Instead of wrapping the following `f.seek(0)` call in a try/except, I think it might be better to do something like\r\n```\r\ntry:\r\n    f.seek(f.tell())  # should be a no-op, but tells us if seek is implemented\r\nexcept:...\r\n```\r\nright after you figure out if `f.tell()` is supported or not.\r\n\r\nThis is because seek is called elsewhere in the load logic, and we might not always enter this particular pathway (the legacy_load failing path where `f.seek(0)` is called). In particular, the following two approaches could work:\r\n1) do a try/catch at every `f.seek` site.\r\n2) do a try/catch at the beginning of the load logic so we're certain that `f.seek` is supported. [what I'm suggesting here]", "created_at": "2018-06-08T15:50:41Z", "updated_at": "2018-11-23T15:45:15Z", "html_url": "https://github.com/pytorch/pytorch/pull/7754#discussion_r194102027", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/7754", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/194102027"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/7754#discussion_r194102027"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/7754"}}, "body_html": "<p>Instead of wrapping the following <code>f.seek(0)</code> call in a try/except, I think it might be better to do something like</p>\n<pre><code>try:\n    f.seek(f.tell())  # should be a no-op, but tells us if seek is implemented\nexcept:...\n</code></pre>\n<p>right after you figure out if <code>f.tell()</code> is supported or not.</p>\n<p>This is because seek is called elsewhere in the load logic, and we might not always enter this particular pathway (the legacy_load failing path where <code>f.seek(0)</code> is called). In particular, the following two approaches could work:</p>\n<ol>\n<li>do a try/catch at every <code>f.seek</code> site.</li>\n<li>do a try/catch at the beginning of the load logic so we're certain that <code>f.seek</code> is supported. [what I'm suggesting here]</li>\n</ol>", "body_text": "Instead of wrapping the following f.seek(0) call in a try/except, I think it might be better to do something like\ntry:\n    f.seek(f.tell())  # should be a no-op, but tells us if seek is implemented\nexcept:...\n\nright after you figure out if f.tell() is supported or not.\nThis is because seek is called elsewhere in the load logic, and we might not always enter this particular pathway (the legacy_load failing path where f.seek(0) is called). In particular, the following two approaches could work:\n\ndo a try/catch at every f.seek site.\ndo a try/catch at the beginning of the load logic so we're certain that f.seek is supported. [what I'm suggesting here]"}