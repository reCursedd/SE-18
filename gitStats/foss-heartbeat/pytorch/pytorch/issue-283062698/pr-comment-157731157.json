{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/157731157", "pull_request_review_id": 84420813, "id": 157731157, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1NzczMTE1Nw==", "diff_hunk": "@@ -289,12 +289,17 @@ struct CodeImpl {\n     // this is done with a backward scan where we mark the first time we see it\n     std::unordered_set<int> seen_registers;\n     auto scanUses = [&](UseList & u) {\n-      listBegin(u.free_flags);\n-      for(int i = 0; i < u.values.size; i++) {\n+      // scan backwards because the same value may appear > once in a use list", "path": "torch/csrc/jit/interpreter.cpp", "position": 6, "original_position": 6, "commit_id": "7ef855e4b9902e3ee5f5f3c4d7f5fae3631074ad", "original_commit_id": "a79eee918b306464ab12249df267c367aef54ec3", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "body": "I don't fully understand this fix. This function scans an input list to every instruction in reverse, so it doesn't really matter which input marks the value to be freed later, right? Or do we empty the registers when we load inputs and that's what's causing the failure (next inputs get undefined tensors)? A bit more detailed comment would be helpful", "created_at": "2017-12-19T11:39:46Z", "updated_at": "2018-11-23T15:37:31Z", "html_url": "https://github.com/pytorch/pytorch/pull/4244#discussion_r157731157", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/4244", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/157731157"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/4244#discussion_r157731157"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/4244"}}, "body_html": "<p>I don't fully understand this fix. This function scans an input list to every instruction in reverse, so it doesn't really matter which input marks the value to be freed later, right? Or do we empty the registers when we load inputs and that's what's causing the failure (next inputs get undefined tensors)? A bit more detailed comment would be helpful</p>", "body_text": "I don't fully understand this fix. This function scans an input list to every instruction in reverse, so it doesn't really matter which input marks the value to be freed later, right? Or do we empty the registers when we load inputs and that's what's causing the failure (next inputs get undefined tensors)? A bit more detailed comment would be helpful", "in_reply_to_id": 157654252}