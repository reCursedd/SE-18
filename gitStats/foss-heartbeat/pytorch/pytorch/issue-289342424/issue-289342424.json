{"url": "https://api.github.com/repos/pytorch/pytorch/issues/4709", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/4709/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/4709/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/4709/events", "html_url": "https://github.com/pytorch/pytorch/issues/4709", "id": 289342424, "node_id": "MDU6SXNzdWUyODkzNDI0MjQ=", "number": 4709, "title": "Adding flexibility to Trainer", "user": {"login": "keon", "id": 10793962, "node_id": "MDQ6VXNlcjEwNzkzOTYy", "avatar_url": "https://avatars0.githubusercontent.com/u/10793962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/keon", "html_url": "https://github.com/keon", "followers_url": "https://api.github.com/users/keon/followers", "following_url": "https://api.github.com/users/keon/following{/other_user}", "gists_url": "https://api.github.com/users/keon/gists{/gist_id}", "starred_url": "https://api.github.com/users/keon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/keon/subscriptions", "organizations_url": "https://api.github.com/users/keon/orgs", "repos_url": "https://api.github.com/users/keon/repos", "events_url": "https://api.github.com/users/keon/events{/privacy}", "received_events_url": "https://api.github.com/users/keon/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2018-01-17T17:06:31Z", "updated_at": "2018-01-17T17:14:40Z", "closed_at": "2018-01-17T17:14:40Z", "author_association": "NONE", "body_html": "<p>Current implementation of <a href=\"https://github.com/pytorch/pytorch/blob/master/torch/utils/trainer/trainer.py\"><code>Trainer</code></a> does not allow for custom implementation of <code>closure</code> function which is passed to the optimizer.</p>\n<p>Custom implementation of closure would be great since it could change according to the model.</p>\n<p>What do you think about allowing a parameter (something like <code>get_closure</code>) that returns a closure?</p>\n<p>the implementation will be like:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">class</span> <span class=\"pl-en\">Trainer</span>(<span class=\"pl-c1\">object</span>):\n  <span class=\"pl-k\">def</span> <span class=\"pl-c1\">__init__</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>):\n    <span class=\"pl-c1\">self</span>.val <span class=\"pl-k\">=</span> <span class=\"pl-c1\">5</span>\n\n  <span class=\"pl-k\">def</span> <span class=\"pl-en\">train</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>, <span class=\"pl-smi\">get_closure</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">None</span>):\n    closure <span class=\"pl-k\">=</span> get_closure(<span class=\"pl-c1\">self</span>)\n    optimizer(closure)\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">optimizer</span>(<span class=\"pl-smi\">closure</span>):\n  <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>executing optimizer!<span class=\"pl-pds\">\"</span></span>)\n  closure()\n\n<span class=\"pl-k\">def</span> <span class=\"pl-en\">get_custom_closure</span>(<span class=\"pl-smi\">trainer</span>):\n  <span class=\"pl-k\">def</span> <span class=\"pl-en\">custom_closure</span>():\n    <span class=\"pl-c1\">print</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>executing custom closure<span class=\"pl-pds\">\"</span></span>, trainer.val)\n  <span class=\"pl-k\">return</span> custom_closure\n\na <span class=\"pl-k\">=</span> Trainer()\na.train(get_custom_closure)</pre></div>\n<pre><code>executing optimizer!\nexecuting custom closure 5\n</code></pre>\n<p>Please let me know if you guys have any better ideas.</p>", "body_text": "Current implementation of Trainer does not allow for custom implementation of closure function which is passed to the optimizer.\nCustom implementation of closure would be great since it could change according to the model.\nWhat do you think about allowing a parameter (something like get_closure) that returns a closure?\nthe implementation will be like:\nclass Trainer(object):\n  def __init__(self):\n    self.val = 5\n\n  def train(self, get_closure=None):\n    closure = get_closure(self)\n    optimizer(closure)\n\ndef optimizer(closure):\n  print(\"executing optimizer!\")\n  closure()\n\ndef get_custom_closure(trainer):\n  def custom_closure():\n    print(\"executing custom closure\", trainer.val)\n  return custom_closure\n\na = Trainer()\na.train(get_custom_closure)\nexecuting optimizer!\nexecuting custom closure 5\n\nPlease let me know if you guys have any better ideas.", "body": "Current implementation of [`Trainer`](https://github.com/pytorch/pytorch/blob/master/torch/utils/trainer/trainer.py) does not allow for custom implementation of `closure` function which is passed to the optimizer.\r\n\r\nCustom implementation of closure would be great since it could change according to the model.\r\n\r\nWhat do you think about allowing a parameter (something like `get_closure`) that returns a closure?\r\n\r\nthe implementation will be like:\r\n\r\n```python\r\nclass Trainer(object):\r\n  def __init__(self):\r\n    self.val = 5\r\n\r\n  def train(self, get_closure=None):\r\n    closure = get_closure(self)\r\n    optimizer(closure)\r\n\r\ndef optimizer(closure):\r\n  print(\"executing optimizer!\")\r\n  closure()\r\n\r\ndef get_custom_closure(trainer):\r\n  def custom_closure():\r\n    print(\"executing custom closure\", trainer.val)\r\n  return custom_closure\r\n\r\na = Trainer()\r\na.train(get_custom_closure)\r\n```\r\n\r\n```\r\nexecuting optimizer!\r\nexecuting custom closure 5\r\n```\r\n\r\nPlease let me know if you guys have any better ideas."}