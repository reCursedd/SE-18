{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/410538553", "html_url": "https://github.com/pytorch/pytorch/issues/9332#issuecomment-410538553", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/9332", "id": 410538553, "node_id": "MDEyOklzc3VlQ29tbWVudDQxMDUzODU1Mw==", "user": {"login": "Balandat", "id": 1605878, "node_id": "MDQ6VXNlcjE2MDU4Nzg=", "avatar_url": "https://avatars2.githubusercontent.com/u/1605878?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Balandat", "html_url": "https://github.com/Balandat", "followers_url": "https://api.github.com/users/Balandat/followers", "following_url": "https://api.github.com/users/Balandat/following{/other_user}", "gists_url": "https://api.github.com/users/Balandat/gists{/gist_id}", "starred_url": "https://api.github.com/users/Balandat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Balandat/subscriptions", "organizations_url": "https://api.github.com/users/Balandat/orgs", "repos_url": "https://api.github.com/users/Balandat/repos", "events_url": "https://api.github.com/users/Balandat/events{/privacy}", "received_events_url": "https://api.github.com/users/Balandat/received_events", "type": "User", "site_admin": false}, "created_at": "2018-08-05T18:27:05Z", "updated_at": "2018-08-05T18:27:05Z", "author_association": "NONE", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=23639302\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/vishwakftw\">@vishwakftw</a>, no sure I completely follow (I'm not familiar with the <code>at::Generator</code> objects).</p>\n<ol>\n<li>\n<p>Do you suggest doing al the looping etc. that's done in the C-code in python? That would be inadmissibly slow (that's why this was moved to cython). In general, performance in generating these Sobol samples is critical, since it would be used to do things like quasi-Monte-Carlo integration, for which more samples are better (we're talking millions of samples here).</p>\n</li>\n<li>\n<p>What's the requirement of the <code>at::Generator</code> object for seeding? Do you think it would be a challenge to keep track of the position in the sequence of samples? This relates to my comment above:</p>\n</li>\n</ol>\n<blockquote>\n<p>Calling draw on an instance of <code>SobolEngine</code> will generate points of a space-filling sequence. The important thing to note is that in order to continue filling the <code>[0, 1]^dimen</code> space \"in between\" the already drawn points, draws need to continue in sequence (i.e. the num_generated variable should not be reset).</p>\n</blockquote>", "body_text": "@vishwakftw, no sure I completely follow (I'm not familiar with the at::Generator objects).\n\n\nDo you suggest doing al the looping etc. that's done in the C-code in python? That would be inadmissibly slow (that's why this was moved to cython). In general, performance in generating these Sobol samples is critical, since it would be used to do things like quasi-Monte-Carlo integration, for which more samples are better (we're talking millions of samples here).\n\n\nWhat's the requirement of the at::Generator object for seeding? Do you think it would be a challenge to keep track of the position in the sequence of samples? This relates to my comment above:\n\n\n\nCalling draw on an instance of SobolEngine will generate points of a space-filling sequence. The important thing to note is that in order to continue filling the [0, 1]^dimen space \"in between\" the already drawn points, draws need to continue in sequence (i.e. the num_generated variable should not be reset).", "body": "@vishwakftw, no sure I completely follow (I'm not familiar with the `at::Generator` objects).\r\n\r\n1. Do you suggest doing al the looping etc. that's done in the C-code in python? That would be inadmissibly slow (that's why this was moved to cython). In general, performance in generating these Sobol samples is critical, since it would be used to do things like quasi-Monte-Carlo integration, for which more samples are better (we're talking millions of samples here).\r\n\r\n2. What's the requirement of the `at::Generator` object for seeding? Do you think it would be a challenge to keep track of the position in the sequence of samples? This relates to my comment above:\r\n> Calling draw on an instance of `SobolEngine` will generate points of a space-filling sequence. The important thing to note is that in order to continue filling the `[0, 1]^dimen` space \"in between\" the already drawn points, draws need to continue in sequence (i.e. the num_generated variable should not be reset).\r\n\r\n\r\n "}