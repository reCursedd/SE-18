{"url": "https://api.github.com/repos/pytorch/pytorch/issues/6684", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/6684/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/6684/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/6684/events", "html_url": "https://github.com/pytorch/pytorch/pull/6684", "id": 315281224, "node_id": "MDExOlB1bGxSZXF1ZXN0MTgyMzM0MDg0", "number": 6684, "title": "Create FileBaton to synchronize distributed JIT C++ extension builds", "user": {"login": "goldsborough", "id": 6429851, "node_id": "MDQ6VXNlcjY0Mjk4NTE=", "avatar_url": "https://avatars3.githubusercontent.com/u/6429851?v=4", "gravatar_id": "", "url": "https://api.github.com/users/goldsborough", "html_url": "https://github.com/goldsborough", "followers_url": "https://api.github.com/users/goldsborough/followers", "following_url": "https://api.github.com/users/goldsborough/following{/other_user}", "gists_url": "https://api.github.com/users/goldsborough/gists{/gist_id}", "starred_url": "https://api.github.com/users/goldsborough/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/goldsborough/subscriptions", "organizations_url": "https://api.github.com/users/goldsborough/orgs", "repos_url": "https://api.github.com/users/goldsborough/repos", "events_url": "https://api.github.com/users/goldsborough/events{/privacy}", "received_events_url": "https://api.github.com/users/goldsborough/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}], "milestone": null, "comments": 3, "created_at": "2018-04-17T23:53:28Z", "updated_at": "2018-11-23T15:42:47Z", "closed_at": "2018-04-18T22:07:04Z", "author_association": "CONTRIBUTOR", "pull_request": {"url": "https://api.github.com/repos/pytorch/pytorch/pulls/6684", "html_url": "https://github.com/pytorch/pytorch/pull/6684", "diff_url": "https://github.com/pytorch/pytorch/pull/6684.diff", "patch_url": "https://github.com/pytorch/pytorch/pull/6684.patch"}, "body_html": "<p>As reported by <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=9110200\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/fmassa\">@fmassa</a> in <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"312053714\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/6353\" data-hovercard-type=\"issue\" data-hovercard-url=\"/pytorch/pytorch/issues/6353/hovercard\" href=\"https://github.com/pytorch/pytorch/issues/6353\">#6353</a> , when using JIT C++ extensions together with <code>torch.distributed.launch</code>, each process separately compiles the extension, and then crashes occasionally as the processes race with each other.</p>\n<p>This PR creates a <code>FileBaton</code> datastructure, which allows two things:</p>\n<ol>\n<li>atomically creating a file,</li>\n<li>waiting until the file is deleted (spinning with sleeps)</li>\n</ol>\n<p>This serves as a sufficient \"rendezvous\"/single-shot synchronization mechanism. As far as I can google, the file creation mechanism I use <code>O_CREAT | O_EXCL</code> is only atomic on Unix, so while this code will work fine on Windows, it may not behave in an entirely race-free way. I did not see a straightforward way provided by Python to do this on Windows (cc <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=9998726\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/peterjc123\">@peterjc123</a> )</p>\n<p><span class=\"issue-keyword tooltipped tooltipped-se\" aria-label=\"This pull request closes issue #6353.\">Fixes</span> <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"312053714\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/6353\" data-hovercard-type=\"issue\" data-hovercard-url=\"/pytorch/pytorch/issues/6353/hovercard\" href=\"https://github.com/pytorch/pytorch/issues/6353\">#6353</a></p>\n<h2>Test plan</h2>\n<ol>\n<li>See <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"312053714\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/6353\" data-hovercard-type=\"issue\" data-hovercard-url=\"/pytorch/pytorch/issues/6353/hovercard\" href=\"https://github.com/pytorch/pytorch/issues/6353\">#6353</a> for a MWE, also pass <code>verbose=True</code> to <code>load_ext()</code></li>\n<li>Run with <code>python -m torch.distributed.launch --nproc_per_node=4 mwe.py</code> and old code,</li>\n<li>Observe multiple, concurrent compilation. Not necessarily a crash, but possibly,</li>\n<li>Run with new code,</li>\n<li>Observe that only one process compiles the code.</li>\n</ol>", "body_text": "As reported by @fmassa in #6353 , when using JIT C++ extensions together with torch.distributed.launch, each process separately compiles the extension, and then crashes occasionally as the processes race with each other.\nThis PR creates a FileBaton datastructure, which allows two things:\n\natomically creating a file,\nwaiting until the file is deleted (spinning with sleeps)\n\nThis serves as a sufficient \"rendezvous\"/single-shot synchronization mechanism. As far as I can google, the file creation mechanism I use O_CREAT | O_EXCL is only atomic on Unix, so while this code will work fine on Windows, it may not behave in an entirely race-free way. I did not see a straightforward way provided by Python to do this on Windows (cc @peterjc123 )\nFixes #6353\nTest plan\n\nSee #6353 for a MWE, also pass verbose=True to load_ext()\nRun with python -m torch.distributed.launch --nproc_per_node=4 mwe.py and old code,\nObserve multiple, concurrent compilation. Not necessarily a crash, but possibly,\nRun with new code,\nObserve that only one process compiles the code.", "body": "As reported by @fmassa in #6353 , when using JIT C++ extensions together with `torch.distributed.launch`, each process separately compiles the extension, and then crashes occasionally as the processes race with each other.\r\n\r\nThis PR creates a `FileBaton` datastructure, which allows two things:\r\n1) atomically creating a file,\r\n2) waiting until the file is deleted (spinning with sleeps)\r\n\r\nThis serves as a sufficient \"rendezvous\"/single-shot synchronization mechanism. As far as I can google, the file creation mechanism I use `O_CREAT | O_EXCL` is only atomic on Unix, so while this code will work fine on Windows, it may not behave in an entirely race-free way. I did not see a straightforward way provided by Python to do this on Windows (cc @peterjc123 )\r\n\r\nFixes #6353 \r\n\r\n## Test plan\r\n\r\n1. See #6353 for a MWE, also pass `verbose=True` to `load_ext()`\r\n2. Run with `python -m torch.distributed.launch --nproc_per_node=4 mwe.py` and old code,\r\n3. Observe multiple, concurrent compilation. Not necessarily a crash, but possibly,\r\n4. Run with new code,\r\n5. Observe that only one process compiles the code."}