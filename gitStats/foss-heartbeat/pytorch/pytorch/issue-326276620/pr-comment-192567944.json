{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/192567944", "pull_request_review_id": 125374196, "id": 192567944, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5MjU2Nzk0NA==", "diff_hunk": "@@ -45,15 +44,13 @@ std::shared_ptr<Module> Module::clone() const {\n \n std::map<std::string, Variable> Module::parameters() const {\n   std::map<std::string, Variable> ret;\n-  for (const auto& pair : children_) {\n-    auto& name = pair.first;\n-    auto& child = pair.second;\n-    for (auto& p : child->parameters()) {\n-      ret[name + \".\" + p.first] = p.second;\n+  for (const auto& child : children_) {\n+    for (auto& p : (*child)->parameters()) {\n+      ret[child.key + \".\" + p.first] = p.second;\n     }\n   }\n-  for (const auto& pair : parameters_) {\n-    ret[pair.first] = pair.second;\n+  for (const auto& parameter : parameters_) {\n+    ret[parameter.key] = parameter.value;\n   }\n   return ret;\n }", "path": "torch/csrc/api/src/nn/module.cpp", "position": 28, "original_position": 28, "commit_id": "12261b0f29c997486ecd1dbc39c35b0559c404b4", "original_commit_id": "cfc0c3faab58058aee6aafb9abd432c2c1974a5f", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "body": "Since we're starting to use `OrderedMap`, it would be good to make this function conform to the Python interface. Currently, it will sort the returned value according the the ordering on `std::string` names, which is not the same as what we do in Python. Also, `parameters()` in Python only returns an iterable over tensors, without their names. I'd suggest flattening them into a vector, and using `named_parameters()` otherwise (which will also need to return an OrderedDict).", "created_at": "2018-06-02T19:20:40Z", "updated_at": "2018-11-23T15:44:53Z", "html_url": "https://github.com/pytorch/pytorch/pull/7823#discussion_r192567944", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/7823", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/192567944"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/7823#discussion_r192567944"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/7823"}}, "body_html": "<p>Since we're starting to use <code>OrderedMap</code>, it would be good to make this function conform to the Python interface. Currently, it will sort the returned value according the the ordering on <code>std::string</code> names, which is not the same as what we do in Python. Also, <code>parameters()</code> in Python only returns an iterable over tensors, without their names. I'd suggest flattening them into a vector, and using <code>named_parameters()</code> otherwise (which will also need to return an OrderedDict).</p>", "body_text": "Since we're starting to use OrderedMap, it would be good to make this function conform to the Python interface. Currently, it will sort the returned value according the the ordering on std::string names, which is not the same as what we do in Python. Also, parameters() in Python only returns an iterable over tensors, without their names. I'd suggest flattening them into a vector, and using named_parameters() otherwise (which will also need to return an OrderedDict)."}