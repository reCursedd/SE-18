{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/412261599", "html_url": "https://github.com/pytorch/pytorch/issues/10402#issuecomment-412261599", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/10402", "id": 412261599, "node_id": "MDEyOklzc3VlQ29tbWVudDQxMjI2MTU5OQ==", "user": {"login": "lantiga", "id": 191033, "node_id": "MDQ6VXNlcjE5MTAzMw==", "avatar_url": "https://avatars2.githubusercontent.com/u/191033?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lantiga", "html_url": "https://github.com/lantiga", "followers_url": "https://api.github.com/users/lantiga/followers", "following_url": "https://api.github.com/users/lantiga/following{/other_user}", "gists_url": "https://api.github.com/users/lantiga/gists{/gist_id}", "starred_url": "https://api.github.com/users/lantiga/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lantiga/subscriptions", "organizations_url": "https://api.github.com/users/lantiga/orgs", "repos_url": "https://api.github.com/users/lantiga/repos", "events_url": "https://api.github.com/users/lantiga/events{/privacy}", "received_events_url": "https://api.github.com/users/lantiga/received_events", "type": "User", "site_admin": false}, "created_at": "2018-08-11T08:51:49Z", "updated_at": "2018-08-11T12:10:36Z", "author_association": "COLLABORATOR", "body_html": "<p><del>An alternate way would be to build an index tensor for just the elements that will be printed (typically not a lot) and then just use advanced indexing. This should avoid calls to \u2018contiguous\u2019 and extra allocations would be proportional to what\u2019s actually being printed.</del></p>\n<p>Upon closer inspection,</p>\n<div class=\"highlight highlight-source-python\"><pre>[get_summarized_data(<span class=\"pl-c1\">self</span>[i]).reshape(<span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>) <span class=\"pl-k\">for</span> i <span class=\"pl-k\">in</span> <span class=\"pl-c1\">...</span> ]</pre></div>\n<p>is the way to go. It will only reshape the intermediate tensors recursively returned by <code>get_summarized_data</code>, which at most have the same number of elements as the printed values.</p>", "body_text": "An alternate way would be to build an index tensor for just the elements that will be printed (typically not a lot) and then just use advanced indexing. This should avoid calls to \u2018contiguous\u2019 and extra allocations would be proportional to what\u2019s actually being printed.\nUpon closer inspection,\n[get_summarized_data(self[i]).reshape(-1) for i in ... ]\nis the way to go. It will only reshape the intermediate tensors recursively returned by get_summarized_data, which at most have the same number of elements as the printed values.", "body": "~~An alternate way would be to build an index tensor for just the elements that will be printed (typically not a lot) and then just use advanced indexing. This should avoid calls to \u2018contiguous\u2019 and extra allocations would be proportional to what\u2019s actually being printed.~~\r\n\r\nUpon closer inspection, \r\n```python\r\n[get_summarized_data(self[i]).reshape(-1) for i in ... ]\r\n```\r\nis the way to go. It will only reshape the intermediate tensors recursively returned by `get_summarized_data`, which at most have the same number of elements as the printed values."}