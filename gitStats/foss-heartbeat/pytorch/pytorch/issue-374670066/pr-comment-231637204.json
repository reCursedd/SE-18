{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/231637204", "pull_request_review_id": 172641023, "id": 231637204, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMTYzNzIwNA==", "diff_hunk": "@@ -533,19 +533,48 @@ RegisterOperators reg({\n         prim::fork,\n         [](const Node* node) {\n           Code code(node->g(attr::Subgraph));\n+          int n_inputs = node->inputs().size();\n           JIT_ASSERT(node->blocks().size() == 0);\n           JIT_ASSERT(node->hasAttribute(attr::Subgraph));\n           return [=](Stack& stack) {\n-            InterpreterState(code).run(stack);\n-            push(stack, Future(pop(stack)));\n+            // Move inputs to a separate stack\n+            auto copied_stack = new Stack(\n+                stack.end() - n_inputs,\n+                stack.end());\n+            drop(stack, n_inputs);\n+\n+            auto copied_state = new InterpreterState(code);\n+\n+            push(stack, copied_state->getFuture());\n+\n+            // TODO: who/how to hold the lifecycle for copied_stack/copied_state?\n+            // We currently add them to callback so they will be destroyed when future completes.\n+            // Suppose we have two threads: T1 forks T2 and waits on T2;", "path": "torch/csrc/jit/register_prim_ops.cpp", "position": null, "original_position": 22, "commit_id": "928476a76fc9249e71a8a523919ab91bc49e5b2e", "original_commit_id": "eba61b41862c42d186e6bf317d356c00ef197abd", "user": {"login": "zdevito", "id": 370202, "node_id": "MDQ6VXNlcjM3MDIwMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/370202?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zdevito", "html_url": "https://github.com/zdevito", "followers_url": "https://api.github.com/users/zdevito/followers", "following_url": "https://api.github.com/users/zdevito/following{/other_user}", "gists_url": "https://api.github.com/users/zdevito/gists{/gist_id}", "starred_url": "https://api.github.com/users/zdevito/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zdevito/subscriptions", "organizations_url": "https://api.github.com/users/zdevito/orgs", "repos_url": "https://api.github.com/users/zdevito/repos", "events_url": "https://api.github.com/users/zdevito/events{/privacy}", "received_events_url": "https://api.github.com/users/zdevito/received_events", "type": "User", "site_admin": false}, "body": "You can move the stack by using a class rather than a lambda. A class with an operator() is still a valid std::function<void(void)>.\r\n```\r\nclass InterpreterContinuation {\r\n   InterpreterContinuation(InterpreterState state, Stack initial_stack)\r\n  : state(std::move(state)), stack(std::move(initial_stack)) {}\r\n  void operator()(void) {\r\n     state.run(stack);\r\n  }\r\nprivate:\r\n  Stack stack;\r\n  InterpreterState state;\r\n};\r\n```\r\n\r\nAfter the interpreter returns, whether it finished or not, the stack is no longer used. So once this Closure finishes it no longer needs Stack and it will get destroyed. If the Interpreter did not finish, then it must have created a callback on another future that would schedule the rest of the interpreter to run. That callback will capture a reference to InterpreterState, increasing its refcount. InterpreterState will destruct when there are no longer any callbacks referring to it.", "created_at": "2018-11-07T19:05:21Z", "updated_at": "2018-11-23T15:54:28Z", "html_url": "https://github.com/pytorch/pytorch/pull/13212#discussion_r231637204", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/13212", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/231637204"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/13212#discussion_r231637204"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/13212"}}, "body_html": "<p>You can move the stack by using a class rather than a lambda. A class with an operator() is still a valid std::function&lt;void(void)&gt;.</p>\n<pre><code>class InterpreterContinuation {\n   InterpreterContinuation(InterpreterState state, Stack initial_stack)\n  : state(std::move(state)), stack(std::move(initial_stack)) {}\n  void operator()(void) {\n     state.run(stack);\n  }\nprivate:\n  Stack stack;\n  InterpreterState state;\n};\n</code></pre>\n<p>After the interpreter returns, whether it finished or not, the stack is no longer used. So once this Closure finishes it no longer needs Stack and it will get destroyed. If the Interpreter did not finish, then it must have created a callback on another future that would schedule the rest of the interpreter to run. That callback will capture a reference to InterpreterState, increasing its refcount. InterpreterState will destruct when there are no longer any callbacks referring to it.</p>", "body_text": "You can move the stack by using a class rather than a lambda. A class with an operator() is still a valid std::function<void(void)>.\nclass InterpreterContinuation {\n   InterpreterContinuation(InterpreterState state, Stack initial_stack)\n  : state(std::move(state)), stack(std::move(initial_stack)) {}\n  void operator()(void) {\n     state.run(stack);\n  }\nprivate:\n  Stack stack;\n  InterpreterState state;\n};\n\nAfter the interpreter returns, whether it finished or not, the stack is no longer used. So once this Closure finishes it no longer needs Stack and it will get destroyed. If the Interpreter did not finish, then it must have created a callback on another future that would schedule the rest of the interpreter to run. That callback will capture a reference to InterpreterState, increasing its refcount. InterpreterState will destruct when there are no longer any callbacks referring to it."}