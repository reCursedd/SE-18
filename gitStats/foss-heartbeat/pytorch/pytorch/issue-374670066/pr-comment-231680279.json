{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/231680279", "pull_request_review_id": 172696539, "id": 231680279, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMTY4MDI3OQ==", "diff_hunk": "@@ -645,25 +645,47 @@ struct InterpreterStateImpl {\n     bool_data(function->bool_data),\n     registers(function->register_size) {\n   }\n-  void run(Stack & stack) {\n+\n+  void run(Stack& stack) {\n     // std::cout << *function->graph << \"\\n\";\n     // function->dump(std::cout);\n     size_t pc = current_pc;\n     auto & instructions = function->instructions;\n     size_t last = instructions.size();\n-    while(pc < last) {\n+\n+    // Check if we are recovered from a suspend\n+    if (current_inst) {\n+      registerOutputs(*current_inst, stack);\n+      current_inst = nullptr;\n+    }\n+\n+    while (pc < last) {\n         // std::cout << \"executing \" << pc << \": \";\n         // function->dumpInstruction(std::cout, pc);\n         // std::cout << \"\\n\";\n         try {\n           auto & inst = instructions[pc];\n           loadTensorsFromRegisters(inst.inputs, stack);\n-          size_t new_pc = pc + 1 + inst.callback(stack);\n-          for(int i = inst.outputs.size - 1; i >= 0; i--) {\n-            int reg = get(inst.outputs,i);\n-            registers[reg] = pop(stack);\n-            // std::cout << \"pop reg[\" << reg << \"];\\n\" << registers[reg] << \"\\n\";\n+          size_t new_pc = pc + 1;\n+          try {\n+            new_pc += inst.callback(stack);\n+          } catch (Suspend& e) {\n+            JIT_ASSERT(!e.future->completed());\n+            e.future->addCallback([&](){\n+              c10::global_work_queue.schedule([&]() {\n+                this->run(stack);\n+              });\n+            });\n+            current_inst = &inst;\n+            current_pc = new_pc;\n+            // Finish what we are waiting on.\n+            // This will schedule the current thread itself back into the queue.\n+            // TODO: we should throw this back to the executor.\n+            e.future->wait();\n+            push(stack, e.future->value());\n+            return;\n           }\n+          registerOutputs(inst, stack);", "path": "torch/csrc/jit/interpreter.cpp", "position": null, "original_position": 51, "commit_id": "928476a76fc9249e71a8a523919ab91bc49e5b2e", "original_commit_id": "eba61b41862c42d186e6bf317d356c00ef197abd", "user": {"login": "zdevito", "id": 370202, "node_id": "MDQ6VXNlcjM3MDIwMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/370202?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zdevito", "html_url": "https://github.com/zdevito", "followers_url": "https://api.github.com/users/zdevito/followers", "following_url": "https://api.github.com/users/zdevito/following{/other_user}", "gists_url": "https://api.github.com/users/zdevito/gists{/gist_id}", "starred_url": "https://api.github.com/users/zdevito/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zdevito/subscriptions", "organizations_url": "https://api.github.com/users/zdevito/orgs", "repos_url": "https://api.github.com/users/zdevito/repos", "events_url": "https://api.github.com/users/zdevito/events{/privacy}", "received_events_url": "https://api.github.com/users/zdevito/received_events", "type": "User", "site_admin": false}, "body": "You can avoid the custom logic on startup by simply re-running the suspending instruction on startup (i.e. leaving the PC unchanged).  The rule should be: on a suspend, wait pops its arguments off the stack, but pushes nothing before suspending. That way when the suspend is thrown, the stack is restored to what it was before the wait ran. Re-running the wait will then continue execution.\r\n```\r\ntry {\r\n          auto & inst = instructions[pc];\r\n          loadTensorsFromRegisters(inst.inputs, stack);\t      \r\n          size_t new_pc = pc + 1 + inst.callback(stack)\r\n          for(int i = inst.outputs.size - 1; i >= 0; i--) {\r\n              int reg = get(inst.outputs,i);\t           \r\n              registers[reg] = pop(stack)\r\n          }\r\n        \r\n} catch(Suspend& e) {\r\n    // same as before, pc was never updated, so restarting the interpreter will rerun the wait instruction, which will load the completed value onto the stack.\r\n}\r\n```\r\nThere should be no need for special logic about current_inst.", "created_at": "2018-11-07T21:18:34Z", "updated_at": "2018-11-23T15:54:28Z", "html_url": "https://github.com/pytorch/pytorch/pull/13212#discussion_r231680279", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/13212", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/231680279"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/13212#discussion_r231680279"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/13212"}}, "body_html": "<p>You can avoid the custom logic on startup by simply re-running the suspending instruction on startup (i.e. leaving the PC unchanged).  The rule should be: on a suspend, wait pops its arguments off the stack, but pushes nothing before suspending. That way when the suspend is thrown, the stack is restored to what it was before the wait ran. Re-running the wait will then continue execution.</p>\n<pre><code>try {\n          auto &amp; inst = instructions[pc];\n          loadTensorsFromRegisters(inst.inputs, stack);\t      \n          size_t new_pc = pc + 1 + inst.callback(stack)\n          for(int i = inst.outputs.size - 1; i &gt;= 0; i--) {\n              int reg = get(inst.outputs,i);\t           \n              registers[reg] = pop(stack)\n          }\n        \n} catch(Suspend&amp; e) {\n    // same as before, pc was never updated, so restarting the interpreter will rerun the wait instruction, which will load the completed value onto the stack.\n}\n</code></pre>\n<p>There should be no need for special logic about current_inst.</p>", "body_text": "You can avoid the custom logic on startup by simply re-running the suspending instruction on startup (i.e. leaving the PC unchanged).  The rule should be: on a suspend, wait pops its arguments off the stack, but pushes nothing before suspending. That way when the suspend is thrown, the stack is restored to what it was before the wait ran. Re-running the wait will then continue execution.\ntry {\n          auto & inst = instructions[pc];\n          loadTensorsFromRegisters(inst.inputs, stack);\t      \n          size_t new_pc = pc + 1 + inst.callback(stack)\n          for(int i = inst.outputs.size - 1; i >= 0; i--) {\n              int reg = get(inst.outputs,i);\t           \n              registers[reg] = pop(stack)\n          }\n        \n} catch(Suspend& e) {\n    // same as before, pc was never updated, so restarting the interpreter will rerun the wait instruction, which will load the completed value onto the stack.\n}\n\nThere should be no need for special logic about current_inst."}