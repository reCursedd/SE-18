{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/223121181", "pull_request_review_id": 162180163, "id": 223121181, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMzEyMTE4MQ==", "diff_hunk": "@@ -133,3 +133,27 @@ struct CAFFE2_API InefficientStdFunctionContext {\n };\n \n } // namespace at\n+\n+namespace caffe2 {\n+\n+// using AllocatorArray = std::array<\n+//     std::unique_ptr<at::Allocator>,\n+//     static_cast<int>(at::DeviceType::COMPILE_TIME_MAX_DEVICE_TYPES)>;\n+/** Set the allocator for DeviceType `t` and takes ownership of the allocator", "path": "aten/src/ATen/core/Allocator.h", "position": null, "original_position": 10, "commit_id": "77422586b8e686972b9416373fac71d159761ae1", "original_commit_id": "c12524ab752182358290446a59759d7b7bce1dd8", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "body": "BTW, this function is also dangerous, because it *invalidates* any other references to the allocator that was previously stored here. So any calls to this beyond the very beginning of this program are liable to cause big problems because we can't keep track if the allocator is still live or not.\r\n\r\nWhen I designed the original allocator API, I wrote it under the assumptions that all allocators have static lifetime. So maybe this array should be written that way too: assume that every allocator has already taken care of its static lifetime somehow, and we're just going to take in a non-owning reference to keep track of it. Then it would even be safe to set the allocator mid-program (though you'd still have to make sure to synchronize all threads) because you wouldn't be invalidating any allocators.", "created_at": "2018-10-05T19:47:43Z", "updated_at": "2018-11-23T15:52:27Z", "html_url": "https://github.com/pytorch/pytorch/pull/12111#discussion_r223121181", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/12111", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/223121181"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/12111#discussion_r223121181"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/12111"}}, "body_html": "<p>BTW, this function is also dangerous, because it <em>invalidates</em> any other references to the allocator that was previously stored here. So any calls to this beyond the very beginning of this program are liable to cause big problems because we can't keep track if the allocator is still live or not.</p>\n<p>When I designed the original allocator API, I wrote it under the assumptions that all allocators have static lifetime. So maybe this array should be written that way too: assume that every allocator has already taken care of its static lifetime somehow, and we're just going to take in a non-owning reference to keep track of it. Then it would even be safe to set the allocator mid-program (though you'd still have to make sure to synchronize all threads) because you wouldn't be invalidating any allocators.</p>", "body_text": "BTW, this function is also dangerous, because it invalidates any other references to the allocator that was previously stored here. So any calls to this beyond the very beginning of this program are liable to cause big problems because we can't keep track if the allocator is still live or not.\nWhen I designed the original allocator API, I wrote it under the assumptions that all allocators have static lifetime. So maybe this array should be written that way too: assume that every allocator has already taken care of its static lifetime somehow, and we're just going to take in a non-owning reference to keep track of it. Then it would even be safe to set the allocator mid-program (though you'd still have to make sure to synchronize all threads) because you wouldn't be invalidating any allocators.", "in_reply_to_id": 223119824}