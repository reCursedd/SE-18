{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/434372853", "html_url": "https://github.com/pytorch/pytorch/pull/13026#issuecomment-434372853", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/13026", "id": 434372853, "node_id": "MDEyOklzc3VlQ29tbWVudDQzNDM3Mjg1Mw==", "user": {"login": "suo", "id": 1617424, "node_id": "MDQ6VXNlcjE2MTc0MjQ=", "avatar_url": "https://avatars2.githubusercontent.com/u/1617424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/suo", "html_url": "https://github.com/suo", "followers_url": "https://api.github.com/users/suo/followers", "following_url": "https://api.github.com/users/suo/following{/other_user}", "gists_url": "https://api.github.com/users/suo/gists{/gist_id}", "starred_url": "https://api.github.com/users/suo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/suo/subscriptions", "organizations_url": "https://api.github.com/users/suo/orgs", "repos_url": "https://api.github.com/users/suo/repos", "events_url": "https://api.github.com/users/suo/events{/privacy}", "received_events_url": "https://api.github.com/users/suo/received_events", "type": "User", "site_admin": false}, "created_at": "2018-10-30T16:29:30Z", "updated_at": "2018-10-30T16:29:30Z", "author_association": "MEMBER", "body_html": "<p>The main performance concern was that <code>addEdge</code> is <code>AR * log (AR)</code>, but the ord of new node is set to the end. So if you inserted new nodes anywhere except the end, <code>AR</code> could be quite large and you get quadratic insertion behavior.</p>\n<p>My other concerns were around maintainability. I don't think pass authors should have to construct a separate data structure every time they want to do reordering, and having <code>ord</code> be out of sync with the the graph's canonical topological ordering is potentially confusing.</p>\n<p>But like I originally said, I think all these problems are fixable by modifying DynamicDAG (adding \"gaps\" like <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=5652049\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/zou3519\">@zou3519</a> describes) and then making it part of the graph interface. I think the ideal end state is we basically merge the topological index stuff and DynamicDAG together to implement <code>moveBeforeTopologicallyValid</code>.</p>", "body_text": "The main performance concern was that addEdge is AR * log (AR), but the ord of new node is set to the end. So if you inserted new nodes anywhere except the end, AR could be quite large and you get quadratic insertion behavior.\nMy other concerns were around maintainability. I don't think pass authors should have to construct a separate data structure every time they want to do reordering, and having ord be out of sync with the the graph's canonical topological ordering is potentially confusing.\nBut like I originally said, I think all these problems are fixable by modifying DynamicDAG (adding \"gaps\" like @zou3519 describes) and then making it part of the graph interface. I think the ideal end state is we basically merge the topological index stuff and DynamicDAG together to implement moveBeforeTopologicallyValid.", "body": "The main performance concern was that `addEdge` is `AR * log (AR)`, but the ord of new node is set to the end. So if you inserted new nodes anywhere except the end, `AR` could be quite large and you get quadratic insertion behavior.\r\n\r\nMy other concerns were around maintainability. I don't think pass authors should have to construct a separate data structure every time they want to do reordering, and having `ord` be out of sync with the the graph's canonical topological ordering is potentially confusing. \r\n\r\nBut like I originally said, I think all these problems are fixable by modifying DynamicDAG (adding \"gaps\" like @zou3519 describes) and then making it part of the graph interface. I think the ideal end state is we basically merge the topological index stuff and DynamicDAG together to implement `moveBeforeTopologicallyValid`.\r\n"}