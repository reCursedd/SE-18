{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/229336781", "pull_request_review_id": 169812638, "id": 229336781, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyOTMzNjc4MQ==", "diff_hunk": "@@ -1412,6 +1412,244 @@ void testDynamicDAG() {\n   testContractEdgeBasic();\n   testContractEdgeCycleDetection();\n }\n+\n+// Fixture to set up a graph and make assertions clearer\n+struct TopoMoveTestFixture {\n+  TopoMoveTestFixture() {\n+    createGraph();\n+  }\n+\n+  // Nodes are named after their output.\n+  // e.g. \"a\" is an alias for \"the node that outputs the value `a`\"\n+  void createGraph() {\n+    createNode(\"a\", {});\n+    createNode(\"b\", {\"a\"});\n+    createNode(\"c\", {});\n+    createNode(\"d\", {\"a\", \"b\"});\n+    createNode(\"e\", {\"c\", \"b\"});\n+    createNode(\"f\", {\"e\"});\n+    createNode(\"g\", {\"e\"});\n+    createNode(\"h\", {\"g\"});\n+    createNode(\"i\", {\"g\"});\n+    createNode(\"j\", {\"i\"});\n+    createNode(\"k\", {\"i\"});\n+    createNode(\"l\", {\"a\"});\n+    createNode(\"m\", {}, {\"l\"}); // block depends on l\n+    createNode(\"n\", {\"m\"});\n+    createNode(\"o\", {\"n\"});\n+    createNode(\"p\", {});\n+    createNode(\"q\", {});\n+    createNode(\"r\", {\"q\"});\n+    createNode(\"s\", {\"q\"});\n+\n+    graph.lint();\n+  }\n+\n+  void createNode(\n+      const std::string& name,\n+      const std::vector<std::string>& inputNames,\n+      const std::vector<std::string>& blockInputNames = {}) {\n+    std::vector<Value*> inputs;\n+    for (const auto name : inputNames) {\n+      inputs.push_back(nodes.at(name)->output());\n+    }\n+    auto node = graph.appendNode(graph.create(prim::Undefined, inputs));\n+    node->output()->setUniqueName(name);\n+    nodes[name] = node;\n+\n+    if (blockInputNames.size() != 0) {\n+      node->addBlock();\n+      std::vector<Value*> blockDeps;\n+      for (const auto name : blockInputNames) {\n+        blockDeps.push_back(nodes.at(name)->output());\n+      }\n+\n+      auto block = node->blocks().at(0);\n+      block->appendNode(graph.create(prim::Undefined, blockDeps));\n+    }\n+  }\n+\n+  bool moveBeforeTopologicallyValid(\n+      const std::string& toInsert,\n+      const std::string& insertPoint) {\n+    std::function<bool(Node*, Node*)> func = [](Node* toInsert,\n+                                                Node* insertPoint) {\n+      return toInsert->moveBeforeTopologicallyValid(insertPoint);\n+    };\n+    return moveWithChecks(toInsert, insertPoint, func);\n+  }\n+\n+  bool moveAfterTopologicallyValid(\n+      const std::string& toInsert,\n+      const std::string& insertPoint) {\n+    std::function<bool(Node*, Node*)> func = [](Node* toInsert,\n+                                                Node* insertPoint) {\n+      return toInsert->moveAfterTopologicallyValid(insertPoint);\n+    };\n+    return moveWithChecks(toInsert, insertPoint, func);\n+  }\n+\n+  bool moveWithChecks(\n+      const std::string& toInsert,\n+      const std::string& insertPoint,\n+      std::function<bool(Node*, Node*)> func) {\n+    auto n = nodes.at(toInsert);\n+    auto insert = nodes.at(insertPoint);\n+    bool isAfter = n->isAfter(insert);\n+\n+    std::vector<Node*> originalOrdering;\n+    Node* original = isAfter ? n->next() : n->prev();\n+\n+    auto curNode = original;\n+    while (curNode != n->owningBlock()->return_node()) {\n+      originalOrdering.push_back(curNode);\n+      if (isAfter) {\n+        curNode = curNode->next();\n+      } else {\n+        curNode = curNode->prev();\n+      }\n+    }\n+\n+    const auto couldMove = func(n, insert);\n+    // Check the graph is okay\n+    graph.lint();\n+\n+    // If this is the picture of nodes\n+    // <some nodes> ... toInsert ... <some more nodes> ... insertPoint\n+    // ^----------^ check that these nodes haven't moved\n+    curNode = original;\n+    size_t idx = 0;\n+    while (curNode != n->owningBlock()->return_node()) {\n+      JIT_ASSERT(originalOrdering[idx] == curNode);\n+      if (isAfter) {\n+        curNode = curNode->next();\n+      } else {\n+        curNode = curNode->prev();\n+      }\n+      idx++;\n+    }\n+\n+    return couldMove;\n+  }\n+\n+  void checkPostCondition(\n+      const std::string& toInsert,\n+      const std::string& insertPoint,\n+      bool after) {\n+    if (after) {\n+      JIT_ASSERT(nodes.at(toInsert)->prev() == nodes.at(insertPoint));\n+    } else {\n+      JIT_ASSERT(nodes.at(toInsert)->next() == nodes.at(insertPoint));\n+    }\n+  }\n+\n+  Graph graph;\n+  std::unordered_map<std::string, Node*> nodes;\n+};\n+\n+void testTopologicalMove() {\n+  {\n+    // Check that we are removing `this`'s deps properly when we need to split\n+    // `this` and deps (see code for what the hell that means)\n+    TopoMoveTestFixture fixture;\n+    JIT_ASSERT(fixture.moveBeforeTopologicallyValid(\"q\", \"s\"));\n+    fixture.checkPostCondition(\"q\", \"s\", false);\n+  }\n+  // Move after\n+  {\n+    // Simple move backward\n+    TopoMoveTestFixture fixture;\n+    JIT_ASSERT(fixture.moveAfterTopologicallyValid(\"c\", \"a\"));\n+    fixture.checkPostCondition(\"c\", \"a\", true);\n+  }\n+  {\n+    // simple invalid move backward\n+    TopoMoveTestFixture fixture;\n+    JIT_ASSERT(!fixture.moveAfterTopologicallyValid(\"d\", \"a\"));\n+  }\n+  {\n+    // doesn't actually move anything\n+    TopoMoveTestFixture fixture;\n+    JIT_ASSERT(fixture.moveAfterTopologicallyValid(\"f\", \"e\"));\n+    fixture.checkPostCondition(\"f\", \"e\", true);\n+  }\n+  {\n+    // move backward with multiple dependencies\n+    TopoMoveTestFixture fixture;\n+    JIT_ASSERT(fixture.moveAfterTopologicallyValid(\"e\", \"c\"));\n+    fixture.checkPostCondition(\"e\", \"c\", true);\n+  }\n+  {\n+    // Move backward with non-zero working set\n+    TopoMoveTestFixture fixture;\n+    JIT_ASSERT(fixture.moveAfterTopologicallyValid(\"k\", \"f\"));\n+    fixture.checkPostCondition(\"k\", \"f\", true);\n+  }\n+  {\n+    // Simple move forward\n+    TopoMoveTestFixture fixture;\n+    JIT_ASSERT(fixture.moveAfterTopologicallyValid(\"c\", \"d\"));\n+    fixture.checkPostCondition(\"c\", \"d\", true);\n+  }\n+  {\n+    // Move forward with non-zero working set\n+    TopoMoveTestFixture fixture;\n+    JIT_ASSERT(fixture.moveAfterTopologicallyValid(\"f\", \"l\"));\n+    fixture.checkPostCondition(\"f\", \"l\", true);\n+  }\n+\n+  // Move before\n+  {\n+    // Simple move forward\n+    TopoMoveTestFixture fixture;\n+    JIT_ASSERT(fixture.moveBeforeTopologicallyValid(\"b\", \"d\"));\n+    fixture.checkPostCondition(\"b\", \"d\", false);\n+  }\n+  {\n+    // Simple move backward\n+    TopoMoveTestFixture fixture;\n+    JIT_ASSERT(fixture.moveBeforeTopologicallyValid(\"c\", \"a\"));\n+    fixture.checkPostCondition(\"c\", \"a\", false);\n+  }\n+  {\n+    // doesn't actually move anything\n+    TopoMoveTestFixture fixture;\n+    JIT_ASSERT(fixture.moveBeforeTopologicallyValid(\"a\", \"b\"));\n+    fixture.checkPostCondition(\"a\", \"b\", false);\n+  }\n+  {\n+    // move forward with deps\n+    TopoMoveTestFixture fixture;\n+    JIT_ASSERT(fixture.moveBeforeTopologicallyValid(\"f\", \"m\"));\n+    fixture.checkPostCondition(\"f\", \"m\", false);\n+  }\n+  {\n+    // move backward with deps\n+    TopoMoveTestFixture fixture;\n+    JIT_ASSERT(fixture.moveBeforeTopologicallyValid(\"l\", \"f\"));\n+    fixture.checkPostCondition(\"l\", \"f\", false);\n+  }\n+\n+  // check that dependencies in blocks are recognized\n+  {\n+    TopoMoveTestFixture fixture;\n+    JIT_ASSERT(!fixture.moveAfterTopologicallyValid(\"l\", \"m\"));\n+    JIT_ASSERT(!fixture.moveBeforeTopologicallyValid(\"m\", \"l\"));\n+    JIT_ASSERT(!fixture.moveAfterTopologicallyValid(\"n\", \"l\"));\n+    JIT_ASSERT(!fixture.moveBeforeTopologicallyValid(\"l\", \"n\"));\n+  }\n+\n+  // Test that moveAfter(n) and moveBefore(n->next()) are not necessarily\n+  // equivalent. Here, the dependency ordering is n -> o -> p.  So we can't\n+  // move `n` after `o`, but we can move `n` before `p` (which pushes `o` after", "path": "test/cpp/jit/tests.h", "position": 233, "original_position": 233, "commit_id": "65c1823be93c87ccb8f900061aa30f27f370a9b1", "original_commit_id": "65c1823be93c87ccb8f900061aa30f27f370a9b1", "user": {"login": "zou3519", "id": 5652049, "node_id": "MDQ6VXNlcjU2NTIwNDk=", "avatar_url": "https://avatars3.githubusercontent.com/u/5652049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zou3519", "html_url": "https://github.com/zou3519", "followers_url": "https://api.github.com/users/zou3519/followers", "following_url": "https://api.github.com/users/zou3519/following{/other_user}", "gists_url": "https://api.github.com/users/zou3519/gists{/gist_id}", "starred_url": "https://api.github.com/users/zou3519/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zou3519/subscriptions", "organizations_url": "https://api.github.com/users/zou3519/orgs", "repos_url": "https://api.github.com/users/zou3519/repos", "events_url": "https://api.github.com/users/zou3519/events{/privacy}", "received_events_url": "https://api.github.com/users/zou3519/received_events", "type": "User", "site_admin": false}, "body": "What happens when you call n.moveBeforeTopologicallyValid(p)?", "created_at": "2018-10-30T14:45:43Z", "updated_at": "2018-11-23T15:53:50Z", "html_url": "https://github.com/pytorch/pytorch/pull/13026#discussion_r229336781", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/13026", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/229336781"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/13026#discussion_r229336781"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/13026"}}, "body_html": "<p>What happens when you call n.moveBeforeTopologicallyValid(p)?</p>", "body_text": "What happens when you call n.moveBeforeTopologicallyValid(p)?"}