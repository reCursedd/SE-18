{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/431532491", "html_url": "https://github.com/pytorch/pytorch/issues/12887#issuecomment-431532491", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/12887", "id": 431532491, "node_id": "MDEyOklzc3VlQ29tbWVudDQzMTUzMjQ5MQ==", "user": {"login": "HKervadec", "id": 4191866, "node_id": "MDQ6VXNlcjQxOTE4NjY=", "avatar_url": "https://avatars0.githubusercontent.com/u/4191866?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKervadec", "html_url": "https://github.com/HKervadec", "followers_url": "https://api.github.com/users/HKervadec/followers", "following_url": "https://api.github.com/users/HKervadec/following{/other_user}", "gists_url": "https://api.github.com/users/HKervadec/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKervadec/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKervadec/subscriptions", "organizations_url": "https://api.github.com/users/HKervadec/orgs", "repos_url": "https://api.github.com/users/HKervadec/repos", "events_url": "https://api.github.com/users/HKervadec/events{/privacy}", "received_events_url": "https://api.github.com/users/HKervadec/received_events", "type": "User", "site_admin": false}, "created_at": "2018-10-20T00:21:52Z", "updated_at": "2018-10-20T00:21:52Z", "author_association": "NONE", "body_html": "<p>Well, just crashed cinnamon when trying to run this on my machine, but for starters, do you mean <code>uint8</code> or <code>int64</code> ? Your title and your code contradict each others. Have 1.0rc0 installed, but in any case, keep in mind that <code>a</code> is absolutely massive (about 20gb of memory).</p>\n<p>However, running <code>(a.numpy() == a.numpy()).sum()</code> worked fairly well on my machine, so I guess this has to do with lazyness: the numpy <code>sum()</code> probably sum as the comparison goes, while the torch version first try to complete the comparison, store the result and then sum it, which can obviously wreak havoc when dealing with such tensors. The segfault could be a code for a memory error.</p>", "body_text": "Well, just crashed cinnamon when trying to run this on my machine, but for starters, do you mean uint8 or int64 ? Your title and your code contradict each others. Have 1.0rc0 installed, but in any case, keep in mind that a is absolutely massive (about 20gb of memory).\nHowever, running (a.numpy() == a.numpy()).sum() worked fairly well on my machine, so I guess this has to do with lazyness: the numpy sum() probably sum as the comparison goes, while the torch version first try to complete the comparison, store the result and then sum it, which can obviously wreak havoc when dealing with such tensors. The segfault could be a code for a memory error.", "body": "Well, just crashed cinnamon when trying to run this on my machine, but for starters, do you mean `uint8` or `int64` ? Your title and your code contradict each others. Have 1.0rc0 installed, but in any case, keep in mind that `a` is absolutely massive (about 20gb of memory).\r\n\r\nHowever, running `(a.numpy() == a.numpy()).sum()` worked fairly well on my machine, so I guess this has to do with lazyness: the numpy `sum()` probably sum as the comparison goes, while the torch version first try to complete the comparison, store the result and then sum it, which can obviously wreak havoc when dealing with such tensors. The segfault could be a code for a memory error."}