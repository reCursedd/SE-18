{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/387153927", "html_url": "https://github.com/pytorch/pytorch/pull/7304#issuecomment-387153927", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/7304", "id": 387153927, "node_id": "MDEyOklzc3VlQ29tbWVudDM4NzE1MzkyNw==", "user": {"login": "goldsborough", "id": 6429851, "node_id": "MDQ6VXNlcjY0Mjk4NTE=", "avatar_url": "https://avatars3.githubusercontent.com/u/6429851?v=4", "gravatar_id": "", "url": "https://api.github.com/users/goldsborough", "html_url": "https://github.com/goldsborough", "followers_url": "https://api.github.com/users/goldsborough/followers", "following_url": "https://api.github.com/users/goldsborough/following{/other_user}", "gists_url": "https://api.github.com/users/goldsborough/gists{/gist_id}", "starred_url": "https://api.github.com/users/goldsborough/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/goldsborough/subscriptions", "organizations_url": "https://api.github.com/users/goldsborough/orgs", "repos_url": "https://api.github.com/users/goldsborough/repos", "events_url": "https://api.github.com/users/goldsborough/events{/privacy}", "received_events_url": "https://api.github.com/users/goldsborough/received_events", "type": "User", "site_admin": false}, "created_at": "2018-05-07T18:12:46Z", "updated_at": "2018-05-07T18:28:39Z", "author_association": "CONTRIBUTOR", "body_html": "<ol>\n<li>Yes they would need all of <code>torch/csrc/</code>. I think it's a good idea though to keep it in its own subdirectory, just for logical separation. Ideally it would even be a top-level directory, e.g. at the level of <code>csrc</code> in order to better express that it uses but is not part of <code>csrc</code> (the autograd parts), but I think I went for <code>csrc/api</code> originally because we have all our C++ code under <code>csrc</code> and existing build code assumes so, and also just for consistency with current conventions.</li>\n<li>For separate <code>include</code> and <code>src</code>: For one, autogradpp already had this structure, so I overtook it when I moved autogradpp into PyTorch. For the other, it is quite the standard C++ library organization scheme and I think it scales better to a very large number of files (which the API won't have, but still). Also, since we agreed in the old C++ API PR that we don't have to care about microsecond gains from inlining, we can move towards having the headers have as little implementation as possible, serving mainly as an interface and documentation source, and move all the implementations into <code>.cpp</code> files. Then jumping between directories should actually be reduced.</li>\n<li>Just to be clear, the free <code>make()</code> function is a <em>very</em> temporary solution, I'm working on a new construction design right now. However, one of the constraints will certainly be to not allow partially constructed objects, as is currently the case (pointed out by <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=4583066\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/apaszke\">@apaszke</a> earlier). I will post a design doc for this.</li>\n</ol>", "body_text": "Yes they would need all of torch/csrc/. I think it's a good idea though to keep it in its own subdirectory, just for logical separation. Ideally it would even be a top-level directory, e.g. at the level of csrc in order to better express that it uses but is not part of csrc (the autograd parts), but I think I went for csrc/api originally because we have all our C++ code under csrc and existing build code assumes so, and also just for consistency with current conventions.\nFor separate include and src: For one, autogradpp already had this structure, so I overtook it when I moved autogradpp into PyTorch. For the other, it is quite the standard C++ library organization scheme and I think it scales better to a very large number of files (which the API won't have, but still). Also, since we agreed in the old C++ API PR that we don't have to care about microsecond gains from inlining, we can move towards having the headers have as little implementation as possible, serving mainly as an interface and documentation source, and move all the implementations into .cpp files. Then jumping between directories should actually be reduced.\nJust to be clear, the free make() function is a very temporary solution, I'm working on a new construction design right now. However, one of the constraints will certainly be to not allow partially constructed objects, as is currently the case (pointed out by @apaszke earlier). I will post a design doc for this.", "body": "1. Yes they would need all of `torch/csrc/`. I think it's a good idea though to keep it in its own subdirectory, just for logical separation. Ideally it would even be a top-level directory, e.g. at the level of `csrc` in order to better express that it uses but is not part of `csrc` (the autograd parts), but I think I went for `csrc/api` originally because we have all our C++ code under `csrc` and existing build code assumes so, and also just for consistency with current conventions.\r\n2. For separate `include` and `src`: For one, autogradpp already had this structure, so I overtook it when I moved autogradpp into PyTorch. For the other, it is quite the standard C++ library organization scheme and I think it scales better to a very large number of files (which the API won't have, but still). Also, since we agreed in the old C++ API PR that we don't have to care about microsecond gains from inlining, we can move towards having the headers have as little implementation as possible, serving mainly as an interface and documentation source, and move all the implementations into `.cpp` files. Then jumping between directories should actually be reduced.\r\n3. Just to be clear, the free `make()` function is a *very* temporary solution, I'm working on a new construction design right now. However, one of the constraints will certainly be to not allow partially constructed objects, as is currently the case (pointed out by @apaszke earlier). I will post a design doc for this."}