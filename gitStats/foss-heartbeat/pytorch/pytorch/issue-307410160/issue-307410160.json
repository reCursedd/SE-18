{"url": "https://api.github.com/repos/pytorch/pytorch/issues/5927", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/5927/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/5927/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/5927/events", "html_url": "https://github.com/pytorch/pytorch/pull/5927", "id": 307410160, "node_id": "MDExOlB1bGxSZXF1ZXN0MTc2NjAzNzQx", "number": 5927, "title": "Linearly interpolating upsampling fix", "user": {"login": "SsnL", "id": 5674597, "node_id": "MDQ6VXNlcjU2NzQ1OTc=", "avatar_url": "https://avatars2.githubusercontent.com/u/5674597?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SsnL", "html_url": "https://github.com/SsnL", "followers_url": "https://api.github.com/users/SsnL/followers", "following_url": "https://api.github.com/users/SsnL/following{/other_user}", "gists_url": "https://api.github.com/users/SsnL/gists{/gist_id}", "starred_url": "https://api.github.com/users/SsnL/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SsnL/subscriptions", "organizations_url": "https://api.github.com/users/SsnL/orgs", "repos_url": "https://api.github.com/users/SsnL/repos", "events_url": "https://api.github.com/users/SsnL/events{/privacy}", "received_events_url": "https://api.github.com/users/SsnL/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 846310180, "node_id": "MDU6TGFiZWw4NDYzMTAxODA=", "url": "https://api.github.com/repos/pytorch/pytorch/labels/bc-breaking", "name": "bc-breaking", "color": "ed7d8a", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 6, "created_at": "2018-03-21T20:41:37Z", "updated_at": "2018-11-23T15:41:03Z", "closed_at": "2018-03-24T16:21:13Z", "author_association": "CONTRIBUTOR", "pull_request": {"url": "https://api.github.com/repos/pytorch/pytorch/pulls/5927", "html_url": "https://github.com/pytorch/pytorch/pull/5927", "diff_url": "https://github.com/pytorch/pytorch/pull/5927.diff", "patch_url": "https://github.com/pytorch/pytorch/pull/5927.patch"}, "body_html": "<p>Add align_corners option to upsampling module &amp; functional when using linearly interpolating modes:</p>\n<p>When align_corners=True, it uses the old original upsampling scheme, which gives visually better results,<br>\nbut doesn't properly align input and output pixels, and thus cause the output vary basing on input.<br>\nThis PR adds this align_corners option, and changes the default behavior to align_corners=False, with<br>\nproper warning if this option is not specified upon using nn.Upsample or nn.functional.upsample to let<br>\nbe aware of this new change.<br>\nAdds tests in test_nn.py for spatial invariance when align_corners=False, and usual module tests for<br>\nalign_corners=False.</p>\n<p>The ratio is basically computed as:</p>\n<pre><code>ratio = align_corners ? (input_size - 1) / (output_size - 1) : input_size / output_size\n</code></pre>\n<p>And src_idx is:</p>\n<pre><code>if align_corners:\n  src_idx = dst_idx * ratio\nelse:\n  src_idx = (dst_idx + 0.5) * ratio - 0.5\n</code></pre>\n<p>The <code>0.5</code> are used to cast the index to location of the pixel centers.</p>\n<p>This also makes the default upsampling behavior consistent with other DL frameworks like tf.</p>\n<p>This solves the issue raised in <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"301605165\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/5511\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/pytorch/pytorch/pull/5511/hovercard\" href=\"https://github.com/pytorch/pytorch/pull/5511\">#5511</a></p>\n<p>cc <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=22355406\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/Dorimer\">@Dorimer</a></p>", "body_text": "Add align_corners option to upsampling module & functional when using linearly interpolating modes:\nWhen align_corners=True, it uses the old original upsampling scheme, which gives visually better results,\nbut doesn't properly align input and output pixels, and thus cause the output vary basing on input.\nThis PR adds this align_corners option, and changes the default behavior to align_corners=False, with\nproper warning if this option is not specified upon using nn.Upsample or nn.functional.upsample to let\nbe aware of this new change.\nAdds tests in test_nn.py for spatial invariance when align_corners=False, and usual module tests for\nalign_corners=False.\nThe ratio is basically computed as:\nratio = align_corners ? (input_size - 1) / (output_size - 1) : input_size / output_size\n\nAnd src_idx is:\nif align_corners:\n  src_idx = dst_idx * ratio\nelse:\n  src_idx = (dst_idx + 0.5) * ratio - 0.5\n\nThe 0.5 are used to cast the index to location of the pixel centers.\nThis also makes the default upsampling behavior consistent with other DL frameworks like tf.\nThis solves the issue raised in #5511\ncc @Dorimer", "body": "Add align_corners option to upsampling module & functional when using linearly interpolating modes:\r\n\r\nWhen align_corners=True, it uses the old original upsampling scheme, which gives visually better results,\r\nbut doesn't properly align input and output pixels, and thus cause the output vary basing on input.\r\nThis PR adds this align_corners option, and changes the default behavior to align_corners=False, with\r\nproper warning if this option is not specified upon using nn.Upsample or nn.functional.upsample to let\r\nbe aware of this new change.\r\nAdds tests in test_nn.py for spatial invariance when align_corners=False, and usual module tests for\r\nalign_corners=False.\r\n\r\nThe ratio is basically computed as:\r\n```\r\nratio = align_corners ? (input_size - 1) / (output_size - 1) : input_size / output_size\r\n```\r\nAnd src_idx is:\r\n```\r\nif align_corners:\r\n  src_idx = dst_idx * ratio\r\nelse:\r\n  src_idx = (dst_idx + 0.5) * ratio - 0.5\r\n```\r\nThe `0.5` are used to cast the index to location of the pixel centers.\r\n\r\nThis also makes the default upsampling behavior consistent with other DL frameworks like tf.\r\n\r\nThis solves the issue raised in #5511 \r\n\r\ncc @Dorimer "}