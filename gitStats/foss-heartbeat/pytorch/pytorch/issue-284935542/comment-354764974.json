{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/354764974", "html_url": "https://github.com/pytorch/pytorch/issues/4382#issuecomment-354764974", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/4382", "id": 354764974, "node_id": "MDEyOklzc3VlQ29tbWVudDM1NDc2NDk3NA==", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "created_at": "2018-01-02T13:20:44Z", "updated_at": "2018-01-02T13:20:44Z", "author_association": "MEMBER", "body_html": "<p>As you pointed out it's not easy to implement a robust way for communication like this, so I think it's best to avoid doing so. One way to implement this would be to encode the information in the object used to index the dataset by creating your own sampler. The whole process would look approximately like this:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">class</span> <span class=\"pl-en\">MySampler</span>(<span class=\"pl-c1\">object</span>):\n    <span class=\"pl-k\">def</span> <span class=\"pl-c1\">__init__</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>, <span class=\"pl-smi\">model</span>):\n        <span class=\"pl-c1\">self</span>.model <span class=\"pl-k\">=</span> model\n    <span class=\"pl-k\">def</span> <span class=\"pl-c1\">__iter__</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>):\n        <span class=\"pl-k\">for</span> i <span class=\"pl-k\">in</span> <span class=\"pl-c1\">range</span>(epoch_length):\n            <span class=\"pl-k\">yield</span> (<span class=\"pl-c1\">self</span>.model.input_size, i) <span class=\"pl-c\"><span class=\"pl-c\">#</span> <span class=\"pl-k\">NOTE</span>: this doesn't do shuffling, but you can sample i</span>\n\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">MyDataset</span>(<span class=\"pl-c1\">object</span>):\n    <span class=\"pl-k\">def</span> <span class=\"pl-c1\">__getitem__</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>, <span class=\"pl-smi\">args</span>):\n        sample_size, sample_idx <span class=\"pl-k\">=</span> args\n        <span class=\"pl-k\">return</span> <span class=\"pl-c1\">...</span> <span class=\"pl-c\"><span class=\"pl-c\">#</span> load the sample and resize</span>\n\ndset <span class=\"pl-k\">=</span> MyDataset()\nsampler <span class=\"pl-k\">=</span> MySampler(model)\nloader <span class=\"pl-k\">=</span> DataLoader(dset, <span class=\"pl-c1\">...</span>, <span class=\"pl-v\">sampler</span><span class=\"pl-k\">=</span>sampler)</pre></div>", "body_text": "As you pointed out it's not easy to implement a robust way for communication like this, so I think it's best to avoid doing so. One way to implement this would be to encode the information in the object used to index the dataset by creating your own sampler. The whole process would look approximately like this:\nclass MySampler(object):\n    def __init__(self, model):\n        self.model = model\n    def __iter__(self):\n        for i in range(epoch_length):\n            yield (self.model.input_size, i) # NOTE: this doesn't do shuffling, but you can sample i\n\nclass MyDataset(object):\n    def __getitem__(self, args):\n        sample_size, sample_idx = args\n        return ... # load the sample and resize\n\ndset = MyDataset()\nsampler = MySampler(model)\nloader = DataLoader(dset, ..., sampler=sampler)", "body": "As you pointed out it's not easy to implement a robust way for communication like this, so I think it's best to avoid doing so. One way to implement this would be to encode the information in the object used to index the dataset by creating your own sampler. The whole process would look approximately like this:\r\n```python\r\nclass MySampler(object):\r\n    def __init__(self, model):\r\n        self.model = model\r\n    def __iter__(self):\r\n        for i in range(epoch_length):\r\n            yield (self.model.input_size, i) # NOTE: this doesn't do shuffling, but you can sample i\r\n\r\nclass MyDataset(object):\r\n    def __getitem__(self, args):\r\n        sample_size, sample_idx = args\r\n        return ... # load the sample and resize\r\n\r\ndset = MyDataset()\r\nsampler = MySampler(model)\r\nloader = DataLoader(dset, ..., sampler=sampler)\r\n```"}