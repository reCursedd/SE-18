{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/205294182", "pull_request_review_id": 140536916, "id": 205294182, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwNTI5NDE4Mg==", "diff_hunk": "@@ -83,146 +116,149 @@ bool outputRequiresGrad(Node* node, std::function<bool(Value*)> requires_grad) {\n   }\n }\n \n-\n-\n static std::vector<Value*> gradientForNode(Node* node, ArrayRef<Value*> grad_values) {\n   const auto build_sym_grad = [node](const std::vector<SymbolicVariable>& grads) -> std::vector<SymbolicVariable> {\n     auto inputs = fmap<SymbolicVariable>(node->inputs());\n     auto outputs = fmap<SymbolicVariable>(node->outputs());\n-    switch(node->kind()) {\n-      case aten::add:\n-        // TODO (apaszke): remove formulas for attributed nodes once they are removed\n-        // o = self + alpha*other\n-        if(inputs.size() == 1) {\n-          return { grads.at(0) };\n-        } else if (node->hasAttribute(attr::alpha)) {\n-          return {grads.at(0), grads.at(0) * at::Scalar(node->t(attr::alpha))};\n-        } else {\n-          return {grads.at(0), nullptr, grads.at(0) * node->namedInput(attr::alpha)};\n-        }\n-      case aten::sub:\n-        // o = self - alpha*other\n-        if(inputs.size() == 1) {\n-          return {grads.at(0)};\n-        } else if (node->hasAttribute(attr::alpha)) {\n-          return {grads.at(0), -grads.at(0) * at::Scalar(node->t(attr::alpha))};\n-        } else {\n-          return {grads.at(0), nullptr, grads.at(0) * node->namedInput(attr::alpha)};\n-        }\n-      case aten::mul:\n-        // o = self * other\n-        if(inputs.size() == 1)\n-          return {grads.at(0) * at::Scalar(node->t(attr::other))};\n-        else\n-          return {grads.at(0) * inputs.at(1), grads.at(0) * inputs.at(0)};\n-      case prim::Constant:\n-        return {};\n-      case aten::sigmoid:\n-        return {grads.at(0) * outputs.at(0) * (1 - outputs.at(0))};\n-      case aten::tanh:\n-        return {grads.at(0) * (1 - outputs.at(0) * outputs.at(0))};\n-      case aten::relu:\n-        return {grads.at(0) * (outputs.at(0) > at::Scalar(0)).type_as(outputs.at(0))};\n-      case aten::exp:\n-        return {grads.at(0) * (outputs.at(0))};\n-      case aten::chunk:\n-      case aten::split:\n-        return {SymbolicVariable::cat(grads, node->namedInput(attr::dim))};\n-      case aten::t:\n-        return {grads.at(0).t()};\n-      case aten::neg:\n-        return {-grads.at(0)};\n-      case aten::view:\n-        // TODO: if sizes are not available statically, add an operator that reutrns them as a tuple\n-        return {grads.at(0).view(inputs.at(0).sizes())};\n-      case aten::type_as:\n-        return {grads.at(0).type_as(inputs.at(0))};\n-      case aten::unsqueeze:\n-        return {grads.at(0).squeeze(node->namedInput(attr::dim))};\n-      case aten::mm: {\n-        SymbolicVariable dmat1, dmat2;\n-        if (auto type = inputs.at(0).value()->type()->cast<TensorType>()) {\n-          auto sizes = type->sizes(), strides = type->strides();\n-          if (strides.at(0) == 1 && strides.at(1) == sizes.at(0)) {\n-            dmat1 = inputs.at(1).mm(grads.at(0).t()).t();\n-          } else {\n-            dmat1 = grads.at(0).mm(inputs.at(1).t());\n-          }\n+\n+    if (node->matches(\"aten::add(Tensor self, Tensor other, *, Scalar alpha) -> Tensor\") ||", "path": "torch/csrc/jit/autodiff.cpp", "position": 180, "original_position": 185, "commit_id": "1f52f39901e6d1f1d0d263b5025388a55194ecc6", "original_commit_id": "9ee72f1547825a8e27d9ca8a7f00ce31e9741aae", "user": {"login": "zdevito", "id": 370202, "node_id": "MDQ6VXNlcjM3MDIwMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/370202?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zdevito", "html_url": "https://github.com/zdevito", "followers_url": "https://api.github.com/users/zdevito/followers", "following_url": "https://api.github.com/users/zdevito/following{/other_user}", "gists_url": "https://api.github.com/users/zdevito/gists{/gist_id}", "starred_url": "https://api.github.com/users/zdevito/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zdevito/subscriptions", "organizations_url": "https://api.github.com/users/zdevito/orgs", "repos_url": "https://api.github.com/users/zdevito/repos", "events_url": "https://api.github.com/users/zdevito/events{/privacy}", "received_events_url": "https://api.github.com/users/zdevito/received_events", "type": "User", "site_admin": false}, "body": "I find the matches code much more understandable than what we had before.", "created_at": "2018-07-25T23:43:08Z", "updated_at": "2018-11-23T15:48:09Z", "html_url": "https://github.com/pytorch/pytorch/pull/9807#discussion_r205294182", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/9807", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/205294182"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/9807#discussion_r205294182"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/9807"}}, "body_html": "<p>I find the matches code much more understandable than what we had before.</p>", "body_text": "I find the matches code much more understandable than what we had before."}