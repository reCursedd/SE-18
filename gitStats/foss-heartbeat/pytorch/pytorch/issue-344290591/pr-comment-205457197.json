{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/205457197", "pull_request_review_id": 140728991, "id": 205457197, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwNTQ1NzE5Nw==", "diff_hunk": "@@ -83,146 +116,149 @@ bool outputRequiresGrad(Node* node, std::function<bool(Value*)> requires_grad) {\n   }\n }\n \n-\n-\n static std::vector<Value*> gradientForNode(Node* node, ArrayRef<Value*> grad_values) {\n   const auto build_sym_grad = [node](const std::vector<SymbolicVariable>& grads) -> std::vector<SymbolicVariable> {\n     auto inputs = fmap<SymbolicVariable>(node->inputs());\n     auto outputs = fmap<SymbolicVariable>(node->outputs());\n-    switch(node->kind()) {\n-      case aten::add:\n-        // TODO (apaszke): remove formulas for attributed nodes once they are removed\n-        // o = self + alpha*other\n-        if(inputs.size() == 1) {\n-          return { grads.at(0) };\n-        } else if (node->hasAttribute(attr::alpha)) {\n-          return {grads.at(0), grads.at(0) * at::Scalar(node->t(attr::alpha))};\n-        } else {\n-          return {grads.at(0), nullptr, grads.at(0) * node->namedInput(attr::alpha)};\n-        }\n-      case aten::sub:\n-        // o = self - alpha*other\n-        if(inputs.size() == 1) {\n-          return {grads.at(0)};\n-        } else if (node->hasAttribute(attr::alpha)) {\n-          return {grads.at(0), -grads.at(0) * at::Scalar(node->t(attr::alpha))};\n-        } else {\n-          return {grads.at(0), nullptr, grads.at(0) * node->namedInput(attr::alpha)};\n-        }\n-      case aten::mul:\n-        // o = self * other\n-        if(inputs.size() == 1)\n-          return {grads.at(0) * at::Scalar(node->t(attr::other))};\n-        else\n-          return {grads.at(0) * inputs.at(1), grads.at(0) * inputs.at(0)};\n-      case prim::Constant:\n-        return {};\n-      case aten::sigmoid:\n-        return {grads.at(0) * outputs.at(0) * (1 - outputs.at(0))};\n-      case aten::tanh:\n-        return {grads.at(0) * (1 - outputs.at(0) * outputs.at(0))};\n-      case aten::relu:\n-        return {grads.at(0) * (outputs.at(0) > at::Scalar(0)).type_as(outputs.at(0))};\n-      case aten::exp:\n-        return {grads.at(0) * (outputs.at(0))};\n-      case aten::chunk:\n-      case aten::split:\n-        return {SymbolicVariable::cat(grads, node->namedInput(attr::dim))};\n-      case aten::t:\n-        return {grads.at(0).t()};\n-      case aten::neg:\n-        return {-grads.at(0)};\n-      case aten::view:\n-        // TODO: if sizes are not available statically, add an operator that reutrns them as a tuple\n-        return {grads.at(0).view(inputs.at(0).sizes())};\n-      case aten::type_as:\n-        return {grads.at(0).type_as(inputs.at(0))};\n-      case aten::unsqueeze:\n-        return {grads.at(0).squeeze(node->namedInput(attr::dim))};\n-      case aten::mm: {\n-        SymbolicVariable dmat1, dmat2;\n-        if (auto type = inputs.at(0).value()->type()->cast<TensorType>()) {\n-          auto sizes = type->sizes(), strides = type->strides();\n-          if (strides.at(0) == 1 && strides.at(1) == sizes.at(0)) {\n-            dmat1 = inputs.at(1).mm(grads.at(0).t()).t();\n-          } else {\n-            dmat1 = grads.at(0).mm(inputs.at(1).t());\n-          }\n+\n+    if (node->matches(\"aten::add(Tensor self, Tensor other, *, Scalar alpha) -> Tensor\") ||", "path": "torch/csrc/jit/autodiff.cpp", "position": 180, "original_position": 185, "commit_id": "1f52f39901e6d1f1d0d263b5025388a55194ecc6", "original_commit_id": "9ee72f1547825a8e27d9ca8a7f00ce31e9741aae", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "body": "Oh they definitely are. And they at least give you enough confidence to safely access and process input lists to nodes. I'm only looking forward to getting rid of flattening tensor lists into arguments, and we'll be in a very good place then.", "created_at": "2018-07-26T13:34:16Z", "updated_at": "2018-11-23T15:48:12Z", "html_url": "https://github.com/pytorch/pytorch/pull/9807#discussion_r205457197", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/9807", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/205457197"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/9807#discussion_r205457197"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/9807"}}, "body_html": "<p>Oh they definitely are. And they at least give you enough confidence to safely access and process input lists to nodes. I'm only looking forward to getting rid of flattening tensor lists into arguments, and we'll be in a very good place then.</p>", "body_text": "Oh they definitely are. And they at least give you enough confidence to safely access and process input lists to nodes. I'm only looking forward to getting rid of flattening tensor lists into arguments, and we'll be in a very good place then.", "in_reply_to_id": 205294182}