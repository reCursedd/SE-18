{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/182468422", "pull_request_review_id": 113269542, "id": 182468422, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4MjQ2ODQyMg==", "diff_hunk": "@@ -58,12 +58,11 @@ void SortAndLimitRoIsByScores(Eigen::Ref<const EArrXf> scores, int n,\n   // Note that people have found nth_element + sort to be much faster\n   // than partial_sort so we use it here\n   if (n > 0 && n < rois.rows()) {\n-    std::nth_element(idxs.begin(), idxs.begin() + n, idxs.end(), comp);", "path": "caffe2/operators/collect_and_distribute_fpn_rpn_proposals_op.cc", "position": null, "original_position": 4, "commit_id": "f9094b94fe3131876fc706462e04023395f6bbd3", "original_commit_id": "bc53c9c625b989bc899a00d79b4abf0968a9d757", "user": {"login": "orionr", "id": 79994, "node_id": "MDQ6VXNlcjc5OTk0", "avatar_url": "https://avatars3.githubusercontent.com/u/79994?v=4", "gravatar_id": "", "url": "https://api.github.com/users/orionr", "html_url": "https://github.com/orionr", "followers_url": "https://api.github.com/users/orionr/followers", "following_url": "https://api.github.com/users/orionr/following{/other_user}", "gists_url": "https://api.github.com/users/orionr/gists{/gist_id}", "starred_url": "https://api.github.com/users/orionr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/orionr/subscriptions", "organizations_url": "https://api.github.com/users/orionr/orgs", "repos_url": "https://api.github.com/users/orionr/repos", "events_url": "https://api.github.com/users/orionr/events{/privacy}", "received_events_url": "https://api.github.com/users/orionr/received_events", "type": "User", "site_admin": false}, "body": "I agree - we should keep this. The comment I made above about nth_element + sort hasn't really been tested on real-world cases, so it could likely be wrong. If you could verify given the larger range of test cases below, that would be great. Then we can decide whether to use nth_element + sort or partial_sort.\r\n\r\nIn both cases, though, we can make it stable by adjusting comp to also test index:\r\n\r\n```\r\nauto comp = [&scores](int lhs, int rhs) {\r\n  if (scores(lhs) > scores(rhs)) return true;\r\n  if (scores(lhs) < scores(rhs)) return false;\r\n  return lhs > rhs;\r\n};\r\n```\r\nThen there's no need to use stable_sort. Thoughts?", "created_at": "2018-04-18T15:23:43Z", "updated_at": "2018-11-23T15:42:44Z", "html_url": "https://github.com/pytorch/pytorch/pull/6693#discussion_r182468422", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/6693", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/182468422"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/6693#discussion_r182468422"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/6693"}}, "body_html": "<p>I agree - we should keep this. The comment I made above about nth_element + sort hasn't really been tested on real-world cases, so it could likely be wrong. If you could verify given the larger range of test cases below, that would be great. Then we can decide whether to use nth_element + sort or partial_sort.</p>\n<p>In both cases, though, we can make it stable by adjusting comp to also test index:</p>\n<pre><code>auto comp = [&amp;scores](int lhs, int rhs) {\n  if (scores(lhs) &gt; scores(rhs)) return true;\n  if (scores(lhs) &lt; scores(rhs)) return false;\n  return lhs &gt; rhs;\n};\n</code></pre>\n<p>Then there's no need to use stable_sort. Thoughts?</p>", "body_text": "I agree - we should keep this. The comment I made above about nth_element + sort hasn't really been tested on real-world cases, so it could likely be wrong. If you could verify given the larger range of test cases below, that would be great. Then we can decide whether to use nth_element + sort or partial_sort.\nIn both cases, though, we can make it stable by adjusting comp to also test index:\nauto comp = [&scores](int lhs, int rhs) {\n  if (scores(lhs) > scores(rhs)) return true;\n  if (scores(lhs) < scores(rhs)) return false;\n  return lhs > rhs;\n};\n\nThen there's no need to use stable_sort. Thoughts?", "in_reply_to_id": 182306343}