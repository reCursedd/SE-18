{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/175045201", "pull_request_review_id": 104505026, "id": 175045201, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE3NTA0NTIwMQ==", "diff_hunk": "@@ -105,124 +122,133 @@ struct NamedParameter {\n   std::unique_ptr<at::Tensor> parameter;\n };\n \n-struct NamedMember {\n-  enum Kind { Module, Parameter, Method, None };\n-  // note: None is used to report undefined attributes;\n-  Kind kind;\n-  size_t offset;\n-\n-  static const char * kind_string(Kind kind) {\n-    switch(kind) {\n-      case Module: return \"module\";\n-      case Parameter: return \"parameter\";\n-      case Method: return \"method\";\n-      case None: return \"none\";\n-      default: return \"unknown\";\n+// simple ordered dict used only in Module\n+// contains only the minimum necessary functionality for Module\n+template<typename T>\n+struct OrderedDict {\n+  OrderedDict() {}\n+  T& insert(const std::string& name,  T&& value, const char* what) {\n+    if(index_.count(name) != 0) {\n+      std::stringstream ss;\n+      ss << \"module \" << what << \"'\" << name << \"' already defined.\";\n+      throw std::runtime_error(ss.str());\n     }\n+    values_.push_back(std::move(value));\n+    index_[name] = values_.size() - 1;\n+    return values_.back();\n+  }\n+  at::optional<T&> find(const std::string& str) {\n+    auto it = index_.find(str);\n+    if(it == index_.end())\n+      return at::nullopt;\n+    return at::optional<T&>(values_.at(it->second));\n+  }\n+  at::optional<const T&> find(const std::string& str) const {\n+    auto it = index_.find(str);\n+    if(it == index_.end())\n+      return at::nullopt;\n+    return at::optional<const T&>(values_.at(it->second));\n+  }\n+  T& get(const std::string& name, const char * what) {\n+    if(auto v = find(name)) {\n+      return *v;\n+    }\n+    std::stringstream ss;\n+    ss << \"module \" << what << \"'\" << name << \"' is not defined.\";\n+    throw std::runtime_error(ss.str());\n+  }\n+  const T& get(const std::string& name, const char * what) const {\n+    if(auto v = find(name)) {\n+      return *v;\n+    }\n+    std::stringstream ss;\n+    ss << \"module \" << what << \"'\" << name << \"' is not defined.\";\n+    throw std::runtime_error(ss.str());\n+  }\n+  const std::vector<T>& values() const {\n+    return values_;\n   }\n+private:\n+  std::unordered_map<std::string, size_t> index_;\n+  std::vector<T> values_;\n };\n \n struct Module : public std::enable_shared_from_this<Module> {\n   TH_DISALLOW_COPY_AND_ASSIGN(Module);\n   Module(bool optimize)\n   : optimize(optimize) {}\n \n-  void register_parameter(const std::string & name, at::Tensor v) {\n-    parameters.push_back(NamedParameter(name, std::move(v)));\n-    add_member(name, NamedMember::Parameter, parameters.size() - 1);\n-  }\n-  void register_or_set_parameter(const std::string & name, autograd::Variable v) {\n-    if(find_attribute(name) == NamedMember::Parameter) {\n-      set_parameter(name, v);\n-    } else {\n-      register_parameter(name, v);\n+  void register_parameter(const std::string & name, autograd::Variable v, bool is_buffer) {\n+    if(auto p = parameters.find(name)){\n+      *p->slot() = v;\n+      p->is_buffer = is_buffer;\n+      return;\n     }\n+    parameters.insert(name, NamedParameter(name, std::move(v), is_buffer), \"parameter\");\n   }\n   void register_module(const std::string& name, std::shared_ptr<Module> module) {\n-    JIT_ASSERT(module);\n-    modules.push_back(NamedModule {name, std::move(module)});\n-    add_member(name, NamedMember::Module, modules.size() - 1);\n+    modules.insert(name, {name, std::move(module)}, \"module\");\n   }\n \n-  Method& create_method(const std::string & name) {\n-    methods.emplace_back(new Method(name, optimize));\n-    add_member(name, NamedMember::Method, methods.size() - 1);\n-    return *methods.back();\n+  Method& create_method(const std::string & name, std::shared_ptr<Graph> graph = nullptr, std::vector<at::Tensor*> member_inputs = {}) {\n+    if(!graph)\n+      graph = std::make_shared<Graph>();\n+    std::unique_ptr<Method> method(new Method(name, optimize, std::move(graph), std::move(member_inputs)));\n+\n+    return *methods.insert(name, std::move(method), \"method\");\n   }\n \n-  at::Tensor* parameter_slot(const std::string & name) {\n-    return parameters.at(find_member(name, NamedMember::Parameter)).slot();\n+  at::Tensor* parameter_slot(const std::string & name) const {\n+    return parameters.get(name, \"parameter\").slot();\n   }\n \n   void set_parameter(const std::string & name, at::Tensor v) {\n     *parameter_slot(name) = std::move(v);\n   }\n \n-  at::Tensor get_parameter(const std::string& name) {\n-    return *parameter_slot(name);\n+  autograd::Variable get_parameter(const std::string& name) const {\n+    return static_cast<autograd::Variable&>(*parameter_slot(name));\n   }\n \n   // each module owns its method. The reference returned here\n   // is guarenteed to stay valid until this module has been destoryed\n   Method& get_method(const std::string& name) const {\n-    return *methods.at(find_member(name, NamedMember::Method));\n+    return *methods.get(name, \"method\");\n   }\n \n   std::shared_ptr<Module> get_module(const std::string& name) const {\n-    auto loc = find_member(name, NamedMember::Module);\n-    return modules.at(loc).module;\n+    return modules.get(name, \"module\").module;\n   }\n \n-  NamedMember::Kind find_attribute(const std::string& name) {\n-    auto it = members.find(name);\n-    if(it == members.end())\n-      return NamedMember::None;\n-    return it->second.kind;\n+  const std::vector<NamedModule>& get_modules() const {\n+    return modules.values();\n   }\n-\n-  void dump() const {\n-    for(auto entry : members) {\n-      std::cout << entry.first << \": \" << NamedMember::kind_string(entry.second.kind) << \"\\n\";\n-    }\n+  const  std::vector<NamedParameter>& get_parameters() const {\n+    return parameters.values();\n   }\n \n-private:\n-  size_t find_member(const std::string& name, NamedMember::Kind kind) const  {\n-    auto it = members.find(name);\n-    if(it == members.end()) {\n-      std::stringstream ss;\n-      ss << \"unknown \" << NamedMember::kind_string(kind) << \" '\" << name << \"'\";\n-      throw std::runtime_error(ss.str());\n-    }\n-    if(it->second.kind != kind) {\n-      std::stringstream ss;\n-      ss << \"Expected attribute '\" << name << \"' to be a \"\n-        << NamedMember::kind_string(kind) << \" but found \"\n-        << NamedMember::kind_string(it->second.kind);\n-      throw std::runtime_error(ss.str());\n-    }\n-    JIT_ASSERT(it != members.end() && it->second.kind == kind);\n-    return it->second.offset;\n+\n+  at::optional<NamedParameter&> find_parameter(const std::string& name) {\n+    return parameters.find(name);\n   }\n-  void add_member(const std::string& name, NamedMember::Kind kind, size_t offset) {\n-    auto it = members.find(name);\n-    if(it != members.end()) {\n-      std::stringstream ss;\n-      ss << \"attempting to add \" << NamedMember::kind_string(kind) << \" '\" << name << \"' but Module already contains \"\n-      << NamedMember::kind_string(it->second.kind) << \" '\" << name << \"'\";\n-      throw std::runtime_error(ss.str());\n-    }\n-    members[std::move(name)] = NamedMember { kind, offset };\n+  at::optional<NamedModule&> find_module(const std::string& name) {\n+    return modules.find(name);\n+  }\n+  at::optional<Method&> find_method(const std::string& name) {\n+    if(auto pm = methods.find(name))\n+      return at::optional<Method&>(**pm);\n+    return at::nullopt;\n   }\n+\n+private:\n+\n   // invariant: to ensure member_inputs of Methods stay valid,\n   // it is only legal to _add_ new modules and parameters.\n   // removing them will allow member_inputs to point to invalid parameters\n   // no such restriction exists for methods\n-  std::vector<NamedModule> modules;\n-  std::vector<NamedParameter> parameters;\n-  std::vector<std::unique_ptr<Method>> methods;\n-\n-  std::unordered_map<std::string, NamedMember> members;\n+  OrderedDict<NamedModule> modules;\n+  OrderedDict<NamedParameter> parameters;\n+  OrderedDict<std::unique_ptr<Method>> methods;", "path": "torch/csrc/jit/script/module.h", "position": 301, "original_position": 281, "commit_id": "50399284500538c5061b09ca43ce118e838d09db", "original_commit_id": "6699ca53212e7b5395c74cad71cd9b61fe0fdf63", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "body": "Can you remind me why do we keep `unique_ptr`s here? Is it because `methods` are quite heavyweight and we want to avoid the cost of moving?", "created_at": "2018-03-16T10:12:53Z", "updated_at": "2018-11-23T15:40:50Z", "html_url": "https://github.com/pytorch/pytorch/pull/5769#discussion_r175045201", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/5769", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/175045201"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/5769#discussion_r175045201"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/5769"}}, "body_html": "<p>Can you remind me why do we keep <code>unique_ptr</code>s here? Is it because <code>methods</code> are quite heavyweight and we want to avoid the cost of moving?</p>", "body_text": "Can you remind me why do we keep unique_ptrs here? Is it because methods are quite heavyweight and we want to avoid the cost of moving?"}