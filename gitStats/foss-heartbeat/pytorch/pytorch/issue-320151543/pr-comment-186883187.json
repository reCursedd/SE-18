{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/186883187", "pull_request_review_id": 118552389, "id": 186883187, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4Njg4MzE4Nw==", "diff_hunk": "@@ -0,0 +1,42 @@\n+#pragma once\n+\n+#include <ATen/Registry.h>\n+#include <ATen/Error.h>\n+#include <ATen/ScalarType.h>\n+\n+namespace at {\n+  class Context;\n+}\n+\n+// NB: Registry class not actually in the namespace detail, due to limitations\n+// of Registry.h\n+namespace at {\n+\n+// The VariableHooksInterface is an interface for autograd functionality\n+// which currently doesn't live in libATen.so AND needs to be called from\n+// ATen.  In this case, it is only the type registry for Variable types,", "path": "aten/src/ATen/detail/VariableHooksInterface.h", "position": 17, "original_position": 17, "commit_id": "eb6abd0bc078c77e3ea4f1e8909d2ed494d365b3", "original_commit_id": "241f08d67e60910713b5c77eb16f6dac726cece2", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "body": "Yeah, it's used to add Variable variants of types whenever we register new types to the type registry.  The specific case we have to worry about looks like this:\r\n\r\n1. libATen.so is loaded, and it initializes the type registry with CPU types.  However, CUDA types are not initialized (they are only initialized when we lazily initialize CUDA)\r\n2. libtorch.so is loaded, and it initializes the variable type registry with all the types in the type registry, which in this case is only the CPU types\r\n3. During execution, CUDA initialization occurs.  CUDA initializes the type registry with CUDA types, and now we need to also, at the same time we're initializing the CUDA types, also initialize the CUDA variable types.\r\n\r\nAlso, because C10 is going to have native knowledge about Variables, I sucked the variable type registry into ATen.\r\n", "created_at": "2018-05-08T22:12:17Z", "updated_at": "2018-11-23T15:43:44Z", "html_url": "https://github.com/pytorch/pytorch/pull/7275#discussion_r186883187", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/7275", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/186883187"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/7275#discussion_r186883187"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/7275"}}, "body_html": "<p>Yeah, it's used to add Variable variants of types whenever we register new types to the type registry.  The specific case we have to worry about looks like this:</p>\n<ol>\n<li>libATen.so is loaded, and it initializes the type registry with CPU types.  However, CUDA types are not initialized (they are only initialized when we lazily initialize CUDA)</li>\n<li>libtorch.so is loaded, and it initializes the variable type registry with all the types in the type registry, which in this case is only the CPU types</li>\n<li>During execution, CUDA initialization occurs.  CUDA initializes the type registry with CUDA types, and now we need to also, at the same time we're initializing the CUDA types, also initialize the CUDA variable types.</li>\n</ol>\n<p>Also, because C10 is going to have native knowledge about Variables, I sucked the variable type registry into ATen.</p>", "body_text": "Yeah, it's used to add Variable variants of types whenever we register new types to the type registry.  The specific case we have to worry about looks like this:\n\nlibATen.so is loaded, and it initializes the type registry with CPU types.  However, CUDA types are not initialized (they are only initialized when we lazily initialize CUDA)\nlibtorch.so is loaded, and it initializes the variable type registry with all the types in the type registry, which in this case is only the CPU types\nDuring execution, CUDA initialization occurs.  CUDA initializes the type registry with CUDA types, and now we need to also, at the same time we're initializing the CUDA types, also initialize the CUDA variable types.\n\nAlso, because C10 is going to have native knowledge about Variables, I sucked the variable type registry into ATen.", "in_reply_to_id": 186786088}