{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/170147180", "pull_request_review_id": 98789435, "id": 170147180, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE3MDE0NzE4MA==", "diff_hunk": "@@ -58,64 +63,126 @@ def is_jit_op(decl):\n             'Tensor' in decl['return_type'])\n \n \n+prefer_tensor_overload = {\n+    'lt-2', 'gt-2', 'le-2', 'ge-2', 'eq-2', 'ne-2', 'pow-2', 'add-3', 'sub-3',\n+    'mul-2', 'div-2', 'fmod-2', 'remainder-2'\n+}\n+\n+\n def gen_jit_dispatch(declarations, out):\n     aten_decls = load_aten_declarations(declarations)\n     jit_decls = [d for d in aten_decls if is_jit_op(d)]\n \n     def is_tensor_arg(arg):\n         return arg['simple_type'] in {'Tensor', 'TensorList'}\n \n+    for decl in jit_decls:\n+        arguments = decl['arguments']\n+        name = decl['name']\n+        has_tensorlist = any(arg['simple_type'] == 'TensorList' for arg in arguments)\n+        has_scalar = any(arg['simple_type'] == 'Scalar' for arg in arguments)\n+        if has_tensorlist:\n+            continue\n+        if has_scalar:\n+            continue\n+\n     ops = {}\n     for decl in jit_decls:\n         arguments = decl['arguments']\n         name = decl['name']\n-        scalar_args = [arg for arg in arguments if not is_tensor_arg(arg)]\n         has_tensorlist = any(arg['simple_type'] == 'TensorList' for arg in arguments)\n \n-        # Descriptor is a unique identified for a particular overload of an op\n-        attr_names = sorted([arg['name'] for arg in scalar_args])\n-        num_inputs = len(arguments) - len(scalar_args) if not has_tensorlist else \"*\"\n-        descriptor = '-'.join([decl['name'], str(num_inputs)] + attr_names)\n-\n-        # All scalar args need to be assigned, so they can be captured by a lambda\n-        assignments = [ATTR_ASSIGNMENT.substitute(type=arg['simple_type'],\n-                                                  type_cast=TYPE_CASTS.get(arg['simple_type'], arg['simple_type']),\n-                                                  name=arg['name'],\n-                                                  method=ATTR_METHOD_MAP[arg['simple_type']])\n-                       for arg in scalar_args]\n-\n-        # Generate the actuall ATen call. This gets a bit tricky because of\n-        # TensorList arguments, and functions that are only available as methods.\n-        if 'namespace' in decl['method_of']:\n-            if has_tensorlist:\n-                if sum(map(is_tensor_arg, arguments)) != 1:\n-                    # TODO: support this\n-                    continue\n-                args = ['TensorTemporaryList(inputs)' if is_tensor_arg(arg) else arg['name']\n+        scalar_arg_idx = [i for i, arg in enumerate(arguments) if not is_tensor_arg(arg)]\n+        tensor_arg_idx = [i for i, arg in enumerate(arguments) if is_tensor_arg(arg)]\n+\n+        # Right now, we generate dispatch methods that either take all non-tensor arguments\n+        # as attributes, or don't use any attributes at all. In the future we might want to\n+        # have something in the middle too (might be useful for e.g. constant propagation\n+        # into attributes, as that would allow us to avoid reparsing tensors into scalar\n+        # args at every invocation).\n+        # NB: if there are no scalar args then both options on LHS are equivalent, so deduplicate them.\n+        scalar_arg_idx_iter = ([], scalar_arg_idx) if scalar_arg_idx else ([],)\n+        for pos_scalar_arg_idx in scalar_arg_idx_iter:\n+            pos_scalar_args = [arguments[i] for i in pos_scalar_arg_idx]\n+            kw_scalar_args = [arguments[i] for i in scalar_arg_idx\n+                              if i not in pos_scalar_arg_idx]\n+            # Descriptor is a unique identifier for a particular overload of an op\n+            attr_names = sorted([arg['name'] for arg in kw_scalar_args])\n+            num_inputs = len(tensor_arg_idx) + len(pos_scalar_arg_idx) if not has_tensorlist else '*'\n+            descriptor = '-'.join([decl['name'], str(num_inputs)] + attr_names)\n+\n+            kw_assignments = [KW_ASSIGNMENT.substitute(type_cast=TYPE_CASTS.get(arg['simple_type'], arg['simple_type']),\n+                                                       name=arg['name'],\n+                                                       method=ATTR_METHOD_MAP[arg['simple_type']])\n+                              for arg in kw_scalar_args]\n+            # TODO: if has_tensor_list then we need to count form the end!\n+            pos_scalar_arg_offsets = [i + len([None for t_idx in tensor_arg_idx if t_idx < s_idx])", "path": "tools/jit/gen_jit_dispatch.py", "position": null, "original_position": 106, "commit_id": "93f8a1fc4c78d6b999d43a85d98d0eb007016001", "original_commit_id": "f8fa87b4586261b389943c13c72c347046ced63c", "user": {"login": "zdevito", "id": 370202, "node_id": "MDQ6VXNlcjM3MDIwMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/370202?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zdevito", "html_url": "https://github.com/zdevito", "followers_url": "https://api.github.com/users/zdevito/followers", "following_url": "https://api.github.com/users/zdevito/following{/other_user}", "gists_url": "https://api.github.com/users/zdevito/gists{/gist_id}", "starred_url": "https://api.github.com/users/zdevito/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zdevito/subscriptions", "organizations_url": "https://api.github.com/users/zdevito/orgs", "repos_url": "https://api.github.com/users/zdevito/repos", "events_url": "https://api.github.com/users/zdevito/events{/privacy}", "received_events_url": "https://api.github.com/users/zdevito/received_events", "type": "User", "site_admin": false}, "body": "`[None for t_idx in tensor_arg_idx if t_idx < s_idx]` <--  This heavy use of array indexing is confusing. I can't really follow what is going on here. Can you find a clearer way of categorizing each input? I think a loop over all arguments, classifying them as tensor, position_scalar, or kwarg and adding entries into pos_assigns, kw_assignments, etc. would be easier to follow.", "created_at": "2018-02-23T01:49:56Z", "updated_at": "2018-11-23T15:39:55Z", "html_url": "https://github.com/pytorch/pytorch/pull/5298#discussion_r170147180", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/5298", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/170147180"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/5298#discussion_r170147180"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/5298"}}, "body_html": "<p><code>[None for t_idx in tensor_arg_idx if t_idx &lt; s_idx]</code> &lt;--  This heavy use of array indexing is confusing. I can't really follow what is going on here. Can you find a clearer way of categorizing each input? I think a loop over all arguments, classifying them as tensor, position_scalar, or kwarg and adding entries into pos_assigns, kw_assignments, etc. would be easier to follow.</p>", "body_text": "[None for t_idx in tensor_arg_idx if t_idx < s_idx] <--  This heavy use of array indexing is confusing. I can't really follow what is going on here. Can you find a clearer way of categorizing each input? I think a loop over all arguments, classifying them as tensor, position_scalar, or kwarg and adding entries into pos_assigns, kw_assignments, etc. would be easier to follow."}