{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/166802591", "pull_request_review_id": 94923620, "id": 166802591, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2NjgwMjU5MQ==", "diff_hunk": "@@ -1,46 +1,68 @@\n #pragma once\n \n-#include <mutex>\n-#include <memory>\n-#include <functional>\n-#include <ATen/ATen.h>\n-\n-#include \"torch/csrc/jit/tracer_state.h\"\n-#include \"torch/csrc/autograd/variable.h\"\n #include \"torch/csrc/autograd/variable_version.h\"\n-#include \"torch/csrc/Types.h\"\n \n-namespace torch { namespace autograd {\n+#include <ATen/Tensor.h>\n+\n+#include <cstdint>\n+#include <list>\n+#include <memory>\n \n+namespace torch {\n+namespace autograd {\n+class Variable;\n struct Function;\n+} // namespace autograd\n+namespace jit { namespace tracer {\n+struct ValueTracingStateElem;\n+using ValueTracingState = std::list<ValueTracingStateElem>;\n+}} // namespace jit::tracer\n+} // namespace torch\n \n-extern const char* ERR_BACKWARD_TWICE;\n+namespace torch { namespace autograd {\n \n-struct SavedVariable {\n-  SavedVariable()\n-    : data()\n-    , has_grad_fn(false)\n-    , version()\n-    , requires_grad(false)\n-    , expected_version(-1) {}\n+extern const char* ERR_BACKWARD_TWICE;\n \n+/// A snapshot of a variable at a certain version. A `SavedVariable` stores\n+/// enough information to reconstruct a variable from a certain point in time.\n+class SavedVariable {\n+ public:\n+  SavedVariable() = default;\n   SavedVariable(const Variable& variable, bool is_output);\n+  SavedVariable(SavedVariable&&) = default;\n+  SavedVariable& operator=(SavedVariable&&) = default;\n+\n+  // Must be defined externally to avoid it being inlined by the compiler,\n+  // which would require it to see the definition of ValueTracingState.\n+  ~SavedVariable();", "path": "torch/csrc/autograd/saved_variable.h", "position": null, "original_position": 54, "commit_id": "eba1e177795cddcd1971096dbccdcd81e0dcd773", "original_commit_id": "2770506f74aa5bd4f0a6c4a3dee541a6e8e4250c", "user": {"login": "goldsborough", "id": 6429851, "node_id": "MDQ6VXNlcjY0Mjk4NTE=", "avatar_url": "https://avatars3.githubusercontent.com/u/6429851?v=4", "gravatar_id": "", "url": "https://api.github.com/users/goldsborough", "html_url": "https://github.com/goldsborough", "followers_url": "https://api.github.com/users/goldsborough/followers", "following_url": "https://api.github.com/users/goldsborough/following{/other_user}", "gists_url": "https://api.github.com/users/goldsborough/gists{/gist_id}", "starred_url": "https://api.github.com/users/goldsborough/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/goldsborough/subscriptions", "organizations_url": "https://api.github.com/users/goldsborough/orgs", "repos_url": "https://api.github.com/users/goldsborough/repos", "events_url": "https://api.github.com/users/goldsborough/events{/privacy}", "received_events_url": "https://api.github.com/users/goldsborough/received_events", "type": "User", "site_admin": false}, "body": "I forward declared `ValueTracingStateElem` so we don't have to include `tracer_state.h` which includes the whole JIT IR. Holding a `shared_ptr`/`unique_ptr` to an incomplete type works only if the destructor is defined in the implementation file (where the definition of `ValueTracingStateElem` is available), as the inlined destructor will otherwise call the destructor of the smart pointer, which will require the size/definition of the forward declared class.", "created_at": "2018-02-08T00:40:13Z", "updated_at": "2018-11-23T15:39:21Z", "html_url": "https://github.com/pytorch/pytorch/pull/5127#discussion_r166802591", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/5127", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/166802591"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/5127#discussion_r166802591"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/5127"}}, "body_html": "<p>I forward declared <code>ValueTracingStateElem</code> so we don't have to include <code>tracer_state.h</code> which includes the whole JIT IR. Holding a <code>shared_ptr</code>/<code>unique_ptr</code> to an incomplete type works only if the destructor is defined in the implementation file (where the definition of <code>ValueTracingStateElem</code> is available), as the inlined destructor will otherwise call the destructor of the smart pointer, which will require the size/definition of the forward declared class.</p>", "body_text": "I forward declared ValueTracingStateElem so we don't have to include tracer_state.h which includes the whole JIT IR. Holding a shared_ptr/unique_ptr to an incomplete type works only if the destructor is defined in the implementation file (where the definition of ValueTracingStateElem is available), as the inlined destructor will otherwise call the destructor of the smart pointer, which will require the size/definition of the forward declared class.", "in_reply_to_id": 166791422}