{"url": "https://api.github.com/repos/pytorch/pytorch/issues/12460", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/12460/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/12460/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/12460/events", "html_url": "https://github.com/pytorch/pytorch/issues/12460", "id": 367905059, "node_id": "MDU6SXNzdWUzNjc5MDUwNTk=", "number": 12460, "title": "input_device, output_device, devices_used properties", "user": {"login": "tmbdev", "id": 333887, "node_id": "MDQ6VXNlcjMzMzg4Nw==", "avatar_url": "https://avatars0.githubusercontent.com/u/333887?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmbdev", "html_url": "https://github.com/tmbdev", "followers_url": "https://api.github.com/users/tmbdev/followers", "following_url": "https://api.github.com/users/tmbdev/following{/other_user}", "gists_url": "https://api.github.com/users/tmbdev/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmbdev/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmbdev/subscriptions", "organizations_url": "https://api.github.com/users/tmbdev/orgs", "repos_url": "https://api.github.com/users/tmbdev/repos", "events_url": "https://api.github.com/users/tmbdev/events{/privacy}", "received_events_url": "https://api.github.com/users/tmbdev/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2018-10-08T18:32:05Z", "updated_at": "2018-10-11T18:29:26Z", "closed_at": null, "author_association": "NONE", "body_html": "<h2><g-emoji class=\"g-emoji\" alias=\"rocket\" fallback-src=\"https://assets-cdn.github.com/images/icons/emoji/unicode/1f680.png\">\ud83d\ude80</g-emoji> Feature</h2>\n\n<p>People keep requesting a .device property on layers, and that's legitimately turned down with the response \"<em>Modules can hold parameters of different types on different devices, and so it\u2019s not always possible to unambiguously determine the device.</em>\" e.g., <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"364457748\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/12135\" data-hovercard-type=\"issue\" data-hovercard-url=\"/pytorch/pytorch/issues/12135/hovercard\" href=\"https://github.com/pytorch/pytorch/issues/12135\">#12135</a> A simple \".device\" property doesn't work well.</p>\n<p>In fact, I think what people really want is:</p>\n<ul>\n<li>Tell me where I can put inputs.</li>\n<li>Tell me where outputs are produced.</li>\n<li>Tell me what devices are actually used internally by this module.</li>\n<li>Convert this input into something you can use.</li>\n<li>Produce output in this preferred format.</li>\n</ul>\n<p>For example, just because a module stores parameters on a GPU doesn't mean it is limited to GPU inputs.</p>\n<h2>Pitch</h2>\n<p>I'd suggest thinking more about a simple API to query the relationship between modules and inputs. In principle, these can be pretty complex (\"if you give me an X I give you a Y\", etc.), but maybe just something for the common cases. E.g.,</p>\n<pre><code>m.input_devices() --&gt; [\"cuda:0\", \"cuda:*\", \"cpu\"]\nm.output_devices() --&gt; [\"cuda:0\"]\nm.required_devices() --&gt; [\"cuda:0\"]\n</code></pre>\n<p>By convention, input_devices()[0] would be the preferred device for inputs.</p>\n<p>A default implementation based on next(m.parameters()).device would return [device] for all three methods, and return [] if there are no parameters; this seems to reflect current practice and assumptions.</p>\n<p>Without an API, people are going to hardcode assumptions about the relationship between parameters, modules, and devices that are unnecessarily restrictive or simply wrong in general.</p>\n<p>In addition, forward and backward methods might get a preferred_device keyword argument that allows them to put results on the preferred output device.</p>", "body_text": "\ud83d\ude80 Feature\n\nPeople keep requesting a .device property on layers, and that's legitimately turned down with the response \"Modules can hold parameters of different types on different devices, and so it\u2019s not always possible to unambiguously determine the device.\" e.g., #12135 A simple \".device\" property doesn't work well.\nIn fact, I think what people really want is:\n\nTell me where I can put inputs.\nTell me where outputs are produced.\nTell me what devices are actually used internally by this module.\nConvert this input into something you can use.\nProduce output in this preferred format.\n\nFor example, just because a module stores parameters on a GPU doesn't mean it is limited to GPU inputs.\nPitch\nI'd suggest thinking more about a simple API to query the relationship between modules and inputs. In principle, these can be pretty complex (\"if you give me an X I give you a Y\", etc.), but maybe just something for the common cases. E.g.,\nm.input_devices() --> [\"cuda:0\", \"cuda:*\", \"cpu\"]\nm.output_devices() --> [\"cuda:0\"]\nm.required_devices() --> [\"cuda:0\"]\n\nBy convention, input_devices()[0] would be the preferred device for inputs.\nA default implementation based on next(m.parameters()).device would return [device] for all three methods, and return [] if there are no parameters; this seems to reflect current practice and assumptions.\nWithout an API, people are going to hardcode assumptions about the relationship between parameters, modules, and devices that are unnecessarily restrictive or simply wrong in general.\nIn addition, forward and backward methods might get a preferred_device keyword argument that allows them to put results on the preferred output device.", "body": "## \ud83d\ude80 Feature\r\n<!-- A clear and concise description of the feature proposal -->\r\n\r\nPeople keep requesting a .device property on layers, and that's legitimately turned down with the response \"_Modules can hold parameters of different types on different devices, and so it\u2019s not always possible to unambiguously determine the device._\" e.g., #12135 A simple \".device\" property doesn't work well.\r\n\r\nIn fact, I think what people really want is:\r\n\r\n- Tell me where I can put inputs.\r\n- Tell me where outputs are produced.\r\n- Tell me what devices are actually used internally by this module.\r\n- Convert this input into something you can use.\r\n- Produce output in this preferred format.\r\n\r\nFor example, just because a module stores parameters on a GPU doesn't mean it is limited to GPU inputs.\r\n\r\n## Pitch\r\n\r\nI'd suggest thinking more about a simple API to query the relationship between modules and inputs. In principle, these can be pretty complex (\"if you give me an X I give you a Y\", etc.), but maybe just something for the common cases. E.g.,\r\n\r\n    m.input_devices() --> [\"cuda:0\", \"cuda:*\", \"cpu\"]\r\n    m.output_devices() --> [\"cuda:0\"]\r\n    m.required_devices() --> [\"cuda:0\"]\r\n\r\nBy convention, input_devices()[0] would be the preferred device for inputs.\r\n\r\nA default implementation based on next(m.parameters()).device would return [device] for all three methods, and return [] if there are no parameters; this seems to reflect current practice and assumptions.\r\n\r\nWithout an API, people are going to hardcode assumptions about the relationship between parameters, modules, and devices that are unnecessarily restrictive or simply wrong in general.\r\n\r\nIn addition, forward and backward methods might get a preferred_device keyword argument that allows them to put results on the preferred output device."}