{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/213699745", "pull_request_review_id": 150587305, "id": 213699745, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMzY5OTc0NQ==", "diff_hunk": "@@ -0,0 +1,71 @@\n+#if USE_CPU_FUSER || USE_CUDA_FUSER\n+#pragma once\n+\n+#include \"torch/csrc/jit/fusers/fusion_interface.h\"\n+#include \"torch/csrc/jit/fusers/common/fusion_arg_spec.h\"\n+#include \"torch/csrc/jit/fusers/common/common_fusion_function.h\"\n+\n+#include \"torch/csrc/jit/stack.h\"\n+#include \"torch/csrc/jit/interpreter.h\"\n+#include \"torch/csrc/jit/ir.h\"\n+\n+#include \"ATen/ATen.h\"\n+\n+#include <memory>\n+#include <cstdint>\n+#include <vector>\n+#include <unordered_map>\n+\n+namespace torch { namespace jit {\n+\n+// FusionCompiler has very limited shape information available at the time getOrCompile\n+// is called, and this is why it can't really prepare the kernels at that time. Instead,\n+// it returns this object, which will take care of matching the run-time shapes to whatever\n+// kernels we have compiled already.\n+//\n+// Two configurations are considered eligible for the same fused kernel if:\n+//   - the shapes satisfy graph invariants for our fused code (e.g. that all intermediate shapes\n+//     are the same - see fusion_compiler.cpp for more details).\n+//   - their FusionArgSpecs compare equal\n+struct CommonFusionHandle : public FusionHandle {", "path": "torch/csrc/jit/fusers/common/common_fusion_handle.h", "position": null, "original_position": 30, "commit_id": "b8793a0e4816739a48d503f6388d92e61b8c83a1", "original_commit_id": "6fdaaa1f85d6e9ed7189419328ada48e773c6dec", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "body": "Why do we have both `CommonFusionHandle` and `FusionHandle`? What's uncommon about `FusionHandle`?\r\n\r\nAlso, \"FusionHandle\" is not a very informative name (it's a handle to what fusion? why do we need a handle to a fused kernel instead of using it directly as it's an internal struct??). It also hides the fact that calling `run` on this might be expensive in certain cases (which the `FusionKernelCache` name made clear).", "created_at": "2018-08-29T14:27:18Z", "updated_at": "2018-11-23T15:50:15Z", "html_url": "https://github.com/pytorch/pytorch/pull/10981#discussion_r213699745", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/10981", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/213699745"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/10981#discussion_r213699745"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/10981"}}, "body_html": "<p>Why do we have both <code>CommonFusionHandle</code> and <code>FusionHandle</code>? What's uncommon about <code>FusionHandle</code>?</p>\n<p>Also, \"FusionHandle\" is not a very informative name (it's a handle to what fusion? why do we need a handle to a fused kernel instead of using it directly as it's an internal struct??). It also hides the fact that calling <code>run</code> on this might be expensive in certain cases (which the <code>FusionKernelCache</code> name made clear).</p>", "body_text": "Why do we have both CommonFusionHandle and FusionHandle? What's uncommon about FusionHandle?\nAlso, \"FusionHandle\" is not a very informative name (it's a handle to what fusion? why do we need a handle to a fused kernel instead of using it directly as it's an internal struct??). It also hides the fact that calling run on this might be expensive in certain cases (which the FusionKernelCache name made clear)."}