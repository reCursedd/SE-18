{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/164896670", "pull_request_review_id": 92742713, "id": 164896670, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2NDg5NjY3MA==", "diff_hunk": "@@ -0,0 +1,203 @@\n+r\"\"\"\n+PyTorch provides two global :class:`ConstraintRegistry` objects that link\n+:class:`~torch.distributions.constraints.Constraint` objects to\n+:class:`~torch.distributions.transforms.Transform` objects. These objects both\n+input constraints and return transforms, but they have different guarantees on\n+bijectivity.\n+\n+1. ``biject_to(constraint)`` looks up a bijective\n+   :class:`~torch.distributions.transforms.Transform` from ``constraints.real``\n+   to the given ``constraint``. The returned transform is guaranteed to have\n+   ``.bijective = True`` and should implement ``.log_abs_det_jacobian()``.\n+2. ``transform_to(constraint)`` looks up a not-necessarily bijective\n+   :class:`~torch.distributions.transforms.Transform` from ``constraints.real``\n+   to the given ``constraint``. The returned transform is not guaranteed to\n+   implement ``.log_abs_det_jacobian()``.\n+\n+The ``transform_to()`` registry is useful for performing unconstrained\n+optimization on constrained parameters of probability distributions, which are\n+indicated by each distribution's ``.params`` dict. These transforms often\n+overparameterize a space in order to avoid rotation; they are thus more\n+suitable for coordinate-wise optimization algorithms like Adam::\n+\n+    loc = Variable(torch.zeros(100), requires_grad=True)\n+    unconstrained = Variable(torch.zeros(100), requires_grad=True)\n+    scale = transform_to(Normal.params['scale'])(unconstrained)\n+    loss = -Normal(loc, scale).log_prob(data).sum()\n+\n+The ``biject_to()`` registry is useful for Hamiltonian Monte Carlo, where\n+samples from a probability distribution with constrained ``.support`` are\n+propagated in an unconstrained space, and algorithms are typically rotation\n+invariant.::\n+\n+    dist = Exponential(rate)\n+    unconstrained = Variable(torch.zeros(100), requires_grad=True)\n+    sample = biject_to(dist.support)(unconstrained)\n+    potential_energy = -dist.log_prob(sample).sum()\n+\n+.. note::\n+\n+    An example where ``transform_to`` and ``biject_to`` differ is\n+    ``constraints.simplex``: ``transform_to(constraints.simplex)`` returns a\n+    :class:`~torch.distributions.transforms.BoltzmannTransform` that simply\n+    exponentiates and normalizes its inputs; this is a cheap and mostly\n+    coordinate-wise operation appropriate for algorithms like SVI. In\n+    contrast, ``biject_to(constraints.simplex)`` returns a\n+    :class:`~torch.distributions.transforms.StickBreakingTransform` that\n+    bijects its input down to a one-fewer-dimensional space; this a more\n+    expensive less numerically stable transform but is needed for algorithms\n+    like HMC.\n+\n+The ``biject_to`` and ``transform_to`` objects can be extended by user-defined\n+constraints and transforms using their ``.register()`` method either as a\n+function on singleton constraints::\n+\n+    transform_to.register(my_constraint, my_transform)\n+\n+or as a decorator on parameterized constraints::\n+\n+    @transform_to.register(MyConstraintClass)\n+    def my_factory(constraint):\n+        assert isinstance(constraint, MyConstraintClass)\n+        return MyTransform(constraint.param1, constraint.param2)\n+\n+You can create your own registry by creating a new :class:`ConstraintRegistry`\n+object.\n+\"\"\"\n+\n+from torch.distributions import constraints, transforms\n+\n+__all__ = [\n+    'ConstraintRegistry',\n+    'biject_to',\n+    'transform_to',\n+]\n+\n+\n+class ConstraintRegistry(object):\n+    \"\"\"\n+    Registry to link constraints to transforms.\n+    \"\"\"\n+    def __init__(self):\n+        self._registry = {}\n+\n+    def register(self, constraint, transform=None):\n+        \"\"\"\n+        Registers a :class:`~torch.distributions.constraints.Constraint`\n+        subclass or singleton object in this registry. Usage as decorator::\n+\n+            @my_registry.register(MyConstraintClass)", "path": "torch/distributions/constraint_registry.py", "position": 89, "original_position": 89, "commit_id": "31b221d85db0e51f5e3cdb122ff131096586878f", "original_commit_id": "31b221d85db0e51f5e3cdb122ff131096586878f", "user": {"login": "fritzo", "id": 648532, "node_id": "MDQ6VXNlcjY0ODUzMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/648532?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fritzo", "html_url": "https://github.com/fritzo", "followers_url": "https://api.github.com/users/fritzo/followers", "following_url": "https://api.github.com/users/fritzo/following{/other_user}", "gists_url": "https://api.github.com/users/fritzo/gists{/gist_id}", "starred_url": "https://api.github.com/users/fritzo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fritzo/subscriptions", "organizations_url": "https://api.github.com/users/fritzo/orgs", "repos_url": "https://api.github.com/users/fritzo/repos", "events_url": "https://api.github.com/users/fritzo/events{/privacy}", "received_events_url": "https://api.github.com/users/fritzo/received_events", "type": "User", "site_admin": false}, "body": "I don't know. I needed two, and @martinjankowiak noted that it is useful to tweak which transforms are used for each constraint. One plausible application is to implement a registry `transform_from_unit_interval_to()` whereas the builtin registries both transform from `constraints.real` to various other constraints.\r\n\r\nBut I'm ok making this private if you'd prefer a narrower interface.", "created_at": "2018-01-30T22:18:09Z", "updated_at": "2018-11-23T15:38:45Z", "html_url": "https://github.com/pytorch/pytorch/pull/4902#discussion_r164896670", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/4902", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/164896670"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/4902#discussion_r164896670"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/4902"}}, "body_html": "<p>I don't know. I needed two, and <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=22105218\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/martinjankowiak\">@martinjankowiak</a> noted that it is useful to tweak which transforms are used for each constraint. One plausible application is to implement a registry <code>transform_from_unit_interval_to()</code> whereas the builtin registries both transform from <code>constraints.real</code> to various other constraints.</p>\n<p>But I'm ok making this private if you'd prefer a narrower interface.</p>", "body_text": "I don't know. I needed two, and @martinjankowiak noted that it is useful to tweak which transforms are used for each constraint. One plausible application is to implement a registry transform_from_unit_interval_to() whereas the builtin registries both transform from constraints.real to various other constraints.\nBut I'm ok making this private if you'd prefer a narrower interface.", "in_reply_to_id": 164894324}