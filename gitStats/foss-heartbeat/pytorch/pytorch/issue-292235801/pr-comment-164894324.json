{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/164894324", "pull_request_review_id": 92739930, "id": 164894324, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2NDg5NDMyNA==", "diff_hunk": "@@ -0,0 +1,203 @@\n+r\"\"\"\n+PyTorch provides two global :class:`ConstraintRegistry` objects that link\n+:class:`~torch.distributions.constraints.Constraint` objects to\n+:class:`~torch.distributions.transforms.Transform` objects. These objects both\n+input constraints and return transforms, but they have different guarantees on\n+bijectivity.\n+\n+1. ``biject_to(constraint)`` looks up a bijective\n+   :class:`~torch.distributions.transforms.Transform` from ``constraints.real``\n+   to the given ``constraint``. The returned transform is guaranteed to have\n+   ``.bijective = True`` and should implement ``.log_abs_det_jacobian()``.\n+2. ``transform_to(constraint)`` looks up a not-necessarily bijective\n+   :class:`~torch.distributions.transforms.Transform` from ``constraints.real``\n+   to the given ``constraint``. The returned transform is not guaranteed to\n+   implement ``.log_abs_det_jacobian()``.\n+\n+The ``transform_to()`` registry is useful for performing unconstrained\n+optimization on constrained parameters of probability distributions, which are\n+indicated by each distribution's ``.params`` dict. These transforms often\n+overparameterize a space in order to avoid rotation; they are thus more\n+suitable for coordinate-wise optimization algorithms like Adam::\n+\n+    loc = Variable(torch.zeros(100), requires_grad=True)\n+    unconstrained = Variable(torch.zeros(100), requires_grad=True)\n+    scale = transform_to(Normal.params['scale'])(unconstrained)\n+    loss = -Normal(loc, scale).log_prob(data).sum()\n+\n+The ``biject_to()`` registry is useful for Hamiltonian Monte Carlo, where\n+samples from a probability distribution with constrained ``.support`` are\n+propagated in an unconstrained space, and algorithms are typically rotation\n+invariant.::\n+\n+    dist = Exponential(rate)\n+    unconstrained = Variable(torch.zeros(100), requires_grad=True)\n+    sample = biject_to(dist.support)(unconstrained)\n+    potential_energy = -dist.log_prob(sample).sum()\n+\n+.. note::\n+\n+    An example where ``transform_to`` and ``biject_to`` differ is\n+    ``constraints.simplex``: ``transform_to(constraints.simplex)`` returns a\n+    :class:`~torch.distributions.transforms.BoltzmannTransform` that simply\n+    exponentiates and normalizes its inputs; this is a cheap and mostly\n+    coordinate-wise operation appropriate for algorithms like SVI. In\n+    contrast, ``biject_to(constraints.simplex)`` returns a\n+    :class:`~torch.distributions.transforms.StickBreakingTransform` that\n+    bijects its input down to a one-fewer-dimensional space; this a more\n+    expensive less numerically stable transform but is needed for algorithms\n+    like HMC.\n+\n+The ``biject_to`` and ``transform_to`` objects can be extended by user-defined\n+constraints and transforms using their ``.register()`` method either as a\n+function on singleton constraints::\n+\n+    transform_to.register(my_constraint, my_transform)\n+\n+or as a decorator on parameterized constraints::\n+\n+    @transform_to.register(MyConstraintClass)\n+    def my_factory(constraint):\n+        assert isinstance(constraint, MyConstraintClass)\n+        return MyTransform(constraint.param1, constraint.param2)\n+\n+You can create your own registry by creating a new :class:`ConstraintRegistry`\n+object.\n+\"\"\"\n+\n+from torch.distributions import constraints, transforms\n+\n+__all__ = [\n+    'ConstraintRegistry',\n+    'biject_to',\n+    'transform_to',\n+]\n+\n+\n+class ConstraintRegistry(object):\n+    \"\"\"\n+    Registry to link constraints to transforms.\n+    \"\"\"\n+    def __init__(self):\n+        self._registry = {}\n+\n+    def register(self, constraint, transform=None):\n+        \"\"\"\n+        Registers a :class:`~torch.distributions.constraints.Constraint`\n+        subclass or singleton object in this registry. Usage as decorator::\n+\n+            @my_registry.register(MyConstraintClass)", "path": "torch/distributions/constraint_registry.py", "position": 89, "original_position": 89, "commit_id": "31b221d85db0e51f5e3cdb122ff131096586878f", "original_commit_id": "31b221d85db0e51f5e3cdb122ff131096586878f", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "body": "Is it expected that people will be creating more registries?", "created_at": "2018-01-30T22:08:12Z", "updated_at": "2018-11-23T15:38:45Z", "html_url": "https://github.com/pytorch/pytorch/pull/4902#discussion_r164894324", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/4902", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/164894324"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/4902#discussion_r164894324"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/4902"}}, "body_html": "<p>Is it expected that people will be creating more registries?</p>", "body_text": "Is it expected that people will be creating more registries?"}