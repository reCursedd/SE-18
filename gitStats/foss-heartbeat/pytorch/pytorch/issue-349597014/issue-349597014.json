{"url": "https://api.github.com/repos/pytorch/pytorch/issues/10407", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/10407/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/10407/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/10407/events", "html_url": "https://github.com/pytorch/pytorch/pull/10407", "id": 349597014, "node_id": "MDExOlB1bGxSZXF1ZXN0MjA3Njc1NTYy", "number": 10407, "title": "Don't call into Python during Storage destruction.", "user": {"login": "colesbury", "id": 655866, "node_id": "MDQ6VXNlcjY1NTg2Ng==", "avatar_url": "https://avatars1.githubusercontent.com/u/655866?v=4", "gravatar_id": "", "url": "https://api.github.com/users/colesbury", "html_url": "https://github.com/colesbury", "followers_url": "https://api.github.com/users/colesbury/followers", "following_url": "https://api.github.com/users/colesbury/following{/other_user}", "gists_url": "https://api.github.com/users/colesbury/gists{/gist_id}", "starred_url": "https://api.github.com/users/colesbury/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/colesbury/subscriptions", "organizations_url": "https://api.github.com/users/colesbury/orgs", "repos_url": "https://api.github.com/users/colesbury/repos", "events_url": "https://api.github.com/users/colesbury/events{/privacy}", "received_events_url": "https://api.github.com/users/colesbury/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2018-08-10T17:28:03Z", "updated_at": "2018-08-13T18:21:35Z", "closed_at": "2018-08-13T18:21:35Z", "author_association": "MEMBER", "pull_request": {"url": "https://api.github.com/repos/pytorch/pytorch/pulls/10407", "html_url": "https://github.com/pytorch/pytorch/pull/10407", "diff_url": "https://github.com/pytorch/pytorch/pull/10407.diff", "patch_url": "https://github.com/pytorch/pytorch/pull/10407.patch"}, "body_html": "<pre><code>This removes PyObjectFinalizer. We were seeing SIGSEGV at exit in some\nprograms that use multiprocessing. The backtrace pointed to\nStorageRef.__del__ being called from subtype_dealloc. My guess is that\nthe Python interpreter was shutdown before all C++ Storage objects were\ndeallocated. Deallocating the C++ Storage called the finalizer which\ncalled back into Python after it was no longer safe to do so.\n\nThis avoids a callback from C++ into Python during Storage finalization.\nInstead, dead Storage objects (expired weak references) are collected\nperiodically when shared_cache exceeds a limit. The limit is scaled with\n2x the number of live references, which places an upper bound on the\namount of extra memory held by dead Storage objects. In practice, this\nshould be very small.\n</code></pre>", "body_text": "This removes PyObjectFinalizer. We were seeing SIGSEGV at exit in some\nprograms that use multiprocessing. The backtrace pointed to\nStorageRef.__del__ being called from subtype_dealloc. My guess is that\nthe Python interpreter was shutdown before all C++ Storage objects were\ndeallocated. Deallocating the C++ Storage called the finalizer which\ncalled back into Python after it was no longer safe to do so.\n\nThis avoids a callback from C++ into Python during Storage finalization.\nInstead, dead Storage objects (expired weak references) are collected\nperiodically when shared_cache exceeds a limit. The limit is scaled with\n2x the number of live references, which places an upper bound on the\namount of extra memory held by dead Storage objects. In practice, this\nshould be very small.", "body": "```\r\nThis removes PyObjectFinalizer. We were seeing SIGSEGV at exit in some\r\nprograms that use multiprocessing. The backtrace pointed to\r\nStorageRef.__del__ being called from subtype_dealloc. My guess is that\r\nthe Python interpreter was shutdown before all C++ Storage objects were\r\ndeallocated. Deallocating the C++ Storage called the finalizer which\r\ncalled back into Python after it was no longer safe to do so.\r\n\r\nThis avoids a callback from C++ into Python during Storage finalization.\r\nInstead, dead Storage objects (expired weak references) are collected\r\nperiodically when shared_cache exceeds a limit. The limit is scaled with\r\n2x the number of live references, which places an upper bound on the\r\namount of extra memory held by dead Storage objects. In practice, this\r\nshould be very small.\r\n```"}