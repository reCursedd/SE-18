{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/355653171", "html_url": "https://github.com/pytorch/pytorch/pull/4216#issuecomment-355653171", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/4216", "id": 355653171, "node_id": "MDEyOklzc3VlQ29tbWVudDM1NTY1MzE3MQ==", "user": {"login": "colesbury", "id": 655866, "node_id": "MDQ6VXNlcjY1NTg2Ng==", "avatar_url": "https://avatars1.githubusercontent.com/u/655866?v=4", "gravatar_id": "", "url": "https://api.github.com/users/colesbury", "html_url": "https://github.com/colesbury", "followers_url": "https://api.github.com/users/colesbury/followers", "following_url": "https://api.github.com/users/colesbury/following{/other_user}", "gists_url": "https://api.github.com/users/colesbury/gists{/gist_id}", "starred_url": "https://api.github.com/users/colesbury/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/colesbury/subscriptions", "organizations_url": "https://api.github.com/users/colesbury/orgs", "repos_url": "https://api.github.com/users/colesbury/repos", "events_url": "https://api.github.com/users/colesbury/events{/privacy}", "received_events_url": "https://api.github.com/users/colesbury/received_events", "type": "User", "site_admin": false}, "created_at": "2018-01-05T20:09:36Z", "updated_at": "2018-01-05T20:09:36Z", "author_association": "MEMBER", "body_html": "<p>I really like that we're speeding up DataParallel. I'm a bit concerned about the caching strategy. We're adding state to DataParallel, but still trying to pretend it's stateless.</p>\n<p>Is there a way to speed up replicate without adding hidden state (the caching)? For example, we're already special casing <code>_parameters</code>, <code>_buffers</code> and <code>_modules</code>. Can we put a parent class of <code>nn.Module</code> in C++ that handles these three attributes? That would give use quick access to parameters and buffers for broadcasting. Replicate could then be light-weight: create a sort of proxy module that has its own <code>_parameters</code>, <code>_buffers</code>, and <code>_modules</code> but shares <code>__dict__</code>. Sub-modules could be lazily created on access to minimize the overhead at the start of a forward pass.</p>", "body_text": "I really like that we're speeding up DataParallel. I'm a bit concerned about the caching strategy. We're adding state to DataParallel, but still trying to pretend it's stateless.\nIs there a way to speed up replicate without adding hidden state (the caching)? For example, we're already special casing _parameters, _buffers and _modules. Can we put a parent class of nn.Module in C++ that handles these three attributes? That would give use quick access to parameters and buffers for broadcasting. Replicate could then be light-weight: create a sort of proxy module that has its own _parameters, _buffers, and _modules but shares __dict__. Sub-modules could be lazily created on access to minimize the overhead at the start of a forward pass.", "body": "I really like that we're speeding up DataParallel. I'm a bit concerned about the caching strategy. We're adding state to DataParallel, but still trying to pretend it's stateless.\r\n\r\nIs there a way to speed up replicate without adding hidden state (the caching)? For example, we're already special casing `_parameters`, `_buffers` and `_modules`. Can we put a parent class of `nn.Module` in C++ that handles these three attributes? That would give use quick access to parameters and buffers for broadcasting. Replicate could then be light-weight: create a sort of proxy module that has its own `_parameters`, `_buffers`, and `_modules` but shares `__dict__`. Sub-modules could be lazily created on access to minimize the overhead at the start of a forward pass.\r\n\r\n"}