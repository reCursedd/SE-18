{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/340852205", "html_url": "https://github.com/pytorch/pytorch/issues/3387#issuecomment-340852205", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/3387", "id": 340852205, "node_id": "MDEyOklzc3VlQ29tbWVudDM0MDg1MjIwNQ==", "user": {"login": "fmassa", "id": 9110200, "node_id": "MDQ6VXNlcjkxMTAyMDA=", "avatar_url": "https://avatars2.githubusercontent.com/u/9110200?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fmassa", "html_url": "https://github.com/fmassa", "followers_url": "https://api.github.com/users/fmassa/followers", "following_url": "https://api.github.com/users/fmassa/following{/other_user}", "gists_url": "https://api.github.com/users/fmassa/gists{/gist_id}", "starred_url": "https://api.github.com/users/fmassa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fmassa/subscriptions", "organizations_url": "https://api.github.com/users/fmassa/orgs", "repos_url": "https://api.github.com/users/fmassa/repos", "events_url": "https://api.github.com/users/fmassa/events{/privacy}", "received_events_url": "https://api.github.com/users/fmassa/received_events", "type": "User", "site_admin": false}, "created_at": "2017-10-31T18:07:56Z", "updated_at": "2017-10-31T18:07:56Z", "author_association": "MEMBER", "body_html": "<p>For your specific case, it seems that you can extract all the patches using unfold, call <code>.contiguous()</code>, and then zero out the indices that don't satisfy the condition.<br>\nPseudo-code (untested):</p>\n<div class=\"highlight highlight-source-python\"><pre>input_windows <span class=\"pl-k\">=</span> <span class=\"pl-c1\">input</span>.unfold(<span class=\"pl-c1\">2</span>, kh, dh).unfold(<span class=\"pl-c1\">3</span>, kw, dw)\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> view the windows as (kh * kw)</span>\ninput_windows <span class=\"pl-k\">=</span> input_windows.contiguous().view(<span class=\"pl-k\">*</span>input_windows.size()[:<span class=\"pl-k\">-</span><span class=\"pl-c1\">2</span>], <span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>)\ncondition_windows <span class=\"pl-k\">=</span> input_windows.mean(<span class=\"pl-c1\">4</span>) <span class=\"pl-k\">&lt;=</span> threshold\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> mask the inputs you don't want</span>\ninput_windows[condition_windows[<span class=\"pl-c1\">...</span>, <span class=\"pl-c1\">None</span>].expand_as(input_windows)] <span class=\"pl-k\">=</span> <span class=\"pl-c1\">0</span></pre></div>", "body_text": "For your specific case, it seems that you can extract all the patches using unfold, call .contiguous(), and then zero out the indices that don't satisfy the condition.\nPseudo-code (untested):\ninput_windows = input.unfold(2, kh, dh).unfold(3, kw, dw)\n# view the windows as (kh * kw)\ninput_windows = input_windows.contiguous().view(*input_windows.size()[:-2], -1)\ncondition_windows = input_windows.mean(4) <= threshold\n# mask the inputs you don't want\ninput_windows[condition_windows[..., None].expand_as(input_windows)] = 0", "body": "For your specific case, it seems that you can extract all the patches using unfold, call `.contiguous()`, and then zero out the indices that don't satisfy the condition.\r\nPseudo-code (untested):\r\n```python\r\ninput_windows = input.unfold(2, kh, dh).unfold(3, kw, dw)\r\n# view the windows as (kh * kw)\r\ninput_windows = input_windows.contiguous().view(*input_windows.size()[:-2], -1)\r\ncondition_windows = input_windows.mean(4) <= threshold\r\n# mask the inputs you don't want\r\ninput_windows[condition_windows[..., None].expand_as(input_windows)] = 0\r\n```"}