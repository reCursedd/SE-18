{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/340817487", "html_url": "https://github.com/pytorch/pytorch/issues/3387#issuecomment-340817487", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/3387", "id": 340817487, "node_id": "MDEyOklzc3VlQ29tbWVudDM0MDgxNzQ4Nw==", "user": {"login": "LambdaWill", "id": 26055298, "node_id": "MDQ6VXNlcjI2MDU1Mjk4", "avatar_url": "https://avatars3.githubusercontent.com/u/26055298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LambdaWill", "html_url": "https://github.com/LambdaWill", "followers_url": "https://api.github.com/users/LambdaWill/followers", "following_url": "https://api.github.com/users/LambdaWill/following{/other_user}", "gists_url": "https://api.github.com/users/LambdaWill/gists{/gist_id}", "starred_url": "https://api.github.com/users/LambdaWill/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LambdaWill/subscriptions", "organizations_url": "https://api.github.com/users/LambdaWill/orgs", "repos_url": "https://api.github.com/users/LambdaWill/repos", "events_url": "https://api.github.com/users/LambdaWill/events{/privacy}", "received_events_url": "https://api.github.com/users/LambdaWill/received_events", "type": "User", "site_admin": false}, "created_at": "2017-10-31T16:21:58Z", "updated_at": "2017-10-31T16:21:58Z", "author_association": "NONE", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=9110200\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/fmassa\">@fmassa</a> Wow, I have managed to work it out according to your snippet.<br>\nBy the way, I wonder how to handle such situation.</p>\n<div class=\"highlight highlight-source-lua\"><pre><span class=\"pl-k\">function</span> <span class=\"pl-en\">module._extract_patches</span>(<span class=\"pl-smi\">img</span>, <span class=\"pl-smi\">patch_size</span>, <span class=\"pl-smi\">stride</span>, <span class=\"pl-smi\">threshold</span>)\n    <span class=\"pl-k\">local</span> nDim <span class=\"pl-k\">=</span> <span class=\"pl-c1\">3</span>\n    <span class=\"pl-c1\">assert</span>(img:<span class=\"pl-c1\">nDimension</span>() <span class=\"pl-k\">==</span> nDim, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>image must be of dimension 3.<span class=\"pl-pds\">'</span></span>)\n    <span class=\"pl-k\">local</span> C, H, W <span class=\"pl-k\">=</span> img:<span class=\"pl-c1\">size</span>(nDim<span class=\"pl-k\">-</span><span class=\"pl-c1\">2</span>), img:<span class=\"pl-c1\">size</span>(nDim<span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>), img:<span class=\"pl-c1\">size</span>(nDim)\n    <span class=\"pl-k\">local</span> nH <span class=\"pl-k\">=</span> <span class=\"pl-c1\">math.floor</span>( (H <span class=\"pl-k\">-</span> patch_size)<span class=\"pl-k\">/</span>stride <span class=\"pl-k\">+</span> <span class=\"pl-c1\">1</span>)\n    <span class=\"pl-k\">local</span> nW <span class=\"pl-k\">=</span> <span class=\"pl-c1\">math.floor</span>( (W <span class=\"pl-k\">-</span> patch_size)<span class=\"pl-k\">/</span>stride <span class=\"pl-k\">+</span> <span class=\"pl-c1\">1</span>)\n\n    <span class=\"pl-c\"><span class=\"pl-c\">--</span> extract patches</span>\n    <span class=\"pl-k\">local</span> patches <span class=\"pl-k\">=</span> torch.<span class=\"pl-c1\">Tensor</span>(nH<span class=\"pl-k\">*</span>nW, C, patch_size, patch_size):<span class=\"pl-c1\">typeAs</span>(img):<span class=\"pl-c1\">zero</span>()\n    <span class=\"pl-k\">for</span> i<span class=\"pl-k\">=</span><span class=\"pl-c1\">1</span>,nH<span class=\"pl-k\">*</span>nW <span class=\"pl-k\">do</span>\n        <span class=\"pl-k\">local</span> h <span class=\"pl-k\">=</span> <span class=\"pl-c1\">math.floor</span>((i<span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>)<span class=\"pl-k\">/</span>nW)  <span class=\"pl-c\"><span class=\"pl-c\">--</span> zero-index</span>\n        <span class=\"pl-k\">local</span> w <span class=\"pl-k\">=</span> <span class=\"pl-c1\">math.floor</span>((i<span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>)<span class=\"pl-k\">%</span>nW)  <span class=\"pl-c\"><span class=\"pl-c\">--</span> zero-index</span>\n\n<span class=\"pl-c\"><span class=\"pl-c\">--</span>--------- Add a condition here ---------------------</span>\n        <span class=\"pl-k\">local</span> tmp_img <span class=\"pl-k\">=</span> img[{{},\n        {<span class=\"pl-c1\">1</span> <span class=\"pl-k\">+</span> h<span class=\"pl-k\">*</span>stride, <span class=\"pl-c1\">1</span> <span class=\"pl-k\">+</span> h<span class=\"pl-k\">*</span>stride <span class=\"pl-k\">+</span> patch_size<span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>},\n        {<span class=\"pl-c1\">1</span> <span class=\"pl-k\">+</span> w<span class=\"pl-k\">*</span>stride, <span class=\"pl-c1\">1</span> <span class=\"pl-k\">+</span> w<span class=\"pl-k\">*</span>stride <span class=\"pl-k\">+</span> patch_size<span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>}\n        }]\n        <span class=\"pl-k\">if</span> torch.<span class=\"pl-c1\">mean</span>(tmp_img) <span class=\"pl-k\">&gt;</span> threshold <span class=\"pl-k\">then</span>\n               patches[i] <span class=\"pl-k\">=</span> tmp_img\n        <span class=\"pl-k\">end</span>\n    <span class=\"pl-k\">end</span>\n\n    <span class=\"pl-k\">return</span> patches\n<span class=\"pl-k\">end</span></pre></div>", "body_text": "@fmassa Wow, I have managed to work it out according to your snippet.\nBy the way, I wonder how to handle such situation.\nfunction module._extract_patches(img, patch_size, stride, threshold)\n    local nDim = 3\n    assert(img:nDimension() == nDim, 'image must be of dimension 3.')\n    local C, H, W = img:size(nDim-2), img:size(nDim-1), img:size(nDim)\n    local nH = math.floor( (H - patch_size)/stride + 1)\n    local nW = math.floor( (W - patch_size)/stride + 1)\n\n    -- extract patches\n    local patches = torch.Tensor(nH*nW, C, patch_size, patch_size):typeAs(img):zero()\n    for i=1,nH*nW do\n        local h = math.floor((i-1)/nW)  -- zero-index\n        local w = math.floor((i-1)%nW)  -- zero-index\n\n----------- Add a condition here ---------------------\n        local tmp_img = img[{{},\n        {1 + h*stride, 1 + h*stride + patch_size-1},\n        {1 + w*stride, 1 + w*stride + patch_size-1}\n        }]\n        if torch.mean(tmp_img) > threshold then\n               patches[i] = tmp_img\n        end\n    end\n\n    return patches\nend", "body": "@fmassa Wow, I have managed to work it out according to your snippet. \r\nBy the way, I wonder how to handle such situation.\r\n```lua\r\nfunction module._extract_patches(img, patch_size, stride, threshold)\r\n    local nDim = 3\r\n    assert(img:nDimension() == nDim, 'image must be of dimension 3.')\r\n    local C, H, W = img:size(nDim-2), img:size(nDim-1), img:size(nDim)\r\n    local nH = math.floor( (H - patch_size)/stride + 1)\r\n    local nW = math.floor( (W - patch_size)/stride + 1)\r\n\r\n    -- extract patches\r\n    local patches = torch.Tensor(nH*nW, C, patch_size, patch_size):typeAs(img):zero()\r\n    for i=1,nH*nW do\r\n        local h = math.floor((i-1)/nW)  -- zero-index\r\n        local w = math.floor((i-1)%nW)  -- zero-index\r\n\r\n----------- Add a condition here ---------------------\r\n        local tmp_img = img[{{},\r\n        {1 + h*stride, 1 + h*stride + patch_size-1},\r\n        {1 + w*stride, 1 + w*stride + patch_size-1}\r\n        }]\r\n        if torch.mean(tmp_img) > threshold then\r\n               patches[i] = tmp_img\r\n        end\r\n    end\r\n\r\n    return patches\r\nend\r\n```"}