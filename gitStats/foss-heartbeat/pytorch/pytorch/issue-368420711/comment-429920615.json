{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/429920615", "html_url": "https://github.com/pytorch/pytorch/issues/12506#issuecomment-429920615", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/12506", "id": 429920615, "node_id": "MDEyOklzc3VlQ29tbWVudDQyOTkyMDYxNQ==", "user": {"login": "goldsborough", "id": 6429851, "node_id": "MDQ6VXNlcjY0Mjk4NTE=", "avatar_url": "https://avatars3.githubusercontent.com/u/6429851?v=4", "gravatar_id": "", "url": "https://api.github.com/users/goldsborough", "html_url": "https://github.com/goldsborough", "followers_url": "https://api.github.com/users/goldsborough/followers", "following_url": "https://api.github.com/users/goldsborough/following{/other_user}", "gists_url": "https://api.github.com/users/goldsborough/gists{/gist_id}", "starred_url": "https://api.github.com/users/goldsborough/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/goldsborough/subscriptions", "organizations_url": "https://api.github.com/users/goldsborough/orgs", "repos_url": "https://api.github.com/users/goldsborough/repos", "events_url": "https://api.github.com/users/goldsborough/events{/privacy}", "received_events_url": "https://api.github.com/users/goldsborough/received_events", "type": "User", "site_admin": false}, "created_at": "2018-10-15T16:23:19Z", "updated_at": "2018-10-15T16:23:19Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=1892175\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/zeryx\">@zeryx</a> I think you have two options:</p>\n<ol>\n<li>\n<p>If you can do all modifications on the matrix/tensor in-place, you could call <code>from_blob</code> without cloning, mutate the tensor in-place, and since the data would be shared between the tensor and the <code>cv::Mat</code> the mutations would be reflected in the original <code>cv::Mat</code>, which you could then use for further processing/visualization. E.g.</p>\n<div class=\"highlight highlight-source-c++\"><pre> <span class=\"pl-k\">void</span> <span class=\"pl-en\">process</span>(cv::Mat mat) {\n     at::Tensor tensor = <span class=\"pl-c1\">torch::from_blob</span>(...); <span class=\"pl-c\"><span class=\"pl-c\">//</span> No clone, just a \"view\" of the mat as a tensor</span>\n     tensor.<span class=\"pl-c1\">mul_</span>(<span class=\"pl-c1\">2</span>); <span class=\"pl-c\"><span class=\"pl-c\">//</span> The multiplication by two is visible in both the tensor and the original `mat`</span>\n     <span class=\"pl-c1\">visualize</span>(mat); <span class=\"pl-c\"><span class=\"pl-c\">//</span> Since we mutated the underlying data, we can just use the original `mat`</span>\n }</pre></div>\n<p>However, if you are calling a <code>ScriptModule</code> like you do in your example, that mutation will likely not be in-place. As in, the result of <code>module-&gt;forward(...)</code> will likely be a new tensor pointing at new memory, not associated with any <code>cv::Mat</code> (yet). So this does not apply.</p>\n</li>\n<li>\n<p>If the end result of your processing is a brand new tensor, you likely want to convert it back into a <code>cv::Mat</code>. For this you can use <a href=\"https://docs.opencv.org/trunk/d3/d63/classcv_1_1Mat.html#a922de793eabcec705b3579c5f95a643e\" rel=\"nofollow\">this constructor</a> from OpenCV, like the <code>cv::Mat warp(3, 3, CV_32FC1, w.data&lt;float&gt;());</code> I used above. In fact, if you read through the \"Detailed Description\" section, you'll notice that their data model is the same as for our tensors: creating a <code>cv::Mat</code> from some data blob only creates a view, and you can use the <a href=\"https://docs.opencv.org/trunk/d3/d63/classcv_1_1Mat.html#adff2ea98da45eae0833e73582dd4a660\" rel=\"nofollow\"><code>clone()</code></a> method to create a deep-copy of the data.</p>\n</li>\n</ol>\n<p>All of that said, I think the path for you is:</p>\n<ol>\n<li>You start out with a <code>cv::Mat mat</code>,</li>\n<li>If all you're doing is passing the Mat to <code>module-&gt;forward</code> immediately, you can create a tensor from it without copying, i.e. <code>tensor = from_blob(mat.ptr&lt;float&gt;(), sizes)</code> without cloning. For this make sure the original <code>mat</code> is still alive while you call <code>module-&gt;forward</code>.</li>\n<li>Get a new tensor when invoking the module: <code>auto new_tensor = module-&gt;forward(tensor);</code></li>\n<li>Then create a <code>cv::Mat</code> from the resulting tensor: <code>cv::Mat output(sizes, CV_32FC1, new_tensor.data&lt;float&gt;())</code>. At this point the <code>output</code> mat will be pointing at data owned by the <code>new_tensor</code>. If you simply want to visualize it straight away, no need to copy the data into the <code>Mat</code>.</li>\n<li>If you want to return the <code>Mat</code> from a function or otherwise store it, call <code>clone()</code> on the <code>Mat</code> to take ownership of the data by copying it.</li>\n</ol>\n<p>Notice that there is a case where no additional copies are incurred at all, which is when you're only converting to a tensor to call <code>module-&gt;forward</code>, and then only converting back to a <code>Mat</code> to visualize it. Just be aware of how the lifetimes are bound to each other and when you need to call <code>clone()</code>. Hope this helps.</p>", "body_text": "@zeryx I think you have two options:\n\n\nIf you can do all modifications on the matrix/tensor in-place, you could call from_blob without cloning, mutate the tensor in-place, and since the data would be shared between the tensor and the cv::Mat the mutations would be reflected in the original cv::Mat, which you could then use for further processing/visualization. E.g.\n void process(cv::Mat mat) {\n     at::Tensor tensor = torch::from_blob(...); // No clone, just a \"view\" of the mat as a tensor\n     tensor.mul_(2); // The multiplication by two is visible in both the tensor and the original `mat`\n     visualize(mat); // Since we mutated the underlying data, we can just use the original `mat`\n }\nHowever, if you are calling a ScriptModule like you do in your example, that mutation will likely not be in-place. As in, the result of module->forward(...) will likely be a new tensor pointing at new memory, not associated with any cv::Mat (yet). So this does not apply.\n\n\nIf the end result of your processing is a brand new tensor, you likely want to convert it back into a cv::Mat. For this you can use this constructor from OpenCV, like the cv::Mat warp(3, 3, CV_32FC1, w.data<float>()); I used above. In fact, if you read through the \"Detailed Description\" section, you'll notice that their data model is the same as for our tensors: creating a cv::Mat from some data blob only creates a view, and you can use the clone() method to create a deep-copy of the data.\n\n\nAll of that said, I think the path for you is:\n\nYou start out with a cv::Mat mat,\nIf all you're doing is passing the Mat to module->forward immediately, you can create a tensor from it without copying, i.e. tensor = from_blob(mat.ptr<float>(), sizes) without cloning. For this make sure the original mat is still alive while you call module->forward.\nGet a new tensor when invoking the module: auto new_tensor = module->forward(tensor);\nThen create a cv::Mat from the resulting tensor: cv::Mat output(sizes, CV_32FC1, new_tensor.data<float>()). At this point the output mat will be pointing at data owned by the new_tensor. If you simply want to visualize it straight away, no need to copy the data into the Mat.\nIf you want to return the Mat from a function or otherwise store it, call clone() on the Mat to take ownership of the data by copying it.\n\nNotice that there is a case where no additional copies are incurred at all, which is when you're only converting to a tensor to call module->forward, and then only converting back to a Mat to visualize it. Just be aware of how the lifetimes are bound to each other and when you need to call clone(). Hope this helps.", "body": "@zeryx I think you have two options:\r\n\r\n1. If you can do all modifications on the matrix/tensor in-place, you could call `from_blob` without cloning, mutate the tensor in-place, and since the data would be shared between the tensor and the `cv::Mat` the mutations would be reflected in the original `cv::Mat`, which you could then use for further processing/visualization. E.g.\r\n\r\n    ```cpp\r\n     void process(cv::Mat mat) {\r\n         at::Tensor tensor = torch::from_blob(...); // No clone, just a \"view\" of the mat as a tensor\r\n         tensor.mul_(2); // The multiplication by two is visible in both the tensor and the original `mat`\r\n         visualize(mat); // Since we mutated the underlying data, we can just use the original `mat`\r\n     }\r\n    ```\r\n\r\n    However, if you are calling a `ScriptModule` like you do in your example, that mutation will likely not be in-place. As in, the result of `module->forward(...)` will likely be a new tensor pointing at new memory, not associated with any `cv::Mat` (yet). So this does not apply.\r\n\r\n2. If the end result of your processing is a brand new tensor, you likely want to convert it back into a `cv::Mat`. For this you can use [this constructor](https://docs.opencv.org/trunk/d3/d63/classcv_1_1Mat.html#a922de793eabcec705b3579c5f95a643e) from OpenCV, like the `cv::Mat warp(3, 3, CV_32FC1, w.data<float>());` I used above. In fact, if you read through the \"Detailed Description\" section, you'll notice that their data model is the same as for our tensors: creating a `cv::Mat` from some data blob only creates a view, and you can use the [`clone()`](https://docs.opencv.org/trunk/d3/d63/classcv_1_1Mat.html#adff2ea98da45eae0833e73582dd4a660) method to create a deep-copy of the data.\r\n\r\nAll of that said, I think the path for you is:\r\n\r\n1. You start out with a `cv::Mat mat`,\r\n2. If all you're doing is passing the Mat to `module->forward` immediately, you can create a tensor from it without copying, i.e. `tensor = from_blob(mat.ptr<float>(), sizes)` without cloning. For this make sure the original `mat` is still alive while you call `module->forward`.\r\n3. Get a new tensor when invoking the module: `auto new_tensor = module->forward(tensor);`\r\n4. Then create a `cv::Mat` from the resulting tensor: `cv::Mat output(sizes, CV_32FC1, new_tensor.data<float>())`. At this point the `output` mat will be pointing at data owned by the `new_tensor`. If you simply want to visualize it straight away, no need to copy the data into the `Mat`.\r\n5. If you want to return the `Mat` from a function or otherwise store it, call `clone()` on the `Mat` to take ownership of the data by copying it.\r\n\r\nNotice that there is a case where no additional copies are incurred at all, which is when you're only converting to a tensor to call `module->forward`, and then only converting back to a `Mat` to visualize it. Just be aware of how the lifetimes are bound to each other and when you need to call `clone()`. Hope this helps."}