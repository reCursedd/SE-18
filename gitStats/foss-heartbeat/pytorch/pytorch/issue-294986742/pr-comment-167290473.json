{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/167290473", "pull_request_review_id": 95495988, "id": 167290473, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2NzI5MDQ3Mw==", "diff_hunk": "@@ -721,18 +721,40 @@ def forward(self, input, target):\n \n class MultiLabelSoftMarginLoss(_WeightedLoss):\n     r\"\"\"Creates a criterion that optimizes a multi-label one-versus-all\n-    loss based on max-entropy, between input `x`  (a 2D mini-batch `Tensor`) and\n-    target `y` (a binary 2D `Tensor`). For each sample in the minibatch::\n+    loss based on max-entropy, between input `x` and target `y` of size `(N, C)`.\n+    For each sample in the minibatch::\n \n        loss(x, y) = - sum_i (y[i] * log( 1 / (1 + exp(-x[i])) )\n                          + ( (1-y[i]) * log(exp(-x[i]) / (1 + exp(-x[i])) ) )\n \n     where `i == 0` to `x.nElement()-1`, `y[i]  in {0,1}`.\n-    `y` and `x` must have the same size.\n+\n+    Args:\n+        weight (Tensor, optional): a manual rescaling weight given to each", "path": "torch/nn/modules/loss.py", "position": 16, "original_position": 16, "commit_id": "fa07f460dca2e4156691c781da860a594ebeb2ec", "original_commit_id": "dd34866f7c7faceab6c2724dc62ee72388802f13", "user": {"login": "zou3519", "id": 5652049, "node_id": "MDQ6VXNlcjU2NTIwNDk=", "avatar_url": "https://avatars3.githubusercontent.com/u/5652049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zou3519", "html_url": "https://github.com/zou3519", "followers_url": "https://api.github.com/users/zou3519/followers", "following_url": "https://api.github.com/users/zou3519/following{/other_user}", "gists_url": "https://api.github.com/users/zou3519/gists{/gist_id}", "starred_url": "https://api.github.com/users/zou3519/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zou3519/subscriptions", "organizations_url": "https://api.github.com/users/zou3519/orgs", "repos_url": "https://api.github.com/users/zou3519/repos", "events_url": "https://api.github.com/users/zou3519/events{/privacy}", "received_events_url": "https://api.github.com/users/zou3519/received_events", "type": "User", "site_admin": false}, "body": "The weights aren't per class, they're per element I believe. I guess these are close to the same thing because per-class weights can be broadcasted to per element, but I think the shape of the weight tensor can be size `(N, C)`", "created_at": "2018-02-09T17:16:49Z", "updated_at": "2018-11-23T15:39:25Z", "html_url": "https://github.com/pytorch/pytorch/pull/5097#discussion_r167290473", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/5097", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/167290473"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/5097#discussion_r167290473"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/5097"}}, "body_html": "<p>The weights aren't per class, they're per element I believe. I guess these are close to the same thing because per-class weights can be broadcasted to per element, but I think the shape of the weight tensor can be size <code>(N, C)</code></p>", "body_text": "The weights aren't per class, they're per element I believe. I guess these are close to the same thing because per-class weights can be broadcasted to per element, but I think the shape of the weight tensor can be size (N, C)"}