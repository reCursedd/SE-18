{"url": "https://api.github.com/repos/pytorch/pytorch/issues/14018", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/14018/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/14018/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/14018/events", "html_url": "https://github.com/pytorch/pytorch/pull/14018", "id": 381030186, "node_id": "MDExOlB1bGxSZXF1ZXN0MjMxMDkxNTky", "number": 14018, "title": "[jit] alias analysis", "user": {"login": "suo", "id": 1617424, "node_id": "MDQ6VXNlcjE2MTc0MjQ=", "avatar_url": "https://avatars2.githubusercontent.com/u/1617424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/suo", "html_url": "https://github.com/suo", "followers_url": "https://api.github.com/users/suo/followers", "following_url": "https://api.github.com/users/suo/following{/other_user}", "gists_url": "https://api.github.com/users/suo/gists{/gist_id}", "starred_url": "https://api.github.com/users/suo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/suo/subscriptions", "organizations_url": "https://api.github.com/users/suo/orgs", "repos_url": "https://api.github.com/users/suo/repos", "events_url": "https://api.github.com/users/suo/events{/privacy}", "received_events_url": "https://api.github.com/users/suo/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 679953983, "node_id": "MDU6TGFiZWw2Nzk5NTM5ODM=", "url": "https://api.github.com/repos/pytorch/pytorch/labels/jit", "name": "jit", "color": "c5def5", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2018-11-15T07:17:12Z", "updated_at": "2018-11-23T15:55:15Z", "closed_at": "2018-11-22T01:50:22Z", "author_association": "MEMBER", "pull_request": {"url": "https://api.github.com/repos/pytorch/pytorch/pulls/14018", "html_url": "https://github.com/pytorch/pytorch/pull/14018", "diff_url": "https://github.com/pytorch/pytorch/pull/14018.diff", "patch_url": "https://github.com/pytorch/pytorch/pull/14018.patch"}, "body_html": "<p>First draft of an alias analysis pass. It's a big PR unfortunately; a rough table of contents/suggested order of review:</p>\n<ol>\n<li>\n<p><code>AliasAnalysis</code> pass, which traverses the graph and builds an <code>AliasDb</code>. The basic strategy is to assign alias information to every value of mutable type (list/tuple/tensor), and use the alias annotations of each node's schema to assign alias info to the outputs based on the alias info the inputs. Nodes that aren't explicitly schematized have hand-written analysis rules.</p>\n</li>\n<li>\n<p>Integration of aliasing information into <code>moveBefore/AfterTopologicallyValid()</code>. Basically, we pass in an alias DB when we ask for moveBefore/After. Similar to how we can boil down dependency analysis to \"what nodes use this node\", we can boil down mutability analysis to \"what nodes write to an alias set input/output'd by this node\".</p>\n</li>\n<li>\n<p>Integration of alias analysis to optimization passes that need it. Right now, it is <code>GraphFuser</code>, <code>CreateAutodiffSubgraphs</code>, constant prop, and CSE. Not sure if any others need it.</p>\n</li>\n</ol>\n<h3>TODO</h3>\n<ul>\n<li>Testing; still figuring out the best way to do this.</li>\n<li>Eventually we want to integrate the alias db into the graph, but we shouldn't do that until we can guarantee that the information can stay up to date with mutations.</li>\n<li>Do the same thing <code>python_printer</code> did for operators and force people to register alias analyzers if they can't schematize their op.</li>\n</ul>", "body_text": "First draft of an alias analysis pass. It's a big PR unfortunately; a rough table of contents/suggested order of review:\n\n\nAliasAnalysis pass, which traverses the graph and builds an AliasDb. The basic strategy is to assign alias information to every value of mutable type (list/tuple/tensor), and use the alias annotations of each node's schema to assign alias info to the outputs based on the alias info the inputs. Nodes that aren't explicitly schematized have hand-written analysis rules.\n\n\nIntegration of aliasing information into moveBefore/AfterTopologicallyValid(). Basically, we pass in an alias DB when we ask for moveBefore/After. Similar to how we can boil down dependency analysis to \"what nodes use this node\", we can boil down mutability analysis to \"what nodes write to an alias set input/output'd by this node\".\n\n\nIntegration of alias analysis to optimization passes that need it. Right now, it is GraphFuser, CreateAutodiffSubgraphs, constant prop, and CSE. Not sure if any others need it.\n\n\nTODO\n\nTesting; still figuring out the best way to do this.\nEventually we want to integrate the alias db into the graph, but we shouldn't do that until we can guarantee that the information can stay up to date with mutations.\nDo the same thing python_printer did for operators and force people to register alias analyzers if they can't schematize their op.", "body": "First draft of an alias analysis pass. It's a big PR unfortunately; a rough table of contents/suggested order of review:\r\n1. `AliasAnalysis` pass, which traverses the graph and builds an `AliasDb`. The basic strategy is to assign alias information to every value of mutable type (list/tuple/tensor), and use the alias annotations of each node's schema to assign alias info to the outputs based on the alias info the inputs. Nodes that aren't explicitly schematized have hand-written analysis rules.\r\n\r\n2. Integration of aliasing information into `moveBefore/AfterTopologicallyValid()`. Basically, we pass in an alias DB when we ask for moveBefore/After. Similar to how we can boil down dependency analysis to \"what nodes use this node\", we can boil down mutability analysis to \"what nodes write to an alias set input/output'd by this node\".\r\n\r\n3. Integration of alias analysis to optimization passes that need it. Right now, it is `GraphFuser`, `CreateAutodiffSubgraphs`, constant prop, and CSE. Not sure if any others need it.\r\n\r\n### TODO\r\n- Testing; still figuring out the best way to do this.\r\n- Eventually we want to integrate the alias db into the graph, but we shouldn't do that until we can guarantee that the information can stay up to date with mutations.\r\n- Do the same thing `python_printer` did for operators and force people to register alias analyzers if they can't schematize their op."}