{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/234326956", "pull_request_review_id": 175953859, "id": 234326956, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNDMyNjk1Ng==", "diff_hunk": "@@ -0,0 +1,383 @@\n+#include \"alias_analysis.h\"\n+\n+namespace torch {\n+namespace jit {\n+bool AliasDb::hasWildcard(const Node* n) const {\n+  for (const auto input : n->inputs()) {\n+    if (valueToAlias_.count(input) != 0 &&\n+        valueToAlias_.at(input).isWildcard()) {\n+      return true;\n+    }\n+  }\n+\n+  for (const auto output : n->outputs()) {\n+    if (valueToAlias_.count(output) != 0 &&\n+        valueToAlias_.at(output).isWildcard()) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+bool AliasDb::hasWrites(const Node* n) const {\n+  for (const auto input : n->inputs()) {\n+    if (valueToAlias_.count(input) != 0 && valueToAlias_.at(input).isWrite()) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+std::unordered_set<Node*> AliasDb::getWritersForNode(const Node* n) const {\n+  // Get all alias sets of this node\n+  // ... check the inputs\n+  std::unordered_set<Symbol> aliasSets;\n+  for (const auto& input : n->inputs()) {\n+    if (valueToAlias_.count(input) != 0) {\n+      for (const auto& aliasSet : valueToAlias_.at(input).sets()) {\n+        aliasSets.insert(aliasSet);\n+      }\n+    }\n+  }\n+\n+  // ... and the outputs\n+  for (const auto& output : n->outputs()) {\n+    if (valueToAlias_.count(output) != 0) {\n+      for (const auto& aliasSet : valueToAlias_.at(output).sets()) {\n+        aliasSets.insert(aliasSet);\n+      }\n+    }\n+  }\n+\n+  // Then get the union of all writers to all those alias sets\n+  std::unordered_set<Node*> writers;\n+  for (const auto& alias : aliasSets) {\n+    if (aliasToWrites_.count(alias) != 0) {\n+      for (const auto writer : aliasToWrites_.at(alias)) {\n+        writers.insert(writer);\n+      }\n+    }\n+  }\n+  return writers;\n+}\n+\n+void AliasDb::dump() const {\n+  std::cout << \"\\n===1. GRAPH===\\n\";\n+  graph_->dump();\n+  std::cout << \"===2. ALIAS SETS===\\n\";\n+  for (const auto& pr : valueToAlias_) {\n+    std::cout << \"%\" << pr.first->uniqueName() << \" : \"\n+              << \"(\";\n+\n+    bool first = true;\n+    for (const auto& alias : pr.second.sets()) {\n+      if (first) {\n+        first = false;\n+      } else {\n+        std::cout << \", \";\n+      }\n+      std::cout << alias.toUnqualString();\n+    }\n+    std::cout << \")\\n\";\n+  }\n+\n+  std::cout << \"\\n===3. WRITES===\\n\";\n+  for (const auto& pr : aliasToWrites_) {\n+    std::cout << \"Alias set \" << pr.first.toUnqualString() << \":\\n\";\n+    for (const auto node : pr.second) {\n+      std::cout << \"  \" << *node;\n+    }\n+    std::cout << \"\\n\";\n+  }\n+}\n+\n+void AliasDb::analyze(std::shared_ptr<Graph> graph) {\n+  // Assign aliases to the graph's inputs, assuming that all inputs of a given\n+  // type may alias to each other.\n+  const auto tensorAlias = getFreshAlias();\n+  // Create a separate alias set for each list type\n+  std::map<TypeKind, Symbol> listTypeAliases;\n+  // Create a separate alias set for each tuple type\n+  std::map<TupleTypePtr, Symbol> tupleTypeAliases;\n+\n+  for (auto input : graph->inputs()) {\n+    if (input->type()->isSubtypeOf(DynamicType::get())) {\n+      giveAlias(input, tensorAlias);\n+    } else if (input->type()->kind() == TypeKind::ListType) {\n+      const auto containedType = input->type()->containedTypes().at(0);\n+      if (listTypeAliases.count(containedType->kind()) == 0) {\n+        listTypeAliases[containedType->kind()] = getFreshAlias();\n+      }\n+\n+      giveAlias(input, listTypeAliases.at(containedType->kind()));\n+    } else if (input->type()->kind() == TypeKind::TupleType) {\n+      auto tupleType = input->type()->cast<TupleType>();\n+      if (tupleTypeAliases.count(tupleType) == 0) {\n+        tupleTypeAliases[tupleType] = getFreshAlias();\n+      }\n+      giveAlias(input, tupleTypeAliases.at(tupleType));\n+\n+    } else {\n+      JIT_ASSERT(!isMutableType(input));\n+    }\n+  }\n+\n+  analyze(graph->block());\n+}\n+\n+void AliasDb::analyze(Block* block) {\n+  for (auto node : block->nodes()) {\n+    analyze(node);\n+  }\n+}\n+\n+// The basic strategy is:\n+//   1. Retrieve alias information for every input.\n+//   2. Use the node's schema's alias annotations to propgagate alias/write\n+//      information to the outputs. For unschematized nodes, a special analyzer\n+//      will have to be handwritten.\n+void AliasDb::analyze(Node* node) {\n+  // These nodes are not schematized, so we need to handle them specially\n+  // TODO do the thing that python_printer does to force operator writers to\n+  // register aliasing information\n+  switch (node->kind()) {\n+    case prim::If:\n+      return analyzeIf(node);\n+    case prim::Loop:\n+      return analyzeLoop(node);\n+    case prim::FusionGroup:\n+    case prim::DifferentiableGraph:\n+      return analyzeSubgraph(node);\n+    case prim::Constant:\n+    case prim::ListConstruct:\n+    case prim::TupleConstruct:\n+    case prim::Undefined:\n+    case prim::FusedConcat:\n+      return analyzeCreator(node);\n+    case prim::TupleUnpack:\n+    case prim::TupleIndex:\n+    case prim::TupleSlice:\n+    case prim::ListUnpack:\n+    case prim::PythonOp:\n+      return analyzeExtractor(node);\n+    case prim::ConstantChunk:\n+      return analyzeChunk(node);\n+  }\n+\n+  const auto& schema = node->schema();\n+  if (schema.is_vararg() || schema.is_varret()) {\n+    const auto hasMutableOutputs = std::any_of(\n+        node->outputs().cbegin(),\n+        node->outputs().cend(),\n+        [this](const Value* output) { return isMutableType(output); });\n+\n+    // We don't have alias info for this node. Either schematize it, or\n+    // add it an analyze* method for it.\n+    JIT_ASSERT(!hasMutableOutputs);\n+  }\n+\n+  // Bind formal alias annotation to actual alias sets\n+  std::unordered_map<Symbol, AliasInfo> formalToActual;\n+  for (size_t i = 0; i < schema.arguments().size(); i++) {\n+    const auto& formal = schema.arguments()[i].alias_info();\n+    const auto& actualValue = node->inputs().at(i);\n+    // Skip if there's no alias annotation\n+    if (!formal) {\n+      continue;\n+    }\n+\n+    // We don't support composite types for alias analysis yet.\n+    JIT_ASSERT(formal->containedTypes().size() == 0);\n+    // TODO neither unions nor wildcards make sense on an input. We should\n+    // disallow them in function schema\n+    JIT_ASSERT(!formal->isWildcard())\n+    const auto& formalAlias = formal->set();\n+\n+    // skip if we've already bound this alias\n+    if (formalToActual.count(formalAlias) != 0) {\n+      continue;\n+    }\n+\n+    const auto& actualAlias = valueToAlias_.at(actualValue);\n+\n+    // Bind the formal to the actual\n+    formalToActual[formalAlias] = actualAlias;\n+\n+    // Record all writes\n+    for (const auto& alias : actualAlias.sets()) {\n+      if (formal->isWrite()) {\n+        aliasToWrites_[alias].insert(node);\n+      }\n+    }\n+  }\n+\n+  // Use the formal-actual mapping to give aliases to the outputs\n+  for (size_t i = 0; i < schema.returns().size(); i++) {\n+    const auto actual = node->outputs().at(i);\n+    if (!isMutableType(actual)) {\n+      continue;\n+    }\n+\n+    const auto& formal = schema.returns()[i].alias_info();\n+    if (!formal) {\n+      // This is a fresh tensor\n+      giveAlias(actual, getFreshAlias());\n+      continue;\n+    }\n+\n+    // We don't support composite types for alias analysis yet.\n+    JIT_ASSERT(formal->containedTypes().size() == 0);\n+\n+    if (formal->isWildcard()) {\n+      giveAlias(actual, AliasInfo::createWildcard());\n+      continue;\n+    }\n+\n+    const auto& formalAlias = formal->set();\n+    auto outputAlias = formalToActual.at(formalAlias);\n+\n+    giveAlias(actual, outputAlias);\n+  }\n+}\n+\n+void AliasDb::analyzeIf(Node* node) {\n+  // For if statements, the alias set of an output is the union of the\n+  // alias sets generated by the if and else block\n+  const auto trueBlock = node->blocks().at(0);\n+  const auto falseBlock = node->blocks().at(1);\n+  analyze(trueBlock);\n+  analyze(falseBlock);\n+\n+  for (size_t i = 0; i < node->outputs().size(); i++) {\n+    const auto nodeOutput = node->outputs()[i];\n+    if (!isMutableType(nodeOutput)) {\n+      continue;\n+    }\n+\n+    const auto trueOutput = trueBlock->outputs().at(i);\n+    const auto falseOutput = falseBlock->outputs().at(i);\n+\n+    // If a value is only used in one of the branches, then other branch\n+    // won't have alias information for it. Just assign it an empty set in\n+    // this case.\n+    if (valueToAlias_.count(trueOutput) == 0) {\n+      JIT_ASSERT(valueToAlias_.count(falseOutput) != 0);\n+      giveAlias(trueOutput, AliasInfo());\n+    } else if (valueToAlias_.count(falseOutput) == 0) {\n+      JIT_ASSERT(valueToAlias_.count(trueOutput) != 0);\n+      giveAlias(falseOutput, AliasInfo());\n+    }\n+\n+    AliasInfo aliasInfo;\n+    aliasInfo.unionWith(valueToAlias_.at(trueOutput));\n+    aliasInfo.unionWith(valueToAlias_.at(falseOutput));\n+    valueToAlias_[nodeOutput] = aliasInfo;", "path": "torch/csrc/jit/passes/alias_analysis.cpp", "position": null, "original_position": 274, "commit_id": "b50116902b2ead84375f23e4a9bb629268004c9d", "original_commit_id": "f8e6b4247e28c4e84d87f0f0eb421c09b5b0c3af", "user": {"login": "suo", "id": 1617424, "node_id": "MDQ6VXNlcjE2MTc0MjQ=", "avatar_url": "https://avatars2.githubusercontent.com/u/1617424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/suo", "html_url": "https://github.com/suo", "followers_url": "https://api.github.com/users/suo/followers", "following_url": "https://api.github.com/users/suo/following{/other_user}", "gists_url": "https://api.github.com/users/suo/gists{/gist_id}", "starred_url": "https://api.github.com/users/suo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/suo/subscriptions", "organizations_url": "https://api.github.com/users/suo/orgs", "repos_url": "https://api.github.com/users/suo/repos", "events_url": "https://api.github.com/users/suo/events{/privacy}", "received_events_url": "https://api.github.com/users/suo/received_events", "type": "User", "site_admin": false}, "body": "giveAlias doesn't do a union. In retrospect, it would be simpler if giveAlias did actually union so we can use it here.", "created_at": "2018-11-16T19:45:18Z", "updated_at": "2018-11-23T15:55:04Z", "html_url": "https://github.com/pytorch/pytorch/pull/14018#discussion_r234326956", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/14018", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/234326956"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/14018#discussion_r234326956"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/14018"}}, "body_html": "<p>giveAlias doesn't do a union. In retrospect, it would be simpler if giveAlias did actually union so we can use it here.</p>", "body_text": "giveAlias doesn't do a union. In retrospect, it would be simpler if giveAlias did actually union so we can use it here.", "in_reply_to_id": 234295834}