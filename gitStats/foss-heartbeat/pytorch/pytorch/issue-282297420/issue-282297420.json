{"url": "https://api.github.com/repos/pytorch/pytorch/issues/4187", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/4187/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/4187/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/4187/events", "html_url": "https://github.com/pytorch/pytorch/issues/4187", "id": 282297420, "node_id": "MDU6SXNzdWUyODIyOTc0MjA=", "number": 4187, "title": "Towards better C++ exception traces with try...catch", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2017-12-15T01:59:42Z", "updated_at": "2017-12-15T20:52:57Z", "closed_at": null, "author_association": "CONTRIBUTOR", "body_html": "<p>Right now, when we raise an error in C++ code, no useful information is made available to the user besides the text at the site the exception was thrown. This is not friendly for our users. At a first glance, one might be tempted to see if there is a way to extract a stack trace from the stack and associate with the exception, but one will quickly find that doing so portably is actually quite a bit of work, and you are still in trouble when library code raises exceptions (where you are unable to replace the throw with your own custom function.)</p>\n<p>Fortunately, in ATen we currently make liberal use of code generation, which means we can adopt an alternative strategy for exception handling: add try-catch blocks at all method exit points to annotate exceptions with the necessary metadata to give a good stack trace. And furthermore, modern C++ compilers make try...catch blocks extremely cheap when no exception is thrown.</p>\n<p>To implement this, we would need to:</p>\n<ol>\n<li>\n<p>Design a new exception type which contains stack information we are interested in. A very simple representation would be a vector of strings, but more sophisticated strategies might include correlating tensors at the exception site to the tensors originally passed in by the user (e.g., if convolution raises an exception about 'input', but it becomes clear later that this is actually the 'grad_output' of a transposed convolution, a structured error representation would let us rewrite the error message to more clearly indicate the name of the tensor.</p>\n</li>\n<li>\n<p>Modify code generation to insert try..catch blocks at appropriate method entry points, catching both the new exception type as well as all other exceptions and augmenting them with the necessary information.</p>\n</li>\n<li>\n<p>Render the exceptions in a nice form when they hit users.</p>\n</li>\n</ol>", "body_text": "Right now, when we raise an error in C++ code, no useful information is made available to the user besides the text at the site the exception was thrown. This is not friendly for our users. At a first glance, one might be tempted to see if there is a way to extract a stack trace from the stack and associate with the exception, but one will quickly find that doing so portably is actually quite a bit of work, and you are still in trouble when library code raises exceptions (where you are unable to replace the throw with your own custom function.)\nFortunately, in ATen we currently make liberal use of code generation, which means we can adopt an alternative strategy for exception handling: add try-catch blocks at all method exit points to annotate exceptions with the necessary metadata to give a good stack trace. And furthermore, modern C++ compilers make try...catch blocks extremely cheap when no exception is thrown.\nTo implement this, we would need to:\n\n\nDesign a new exception type which contains stack information we are interested in. A very simple representation would be a vector of strings, but more sophisticated strategies might include correlating tensors at the exception site to the tensors originally passed in by the user (e.g., if convolution raises an exception about 'input', but it becomes clear later that this is actually the 'grad_output' of a transposed convolution, a structured error representation would let us rewrite the error message to more clearly indicate the name of the tensor.\n\n\nModify code generation to insert try..catch blocks at appropriate method entry points, catching both the new exception type as well as all other exceptions and augmenting them with the necessary information.\n\n\nRender the exceptions in a nice form when they hit users.", "body": "Right now, when we raise an error in C++ code, no useful information is made available to the user besides the text at the site the exception was thrown. This is not friendly for our users. At a first glance, one might be tempted to see if there is a way to extract a stack trace from the stack and associate with the exception, but one will quickly find that doing so portably is actually quite a bit of work, and you are still in trouble when library code raises exceptions (where you are unable to replace the throw with your own custom function.)\r\n\r\nFortunately, in ATen we currently make liberal use of code generation, which means we can adopt an alternative strategy for exception handling: add try-catch blocks at all method exit points to annotate exceptions with the necessary metadata to give a good stack trace. And furthermore, modern C++ compilers make try...catch blocks extremely cheap when no exception is thrown.\r\n\r\nTo implement this, we would need to:\r\n\r\n1. Design a new exception type which contains stack information we are interested in. A very simple representation would be a vector of strings, but more sophisticated strategies might include correlating tensors at the exception site to the tensors originally passed in by the user (e.g., if convolution raises an exception about 'input', but it becomes clear later that this is actually the 'grad_output' of a transposed convolution, a structured error representation would let us rewrite the error message to more clearly indicate the name of the tensor.\r\n\r\n2. Modify code generation to insert try..catch blocks at appropriate method entry points, catching both the new exception type as well as all other exceptions and augmenting them with the necessary information.\r\n\r\n3. Render the exceptions in a nice form when they hit users."}