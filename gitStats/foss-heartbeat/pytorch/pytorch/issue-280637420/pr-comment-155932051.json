{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/155932051", "pull_request_review_id": 82335104, "id": 155932051, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1NTkzMjA1MQ==", "diff_hunk": "@@ -0,0 +1,33 @@\n+#pragma once\n+\n+#include <memory>\n+#include <stddef.h>\n+\n+#include \"ATen/Retainable.h\"\n+\n+namespace at {\n+\n+struct Allocator {\n+  virtual void* allocate(std::size_t n) const = 0;\n+  virtual void deallocate(void* ptr) const = 0;\n+};\n+\n+namespace detail {\n+\n+struct AllocatorContext : public Retainable {", "path": "aten/src/ATen/Allocator.h", "position": null, "original_position": 17, "commit_id": "cd4cdb9fa1bbafa2abfb13878e7c22d3d88f5c9a", "original_commit_id": "54f86b50661dc920ee70d6a00ce5e40e2f5a3e6e", "user": {"login": "colesbury", "id": 655866, "node_id": "MDQ6VXNlcjY1NTg2Ng==", "avatar_url": "https://avatars1.githubusercontent.com/u/655866?v=4", "gravatar_id": "", "url": "https://api.github.com/users/colesbury", "html_url": "https://github.com/colesbury", "followers_url": "https://api.github.com/users/colesbury/followers", "following_url": "https://api.github.com/users/colesbury/following{/other_user}", "gists_url": "https://api.github.com/users/colesbury/gists{/gist_id}", "starred_url": "https://api.github.com/users/colesbury/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/colesbury/subscriptions", "organizations_url": "https://api.github.com/users/colesbury/orgs", "repos_url": "https://api.github.com/users/colesbury/repos", "events_url": "https://api.github.com/users/colesbury/events{/privacy}", "received_events_url": "https://api.github.com/users/colesbury/received_events", "type": "User", "site_admin": false}, "body": "Allocators own their own state, if they have any. The state is not part of `AllocatorContext`. \r\n\r\n`AllocatorContext` is an implementation detail (it's not part of the public API). It adds refcounting to allocators without requiring refcounting to be part of the public API.  If I were designing the API from scratch, I might have `Storage` own the allocator and not bother with `AllocatorContext`:\r\n\r\n```\r\nstruct Storage {\r\nprivate:\r\n  std::unique_ptr<Allocator> allocator;\r\n};\r\n```\r\n\r\nInstead, we have to thread the allocator through the `THAllocator`/`THCDeviceAllocator` API, which uses C style `void*` context pointers. We want refcounting internally because a resized tensor goes through the following calls:\r\n\r\n```\r\nmalloc (new)\r\n...\r\nmalloc (resize)\r\nfree (delete old)\r\n...\r\nfree (final delete)\r\n```\r\n\r\nWe need refcounting to know if we can delete the allocator `unique_ptr` at the final call to free.\r\n\r\nYou can implement stateful or stateless allocators with this API or allocators that only have global state. The pinned memory allocator is a caching allocator.\r\n\r\nFor stateless or global allocators, there's a little extra overhead with this API, since it takes in a `unique_ptr<Allocator>` whose lifetime is tied to the storage. This is the same tradeoff we make with `storageFromBlob(..., deleter)` and the same tradeoff made by `shared_ptr` with a custom deleter.", "created_at": "2017-12-09T20:53:42Z", "updated_at": "2018-11-23T15:37:13Z", "html_url": "https://github.com/pytorch/pytorch/pull/4094#discussion_r155932051", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/4094", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/155932051"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/4094#discussion_r155932051"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/4094"}}, "body_html": "<p>Allocators own their own state, if they have any. The state is not part of <code>AllocatorContext</code>.</p>\n<p><code>AllocatorContext</code> is an implementation detail (it's not part of the public API). It adds refcounting to allocators without requiring refcounting to be part of the public API.  If I were designing the API from scratch, I might have <code>Storage</code> own the allocator and not bother with <code>AllocatorContext</code>:</p>\n<pre><code>struct Storage {\nprivate:\n  std::unique_ptr&lt;Allocator&gt; allocator;\n};\n</code></pre>\n<p>Instead, we have to thread the allocator through the <code>THAllocator</code>/<code>THCDeviceAllocator</code> API, which uses C style <code>void*</code> context pointers. We want refcounting internally because a resized tensor goes through the following calls:</p>\n<pre><code>malloc (new)\n...\nmalloc (resize)\nfree (delete old)\n...\nfree (final delete)\n</code></pre>\n<p>We need refcounting to know if we can delete the allocator <code>unique_ptr</code> at the final call to free.</p>\n<p>You can implement stateful or stateless allocators with this API or allocators that only have global state. The pinned memory allocator is a caching allocator.</p>\n<p>For stateless or global allocators, there's a little extra overhead with this API, since it takes in a <code>unique_ptr&lt;Allocator&gt;</code> whose lifetime is tied to the storage. This is the same tradeoff we make with <code>storageFromBlob(..., deleter)</code> and the same tradeoff made by <code>shared_ptr</code> with a custom deleter.</p>", "body_text": "Allocators own their own state, if they have any. The state is not part of AllocatorContext.\nAllocatorContext is an implementation detail (it's not part of the public API). It adds refcounting to allocators without requiring refcounting to be part of the public API.  If I were designing the API from scratch, I might have Storage own the allocator and not bother with AllocatorContext:\nstruct Storage {\nprivate:\n  std::unique_ptr<Allocator> allocator;\n};\n\nInstead, we have to thread the allocator through the THAllocator/THCDeviceAllocator API, which uses C style void* context pointers. We want refcounting internally because a resized tensor goes through the following calls:\nmalloc (new)\n...\nmalloc (resize)\nfree (delete old)\n...\nfree (final delete)\n\nWe need refcounting to know if we can delete the allocator unique_ptr at the final call to free.\nYou can implement stateful or stateless allocators with this API or allocators that only have global state. The pinned memory allocator is a caching allocator.\nFor stateless or global allocators, there's a little extra overhead with this API, since it takes in a unique_ptr<Allocator> whose lifetime is tied to the storage. This is the same tradeoff we make with storageFromBlob(..., deleter) and the same tradeoff made by shared_ptr with a custom deleter.", "in_reply_to_id": 155911367}