{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/180500154", "pull_request_review_id": 110930522, "id": 180500154, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4MDUwMDE1NA==", "diff_hunk": "@@ -5906,3 +5911,328 @@\n     )\n \n \"\"\")\n+\n+add_docstr(torch.fft,\n+           r\"\"\"\n+fft(input, signal_ndim, normalized=False) -> Tensor\n+\n+Complex-to-complex Discrete Fourier Transform\n+\n+This method computes the complex-to-complex discrete Fourier transform.\n+Ignoring the batch dimension, it computes the following expression:\n+\n+.. math::\n+    X[\\omega_1, \\dots, \\omega_d] =\n+        \\frac{1}{\\prod_{i=1}^d N_i} \\sum_{n_1=0}^{N_1} \\dots \\sum_{n_d=0}^{N_d} x[n_1, \\dots, n_d]\n+         e^{-j\\ 2 \\pi \\sum_{i=0}^d \\frac{\\omega_i n_i}{N_i}},\n+\n+where :math:`d`=:attr:`signal_ndim` is number of dimensions for the\n+signal, and :math:`N_i` is the size of signal dimension :math:`i`.\n+\n+This method supports 1D, 2D and 3D complex-to-complex transforms, indicated\n+by :attr:`signal_ndim`. :attr:`input` must be a tensor with last dimension\n+of size 2, representing the real and imaginary components of complex\n+numbers, and should have ``signal_ndim + 1`` dimensions or ``signal_ndim + 2``\n+dimensions with batched data. If :attr:`normalized` is set to ``True``, this\n+returns the normalized Fourier transform results, i.e., divided by\n+:math:`\\sqrt{\\prod_{i=1}^d N_i}`, to become a unitary operator.\n+\n+Returns the real and the imaginary parts together as one tensor of the same\n+shape of :attr:`input`.\n+\n+The inverse of this function is :func:`ifft`.\n+\n+.. warning::\n+    For CPU tensors, this method is currently only available with MKL. Check\n+    :meth:`torch.backends.mkl.is_available` to see if MKL is installed.\n+\n+Arguments:\n+    input (Tensor): the input tensor\n+    signal_ndim (int): the number of dimensions in each signal, can only be 1, 2 or 3\n+    normalized (bool, optional): controls whether to return normalized results.\n+        Default: ``False``\n+\n+Returns:\n+    Tensor: A tensor containing the complex-to-complex Fourier transform result\n+\n+Example::\n+\n+    >>> # unbatched 2D FFT\n+    >>> x = torch.randn(4, 3, 2)\n+    >>> torch.fft(x, 2)\n+\n+    (0 ,.,.) =\n+      6.8901 -1.7571\n+      0.4166 -1.1500\n+      3.9736  0.5400\n+\n+    (1 ,.,.) =\n+     -0.3050  0.4976\n+      0.2072  1.1015\n+      1.3850 -0.0566\n+\n+    (2 ,.,.) =\n+      3.1463  3.3727\n+      1.4051 -3.3523\n+      1.5072 -4.1700\n+\n+    (3 ,.,.) =\n+      5.1215 -2.5402\n+      5.1859  1.4077\n+      2.0077  1.3137\n+    [torch.FloatTensor of size (4,3,2)]\n+\n+    >>> # batched 1D FFT\n+    >>> torch.fft(x, 1)\n+\n+    (0 ,.,.) =\n+      3.7132 -0.1067\n+      1.8037 -0.4983\n+      2.2184 -0.5932\n+\n+    (1 ,.,.) =\n+      0.1765 -2.6391\n+     -0.1705 -0.6941\n+      0.9592  1.0218\n+\n+    (2 ,.,.) =\n+      1.3050  0.9145\n+     -0.8929 -1.7529\n+      0.5220 -1.2218\n+\n+    (3 ,.,.) =\n+      1.6954  0.0742\n+     -0.3237  1.7953\n+      0.2740  1.3332\n+    [torch.FloatTensor of size (4,3,2)]\n+\n+\"\"\")\n+\n+add_docstr(torch.ifft,\n+           r\"\"\"\n+ifft(input, signal_ndim, normalized=False) -> Tensor\n+\n+Complex-to-complex Inverse Discrete Fourier Transform\n+\n+This method computes the complex-to-complex inverse discrete Fourier\n+transform. Ignoring the batch dimension, it computes the following\n+expression:\n+\n+.. math::\n+    X[\\omega_1, \\dots, \\omega_d] =\n+        \\frac{1}{\\prod_{i=1}^d N_i} \\sum_{n_1=0}^{N_1} \\dots \\sum_{n_d=0}^{N_d} x[n_1, \\dots, n_d]\n+         e^{j\\ 2 \\pi \\sum_{i=0}^d \\frac{\\omega_i n_i}{N_i}},\n+\n+where :math:`d`=:attr:`signal_ndim` is number of dimensions for the\n+signal, and :math:`N_i` is the size of signal dimension :math:`i`.\n+\n+The argument specifications are almost identical with :func:`fft`. However,\n+if :attr:`normalized` is set to ``True``, this instead returns the results\n+multiplied by :math:`\\sqrt{\\prod_{i=1}^d N_i}`, to become a unitary\n+operator. Therefore, to invert an :func:`fft`, the :attr:`normalized`\n+argument should be set identically for :func:`ifft`.\n+\n+Returns the real and the imaginary parts together as one tensor of the same\n+shape of :attr:`input`.\n+\n+The inverse of this function is :func:`fft`.\n+\n+.. warning::\n+    For CPU tensors, this method is currently only available with MKL. Check\n+    :meth:`torch.backends.mkl.is_available` to see if MKL is installed.\n+\n+Arguments:\n+    input (Tensor): the input tensor\n+    signal_ndim (int): the number of dimensions in each signal, can only be 1, 2 or 3\n+    normalized (bool, optional): controls whether to return normalized results.\n+        Default: ``False``\n+\n+Returns:\n+    Tensor: A tensor containing the complex-to-complex inverse Fourier transform result\n+\n+Example::\n+\n+    >>> x = torch.randn(3, 3, 2)\n+    >>> x\n+\n+    (0 ,.,.) =\n+      1.2735 -0.9441\n+     -1.0940  0.2728\n+      0.8997  0.4231\n+\n+    (1 ,.,.) =\n+     -0.5239 -1.4942\n+      0.5248  3.3432\n+      1.0976 -2.0426\n+\n+    (2 ,.,.) =\n+      1.1039  1.9541\n+     -0.2774  0.2631\n+      0.3102  0.8129\n+    [torch.FloatTensor of size (3,3,2)]\n+\n+    >>> y = torch.fft(x, 2)\n+    >>> torch.ifft(y, 2)  # recover x\n+\n+    (0 ,.,.) =\n+      1.2735 -0.9441\n+     -1.0940  0.2728\n+      0.8997  0.4231\n+\n+    (1 ,.,.) =\n+     -0.5239 -1.4942\n+      0.5248  3.3432\n+      1.0976 -2.0426\n+\n+    (2 ,.,.) =\n+      1.1039  1.9541\n+     -0.2774  0.2631\n+      0.3102  0.8129\n+    [torch.FloatTensor of size (3,3,2)]\n+\n+\"\"\")\n+\n+add_docstr(torch.rfft,\n+           r\"\"\"\n+rfft(input, signal_ndim, normalized=False, onesided=True) -> Tensor\n+\n+Real-to-complex Discrete Fourier Transform\n+\n+This method computes the real-to-complex discrete Fourier transform. It is\n+mathematically equivalent with :func:`fft` with differences only in formats\n+of the input and output.\n+\n+This method supports 1D, 2D and 3D real-to-complex transforms, indicated\n+by :attr:`signal_ndim`. :attr:`input` must be a tensor with ``signal_ndim``\n+dimensions or ``signal_ndim + 1`` dimensions with batched data. If\n+:attr:`normalized` is set to ``True``, this returns the normalized Fourier\n+transform results, i.e., divided by :math:`\\sqrt{\\prod_{i=1}^d N_i}`, to\n+become a unitary operator.\n+\n+The real-to-complex Fourier transform results follow conjugate symmetry:\n+\n+.. math::\n+    X[\\omega_1, \\dots, \\omega_d] = X^*[N_1 - \\omega_1, \\dots, N_d - \\omega_d],\n+\n+where the index arithmetic is computed modulus the size of the corresponding\n+dimension. Therefore, :attr:`onesided` controls whether to avoid redundancy\n+in the output results. If set to ``True`` (default), the output will not be\n+full complex result of shape :math:`(* \\times 2)`, where :math:`*` is the\n+shape of :attr:`input`, but instead the last dimension will be halfed as\n+:math:`\\lfloor \\frac{N_d}{2} \\rfloor + 1`.\n+\n+The inverse of this function is :func:`irfft`.\n+\n+.. warning::\n+    For CPU tensors, this method is currently only available with MKL. Check\n+    :meth:`torch.backends.mkl.is_available` to see if MKL is installed.\n+\n+Arguments:\n+    input (Tensor): the input tensor\n+    signal_ndim (int): the number of dimensions in each signal, can only be 1, 2 or 3\n+    normalized (bool, optional): controls whether to return normalized results.\n+        Default: ``False``\n+    onesided (bool, optional): controls whether to return half of results to\n+        avoid redundancy Default: ``True``\n+\n+Returns:\n+    Tensor: A tensor containing the real-to-complex Fourier transform result\n+\n+Example::\n+\n+    >>> x = torch.randn(5, 5)\n+    >>> torch.rfft(x, 2).shape\n+    torch.Size([5, 3, 2])\n+    >>> torch.rfft(x, 2, onesided=False).shape\n+    torch.Size([5, 5, 2])\n+\n+\"\"\")\n+\n+\n+add_docstr(torch.irfft,\n+           r\"\"\"\n+irfft(input, signal_ndim, normalized=False, onesided=True, signal_sizes=None) -> Tensor\n+\n+Complex-to-real Inverse Discrete Fourier Transform\n+\n+This method computes the complex-to-real inverse discrete Fourier transform.\n+It is mathematically equivalent with :func:`ifft` with differences only in\n+formats of the input and output.\n+\n+The argument specifications are almost identical with :func:`ifft`. Similar\n+to :func:`ifft`, if :attr:`normalized` is set to ``True``, this instead\n+returns the results multiplied by :math:`\\sqrt{\\prod_{i=1}^K N_i}`, to\n+become a unitary operator.\n+\n+Due to the conjugate symmetry, :attr:`input` do not need to contain the full\n+complex frequency values. Roughly half of the values will be sufficient, as\n+is the case when :attr:`input` is given by :func:`rfft` with\n+``rfft(signal, onesided=True)``. In such case, set the :attr:`onesided`\n+argument of this method to ``True``. Moreover, the original signal shape\n+information can sometimes be lost, optionally set :attr:`signal_sizes` to be\n+the size of the original signal (without batch dimension if in batched mode) to\n+recover it with correct shape.\n+\n+Therefore, to invert an :func:`rfft`, the :attr:`normalized` and\n+:attr:`onesided` arguments should be set identically for :func:`irfft`, and\n+preferrably a :func:`signal_sizes` is given to avoid size mismatch. See the\n+example below for a case of size mismatch.\n+\n+See :func:`rfft` for details on conjugate symmetry.\n+\n+The inverse of this function is :func:`rfft`.\n+\n+.. warning::\n+    Genearlly speaking, the input of this function should contain values", "path": "torch/_torch_docs.py", "position": null, "original_position": 317, "commit_id": "4f42e27b4155bfc1db469b02be6a050eba627e5d", "original_commit_id": "2a27b4ada5db468459a84174e69e275a1c941073", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "body": "Generally", "created_at": "2018-04-10T17:14:20Z", "updated_at": "2018-11-23T15:42:11Z", "html_url": "https://github.com/pytorch/pytorch/pull/5537#discussion_r180500154", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/5537", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/180500154"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/5537#discussion_r180500154"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/5537"}}, "body_html": "<p>Generally</p>", "body_text": "Generally"}