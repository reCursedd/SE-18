{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/422470226", "html_url": "https://github.com/pytorch/pytorch/pull/11619#issuecomment-422470226", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/11619", "id": 422470226, "node_id": "MDEyOklzc3VlQ29tbWVudDQyMjQ3MDIyNg==", "user": {"login": "goldsborough", "id": 6429851, "node_id": "MDQ6VXNlcjY0Mjk4NTE=", "avatar_url": "https://avatars3.githubusercontent.com/u/6429851?v=4", "gravatar_id": "", "url": "https://api.github.com/users/goldsborough", "html_url": "https://github.com/goldsborough", "followers_url": "https://api.github.com/users/goldsborough/followers", "following_url": "https://api.github.com/users/goldsborough/following{/other_user}", "gists_url": "https://api.github.com/users/goldsborough/gists{/gist_id}", "starred_url": "https://api.github.com/users/goldsborough/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/goldsborough/subscriptions", "organizations_url": "https://api.github.com/users/goldsborough/orgs", "repos_url": "https://api.github.com/users/goldsborough/repos", "events_url": "https://api.github.com/users/goldsborough/events{/privacy}", "received_events_url": "https://api.github.com/users/goldsborough/received_events", "type": "User", "site_admin": false}, "created_at": "2018-09-18T16:58:58Z", "updated_at": "2018-09-18T18:02:29Z", "author_association": "CONTRIBUTOR", "body_html": "<p>After discussing with <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=3605224\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/ebetica\">@ebetica</a> we found that backwards compatibility with cereal is not as important and that StarCraft would be happy to switch to protobuf. For this reason I've opted to specialize my design a little more towards our Protobuf serialization format. The new primitives are <code>InputArchive</code> and <code>OutputArchive</code>, which both wrap a <code>ScriptModule</code>, which we use as a vehicle for serialization. The API for e.g. <code>InputArchive</code> is:</p>\n<pre><code>class InputArchive {\n public:\n  void read(const std::string&amp; key, Tensor&amp; tensor, bool is_buffer = false);\n  void read(const std::string&amp; key, InputArchive&amp; archive);\n\n  template &lt;typename... Ts&gt;\n  void operator()(Ts&amp;&amp;... ts) {\n    read(std::forward&lt;Ts&gt;(ts)...);\n  }\n\n private:\n  std::shared_ptr&lt;jit::script::Module&gt; module_;\n};\n</code></pre>\n<p>which gets populated e.g. in <code>nn::Module::load</code>:</p>\n<pre><code>void Module::load(serialize::InputArchive&amp; archive) {\n  for (auto&amp; parameter : parameters_) {\n    archive.read(parameter.key, parameter.value);\n  }\n  for (auto&amp; buffer : buffers_) {\n    archive.read(buffer.key, buffer.value, /*is_buffer=*/true);\n  }\n  for (const auto&amp; child : children_) {\n      serialize::InputArchive child_archive;\n      archive.read(child.key, child_archive);\n      child.value-&gt;load(child_archive);\n  }\n}\n</code></pre>\n<p>This API is not intended for inheritence. The reason why is that <code>InputArchive</code>s are recursively built (1 InputArchive = 1 ScriptModule) and have to be re-instantiated inside of <code>save()</code> or <code>load()</code>. This re-instantiation wouldn't work (nicely) if <code>InputArchive</code> were an abstract class.</p>\n<p>This means we only support protobuf serialization out of the box. However, I've made sure that all parameters and buffers in modules and optimizers that one would want to store are properly exposed. This means if one wanted to, one could write a new serialization library on top of the <code>Module</code> base class. I believe this is more the strategy we have in Python, where we have one blessed serialization API (Pickle), but generally modules and optimizers expose enough state that anyone could dump their models into a Thrift or JSON interface.</p>\n<p>CC <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=3605224\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/ebetica\">@ebetica</a> <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=17890620\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/dzhulgakov\">@dzhulgakov</a> <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=370202\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/zdevito\">@zdevito</a> <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=4583066\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/apaszke\">@apaszke</a> <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=13564\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/ezyang\">@ezyang</a></p>", "body_text": "After discussing with @ebetica we found that backwards compatibility with cereal is not as important and that StarCraft would be happy to switch to protobuf. For this reason I've opted to specialize my design a little more towards our Protobuf serialization format. The new primitives are InputArchive and OutputArchive, which both wrap a ScriptModule, which we use as a vehicle for serialization. The API for e.g. InputArchive is:\nclass InputArchive {\n public:\n  void read(const std::string& key, Tensor& tensor, bool is_buffer = false);\n  void read(const std::string& key, InputArchive& archive);\n\n  template <typename... Ts>\n  void operator()(Ts&&... ts) {\n    read(std::forward<Ts>(ts)...);\n  }\n\n private:\n  std::shared_ptr<jit::script::Module> module_;\n};\n\nwhich gets populated e.g. in nn::Module::load:\nvoid Module::load(serialize::InputArchive& archive) {\n  for (auto& parameter : parameters_) {\n    archive.read(parameter.key, parameter.value);\n  }\n  for (auto& buffer : buffers_) {\n    archive.read(buffer.key, buffer.value, /*is_buffer=*/true);\n  }\n  for (const auto& child : children_) {\n      serialize::InputArchive child_archive;\n      archive.read(child.key, child_archive);\n      child.value->load(child_archive);\n  }\n}\n\nThis API is not intended for inheritence. The reason why is that InputArchives are recursively built (1 InputArchive = 1 ScriptModule) and have to be re-instantiated inside of save() or load(). This re-instantiation wouldn't work (nicely) if InputArchive were an abstract class.\nThis means we only support protobuf serialization out of the box. However, I've made sure that all parameters and buffers in modules and optimizers that one would want to store are properly exposed. This means if one wanted to, one could write a new serialization library on top of the Module base class. I believe this is more the strategy we have in Python, where we have one blessed serialization API (Pickle), but generally modules and optimizers expose enough state that anyone could dump their models into a Thrift or JSON interface.\nCC @ebetica @dzhulgakov @zdevito @apaszke @ezyang", "body": "After discussing with @ebetica we found that backwards compatibility with cereal is not as important and that StarCraft would be happy to switch to protobuf. For this reason I've opted to specialize my design a little more towards our Protobuf serialization format. The new primitives are `InputArchive` and `OutputArchive`, which both wrap a `ScriptModule`, which we use as a vehicle for serialization. The API for e.g. `InputArchive` is:\r\n\r\n```\r\nclass InputArchive {\r\n public:\r\n  void read(const std::string& key, Tensor& tensor, bool is_buffer = false);\r\n  void read(const std::string& key, InputArchive& archive);\r\n\r\n  template <typename... Ts>\r\n  void operator()(Ts&&... ts) {\r\n    read(std::forward<Ts>(ts)...);\r\n  }\r\n\r\n private:\r\n  std::shared_ptr<jit::script::Module> module_;\r\n};\r\n```\r\n\r\nwhich gets populated e.g. in `nn::Module::load`:\r\n```\r\nvoid Module::load(serialize::InputArchive& archive) {\r\n  for (auto& parameter : parameters_) {\r\n    archive.read(parameter.key, parameter.value);\r\n  }\r\n  for (auto& buffer : buffers_) {\r\n    archive.read(buffer.key, buffer.value, /*is_buffer=*/true);\r\n  }\r\n  for (const auto& child : children_) {\r\n      serialize::InputArchive child_archive;\r\n      archive.read(child.key, child_archive);\r\n      child.value->load(child_archive);\r\n  }\r\n}\r\n```\r\n\r\nThis API is not intended for inheritence. The reason why is that `InputArchive`s are recursively built (1 InputArchive = 1 ScriptModule) and have to be re-instantiated inside of `save()` or `load()`. This re-instantiation wouldn't work (nicely) if `InputArchive` were an abstract class.\r\n\r\nThis means we only support protobuf serialization out of the box. However, I've made sure that all parameters and buffers in modules and optimizers that one would want to store are properly exposed. This means if one wanted to, one could write a new serialization library on top of the `Module` base class. I believe this is more the strategy we have in Python, where we have one blessed serialization API (Pickle), but generally modules and optimizers expose enough state that anyone could dump their models into a Thrift or JSON interface.\r\n\r\nCC @ebetica @dzhulgakov @zdevito @apaszke @ezyang "}