{"url": "https://api.github.com/repos/pytorch/pytorch/issues/11619", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/11619/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/11619/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/11619/events", "html_url": "https://github.com/pytorch/pytorch/pull/11619", "id": 359722542, "node_id": "MDExOlB1bGxSZXF1ZXN0MjE1MTQ5Nzc0", "number": 11619, "title": "[C++ API] Protobuf serialization", "user": {"login": "goldsborough", "id": 6429851, "node_id": "MDQ6VXNlcjY0Mjk4NTE=", "avatar_url": "https://avatars3.githubusercontent.com/u/6429851?v=4", "gravatar_id": "", "url": "https://api.github.com/users/goldsborough", "html_url": "https://github.com/goldsborough", "followers_url": "https://api.github.com/users/goldsborough/followers", "following_url": "https://api.github.com/users/goldsborough/following{/other_user}", "gists_url": "https://api.github.com/users/goldsborough/gists{/gist_id}", "starred_url": "https://api.github.com/users/goldsborough/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/goldsborough/subscriptions", "organizations_url": "https://api.github.com/users/goldsborough/orgs", "repos_url": "https://api.github.com/users/goldsborough/repos", "events_url": "https://api.github.com/users/goldsborough/events{/privacy}", "received_events_url": "https://api.github.com/users/goldsborough/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2018-09-13T02:49:46Z", "updated_at": "2018-11-23T15:51:46Z", "closed_at": "2018-09-21T03:40:44Z", "author_association": "CONTRIBUTOR", "pull_request": {"url": "https://api.github.com/repos/pytorch/pytorch/pulls/11619", "html_url": "https://github.com/pytorch/pytorch/pull/11619", "diff_url": "https://github.com/pytorch/pytorch/pull/11619.diff", "patch_url": "https://github.com/pytorch/pytorch/pull/11619.patch"}, "body_html": "<p>This PR serves two purposes:</p>\n<ol>\n<li>Design an abstraction over a serialization scheme for C++ modules, optimizers and tensors in general,</li>\n<li>Add serialization to the ONNX/PyTorch proto format.</li>\n</ol>\n<p>This is currently a rough prototype I coded up today, to get quick feedback.</p>\n<p>For this I propose the following serialization interface within the C++ API:</p>\n<div class=\"highlight highlight-source-c++\"><pre><span class=\"pl-k\">namespace</span> <span class=\"pl-en\">torch</span> { <span class=\"pl-k\">namespace</span> <span class=\"pl-en\">serialize</span> {\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">Reader</span> {\n <span class=\"pl-k\">public:</span>\n  <span class=\"pl-k\">virtual</span> <span class=\"pl-en\">~Reader</span>() = <span class=\"pl-k\">default</span>;\n  <span class=\"pl-k\">virtual</span> <span class=\"pl-k\">void</span> <span class=\"pl-en\">read</span>(<span class=\"pl-k\">const</span> std::string&amp; key, Tensor&amp; tensor, <span class=\"pl-k\">bool</span> is_buffer = <span class=\"pl-c1\">false</span>) = 0;\n  <span class=\"pl-k\">virtual</span> <span class=\"pl-k\">void</span> <span class=\"pl-en\">finish</span>() { }\n};\n\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">Writer</span> {\n <span class=\"pl-k\">public:</span>\n  <span class=\"pl-k\">virtual</span> <span class=\"pl-en\">~Reader</span>() = <span class=\"pl-k\">default</span>;\n  <span class=\"pl-k\">virtual</span> <span class=\"pl-k\">void</span> <span class=\"pl-en\">writer</span>(<span class=\"pl-k\">const</span> std::string&amp; key, <span class=\"pl-k\">const</span> Tensor&amp; tensor, <span class=\"pl-k\">bool</span> is_buffer = <span class=\"pl-c1\">false</span>) = 0;\n  <span class=\"pl-k\">virtual</span> <span class=\"pl-k\">void</span> <span class=\"pl-en\">finish</span>() { }\n};\n}} <span class=\"pl-c\"><span class=\"pl-c\">//</span> namespace torch::serialize</span></pre></div>\n<p>There are then subclasses of these two for (1) Cereal and (2) Protobuf (called the \"DefaultWriter\" and \"DefaultReader\" to hide the implementation details). See <code>torch/serialize/cereal.h</code> and <code>torch/serialize/default.h</code>. This abstraction and subclassing for these two allows us to:</p>\n<ol>\n<li>Provide a cereal-less serialization forward that we can ship and iterate on going forward,</li>\n<li>Provide no-friction backwards compatibility with existing C++ API uses, mainly StarCraft.</li>\n</ol>\n<p>The user-facing API is (conceptually):</p>\n<div class=\"highlight highlight-source-c++\"><pre><span class=\"pl-k\">void</span> <span class=\"pl-en\">torch::save</span>(<span class=\"pl-k\">const</span> Module&amp; module, Writer&amp; writer);\n<span class=\"pl-k\">void</span> <span class=\"pl-en\">torch::save</span>(<span class=\"pl-k\">const</span> Optimizer&amp; optimizer, Writer&amp; writer);\n<span class=\"pl-k\">void</span> <span class=\"pl-en\">torch::read</span>(Module&amp; module, Reader&amp; reader);\n<span class=\"pl-k\">void</span> <span class=\"pl-en\">torch::read</span>(Optimizer&amp; optimizer, Reader&amp; reader);</pre></div>\n<p>with implementations for both optimizers and modules that write into the <code>Writer</code> and read from the <code>Reader</code></p>\n<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=3605224\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/ebetica\">@ebetica</a> <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=13564\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/ezyang\">@ezyang</a> <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=370202\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/zdevito\">@zdevito</a> <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=17890620\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/dzhulgakov\">@dzhulgakov</a></p>", "body_text": "This PR serves two purposes:\n\nDesign an abstraction over a serialization scheme for C++ modules, optimizers and tensors in general,\nAdd serialization to the ONNX/PyTorch proto format.\n\nThis is currently a rough prototype I coded up today, to get quick feedback.\nFor this I propose the following serialization interface within the C++ API:\nnamespace torch { namespace serialize {\nclass Reader {\n public:\n  virtual ~Reader() = default;\n  virtual void read(const std::string& key, Tensor& tensor, bool is_buffer = false) = 0;\n  virtual void finish() { }\n};\n\nclass Writer {\n public:\n  virtual ~Reader() = default;\n  virtual void writer(const std::string& key, const Tensor& tensor, bool is_buffer = false) = 0;\n  virtual void finish() { }\n};\n}} // namespace torch::serialize\nThere are then subclasses of these two for (1) Cereal and (2) Protobuf (called the \"DefaultWriter\" and \"DefaultReader\" to hide the implementation details). See torch/serialize/cereal.h and torch/serialize/default.h. This abstraction and subclassing for these two allows us to:\n\nProvide a cereal-less serialization forward that we can ship and iterate on going forward,\nProvide no-friction backwards compatibility with existing C++ API uses, mainly StarCraft.\n\nThe user-facing API is (conceptually):\nvoid torch::save(const Module& module, Writer& writer);\nvoid torch::save(const Optimizer& optimizer, Writer& writer);\nvoid torch::read(Module& module, Reader& reader);\nvoid torch::read(Optimizer& optimizer, Reader& reader);\nwith implementations for both optimizers and modules that write into the Writer and read from the Reader\n@ebetica @ezyang @zdevito @dzhulgakov", "body": "This PR serves two purposes:\r\n\r\n1. Design an abstraction over a serialization scheme for C++ modules, optimizers and tensors in general,\r\n2. Add serialization to the ONNX/PyTorch proto format.\r\n\r\nThis is currently a rough prototype I coded up today, to get quick feedback.\r\n\r\nFor this I propose the following serialization interface within the C++ API:\r\n\r\n```cpp\r\nnamespace torch { namespace serialize {\r\nclass Reader {\r\n public:\r\n  virtual ~Reader() = default;\r\n  virtual void read(const std::string& key, Tensor& tensor, bool is_buffer = false) = 0;\r\n  virtual void finish() { }\r\n};\r\n\r\nclass Writer {\r\n public:\r\n  virtual ~Reader() = default;\r\n  virtual void writer(const std::string& key, const Tensor& tensor, bool is_buffer = false) = 0;\r\n  virtual void finish() { }\r\n};\r\n}} // namespace torch::serialize\r\n```\r\n\r\nThere are then subclasses of these two for (1) Cereal and (2) Protobuf (called the \"DefaultWriter\" and \"DefaultReader\" to hide the implementation details). See `torch/serialize/cereal.h` and `torch/serialize/default.h`. This abstraction and subclassing for these two allows us to:\r\n\r\n1. Provide a cereal-less serialization forward that we can ship and iterate on going forward,\r\n2. Provide no-friction backwards compatibility with existing C++ API uses, mainly StarCraft.\r\n\r\nThe user-facing API is (conceptually):\r\n\r\n```cpp\r\nvoid torch::save(const Module& module, Writer& writer);\r\nvoid torch::save(const Optimizer& optimizer, Writer& writer);\r\nvoid torch::read(Module& module, Reader& reader);\r\nvoid torch::read(Optimizer& optimizer, Reader& reader);\r\n```\r\n\r\nwith implementations for both optimizers and modules that write into the `Writer` and read from the `Reader`\r\n\r\n@ebetica @ezyang @zdevito @dzhulgakov "}