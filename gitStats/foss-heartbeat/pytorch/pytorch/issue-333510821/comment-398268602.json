{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/398268602", "html_url": "https://github.com/pytorch/pytorch/issues/8637#issuecomment-398268602", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/8637", "id": 398268602, "node_id": "MDEyOklzc3VlQ29tbWVudDM5ODI2ODYwMg==", "user": {"login": "SsnL", "id": 5674597, "node_id": "MDQ6VXNlcjU2NzQ1OTc=", "avatar_url": "https://avatars2.githubusercontent.com/u/5674597?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SsnL", "html_url": "https://github.com/SsnL", "followers_url": "https://api.github.com/users/SsnL/followers", "following_url": "https://api.github.com/users/SsnL/following{/other_user}", "gists_url": "https://api.github.com/users/SsnL/gists{/gist_id}", "starred_url": "https://api.github.com/users/SsnL/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SsnL/subscriptions", "organizations_url": "https://api.github.com/users/SsnL/orgs", "repos_url": "https://api.github.com/users/SsnL/repos", "events_url": "https://api.github.com/users/SsnL/events{/privacy}", "received_events_url": "https://api.github.com/users/SsnL/received_events", "type": "User", "site_admin": false}, "created_at": "2018-06-19T04:10:32Z", "updated_at": "2018-06-19T04:10:32Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Yeah, <code>testModule</code> won't work because you saved the method <code>self._realOperation</code>, which is bound to this particular <code>testModule</code> instance, as the attribute <code>self.operation_function</code>. When broadcasting the module to different GPUs, this attribute, as it is not a tensor, is just simply duplicated, which means that all broadcast copies of this module have the attribute refer to the same bound method, and that this method is bound to the same instance and thus using the same <code>self.g</code>, which has all parameters only on GPU 0. Therefore it errors on GPU 1.</p>\n<p>In <code>testModule2</code>, in <code>forward</code> of each broadcast copy, the dynamically found <code>self.g</code> is the <code>g</code> attribute of that copy, whose parameters are broadcast to corresponding GPU.</p>\n<p>If you just do not save the method as an attribute, the code should work fine. E.g., directly calling <code>self._realOperation</code> in <code>forward</code>, writing <code>self.operation_function</code> as another method of the class, etc.</p>\n<p>In theory we can fix this by checking the broadcast module's <code>__dict__</code> and see if there are methods of this instance bounded as attributes. But I don't think that this is very common.</p>", "body_text": "Yeah, testModule won't work because you saved the method self._realOperation, which is bound to this particular testModule instance, as the attribute self.operation_function. When broadcasting the module to different GPUs, this attribute, as it is not a tensor, is just simply duplicated, which means that all broadcast copies of this module have the attribute refer to the same bound method, and that this method is bound to the same instance and thus using the same self.g, which has all parameters only on GPU 0. Therefore it errors on GPU 1.\nIn testModule2, in forward of each broadcast copy, the dynamically found self.g is the g attribute of that copy, whose parameters are broadcast to corresponding GPU.\nIf you just do not save the method as an attribute, the code should work fine. E.g., directly calling self._realOperation in forward, writing self.operation_function as another method of the class, etc.\nIn theory we can fix this by checking the broadcast module's __dict__ and see if there are methods of this instance bounded as attributes. But I don't think that this is very common.", "body": "Yeah, `testModule` won't work because you saved the method `self._realOperation`, which is bound to this particular `testModule` instance, as the attribute `self.operation_function`. When broadcasting the module to different GPUs, this attribute, as it is not a tensor, is just simply duplicated, which means that all broadcast copies of this module have the attribute refer to the same bound method, and that this method is bound to the same instance and thus using the same `self.g`, which has all parameters only on GPU 0. Therefore it errors on GPU 1.\r\n\r\nIn `testModule2`, in `forward` of each broadcast copy, the dynamically found `self.g` is the `g` attribute of that copy, whose parameters are broadcast to corresponding GPU.\r\n\r\nIf you just do not save the method as an attribute, the code should work fine. E.g., directly calling `self._realOperation` in `forward`, writing `self.operation_function` as another method of the class, etc.\r\n\r\nIn theory we can fix this by checking the broadcast module's `__dict__` and see if there are methods of this instance bounded as attributes. But I don't think that this is very common."}