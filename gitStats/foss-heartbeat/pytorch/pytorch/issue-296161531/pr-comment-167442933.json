{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/167442933", "pull_request_review_id": 95663467, "id": 167442933, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2NzQ0MjkzMw==", "diff_hunk": "@@ -34,18 +34,122 @@ using ListAttributeMap = std::unordered_map<\n     std::string,\n     std::pair<const std::vector<double>, std::string>>;\n \n+// Keep track of environment as we descend down nested control\n+// structures.\n+struct Environment {\n+  Environment(Block* b, std::shared_ptr<Environment> next = nullptr)\n+      : b(b), next(next) {}\n+\n+  std::vector<std::string> captured_inputs;\n+  ValueTable value_table;\n+  Block* b;\n+\n+  std::shared_ptr<Environment> next;\n+\n+  Value* findInThisFrame(const std::string& name) {\n+    if (value_table.count(name)) {\n+      return value_table.at(name);\n+    }\n+    return nullptr;\n+  }\n+\n+  Value* findInParentFrame(const std::string& name) {\n+    for (auto runner = next; runner; runner = runner->next) {\n+      if (runner->value_table.count(name)) {\n+        return runner->value_table.at(name);\n+      }\n+    }\n+    return nullptr;\n+  }\n+\n+  Value* createCapturedInput(const std::string& name) {\n+    // Create the input\n+    Value* new_input = b->addInput();\n+\n+    // Associate this name with this value\n+    value_table[name] = new_input;\n+\n+    // List as a positional input\n+    captured_inputs.push_back(name);\n+\n+    return new_input;\n+  }\n+\n+  Symbol getBlockOwningKind() {\n+    Symbol owning_kind = Symbol();\n+    if (b->owningNode()) {\n+      owning_kind = b->owningNode()->kind();\n+    }\n+    return owning_kind;\n+  }\n+\n+  void setVar(const std::string& name, Value* value) {\n+    if (!findInThisFrame(name) && findInParentFrame(name) &&\n+        getBlockOwningKind() == Symbol(\"Loop\"))\n+      createCapturedInput(name);\n+    value_table[name] = value;\n+  }\n+\n+  Value* getVar(const Ident& ident) {\n+    return getVar(ident.name(), ident);\n+  }\n+\n+  Value* getVar(const std::string& ident, const TreeView& tv) {\n+    Value* retval = findInThisFrame(ident);\n+\n+    if (!retval && (retval = findInParentFrame(ident)) &&\n+        getBlockOwningKind() == Symbol(\"Loop\"))\n+      retval = createCapturedInput(ident);\n+\n+    if (!retval) {\n+      throw ErrorReport(tv) << \"undefined value \" << ident;\n+    }\n+\n+    return retval;\n+  }\n+\n+  // Given that after emitting statements in a block, we've added block inputs\n+  // for all value references and assignments, delete inputs for which there was\n+  // no assignment, only references.\n+  void deleteExtraInputs() {\n+    std::vector<size_t> inputs_to_delete;\n+    int i = 0;\n+    for (const auto& x : captured_inputs) {\n+      if (b->inputs()[i] == value_table[x]) {\n+        inputs_to_delete.push_back(i);\n+      }\n+      i++;\n+    }\n+\n+    for (auto ritr = inputs_to_delete.rbegin(); ritr != inputs_to_delete.rend();\n+         ++ritr) {\n+      auto name = captured_inputs[*ritr];\n+      Value* v = value_table[name];\n+      Value* orig = findInParentFrame(name);\n+      // Replace all matching node inputs with original value\n+      // from an enclosing scope\n+      v->replaceAllUsesWith(orig);\n+\n+      // Actually remove the input\n+      b->eraseInput(*ritr);\n+      captured_inputs.erase(captured_inputs.begin() + *ritr);\n+    }\n+  }\n+};", "path": "torch/csrc/jit/script/compiler.cpp", "position": null, "original_position": 105, "commit_id": "05aff78887f37d6385bd2ed0962b5ac84ce6cf52", "original_commit_id": "c6a6d159564a9b1010e8bc6adb5aab6a94d13715", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "body": "@apaszke I don't think maintaining compatibility with Python is a good idea. Right now our control flow operators are desugarable into functions which take lambdas as arguments; that is to say, environment semantics apply universally for all nodes which take graph arguments. It makes little sense to introduce special forms to the core language just to emulate Python's broken semantics.\r\n\r\nBetter is, if you really want the Python style behavior, to desugar a Python style AST into the structured one. That's not too hard, assuming that you can do a little bit of analysis.", "created_at": "2018-02-11T17:42:27Z", "updated_at": "2018-11-23T15:39:27Z", "html_url": "https://github.com/pytorch/pytorch/pull/5176#discussion_r167442933", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/5176", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/167442933"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/5176#discussion_r167442933"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/5176"}}, "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=4583066\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/apaszke\">@apaszke</a> I don't think maintaining compatibility with Python is a good idea. Right now our control flow operators are desugarable into functions which take lambdas as arguments; that is to say, environment semantics apply universally for all nodes which take graph arguments. It makes little sense to introduce special forms to the core language just to emulate Python's broken semantics.</p>\n<p>Better is, if you really want the Python style behavior, to desugar a Python style AST into the structured one. That's not too hard, assuming that you can do a little bit of analysis.</p>", "body_text": "@apaszke I don't think maintaining compatibility with Python is a good idea. Right now our control flow operators are desugarable into functions which take lambdas as arguments; that is to say, environment semantics apply universally for all nodes which take graph arguments. It makes little sense to introduce special forms to the core language just to emulate Python's broken semantics.\nBetter is, if you really want the Python style behavior, to desugar a Python style AST into the structured one. That's not too hard, assuming that you can do a little bit of analysis.", "in_reply_to_id": 167426841}