{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/168029160", "pull_request_review_id": 96329668, "id": 168029160, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2ODAyOTE2MA==", "diff_hunk": "@@ -34,23 +34,127 @@ using ListAttributeMap = std::unordered_map<\n     std::string,\n     std::pair<const std::vector<double>, std::string>>;\n \n+// Keep track of environment as we descend down nested control\n+// structures.\n+struct Environment {\n+  Environment(Block* b, std::shared_ptr<Environment> next = nullptr)\n+      : b(b), next(next) {}\n+\n+  std::vector<std::string> captured_inputs;\n+  ValueTable value_table;\n+  Block* b;\n+\n+  std::shared_ptr<Environment> next;\n+\n+  Value* findInThisFrame(const std::string& name) {\n+    if (value_table.count(name)) {\n+      return value_table.at(name);\n+    }\n+    return nullptr;\n+  }\n+\n+  Value* findInParentFrame(const std::string& name) {\n+    for (auto runner = next; runner; runner = runner->next) {\n+      if (runner->value_table.count(name)) {\n+        return runner->value_table.at(name);\n+      }\n+    }\n+    return nullptr;\n+  }\n+\n+  Value* createCapturedInput(const std::string& name) {\n+    // Create the input\n+    Value* new_input = b->addInput();\n+\n+    // Associate this name with this value\n+    value_table[name] = new_input;\n+\n+    // List as a positional input\n+    captured_inputs.push_back(name);\n+\n+    return new_input;\n+  }\n+\n+  Symbol getBlockOwningKind() {\n+    Symbol owning_kind = Symbol();\n+    if (b->owningNode()) {\n+      owning_kind = b->owningNode()->kind();\n+    }\n+    return owning_kind;\n+  }\n+\n+  void setVar(const std::string& name, Value* value) {\n+    if (!findInThisFrame(name) && findInParentFrame(name) &&\n+        getBlockOwningKind() == Symbol(\"Loop\"))\n+      createCapturedInput(name);\n+    value_table[name] = value;\n+  }\n+\n+  Value* getVar(const Ident& ident) {\n+    return getVar(ident.name(), ident);\n+  }\n+\n+  Value* getVar(const std::string& ident, const TreeView& tv) {\n+    Value* retval = findInThisFrame(ident);\n+\n+    if (!retval && (retval = findInParentFrame(ident)) &&\n+        getBlockOwningKind() == Symbol(\"Loop\"))\n+      retval = createCapturedInput(ident);\n+\n+    if (!retval) {\n+      throw ErrorReport(tv) << \"undefined value \" << ident;\n+    }\n+\n+    return retval;\n+  }\n+\n+  // Given that after emitting statements in a block, we've added block inputs\n+  // for all value references and assignments, delete inputs for which there was\n+  // no assignment, only references.\n+  void deleteExtraInputs(size_t skip_num = 0) {", "path": "torch/csrc/jit/script/compiler.cpp", "position": 115, "original_position": 81, "commit_id": "05aff78887f37d6385bd2ed0962b5ac84ce6cf52", "original_commit_id": "a7e15a0f61f2cf2d27c900cb2bd947bd5eeb7f7b", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "body": "I don't understand why do we need this. The whole contract of `getVar` + `deleteExtraInputs` is a bit unclear to me. Since we never want to add values we only retrieve in the body of the loop, then why do we have `Loop` special cased in `getVar` and not in `setVar` (i.e. lazily add a mutated input if it's not in the current scope). That would avoid the need for `deleteExtraInputs`", "created_at": "2018-02-13T22:53:42Z", "updated_at": "2018-11-23T15:39:34Z", "html_url": "https://github.com/pytorch/pytorch/pull/5176#discussion_r168029160", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/5176", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/168029160"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/5176#discussion_r168029160"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/5176"}}, "body_html": "<p>I don't understand why do we need this. The whole contract of <code>getVar</code> + <code>deleteExtraInputs</code> is a bit unclear to me. Since we never want to add values we only retrieve in the body of the loop, then why do we have <code>Loop</code> special cased in <code>getVar</code> and not in <code>setVar</code> (i.e. lazily add a mutated input if it's not in the current scope). That would avoid the need for <code>deleteExtraInputs</code></p>", "body_text": "I don't understand why do we need this. The whole contract of getVar + deleteExtraInputs is a bit unclear to me. Since we never want to add values we only retrieve in the body of the loop, then why do we have Loop special cased in getVar and not in setVar (i.e. lazily add a mutated input if it's not in the current scope). That would avoid the need for deleteExtraInputs"}