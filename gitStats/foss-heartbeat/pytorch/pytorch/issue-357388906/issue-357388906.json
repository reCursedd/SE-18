{"url": "https://api.github.com/repos/pytorch/pytorch/issues/11293", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/11293/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/11293/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/11293/events", "html_url": "https://github.com/pytorch/pytorch/pull/11293", "id": 357388906, "node_id": "MDExOlB1bGxSZXF1ZXN0MjEzNDE2OTEy", "number": 11293, "title": "Improves ATen CUDAEvent", "user": {"login": "mruberry", "id": 38511765, "node_id": "MDQ6VXNlcjM4NTExNzY1", "avatar_url": "https://avatars3.githubusercontent.com/u/38511765?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mruberry", "html_url": "https://github.com/mruberry", "followers_url": "https://api.github.com/users/mruberry/followers", "following_url": "https://api.github.com/users/mruberry/following{/other_user}", "gists_url": "https://api.github.com/users/mruberry/gists{/gist_id}", "starred_url": "https://api.github.com/users/mruberry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mruberry/subscriptions", "organizations_url": "https://api.github.com/users/mruberry/orgs", "repos_url": "https://api.github.com/users/mruberry/repos", "events_url": "https://api.github.com/users/mruberry/events{/privacy}", "received_events_url": "https://api.github.com/users/mruberry/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 7, "created_at": "2018-09-05T20:24:35Z", "updated_at": "2018-11-23T15:50:37Z", "closed_at": "2018-09-07T04:40:53Z", "author_association": "CONTRIBUTOR", "pull_request": {"url": "https://api.github.com/repos/pytorch/pytorch/pulls/11293", "html_url": "https://github.com/pytorch/pytorch/pull/11293", "diff_url": "https://github.com/pytorch/pytorch/pull/11293.diff", "patch_url": "https://github.com/pytorch/pytorch/pull/11293.patch"}, "body_html": "<p>After submitting PR <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"343790017\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/9726\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/pytorch/pytorch/pull/9726/hovercard\" href=\"https://github.com/pytorch/pytorch/pull/9726\">#9726</a>, PR <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"351229286\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/10581\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/pytorch/pytorch/pull/10581/hovercard\" href=\"https://github.com/pytorch/pytorch/pull/10581\">#10581</a> created a different CUDAEvent class. The CUDAEvent proposed in <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"343790017\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/9726\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/pytorch/pytorch/pull/9726/hovercard\" href=\"https://github.com/pytorch/pytorch/pull/9726\">#9726</a> was similar to the c10d::CUDAEvent class with additional testing and functionality. In particular, it was movable but not copyable. The CUDAEvent created by <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"351229286\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/10581\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/pytorch/pytorch/pull/10581/hovercard\" href=\"https://github.com/pytorch/pytorch/pull/10581\">#10581</a> is refcounted and copyable. This PR retains the refcounting of the latter PR while fixing several bugs, adding tests, and extending the functionality to support testing and usage like in PR <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"331398278\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/8354\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/pytorch/pytorch/pull/8354/hovercard\" href=\"https://github.com/pytorch/pytorch/pull/8354\">#8354</a>. In particular, this PR:</p>\n<ul>\n<li>Adds set_device() to CUDAContext</li>\n<li>Adds three CUDAEvent tests to stream_test.cpp</li>\n<li>Fixes three bugs:</li>\n<li>Refcounting was broken. Destroying an of the RAIIs holding a particular CUDAEvent would destroy the event UNLESS it was the last RAII (the check was backwards).</li>\n<li>Moving an event would cause a segfault.</li>\n<li>Events were not destroyed on the device they were created on. See PR <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"340898214\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/9415\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/pytorch/pytorch/pull/9415/hovercard\" href=\"https://github.com/pytorch/pytorch/pull/9415\">#9415</a> (<a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=9845\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/pietern\">@pietern</a>)</li>\n<li>Adds the happened() and recordOnce() functions</li>\n<li>Changes the record() functions to not be const</li>\n<li>Adds additional assertions to verify correctness</li>\n</ul>\n<p>This PR does not:</p>\n<ul>\n<li>Make c10d use the ATen CUDAEvent (this is appropriate for a separate PR)</li>\n</ul>\n<p>Whether events should be refcounted is an interesting question. It adds some atomic operations and makes event creation eager. Making events movable but not copyable (like the c10d events) avoids these costs and allows events to be lazily constructed. Lazy construction is preferable when working with containers (like std::array or std::vector) and because the event's device can be set automatically to the first stream it's recorded on. With eager construction the user is required to understand that events have a device and acquire the device of the stream the event will be recorded on upfront. This can be seen here:</p>\n<p><div class=\"border rounded-1 my-2\">\n  <div class=\"f6 px-3 py-2 lh-condensed border-bottom bg-gray-light\">\n    <p class=\"mb-0 text-bold\">\n      <a href=\"https://github.com/pytorch/pytorch/blob/542aadd9a7609892e207c1e15de08a975b697752/aten/src/ATen/native/cudnn/RNN.cpp#L1130-L1132\">pytorch/aten/src/ATen/native/cudnn/RNN.cpp</a>\n    </p>\n    <p class=\"mb-0 text-gray-light\">\n        Lines 1130 to 1132\n      in\n      <a data-pjax=\"true\" class=\"commit-tease-sha\" href=\"/pytorch/pytorch/commit/542aadd9a7609892e207c1e15de08a975b697752\">542aadd</a>\n    </p>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper blob-wrapper-embedded data\">\n    <table class=\"highlight tab-size mb-0 js-file-line-container\" data-tab-size=\"8\">\n\n        <tbody><tr class=\"border-0\">\n          <td id=\"L1130\" class=\"blob-num border-0 px-3 py-0 bg-white js-line-number\" data-line-number=\"1130\"></td>\n          <td id=\"LC1130\" class=\"blob-code border-0 px-3 py-0 bg-white blob-code-inner js-file-line\"> <span class=\"pl-c\"><span class=\"pl-c\">//</span> NB: CUDA binds the event to a device at creation time, so we can initialize it</span> </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L1131\" class=\"blob-num border-0 px-3 py-0 bg-white js-line-number\" data-line-number=\"1131\"></td>\n          <td id=\"LC1131\" class=\"blob-code border-0 px-3 py-0 bg-white blob-code-inner js-file-line\"> <span class=\"pl-c\"><span class=\"pl-c\">//</span> only now, when we know we're on the correct device.</span> </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L1132\" class=\"blob-num border-0 px-3 py-0 bg-white js-line-number\" data-line-number=\"1132\"></td>\n          <td id=\"LC1132\" class=\"blob-code border-0 px-3 py-0 bg-white blob-code-inner js-file-line\"> state.<span class=\"pl-smi\">event</span>.<span class=\"pl-c1\">emplace</span>(); </td>\n        </tr>\n    </tbody></table>\n  </div>\n</div>\n</p>\n<p>and that file is the only one which currently uses the ATen CUDAEvent.</p>\n<p>Refcounting does allow single writer multi-reader scenarios, although these scenarios can be also be supported by providing indirect access to the underlying CUDAEvent. I believe all current and planned usage scenarios do not require refcounting, and if desired I can update this PR to remove refcounting and make the ATen event movable but not copyable like the c10d event. I think not refcounting is preferable because it can improve performance, ease usability, and simplify the code (as seen with two of the above bugs).</p>\n<p>I have decided to separate this from PR <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"331398278\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/8354\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/pytorch/pytorch/pull/8354/hovercard\" href=\"https://github.com/pytorch/pytorch/pull/8354\">#8354</a> since while it's required for PR <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"331398278\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/8354\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/pytorch/pytorch/pull/8354/hovercard\" href=\"https://github.com/pytorch/pytorch/pull/8354\">#8354</a> the changes are, clearly, of independent interest. PR <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"331398278\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/8354\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/pytorch/pytorch/pull/8354/hovercard\" href=\"https://github.com/pytorch/pytorch/pull/8354\">#8354</a> has a new dependency on this one, however. I am closing PR <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"343790017\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/9726\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/pytorch/pytorch/pull/9726/hovercard\" href=\"https://github.com/pytorch/pytorch/pull/9726\">#9726</a> in favor of this PR.</p>\n<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=4583066\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/apaszke\">@apaszke</a> <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=13564\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/ezyang\">@ezyang</a> <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=9845\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/pietern\">@pietern</a></p>", "body_text": "After submitting PR #9726, PR #10581 created a different CUDAEvent class. The CUDAEvent proposed in #9726 was similar to the c10d::CUDAEvent class with additional testing and functionality. In particular, it was movable but not copyable. The CUDAEvent created by #10581 is refcounted and copyable. This PR retains the refcounting of the latter PR while fixing several bugs, adding tests, and extending the functionality to support testing and usage like in PR #8354. In particular, this PR:\n\nAdds set_device() to CUDAContext\nAdds three CUDAEvent tests to stream_test.cpp\nFixes three bugs:\nRefcounting was broken. Destroying an of the RAIIs holding a particular CUDAEvent would destroy the event UNLESS it was the last RAII (the check was backwards).\nMoving an event would cause a segfault.\nEvents were not destroyed on the device they were created on. See PR #9415 (@pietern)\nAdds the happened() and recordOnce() functions\nChanges the record() functions to not be const\nAdds additional assertions to verify correctness\n\nThis PR does not:\n\nMake c10d use the ATen CUDAEvent (this is appropriate for a separate PR)\n\nWhether events should be refcounted is an interesting question. It adds some atomic operations and makes event creation eager. Making events movable but not copyable (like the c10d events) avoids these costs and allows events to be lazily constructed. Lazy construction is preferable when working with containers (like std::array or std::vector) and because the event's device can be set automatically to the first stream it's recorded on. With eager construction the user is required to understand that events have a device and acquire the device of the stream the event will be recorded on upfront. This can be seen here:\n\n  \n    \n      pytorch/aten/src/ATen/native/cudnn/RNN.cpp\n    \n    \n        Lines 1130 to 1132\n      in\n      542aadd\n    \n    \n    \n    \n\n        \n          \n           // NB: CUDA binds the event to a device at creation time, so we can initialize it \n        \n\n        \n          \n           // only now, when we know we're on the correct device. \n        \n\n        \n          \n           state.event.emplace(); \n        \n    \n  \n\n\nand that file is the only one which currently uses the ATen CUDAEvent.\nRefcounting does allow single writer multi-reader scenarios, although these scenarios can be also be supported by providing indirect access to the underlying CUDAEvent. I believe all current and planned usage scenarios do not require refcounting, and if desired I can update this PR to remove refcounting and make the ATen event movable but not copyable like the c10d event. I think not refcounting is preferable because it can improve performance, ease usability, and simplify the code (as seen with two of the above bugs).\nI have decided to separate this from PR #8354 since while it's required for PR #8354 the changes are, clearly, of independent interest. PR #8354 has a new dependency on this one, however. I am closing PR #9726 in favor of this PR.\n@apaszke @ezyang @pietern", "body": "After submitting PR #9726, PR #10581 created a different CUDAEvent class. The CUDAEvent proposed in #9726 was similar to the c10d::CUDAEvent class with additional testing and functionality. In particular, it was movable but not copyable. The CUDAEvent created by #10581 is refcounted and copyable. This PR retains the refcounting of the latter PR while fixing several bugs, adding tests, and extending the functionality to support testing and usage like in PR #8354. In particular, this PR:\r\n\r\n- Adds set_device() to CUDAContext\r\n- Adds three CUDAEvent tests to stream_test.cpp \r\n- Fixes three bugs:\r\n- Refcounting was broken. Destroying an of the RAIIs holding a particular CUDAEvent would destroy the event UNLESS it was the last RAII (the check was backwards).\r\n- Moving an event would cause a segfault.\r\n- Events were not destroyed on the device they were created on. See PR #9415 (@pietern)\r\n- Adds the happened() and recordOnce() functions\r\n- Changes the record() functions to not be const\r\n- Adds additional assertions to verify correctness\r\n\r\nThis PR does not:\r\n\r\n- Make c10d use the ATen CUDAEvent (this is appropriate for a separate PR)\r\n\r\nWhether events should be refcounted is an interesting question. It adds some atomic operations and makes event creation eager. Making events movable but not copyable (like the c10d events) avoids these costs and allows events to be lazily constructed. Lazy construction is preferable when working with containers (like std::array or std::vector) and because the event's device can be set automatically to the first stream it's recorded on. With eager construction the user is required to understand that events have a device and acquire the device of the stream the event will be recorded on upfront. This can be seen here:\r\n\r\nhttps://github.com/pytorch/pytorch/blob/542aadd9a7609892e207c1e15de08a975b697752/aten/src/ATen/native/cudnn/RNN.cpp#L1130-L1132\r\n\r\nand that file is the only one which currently uses the ATen CUDAEvent.\r\n\r\nRefcounting does allow single writer multi-reader scenarios, although these scenarios can be also be supported by providing indirect access to the underlying CUDAEvent. I believe all current and planned usage scenarios do not require refcounting, and if desired I can update this PR to remove refcounting and make the ATen event movable but not copyable like the c10d event. I think not refcounting is preferable because it can improve performance, ease usability, and simplify the code (as seen with two of the above bugs). \r\n\r\nI have decided to separate this from PR #8354 since while it's required for PR #8354 the changes are, clearly, of independent interest. PR #8354 has a new dependency on this one, however. I am closing PR #9726 in favor of this PR. \r\n\r\n@apaszke @ezyang @pietern "}