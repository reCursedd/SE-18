{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/208068570", "pull_request_review_id": 143805907, "id": 208068570, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwODA2ODU3MA==", "diff_hunk": "@@ -899,8 +899,13 @@ struct to_ir {\n     // Register outputs in each block\n     for (const auto& x : mutated_variables) {\n       auto tv = save_true->getVar(x, stmt.range());\n-      true_block->registerOutput(tv);\n       auto fv = save_false->getVar(x, stmt.range());\n+      if (!tv->type()->isSubtypeOf(unshapedType(fv->type()))) {", "path": "torch/csrc/jit/script/compiler.cpp", "position": null, "original_position": 6, "commit_id": "624f11f604758f6f58bddba3f0d9912df4ac86c9", "original_commit_id": "8e310c29ad4e5990f86ec6e7569fcef6cc3f7d91", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "body": "Consider that the false branch produces a value of type `ft` and the true branch produces a value of type `tt`, which is different than `ft`, but happens to be a subtype of it. This conditional will accept it, but if someone were to negate the condition and swap the branches, then it would actually get rejected. This is counterintuitive and this shouldn't happen, and I see two ways to fix it:\r\n1. Check for type equality (very strict, very easy, should work well for now)\r\n2. Have a type unification function. For example you can unify `Dynamic` with `Float(2, 50)`, because the other one is a refinement of the first one. But it is a commutative property, so `Float(2, 50)` also has to unify with `Dynamic`. Considering the simplicity of our type system it's not hard to write a function that verifies whether two types can be unified, but it might be an overkill at this point.", "created_at": "2018-08-07T00:41:53Z", "updated_at": "2018-11-23T15:48:52Z", "html_url": "https://github.com/pytorch/pytorch/pull/10281#discussion_r208068570", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/10281", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/208068570"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/10281#discussion_r208068570"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/10281"}}, "body_html": "<p>Consider that the false branch produces a value of type <code>ft</code> and the true branch produces a value of type <code>tt</code>, which is different than <code>ft</code>, but happens to be a subtype of it. This conditional will accept it, but if someone were to negate the condition and swap the branches, then it would actually get rejected. This is counterintuitive and this shouldn't happen, and I see two ways to fix it:</p>\n<ol>\n<li>Check for type equality (very strict, very easy, should work well for now)</li>\n<li>Have a type unification function. For example you can unify <code>Dynamic</code> with <code>Float(2, 50)</code>, because the other one is a refinement of the first one. But it is a commutative property, so <code>Float(2, 50)</code> also has to unify with <code>Dynamic</code>. Considering the simplicity of our type system it's not hard to write a function that verifies whether two types can be unified, but it might be an overkill at this point.</li>\n</ol>", "body_text": "Consider that the false branch produces a value of type ft and the true branch produces a value of type tt, which is different than ft, but happens to be a subtype of it. This conditional will accept it, but if someone were to negate the condition and swap the branches, then it would actually get rejected. This is counterintuitive and this shouldn't happen, and I see two ways to fix it:\n\nCheck for type equality (very strict, very easy, should work well for now)\nHave a type unification function. For example you can unify Dynamic with Float(2, 50), because the other one is a refinement of the first one. But it is a commutative property, so Float(2, 50) also has to unify with Dynamic. Considering the simplicity of our type system it's not hard to write a function that verifies whether two types can be unified, but it might be an overkill at this point."}