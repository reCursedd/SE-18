{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/167835774", "pull_request_review_id": 96108460, "id": 167835774, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2NzgzNTc3NA==", "diff_hunk": "@@ -0,0 +1,285 @@\n+import torch\n+import sys\n+import ast\n+import inspect\n+from functools import partial\n+from collections import namedtuple\n+from torch._C._jit_tree_views import *\n+\n+# TODO: improve error reporting (show source)\n+#       once this is done, convert all asserts into checks with nicer error messages\n+\n+PY2 = sys.version_info[0] == 2\n+_reserved_prefix = '__jit'\n+\n+\n+def get_jit_ast(fn):\n+    source = dedent(inspect.getsource(fn))\n+    py_ast = ast.parse(source)\n+    if len(py_ast.body) != 1 or not isinstance(py_ast.body[0], ast.FunctionDef):\n+        raise RuntimeError(\"expected a single top-level function\")\n+    return build_def(SourceRangeFactory(source), py_ast.body[0])\n+\n+\n+def dedent(source):\n+    lines = source.split('\\n')\n+    indent_depth = 0\n+    while lines[0][indent_depth] == ' ':\n+        indent_depth += 1\n+    return '\\n'.join(l[indent_depth:] for l in lines)\n+\n+\n+class Builder(object):\n+    def __call__(self, ctx, node):\n+        try:\n+            method = getattr(self, 'build_' + node.__class__.__name__)\n+        except AttributeError:\n+            raise RuntimeError(node.__class__.__name__ + \" isn't a supported Python feature\")\n+        return method(ctx, node)\n+\n+\n+class CountReturns(ast.NodeVisitor):\n+    def __init__(self):\n+        self.num_returns = 0\n+\n+    def visit_Return(self, ret):\n+        self.num_returns += 1\n+\n+    @staticmethod\n+    def get_count(py_def):\n+        counter = CountReturns()\n+        counter.visit(py_def)\n+        return counter.num_returns\n+\n+\n+_ret_err_msg = (\"JIT-ed functions can only have a single return, \"\n+                \"and it has to be the last statement in the body\")\n+\n+\n+def build_def(ctx, py_def):\n+    assert len(py_def.decorator_list) == 0\n+    returns = []\n+    ret_body = []\n+    body = py_def.body\n+    num_returns = CountReturns.get_count(py_def)\n+    if num_returns == 1:\n+        ret_stmt, body = body[-1], body[:-1]\n+        if not isinstance(ret_stmt, ast.Return):\n+            raise ValueError(_ret_err_msg)\n+        ret_expr = ret_stmt.value\n+        ret_vals = ret_expr.elts if isinstance(ret_expr, ast.Tuple) else [ret_expr]\n+        for i, val in enumerate(ret_vals):\n+            val_expr = build_expr(ctx, val)\n+            val_name = _reserved_prefix + '_' + str(i)\n+            r = val_expr.range()\n+            returns.append(Param(TensorType(r), Ident(r, val_name)))\n+            ret_body.append(Assign([Ident(r, val_name)], '=', val_expr))\n+    elif num_returns > 1:\n+        raise ValueError(_ret_err_msg)\n+    r = ctx.make_range(py_def.lineno, py_def.col_offset,\n+                       py_def.col_offset + len(\"def\"))\n+    return Def(Ident(r, py_def.name),\n+               build_param_list(ctx, py_def.args),\n+               returns,\n+               build_stmt_list(ctx, body) + ret_body)\n+\n+\n+def build_param_list(ctx, py_args):\n+    assert py_args.vararg is None\n+    assert py_args.kwarg is None\n+    assert not py_args.defaults\n+    if PY2:\n+        # TODO: args are in py_args.args, but are expressions <sigh>\n+        raise RuntimeError(\"PY2 not supported\")\n+    else:\n+        assert not py_args.kwonlyargs\n+        assert not py_args.kw_defaults\n+        return [build_param(ctx, arg) for arg in py_args.args]\n+\n+\n+def build_param(ctx, py_arg):\n+    assert py_arg.annotation is None  # TODO: handle annotations to get types\n+    name = py_arg.arg\n+    r = ctx.make_range(py_arg.lineno, py_arg.col_offset, py_arg.col_offset + len(name))\n+    return Param(TensorType(r), Ident(r, name))\n+\n+\n+def build_stmt_list(ctx, py_stmt_list):\n+    return [build_stmt(ctx, stmt) for stmt in py_stmt_list]\n+\n+\n+class StmtBuilder(Builder):\n+    augassign_map = {\n+        ast.Add: '+',\n+        ast.Sub: '-',\n+        ast.Mult: '*',\n+        ast.Div: '/',\n+    }\n+\n+    @staticmethod\n+    def build_Expr(ctx, stmt):\n+        return ExprStmt(build_expr(ctx, stmt.value))\n+\n+    @staticmethod\n+    def get_assign_ident(ctx, expr):\n+        var = build_expr(ctx, expr)\n+        if not isinstance(var, Var):\n+            raise RuntimeError(\"the only expressions allowed on the left hand side of \"\n+                               \"assignments are variable names\")\n+        return var.name()\n+\n+    @staticmethod\n+    def build_Assign(ctx, stmt):\n+        return Assign([StmtBuilder.get_assign_ident(ctx, e) for e in stmt.targets],\n+                      '=',\n+                      build_expr(ctx, stmt.value))\n+\n+    @staticmethod\n+    def build_AugAssign(ctx, stmt):\n+        op = type(stmt.op)\n+        if op in StmtBuilder.augassign_map:\n+            op_token = StmtBuilder.augassign_map[op]\n+        else:\n+            raise RuntimeError(\"unsupported kind of augumented assignment: \" + op.__name__)\n+        return Assign([StmtBuilder.get_assign_ident(ctx, stmt.target)],\n+                      op_token,\n+                      build_expr(ctx, stmt.value))\n+\n+    @staticmethod\n+    def build_While(ctx, stmt):\n+        if stmt.orelse:\n+            raise RuntimeError(\"else branches of while loops aren't supported\")\n+        r = ctx.make_range(stmt.lineno, stmt.col_offset, stmt.col_offset + len(\"while\"))\n+        return While(r, build_expr(ctx, stmt.test), [build_stmt(ctx, s) for s in stmt.body])\n+\n+    @staticmethod\n+    def build_If(ctx, stmt):\n+        r = ctx.make_range(stmt.lineno, stmt.col_offset, stmt.col_offset + len(\"if\"))\n+        return If(r, build_expr(ctx, stmt.test),\n+                  [build_stmt(ctx, s) for s in stmt.body],\n+                  [build_stmt(ctx, s) for s in stmt.orelse])\n+\n+\n+class ExprBuilder(Builder):\n+    _MethodRef = namedtuple('MethodRef', ['self', 'name'])\n+    binop_map = {\n+        ast.Add: partial(BinOp, '+'),\n+        ast.Sub: partial(BinOp, '-'),\n+        ast.Mult: partial(BinOp, '*'),\n+        ast.Div: partial(BinOp, '/'),\n+    }\n+\n+    unop_map = {\n+        ast.Not: (UnaryOp, 'not'),\n+        ast.USub: (UnaryOp, '-'),\n+    }\n+\n+    boolop_map = {\n+        ast.And: partial(BinOp, 'and'),\n+        ast.Or: partial(BinOp, 'or'),\n+    }\n+\n+    cmpop_map = {\n+        ast.Eq: partial(BinOp, '=='),\n+        ast.NotEq: partial(BinOp, '!='),\n+        ast.LtE: partial(BinOp, '<='),\n+        ast.Lt: partial(BinOp, '<'),\n+        ast.GtE: partial(BinOp, '>='),\n+        ast.Gt: partial(BinOp, '>'),\n+    }\n+\n+    @staticmethod\n+    def build_Attribute(ctx, expr):\n+        # NB: the only attributes we support are for getting methods\n+        value = build_expr(ctx, expr.value)\n+        return ExprBuilder._MethodRef(value, Ident(value.range(), expr.attr))\n+\n+    @staticmethod\n+    def build_Call(ctx, expr):\n+        ref = build_expr(ctx, expr.func, allow_methods=True)\n+        assert type(ref) is ExprBuilder._MethodRef", "path": "torch/jit/python_frontend.py", "position": null, "original_position": 200, "commit_id": "c7d017de191eb1be80fd293bfbb5b04f79bad0be", "original_commit_id": "eecec783f2c3f082cd9cdb535e14e5bbaed11912", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "body": "Yes, I put a TODO for error messages at the top and wanted to tackle that as the next change once this lands. Adding nice error handling, with source printing and all that will be +50% code, so I wanted to get this in first, and then convert all ugly asserts and vague \"not supported\" messages to something better.", "created_at": "2018-02-13T11:26:53Z", "updated_at": "2018-11-23T15:39:32Z", "html_url": "https://github.com/pytorch/pytorch/pull/5190#discussion_r167835774", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/5190", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/167835774"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/5190#discussion_r167835774"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/5190"}}, "body_html": "<p>Yes, I put a TODO for error messages at the top and wanted to tackle that as the next change once this lands. Adding nice error handling, with source printing and all that will be +50% code, so I wanted to get this in first, and then convert all ugly asserts and vague \"not supported\" messages to something better.</p>", "body_text": "Yes, I put a TODO for error messages at the top and wanted to tackle that as the next change once this lands. Adding nice error handling, with source printing and all that will be +50% code, so I wanted to get this in first, and then convert all ugly asserts and vague \"not supported\" messages to something better.", "in_reply_to_id": 167745720}