{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/234528243", "pull_request_review_id": 176184916, "id": 234528243, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNDUyODI0Mw==", "diff_hunk": "@@ -465,32 +465,146 @@ class MethodEncoder : public EncoderBase {\n                       const TypePtr& type,\n                       const std::string& name);\n \n-  PyTorchStreamWriter* stream_writer_;\n-  // Used to deduplicate tensor storages\n-  std::unordered_map<const void*, uint64_t>* storage_dedup_map_;\n-\n-  // Used to keep track of Parameter names so Methods can refer to them\n-  std::unordered_map<at::Tensor*, std::string>* parameter_map_;\n+  // serializer already serialized all the tensors, and stores\n+  // the tensor and parameter tables\n+  const ScriptModuleSerializer* serializer_;\n \n   // Used to create sequential dummy names for node types\n   size_t type_counter_ = 0;\n };\n \n+// this is a serializer class which saves script modules to pt files. the\n+// content of the file is written using PyTorchStreamWriter, for details please\n+// check caffe2/serialize/inline_container.h. all the records except the last\n+// one are tensor data, and the last record is a serialized ModelProto, defined\n+// in caffe2/proto/torch.proto. ModelProto contains all the metadata of the\n+// model, and it is serialized as json.\n+class ScriptModuleSerializer final {\n+ public:\n+  ScriptModuleSerializer(const std::string& filename);\n+\n+  ScriptModuleSerializer(std::ostream* ofs);\n+\n+  void serialize(const script::Module& module);\n+\n+  const std::unordered_map<const at::Tensor*, uint64_t>& tensorTable() const;\n+\n+  const std::unordered_map<const at::Tensor*, std::string>& paramMap() const;\n+\n+ private:\n+  void convertToModel(\n+      const script::Module& module,\n+      torch::ModelDef* model_def);\n+\n+  // add a tensor to the tensorTable\n+  void addTensor(const at::Tensor* tensor);\n+\n+  // recursively collect the tensors in a block and add them to the tensorTable\n+  void findTensorInBlock(const Block& block);\n+\n+  // recursively iterate over the whole module to collect the information of\n+  // tensors and parameters\n+  void collectInfo(\n+      const script::Module& module,\n+      const std::string& prefix);\n+\n+  // write the content of the tensor to the file/stream, and save the\n+  // offset in the storageMap_\n+  void convertAndWriteTensor(\n+      const at::Tensor& tensor,\n+      caffe2::TensorProto* tensor_proto);\n+\n+  // dump all the tensors in the tensorTable_ to a ModelDef (metadata) and\n+  // the file/stream (the content), assuming all the information of the\n+  // tensors has been collected. the method calls convertAndWriteTensor\n+  // to dump the content of a tensor\n+  void writeTensorTable(torch::ModelDef* model_def);\n+\n+  void convertModule(\n+      const script::Module& module,\n+      const std::string& name,\n+      torch::ModuleDef* module_def);\n+\n+  void convertParameter(\n+      const script::NamedParameter& param,\n+      torch::ParameterDef* param_def);\n+\n+  void convertMethod(const script::Method& method, torch::MethodDef* method_def);\n+\n+  std::ofstream ofs_;\n+  PyTorchStreamWriter writer_;\n+  // storage_ptr => record_offset\n+  std::unordered_map<const void*, uint64_t> storageMap_;\n+  // tensor => param name\n+  std::unordered_map<const at::Tensor*, std::string> paramMap_;\n+  // tensor => tensor_id\n+  std::unordered_map<const at::Tensor*, uint64_t> tensorTable_;\n+  // used for generating table id for tensors\n+  uint64_t nextTensorId_ = 0;\n+};\n+\n+// MethodEncoder's methods\n MethodEncoder::MethodEncoder(\n     const script::Method& method,\n     std::string* torch_script,\n-    std::unordered_map<const void*, uint64_t>* storage_map,\n-    std::unordered_map<at::Tensor*, std::string>* parameter_map,\n-    PyTorchStreamWriter* writer)\n+    const ScriptModuleSerializer& serializer)\n     : EncoderBase(onnx_torch::OperatorExportTypes::RAW, false) {\n-  storage_dedup_map_ = storage_map;\n-  parameter_map_ = parameter_map;\n-  stream_writer_ = writer;\n   // we already keep the tree structure in the top level module,\n   // so pass \"\" as prefix\n+  serializer_ = &serializer;\n   EncodeMethod(torch_script, method, \"\");\n }\n \n+void MethodEncoder::EncodeMethod(\n+    std::string* torch_script,\n+    const script::Method& method,\n+    const std::string prefix) {\n+  onnx::ModelProto model_proto;\n+  model_proto.set_doc_string(\"THIS PROTO IS NOT STANDARD ONNX\");\n+  auto* node_proto = model_proto.mutable_graph()->add_node();\n+  node_proto->set_name(prefix + method.name());\n+  if (method.is_optimized()) {\n+    // mark that this method was optimized\n+    node_proto->set_domain(\"optimized\");\n+  }\n+\n+  // We store the schema string in the docstring.\n+  node_proto->set_doc_string(getExportableSchemaStringForMethod(method));\n+\n+  // Store member_inputs of Method in input\n+  for (auto &member_input : method.params()) {\n+    auto it = serializer_->paramMap().find(member_input);", "path": "torch/csrc/jit/export.cpp", "position": null, "original_position": 144, "commit_id": "f84ce89ab22f13e24b110956e3e67c94bd02e7c1", "original_commit_id": "5a7586ced56bd9d39add9d34766f428e7b217abf", "user": {"login": "houseroad", "id": 30275821, "node_id": "MDQ6VXNlcjMwMjc1ODIx", "avatar_url": "https://avatars0.githubusercontent.com/u/30275821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/houseroad", "html_url": "https://github.com/houseroad", "followers_url": "https://api.github.com/users/houseroad/followers", "following_url": "https://api.github.com/users/houseroad/following{/other_user}", "gists_url": "https://api.github.com/users/houseroad/gists{/gist_id}", "starred_url": "https://api.github.com/users/houseroad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/houseroad/subscriptions", "organizations_url": "https://api.github.com/users/houseroad/orgs", "repos_url": "https://api.github.com/users/houseroad/repos", "events_url": "https://api.github.com/users/houseroad/events{/privacy}", "received_events_url": "https://api.github.com/users/houseroad/received_events", "type": "User", "site_admin": false}, "body": "agree, will do it\r\n", "created_at": "2018-11-19T08:34:51Z", "updated_at": "2018-11-23T15:55:09Z", "html_url": "https://github.com/pytorch/pytorch/pull/13861#discussion_r234528243", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/13861", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/234528243"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/13861#discussion_r234528243"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/13861"}}, "body_html": "<p>agree, will do it</p>", "body_text": "agree, will do it", "in_reply_to_id": 234518959}