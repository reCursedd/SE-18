{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/297754244", "html_url": "https://github.com/pytorch/pytorch/issues/1080#issuecomment-297754244", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/1080", "id": 297754244, "node_id": "MDEyOklzc3VlQ29tbWVudDI5Nzc1NDI0NA==", "user": {"login": "fmassa", "id": 9110200, "node_id": "MDQ6VXNlcjkxMTAyMDA=", "avatar_url": "https://avatars2.githubusercontent.com/u/9110200?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fmassa", "html_url": "https://github.com/fmassa", "followers_url": "https://api.github.com/users/fmassa/followers", "following_url": "https://api.github.com/users/fmassa/following{/other_user}", "gists_url": "https://api.github.com/users/fmassa/gists{/gist_id}", "starred_url": "https://api.github.com/users/fmassa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fmassa/subscriptions", "organizations_url": "https://api.github.com/users/fmassa/orgs", "repos_url": "https://api.github.com/users/fmassa/repos", "events_url": "https://api.github.com/users/fmassa/events{/privacy}", "received_events_url": "https://api.github.com/users/fmassa/received_events", "type": "User", "site_admin": false}, "created_at": "2017-04-27T15:45:44Z", "updated_at": "2017-04-27T15:45:44Z", "author_association": "MEMBER", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=4529377\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/killeent\">@killeent</a> This code supports advanced indexing as described in <a href=\"https://docs.scipy.org/doc/numpy/reference/arrays.indexing.html#integer-array-indexing\" rel=\"nofollow\">https://docs.scipy.org/doc/numpy/reference/arrays.indexing.html#integer-array-indexing</a></p>\n<p>Combining advanced and basic indexing is supported with the same behavior as numpy, the restriction at the moment is that I don't take into account partial slices (<code>a[1:3]</code>), for example</p>\n<div class=\"highlight highlight-source-python\"><pre>x <span class=\"pl-k\">=</span> np.random.random((<span class=\"pl-c1\">10</span>, <span class=\"pl-c1\">20</span>, <span class=\"pl-c1\">30</span>, <span class=\"pl-c1\">40</span>, <span class=\"pl-c1\">50</span>))\nx[:, [<span class=\"pl-c1\">1</span>,<span class=\"pl-c1\">2</span>], :, [<span class=\"pl-c1\">2</span>,<span class=\"pl-c1\">3</span>], [<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">3</span>]] <span class=\"pl-c\"><span class=\"pl-c\">#</span> supported in the snippet, no partial slice</span>\nx[<span class=\"pl-c1\">1</span>:<span class=\"pl-c1\">2</span>, [<span class=\"pl-c1\">1</span>,<span class=\"pl-c1\">2</span>], <span class=\"pl-c1\">1</span>:<span class=\"pl-c1\">3</span>, [<span class=\"pl-c1\">2</span>,<span class=\"pl-c1\">3</span>], [<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">3</span>]] <span class=\"pl-c\"><span class=\"pl-c\">#</span> not supported because of slices</span></pre></div>\n<p>In order to support partial slicing, what I'd do is to first perform the partial slicing over all dimensions, and then apply the advanced indexing. Something like</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-c\"><span class=\"pl-c\">#</span> I want x[1:2, [1,2], 1:3, [2,3], [1, 3]]</span>\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> first perform basic indexing</span>\ntemp <span class=\"pl-k\">=</span> x[<span class=\"pl-c1\">1</span>:<span class=\"pl-c1\">2</span>, :, <span class=\"pl-c1\">1</span>:<span class=\"pl-c1\">3</span>, :, :]\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> now apply advanced indexing</span>\nx_final <span class=\"pl-k\">=</span> temp[:, [<span class=\"pl-c1\">1</span>,<span class=\"pl-c1\">2</span>], :, [<span class=\"pl-c1\">2</span>,<span class=\"pl-c1\">3</span>], [<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">3</span>]]</pre></div>\n<p>In the bottom of the gist there are some examples comparing the implementation with numpy one.</p>\n<p>The idea of the linear index can be better explained with an example: for a tensor <code>x</code> of size <code>(5, 5)</code>, say we want to index it following <code>x[[0, 1], [1, 2]]</code>. This is equivalent to view <code>x</code> as a 1d tensor, and perform an <code>index_select</code> using as indices the linear indices corresponding to <code>[[0, 1], [1, 2]]</code>, which for a <code>5x5</code> tensor is <code>[1, 7]</code>.</p>\n<p>Please let me know if I wasn't clear.</p>", "body_text": "@killeent This code supports advanced indexing as described in https://docs.scipy.org/doc/numpy/reference/arrays.indexing.html#integer-array-indexing\nCombining advanced and basic indexing is supported with the same behavior as numpy, the restriction at the moment is that I don't take into account partial slices (a[1:3]), for example\nx = np.random.random((10, 20, 30, 40, 50))\nx[:, [1,2], :, [2,3], [1, 3]] # supported in the snippet, no partial slice\nx[1:2, [1,2], 1:3, [2,3], [1, 3]] # not supported because of slices\nIn order to support partial slicing, what I'd do is to first perform the partial slicing over all dimensions, and then apply the advanced indexing. Something like\n# I want x[1:2, [1,2], 1:3, [2,3], [1, 3]]\n# first perform basic indexing\ntemp = x[1:2, :, 1:3, :, :]\n# now apply advanced indexing\nx_final = temp[:, [1,2], :, [2,3], [1, 3]]\nIn the bottom of the gist there are some examples comparing the implementation with numpy one.\nThe idea of the linear index can be better explained with an example: for a tensor x of size (5, 5), say we want to index it following x[[0, 1], [1, 2]]. This is equivalent to view x as a 1d tensor, and perform an index_select using as indices the linear indices corresponding to [[0, 1], [1, 2]], which for a 5x5 tensor is [1, 7].\nPlease let me know if I wasn't clear.", "body": "@killeent This code supports advanced indexing as described in https://docs.scipy.org/doc/numpy/reference/arrays.indexing.html#integer-array-indexing \r\n\r\nCombining advanced and basic indexing is supported with the same behavior as numpy, the restriction at the moment is that I don't take into account partial slices (`a[1:3]`), for example\r\n```python\r\nx = np.random.random((10, 20, 30, 40, 50))\r\nx[:, [1,2], :, [2,3], [1, 3]] # supported in the snippet, no partial slice\r\nx[1:2, [1,2], 1:3, [2,3], [1, 3]] # not supported because of slices\r\n```\r\nIn order to support partial slicing, what I'd do is to first perform the partial slicing over all dimensions, and then apply the advanced indexing. Something like\r\n```python\r\n# I want x[1:2, [1,2], 1:3, [2,3], [1, 3]]\r\n# first perform basic indexing\r\ntemp = x[1:2, :, 1:3, :, :]\r\n# now apply advanced indexing\r\nx_final = temp[:, [1,2], :, [2,3], [1, 3]]\r\n```\r\n\r\nIn the bottom of the gist there are some examples comparing the implementation with numpy one.\r\n\r\nThe idea of the linear index can be better explained with an example: for a tensor `x` of size `(5, 5)`, say we want to index it following `x[[0, 1], [1, 2]]`. This is equivalent to view `x` as a 1d tensor, and perform an `index_select` using as indices the linear indices corresponding to `[[0, 1], [1, 2]]`, which for a `5x5` tensor is `[1, 7]`.\r\n\r\nPlease let me know if I wasn't clear."}