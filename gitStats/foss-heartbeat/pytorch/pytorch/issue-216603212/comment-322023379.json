{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/322023379", "html_url": "https://github.com/pytorch/pytorch/issues/1080#issuecomment-322023379", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/1080", "id": 322023379, "node_id": "MDEyOklzc3VlQ29tbWVudDMyMjAyMzM3OQ==", "user": {"login": "xuancong84", "id": 10172392, "node_id": "MDQ6VXNlcjEwMTcyMzky", "avatar_url": "https://avatars0.githubusercontent.com/u/10172392?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xuancong84", "html_url": "https://github.com/xuancong84", "followers_url": "https://api.github.com/users/xuancong84/followers", "following_url": "https://api.github.com/users/xuancong84/following{/other_user}", "gists_url": "https://api.github.com/users/xuancong84/gists{/gist_id}", "starred_url": "https://api.github.com/users/xuancong84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xuancong84/subscriptions", "organizations_url": "https://api.github.com/users/xuancong84/orgs", "repos_url": "https://api.github.com/users/xuancong84/repos", "events_url": "https://api.github.com/users/xuancong84/events{/privacy}", "received_events_url": "https://api.github.com/users/xuancong84/received_events", "type": "User", "site_admin": false}, "created_at": "2017-08-13T05:46:18Z", "updated_at": "2017-08-13T07:06:28Z", "author_association": "NONE", "body_html": "<p>Actually, I do fully understand the non-adjacent advanced indexing logic. But I don't think its design is good enough.<br>\nConsider the following example,</p>\n<pre><code>x = np.random.random((10, 20, 30, 40, 50))\nidx1 = [1, 8, 5]\nidx2 = [4, 1, 6]\n</code></pre>\n<p>In the current indexing logic design, the very fact that it matters whether the two indexing arrays (idx1 and idx2) are adjacent to each other or not, is because it could mean two things when multiple indexing arrays are provided:<br>\n1). <strong>tensor slicing</strong>. x[:, idx1, idx2, :, :] could mean that along the 2nd dimension, we choose slices with indices idx1, and along the 3rd dimension, we choose slices with indices idx2.<br>\n2). <strong>multi-point selection</strong>. x[:, idx1, idx2, :, :] could mean that in the subspace formed by the 2nd and 3rd dimension, we choose points [(1,4), (8,1), (5,6)], which are in fact [(idx1[0], idx2[0]), (idx1[1], idx2[1]), (idx1[2], idx2[2])]. Therefore, idx1 and idx2 must have the same number of elements. (In fact, it will throw exception if idx1 and idx2 have different number of elements.)<br>\nTake note that 1) and 2) are the same if there is only one indexing array, e.g., x[:, idx1, :, :, :], x[:, :, :, idx2, :]</p>\n<p>Do take note that the difference between 1) and 2) is that:<br>\n<strong>In 1)</strong>, all the len(idx1)*len(idx2)=9 points are chosen. The subspace formed by the 2nd and 3rd dimension is a 20-by-30 grid plane, choosing [1, 8, 5] along the 2nd dimension (with max size 20), and choosing [4, 1, 6] along the 3rd dimension (with max size 30), this will end up with all the 3x3=9 points [(1,4), (1,1), (1,6), (8,4), (8,1), (8,6), (5,4), (5,1), (5,6)]. In this way, you cannot arbitrarily select any number of any points in this subspace.<br>\n<strong>In 2)</strong>, you have the freedom to select any number of any points in the 20-by-30 grid subspace. However, if you would like to extract N slices along the 2nd dimension and M slices along the 3rd dimension, then you need to list down all the N*M pairs of coordinates, i.e., len(idx1)=len(idx2)=N*M, which is very tedious to list down.</p>\n<p>The problem with the current indexing logic is that it is neither self-consistent nor systematic. This is because even though idx1 and idx2 are not adjacent, you can still perform multi-point selection. Take 3D space for example, <code>y=np.random.random((10, 20, 30))</code>, y[idx1, :, idx2] means select the 3 points along the X-Z plane. And there is no reason why you must order the multi-point-selection dimension to the beginning just because idx1 and idx2 are adjacent. Instead, you could adopt either one of the following two conventions:</p>\n<ol>\n<li>always bring to the front, e.g.,</li>\n</ol>\n<pre><code>x[:, idx1, idx2, :, :].shape=(3, 10, 40, 50)\nx[:, idx1, :, idx2, :].shape=(3, 10, 30, 50)\n</code></pre>\n<ol start=\"2\">\n<li>stick to the 1st multi-point-selection coordinate dimension, e.g.,</li>\n</ol>\n<pre><code>x[:, idx1, idx2, :, :].shape=(10, 3, 40, 50)\nx[:, idx1, :, idx2, :].shape=(10, 3, 30, 50)\nx[:, :, idx1, idx2, :].shape=(10, 20, 3, 50)\nx[:, :, idx1, :, idx2].shape=(10, 20, 3, 40)\n</code></pre>\n<p>A more elegant design would be the following:<br>\na) use list for <strong>tensor slicing</strong> and use tuple for <strong>multi-point selection</strong>, or the other way round if you do not want to break compatibility with previous version.<br>\nb) adopt Convention 1, always bring the multi-point-selection dimension to the front, because both <strong>tensor slicing</strong> and <strong>multi-point selection</strong> can co-exist, and you don't want to mess up. For example, x[:, [2, 8, 5, 3], (2, 4, 6), [4, 9, 6], (3, 5, 7)] means take slices 2,8,5,3 along the 2nd dimension, take slices 4,9,6 along the 4th dimension, in the subspace plane formed by the 3rd and 5th dimension, select points (2,3), (4,5) and (6,7).<br>\nc) use a trailing comma to denote aligning dimensions from the left, e.g., for x[:, idx1, :,], idx1 refers to the 2nd dimension; use a preceding comma to denote aligning dimensions from the right, e.g., for x[, :, idx1, :], idx1 refers to the 4th dimension. If neither trailing comma nor preceding comma exist, and the indices dimension is less than the tensor dimension, then default to the current (aligning from the left).</p>\n<p>This would make things much simpler and clearer!</p>", "body_text": "Actually, I do fully understand the non-adjacent advanced indexing logic. But I don't think its design is good enough.\nConsider the following example,\nx = np.random.random((10, 20, 30, 40, 50))\nidx1 = [1, 8, 5]\nidx2 = [4, 1, 6]\n\nIn the current indexing logic design, the very fact that it matters whether the two indexing arrays (idx1 and idx2) are adjacent to each other or not, is because it could mean two things when multiple indexing arrays are provided:\n1). tensor slicing. x[:, idx1, idx2, :, :] could mean that along the 2nd dimension, we choose slices with indices idx1, and along the 3rd dimension, we choose slices with indices idx2.\n2). multi-point selection. x[:, idx1, idx2, :, :] could mean that in the subspace formed by the 2nd and 3rd dimension, we choose points [(1,4), (8,1), (5,6)], which are in fact [(idx1[0], idx2[0]), (idx1[1], idx2[1]), (idx1[2], idx2[2])]. Therefore, idx1 and idx2 must have the same number of elements. (In fact, it will throw exception if idx1 and idx2 have different number of elements.)\nTake note that 1) and 2) are the same if there is only one indexing array, e.g., x[:, idx1, :, :, :], x[:, :, :, idx2, :]\nDo take note that the difference between 1) and 2) is that:\nIn 1), all the len(idx1)*len(idx2)=9 points are chosen. The subspace formed by the 2nd and 3rd dimension is a 20-by-30 grid plane, choosing [1, 8, 5] along the 2nd dimension (with max size 20), and choosing [4, 1, 6] along the 3rd dimension (with max size 30), this will end up with all the 3x3=9 points [(1,4), (1,1), (1,6), (8,4), (8,1), (8,6), (5,4), (5,1), (5,6)]. In this way, you cannot arbitrarily select any number of any points in this subspace.\nIn 2), you have the freedom to select any number of any points in the 20-by-30 grid subspace. However, if you would like to extract N slices along the 2nd dimension and M slices along the 3rd dimension, then you need to list down all the N*M pairs of coordinates, i.e., len(idx1)=len(idx2)=N*M, which is very tedious to list down.\nThe problem with the current indexing logic is that it is neither self-consistent nor systematic. This is because even though idx1 and idx2 are not adjacent, you can still perform multi-point selection. Take 3D space for example, y=np.random.random((10, 20, 30)), y[idx1, :, idx2] means select the 3 points along the X-Z plane. And there is no reason why you must order the multi-point-selection dimension to the beginning just because idx1 and idx2 are adjacent. Instead, you could adopt either one of the following two conventions:\n\nalways bring to the front, e.g.,\n\nx[:, idx1, idx2, :, :].shape=(3, 10, 40, 50)\nx[:, idx1, :, idx2, :].shape=(3, 10, 30, 50)\n\n\nstick to the 1st multi-point-selection coordinate dimension, e.g.,\n\nx[:, idx1, idx2, :, :].shape=(10, 3, 40, 50)\nx[:, idx1, :, idx2, :].shape=(10, 3, 30, 50)\nx[:, :, idx1, idx2, :].shape=(10, 20, 3, 50)\nx[:, :, idx1, :, idx2].shape=(10, 20, 3, 40)\n\nA more elegant design would be the following:\na) use list for tensor slicing and use tuple for multi-point selection, or the other way round if you do not want to break compatibility with previous version.\nb) adopt Convention 1, always bring the multi-point-selection dimension to the front, because both tensor slicing and multi-point selection can co-exist, and you don't want to mess up. For example, x[:, [2, 8, 5, 3], (2, 4, 6), [4, 9, 6], (3, 5, 7)] means take slices 2,8,5,3 along the 2nd dimension, take slices 4,9,6 along the 4th dimension, in the subspace plane formed by the 3rd and 5th dimension, select points (2,3), (4,5) and (6,7).\nc) use a trailing comma to denote aligning dimensions from the left, e.g., for x[:, idx1, :,], idx1 refers to the 2nd dimension; use a preceding comma to denote aligning dimensions from the right, e.g., for x[, :, idx1, :], idx1 refers to the 4th dimension. If neither trailing comma nor preceding comma exist, and the indices dimension is less than the tensor dimension, then default to the current (aligning from the left).\nThis would make things much simpler and clearer!", "body": "Actually, I do fully understand the non-adjacent advanced indexing logic. But I don't think its design is good enough.\r\nConsider the following example,\r\n```\r\nx = np.random.random((10, 20, 30, 40, 50))\r\nidx1 = [1, 8, 5]\r\nidx2 = [4, 1, 6]\r\n```\r\nIn the current indexing logic design, the very fact that it matters whether the two indexing arrays (idx1 and idx2) are adjacent to each other or not, is because it could mean two things when multiple indexing arrays are provided:\r\n1). **tensor slicing**. x[:, idx1, idx2, :, :] could mean that along the 2nd dimension, we choose slices with indices idx1, and along the 3rd dimension, we choose slices with indices idx2.\r\n2). **multi-point selection**. x[:, idx1, idx2, :, :] could mean that in the subspace formed by the 2nd and 3rd dimension, we choose points [(1,4), (8,1), (5,6)], which are in fact [(idx1[0], idx2[0]), (idx1[1], idx2[1]), (idx1[2], idx2[2])]. Therefore, idx1 and idx2 must have the same number of elements. (In fact, it will throw exception if idx1 and idx2 have different number of elements.)\r\nTake note that 1) and 2) are the same if there is only one indexing array, e.g., x[:, idx1, :, :, :], x[:, :, :, idx2, :]\r\n\r\nDo take note that the difference between 1) and 2) is that:\r\n**In 1)**, all the len(idx1)\\*len(idx2)=9 points are chosen. The subspace formed by the 2nd and 3rd dimension is a 20-by-30 grid plane, choosing [1, 8, 5] along the 2nd dimension (with max size 20), and choosing [4, 1, 6] along the 3rd dimension (with max size 30), this will end up with all the 3x3=9 points [(1,4), (1,1), (1,6), (8,4), (8,1), (8,6), (5,4), (5,1), (5,6)]. In this way, you cannot arbitrarily select any number of any points in this subspace.\r\n**In 2)**, you have the freedom to select any number of any points in the 20-by-30 grid subspace. However, if you would like to extract N slices along the 2nd dimension and M slices along the 3rd dimension, then you need to list down all the N\\*M pairs of coordinates, i.e., len(idx1)=len(idx2)=N\\*M, which is very tedious to list down.\r\n\r\nThe problem with the current indexing logic is that it is neither self-consistent nor systematic. This is because even though idx1 and idx2 are not adjacent, you can still perform multi-point selection. Take 3D space for example, `y=np.random.random((10, 20, 30))`, y[idx1, :, idx2] means select the 3 points along the X-Z plane. And there is no reason why you must order the multi-point-selection dimension to the beginning just because idx1 and idx2 are adjacent. Instead, you could adopt either one of the following two conventions:\r\n1. always bring to the front, e.g., \r\n```\r\nx[:, idx1, idx2, :, :].shape=(3, 10, 40, 50)\r\nx[:, idx1, :, idx2, :].shape=(3, 10, 30, 50)\r\n```\r\n2. stick to the 1st multi-point-selection coordinate dimension, e.g.,\r\n```\r\nx[:, idx1, idx2, :, :].shape=(10, 3, 40, 50)\r\nx[:, idx1, :, idx2, :].shape=(10, 3, 30, 50)\r\nx[:, :, idx1, idx2, :].shape=(10, 20, 3, 50)\r\nx[:, :, idx1, :, idx2].shape=(10, 20, 3, 40)\r\n```\r\n\r\nA more elegant design would be the following:\r\na) use list for **tensor slicing** and use tuple for **multi-point selection**, or the other way round if you do not want to break compatibility with previous version.\r\nb) adopt Convention 1, always bring the multi-point-selection dimension to the front, because both **tensor slicing** and **multi-point selection** can co-exist, and you don't want to mess up. For example, x[:, [2, 8, 5, 3], (2, 4, 6), [4, 9, 6], (3, 5, 7)] means take slices 2,8,5,3 along the 2nd dimension, take slices 4,9,6 along the 4th dimension, in the subspace plane formed by the 3rd and 5th dimension, select points (2,3), (4,5) and (6,7). \r\nc) use a trailing comma to denote aligning dimensions from the left, e.g., for x[:, idx1, :,], idx1 refers to the 2nd dimension; use a preceding comma to denote aligning dimensions from the right, e.g., for x[, :, idx1, :], idx1 refers to the 4th dimension. If neither trailing comma nor preceding comma exist, and the indices dimension is less than the tensor dimension, then default to the current (aligning from the left).\r\n\r\nThis would make things much simpler and clearer!"}