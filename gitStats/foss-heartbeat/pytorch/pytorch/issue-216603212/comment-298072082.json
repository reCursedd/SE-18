{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/298072082", "html_url": "https://github.com/pytorch/pytorch/issues/1080#issuecomment-298072082", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/1080", "id": 298072082, "node_id": "MDEyOklzc3VlQ29tbWVudDI5ODA3MjA4Mg==", "user": {"login": "fmassa", "id": 9110200, "node_id": "MDQ6VXNlcjkxMTAyMDA=", "avatar_url": "https://avatars2.githubusercontent.com/u/9110200?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fmassa", "html_url": "https://github.com/fmassa", "followers_url": "https://api.github.com/users/fmassa/followers", "following_url": "https://api.github.com/users/fmassa/following{/other_user}", "gists_url": "https://api.github.com/users/fmassa/gists{/gist_id}", "starred_url": "https://api.github.com/users/fmassa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fmassa/subscriptions", "organizations_url": "https://api.github.com/users/fmassa/orgs", "repos_url": "https://api.github.com/users/fmassa/repos", "events_url": "https://api.github.com/users/fmassa/events{/privacy}", "received_events_url": "https://api.github.com/users/fmassa/received_events", "type": "User", "site_admin": false}, "created_at": "2017-04-28T18:25:37Z", "updated_at": "2017-04-28T18:25:37Z", "author_association": "MEMBER", "body_html": "<p>Sure, no problem. Indeed, it took me sometime to understand this indexing part in numpy.</p>\n<p>I think it's easier to use an example here.<br>\nSay we have</p>\n<div class=\"highlight highlight-source-python\"><pre>x <span class=\"pl-k\">=</span> np.random.random((<span class=\"pl-c1\">10</span>, <span class=\"pl-c1\">20</span>, <span class=\"pl-c1\">30</span>, <span class=\"pl-c1\">40</span>, <span class=\"pl-c1\">50</span>))\nidx1 <span class=\"pl-k\">=</span> [<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">8</span>, <span class=\"pl-c1\">5</span>]\nidx2 <span class=\"pl-k\">=</span> [<span class=\"pl-c1\">4</span>, <span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">6</span>]</pre></div>\n<p>There are two possible cases: <code>idx1</code> and <code>idx2</code> appear in consecutive dimensions of the tensor. In this case, the position of the resulting tensor after indexing is well defined, and appears at the same position as the first index. So <code>x[:, idx1, idx2, :, :].shape == (10, 3, 40, 50)</code>.</p>\n<p>Now, if the indices does not appear in consecutive dimensions (for example in <code>x[:, idx1, :, idx2, :]</code>), there is no unambiguous place to drop the indexing subspace, so the subspace is sent to the beginning of the array (yielding an array of shape <code>x[:, idx1, :, idx2, :].shape == (3, 10, 30, 50)</code>.</p>\n<p>The code that you pointed out is doing just that. It checks if the indices appears in consecutive dimensions or not, and if not then permute the tensor so that the indexing dimensions comes first.</p>\n<p>Let me know if you have other questions. We could also chat though slack if you prefer.</p>", "body_text": "Sure, no problem. Indeed, it took me sometime to understand this indexing part in numpy.\nI think it's easier to use an example here.\nSay we have\nx = np.random.random((10, 20, 30, 40, 50))\nidx1 = [1, 8, 5]\nidx2 = [4, 1, 6]\nThere are two possible cases: idx1 and idx2 appear in consecutive dimensions of the tensor. In this case, the position of the resulting tensor after indexing is well defined, and appears at the same position as the first index. So x[:, idx1, idx2, :, :].shape == (10, 3, 40, 50).\nNow, if the indices does not appear in consecutive dimensions (for example in x[:, idx1, :, idx2, :]), there is no unambiguous place to drop the indexing subspace, so the subspace is sent to the beginning of the array (yielding an array of shape x[:, idx1, :, idx2, :].shape == (3, 10, 30, 50).\nThe code that you pointed out is doing just that. It checks if the indices appears in consecutive dimensions or not, and if not then permute the tensor so that the indexing dimensions comes first.\nLet me know if you have other questions. We could also chat though slack if you prefer.", "body": "Sure, no problem. Indeed, it took me sometime to understand this indexing part in numpy.\r\n\r\nI think it's easier to use an example here.\r\nSay we have \r\n```python\r\nx = np.random.random((10, 20, 30, 40, 50))\r\nidx1 = [1, 8, 5]\r\nidx2 = [4, 1, 6]\r\n```\r\nThere are two possible cases: `idx1` and `idx2` appear in consecutive dimensions of the tensor. In this case, the position of the resulting tensor after indexing is well defined, and appears at the same position as the first index. So `x[:, idx1, idx2, :, :].shape == (10, 3, 40, 50)`.\r\n\r\nNow, if the indices does not appear in consecutive dimensions (for example in `x[:, idx1, :, idx2, :]`), there is no unambiguous place to drop the indexing subspace, so the subspace is sent to the beginning of the array (yielding an array of shape `x[:, idx1, :, idx2, :].shape == (3, 10, 30, 50)`.\r\n\r\nThe code that you pointed out is doing just that. It checks if the indices appears in consecutive dimensions or not, and if not then permute the tensor so that the indexing dimensions comes first.\r\n\r\nLet me know if you have other questions. We could also chat though slack if you prefer."}