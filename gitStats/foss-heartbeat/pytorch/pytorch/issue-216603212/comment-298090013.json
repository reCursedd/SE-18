{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/298090013", "html_url": "https://github.com/pytorch/pytorch/issues/1080#issuecomment-298090013", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/1080", "id": 298090013, "node_id": "MDEyOklzc3VlQ29tbWVudDI5ODA5MDAxMw==", "user": {"login": "killeent", "id": 4529377, "node_id": "MDQ6VXNlcjQ1MjkzNzc=", "avatar_url": "https://avatars1.githubusercontent.com/u/4529377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/killeent", "html_url": "https://github.com/killeent", "followers_url": "https://api.github.com/users/killeent/followers", "following_url": "https://api.github.com/users/killeent/following{/other_user}", "gists_url": "https://api.github.com/users/killeent/gists{/gist_id}", "starred_url": "https://api.github.com/users/killeent/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/killeent/subscriptions", "organizations_url": "https://api.github.com/users/killeent/orgs", "repos_url": "https://api.github.com/users/killeent/repos", "events_url": "https://api.github.com/users/killeent/events{/privacy}", "received_events_url": "https://api.github.com/users/killeent/received_events", "type": "User", "site_admin": false}, "created_at": "2017-04-28T19:45:30Z", "updated_at": "2017-04-28T19:45:30Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Discussed with <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=9110200\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/fmassa\">@fmassa</a> on Slack. I think the steps to complete this task are:</p>\n<ol>\n<li>The simplest case of advanced indexing is having as input ndim(indexed tensor) input arrays. We can support this limited use case by verifying the input, and then porting the Python code above where we use <code>index_select</code> and <code>view</code> operations to generate the result.</li>\n<li>Then, we can extend support to cases where we only perform advanced indexing on a subset of the tensor, with adjacent advanced indices, i.e. the case <code>x[:, idx1, idx2, :, :]</code> above</li>\n<li>Extend the advanced indexing to support non-adjacent advanced indexing: <code>x[:, idx1, :, idx2, :]</code></li>\n<li>Implement 2-pass indexing to support the combination of basic indexing and advanced indexing: <code>x[1:2, [1,2], 1:3, [2,3], [1, 3]]</code></li>\n</ol>\n<p>I will do my best to tackle 1), and then will evaluate from there.</p>", "body_text": "Discussed with @fmassa on Slack. I think the steps to complete this task are:\n\nThe simplest case of advanced indexing is having as input ndim(indexed tensor) input arrays. We can support this limited use case by verifying the input, and then porting the Python code above where we use index_select and view operations to generate the result.\nThen, we can extend support to cases where we only perform advanced indexing on a subset of the tensor, with adjacent advanced indices, i.e. the case x[:, idx1, idx2, :, :] above\nExtend the advanced indexing to support non-adjacent advanced indexing: x[:, idx1, :, idx2, :]\nImplement 2-pass indexing to support the combination of basic indexing and advanced indexing: x[1:2, [1,2], 1:3, [2,3], [1, 3]]\n\nI will do my best to tackle 1), and then will evaluate from there.", "body": "Discussed with @fmassa on Slack. I think the steps to complete this task are:\r\n\r\n1. The simplest case of advanced indexing is having as input ndim(indexed tensor) input arrays. We can support this limited use case by verifying the input, and then porting the Python code above where we use `index_select` and `view` operations to generate the result.\r\n2. Then, we can extend support to cases where we only perform advanced indexing on a subset of the tensor, with adjacent advanced indices, i.e. the case `x[:, idx1, idx2, :, :]` above\r\n3. Extend the advanced indexing to support non-adjacent advanced indexing: `x[:, idx1, :, idx2, :]`\r\n4. Implement 2-pass indexing to support the combination of basic indexing and advanced indexing: `x[1:2, [1,2], 1:3, [2,3], [1, 3]]`\r\n\r\nI will do my best to tackle 1), and then will evaluate from there."}