{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/218315298", "pull_request_review_id": 156221069, "id": 218315298, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxODMxNTI5OA==", "diff_hunk": "@@ -81,51 +90,145 @@ AT_DEFINE_HASH_FOR_IDWRAPPER(caffe2::TypeIdentifier)\n \n namespace caffe2 {\n \n-AT_CORE_API std::unordered_map<TypeIdentifier, std::string>& gTypeNames();\n-AT_CORE_API std::unordered_set<std::string>& gRegisteredTypeNames();\n \n+namespace detail {\n+\n+struct TypeMetaData final {\n+  using PlacementNew = void(void*, size_t);\n+  using TypedCopy = void(const void*, void*, size_t);\n+  using TypedDestructor = void(void*, size_t);\n+\n+  size_t itemsize_;\n+  PlacementNew* ctor_;\n+  TypedCopy* copy_;\n+  TypedDestructor* dtor_;\n+  TypeIdentifier id_;\n+  const char* name_;\n+};\n \n-AT_CORE_API std::mutex& gTypeRegistrationMutex();\n+// Mechanism for throwing errors which can't be prevented at compile time\n+// due to type erasure. E.g. somebody calling TypeMeta::copy() for\n+// non-copyable type. Right now just throws exception but is implemented\n+// in .cpp to manage dependencies\n+void _ThrowRuntimeTypeLogicError(const std::string& msg);\n \n+/**\n+ * Placement new function for the type.\n+ */\n template <typename T>\n-struct TypeNameRegisterer {\n-  TypeNameRegisterer(TypeIdentifier id, const std::string& literal_name) {\n-    std::lock_guard<std::mutex> guard(gTypeRegistrationMutex());\n-#ifdef __GXX_RTTI\n-    (void)literal_name;\n-\n-    std::string name = at::demangle(typeid(T).name());\n-    // If we are in RTTI mode, we will also use this opportunity to do sanity\n-    // check if there are duplicated ids registered for the same type. This\n-    // usually happens when one does not do RTLD_GLOBAL, which is often the\n-    // case in Python. The way we do the check is to make sure that there are\n-    // no duplicated names registered - this could be done by checking the\n-    // uniqueness of names.\n-    if (gRegisteredTypeNames().count(name)) {\n-      AT_ERROR(\"typeid.h: Type name \", name, \" was registered twice.  \"\n-               \"This should not happen.  Things to check:\\n\"\n-               \"1. Did you add a new CAFFE_KNOWN_TYPE?  If so, check that \"\n-               \"it is not duplicated with an existing CAFFE_KNOWN_TYPE.\\n\"\n-               \"2. Did you build and install PyTorch and Caffe2 separately? \"\n-               \"For example, this would be the case if you ran scripts/onnx/install.sh or \"\n-               \"scripts/onnx/install-develop.sh prior to Aug 12, 2018 \"\n-               \"(commit 1756daaa7530d).  If so, rebuild using the environment variable \"\n-               \" FULL_CAFFE2=1 (if you build latest master, the ONNX scripts are \"\n-               \"updated to do this for you.) \"\n-               \"For more context, see https://github.com/pytorch/pytorch/issues/10460\");\n-    }\n-    gRegisteredTypeNames().insert(name);\n-    gTypeNames()[id] = name;\n-#else // __GXX_RTTI\n-    if (literal_name.empty()) {\n-      gTypeNames()[id] = \"(RTTI disabled, cannot show name)\";\n-    } else {\n-      gTypeNames()[id] = literal_name;\n-    }\n-#endif // __GXX_RTTI\n+inline void _Ctor(void* ptr, size_t n) {\n+  T* typed_ptr = static_cast<T*>(ptr);\n+  for (size_t i = 0; i < n; ++i) {\n+    new (typed_ptr + i) T;\n   }\n+}\n+\n+template <typename T>\n+inline void _CtorNotDefault(void* /*ptr*/, size_t /*n*/) {\n+  _ThrowRuntimeTypeLogicError(\n+      \"Type \" + std::string(at::demangle_type<T>()) +\n+      \" is not default-constructible.\");\n+}\n+\n+template <\n+    typename T,\n+    typename std::enable_if<std::is_default_constructible<T>::value>::type* =\n+        nullptr>\n+inline TypeMetaData::PlacementNew* _PickCtor() {\n+  return &_Ctor<T>;\n+}\n+\n+template <\n+    typename T,\n+    typename std::enable_if<!std::is_default_constructible<T>::value>::type* =\n+        nullptr>\n+inline TypeMetaData::PlacementNew* _PickCtor() {\n+  return &_CtorNotDefault<T>;\n+}\n+\n+/**\n+ * Typed copy function for classes.\n+ */\n+template <typename T>\n+inline void _Copy(const void* src, void* dst, size_t n) {\n+  const T* typed_src = static_cast<const T*>(src);\n+  T* typed_dst = static_cast<T*>(dst);\n+  for (size_t i = 0; i < n; ++i) {\n+    typed_dst[i] = typed_src[i];\n+  }\n+}\n+\n+/**\n+ * A placeholder function for types that do not allow assignment.\n+ */\n+template <typename T>\n+inline void _CopyNotAllowed(\n+    const void* /*src*/,\n+    void* /*dst*/,\n+    size_t /*n*/) {\n+  _ThrowRuntimeTypeLogicError(\n+      \"Type \" + std::string(at::demangle_type<T>()) +\n+      \" does not allow assignment.\");\n+}\n+\n+template <\n+    typename T,\n+    typename std::enable_if<std::is_copy_assignable<T>::value>::type* =\n+        nullptr>\n+inline TypeMetaData::TypedCopy* _PickCopy() {\n+  return &_Copy<T>;\n+}\n+\n+template <\n+    typename T,\n+    typename std::enable_if<!std::is_copy_assignable<T>::value>::type* =\n+        nullptr>\n+inline TypeMetaData::TypedCopy* _PickCopy() {\n+  return &_CopyNotAllowed<T>;\n+}\n+\n+/**\n+ * Destructor for non-fundamental types.\n+ */\n+template <typename T>\n+inline void _Dtor(void* ptr, size_t n) {\n+  T* typed_ptr = static_cast<T*>(ptr);\n+  for (size_t i = 0; i < n; ++i) {\n+    typed_ptr[i].~T();\n+  }\n+}\n+\n+template<class T> const char* _TypeName() noexcept;\n+\n+template<class T, class Enable = void>\n+struct TypeMetaDataRegistry final {\n+  static_assert(!std::is_same<T, T>::value, \"This should never be picked since TypeMetaDataRegistry has specialisations for all cases\");\n };\n \n+template <typename T>\n+struct TypeMetaDataRegistry<T, c10::guts::enable_if_t<std::is_fundamental<T>::value || std::is_pointer<T>::value>> final {", "path": "aten/src/ATen/core/typeid.h", "position": null, "original_position": 196, "commit_id": "25e01f322fe194f8bc320f6285d1065d4712bbf5", "original_commit_id": "850ad0b7295b8c2033e54aaa87ae0d5400e1d576", "user": {"login": "dzhulgakov", "id": 17890620, "node_id": "MDQ6VXNlcjE3ODkwNjIw", "avatar_url": "https://avatars2.githubusercontent.com/u/17890620?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dzhulgakov", "html_url": "https://github.com/dzhulgakov", "followers_url": "https://api.github.com/users/dzhulgakov/followers", "following_url": "https://api.github.com/users/dzhulgakov/following{/other_user}", "gists_url": "https://api.github.com/users/dzhulgakov/gists{/gist_id}", "starred_url": "https://api.github.com/users/dzhulgakov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dzhulgakov/subscriptions", "organizations_url": "https://api.github.com/users/dzhulgakov/orgs", "repos_url": "https://api.github.com/users/dzhulgakov/repos", "events_url": "https://api.github.com/users/dzhulgakov/events{/privacy}", "received_events_url": "https://api.github.com/users/dzhulgakov/received_events", "type": "User", "site_admin": false}, "body": "so.... will it work as expected across binary boundaries?\r\n\r\nthe reason current type meta was setup this way with CAFFE_KNOWN_TYPE explicit anntotations is that static variables in templates are prone to double-declarations when shared libraries are loaded with RTLD_GLOBAL.\r\n\r\nit might be fine as long as we don't use TypeMetaDataRegistry pointer for comparison, but it looks like you do above in operator==\r\n\r\nThe general safety rule is to avoid static variables in templates or in inline functions in .h files all together. Thus you can move this initialization to the constructor and explicitly specialize/instantiate TypeMetaDataRegistry only within CAFFE_KNOWN_TYPE. Would that work?", "created_at": "2018-09-18T06:49:49Z", "updated_at": "2018-11-23T15:51:33Z", "html_url": "https://github.com/pytorch/pytorch/pull/11502#discussion_r218315298", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/11502", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/218315298"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/11502#discussion_r218315298"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/11502"}}, "body_html": "<p>so.... will it work as expected across binary boundaries?</p>\n<p>the reason current type meta was setup this way with CAFFE_KNOWN_TYPE explicit anntotations is that static variables in templates are prone to double-declarations when shared libraries are loaded with RTLD_GLOBAL.</p>\n<p>it might be fine as long as we don't use TypeMetaDataRegistry pointer for comparison, but it looks like you do above in operator==</p>\n<p>The general safety rule is to avoid static variables in templates or in inline functions in .h files all together. Thus you can move this initialization to the constructor and explicitly specialize/instantiate TypeMetaDataRegistry only within CAFFE_KNOWN_TYPE. Would that work?</p>", "body_text": "so.... will it work as expected across binary boundaries?\nthe reason current type meta was setup this way with CAFFE_KNOWN_TYPE explicit anntotations is that static variables in templates are prone to double-declarations when shared libraries are loaded with RTLD_GLOBAL.\nit might be fine as long as we don't use TypeMetaDataRegistry pointer for comparison, but it looks like you do above in operator==\nThe general safety rule is to avoid static variables in templates or in inline functions in .h files all together. Thus you can move this initialization to the constructor and explicitly specialize/instantiate TypeMetaDataRegistry only within CAFFE_KNOWN_TYPE. Would that work?"}