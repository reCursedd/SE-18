{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/227212903", "pull_request_review_id": 167191477, "id": 227212903, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNzIxMjkwMw==", "diff_hunk": "@@ -1499,11 +1553,27 @@ struct to_ir {\n \n   std::shared_ptr<SugaredValue> emitApplyExpr(Apply &apply, size_t n_binders) {\n     auto sv = emitSugaredExpr(apply.callee(), 1);\n-    auto inputs = getNamedValues(apply.inputs(), true);\n     auto attributes = fmap(apply.attributes(), [&](const Attribute& attr) {\n       return NamedValue(attr.range(), attr.name().name(), emitExpr(attr.value()));\n     });\n-    return sv->call(apply.callee().range(), method, inputs, attributes, n_binders);\n+\n+    auto loc = apply.callee().range();\n+    if (sv->kind() == \"fork\") {\n+      JIT_ASSERT(attributes.size() == 0);\n+      JIT_ASSERT(n_binders == 1);\n+      auto& trees = apply.inputs().tree()->trees();\n+      if (trees.size() != 2) {\n+        throw ErrorReport(loc) << \"Expected a module and a single tuple argument to fork()\";\n+      }\n+\n+      auto sugared_expr = emitSugaredExpr(Expr(trees[0]), 1);\n+      TreeList sliced_trees(trees.begin() + 1, trees.end());\n+      auto& input = getNamedValues(sliced_trees, true)[0];\n+      return static_cast<ForkValue*>(sv.get())->call(loc, method, sugared_expr, input);\n+    } else {\n+      auto inputs = getNamedValues(apply.inputs(), true);\n+      return sv->call(loc, method, inputs, attributes, n_binders);", "path": "torch/csrc/jit/script/compiler.cpp", "position": 23, "original_position": 86, "commit_id": "444a45cb215a9dc800f84aaff3de91b484dad6ca", "original_commit_id": "5461791afd902ed40b39e559c31a0eaf7b967e8e", "user": {"login": "zdevito", "id": 370202, "node_id": "MDQ6VXNlcjM3MDIwMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/370202?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zdevito", "html_url": "https://github.com/zdevito", "followers_url": "https://api.github.com/users/zdevito/followers", "following_url": "https://api.github.com/users/zdevito/following{/other_user}", "gists_url": "https://api.github.com/users/zdevito/gists{/gist_id}", "starred_url": "https://api.github.com/users/zdevito/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zdevito/subscriptions", "organizations_url": "https://api.github.com/users/zdevito/orgs", "repos_url": "https://api.github.com/users/zdevito/repos", "events_url": "https://api.github.com/users/zdevito/events{/privacy}", "received_events_url": "https://api.github.com/users/zdevito/received_events", "type": "User", "site_admin": false}, "body": "[generating the function] It is important that we generate the call to the forked function in a way that (1) supports all the callable things in TorchScript and (2) is a pure function of its inputs. There are methods in TorchScript so the arguments to a call do not always contain all the true arguments to the functions. I suggest this approach to get this correct:\r\n\r\n1. initially create a sub-block, as is already done. Do not add any input arguments to the block, they are unnecessary at this point. The `schema()` function is not required.\r\n2. change the insert point to the block and do this code similar to before (note sliced_inputs is NamedValues for all but the first value in inputs):\r\n```\r\nauto fn_sugared_output = forked->call(loc, m, sliced_inputs, attributes, 1);\r\nauto fn_simple_output = fn_sugared_output->asValue(loc, m);\r\nbody_block->registerOutput(fn_simple_output);\r\n```\r\n3. \"Lambda lift\" the block into its own Graph. That is, for each unique value used in the block that is defined outside of the block, add it as a formal input to the Graph, and then copy the body of the block into the new Graph, replacing the actual inputs with the formal ones. Similarly, add the actual value (which corresponds to the formal input) as an input to the fork primitive. We can go over this in person if it isn't immediately clear.\r\n\r\n4. add the Graph as an attribute of the Fork node. The implementation of Fork should then construct an Interpreter object for this graph and use it to calculate the actual value.\r\n", "created_at": "2018-10-23T03:36:29Z", "updated_at": "2018-11-23T15:53:25Z", "html_url": "https://github.com/pytorch/pytorch/pull/12976#discussion_r227212903", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/12976", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/227212903"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/12976#discussion_r227212903"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/12976"}}, "body_html": "<p>[generating the function] It is important that we generate the call to the forked function in a way that (1) supports all the callable things in TorchScript and (2) is a pure function of its inputs. There are methods in TorchScript so the arguments to a call do not always contain all the true arguments to the functions. I suggest this approach to get this correct:</p>\n<ol>\n<li>initially create a sub-block, as is already done. Do not add any input arguments to the block, they are unnecessary at this point. The <code>schema()</code> function is not required.</li>\n<li>change the insert point to the block and do this code similar to before (note sliced_inputs is NamedValues for all but the first value in inputs):</li>\n</ol>\n<pre><code>auto fn_sugared_output = forked-&gt;call(loc, m, sliced_inputs, attributes, 1);\nauto fn_simple_output = fn_sugared_output-&gt;asValue(loc, m);\nbody_block-&gt;registerOutput(fn_simple_output);\n</code></pre>\n<ol start=\"3\">\n<li>\n<p>\"Lambda lift\" the block into its own Graph. That is, for each unique value used in the block that is defined outside of the block, add it as a formal input to the Graph, and then copy the body of the block into the new Graph, replacing the actual inputs with the formal ones. Similarly, add the actual value (which corresponds to the formal input) as an input to the fork primitive. We can go over this in person if it isn't immediately clear.</p>\n</li>\n<li>\n<p>add the Graph as an attribute of the Fork node. The implementation of Fork should then construct an Interpreter object for this graph and use it to calculate the actual value.</p>\n</li>\n</ol>", "body_text": "[generating the function] It is important that we generate the call to the forked function in a way that (1) supports all the callable things in TorchScript and (2) is a pure function of its inputs. There are methods in TorchScript so the arguments to a call do not always contain all the true arguments to the functions. I suggest this approach to get this correct:\n\ninitially create a sub-block, as is already done. Do not add any input arguments to the block, they are unnecessary at this point. The schema() function is not required.\nchange the insert point to the block and do this code similar to before (note sliced_inputs is NamedValues for all but the first value in inputs):\n\nauto fn_sugared_output = forked->call(loc, m, sliced_inputs, attributes, 1);\nauto fn_simple_output = fn_sugared_output->asValue(loc, m);\nbody_block->registerOutput(fn_simple_output);\n\n\n\n\"Lambda lift\" the block into its own Graph. That is, for each unique value used in the block that is defined outside of the block, add it as a formal input to the Graph, and then copy the body of the block into the new Graph, replacing the actual inputs with the formal ones. Similarly, add the actual value (which corresponds to the formal input) as an input to the fork primitive. We can go over this in person if it isn't immediately clear.\n\n\nadd the Graph as an attribute of the Fork node. The implementation of Fork should then construct an Interpreter object for this graph and use it to calculate the actual value."}