{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/440174894", "html_url": "https://github.com/pytorch/pytorch/issues/14219#issuecomment-440174894", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/14219", "id": 440174894, "node_id": "MDEyOklzc3VlQ29tbWVudDQ0MDE3NDg5NA==", "user": {"login": "jinfagang", "id": 21303438, "node_id": "MDQ6VXNlcjIxMzAzNDM4", "avatar_url": "https://avatars3.githubusercontent.com/u/21303438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jinfagang", "html_url": "https://github.com/jinfagang", "followers_url": "https://api.github.com/users/jinfagang/followers", "following_url": "https://api.github.com/users/jinfagang/following{/other_user}", "gists_url": "https://api.github.com/users/jinfagang/gists{/gist_id}", "starred_url": "https://api.github.com/users/jinfagang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jinfagang/subscriptions", "organizations_url": "https://api.github.com/users/jinfagang/orgs", "repos_url": "https://api.github.com/users/jinfagang/repos", "events_url": "https://api.github.com/users/jinfagang/events{/privacy}", "received_events_url": "https://api.github.com/users/jinfagang/received_events", "type": "User", "site_admin": false}, "created_at": "2018-11-20T07:44:42Z", "updated_at": "2018-11-20T07:44:42Z", "author_association": "NONE", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=20787943\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/t-vi\">@t-vi</a> Hi, thanks for your reply. For more investigation, the c++ simple program is like this:</p>\n<div class=\"highlight highlight-source-c++\"><pre>#<span class=\"pl-k\">include</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>torch/script.h<span class=\"pl-pds\">\"</span></span>\n#<span class=\"pl-k\">include</span> <span class=\"pl-s\"><span class=\"pl-pds\">&lt;</span>torch/script.h<span class=\"pl-pds\">&gt;</span></span>\n#<span class=\"pl-k\">include</span> <span class=\"pl-s\"><span class=\"pl-pds\">&lt;</span>torch/torch.h<span class=\"pl-pds\">&gt;</span></span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>#include &lt;torch/Tensor.h&gt;</span>\n#<span class=\"pl-k\">include</span> <span class=\"pl-s\"><span class=\"pl-pds\">&lt;</span>ATen/Tensor.h<span class=\"pl-pds\">&gt;</span></span>\n#<span class=\"pl-k\">include</span> <span class=\"pl-s\"><span class=\"pl-pds\">&lt;</span>opencv2/opencv.hpp<span class=\"pl-pds\">&gt;</span></span>\n#<span class=\"pl-k\">include</span> <span class=\"pl-s\"><span class=\"pl-pds\">&lt;</span>opencv2/imgproc/imgproc.hpp<span class=\"pl-pds\">&gt;</span></span>\n\n\n#<span class=\"pl-k\">include</span> <span class=\"pl-s\"><span class=\"pl-pds\">&lt;</span>iostream<span class=\"pl-pds\">&gt;</span></span>\n#<span class=\"pl-k\">include</span> <span class=\"pl-s\"><span class=\"pl-pds\">&lt;</span>memory<span class=\"pl-pds\">&gt;</span></span>\n<span class=\"pl-c\"><span class=\"pl-c\">//</span>#include &lt;vec&gt;</span>\n\n\n<span class=\"pl-k\">using</span> <span class=\"pl-k\">namespace</span> <span class=\"pl-en\">std</span><span class=\"pl-k\">;</span>\n\n\n<span class=\"pl-k\">void</span> <span class=\"pl-en\">load_labels</span>(string label_f, vector&lt;string&gt; labels) {\n    ifstream <span class=\"pl-smi\">ins</span>(label_f);\n    string line;\n    <span class=\"pl-k\">while</span> (<span class=\"pl-c1\">getline</span>(ins, line)) {\n        labels.<span class=\"pl-c1\">push_back</span>(line);\n    }\n}\n\n\n<span class=\"pl-k\">int</span> <span class=\"pl-en\">main</span>(<span class=\"pl-k\">int</span> argc, <span class=\"pl-k\">const</span> <span class=\"pl-k\">char</span>* argv[]) {\n\n    <span class=\"pl-k\">if</span> (argc != <span class=\"pl-c1\">4</span>) {\n        cout &lt;&lt; <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>ptcpp path/to/scripts/model.pt path/to/image.jpg path/to/label.txt<span class=\"pl-cce\">\\n</span><span class=\"pl-pds\">\"</span></span>;\n        <span class=\"pl-k\">return</span> -<span class=\"pl-c1\">1</span>;\n    }\n\n    shared_ptr&lt;torch::jit::script::Module&gt; module = <span class=\"pl-c1\">torch::jit::load</span>(argv[<span class=\"pl-c1\">1</span>]);\n\n    <span class=\"pl-k\">if</span> (module == <span class=\"pl-c1\">nullptr</span>) {\n        cerr &lt;&lt; <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>model load error from <span class=\"pl-pds\">\"</span></span> &lt;&lt; argv[<span class=\"pl-c1\">1</span>] &lt;&lt; endl;\n    }\n    cout &lt;&lt; <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Model load ok.<span class=\"pl-cce\">\\n</span><span class=\"pl-pds\">\"</span></span>;\n\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span> load image and transform</span>\n    cv::Mat image;\n    image = <span class=\"pl-c1\">cv::imread</span>(argv[<span class=\"pl-c1\">2</span>], <span class=\"pl-c1\">1</span>);\n    <span class=\"pl-c1\">cv::cvtColor</span>(image, image, CV_BGR2RGB);\n    cv::Mat img_float;\n    image.<span class=\"pl-c1\">convertTo</span>(img_float, CV_32F, <span class=\"pl-c1\">1.0</span>/<span class=\"pl-c1\">255</span>);\n    <span class=\"pl-c1\">cv::resize</span>(img_float, img_float, <span class=\"pl-c1\">cv::Size</span>(<span class=\"pl-c1\">224</span>, <span class=\"pl-c1\">224</span>));\n    <span class=\"pl-k\">auto</span> img_tensor = <span class=\"pl-c1\">torch::CUDA</span>(torch::<span class=\"pl-c1\">kFloat32</span>).<span class=\"pl-c1\">tensorFromBlob</span>(img_float.<span class=\"pl-smi\">data</span>, {<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">224</span>, <span class=\"pl-c1\">224</span>, <span class=\"pl-c1\">3</span>});\n    img_tensor = img_tensor.<span class=\"pl-c1\">permute</span>({<span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">3</span>, <span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">2</span>});\n    img_tensor[<span class=\"pl-c1\">0</span>][<span class=\"pl-c1\">0</span>] = img_tensor[<span class=\"pl-c1\">0</span>][<span class=\"pl-c1\">0</span>].<span class=\"pl-c1\">sub</span>(<span class=\"pl-c1\">0.485</span>).<span class=\"pl-c1\">div</span>(<span class=\"pl-c1\">0.229</span>);\n    img_tensor[<span class=\"pl-c1\">0</span>][<span class=\"pl-c1\">1</span>] = img_tensor[<span class=\"pl-c1\">0</span>][<span class=\"pl-c1\">1</span>].<span class=\"pl-c1\">sub</span>(<span class=\"pl-c1\">0.456</span>).<span class=\"pl-c1\">div</span>(<span class=\"pl-c1\">0.224</span>);\n    img_tensor[<span class=\"pl-c1\">0</span>][<span class=\"pl-c1\">2</span>] = img_tensor[<span class=\"pl-c1\">0</span>][<span class=\"pl-c1\">2</span>].<span class=\"pl-c1\">sub</span>(<span class=\"pl-c1\">0.406</span>).<span class=\"pl-c1\">div</span>(<span class=\"pl-c1\">0.225</span>);\n    <span class=\"pl-k\">auto</span> img_var = <span class=\"pl-c1\">torch::autograd::make_variable</span>(img_tensor, <span class=\"pl-c1\">false</span>);\n\n    vector&lt;torch::jit::IValue&gt; inputs;\n    inputs.<span class=\"pl-c1\">push_back</span>(img_var);\n    torch::Tensor out_tensor = module-&gt;<span class=\"pl-c1\">forward</span>(inputs).<span class=\"pl-c1\">toTensor</span>();\n    cout &lt;&lt; out_tensor.<span class=\"pl-c1\">slice</span>(<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">0</span>, <span class=\"pl-c1\">10</span>) &lt;&lt; <span class=\"pl-s\"><span class=\"pl-pds\">'</span><span class=\"pl-cce\">\\n</span><span class=\"pl-pds\">'</span></span>;\n\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span> load label</span>\n    vector&lt;string&gt; labels;\n    <span class=\"pl-c1\">load_labels</span>(argv[<span class=\"pl-c1\">3</span>], labels);\n    cout &lt;&lt; <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Found all <span class=\"pl-pds\">\"</span></span> &lt;&lt; labels.<span class=\"pl-c1\">size</span>() &lt;&lt; <span class=\"pl-s\"><span class=\"pl-pds\">\"</span> labels.<span class=\"pl-cce\">\\n</span><span class=\"pl-pds\">\"</span></span>;\n\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span> out tensor sort, print the first 2 category</span>\n    std::tuple&lt;torch::Tensor,torch::Tensor&gt; result = out_tensor.<span class=\"pl-c1\">sort</span>(-<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">true</span>);\n    torch::Tensor top_scores = std::get&lt;<span class=\"pl-c1\">0</span>&gt;(result)[<span class=\"pl-c1\">0</span>];\n    torch::Tensor top_idxs = std::get&lt;<span class=\"pl-c1\">1</span>&gt;(result)[<span class=\"pl-c1\">0</span>].<span class=\"pl-c1\">toType</span>(torch::<span class=\"pl-c1\">kInt32</span>);\n\n    <span class=\"pl-k\">auto</span> top_scores_a = top_scores.<span class=\"pl-smi\">accessor</span>&lt;<span class=\"pl-k\">float</span>,<span class=\"pl-c1\">1</span>&gt;();\n    <span class=\"pl-k\">auto</span> top_idxs_a = top_idxs.<span class=\"pl-smi\">accessor</span>&lt;<span class=\"pl-k\">int</span>,<span class=\"pl-c1\">1</span>&gt;();\n\n    <span class=\"pl-k\">for</span> (<span class=\"pl-k\">int</span> i = <span class=\"pl-c1\">0</span>; i &lt; <span class=\"pl-c1\">5</span>; ++i) {\n        <span class=\"pl-k\">int</span> idx = top_idxs_a[i];\n        std::cout &lt;&lt; <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>top-<span class=\"pl-pds\">\"</span></span> &lt;&lt; i+<span class=\"pl-c1\">1</span> &lt;&lt; <span class=\"pl-s\"><span class=\"pl-pds\">\"</span> label: <span class=\"pl-pds\">\"</span></span>;\n        std::cout &lt;&lt; labels[idx] &lt;&lt; <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>, score: <span class=\"pl-pds\">\"</span></span> &lt;&lt; top_scores_a[i] &lt;&lt; std::endl;\n    }\n\n    <span class=\"pl-k\">return</span> <span class=\"pl-c1\">0</span>;\n}</pre></div>\n<p>In official documentation says the include should be <code>torch/Tensor.h</code>, but the latest c++ api not have this file, so that I changed it:</p>\n<pre><code>//#include &lt;torch/Tensor.h&gt;\n#include &lt;ATen/Tensor.h&gt;\n</code></pre>\n<p>Could this be any other problem?</p>", "body_text": "@t-vi Hi, thanks for your reply. For more investigation, the c++ simple program is like this:\n#include \"torch/script.h\"\n#include <torch/script.h>\n#include <torch/torch.h>\n//#include <torch/Tensor.h>\n#include <ATen/Tensor.h>\n#include <opencv2/opencv.hpp>\n#include <opencv2/imgproc/imgproc.hpp>\n\n\n#include <iostream>\n#include <memory>\n//#include <vec>\n\n\nusing namespace std;\n\n\nvoid load_labels(string label_f, vector<string> labels) {\n    ifstream ins(label_f);\n    string line;\n    while (getline(ins, line)) {\n        labels.push_back(line);\n    }\n}\n\n\nint main(int argc, const char* argv[]) {\n\n    if (argc != 4) {\n        cout << \"ptcpp path/to/scripts/model.pt path/to/image.jpg path/to/label.txt\\n\";\n        return -1;\n    }\n\n    shared_ptr<torch::jit::script::Module> module = torch::jit::load(argv[1]);\n\n    if (module == nullptr) {\n        cerr << \"model load error from \" << argv[1] << endl;\n    }\n    cout << \"Model load ok.\\n\";\n\n    // load image and transform\n    cv::Mat image;\n    image = cv::imread(argv[2], 1);\n    cv::cvtColor(image, image, CV_BGR2RGB);\n    cv::Mat img_float;\n    image.convertTo(img_float, CV_32F, 1.0/255);\n    cv::resize(img_float, img_float, cv::Size(224, 224));\n    auto img_tensor = torch::CUDA(torch::kFloat32).tensorFromBlob(img_float.data, {1, 224, 224, 3});\n    img_tensor = img_tensor.permute({0, 3, 1, 2});\n    img_tensor[0][0] = img_tensor[0][0].sub(0.485).div(0.229);\n    img_tensor[0][1] = img_tensor[0][1].sub(0.456).div(0.224);\n    img_tensor[0][2] = img_tensor[0][2].sub(0.406).div(0.225);\n    auto img_var = torch::autograd::make_variable(img_tensor, false);\n\n    vector<torch::jit::IValue> inputs;\n    inputs.push_back(img_var);\n    torch::Tensor out_tensor = module->forward(inputs).toTensor();\n    cout << out_tensor.slice(1, 0, 10) << '\\n';\n\n    // load label\n    vector<string> labels;\n    load_labels(argv[3], labels);\n    cout << \"Found all \" << labels.size() << \" labels.\\n\";\n\n    // out tensor sort, print the first 2 category\n    std::tuple<torch::Tensor,torch::Tensor> result = out_tensor.sort(-1, true);\n    torch::Tensor top_scores = std::get<0>(result)[0];\n    torch::Tensor top_idxs = std::get<1>(result)[0].toType(torch::kInt32);\n\n    auto top_scores_a = top_scores.accessor<float,1>();\n    auto top_idxs_a = top_idxs.accessor<int,1>();\n\n    for (int i = 0; i < 5; ++i) {\n        int idx = top_idxs_a[i];\n        std::cout << \"top-\" << i+1 << \" label: \";\n        std::cout << labels[idx] << \", score: \" << top_scores_a[i] << std::endl;\n    }\n\n    return 0;\n}\nIn official documentation says the include should be torch/Tensor.h, but the latest c++ api not have this file, so that I changed it:\n//#include <torch/Tensor.h>\n#include <ATen/Tensor.h>\n\nCould this be any other problem?", "body": "@t-vi Hi, thanks for your reply. For more investigation, the c++ simple program is like this:\r\n\r\n```c++\r\n#include \"torch/script.h\"\r\n#include <torch/script.h>\r\n#include <torch/torch.h>\r\n//#include <torch/Tensor.h>\r\n#include <ATen/Tensor.h>\r\n#include <opencv2/opencv.hpp>\r\n#include <opencv2/imgproc/imgproc.hpp>\r\n\r\n\r\n#include <iostream>\r\n#include <memory>\r\n//#include <vec>\r\n\r\n\r\nusing namespace std;\r\n\r\n\r\nvoid load_labels(string label_f, vector<string> labels) {\r\n    ifstream ins(label_f);\r\n    string line;\r\n    while (getline(ins, line)) {\r\n        labels.push_back(line);\r\n    }\r\n}\r\n\r\n\r\nint main(int argc, const char* argv[]) {\r\n\r\n    if (argc != 4) {\r\n        cout << \"ptcpp path/to/scripts/model.pt path/to/image.jpg path/to/label.txt\\n\";\r\n        return -1;\r\n    }\r\n\r\n    shared_ptr<torch::jit::script::Module> module = torch::jit::load(argv[1]);\r\n\r\n    if (module == nullptr) {\r\n        cerr << \"model load error from \" << argv[1] << endl;\r\n    }\r\n    cout << \"Model load ok.\\n\";\r\n\r\n    // load image and transform\r\n    cv::Mat image;\r\n    image = cv::imread(argv[2], 1);\r\n    cv::cvtColor(image, image, CV_BGR2RGB);\r\n    cv::Mat img_float;\r\n    image.convertTo(img_float, CV_32F, 1.0/255);\r\n    cv::resize(img_float, img_float, cv::Size(224, 224));\r\n    auto img_tensor = torch::CUDA(torch::kFloat32).tensorFromBlob(img_float.data, {1, 224, 224, 3});\r\n    img_tensor = img_tensor.permute({0, 3, 1, 2});\r\n    img_tensor[0][0] = img_tensor[0][0].sub(0.485).div(0.229);\r\n    img_tensor[0][1] = img_tensor[0][1].sub(0.456).div(0.224);\r\n    img_tensor[0][2] = img_tensor[0][2].sub(0.406).div(0.225);\r\n    auto img_var = torch::autograd::make_variable(img_tensor, false);\r\n\r\n    vector<torch::jit::IValue> inputs;\r\n    inputs.push_back(img_var);\r\n    torch::Tensor out_tensor = module->forward(inputs).toTensor();\r\n    cout << out_tensor.slice(1, 0, 10) << '\\n';\r\n\r\n    // load label\r\n    vector<string> labels;\r\n    load_labels(argv[3], labels);\r\n    cout << \"Found all \" << labels.size() << \" labels.\\n\";\r\n\r\n    // out tensor sort, print the first 2 category\r\n    std::tuple<torch::Tensor,torch::Tensor> result = out_tensor.sort(-1, true);\r\n    torch::Tensor top_scores = std::get<0>(result)[0];\r\n    torch::Tensor top_idxs = std::get<1>(result)[0].toType(torch::kInt32);\r\n\r\n    auto top_scores_a = top_scores.accessor<float,1>();\r\n    auto top_idxs_a = top_idxs.accessor<int,1>();\r\n\r\n    for (int i = 0; i < 5; ++i) {\r\n        int idx = top_idxs_a[i];\r\n        std::cout << \"top-\" << i+1 << \" label: \";\r\n        std::cout << labels[idx] << \", score: \" << top_scores_a[i] << std::endl;\r\n    }\r\n\r\n    return 0;\r\n}\r\n```\r\n\r\nIn official documentation says the include should be `torch/Tensor.h`, but the latest c++ api not have this file, so that I changed it:\r\n```\r\n//#include <torch/Tensor.h>\r\n#include <ATen/Tensor.h>\r\n```\r\n\r\nCould this be any other problem?"}