{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/378365463", "html_url": "https://github.com/pytorch/pytorch/pull/6234#issuecomment-378365463", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/6234", "id": 378365463, "node_id": "MDEyOklzc3VlQ29tbWVudDM3ODM2NTQ2Mw==", "user": {"login": "zeryx", "id": 1892175, "node_id": "MDQ6VXNlcjE4OTIxNzU=", "avatar_url": "https://avatars1.githubusercontent.com/u/1892175?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zeryx", "html_url": "https://github.com/zeryx", "followers_url": "https://api.github.com/users/zeryx/followers", "following_url": "https://api.github.com/users/zeryx/following{/other_user}", "gists_url": "https://api.github.com/users/zeryx/gists{/gist_id}", "starred_url": "https://api.github.com/users/zeryx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zeryx/subscriptions", "organizations_url": "https://api.github.com/users/zeryx/orgs", "repos_url": "https://api.github.com/users/zeryx/repos", "events_url": "https://api.github.com/users/zeryx/events{/privacy}", "received_events_url": "https://api.github.com/users/zeryx/received_events", "type": "User", "site_admin": false}, "created_at": "2018-04-03T19:18:29Z", "updated_at": "2018-04-03T19:26:47Z", "author_association": "NONE", "body_html": "<p>Thanks for the quick response <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=1310570\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/soumith\">@soumith</a>!<br>\nLet me take a crack at exploring your scenarios:</p>\n<ul>\n<li>\n<p><code>Model files where part of the definition is an inline python string won't work</code> -&gt; I can't imagine or visualize a scenario where this might occur, this also seems (from my rudimentary understanding of the process) to be somewhat of an anti-pattern that should be discouraged, no? Maybe I'm misunderstanding you here.</p>\n</li>\n<li>\n<p><code>Model definitions with unpicklable objects simply won't work (such as lambdas)</code> -&gt; Since this is an optional save/load path (I intentionally separated it from .load() and .save() for this reason) we aren't necessarily restricting the development surface to only picklable components, but giving an ergonomic option when your model architecture satisfies these (lightweight) requirements.</p>\n</li>\n<li>\n<p><code>Saved definitions across pytorch versions might or might not work</code> -&gt; True, but that problem still exists if you preserved your source code anyways. Now that I'm thinking about it, I could certainly imagine a world where a metadata file was provided in the zip ball along with the source/model files for additional clarity, where the torch version and other information that the developer might need could exist. If we're in agreement here I might spend an hour or so to make sure that the model/model def metadata is exposed with <code>load_model()</code>.</p>\n</li>\n</ul>\n<p>The altruistic reason why I made this PR was to improve the new user experience for developers of a background similar to mine (productionizing ML).</p>\n<p>With all of that, I certainly don't want to discourage any suggestions! I would hate to see another user, particularly a novice or new pytorch user, run into the issue I'm trying to tackle with the PR without access to the tools they need to solve it.</p>", "body_text": "Thanks for the quick response @soumith!\nLet me take a crack at exploring your scenarios:\n\n\nModel files where part of the definition is an inline python string won't work -> I can't imagine or visualize a scenario where this might occur, this also seems (from my rudimentary understanding of the process) to be somewhat of an anti-pattern that should be discouraged, no? Maybe I'm misunderstanding you here.\n\n\nModel definitions with unpicklable objects simply won't work (such as lambdas) -> Since this is an optional save/load path (I intentionally separated it from .load() and .save() for this reason) we aren't necessarily restricting the development surface to only picklable components, but giving an ergonomic option when your model architecture satisfies these (lightweight) requirements.\n\n\nSaved definitions across pytorch versions might or might not work -> True, but that problem still exists if you preserved your source code anyways. Now that I'm thinking about it, I could certainly imagine a world where a metadata file was provided in the zip ball along with the source/model files for additional clarity, where the torch version and other information that the developer might need could exist. If we're in agreement here I might spend an hour or so to make sure that the model/model def metadata is exposed with load_model().\n\n\nThe altruistic reason why I made this PR was to improve the new user experience for developers of a background similar to mine (productionizing ML).\nWith all of that, I certainly don't want to discourage any suggestions! I would hate to see another user, particularly a novice or new pytorch user, run into the issue I'm trying to tackle with the PR without access to the tools they need to solve it.", "body": "Thanks for the quick response @soumith! \r\nLet me take a crack at exploring your scenarios:\r\n * `Model files where part of the definition is an inline python string won't work` -> I can't imagine or visualize a scenario where this might occur, this also seems (from my rudimentary understanding of the process) to be somewhat of an anti-pattern that should be discouraged, no? Maybe I'm misunderstanding you here.\r\n\r\n* `Model definitions with unpicklable objects simply won't work (such as lambdas)` -> Since this is an optional save/load path (I intentionally separated it from .load() and .save() for this reason) we aren't necessarily restricting the development surface to only picklable components, but giving an ergonomic option when your model architecture satisfies these (lightweight) requirements.\r\n\r\n* `Saved definitions across pytorch versions might or might not work` -> True, but that problem still exists if you preserved your source code anyways. Now that I'm thinking about it, I could certainly imagine a world where a metadata file was provided in the zip ball along with the source/model files for additional clarity, where the torch version and other information that the developer might need could exist. If we're in agreement here I might spend an hour or so to make sure that the model/model def metadata is exposed with `load_model()`.\r\n\r\nThe altruistic reason why I made this PR was to improve the new user experience for developers of a background similar to mine (productionizing ML).\r\n\r\nWith all of that, I certainly don't want to discourage any suggestions! I would hate to see another user, particularly a novice or new pytorch user, run into the issue I'm trying to tackle with the PR without access to the tools they need to solve it."}