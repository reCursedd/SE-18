{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/402006444", "html_url": "https://github.com/pytorch/pytorch/issues/4570#issuecomment-402006444", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/4570", "id": 402006444, "node_id": "MDEyOklzc3VlQ29tbWVudDQwMjAwNjQ0NA==", "user": {"login": "chintak", "id": 3398558, "node_id": "MDQ6VXNlcjMzOTg1NTg=", "avatar_url": "https://avatars2.githubusercontent.com/u/3398558?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chintak", "html_url": "https://github.com/chintak", "followers_url": "https://api.github.com/users/chintak/followers", "following_url": "https://api.github.com/users/chintak/following{/other_user}", "gists_url": "https://api.github.com/users/chintak/gists{/gist_id}", "starred_url": "https://api.github.com/users/chintak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chintak/subscriptions", "organizations_url": "https://api.github.com/users/chintak/orgs", "repos_url": "https://api.github.com/users/chintak/repos", "events_url": "https://api.github.com/users/chintak/events{/privacy}", "received_events_url": "https://api.github.com/users/chintak/received_events", "type": "User", "site_admin": false}, "created_at": "2018-07-03T04:00:35Z", "updated_at": "2018-07-03T04:01:43Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=7546747\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/sunshineatnoon\">@sunshineatnoon</a>, how about:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> <span class=\"pl-k\">import</span> torch\n<span class=\"pl-k\">&gt;&gt;</span><span class=\"pl-k\">&gt;</span> <span class=\"pl-c1\">help</span>(torch.bincount)</pre></div>\n<div class=\"highlight highlight-text-restructuredtext\"><pre>Help on built-in function bincount:\n\nbincount(...)\n    bincount(self, weights=None, minlength=0) -&gt; Tensor\n\n    Count the frequency of each value in an array of non-negative ints.\n\n    The number of bins (size 1) is one larger than the largest value in\n    :<span class=\"pl-en\">attr</span>:`<span class=\"pl-s\">input</span>`. If :<span class=\"pl-en\">attr</span>:`<span class=\"pl-s\">minlength</span>` is specified, the number of bins is at least\n    :<span class=\"pl-en\">attr</span>:`<span class=\"pl-s\">minlength</span>`. If <span class=\"pl-c1\">``n``</span> is the value at position <span class=\"pl-c1\">``i``</span>,\n    :<span class=\"pl-en\">math</span>:`out[n] += weights[i]` if :<span class=\"pl-en\">attr</span>:`<span class=\"pl-s\">weights</span>` is specified else\n    :<span class=\"pl-en\">math</span>:`out[n] += <span class=\"pl-c1\">1</span>`.\n\n    Arguments:\n        input (Tensor): 1-d int tensor\n        weights (Tensor): optional, weight for each value in the input tensor.\n            Should be of same size as input tensor.\n        minlength (int): optional, min number of bins. Should be non-negative.\n\n    Shape:\n        output (Tensor): <span class=\"pl-c1\">``Size([max(input) + 1])``</span>\n\n    Example::\n\n<span class=\"pl-c1\">        &gt;&gt;&gt; input = torch.randint(0, 8, (5,), dtype=torch.int64)</span>\n<span class=\"pl-c1\">        &gt;&gt;&gt; weights = torch.linspace(0, 1, steps=5)</span>\n<span class=\"pl-c1\">        &gt;&gt;&gt; input, weights</span>\n<span class=\"pl-c1\">        (tensor([4, 3, 6, 3, 4]),</span>\n<span class=\"pl-c1\">         tensor([ 0.0000,  0.2500,  0.5000,  0.7500,  1.0000])</span>\n\n<span class=\"pl-c1\">        &gt;&gt;&gt; torch.bincount(input)</span>\n<span class=\"pl-c1\">        tensor([0, 0, 0, 2, 2, 0, 1])</span>\n\n<span class=\"pl-c1\">        &gt;&gt;&gt; input.bincount(weights)</span>\n<span class=\"pl-c1\">        tensor([0.0000, 0.0000, 0.0000, 1.0000, 1.0000, 0.0000, 0.5000])</span></pre></div>", "body_text": "@sunshineatnoon, how about:\n>>> import torch\n>>> help(torch.bincount)\nHelp on built-in function bincount:\n\nbincount(...)\n    bincount(self, weights=None, minlength=0) -> Tensor\n\n    Count the frequency of each value in an array of non-negative ints.\n\n    The number of bins (size 1) is one larger than the largest value in\n    :attr:`input`. If :attr:`minlength` is specified, the number of bins is at least\n    :attr:`minlength`. If ``n`` is the value at position ``i``,\n    :math:`out[n] += weights[i]` if :attr:`weights` is specified else\n    :math:`out[n] += 1`.\n\n    Arguments:\n        input (Tensor): 1-d int tensor\n        weights (Tensor): optional, weight for each value in the input tensor.\n            Should be of same size as input tensor.\n        minlength (int): optional, min number of bins. Should be non-negative.\n\n    Shape:\n        output (Tensor): ``Size([max(input) + 1])``\n\n    Example::\n\n        >>> input = torch.randint(0, 8, (5,), dtype=torch.int64)\n        >>> weights = torch.linspace(0, 1, steps=5)\n        >>> input, weights\n        (tensor([4, 3, 6, 3, 4]),\n         tensor([ 0.0000,  0.2500,  0.5000,  0.7500,  1.0000])\n\n        >>> torch.bincount(input)\n        tensor([0, 0, 0, 2, 2, 0, 1])\n\n        >>> input.bincount(weights)\n        tensor([0.0000, 0.0000, 0.0000, 1.0000, 1.0000, 0.0000, 0.5000])", "body": "@sunshineatnoon, how about:\r\n```python\r\n>>> import torch\r\n>>> help(torch.bincount)\r\n```\r\n```rst\r\nHelp on built-in function bincount:\r\n\r\nbincount(...)\r\n    bincount(self, weights=None, minlength=0) -> Tensor\r\n\r\n    Count the frequency of each value in an array of non-negative ints.\r\n\r\n    The number of bins (size 1) is one larger than the largest value in\r\n    :attr:`input`. If :attr:`minlength` is specified, the number of bins is at least\r\n    :attr:`minlength`. If ``n`` is the value at position ``i``,\r\n    :math:`out[n] += weights[i]` if :attr:`weights` is specified else\r\n    :math:`out[n] += 1`.\r\n\r\n    Arguments:\r\n        input (Tensor): 1-d int tensor\r\n        weights (Tensor): optional, weight for each value in the input tensor.\r\n            Should be of same size as input tensor.\r\n        minlength (int): optional, min number of bins. Should be non-negative.\r\n\r\n    Shape:\r\n        output (Tensor): ``Size([max(input) + 1])``\r\n\r\n    Example::\r\n\r\n        >>> input = torch.randint(0, 8, (5,), dtype=torch.int64)\r\n        >>> weights = torch.linspace(0, 1, steps=5)\r\n        >>> input, weights\r\n        (tensor([4, 3, 6, 3, 4]),\r\n         tensor([ 0.0000,  0.2500,  0.5000,  0.7500,  1.0000])\r\n\r\n        >>> torch.bincount(input)\r\n        tensor([0, 0, 0, 2, 2, 0, 1])\r\n\r\n        >>> input.bincount(weights)\r\n        tensor([0.0000, 0.0000, 0.0000, 1.0000, 1.0000, 0.0000, 0.5000])\r\n```"}