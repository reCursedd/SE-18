{"url": "https://api.github.com/repos/pytorch/pytorch/issues/10488", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/10488/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/10488/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/10488/events", "html_url": "https://github.com/pytorch/pytorch/pull/10488", "id": 350206147, "node_id": "MDExOlB1bGxSZXF1ZXN0MjA4MTEzNDU3", "number": 10488, "title": "Use intrusive_ptr in Storage; replace unique_ptr<Storage> with Storage", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2018-08-13T21:47:16Z", "updated_at": "2018-11-23T15:49:44Z", "closed_at": "2018-08-22T04:41:10Z", "author_association": "CONTRIBUTOR", "pull_request": {"url": "https://api.github.com/repos/pytorch/pytorch/pulls/10488", "html_url": "https://github.com/pytorch/pytorch/pull/10488", "diff_url": "https://github.com/pytorch/pytorch/pull/10488.diff", "patch_url": "https://github.com/pytorch/pytorch/pull/10488.patch"}, "body_html": "<pre><code>Use intrusive_ptr in Storage; replace unique_ptr&lt;Storage&gt; with Storage\n\nThis patch does two major changes:\n\n- It replaces the use of Retainable in Storage with a new implementation\n  based on intrusive_ptr.  This will be necessary because Caffe2 will\n  be using this class to implement intrusive_ptrs, and we need to\n  line these up for the merge.  One good thing about the new implementation is\n  that the default copy/move constructors/assignment operators and destructor\n  work automatically, instead of needing to be hardcoded into Storage/Tensor.\n\n- It replaces all places where we returned std::unique_ptr&lt;Storage&gt; with\n  Storage, collapsing an unnecessary double indirection that is no longer\n  necessary now that we have correctly working copy/move constructors.\n\nI didn't initially want to do step (2), but it was very important to\neliminate all bare uses of new Storage and new StorageImpl, and this making\nthe API change was the most straightforward way to do this.\n\nHOW TO FIX YOUR CODE IN THE NEW API\n\n- You no longer need to dereference the result of tensor.storage() to pass\n  it to set.  So, instead of:\n\n      x.set_(*y.storage());\n\n  just write:\n\n      x.set_(y.storage());\n\n- If you were accessing methods on StorageImpl via the pImpl() method, you\n  must use the dot operator to run pImpl().  Even better; just drop pImpl,\n  we now have method forwarding.  So, instead of:\n\n      storage-&gt;pImpl()-&gt;data();\n\n  just do:\n\n      storage-&gt;data();\n      // storage.pImpl()-&gt;data() works too but is not as recommended\n\nMISC CODE UPDATES\n\n- retain, release, weak_retain, weak_release and weak_lock are now\n  reimplemented using the \"blessed API\"\n\n- nvcc OS X and general OS X portability improvements to intrusive_ptr\n\n- A new comment in intrusive_ptr describing how stack allocated\n  intrusive_ptr_targets work differently than heap allocated ones\n  from c10::make_intrusive\n\nCAVEAT EMPTOR\n\n- THStorage_weakRetain used to work on strong pointers, but it NO LONGER\n  works with intrusive_ptr.  You must reclaim the strong pointer into a\n  real strong pointer, construct a weak pointer from it, and then release\n  the strong and weak pointers.  See StorageSharing.cpp for an example.\n</code></pre>", "body_text": "Use intrusive_ptr in Storage; replace unique_ptr<Storage> with Storage\n\nThis patch does two major changes:\n\n- It replaces the use of Retainable in Storage with a new implementation\n  based on intrusive_ptr.  This will be necessary because Caffe2 will\n  be using this class to implement intrusive_ptrs, and we need to\n  line these up for the merge.  One good thing about the new implementation is\n  that the default copy/move constructors/assignment operators and destructor\n  work automatically, instead of needing to be hardcoded into Storage/Tensor.\n\n- It replaces all places where we returned std::unique_ptr<Storage> with\n  Storage, collapsing an unnecessary double indirection that is no longer\n  necessary now that we have correctly working copy/move constructors.\n\nI didn't initially want to do step (2), but it was very important to\neliminate all bare uses of new Storage and new StorageImpl, and this making\nthe API change was the most straightforward way to do this.\n\nHOW TO FIX YOUR CODE IN THE NEW API\n\n- You no longer need to dereference the result of tensor.storage() to pass\n  it to set.  So, instead of:\n\n      x.set_(*y.storage());\n\n  just write:\n\n      x.set_(y.storage());\n\n- If you were accessing methods on StorageImpl via the pImpl() method, you\n  must use the dot operator to run pImpl().  Even better; just drop pImpl,\n  we now have method forwarding.  So, instead of:\n\n      storage->pImpl()->data();\n\n  just do:\n\n      storage->data();\n      // storage.pImpl()->data() works too but is not as recommended\n\nMISC CODE UPDATES\n\n- retain, release, weak_retain, weak_release and weak_lock are now\n  reimplemented using the \"blessed API\"\n\n- nvcc OS X and general OS X portability improvements to intrusive_ptr\n\n- A new comment in intrusive_ptr describing how stack allocated\n  intrusive_ptr_targets work differently than heap allocated ones\n  from c10::make_intrusive\n\nCAVEAT EMPTOR\n\n- THStorage_weakRetain used to work on strong pointers, but it NO LONGER\n  works with intrusive_ptr.  You must reclaim the strong pointer into a\n  real strong pointer, construct a weak pointer from it, and then release\n  the strong and weak pointers.  See StorageSharing.cpp for an example.", "body": "```\r\nUse intrusive_ptr in Storage; replace unique_ptr<Storage> with Storage\r\n\r\nThis patch does two major changes:\r\n\r\n- It replaces the use of Retainable in Storage with a new implementation\r\n  based on intrusive_ptr.  This will be necessary because Caffe2 will\r\n  be using this class to implement intrusive_ptrs, and we need to\r\n  line these up for the merge.  One good thing about the new implementation is\r\n  that the default copy/move constructors/assignment operators and destructor\r\n  work automatically, instead of needing to be hardcoded into Storage/Tensor.\r\n\r\n- It replaces all places where we returned std::unique_ptr<Storage> with\r\n  Storage, collapsing an unnecessary double indirection that is no longer\r\n  necessary now that we have correctly working copy/move constructors.\r\n\r\nI didn't initially want to do step (2), but it was very important to\r\neliminate all bare uses of new Storage and new StorageImpl, and this making\r\nthe API change was the most straightforward way to do this.\r\n\r\nHOW TO FIX YOUR CODE IN THE NEW API\r\n\r\n- You no longer need to dereference the result of tensor.storage() to pass\r\n  it to set.  So, instead of:\r\n\r\n      x.set_(*y.storage());\r\n\r\n  just write:\r\n\r\n      x.set_(y.storage());\r\n\r\n- If you were accessing methods on StorageImpl via the pImpl() method, you\r\n  must use the dot operator to run pImpl().  Even better; just drop pImpl,\r\n  we now have method forwarding.  So, instead of:\r\n\r\n      storage->pImpl()->data();\r\n\r\n  just do:\r\n\r\n      storage->data();\r\n      // storage.pImpl()->data() works too but is not as recommended\r\n\r\nMISC CODE UPDATES\r\n\r\n- retain, release, weak_retain, weak_release and weak_lock are now\r\n  reimplemented using the \"blessed API\"\r\n\r\n- nvcc OS X and general OS X portability improvements to intrusive_ptr\r\n\r\n- A new comment in intrusive_ptr describing how stack allocated\r\n  intrusive_ptr_targets work differently than heap allocated ones\r\n  from c10::make_intrusive\r\n\r\nCAVEAT EMPTOR\r\n\r\n- THStorage_weakRetain used to work on strong pointers, but it NO LONGER\r\n  works with intrusive_ptr.  You must reclaim the strong pointer into a\r\n  real strong pointer, construct a weak pointer from it, and then release\r\n  the strong and weak pointers.  See StorageSharing.cpp for an example.\r\n```"}