{"url": "https://api.github.com/repos/pytorch/pytorch/issues/10048", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/10048/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/10048/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/10048/events", "html_url": "https://github.com/pytorch/pytorch/pull/10048", "id": 346012716, "node_id": "MDExOlB1bGxSZXF1ZXN0MjA0OTc5OTMy", "number": 10048, "title": "[JIT] Add registerOperator overloads that infer the schema", "user": {"login": "goldsborough", "id": 6429851, "node_id": "MDQ6VXNlcjY0Mjk4NTE=", "avatar_url": "https://avatars3.githubusercontent.com/u/6429851?v=4", "gravatar_id": "", "url": "https://api.github.com/users/goldsborough", "html_url": "https://github.com/goldsborough", "followers_url": "https://api.github.com/users/goldsborough/followers", "following_url": "https://api.github.com/users/goldsborough/following{/other_user}", "gists_url": "https://api.github.com/users/goldsborough/gists{/gist_id}", "starred_url": "https://api.github.com/users/goldsborough/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/goldsborough/subscriptions", "organizations_url": "https://api.github.com/users/goldsborough/orgs", "repos_url": "https://api.github.com/users/goldsborough/repos", "events_url": "https://api.github.com/users/goldsborough/events{/privacy}", "received_events_url": "https://api.github.com/users/goldsborough/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 679953983, "node_id": "MDU6TGFiZWw2Nzk5NTM5ODM=", "url": "https://api.github.com/repos/pytorch/pytorch/labels/jit", "name": "jit", "color": "c5def5", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2018-07-31T02:32:30Z", "updated_at": "2018-11-23T15:48:39Z", "closed_at": "2018-08-03T18:47:05Z", "author_association": "CONTRIBUTOR", "pull_request": {"url": "https://api.github.com/repos/pytorch/pytorch/pulls/10048", "html_url": "https://github.com/pytorch/pytorch/pull/10048", "diff_url": "https://github.com/pytorch/pytorch/pull/10048.diff", "patch_url": "https://github.com/pytorch/pytorch/pull/10048.patch"}, "body_html": "<p>This PR adds a way to infer the JIT/script schema of a function from its signature, and then create an operator from the schema and implementation. The implementation function is wrapped into another function, which pops values from the stack into an argument tuple, then invokes the function and pushes the return value back onto the stack, sometimes unpacking the return value if it is a tuple.</p>\n<p>Currently the method is called <code>createOperator</code>. We may want to think of a nicer way of registering ops in tandem with <code>RegisterOperators</code>. It might be very cumbersome to add a template constructor to <code>Operator</code>, so maybe we can come up with a chaining method on <code>RegisterOperators</code> like <code>RegisterOperators(schema, func).op(schema.func).op(schema, func)</code> -- it has to work at startup time (for a static variable) though. We can solve this in another PR.</p>\n<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=370202\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/zdevito\">@zdevito</a> <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=4583066\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/apaszke\">@apaszke</a> <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=2373925\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/smessmer\">@smessmer</a> <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=17890620\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/dzhulgakov\">@dzhulgakov</a></p>", "body_text": "This PR adds a way to infer the JIT/script schema of a function from its signature, and then create an operator from the schema and implementation. The implementation function is wrapped into another function, which pops values from the stack into an argument tuple, then invokes the function and pushes the return value back onto the stack, sometimes unpacking the return value if it is a tuple.\nCurrently the method is called createOperator. We may want to think of a nicer way of registering ops in tandem with RegisterOperators. It might be very cumbersome to add a template constructor to Operator, so maybe we can come up with a chaining method on RegisterOperators like RegisterOperators(schema, func).op(schema.func).op(schema, func) -- it has to work at startup time (for a static variable) though. We can solve this in another PR.\n@zdevito @apaszke @smessmer @dzhulgakov", "body": "This PR adds a way to infer the JIT/script schema of a function from its signature, and then create an operator from the schema and implementation. The implementation function is wrapped into another function, which pops values from the stack into an argument tuple, then invokes the function and pushes the return value back onto the stack, sometimes unpacking the return value if it is a tuple.\r\n\r\nCurrently the method is called `createOperator`. We may want to think of a nicer way of registering ops in tandem with `RegisterOperators`. It might be very cumbersome to add a template constructor to `Operator`, so maybe we can come up with a chaining method on `RegisterOperators` like `RegisterOperators(schema, func).op(schema.func).op(schema, func)` -- it has to work at startup time (for a static variable) though. We can solve this in another PR.\r\n\r\n@zdevito @apaszke @smessmer @dzhulgakov "}