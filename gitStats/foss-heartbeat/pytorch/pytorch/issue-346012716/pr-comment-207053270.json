{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/207053270", "pull_request_review_id": 142588752, "id": 207053270, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwNzA1MzI3MA==", "diff_hunk": "@@ -0,0 +1,190 @@\n+#pragma once\n+\n+#include <torch/csrc/jit/function_schema.h>\n+#include <torch/csrc/jit/ir.h>\n+#include <torch/csrc/jit/operator.h>\n+#include <torch/csrc/jit/stack.h>\n+#include <torch/csrc/utils/variadic.h>\n+\n+#include <caffe2/utils/Metaprogramming.h>\n+#include <caffe2/utils/TypeList.h>\n+\n+namespace torch { namespace jit {\n+namespace detail {\n+template <typename... Ts, size_t... Is>\n+std::vector<Argument> createArgumentVectorFromTypes(Indices<Is...> indices) {\n+  // Arguments are named \"_<index>\"\n+  return {Argument(\"_\" + std::to_string(Is), getTypePtr<Ts>())...};\n+}\n+\n+template <typename... Ts, size_t... Is>\n+std::vector<Argument> createReturns(Indices<Is...> indices) {\n+  return createArgumentVectorFromTypes<Ts..., Is...>();\n+}\n+\n+/// Unpack a tuple return type into a vector of return types, one per tuple\n+/// element.\n+template <typename... Ts>\n+std::vector<Argument> createReturns(std::tuple<Ts...>* tuple) {\n+  // Create an index pack so we can call `get<Indices>` on the tuple next.\n+  return createReturns<Ts...>(typename MakeIndices<sizeof...(Ts)>::indices{});\n+}\n+\n+/// Create a single-element `vector` for simple (non-tuple) return types.\n+template <typename ReturnType>\n+std::vector<Argument> createReturns(ReturnType*) {\n+  return {Argument(\"_1\", getTypePtr<ReturnType>())};\n+}\n+\n+/// Creates a vector of `Argument` from `FunctionTraits` and a pack of indices\n+/// into the argument list.\n+template <typename FunctionTraits, size_t... Is>\n+std::vector<Argument> createArgumentVectorFromTraits(Indices<Is...> indices) {\n+  using ArgumentTypes = typename FunctionTraits::parameter_types;\n+  return createArgumentVectorFromTypes<\n+      c10::guts::typelist::element_t<Is, ArgumentTypes>...>(indices);\n+}\n+\n+/// Creates a `FunctionSchema` object from a `FunctionTraits` type for a\n+/// function.\n+template <typename FunctionTraits>\n+FunctionSchema createFunctionSchemaFromTraits(const std::string& name) {\n+  using ReturnType = typename FunctionTraits::return_type;\n+  auto arguments = createArgumentVectorFromTraits<FunctionTraits>(\n+      typename MakeIndices<FunctionTraits::number_of_parameters>::indices{});\n+  auto returns = createReturns(static_cast<ReturnType*>(nullptr));\n+  return {name, arguments, returns};\n+}\n+\n+/// Does two things for an operator implementation and a tuple of arguments:\n+/// 1. Pops all necessary arguments off the stack into the tuple's elements,\n+/// 2. Unpacks the tuple and calls the operator implementation.\n+/// The result of the implementation call is returned.\n+template <\n+    typename ReturnType,\n+    typename Implementation,\n+    typename... Types,\n+    size_t... Is>\n+ReturnType callOperatorWithTuple(\n+    Implementation&& implementation,\n+    Stack& stack,\n+    std::tuple<Types...>& tuple,\n+    Indices<Is...>) {\n+  pop(stack, std::get<Is>(tuple)...);\n+  return std::forward<Implementation>(implementation)(std::get<Is>(tuple)...);\n+}\n+\n+void checkArgumentVector(\n+    const char* what,\n+    const std::vector<Argument>& inferred,\n+    const std::vector<Argument>& provided,\n+    const FunctionSchema& inferredSchema,\n+    const FunctionSchema& providedSchema) {\n+  AT_CHECK(\n+      inferred.size() == provided.size(),\n+      \"Inferred \", inferred.size(), \" \", what,\n+      \"(s) for operator implementation, but the provided schema specified \",\n+      provided.size(), \" \", what, \"(s). Inferred schema: \",\n+      inferredSchema, \" | Provided schema: \", providedSchema);\n+  for (size_t i = 0; i < provided.size(); ++i) {\n+    AT_CHECK(\n+        provided[i].type == inferred[i].type,\n+        \"Inferred type for \", what, \" #\", i, \" was \",\n+        *inferred[i].type, \", but the provided schema specified type \",\n+        *provided[i].type, \" for the \", what,\n+        \" in that position. Inferred schema: \",\n+        inferredSchema, \" | Provided schema: \", providedSchema);\n+  }\n+}\n+\n+/// If `schemaOrName` contains a `(`, it is assumed it specifies a schema, else\n+/// it is assumed it only specifies the name. In the case where it is a full\n+/// schema (assumed), we nevertheless infer the schema and verify that the user\n+/// made no mistakes. Either way, this function returns the final schema.\n+template <typename Traits>\n+FunctionSchema inferAndCheckSchema(const std::string& schemaOrName) {\n+  // If there is no '(' in the schema, we assume this is only the name (e.g.\n+  // \"foo::bar\").\n+  const auto bracketIndex = schemaOrName.find('(');\n+  if (bracketIndex == std::string::npos) {\n+    // Infer the full schema and we're good.\n+    return torch::jit::detail::createFunctionSchemaFromTraits<Traits>(\n+        /*name=*/schemaOrName);\n+  }\n+\n+  // If the user provided her own schema, we need to infer it nevertheless and\n+  // check that it's correct. We return the user provided schema in the end\n+  // because it has proper argument names.\n+\n+  auto providedSchema = parseSchema(schemaOrName);\n+  // Pick out only the name part.\n+  auto name = schemaOrName.substr(0, bracketIndex);\n+\n+  const auto inferredSchema =\n+      torch::jit::detail::createFunctionSchemaFromTraits<Traits>(name);\n+  checkArgumentVector(\n+      \"argument\",\n+      inferredSchema.arguments,\n+      providedSchema.arguments,\n+      inferredSchema,\n+      providedSchema);\n+  checkArgumentVector(\n+      \"return value\",\n+      inferredSchema.returns,\n+      providedSchema.returns,\n+      inferredSchema,\n+      providedSchema);\n+  return providedSchema;\n+}\n+} // namespace detail\n+\n+/// Registers a custom operator with a name or schema, and an implementation\n+/// function.\n+///\n+/// If the first argument specifies only the function name like `foo::bar`, the\n+/// schema, including the type of each argument and the return type, is inferred\n+/// from the function signature. Otherwise, the string should specify the whole\n+/// schema, like `foo::bar(Tensor a, double b) -> Tensor`. In that case, the\n+/// schema will still be inferred from the function and checked against this\n+/// provided schema.\n+///\n+/// If the schema is left to be inferred, the argument names will take on\n+/// sequential placeholder names like `_0`, `_1`, '_2' and so on. If you want\n+/// argument names to be preserved, you should provide the schema yourself.\n+///\n+/// The implementation function can be a function pointer or a functor\n+/// (including a lambda object). The function (or `operator()`) can take any\n+/// number of arguments with a type from the subset accepted by the PyTorch\n+/// JIT/Script backend, and return a single type or a tuple of types.\n+///\n+/// Example invocation:\n+/// ```\n+/// createOperator(\n+///    parseSchema(\"foo::bar(float a, Tensor b)\"),", "path": "torch/csrc/jit/custom_operator.h", "position": null, "original_position": 163, "commit_id": "0f99f499f0d40e72445c4ac45bebe436638e3f79", "original_commit_id": "85a02704a858e51a4ae5f22a0b248a3a4faa370d", "user": {"login": "zdevito", "id": 370202, "node_id": "MDQ6VXNlcjM3MDIwMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/370202?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zdevito", "html_url": "https://github.com/zdevito", "followers_url": "https://api.github.com/users/zdevito/followers", "following_url": "https://api.github.com/users/zdevito/following{/other_user}", "gists_url": "https://api.github.com/users/zdevito/gists{/gist_id}", "starred_url": "https://api.github.com/users/zdevito/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zdevito/subscriptions", "organizations_url": "https://api.github.com/users/zdevito/orgs", "repos_url": "https://api.github.com/users/zdevito/repos", "events_url": "https://api.github.com/users/zdevito/events{/privacy}", "received_events_url": "https://api.github.com/users/zdevito/received_events", "type": "User", "site_admin": false}, "body": "example is out of date", "created_at": "2018-08-01T22:33:17Z", "updated_at": "2018-11-23T15:48:35Z", "html_url": "https://github.com/pytorch/pytorch/pull/10048#discussion_r207053270", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/10048", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/207053270"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/10048#discussion_r207053270"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/10048"}}, "body_html": "<p>example is out of date</p>", "body_text": "example is out of date"}