{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/223425546", "pull_request_review_id": 162545735, "id": 223425546, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMzQyNTU0Ng==", "diff_hunk": "@@ -87,32 +111,33 @@ def _worker_loop(dataset, index_queue, data_queue, done_event, collate_fn, seed,\n         random.seed(seed)\n         torch.manual_seed(seed)\n \n-        # Do not wait for putting thread to join when this worker exits.\n-        # Otherwise, this worker may always be waiting to put and doesn't check\n-        # index_queue and done_event for termination signal.\n         data_queue.cancel_join_thread()\n \n         if init_fn is not None:\n             init_fn(worker_id)\n \n         watchdog = ManagerWatchdog()\n \n-        while True:\n+        while watchdog.is_alive():\n             try:\n-                r = index_queue.get(timeout=MANAGER_STATUS_CHECK_INTERVAL)\n+                r = index_queue.get(timeout=MP_STATUS_CHECK_INTERVAL)\n             except queue.Empty:\n-                if watchdog.is_alive() and not done_event.is_set():\n-                    continue\n-                else:\n-                    break\n-            # use done_event so that we can get faster exiting signal even if there\n-            # are still indices in index_queue\n-            if r is None or done_event.is_set():\n-                break\n+                continue", "path": "torch/utils/data/dataloader.py", "position": 96, "original_position": 96, "commit_id": "d3c4ffa092580d5b15ef2705bd3904f7b685e511", "original_commit_id": "398578667ab67c1b09c73456159eead852177cc1", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "body": "I don't think this is equivalent to the code we used previously. We used to not only check that the watchdog is alive, but also that the done event is not set, before we were allowed to continue an iteration. So theoretically a situation where the manager stays alive, but never pushes to a queue again, would put you in an infinite busy loop in here. That's not very nice, but I guess it should never happen, since our invariant is that everyone will eventually get their `None` signal at the end...", "created_at": "2018-10-08T16:28:09Z", "updated_at": "2018-11-23T15:52:33Z", "html_url": "https://github.com/pytorch/pytorch/pull/11985#discussion_r223425546", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/11985", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/223425546"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/11985#discussion_r223425546"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/11985"}}, "body_html": "<p>I don't think this is equivalent to the code we used previously. We used to not only check that the watchdog is alive, but also that the done event is not set, before we were allowed to continue an iteration. So theoretically a situation where the manager stays alive, but never pushes to a queue again, would put you in an infinite busy loop in here. That's not very nice, but I guess it should never happen, since our invariant is that everyone will eventually get their <code>None</code> signal at the end...</p>", "body_text": "I don't think this is equivalent to the code we used previously. We used to not only check that the watchdog is alive, but also that the done event is not set, before we were allowed to continue an iteration. So theoretically a situation where the manager stays alive, but never pushes to a queue again, would put you in an infinite busy loop in here. That's not very nice, but I guess it should never happen, since our invariant is that everyone will eventually get their None signal at the end..."}