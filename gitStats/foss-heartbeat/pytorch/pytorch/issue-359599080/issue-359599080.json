{"url": "https://api.github.com/repos/pytorch/pytorch/issues/11589", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/11589/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/11589/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/11589/events", "html_url": "https://github.com/pytorch/pytorch/pull/11589", "id": 359599080, "node_id": "MDExOlB1bGxSZXF1ZXN0MjE1MDU0MDI0", "number": 11589, "title": "Disallow scalar parameters in  Dirichlet and Categorical", "user": {"login": "neerajprad", "id": 1762463, "node_id": "MDQ6VXNlcjE3NjI0NjM=", "avatar_url": "https://avatars3.githubusercontent.com/u/1762463?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neerajprad", "html_url": "https://github.com/neerajprad", "followers_url": "https://api.github.com/users/neerajprad/followers", "following_url": "https://api.github.com/users/neerajprad/following{/other_user}", "gists_url": "https://api.github.com/users/neerajprad/gists{/gist_id}", "starred_url": "https://api.github.com/users/neerajprad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neerajprad/subscriptions", "organizations_url": "https://api.github.com/users/neerajprad/orgs", "repos_url": "https://api.github.com/users/neerajprad/repos", "events_url": "https://api.github.com/users/neerajprad/events{/privacy}", "received_events_url": "https://api.github.com/users/neerajprad/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2018-09-12T18:25:48Z", "updated_at": "2018-11-23T15:51:12Z", "closed_at": "2018-09-14T14:57:03Z", "author_association": "CONTRIBUTOR", "pull_request": {"url": "https://api.github.com/repos/pytorch/pytorch/pulls/11589", "html_url": "https://github.com/pytorch/pytorch/pull/11589", "diff_url": "https://github.com/pytorch/pytorch/pull/11589.diff", "patch_url": "https://github.com/pytorch/pytorch/pull/11589.patch"}, "body_html": "<p>This adds a small check in <code>Dirichlet</code> and <code>Categorical</code> <code>__init__</code> methods to ensure that scalar parameters are not admissible.</p>\n<p><strong>Motivation</strong><br>\nCurrently, <code>Dirichlet</code> throws no error when provided with a scalar parameter, but if we <code>expand</code> a scalar instance, it inherits the empty event shape from the original instance and gives unexpected results.</p>\n<p>The alternative to this check is to promote <code>event_shape</code> to be <code>torch.Size((1,))</code> if the original instance was a scalar, but that seems to add a bit more complexity (and changes the behavior of <code>expand</code> in that it would affect the <code>event_shape</code> as well as the <code>batch_shape</code> now). Does this seem reasonable? cc. <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=1093846\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/alicanb\">@alicanb</a>, <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=648532\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/fritzo\">@fritzo</a>.</p>\n<div class=\"highlight highlight-source-python\"><pre>In [<span class=\"pl-c1\">4</span>]: d <span class=\"pl-k\">=</span> dist.Dirichlet(torch.tensor(<span class=\"pl-c1\">1</span>.))\n\nIn [<span class=\"pl-c1\">5</span>]: d.sample()\nOut[<span class=\"pl-c1\">5</span>]: tensor(<span class=\"pl-c1\">1.0000</span>)\n\nIn [<span class=\"pl-c1\">6</span>]: d.log_prob(d.sample())\nOut[<span class=\"pl-c1\">6</span>]: tensor(<span class=\"pl-c1\">0</span>.)\n\nIn [<span class=\"pl-c1\">7</span>]: e <span class=\"pl-k\">=</span> d.expand([<span class=\"pl-c1\">3</span>])\n\nIn [<span class=\"pl-c1\">8</span>]: e.sample()\nOut[<span class=\"pl-c1\">8</span>]: tensor([<span class=\"pl-c1\">0.3953</span>, <span class=\"pl-c1\">0.1797</span>, <span class=\"pl-c1\">0.4250</span>])  <span class=\"pl-c\"><span class=\"pl-c\">#</span> interpreted as events</span>\n\nIn [<span class=\"pl-c1\">9</span>]: e.log_prob(e.sample())\nOut[<span class=\"pl-c1\">9</span>]: tensor(<span class=\"pl-c1\">0.6931</span>)  <span class=\"pl-c\"><span class=\"pl-c\">#</span> wrongly summed out</span>\n\nIn [<span class=\"pl-c1\">10</span>]: e.batch_shape\nOut[<span class=\"pl-c1\">10</span>]: torch.Size([<span class=\"pl-c1\">3</span>])\n\nIn [<span class=\"pl-c1\">11</span>]: e.event_shape\nOut[<span class=\"pl-c1\">11</span>]: torch.Size([])  <span class=\"pl-c\"><span class=\"pl-c\">#</span> cannot be empty</span></pre></div>\n<p>Additionally, based on review comments, this removes <code>real_vector</code> constraint. This was only being used in <code>MultivariateNormal</code>, but I am happy to revert this if we want to keep it around for backwards compatibility.</p>", "body_text": "This adds a small check in Dirichlet and Categorical __init__ methods to ensure that scalar parameters are not admissible.\nMotivation\nCurrently, Dirichlet throws no error when provided with a scalar parameter, but if we expand a scalar instance, it inherits the empty event shape from the original instance and gives unexpected results.\nThe alternative to this check is to promote event_shape to be torch.Size((1,)) if the original instance was a scalar, but that seems to add a bit more complexity (and changes the behavior of expand in that it would affect the event_shape as well as the batch_shape now). Does this seem reasonable? cc. @alicanb, @fritzo.\nIn [4]: d = dist.Dirichlet(torch.tensor(1.))\n\nIn [5]: d.sample()\nOut[5]: tensor(1.0000)\n\nIn [6]: d.log_prob(d.sample())\nOut[6]: tensor(0.)\n\nIn [7]: e = d.expand([3])\n\nIn [8]: e.sample()\nOut[8]: tensor([0.3953, 0.1797, 0.4250])  # interpreted as events\n\nIn [9]: e.log_prob(e.sample())\nOut[9]: tensor(0.6931)  # wrongly summed out\n\nIn [10]: e.batch_shape\nOut[10]: torch.Size([3])\n\nIn [11]: e.event_shape\nOut[11]: torch.Size([])  # cannot be empty\nAdditionally, based on review comments, this removes real_vector constraint. This was only being used in MultivariateNormal, but I am happy to revert this if we want to keep it around for backwards compatibility.", "body": "This adds a small check in `Dirichlet` and `Categorical` `__init__` methods to ensure that scalar parameters are not admissible. \r\n\r\n**Motivation**\r\nCurrently, `Dirichlet` throws no error when provided with a scalar parameter, but if we `expand` a scalar instance, it inherits the empty event shape from the original instance and gives unexpected results. \r\n\r\nThe alternative to this check is to promote `event_shape` to be `torch.Size((1,))` if the original instance was a scalar, but that seems to add a bit more complexity (and changes the behavior of `expand` in that it would affect the `event_shape` as well as the `batch_shape` now). Does this seem reasonable? cc. @alicanb, @fritzo. \r\n\r\n```python\r\nIn [4]: d = dist.Dirichlet(torch.tensor(1.))\r\n\r\nIn [5]: d.sample()\r\nOut[5]: tensor(1.0000)\r\n\r\nIn [6]: d.log_prob(d.sample())\r\nOut[6]: tensor(0.)\r\n\r\nIn [7]: e = d.expand([3])\r\n\r\nIn [8]: e.sample()\r\nOut[8]: tensor([0.3953, 0.1797, 0.4250])  # interpreted as events\r\n\r\nIn [9]: e.log_prob(e.sample())\r\nOut[9]: tensor(0.6931)  # wrongly summed out\r\n\r\nIn [10]: e.batch_shape\r\nOut[10]: torch.Size([3])\r\n\r\nIn [11]: e.event_shape\r\nOut[11]: torch.Size([])  # cannot be empty\r\n```\r\n\r\nAdditionally, based on review comments, this removes `real_vector` constraint. This was only being used in `MultivariateNormal`, but I am happy to revert this if we want to keep it around for backwards compatibility."}