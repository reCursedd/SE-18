{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/352291039", "html_url": "https://github.com/pytorch/pytorch/issues/4215#issuecomment-352291039", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/4215", "id": 352291039, "node_id": "MDEyOklzc3VlQ29tbWVudDM1MjI5MTAzOQ==", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "created_at": "2017-12-17T22:29:16Z", "updated_at": "2017-12-17T22:29:16Z", "author_association": "CONTRIBUTOR", "body_html": "<p>OK, at the time I filed this, I wasn't quite sure if this was causing my memory corruption, but I've run some more tests and I am fairly confident that the memory corruption that I've been tracking down since Friday boils down to this function implementation in <code>VariableType.cpp</code>:</p>\n<pre><code>static void set_flags(at::ArrayRef&lt;Variable&gt; vl, VarFlags flags, std::shared_ptr&lt;Function&gt; grad_fn) {\n  if (grad_fn) {\n    grad_fn-&gt;num_inputs = vl.size();\n  }\n  int64_t output_nr = 0;\n  for (auto&amp; var : vl) {\n    // TODO: combine this with the Variable construction\n    var.get()-&gt;requires_grad = flags.requires_grad;\n    var.get()-&gt;is_volatile = flags.is_volatile;\n    var.get()-&gt;output_nr = output_nr;\n    var.get()-&gt;_grad_fn = grad_fn;\n    output_nr++;\n  }\n}\n</code></pre>\n<p>This code looked totally reasonable in review, and is in actuality extremely dangerous because it assumes that all the Variables are defined and silently corrupts memory if they are not. But <em>unlike</em> null pointers, the memory <code>var</code> points to is usually mapped, which means you don't get an immediate segfault when this happens.</p>\n<p>Under what circumstances could we return an undefined variable from a method wrapped in Variable? The situation that triggers this is when we have backwards functions, which take an <code>output_mask</code> to determine what outputs they need to compute. Here, an undefined is returned in any case the gradient was not requested. Thus, making Variable non-default constructible doesn't solve the problem.</p>\n<p>What about making <code>set_flags</code> a method on <code>Variable</code>, and truly making it illegal, everywhere, to access data members directly? I think that would make it sufficiently difficult to commit the same error in the future.</p>", "body_text": "OK, at the time I filed this, I wasn't quite sure if this was causing my memory corruption, but I've run some more tests and I am fairly confident that the memory corruption that I've been tracking down since Friday boils down to this function implementation in VariableType.cpp:\nstatic void set_flags(at::ArrayRef<Variable> vl, VarFlags flags, std::shared_ptr<Function> grad_fn) {\n  if (grad_fn) {\n    grad_fn->num_inputs = vl.size();\n  }\n  int64_t output_nr = 0;\n  for (auto& var : vl) {\n    // TODO: combine this with the Variable construction\n    var.get()->requires_grad = flags.requires_grad;\n    var.get()->is_volatile = flags.is_volatile;\n    var.get()->output_nr = output_nr;\n    var.get()->_grad_fn = grad_fn;\n    output_nr++;\n  }\n}\n\nThis code looked totally reasonable in review, and is in actuality extremely dangerous because it assumes that all the Variables are defined and silently corrupts memory if they are not. But unlike null pointers, the memory var points to is usually mapped, which means you don't get an immediate segfault when this happens.\nUnder what circumstances could we return an undefined variable from a method wrapped in Variable? The situation that triggers this is when we have backwards functions, which take an output_mask to determine what outputs they need to compute. Here, an undefined is returned in any case the gradient was not requested. Thus, making Variable non-default constructible doesn't solve the problem.\nWhat about making set_flags a method on Variable, and truly making it illegal, everywhere, to access data members directly? I think that would make it sufficiently difficult to commit the same error in the future.", "body": "OK, at the time I filed this, I wasn't quite sure if this was causing my memory corruption, but I've run some more tests and I am fairly confident that the memory corruption that I've been tracking down since Friday boils down to this function implementation in `VariableType.cpp`:\r\n\r\n```\r\nstatic void set_flags(at::ArrayRef<Variable> vl, VarFlags flags, std::shared_ptr<Function> grad_fn) {\r\n  if (grad_fn) {\r\n    grad_fn->num_inputs = vl.size();\r\n  }\r\n  int64_t output_nr = 0;\r\n  for (auto& var : vl) {\r\n    // TODO: combine this with the Variable construction\r\n    var.get()->requires_grad = flags.requires_grad;\r\n    var.get()->is_volatile = flags.is_volatile;\r\n    var.get()->output_nr = output_nr;\r\n    var.get()->_grad_fn = grad_fn;\r\n    output_nr++;\r\n  }\r\n}\r\n```\r\n\r\nThis code looked totally reasonable in review, and is in actuality extremely dangerous because it assumes that all the Variables are defined and silently corrupts memory if they are not. But *unlike* null pointers, the memory `var` points to is usually mapped, which means you don't get an immediate segfault when this happens.\r\n\r\nUnder what circumstances could we return an undefined variable from a method wrapped in Variable? The situation that triggers this is when we have backwards functions, which take an `output_mask` to determine what outputs they need to compute. Here, an undefined is returned in any case the gradient was not requested. Thus, making Variable non-default constructible doesn't solve the problem.\r\n\r\nWhat about making `set_flags` a method on `Variable`, and truly making it illegal, everywhere, to access data members directly? I think that would make it sufficiently difficult to commit the same error in the future."}