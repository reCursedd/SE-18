{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/110113923", "pull_request_review_id": 31261044, "id": 110113923, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDExMDExMzkyMw==", "diff_hunk": "@@ -112,134 +122,132 @@ auto Engine::thread_on_exception(FunctionTask& task, std::exception& e) -> void\n   }\n }\n \n-static variable_list call_pre_hooks(Function& fn, variable_list grad_output) {\n+static variable_list call_pre_hooks(Function& fn, variable_list inputs) {\n   for (auto& hook : fn.pre_hooks) {\n-    grad_output = (*hook)(grad_output);\n+    inputs = (*hook)(inputs);\n   }\n-  return grad_output;\n+  return inputs;\n }\n \n-static variable_list call_post_hooks(Function& fn, variable_list grad_input, variable_list grad_output) {\n+static variable_list call_post_hooks(Function& fn, variable_list outputs, variable_list inputs) {\n   for (auto& hook : fn.post_hooks) {\n-    grad_input = (*hook)(grad_input, grad_output);\n+    outputs = (*hook)(outputs, inputs);\n   }\n-  return grad_input;\n+  return outputs;\n }\n \n-static variable_list call_function(FunctionTask& task) {\n-  auto grad_output = call_pre_hooks(*task.fn, GradBuffer::variables(std::move(task.grad)));\n-  auto grad_input = task.fn->apply(grad_output);\n-  return call_post_hooks(*task.fn, std::move(grad_input), std::move(grad_output));\n+static std::pair<bool, variable_list> call_function(FunctionTask& task) {\n+  auto& fn = *task.fn;\n+  auto inputs = call_pre_hooks(fn, InputBuffer::variables(std::move(task.inputs)));\n+\n+  auto& function_callbacks = task.base->function_callbacks;", "path": "torch/csrc/autograd/engine.cpp", "position": null, "original_position": 103, "commit_id": "fc48d2c1dd1d40fef3f8c727897eaac70d9bbd14", "original_commit_id": "bede03dfafc40978334d5564eb2e2d48483d437a", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "body": "Yeah it might seem weird but that's how hooks work:\r\n* You can think of pre-hooks as hooks registered on incoming edges, but since we have no \"edge objects\", we need to register them in the next function. But they are `pre_hooks` because they always execute before the inputs even arrive at the function. Also, this is needed because we want to execute the Variable hooks even when we'll be capturing the grad using a callback.\r\n* Post hooks are for reading/overriding the output of the function, so it doesn't make sense to call them if a callback aborts the operation.", "created_at": "2017-04-06T09:16:02Z", "updated_at": "2018-11-23T15:33:02Z", "html_url": "https://github.com/pytorch/pytorch/pull/1016#discussion_r110113923", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/1016", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/110113923"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/1016#discussion_r110113923"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/1016"}}, "body_html": "<p>Yeah it might seem weird but that's how hooks work:</p>\n<ul>\n<li>You can think of pre-hooks as hooks registered on incoming edges, but since we have no \"edge objects\", we need to register them in the next function. But they are <code>pre_hooks</code> because they always execute before the inputs even arrive at the function. Also, this is needed because we want to execute the Variable hooks even when we'll be capturing the grad using a callback.</li>\n<li>Post hooks are for reading/overriding the output of the function, so it doesn't make sense to call them if a callback aborts the operation.</li>\n</ul>", "body_text": "Yeah it might seem weird but that's how hooks work:\n\nYou can think of pre-hooks as hooks registered on incoming edges, but since we have no \"edge objects\", we need to register them in the next function. But they are pre_hooks because they always execute before the inputs even arrive at the function. Also, this is needed because we want to execute the Variable hooks even when we'll be capturing the grad using a callback.\nPost hooks are for reading/overriding the output of the function, so it doesn't make sense to call them if a callback aborts the operation.", "in_reply_to_id": 109857075}