{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/343729884", "html_url": "https://github.com/pytorch/pytorch/issues/3653#issuecomment-343729884", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/3653", "id": 343729884, "node_id": "MDEyOklzc3VlQ29tbWVudDM0MzcyOTg4NA==", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "created_at": "2017-11-12T11:18:08Z", "updated_at": "2017-11-12T11:18:08Z", "author_association": "MEMBER", "body_html": "<p>There's a good reason for the <code>view</code> invariant - most of such reshapes are impossible to pull off using stride tricks if then tensor isn't contiguous. On the other hand, making it contiguous inside <code>view</code> would mean that sometimes the returned tensor shares storage with input, and sometimes doesn't. This is important for cases like these: <code>x.view(-1)[::x.size(1) + 1] += c</code> (add <code>c</code> to diagonal of matrix <code>x</code>). If you know/suspect that tensors might sometimes be non-contiguous just add <code>.contiguous()</code> before <code>.view()</code> it's a no-op if the tensor already is contiguous</p>", "body_text": "There's a good reason for the view invariant - most of such reshapes are impossible to pull off using stride tricks if then tensor isn't contiguous. On the other hand, making it contiguous inside view would mean that sometimes the returned tensor shares storage with input, and sometimes doesn't. This is important for cases like these: x.view(-1)[::x.size(1) + 1] += c (add c to diagonal of matrix x). If you know/suspect that tensors might sometimes be non-contiguous just add .contiguous() before .view() it's a no-op if the tensor already is contiguous", "body": "There's a good reason for the `view` invariant - most of such reshapes are impossible to pull off using stride tricks if then tensor isn't contiguous. On the other hand, making it contiguous inside `view` would mean that sometimes the returned tensor shares storage with input, and sometimes doesn't. This is important for cases like these: `x.view(-1)[::x.size(1) + 1] += c` (add `c` to diagonal of matrix `x`). If you know/suspect that tensors might sometimes be non-contiguous just add `.contiguous()` before `.view()` it's a no-op if the tensor already is contiguous"}