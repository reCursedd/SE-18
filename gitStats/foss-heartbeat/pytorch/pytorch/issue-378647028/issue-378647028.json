{"url": "https://api.github.com/repos/pytorch/pytorch/issues/13715", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/13715/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/13715/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/13715/events", "html_url": "https://github.com/pytorch/pytorch/issues/13715", "id": 378647028, "node_id": "MDU6SXNzdWUzNzg2NDcwMjg=", "number": 13715, "title": "caffe2 c++ load pb model fail", "user": {"login": "cswwp", "id": 11901683, "node_id": "MDQ6VXNlcjExOTAxNjgz", "avatar_url": "https://avatars0.githubusercontent.com/u/11901683?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cswwp", "html_url": "https://github.com/cswwp", "followers_url": "https://api.github.com/users/cswwp/followers", "following_url": "https://api.github.com/users/cswwp/following{/other_user}", "gists_url": "https://api.github.com/users/cswwp/gists{/gist_id}", "starred_url": "https://api.github.com/users/cswwp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cswwp/subscriptions", "organizations_url": "https://api.github.com/users/cswwp/orgs", "repos_url": "https://api.github.com/users/cswwp/repos", "events_url": "https://api.github.com/users/cswwp/events{/privacy}", "received_events_url": "https://api.github.com/users/cswwp/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 890282107, "node_id": "MDU6TGFiZWw4OTAyODIxMDc=", "url": "https://api.github.com/repos/pytorch/pytorch/labels/caffe2", "name": "caffe2", "color": "210aa8", "default": false}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2018-11-08T09:32:48Z", "updated_at": "2018-11-14T15:07:24Z", "closed_at": null, "author_association": "NONE", "body_html": "<p>Hi everyone, i convert shufflenet v2 to caffe2 pb model, which correct run in python caffe2, but when i load pb model in caffe2 c++, it can't generate predictor, my code is as follows:<br>\n`namespace caffe2 {</p>\n<p>void run() {<br>\nstd::cout &lt;&lt; std::endl;<br>\nstd::cout &lt;&lt; \"## Caffe2 Loading Pre-Trained Models Tutorial ##\" &lt;&lt; std::endl;<br>\nstd::cout &lt;&lt; \"<a href=\"https://caffe2.ai/docs/zoo.html\" rel=\"nofollow\">https://caffe2.ai/docs/zoo.html</a>\" &lt;&lt; std::endl;<br>\nstd::cout &lt;&lt; \"<a href=\"https://caffe2.ai/docs/tutorial-loading-pre-trained-models.html\" rel=\"nofollow\">https://caffe2.ai/docs/tutorial-loading-pre-trained-models.html</a>\"<br>\n&lt;&lt; std::endl;<br>\nstd::cout &lt;&lt; \"<a href=\"https://caffe2.ai/docs/tutorial-image-pre-processing.html\" rel=\"nofollow\">https://caffe2.ai/docs/tutorial-image-pre-processing.html</a>\"<br>\n&lt;&lt; std::endl;<br>\nstd::cout &lt;&lt; std::endl;</p>\n<p>if (!std::ifstream(FLAGS_init_net).good() ||<br>\n!std::ifstream(FLAGS_predict_net).good()) {<br>\nstd::cerr &lt;&lt; \"error: Squeezenet model file missing: \"<br>\n&lt;&lt; (std::ifstream(FLAGS_init_net).good() ? FLAGS_predict_net<br>\n: FLAGS_init_net)<br>\n&lt;&lt; std::endl;<br>\nstd::cerr &lt;&lt; \"Make sure to first run ./script/download_resource.sh\"<br>\n&lt;&lt; std::endl;<br>\nreturn;<br>\n}</p>\n<p>if (!std::ifstream(FLAGS_file).good()) {<br>\nstd::cerr &lt;&lt; \"error: Image file missing: \" &lt;&lt; FLAGS_file &lt;&lt; std::endl;<br>\nreturn;<br>\n}</p>\n<p>if (!std::ifstream(FLAGS_classes).good()) {<br>\nstd::cerr &lt;&lt; \"error: Classes file invalid: \" &lt;&lt; FLAGS_classes &lt;&lt; std::endl;<br>\nreturn;<br>\n}</p>\n<p>std::cout &lt;&lt; \"init-net: \" &lt;&lt; FLAGS_init_net &lt;&lt; std::endl;<br>\nstd::cout &lt;&lt; \"predict-net: \" &lt;&lt; FLAGS_predict_net &lt;&lt; std::endl;<br>\nstd::cout &lt;&lt; \"file: \" &lt;&lt; FLAGS_file &lt;&lt; std::endl;<br>\nstd::cout &lt;&lt; \"size: \" &lt;&lt; FLAGS_size &lt;&lt; std::endl;</p>\n<p>std::cout &lt;&lt; std::endl;</p>\n<p>// &gt;&gt;&gt; img =<br>\n// skimage.img_as_float(skimage.io.imread(IMAGE_LOCATION)).astype(np.float32)<br>\nauto image = cv::imread(FLAGS_file);  // CV_8UC3<br>\nstd::cout &lt;&lt; \"image size: \" &lt;&lt; image.size() &lt;&lt; std::endl;</p>\n<p>// scale image to fit<br>\ncv::Size scale(std::max(FLAGS_size * image.cols / image.rows, FLAGS_size),<br>\nstd::max(FLAGS_size, FLAGS_size * image.rows / image.cols));<br>\ncv::resize(image, image, scale);<br>\nstd::cout &lt;&lt; \"scaled size: \" &lt;&lt; image.size() &lt;&lt; std::endl;</p>\n<p>// crop image to fit<br>\ncv::Rect crop((image.cols - FLAGS_size) / 2, (image.rows - FLAGS_size) / 2,<br>\nFLAGS_size, FLAGS_size);<br>\nimage = image(crop);<br>\nstd::cout &lt;&lt; \"cropped size: \" &lt;&lt; image.size() &lt;&lt; std::endl;</p>\n<p>// convert to float, normalize to mean 128<br>\nimage.convertTo(image, CV_32FC3, 1.0, -128);<br>\nstd::cout &lt;&lt; \"value range: (\"<br>\n&lt;&lt; *std::min_element((float *)image.datastart,<br>\n(float *)image.dataend)<br>\n&lt;&lt; \", \"<br>\n&lt;&lt; *std::max_element((float *)image.datastart,<br>\n(float *)image.dataend)<br>\n&lt;&lt; \")\" &lt;&lt; std::endl;</p>\n<p>// convert NHWC to NCHW<br>\nvectorcv::Mat channels(3);<br>\ncv::split(image, channels);<br>\nstd::vector data;<br>\nfor (auto &amp;c : channels) {<br>\ndata.insert(data.end(), (float *)c.datastart, (float *)c.dataend);<br>\n}<br>\nstd::vector dims({1, image.channels(), image.rows, image.cols});<br>\nTensorCPU tensor(dims, data, NULL);</p>\n<p>// Load Squeezenet model<br>\nNetDef init_net, predict_net;</p>\n<p>// &gt;&gt;&gt; with open(path_to_INIT_NET) as f:<br>\nCAFFE_ENFORCE(ReadProtoFromFile(FLAGS_init_net, &amp;init_net));<br>\nstd::cout &lt;&lt;\"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\"&lt;&lt; std::endl;<br>\n// &gt;&gt;&gt; with open(path_to_PREDICT_NET) as f:<br>\nCAFFE_ENFORCE(ReadProtoFromFile(FLAGS_predict_net, &amp;predict_net));<br>\nstd::cout &lt;&lt;\"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\"&lt;&lt; std::endl;<br>\n// &gt;&gt;&gt; p = workspace.Predictor(init_net, predict_net)<br>\nWorkspace workspace(\"tmp\");<br>\nCAFFE_ENFORCE(workspace.RunNetOnce(init_net));</p>\n<p>auto input = workspace.CreateBlob(\"data\")-&gt;GetMutable();<br>\ninput-&gt;ResizeLike(tensor);<br>\ninput-&gt;ShareData(tensor);<br>\nCAFFE_ENFORCE(workspace.RunNetOnce(predict_net));<br>\nstd::cout &lt;&lt;\"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\"&lt;&lt; std::endl;</p>\n<p>// &gt;&gt;&gt; results = p.run([img])<br>\nauto &amp;output_name = predict_net.external_output(0);<br>\nauto output = workspace.GetBlob(output_name)-&gt;Get();</p>\n<p>// sort top results<br>\nconst auto &amp;probs = output.data();<br>\nstd::vector&lt;std::pair&lt;int, int&gt;&gt; pairs;<br>\nfor (auto i = 0; i &lt; output.size(); i++) {<br>\nif (probs[i] &gt; 0.01) {<br>\npairs.push_back(std::make_pair(probs[i] * 100, i));<br>\n}<br>\n}</p>\n<p>std::sort(pairs.begin(), pairs.end());</p>\n<p>std::cout &lt;&lt; std::endl;</p>\n<p>// read classes<br>\nstd::ifstream file(FLAGS_classes);<br>\nstd::string temp;<br>\nstd::vectorstd::string classes;<br>\nwhile (std::getline(file, temp)) {<br>\nclasses.push_back(temp);<br>\n}</p>\n<p>// show results<br>\nstd::cout &lt;&lt; \"output: \" &lt;&lt; std::endl;<br>\nfor (auto pair : pairs) {<br>\nstd::cout &lt;&lt; \"  \" &lt;&lt; pair.first &lt;&lt; \"% '\" &lt;&lt; classes[pair.second] &lt;&lt; \"' (\"<br>\n&lt;&lt; pair.second &lt;&lt; \")\" &lt;&lt; std::endl;<br>\n}<br>\n}</p>\n<p>}  // namespace caffe2<br>\n`<br>\nthe error is<br>\nterminate called after throwing an instance of 'caffe2::EnforceNotMet'<br>\nwhat():  [enforce fail at operator.cc:42] blob != nullptr. op Conv: Encountered a non-existing input blob: 0</p>\n<p>anyone help me ?</p>", "body_text": "Hi everyone, i convert shufflenet v2 to caffe2 pb model, which correct run in python caffe2, but when i load pb model in caffe2 c++, it can't generate predictor, my code is as follows:\n`namespace caffe2 {\nvoid run() {\nstd::cout << std::endl;\nstd::cout << \"## Caffe2 Loading Pre-Trained Models Tutorial ##\" << std::endl;\nstd::cout << \"https://caffe2.ai/docs/zoo.html\" << std::endl;\nstd::cout << \"https://caffe2.ai/docs/tutorial-loading-pre-trained-models.html\"\n<< std::endl;\nstd::cout << \"https://caffe2.ai/docs/tutorial-image-pre-processing.html\"\n<< std::endl;\nstd::cout << std::endl;\nif (!std::ifstream(FLAGS_init_net).good() ||\n!std::ifstream(FLAGS_predict_net).good()) {\nstd::cerr << \"error: Squeezenet model file missing: \"\n<< (std::ifstream(FLAGS_init_net).good() ? FLAGS_predict_net\n: FLAGS_init_net)\n<< std::endl;\nstd::cerr << \"Make sure to first run ./script/download_resource.sh\"\n<< std::endl;\nreturn;\n}\nif (!std::ifstream(FLAGS_file).good()) {\nstd::cerr << \"error: Image file missing: \" << FLAGS_file << std::endl;\nreturn;\n}\nif (!std::ifstream(FLAGS_classes).good()) {\nstd::cerr << \"error: Classes file invalid: \" << FLAGS_classes << std::endl;\nreturn;\n}\nstd::cout << \"init-net: \" << FLAGS_init_net << std::endl;\nstd::cout << \"predict-net: \" << FLAGS_predict_net << std::endl;\nstd::cout << \"file: \" << FLAGS_file << std::endl;\nstd::cout << \"size: \" << FLAGS_size << std::endl;\nstd::cout << std::endl;\n// >>> img =\n// skimage.img_as_float(skimage.io.imread(IMAGE_LOCATION)).astype(np.float32)\nauto image = cv::imread(FLAGS_file);  // CV_8UC3\nstd::cout << \"image size: \" << image.size() << std::endl;\n// scale image to fit\ncv::Size scale(std::max(FLAGS_size * image.cols / image.rows, FLAGS_size),\nstd::max(FLAGS_size, FLAGS_size * image.rows / image.cols));\ncv::resize(image, image, scale);\nstd::cout << \"scaled size: \" << image.size() << std::endl;\n// crop image to fit\ncv::Rect crop((image.cols - FLAGS_size) / 2, (image.rows - FLAGS_size) / 2,\nFLAGS_size, FLAGS_size);\nimage = image(crop);\nstd::cout << \"cropped size: \" << image.size() << std::endl;\n// convert to float, normalize to mean 128\nimage.convertTo(image, CV_32FC3, 1.0, -128);\nstd::cout << \"value range: (\"\n<< *std::min_element((float *)image.datastart,\n(float *)image.dataend)\n<< \", \"\n<< *std::max_element((float *)image.datastart,\n(float *)image.dataend)\n<< \")\" << std::endl;\n// convert NHWC to NCHW\nvectorcv::Mat channels(3);\ncv::split(image, channels);\nstd::vector data;\nfor (auto &c : channels) {\ndata.insert(data.end(), (float *)c.datastart, (float *)c.dataend);\n}\nstd::vector dims({1, image.channels(), image.rows, image.cols});\nTensorCPU tensor(dims, data, NULL);\n// Load Squeezenet model\nNetDef init_net, predict_net;\n// >>> with open(path_to_INIT_NET) as f:\nCAFFE_ENFORCE(ReadProtoFromFile(FLAGS_init_net, &init_net));\nstd::cout <<\">>>>>>>>>>>>>>>\"<< std::endl;\n// >>> with open(path_to_PREDICT_NET) as f:\nCAFFE_ENFORCE(ReadProtoFromFile(FLAGS_predict_net, &predict_net));\nstd::cout <<\">>>>>>>>>>>>>>>\"<< std::endl;\n// >>> p = workspace.Predictor(init_net, predict_net)\nWorkspace workspace(\"tmp\");\nCAFFE_ENFORCE(workspace.RunNetOnce(init_net));\nauto input = workspace.CreateBlob(\"data\")->GetMutable();\ninput->ResizeLike(tensor);\ninput->ShareData(tensor);\nCAFFE_ENFORCE(workspace.RunNetOnce(predict_net));\nstd::cout <<\">>>>>>>>>>>>>>>\"<< std::endl;\n// >>> results = p.run([img])\nauto &output_name = predict_net.external_output(0);\nauto output = workspace.GetBlob(output_name)->Get();\n// sort top results\nconst auto &probs = output.data();\nstd::vector<std::pair<int, int>> pairs;\nfor (auto i = 0; i < output.size(); i++) {\nif (probs[i] > 0.01) {\npairs.push_back(std::make_pair(probs[i] * 100, i));\n}\n}\nstd::sort(pairs.begin(), pairs.end());\nstd::cout << std::endl;\n// read classes\nstd::ifstream file(FLAGS_classes);\nstd::string temp;\nstd::vectorstd::string classes;\nwhile (std::getline(file, temp)) {\nclasses.push_back(temp);\n}\n// show results\nstd::cout << \"output: \" << std::endl;\nfor (auto pair : pairs) {\nstd::cout << \"  \" << pair.first << \"% '\" << classes[pair.second] << \"' (\"\n<< pair.second << \")\" << std::endl;\n}\n}\n}  // namespace caffe2\n`\nthe error is\nterminate called after throwing an instance of 'caffe2::EnforceNotMet'\nwhat():  [enforce fail at operator.cc:42] blob != nullptr. op Conv: Encountered a non-existing input blob: 0\nanyone help me ?", "body": "Hi everyone, i convert shufflenet v2 to caffe2 pb model, which correct run in python caffe2, but when i load pb model in caffe2 c++, it can't generate predictor, my code is as follows:\r\n`namespace caffe2 {\r\n\r\nvoid run() {\r\n  std::cout << std::endl;\r\n  std::cout << \"## Caffe2 Loading Pre-Trained Models Tutorial ##\" << std::endl;\r\n  std::cout << \"https://caffe2.ai/docs/zoo.html\" << std::endl;\r\n  std::cout << \"https://caffe2.ai/docs/tutorial-loading-pre-trained-models.html\"\r\n            << std::endl;\r\n  std::cout << \"https://caffe2.ai/docs/tutorial-image-pre-processing.html\"\r\n            << std::endl;\r\n  std::cout << std::endl;\r\n\r\n  if (!std::ifstream(FLAGS_init_net).good() ||\r\n      !std::ifstream(FLAGS_predict_net).good()) {\r\n    std::cerr << \"error: Squeezenet model file missing: \"\r\n              << (std::ifstream(FLAGS_init_net).good() ? FLAGS_predict_net\r\n                                                       : FLAGS_init_net)\r\n              << std::endl;\r\n    std::cerr << \"Make sure to first run ./script/download_resource.sh\"\r\n              << std::endl;\r\n    return;\r\n  }\r\n\r\n  if (!std::ifstream(FLAGS_file).good()) {\r\n    std::cerr << \"error: Image file missing: \" << FLAGS_file << std::endl;\r\n    return;\r\n  }\r\n\r\n  if (!std::ifstream(FLAGS_classes).good()) {\r\n    std::cerr << \"error: Classes file invalid: \" << FLAGS_classes << std::endl;\r\n    return;\r\n  }\r\n\r\n  std::cout << \"init-net: \" << FLAGS_init_net << std::endl;\r\n  std::cout << \"predict-net: \" << FLAGS_predict_net << std::endl;\r\n  std::cout << \"file: \" << FLAGS_file << std::endl;\r\n  std::cout << \"size: \" << FLAGS_size << std::endl;\r\n\r\n  std::cout << std::endl;\r\n\r\n  // >>> img =\r\n  // skimage.img_as_float(skimage.io.imread(IMAGE_LOCATION)).astype(np.float32)\r\n  auto image = cv::imread(FLAGS_file);  // CV_8UC3\r\n  std::cout << \"image size: \" << image.size() << std::endl;\r\n\r\n  // scale image to fit\r\n  cv::Size scale(std::max(FLAGS_size * image.cols / image.rows, FLAGS_size),\r\n                 std::max(FLAGS_size, FLAGS_size * image.rows / image.cols));\r\n  cv::resize(image, image, scale);\r\n  std::cout << \"scaled size: \" << image.size() << std::endl;\r\n\r\n  // crop image to fit\r\n  cv::Rect crop((image.cols - FLAGS_size) / 2, (image.rows - FLAGS_size) / 2,\r\n                FLAGS_size, FLAGS_size);\r\n  image = image(crop);\r\n  std::cout << \"cropped size: \" << image.size() << std::endl;\r\n\r\n  // convert to float, normalize to mean 128\r\n  image.convertTo(image, CV_32FC3, 1.0, -128);\r\n  std::cout << \"value range: (\"\r\n            << *std::min_element((float *)image.datastart,\r\n                                 (float *)image.dataend)\r\n            << \", \"\r\n            << *std::max_element((float *)image.datastart,\r\n                                 (float *)image.dataend)\r\n            << \")\" << std::endl;\r\n\r\n  // convert NHWC to NCHW\r\n  vector<cv::Mat> channels(3);\r\n  cv::split(image, channels);\r\n  std::vector<float> data;\r\n  for (auto &c : channels) {\r\n    data.insert(data.end(), (float *)c.datastart, (float *)c.dataend);\r\n  }\r\n  std::vector<TIndex> dims({1, image.channels(), image.rows, image.cols});\r\n  TensorCPU tensor(dims, data, NULL);\r\n\r\n  // Load Squeezenet model\r\n  NetDef init_net, predict_net;\r\n\r\n  // >>> with open(path_to_INIT_NET) as f:\r\n  CAFFE_ENFORCE(ReadProtoFromFile(FLAGS_init_net, &init_net));\r\n  std::cout <<\">>>>>>>>>>>>>>>\"<< std::endl;\r\n  // >>> with open(path_to_PREDICT_NET) as f:\r\n  CAFFE_ENFORCE(ReadProtoFromFile(FLAGS_predict_net, &predict_net));\r\n    std::cout <<\">>>>>>>>>>>>>>>\"<< std::endl;\r\n  // >>> p = workspace.Predictor(init_net, predict_net)\r\n  Workspace workspace(\"tmp\");\r\n  CAFFE_ENFORCE(workspace.RunNetOnce(init_net));\r\n\r\n  auto input = workspace.CreateBlob(\"data\")->GetMutable<TensorCPU>();\r\n  input->ResizeLike(tensor);\r\n  input->ShareData(tensor);\r\n  CAFFE_ENFORCE(workspace.RunNetOnce(predict_net));\r\n  std::cout <<\">>>>>>>>>>>>>>>\"<< std::endl;\r\n\r\n  // >>> results = p.run([img])\r\n  auto &output_name = predict_net.external_output(0);\r\n  auto output = workspace.GetBlob(output_name)->Get<TensorCPU>();\r\n\r\n  // sort top results\r\n  const auto &probs = output.data<float>();\r\n  std::vector<std::pair<int, int>> pairs;\r\n  for (auto i = 0; i < output.size(); i++) {\r\n    if (probs[i] > 0.01) {\r\n      pairs.push_back(std::make_pair(probs[i] * 100, i));\r\n    }\r\n  }\r\n\r\n  std::sort(pairs.begin(), pairs.end());\r\n\r\n  std::cout << std::endl;\r\n\r\n  // read classes\r\n  std::ifstream file(FLAGS_classes);\r\n  std::string temp;\r\n  std::vector<std::string> classes;\r\n  while (std::getline(file, temp)) {\r\n    classes.push_back(temp);\r\n  }\r\n\r\n  // show results\r\n  std::cout << \"output: \" << std::endl;\r\n  for (auto pair : pairs) {\r\n    std::cout << \"  \" << pair.first << \"% '\" << classes[pair.second] << \"' (\"\r\n              << pair.second << \")\" << std::endl;\r\n  }\r\n}\r\n\r\n}  // namespace caffe2\r\n`\r\nthe error is \r\nterminate called after throwing an instance of 'caffe2::EnforceNotMet'\r\n  what():  [enforce fail at operator.cc:42] blob != nullptr. op Conv: Encountered a non-existing input blob: 0 \r\n\r\nanyone help me ?"}