{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/153082490", "pull_request_review_id": 79038620, "id": 153082490, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1MzA4MjQ5MA==", "diff_hunk": "@@ -382,6 +384,94 @@ struct GraphFuser {\n     return ++consumer->reverseIterator();\n   }\n \n+  // This is a hack to improve the fusion in case the graph looks like this:\n+  //\n+  // %1 = f(...)\n+  // %2 = g(%1)\n+  // %3 = h(%1)\n+  // %4 = l(%3)\n+  // return %4, %2\n+  //\n+  // where f, g, h, l are fusable operations\n+  //\n+  // If you follow the algorithm, you'll see that we will end up with a group\n+  // that fuses 3 and 4, and another one that fuses 2 and 1. This function will\n+  // connect them into a single group.\n+  void mergeNeighbouringFusionGroups() {", "path": "torch/csrc/jit/passes/graph_fuser.cpp", "position": null, "original_position": 26, "commit_id": "7722a1ba1904143ca9ab971f39c59282e59b7b87", "original_commit_id": "a62b882d3c6f762efb7dc8edf48f8a425962f5c9", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "body": "I don't think that the main path ignores FusionGroup <-> FusionGroup - it just can't happen. We always iterate from nodes of higher topological index, and fusion groups have the index equal to max of nodes they fuse. This means that once we finish fusing things into group X, all other nodes considered as consumers will have topological numbers strictly less than X, and you will never find X in their inputs, so there's no way to even consider this possibility.\r\n\r\nThe only way we could do it would be to run the fusing pass multiple times, until it makes no changes to the graph. This is an alternative that I thought about, but decided that this is simpler. However, as you said, now that the code is there it shouldn't be too hard, so I can do it.\r\n\r\nYeah, that works too. Checking the more relaxed condition shouldn't be too computationally expensive, because you limit yourself to this particular topological range (I think it's n^2 worst case, but that will almost never happen in real graphs). But this could be also relaxed in the main path, so we can just consider doing it later.", "created_at": "2017-11-26T21:32:48Z", "updated_at": "2018-11-23T15:36:48Z", "html_url": "https://github.com/pytorch/pytorch/pull/3885#discussion_r153082490", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/3885", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/153082490"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/3885#discussion_r153082490"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/3885"}}, "body_html": "<p>I don't think that the main path ignores FusionGroup &lt;-&gt; FusionGroup - it just can't happen. We always iterate from nodes of higher topological index, and fusion groups have the index equal to max of nodes they fuse. This means that once we finish fusing things into group X, all other nodes considered as consumers will have topological numbers strictly less than X, and you will never find X in their inputs, so there's no way to even consider this possibility.</p>\n<p>The only way we could do it would be to run the fusing pass multiple times, until it makes no changes to the graph. This is an alternative that I thought about, but decided that this is simpler. However, as you said, now that the code is there it shouldn't be too hard, so I can do it.</p>\n<p>Yeah, that works too. Checking the more relaxed condition shouldn't be too computationally expensive, because you limit yourself to this particular topological range (I think it's n^2 worst case, but that will almost never happen in real graphs). But this could be also relaxed in the main path, so we can just consider doing it later.</p>", "body_text": "I don't think that the main path ignores FusionGroup <-> FusionGroup - it just can't happen. We always iterate from nodes of higher topological index, and fusion groups have the index equal to max of nodes they fuse. This means that once we finish fusing things into group X, all other nodes considered as consumers will have topological numbers strictly less than X, and you will never find X in their inputs, so there's no way to even consider this possibility.\nThe only way we could do it would be to run the fusing pass multiple times, until it makes no changes to the graph. This is an alternative that I thought about, but decided that this is simpler. However, as you said, now that the code is there it shouldn't be too hard, so I can do it.\nYeah, that works too. Checking the more relaxed condition shouldn't be too computationally expensive, because you limit yourself to this particular topological range (I think it's n^2 worst case, but that will almost never happen in real graphs). But this could be also relaxed in the main path, so we can just consider doing it later.", "in_reply_to_id": 153081720}