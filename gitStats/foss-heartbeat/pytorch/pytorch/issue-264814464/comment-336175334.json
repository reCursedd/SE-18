{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/336175334", "html_url": "https://github.com/pytorch/pytorch/pull/3084#issuecomment-336175334", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/3084", "id": 336175334, "node_id": "MDEyOklzc3VlQ29tbWVudDMzNjE3NTMzNA==", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "created_at": "2017-10-12T15:34:15Z", "updated_at": "2017-10-12T15:34:15Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=30275821\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/houseroad\">@houseroad</a>: <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=4583066\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/apaszke\">@apaszke</a> made a comment that made me realize that we might not have to do too much work to support scalar export, even though the PyTorch Python API doesn't support it.</p>\n<p>The key observation is that Attributes hold an ATen tensor: <a href=\"https://github.com/pytorch/pytorch/blob/master/torch/csrc/jit/attributes.h#L72\">https://github.com/pytorch/pytorch/blob/master/torch/csrc/jit/attributes.h#L72</a> which DOES support zero-dim one-elem tensors. <a href=\"https://github.com/zdevito/ATen#scalars-and-zero-dimensional-tensors\">https://github.com/zdevito/ATen#scalars-and-zero-dimensional-tensors</a></p>\n<p>So all you need to do is add an alternate Python binding for <code>t</code> (and <code>ts</code>, if you're feeling frisky) which bypasses the Python tensor to ATen conversion and just constructs the correct ATen tensor directly. I'd probably recommend making a straight up new method at <a href=\"https://github.com/pytorch/pytorch/blob/master/torch/csrc/jit/python_ir.cpp#L105\">https://github.com/pytorch/pytorch/blob/master/torch/csrc/jit/python_ir.cpp#L105</a> which still takes an ATen 1-dim 1-elem tensor (otherwise you have to make a binding for int/float/etc) and turns it into a 0-dim 1-elem tensor.</p>\n<p>Maybe something like:</p>\n<pre><code>    def(\"scalar_\",[](Node &amp; n, const char * name, at::Tensor v) {\n      return n.t_(stringToSymbol(name), std::move(v.view({})));\n    })\n</code></pre>\n<p>(I am not a hundred percent sure <code>v.view({})</code> works.)</p>", "body_text": "@houseroad: @apaszke made a comment that made me realize that we might not have to do too much work to support scalar export, even though the PyTorch Python API doesn't support it.\nThe key observation is that Attributes hold an ATen tensor: https://github.com/pytorch/pytorch/blob/master/torch/csrc/jit/attributes.h#L72 which DOES support zero-dim one-elem tensors. https://github.com/zdevito/ATen#scalars-and-zero-dimensional-tensors\nSo all you need to do is add an alternate Python binding for t (and ts, if you're feeling frisky) which bypasses the Python tensor to ATen conversion and just constructs the correct ATen tensor directly. I'd probably recommend making a straight up new method at https://github.com/pytorch/pytorch/blob/master/torch/csrc/jit/python_ir.cpp#L105 which still takes an ATen 1-dim 1-elem tensor (otherwise you have to make a binding for int/float/etc) and turns it into a 0-dim 1-elem tensor.\nMaybe something like:\n    def(\"scalar_\",[](Node & n, const char * name, at::Tensor v) {\n      return n.t_(stringToSymbol(name), std::move(v.view({})));\n    })\n\n(I am not a hundred percent sure v.view({}) works.)", "body": "@houseroad: @apaszke made a comment that made me realize that we might not have to do too much work to support scalar export, even though the PyTorch Python API doesn't support it.\r\n\r\nThe key observation is that Attributes hold an ATen tensor: https://github.com/pytorch/pytorch/blob/master/torch/csrc/jit/attributes.h#L72 which DOES support zero-dim one-elem tensors. https://github.com/zdevito/ATen#scalars-and-zero-dimensional-tensors\r\n\r\nSo all you need to do is add an alternate Python binding for `t` (and `ts`, if you're feeling frisky) which bypasses the Python tensor to ATen conversion and just constructs the correct ATen tensor directly. I'd probably recommend making a straight up new method at https://github.com/pytorch/pytorch/blob/master/torch/csrc/jit/python_ir.cpp#L105 which still takes an ATen 1-dim 1-elem tensor (otherwise you have to make a binding for int/float/etc) and turns it into a 0-dim 1-elem tensor.\r\n\r\nMaybe something like:\r\n\r\n```\r\n    def(\"scalar_\",[](Node & n, const char * name, at::Tensor v) {\r\n      return n.t_(stringToSymbol(name), std::move(v.view({})));\r\n    })\r\n```\r\n\r\n(I am not a hundred percent sure `v.view({})` works.)"}