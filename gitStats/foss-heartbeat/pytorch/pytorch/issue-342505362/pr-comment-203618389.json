{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/203618389", "pull_request_review_id": 138540116, "id": 203618389, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMzYxODM4OQ==", "diff_hunk": "@@ -227,11 +227,37 @@ using OperatorMap = std::unordered_map<Symbol, std::vector<std::shared_ptr<Opera\n struct OperatorRegistry  {\n   OperatorMap operators;\n   std::mutex lock;\n+  // TODO: comment\n+  std::unordered_map<std::string, std::shared_ptr<Operator>> operators_by_sig;\n+  std::unordered_map<const char *, std::shared_ptr<Operator>> operators_by_sig_literal;", "path": "torch/csrc/jit/operator.cpp", "position": null, "original_position": 6, "commit_id": "ef15a232d7a091f02f20bd5632d19583286e3ba3", "original_commit_id": "ee9c00190a2d077295ccea0e1ff0c1100ec59b7d", "user": {"login": "zdevito", "id": 370202, "node_id": "MDQ6VXNlcjM3MDIwMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/370202?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zdevito", "html_url": "https://github.com/zdevito", "followers_url": "https://api.github.com/users/zdevito/followers", "following_url": "https://api.github.com/users/zdevito/following{/other_user}", "gists_url": "https://api.github.com/users/zdevito/gists{/gist_id}", "starred_url": "https://api.github.com/users/zdevito/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zdevito/subscriptions", "organizations_url": "https://api.github.com/users/zdevito/orgs", "repos_url": "https://api.github.com/users/zdevito/repos", "events_url": "https://api.github.com/users/zdevito/events{/privacy}", "received_events_url": "https://api.github.com/users/zdevito/received_events", "type": "User", "site_admin": false}, "body": "This means that you have to get everything, including whitespace, exactly right if you want an operator to match. I guess this is alright, but it will lead to some difficult-to-find errors when debugging match statements. It would be better if we defined an equality operator on function schema, parsed each string literal the first time we saw it, and then used FunctionSchema equality to find the registered operator. This would fix the default-value print issues, and also enable other match possibilities in the future like marking inputs const inline:\r\n```\r\nnode->matches(\"add(Tensor a, const Scalar b) -> Tensor\")\r\n```", "created_at": "2018-07-19T06:54:38Z", "updated_at": "2018-11-23T15:47:41Z", "html_url": "https://github.com/pytorch/pytorch/pull/9567#discussion_r203618389", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/9567", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/203618389"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/9567#discussion_r203618389"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/9567"}}, "body_html": "<p>This means that you have to get everything, including whitespace, exactly right if you want an operator to match. I guess this is alright, but it will lead to some difficult-to-find errors when debugging match statements. It would be better if we defined an equality operator on function schema, parsed each string literal the first time we saw it, and then used FunctionSchema equality to find the registered operator. This would fix the default-value print issues, and also enable other match possibilities in the future like marking inputs const inline:</p>\n<pre><code>node-&gt;matches(\"add(Tensor a, const Scalar b) -&gt; Tensor\")\n</code></pre>", "body_text": "This means that you have to get everything, including whitespace, exactly right if you want an operator to match. I guess this is alright, but it will lead to some difficult-to-find errors when debugging match statements. It would be better if we defined an equality operator on function schema, parsed each string literal the first time we saw it, and then used FunctionSchema equality to find the registered operator. This would fix the default-value print issues, and also enable other match possibilities in the future like marking inputs const inline:\nnode->matches(\"add(Tensor a, const Scalar b) -> Tensor\")"}