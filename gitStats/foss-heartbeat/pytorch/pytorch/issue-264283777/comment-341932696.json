{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/341932696", "html_url": "https://github.com/pytorch/pytorch/issues/3050#issuecomment-341932696", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/3050", "id": 341932696, "node_id": "MDEyOklzc3VlQ29tbWVudDM0MTkzMjY5Ng==", "user": {"login": "obilaniu", "id": 3268344, "node_id": "MDQ6VXNlcjMyNjgzNDQ=", "avatar_url": "https://avatars3.githubusercontent.com/u/3268344?v=4", "gravatar_id": "", "url": "https://api.github.com/users/obilaniu", "html_url": "https://github.com/obilaniu", "followers_url": "https://api.github.com/users/obilaniu/followers", "following_url": "https://api.github.com/users/obilaniu/following{/other_user}", "gists_url": "https://api.github.com/users/obilaniu/gists{/gist_id}", "starred_url": "https://api.github.com/users/obilaniu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/obilaniu/subscriptions", "organizations_url": "https://api.github.com/users/obilaniu/orgs", "repos_url": "https://api.github.com/users/obilaniu/repos", "events_url": "https://api.github.com/users/obilaniu/events{/privacy}", "received_events_url": "https://api.github.com/users/obilaniu/received_events", "type": "User", "site_admin": false}, "created_at": "2017-11-04T21:57:54Z", "updated_at": "2017-11-04T22:01:46Z", "author_association": "NONE", "body_html": "<p>Gentlemen and gentlewomen, <a href=\"https://github.com/pytorch/pytorch/commit/502aaf39cf4a878f9e4f849e5f409573aa598aa9\">this commit</a> from PR <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"270835760\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/3456\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/pytorch/pytorch/pull/3456/hovercard\" href=\"https://github.com/pytorch/pytorch/pull/3456\">#3456</a> breaks GCC 4.9. In the <code>stdatomic.h</code> header that ships with GCC 4.9, <code>ATOMIC_INT_LOCK_FREE</code> is implemented with compiler builtins and <code>?:</code>, causing the preprocessor to vomit a cryptic message</p>\n<pre><code>In file included from /PATH/TO/pytorch/aten/src/TH/THAllocator.c:8:0:\nPATH/TO/pytorch/aten/src/TH/THAllocator.c:9:5: error: missing binary operator before token \"(\"\n#if ATOMIC_INT_LOCK_FREE == 2\n    ^\n</code></pre>\n<p>because the expansion of <code>ATOMIC_INT_LOCK_FREE</code> eventually reaches</p>\n<pre><code>#define __atomic_type_lock_free(T) \\\n(__atomic_always_lock_free (sizeof (T), (void *) 0) \\\n? 2 \\\n: (__atomic_is_lock_free (sizeof (T), (void *) 0) ? 1 : 0))\n</code></pre>\n<p>with <code>T=atomic_int</code>, and since the preprocessor is unaware of compiler builtins it substitutes them with <code>0</code>, wherefore you see complaints about what effectively is the junk expression <code>#if 0(0(0)(0)....</code> that appears at first glance to be a math expression that is simply lacking in binary operations.</p>\n<p>The effective requirement for PyTorch is now GCC 5.3.0, where the <code>ATOMIC_x_LOCK_FREE</code> family was reimplemented in <code>stdatomic.h</code> in terms of preprocessor defines, whose values are numerically available to the preprocessor.</p>\n<p>Noteworthy is that G++ 4.9 is not affected, since that change happened in the C++ library 3 years earlier (2011) than for the C library (2014), and so was included in G++ 4.9.</p>", "body_text": "Gentlemen and gentlewomen, this commit from PR #3456 breaks GCC 4.9. In the stdatomic.h header that ships with GCC 4.9, ATOMIC_INT_LOCK_FREE is implemented with compiler builtins and ?:, causing the preprocessor to vomit a cryptic message\nIn file included from /PATH/TO/pytorch/aten/src/TH/THAllocator.c:8:0:\nPATH/TO/pytorch/aten/src/TH/THAllocator.c:9:5: error: missing binary operator before token \"(\"\n#if ATOMIC_INT_LOCK_FREE == 2\n    ^\n\nbecause the expansion of ATOMIC_INT_LOCK_FREE eventually reaches\n#define __atomic_type_lock_free(T) \\\n(__atomic_always_lock_free (sizeof (T), (void *) 0) \\\n? 2 \\\n: (__atomic_is_lock_free (sizeof (T), (void *) 0) ? 1 : 0))\n\nwith T=atomic_int, and since the preprocessor is unaware of compiler builtins it substitutes them with 0, wherefore you see complaints about what effectively is the junk expression #if 0(0(0)(0).... that appears at first glance to be a math expression that is simply lacking in binary operations.\nThe effective requirement for PyTorch is now GCC 5.3.0, where the ATOMIC_x_LOCK_FREE family was reimplemented in stdatomic.h in terms of preprocessor defines, whose values are numerically available to the preprocessor.\nNoteworthy is that G++ 4.9 is not affected, since that change happened in the C++ library 3 years earlier (2011) than for the C library (2014), and so was included in G++ 4.9.", "body": "Gentlemen and gentlewomen, [this commit](https://github.com/pytorch/pytorch/commit/502aaf39cf4a878f9e4f849e5f409573aa598aa9) from PR #3456 breaks GCC 4.9. In the `stdatomic.h` header that ships with GCC 4.9, `ATOMIC_INT_LOCK_FREE` is implemented with compiler builtins and `?:`, causing the preprocessor to vomit a cryptic message\r\n\r\n```\r\nIn file included from /PATH/TO/pytorch/aten/src/TH/THAllocator.c:8:0:\r\nPATH/TO/pytorch/aten/src/TH/THAllocator.c:9:5: error: missing binary operator before token \"(\"\r\n#if ATOMIC_INT_LOCK_FREE == 2\r\n    ^\r\n```\r\n\r\nbecause the expansion of `ATOMIC_INT_LOCK_FREE` eventually reaches\r\n\r\n```\r\n#define __atomic_type_lock_free(T) \\\r\n(__atomic_always_lock_free (sizeof (T), (void *) 0) \\\r\n? 2 \\\r\n: (__atomic_is_lock_free (sizeof (T), (void *) 0) ? 1 : 0))\r\n```\r\n\r\nwith `T=atomic_int`, and since the preprocessor is unaware of compiler builtins it substitutes them with `0`, wherefore you see complaints about what effectively is the junk expression `#if 0(0(0)(0)....` that appears at first glance to be a math expression that is simply lacking in binary operations.\r\n\r\nThe effective requirement for PyTorch is now GCC 5.3.0, where the `ATOMIC_x_LOCK_FREE` family was reimplemented in `stdatomic.h` in terms of preprocessor defines, whose values are numerically available to the preprocessor.\r\n\r\nNoteworthy is that G++ 4.9 is not affected, since that change happened in the C++ library 3 years earlier (2011) than for the C library (2014), and so was included in G++ 4.9."}