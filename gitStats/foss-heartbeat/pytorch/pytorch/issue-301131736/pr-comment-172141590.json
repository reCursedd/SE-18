{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/172141590", "pull_request_review_id": 101107606, "id": 172141590, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE3MjE0MTU5MA==", "diff_hunk": "@@ -8,3 +8,129 @@\n \n #include \"generic/serialization.cpp\"\n #include <TH/THGenerateHalfType.h>\n+\n+#include \"serialization.h\"\n+\n+ssize_t doPythonReadBuffered(PyObject* fildes, void* buf, size_t nbytes);\n+ssize_t doPythonReadInto(PyObject* fildes, void* buf, size_t nbytes);\n+ssize_t doPythonWrite(PyObject* fildes, void* buf, size_t nbytes);\n+\n+template <>\n+inline ssize_t doRead<int>(int fildes, void* buf, size_t nbytes) {\n+  return read(fildes, buf, nbytes);\n+}\n+\n+template <>\n+inline ssize_t doRead<PyObject*>(PyObject* fildes, void* buf, size_t nbytes) {\n+  // Try to use fildes.readinto() instead of fildes.read()\n+  // because it is more memory efficient.\n+  auto has_readinto = PyObject_HasAttrString(fildes, \"readinto\") == 1;\n+  if (has_readinto) {\n+    return doPythonReadInto(fildes, buf, nbytes);\n+  }\n+  return doPythonReadBuffered(fildes, buf, nbytes);\n+}\n+\n+template <>\n+inline ssize_t doWrite<int>(int fildes, void* buf, size_t nbytes) {\n+  return write(fildes, buf, nbytes);\n+}\n+\n+template <>\n+inline ssize_t doWrite<PyObject*>(PyObject* fildes, void* buf, size_t nbytes) {\n+  return doPythonWrite(fildes, buf, nbytes);\n+}\n+\n+static inline bool isUnsupportedOperation() {\n+  THPObjectPtr io(PyImport_ImportModule(\"io\"));\n+  if (!io) throw python_error();\n+  THPObjectPtr exception(PyObject_GetAttrString(io, \"UnsupportedOperation\"));\n+  if (!exception) python_error();\n+  return PyErr_ExceptionMatches(exception.get());\n+}\n+\n+// Call Python fildes.read(nbytes) and copy it to buf.\n+inline ssize_t doPythonReadBuffered(PyObject* fildes, void* buf, size_t nbytes) {\n+  const size_t buffer_size = 262144;  // 2^18\n+  size_t read_bytes = 0;\n+\n+  while (read_bytes < nbytes) {\n+    auto remaining = nbytes - read_bytes;\n+    auto to_read = remaining > buffer_size ? buffer_size : remaining;\n+    THPObjectPtr r(PyObject_CallMethod(fildes, \"read\", \"i\", to_read));\n+    if (!r) throw python_error();\n+\n+    // read output is String (Python 2) / Bytes (Python 3)\n+#if PY_MAJOR_VERSION >= 3\n+    auto size = PyBytes_GET_SIZE(r.get());\n+    const void* bytes = PyBytes_AsString(r.get());\n+#else\n+    auto size = PyString_GET_SIZE(r.get());\n+    const void* bytes = PyString_AsString(r.get());\n+#endif\n+\n+    // we read EOF\n+    if (size == 0) {\n+      return read_bytes;\n+    }\n+\n+    memcpy(reinterpret_cast<char*>(buf) + read_bytes, bytes, size);\n+    read_bytes += size;\n+  } // Reading loop\n+\n+  return read_bytes;\n+}\n+\n+// Either does fildes.readinto(buf) or fildes.write(buf)\n+static inline ssize_t doPythonIO(PyObject* fildes, void* buf, size_t nbytes, bool is_read) {\n+#if PY_MAJOR_VERSION >= 3\n+  auto rw_flag = is_read ? PyBUF_WRITE : PyBUF_READ;\n+  THPObjectPtr memview(PyMemoryView_FromMemory(\n+      reinterpret_cast<char*>(buf), nbytes, rw_flag));\n+#else\n+  // PyMemoryView_FromMemory doesn't exist in Python 2.7, so we manually\n+  // create a Py_buffer that describes the memory and create a memoryview from it.\n+  auto readonly_flag = is_read ? 1 : 0;\n+  Py_buffer pyBuf;\n+  pyBuf.buf = buf;\n+  pyBuf.obj = nullptr;\n+  pyBuf.len = (Py_ssize_t)nbytes;\n+  pyBuf.itemsize = 1;\n+  pyBuf.readonly = readonly_flag;\n+  pyBuf.ndim = 0;\n+  pyBuf.format = nullptr;\n+  pyBuf.shape = nullptr;\n+  pyBuf.strides = nullptr;\n+  pyBuf.suboffsets = nullptr;\n+  pyBuf.internal = nullptr;\n+\n+  THPObjectPtr memview(PyMemoryView_FromBuffer(&pyBuf));", "path": "torch/csrc/serialization.cpp", "position": null, "original_position": 100, "commit_id": "bdaf61fb52ecadc1e0f83be28ea738ad2635257d", "original_commit_id": "f00e98c068bee467fbdd233717d3cd2a9f8df509", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "body": "This part of the docs for `PyMemoryView_FromBuffer` is a bit worrying for me:\r\n> The memoryview object then owns the buffer, which means you shouldn\u2019t try to release it yourself: it will be released on deallocation of the memoryview object.\r\n\r\nWhy not use `PyBuffer_FromReadWriteMemory`?\r\n", "created_at": "2018-03-05T10:22:04Z", "updated_at": "2018-11-23T15:40:21Z", "html_url": "https://github.com/pytorch/pytorch/pull/5466#discussion_r172141590", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/5466", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/172141590"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/5466#discussion_r172141590"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/5466"}}, "body_html": "<p>This part of the docs for <code>PyMemoryView_FromBuffer</code> is a bit worrying for me:</p>\n<blockquote>\n<p>The memoryview object then owns the buffer, which means you shouldn\u2019t try to release it yourself: it will be released on deallocation of the memoryview object.</p>\n</blockquote>\n<p>Why not use <code>PyBuffer_FromReadWriteMemory</code>?</p>", "body_text": "This part of the docs for PyMemoryView_FromBuffer is a bit worrying for me:\n\nThe memoryview object then owns the buffer, which means you shouldn\u2019t try to release it yourself: it will be released on deallocation of the memoryview object.\n\nWhy not use PyBuffer_FromReadWriteMemory?"}