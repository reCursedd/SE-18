{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/171828969", "pull_request_review_id": 100750956, "id": 171828969, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE3MTgyODk2OQ==", "diff_hunk": "@@ -0,0 +1,98 @@\n+#pragma once\n+#include <Python.h>\n+\n+// Call Python fildes.read(nbytes) and copy it to buf.\n+// Requires a buffer for the bytes object returned from read\n+// so the reading is chunked.\n+inline ssize_t pyReadBuffered(PyObject* fildes, void* buf, size_t nbytes) {\n+  const size_t buffer_size = 262144;  // 2^18\n+  size_t read_bytes = 0;\n+\n+  while (read_bytes < nbytes) {\n+    auto remaining = nbytes - read_bytes;\n+    auto to_read = remaining > buffer_size ? buffer_size : remaining;\n+    THPObjectPtr r(PyObject_CallMethod(fildes, \"read\", \"i\", to_read));\n+    if (!r) throw python_error();\n+\n+    // read output is String (Python 2) / Bytes (Python 3)\n+#if PY_MAJOR_VERSION >= 3\n+    auto size = PyBytes_GET_SIZE(r.get());\n+    const void* bytes = PyBytes_AsString(r.get());\n+#else\n+    auto size = PyString_GET_SIZE(r.get());\n+    const void* bytes = PyString_AsString(r.get());\n+#endif\n+\n+    // we read EOF\n+    if (size == 0) {\n+      return read_bytes;\n+    }\n+\n+    memcpy(reinterpret_cast<char*>(buf) + read_bytes, bytes, size);\n+    read_bytes += size;\n+  } // Reading loop\n+\n+  return read_bytes;\n+}\n+\n+static inline bool isUnsupportedOperation() {\n+  THPObjectPtr io(PyImport_ImportModule(\"io\"));\n+  if (!io) throw python_error();\n+  THPObjectPtr exception(PyObject_GetAttrString(io, \"UnsupportedOperation\"));\n+  if (!exception) python_error();\n+  return PyErr_ExceptionMatches(exception.get());\n+}\n+\n+// Either does fildes.readinto(buf) or fildes.write(buf)\n+static inline ssize_t io(PyObject* fildes, void* buf, size_t nbytes, bool is_read) {\n+#if PY_MAJOR_VERSION >= 3\n+  auto rw_flag = is_read ? PyBUF_WRITE : PyBUF_READ;\n+  THPObjectPtr memview(PyMemoryView_FromMemory(\n+      reinterpret_cast<char*>(buf), nbytes, rw_flag));\n+#else\n+  // PyMemoryView_FromMemory doesn't exist in Python 2.7, so we manually\n+  // create a Py_buffer that describes the memory and create a memoryview from it.\n+  auto readonly_flag = is_read ? 1 : 0;\n+  Py_buffer pyBuf;\n+  pyBuf.buf = buf;\n+  pyBuf.obj = nullptr;\n+  pyBuf.len = (Py_ssize_t)nbytes;\n+  pyBuf.itemsize = 1;\n+  pyBuf.readonly = readonly_flag;\n+  pyBuf.ndim = 0;\n+  pyBuf.format = nullptr;\n+  pyBuf.shape = nullptr;\n+  pyBuf.strides = nullptr;\n+  pyBuf.suboffsets = nullptr;\n+  pyBuf.internal = nullptr;\n+\n+  THPObjectPtr memview(PyMemoryView_FromBuffer(&pyBuf));\n+#endif\n+  if (!memview) throw python_error();\n+\n+  char* method = \"write\";\n+  if (is_read) {\n+    method = \"readinto\";\n+  }\n+  THPObjectPtr r(PyObject_CallMethod(fildes, method, \"O\", memview.get()));\n+  if (r) {\n+    return PyLong_AsSsize_t(r.get());\n+  }\n+\n+  // fildes.readinto can return UnsupportedOperation so fall back to fildes.read.\n+  if (is_read && isUnsupportedOperation()) {\n+    PyErr_Clear();\n+    return pyReadBuffered(fildes, buf, nbytes);\n+  }\n+  throw python_error();\n+}\n+\n+// Call Python fildes.readinto(buf)\n+inline ssize_t pyReadInto(PyObject* fildes, void* buf, size_t nbytes) {\n+  return io(fildes, buf, nbytes, /* is_read */ true);\n+}\n+\n+// Call Python fildes.write(buf)\n+inline ssize_t pyWrite(PyObject* fildes, void* buf, size_t nbytes) {\n+  return io(fildes, buf, nbytes, /* is_read */ false);\n+}", "path": "torch/csrc/python_serialization.h", "position": null, "original_position": 98, "commit_id": "bdaf61fb52ecadc1e0f83be28ea738ad2635257d", "original_commit_id": "0eb62aec49604a82e89251d8fc6648e1269e1412", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "body": "It would be better to keep those functions + the actual implementations of `doRead` and `doWrite` from `serialization.h` in a `.cpp` file, only forward-declare the templates in the header, and explicitly instantiate them in the `.cpp` file", "created_at": "2018-03-02T11:52:07Z", "updated_at": "2018-11-23T15:40:16Z", "html_url": "https://github.com/pytorch/pytorch/pull/5466#discussion_r171828969", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/5466", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/171828969"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/5466#discussion_r171828969"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/5466"}}, "body_html": "<p>It would be better to keep those functions + the actual implementations of <code>doRead</code> and <code>doWrite</code> from <code>serialization.h</code> in a <code>.cpp</code> file, only forward-declare the templates in the header, and explicitly instantiate them in the <code>.cpp</code> file</p>", "body_text": "It would be better to keep those functions + the actual implementations of doRead and doWrite from serialization.h in a .cpp file, only forward-declare the templates in the header, and explicitly instantiate them in the .cpp file"}