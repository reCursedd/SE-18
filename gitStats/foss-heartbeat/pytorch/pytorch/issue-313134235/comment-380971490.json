{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/380971490", "html_url": "https://github.com/pytorch/pytorch/pull/6492#issuecomment-380971490", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/6492", "id": 380971490, "node_id": "MDEyOklzc3VlQ29tbWVudDM4MDk3MTQ5MA==", "user": {"login": "zdevito", "id": 370202, "node_id": "MDQ6VXNlcjM3MDIwMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/370202?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zdevito", "html_url": "https://github.com/zdevito", "followers_url": "https://api.github.com/users/zdevito/followers", "following_url": "https://api.github.com/users/zdevito/following{/other_user}", "gists_url": "https://api.github.com/users/zdevito/gists{/gist_id}", "starred_url": "https://api.github.com/users/zdevito/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zdevito/subscriptions", "organizations_url": "https://api.github.com/users/zdevito/orgs", "repos_url": "https://api.github.com/users/zdevito/repos", "events_url": "https://api.github.com/users/zdevito/events{/privacy}", "received_events_url": "https://api.github.com/users/zdevito/received_events", "type": "User", "site_admin": false}, "created_at": "2018-04-12T23:10:03Z", "updated_at": "2018-04-12T23:10:03Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Semantics of n_binders (I will add this to the tuple unpack commit PR as a comment):</p>\n<p><code>n_binders</code> is always set to the number of variables an expression is syntactically bound to:</p>\n<pre><code>a = foo() # 1 binder (note in this case the single binder might be a tuple)\na, * b = foo() # 1 binder\na, b = foo() # 2 binders\nfoo() # 0 binders\n</code></pre>\n<p>In subexpressions, like <code>bar()</code> in <code>foo(bar())</code>,  <code>n_binders</code> is always set to 1. <code>n_binders</code> is used as a hint to subexpressions to determine how many values they should return when that number is ambiguous statically. In particular it is currently used to decide how many tensors a call to a python function will return. It is only a hint, functions do not have to check that <code>n_binders</code> match the number of things they are returning, the assignment logic will do that anyway.</p>", "body_text": "Semantics of n_binders (I will add this to the tuple unpack commit PR as a comment):\nn_binders is always set to the number of variables an expression is syntactically bound to:\na = foo() # 1 binder (note in this case the single binder might be a tuple)\na, * b = foo() # 1 binder\na, b = foo() # 2 binders\nfoo() # 0 binders\n\nIn subexpressions, like bar() in foo(bar()),  n_binders is always set to 1. n_binders is used as a hint to subexpressions to determine how many values they should return when that number is ambiguous statically. In particular it is currently used to decide how many tensors a call to a python function will return. It is only a hint, functions do not have to check that n_binders match the number of things they are returning, the assignment logic will do that anyway.", "body": "Semantics of n_binders (I will add this to the tuple unpack commit PR as a comment):\r\n\r\n`n_binders` is always set to the number of variables an expression is syntactically bound to:\r\n```\r\na = foo() # 1 binder (note in this case the single binder might be a tuple)\r\na, * b = foo() # 1 binder\r\na, b = foo() # 2 binders\r\nfoo() # 0 binders\r\n```\r\nIn subexpressions, like `bar()` in `foo(bar())`,  `n_binders` is always set to 1. `n_binders` is used as a hint to subexpressions to determine how many values they should return when that number is ambiguous statically. In particular it is currently used to decide how many tensors a call to a python function will return. It is only a hint, functions do not have to check that `n_binders` match the number of things they are returning, the assignment logic will do that anyway.\r\n\r\n"}