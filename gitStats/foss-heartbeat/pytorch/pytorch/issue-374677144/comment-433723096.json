{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/433723096", "html_url": "https://github.com/pytorch/pytorch/pull/13213#issuecomment-433723096", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/13213", "id": 433723096, "node_id": "MDEyOklzc3VlQ29tbWVudDQzMzcyMzA5Ng==", "user": {"login": "jma127", "id": 2780434, "node_id": "MDQ6VXNlcjI3ODA0MzQ=", "avatar_url": "https://avatars2.githubusercontent.com/u/2780434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jma127", "html_url": "https://github.com/jma127", "followers_url": "https://api.github.com/users/jma127/followers", "following_url": "https://api.github.com/users/jma127/following{/other_user}", "gists_url": "https://api.github.com/users/jma127/gists{/gist_id}", "starred_url": "https://api.github.com/users/jma127/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jma127/subscriptions", "organizations_url": "https://api.github.com/users/jma127/orgs", "repos_url": "https://api.github.com/users/jma127/repos", "events_url": "https://api.github.com/users/jma127/events{/privacy}", "received_events_url": "https://api.github.com/users/jma127/received_events", "type": "User", "site_admin": false}, "created_at": "2018-10-28T17:07:25Z", "updated_at": "2018-10-28T17:07:25Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Got it <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=4583066\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/apaszke\">@apaszke</a> .</p>\n<p>This does provide implementations of the algorithms above, in a strictly more efficient manner (save for NAdam, which has equal efficiency).</p>\n<p>Suppose that we were instead to individually implement multiple of the above algorithms in PyTorch (I would surmise that algos 2-6 are candidates under the criteria you mentioned -- and there exists a <a href=\"https://github.com/pytorch/pytorch/pull/5804\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/pytorch/pytorch/pull/5804/hovercard\">dormant PR</a> for 6). Would we write each of them in separate classes, using the respective original (less efficient and less accessible) implementations? To get a sense of the difference, compare lines 85-88 of qhm.py with lines 58-65 of <a href=\"https://github.com/rahulkidambi/AccSGD/blob/master/AccSGD.py\">AccSGD.py</a>.</p>\n<p>It seems to me that it's preferable to provide the single (well, times two) efficient and expressive method simply for this reason, irrespective of publication date or any direct usage of that method.</p>\n<p>Happy to keep them in contrib or a separate repository, just wanted to make the above point to inform that decision.</p>\n<p>Another option is to add the functionality for QHM to SGD, and for QHAdam to Adam. This was done with the <code>amsgrad</code> flag in Adam, well before the publication of that paper.</p>\n<p>cc <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=1310570\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/soumith\">@soumith</a> for input as well.</p>", "body_text": "Got it @apaszke .\nThis does provide implementations of the algorithms above, in a strictly more efficient manner (save for NAdam, which has equal efficiency).\nSuppose that we were instead to individually implement multiple of the above algorithms in PyTorch (I would surmise that algos 2-6 are candidates under the criteria you mentioned -- and there exists a dormant PR for 6). Would we write each of them in separate classes, using the respective original (less efficient and less accessible) implementations? To get a sense of the difference, compare lines 85-88 of qhm.py with lines 58-65 of AccSGD.py.\nIt seems to me that it's preferable to provide the single (well, times two) efficient and expressive method simply for this reason, irrespective of publication date or any direct usage of that method.\nHappy to keep them in contrib or a separate repository, just wanted to make the above point to inform that decision.\nAnother option is to add the functionality for QHM to SGD, and for QHAdam to Adam. This was done with the amsgrad flag in Adam, well before the publication of that paper.\ncc @soumith for input as well.", "body": "Got it @apaszke .\r\n\r\nThis does provide implementations of the algorithms above, in a strictly more efficient manner (save for NAdam, which has equal efficiency).\r\n\r\nSuppose that we were instead to individually implement multiple of the above algorithms in PyTorch (I would surmise that algos 2-6 are candidates under the criteria you mentioned -- and there exists a [dormant PR](https://github.com/pytorch/pytorch/pull/5804) for 6). Would we write each of them in separate classes, using the respective original (less efficient and less accessible) implementations? To get a sense of the difference, compare lines 85-88 of qhm.py with lines 58-65 of [AccSGD.py](https://github.com/rahulkidambi/AccSGD/blob/master/AccSGD.py).\r\n\r\nIt seems to me that it's preferable to provide the single (well, times two) efficient and expressive method simply for this reason, irrespective of publication date or any direct usage of that method.\r\n\r\nHappy to keep them in contrib or a separate repository, just wanted to make the above point to inform that decision.\r\n\r\nAnother option is to add the functionality for QHM to SGD, and for QHAdam to Adam. This was done with the ``amsgrad`` flag in Adam, well before the publication of that paper.\r\n\r\ncc @soumith for input as well."}