{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/255407094", "html_url": "https://github.com/pytorch/pytorch/issues/140#issuecomment-255407094", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/140", "id": 255407094, "node_id": "MDEyOklzc3VlQ29tbWVudDI1NTQwNzA5NA==", "user": {"login": "fmassa", "id": 9110200, "node_id": "MDQ6VXNlcjkxMTAyMDA=", "avatar_url": "https://avatars2.githubusercontent.com/u/9110200?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fmassa", "html_url": "https://github.com/fmassa", "followers_url": "https://api.github.com/users/fmassa/followers", "following_url": "https://api.github.com/users/fmassa/following{/other_user}", "gists_url": "https://api.github.com/users/fmassa/gists{/gist_id}", "starred_url": "https://api.github.com/users/fmassa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fmassa/subscriptions", "organizations_url": "https://api.github.com/users/fmassa/orgs", "repos_url": "https://api.github.com/users/fmassa/repos", "events_url": "https://api.github.com/users/fmassa/events{/privacy}", "received_events_url": "https://api.github.com/users/fmassa/received_events", "type": "User", "site_admin": false}, "created_at": "2016-10-21T15:23:56Z", "updated_at": "2016-10-21T15:23:56Z", "author_association": "MEMBER", "body_html": "<p>One thing to have in mind, if we only add the narrow thing I mentioned, some more special treatment will need to be added if we want to do something like</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">import</span> torch\n<span class=\"pl-k\">from</span> torch.autograd <span class=\"pl-k\">import</span> Variable\n\nx <span class=\"pl-k\">=</span> Variable(torch.Tensor([<span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">2</span>, <span class=\"pl-c1\">3</span>]), <span class=\"pl-v\">requires_grad</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">True</span>)\ny <span class=\"pl-k\">=</span> Variable(torch.Tensor([<span class=\"pl-c1\">2</span>, <span class=\"pl-c1\">3</span>, <span class=\"pl-c1\">4</span>]), <span class=\"pl-v\">requires_grad</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">True</span>)\nx[<span class=\"pl-c1\">0</span>] <span class=\"pl-k\">=</span> y[<span class=\"pl-c1\">1</span>] <span class=\"pl-c\"><span class=\"pl-c\">#</span> this would error out with narrows</span>\nx[y[<span class=\"pl-c1\">0</span>]] <span class=\"pl-k\">=</span> <span class=\"pl-c1\">1</span> <span class=\"pl-c\"><span class=\"pl-c\">#</span> error as well, but less common</span></pre></div>\n<p>The issue first issue would be that we pass a 1D tensor as the filling value to the <code>fill</code> function (instead of a number).<br>\nThe second one would be that we would be passing a 1D tensor as argument of the index (or narrow) function instead of a number as well.</p>\n<p>Getting the number back from the tensor would be a sync point on the GPU (as is already the case btw), and might make the code pretty ugly with lots of checks here and there asserting for 1d tensors that are supposed to be numbers.</p>\n<p>I think this is a corner case though, as maybe not many people will be changing single elements of the tensors (would be slow!).</p>", "body_text": "One thing to have in mind, if we only add the narrow thing I mentioned, some more special treatment will need to be added if we want to do something like\nimport torch\nfrom torch.autograd import Variable\n\nx = Variable(torch.Tensor([1, 2, 3]), requires_grad=True)\ny = Variable(torch.Tensor([2, 3, 4]), requires_grad=True)\nx[0] = y[1] # this would error out with narrows\nx[y[0]] = 1 # error as well, but less common\nThe issue first issue would be that we pass a 1D tensor as the filling value to the fill function (instead of a number).\nThe second one would be that we would be passing a 1D tensor as argument of the index (or narrow) function instead of a number as well.\nGetting the number back from the tensor would be a sync point on the GPU (as is already the case btw), and might make the code pretty ugly with lots of checks here and there asserting for 1d tensors that are supposed to be numbers.\nI think this is a corner case though, as maybe not many people will be changing single elements of the tensors (would be slow!).", "body": "One thing to have in mind, if we only add the narrow thing I mentioned, some more special treatment will need to be added if we want to do something like\n\n``` python\nimport torch\nfrom torch.autograd import Variable\n\nx = Variable(torch.Tensor([1, 2, 3]), requires_grad=True)\ny = Variable(torch.Tensor([2, 3, 4]), requires_grad=True)\nx[0] = y[1] # this would error out with narrows\nx[y[0]] = 1 # error as well, but less common\n```\n\nThe issue first issue would be that we pass a 1D tensor as the filling value to the `fill` function (instead of a number).\nThe second one would be that we would be passing a 1D tensor as argument of the index (or narrow) function instead of a number as well.\n\nGetting the number back from the tensor would be a sync point on the GPU (as is already the case btw), and might make the code pretty ugly with lots of checks here and there asserting for 1d tensors that are supposed to be numbers.\n\nI think this is a corner case though, as maybe not many people will be changing single elements of the tensors (would be slow!).\n"}