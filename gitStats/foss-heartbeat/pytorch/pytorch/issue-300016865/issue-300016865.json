{"url": "https://api.github.com/repos/pytorch/pytorch/issues/5403", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/5403/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/5403/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/5403/events", "html_url": "https://github.com/pytorch/pytorch/issues/5403", "id": 300016865, "node_id": "MDU6SXNzdWUzMDAwMTY4NjU=", "number": 5403, "title": "How to Detach specific components in the loss?", "user": {"login": "ankitvad", "id": 3066071, "node_id": "MDQ6VXNlcjMwNjYwNzE=", "avatar_url": "https://avatars3.githubusercontent.com/u/3066071?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ankitvad", "html_url": "https://github.com/ankitvad", "followers_url": "https://api.github.com/users/ankitvad/followers", "following_url": "https://api.github.com/users/ankitvad/following{/other_user}", "gists_url": "https://api.github.com/users/ankitvad/gists{/gist_id}", "starred_url": "https://api.github.com/users/ankitvad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ankitvad/subscriptions", "organizations_url": "https://api.github.com/users/ankitvad/orgs", "repos_url": "https://api.github.com/users/ankitvad/repos", "events_url": "https://api.github.com/users/ankitvad/events{/privacy}", "received_events_url": "https://api.github.com/users/ankitvad/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2018-02-25T11:02:36Z", "updated_at": "2018-02-25T16:24:47Z", "closed_at": "2018-02-25T16:24:47Z", "author_association": "NONE", "body_html": "<p>I'm a little confused how to detach certain model from the loss computation graph.<br>\nIf I have 3 models that generate an output: <code>A</code>,  <code>B</code> and <code>C</code>, given an input.<br>\nAnd, 3  optimizers for those 3 models: <code>Oa</code>, <code>Ob</code> and <code>Oc</code>, for A, B and C resp.<br>\nLet's assume I have an initial input <code>x</code>.<br>\nI also have 3 losses <code>L1</code>, <code>L2</code> and <code>L3</code>.</p>\n<p>Let's assume a scenario where the system does <code>L2</code> that calculates <code>B(A(x))</code>, amongst other things.</p>\n<p>If we want a loss to optimize only certain models. eg. If we want to optimize only <code>B</code> we can do it 2 ways:</p>\n<pre><code>1)\nop = A(x)\nop2 = B(op.detach())\ncost = L2(op2, ground_truth)\ncost.backward()\nOb.step()\n#This would only backprop. gradients and optimize B.\n\n2)\nop = A(x)\nop2 = B(op)\ncost = L2(op2, ground_truth)\ncost.backward()\nOb.step()\n#This would backprop. loss to both A and B, \n#but it doesn't matter because we are just doing Ob.step()\n</code></pre>\n<p>Now in this if we wanted to optimize <code>A</code> for <code>B(A(x))</code> we can't do <code>(1)</code> we can do <code>(2)</code>.</p>\n<pre><code>op = A(x)\nop2 = B(op)\ncost = L2(op2, ground_truth)\ncost.backward()\nOa.step()\n#Here gradients are calculated for both `A` and `B`, but it doesn't matter because we are\n#just optimizing A with Oa.\n</code></pre>\n<p>I have understood this but let's say that:<br>\nnetLoss = L1 + L2 + L3<br>\nIn this I have the second case above. L2 has both A and B in the computation graph and we only want to optimize A with respect to L2. The problem is that we want to do netLoss.backward() and L1 + L2 + L3 contains A, B and C in them total.</p>\n<p>So after netLoss.backward() we have to do:<br>\nOa.step()<br>\nOb.step()<br>\nOc.step()</p>\n<p>So, <code>Ob</code> will take gradients from L2 as well, and form the other losses that has it also. Is there some way to do netLoss.backward() when we can exclude certain models from the graph? Eg. in (2) above where we want to update only <code>A</code> in B(A(x)).</p>", "body_text": "I'm a little confused how to detach certain model from the loss computation graph.\nIf I have 3 models that generate an output: A,  B and C, given an input.\nAnd, 3  optimizers for those 3 models: Oa, Ob and Oc, for A, B and C resp.\nLet's assume I have an initial input x.\nI also have 3 losses L1, L2 and L3.\nLet's assume a scenario where the system does L2 that calculates B(A(x)), amongst other things.\nIf we want a loss to optimize only certain models. eg. If we want to optimize only B we can do it 2 ways:\n1)\nop = A(x)\nop2 = B(op.detach())\ncost = L2(op2, ground_truth)\ncost.backward()\nOb.step()\n#This would only backprop. gradients and optimize B.\n\n2)\nop = A(x)\nop2 = B(op)\ncost = L2(op2, ground_truth)\ncost.backward()\nOb.step()\n#This would backprop. loss to both A and B, \n#but it doesn't matter because we are just doing Ob.step()\n\nNow in this if we wanted to optimize A for B(A(x)) we can't do (1) we can do (2).\nop = A(x)\nop2 = B(op)\ncost = L2(op2, ground_truth)\ncost.backward()\nOa.step()\n#Here gradients are calculated for both `A` and `B`, but it doesn't matter because we are\n#just optimizing A with Oa.\n\nI have understood this but let's say that:\nnetLoss = L1 + L2 + L3\nIn this I have the second case above. L2 has both A and B in the computation graph and we only want to optimize A with respect to L2. The problem is that we want to do netLoss.backward() and L1 + L2 + L3 contains A, B and C in them total.\nSo after netLoss.backward() we have to do:\nOa.step()\nOb.step()\nOc.step()\nSo, Ob will take gradients from L2 as well, and form the other losses that has it also. Is there some way to do netLoss.backward() when we can exclude certain models from the graph? Eg. in (2) above where we want to update only A in B(A(x)).", "body": "I'm a little confused how to detach certain model from the loss computation graph.\r\nIf I have 3 models that generate an output: `A`,  `B` and `C`, given an input.\r\nAnd, 3  optimizers for those 3 models: `Oa`, `Ob` and `Oc`, for A, B and C resp.\r\nLet's assume I have an initial input `x`.\r\nI also have 3 losses `L1`, `L2` and `L3`.\r\n\r\nLet's assume a scenario where the system does `L2` that calculates `B(A(x))`, amongst other things.\r\n\r\nIf we want a loss to optimize only certain models. eg. If we want to optimize only `B` we can do it 2 ways:\r\n```\r\n1)\r\nop = A(x)\r\nop2 = B(op.detach())\r\ncost = L2(op2, ground_truth)\r\ncost.backward()\r\nOb.step()\r\n#This would only backprop. gradients and optimize B.\r\n\r\n2)\r\nop = A(x)\r\nop2 = B(op)\r\ncost = L2(op2, ground_truth)\r\ncost.backward()\r\nOb.step()\r\n#This would backprop. loss to both A and B, \r\n#but it doesn't matter because we are just doing Ob.step()\r\n```\r\n\r\nNow in this if we wanted to optimize `A` for `B(A(x))` we can't do `(1)` we can do `(2)`.\r\n```\r\nop = A(x)\r\nop2 = B(op)\r\ncost = L2(op2, ground_truth)\r\ncost.backward()\r\nOa.step()\r\n#Here gradients are calculated for both `A` and `B`, but it doesn't matter because we are\r\n#just optimizing A with Oa.\r\n```\r\nI have understood this but let's say that:\r\nnetLoss = L1 + L2 + L3\r\nIn this I have the second case above. L2 has both A and B in the computation graph and we only want to optimize A with respect to L2. The problem is that we want to do netLoss.backward() and L1 + L2 + L3 contains A, B and C in them total.\r\n\r\nSo after netLoss.backward() we have to do:\r\nOa.step()\r\nOb.step()\r\nOc.step()\r\n\r\nSo, `Ob` will take gradients from L2 as well, and form the other losses that has it also. Is there some way to do netLoss.backward() when we can exclude certain models from the graph? Eg. in (2) above where we want to update only `A` in B(A(x))."}