{"url": "https://api.github.com/repos/pytorch/pytorch/issues/8597", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/8597/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/8597/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/8597/events", "html_url": "https://github.com/pytorch/pytorch/issues/8597", "id": 333193425, "node_id": "MDU6SXNzdWUzMzMxOTM0MjU=", "number": 8597, "title": "[FR, Feature Request] Segmentation Loader", "user": {"login": "BlanchonMarc", "id": 22957657, "node_id": "MDQ6VXNlcjIyOTU3NjU3", "avatar_url": "https://avatars3.githubusercontent.com/u/22957657?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BlanchonMarc", "html_url": "https://github.com/BlanchonMarc", "followers_url": "https://api.github.com/users/BlanchonMarc/followers", "following_url": "https://api.github.com/users/BlanchonMarc/following{/other_user}", "gists_url": "https://api.github.com/users/BlanchonMarc/gists{/gist_id}", "starred_url": "https://api.github.com/users/BlanchonMarc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BlanchonMarc/subscriptions", "organizations_url": "https://api.github.com/users/BlanchonMarc/orgs", "repos_url": "https://api.github.com/users/BlanchonMarc/repos", "events_url": "https://api.github.com/users/BlanchonMarc/events{/privacy}", "received_events_url": "https://api.github.com/users/BlanchonMarc/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2018-06-18T09:23:56Z", "updated_at": "2018-06-18T13:48:14Z", "closed_at": "2018-06-18T13:48:13Z", "author_association": "NONE", "body_html": "<p>Hello,</p>\n<p>As explained previously in another issue (sorry i'm not able to find it anymore), PyTorch had no segmentation loader innately implemented.<br>\nFor this reason, I developped mine and it is working fine with all the rest of the framework.<br>\nI hope you did not implement it before, I allow myself to provide you my code which embed all the docstrings and explanation, like this you do not need to work more on this task.</p>\n<pre><code>'''\nCreating a Dataloader for segmentation taks\n'''\n\nimport os\nimport glob\nfrom PIL import Image\nimport torch\nfrom torch.utils.data import Dataset\nfrom torch.autograd import Variable\n\n\nclass ImageFolderSegmentation(Dataset):\n    \"\"\"\n        A generic data loader for image segmentation where the data\n        are organised as:\n\n        ....\n\n        Parameters\n        ----------\n        root : str\n            Root folder containing the segmentation data.\n        images_path : str\n            path of the images with selector\n            image_path = '/image/*.png'\n        label_path : str\n            path of the labals with selector\n        conversion : str\n            conversion for input images\n        transform : Composed Transformation\n            transformation applied on input images\n        label_transform : Composed Transformation\n            transformation applied on label images\n\n        Attributes\n        ----------\n        image_filenames : list of str\n            images names with full path\n        label_filenames : list of str\n            label names with full path\n        conv: list of str\n            conversion List\n\n        Examples\n        --------\n\n        &gt;&gt;&gt; from dataloaderSegmentation import ImageFolderSegmentation\n        &gt;&gt;&gt; image_path = '/image/*.png'\n        &gt;&gt;&gt; label_path = '/label/*.png'\n        &gt;&gt;&gt; data = ImageFolderSegmentation(image_path=image_path,\n        ...                                label_path=label_path)\n\n\n    \"\"\"\n\n    def __init__(self, images_path, label_path, conversion='RGB',\n                 transform=None,\n                 label_transform=None):\n\n        self.image_filenames = sorted(glob.glob(images_path))\n        self.label_filenames = sorted(glob.glob(label_path))\n\n        self.conversion = conversion\n\n        if not all([self._get_filename(imf) == self._get_filename(lf)\n                    for imf, lf in zip(self.image_filenames,\n                                       self.label_filenames)]):\n                raise ValueError(\n                    'Image names in Images and label have to be identical')\n        self.transform = transform\n        self.label_transform = label_transform\n\n    def _get_filename(self, path):\n        return os.path.basename(os.path.splitext(path)[0])\n\n    def _pil_loader(self, path, conversion=None):\n        with open(path, 'rb') as f:\n            if conversion is not None:\n                return Image.open(f).convert(conversion)\n            else:\n                return Image.open(f).convert('P')\n\n    def __getitem__(self, index):\n        '''Get an image and a label'''\n\n        image = self._pil_loader(path=self.image_filenames[index],\n                                 conversion='RGB')\n        label = self._pil_loader(path=self.label_filenames[index])\n\n        if self.transform is not None:\n            image = self.transform(image)\n        if self.label_transform is not None:\n            label = self.label_transform(label)\n\n        return (image, label)\n\n    def __len__(self):\n        return len(self.image_filenames)\n\n    def __repr__(self):\n        fmt_str = 'Dataset ' + self.__class__.__name__ + '\\n'\n        fmt_str += '    Number of datapoints: {}\\n'.format(self.__len__())\n        tmp = '    Transforms (if any): '\n        fmt_str += '{0}{1}\\n'.format(tmp,\n                                     self.transform.__repr__().replace(\n                                         '\\n', '\\n' + ' ' * len(tmp)))\n        tmp = '    Label Transforms (if any): '\n        fmt_str += '{0}{1}'.format(tmp,\n                                   self.label_transform.__repr__().replace(\n                                       '\\n', '\\n' + ' ' * len(tmp)))\n        return fmt_str\n\n\n</code></pre>\n<p>Hope it will be helpful.</p>\n<p>Regards.</p>", "body_text": "Hello,\nAs explained previously in another issue (sorry i'm not able to find it anymore), PyTorch had no segmentation loader innately implemented.\nFor this reason, I developped mine and it is working fine with all the rest of the framework.\nI hope you did not implement it before, I allow myself to provide you my code which embed all the docstrings and explanation, like this you do not need to work more on this task.\n'''\nCreating a Dataloader for segmentation taks\n'''\n\nimport os\nimport glob\nfrom PIL import Image\nimport torch\nfrom torch.utils.data import Dataset\nfrom torch.autograd import Variable\n\n\nclass ImageFolderSegmentation(Dataset):\n    \"\"\"\n        A generic data loader for image segmentation where the data\n        are organised as:\n\n        ....\n\n        Parameters\n        ----------\n        root : str\n            Root folder containing the segmentation data.\n        images_path : str\n            path of the images with selector\n            image_path = '/image/*.png'\n        label_path : str\n            path of the labals with selector\n        conversion : str\n            conversion for input images\n        transform : Composed Transformation\n            transformation applied on input images\n        label_transform : Composed Transformation\n            transformation applied on label images\n\n        Attributes\n        ----------\n        image_filenames : list of str\n            images names with full path\n        label_filenames : list of str\n            label names with full path\n        conv: list of str\n            conversion List\n\n        Examples\n        --------\n\n        >>> from dataloaderSegmentation import ImageFolderSegmentation\n        >>> image_path = '/image/*.png'\n        >>> label_path = '/label/*.png'\n        >>> data = ImageFolderSegmentation(image_path=image_path,\n        ...                                label_path=label_path)\n\n\n    \"\"\"\n\n    def __init__(self, images_path, label_path, conversion='RGB',\n                 transform=None,\n                 label_transform=None):\n\n        self.image_filenames = sorted(glob.glob(images_path))\n        self.label_filenames = sorted(glob.glob(label_path))\n\n        self.conversion = conversion\n\n        if not all([self._get_filename(imf) == self._get_filename(lf)\n                    for imf, lf in zip(self.image_filenames,\n                                       self.label_filenames)]):\n                raise ValueError(\n                    'Image names in Images and label have to be identical')\n        self.transform = transform\n        self.label_transform = label_transform\n\n    def _get_filename(self, path):\n        return os.path.basename(os.path.splitext(path)[0])\n\n    def _pil_loader(self, path, conversion=None):\n        with open(path, 'rb') as f:\n            if conversion is not None:\n                return Image.open(f).convert(conversion)\n            else:\n                return Image.open(f).convert('P')\n\n    def __getitem__(self, index):\n        '''Get an image and a label'''\n\n        image = self._pil_loader(path=self.image_filenames[index],\n                                 conversion='RGB')\n        label = self._pil_loader(path=self.label_filenames[index])\n\n        if self.transform is not None:\n            image = self.transform(image)\n        if self.label_transform is not None:\n            label = self.label_transform(label)\n\n        return (image, label)\n\n    def __len__(self):\n        return len(self.image_filenames)\n\n    def __repr__(self):\n        fmt_str = 'Dataset ' + self.__class__.__name__ + '\\n'\n        fmt_str += '    Number of datapoints: {}\\n'.format(self.__len__())\n        tmp = '    Transforms (if any): '\n        fmt_str += '{0}{1}\\n'.format(tmp,\n                                     self.transform.__repr__().replace(\n                                         '\\n', '\\n' + ' ' * len(tmp)))\n        tmp = '    Label Transforms (if any): '\n        fmt_str += '{0}{1}'.format(tmp,\n                                   self.label_transform.__repr__().replace(\n                                       '\\n', '\\n' + ' ' * len(tmp)))\n        return fmt_str\n\n\n\nHope it will be helpful.\nRegards.", "body": "Hello,\r\n\r\nAs explained previously in another issue (sorry i'm not able to find it anymore), PyTorch had no segmentation loader innately implemented. \r\nFor this reason, I developped mine and it is working fine with all the rest of the framework. \r\nI hope you did not implement it before, I allow myself to provide you my code which embed all the docstrings and explanation, like this you do not need to work more on this task.\r\n\r\n\r\n```\r\n'''\r\nCreating a Dataloader for segmentation taks\r\n'''\r\n\r\nimport os\r\nimport glob\r\nfrom PIL import Image\r\nimport torch\r\nfrom torch.utils.data import Dataset\r\nfrom torch.autograd import Variable\r\n\r\n\r\nclass ImageFolderSegmentation(Dataset):\r\n    \"\"\"\r\n        A generic data loader for image segmentation where the data\r\n        are organised as:\r\n\r\n        ....\r\n\r\n        Parameters\r\n        ----------\r\n        root : str\r\n            Root folder containing the segmentation data.\r\n        images_path : str\r\n            path of the images with selector\r\n            image_path = '/image/*.png'\r\n        label_path : str\r\n            path of the labals with selector\r\n        conversion : str\r\n            conversion for input images\r\n        transform : Composed Transformation\r\n            transformation applied on input images\r\n        label_transform : Composed Transformation\r\n            transformation applied on label images\r\n\r\n        Attributes\r\n        ----------\r\n        image_filenames : list of str\r\n            images names with full path\r\n        label_filenames : list of str\r\n            label names with full path\r\n        conv: list of str\r\n            conversion List\r\n\r\n        Examples\r\n        --------\r\n\r\n        >>> from dataloaderSegmentation import ImageFolderSegmentation\r\n        >>> image_path = '/image/*.png'\r\n        >>> label_path = '/label/*.png'\r\n        >>> data = ImageFolderSegmentation(image_path=image_path,\r\n        ...                                label_path=label_path)\r\n\r\n\r\n    \"\"\"\r\n\r\n    def __init__(self, images_path, label_path, conversion='RGB',\r\n                 transform=None,\r\n                 label_transform=None):\r\n\r\n        self.image_filenames = sorted(glob.glob(images_path))\r\n        self.label_filenames = sorted(glob.glob(label_path))\r\n\r\n        self.conversion = conversion\r\n\r\n        if not all([self._get_filename(imf) == self._get_filename(lf)\r\n                    for imf, lf in zip(self.image_filenames,\r\n                                       self.label_filenames)]):\r\n                raise ValueError(\r\n                    'Image names in Images and label have to be identical')\r\n        self.transform = transform\r\n        self.label_transform = label_transform\r\n\r\n    def _get_filename(self, path):\r\n        return os.path.basename(os.path.splitext(path)[0])\r\n\r\n    def _pil_loader(self, path, conversion=None):\r\n        with open(path, 'rb') as f:\r\n            if conversion is not None:\r\n                return Image.open(f).convert(conversion)\r\n            else:\r\n                return Image.open(f).convert('P')\r\n\r\n    def __getitem__(self, index):\r\n        '''Get an image and a label'''\r\n\r\n        image = self._pil_loader(path=self.image_filenames[index],\r\n                                 conversion='RGB')\r\n        label = self._pil_loader(path=self.label_filenames[index])\r\n\r\n        if self.transform is not None:\r\n            image = self.transform(image)\r\n        if self.label_transform is not None:\r\n            label = self.label_transform(label)\r\n\r\n        return (image, label)\r\n\r\n    def __len__(self):\r\n        return len(self.image_filenames)\r\n\r\n    def __repr__(self):\r\n        fmt_str = 'Dataset ' + self.__class__.__name__ + '\\n'\r\n        fmt_str += '    Number of datapoints: {}\\n'.format(self.__len__())\r\n        tmp = '    Transforms (if any): '\r\n        fmt_str += '{0}{1}\\n'.format(tmp,\r\n                                     self.transform.__repr__().replace(\r\n                                         '\\n', '\\n' + ' ' * len(tmp)))\r\n        tmp = '    Label Transforms (if any): '\r\n        fmt_str += '{0}{1}'.format(tmp,\r\n                                   self.label_transform.__repr__().replace(\r\n                                       '\\n', '\\n' + ' ' * len(tmp)))\r\n        return fmt_str\r\n\r\n\r\n```\r\n\r\nHope it will be helpful. \r\n\r\nRegards."}