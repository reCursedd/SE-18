{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/196169668", "pull_request_review_id": 129671782, "id": 196169668, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NjE2OTY2OA==", "diff_hunk": "@@ -148,37 +148,67 @@ const std::exception& ProcessGroupNCCL::WorkNCCL::exception() const {\n       \"isCompleted() and wait() will either succeed or throw\");\n }\n \n+std::unordered_map<ssize_t, ssize_t> ProcessGroupNCCL::pgUniqueNCCLIDCnt_;\n+ssize_t ProcessGroupNCCL::processGroupCounter_ = -1;\n+std::mutex ProcessGroupNCCL::pgTrackingLock_;\n+\n ProcessGroupNCCL::ProcessGroupNCCL(\n     const std::shared_ptr<Store>& store,\n     int rank,\n     int size)\n     : ProcessGroup(rank, size), store_(store) {\n-  C10D_CUDA_CHECK(cudaGetDeviceCount(&numGPUs_));\n   thcState_ = ::at::globalContext().lazyInitCUDA();\n+  // Generate the Process Group ID for current PG, this needs to be identical\n+  // for all processes\n+  std::unique_lock<std::mutex> lock(pgTrackingLock_);\n+  while (true) {\n+    ++processGroupCounter_;\n+    if (pgUniqueNCCLIDCnt_.find(processGroupCounter_) ==\n+        pgUniqueNCCLIDCnt_.end()) {\n+      pgUniqueNCCLIDCnt_[processGroupCounter_] = -1;\n+      processGroupID_ = std::to_string(processGroupCounter_);\n+      return;\n+    }\n+  }", "path": "torch/lib/c10d/ProcessGroupNCCL.cpp", "position": null, "original_position": 26, "commit_id": "ac86a8bfe0f243c213b1717abe3e96d5f9682f48", "original_commit_id": "592ce2613a85be21277ad488008e8265a6525462", "user": {"login": "teng-li", "id": 8120856, "node_id": "MDQ6VXNlcjgxMjA4NTY=", "avatar_url": "https://avatars2.githubusercontent.com/u/8120856?v=4", "gravatar_id": "", "url": "https://api.github.com/users/teng-li", "html_url": "https://github.com/teng-li", "followers_url": "https://api.github.com/users/teng-li/followers", "following_url": "https://api.github.com/users/teng-li/following{/other_user}", "gists_url": "https://api.github.com/users/teng-li/gists{/gist_id}", "starred_url": "https://api.github.com/users/teng-li/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/teng-li/subscriptions", "organizations_url": "https://api.github.com/users/teng-li/orgs", "repos_url": "https://api.github.com/users/teng-li/repos", "events_url": "https://api.github.com/users/teng-li/events{/privacy}", "received_events_url": "https://api.github.com/users/teng-li/received_events", "type": "User", "site_admin": false}, "body": "I don't simply want to increase the counter and overflow, that's what the while loop is for. And for the lock is self, it is needed since we increase the counter and then read it, and then use it to  access the map, the whole op needs to be atomic.", "created_at": "2018-06-18T17:56:15Z", "updated_at": "2018-11-23T15:45:42Z", "html_url": "https://github.com/pytorch/pytorch/pull/8357#discussion_r196169668", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/8357", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/196169668"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/8357#discussion_r196169668"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/8357"}}, "body_html": "<p>I don't simply want to increase the counter and overflow, that's what the while loop is for. And for the lock is self, it is needed since we increase the counter and then read it, and then use it to  access the map, the whole op needs to be atomic.</p>", "body_text": "I don't simply want to increase the counter and overflow, that's what the while loop is for. And for the lock is self, it is needed since we increase the counter and then read it, and then use it to  access the map, the whole op needs to be atomic.", "in_reply_to_id": 196135447}