{"url": "https://api.github.com/repos/pytorch/pytorch/issues/3025", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/3025/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/3025/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/3025/events", "html_url": "https://github.com/pytorch/pytorch/issues/3025", "id": 263762887, "node_id": "MDU6SXNzdWUyNjM3NjI4ODc=", "number": 3025, "title": "Add a torch function similar to numpy.in1d", "user": {"login": "aron-bordin", "id": 4960137, "node_id": "MDQ6VXNlcjQ5NjAxMzc=", "avatar_url": "https://avatars3.githubusercontent.com/u/4960137?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aron-bordin", "html_url": "https://github.com/aron-bordin", "followers_url": "https://api.github.com/users/aron-bordin/followers", "following_url": "https://api.github.com/users/aron-bordin/following{/other_user}", "gists_url": "https://api.github.com/users/aron-bordin/gists{/gist_id}", "starred_url": "https://api.github.com/users/aron-bordin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aron-bordin/subscriptions", "organizations_url": "https://api.github.com/users/aron-bordin/orgs", "repos_url": "https://api.github.com/users/aron-bordin/repos", "events_url": "https://api.github.com/users/aron-bordin/events{/privacy}", "received_events_url": "https://api.github.com/users/aron-bordin/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 424131849, "node_id": "MDU6TGFiZWw0MjQxMzE4NDk=", "url": "https://api.github.com/repos/pytorch/pytorch/labels/enhancement", "name": "enhancement", "color": "84b6eb", "default": true}, {"id": 443483881, "node_id": "MDU6TGFiZWw0NDM0ODM4ODE=", "url": "https://api.github.com/repos/pytorch/pytorch/labels/todo", "name": "todo", "color": "c2e0c6", "default": false}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2017-10-08T23:53:44Z", "updated_at": "2018-08-08T15:25:38Z", "closed_at": null, "author_association": "CONTRIBUTOR", "body_html": "<p>I believe that should be useful to have a function similar to <a href=\"https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.in1d.html\" rel=\"nofollow\">https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.in1d.html</a>, that compares a tensor element-wise with a list of possible values. (I'm using it to filter labels/classes in some classifiers).</p>\n<p>Expected behavior:</p>\n<pre><code>&gt;&gt;&gt; a = torch.LongTensor([[1,2,3],[1,1,2],[3,5,1]])\n&gt;&gt;&gt; a\n 1  2  3\n 1  1  2\n 3  5  1\n[torch.LongTensor of size 3x3]\n&gt;&gt;&gt; a.in(torch.LongTensor([1, 2, 5]))\n 1 1 0\n 1 1 1\n 0 1 1\n</code></pre>\n<p>Now it's possible to implement it by iterating over the filter, and storing the results in a tensor with the OR operator. But a faster implementation is possible with TH/THC</p>\n<p>My current implementation:</p>\n<pre><code>@utils.tensorfy(0, 1, tensor_klass=torch.LongTensor)\ndef filter_labels(y, labels):\n    \"\"\"Utility used to create a mask to filter values in a tensor.\n\n    Args:\n        y (list, torch.Tensor): tensor where each element is a numeric integer\n            representing a label.\n        labels (list, torch.Tensor): filter used to generate the mask. For each\n            value in ``y`` its mask will be \"1\" if its value is in ``labels``,\n            \"0\" otherwise\".\n\n    Shape:\n        y: can have any shape. Usually will be :math:`(N, S)` or :math:`(S)`,\n            containing `batch X samples` or just a list of `samples`.\n        labels: a flatten list, or a 1D LongTensor.\n\n    Returns:\n        mask (torch.ByteTensor): a binary mask, with \"1\" with the respective value from ``y`` is\n        in the ``labels`` filter.\n\n    Example::\n\n        &gt;&gt;&gt; a = torch.LongTensor([[1,2,3],[1,1,2],[3,5,1]])\n        &gt;&gt;&gt; a\n         1  2  3\n         1  1  2\n         3  5  1\n        [torch.LongTensor of size 3x3]\n        &gt;&gt;&gt; classification.filter_labels(a, [1, 2, 5])\n         1  1  0\n         1  1  1\n         0  1  1\n        [torch.ByteTensor of size 3x3]\n        &gt;&gt;&gt; classification.filter_labels(a, torch.LongTensor([1]))\n         1  0  0\n         1  1  0\n         0  0  1\n        [torch.ByteTensor of size 3x3]\n    \"\"\"\n    mapping = torch.zeros(y.size()).byte()\n\n    for label in labels:\n        mapping = mapping | y.eq(label)\n\n    return mapping\n\n</code></pre>", "body_text": "I believe that should be useful to have a function similar to https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.in1d.html, that compares a tensor element-wise with a list of possible values. (I'm using it to filter labels/classes in some classifiers).\nExpected behavior:\n>>> a = torch.LongTensor([[1,2,3],[1,1,2],[3,5,1]])\n>>> a\n 1  2  3\n 1  1  2\n 3  5  1\n[torch.LongTensor of size 3x3]\n>>> a.in(torch.LongTensor([1, 2, 5]))\n 1 1 0\n 1 1 1\n 0 1 1\n\nNow it's possible to implement it by iterating over the filter, and storing the results in a tensor with the OR operator. But a faster implementation is possible with TH/THC\nMy current implementation:\n@utils.tensorfy(0, 1, tensor_klass=torch.LongTensor)\ndef filter_labels(y, labels):\n    \"\"\"Utility used to create a mask to filter values in a tensor.\n\n    Args:\n        y (list, torch.Tensor): tensor where each element is a numeric integer\n            representing a label.\n        labels (list, torch.Tensor): filter used to generate the mask. For each\n            value in ``y`` its mask will be \"1\" if its value is in ``labels``,\n            \"0\" otherwise\".\n\n    Shape:\n        y: can have any shape. Usually will be :math:`(N, S)` or :math:`(S)`,\n            containing `batch X samples` or just a list of `samples`.\n        labels: a flatten list, or a 1D LongTensor.\n\n    Returns:\n        mask (torch.ByteTensor): a binary mask, with \"1\" with the respective value from ``y`` is\n        in the ``labels`` filter.\n\n    Example::\n\n        >>> a = torch.LongTensor([[1,2,3],[1,1,2],[3,5,1]])\n        >>> a\n         1  2  3\n         1  1  2\n         3  5  1\n        [torch.LongTensor of size 3x3]\n        >>> classification.filter_labels(a, [1, 2, 5])\n         1  1  0\n         1  1  1\n         0  1  1\n        [torch.ByteTensor of size 3x3]\n        >>> classification.filter_labels(a, torch.LongTensor([1]))\n         1  0  0\n         1  1  0\n         0  0  1\n        [torch.ByteTensor of size 3x3]\n    \"\"\"\n    mapping = torch.zeros(y.size()).byte()\n\n    for label in labels:\n        mapping = mapping | y.eq(label)\n\n    return mapping", "body": "I believe that should be useful to have a function similar to https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.in1d.html, that compares a tensor element-wise with a list of possible values. (I'm using it to filter labels/classes in some classifiers).\r\n\r\nExpected behavior:\r\n\r\n```\r\n>>> a = torch.LongTensor([[1,2,3],[1,1,2],[3,5,1]])\r\n>>> a\r\n 1  2  3\r\n 1  1  2\r\n 3  5  1\r\n[torch.LongTensor of size 3x3]\r\n>>> a.in(torch.LongTensor([1, 2, 5]))\r\n 1 1 0\r\n 1 1 1\r\n 0 1 1\r\n```\r\n\r\nNow it's possible to implement it by iterating over the filter, and storing the results in a tensor with the OR operator. But a faster implementation is possible with TH/THC\r\n\r\nMy current implementation:\r\n\r\n```\r\n@utils.tensorfy(0, 1, tensor_klass=torch.LongTensor)\r\ndef filter_labels(y, labels):\r\n    \"\"\"Utility used to create a mask to filter values in a tensor.\r\n\r\n    Args:\r\n        y (list, torch.Tensor): tensor where each element is a numeric integer\r\n            representing a label.\r\n        labels (list, torch.Tensor): filter used to generate the mask. For each\r\n            value in ``y`` its mask will be \"1\" if its value is in ``labels``,\r\n            \"0\" otherwise\".\r\n\r\n    Shape:\r\n        y: can have any shape. Usually will be :math:`(N, S)` or :math:`(S)`,\r\n            containing `batch X samples` or just a list of `samples`.\r\n        labels: a flatten list, or a 1D LongTensor.\r\n\r\n    Returns:\r\n        mask (torch.ByteTensor): a binary mask, with \"1\" with the respective value from ``y`` is\r\n        in the ``labels`` filter.\r\n\r\n    Example::\r\n\r\n        >>> a = torch.LongTensor([[1,2,3],[1,1,2],[3,5,1]])\r\n        >>> a\r\n         1  2  3\r\n         1  1  2\r\n         3  5  1\r\n        [torch.LongTensor of size 3x3]\r\n        >>> classification.filter_labels(a, [1, 2, 5])\r\n         1  1  0\r\n         1  1  1\r\n         0  1  1\r\n        [torch.ByteTensor of size 3x3]\r\n        >>> classification.filter_labels(a, torch.LongTensor([1]))\r\n         1  0  0\r\n         1  1  0\r\n         0  0  1\r\n        [torch.ByteTensor of size 3x3]\r\n    \"\"\"\r\n    mapping = torch.zeros(y.size()).byte()\r\n\r\n    for label in labels:\r\n        mapping = mapping | y.eq(label)\r\n\r\n    return mapping\r\n\r\n```"}