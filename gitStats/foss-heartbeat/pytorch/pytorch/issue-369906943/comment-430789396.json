{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/430789396", "html_url": "https://github.com/pytorch/pytorch/issues/12633#issuecomment-430789396", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/12633", "id": 430789396, "node_id": "MDEyOklzc3VlQ29tbWVudDQzMDc4OTM5Ng==", "user": {"login": "weiyangfb", "id": 38509346, "node_id": "MDQ6VXNlcjM4NTA5MzQ2", "avatar_url": "https://avatars1.githubusercontent.com/u/38509346?v=4", "gravatar_id": "", "url": "https://api.github.com/users/weiyangfb", "html_url": "https://github.com/weiyangfb", "followers_url": "https://api.github.com/users/weiyangfb/followers", "following_url": "https://api.github.com/users/weiyangfb/following{/other_user}", "gists_url": "https://api.github.com/users/weiyangfb/gists{/gist_id}", "starred_url": "https://api.github.com/users/weiyangfb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/weiyangfb/subscriptions", "organizations_url": "https://api.github.com/users/weiyangfb/orgs", "repos_url": "https://api.github.com/users/weiyangfb/repos", "events_url": "https://api.github.com/users/weiyangfb/events{/privacy}", "received_events_url": "https://api.github.com/users/weiyangfb/received_events", "type": "User", "site_admin": false}, "created_at": "2018-10-17T21:05:07Z", "updated_at": "2018-10-17T21:47:49Z", "author_association": "CONTRIBUTOR", "body_html": "<p>calling <code>indices.contiguous()</code> and <code>values.contiguous()</code> everywhere still looks cumbersome. Previously people relies on <code>SparseTensor.coalesce()</code> to assert contiguity. But this is no long true since <code>set_coalesced()</code> is exposed. To ensure contiguity, currently I have to write code this way:</p>\n<pre><code>SparseTensor sparse = sparse_.coalesce();\n\n// Ensure indices and values to be contiguous,\n// This is because set_coalesced() can mutate the coalesce bit,\n// and so sparse_.coalesce() doesn't guarantee contiguity.\n// Remove this when kernels in this function can deal with non-contiguous case.\nLongTensor indices = sparse._indices().contiguous();\nTensor values = sparse._values().contiguous();\nAT_ASSERT(indices.is_contiguous());\nAT_ASSERT(values.is_contiguous());\n</code></pre>\n<p>Edit: this is not a complete fix either... We will still have to make sure <code>sparse</code> is truly coalesced, meaning both have to be true:</p>\n<ul>\n<li>indices are unique</li>\n<li>indices are sorted</li>\n</ul>", "body_text": "calling indices.contiguous() and values.contiguous() everywhere still looks cumbersome. Previously people relies on SparseTensor.coalesce() to assert contiguity. But this is no long true since set_coalesced() is exposed. To ensure contiguity, currently I have to write code this way:\nSparseTensor sparse = sparse_.coalesce();\n\n// Ensure indices and values to be contiguous,\n// This is because set_coalesced() can mutate the coalesce bit,\n// and so sparse_.coalesce() doesn't guarantee contiguity.\n// Remove this when kernels in this function can deal with non-contiguous case.\nLongTensor indices = sparse._indices().contiguous();\nTensor values = sparse._values().contiguous();\nAT_ASSERT(indices.is_contiguous());\nAT_ASSERT(values.is_contiguous());\n\nEdit: this is not a complete fix either... We will still have to make sure sparse is truly coalesced, meaning both have to be true:\n\nindices are unique\nindices are sorted", "body": "calling `indices.contiguous()` and `values.contiguous()` everywhere still looks cumbersome. Previously people relies on `SparseTensor.coalesce()` to assert contiguity. But this is no long true since `set_coalesced()` is exposed. To ensure contiguity, currently I have to write code this way:\r\n```\r\nSparseTensor sparse = sparse_.coalesce();\r\n\r\n// Ensure indices and values to be contiguous,\r\n// This is because set_coalesced() can mutate the coalesce bit,\r\n// and so sparse_.coalesce() doesn't guarantee contiguity.\r\n// Remove this when kernels in this function can deal with non-contiguous case.\r\nLongTensor indices = sparse._indices().contiguous();\r\nTensor values = sparse._values().contiguous();\r\nAT_ASSERT(indices.is_contiguous());\r\nAT_ASSERT(values.is_contiguous());\r\n```\r\n\r\nEdit: this is not a complete fix either... We will still have to make sure `sparse` is truly coalesced, meaning both have to be true:\r\n\r\n- indices are unique\r\n- indices are sorted"}