{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/420344050", "html_url": "https://github.com/pytorch/pytorch/issues/11516#issuecomment-420344050", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/11516", "id": 420344050, "node_id": "MDEyOklzc3VlQ29tbWVudDQyMDM0NDA1MA==", "user": {"login": "goldsborough", "id": 6429851, "node_id": "MDQ6VXNlcjY0Mjk4NTE=", "avatar_url": "https://avatars3.githubusercontent.com/u/6429851?v=4", "gravatar_id": "", "url": "https://api.github.com/users/goldsborough", "html_url": "https://github.com/goldsborough", "followers_url": "https://api.github.com/users/goldsborough/followers", "following_url": "https://api.github.com/users/goldsborough/following{/other_user}", "gists_url": "https://api.github.com/users/goldsborough/gists{/gist_id}", "starred_url": "https://api.github.com/users/goldsborough/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/goldsborough/subscriptions", "organizations_url": "https://api.github.com/users/goldsborough/orgs", "repos_url": "https://api.github.com/users/goldsborough/repos", "events_url": "https://api.github.com/users/goldsborough/events{/privacy}", "received_events_url": "https://api.github.com/users/goldsborough/received_events", "type": "User", "site_admin": false}, "created_at": "2018-09-11T16:55:52Z", "updated_at": "2018-09-11T16:55:52Z", "author_association": "CONTRIBUTOR", "body_html": "<p>For one, in order to fix it to give it the semantics you expected, why not change the operator== to check if one of the indices -1?</p>\n<p>On a larger note, not sure I agree with the overall idea. The default state is a distinct state from a concrete device + index pair. A default constructed string is quite different from a string with content and you wouldn\u2019t expect them to compare equal. In your example you asked the question \u201cis this very specific device which I have equal to this other very specific device\u201d. They weren\u2019t so the answer was false. I think you simply have to be more explicit with the logic you use for checking equality. I think whatever we decide <code>Device::operator==</code> should not change its semantics from what they currently are. The semantics are very simple: the device type must match and the device index must match. An explicit index is different from the default index. I like to think of it as being a variant</p>\n<pre><code>enum DeviceIndex {\n  Default,\n  Concrete: i32\n}\n</code></pre>\n<p>and those two currently don't compare equal and that is a valid constraint IMO.</p>\n<p>I feel like a whole separate type, <code>FullDevice</code>, would add additional complexity and require more education of users (\"Why are there two types?\"; \"Why doesn't this work the way I expected\" , \"You should use <code>FullDevice</code> here, but just <code>Device</code> everywhere else\"?).</p>\n<p>In Python devices currently do not compare at all, so I guess we can't fall back on that behavior there.</p>\n<p>I think my gut answer here would be:</p>\n<ol>\n<li><code>ensure_has_index()</code> is useful to have either way, let's add that as a way to \"concretize\" the index,</li>\n<li>Use explicit logic for what you wanted to achieve, which was:</li>\n</ol>\n<pre><code>Tensor Tensor::cuda(int32_t index = -1) {\n  const auto my_device = this-&gt;device();\n  if (my_device.is_cuda() &amp;&amp; my_device.device_index() == index) {\n    return *this;  \n  }\n  // do the transfer\n}\n</code></pre>\n<p>I actually don't know why your method even accepts a device in your example, that sounds like the wrong argument?</p>\n<p>This is my brain dump answer on the question, not final. Happy to discuss more.</p>", "body_text": "For one, in order to fix it to give it the semantics you expected, why not change the operator== to check if one of the indices -1?\nOn a larger note, not sure I agree with the overall idea. The default state is a distinct state from a concrete device + index pair. A default constructed string is quite different from a string with content and you wouldn\u2019t expect them to compare equal. In your example you asked the question \u201cis this very specific device which I have equal to this other very specific device\u201d. They weren\u2019t so the answer was false. I think you simply have to be more explicit with the logic you use for checking equality. I think whatever we decide Device::operator== should not change its semantics from what they currently are. The semantics are very simple: the device type must match and the device index must match. An explicit index is different from the default index. I like to think of it as being a variant\nenum DeviceIndex {\n  Default,\n  Concrete: i32\n}\n\nand those two currently don't compare equal and that is a valid constraint IMO.\nI feel like a whole separate type, FullDevice, would add additional complexity and require more education of users (\"Why are there two types?\"; \"Why doesn't this work the way I expected\" , \"You should use FullDevice here, but just Device everywhere else\"?).\nIn Python devices currently do not compare at all, so I guess we can't fall back on that behavior there.\nI think my gut answer here would be:\n\nensure_has_index() is useful to have either way, let's add that as a way to \"concretize\" the index,\nUse explicit logic for what you wanted to achieve, which was:\n\nTensor Tensor::cuda(int32_t index = -1) {\n  const auto my_device = this->device();\n  if (my_device.is_cuda() && my_device.device_index() == index) {\n    return *this;  \n  }\n  // do the transfer\n}\n\nI actually don't know why your method even accepts a device in your example, that sounds like the wrong argument?\nThis is my brain dump answer on the question, not final. Happy to discuss more.", "body": "For one, in order to fix it to give it the semantics you expected, why not change the operator== to check if one of the indices -1?\r\n\r\nOn a larger note, not sure I agree with the overall idea. The default state is a distinct state from a concrete device + index pair. A default constructed string is quite different from a string with content and you wouldn\u2019t expect them to compare equal. In your example you asked the question \u201cis this very specific device which I have equal to this other very specific device\u201d. They weren\u2019t so the answer was false. I think you simply have to be more explicit with the logic you use for checking equality. I think whatever we decide `Device::operator==` should not change its semantics from what they currently are. The semantics are very simple: the device type must match and the device index must match. An explicit index is different from the default index. I like to think of it as being a variant\r\n```\r\nenum DeviceIndex {\r\n  Default,\r\n  Concrete: i32\r\n}\r\n```\r\nand those two currently don't compare equal and that is a valid constraint IMO.\r\n\r\nI feel like a whole separate type, `FullDevice`, would add additional complexity and require more education of users (\"Why are there two types?\"; \"Why doesn't this work the way I expected\" , \"You should use `FullDevice` here, but just `Device` everywhere else\"?).\r\n\r\nIn Python devices currently do not compare at all, so I guess we can't fall back on that behavior there.\r\n\r\nI think my gut answer here would be:\r\n1. `ensure_has_index()` is useful to have either way, let's add that as a way to \"concretize\" the index,\r\n2. Use explicit logic for what you wanted to achieve, which was:\r\n```\r\nTensor Tensor::cuda(int32_t index = -1) {\r\n  const auto my_device = this->device();\r\n  if (my_device.is_cuda() && my_device.device_index() == index) {\r\n    return *this;  \r\n  }\r\n  // do the transfer\r\n}\r\n```\r\n I actually don't know why your method even accepts a device in your example, that sounds like the wrong argument?\r\n\r\nThis is my brain dump answer on the question, not final. Happy to discuss more."}