{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/408258359", "html_url": "https://github.com/pytorch/pytorch/pull/9422#issuecomment-408258359", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/9422", "id": 408258359, "node_id": "MDEyOklzc3VlQ29tbWVudDQwODI1ODM1OQ==", "user": {"login": "zdevito", "id": 370202, "node_id": "MDQ6VXNlcjM3MDIwMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/370202?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zdevito", "html_url": "https://github.com/zdevito", "followers_url": "https://api.github.com/users/zdevito/followers", "following_url": "https://api.github.com/users/zdevito/following{/other_user}", "gists_url": "https://api.github.com/users/zdevito/gists{/gist_id}", "starred_url": "https://api.github.com/users/zdevito/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zdevito/subscriptions", "organizations_url": "https://api.github.com/users/zdevito/orgs", "repos_url": "https://api.github.com/users/zdevito/repos", "events_url": "https://api.github.com/users/zdevito/events{/privacy}", "received_events_url": "https://api.github.com/users/zdevito/received_events", "type": "User", "site_admin": false}, "created_at": "2018-07-26T22:47:45Z", "updated_at": "2018-07-26T22:47:45Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Hmm, I guess we can:</p>\n<ol>\n<li>Have an inline annotation that is basically a escape operator that evaluates the python code an drops the evaluated result in:</li>\n</ol>\n<p>@torch.jit.script<br>\ndef fn(x):<br>\nreturn x + const(math.pi + 3)<br>\n~~~~~~~~  &lt;- evaluated as python during compilation, if you change math.pi it is on you to fix it</p>\n<ol start=\"2\">\n<li>Wrap modules:</li>\n</ol>\n<pre><code>math = constify(math, ['pi'])\n</code></pre>\n<p>This would ensure pi does not change in the module. However, it doesn't check that math isn't re-assigned. So it is not safe anyway. Because of this I don't really like this version.</p>\n<ol start=\"3\">\n<li>Make some generic, but reasonable, assumptions about what will and won't be constant. For instance, we can assume that a global variable that is a module will not be reassigned, and the fields of modules will not be reassigned. In this world <code>math.pi</code> would work, but only because math is a global module, and <code>math.pi</code> is a field of that module. Other globals, like raw numbers, would not be considered constants by default. This one seems pretty reasonable, except in the case where you violate the assumption and get a very hard-to-find error.</li>\n</ol>\n<p>Aside: we already do a form of (3) for any python function. Anything that resolves to a python function is assumed to be a constant, even though you can trivial break it:</p>\n<pre><code>def foo(x):\n  print \"hi\"\n  return x\n\n@torch.jit.script\ndef bar(x):\n  foo(x)\n\nfoo = 3\n\nbar(3) # still prints \"hi\", the resolution to the function was done at compile time.\n</code></pre>\n<p>My vote, reluctantly, is for (3)</p>\n<p>A global that is a subclass of python module is assumed to not change. Its fields are also assumed to not change and so can become constants. Functions are generally assumed to be constants.</p>", "body_text": "Hmm, I guess we can:\n\nHave an inline annotation that is basically a escape operator that evaluates the python code an drops the evaluated result in:\n\n@torch.jit.script\ndef fn(x):\nreturn x + const(math.pi + 3)\n~~~~~~~~  <- evaluated as python during compilation, if you change math.pi it is on you to fix it\n\nWrap modules:\n\nmath = constify(math, ['pi'])\n\nThis would ensure pi does not change in the module. However, it doesn't check that math isn't re-assigned. So it is not safe anyway. Because of this I don't really like this version.\n\nMake some generic, but reasonable, assumptions about what will and won't be constant. For instance, we can assume that a global variable that is a module will not be reassigned, and the fields of modules will not be reassigned. In this world math.pi would work, but only because math is a global module, and math.pi is a field of that module. Other globals, like raw numbers, would not be considered constants by default. This one seems pretty reasonable, except in the case where you violate the assumption and get a very hard-to-find error.\n\nAside: we already do a form of (3) for any python function. Anything that resolves to a python function is assumed to be a constant, even though you can trivial break it:\ndef foo(x):\n  print \"hi\"\n  return x\n\n@torch.jit.script\ndef bar(x):\n  foo(x)\n\nfoo = 3\n\nbar(3) # still prints \"hi\", the resolution to the function was done at compile time.\n\nMy vote, reluctantly, is for (3)\nA global that is a subclass of python module is assumed to not change. Its fields are also assumed to not change and so can become constants. Functions are generally assumed to be constants.", "body": "Hmm, I guess we can:\r\n\r\n1. Have an inline annotation that is basically a escape operator that evaluates the python code an drops the evaluated result in:\r\n\r\n@torch.jit.script\r\ndef fn(x):\r\n   return x + const(math.pi + 3)\r\n                               ~~~~~~~~  <- evaluated as python during compilation, if you change math.pi it is on you to fix it\r\n\r\n2. Wrap modules:\r\n ```\r\nmath = constify(math, ['pi'])\r\n```\r\nThis would ensure pi does not change in the module. However, it doesn't check that math isn't re-assigned. So it is not safe anyway. Because of this I don't really like this version.\r\n\r\n3. Make some generic, but reasonable, assumptions about what will and won't be constant. For instance, we can assume that a global variable that is a module will not be reassigned, and the fields of modules will not be reassigned. In this world `math.pi` would work, but only because math is a global module, and `math.pi` is a field of that module. Other globals, like raw numbers, would not be considered constants by default. This one seems pretty reasonable, except in the case where you violate the assumption and get a very hard-to-find error.\r\n\r\nAside: we already do a form of (3) for any python function. Anything that resolves to a python function is assumed to be a constant, even though you can trivial break it:\r\n\r\n```\r\ndef foo(x):\r\n  print \"hi\"\r\n  return x\r\n\r\n@torch.jit.script\r\ndef bar(x):\r\n  foo(x)\r\n\r\nfoo = 3\r\n\r\nbar(3) # still prints \"hi\", the resolution to the function was done at compile time.\r\n``` \r\n\r\nMy vote, reluctantly, is for (3)\r\n\r\nA global that is a subclass of python module is assumed to not change. Its fields are also assumed to not change and so can become constants. Functions are generally assumed to be constants.\r\n"}