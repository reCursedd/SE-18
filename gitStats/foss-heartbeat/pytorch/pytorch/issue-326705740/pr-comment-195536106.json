{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/195536106", "pull_request_review_id": 128921791, "id": 195536106, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NTUzNjEwNg==", "diff_hunk": "@@ -0,0 +1,111 @@\n+#pragma once\n+\n+#include <ATen/Device.h>\n+#include <ATen/ScalarType.h>\n+#include <ATen/Tensor.h>\n+#include <ATen/detail/CUDAHooksInterface.h>\n+#include <ATen/optional.h>\n+\n+#include <cstddef>\n+\n+namespace at {\n+/// RAII guard that sets a certain default device in its constructor, and\n+/// changes it back to the device that was originally active upon destruction.\n+///\n+/// The device is always reset to the one that was active at the time of\n+/// construction of the guard. Even if you `set_index` after construction, the\n+/// destructor will still reset the index to the one that was active at\n+/// construction time.\n+///\n+/// Legacy constructors and setters are kept around that accept -1 as the device\n+/// index, which is equivalent to `at::nullopt`. All new code should prefer the\n+/// latter.\n+struct DeviceGuard {\n+  /// Default constructor, does nothing.\n+  DeviceGuard();\n+\n+  /// Calls `set_device` with the given `Device`. Defined in Device.cpp because\n+  /// the CUDA device compiler complains otherwise.\n+  explicit DeviceGuard(Device device);\n+\n+  /// Convenience constructor that creates a `Device` from the given\n+  /// arguments and then forwards to the constructor from `Device`.\n+  DeviceGuard(Backend backend, at::optional<int32_t> device_index);\n+\n+  /// Legacy constructor that accepts -1 as the device index and turns it into\n+  /// `at::nullopt`.\n+  /* deprecated */ DeviceGuard(Backend backend, int32_t device_index);\n+\n+  /// Sets the device to the index on which the given tensor is located.\n+  explicit DeviceGuard(const Tensor& tensor);\n+\n+  /// Sets the device to the index on which the first tensor in the list is\n+  /// located. If the list is empty, does nothing.\n+  explicit DeviceGuard(const TensorList& tensors);\n+\n+  /// Resets the device to the index that was active at construction of the\n+  /// guard.\n+  ~DeviceGuard() {\n+    // It should only not have a value if an index was never actually set.\n+    if (original_device_) {\n+      // NOTE: When more devices are added, their respective ways of changing\n+      // the device should be added here.\n+      if (original_device_->is_cuda()) {\n+        // Unchecked because we don't want to throw in the destructor.\n+        detail::DynamicCUDAInterface::unchecked_set_device(\n+            original_device_->index().value());\n+      }\n+    }\n+  }\n+\n+  /// Legacy function that sets the backend to CUDA, and accepts -1 as the\n+  /// device index, which is turned into `at::nullopt`. Use `set_device` for new\n+  /// code.\n+  /* deprecated */ void set_index(int32_t device_index);\n+\n+  /// Sets the device to the given one if its index is not `nullopt`.\n+  void set_device(Device device) {\n+    if (!device.has_index()) {\n+      // Figure out a better strategy here once we really have more than CUDA\n+      // and CPU devices. For example, the device index may just default to zero\n+      // if the device type differs from the current device type.\n+      return;\n+    }\n+    if (!original_device_) {\n+      // Add more ways of swapping the device when more device types are added.\n+      if (device.is_cuda()) {\n+        int32_t previous_index = 0;\n+        detail::DynamicCUDAInterface::get_device(&previous_index);\n+        original_device_ = Device(Device::Type::CUDA, previous_index);\n+      } else {\n+        original_device_ = Device(Device::Type::CPU);", "path": "aten/src/ATen/DeviceGuard.h", "position": null, "original_position": 81, "commit_id": "c5b2af6a950b67445ad8916d364fd24456d7aa39", "original_commit_id": "78cec40f5df0dad001f04e09a7b924cad7fdaf03", "user": {"login": "colesbury", "id": 655866, "node_id": "MDQ6VXNlcjY1NTg2Ng==", "avatar_url": "https://avatars1.githubusercontent.com/u/655866?v=4", "gravatar_id": "", "url": "https://api.github.com/users/colesbury", "html_url": "https://github.com/colesbury", "followers_url": "https://api.github.com/users/colesbury/followers", "following_url": "https://api.github.com/users/colesbury/following{/other_user}", "gists_url": "https://api.github.com/users/colesbury/gists{/gist_id}", "starred_url": "https://api.github.com/users/colesbury/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/colesbury/subscriptions", "organizations_url": "https://api.github.com/users/colesbury/orgs", "repos_url": "https://api.github.com/users/colesbury/repos", "events_url": "https://api.github.com/users/colesbury/events{/privacy}", "received_events_url": "https://api.github.com/users/colesbury/received_events", "type": "User", "site_admin": false}, "body": "This looks wrong to me. Consider this sequence of calls:\r\n\r\n```\r\nDeviceGuard guard;\r\nguard.set_device(/*CPU*/);\r\nguard.set_device(1);\r\n```\r\n\r\nWhen the DeviceGuard is destroyed, it won't restore the correct CUDA device because original_device will be a CPU device.", "created_at": "2018-06-14T18:58:41Z", "updated_at": "2018-11-23T15:45:34Z", "html_url": "https://github.com/pytorch/pytorch/pull/7869#discussion_r195536106", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/7869", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/195536106"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/7869#discussion_r195536106"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/7869"}}, "body_html": "<p>This looks wrong to me. Consider this sequence of calls:</p>\n<pre><code>DeviceGuard guard;\nguard.set_device(/*CPU*/);\nguard.set_device(1);\n</code></pre>\n<p>When the DeviceGuard is destroyed, it won't restore the correct CUDA device because original_device will be a CPU device.</p>", "body_text": "This looks wrong to me. Consider this sequence of calls:\nDeviceGuard guard;\nguard.set_device(/*CPU*/);\nguard.set_device(1);\n\nWhen the DeviceGuard is destroyed, it won't restore the correct CUDA device because original_device will be a CPU device."}