{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/396374349", "html_url": "https://github.com/pytorch/pytorch/pull/7869#issuecomment-396374349", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/7869", "id": 396374349, "node_id": "MDEyOklzc3VlQ29tbWVudDM5NjM3NDM0OQ==", "user": {"login": "colesbury", "id": 655866, "node_id": "MDQ6VXNlcjY1NTg2Ng==", "avatar_url": "https://avatars1.githubusercontent.com/u/655866?v=4", "gravatar_id": "", "url": "https://api.github.com/users/colesbury", "html_url": "https://github.com/colesbury", "followers_url": "https://api.github.com/users/colesbury/followers", "following_url": "https://api.github.com/users/colesbury/following{/other_user}", "gists_url": "https://api.github.com/users/colesbury/gists{/gist_id}", "starred_url": "https://api.github.com/users/colesbury/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/colesbury/subscriptions", "organizations_url": "https://api.github.com/users/colesbury/orgs", "repos_url": "https://api.github.com/users/colesbury/repos", "events_url": "https://api.github.com/users/colesbury/events{/privacy}", "received_events_url": "https://api.github.com/users/colesbury/received_events", "type": "User", "site_admin": false}, "created_at": "2018-06-11T20:23:02Z", "updated_at": "2018-06-11T20:26:22Z", "author_association": "MEMBER", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=6429851\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/goldsborough\">@goldsborough</a>, I don't have a better idea other than a global hook sort of like DynamicCUDAInterface. This isn't great, but it mostly remains an implementation detail that I imagine will get better with C10. I'm curious about <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=370202\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/zdevito\">@zdevito</a>'s opinion.</p>\n<p>As a minor note, there are currently two TensorOption functions that depend on Variable behavior: type() and apply(). You can just have one: <code>Tensor wrap(Tensor)</code>. The <code>type()</code> function could always return the non-Variable Tensor type and <code>Tensor wrap(Tensor)</code> would wrap it in a Variable and set requires_grad if necessary. This isn't too important, it just avoids the <code>set_version_counter(0)</code>.</p>\n<p>I think a single <code>TensorOption</code> struct will segue more easily into C10 as well, which won't have the same stratification between Variable/Tensor. (cc <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=13564\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/ezyang\">@ezyang</a>, correct me if I'm wrong).</p>", "body_text": "@goldsborough, I don't have a better idea other than a global hook sort of like DynamicCUDAInterface. This isn't great, but it mostly remains an implementation detail that I imagine will get better with C10. I'm curious about @zdevito's opinion.\nAs a minor note, there are currently two TensorOption functions that depend on Variable behavior: type() and apply(). You can just have one: Tensor wrap(Tensor). The type() function could always return the non-Variable Tensor type and Tensor wrap(Tensor) would wrap it in a Variable and set requires_grad if necessary. This isn't too important, it just avoids the set_version_counter(0).\nI think a single TensorOption struct will segue more easily into C10 as well, which won't have the same stratification between Variable/Tensor. (cc @ezyang, correct me if I'm wrong).", "body": "@goldsborough, I don't have a better idea other than a global hook sort of like DynamicCUDAInterface. This isn't great, but it mostly remains an implementation detail that I imagine will get better with C10. I'm curious about @zdevito's opinion.\r\n\r\nAs a minor note, there are currently two TensorOption functions that depend on Variable behavior: type() and apply(). You can just have one: `Tensor wrap(Tensor)`. The `type()` function could always return the non-Variable Tensor type and `Tensor wrap(Tensor)` would wrap it in a Variable and set requires_grad if necessary. This isn't too important, it just avoids the `set_version_counter(0)`.\r\n\r\nI think a single `TensorOption` struct will segue more easily into C10 as well, which won't have the same stratification between Variable/Tensor. (cc @ezyang, correct me if I'm wrong)."}