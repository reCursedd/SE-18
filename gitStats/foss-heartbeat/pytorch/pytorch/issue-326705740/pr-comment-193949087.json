{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/193949087", "pull_request_review_id": 127026150, "id": 193949087, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5Mzk0OTA4Nw==", "diff_hunk": "@@ -0,0 +1,135 @@\n+#pragma once\n+\n+#include <ATen/Device.h>\n+#include <ATen/Layout.h>\n+#include <ATen/ScalarType.h>\n+#include <ATen/optional.h>\n+\n+#include <cstddef>\n+\n+namespace at {\n+struct Type;\n+struct Tensor;\n+} // namespace at\n+\n+namespace at {\n+\n+/// A class to encapsulate construction axes of a `Tensor`.\n+/// `TensorOptions` is a virtual class to enable overriding of certain methods\n+/// by subclasses in other libraries, such as PyTorch. In PyTorch, there is a\n+/// `torch::TensorOptions` subclass of this `TensorOptions`, which changes\n+/// `type()` to return a variable type instead of a tensor type, such that\n+/// variables are created inside factory methods, instead of tensors.\n+/// Furthermore, it changes `apply` to perform certain post-creation steps, such\n+/// as setting the `requires_grad` property of a `Variable`.\n+struct TensorOptions {\n+  /// Constructs the `TensorOptions` with valid defaults, which are:\n+  /// - dtype: float\n+  /// - device: CPU\n+  /// - layout: strided\n+  TensorOptions() = default;\n+\n+  /// Constructs the `TensorOptions` from the type of the given `Tensor`.\n+  /// If the `Tensor` has a CUDA type, the `device_index` will match that of the\n+  /// tensor. See the constructor from `Type` for the semantics w.r.t. the\n+  /// `type()` method.\n+  explicit TensorOptions(Tensor tensor);\n+\n+  /// Constructs the `TensorOptions` from a type and optional `device_index`.\n+  ///\n+  /// NOTE: This changes the behavior of `TensorOptions::type()` in that it will", "path": "aten/src/ATen/TensorOptions.h", "position": null, "original_position": 40, "commit_id": "c5b2af6a950b67445ad8916d364fd24456d7aa39", "original_commit_id": "c760d1cdac573d758f59013d06d1ae773a91bd26", "user": {"login": "zdevito", "id": 370202, "node_id": "MDQ6VXNlcjM3MDIwMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/370202?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zdevito", "html_url": "https://github.com/zdevito", "followers_url": "https://api.github.com/users/zdevito/followers", "following_url": "https://api.github.com/users/zdevito/following{/other_user}", "gists_url": "https://api.github.com/users/zdevito/gists{/gist_id}", "starred_url": "https://api.github.com/users/zdevito/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zdevito/subscriptions", "organizations_url": "https://api.github.com/users/zdevito/orgs", "repos_url": "https://api.github.com/users/zdevito/repos", "events_url": "https://api.github.com/users/zdevito/events{/privacy}", "received_events_url": "https://api.github.com/users/zdevito/received_events", "type": "User", "site_admin": false}, "body": "This is pretty subtle and gets to a tension with TensorOptions: should the TensorOptions struct fully specify the dynamic type of the tensor. Eventually TensorOptions will gain `requires_grad` as well. In that case, the answer will be yes: it fully specifies the type to construct. However, if a external subclass of  Tensor is introduced, then there will be no way to use constructors like `ones` with it.  Maybe this is ok, and I think this behavior is acceptable for now, but if you have suggestions for how to think about which types get to go into TensorOptions and which do not, I'd be interested in hearing about it.", "created_at": "2018-06-08T04:17:48Z", "updated_at": "2018-11-23T15:45:14Z", "html_url": "https://github.com/pytorch/pytorch/pull/7869#discussion_r193949087", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/7869", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/193949087"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/7869#discussion_r193949087"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/7869"}}, "body_html": "<p>This is pretty subtle and gets to a tension with TensorOptions: should the TensorOptions struct fully specify the dynamic type of the tensor. Eventually TensorOptions will gain <code>requires_grad</code> as well. In that case, the answer will be yes: it fully specifies the type to construct. However, if a external subclass of  Tensor is introduced, then there will be no way to use constructors like <code>ones</code> with it.  Maybe this is ok, and I think this behavior is acceptable for now, but if you have suggestions for how to think about which types get to go into TensorOptions and which do not, I'd be interested in hearing about it.</p>", "body_text": "This is pretty subtle and gets to a tension with TensorOptions: should the TensorOptions struct fully specify the dynamic type of the tensor. Eventually TensorOptions will gain requires_grad as well. In that case, the answer will be yes: it fully specifies the type to construct. However, if a external subclass of  Tensor is introduced, then there will be no way to use constructors like ones with it.  Maybe this is ok, and I think this behavior is acceptable for now, but if you have suggestions for how to think about which types get to go into TensorOptions and which do not, I'd be interested in hearing about it."}