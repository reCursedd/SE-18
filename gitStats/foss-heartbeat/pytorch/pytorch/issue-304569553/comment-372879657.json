{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/372879657", "html_url": "https://github.com/pytorch/pytorch/pull/5723#issuecomment-372879657", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/5723", "id": 372879657, "node_id": "MDEyOklzc3VlQ29tbWVudDM3Mjg3OTY1Nw==", "user": {"login": "cpuhrsch", "id": 1716488, "node_id": "MDQ6VXNlcjE3MTY0ODg=", "avatar_url": "https://avatars1.githubusercontent.com/u/1716488?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cpuhrsch", "html_url": "https://github.com/cpuhrsch", "followers_url": "https://api.github.com/users/cpuhrsch/followers", "following_url": "https://api.github.com/users/cpuhrsch/following{/other_user}", "gists_url": "https://api.github.com/users/cpuhrsch/gists{/gist_id}", "starred_url": "https://api.github.com/users/cpuhrsch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cpuhrsch/subscriptions", "organizations_url": "https://api.github.com/users/cpuhrsch/orgs", "repos_url": "https://api.github.com/users/cpuhrsch/repos", "events_url": "https://api.github.com/users/cpuhrsch/events{/privacy}", "received_events_url": "https://api.github.com/users/cpuhrsch/received_events", "type": "User", "site_admin": false}, "created_at": "2018-03-14T02:02:00Z", "updated_at": "2018-03-14T02:02:00Z", "author_association": "CONTRIBUTOR", "body_html": "<p>We came upon one issues related to std::thread and tbb. When running e.g. sum within a std::thread, the number of threads chosen will not be respected. So, even if I launch the problem with OMP_NUM_THREADS=1, the std::thread will use the default (all available cores). This causes issues with autograd (engine.cpp). The proposed solution is to only set the number of threads and then have this global variable be read by the respective threads. Then you create a static tbb init object within each parallel function that will initialize itself with the current number of threads. This object is updated only if the number of threads has been changed. There does not appear to be any noticeable performance penalty for this and it also appears to resolve the issue.</p>", "body_text": "We came upon one issues related to std::thread and tbb. When running e.g. sum within a std::thread, the number of threads chosen will not be respected. So, even if I launch the problem with OMP_NUM_THREADS=1, the std::thread will use the default (all available cores). This causes issues with autograd (engine.cpp). The proposed solution is to only set the number of threads and then have this global variable be read by the respective threads. Then you create a static tbb init object within each parallel function that will initialize itself with the current number of threads. This object is updated only if the number of threads has been changed. There does not appear to be any noticeable performance penalty for this and it also appears to resolve the issue.", "body": "We came upon one issues related to std::thread and tbb. When running e.g. sum within a std::thread, the number of threads chosen will not be respected. So, even if I launch the problem with OMP_NUM_THREADS=1, the std::thread will use the default (all available cores). This causes issues with autograd (engine.cpp). The proposed solution is to only set the number of threads and then have this global variable be read by the respective threads. Then you create a static tbb init object within each parallel function that will initialize itself with the current number of threads. This object is updated only if the number of threads has been changed. There does not appear to be any noticeable performance penalty for this and it also appears to resolve the issue."}