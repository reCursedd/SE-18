{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/198291875", "pull_request_review_id": 132197887, "id": 198291875, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODI5MTg3NQ==", "diff_hunk": "@@ -0,0 +1,190 @@\n+#pragma once\n+\n+#include <unordered_map>\n+\n+#include \"onnx/onnx_pb.h\"\n+#include \"onnx/onnxifi.h\"\n+\n+#include \"caffe2/core/context.h\"\n+#include \"caffe2/core/logging.h\"\n+#include \"caffe2/core/operator.h\"\n+#include \"caffe2/onnx/onnxifi_manager.h\"\n+#include \"caffe2/utils/string_utils.h\"\n+\n+namespace caffe2 {\n+\n+template <typename T, typename Context>\n+class OnnxifiOp final : public Operator<Context> {\n+ public:\n+  USE_OPERATOR_CONTEXT_FUNCTIONS;\n+  OnnxifiOp(const OperatorDef& operator_def, Workspace* ws)\n+      : Operator<Context>(operator_def, ws) {\n+    onnxifi_backend_ =\n+        OperatorBase::GetSingleArgument<std::string>(\"onnxifi_backend\", \"\");\n+    CAFFE_ENFORCE(!onnxifi_backend_.empty(), \"Unspecified onnxifi_backend\");\n+    auto* onnxifi_manager = onnx::OnnxifiManager::get_onnxifi_manager();\n+    lib_ = onnxifi_manager->AddOnnxifiLibrary(onnxifi_backend_);\n+    auto onnx_model_str =\n+        OperatorBase::GetSingleArgument<std::string>(\"onnx_model\", \"\");\n+    CAFFE_ENFORCE(!onnx_model_str.empty(), \"onnx_model cannot be empty\");\n+\n+    // Setup input/output descriptor templates\n+    for (const auto& input : operator_def.input()) {\n+      input_desc_.push_back(onnxTensorDescriptor());\n+      input_desc_.back().name = input.c_str();\n+    }\n+    int output_idx = 0;\n+    for (const auto& output : operator_def.output()) {\n+      output_desc_.push_back(onnxTensorDescriptor());\n+      output_desc_.back().name = output.c_str();\n+\n+      // For output, we try to get its output size hint\n+      const std::string key = MakeString(\"output_size_hint_\", output_idx);\n+      auto output_size_hint = OperatorBase::GetRepeatedArgument<int>(key);\n+      if (!output_size_hint.empty()) {\n+        std::vector<TIndex> dims;\n+        for (const auto v : output_size_hint) {\n+          dims.push_back(v);\n+        }\n+        output_size_hints_.emplace(output_idx, std::move(dims));\n+      }\n+      ++output_idx;\n+    }\n+\n+    // Encode arguments starting with \"custom_\" to backend\n+    std::vector<uint64_t> property_pointers;\n+    std::vector<int64_t> int_args;\n+    std::vector<float> float_args;\n+    BuildPropertyList(operator_def, &property_pointers, &int_args, &float_args);\n+\n+    // Pull the weights from workspace and feed it to the backend through\n+    // setGraphIO. Notice that since we may have rewritten the net, we need to\n+    // map the weight names\n+    auto initializers =\n+        OperatorBase::GetRepeatedArgument<std::string>(\"initializers\");\n+    CAFFE_ENFORCE_EQ(\n+        initializers.size() % 2, 0, \"initializers should come in pairs\");\n+    std::unordered_set<std::string> initializer_set;\n+    std::unordered_map<std::string, std::string> input_mapping;\n+    for (auto it = initializers.begin(); it != initializers.end(); ++it) {\n+      auto key = *it++;\n+      input_mapping.emplace(key, *it);\n+      initializer_set.emplace(key);\n+    }\n+    Workspace mapped_ws(ws, input_mapping);\n+    std::vector<std::string> weight_names;\n+    std::vector<std::vector<uint64_t>> weight_shapes;\n+    auto weight_descs = BuildInitializationList(\n+        &mapped_ws, &initializer_set, &weight_names, &weight_shapes);\n+\n+    ::ONNX_NAMESPACE::ModelProto onnx_model;\n+    ParseProtoFromLargeString(onnx_model_str, &onnx_model);\n+    onnx_model_str.clear();\n+    onnx_model.SerializeToString(&onnx_model_str);\n+\n+    // Build the Onnxifi engine\n+    CAFFE_ENFORCE_EQ(\n+        lib_->onnxGetBackendIDs(backend_ids_, &num_backends_),\n+        ONNXIFI_STATUS_SUCCESS);\n+    CAFFE_ENFORCE_LT(\n+        num_backends_, 0, \"At least 1 onnxifi backend should be available\");\n+    // TODO: choose backedn id\n+    CAFFE_ENFORCE_EQ(\n+        lib_->onnxInitBackend(backend_ids_[0], property_pointers.data(), &backend_),\n+        ONNXIFI_STATUS_SUCCESS);\n+    CAFFE_ENFORCE_EQ(\n+        lib_->onnxInitGraph(\n+            backend_,\n+            onnx_model_str.size(),\n+            (void*)(onnx_model_str.c_str()),\n+            weight_descs.size(),\n+            weight_descs.data(),\n+            &graph_),\n+        ONNXIFI_STATUS_SUCCESS);\n+  }\n+\n+  ~OnnxifiOp() {\n+    if (graph_) {\n+      CAFFE_ENFORCE_EQ(lib_->onnxReleaseGraph(graph_), ONNXIFI_STATUS_SUCCESS);\n+      graph_ = nullptr;\n+    }\n+    if (backend_) {\n+      CAFFE_ENFORCE_EQ(\n+          lib_->onnxReleaseBackend(backend_), ONNXIFI_STATUS_SUCCESS);\n+      backend_ = nullptr;\n+    }\n+    for (unsigned i = 0U; i < num_backends_; ++i) {\n+      CAFFE_ENFORCE_EQ(\n+          lib_->onnxReleaseBackendID(backend_ids_[i]), ONNXIFI_STATUS_SUCCESS);\n+    }\n+    backend_ids_ = nullptr;\n+  }\n+\n+  bool RunOnDevice() override;\n+\n+ private:\n+  void SetOutputShape(int output_idx, std::vector<TIndex>* dims) {\n+    const auto it = output_size_hints_.find(output_idx);\n+    if (it != output_size_hints_.end()) {\n+      *dims = it->second;\n+    }\n+  }\n+\n+  void BuildPropertyList(\n+      const OperatorDef& operator_def,\n+      std::vector<uint64_t>* property_list,\n+      std::vector<int64_t>* int_args,\n+      std::vector<float>* float_args) {\n+    for (const auto& arg: operator_def.arg()) {\n+      if (!StartsWith(arg.name(), \"custom_\")) {\n+        continue;\n+      }\n+      // Pick the name as ABC if the arg name is custom_ABC\n+      property_list->push_back((uint64_t)(arg.name().c_str() + 7));", "path": "caffe2/operators/onnxifi_op.h", "position": null, "original_position": 143, "commit_id": "d441bb622ebb16bcc309e6ffb07b51ed43f161ce", "original_commit_id": "debb55005fa6b7de47d4aaad7a306ef58c7e075f", "user": {"login": "Maratyszcza", "id": 1093985, "node_id": "MDQ6VXNlcjEwOTM5ODU=", "avatar_url": "https://avatars1.githubusercontent.com/u/1093985?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Maratyszcza", "html_url": "https://github.com/Maratyszcza", "followers_url": "https://api.github.com/users/Maratyszcza/followers", "following_url": "https://api.github.com/users/Maratyszcza/following{/other_user}", "gists_url": "https://api.github.com/users/Maratyszcza/gists{/gist_id}", "starred_url": "https://api.github.com/users/Maratyszcza/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Maratyszcza/subscriptions", "organizations_url": "https://api.github.com/users/Maratyszcza/orgs", "repos_url": "https://api.github.com/users/Maratyszcza/repos", "events_url": "https://api.github.com/users/Maratyszcza/events{/privacy}", "received_events_url": "https://api.github.com/users/Maratyszcza/received_events", "type": "User", "site_admin": false}, "body": "`property_list` isn't intended for passing arbitrary properties by string key. If you need to pass any non-standard property, define a constant `ONNXIFI_BACKEND_PROPERTY_SOMETHING` for the key.", "created_at": "2018-06-26T20:46:22Z", "updated_at": "2018-11-23T15:46:24Z", "html_url": "https://github.com/pytorch/pytorch/pull/8749#discussion_r198291875", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/8749", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/198291875"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/8749#discussion_r198291875"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/8749"}}, "body_html": "<p><code>property_list</code> isn't intended for passing arbitrary properties by string key. If you need to pass any non-standard property, define a constant <code>ONNXIFI_BACKEND_PROPERTY_SOMETHING</code> for the key.</p>", "body_text": "property_list isn't intended for passing arbitrary properties by string key. If you need to pass any non-standard property, define a constant ONNXIFI_BACKEND_PROPERTY_SOMETHING for the key."}