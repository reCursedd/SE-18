{"url": "https://api.github.com/repos/pytorch/pytorch/issues/5460", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/5460/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/5460/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/5460/events", "html_url": "https://github.com/pytorch/pytorch/issues/5460", "id": 301096010, "node_id": "MDU6SXNzdWUzMDEwOTYwMTA=", "number": 5460, "title": "Rework how symbolic override works", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 693805995, "node_id": "MDU6TGFiZWw2OTM4MDU5OTU=", "url": "https://api.github.com/repos/pytorch/pytorch/labels/onnx", "name": "onnx", "color": "e99695", "default": false}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2018-02-28T16:40:09Z", "updated_at": "2018-03-01T22:26:23Z", "closed_at": null, "author_association": "CONTRIBUTOR", "body_html": "<p>Motivation: we want to write all of our traces like this:</p>\n<div class=\"highlight highlight-source-python\"><pre>    <span class=\"pl-k\">def</span> <span class=\"pl-en\">f_symbolic</span>(<span class=\"pl-smi\">g</span>, <span class=\"pl-smi\">val1</span>, <span class=\"pl-smi\">val2</span>, <span class=\"pl-smi\">bool_flag</span>):\n        <span class=\"pl-k\">return</span> g.op(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>F<span class=\"pl-pds\">\"</span></span>, val1, val2)\n\n    <span class=\"pl-en\">@symbolic</span>(f_symbolic)\n    <span class=\"pl-k\">def</span> <span class=\"pl-en\">f</span>(<span class=\"pl-smi\">var1</span>, <span class=\"pl-smi\">var2</span>, <span class=\"pl-smi\">bool_flag</span>):\n        <span class=\"pl-c1\">...</span>\n        <span class=\"pl-k\">return</span> <span class=\"pl-c1\">...</span></pre></div>\n<p>How it improves over the current situation:</p>\n<ul>\n<li>We want to STOP inlining the \"is-tracing\" test.  This is<br>\nimplementation details and we don't want it splattered all over<br>\nuserspace.</li>\n<li>We want to be able to wrap functions which take non-Variable<br>\narguments (such that you aren't induced to do refactors<br>\nlike in <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"300416726\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/5420\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/pytorch/pytorch/pull/5420/hovercard\" href=\"https://github.com/pytorch/pytorch/pull/5420\">#5420</a> ).</li>\n</ul>\n<p>Current call sites:</p>\n<ul>\n<li>RNNs <code>torch/nn/_functions/rnn.py</code>  (this site is special, cannot<br>\ninstrument function because there is a factory)\n<ul>\n<li>It would probably suffice to instrument CudnnRNN and<br>\nAutogradRNN separately</li>\n</ul>\n</li>\n<li><code>pack_padded_sequence</code> (inlined \"is-tracing\" test)\n<ul>\n<li>I don't understand, this seems to pass non-Variable through?<br>\n(did it just not work???)</li>\n</ul>\n</li>\n<li><code>pad_packed_sequence</code></li>\n<li><code>instance_norm</code>. This is done as inner function.\n<ul>\n<li>We need the defaults; handle this using getargspec</li>\n<li>We want some operations handled outside (so we get tracing<br>\nfor them automatically).  This is legit (but don't do<br>\ninner function.)</li>\n<li>(Ditto, seems to use attributes)</li>\n</ul>\n</li>\n</ul>\n<p>Experiment:</p>\n<ul>\n<li>How much is the decorator overhead?  If it is trivial, stop inlining<br>\ndecorator test.</li>\n</ul>\n<p>Constraints:</p>\n<ul>\n<li>Some functions may pass Variables in non-trivial data structures<br>\n(not possible to write <em>generic</em> argument parser which can unambiguously<br>\nidentify all variables).  But this is not the common case.</li>\n</ul>\n<p>CC <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=1388690\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/anderspapitto\">@anderspapitto</a></p>", "body_text": "Motivation: we want to write all of our traces like this:\n    def f_symbolic(g, val1, val2, bool_flag):\n        return g.op(\"F\", val1, val2)\n\n    @symbolic(f_symbolic)\n    def f(var1, var2, bool_flag):\n        ...\n        return ...\nHow it improves over the current situation:\n\nWe want to STOP inlining the \"is-tracing\" test.  This is\nimplementation details and we don't want it splattered all over\nuserspace.\nWe want to be able to wrap functions which take non-Variable\narguments (such that you aren't induced to do refactors\nlike in #5420 ).\n\nCurrent call sites:\n\nRNNs torch/nn/_functions/rnn.py  (this site is special, cannot\ninstrument function because there is a factory)\n\nIt would probably suffice to instrument CudnnRNN and\nAutogradRNN separately\n\n\npack_padded_sequence (inlined \"is-tracing\" test)\n\nI don't understand, this seems to pass non-Variable through?\n(did it just not work???)\n\n\npad_packed_sequence\ninstance_norm. This is done as inner function.\n\nWe need the defaults; handle this using getargspec\nWe want some operations handled outside (so we get tracing\nfor them automatically).  This is legit (but don't do\ninner function.)\n(Ditto, seems to use attributes)\n\n\n\nExperiment:\n\nHow much is the decorator overhead?  If it is trivial, stop inlining\ndecorator test.\n\nConstraints:\n\nSome functions may pass Variables in non-trivial data structures\n(not possible to write generic argument parser which can unambiguously\nidentify all variables).  But this is not the common case.\n\nCC @anderspapitto", "body": "Motivation: we want to write all of our traces like this:\r\n\r\n```python\r\n    def f_symbolic(g, val1, val2, bool_flag):\r\n        return g.op(\"F\", val1, val2)\r\n\r\n    @symbolic(f_symbolic)\r\n    def f(var1, var2, bool_flag):\r\n        ...\r\n        return ...\r\n```\r\n\r\nHow it improves over the current situation:\r\n\r\n- We want to STOP inlining the \"is-tracing\" test.  This is\r\n  implementation details and we don't want it splattered all over\r\n  userspace.\r\n- We want to be able to wrap functions which take non-Variable\r\n  arguments (such that you aren't induced to do refactors\r\n  like in https://github.com/pytorch/pytorch/pull/5420 ).\r\n\r\nCurrent call sites:\r\n- RNNs `torch/nn/_functions/rnn.py`  (this site is special, cannot\r\n  instrument function because there is a factory)\r\n    - It would probably suffice to instrument CudnnRNN and\r\n      AutogradRNN separately\r\n- `pack_padded_sequence` (inlined \"is-tracing\" test)\r\n    - I don't understand, this seems to pass non-Variable through?\r\n      (did it just not work???)\r\n- `pad_packed_sequence`\r\n- `instance_norm`. This is done as inner function.\r\n    - We need the defaults; handle this using getargspec\r\n    - We want some operations handled outside (so we get tracing\r\n      for them automatically).  This is legit (but don't do\r\n      inner function.)\r\n    - (Ditto, seems to use attributes)\r\n\r\nExperiment:\r\n- How much is the decorator overhead?  If it is trivial, stop inlining\r\n  decorator test.\r\n\r\nConstraints:\r\n- Some functions may pass Variables in non-trivial data structures\r\n  (not possible to write *generic* argument parser which can unambiguously\r\n  identify all variables).  But this is not the common case.\r\n\r\nCC @anderspapitto "}