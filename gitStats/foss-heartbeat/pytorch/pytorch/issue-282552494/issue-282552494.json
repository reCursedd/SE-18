{"url": "https://api.github.com/repos/pytorch/pytorch/issues/4201", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/4201/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/4201/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/4201/events", "html_url": "https://github.com/pytorch/pytorch/pull/4201", "id": 282552494, "node_id": "MDExOlB1bGxSZXF1ZXN0MTU4Njk3Mjc5", "number": 4201, "title": "Refactor cudnn code layout / make build more robust.", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2017-12-15T21:27:50Z", "updated_at": "2018-11-23T15:37:30Z", "closed_at": "2017-12-18T21:47:58Z", "author_association": "CONTRIBUTOR", "pull_request": {"url": "https://api.github.com/repos/pytorch/pytorch/pulls/4201", "html_url": "https://github.com/pytorch/pytorch/pull/4201", "diff_url": "https://github.com/pytorch/pytorch/pull/4201.diff", "patch_url": "https://github.com/pytorch/pytorch/pull/4201.patch"}, "body_html": "<p>When I previously moved cuDNN into ATen, I wasn't too familiar with the<br>\nATen native function directory layout, and so I did a number of<br>\nsuboptimal things.  This commit fixes those problems.</p>\n<ul>\n<li>\n<p>If NO_CUDA was set but cuDNN is installed on your system, we'd incorrectly<br>\nassume that CUDNN was enabled, to hilarious effect.</p>\n</li>\n<li>\n<p>We now distinguish between cudnn implementation files and cudnn<br>\nnative function files.  The native files now live in ATen/native/cudnn,<br>\nand are <em>unconditionally compiled</em>, even when we are not building with cuDNN.<br>\nThis means that we can unconditionally declare cudnn functions in yaml<br>\nand they are always available, even if they are broken.  The cuDNN specific<br>\nfiles live in 'cudnn', they are <em>never</em> installed, and they are used<br>\npurely for implementation purposes.  I had to add stub implementations of<br>\nall ATen functions to achieve this.</p>\n</li>\n<li>\n<p>I had written headers for at::native functions manually, but codegen<br>\nwill generate them for me automatically.  So I deleted the headers.<br>\nThat lets me get rid of some header install logic as well.</p>\n</li>\n<li>\n<p>There's a new note about ATen preprocessor philosophy.</p>\n</li>\n</ul>\n<p>Signed-off-by: Edward Z. Yang <a href=\"mailto:ezyang@fb.com\">ezyang@fb.com</a></p>", "body_text": "When I previously moved cuDNN into ATen, I wasn't too familiar with the\nATen native function directory layout, and so I did a number of\nsuboptimal things.  This commit fixes those problems.\n\n\nIf NO_CUDA was set but cuDNN is installed on your system, we'd incorrectly\nassume that CUDNN was enabled, to hilarious effect.\n\n\nWe now distinguish between cudnn implementation files and cudnn\nnative function files.  The native files now live in ATen/native/cudnn,\nand are unconditionally compiled, even when we are not building with cuDNN.\nThis means that we can unconditionally declare cudnn functions in yaml\nand they are always available, even if they are broken.  The cuDNN specific\nfiles live in 'cudnn', they are never installed, and they are used\npurely for implementation purposes.  I had to add stub implementations of\nall ATen functions to achieve this.\n\n\nI had written headers for at::native functions manually, but codegen\nwill generate them for me automatically.  So I deleted the headers.\nThat lets me get rid of some header install logic as well.\n\n\nThere's a new note about ATen preprocessor philosophy.\n\n\nSigned-off-by: Edward Z. Yang ezyang@fb.com", "body": "When I previously moved cuDNN into ATen, I wasn't too familiar with the\r\nATen native function directory layout, and so I did a number of\r\nsuboptimal things.  This commit fixes those problems.\r\n\r\n- If NO_CUDA was set but cuDNN is installed on your system, we'd incorrectly\r\n  assume that CUDNN was enabled, to hilarious effect.\r\n\r\n- We now distinguish between cudnn implementation files and cudnn\r\n  native function files.  The native files now live in ATen/native/cudnn,\r\n  and are *unconditionally compiled*, even when we are not building with cuDNN.\r\n  This means that we can unconditionally declare cudnn functions in yaml\r\n  and they are always available, even if they are broken.  The cuDNN specific\r\n  files live in 'cudnn', they are *never* installed, and they are used\r\n  purely for implementation purposes.  I had to add stub implementations of\r\n  all ATen functions to achieve this.\r\n\r\n- I had written headers for at::native functions manually, but codegen\r\n  will generate them for me automatically.  So I deleted the headers.\r\n  That lets me get rid of some header install logic as well.\r\n\r\n- There's a new note about ATen preprocessor philosophy.\r\n\r\nSigned-off-by: Edward Z. Yang <ezyang@fb.com>"}