{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/388916994", "html_url": "https://github.com/pytorch/pytorch/issues/7278#issuecomment-388916994", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/7278", "id": 388916994, "node_id": "MDEyOklzc3VlQ29tbWVudDM4ODkxNjk5NA==", "user": {"login": "sethah", "id": 7275795, "node_id": "MDQ6VXNlcjcyNzU3OTU=", "avatar_url": "https://avatars2.githubusercontent.com/u/7275795?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sethah", "html_url": "https://github.com/sethah", "followers_url": "https://api.github.com/users/sethah/followers", "following_url": "https://api.github.com/users/sethah/following{/other_user}", "gists_url": "https://api.github.com/users/sethah/gists{/gist_id}", "starred_url": "https://api.github.com/users/sethah/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sethah/subscriptions", "organizations_url": "https://api.github.com/users/sethah/orgs", "repos_url": "https://api.github.com/users/sethah/repos", "events_url": "https://api.github.com/users/sethah/events{/privacy}", "received_events_url": "https://api.github.com/users/sethah/received_events", "type": "User", "site_admin": false}, "created_at": "2018-05-14T18:29:38Z", "updated_at": "2018-05-14T18:29:38Z", "author_association": "CONTRIBUTOR", "body_html": "<p>The issue occurs in <code>static std::vector&lt;int64_t&gt; compute_sizes(PyObject* seq)</code> in <code>csrc-&gt;utils</code> file. This method tries to get the size of the would be tensor by taking the length of the first element in the sequence as long as it can. So for a (3x2x4) numpy array, for example, it would get the sizes by essentially doing:</p>\n<div class=\"highlight highlight-source-python\"><pre>dim1 <span class=\"pl-k\">=</span> <span class=\"pl-c1\">len</span>(seq)\ndim2 <span class=\"pl-k\">=</span> <span class=\"pl-c1\">len</span>(seq[<span class=\"pl-c1\">0</span>])\ndim3 <span class=\"pl-k\">=</span> <span class=\"pl-c1\">len</span>(seq[<span class=\"pl-c1\">0</span>][<span class=\"pl-c1\">0</span>])</pre></div>\n<p>For a pandas series, the call to <code>PySequence_GetItem(seq, 0)</code> sometimes succeeds, as long as 0 is in the index of the series. It's the same as doing <code>seq[0]</code> on a pandas series. In the case above that fails you can see that zero is not in the index:</p>\n<pre><code>In [4]: seq[1:]\nOut[4]: \n1    0.2\n2    0.3\ndtype: float64\n\nIn [5]: seq[1:][0]\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\n&lt;ipython-input-5-a6bd6280d307&gt; in &lt;module&gt;()\n----&gt; 1 seq[1:][0]\n\n~/anaconda2/envs/torchdev/lib/python3.6/site-packages/pandas/core/series.py in __getitem__(self, key)\n    621         key = com._apply_if_callable(key, self)\n    622         try:\n--&gt; 623             result = self.index.get_value(self, key)\n    624 \n    625             if not is_scalar(result):\n\n~/anaconda2/envs/torchdev/lib/python3.6/site-packages/pandas/core/indexes/base.py in get_value(self, series, key)\n   2558         try:\n   2559             return self._engine.get_value(s, k,\n-&gt; 2560                                           tz=getattr(series.dtype, 'tz', None))\n   2561         except KeyError as e1:\n   2562             if len(self) &gt; 0 and self.inferred_type in ['integer', 'boolean']:\n\npandas/_libs/index.pyx in pandas._libs.index.IndexEngine.get_value()\n\npandas/_libs/index.pyx in pandas._libs.index.IndexEngine.get_value()\n\npandas/_libs/index.pyx in pandas._libs.index.IndexEngine.get_loc()\n\npandas/_libs/hashtable_class_helper.pxi in pandas._libs.hashtable.Int64HashTable.get_item()\n\npandas/_libs/hashtable_class_helper.pxi in pandas._libs.hashtable.Int64HashTable.get_item()\n\nKeyError: 0\n</code></pre>\n<p>When called directly from C++, this will result in a segmentation fault. It's worth noting that the same thing happens with a pandas dataframe:</p>\n<pre><code>In [12]: df = pd.DataFrame(np.random.normal(0, 1, (2, 3)), columns=['a', 'b', 'c'])\n\nIn [13]: t = torch.FloatTensor(df)\nSegmentation fault: 11\n</code></pre>\n<p>The inherent problem is that <code>PySequence_Check</code> is <code>True</code> on a pandas dataframe, and the <code>PySequence_Length(seq)</code> returns something greater than zero, but <code>PySequence_GetItem</code> tries to find the zeroth element of the index, which may not exist. I'd be happy to look into a solution for this.</p>", "body_text": "The issue occurs in static std::vector<int64_t> compute_sizes(PyObject* seq) in csrc->utils file. This method tries to get the size of the would be tensor by taking the length of the first element in the sequence as long as it can. So for a (3x2x4) numpy array, for example, it would get the sizes by essentially doing:\ndim1 = len(seq)\ndim2 = len(seq[0])\ndim3 = len(seq[0][0])\nFor a pandas series, the call to PySequence_GetItem(seq, 0) sometimes succeeds, as long as 0 is in the index of the series. It's the same as doing seq[0] on a pandas series. In the case above that fails you can see that zero is not in the index:\nIn [4]: seq[1:]\nOut[4]: \n1    0.2\n2    0.3\ndtype: float64\n\nIn [5]: seq[1:][0]\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\n<ipython-input-5-a6bd6280d307> in <module>()\n----> 1 seq[1:][0]\n\n~/anaconda2/envs/torchdev/lib/python3.6/site-packages/pandas/core/series.py in __getitem__(self, key)\n    621         key = com._apply_if_callable(key, self)\n    622         try:\n--> 623             result = self.index.get_value(self, key)\n    624 \n    625             if not is_scalar(result):\n\n~/anaconda2/envs/torchdev/lib/python3.6/site-packages/pandas/core/indexes/base.py in get_value(self, series, key)\n   2558         try:\n   2559             return self._engine.get_value(s, k,\n-> 2560                                           tz=getattr(series.dtype, 'tz', None))\n   2561         except KeyError as e1:\n   2562             if len(self) > 0 and self.inferred_type in ['integer', 'boolean']:\n\npandas/_libs/index.pyx in pandas._libs.index.IndexEngine.get_value()\n\npandas/_libs/index.pyx in pandas._libs.index.IndexEngine.get_value()\n\npandas/_libs/index.pyx in pandas._libs.index.IndexEngine.get_loc()\n\npandas/_libs/hashtable_class_helper.pxi in pandas._libs.hashtable.Int64HashTable.get_item()\n\npandas/_libs/hashtable_class_helper.pxi in pandas._libs.hashtable.Int64HashTable.get_item()\n\nKeyError: 0\n\nWhen called directly from C++, this will result in a segmentation fault. It's worth noting that the same thing happens with a pandas dataframe:\nIn [12]: df = pd.DataFrame(np.random.normal(0, 1, (2, 3)), columns=['a', 'b', 'c'])\n\nIn [13]: t = torch.FloatTensor(df)\nSegmentation fault: 11\n\nThe inherent problem is that PySequence_Check is True on a pandas dataframe, and the PySequence_Length(seq) returns something greater than zero, but PySequence_GetItem tries to find the zeroth element of the index, which may not exist. I'd be happy to look into a solution for this.", "body": "The issue occurs in `static std::vector<int64_t> compute_sizes(PyObject* seq)` in `csrc->utils` file. This method tries to get the size of the would be tensor by taking the length of the first element in the sequence as long as it can. So for a (3x2x4) numpy array, for example, it would get the sizes by essentially doing:\r\n\r\n```python\r\ndim1 = len(seq)\r\ndim2 = len(seq[0])\r\ndim3 = len(seq[0][0])\r\n```\r\n\r\nFor a pandas series, the call to `PySequence_GetItem(seq, 0)` sometimes succeeds, as long as 0 is in the index of the series. It's the same as doing `seq[0]` on a pandas series. In the case above that fails you can see that zero is not in the index:\r\n\r\n```\r\nIn [4]: seq[1:]\r\nOut[4]: \r\n1    0.2\r\n2    0.3\r\ndtype: float64\r\n\r\nIn [5]: seq[1:][0]\r\n---------------------------------------------------------------------------\r\nKeyError                                  Traceback (most recent call last)\r\n<ipython-input-5-a6bd6280d307> in <module>()\r\n----> 1 seq[1:][0]\r\n\r\n~/anaconda2/envs/torchdev/lib/python3.6/site-packages/pandas/core/series.py in __getitem__(self, key)\r\n    621         key = com._apply_if_callable(key, self)\r\n    622         try:\r\n--> 623             result = self.index.get_value(self, key)\r\n    624 \r\n    625             if not is_scalar(result):\r\n\r\n~/anaconda2/envs/torchdev/lib/python3.6/site-packages/pandas/core/indexes/base.py in get_value(self, series, key)\r\n   2558         try:\r\n   2559             return self._engine.get_value(s, k,\r\n-> 2560                                           tz=getattr(series.dtype, 'tz', None))\r\n   2561         except KeyError as e1:\r\n   2562             if len(self) > 0 and self.inferred_type in ['integer', 'boolean']:\r\n\r\npandas/_libs/index.pyx in pandas._libs.index.IndexEngine.get_value()\r\n\r\npandas/_libs/index.pyx in pandas._libs.index.IndexEngine.get_value()\r\n\r\npandas/_libs/index.pyx in pandas._libs.index.IndexEngine.get_loc()\r\n\r\npandas/_libs/hashtable_class_helper.pxi in pandas._libs.hashtable.Int64HashTable.get_item()\r\n\r\npandas/_libs/hashtable_class_helper.pxi in pandas._libs.hashtable.Int64HashTable.get_item()\r\n\r\nKeyError: 0\r\n```\r\n\r\nWhen called directly from C++, this will result in a segmentation fault. It's worth noting that the same thing happens with a pandas dataframe:\r\n\r\n```\r\nIn [12]: df = pd.DataFrame(np.random.normal(0, 1, (2, 3)), columns=['a', 'b', 'c'])\r\n\r\nIn [13]: t = torch.FloatTensor(df)\r\nSegmentation fault: 11\r\n```\r\n\r\nThe inherent problem is that `PySequence_Check` is `True` on a pandas dataframe, and the `PySequence_Length(seq)` returns something greater than zero, but `PySequence_GetItem` tries to find the zeroth element of the index, which may not exist. I'd be happy to look into a solution for this.\r\n"}