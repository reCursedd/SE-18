{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/396065785", "html_url": "https://github.com/pytorch/pytorch/issues/8304#issuecomment-396065785", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/8304", "id": 396065785, "node_id": "MDEyOklzc3VlQ29tbWVudDM5NjA2NTc4NQ==", "user": {"login": "SsnL", "id": 5674597, "node_id": "MDQ6VXNlcjU2NzQ1OTc=", "avatar_url": "https://avatars2.githubusercontent.com/u/5674597?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SsnL", "html_url": "https://github.com/SsnL", "followers_url": "https://api.github.com/users/SsnL/followers", "following_url": "https://api.github.com/users/SsnL/following{/other_user}", "gists_url": "https://api.github.com/users/SsnL/gists{/gist_id}", "starred_url": "https://api.github.com/users/SsnL/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SsnL/subscriptions", "organizations_url": "https://api.github.com/users/SsnL/orgs", "repos_url": "https://api.github.com/users/SsnL/repos", "events_url": "https://api.github.com/users/SsnL/events{/privacy}", "received_events_url": "https://api.github.com/users/SsnL/received_events", "type": "User", "site_admin": false}, "created_at": "2018-06-10T17:17:05Z", "updated_at": "2018-06-10T17:17:05Z", "author_association": "CONTRIBUTOR", "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=451667\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/phizaz\">@phizaz</a> In your example, the reverse mode AD will calculate <code>gx = gy * (dy/ dx) = W gy</code>, and yes indeed it would obtain <code>W</code> in <strong>this</strong> example. However, as I mentioned above, it generally doesn't necessarily obtain the Jacobian. Furthermore, it doesn't work by multiplying all Jacobians from each step to get full Jacobian. In other words, for this example, the values fed into the next step is <code>gx</code> rather than <code>W</code>. So eventually you would get from the computation graph <code>g Input = \\sum g Output_i * d Output_i / d Input</code>, where <code>Input</code> is the leaves of the graph, and <code>Output</code> is the final result, rather than the Jacobian.</p>", "body_text": "@phizaz In your example, the reverse mode AD will calculate gx = gy * (dy/ dx) = W gy, and yes indeed it would obtain W in this example. However, as I mentioned above, it generally doesn't necessarily obtain the Jacobian. Furthermore, it doesn't work by multiplying all Jacobians from each step to get full Jacobian. In other words, for this example, the values fed into the next step is gx rather than W. So eventually you would get from the computation graph g Input = \\sum g Output_i * d Output_i / d Input, where Input is the leaves of the graph, and Output is the final result, rather than the Jacobian.", "body": "@phizaz In your example, the reverse mode AD will calculate `gx = gy * (dy/ dx) = W gy`, and yes indeed it would obtain `W` in **this** example. However, as I mentioned above, it generally doesn't necessarily obtain the Jacobian. Furthermore, it doesn't work by multiplying all Jacobians from each step to get full Jacobian. In other words, for this example, the values fed into the next step is `gx` rather than `W`. So eventually you would get from the computation graph `g Input = \\sum g Output_i * d Output_i / d Input`, where `Input` is the leaves of the graph, and `Output` is the final result, rather than the Jacobian."}