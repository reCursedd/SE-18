{"url": "https://api.github.com/repos/pytorch/pytorch/issues/7901", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/7901/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/7901/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/7901/events", "html_url": "https://github.com/pytorch/pytorch/issues/7901", "id": 327116200, "node_id": "MDU6SXNzdWUzMjcxMTYyMDA=", "number": 7901, "title": "unordered_set in caffe2::Observable::AttachObserver?", "user": {"login": "armenpoghosov", "id": 39712046, "node_id": "MDQ6VXNlcjM5NzEyMDQ2", "avatar_url": "https://avatars0.githubusercontent.com/u/39712046?v=4", "gravatar_id": "", "url": "https://api.github.com/users/armenpoghosov", "html_url": "https://github.com/armenpoghosov", "followers_url": "https://api.github.com/users/armenpoghosov/followers", "following_url": "https://api.github.com/users/armenpoghosov/following{/other_user}", "gists_url": "https://api.github.com/users/armenpoghosov/gists{/gist_id}", "starred_url": "https://api.github.com/users/armenpoghosov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/armenpoghosov/subscriptions", "organizations_url": "https://api.github.com/users/armenpoghosov/orgs", "repos_url": "https://api.github.com/users/armenpoghosov/repos", "events_url": "https://api.github.com/users/armenpoghosov/events{/privacy}", "received_events_url": "https://api.github.com/users/armenpoghosov/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 890282107, "node_id": "MDU6TGFiZWw4OTAyODIxMDc=", "url": "https://api.github.com/repos/pytorch/pytorch/labels/caffe2", "name": "caffe2", "color": "210aa8", "default": false}], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2018-05-28T20:57:50Z", "updated_at": "2018-05-29T13:54:59Z", "closed_at": null, "author_association": "NONE", "body_html": "<h2>Issue description</h2>\n<p>Correct me if I am wrong but it seems that there is a needless unordered_set filled from the observers_list_ just to check for parameter duplicate. I think this set can be removed completely and the check can be done in the filling loop.</p>\n<h2>Code example</h2>\n<pre><code>observer.h:52\nstd::unordered_set&lt;const Observer*&gt; observers;\nfor (auto&amp; ob : observers_list_) {\n  observers.insert(ob.get());\n}\nconst auto* observer_ptr = observer.get();\nif (observers.count(observer_ptr)) {\n  return observer_ptr;\n}\nobservers_list_.push_back(std::move(observer));\nreturn observer_ptr;\n</code></pre>\n<p>the code above should be changed to something like:</p>\n<pre><code>const auto* observer_ptr = observer.get();\nfor (auto&amp; ob : observers_list_) {\n   if (ob.get() == observer_ptr)\n       return observer_ptr;\n}\nobservers_list_.push_back(std::move(observer));\nreturn observer_ptr;\n</code></pre>", "body_text": "Issue description\nCorrect me if I am wrong but it seems that there is a needless unordered_set filled from the observers_list_ just to check for parameter duplicate. I think this set can be removed completely and the check can be done in the filling loop.\nCode example\nobserver.h:52\nstd::unordered_set<const Observer*> observers;\nfor (auto& ob : observers_list_) {\n  observers.insert(ob.get());\n}\nconst auto* observer_ptr = observer.get();\nif (observers.count(observer_ptr)) {\n  return observer_ptr;\n}\nobservers_list_.push_back(std::move(observer));\nreturn observer_ptr;\n\nthe code above should be changed to something like:\nconst auto* observer_ptr = observer.get();\nfor (auto& ob : observers_list_) {\n   if (ob.get() == observer_ptr)\n       return observer_ptr;\n}\nobservers_list_.push_back(std::move(observer));\nreturn observer_ptr;", "body": "## Issue description\r\nCorrect me if I am wrong but it seems that there is a needless unordered_set filled from the observers_list_ just to check for parameter duplicate. I think this set can be removed completely and the check can be done in the filling loop.\r\n\r\n## Code example\r\n    observer.h:52\r\n    std::unordered_set<const Observer*> observers;\r\n    for (auto& ob : observers_list_) {\r\n      observers.insert(ob.get());\r\n    }\r\n    const auto* observer_ptr = observer.get();\r\n    if (observers.count(observer_ptr)) {\r\n      return observer_ptr;\r\n    }\r\n    observers_list_.push_back(std::move(observer));\r\n    return observer_ptr;\r\n\r\nthe code above should be changed to something like:\r\n\r\n    const auto* observer_ptr = observer.get();\r\n    for (auto& ob : observers_list_) {\r\n       if (ob.get() == observer_ptr)\r\n           return observer_ptr;\r\n    }\r\n    observers_list_.push_back(std::move(observer));\r\n    return observer_ptr;\r\n"}