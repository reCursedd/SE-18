{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/225759176", "pull_request_review_id": 165430005, "id": 225759176, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTc1OTE3Ng==", "diff_hunk": "@@ -4629,24 +4629,66 @@ def test(name):\n     def test_signal_window_functions(self):\n         self._test_signal_window_functions(self)\n \n-    @skipIfNoLapack\n-    def test_inverse(self):\n-        M = torch.randn(5, 5)\n+    @staticmethod\n+    def _test_inverse(self, cast):\n+        from common import random_fullrank_matrix_distinct_singular_value\n+\n+        # no batches: 2-D tensors\n+        M = cast(random_fullrank_matrix_distinct_singular_value(5))\n         MI = torch.inverse(M)\n-        E = torch.eye(5)\n-        self.assertFalse(MI.is_contiguous(), 'MI is contiguous')\n+        E = cast(torch.eye(5))\n         self.assertEqual(E, torch.mm(M, MI), 1e-8, 'inverse value')\n         self.assertEqual(E, torch.mm(MI, M), 1e-8, 'inverse value')\n \n-        MII = torch.Tensor(5, 5)\n+        MII = cast(torch.Tensor(5, 5))\n         torch.inverse(M, out=MII)\n-        self.assertFalse(MII.is_contiguous(), 'MII is contiguous')\n         self.assertEqual(MII, MI, 0, 'inverse value in-place')\n         # second call, now that MII is transposed\n         torch.inverse(M, out=MII)\n-        self.assertFalse(MII.is_contiguous(), 'MII is contiguous')\n         self.assertEqual(MII, MI, 0, 'inverse value in-place')\n \n+        # one batch\n+        M = cast(random_fullrank_matrix_distinct_singular_value(5, 1))\n+        MI = torch.inverse(M)\n+        expected_inv = M.squeeze(0).inverse()\n+        self.assertEqual(MI, expected_inv.unsqueeze(0))\n+\n+        # four batches\n+        M = cast(random_fullrank_matrix_distinct_singular_value(5, 4))\n+        expected_inv_list = []\n+        for i in range(0, 4):\n+            expected_inv_list.append(torch.inverse(M[i]))\n+        expected_inv = torch.stack(expected_inv_list)\n+        MI = torch.inverse(M)\n+        self.assertEqual(MI, expected_inv)\n+\n+        # correctness test\n+        M = cast(random_fullrank_matrix_distinct_singular_value(5, 3))\n+        MI = torch.inverse(M)\n+        self.assertEqual(torch.matmul(M, MI), E.expand_as(M))\n+        self.assertEqual(torch.matmul(MI, M), E.expand_as(M))\n+\n+        # torch.inverse with out and batches\n+        M = cast(random_fullrank_matrix_distinct_singular_value(5, 3))\n+        MI = torch.Tensor(3, 5, 5)\n+        torch.inverse(M, out=MI)\n+        self.assertEqual(torch.inverse(M), MI)\n+", "path": "test/test_torch.py", "position": 146, "original_position": 56, "commit_id": "8cc65045618a15a741a33ac31a59edbbc7279290", "original_commit_id": "a217271aa281b4546cbc31cbcaa329015265a85b", "user": {"login": "zou3519", "id": 5652049, "node_id": "MDQ6VXNlcjU2NTIwNDk=", "avatar_url": "https://avatars3.githubusercontent.com/u/5652049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zou3519", "html_url": "https://github.com/zou3519", "followers_url": "https://api.github.com/users/zou3519/followers", "following_url": "https://api.github.com/users/zou3519/following{/other_user}", "gists_url": "https://api.github.com/users/zou3519/gists{/gist_id}", "starred_url": "https://api.github.com/users/zou3519/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zou3519/subscriptions", "organizations_url": "https://api.github.com/users/zou3519/orgs", "repos_url": "https://api.github.com/users/zou3519/repos", "events_url": "https://api.github.com/users/zou3519/events{/privacy}", "received_events_url": "https://api.github.com/users/zou3519/received_events", "type": "User", "site_admin": false}, "body": "We only test `torch.inverse` on tensors of the form `(B, N, N)` and `(N, N)`. Would it be possible to add one test for a tensor of the form `(B1, ..., BK, N, N)`?\r\n\r\nIt would also be nice to add a `self.assertRaisesRegex` test for the error message if the user passes in a matrix or a batch of matricies that are not square", "created_at": "2018-10-17T01:46:21Z", "updated_at": "2018-11-23T15:53:06Z", "html_url": "https://github.com/pytorch/pytorch/pull/9949#discussion_r225759176", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/9949", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/225759176"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/9949#discussion_r225759176"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/9949"}}, "body_html": "<p>We only test <code>torch.inverse</code> on tensors of the form <code>(B, N, N)</code> and <code>(N, N)</code>. Would it be possible to add one test for a tensor of the form <code>(B1, ..., BK, N, N)</code>?</p>\n<p>It would also be nice to add a <code>self.assertRaisesRegex</code> test for the error message if the user passes in a matrix or a batch of matricies that are not square</p>", "body_text": "We only test torch.inverse on tensors of the form (B, N, N) and (N, N). Would it be possible to add one test for a tensor of the form (B1, ..., BK, N, N)?\nIt would also be nice to add a self.assertRaisesRegex test for the error message if the user passes in a matrix or a batch of matricies that are not square"}