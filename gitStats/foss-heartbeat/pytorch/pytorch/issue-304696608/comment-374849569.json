{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/374849569", "html_url": "https://github.com/pytorch/pytorch/issues/5736#issuecomment-374849569", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/5736", "id": 374849569, "node_id": "MDEyOklzc3VlQ29tbWVudDM3NDg0OTU2OQ==", "user": {"login": "alsrgv", "id": 16640218, "node_id": "MDQ6VXNlcjE2NjQwMjE4", "avatar_url": "https://avatars2.githubusercontent.com/u/16640218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alsrgv", "html_url": "https://github.com/alsrgv", "followers_url": "https://api.github.com/users/alsrgv/followers", "following_url": "https://api.github.com/users/alsrgv/following{/other_user}", "gists_url": "https://api.github.com/users/alsrgv/gists{/gist_id}", "starred_url": "https://api.github.com/users/alsrgv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alsrgv/subscriptions", "organizations_url": "https://api.github.com/users/alsrgv/orgs", "repos_url": "https://api.github.com/users/alsrgv/repos", "events_url": "https://api.github.com/users/alsrgv/events{/privacy}", "received_events_url": "https://api.github.com/users/alsrgv/received_events", "type": "User", "site_admin": false}, "created_at": "2018-03-21T07:10:49Z", "updated_at": "2018-03-21T07:10:49Z", "author_association": "CONTRIBUTOR", "body_html": "<p>I believe CUDA memory is pinned because I'm using <code>pin_memory=True</code>.  The processes which are left holding memory have just two threads looking like this, which looks very much like preprocessor thread:</p>\n<pre><code>(gdb) thread apply all bt\n\nThread 2 (Thread 0x7f266cfff700 (LWP 41632)):\n#0  0x00007f270f1c8c8d in accept () at ../sysdeps/unix/syscall-template.S:81\n#1  0x00000000005c2164 in ?? ()\n#2  0x00000000004d34b7 in PyEval_EvalFrameEx ()\n#3  0x00000000004d2e77 in PyEval_EvalFrameEx ()\n#4  0x00000000004d2e77 in PyEval_EvalFrameEx ()\n#5  0x00000000004d2e77 in PyEval_EvalFrameEx ()\n#6  0x00000000004ebff8 in ?? ()\n#7  0x00000000004d03a1 in PyEval_EvalFrameEx ()\n#8  0x00000000004d2e77 in PyEval_EvalFrameEx ()\n#9  0x00000000004d2e77 in PyEval_EvalFrameEx ()\n#10 0x00000000004ebff8 in ?? ()\n#11 0x00000000005107f8 in ?? ()\n#12 0x00000000004d881a in PyEval_CallObjectWithKeywords ()\n#13 0x00000000005c1f32 in ?? ()\n#14 0x00007f270f1c2064 in start_thread (arg=0x7f266cfff700) at pthread_create.c:309\n#15 0x00007f270e5d462d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111\n\nThread 1 (Thread 0x7f270f5e5700 (LWP 41631)):\n#0  0x00007f270f1c8a9d in read () at ../sysdeps/unix/syscall-template.S:81\n#1  0x00007f2688f0e776 in ?? () from /home/asergeev/env-pytorch/lib/python2.7/lib-dynload/_multiprocessing.x86_64-linux-gnu.so\n#2  0x00000000004cddf4 in PyEval_EvalFrameEx ()\n#3  0x00000000004d2e77 in PyEval_EvalFrameEx ()\n#4  0x00000000004cc4f1 in PyEval_EvalCodeEx ()\n#5  0x00000000004d3ce0 in PyEval_EvalFrameEx ()\n#6  0x00000000004ebff8 in ?? ()\n#7  0x00000000004d03a1 in PyEval_EvalFrameEx ()\n#8  0x00000000004d2e77 in PyEval_EvalFrameEx ()\n#9  0x00000000004d2e77 in PyEval_EvalFrameEx ()\n#10 0x00000000004ebff8 in ?? ()\n#11 0x00000000005107f8 in ?? ()\n#12 0x000000000050f479 in ?? ()\n#13 0x00000000004be10b in ?? ()\n#14 0x00000000004d3309 in PyEval_EvalFrameEx ()\n#15 0x00000000004d2e77 in PyEval_EvalFrameEx ()\n#16 0x00000000004ebff8 in ?? ()\n#17 0x00000000005107f8 in ?? ()\n#18 0x000000000050f863 in ?? ()\n#19 0x00000000004be10b in ?? ()\n#20 0x00000000004d3309 in PyEval_EvalFrameEx ()\n#21 0x00000000004ebff8 in ?? ()\n#22 0x00000000005107f8 in ?? ()\n---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---\n#23 0x00000000004b794e in PyObject_Call ()\n#24 0x00000000005176f2 in ?? ()\n#25 0x000000000053113c in ?? ()\n#26 0x00000000004be025 in ?? ()\n#27 0x00000000004d3309 in PyEval_EvalFrameEx ()\n#28 0x00000000004cc4f1 in PyEval_EvalCodeEx ()\n#29 0x00000000004d3ce0 in PyEval_EvalFrameEx ()\n#30 0x00000000004cc4f1 in PyEval_EvalCodeEx ()\n#31 0x000000000050a40f in ?? ()\n#32 0x0000000000501a72 in PyRun_FileExFlags ()\n#33 0x0000000000500187 in PyRun_SimpleFileExFlags ()\n#34 0x000000000049b9fe in Py_Main ()\n#35 0x00007f270e50db45 in __libc_start_main (main=0x49b490 &lt;main&gt;, argc=2, argv=0x7fff90e8bbd8, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fff90e8bbc8)\n    at libc-start.c:287\n#36 0x000000000049b3bc in _start ()\n(gdb)\n</code></pre>\n<p>I think the issue is that I'm working on C extension and in process of doing that are getting segfaults and are sometimes terminating script not very nicely (via -9).</p>\n<p>All this prevent Python's <code>daemon</code> process handling.  I wrote a reproducer of my behavior with correct handling via polling <code>getppid()</code> - <a href=\"https://gist.github.com/alsrgv/b163c772edc76481ac2226833e08b21b\">https://gist.github.com/alsrgv/b163c772edc76481ac2226833e08b21b</a>.  Can this be integrated into preprocessing thread logic?</p>", "body_text": "I believe CUDA memory is pinned because I'm using pin_memory=True.  The processes which are left holding memory have just two threads looking like this, which looks very much like preprocessor thread:\n(gdb) thread apply all bt\n\nThread 2 (Thread 0x7f266cfff700 (LWP 41632)):\n#0  0x00007f270f1c8c8d in accept () at ../sysdeps/unix/syscall-template.S:81\n#1  0x00000000005c2164 in ?? ()\n#2  0x00000000004d34b7 in PyEval_EvalFrameEx ()\n#3  0x00000000004d2e77 in PyEval_EvalFrameEx ()\n#4  0x00000000004d2e77 in PyEval_EvalFrameEx ()\n#5  0x00000000004d2e77 in PyEval_EvalFrameEx ()\n#6  0x00000000004ebff8 in ?? ()\n#7  0x00000000004d03a1 in PyEval_EvalFrameEx ()\n#8  0x00000000004d2e77 in PyEval_EvalFrameEx ()\n#9  0x00000000004d2e77 in PyEval_EvalFrameEx ()\n#10 0x00000000004ebff8 in ?? ()\n#11 0x00000000005107f8 in ?? ()\n#12 0x00000000004d881a in PyEval_CallObjectWithKeywords ()\n#13 0x00000000005c1f32 in ?? ()\n#14 0x00007f270f1c2064 in start_thread (arg=0x7f266cfff700) at pthread_create.c:309\n#15 0x00007f270e5d462d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111\n\nThread 1 (Thread 0x7f270f5e5700 (LWP 41631)):\n#0  0x00007f270f1c8a9d in read () at ../sysdeps/unix/syscall-template.S:81\n#1  0x00007f2688f0e776 in ?? () from /home/asergeev/env-pytorch/lib/python2.7/lib-dynload/_multiprocessing.x86_64-linux-gnu.so\n#2  0x00000000004cddf4 in PyEval_EvalFrameEx ()\n#3  0x00000000004d2e77 in PyEval_EvalFrameEx ()\n#4  0x00000000004cc4f1 in PyEval_EvalCodeEx ()\n#5  0x00000000004d3ce0 in PyEval_EvalFrameEx ()\n#6  0x00000000004ebff8 in ?? ()\n#7  0x00000000004d03a1 in PyEval_EvalFrameEx ()\n#8  0x00000000004d2e77 in PyEval_EvalFrameEx ()\n#9  0x00000000004d2e77 in PyEval_EvalFrameEx ()\n#10 0x00000000004ebff8 in ?? ()\n#11 0x00000000005107f8 in ?? ()\n#12 0x000000000050f479 in ?? ()\n#13 0x00000000004be10b in ?? ()\n#14 0x00000000004d3309 in PyEval_EvalFrameEx ()\n#15 0x00000000004d2e77 in PyEval_EvalFrameEx ()\n#16 0x00000000004ebff8 in ?? ()\n#17 0x00000000005107f8 in ?? ()\n#18 0x000000000050f863 in ?? ()\n#19 0x00000000004be10b in ?? ()\n#20 0x00000000004d3309 in PyEval_EvalFrameEx ()\n#21 0x00000000004ebff8 in ?? ()\n#22 0x00000000005107f8 in ?? ()\n---Type <return> to continue, or q <return> to quit---\n#23 0x00000000004b794e in PyObject_Call ()\n#24 0x00000000005176f2 in ?? ()\n#25 0x000000000053113c in ?? ()\n#26 0x00000000004be025 in ?? ()\n#27 0x00000000004d3309 in PyEval_EvalFrameEx ()\n#28 0x00000000004cc4f1 in PyEval_EvalCodeEx ()\n#29 0x00000000004d3ce0 in PyEval_EvalFrameEx ()\n#30 0x00000000004cc4f1 in PyEval_EvalCodeEx ()\n#31 0x000000000050a40f in ?? ()\n#32 0x0000000000501a72 in PyRun_FileExFlags ()\n#33 0x0000000000500187 in PyRun_SimpleFileExFlags ()\n#34 0x000000000049b9fe in Py_Main ()\n#35 0x00007f270e50db45 in __libc_start_main (main=0x49b490 <main>, argc=2, argv=0x7fff90e8bbd8, init=<optimized out>, fini=<optimized out>, rtld_fini=<optimized out>, stack_end=0x7fff90e8bbc8)\n    at libc-start.c:287\n#36 0x000000000049b3bc in _start ()\n(gdb)\n\nI think the issue is that I'm working on C extension and in process of doing that are getting segfaults and are sometimes terminating script not very nicely (via -9).\nAll this prevent Python's daemon process handling.  I wrote a reproducer of my behavior with correct handling via polling getppid() - https://gist.github.com/alsrgv/b163c772edc76481ac2226833e08b21b.  Can this be integrated into preprocessing thread logic?", "body": "I believe CUDA memory is pinned because I'm using `pin_memory=True`.  The processes which are left holding memory have just two threads looking like this, which looks very much like preprocessor thread:\r\n\r\n```\r\n(gdb) thread apply all bt\r\n\r\nThread 2 (Thread 0x7f266cfff700 (LWP 41632)):\r\n#0  0x00007f270f1c8c8d in accept () at ../sysdeps/unix/syscall-template.S:81\r\n#1  0x00000000005c2164 in ?? ()\r\n#2  0x00000000004d34b7 in PyEval_EvalFrameEx ()\r\n#3  0x00000000004d2e77 in PyEval_EvalFrameEx ()\r\n#4  0x00000000004d2e77 in PyEval_EvalFrameEx ()\r\n#5  0x00000000004d2e77 in PyEval_EvalFrameEx ()\r\n#6  0x00000000004ebff8 in ?? ()\r\n#7  0x00000000004d03a1 in PyEval_EvalFrameEx ()\r\n#8  0x00000000004d2e77 in PyEval_EvalFrameEx ()\r\n#9  0x00000000004d2e77 in PyEval_EvalFrameEx ()\r\n#10 0x00000000004ebff8 in ?? ()\r\n#11 0x00000000005107f8 in ?? ()\r\n#12 0x00000000004d881a in PyEval_CallObjectWithKeywords ()\r\n#13 0x00000000005c1f32 in ?? ()\r\n#14 0x00007f270f1c2064 in start_thread (arg=0x7f266cfff700) at pthread_create.c:309\r\n#15 0x00007f270e5d462d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111\r\n\r\nThread 1 (Thread 0x7f270f5e5700 (LWP 41631)):\r\n#0  0x00007f270f1c8a9d in read () at ../sysdeps/unix/syscall-template.S:81\r\n#1  0x00007f2688f0e776 in ?? () from /home/asergeev/env-pytorch/lib/python2.7/lib-dynload/_multiprocessing.x86_64-linux-gnu.so\r\n#2  0x00000000004cddf4 in PyEval_EvalFrameEx ()\r\n#3  0x00000000004d2e77 in PyEval_EvalFrameEx ()\r\n#4  0x00000000004cc4f1 in PyEval_EvalCodeEx ()\r\n#5  0x00000000004d3ce0 in PyEval_EvalFrameEx ()\r\n#6  0x00000000004ebff8 in ?? ()\r\n#7  0x00000000004d03a1 in PyEval_EvalFrameEx ()\r\n#8  0x00000000004d2e77 in PyEval_EvalFrameEx ()\r\n#9  0x00000000004d2e77 in PyEval_EvalFrameEx ()\r\n#10 0x00000000004ebff8 in ?? ()\r\n#11 0x00000000005107f8 in ?? ()\r\n#12 0x000000000050f479 in ?? ()\r\n#13 0x00000000004be10b in ?? ()\r\n#14 0x00000000004d3309 in PyEval_EvalFrameEx ()\r\n#15 0x00000000004d2e77 in PyEval_EvalFrameEx ()\r\n#16 0x00000000004ebff8 in ?? ()\r\n#17 0x00000000005107f8 in ?? ()\r\n#18 0x000000000050f863 in ?? ()\r\n#19 0x00000000004be10b in ?? ()\r\n#20 0x00000000004d3309 in PyEval_EvalFrameEx ()\r\n#21 0x00000000004ebff8 in ?? ()\r\n#22 0x00000000005107f8 in ?? ()\r\n---Type <return> to continue, or q <return> to quit---\r\n#23 0x00000000004b794e in PyObject_Call ()\r\n#24 0x00000000005176f2 in ?? ()\r\n#25 0x000000000053113c in ?? ()\r\n#26 0x00000000004be025 in ?? ()\r\n#27 0x00000000004d3309 in PyEval_EvalFrameEx ()\r\n#28 0x00000000004cc4f1 in PyEval_EvalCodeEx ()\r\n#29 0x00000000004d3ce0 in PyEval_EvalFrameEx ()\r\n#30 0x00000000004cc4f1 in PyEval_EvalCodeEx ()\r\n#31 0x000000000050a40f in ?? ()\r\n#32 0x0000000000501a72 in PyRun_FileExFlags ()\r\n#33 0x0000000000500187 in PyRun_SimpleFileExFlags ()\r\n#34 0x000000000049b9fe in Py_Main ()\r\n#35 0x00007f270e50db45 in __libc_start_main (main=0x49b490 <main>, argc=2, argv=0x7fff90e8bbd8, init=<optimized out>, fini=<optimized out>, rtld_fini=<optimized out>, stack_end=0x7fff90e8bbc8)\r\n    at libc-start.c:287\r\n#36 0x000000000049b3bc in _start ()\r\n(gdb)\r\n```\r\n\r\nI think the issue is that I'm working on C extension and in process of doing that are getting segfaults and are sometimes terminating script not very nicely (via -9).\r\n\r\nAll this prevent Python's `daemon` process handling.  I wrote a reproducer of my behavior with correct handling via polling `getppid()` - https://gist.github.com/alsrgv/b163c772edc76481ac2226833e08b21b.  Can this be integrated into preprocessing thread logic?"}