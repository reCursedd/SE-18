{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/408594930", "html_url": "https://github.com/pytorch/pytorch/pull/9628#issuecomment-408594930", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/9628", "id": 408594930, "node_id": "MDEyOklzc3VlQ29tbWVudDQwODU5NDkzMA==", "user": {"login": "t-vi", "id": 20787943, "node_id": "MDQ6VXNlcjIwNzg3OTQz", "avatar_url": "https://avatars2.githubusercontent.com/u/20787943?v=4", "gravatar_id": "", "url": "https://api.github.com/users/t-vi", "html_url": "https://github.com/t-vi", "followers_url": "https://api.github.com/users/t-vi/followers", "following_url": "https://api.github.com/users/t-vi/following{/other_user}", "gists_url": "https://api.github.com/users/t-vi/gists{/gist_id}", "starred_url": "https://api.github.com/users/t-vi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/t-vi/subscriptions", "organizations_url": "https://api.github.com/users/t-vi/orgs", "repos_url": "https://api.github.com/users/t-vi/repos", "events_url": "https://api.github.com/users/t-vi/events{/privacy}", "received_events_url": "https://api.github.com/users/t-vi/received_events", "type": "User", "site_admin": false}, "created_at": "2018-07-28T09:27:45Z", "updated_at": "2018-07-28T09:27:45Z", "author_association": "CONTRIBUTOR", "body_html": "<p>So I found TensorAccessors and they I couldn't resist switching to them (30 lines of code less and much clearer indexing) for CPU. I also changed the CPU and CUDA versions to all accept int labels (and move them to GPU as needed). The idea is that if you program against CuDNN (where you have to have CPU int labels) you can switch to CUDA/CPU as needed.</p>\n<p>The remaining two CI failures (running out of heap on Windows somewhere else, some timeout for the ROCm one) look like I cannot do much about.</p>\n<p>I had to adapt the test infrastructure a bit to cover all cases (so additional arguments and not converting targets).</p>", "body_text": "So I found TensorAccessors and they I couldn't resist switching to them (30 lines of code less and much clearer indexing) for CPU. I also changed the CPU and CUDA versions to all accept int labels (and move them to GPU as needed). The idea is that if you program against CuDNN (where you have to have CPU int labels) you can switch to CUDA/CPU as needed.\nThe remaining two CI failures (running out of heap on Windows somewhere else, some timeout for the ROCm one) look like I cannot do much about.\nI had to adapt the test infrastructure a bit to cover all cases (so additional arguments and not converting targets).", "body": "So I found TensorAccessors and they I couldn't resist switching to them (30 lines of code less and much clearer indexing) for CPU. I also changed the CPU and CUDA versions to all accept int labels (and move them to GPU as needed). The idea is that if you program against CuDNN (where you have to have CPU int labels) you can switch to CUDA/CPU as needed.\r\n\r\nThe remaining two CI failures (running out of heap on Windows somewhere else, some timeout for the ROCm one) look like I cannot do much about.\r\n\r\nI had to adapt the test infrastructure a bit to cover all cases (so additional arguments and not converting targets)."}