{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/418917541", "html_url": "https://github.com/pytorch/pytorch/issues/10120#issuecomment-418917541", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/10120", "id": 418917541, "node_id": "MDEyOklzc3VlQ29tbWVudDQxODkxNzU0MQ==", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "created_at": "2018-09-05T23:50:44Z", "updated_at": "2018-09-05T23:50:44Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Here is a workaround that might help. I need to make sure it doesn't leak memory though:</p>\n<pre><code>diff --git a/torch/csrc/generic/Storage.cpp b/torch/csrc/generic/Storage.cpp\nindex 94c0b85bd..f7708978e 100644\n--- a/torch/csrc/generic/Storage.cpp\n+++ b/torch/csrc/generic/Storage.cpp\n@@ -160,8 +160,32 @@ static PyObject * THPStorage_(get)(THPStorage *self, PyObject *index)\n     return THPUtils_(newReal)(value);\n   /* Slice index */\n   } else if (PySlice_Check(index)) {\n-    THPUtils_setError(\"storages don't support slicing\");\n-    return nullptr;\n+    Py_ssize_t start, stop, slicelength, step;\n+    int64_t len = THWStorage_(size)(LIBRARY_STATE self-&gt;cdata);\n+    if (!THPUtils_parseSlice(index, len, &amp;start, &amp;stop, &amp;step, &amp;slicelength))\n+      return NULL;\n+    if (step != 1) {\n+      THPUtils_setError(\"Trying to slice with a step of %\" PRId64 \", but only a step of \"\n+          \"1 is supported\", (int64_t)step);\n+      return NULL;\n+    }\n+\n+    scalar_t *data = THWStorage_(data)(LIBRARY_STATE self-&gt;cdata);\n+\n+    at::StorageImpl* old_storage = self-&gt;cdata;\n+    c10::raw::intrusive_ptr::incref(old_storage);\n+    at::Storage new_storage(c10::make_intrusive&lt;at::StorageImpl&gt;(\n+      old_storage-&gt;dtype(),\n+      slicelength,\n+      at::DataPtr(static_cast&lt;void*&gt;(data + start),\n+                  old_storage,\n+                  [](void* s) { c10::raw::intrusive_ptr::decref(static_cast&lt;at::StorageImpl*&gt;(s)); },\n+                  old_storage-&gt;device()),\n+      nullptr,\n+      false));\n+\n+    PyObject *_ret = THPStorage_(New)(new_storage.unsafeReleaseStorageImpl());\n+    return _ret;\n   }\n   PyErr_Format(PyExc_TypeError, \"can't index a \" THPStorageStr \" with %s\",\n       THPUtils_typename(index));\n</code></pre>", "body_text": "Here is a workaround that might help. I need to make sure it doesn't leak memory though:\ndiff --git a/torch/csrc/generic/Storage.cpp b/torch/csrc/generic/Storage.cpp\nindex 94c0b85bd..f7708978e 100644\n--- a/torch/csrc/generic/Storage.cpp\n+++ b/torch/csrc/generic/Storage.cpp\n@@ -160,8 +160,32 @@ static PyObject * THPStorage_(get)(THPStorage *self, PyObject *index)\n     return THPUtils_(newReal)(value);\n   /* Slice index */\n   } else if (PySlice_Check(index)) {\n-    THPUtils_setError(\"storages don't support slicing\");\n-    return nullptr;\n+    Py_ssize_t start, stop, slicelength, step;\n+    int64_t len = THWStorage_(size)(LIBRARY_STATE self->cdata);\n+    if (!THPUtils_parseSlice(index, len, &start, &stop, &step, &slicelength))\n+      return NULL;\n+    if (step != 1) {\n+      THPUtils_setError(\"Trying to slice with a step of %\" PRId64 \", but only a step of \"\n+          \"1 is supported\", (int64_t)step);\n+      return NULL;\n+    }\n+\n+    scalar_t *data = THWStorage_(data)(LIBRARY_STATE self->cdata);\n+\n+    at::StorageImpl* old_storage = self->cdata;\n+    c10::raw::intrusive_ptr::incref(old_storage);\n+    at::Storage new_storage(c10::make_intrusive<at::StorageImpl>(\n+      old_storage->dtype(),\n+      slicelength,\n+      at::DataPtr(static_cast<void*>(data + start),\n+                  old_storage,\n+                  [](void* s) { c10::raw::intrusive_ptr::decref(static_cast<at::StorageImpl*>(s)); },\n+                  old_storage->device()),\n+      nullptr,\n+      false));\n+\n+    PyObject *_ret = THPStorage_(New)(new_storage.unsafeReleaseStorageImpl());\n+    return _ret;\n   }\n   PyErr_Format(PyExc_TypeError, \"can't index a \" THPStorageStr \" with %s\",\n       THPUtils_typename(index));", "body": "Here is a workaround that might help. I need to make sure it doesn't leak memory though:\r\n\r\n```\r\ndiff --git a/torch/csrc/generic/Storage.cpp b/torch/csrc/generic/Storage.cpp\r\nindex 94c0b85bd..f7708978e 100644\r\n--- a/torch/csrc/generic/Storage.cpp\r\n+++ b/torch/csrc/generic/Storage.cpp\r\n@@ -160,8 +160,32 @@ static PyObject * THPStorage_(get)(THPStorage *self, PyObject *index)\r\n     return THPUtils_(newReal)(value);\r\n   /* Slice index */\r\n   } else if (PySlice_Check(index)) {\r\n-    THPUtils_setError(\"storages don't support slicing\");\r\n-    return nullptr;\r\n+    Py_ssize_t start, stop, slicelength, step;\r\n+    int64_t len = THWStorage_(size)(LIBRARY_STATE self->cdata);\r\n+    if (!THPUtils_parseSlice(index, len, &start, &stop, &step, &slicelength))\r\n+      return NULL;\r\n+    if (step != 1) {\r\n+      THPUtils_setError(\"Trying to slice with a step of %\" PRId64 \", but only a step of \"\r\n+          \"1 is supported\", (int64_t)step);\r\n+      return NULL;\r\n+    }\r\n+\r\n+    scalar_t *data = THWStorage_(data)(LIBRARY_STATE self->cdata);\r\n+\r\n+    at::StorageImpl* old_storage = self->cdata;\r\n+    c10::raw::intrusive_ptr::incref(old_storage);\r\n+    at::Storage new_storage(c10::make_intrusive<at::StorageImpl>(\r\n+      old_storage->dtype(),\r\n+      slicelength,\r\n+      at::DataPtr(static_cast<void*>(data + start),\r\n+                  old_storage,\r\n+                  [](void* s) { c10::raw::intrusive_ptr::decref(static_cast<at::StorageImpl*>(s)); },\r\n+                  old_storage->device()),\r\n+      nullptr,\r\n+      false));\r\n+\r\n+    PyObject *_ret = THPStorage_(New)(new_storage.unsafeReleaseStorageImpl());\r\n+    return _ret;\r\n   }\r\n   PyErr_Format(PyExc_TypeError, \"can't index a \" THPStorageStr \" with %s\",\r\n       THPUtils_typename(index));\r\n```"}