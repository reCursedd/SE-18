{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/153082935", "pull_request_review_id": 79039084, "id": 153082935, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1MzA4MjkzNQ==", "diff_hunk": "@@ -155,9 +130,43 @@ def __call__(cls, *args, **kwargs):\n             # user passed in), this problem goes away, because the class\n             # __init__ is a part of is indeed Foo.\n \n+            old_init = arg.__init__\n+            # Python 2 has a concept of unbound methods, which doesn't play well\n+            # with what we want to do here. Therefore, unpack the method into a", "path": "torch/jit/__init__.py", "position": null, "original_position": 49, "commit_id": "77e4a4b39eda7f9e35007fce7744919037ee0c13", "original_commit_id": "93031a18593c0fdbef69b812f31c38bbb6f48b62", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "body": "Basically the problem is that unbound methods are like functions, but with type checks on the first argument. If we didn't unwrap them you'll get errors like \"__init__ expected the first argument to be of type MyModule, but it is MyModule\". That's because it still checks for the old class, but it gets the decorated class. Unwrapping the method into a plain function gets rid of the type check. Python 3 already returns a plain function, so there's no need to do anything", "created_at": "2017-11-26T21:50:29Z", "updated_at": "2018-11-23T15:36:49Z", "html_url": "https://github.com/pytorch/pytorch/pull/3855#discussion_r153082935", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/3855", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/153082935"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/3855#discussion_r153082935"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/3855"}}, "body_html": "<p>Basically the problem is that unbound methods are like functions, but with type checks on the first argument. If we didn't unwrap them you'll get errors like \"<strong>init</strong> expected the first argument to be of type MyModule, but it is MyModule\". That's because it still checks for the old class, but it gets the decorated class. Unwrapping the method into a plain function gets rid of the type check. Python 3 already returns a plain function, so there's no need to do anything</p>", "body_text": "Basically the problem is that unbound methods are like functions, but with type checks on the first argument. If we didn't unwrap them you'll get errors like \"init expected the first argument to be of type MyModule, but it is MyModule\". That's because it still checks for the old class, but it gets the decorated class. Unwrapping the method into a plain function gets rid of the type check. Python 3 already returns a plain function, so there's no need to do anything", "in_reply_to_id": 153081914}