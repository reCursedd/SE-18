{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/210009395", "pull_request_review_id": 146136190, "id": 210009395, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDAwOTM5NQ==", "diff_hunk": "@@ -0,0 +1,184 @@\n+#include \"torch/csrc/jit/passes/annotate_effects.h\"\n+#include <set>\n+\n+namespace torch {\n+namespace jit {\n+namespace {\n+\n+// Ops with effects that we need to track through the passing of world tokens\n+// e.g. mutation\n+const std::unordered_set<Symbol> effectfulOps = {\n+    aten::append,\n+};\n+\n+/**\n+ * AnnotateEffects\n+ *\n+ * This pass annotates effectful operations (such as ones that mutate existing\n+ * values) to prevent subsequent passes from re-ordering ops in a way that\n+ * changes the meaning of the program.\n+ *\n+ * It does this by adding primitive memory fence ops around nodes that use\n+ * mutable values. The memory fences input and output a \"World\" token, which\n+ * expresses effects explicitly in the IR and forces all fenced nodes to be\n+ * linearized.\n+ */\n+class AnnotateEffectsImpl {\n+ public:\n+  void annotateEffects(Graph* g) {\n+    // Generate the first world token\n+    const auto tokenGenerator = g->create(prim::Constant);\n+    g->block()->prependNode(tokenGenerator);\n+    auto curToken = tokenGenerator->output()->setType(WorldType::get());\n+\n+    visitBlock(g->block(), curToken);\n+  }\n+\n+ private:\n+  Value* visitBlock(Block* block, Value* curToken) {\n+    for (auto* node : block->nodes()) {\n+      curToken = visitNode(node, curToken);\n+    }\n+    return curToken;\n+  }\n+\n+  // If a node uses a mutable variable (or mutates a previously constant\n+  // variable), create a memory fence around the node.\n+  //\n+  // Returns the last world token emitted for subsequent memory fences to use.\n+  Value* visitNode(Node* node, Value* curToken) {\n+    if (node->kind() == prim::If) {\n+      JIT_ASSERT(node->blocks().size() == 2);\n+\n+      auto trueBlock = node->blocks().at(0);\n+      auto falseBlock = node->blocks().at(1);\n+\n+      auto trueToken = visitBlock(trueBlock, curToken);\n+      auto falseToken = visitBlock(falseBlock, curToken);\n+\n+      // If any branch has a mutating op, this node has to output a world token\n+      if (trueToken != curToken || falseToken != curToken) {\n+        trueBlock->registerOutput(trueToken);\n+        falseBlock->registerOutput(falseToken);\n+\n+        return node->addOutput()->setType(WorldType::get());\n+      }\n+      return curToken;\n+    }\n+\n+    if (node->kind() == prim::Loop) {\n+      JIT_ASSERT(node->blocks().size() == 1);\n+      auto block = node->blocks().at(0);\n+      if (!shouldAddFence(block)) {\n+        // Bail out early if there's no mutable variables used inside\n+        return curToken;\n+      }\n+\n+      // Register the world token as a loop carried dependency\n+      auto beginLoopToken = block->addInput()->setType(WorldType::get());\n+      auto endLoopToken = visitBlock(block, beginLoopToken);\n+      block->registerOutput(endLoopToken);\n+\n+      JIT_ASSERT(endLoopToken != beginLoopToken);\n+\n+      // Thread the world token through the loop node\n+      node->addInput(curToken);\n+      return node->addOutput()->setType(WorldType::get());\n+    }\n+\n+    JIT_ASSERT(node->blocks().size() == 0);\n+\n+    if (shouldAddFence(node)) {\n+      return addFenceForNode(node, curToken);\n+    }\n+\n+    return curToken;\n+  }\n+\n+  bool shouldAddFence(Node* node) {\n+    // Check if this node uses a known mutable value\n+    for (auto* input : node->inputs()) {\n+      if (mutableValues_.count(input) != 0) {\n+        return true;", "path": "torch/csrc/jit/passes/annotate_effects.cpp", "position": 102, "original_position": 102, "commit_id": "f2f80212356100179d9b3a4b06e5d8d964a9342c", "original_commit_id": "ed7ae9a02e7cff3a5178513b58dec6466a83913e", "user": {"login": "suo", "id": 1617424, "node_id": "MDQ6VXNlcjE2MTc0MjQ=", "avatar_url": "https://avatars2.githubusercontent.com/u/1617424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/suo", "html_url": "https://github.com/suo", "followers_url": "https://api.github.com/users/suo/followers", "following_url": "https://api.github.com/users/suo/following{/other_user}", "gists_url": "https://api.github.com/users/suo/gists{/gist_id}", "starred_url": "https://api.github.com/users/suo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/suo/subscriptions", "organizations_url": "https://api.github.com/users/suo/orgs", "repos_url": "https://api.github.com/users/suo/repos", "events_url": "https://api.github.com/users/suo/events{/privacy}", "received_events_url": "https://api.github.com/users/suo/received_events", "type": "User", "site_admin": false}, "body": "We need to guard every use of the mutable value if we want to prevent all forms of dependence-violating reordering. As a small example:\r\n```\r\nfoo = []\r\nfoo.append(5)\r\nx = len(foo)\r\nfoo.append(6)\r\n```\r\nAny reordering of instructions here will change the meaning of the program. If we only fenced the `append`s, then only ordering of the appends would be linearized, and the following optimization would be allowed:\r\n```\r\nfoo = []\r\nfoo.append(5)\r\nfoo.append(6)\r\nx = len(foo)\r\n```\r\nIt's true that non-mutating uses before the first and after the last mutation could be safe to re-order. I was thinking I'd add something to relax that constraint later.", "created_at": "2018-08-14T16:01:23Z", "updated_at": "2018-11-23T15:49:18Z", "html_url": "https://github.com/pytorch/pytorch/pull/10500#discussion_r210009395", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/10500", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/210009395"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/10500#discussion_r210009395"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/10500"}}, "body_html": "<p>We need to guard every use of the mutable value if we want to prevent all forms of dependence-violating reordering. As a small example:</p>\n<pre><code>foo = []\nfoo.append(5)\nx = len(foo)\nfoo.append(6)\n</code></pre>\n<p>Any reordering of instructions here will change the meaning of the program. If we only fenced the <code>append</code>s, then only ordering of the appends would be linearized, and the following optimization would be allowed:</p>\n<pre><code>foo = []\nfoo.append(5)\nfoo.append(6)\nx = len(foo)\n</code></pre>\n<p>It's true that non-mutating uses before the first and after the last mutation could be safe to re-order. I was thinking I'd add something to relax that constraint later.</p>", "body_text": "We need to guard every use of the mutable value if we want to prevent all forms of dependence-violating reordering. As a small example:\nfoo = []\nfoo.append(5)\nx = len(foo)\nfoo.append(6)\n\nAny reordering of instructions here will change the meaning of the program. If we only fenced the appends, then only ordering of the appends would be linearized, and the following optimization would be allowed:\nfoo = []\nfoo.append(5)\nfoo.append(6)\nx = len(foo)\n\nIt's true that non-mutating uses before the first and after the last mutation could be safe to re-order. I was thinking I'd add something to relax that constraint later.", "in_reply_to_id": 209989696}