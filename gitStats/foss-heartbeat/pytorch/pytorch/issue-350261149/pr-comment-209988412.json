{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/209988412", "pull_request_review_id": 146103838, "id": 209988412, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwOTk4ODQxMg==", "diff_hunk": "@@ -0,0 +1,184 @@\n+#include \"torch/csrc/jit/passes/annotate_effects.h\"\n+#include <set>\n+\n+namespace torch {\n+namespace jit {\n+namespace {\n+\n+// Ops with effects that we need to track through the passing of world tokens\n+// e.g. mutation\n+const std::unordered_set<Symbol> effectfulOps = {\n+    aten::append,\n+};\n+\n+/**\n+ * AnnotateEffects\n+ *\n+ * This pass annotates effectful operations (such as ones that mutate existing\n+ * values) to prevent subsequent passes from re-ordering ops in a way that\n+ * changes the meaning of the program.\n+ *\n+ * It does this by adding primitive memory fence ops around nodes that use\n+ * mutable values. The memory fences input and output a \"World\" token, which\n+ * expresses effects explicitly in the IR and forces all fenced nodes to be\n+ * linearized.\n+ */\n+class AnnotateEffectsImpl {\n+ public:\n+  void annotateEffects(Graph* g) {\n+    // Generate the first world token\n+    const auto tokenGenerator = g->create(prim::Constant);", "path": "torch/csrc/jit/passes/annotate_effects.cpp", "position": 30, "original_position": 30, "commit_id": "f2f80212356100179d9b3a4b06e5d8d964a9342c", "original_commit_id": "ed7ae9a02e7cff3a5178513b58dec6466a83913e", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "body": "I'm pretty sure this will work badly with inlining of function calls. The token should be passed from the caller to the callee, instead of callee having its own independent copy.", "created_at": "2018-08-14T15:06:25Z", "updated_at": "2018-11-23T15:49:17Z", "html_url": "https://github.com/pytorch/pytorch/pull/10500#discussion_r209988412", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/10500", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/209988412"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/10500#discussion_r209988412"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/10500"}}, "body_html": "<p>I'm pretty sure this will work badly with inlining of function calls. The token should be passed from the caller to the callee, instead of callee having its own independent copy.</p>", "body_text": "I'm pretty sure this will work badly with inlining of function calls. The token should be passed from the caller to the callee, instead of callee having its own independent copy."}