{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/209984346", "pull_request_review_id": 146103838, "id": 209984346, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwOTk4NDM0Ng==", "diff_hunk": "@@ -20,6 +20,11 @@ std::unordered_set<Symbol> skip_list = {\n   //FIXME Same problem as in DCE - cpp & python PythonOp and CppOp should be\n   //FIXME treated as having side effects but ONNX depends on them being removed\n   prim::Print,\n+  // A memory fence implies a value is being mutated, so constant propagation\n+  // must be disallowed.", "path": "torch/csrc/jit/passes/constant_propagation.cpp", "position": 5, "original_position": 5, "commit_id": "f2f80212356100179d9b3a4b06e5d8d964a9342c", "original_commit_id": "ed7ae9a02e7cff3a5178513b58dec6466a83913e", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "body": "I can't see why would that be the case. It really depends on wha kind of side effects we're talking about, but \"local mutation\" as in here is generally a benign one. For example, most of the initial examples in your tests should be perfectly eligible for constant prop, as the list will effectively have the same shape at every run. The purpose of the token we pass around is to *serialize* those calls, not prevent any optimization on them.", "created_at": "2018-08-14T14:55:53Z", "updated_at": "2018-11-23T15:49:17Z", "html_url": "https://github.com/pytorch/pytorch/pull/10500#discussion_r209984346", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/10500", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/209984346"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/10500#discussion_r209984346"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/10500"}}, "body_html": "<p>I can't see why would that be the case. It really depends on wha kind of side effects we're talking about, but \"local mutation\" as in here is generally a benign one. For example, most of the initial examples in your tests should be perfectly eligible for constant prop, as the list will effectively have the same shape at every run. The purpose of the token we pass around is to <em>serialize</em> those calls, not prevent any optimization on them.</p>", "body_text": "I can't see why would that be the case. It really depends on wha kind of side effects we're talking about, but \"local mutation\" as in here is generally a benign one. For example, most of the initial examples in your tests should be perfectly eligible for constant prop, as the list will effectively have the same shape at every run. The purpose of the token we pass around is to serialize those calls, not prevent any optimization on them."}