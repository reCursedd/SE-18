{"url": "https://api.github.com/repos/pytorch/pytorch/issues/1291", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/1291/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/1291/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/1291/events", "html_url": "https://github.com/pytorch/pytorch/issues/1291", "id": 222585776, "node_id": "MDU6SXNzdWUyMjI1ODU3NzY=", "number": 1291, "title": "`list(model.Parameters())` behaves differently for custom `nn.module`", "user": {"login": "pavanramkumar", "id": 3664715, "node_id": "MDQ6VXNlcjM2NjQ3MTU=", "avatar_url": "https://avatars2.githubusercontent.com/u/3664715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pavanramkumar", "html_url": "https://github.com/pavanramkumar", "followers_url": "https://api.github.com/users/pavanramkumar/followers", "following_url": "https://api.github.com/users/pavanramkumar/following{/other_user}", "gists_url": "https://api.github.com/users/pavanramkumar/gists{/gist_id}", "starred_url": "https://api.github.com/users/pavanramkumar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pavanramkumar/subscriptions", "organizations_url": "https://api.github.com/users/pavanramkumar/orgs", "repos_url": "https://api.github.com/users/pavanramkumar/repos", "events_url": "https://api.github.com/users/pavanramkumar/events{/privacy}", "received_events_url": "https://api.github.com/users/pavanramkumar/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2017-04-19T00:51:41Z", "updated_at": "2017-04-19T00:58:37Z", "closed_at": "2017-04-19T00:58:37Z", "author_association": "NONE", "body_html": "<p>I'm trying to write a custom module. Listing its parameters seems to depend on whether you define an operation in <code>__init__()</code> as an instance variable.</p>\n<p>So for instance, this lists the parameters correctly:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">class</span> <span class=\"pl-en\">ThreeLayerNet</span>(<span class=\"pl-e\">torch</span>.<span class=\"pl-e\">nn</span>.<span class=\"pl-e\">Module</span>):\n  <span class=\"pl-k\">def</span> <span class=\"pl-c1\">__init__</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>, <span class=\"pl-smi\">D_in</span>, <span class=\"pl-smi\">H</span>, <span class=\"pl-smi\">D_out</span>):\n    <span class=\"pl-c1\">super</span>(ThreeLayerNet, <span class=\"pl-c1\">self</span>).<span class=\"pl-c1\">__init__</span>()\n    <span class=\"pl-c1\">self</span>.linear1 <span class=\"pl-k\">=</span> torch.nn.Linear(D_in, H)\n    <span class=\"pl-c1\">self</span>.linear2 <span class=\"pl-k\">=</span> torch.nn.Linear(H, H)\n    <span class=\"pl-c1\">self</span>.linear3 <span class=\"pl-k\">=</span> torch.nn.Linear(H, D_out)\n\n  <span class=\"pl-k\">def</span> <span class=\"pl-en\">forward</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>, <span class=\"pl-smi\">x</span>):\n    h_relu <span class=\"pl-k\">=</span> <span class=\"pl-c1\">self</span>.linear1(x).clamp(<span class=\"pl-v\">min</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">0</span>)\n    h_relu <span class=\"pl-k\">=</span> <span class=\"pl-c1\">self</span>.linear2(h_relu).clamp(<span class=\"pl-v\">min</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">0</span>)\n    y_pred <span class=\"pl-k\">=</span> <span class=\"pl-c1\">self</span>.linear3(h_relu)\n    <span class=\"pl-k\">return</span> y_pred\n\nD_in, H, D_out <span class=\"pl-k\">=</span> <span class=\"pl-c1\">1000</span>, <span class=\"pl-c1\">100</span>, <span class=\"pl-c1\">10</span>\nmodel <span class=\"pl-k\">=</span> ThreeLayerNet(D_in, H, D_out)\n<span class=\"pl-c1\">list</span>(model.parameters())</pre></div>\n<p>But this does not:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">class</span> <span class=\"pl-en\">ThreeLayerNet</span>(<span class=\"pl-e\">torch</span>.<span class=\"pl-e\">nn</span>.<span class=\"pl-e\">Module</span>):\n  <span class=\"pl-k\">def</span> <span class=\"pl-c1\">__init__</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>, <span class=\"pl-smi\">D_in</span>, <span class=\"pl-smi\">H</span>, <span class=\"pl-smi\">D_out</span>):\n    <span class=\"pl-c1\">super</span>(ThreeLayerNet, <span class=\"pl-c1\">self</span>).<span class=\"pl-c1\">__init__</span>()\n\n  <span class=\"pl-k\">def</span> <span class=\"pl-en\">forward</span>(<span class=\"pl-smi\"><span class=\"pl-smi\">self</span></span>, <span class=\"pl-smi\">x</span>):\n    h_relu <span class=\"pl-k\">=</span> torch.nn.Linear(D_in, H)(x).clamp(<span class=\"pl-v\">min</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">0</span>)\n    h_relu <span class=\"pl-k\">=</span> torch.nn.Linear(H, H)(h_relu).clamp(<span class=\"pl-v\">min</span><span class=\"pl-k\">=</span><span class=\"pl-c1\">0</span>)\n    y_pred <span class=\"pl-k\">=</span> torch.nn.Linear(H, D_out)(h_relu)\n    <span class=\"pl-k\">return</span> y_pred\n\nD_in, H, D_out <span class=\"pl-k\">=</span> <span class=\"pl-c1\">1000</span>, <span class=\"pl-c1\">100</span>, <span class=\"pl-c1\">10</span>\nmodel <span class=\"pl-k\">=</span> ThreeLayerNet(D_in, H, D_out)\n<span class=\"pl-c1\">list</span>(model.parameters())</pre></div>\n<p>Is this expected behavior? If so, it is sufficient to define all layers with parameters alone as instance variables, or do we also define non-linearities?</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-c1\">self</span>.activation1 <span class=\"pl-k\">=</span> torch.nn.Sigmoid()</pre></div>\n<p>Any help is appreciated. Thanks!</p>", "body_text": "I'm trying to write a custom module. Listing its parameters seems to depend on whether you define an operation in __init__() as an instance variable.\nSo for instance, this lists the parameters correctly:\nclass ThreeLayerNet(torch.nn.Module):\n  def __init__(self, D_in, H, D_out):\n    super(ThreeLayerNet, self).__init__()\n    self.linear1 = torch.nn.Linear(D_in, H)\n    self.linear2 = torch.nn.Linear(H, H)\n    self.linear3 = torch.nn.Linear(H, D_out)\n\n  def forward(self, x):\n    h_relu = self.linear1(x).clamp(min=0)\n    h_relu = self.linear2(h_relu).clamp(min=0)\n    y_pred = self.linear3(h_relu)\n    return y_pred\n\nD_in, H, D_out = 1000, 100, 10\nmodel = ThreeLayerNet(D_in, H, D_out)\nlist(model.parameters())\nBut this does not:\nclass ThreeLayerNet(torch.nn.Module):\n  def __init__(self, D_in, H, D_out):\n    super(ThreeLayerNet, self).__init__()\n\n  def forward(self, x):\n    h_relu = torch.nn.Linear(D_in, H)(x).clamp(min=0)\n    h_relu = torch.nn.Linear(H, H)(h_relu).clamp(min=0)\n    y_pred = torch.nn.Linear(H, D_out)(h_relu)\n    return y_pred\n\nD_in, H, D_out = 1000, 100, 10\nmodel = ThreeLayerNet(D_in, H, D_out)\nlist(model.parameters())\nIs this expected behavior? If so, it is sufficient to define all layers with parameters alone as instance variables, or do we also define non-linearities?\nself.activation1 = torch.nn.Sigmoid()\nAny help is appreciated. Thanks!", "body": "I'm trying to write a custom module. Listing its parameters seems to depend on whether you define an operation in `__init__()` as an instance variable. \r\n\r\nSo for instance, this lists the parameters correctly:\r\n\r\n```python\r\nclass ThreeLayerNet(torch.nn.Module):\r\n  def __init__(self, D_in, H, D_out):\r\n    super(ThreeLayerNet, self).__init__()\r\n    self.linear1 = torch.nn.Linear(D_in, H)\r\n    self.linear2 = torch.nn.Linear(H, H)\r\n    self.linear3 = torch.nn.Linear(H, D_out)\r\n\r\n  def forward(self, x):\r\n    h_relu = self.linear1(x).clamp(min=0)\r\n    h_relu = self.linear2(h_relu).clamp(min=0)\r\n    y_pred = self.linear3(h_relu)\r\n    return y_pred\r\n\r\nD_in, H, D_out = 1000, 100, 10\r\nmodel = ThreeLayerNet(D_in, H, D_out)\r\nlist(model.parameters())\r\n```\r\n\r\nBut this does not:\r\n\r\n```python\r\nclass ThreeLayerNet(torch.nn.Module):\r\n  def __init__(self, D_in, H, D_out):\r\n    super(ThreeLayerNet, self).__init__()\r\n\r\n  def forward(self, x):\r\n    h_relu = torch.nn.Linear(D_in, H)(x).clamp(min=0)\r\n    h_relu = torch.nn.Linear(H, H)(h_relu).clamp(min=0)\r\n    y_pred = torch.nn.Linear(H, D_out)(h_relu)\r\n    return y_pred\r\n\r\nD_in, H, D_out = 1000, 100, 10\r\nmodel = ThreeLayerNet(D_in, H, D_out)\r\nlist(model.parameters())\r\n```\r\n\r\nIs this expected behavior? If so, it is sufficient to define all layers with parameters alone as instance variables, or do we also define non-linearities?\r\n\r\n```python\r\nself.activation1 = torch.nn.Sigmoid()\r\n```\r\n\r\nAny help is appreciated. Thanks!"}