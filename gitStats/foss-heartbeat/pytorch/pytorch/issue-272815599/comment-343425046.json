{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/343425046", "html_url": "https://github.com/pytorch/pytorch/issues/3619#issuecomment-343425046", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/3619", "id": 343425046, "node_id": "MDEyOklzc3VlQ29tbWVudDM0MzQyNTA0Ng==", "user": {"login": "ChangYong-Oh", "id": 5415216, "node_id": "MDQ6VXNlcjU0MTUyMTY=", "avatar_url": "https://avatars0.githubusercontent.com/u/5415216?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ChangYong-Oh", "html_url": "https://github.com/ChangYong-Oh", "followers_url": "https://api.github.com/users/ChangYong-Oh/followers", "following_url": "https://api.github.com/users/ChangYong-Oh/following{/other_user}", "gists_url": "https://api.github.com/users/ChangYong-Oh/gists{/gist_id}", "starred_url": "https://api.github.com/users/ChangYong-Oh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ChangYong-Oh/subscriptions", "organizations_url": "https://api.github.com/users/ChangYong-Oh/orgs", "repos_url": "https://api.github.com/users/ChangYong-Oh/repos", "events_url": "https://api.github.com/users/ChangYong-Oh/events{/privacy}", "received_events_url": "https://api.github.com/users/ChangYong-Oh/received_events", "type": "User", "site_admin": false}, "created_at": "2017-11-10T09:39:17Z", "updated_at": "2017-11-10T09:43:04Z", "author_association": "NONE", "body_html": "<p>These are some error cases and ad-hoc solution to that in my machine.<br>\nHope this help.</p>\n<pre><code>def error_reproduce():\n\tn_data = 500\n\tndim = 1000\n\n\tb = Variable(torch.randn(ndim, n_data))\n\tA = Variable(torch.randn(ndim, ndim))\n\n\tA_sym = A.mm(A.t())\n\n\tpool = torch.multiprocessing.Pool(1)\n\tres = pool.apply_async(torch.gesv, args=(b, A))\n\tpool.close()\n\tpool.join()\n\treturn res.get()\n\n\ndef no_error_without_blas():\n\tn_data = 500\n\tndim = 1000\n\n\tb = Variable(torch.randn(ndim, n_data))\n\tA = Variable(torch.randn(ndim, ndim))\n\n\tpool = torch.multiprocessing.Pool(1)\n\tres = pool.apply_async(torch.gesv, args=(b, A))\n\tpool.close()\n\tpool.join()\n\treturn res.get()\n\n\ndef no_error_by_calling_pool_first():\n\tn_data = 500\n\tndim = 1000\n\n\tb = Variable(torch.randn(ndim, n_data))\n\tA = Variable(torch.randn(ndim, ndim))\n\n\tpool = torch.multiprocessing.Pool(1)\n\n\tA_sym = A.mm(A.t())\n\n\tres = pool.apply_async(torch.gesv, args=(b, A))\n\tpool.close()\n\tpool.join()\n\treturn res.get()\n</code></pre>\n<p>Only difference is the order of calling blas(torch.mm==addmm) and multiprocessing.Pool</p>", "body_text": "These are some error cases and ad-hoc solution to that in my machine.\nHope this help.\ndef error_reproduce():\n\tn_data = 500\n\tndim = 1000\n\n\tb = Variable(torch.randn(ndim, n_data))\n\tA = Variable(torch.randn(ndim, ndim))\n\n\tA_sym = A.mm(A.t())\n\n\tpool = torch.multiprocessing.Pool(1)\n\tres = pool.apply_async(torch.gesv, args=(b, A))\n\tpool.close()\n\tpool.join()\n\treturn res.get()\n\n\ndef no_error_without_blas():\n\tn_data = 500\n\tndim = 1000\n\n\tb = Variable(torch.randn(ndim, n_data))\n\tA = Variable(torch.randn(ndim, ndim))\n\n\tpool = torch.multiprocessing.Pool(1)\n\tres = pool.apply_async(torch.gesv, args=(b, A))\n\tpool.close()\n\tpool.join()\n\treturn res.get()\n\n\ndef no_error_by_calling_pool_first():\n\tn_data = 500\n\tndim = 1000\n\n\tb = Variable(torch.randn(ndim, n_data))\n\tA = Variable(torch.randn(ndim, ndim))\n\n\tpool = torch.multiprocessing.Pool(1)\n\n\tA_sym = A.mm(A.t())\n\n\tres = pool.apply_async(torch.gesv, args=(b, A))\n\tpool.close()\n\tpool.join()\n\treturn res.get()\n\nOnly difference is the order of calling blas(torch.mm==addmm) and multiprocessing.Pool", "body": "These are some error cases and ad-hoc solution to that in my machine.\r\nHope this help.\r\n```\r\ndef error_reproduce():\r\n\tn_data = 500\r\n\tndim = 1000\r\n\r\n\tb = Variable(torch.randn(ndim, n_data))\r\n\tA = Variable(torch.randn(ndim, ndim))\r\n\r\n\tA_sym = A.mm(A.t())\r\n\r\n\tpool = torch.multiprocessing.Pool(1)\r\n\tres = pool.apply_async(torch.gesv, args=(b, A))\r\n\tpool.close()\r\n\tpool.join()\r\n\treturn res.get()\r\n\r\n\r\ndef no_error_without_blas():\r\n\tn_data = 500\r\n\tndim = 1000\r\n\r\n\tb = Variable(torch.randn(ndim, n_data))\r\n\tA = Variable(torch.randn(ndim, ndim))\r\n\r\n\tpool = torch.multiprocessing.Pool(1)\r\n\tres = pool.apply_async(torch.gesv, args=(b, A))\r\n\tpool.close()\r\n\tpool.join()\r\n\treturn res.get()\r\n\r\n\r\ndef no_error_by_calling_pool_first():\r\n\tn_data = 500\r\n\tndim = 1000\r\n\r\n\tb = Variable(torch.randn(ndim, n_data))\r\n\tA = Variable(torch.randn(ndim, ndim))\r\n\r\n\tpool = torch.multiprocessing.Pool(1)\r\n\r\n\tA_sym = A.mm(A.t())\r\n\r\n\tres = pool.apply_async(torch.gesv, args=(b, A))\r\n\tpool.close()\r\n\tpool.join()\r\n\treturn res.get()\r\n```\r\n\r\nOnly difference is the order of calling blas(torch.mm==addmm) and multiprocessing.Pool"}