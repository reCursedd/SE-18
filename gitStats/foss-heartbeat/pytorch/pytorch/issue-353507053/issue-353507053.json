{"url": "https://api.github.com/repos/pytorch/pytorch/issues/10824", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/10824/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/10824/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/10824/events", "html_url": "https://github.com/pytorch/pytorch/pull/10824", "id": 353507053, "node_id": "MDExOlB1bGxSZXF1ZXN0MjEwNTQxMzg0", "number": 10824, "title": "Change Tensor/TensorImpl to use c10::intrusive_ptr", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2018-08-23T18:47:31Z", "updated_at": "2018-11-23T15:50:05Z", "closed_at": "2018-08-27T23:12:03Z", "author_association": "CONTRIBUTOR", "pull_request": {"url": "https://api.github.com/repos/pytorch/pytorch/pulls/10824", "html_url": "https://github.com/pytorch/pytorch/pull/10824", "diff_url": "https://github.com/pytorch/pytorch/pull/10824.diff", "patch_url": "https://github.com/pytorch/pytorch/pull/10824.patch"}, "body_html": "<p>Summary:<br>\nPull Request <span class=\"issue-keyword tooltipped tooltipped-se\" aria-label=\"This pull request closes pull request #10824.\">resolved</span>: <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"353507053\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/10824\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/pytorch/pytorch/pull/10824/hovercard\" href=\"https://github.com/pytorch/pytorch/pull/10824\">#10824</a></p>\n<p>API additions:</p>\n<ul>\n<li>Tensor(c10::intrusive_ptr&lt;TensorImpl,UndefinedTensor&gt;&amp;&amp;)</li>\n<li>Tensor(const c10::intrusive_ptr&lt;TensorImpl,UndefinedTensor&gt;&amp;)</li>\n<li>Tensor::operator=(Tensor&amp;&amp;) &amp;&amp; (for completeness sake)</li>\n<li>TensorBase::unsafeGetTensorImpl()</li>\n<li>TensorBase::unsafeReleaseTensorImpl()</li>\n<li>TensorBase::getIntrusivePtr()</li>\n<li>TensorImpl::type_id()</li>\n<li>Tensor::set_data()</li>\n<li>Tensor::is_same(Tensor)</li>\n<li>Tensor::use_count()</li>\n<li>Tensor::type_id()</li>\n<li>Tensor::scalar_type()</li>\n<li>WeakTensor::is_same(WeakTensor)</li>\n<li>intrusive_ptr::weak_use_count()</li>\n<li>weak_intrusive_ptr::weak_use_count()</li>\n<li>c10::raw::intrusive_ptr::{incref,decref,make_weak}</li>\n<li>c10::raw::weak_intrusive_ptr::{incref,decref,lock}</li>\n</ul>\n<p>API changes:</p>\n<ul>\n<li>Tensor::pImpl is no longer public (and now named tensor_impl_)\n<ul>\n<li>Most methods accessed this way are now accessible on Tensor<br>\nmaybe_zero_dim() and set_wrapped_number() being prominent exceptions<br>\n(they are now accessed through unsafeGetTensorImpl())</li>\n</ul>\n</li>\n<li>Type is no longer friend of Tensor</li>\n<li>TensorBase::reset(TensorImpl*) is deleted</li>\n<li>TensorBase::reset(TensorImpl*, bool should_retain) is deleted</li>\n<li>TensorBase::swap(TensorBaseImpl&amp;) is deleted; use std::swap instead</li>\n<li>TensorBase::get() is deleted; use unsafeGetTensorImpl() instead</li>\n<li>TensorBase::detach() is deleted; use unsafeReleaseTensorImpl() instead</li>\n<li>TensorBase::retain() is deleted; use _raw_incref() instead</li>\n<li>TensorBase::release() is deleted; use _raw_decref() instead</li>\n<li>WeakTensor lost most of its methods (it no longer inherits from<br>\nTensorBase)</li>\n<li>TensorImpl::storage() is now a const method</li>\n<li>Tensor(TensorBase) constructor removed, instead<br>\nwe go through getIntrusivePtr().  I'm not sure about<br>\nthis change; I happened to have accidentally removed the<br>\nTensorBase constructor and decided to fix call sites,<br>\nbut I could go the other way.</li>\n<li>detail::set_data() is deleted; use Tensor::set_data() instead</li>\n<li>c10::raw_intrusive_ptr_target removed; use the functions in c10::raw instead.<br>\n(The reason for this change, is that it is invalid to cast an intrusive_ptr_target*<br>\nto a raw_intrusive_ptr_target* to take advantage of the methods. But there is<br>\nno reason the incref/decref methods shouldn't also work on intrusive_ptr_target;<br>\nit is primarily an API consideration. We can be more standards compliant by<br>\nkeeping them as functions, which are universally applicable.)</li>\n<li>intrusive_ptr::reclaim() and weak_intrusive_ptr::reclaim() now work on<br>\npointers of the NullType. (This counts as a bug fix, because the documentation<br>\nspecified that pointers produced by release() are valid to reclaim(), and<br>\na release() on a null intrusive_ptr produces the NullType::singleton())</li>\n</ul>\n<p>Bug fixes:</p>\n<ul>\n<li>Dispatch code for mutable references incorrectly returned<br>\na reference to a value argument (which would immediately<br>\ngo out of scope).  They now correctly return a tensor by<br>\nvalue.</li>\n<li>intrusive_ptr copy/move assignment did not work correctly when<br>\nan object was assigned to itself. We now check for this case and<br>\nno-op if so. (This bug manifested itself as a Tensor mysteriously<br>\nbecoming an UndefinedTensor after lines of code like<br>\n'x = x.mul_(y)'</li>\n</ul>\n<p>Other changes:</p>\n<ul>\n<li>The checked cast functions in Utils.h have now been<br>\nrenamed and detemplatized into checked unwrap functions.</li>\n<li>Added type_id() and scalar_type() methods to Tensor</li>\n<li>pImpl is no longer public</li>\n<li>Documented what the &amp;&amp; overloads are doing</li>\n<li>All occurrences of 'new TensorImpl' (and similar spellings, like 'new THTensor')<br>\nhave been expunged. This is NO LONGER a valid way to create a new<br>\ntensor, and if you do this, upon your first incref, you will catch an ASSERT<br>\nfailure saying that only tensors created by intrusive_ptr::release() are valid<br>\nto reclaim(). Use c10::make_intrusive instead in this situation.</li>\n<li>IValue is adjusted to use intrusive_ptr instead of Retainable, and all<br>\nother sub-classes of Retainable were modified to use intrusive_ptr.<br>\nWhen doing this, I had to make the constructors of sub-classes like<br>\nConstantList public, so that c10::make_intrusive could invoke them.  Fortunately,<br>\nif you incorrectly stack allocate a ConstantList, and then try to get an<br>\nintrusive_ptr to it, it will fail, as stack allocated ConstantLists have refcount 0.</li>\n<li>IValue very narrowly sidesteps the problem of handling NullType, as it<br>\nconsiders intrusive_ptr identical to intrusive_ptr&lt;TensorImpl, UndefinedTensor&gt;<br>\nwhich is not always true. This was always the case, but there's now a comment<br>\nexplaining what's going on.</li>\n</ul>\n<p>Some MSVC bugs were uncovered during the preparation of this patch.<br>\nThey are documented as comments in the code.</p>\n<p>Differential Revision: D9481140</p>", "body_text": "Summary:\nPull Request resolved: #10824\nAPI additions:\n\nTensor(c10::intrusive_ptr<TensorImpl,UndefinedTensor>&&)\nTensor(const c10::intrusive_ptr<TensorImpl,UndefinedTensor>&)\nTensor::operator=(Tensor&&) && (for completeness sake)\nTensorBase::unsafeGetTensorImpl()\nTensorBase::unsafeReleaseTensorImpl()\nTensorBase::getIntrusivePtr()\nTensorImpl::type_id()\nTensor::set_data()\nTensor::is_same(Tensor)\nTensor::use_count()\nTensor::type_id()\nTensor::scalar_type()\nWeakTensor::is_same(WeakTensor)\nintrusive_ptr::weak_use_count()\nweak_intrusive_ptr::weak_use_count()\nc10::raw::intrusive_ptr::{incref,decref,make_weak}\nc10::raw::weak_intrusive_ptr::{incref,decref,lock}\n\nAPI changes:\n\nTensor::pImpl is no longer public (and now named tensor_impl_)\n\nMost methods accessed this way are now accessible on Tensor\nmaybe_zero_dim() and set_wrapped_number() being prominent exceptions\n(they are now accessed through unsafeGetTensorImpl())\n\n\nType is no longer friend of Tensor\nTensorBase::reset(TensorImpl*) is deleted\nTensorBase::reset(TensorImpl*, bool should_retain) is deleted\nTensorBase::swap(TensorBaseImpl&) is deleted; use std::swap instead\nTensorBase::get() is deleted; use unsafeGetTensorImpl() instead\nTensorBase::detach() is deleted; use unsafeReleaseTensorImpl() instead\nTensorBase::retain() is deleted; use _raw_incref() instead\nTensorBase::release() is deleted; use _raw_decref() instead\nWeakTensor lost most of its methods (it no longer inherits from\nTensorBase)\nTensorImpl::storage() is now a const method\nTensor(TensorBase) constructor removed, instead\nwe go through getIntrusivePtr().  I'm not sure about\nthis change; I happened to have accidentally removed the\nTensorBase constructor and decided to fix call sites,\nbut I could go the other way.\ndetail::set_data() is deleted; use Tensor::set_data() instead\nc10::raw_intrusive_ptr_target removed; use the functions in c10::raw instead.\n(The reason for this change, is that it is invalid to cast an intrusive_ptr_target*\nto a raw_intrusive_ptr_target* to take advantage of the methods. But there is\nno reason the incref/decref methods shouldn't also work on intrusive_ptr_target;\nit is primarily an API consideration. We can be more standards compliant by\nkeeping them as functions, which are universally applicable.)\nintrusive_ptr::reclaim() and weak_intrusive_ptr::reclaim() now work on\npointers of the NullType. (This counts as a bug fix, because the documentation\nspecified that pointers produced by release() are valid to reclaim(), and\na release() on a null intrusive_ptr produces the NullType::singleton())\n\nBug fixes:\n\nDispatch code for mutable references incorrectly returned\na reference to a value argument (which would immediately\ngo out of scope).  They now correctly return a tensor by\nvalue.\nintrusive_ptr copy/move assignment did not work correctly when\nan object was assigned to itself. We now check for this case and\nno-op if so. (This bug manifested itself as a Tensor mysteriously\nbecoming an UndefinedTensor after lines of code like\n'x = x.mul_(y)'\n\nOther changes:\n\nThe checked cast functions in Utils.h have now been\nrenamed and detemplatized into checked unwrap functions.\nAdded type_id() and scalar_type() methods to Tensor\npImpl is no longer public\nDocumented what the && overloads are doing\nAll occurrences of 'new TensorImpl' (and similar spellings, like 'new THTensor')\nhave been expunged. This is NO LONGER a valid way to create a new\ntensor, and if you do this, upon your first incref, you will catch an ASSERT\nfailure saying that only tensors created by intrusive_ptr::release() are valid\nto reclaim(). Use c10::make_intrusive instead in this situation.\nIValue is adjusted to use intrusive_ptr instead of Retainable, and all\nother sub-classes of Retainable were modified to use intrusive_ptr.\nWhen doing this, I had to make the constructors of sub-classes like\nConstantList public, so that c10::make_intrusive could invoke them.  Fortunately,\nif you incorrectly stack allocate a ConstantList, and then try to get an\nintrusive_ptr to it, it will fail, as stack allocated ConstantLists have refcount 0.\nIValue very narrowly sidesteps the problem of handling NullType, as it\nconsiders intrusive_ptr identical to intrusive_ptr<TensorImpl, UndefinedTensor>\nwhich is not always true. This was always the case, but there's now a comment\nexplaining what's going on.\n\nSome MSVC bugs were uncovered during the preparation of this patch.\nThey are documented as comments in the code.\nDifferential Revision: D9481140", "body": "Summary:\r\nPull Request resolved: https://github.com/pytorch/pytorch/pull/10824\r\n\r\nAPI additions:\r\n- Tensor(c10::intrusive_ptr<TensorImpl,UndefinedTensor>&&)\r\n- Tensor(const c10::intrusive_ptr<TensorImpl,UndefinedTensor>&)\r\n- Tensor::operator=(Tensor&&) && (for completeness sake)\r\n- TensorBase::unsafeGetTensorImpl()\r\n- TensorBase::unsafeReleaseTensorImpl()\r\n- TensorBase::getIntrusivePtr()\r\n- TensorImpl::type_id()\r\n- Tensor::set_data()\r\n- Tensor::is_same(Tensor)\r\n- Tensor::use_count()\r\n- Tensor::type_id()\r\n- Tensor::scalar_type()\r\n- WeakTensor::is_same(WeakTensor)\r\n- intrusive_ptr::weak_use_count()\r\n- weak_intrusive_ptr::weak_use_count()\r\n- c10::raw::intrusive_ptr::{incref,decref,make_weak}\r\n- c10::raw::weak_intrusive_ptr::{incref,decref,lock}\r\n\r\nAPI changes:\r\n- Tensor::pImpl is no longer public (and now named tensor_impl_)\r\n    - Most methods accessed this way are now accessible on Tensor\r\n      maybe_zero_dim() and set_wrapped_number() being prominent exceptions\r\n      (they are now accessed through unsafeGetTensorImpl())\r\n- Type is no longer friend of Tensor\r\n- TensorBase::reset(TensorImpl*) is deleted\r\n- TensorBase::reset(TensorImpl*, bool should_retain) is deleted\r\n- TensorBase::swap(TensorBaseImpl&) is deleted; use std::swap instead\r\n- TensorBase::get() is deleted; use unsafeGetTensorImpl() instead\r\n- TensorBase::detach() is deleted; use unsafeReleaseTensorImpl() instead\r\n- TensorBase::retain() is deleted; use _raw_incref() instead\r\n- TensorBase::release() is deleted; use _raw_decref() instead\r\n- WeakTensor lost most of its methods (it no longer inherits from\r\n  TensorBase)\r\n- TensorImpl::storage() is now a const method\r\n- Tensor(TensorBase) constructor removed, instead\r\n  we go through getIntrusivePtr().  I'm not sure about\r\n  this change; I happened to have accidentally removed the\r\n  TensorBase constructor and decided to fix call sites,\r\n  but I could go the other way.\r\n- detail::set_data() is deleted; use Tensor::set_data() instead\r\n- c10::raw_intrusive_ptr_target removed; use the functions in c10::raw instead.\r\n  (The reason for this change, is that it is invalid to cast an intrusive_ptr_target*\r\n  to a raw_intrusive_ptr_target* to take advantage of the methods. But there is\r\n  no reason the incref/decref methods shouldn't also work on intrusive_ptr_target;\r\n  it is primarily an API consideration. We can be more standards compliant by\r\n  keeping them as functions, which are universally applicable.)\r\n- intrusive_ptr::reclaim() and weak_intrusive_ptr::reclaim() now work on\r\n  pointers of the NullType. (This counts as a bug fix, because the documentation\r\n  specified that pointers produced by release() are valid to reclaim(), and\r\n  a release() on a null intrusive_ptr produces the NullType::singleton())\r\n\r\nBug fixes:\r\n- Dispatch code for mutable references incorrectly returned\r\n  a reference to a value argument (which would immediately\r\n  go out of scope).  They now correctly return a tensor by\r\n  value.\r\n- intrusive_ptr copy/move assignment did not work correctly when\r\n  an object was assigned to itself. We now check for this case and\r\n  no-op if so. (This bug manifested itself as a Tensor mysteriously\r\n  becoming an UndefinedTensor after lines of code like\r\n  'x = x.mul_(y)'\r\n\r\nOther changes:\r\n- The checked cast functions in Utils.h have now been\r\n  renamed and detemplatized into checked unwrap functions.\r\n- Added type_id() and scalar_type() methods to Tensor\r\n- pImpl is no longer public\r\n- Documented what the && overloads are doing\r\n- All occurrences of 'new TensorImpl' (and similar spellings, like 'new THTensor')\r\n  have been expunged. This is NO LONGER a valid way to create a new\r\n  tensor, and if you do this, upon your first incref, you will catch an ASSERT\r\n  failure saying that only tensors created by intrusive_ptr::release() are valid\r\n  to reclaim(). Use c10::make_intrusive instead in this situation.\r\n- IValue is adjusted to use intrusive_ptr instead of Retainable, and all\r\n  other sub-classes of Retainable were modified to use intrusive_ptr.\r\n  When doing this, I had to make the constructors of sub-classes like\r\n  ConstantList public, so that c10::make_intrusive could invoke them.  Fortunately,\r\n  if you incorrectly stack allocate a ConstantList, and then try to get an\r\n  intrusive_ptr to it, it will fail, as stack allocated ConstantLists have refcount 0.\r\n- IValue very narrowly sidesteps the problem of handling NullType, as it\r\n  considers intrusive_ptr<TensorImpl> identical to intrusive_ptr<TensorImpl, UndefinedTensor>\r\n  which is not always true. This was always the case, but there's now a comment\r\n  explaining what's going on.\r\n\r\nSome MSVC bugs were uncovered during the preparation of this patch.\r\nThey are documented as comments in the code.\r\n\r\nDifferential Revision: D9481140"}