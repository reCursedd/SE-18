{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/212814370", "pull_request_review_id": 149526476, "id": 212814370, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMjgxNDM3MA==", "diff_hunk": "@@ -6,15 +6,15 @@ namespace at {\n \n struct AT_API UndefinedTensor final : public TensorImpl {\n public:\n-  static inline UndefinedTensor * singleton() {\n+  static constexpr inline TensorImpl * singleton() {", "path": "aten/src/ATen/UndefinedTensor.h", "position": null, "original_position": 5, "commit_id": "d0d160a5f5d5784bcc7111819ae20f9947b2a4e0", "original_commit_id": "7b00a9dace84566b95811ebc988566c866d36b54", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "body": "I'm not sure what you mean by this question. I guess I can try restating the justification: if you `s/TensorImpl/UndefinedTensor/`, a static assert in `c10::intrusive_ptr` fails, because when you pass UndefinedTensor as the NullType to `c10::intrusive_ptr<TensorImpl, UndefinedTensor>`, it checks that `UndefinedTensor::singleton()` returns a `TensorImpl*` (NOT the refined type.)\r\n\r\nAs it turns out, no one really needs the refined `UndefinedTensor` type (because it's purpose in life is to serve as an implementation of the `TensorImpl` interface), so this change didn't have any other consequences.", "created_at": "2018-08-26T04:09:03Z", "updated_at": "2018-11-23T15:50:02Z", "html_url": "https://github.com/pytorch/pytorch/pull/10824#discussion_r212814370", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/10824", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/212814370"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/10824#discussion_r212814370"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/10824"}}, "body_html": "<p>I'm not sure what you mean by this question. I guess I can try restating the justification: if you <code>s/TensorImpl/UndefinedTensor/</code>, a static assert in <code>c10::intrusive_ptr</code> fails, because when you pass UndefinedTensor as the NullType to <code>c10::intrusive_ptr&lt;TensorImpl, UndefinedTensor&gt;</code>, it checks that <code>UndefinedTensor::singleton()</code> returns a <code>TensorImpl*</code> (NOT the refined type.)</p>\n<p>As it turns out, no one really needs the refined <code>UndefinedTensor</code> type (because it's purpose in life is to serve as an implementation of the <code>TensorImpl</code> interface), so this change didn't have any other consequences.</p>", "body_text": "I'm not sure what you mean by this question. I guess I can try restating the justification: if you s/TensorImpl/UndefinedTensor/, a static assert in c10::intrusive_ptr fails, because when you pass UndefinedTensor as the NullType to c10::intrusive_ptr<TensorImpl, UndefinedTensor>, it checks that UndefinedTensor::singleton() returns a TensorImpl* (NOT the refined type.)\nAs it turns out, no one really needs the refined UndefinedTensor type (because it's purpose in life is to serve as an implementation of the TensorImpl interface), so this change didn't have any other consequences.", "in_reply_to_id": 212674196}