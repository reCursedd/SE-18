{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/212813248", "pull_request_review_id": 149525287, "id": 212813248, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMjgxMzI0OA==", "diff_hunk": "@@ -2,107 +2,52 @@\n \n #include \"ATen/TensorImpl.h\"\n #include \"ATen/UndefinedTensor.h\"\n+#include \"ATen/core/Error.h\"\n \n namespace at { namespace detail {\n \n-// TensorBaseImpl is the base class for Tensor which handles the reference counting\n-template<bool is_strong>\n-struct TensorBaseImpl {\n-  TensorBaseImpl(): TensorBaseImpl(UndefinedTensor::singleton(), false) {}\n-  TensorBaseImpl(TensorImpl * self, bool should_retain)\n-  : pImpl(self) {\n-    if (pImpl == nullptr) {\n+// TensorBaseImpl is the base class for Tensor.\n+// TODO: Eliminate this, once we remove TensorBase from Scalar.  At\n+// the moment it's only used to break an include cycle for Scalar\n+struct TensorBase {\n+  TensorBase() {}\n+  TensorBase(TensorImpl * tensor_impl, bool retain) : tensor_impl_(c10::intrusive_ptr<TensorImpl, UndefinedTensor>::reclaim(tensor_impl)) {\n+    if (tensor_impl == nullptr) {\n       throw std::runtime_error(\"TensorBaseImpl with nullptr not supported\");\n     }\n-    if(should_retain && pImpl != UndefinedTensor::singleton()) {\n-      retain();\n+    if (retain) {\n+      tensor_impl->_raw_incref();\n     }\n   }\n-  TensorBaseImpl(const TensorBaseImpl & rhs)\n-  : pImpl(rhs.pImpl) {\n-    if (pImpl != UndefinedTensor::singleton()) {\n-      retain();\n-    }\n-  }\n-  TensorBaseImpl(TensorBaseImpl && rhs) noexcept\n-  : pImpl(rhs.pImpl) {\n-    rhs.pImpl = UndefinedTensor::singleton();\n-  }\n-  ~TensorBaseImpl() {\n-    if (pImpl != UndefinedTensor::singleton()) {\n-      release();\n-    }\n-  }\n-  TensorBaseImpl & operator=(TensorBaseImpl && rhs) & {\n-    rhs.swap(*this);\n-    return *this;\n-  }\n-  TensorBaseImpl & operator=(TensorBaseImpl const & rhs) & {\n-    //TensorBaseImpl ctor retains original rhs.pImpl\n-    //then rhs.pImpl is swapped with this->pImpl\n-    //finally TensorBaseImpl dtor releases rhs.pImpl, which was originally this->pImpl\n-    TensorBaseImpl(rhs).swap(*this);\n-    return *this;\n-  }\n+  TensorBase(c10::intrusive_ptr<TensorImpl, UndefinedTensor>&& ptr) : tensor_impl_(std::move(ptr)) {}\n+  TensorBase(const c10::intrusive_ptr<TensorImpl, UndefinedTensor>& ptr) : tensor_impl_(ptr) {}\n+\n   int64_t dim() const {\n-    if (is_strong) {\n-      return pImpl->dim();\n-    } else {\n-      AT_ERROR(\"Can't call dim() on a WeakTensor\");\n-    }\n-  }\n-  void reset() {\n-    TensorBaseImpl().swap(*this);\n+    return tensor_impl_->dim();\n   }\n-  void reset(TensorImpl * rhs) {\n-    TensorBaseImpl(rhs, true).swap(*this);\n-  }\n-  void reset(TensorImpl * rhs, bool should_retain) {\n-    TensorBaseImpl(rhs, should_retain).swap(*this );\n-  }\n-  void swap(TensorBaseImpl & rhs) {\n-    TensorImpl * tmp = pImpl;\n-    pImpl = rhs.pImpl;\n-    rhs.pImpl = tmp;\n+\n+  TensorImpl * unsafeGetTensorImpl() const {\n+    return tensor_impl_.get();\n   }\n-  TensorImpl * get() const {\n-    return pImpl;\n+  TensorImpl * unsafeReleaseTensorImpl() {\n+    return tensor_impl_.release();\n   }\n-  TensorImpl * detach() {\n-    TensorImpl * ret = pImpl;\n-    pImpl = UndefinedTensor::singleton();\n-    return ret;\n+  const c10::intrusive_ptr<TensorImpl, UndefinedTensor>& getIntrusivePtr() const {\n+    return tensor_impl_;\n   }\n \n   bool defined() const {\n-    return pImpl != UndefinedTensor::singleton();\n+    return tensor_impl_;\n   }\n \n-  friend struct at::Type;\n-\n-  //TODO(zach): sort out friend structes\n-public:\n-  TensorImpl * pImpl;\n-\n-private:\n-  void retain() {\n-    if (is_strong) {\n-      pImpl->retain();\n-    } else {\n-      pImpl->weak_retain();\n-    }\n+  void reset() {\n+    tensor_impl_.reset();\n   }\n \n-  void release() {\n-    if (is_strong) {\n-      pImpl->release();\n-    } else {\n-      pImpl->weak_release();\n-    }\n-  }\n-};\n+  friend struct WeakTensor;\n \n-using TensorBase = TensorBaseImpl<true>;\n-using WeakTensorBase = TensorBaseImpl<false>;\n+protected:\n+  c10::intrusive_ptr<TensorImpl, UndefinedTensor> tensor_impl_;", "path": "aten/src/ATen/TensorBase.h", "position": 132, "original_position": 132, "commit_id": "d0d160a5f5d5784bcc7111819ae20f9947b2a4e0", "original_commit_id": "7b00a9dace84566b95811ebc988566c866d36b54", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "body": "Two reasons: (1) Storage prior to this patch was using `storage_impl_` so I wanted to make it consistent, and (2) pImpl was historically used to refer to `TensorImpl*` raw pointer, so when I changed the type I wanted force myself to update all of the call sites (in case something typechecked, but was wrong).", "created_at": "2018-08-26T02:27:30Z", "updated_at": "2018-11-23T15:50:01Z", "html_url": "https://github.com/pytorch/pytorch/pull/10824#discussion_r212813248", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/10824", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/212813248"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/10824#discussion_r212813248"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/10824"}}, "body_html": "<p>Two reasons: (1) Storage prior to this patch was using <code>storage_impl_</code> so I wanted to make it consistent, and (2) pImpl was historically used to refer to <code>TensorImpl*</code> raw pointer, so when I changed the type I wanted force myself to update all of the call sites (in case something typechecked, but was wrong).</p>", "body_text": "Two reasons: (1) Storage prior to this patch was using storage_impl_ so I wanted to make it consistent, and (2) pImpl was historically used to refer to TensorImpl* raw pointer, so when I changed the type I wanted force myself to update all of the call sites (in case something typechecked, but was wrong).", "in_reply_to_id": 212680476}