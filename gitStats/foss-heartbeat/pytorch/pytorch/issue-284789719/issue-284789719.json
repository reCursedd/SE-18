{"url": "https://api.github.com/repos/pytorch/pytorch/issues/4367", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/4367/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/4367/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/4367/events", "html_url": "https://github.com/pytorch/pytorch/pull/4367", "id": 284789719, "node_id": "MDExOlB1bGxSZXF1ZXN0MTYwMjk4MjAz", "number": 4367, "title": "Fix creating tensors with np.longlong array", "user": {"login": "zou3519", "id": 5652049, "node_id": "MDQ6VXNlcjU2NTIwNDk=", "avatar_url": "https://avatars3.githubusercontent.com/u/5652049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zou3519", "html_url": "https://github.com/zou3519", "followers_url": "https://api.github.com/users/zou3519/followers", "following_url": "https://api.github.com/users/zou3519/following{/other_user}", "gists_url": "https://api.github.com/users/zou3519/gists{/gist_id}", "starred_url": "https://api.github.com/users/zou3519/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zou3519/subscriptions", "organizations_url": "https://api.github.com/users/zou3519/orgs", "repos_url": "https://api.github.com/users/zou3519/repos", "events_url": "https://api.github.com/users/zou3519/events{/privacy}", "received_events_url": "https://api.github.com/users/zou3519/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2017-12-27T20:21:01Z", "updated_at": "2018-01-03T19:50:16Z", "closed_at": "2017-12-28T00:15:04Z", "author_association": "CONTRIBUTOR", "pull_request": {"url": "https://api.github.com/repos/pytorch/pytorch/pulls/4367", "html_url": "https://github.com/pytorch/pytorch/pull/4367", "diff_url": "https://github.com/pytorch/pytorch/pull/4367.diff", "patch_url": "https://github.com/pytorch/pytorch/pull/4367.patch"}, "body_html": "<p><span class=\"issue-keyword tooltipped tooltipped-se\" aria-label=\"This pull request closes issue #4363.\">Fixes</span> <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"284729606\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/4363\" data-hovercard-type=\"issue\" data-hovercard-url=\"/pytorch/pytorch/issues/4363/hovercard\" href=\"https://github.com/pytorch/pytorch/issues/4363\">#4363</a>.<br>\n<span class=\"issue-keyword tooltipped tooltipped-se\" aria-label=\"This pull request closes issue #4364.\">Fixes</span> <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"284732161\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/4364\" data-hovercard-type=\"issue\" data-hovercard-url=\"/pytorch/pytorch/issues/4364/hovercard\" href=\"https://github.com/pytorch/pytorch/issues/4364\">#4364</a>.</p>\n<p>When one creates an <code>ndarray</code> with <code>np.longlong</code> type, calling <code>.dtype</code> on the <code>ndarray</code> prints <code>np.int64</code>. As far as I can tell, the <code>np.longlong</code> type is equivalent to <code>np.int64</code>.</p>\n<p>However, in C code, the <code>NPY_LONGLONG</code> macro has a different value from the <code>NPY_INT64</code> macro.</p>\n<p>This makes it so that we treat <code>NPY_LONGLONG</code> the same way as <code>NPY_INT64</code>. Alternatively, to fix these issues, I could reject <code>NPY_LONGLONG</code> and include better error messages but as far as I can tell <code>np.longlong</code> and <code>np.int64</code> are the same.</p>\n<h3>Test Plan</h3>\n<p>Added a unit test case for creating tensors with <code>np.longlong</code></p>\n<p>Run the following (each script is from a separate issue) on python 2.7 and assert output is correct:</p>\n<pre><code>import torch\nimport numpy as np\nany_number = long(2)\na = np.arange(0, any_number)\nprint(a)\nb = torch.Tensor(a)\nprint(b)\n</code></pre>\n<pre><code>import torch\nimport numpy as np\nany_number = long(2)\na = np.arange(0, any_number)\nprint(a, a.dtype)\nb = torch.from_numpy(a)\nprint(b)\n</code></pre>", "body_text": "Fixes #4363.\nFixes #4364.\nWhen one creates an ndarray with np.longlong type, calling .dtype on the ndarray prints np.int64. As far as I can tell, the np.longlong type is equivalent to np.int64.\nHowever, in C code, the NPY_LONGLONG macro has a different value from the NPY_INT64 macro.\nThis makes it so that we treat NPY_LONGLONG the same way as NPY_INT64. Alternatively, to fix these issues, I could reject NPY_LONGLONG and include better error messages but as far as I can tell np.longlong and np.int64 are the same.\nTest Plan\nAdded a unit test case for creating tensors with np.longlong\nRun the following (each script is from a separate issue) on python 2.7 and assert output is correct:\nimport torch\nimport numpy as np\nany_number = long(2)\na = np.arange(0, any_number)\nprint(a)\nb = torch.Tensor(a)\nprint(b)\n\nimport torch\nimport numpy as np\nany_number = long(2)\na = np.arange(0, any_number)\nprint(a, a.dtype)\nb = torch.from_numpy(a)\nprint(b)", "body": "Fixes #4363.\r\nFixes #4364.\r\n\r\nWhen one creates an `ndarray` with `np.longlong` type, calling `.dtype` on the `ndarray` prints `np.int64`. As far as I can tell, the `np.longlong` type is equivalent to `np.int64`.\r\n\r\nHowever, in C code, the `NPY_LONGLONG` macro has a different value from the `NPY_INT64` macro.\r\n\r\nThis makes it so that we treat `NPY_LONGLONG` the same way as `NPY_INT64`. Alternatively, to fix these issues, I could reject `NPY_LONGLONG` and include better error messages but as far as I can tell `np.longlong` and `np.int64` are the same.\r\n\r\n### Test Plan\r\nAdded a unit test case for creating tensors with `np.longlong`\r\n\r\nRun the following (each script is from a separate issue) on python 2.7 and assert output is correct:\r\n```\r\nimport torch\r\nimport numpy as np\r\nany_number = long(2)\r\na = np.arange(0, any_number)\r\nprint(a)\r\nb = torch.Tensor(a)\r\nprint(b)\r\n```\r\n```\r\nimport torch\r\nimport numpy as np\r\nany_number = long(2)\r\na = np.arange(0, any_number)\r\nprint(a, a.dtype)\r\nb = torch.from_numpy(a)\r\nprint(b)\r\n```"}