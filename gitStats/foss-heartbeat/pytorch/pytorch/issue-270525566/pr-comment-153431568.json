{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/153431568", "pull_request_review_id": 79428071, "id": 153431568, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE1MzQzMTU2OA==", "diff_hunk": "@@ -0,0 +1,232 @@\n+#pragma once\n+\n+#include \"../DataChannel.hpp\"\n+#include \"DataChannelUtils.hpp\"\n+\n+#include <nccl.h>\n+\n+#include <utility>\n+#include <memory>\n+#include <string>\n+#include <unordered_map>\n+#include <vector>\n+\n+\n+#define NCCL_CHECK(cmd) do {                                  \\\n+  ncclResult_t error = cmd;                                   \\\n+  if (error != ncclSuccess) {                                 \\\n+    std::string err = \"NCCL error in: \" +                     \\\n+                      std::string(__FILE__) + \":\" +           \\\n+                      std::to_string(__LINE__) + \", \" +       \\\n+                      std::string(ncclGetErrorString(error)); \\\n+    throw std::runtime_error(err);                            \\\n+  }                                                           \\\n+} while (0)\n+\n+\n+namespace thd {\n+\n+// Type aliasing\n+using NcclResourcePair =\n+  std::pair<std::vector<ncclComm_t>*, std::vector<cudaEvent_t>*>;\n+\n+struct DataChannelNccl : DataChannel {\n+\n+  // Nothing to implement\n+  struct RequestNccl : DataChannel::Request {};\n+\n+  // Wrapper on the pair of NCCL resources\n+  class NcclResources {\n+\n+  public:\n+\n+    NcclResources() = default;\n+    NcclResources(std::unique_ptr<std::vector<ncclComm_t>>&& ncclComm,\n+                  std::unique_ptr<std::vector<cudaEvent_t>>&& event):\n+\n+      _commEventPair(std::pair<std::unique_ptr<std::vector<ncclComm_t>>,\n+                               std::unique_ptr<std::vector<cudaEvent_t>>>\n+                               (std::move(ncclComm), std::move(event))) {}\n+    // Delete copy and assignment ctors\n+    NcclResources(const NcclResources&) = delete;\n+    NcclResources& operator=(const NcclResources&) = delete;\n+\n+    // Move ctors by default\n+    NcclResources(NcclResources&&) = default;\n+    NcclResources& operator=(NcclResources&&) = default;\n+\n+    // Nccl Communicator Getter\n+    std::vector<ncclComm_t>* ncclComms() {\n+      return _commEventPair.first.get();\n+    }\n+\n+    // Nccl CUDA event Getter\n+    std::vector<cudaEvent_t>* ncclCudaEvents() {\n+      return _commEventPair.second.get();\n+    }\n+\n+  private:\n+\n+    std::pair<std::unique_ptr<std::vector<ncclComm_t>>,\n+              std::unique_ptr<std::vector<cudaEvent_t>>> _commEventPair;", "path": "torch/lib/THD/base/data_channels/DataChannelNccl.hpp", "position": 71, "original_position": 71, "commit_id": "9400fd54da0d3b3a27b93cc4af8bb4c7a29b47d2", "original_commit_id": "e2ee0c8f846ebc17f4b0cb1233c7bedbdd76d048", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "body": "They will always be very small, so any costs you could possibly pay because of missing a move (I'm also looking for missed moves when reviewing), are probably outweighed by the cost of double indirection when accessing memory all the time. Storing them as two members is going to make the code a lot clearer - if you didn't make them private, you could just access them like regular fields, and wouldn't need `NcclResourcePair` at all - you could just pass `NcclResources&` or `NcclResources*` around and have everything work just fine.", "created_at": "2017-11-28T09:14:08Z", "updated_at": "2018-11-23T15:36:54Z", "html_url": "https://github.com/pytorch/pytorch/pull/3435#discussion_r153431568", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/3435", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/153431568"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/3435#discussion_r153431568"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/3435"}}, "body_html": "<p>They will always be very small, so any costs you could possibly pay because of missing a move (I'm also looking for missed moves when reviewing), are probably outweighed by the cost of double indirection when accessing memory all the time. Storing them as two members is going to make the code a lot clearer - if you didn't make them private, you could just access them like regular fields, and wouldn't need <code>NcclResourcePair</code> at all - you could just pass <code>NcclResources&amp;</code> or <code>NcclResources*</code> around and have everything work just fine.</p>", "body_text": "They will always be very small, so any costs you could possibly pay because of missing a move (I'm also looking for missed moves when reviewing), are probably outweighed by the cost of double indirection when accessing memory all the time. Storing them as two members is going to make the code a lot clearer - if you didn't make them private, you could just access them like regular fields, and wouldn't need NcclResourcePair at all - you could just pass NcclResources& or NcclResources* around and have everything work just fine.", "in_reply_to_id": 152941993}