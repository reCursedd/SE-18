{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/86693039", "pull_request_review_id": 7338159, "id": 86693039, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDg2NjkzMDM5", "diff_hunk": "@@ -321,25 +321,134 @@ PyObject * THPStorage_(_share_fd)(THPStorage *self)\n   PyTuple_SET_ITEM(tuple.get(), 1, size.release());\n   return tuple.release();\n }\n+#endif\n+\n+#ifdef THC_GENERIC_FILE\n+static PyObject * THPStorage_(_share_cuda)(THPStorage *self)\n+{\n+  THStorage *storage = self->cdata;\n+  THPObjectPtr tuple = PyTuple_New(5);\n+  THPObjectPtr device = PyLong_FromLong(storage->device);\n+  THPObjectPtr _handle = Py_None;\n+  Py_INCREF(Py_None);\n+  THPObjectPtr size = PyLong_FromLong(storage->size);\n+  THPObjectPtr _offset = PyLong_FromLong(0);\n+  THPObjectPtr view_size = PyLong_FromLong(storage->size);\n+  if (storage->data) {\n+    size_t base_size;\n+    void *base_ptr = THCCachingAllocator_getBaseAllocation(storage->data, &base_size);\n+    ptrdiff_t offset = (char*)storage->data - (char*)base_ptr;\n+\n+    cudaIpcMemHandle_t handle;\n+    THCudaCheck(cudaIpcGetMemHandle(&handle, base_ptr));\n+\n+    _handle = PyBytes_FromStringAndSize((char *)&handle, CUDA_IPC_HANDLE_SIZE);\n+    _offset = PyLong_FromSsize_t((Py_ssize_t)offset);\n+    size = PyLong_FromSize_t(base_size);\n+  }\n+  if (!tuple || !device || !_handle || !size || !_offset || !view_size) {\n+    return NULL;\n+  }\n+  PyTuple_SET_ITEM(tuple.get(), 0, device.release());\n+  PyTuple_SET_ITEM(tuple.get(), 1, _handle.release());\n+  PyTuple_SET_ITEM(tuple.get(), 2, size.release());\n+  PyTuple_SET_ITEM(tuple.get(), 3, _offset.release());\n+  PyTuple_SET_ITEM(tuple.get(), 4, view_size.release());\n+  return tuple.release();\n+}\n+#endif\n+\n+// Returns an object that holds a \"weak\" pointer to the THStorage. The\n+// pointer is set to None when the THStorage is deallocated. This is done by\n+// wrapping the storages allocator with THStorageWeakRefAllocator which is\n+// responsible for clearing the weak reference.\n+static PyObject * THPStorage_(newWeakRef)(THStorage *storage, PyObject *ctor) {\n+  while (storage->flag & TH_STORAGE_VIEW) {\n+    storage = storage->view;\n+  }\n+  bool hasWeakAllocator;\n+#ifdef THC_GENERIC_FILE\n+  hasWeakAllocator = storage->allocator == &THCStorageWeakRefAllocator;\n+#else\n+  hasWeakAllocator = storage->allocator == &THStorageWeakRefAllocator;\n+#endif\n+  if (hasWeakAllocator) {\n+    auto allocator_obj = ((StorageWeakRefAllocator*)storage->allocatorContext);\n+    Py_INCREF(allocator_obj->object.get());\n+    return allocator_obj->object.get();\n+  }\n \n-PyObject * THPStorage_(_share)(THPStorage *self, PyObject *use_fd)\n+  THPObjectPtr args = Py_BuildValue(\"(N)\", PyLong_FromVoidPtr(storage));\n+  if (!args) return NULL;\n+  THPObjectPtr ref = PyObject_Call(ctor, args, NULL);\n+  if (!ref) return NULL;\n+#ifdef THC_GENERIC_FILE\n+  storage->allocatorContext = new CudaStorageWeakRefAllocator(\n+        ref.get(), storage->allocator, storage->allocatorContext);\n+  storage->allocator = &THCStorageWeakRefAllocator;\n+#else\n+  storage->allocatorContext = new StorageWeakRefAllocator(\n+        ref.get(), storage->allocator, storage->allocatorContext);\n+  storage->allocator = &THStorageWeakRefAllocator;\n+#endif\n+  return ref.release();\n+}\n+\n+PyObject * THPStorage_(newWithWeakPtr)(PyObject *_unused, PyObject *arg)\n {\n   HANDLE_TH_ERRORS\n-  THPObjectPtr result_tuple = PyTuple_New(2);\n+  THPObjectPtr ref = PyObject_GetAttrString(arg, \"cdata\");\n+  if (!ref) {\n+    return NULL;\n+  } else if (ref.get() == Py_None) {\n+    Py_RETURN_NONE;\n+  }\n+  THPUtils_assert(THPUtils_checkLong(ref.get()),\n+      \"_new_with_weak_ptr(): arg.cdata must be an 'int'\");\n+  THStorage *storage = (THStorage*)PyLong_AsVoidPtr(ref.get());\n+  // increment refcount only if it's positive\n+  int refcount = THAtomicGet(&storage->refcount);\n+  while (refcount > 0) {\n+    if (THAtomicCompareAndSwap(&storage->refcount, refcount, refcount + 1)) {", "path": "torch/csrc/generic/StorageMethods.cpp", "position": null, "original_position": 122, "commit_id": "f2c88c328ee29fb70123b30a2c637434382624c9", "original_commit_id": "782b98406e53e23328102307e4f8a0271d9f5231", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "body": "The same problem will appear if the CAS fails, because some other thread has decremented the refcount to 0, and the next THAtomicGet will be an illegal memory operation.\n", "created_at": "2016-11-06T18:52:25Z", "updated_at": "2018-11-23T15:31:52Z", "html_url": "https://github.com/pytorch/pytorch/pull/203#discussion_r86693039", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/203", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/86693039"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/203#discussion_r86693039"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/203"}}, "body_html": "<p>The same problem will appear if the CAS fails, because some other thread has decremented the refcount to 0, and the next THAtomicGet will be an illegal memory operation.</p>", "body_text": "The same problem will appear if the CAS fails, because some other thread has decremented the refcount to 0, and the next THAtomicGet will be an illegal memory operation.", "in_reply_to_id": 86692999}