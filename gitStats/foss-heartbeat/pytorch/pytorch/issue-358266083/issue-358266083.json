{"url": "https://api.github.com/repos/pytorch/pytorch/issues/11420", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/11420/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/11420/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/11420/events", "html_url": "https://github.com/pytorch/pytorch/pull/11420", "id": 358266083, "node_id": "MDExOlB1bGxSZXF1ZXN0MjE0MDc4NTky", "number": 11420, "title": "[pytorch][PR] Conversions to and from complex numbers.", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 0, "created_at": "2018-09-08T05:24:43Z", "updated_at": "2018-09-08T23:40:58Z", "closed_at": "2018-09-08T23:40:58Z", "author_association": "CONTRIBUTOR", "pull_request": {"url": "https://api.github.com/repos/pytorch/pytorch/pulls/11420", "html_url": "https://github.com/pytorch/pytorch/pull/11420", "diff_url": "https://github.com/pytorch/pytorch/pull/11420.diff", "patch_url": "https://github.com/pytorch/pytorch/pull/11420.patch"}, "body_html": "<p>Stack:<br>\n\u00a0\u00a0\u00a0\u00a0<g-emoji class=\"g-emoji\" alias=\"black_circle\" fallback-src=\"https://assets-cdn.github.com/images/icons/emoji/unicode/26ab.png\">\u26ab\ufe0f</g-emoji>\u00a0 <strong><a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"358266083\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/11420\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/pytorch/pytorch/pull/11420/hovercard\" href=\"https://github.com/pytorch/pytorch/pull/11420\">#11420</a> [pytorch][PR] Conversions to and from complex numbers.</strong>\u00a0\u00a0<a href=\"https://our.internmc.facebook.com/intern/diff/D9697878/\" rel=\"nofollow\"><g-emoji class=\"g-emoji\" alias=\"green_heart\" fallback-src=\"https://assets-cdn.github.com/images/icons/emoji/unicode/1f49a.png\">\ud83d\udc9a</g-emoji></a></p>\n<p>Surprisingly tricky!  Here are the major pieces:</p>\n<ul>\n<li>\n<p>We grow a even yet more ludicrous macro<br>\nAT_FORALL_SCALAR_TYPES_WITH_COMPLEX_EXCEPT_COMPLEX_HALF<br>\nwhich does what it says on the tin.  This is because I was<br>\ntoo lazy to figure out how to define the necessary conversions<br>\nin and out of ComplexHalf without triggering ambiguity problems.<br>\nIt doesn't seem to be as simple as just Half.  Leave it for<br>\nwhen someone actually wants this.</p>\n</li>\n<li>\n<p>Scalar now can hold std::complex.  Internally, it is<br>\nstored as double[2] because nvcc chokes on a non-POD type<br>\ninside a union.</p>\n</li>\n<li>\n<p>overflow() checking is generalized to work with complex.<br>\nWhen converting <em>to</em> std::complex, all we need to do is check<br>\nfor overflow against T.  When converting <em>from</em> complex, we<br>\nmust check (1) if To is not complex, that imag() == 0<br>\nand (2) for overflow componentwise.</p>\n</li>\n<li>\n<p>convert() is generalized to work with complex&lt;-&gt;real conversions.<br>\nComplex to real drops the imaginary component; we rely on<br>\noverflow checking to tell if this actually loses fidelity. To get<br>\nthe specializations and overloads to work out, we introduce<br>\na new Converter class that actually is specializable.</p>\n</li>\n<li>\n<p>Complex scalars convert into Python complex numbers</p>\n</li>\n<li>\n<p>This probably fixes complex tensor printing, but there is no way<br>\nto test this right now.</p>\n</li>\n</ul>\n<p>Signed-off-by: Edward Z. Yang <a href=\"mailto:ezyang@fb.com\">ezyang@fb.com</a><br>\nGitHub Author: Edward Z. Yang <a href=\"mailto:ezyang@fb.com\">ezyang@fb.com</a></p>\n<p>Differential Revision: <a href=\"https://our.internmc.facebook.com/intern/diff/D9697878/\" rel=\"nofollow\">D9697878</a></p>", "body_text": "Stack:\n\u00a0\u00a0\u00a0\u00a0\u26ab\ufe0f\u00a0 #11420 [pytorch][PR] Conversions to and from complex numbers.\u00a0\u00a0\ud83d\udc9a\nSurprisingly tricky!  Here are the major pieces:\n\n\nWe grow a even yet more ludicrous macro\nAT_FORALL_SCALAR_TYPES_WITH_COMPLEX_EXCEPT_COMPLEX_HALF\nwhich does what it says on the tin.  This is because I was\ntoo lazy to figure out how to define the necessary conversions\nin and out of ComplexHalf without triggering ambiguity problems.\nIt doesn't seem to be as simple as just Half.  Leave it for\nwhen someone actually wants this.\n\n\nScalar now can hold std::complex.  Internally, it is\nstored as double[2] because nvcc chokes on a non-POD type\ninside a union.\n\n\noverflow() checking is generalized to work with complex.\nWhen converting to std::complex, all we need to do is check\nfor overflow against T.  When converting from complex, we\nmust check (1) if To is not complex, that imag() == 0\nand (2) for overflow componentwise.\n\n\nconvert() is generalized to work with complex<->real conversions.\nComplex to real drops the imaginary component; we rely on\noverflow checking to tell if this actually loses fidelity. To get\nthe specializations and overloads to work out, we introduce\na new Converter class that actually is specializable.\n\n\nComplex scalars convert into Python complex numbers\n\n\nThis probably fixes complex tensor printing, but there is no way\nto test this right now.\n\n\nSigned-off-by: Edward Z. Yang ezyang@fb.com\nGitHub Author: Edward Z. Yang ezyang@fb.com\nDifferential Revision: D9697878", "body": "Stack:\n&nbsp;&nbsp;&nbsp;&nbsp;:black_circle:&nbsp; **#11420 [pytorch][PR] Conversions to and from complex numbers.**&nbsp;&nbsp;[:green_heart:](https://our.internmc.facebook.com/intern/diff/D9697878/)\n\nSurprisingly tricky!  Here are the major pieces:\n\n- We grow a even yet more ludicrous macro\n  AT_FORALL_SCALAR_TYPES_WITH_COMPLEX_EXCEPT_COMPLEX_HALF\n  which does what it says on the tin.  This is because I was\n  too lazy to figure out how to define the necessary conversions\n  in and out of ComplexHalf without triggering ambiguity problems.\n  It doesn't seem to be as simple as just Half.  Leave it for\n  when someone actually wants this.\n\n- Scalar now can hold std::complex<double>.  Internally, it is\n  stored as double[2] because nvcc chokes on a non-POD type\n  inside a union.\n\n- overflow() checking is generalized to work with complex.\n  When converting *to* std::complex<T>, all we need to do is check\n  for overflow against T.  When converting *from* complex, we\n  must check (1) if To is not complex, that imag() == 0\n  and (2) for overflow componentwise.\n\n- convert() is generalized to work with complex<->real conversions.\n  Complex to real drops the imaginary component; we rely on\n  overflow checking to tell if this actually loses fidelity. To get\n  the specializations and overloads to work out, we introduce\n  a new Converter class that actually is specializable.\n\n- Complex scalars convert into Python complex numbers\n\n- This probably fixes complex tensor printing, but there is no way\n  to test this right now.\n\n\nSigned-off-by: Edward Z. Yang <ezyang@fb.com>\nGitHub Author: Edward Z. Yang <ezyang@fb.com>\n\nDifferential Revision: [D9697878](https://our.internmc.facebook.com/intern/diff/D9697878/)"}