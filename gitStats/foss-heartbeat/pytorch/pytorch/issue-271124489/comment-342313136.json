{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/342313136", "html_url": "https://github.com/pytorch/pytorch/pull/3474#issuecomment-342313136", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/3474", "id": 342313136, "node_id": "MDEyOklzc3VlQ29tbWVudDM0MjMxMzEzNg==", "user": {"login": "SsnL", "id": 5674597, "node_id": "MDQ6VXNlcjU2NzQ1OTc=", "avatar_url": "https://avatars2.githubusercontent.com/u/5674597?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SsnL", "html_url": "https://github.com/SsnL", "followers_url": "https://api.github.com/users/SsnL/followers", "following_url": "https://api.github.com/users/SsnL/following{/other_user}", "gists_url": "https://api.github.com/users/SsnL/gists{/gist_id}", "starred_url": "https://api.github.com/users/SsnL/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SsnL/subscriptions", "organizations_url": "https://api.github.com/users/SsnL/orgs", "repos_url": "https://api.github.com/users/SsnL/repos", "events_url": "https://api.github.com/users/SsnL/events{/privacy}", "received_events_url": "https://api.github.com/users/SsnL/received_events", "type": "User", "site_admin": false}, "created_at": "2017-11-06T22:43:38Z", "updated_at": "2017-11-06T22:47:26Z", "author_association": "CONTRIBUTOR", "body_html": "<p>Addressing the comments by <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=655866\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/colesbury\">@colesbury</a> and <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=4583066\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/apaszke\">@apaszke</a> , I updated PR:</p>\n<ol>\n<li>\n<p>Removed SIGALRM logic. Now the DataLoader will create a separate thread if <strong>either</strong><code>pin_memory</code> is set or <code>timeout &gt; 0</code>. Since the thread communicates with the main thread with a <code>queue.Queue</code>, we do timeout there.</p>\n</li>\n<li>\n<p>The SIGCHLD handler now only <code>waitpid</code> on the child processes of interest, so Python can update the <code>is_alive()</code> and <code>exitcode</code> for other processes.</p>\n</li>\n<li>\n<p>Re-wrote the part to remove pids from the collections so that at any time, the array contains only valid pids (some might be dead workers), and includes all alive pids.</p>\n</li>\n<li>\n<p>Added <code>std::atomic</code> on several variables. Did <code>is_log_free</code> check.</p>\n</li>\n<li>\n<p>Added basic level error handling code for library functions. Used <code>HANDLE_TH_ERRORS</code> to wrap the C++ functions.</p>\n</li>\n<li>\n<p>Moved the new C++ functions to a separate file. Added dummy implementation for Windows.</p>\n</li>\n<li>\n<p>Add tests. Unfortunately, for <code>test_segfault</code>, the print to <code>stderr</code> is from C++, so I don't know if there is a way to hide that on Python side. So passing the tests will still show a single line error message <code>ERROR: Unexpected segmentation fault encountered in worker.</code>.</p>\n</li>\n</ol>", "body_text": "Addressing the comments by @colesbury and @apaszke , I updated PR:\n\n\nRemoved SIGALRM logic. Now the DataLoader will create a separate thread if eitherpin_memory is set or timeout > 0. Since the thread communicates with the main thread with a queue.Queue, we do timeout there.\n\n\nThe SIGCHLD handler now only waitpid on the child processes of interest, so Python can update the is_alive() and exitcode for other processes.\n\n\nRe-wrote the part to remove pids from the collections so that at any time, the array contains only valid pids (some might be dead workers), and includes all alive pids.\n\n\nAdded std::atomic on several variables. Did is_log_free check.\n\n\nAdded basic level error handling code for library functions. Used HANDLE_TH_ERRORS to wrap the C++ functions.\n\n\nMoved the new C++ functions to a separate file. Added dummy implementation for Windows.\n\n\nAdd tests. Unfortunately, for test_segfault, the print to stderr is from C++, so I don't know if there is a way to hide that on Python side. So passing the tests will still show a single line error message ERROR: Unexpected segmentation fault encountered in worker..", "body": "Addressing the comments by @colesbury and @apaszke , I updated PR:\r\n\r\n1. Removed SIGALRM logic. Now the DataLoader will create a separate thread if **either**`pin_memory` is set or `timeout > 0`. Since the thread communicates with the main thread with a `queue.Queue`, we do timeout there. \r\n\r\n2. The SIGCHLD handler now only `waitpid` on the child processes of interest, so Python can update the `is_alive()` and `exitcode` for other processes. \r\n\r\n3. Re-wrote the part to remove pids from the collections so that at any time, the array contains only valid pids (some might be dead workers), and includes all alive pids.\r\n\r\n4. Added `std::atomic` on several variables. Did `is_log_free` check. \r\n\r\n5. Added basic level error handling code for library functions. Used `HANDLE_TH_ERRORS` to wrap the C++ functions.\r\n\r\n6. Moved the new C++ functions to a separate file. Added dummy implementation for Windows.\r\n\r\n7. Add tests. Unfortunately, for `test_segfault`, the print to `stderr` is from C++, so I don't know if there is a way to hide that on Python side. So passing the tests will still show a single line error message `ERROR: Unexpected segmentation fault encountered in worker.`.\r\n"}