{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/204668216", "pull_request_review_id": 139781933, "id": 204668216, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwNDY2ODIxNg==", "diff_hunk": "@@ -241,180 +197,546 @@ void encodeBlock(onnx::GraphProto * p_g, Block *b,\n       if (input->node()->kind() == prim::Undefined && !is_raw_export) {\n         p_n->add_input(\"\");\n       } else {\n-        p_n->add_input(value_name(input));\n+        p_n->add_input(input->uniqueName());\n       }\n     }\n     for(auto output : node->outputs()) {\n-      p_n->add_output(value_name(output));\n+      p_n->add_output(output->uniqueName());\n     }\n     if (is_raw_export) {\n       JIT_ASSERT(!node->kind().is_onnx());\n       p_n->set_domain(node->kind().domainString());\n     }\n-    else if (ctx->operator_export_type != onnx::OperatorExportTypes::ONNX_ATEN_FALLBACK) {\n+    else if (operator_export_type_ == onnx_torch::OperatorExportTypes::ONNX) {\n       JIT_ASSERT(node->kind().is_onnx());\n     }\n     p_n->set_op_type(node->kind().toUnqualString());\n     for(auto attr_name : node->attributeNames()) {\n-      addAttribute(p_n, node, attr_name, ctx);\n+      AddAttribute(p_n, node, attr_name);\n     }\n     if (is_raw_export && node->blocks().size() > 0) {\n       auto blocks = p_n->add_attribute();\n       blocks->set_name(\"_blocks\");\n-      blocks->set_type(onnx::aGRAPHS);\n+      blocks->set_type(onnx::AttributeProto_AttributeType_GRAPHS);\n       for (auto block : node->blocks()) {\n         auto graph = blocks->add_graphs();\n-        encodeBlock(graph, block, initializers, ctx, raw_data_export_map);\n+        EncodeBlock(graph, block, initializers);\n       }\n     }\n     if (node->kind() == torch::jit::onnx::Loop) {\n       JIT_ASSERT(node->blocks().size() == 1);\n \n       auto body = p_n->add_attribute();\n       body->set_name(\"body\");\n-      body->set_type(onnx::aGRAPH);\n+      body->set_type(onnx::AttributeProto_AttributeType_GRAPH);\n       auto g = body->mutable_g();\n-      encodeBlock(g, node->blocks()[0], {}, ctx, raw_data_export_map);\n+      EncodeBlock(g, node->blocks()[0]);\n     }\n     if (node->kind() == torch::jit::onnx::If) {\n       JIT_ASSERT(node->blocks().size() == 2);\n \n       auto true_branch = p_n->add_attribute();\n       true_branch->set_name(\"then_branch\");\n-      true_branch->set_type(onnx::aGRAPH);\n+      true_branch->set_type(onnx::AttributeProto_AttributeType_GRAPH);\n       auto true_g = true_branch->mutable_g();\n-      encodeBlock(true_g, node->blocks()[0], {}, ctx, raw_data_export_map);\n+      EncodeBlock(true_g, node->blocks()[0]);\n \n       auto false_branch = p_n->add_attribute();\n       false_branch->set_name(\"else_branch\");\n-      false_branch->set_type(onnx::aGRAPH);\n+      false_branch->set_type(onnx::AttributeProto_AttributeType_GRAPH);\n       auto false_g = false_branch->mutable_g();\n-      encodeBlock(false_g, node->blocks()[1], {}, ctx, raw_data_export_map);\n+      EncodeBlock(false_g, node->blocks()[1]);\n     }\n   }\n   auto num_initializers = initializers.size();\n-  JIT_ASSERT(b->inputs().size() >= num_initializers);\n-  size_t inputs_count = b->inputs().size() - num_initializers;\n+  JIT_ASSERT(block->inputs().size() >= num_initializers);\n+  size_t inputs_count = block->inputs().size() - num_initializers;\n   for (auto & tensor : initializers) {\n     // TODO: stop using positions to determine which initializers\n     // match to which inputs\n-    std::string name = p_g->get_input_name(inputs_count++);\n-    auto p = p_g->add_initializer();\n+    std::string name = graph_proto->input(inputs_count++).name();\n+    auto p = graph_proto->add_initializer();\n     p->set_name(name);\n-    if (raw_data_export_map) {\n-      encodeTensor(p, tensor, name, raw_data_export_map);\n-    } else {\n-      encodeTensor(p, tensor, {});\n-    }\n+    EncodeTensor(p, tensor, name);\n+  }\n+}\n+\n+void JitEncoder::AddAttribute(onnx::NodeProto *node_proto, const jit::Node *node, const jit::Symbol name) {\n+  auto attr = node_proto->add_attribute();\n+  JIT_ASSERT(name.is_attr());\n+  attr->set_name(name.toUnqualString());\n+  switch(node->kindOf(name)) {\n+    case AttributeKind::f:\n+      attr->set_f(node->f(name));\n+      attr->set_type(onnx::AttributeProto_AttributeType_FLOAT);\n+      break;\n+    case AttributeKind::fs:\n+      attr->set_type(onnx::AttributeProto_AttributeType_FLOATS);\n+      for(auto & v : node->fs(name))\n+        attr->add_floats(v);\n+      break;\n+    case AttributeKind::i:\n+      attr->set_type(onnx::AttributeProto_AttributeType_INT);\n+      attr->set_i(node->i(name));\n+      break;\n+    case AttributeKind::is:\n+      attr->set_type(onnx::AttributeProto_AttributeType_INTS);\n+      for(auto & v : node->is(name))\n+        attr->add_ints(v);\n+      break;\n+    case AttributeKind::s:\n+      attr->set_type(onnx::AttributeProto_AttributeType_STRING);\n+      attr->set_s(node->s(name));\n+      break;\n+    case AttributeKind::ss:\n+      attr->set_type(onnx::AttributeProto_AttributeType_STRINGS);\n+      for(auto & v : node->ss(name))\n+        attr->add_strings(v);\n+      break;\n+    case AttributeKind::t: {\n+      attr->set_type(onnx::AttributeProto_AttributeType_TENSOR);\n+      auto t = attr->mutable_t();\n+      EncodeTensor(t, node->t(name));\n+    } break;\n+    case AttributeKind::ts:\n+      attr->set_type(onnx::AttributeProto_AttributeType_TENSORS);\n+      for(auto & v : node->ts(name)) {\n+        auto t = attr->add_tensors();\n+        EncodeTensor(t, v);\n+      }\n+      break;\n+    case AttributeKind::g: {\n+      attr->set_type(onnx::AttributeProto_AttributeType_GRAPH);\n+      auto g = attr->mutable_g();\n+      EncodeGraph(g, node->g(name));\n+    } break;\n+    case AttributeKind::gs:\n+      attr->set_type(onnx::AttributeProto_AttributeType_GRAPHS);\n+      for(auto & v : node->gs(name)) {\n+        auto g = attr->add_graphs();\n+        EncodeGraph(g, v);\n+      }\n+      break;", "path": "torch/csrc/jit/export.cpp", "position": 502, "original_position": 505, "commit_id": "f622bcc6b1e23e942cca8615b87321ebc91e4273", "original_commit_id": "dfe899efbacf40f945fd85e4d49e3d0748317f4d", "user": {"login": "dzhulgakov", "id": 17890620, "node_id": "MDQ6VXNlcjE3ODkwNjIw", "avatar_url": "https://avatars2.githubusercontent.com/u/17890620?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dzhulgakov", "html_url": "https://github.com/dzhulgakov", "followers_url": "https://api.github.com/users/dzhulgakov/followers", "following_url": "https://api.github.com/users/dzhulgakov/following{/other_user}", "gists_url": "https://api.github.com/users/dzhulgakov/gists{/gist_id}", "starred_url": "https://api.github.com/users/dzhulgakov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dzhulgakov/subscriptions", "organizations_url": "https://api.github.com/users/dzhulgakov/orgs", "repos_url": "https://api.github.com/users/dzhulgakov/repos", "events_url": "https://api.github.com/users/dzhulgakov/events{/privacy}", "received_events_url": "https://api.github.com/users/dzhulgakov/received_events", "type": "User", "site_admin": false}, "body": "have also default case? (error)", "created_at": "2018-07-24T08:34:20Z", "updated_at": "2018-11-23T15:47:57Z", "html_url": "https://github.com/pytorch/pytorch/pull/9746#discussion_r204668216", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/9746", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/204668216"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/9746#discussion_r204668216"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/9746"}}, "body_html": "<p>have also default case? (error)</p>", "body_text": "have also default case? (error)"}