{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/204671159", "pull_request_review_id": 139781933, "id": 204671159, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwNDY3MTE1OQ==", "diff_hunk": "@@ -15,514 +15,308 @@ namespace torch { namespace jit {\n \n namespace {\n \n-// Deserialized data\n-\n-struct Tensor_ {\n-  std::vector<int64_t> dims;\n-  std::vector<uint8_t> raw_data;\n-  onnx_TensorProto_DataType data_type;\n-};\n-\n-struct AttributeValue_ {\n-  std::string name;\n-  onnx_AttributeProto_AttributeType type;\n-  double f;\n-  int64_t i;\n-  std::string s;\n-  Tensor_ t;\n-  std::string g;\n-  std::vector<double> fs;\n-  std::vector<int64_t> is;\n-  std::vector<std::string> ss;\n-  std::vector<Tensor_> ts;\n-  std::vector<std::string> gs;\n-};\n-\n-struct Value_ {\n-  std::string name;\n-};\n-\n-struct Node_ {\n-  std::string op_type;\n-  std::string domain;\n-  std::vector<std::string> inputs;\n-  std::vector<std::string> outputs;\n-  std::vector<AttributeValue_> attrs;\n-};\n-\n-struct Graph_ {\n-  std::vector<Value_> inputs;\n-  std::vector<Value_> outputs;\n-  std::vector<Node_> nodes;\n-  std::vector<Tensor_> initializers;\n-};\n-\n-struct Model_ {\n-  Graph_ graph;\n-};\n-\n-\n-// Readers\n-\n-struct ReaderBase {\n-  ReaderBase() {}\n-  ReaderBase(pb_callback_t& cb) {\n-    initialize_callback(cb);\n-  }\n-\n-  void initialize_callback(pb_callback_t& cb) {\n-    cb.funcs.decode = ReaderBase::decode;\n-    cb.arg = this;\n-  }\n-\n-  virtual void decode(pb_istream_t *stream) = 0;\n-\n-  static bool decode(pb_istream_t *stream, const pb_field_t *, void **_self) {\n-    ReaderBase* self = *reinterpret_cast<ReaderBase* const *>(_self);\n-    self->decode(stream);\n-    return true;\n-  }\n-};\n-\n-\n-template<typename T>\n-struct Reader : ReaderBase {};\n-\n-template<typename T>\n-struct Reader<std::vector<T>> : Reader<T> {\n-  Reader(pb_callback_t& cb) : Reader<T>(cb) {}\n-  // Decode is going to be called repeatedly from the callback\n-  // (registered in the parent class constructor) each time an\n-  // element is encountered. So all we do is relay the decoding\n-  // through the parent class decode and push the result, every\n-  // time this decode is called.\n-  virtual void decode(pb_istream_t *stream) override {\n-    Reader<T>::decode(stream);\n-    values.push_back(std::move(Reader<T>::value));\n-  }\n-  std::vector<T> values;\n-};\n-\n-template<>\n-struct Reader<std::string> : ReaderBase {\n-  Reader(pb_callback_t& cb) : ReaderBase(cb) {}\n-  virtual void decode(pb_istream_t *stream) override {\n-    // For string and bytes, the length value has already been\n-    // parsed, and is available at stream->bytes_left.\n-    std::vector<uint8_t> res(stream->bytes_left);\n-    if (!pb_read(stream, res.data(), stream->bytes_left)) {\n-      throw std::runtime_error(\"Decoding failed\");\n-    }\n-    value.assign(res.begin(), res.end());\n-  }\n-  std::string value;\n-};\n-\n-template<>\n-struct Reader<double> : ReaderBase {\n-  Reader(pb_callback_t& cb) : ReaderBase(cb) {}\n-  virtual void decode(pb_istream_t *stream) override {\n-    if (!pb_decode_fixed32(stream, &value)) {\n-      throw std::runtime_error(\"Decoding failed\");\n-    }\n-  }\n-  double value;\n-};\n-\n-template<>\n-struct Reader<int64_t> : ReaderBase {\n-  Reader(pb_callback_t& cb) : ReaderBase(cb) {}\n-  virtual void decode(pb_istream_t *stream) override {\n-    if (!pb_decode_varint(stream, reinterpret_cast<uint64_t*>(&value))) {\n-      throw std::runtime_error(\"Decoding failed\");\n-    }\n-  }\n-  int64_t value;\n-};\n-\n-template<>\n-struct Reader<std::vector<uint8_t>> : ReaderBase {\n-  Reader(pb_callback_t& cb) : ReaderBase(cb) {}\n-  virtual void decode(pb_istream_t *stream) override {\n-    // For string and bytes, the length value has already been\n-    // parsed, and is available at stream->bytes_left.\n-    value.resize(stream->bytes_left);\n-    if (!pb_read(stream, value.data(), stream->bytes_left)) {\n-      throw std::runtime_error(\"Decoding failed\");\n-    }\n-  }\n-  std::vector<uint8_t> value;\n-};\n-\n-template<>\n-struct Reader<Tensor_> : ReaderBase {\n-  Reader()\n-    : proto(onnx_TensorProto_init_default)\n-    , dims_reader(proto.dims)\n-    , raw_data_reader(proto.raw_data)\n-  {}\n-\n-  Reader(pb_callback_t& cb)\n-    : Reader() { initialize_callback(cb); }\n-\n-  virtual void decode(pb_istream_t *stream) override {\n-    if (!pb_decode(stream, onnx_TensorProto_fields, &proto)) {\n-      throw std::runtime_error(\"Decoding failed\");\n-    }\n-\n-    value.dims = std::move(dims_reader.values);\n-    value.raw_data = std::move(raw_data_reader.value);\n-    value.data_type = proto.data_type;\n-  }\n-\n-  onnx_TensorProto proto;\n-  Reader<std::vector<int64_t>> dims_reader;\n-  Reader<std::vector<uint8_t>> raw_data_reader;\n-  Tensor_ value;\n-};\n-\n-template<>\n-struct Reader<AttributeValue_> : ReaderBase {\n-  Reader()\n-    : proto(onnx_AttributeProto_init_default)\n-    , name_reader(proto.name)\n-    , str_reader(proto.s)\n-    , tensor_reader(proto.t)\n-    , graph_reader(proto.g)\n-    , floats_reader(proto.floats)\n-    , ints_reader(proto.ints)\n-    , strings_reader(proto.strings)\n-    , tensors_reader(proto.tensors)\n-    , graphs_reader(proto.graphs) {}\n-\n-  Reader(pb_callback_t& cb)\n-    : Reader() { initialize_callback(cb); }\n-\n-  virtual void decode(pb_istream_t *stream) override {\n-    if (!pb_decode(stream, onnx_AttributeProto_fields, &proto)) {\n-      throw std::runtime_error(\"Decoding failed\");\n-    }\n-\n-    value.name = std::move(name_reader.value);\n-    value.type = proto.type;\n-    value.f = proto.f;\n-    value.i = proto.i;\n-    value.s = std::move(str_reader.value);\n-    value.t = std::move(tensor_reader.value);\n-    value.g = std::move(graph_reader.value);\n-    value.fs = std::move(floats_reader.values);\n-    value.is = std::move(ints_reader.values);\n-    value.ss = std::move(strings_reader.values);\n-    value.ts = std::move(tensors_reader.values);\n-    value.gs = std::move(graphs_reader.values);\n-  }\n-\n-  onnx_AttributeProto proto;\n-  Reader<std::string> name_reader;\n-  Reader<std::string> str_reader;\n-  Reader<Tensor_> tensor_reader;\n-  Reader<std::string> graph_reader;\n-  Reader<std::vector<double>> floats_reader;\n-  Reader<std::vector<int64_t>> ints_reader;\n-  Reader<std::vector<std::string>> strings_reader;\n-  Reader<std::vector<Tensor_>> tensors_reader;\n-  Reader<std::vector<std::string>> graphs_reader;\n-  AttributeValue_ value;\n-};\n-\n-template<>\n-struct Reader<Value_> : ReaderBase {\n-  Reader()\n-    : proto(onnx_ValueInfoProto_init_default)\n-    , name_reader(proto.name) {}\n-  Reader(pb_callback_t& cb)\n-    : Reader() { initialize_callback(cb); }\n-\n-  virtual void decode(pb_istream_t *stream) override {\n-    if (!pb_decode(stream, onnx_ValueInfoProto_fields, &proto)) {\n-      throw std::runtime_error(\"Decoding failed\");\n-    }\n-\n-    value.name = std::move(name_reader.value);\n-  }\n-\n-  onnx_ValueInfoProto proto;\n-  Reader<std::string> name_reader;\n-  Value_ value;\n-};\n-\n-\n-template<>\n-struct Reader<Node_> : ReaderBase {\n-  Reader()\n-    : proto(onnx_NodeProto_init_default)\n-    , op_type_reader(proto.op_type)\n-    , domain_reader(proto.domain)\n-    , inputs_reader(proto.input)\n-    , outputs_reader(proto.output)\n-    , attrs_reader(proto.attribute)\n-  {}\n-  Reader(pb_callback_t& cb)\n-    : Reader() { initialize_callback(cb); }\n-\n-  virtual void decode(pb_istream_t *stream) override {\n-    if (!pb_decode(stream, onnx_NodeProto_fields, &proto)) {\n-      throw std::runtime_error(\"Decoding failed\");\n-    }\n-\n-    value.op_type = std::move(op_type_reader.value);\n-    value.domain = std::move(domain_reader.value);\n-    value.inputs = std::move(inputs_reader.values);\n-    value.outputs = std::move(outputs_reader.values);\n-    value.attrs = std::move(attrs_reader.values);\n-  }\n-\n-  onnx_NodeProto proto;\n-  Reader<std::string> op_type_reader;\n-  Reader<std::string> domain_reader;\n-  Reader<std::vector<std::string>> inputs_reader;\n-  Reader<std::vector<std::string>> outputs_reader;\n-  Reader<std::vector<AttributeValue_>> attrs_reader;\n-  Node_ value;\n-};\n+// IR graph construction\n \n+class JitDecoder {\n+ protected:\n+  std::shared_ptr<Graph> buildGraph(const onnx_torch::GraphProto& graph_proto);\n \n-template<>\n-struct Reader<Graph_> : ReaderBase {\n-  Reader()\n-    : proto(onnx_GraphProto_init_default)\n-    , input_reader(proto.input)\n-    , output_reader(proto.output)\n-    , node_reader(proto.node)\n-    , initializer_reader(proto.initializer)\n-  {}\n-  Reader(pb_callback_t& cb)\n-    : Reader() { initialize_callback(cb); }\n-\n-  virtual void decode(pb_istream_t *stream) override {\n-    if (!pb_decode(stream, onnx_GraphProto_fields, &proto)) {\n-      throw std::runtime_error(\"Decoding failed\");\n-    }\n+  void buildBlock(const onnx_torch::GraphProto& graph_proto, Block* block,\n+                   std::unordered_map<std::string, Value*>& value_map);\n \n-    value.inputs = std::move(input_reader.values);\n-    value.outputs = std::move(output_reader.values);\n-    value.nodes = std::move(node_reader.values);\n-    value.initializers = std::move(initializer_reader.values);\n-  }\n+  void buildBlocks(const std::vector<onnx_torch::GraphProto>& graphs_, Node* node,\n+                   std::unordered_map<std::string, Value*>& value_map);\n \n-  static Graph_ read(pb_istream_t *stream) {\n-    Reader<Graph_> reader;\n-    reader.decode(stream);\n-    return reader.value;\n-  }\n+  at::ScalarType onnxTypeToATenType(onnx_torch::TensorProto_DataType tensor_proto);\n \n-  onnx_GraphProto proto;\n-  Reader<std::vector<Value_>> input_reader;\n-  Reader<std::vector<Value_>> output_reader;\n-  Reader<std::vector<Node_>> node_reader;\n-  Reader<std::vector<Tensor_>> initializer_reader;\n-  Graph_ value;\n+  virtual at::Tensor buildTensor(const onnx_torch::TensorProto& tensor_proto);\n };\n \n-\n-template<>\n-struct Reader<Model_> : ReaderBase {\n-  Reader()\n-    : proto(onnx_ModelProto_init_default)\n-    , graph_reader(proto.graph) {}\n-  Reader(pb_callback_t& cb)\n-    : Reader() { initialize_callback(cb); }\n-\n-  virtual void decode(pb_istream_t *stream) override {\n-    if (!pb_decode(stream, onnx_ModelProto_fields, &proto)) {\n-      throw std::runtime_error(\"Decoding failed\");\n-    }\n-\n-    value.graph = std::move(graph_reader.value);\n-  }\n-\n-  static Model_ read(pb_istream_t *stream) {\n-    Reader<Model_> reader;\n-    reader.decode(stream);\n-    return reader.value;\n-  }\n-\n-  onnx_ModelProto proto;\n-  Reader<Graph_> graph_reader;\n-  Model_ value;\n-};\n-\n-\n-// IR graph construction\n-\n-at::Tensor buildTensor(const Tensor_& tensor_) {\n-\n-  at::Tensor tensor;\n-\n-  switch(tensor_.data_type) {\n-    case onnx_TensorProto_DataType_UINT8:\n-      tensor = at::CPU(at::kByte).tensor();\n-      break;\n-    case onnx_TensorProto_DataType_INT8:\n-      tensor = at::CPU(at::kChar).tensor();\n-      break;\n-    case onnx_TensorProto_DataType_INT16:\n-      tensor = at::CPU(at::kShort).tensor();\n-      break;\n-    case onnx_TensorProto_DataType_INT32:\n-      tensor = at::CPU(at::kInt).tensor();\n-      break;\n-    case onnx_TensorProto_DataType_INT64:\n-      tensor = at::CPU(at::kLong).tensor();\n-      break;\n-    case onnx_TensorProto_DataType_FLOAT16:\n-      tensor = at::CPU(at::kHalf).tensor();\n-      break;\n-    case onnx_TensorProto_DataType_FLOAT:\n-      tensor = at::CPU(at::kFloat).tensor();\n-      break;\n-    case onnx_TensorProto_DataType_DOUBLE:\n-      tensor = at::CPU(at::kDouble).tensor();\n-      break;\n+at::ScalarType JitDecoder::onnxTypeToATenType(onnx_torch::TensorProto_DataType onnx_type) {\n+  switch(onnx_type) {\n+    case onnx_torch::TensorProto_DataType_UINT8:\n+      return at::kByte;\n+    case onnx_torch::TensorProto_DataType_INT8:\n+      return at::kChar;\n+    case onnx_torch::TensorProto_DataType_INT16:\n+      return at::kShort;\n+    case onnx_torch::TensorProto_DataType_INT32:\n+      return at::kInt;\n+    case onnx_torch::TensorProto_DataType_INT64:\n+      return at::kLong;\n+    case onnx_torch::TensorProto_DataType_FLOAT16:\n+      return at::kHalf;\n+    case onnx_torch::TensorProto_DataType_FLOAT:\n+      return at::kFloat;\n+    case onnx_torch::TensorProto_DataType_DOUBLE:\n+      return at::kDouble;\n     default:\n       throw std::runtime_error(\"Unsupported data type\");\n   }\n-\n-  tensor.resize_(tensor_.dims);\n-\n-  TORCH_ASSERT(tensor.storage()->size() * tensor.storage()->elementSize() == tensor_.raw_data.size());\n-\n-  std::memcpy(tensor.data_ptr(), tensor_.raw_data.data(), tensor_.raw_data.size());\n-\n-  return tensor;\n }\n \n-Graph_ readSubgraph(const std::string& serialized_subgraph) {\n-  pb_istream_t istream = pb_istream_from_buffer(reinterpret_cast<const pb_byte_t *>(serialized_subgraph.data()), serialized_subgraph.size());\n-\n-  return Reader<Graph_>::read(&istream);\n+at::Tensor JitDecoder::buildTensor(const onnx_torch::TensorProto& tensor_proto) {\n+  at::Tensor tensor = at::CPU(onnxTypeToATenType(tensor_proto.data_type())).tensor();", "path": "torch/csrc/jit/import.cpp", "position": null, "original_position": 426, "commit_id": "f622bcc6b1e23e942cca8615b87321ebc91e4273", "original_commit_id": "dfe899efbacf40f945fd85e4d49e3d0748317f4d", "user": {"login": "dzhulgakov", "id": 17890620, "node_id": "MDQ6VXNlcjE3ODkwNjIw", "avatar_url": "https://avatars2.githubusercontent.com/u/17890620?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dzhulgakov", "html_url": "https://github.com/dzhulgakov", "followers_url": "https://api.github.com/users/dzhulgakov/followers", "following_url": "https://api.github.com/users/dzhulgakov/following{/other_user}", "gists_url": "https://api.github.com/users/dzhulgakov/gists{/gist_id}", "starred_url": "https://api.github.com/users/dzhulgakov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dzhulgakov/subscriptions", "organizations_url": "https://api.github.com/users/dzhulgakov/orgs", "repos_url": "https://api.github.com/users/dzhulgakov/repos", "events_url": "https://api.github.com/users/dzhulgakov/events{/privacy}", "received_events_url": "https://api.github.com/users/dzhulgakov/received_events", "type": "User", "site_admin": false}, "body": "btw, should we store also tensor's device? or things magically turn to cpu after serialization?", "created_at": "2018-07-24T08:44:05Z", "updated_at": "2018-11-23T15:47:57Z", "html_url": "https://github.com/pytorch/pytorch/pull/9746#discussion_r204671159", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/9746", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/204671159"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/9746#discussion_r204671159"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/9746"}}, "body_html": "<p>btw, should we store also tensor's device? or things magically turn to cpu after serialization?</p>", "body_text": "btw, should we store also tensor's device? or things magically turn to cpu after serialization?"}