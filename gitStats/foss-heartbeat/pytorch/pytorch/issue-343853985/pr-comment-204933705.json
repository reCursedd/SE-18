{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/204933705", "pull_request_review_id": 140034348, "id": 204933705, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwNDkzMzcwNQ==", "diff_hunk": "@@ -155,27 +161,162 @@ void buildBlock(const onnx_torch::GraphProto& graph_proto, Block* block,\n   }\n }\n \n-std::shared_ptr<Graph> buildGraph(const onnx_torch::GraphProto& graph_proto, std::vector<at::Tensor>& initializers) {\n+class GraphDecoder : JitDecoder {\n+ public:\n+  std::shared_ptr<Graph> decode(const std::string& serialized_graph,\n+                                std::vector<at::Tensor>& initializers);\n+};\n \n-  auto graph = buildGraph(graph_proto);\n+std::shared_ptr<Graph> GraphDecoder::decode(\n+    const std::string& serialized_graph,\n+    std::vector<at::Tensor>& initializers) {\n+  auto model_proto = onnx_torch::ModelProto();\n+  model_proto.ParseFromString(serialized_graph);\n \n-  for (auto tensor_ : graph_proto.initializer()) {\n+  auto graph_proto = model_proto.graph();\n+  auto graph = buildGraph(graph_proto);\n+  for (auto &tensor_ : graph_proto.initializer()) {\n     initializers.push_back(buildTensor(tensor_));\n   }\n-\n   return graph;\n }\n \n+class ModuleDecoder : JitDecoder {\n+ public:\n+  std::shared_ptr<script::Module> decode(\n+      std::shared_ptr<script::Module> root_module,\n+      const std::string& serialized_module,\n+      const std::unordered_map<std::string, std::string>& storage_map);\n+\n+ private:\n+  at::Tensor buildTensor(const onnx_torch::TensorProto& tensor_proto);\n+\n+  at::Tensor buildParameter(const onnx_torch::TensorProto& tensor_proto);\n+\n+  at::Storage* getStorage(at::ScalarType type, std::string name);\n+\n+  std::pair<std::shared_ptr<script::Module>, std::string> parseFullName(\n+      std::shared_ptr<script::Module> root_module,\n+      const std::string fullname);\n+\n+  const std::unordered_map<std::string, std::string> *storage_export_map_;\n+  std::unordered_map<std::string, std::unique_ptr<at::Storage>> storage_map_;\n+};\n+\n+at::Tensor ModuleDecoder::buildParameter(const onnx_torch::TensorProto& tensor_proto) {\n+  auto storage = getStorage(onnxTypeToATenType(tensor_proto.data_type()), tensor_proto.doc_string());\n+  std::vector<int64_t> dims, strides;\n+  std::move(tensor_proto.dims().begin(), tensor_proto.dims().end(), std::back_inserter(dims));\n+  std::move(tensor_proto.int32_data().begin() + 3, tensor_proto.int32_data().end(), std::back_inserter(strides));\n+  auto tensor = at::CPU(onnxTypeToATenType(tensor_proto.data_type())).tensor(\n+      *storage, tensor_proto.int64_data(2), dims, strides);\n+  autograd::Variable var = autograd::make_variable(tensor, tensor_proto.int64_data(0));\n+  return var;\n }\n \n-std::shared_ptr<Graph> ImportIRGraph(const std::string& serialized_graph,\n-                                     std::vector<at::Tensor>& initializers) {\n+at::Tensor ModuleDecoder::buildTensor(const onnx_torch::TensorProto& tensor_proto) {\n+  auto storage = getStorage(onnxTypeToATenType(tensor_proto.data_type()), tensor_proto.doc_string());\n+  std::vector<int64_t> dims, strides;\n+  std::move(tensor_proto.dims().begin(), tensor_proto.dims().end(), std::back_inserter(dims));\n+  std::move(tensor_proto.int32_data().begin() + 1, tensor_proto.int32_data().end(), std::back_inserter(strides));\n+  auto tensor = at::CPU(onnxTypeToATenType(tensor_proto.data_type())).tensor(\n+      *storage, tensor_proto.int64_data(0), dims, strides);\n+  return tensor;\n+}\n+\n+at::Storage* ModuleDecoder::getStorage(at::ScalarType type, std::string name) {\n+  auto storage_it = storage_map_.find(name);\n+  if (storage_it == storage_map_.end()) {\n+    auto storage = at::CPU(type).storage();\n+    auto string_it = storage_export_map_->find(name);\n+    JIT_ASSERT(string_it != storage_export_map_->end());\n+    storage->resize(string_it->second.size());\n+    std::memcpy(storage->data(), string_it->second.data(), string_it->second.size());\n+    storage_map_.insert(std::make_pair(name, std::move(storage)));\n+  }\n+  storage_it = storage_map_.find(name);\n+  return storage_it->second.get();\n+}\n+\n+// Given a full name of a parameter or method,\n+// return the parent submodule and local name\n+std::pair<std::shared_ptr<script::Module>, std::string> ModuleDecoder::parseFullName(\n+    std::shared_ptr<script::Module> root_module,\n+    const std::string fullname) {\n+  std::vector<std::string> vec;\n+  std::stringstream ss(fullname);\n+  std::string name;\n+  while (std::getline(ss, name, '.')) {\n+    vec.push_back(name);\n+  }\n+\n+  std::shared_ptr<script::Module> curr = root_module;\n+  for (size_t i = 0; i < vec.size() - 1; i++) {\n+    if (curr->find_module(vec[i]) != nullptr) {", "path": "torch/csrc/jit/import.cpp", "position": null, "original_position": 222, "commit_id": "f622bcc6b1e23e942cca8615b87321ebc91e4273", "original_commit_id": "dfe899efbacf40f945fd85e4d49e3d0748317f4d", "user": {"login": "zdevito", "id": 370202, "node_id": "MDQ6VXNlcjM3MDIwMg==", "avatar_url": "https://avatars0.githubusercontent.com/u/370202?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zdevito", "html_url": "https://github.com/zdevito", "followers_url": "https://api.github.com/users/zdevito/followers", "following_url": "https://api.github.com/users/zdevito/following{/other_user}", "gists_url": "https://api.github.com/users/zdevito/gists{/gist_id}", "starred_url": "https://api.github.com/users/zdevito/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zdevito/subscriptions", "organizations_url": "https://api.github.com/users/zdevito/orgs", "repos_url": "https://api.github.com/users/zdevito/repos", "events_url": "https://api.github.com/users/zdevito/events{/privacy}", "received_events_url": "https://api.github.com/users/zdevito/received_events", "type": "User", "site_admin": false}, "body": "Can simplify:\r\n```\r\n    if (curr->find_module(vec[i]) == nullptr) {\r\n         curr->register_module(vec[i], std::make_shared<script::Module>());\r\n    }\r\n    curr = curr->get_module(vec[i]);\r\n \r\n```", "created_at": "2018-07-24T22:39:21Z", "updated_at": "2018-11-23T15:48:02Z", "html_url": "https://github.com/pytorch/pytorch/pull/9746#discussion_r204933705", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/9746", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/204933705"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/9746#discussion_r204933705"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/9746"}}, "body_html": "<p>Can simplify:</p>\n<pre><code>    if (curr-&gt;find_module(vec[i]) == nullptr) {\n         curr-&gt;register_module(vec[i], std::make_shared&lt;script::Module&gt;());\n    }\n    curr = curr-&gt;get_module(vec[i]);\n \n</code></pre>", "body_text": "Can simplify:\n    if (curr->find_module(vec[i]) == nullptr) {\n         curr->register_module(vec[i], std::make_shared<script::Module>());\n    }\n    curr = curr->get_module(vec[i]);"}