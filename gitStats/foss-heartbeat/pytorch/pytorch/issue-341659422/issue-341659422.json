{"url": "https://api.github.com/repos/pytorch/pytorch/issues/9471", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/9471/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/9471/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/9471/events", "html_url": "https://github.com/pytorch/pytorch/pull/9471", "id": 341659422, "node_id": "MDExOlB1bGxSZXF1ZXN0MjAxNzQ1NjY2", "number": 9471, "title": "make coalesceInsertedDataDependencies foolproof (with 2 fixes)", "user": {"login": "seravee", "id": 1297072, "node_id": "MDQ6VXNlcjEyOTcwNzI=", "avatar_url": "https://avatars0.githubusercontent.com/u/1297072?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seravee", "html_url": "https://github.com/seravee", "followers_url": "https://api.github.com/users/seravee/followers", "following_url": "https://api.github.com/users/seravee/following{/other_user}", "gists_url": "https://api.github.com/users/seravee/gists{/gist_id}", "starred_url": "https://api.github.com/users/seravee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seravee/subscriptions", "organizations_url": "https://api.github.com/users/seravee/orgs", "repos_url": "https://api.github.com/users/seravee/repos", "events_url": "https://api.github.com/users/seravee/events{/privacy}", "received_events_url": "https://api.github.com/users/seravee/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 890282107, "node_id": "MDU6TGFiZWw4OTAyODIxMDc=", "url": "https://api.github.com/repos/pytorch/pytorch/labels/caffe2", "name": "caffe2", "color": "210aa8", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 2, "created_at": "2018-07-16T20:06:38Z", "updated_at": "2018-10-11T18:21:53Z", "closed_at": "2018-10-11T18:21:53Z", "author_association": "CONTRIBUTOR", "pull_request": {"url": "https://api.github.com/repos/pytorch/pytorch/pulls/9471", "html_url": "https://github.com/pytorch/pytorch/pull/9471", "diff_url": "https://github.com/pytorch/pytorch/pull/9471.diff", "patch_url": "https://github.com/pytorch/pytorch/pull/9471.patch"}, "body_html": "<p>Summary:<br>\n1.Currently in coalesceInsertedDataDependencies, the op order correction part might fail for complex cases where a chain of the ops have incorrect order.</p>\n<p>E.g:<br>\nif the correct order is op1-&gt;op2-&gt;op3-&gt;op4,<br>\nbut the op order in the cfg is op3, op4, op1, op2,<br>\nthen after running coalesceInsertedDataDependencies(), the resulting op order will be op2, op3, op4, op1, which is still not correct.</p>\n<p>This blocks complex graph changes e.g. int8 conversion using backend_cutting.</p>\n<p>This diff works by using a full topological sort to sort the ops in each basicblock, to make sure that the op orders are indeed correct. For basicblocks where the number of ops are equal or less than 1, the sorting is skipped.</p>\n<p>2.Also a fix for moveInstructionBefore. Previously the function moveInstructionBefore() needs instr1 to be after instr2 to correctly work. This is due to the iterator invalidation rule for vector erase operation: Invalidates iterators and references at or after the point of the erase. The change get rid of potential vector iterator invalidation issue.</p>\n<p>Differential Revision: D8860056</p>", "body_text": "Summary:\n1.Currently in coalesceInsertedDataDependencies, the op order correction part might fail for complex cases where a chain of the ops have incorrect order.\nE.g:\nif the correct order is op1->op2->op3->op4,\nbut the op order in the cfg is op3, op4, op1, op2,\nthen after running coalesceInsertedDataDependencies(), the resulting op order will be op2, op3, op4, op1, which is still not correct.\nThis blocks complex graph changes e.g. int8 conversion using backend_cutting.\nThis diff works by using a full topological sort to sort the ops in each basicblock, to make sure that the op orders are indeed correct. For basicblocks where the number of ops are equal or less than 1, the sorting is skipped.\n2.Also a fix for moveInstructionBefore. Previously the function moveInstructionBefore() needs instr1 to be after instr2 to correctly work. This is due to the iterator invalidation rule for vector erase operation: Invalidates iterators and references at or after the point of the erase. The change get rid of potential vector iterator invalidation issue.\nDifferential Revision: D8860056", "body": "Summary:\n1.Currently in coalesceInsertedDataDependencies, the op order correction part might fail for complex cases where a chain of the ops have incorrect order.\n\nE.g:\nif the correct order is op1->op2->op3->op4,\nbut the op order in the cfg is op3, op4, op1, op2,\nthen after running coalesceInsertedDataDependencies(), the resulting op order will be op2, op3, op4, op1, which is still not correct.\n\nThis blocks complex graph changes e.g. int8 conversion using backend_cutting.\n\nThis diff works by using a full topological sort to sort the ops in each basicblock, to make sure that the op orders are indeed correct. For basicblocks where the number of ops are equal or less than 1, the sorting is skipped.\n\n2.Also a fix for moveInstructionBefore. Previously the function moveInstructionBefore() needs instr1 to be after instr2 to correctly work. This is due to the iterator invalidation rule for vector erase operation: Invalidates iterators and references at or after the point of the erase. The change get rid of potential vector iterator invalidation issue.\n\nDifferential Revision: D8860056\n"}