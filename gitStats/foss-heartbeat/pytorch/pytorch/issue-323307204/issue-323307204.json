{"url": "https://api.github.com/repos/pytorch/pytorch/issues/7583", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/7583/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/7583/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/7583/events", "html_url": "https://github.com/pytorch/pytorch/pull/7583", "id": 323307204, "node_id": "MDExOlB1bGxSZXF1ZXN0MTg4MTk2ODg4", "number": 7583, "title": "Throw error on tensor creation when sequence shape cannot be determined", "user": {"login": "sethah", "id": 7275795, "node_id": "MDQ6VXNlcjcyNzU3OTU=", "avatar_url": "https://avatars2.githubusercontent.com/u/7275795?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sethah", "html_url": "https://github.com/sethah", "followers_url": "https://api.github.com/users/sethah/followers", "following_url": "https://api.github.com/users/sethah/following{/other_user}", "gists_url": "https://api.github.com/users/sethah/gists{/gist_id}", "starred_url": "https://api.github.com/users/sethah/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sethah/subscriptions", "organizations_url": "https://api.github.com/users/sethah/orgs", "repos_url": "https://api.github.com/users/sethah/repos", "events_url": "https://api.github.com/users/sethah/events{/privacy}", "received_events_url": "https://api.github.com/users/sethah/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 3, "created_at": "2018-05-15T17:11:31Z", "updated_at": "2018-05-18T17:14:47Z", "closed_at": "2018-05-18T17:14:43Z", "author_association": "CONTRIBUTOR", "pull_request": {"url": "https://api.github.com/repos/pytorch/pytorch/pulls/7583", "html_url": "https://github.com/pytorch/pytorch/pull/7583", "diff_url": "https://github.com/pytorch/pytorch/pull/7583.diff", "patch_url": "https://github.com/pytorch/pytorch/pull/7583.patch"}, "body_html": "<p><span class=\"issue-keyword tooltipped tooltipped-se\" aria-label=\"This pull request closes issue #7278.\">Fixes</span> <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"320192756\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/7278\" data-hovercard-type=\"issue\" data-hovercard-url=\"/pytorch/pytorch/issues/7278/hovercard\" href=\"https://github.com/pytorch/pytorch/issues/7278\">#7278</a></p>\n<p>Currently, tensors can be created from Python sequences (determined by <code>PySequence_Check</code>). The shape of the tensor to be created is determined by iterating over the first element in each of the (potentially nested) sequences. This is done <a href=\"https://github.com/pytorch/pytorch/blob/master/torch/csrc/utils/tensor_new.cpp#L87\">here</a>.</p>\n<p>There is an assumption that it is safe to index the <code>PyObect</code> at element zero if <code>PySequence_Check(obj)</code> is true and <code>PySequence_Length(obj) &gt; 0</code>. Unfortunately, Python objects are still free to raise errors in their <code>__getitem__</code> methods under these conditions, which is often the case when creating tensors from Pandas objects. In this case, <code>PySequence_GetItem</code> will return a null pointer, which in turn causes a segmentation fault when the next <code>PySequence_Check</code> call is made.</p>\n<p>This patch adds a simple check for a null pointer and raises a <code>ValueError</code> when this happens. The error trace from the call to <code>__getitem__</code> is not propagated since it is generally unhelpful and confusing. A unit test is added that verifies the appropriate error is raised in this situation.</p>\n<h2>Examples</h2>\n<div class=\"highlight highlight-source-python\"><pre>seq <span class=\"pl-k\">=</span> pd.Series([<span class=\"pl-c1\">1.0</span>, <span class=\"pl-c1\">2.0</span>, <span class=\"pl-c1\">3.0</span>])\ntorch.Tensor(seq)  <span class=\"pl-c\"><span class=\"pl-c\">#</span> succeeds, since seq[0] is defined</span>\ntorch.Tensor(seq[<span class=\"pl-c1\">1</span>:])  <span class=\"pl-c\"><span class=\"pl-c\">#</span> segfault, since seq[0] generates a KeyError</span>\n\ndf <span class=\"pl-k\">=</span> pd.DataFrame(np.ones((<span class=\"pl-c1\">2</span>, <span class=\"pl-c1\">3</span>)), <span class=\"pl-v\">columns</span><span class=\"pl-k\">=</span>[<span class=\"pl-s\"><span class=\"pl-pds\">'</span>a<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>b<span class=\"pl-pds\">'</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>c<span class=\"pl-pds\">'</span></span>])\ntorch.Tensor(df)  <span class=\"pl-c\"><span class=\"pl-c\">#</span> segfault, since df[0] tries to access a column named 0</span></pre></div>\n<h2>Notes</h2>\n<ul>\n<li>It would be better to be able to handle Pandas objects in general, or at least give a nicer error message (e.g. \"did you mean torch.Tensor(df.values)?\"), but that code would be specific to checking for Pandas objects.</li>\n<li>I don't believe there's any surefire way to get the first element in the underlying sequence, which is what <code>PySequence_GetItem(obj, 0)</code> tries to do, but I could have missed it</li>\n<li>I am new to the code here, so if there is a better way to handle the error, or if the unit test is not quite exhaustive, please let me know.</li>\n</ul>", "body_text": "Fixes #7278\nCurrently, tensors can be created from Python sequences (determined by PySequence_Check). The shape of the tensor to be created is determined by iterating over the first element in each of the (potentially nested) sequences. This is done here.\nThere is an assumption that it is safe to index the PyObect at element zero if PySequence_Check(obj) is true and PySequence_Length(obj) > 0. Unfortunately, Python objects are still free to raise errors in their __getitem__ methods under these conditions, which is often the case when creating tensors from Pandas objects. In this case, PySequence_GetItem will return a null pointer, which in turn causes a segmentation fault when the next PySequence_Check call is made.\nThis patch adds a simple check for a null pointer and raises a ValueError when this happens. The error trace from the call to __getitem__ is not propagated since it is generally unhelpful and confusing. A unit test is added that verifies the appropriate error is raised in this situation.\nExamples\nseq = pd.Series([1.0, 2.0, 3.0])\ntorch.Tensor(seq)  # succeeds, since seq[0] is defined\ntorch.Tensor(seq[1:])  # segfault, since seq[0] generates a KeyError\n\ndf = pd.DataFrame(np.ones((2, 3)), columns=['a', 'b', 'c'])\ntorch.Tensor(df)  # segfault, since df[0] tries to access a column named 0\nNotes\n\nIt would be better to be able to handle Pandas objects in general, or at least give a nicer error message (e.g. \"did you mean torch.Tensor(df.values)?\"), but that code would be specific to checking for Pandas objects.\nI don't believe there's any surefire way to get the first element in the underlying sequence, which is what PySequence_GetItem(obj, 0) tries to do, but I could have missed it\nI am new to the code here, so if there is a better way to handle the error, or if the unit test is not quite exhaustive, please let me know.", "body": "Fixes #7278 \r\n\r\nCurrently, tensors can be created from Python sequences (determined by `PySequence_Check`). The shape of the tensor to be created is determined by iterating over the first element in each of the (potentially nested) sequences. This is done [here](https://github.com/pytorch/pytorch/blob/master/torch/csrc/utils/tensor_new.cpp#L87). \r\n\r\nThere is an assumption that it is safe to index the `PyObect` at element zero if `PySequence_Check(obj)` is true and `PySequence_Length(obj) > 0`. Unfortunately, Python objects are still free to raise errors in their `__getitem__` methods under these conditions, which is often the case when creating tensors from Pandas objects. In this case, `PySequence_GetItem` will return a null pointer, which in turn causes a segmentation fault when the next `PySequence_Check` call is made.\r\n\r\nThis patch adds a simple check for a null pointer and raises a `ValueError` when this happens. The error trace from the call to `__getitem__` is not propagated since it is generally unhelpful and confusing. A unit test is added that verifies the appropriate error is raised in this situation.\r\n\r\n## Examples\r\n\r\n```python\r\nseq = pd.Series([1.0, 2.0, 3.0])\r\ntorch.Tensor(seq)  # succeeds, since seq[0] is defined\r\ntorch.Tensor(seq[1:])  # segfault, since seq[0] generates a KeyError\r\n\r\ndf = pd.DataFrame(np.ones((2, 3)), columns=['a', 'b', 'c'])\r\ntorch.Tensor(df)  # segfault, since df[0] tries to access a column named 0\r\n```\r\n\r\n## Notes\r\n\r\n* It would be better to be able to handle Pandas objects in general, or at least give a nicer error message (e.g. \"did you mean torch.Tensor(df.values)?\"), but that code would be specific to checking for Pandas objects.\r\n* I don't believe there's any surefire way to get the first element in the underlying sequence, which is what `PySequence_GetItem(obj, 0)` tries to do, but I could have missed it\r\n* I am new to the code here, so if there is a better way to handle the error, or if the unit test is not quite exhaustive, please let me know."}