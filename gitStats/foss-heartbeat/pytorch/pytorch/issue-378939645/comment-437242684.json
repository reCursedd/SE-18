{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/437242684", "html_url": "https://github.com/pytorch/pytorch/issues/13750#issuecomment-437242684", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/13750", "id": 437242684, "node_id": "MDEyOklzc3VlQ29tbWVudDQzNzI0MjY4NA==", "user": {"login": "SsnL", "id": 5674597, "node_id": "MDQ6VXNlcjU2NzQ1OTc=", "avatar_url": "https://avatars2.githubusercontent.com/u/5674597?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SsnL", "html_url": "https://github.com/SsnL", "followers_url": "https://api.github.com/users/SsnL/followers", "following_url": "https://api.github.com/users/SsnL/following{/other_user}", "gists_url": "https://api.github.com/users/SsnL/gists{/gist_id}", "starred_url": "https://api.github.com/users/SsnL/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SsnL/subscriptions", "organizations_url": "https://api.github.com/users/SsnL/orgs", "repos_url": "https://api.github.com/users/SsnL/repos", "events_url": "https://api.github.com/users/SsnL/events{/privacy}", "received_events_url": "https://api.github.com/users/SsnL/received_events", "type": "User", "site_admin": false}, "created_at": "2018-11-09T04:00:30Z", "updated_at": "2018-11-09T04:00:37Z", "author_association": "CONTRIBUTOR", "body_html": "<p>If helpful, I use lockf to work around the bug</p>\n<div class=\"highlight highlight-source-python\"><pre>                f <span class=\"pl-k\">=</span> <span class=\"pl-c1\">open</span>(state.distributed_init_file, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>a+<span class=\"pl-pds\">'</span></span>)\n\n                <span class=\"pl-c\"><span class=\"pl-c\">#</span> lockf interpretation</span>\n                <span class=\"pl-c\"><span class=\"pl-c\">#</span>   1st byte: the truncating lock, exclusively grabbed by the</span>\n                <span class=\"pl-c\"><span class=\"pl-c\">#</span>             truncating process</span>\n                <span class=\"pl-c\"><span class=\"pl-c\">#</span>             NB: never release this lock</span>\n                <span class=\"pl-c\"><span class=\"pl-c\">#</span>   2st byte: the joining lock, sharedly grabbed by all after</span>\n                <span class=\"pl-c\"><span class=\"pl-c\">#</span>             truncating to ensure truncating finishes before</span>\n                <span class=\"pl-c\"><span class=\"pl-c\">#</span>             init process group on all ranks</span>\n                <span class=\"pl-c\"><span class=\"pl-c\">#</span>             NB: never release this lock</span>\n\n                <span class=\"pl-c\"><span class=\"pl-c\">#</span> lockf API: lockf(file, option, length, start)</span>\n                truncating_proc <span class=\"pl-k\">=</span> <span class=\"pl-c1\">False</span>\n                <span class=\"pl-k\">try</span>:\n                    <span class=\"pl-c\"><span class=\"pl-c\">#</span> grab both bytes exclusively</span>\n                    fcntl.lockf(f, fcntl.<span class=\"pl-c1\">LOCK_EX</span> <span class=\"pl-k\">|</span> fcntl.<span class=\"pl-c1\">LOCK_NB</span>, <span class=\"pl-c1\">2</span>, <span class=\"pl-c1\">0</span>)\n                    truncating_proc <span class=\"pl-k\">=</span> <span class=\"pl-c1\">True</span>\n                <span class=\"pl-k\">except</span> <span class=\"pl-c1\">IOError</span>:\n                    <span class=\"pl-k\">pass</span>\n                <span class=\"pl-k\">if</span> truncating_proc:\n                    f.truncate(<span class=\"pl-c1\">0</span>)\n\n                <span class=\"pl-c\"><span class=\"pl-c\">#</span> truncating proc: downgrad to shared lock on 2nd byte</span>\n                <span class=\"pl-c\"><span class=\"pl-c\">#</span> others         : grab a shared lock on 2nd byte</span>\n                fcntl.lockf(f, fcntl.<span class=\"pl-c1\">LOCK_SH</span>, <span class=\"pl-c1\">1</span>, <span class=\"pl-c1\">1</span>)\n                <span class=\"pl-k\">assert</span> os.path.getsize(state.distributed_init_file) <span class=\"pl-k\">==</span> <span class=\"pl-c1\">0</span>\n\n                <span class=\"pl-k\">def</span> <span class=\"pl-en\">release_distributed_file_init_handle</span>():\n                    fcntl.lockf(f, fcntl.<span class=\"pl-c1\">LOCK_UN</span>)\n                    f.close()\n\n                atexit.register(release_distributed_file_init_handle)  <span class=\"pl-c\"><span class=\"pl-c\">#</span> well, not necessary</span></pre></div>", "body_text": "If helpful, I use lockf to work around the bug\n                f = open(state.distributed_init_file, 'a+')\n\n                # lockf interpretation\n                #   1st byte: the truncating lock, exclusively grabbed by the\n                #             truncating process\n                #             NB: never release this lock\n                #   2st byte: the joining lock, sharedly grabbed by all after\n                #             truncating to ensure truncating finishes before\n                #             init process group on all ranks\n                #             NB: never release this lock\n\n                # lockf API: lockf(file, option, length, start)\n                truncating_proc = False\n                try:\n                    # grab both bytes exclusively\n                    fcntl.lockf(f, fcntl.LOCK_EX | fcntl.LOCK_NB, 2, 0)\n                    truncating_proc = True\n                except IOError:\n                    pass\n                if truncating_proc:\n                    f.truncate(0)\n\n                # truncating proc: downgrad to shared lock on 2nd byte\n                # others         : grab a shared lock on 2nd byte\n                fcntl.lockf(f, fcntl.LOCK_SH, 1, 1)\n                assert os.path.getsize(state.distributed_init_file) == 0\n\n                def release_distributed_file_init_handle():\n                    fcntl.lockf(f, fcntl.LOCK_UN)\n                    f.close()\n\n                atexit.register(release_distributed_file_init_handle)  # well, not necessary", "body": "If helpful, I use lockf to work around the bug\r\n```py\r\n                f = open(state.distributed_init_file, 'a+')\r\n\r\n                # lockf interpretation\r\n                #   1st byte: the truncating lock, exclusively grabbed by the\r\n                #             truncating process\r\n                #             NB: never release this lock\r\n                #   2st byte: the joining lock, sharedly grabbed by all after\r\n                #             truncating to ensure truncating finishes before\r\n                #             init process group on all ranks\r\n                #             NB: never release this lock\r\n\r\n                # lockf API: lockf(file, option, length, start)\r\n                truncating_proc = False\r\n                try:\r\n                    # grab both bytes exclusively\r\n                    fcntl.lockf(f, fcntl.LOCK_EX | fcntl.LOCK_NB, 2, 0)\r\n                    truncating_proc = True\r\n                except IOError:\r\n                    pass\r\n                if truncating_proc:\r\n                    f.truncate(0)\r\n\r\n                # truncating proc: downgrad to shared lock on 2nd byte\r\n                # others         : grab a shared lock on 2nd byte\r\n                fcntl.lockf(f, fcntl.LOCK_SH, 1, 1)\r\n                assert os.path.getsize(state.distributed_init_file) == 0\r\n\r\n                def release_distributed_file_init_handle():\r\n                    fcntl.lockf(f, fcntl.LOCK_UN)\r\n                    f.close()\r\n\r\n                atexit.register(release_distributed_file_init_handle)  # well, not necessary\r\n```"}