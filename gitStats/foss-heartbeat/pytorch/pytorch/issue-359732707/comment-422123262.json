{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/422123262", "html_url": "https://github.com/pytorch/pytorch/issues/11624#issuecomment-422123262", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/11624", "id": 422123262, "node_id": "MDEyOklzc3VlQ29tbWVudDQyMjEyMzI2Mg==", "user": {"login": "zippeurfou", "id": 4520383, "node_id": "MDQ6VXNlcjQ1MjAzODM=", "avatar_url": "https://avatars3.githubusercontent.com/u/4520383?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zippeurfou", "html_url": "https://github.com/zippeurfou", "followers_url": "https://api.github.com/users/zippeurfou/followers", "following_url": "https://api.github.com/users/zippeurfou/following{/other_user}", "gists_url": "https://api.github.com/users/zippeurfou/gists{/gist_id}", "starred_url": "https://api.github.com/users/zippeurfou/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zippeurfou/subscriptions", "organizations_url": "https://api.github.com/users/zippeurfou/orgs", "repos_url": "https://api.github.com/users/zippeurfou/repos", "events_url": "https://api.github.com/users/zippeurfou/events{/privacy}", "received_events_url": "https://api.github.com/users/zippeurfou/received_events", "type": "User", "site_admin": false}, "created_at": "2018-09-17T18:34:48Z", "updated_at": "2018-09-17T18:34:57Z", "author_association": "CONTRIBUTOR", "body_html": "<p>I am unsure I am the best person to answer but I guess it would be fine since:<br>\n<code>-np.max(-np.array([1,2,3,4,5,0,-1,-2,-3])) == np.min(np.array([1,2,3,4,5,0,-1,-2,-3]))</code><br>\nThe TLDR of the paper:<br>\nIf you return min,mean,max and odd power mean, your embedding trigger better result than just the mean. Therefore, an feature suggestion of the embeddingBag would be to:</p>\n<ol>\n<li>be able to get pmean (starting with min)</li>\n<li>return multiple of them concatenated. ie. <code>my_emb_pmean = nn.EmbeddingBag(num_embeddings, embedding_dim, mode = [\"min\", \"mean\", \"max\" ])</code>. This would be of dim <code>(num_embedding, embedding_dim * len(mode))</code></li>\n</ol>\n<p>Right now I am unsure if there are any easy way to ask two EmbeddingBag to share the same weight to achieve the same result.</p>", "body_text": "I am unsure I am the best person to answer but I guess it would be fine since:\n-np.max(-np.array([1,2,3,4,5,0,-1,-2,-3])) == np.min(np.array([1,2,3,4,5,0,-1,-2,-3]))\nThe TLDR of the paper:\nIf you return min,mean,max and odd power mean, your embedding trigger better result than just the mean. Therefore, an feature suggestion of the embeddingBag would be to:\n\nbe able to get pmean (starting with min)\nreturn multiple of them concatenated. ie. my_emb_pmean = nn.EmbeddingBag(num_embeddings, embedding_dim, mode = [\"min\", \"mean\", \"max\" ]). This would be of dim (num_embedding, embedding_dim * len(mode))\n\nRight now I am unsure if there are any easy way to ask two EmbeddingBag to share the same weight to achieve the same result.", "body": "I am unsure I am the best person to answer but I guess it would be fine since:\r\n`-np.max(-np.array([1,2,3,4,5,0,-1,-2,-3])) == np.min(np.array([1,2,3,4,5,0,-1,-2,-3]))`\r\nThe TLDR of the paper:\r\nIf you return min,mean,max and odd power mean, your embedding trigger better result than just the mean. Therefore, an feature suggestion of the embeddingBag would be to:\r\n1) be able to get pmean (starting with min)\r\n2) return multiple of them concatenated. ie. `my_emb_pmean = nn.EmbeddingBag(num_embeddings, embedding_dim, mode = [\"min\", \"mean\", \"max\" ])`. This would be of dim `(num_embedding, embedding_dim * len(mode))`\r\n\r\nRight now I am unsure if there are any easy way to ask two EmbeddingBag to share the same weight to achieve the same result."}