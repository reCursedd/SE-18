{"url": "https://api.github.com/repos/pytorch/pytorch/issues/1438", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/1438/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/1438/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/1438/events", "html_url": "https://github.com/pytorch/pytorch/issues/1438", "id": 225751123, "node_id": "MDU6SXNzdWUyMjU3NTExMjM=", "number": 1438, "title": "Sparse tensor values()/indices() return read-only (const) tensors", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2017-05-02T16:34:00Z", "updated_at": "2017-05-02T18:41:35Z", "closed_at": "2017-05-02T18:41:35Z", "author_association": "CONTRIBUTOR", "body_html": "<p><strong>tl;dr</strong> I propose introducing a new read-only view on tensors, which disable in place operations on a tensor (but can otherwise share storage with a mutable view). <code>values()</code> and <code>indices()</code> should return these read-only views, which make it easier for sparse tensor to maintain its internal invariants.</p>\n<p><strong>Motivation.</strong> The current sparse tensors API provides two methods: <code>values()</code> and <code>indices()</code>, which let you see into the underlying representation of a sparse tensor. These are full, honest to god tensors, supporting the full complement of inplace and out-of-place operations. However, the inplace operations allow for plenty of mischief:</p>\n<pre><code>&gt;&gt; x = torch.sparse.FloatTensor(i,v)\n&gt;&gt;&gt; x\nFloatTensor with indices:\n\n 3  5\n[torch.LongTensor of size 1x2]\nand values:\n\n 0\n 2\n[torch.FloatTensor of size 2]\n\n&gt;&gt;&gt; x.is_coalesced()\nFalse\n\n&gt;&gt;&gt; y = x.coalesce()\n&gt;&gt;&gt; y.indices().fill_(0)\n\n 0  0\n[torch.LongTensor of size 1x2]\n\n&gt;&gt;&gt; y.is_coalesced()\nTrue\n&gt;&gt;&gt; y\nFloatTensor with indices:\n\n 0  0\n[torch.LongTensor of size 1x2]\nand values:\n\n 0\n 2\n[torch.FloatTensor of size 2]\n</code></pre>\n<p>This is a failure of abstraction: the ability to perform in-place updates on the internal tensors of a sparse tensor means that a client can break invariants that we want to apply to a sparse tensor. Unfortunately, being able to directly handle values()/indices() is quite useful, because it allows users to implement operations on sparse tensors that are not otherwise available (see <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"224611346\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/1369\" data-hovercard-type=\"issue\" data-hovercard-url=\"/pytorch/pytorch/issues/1369/hovercard\" href=\"https://github.com/pytorch/pytorch/issues/1369\">#1369</a> for more context.)</p>\n<p>The way to solve this situation is to outlaw inplace operations on sparse tensor internals. To do this, we need a way of providing a \"read-only\" view on tensor.</p>\n<p><strong>Design.</strong> I propose the following changes:</p>\n<ol>\n<li>\n<p>Add a new field to <code>THTensor</code> tracking whether or not this tensor's view on the underlying storage is read-only or not. Since there is already a <code>char flag</code> field, an extra <code>char</code> of storage should not cause the size of a padded THTensor to increase.</p>\n</li>\n<li>\n<p>For all inplace operations, add a test if THTensor is read-only. If it is, raise an error.</p>\n</li>\n<li>\n<p>Modify <code>values</code> and <code>indices</code> to mark the newly allocated THTensor as read-only.</p>\n</li>\n<li>\n<p>Add new method <code>const</code> to tensor which gives you a new THTensor that has a read-only view on the underlying storage, as well as an <code>unsafe_mutable</code> to get a writable view.</p>\n</li>\n</ol>\n<p><strong>Alternatives.</strong> Arguably, only <code>indices()</code> needs to be read-only to preserve invariants on sparse tensors; although it is tricky to handle uncoalesced <code>values()</code> correctly, in-place updates cannot cause problems. (Notably, because the sparse tensor always knows its dimensions, sparse tensors handle shape changes in their underlying tensors correctly.)</p>\n<p><strong>Going further.</strong> These are only read-only views, because it is possible for the underlying storage to change under you due to an inplace update from a writeable view on the same storage. It may also be interesting to support truly immutable storage, for which ALL views are read-only. I don't have a good use case for something like this, but maybe someone else does.</p>", "body_text": "tl;dr I propose introducing a new read-only view on tensors, which disable in place operations on a tensor (but can otherwise share storage with a mutable view). values() and indices() should return these read-only views, which make it easier for sparse tensor to maintain its internal invariants.\nMotivation. The current sparse tensors API provides two methods: values() and indices(), which let you see into the underlying representation of a sparse tensor. These are full, honest to god tensors, supporting the full complement of inplace and out-of-place operations. However, the inplace operations allow for plenty of mischief:\n>> x = torch.sparse.FloatTensor(i,v)\n>>> x\nFloatTensor with indices:\n\n 3  5\n[torch.LongTensor of size 1x2]\nand values:\n\n 0\n 2\n[torch.FloatTensor of size 2]\n\n>>> x.is_coalesced()\nFalse\n\n>>> y = x.coalesce()\n>>> y.indices().fill_(0)\n\n 0  0\n[torch.LongTensor of size 1x2]\n\n>>> y.is_coalesced()\nTrue\n>>> y\nFloatTensor with indices:\n\n 0  0\n[torch.LongTensor of size 1x2]\nand values:\n\n 0\n 2\n[torch.FloatTensor of size 2]\n\nThis is a failure of abstraction: the ability to perform in-place updates on the internal tensors of a sparse tensor means that a client can break invariants that we want to apply to a sparse tensor. Unfortunately, being able to directly handle values()/indices() is quite useful, because it allows users to implement operations on sparse tensors that are not otherwise available (see #1369 for more context.)\nThe way to solve this situation is to outlaw inplace operations on sparse tensor internals. To do this, we need a way of providing a \"read-only\" view on tensor.\nDesign. I propose the following changes:\n\n\nAdd a new field to THTensor tracking whether or not this tensor's view on the underlying storage is read-only or not. Since there is already a char flag field, an extra char of storage should not cause the size of a padded THTensor to increase.\n\n\nFor all inplace operations, add a test if THTensor is read-only. If it is, raise an error.\n\n\nModify values and indices to mark the newly allocated THTensor as read-only.\n\n\nAdd new method const to tensor which gives you a new THTensor that has a read-only view on the underlying storage, as well as an unsafe_mutable to get a writable view.\n\n\nAlternatives. Arguably, only indices() needs to be read-only to preserve invariants on sparse tensors; although it is tricky to handle uncoalesced values() correctly, in-place updates cannot cause problems. (Notably, because the sparse tensor always knows its dimensions, sparse tensors handle shape changes in their underlying tensors correctly.)\nGoing further. These are only read-only views, because it is possible for the underlying storage to change under you due to an inplace update from a writeable view on the same storage. It may also be interesting to support truly immutable storage, for which ALL views are read-only. I don't have a good use case for something like this, but maybe someone else does.", "body": "**tl;dr** I propose introducing a new read-only view on tensors, which disable in place operations on a tensor (but can otherwise share storage with a mutable view). `values()` and `indices()` should return these read-only views, which make it easier for sparse tensor to maintain its internal invariants.\r\n\r\n**Motivation.** The current sparse tensors API provides two methods: `values()` and `indices()`, which let you see into the underlying representation of a sparse tensor. These are full, honest to god tensors, supporting the full complement of inplace and out-of-place operations. However, the inplace operations allow for plenty of mischief:\r\n\r\n```\r\n>> x = torch.sparse.FloatTensor(i,v)\r\n>>> x\r\nFloatTensor with indices:\r\n\r\n 3  5\r\n[torch.LongTensor of size 1x2]\r\nand values:\r\n\r\n 0\r\n 2\r\n[torch.FloatTensor of size 2]\r\n\r\n>>> x.is_coalesced()\r\nFalse\r\n\r\n>>> y = x.coalesce()\r\n>>> y.indices().fill_(0)\r\n\r\n 0  0\r\n[torch.LongTensor of size 1x2]\r\n\r\n>>> y.is_coalesced()\r\nTrue\r\n>>> y\r\nFloatTensor with indices:\r\n\r\n 0  0\r\n[torch.LongTensor of size 1x2]\r\nand values:\r\n\r\n 0\r\n 2\r\n[torch.FloatTensor of size 2]\r\n```\r\n\r\nThis is a failure of abstraction: the ability to perform in-place updates on the internal tensors of a sparse tensor means that a client can break invariants that we want to apply to a sparse tensor. Unfortunately, being able to directly handle values()/indices() is quite useful, because it allows users to implement operations on sparse tensors that are not otherwise available (see #1369 for more context.)\r\n\r\nThe way to solve this situation is to outlaw inplace operations on sparse tensor internals. To do this, we need a way of providing a \"read-only\" view on tensor.\r\n\r\n**Design.** I propose the following changes:\r\n\r\n1. Add a new field to `THTensor` tracking whether or not this tensor's view on the underlying storage is read-only or not. Since there is already a `char flag` field, an extra `char` of storage should not cause the size of a padded THTensor to increase.\r\n\r\n2. For all inplace operations, add a test if THTensor is read-only. If it is, raise an error.\r\n\r\n3. Modify `values` and `indices` to mark the newly allocated THTensor as read-only.\r\n\r\n4. Add new method `const` to tensor which gives you a new THTensor that has a read-only view on the underlying storage, as well as an `unsafe_mutable` to get a writable view.\r\n\r\n**Alternatives.** Arguably, only `indices()` needs to be read-only to preserve invariants on sparse tensors; although it is tricky to handle uncoalesced `values()` correctly, in-place updates cannot cause problems. (Notably, because the sparse tensor always knows its dimensions, sparse tensors handle shape changes in their underlying tensors correctly.)\r\n\r\n**Going further.** These are only read-only views, because it is possible for the underlying storage to change under you due to an inplace update from a writeable view on the same storage. It may also be interesting to support truly immutable storage, for which ALL views are read-only. I don't have a good use case for something like this, but maybe someone else does."}