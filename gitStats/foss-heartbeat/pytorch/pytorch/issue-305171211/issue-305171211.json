{"url": "https://api.github.com/repos/pytorch/pytorch/issues/5774", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/5774/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/5774/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/5774/events", "html_url": "https://github.com/pytorch/pytorch/pull/5774", "id": 305171211, "node_id": "MDExOlB1bGxSZXF1ZXN0MTc0OTY0ODI1", "number": 5774, "title": "improve handling of precision issue in torch.multinomial (solves #4858)", "user": {"login": "t-vi", "id": 20787943, "node_id": "MDQ6VXNlcjIwNzg3OTQz", "avatar_url": "https://avatars2.githubusercontent.com/u/20787943?v=4", "gravatar_id": "", "url": "https://api.github.com/users/t-vi", "html_url": "https://github.com/t-vi", "followers_url": "https://api.github.com/users/t-vi/followers", "following_url": "https://api.github.com/users/t-vi/following{/other_user}", "gists_url": "https://api.github.com/users/t-vi/gists{/gist_id}", "starred_url": "https://api.github.com/users/t-vi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/t-vi/subscriptions", "organizations_url": "https://api.github.com/users/t-vi/orgs", "repos_url": "https://api.github.com/users/t-vi/repos", "events_url": "https://api.github.com/users/t-vi/events{/privacy}", "received_events_url": "https://api.github.com/users/t-vi/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 6, "created_at": "2018-03-14T14:03:22Z", "updated_at": "2018-11-23T15:40:54Z", "closed_at": "2018-03-17T14:26:23Z", "author_association": "CONTRIBUTOR", "pull_request": {"url": "https://api.github.com/repos/pytorch/pytorch/pulls/5774", "html_url": "https://github.com/pytorch/pytorch/pull/5774", "diff_url": "https://github.com/pytorch/pytorch/pull/5774.diff", "patch_url": "https://github.com/pytorch/pytorch/pull/5774.patch"}, "body_html": "<p>Hi,</p>\n<p>I think I figured out <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"291717947\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/4858\" data-hovercard-type=\"issue\" data-hovercard-url=\"/pytorch/pytorch/issues/4858/hovercard\" href=\"https://github.com/pytorch/pytorch/issues/4858\">#4858</a>:<br>\nIf you do <code>torch.cumsum(freqs, 0)</code>, you see that the cumulated sum isn't one when the first of the final 0.0 probabilities happen, so there is a precision issue at the <em>upper</em> end of the range (making the breakage more subtle).<br>\nWhat seems to happen in  <code>aten/src/THC/THCTensorRandom.cuh</code> is that the <code>(0.0, 1.0]</code> random value <code>val</code> generated by <code>cuda_uniform</code> is passed from <code>sampleMultinomialWithReplacement</code> to <code>binarySearchForMultinomial</code> in some cases (1.0 ?), the <code>lt(midVal, val)</code> seems to evaluate to <code>true</code> always and we end with <code>start = size</code> (start being the result of the binary search).<br>\nThen the <a href=\"https://github.com/pytorch/pytorch/blob/e9fffb5579e570d31a256fde7e387d3d8d40b845/aten/src/THC/THCTensorRandom.cuh#L144\"><code>if (start == size)</code></a> catches this precision issue but does the wrong thing in setting <code>start = 0</code>. A more correct thing is to set start = size - 1 (but care for size = 0 unless the compiler figures it cannot happen) and let the code that follows find a non-zero-probability bin.</p>\n<p>With the attached small fix <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=70152\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/coventry\">@coventry</a>'s test case passes 1 million iterations when it used to run into an error reliably in &lt; 10 000 iterations (and I checked that it was indeed reaching the <code>start = 0</code> in this case).</p>\n<p>I hope this helps.</p>\n<p>Best regards</p>\n<p>Thomas</p>", "body_text": "Hi,\nI think I figured out #4858:\nIf you do torch.cumsum(freqs, 0), you see that the cumulated sum isn't one when the first of the final 0.0 probabilities happen, so there is a precision issue at the upper end of the range (making the breakage more subtle).\nWhat seems to happen in  aten/src/THC/THCTensorRandom.cuh is that the (0.0, 1.0] random value val generated by cuda_uniform is passed from sampleMultinomialWithReplacement to binarySearchForMultinomial in some cases (1.0 ?), the lt(midVal, val) seems to evaluate to true always and we end with start = size (start being the result of the binary search).\nThen the if (start == size) catches this precision issue but does the wrong thing in setting start = 0. A more correct thing is to set start = size - 1 (but care for size = 0 unless the compiler figures it cannot happen) and let the code that follows find a non-zero-probability bin.\nWith the attached small fix @coventry's test case passes 1 million iterations when it used to run into an error reliably in < 10 000 iterations (and I checked that it was indeed reaching the start = 0 in this case).\nI hope this helps.\nBest regards\nThomas", "body": "Hi,\r\n\r\nI think I figured out #4858:\r\nIf you do `torch.cumsum(freqs, 0)`, you see that the cumulated sum isn't one when the first of the final 0.0 probabilities happen, so there is a precision issue at the *upper* end of the range (making the breakage more subtle).\r\nWhat seems to happen in  `aten/src/THC/THCTensorRandom.cuh` is that the `(0.0, 1.0]` random value `val` generated by `cuda_uniform` is passed from `sampleMultinomialWithReplacement` to `binarySearchForMultinomial` in some cases (1.0 ?), the `lt(midVal, val)` seems to evaluate to `true` always and we end with `start = size` (start being the result of the binary search).\r\nThen the [`if (start == size)`](https://github.com/pytorch/pytorch/blob/e9fffb5579e570d31a256fde7e387d3d8d40b845/aten/src/THC/THCTensorRandom.cuh#L144) catches this precision issue but does the wrong thing in setting `start = 0`. A more correct thing is to set start = size - 1 (but care for size = 0 unless the compiler figures it cannot happen) and let the code that follows find a non-zero-probability bin.\r\n\r\nWith the attached small fix @coventry's test case passes 1 million iterations when it used to run into an error reliably in < 10 000 iterations (and I checked that it was indeed reaching the `start = 0` in this case).\r\n\r\nI hope this helps.\r\n\r\nBest regards\r\n\r\nThomas\r\n"}