{"url": "https://api.github.com/repos/pytorch/pytorch/issues/4807", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/4807/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/4807/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/4807/events", "html_url": "https://github.com/pytorch/pytorch/pull/4807", "id": 290950944, "node_id": "MDExOlB1bGxSZXF1ZXN0MTY0NjU4MDcw", "number": 4807, "title": "Fix #4480 by tracing inputs before running function.", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 4, "created_at": "2018-01-23T18:46:27Z", "updated_at": "2018-11-23T15:38:28Z", "closed_at": "2018-01-23T23:06:55Z", "author_association": "CONTRIBUTOR", "pull_request": {"url": "https://api.github.com/repos/pytorch/pytorch/pulls/4807", "html_url": "https://github.com/pytorch/pytorch/pull/4807", "diff_url": "https://github.com/pytorch/pytorch/pull/4807.diff", "patch_url": "https://github.com/pytorch/pytorch/pull/4807.patch"}, "body_html": "<p>The DCE trick says that if I have y = f(x), and f is internally implemented as<br>\ng, it's OK to trace both g and f. Recall the tracing algorithm is:</p>\n<pre><code>enter f(x)\ncompute its result y\ntrace y = f(x)\nreturn from f\n</code></pre>\n<p>So when you run the example above, you'll do this:</p>\n<pre><code># suppose x is mapped to %1\nenter f(x)\nenter g(x)\nresult of g is y\ntrace y = g(x a.k.a. %1) (mapping y to %2)\nreturn from g\nresult of f is y\ntrace y = f(x a.k.a. %1) (remapping y to %3)\nreturn from f\n</code></pre>\n<p>and end up with a trace like this:</p>\n<pre><code>%2 = g(%1)\n%3 = f(%1)\n</code></pre>\n<p>... only %3 is live, because %2 was killed from the mapping...  Subsequent DCE<br>\nwill eliminate the invocation of g and you'll only see f in the final trace.</p>\n<p>However, if f and g are inplace functions, the machinery breaks:</p>\n<pre><code># suppose x is mapped to %1\nenter f(x)\nenter g(x)\nresult of g is x\ntrace x = g(x a.k.a. %1) (remapping x to %2)\nreturn from g\nresult of f is x\ntrace x = f(x a.k.a. %2) (remapping x to %3)\nreturn from f\nresulting in:\n\n%2 = g(%1)\n%3 = f(%2) # OOPS\n</code></pre>\n<p>This commit changes the strategy so we instead do this:</p>\n<pre><code>enter f(x)\ntrace f(x)\ncompute its result y\ntrace y = f(x)  (computed above)\nreturn from f\n</code></pre>\n<p>Now we get the correct Value before it is overwritten.<br>\nHere is what the new trace code looks like:</p>\n<pre><code>jit::tracer::PreTraceInfo trace_info;\nif (jit::tracer::isTracing( self, index )) {\n  trace_info = jit::tracer::preRecordTrace( \"index_fill\", { self, index } );\n  setattr(trace_info.n, jit::Symbol(\"dim\"), dim);\n  setattr(trace_info.n, jit::Symbol(\"value\"), value);\n}\nbaseType-&gt;index_fill_(self_, dim, index_, value);\nincrement_version(self);\nrebase_history(self, grad_fn);\nif (trace_info.state != nullptr) {\n  jit::tracer::postRecordTrace( trace_info,  { self } );\n}\n</code></pre>\n<p>Signed-off-by: Edward Z. Yang <a href=\"mailto:ezyang@fb.com\">ezyang@fb.com</a></p>", "body_text": "The DCE trick says that if I have y = f(x), and f is internally implemented as\ng, it's OK to trace both g and f. Recall the tracing algorithm is:\nenter f(x)\ncompute its result y\ntrace y = f(x)\nreturn from f\n\nSo when you run the example above, you'll do this:\n# suppose x is mapped to %1\nenter f(x)\nenter g(x)\nresult of g is y\ntrace y = g(x a.k.a. %1) (mapping y to %2)\nreturn from g\nresult of f is y\ntrace y = f(x a.k.a. %1) (remapping y to %3)\nreturn from f\n\nand end up with a trace like this:\n%2 = g(%1)\n%3 = f(%1)\n\n... only %3 is live, because %2 was killed from the mapping...  Subsequent DCE\nwill eliminate the invocation of g and you'll only see f in the final trace.\nHowever, if f and g are inplace functions, the machinery breaks:\n# suppose x is mapped to %1\nenter f(x)\nenter g(x)\nresult of g is x\ntrace x = g(x a.k.a. %1) (remapping x to %2)\nreturn from g\nresult of f is x\ntrace x = f(x a.k.a. %2) (remapping x to %3)\nreturn from f\nresulting in:\n\n%2 = g(%1)\n%3 = f(%2) # OOPS\n\nThis commit changes the strategy so we instead do this:\nenter f(x)\ntrace f(x)\ncompute its result y\ntrace y = f(x)  (computed above)\nreturn from f\n\nNow we get the correct Value before it is overwritten.\nHere is what the new trace code looks like:\njit::tracer::PreTraceInfo trace_info;\nif (jit::tracer::isTracing( self, index )) {\n  trace_info = jit::tracer::preRecordTrace( \"index_fill\", { self, index } );\n  setattr(trace_info.n, jit::Symbol(\"dim\"), dim);\n  setattr(trace_info.n, jit::Symbol(\"value\"), value);\n}\nbaseType->index_fill_(self_, dim, index_, value);\nincrement_version(self);\nrebase_history(self, grad_fn);\nif (trace_info.state != nullptr) {\n  jit::tracer::postRecordTrace( trace_info,  { self } );\n}\n\nSigned-off-by: Edward Z. Yang ezyang@fb.com", "body": "The DCE trick says that if I have y = f(x), and f is internally implemented as\r\ng, it's OK to trace both g and f. Recall the tracing algorithm is:\r\n\r\n    enter f(x)\r\n    compute its result y\r\n    trace y = f(x)\r\n    return from f\r\n\r\nSo when you run the example above, you'll do this:\r\n\r\n    # suppose x is mapped to %1\r\n    enter f(x)\r\n    enter g(x)\r\n    result of g is y\r\n    trace y = g(x a.k.a. %1) (mapping y to %2)\r\n    return from g\r\n    result of f is y\r\n    trace y = f(x a.k.a. %1) (remapping y to %3)\r\n    return from f\r\n\r\nand end up with a trace like this:\r\n\r\n    %2 = g(%1)\r\n    %3 = f(%1)\r\n\r\n... only %3 is live, because %2 was killed from the mapping...  Subsequent DCE\r\nwill eliminate the invocation of g and you'll only see f in the final trace.\r\n\r\nHowever, if f and g are inplace functions, the machinery breaks:\r\n\r\n    # suppose x is mapped to %1\r\n    enter f(x)\r\n    enter g(x)\r\n    result of g is x\r\n    trace x = g(x a.k.a. %1) (remapping x to %2)\r\n    return from g\r\n    result of f is x\r\n    trace x = f(x a.k.a. %2) (remapping x to %3)\r\n    return from f\r\n    resulting in:\r\n\r\n    %2 = g(%1)\r\n    %3 = f(%2) # OOPS\r\n\r\nThis commit changes the strategy so we instead do this:\r\n\r\n    enter f(x)\r\n    trace f(x)\r\n    compute its result y\r\n    trace y = f(x)  (computed above)\r\n    return from f\r\n\r\nNow we get the correct Value before it is overwritten.\r\nHere is what the new trace code looks like:\r\n\r\n    jit::tracer::PreTraceInfo trace_info;\r\n    if (jit::tracer::isTracing( self, index )) {\r\n      trace_info = jit::tracer::preRecordTrace( \"index_fill\", { self, index } );\r\n      setattr(trace_info.n, jit::Symbol(\"dim\"), dim);\r\n      setattr(trace_info.n, jit::Symbol(\"value\"), value);\r\n    }\r\n    baseType->index_fill_(self_, dim, index_, value);\r\n    increment_version(self);\r\n    rebase_history(self, grad_fn);\r\n    if (trace_info.state != nullptr) {\r\n      jit::tracer::postRecordTrace( trace_info,  { self } );\r\n    }\r\n\r\nSigned-off-by: Edward Z. Yang <ezyang@fb.com>"}