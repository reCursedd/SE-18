{"url": "https://api.github.com/repos/pytorch/pytorch/issues/987", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/987/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/987/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/987/events", "html_url": "https://github.com/pytorch/pytorch/issues/987", "id": 213641899, "node_id": "MDU6SXNzdWUyMTM2NDE4OTk=", "number": 987, "title": "Implement nn.Module.__dir__", "user": {"login": "wcbeard", "id": 379413, "node_id": "MDQ6VXNlcjM3OTQxMw==", "avatar_url": "https://avatars0.githubusercontent.com/u/379413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wcbeard", "html_url": "https://github.com/wcbeard", "followers_url": "https://api.github.com/users/wcbeard/followers", "following_url": "https://api.github.com/users/wcbeard/following{/other_user}", "gists_url": "https://api.github.com/users/wcbeard/gists{/gist_id}", "starred_url": "https://api.github.com/users/wcbeard/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wcbeard/subscriptions", "organizations_url": "https://api.github.com/users/wcbeard/orgs", "repos_url": "https://api.github.com/users/wcbeard/repos", "events_url": "https://api.github.com/users/wcbeard/events{/privacy}", "received_events_url": "https://api.github.com/users/wcbeard/received_events", "type": "User", "site_admin": false}, "labels": [{"id": 424131849, "node_id": "MDU6TGFiZWw0MjQxMzE4NDk=", "url": "https://api.github.com/repos/pytorch/pytorch/labels/enhancement", "name": "enhancement", "color": "84b6eb", "default": true}, {"id": 443484050, "node_id": "MDU6TGFiZWw0NDM0ODQwNTA=", "url": "https://api.github.com/repos/pytorch/pytorch/labels/medium%20priority", "name": "medium priority", "color": "fbca04", "default": false}], "state": "closed", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 5, "created_at": "2017-03-12T22:48:19Z", "updated_at": "2017-04-06T02:18:54Z", "closed_at": "2017-04-06T02:18:54Z", "author_association": "NONE", "body_html": "<p>If I create a module class and add a layer to it, I can't see this new layer when I try to use IPython's autocomplete. For example, with the the following class:</p>\n<pre><code>class Example(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.fully_connected = nn.Linear(20, 1)\n\nex = Example()\n</code></pre>\n<p>When I type <code>ex.f&lt;tab&gt;</code>, the only options are 'forward' and 'float'. And when I type <code>ex.fully_connected.b</code>, I don't get the completion option for the <code>bias</code> attribute.</p>\n<p>From my limited understanding, I think that this has to do with the strings that are returned with the <code>__dir__</code> method:</p>\n<pre><code>[attr for attr in ex.__dir__() if attr.startswith('f')]\n=&gt; ['forward', 'float']\n</code></pre>\n<p>So for the first issue, if I modify the class to have a method</p>\n<pre><code>def __dir__(self):\n    return super().__dir__() + list(self._modules)\n</code></pre>\n<p>then I get the <code>fully_connected</code> as a possible completion.</p>\n<p>I'm not sure if this is because of an intentional design decision, but it would be nice if all of the relevant possible attributes were available with the auto complete, as I'm still becoming familiar with this library.</p>", "body_text": "If I create a module class and add a layer to it, I can't see this new layer when I try to use IPython's autocomplete. For example, with the the following class:\nclass Example(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.fully_connected = nn.Linear(20, 1)\n\nex = Example()\n\nWhen I type ex.f<tab>, the only options are 'forward' and 'float'. And when I type ex.fully_connected.b, I don't get the completion option for the bias attribute.\nFrom my limited understanding, I think that this has to do with the strings that are returned with the __dir__ method:\n[attr for attr in ex.__dir__() if attr.startswith('f')]\n=> ['forward', 'float']\n\nSo for the first issue, if I modify the class to have a method\ndef __dir__(self):\n    return super().__dir__() + list(self._modules)\n\nthen I get the fully_connected as a possible completion.\nI'm not sure if this is because of an intentional design decision, but it would be nice if all of the relevant possible attributes were available with the auto complete, as I'm still becoming familiar with this library.", "body": "If I create a module class and add a layer to it, I can't see this new layer when I try to use IPython's autocomplete. For example, with the the following class:\r\n\r\n    class Example(nn.Module):\r\n        def __init__(self):\r\n            super().__init__()\r\n            self.fully_connected = nn.Linear(20, 1)\r\n\r\n    ex = Example()\r\n\r\nWhen I type `ex.f<tab>`, the only options are 'forward' and 'float'. And when I type `ex.fully_connected.b`, I don't get the completion option for the `bias` attribute.\r\n\r\nFrom my limited understanding, I think that this has to do with the strings that are returned with the `__dir__` method:\r\n\r\n    [attr for attr in ex.__dir__() if attr.startswith('f')]\r\n    => ['forward', 'float']\r\n    \r\nSo for the first issue, if I modify the class to have a method\r\n\r\n    def __dir__(self):\r\n        return super().__dir__() + list(self._modules)\r\n        \r\nthen I get the `fully_connected` as a possible completion.\r\n    \r\nI'm not sure if this is because of an intentional design decision, but it would be nice if all of the relevant possible attributes were available with the auto complete, as I'm still becoming familiar with this library.\r\n\r\n"}