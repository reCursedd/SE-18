{"url": "https://api.github.com/repos/pytorch/pytorch/issues/comments/433739096", "html_url": "https://github.com/pytorch/pytorch/pull/13186#issuecomment-433739096", "issue_url": "https://api.github.com/repos/pytorch/pytorch/issues/13186", "id": 433739096, "node_id": "MDEyOklzc3VlQ29tbWVudDQzMzczOTA5Ng==", "user": {"login": "apaszke", "id": 4583066, "node_id": "MDQ6VXNlcjQ1ODMwNjY=", "avatar_url": "https://avatars3.githubusercontent.com/u/4583066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apaszke", "html_url": "https://github.com/apaszke", "followers_url": "https://api.github.com/users/apaszke/followers", "following_url": "https://api.github.com/users/apaszke/following{/other_user}", "gists_url": "https://api.github.com/users/apaszke/gists{/gist_id}", "starred_url": "https://api.github.com/users/apaszke/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apaszke/subscriptions", "organizations_url": "https://api.github.com/users/apaszke/orgs", "repos_url": "https://api.github.com/users/apaszke/repos", "events_url": "https://api.github.com/users/apaszke/events{/privacy}", "received_events_url": "https://api.github.com/users/apaszke/received_events", "type": "User", "site_admin": false}, "created_at": "2018-10-28T20:35:41Z", "updated_at": "2018-10-28T20:35:49Z", "author_association": "MEMBER", "body_html": "<p>Yeah I know what circular convolution is, my point is that no one should really use that CPU code that computes the Toeplitz matrix. It's extremely memory hungry and very slow compared to cuDNN/MKLDNN. What we should do instead would be a native function which computes something like this:</p>\n<div class=\"highlight highlight-source-python\"><pre><span class=\"pl-k\">def</span> <span class=\"pl-en\">circular_conv</span>(<span class=\"pl-smi\">x</span>, <span class=\"pl-k\">*</span><span class=\"pl-smi\">args</span>):\n  end_slice_of_x <span class=\"pl-k\">=</span> x[<span class=\"pl-k\">-</span>kernel_size:] <span class=\"pl-c\"><span class=\"pl-c\">#</span> not sure if should be kernel_size, but probably some function of it</span>\n  begin_slice_of_x <span class=\"pl-k\">=</span> x[:kernel_size]\n  <span class=\"pl-k\">return</span> regular_conv(torch.cat([end_slice_of_x, x, begin_slice_of_x]), <span class=\"pl-k\">*</span>args)</pre></div>", "body_text": "Yeah I know what circular convolution is, my point is that no one should really use that CPU code that computes the Toeplitz matrix. It's extremely memory hungry and very slow compared to cuDNN/MKLDNN. What we should do instead would be a native function which computes something like this:\ndef circular_conv(x, *args):\n  end_slice_of_x = x[-kernel_size:] # not sure if should be kernel_size, but probably some function of it\n  begin_slice_of_x = x[:kernel_size]\n  return regular_conv(torch.cat([end_slice_of_x, x, begin_slice_of_x]), *args)", "body": "Yeah I know what circular convolution is, my point is that no one should really use that CPU code that computes the Toeplitz matrix. It's extremely memory hungry and very slow compared to cuDNN/MKLDNN. What we should do instead would be a native function which computes something like this:\r\n```python\r\ndef circular_conv(x, *args):\r\n  end_slice_of_x = x[-kernel_size:] # not sure if should be kernel_size, but probably some function of it\r\n  begin_slice_of_x = x[:kernel_size]\r\n  return regular_conv(torch.cat([end_slice_of_x, x, begin_slice_of_x]), *args)\r\n```"}