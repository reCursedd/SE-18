{"url": "https://api.github.com/repos/pytorch/pytorch/issues/10172", "repository_url": "https://api.github.com/repos/pytorch/pytorch", "labels_url": "https://api.github.com/repos/pytorch/pytorch/issues/10172/labels{/name}", "comments_url": "https://api.github.com/repos/pytorch/pytorch/issues/10172/comments", "events_url": "https://api.github.com/repos/pytorch/pytorch/issues/10172/events", "html_url": "https://github.com/pytorch/pytorch/issues/10172", "id": 347127890, "node_id": "MDU6SXNzdWUzNDcxMjc4OTA=", "number": 10172, "title": "[Feature request] Batch eig/symeig functions (for small matrices, with CUDA)", "user": {"login": "gpleiss", "id": 824157, "node_id": "MDQ6VXNlcjgyNDE1Nw==", "avatar_url": "https://avatars0.githubusercontent.com/u/824157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gpleiss", "html_url": "https://github.com/gpleiss", "followers_url": "https://api.github.com/users/gpleiss/followers", "following_url": "https://api.github.com/users/gpleiss/following{/other_user}", "gists_url": "https://api.github.com/users/gpleiss/gists{/gist_id}", "starred_url": "https://api.github.com/users/gpleiss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gpleiss/subscriptions", "organizations_url": "https://api.github.com/users/gpleiss/orgs", "repos_url": "https://api.github.com/users/gpleiss/repos", "events_url": "https://api.github.com/users/gpleiss/events{/privacy}", "received_events_url": "https://api.github.com/users/gpleiss/received_events", "type": "User", "site_admin": false}, "labels": [], "state": "open", "locked": false, "assignee": null, "assignees": [], "milestone": null, "comments": 1, "created_at": "2018-08-02T18:38:23Z", "updated_at": "2018-08-02T20:49:22Z", "closed_at": null, "author_association": "NONE", "body_html": "<p><strong>Proposed</strong> - add <code>torch.geevj</code> and <code>torch.syevj</code> calls, which hook into cuSolver's jacobi-based eigensolvers. These functions could operate on matrices or batches of matrices (that are smaller than 32x32).</p>\n<p><strong>Long</strong> - there are two issues:</p>\n<ul>\n<li>For small matrices (e.g. &lt;32x32 matrices), <code>eig</code> and <code>symeig</code> are much slower for cuda matrices than cpu matrices.</li>\n<li>It would be useful to run <code>eig</code>/<code>symeig</code> on batches of (small) matrices.</li>\n</ul>\n<pre><code>In [8]: %timeit ac.symeig()  # CUDA 32x32 matrix\n19.1 ms \u00b1 840 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n\nIn [9]: %timeit a.symeig()  # CPU 32x32 matrix\n40.8 \u00b5s \u00b1 672 ns per loop (mean \u00b1 std. dev. of 7 runs, 10000 loops each)\n</code></pre>\n<p>cuSolver has Jacobi-based eigensolvers (<code>geevj</code> and <code>syevj</code>), and batched versions of these solvers as well. They are faster for small/medium sized matrices. The only limitation of these functions is that the batched version of <code>geevj</code> and <code>syevj</code> only operate on matrices smaller than 32x32.</p>\n<p>It would be nice to have calls in torch (<code>torch.geevj</code> and <code>torch.syevj</code>) that hook into these functions.</p>\n<p>cc/ <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=4016393\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/jacobrgardner\">@jacobrgardner</a> <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=1605878\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/Balandat\">@Balandat</a> <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=792198\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/darbour\">@darbour</a></p>", "body_text": "Proposed - add torch.geevj and torch.syevj calls, which hook into cuSolver's jacobi-based eigensolvers. These functions could operate on matrices or batches of matrices (that are smaller than 32x32).\nLong - there are two issues:\n\nFor small matrices (e.g. <32x32 matrices), eig and symeig are much slower for cuda matrices than cpu matrices.\nIt would be useful to run eig/symeig on batches of (small) matrices.\n\nIn [8]: %timeit ac.symeig()  # CUDA 32x32 matrix\n19.1 ms \u00b1 840 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\n\nIn [9]: %timeit a.symeig()  # CPU 32x32 matrix\n40.8 \u00b5s \u00b1 672 ns per loop (mean \u00b1 std. dev. of 7 runs, 10000 loops each)\n\ncuSolver has Jacobi-based eigensolvers (geevj and syevj), and batched versions of these solvers as well. They are faster for small/medium sized matrices. The only limitation of these functions is that the batched version of geevj and syevj only operate on matrices smaller than 32x32.\nIt would be nice to have calls in torch (torch.geevj and torch.syevj) that hook into these functions.\ncc/ @jacobrgardner @Balandat @darbour", "body": "**Proposed** - add `torch.geevj` and `torch.syevj` calls, which hook into cuSolver's jacobi-based eigensolvers. These functions could operate on matrices or batches of matrices (that are smaller than 32x32).\r\n\r\n**Long** - there are two issues:\r\n\r\n- For small matrices (e.g. <32x32 matrices), `eig` and `symeig` are much slower for cuda matrices than cpu matrices.\r\n- It would be useful to run `eig`/`symeig` on batches of (small) matrices.\r\n\r\n```\r\nIn [8]: %timeit ac.symeig()  # CUDA 32x32 matrix\r\n19.1 ms \u00b1 840 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)\r\n\r\nIn [9]: %timeit a.symeig()  # CPU 32x32 matrix\r\n40.8 \u00b5s \u00b1 672 ns per loop (mean \u00b1 std. dev. of 7 runs, 10000 loops each)\r\n```\r\n\r\ncuSolver has Jacobi-based eigensolvers (`geevj` and `syevj`), and batched versions of these solvers as well. They are faster for small/medium sized matrices. The only limitation of these functions is that the batched version of `geevj` and `syevj` only operate on matrices smaller than 32x32.\r\n\r\nIt would be nice to have calls in torch (`torch.geevj` and `torch.syevj`) that hook into these functions.\r\n\r\ncc/ @jacobrgardner @Balandat @darbour"}