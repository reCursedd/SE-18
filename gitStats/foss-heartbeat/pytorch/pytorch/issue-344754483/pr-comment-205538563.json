{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/205538563", "pull_request_review_id": 140829407, "id": 205538563, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwNTUzODU2Mw==", "diff_hunk": "@@ -708,90 +709,53 @@ def prepare(cls, model, device='CPU', raw_values_dict=None, **kwargs):\n \n         model = onnx.shape_inference.infer_shapes(model)\n \n-        # Check whether we have RNN related ops\n-        pred_model = cls.optimize_onnx(model, predict=True)\n-        rnn_nodes = []\n-        for node in pred_model.graph.node:\n-            if node.op_type in {'LSTM', 'GRU', 'RNN'}:\n-                rnn_nodes.append(node)\n-\n-        # Build the C++ backend\n-        # TODO: build a predictor that supports GPU\n-        #       And for RNN nets, we need to avoid adding init_net\n-        use_cpp_backend = device == 'CPU' and not rnn_nodes\n-        # use python backend for now\n-        use_cpp_backend = False\n-        if use_cpp_backend:\n-            c2_rnn_ops = []\n-            if rnn_nodes:\n-                init_model = cls.optimize_onnx(model, init=True)\n-                for node in rnn_nodes:\n-                    c2ops = cls._onnx_node_to_caffe2_op(\n-                        init_model, pred_model, node, opset_version)\n-                    init_ops = [x.SerializeToString() for x in c2ops.init_ops]\n-                    ops = [x.SerializeToString() for x in c2ops.ops]\n-                    external_inputs = c2ops.interface_blobs\n-                    c2_rnn_ops.append(C.Caffe2Ops(init_ops, ops, external_inputs))\n-                del init_model\n-\n-            cbackend = C.Caffe2Backend(cls._dummy_name)\n-            if raw_values_dict:\n-                cls._external_value_resolution_pass(model, raw_values_dict)\n-            rep = cbackend.prepare(model.SerializeToString(), device, c2_rnn_ops)\n-            # For testing\n-            # Dump the net descriptions to file for comparison with the Python ones\n-            if \"ONNX_CAFFE2_DEBUG\" in os.environ:\n-                pred_net_str = rep.pred_net()\n-                pn = caffe2_pb2.NetDef()\n-                pn.ParseFromString(pred_net_str)\n-                init_net_str = rep.init_net()\n-                inn = caffe2_pb2.NetDef()\n-                inn.ParseFromString(init_net_str)\n-                with open(\"cpp.txt\", \"w\") as f:\n-                    f.write(\"pred_net: \\n{}\".format(pn))\n-\n-            rep_wrapper = Caffe2CppRep(rep)\n-            return rep_wrapper\n-        else:\n-            ws = Workspace()\n-            device_option = get_device_option(Device(device))\n+        ws = Workspace()\n+        device_option = get_device_option(Device(device))\n \n-            init_net, predict_net = cls._onnx_model_to_caffe2_net(model, device, opset_version, False)\n+        init_net, predict_net = cls._onnx_model_to_caffe2_net(model, device, opset_version, False)\n \n-            if raw_values_dict:\n-                cls._external_value_resolution_pass(model, raw_values_dict)\n+        if raw_values_dict:\n+            cls._external_value_resolution_pass(model, raw_values_dict)\n \n-            # Directly load initializer data into blobs in workspace\n-            cls._direct_initialize_parameters(\n-                model.graph.initializer,\n-                ws,\n-                device_option,\n-            )\n+        # Directly load initializer data into blobs in workspace\n+        cls._direct_initialize_parameters(\n+            model.graph.initializer,\n+            ws,\n+            device_option,\n+        )\n \n-            initialized = {init.name for init in model.graph.initializer}\n+        initialized = {init.name for init in model.graph.initializer}\n \n-            cls._direct_initialize_inputs(\n-                model.graph.input,\n-                initialized,\n-                ws,\n-                device_option,\n-            )\n+        cls._direct_initialize_inputs(\n+            model.graph.input,\n+            initialized,\n+            ws,\n+            device_option,\n+        )\n \n-            uninitialized = [value_info.name for value_info in model.graph.input if value_info.name not in initialized]\n+        uninitialized = [value_info.name for value_info in model.graph.input if value_info.name not in initialized]\n \n-            if \"ONNX_CAFFE2_DEBUG\" in os.environ:\n-                with open(\"python.txt\", \"w\") as f:\n-                    f.write(\"pred_net: \\n{}\".format(predict_net))\n-            retval = Caffe2Rep(init_net, predict_net, ws, uninitialized)\n-            return retval\n+        retval = Caffe2Rep(init_net, predict_net, ws, uninitialized)\n+        return retval\n \n \n     @classmethod\n     # TODO: This method needs a refactor for clarity\n     def _onnx_node_to_caffe2_op(cls, init_model, pred_model, node_def, opset_version):\n         cbackend = C.Caffe2Backend(cls._dummy_name)\n         if cbackend.support_onnx_import(node_def.op_type):\n-            op_strs = cbackend.convert_node(node_def.SerializeToString(), opset_version)\n+\n+            # extract value infos from pred model (value infos of\n+            # node's inputs that are in init model should be all\n+            # available in pred model)\n+            value_infos = []\n+            for name in node_def.input:\n+                if pred_model is not None:\n+                    for vi in itertools.chain(pred_model.graph.input, pred_model.graph.output):", "path": "caffe2/python/onnx/backend.py", "position": null, "original_position": 161, "commit_id": "ad9fbac5efcd2fa28fb633972569eba09054768e", "original_commit_id": "aa78090a98f8daa3a4d0db3422b44ef135194be7", "user": {"login": "houseroad", "id": 30275821, "node_id": "MDQ6VXNlcjMwMjc1ODIx", "avatar_url": "https://avatars0.githubusercontent.com/u/30275821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/houseroad", "html_url": "https://github.com/houseroad", "followers_url": "https://api.github.com/users/houseroad/followers", "following_url": "https://api.github.com/users/houseroad/following{/other_user}", "gists_url": "https://api.github.com/users/houseroad/gists{/gist_id}", "starred_url": "https://api.github.com/users/houseroad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/houseroad/subscriptions", "organizations_url": "https://api.github.com/users/houseroad/orgs", "repos_url": "https://api.github.com/users/houseroad/repos", "events_url": "https://api.github.com/users/houseroad/events{/privacy}", "received_events_url": "https://api.github.com/users/houseroad/received_events", "type": "User", "site_admin": false}, "body": "Also add pred_model.graph.value_info?", "created_at": "2018-07-26T17:25:26Z", "updated_at": "2018-11-23T15:48:14Z", "html_url": "https://github.com/pytorch/pytorch/pull/9870#discussion_r205538563", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/9870", "author_association": "MEMBER", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/205538563"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/9870#discussion_r205538563"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/9870"}}, "body_html": "<p>Also add pred_model.graph.value_info?</p>", "body_text": "Also add pred_model.graph.value_info?"}