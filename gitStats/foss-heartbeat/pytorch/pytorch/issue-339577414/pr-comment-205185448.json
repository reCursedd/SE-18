{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/205185448", "pull_request_review_id": 140406071, "id": 205185448, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwNTE4NTQ0OA==", "diff_hunk": "@@ -90,32 +92,55 @@ SparseTensor new_with_tensor_sparse(const LongTensor& indices, const Tensor& val\n   int64_t denseDims = values.dim() - 1;\n \n   std::vector<int64_t> computed_sizes(sparseDims + denseDims);\n-  // NB: It used to keepdim. I think that was wrong.\n-  LongTensor computed_indices_sizes = std::get</* values */ 0>(indices.max(/* dim */ 1, /* keepdim */ false));\n-  computed_indices_sizes.add_(1); // len = max_index + 1\n-  LongTensor cpu_computed_indices_sizes;\n-  if (computed_indices_sizes.is_cuda()) {\n-    cpu_computed_indices_sizes = at::CPU(kLong).tensor(computed_indices_sizes.sizes());\n-    cpu_computed_indices_sizes.copy_(computed_indices_sizes);\n+  if (indices.numel() > 0) {\n+    // NB: It used to keepdim. I think that was wrong.\n+    LongTensor computed_indices_sizes = std::get</* values */ 0>(indices.max(/* dim */ 1, /* keepdim */ false));\n+    computed_indices_sizes.add_(1); // len = max_index + 1\n+    LongTensor cpu_computed_indices_sizes;\n+    if (computed_indices_sizes.is_cuda()) {\n+      cpu_computed_indices_sizes = at::CPU(kLong).tensor(computed_indices_sizes.sizes());\n+      cpu_computed_indices_sizes.copy_(computed_indices_sizes);\n+    } else {\n+      cpu_computed_indices_sizes = computed_indices_sizes;\n+    }\n+    auto cpu_computed_indices_sizes_accessor = cpu_computed_indices_sizes.accessor<int64_t, 1>();\n+    for (int64_t d = 0; d < sparseDims; d++) {\n+      computed_sizes[static_cast<size_t>(d)] = cpu_computed_indices_sizes_accessor[d];\n+    }\n   } else {\n-    cpu_computed_indices_sizes = computed_indices_sizes;\n-  }\n-  auto cpu_computed_indices_sizes_accessor = cpu_computed_indices_sizes.accessor<int64_t, 1>();\n-  for (int64_t d = 0; d < sparseDims; d++) {\n-    computed_sizes[static_cast<size_t>(d)] = cpu_computed_indices_sizes_accessor[d];\n+    for (int64_t d = 0; d < sparseDims; d++) {\n+      computed_sizes[static_cast<size_t>(d)] = 0;", "path": "aten/src/ATen/native/sparse/SparseTensor.cpp", "position": null, "original_position": 46, "commit_id": "f7b1f23e8f85e8484934de71c9708933421009d0", "original_commit_id": "5c83f2537455f5a108e8ac356844b4e99adc664c", "user": {"login": "yf225", "id": 4063635, "node_id": "MDQ6VXNlcjQwNjM2MzU=", "avatar_url": "https://avatars0.githubusercontent.com/u/4063635?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yf225", "html_url": "https://github.com/yf225", "followers_url": "https://api.github.com/users/yf225/followers", "following_url": "https://api.github.com/users/yf225/following{/other_user}", "gists_url": "https://api.github.com/users/yf225/gists{/gist_id}", "starred_url": "https://api.github.com/users/yf225/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yf225/subscriptions", "organizations_url": "https://api.github.com/users/yf225/orgs", "repos_url": "https://api.github.com/users/yf225/repos", "events_url": "https://api.github.com/users/yf225/events{/privacy}", "received_events_url": "https://api.github.com/users/yf225/received_events", "type": "User", "site_admin": false}, "body": "Do you have an example that I can reproduce? I think this constructor is for creating a sparse tensor with only `indices` and `values` and no size info, and in the normal case we infer the sparse dim part of the size as the max value of each dim in `indices`. But if the `indices` doesn't have elements in it, there is not enough information to know what the the sparse dimension sizes should be, and in this case I set them to 0. I think there might be some use cases that I am still overlooking and should add test cases for.", "created_at": "2018-07-25T16:55:31Z", "updated_at": "2018-11-23T15:48:05Z", "html_url": "https://github.com/pytorch/pytorch/pull/9279#discussion_r205185448", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/9279", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/205185448"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/9279#discussion_r205185448"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/9279"}}, "body_html": "<p>Do you have an example that I can reproduce? I think this constructor is for creating a sparse tensor with only <code>indices</code> and <code>values</code> and no size info, and in the normal case we infer the sparse dim part of the size as the max value of each dim in <code>indices</code>. But if the <code>indices</code> doesn't have elements in it, there is not enough information to know what the the sparse dimension sizes should be, and in this case I set them to 0. I think there might be some use cases that I am still overlooking and should add test cases for.</p>", "body_text": "Do you have an example that I can reproduce? I think this constructor is for creating a sparse tensor with only indices and values and no size info, and in the normal case we infer the sparse dim part of the size as the max value of each dim in indices. But if the indices doesn't have elements in it, there is not enough information to know what the the sparse dimension sizes should be, and in this case I set them to 0. I think there might be some use cases that I am still overlooking and should add test cases for.", "in_reply_to_id": 204580252}