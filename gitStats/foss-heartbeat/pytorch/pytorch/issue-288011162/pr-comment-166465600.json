{"url": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/166465600", "pull_request_review_id": 94532222, "id": 166465600, "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE2NjQ2NTYwMA==", "diff_hunk": "@@ -181,7 +181,28 @@ void encodeGraph(onnx::GraphProto * p_g, const std::shared_ptr<Graph> & g, const\n   JIT_ASSERT(p_g != nullptr);\n   p_g->set_name(\"torch-jit-export\");\n \n+  // The jit tracer may record some unnecessary information.\n+  // We should remove the unused input and initializer.\n+  // Gather all the names of useful nodes and filter out unused ones.\n+  std::unordered_set<std::string> useful_names;\n+  std::vector<std::string> input_names;\n+  for (auto node : g->nodes()) {\n+    for(auto input : node->inputs()) {\n+      useful_names.insert(value_name(input));\n+    }\n+    for(auto output : node->outputs()) {\n+      useful_names.insert(value_name(output));\n+    }\n+  }\n+  for (auto output : g->outputs()) {\n+    useful_names.insert(value_name(output));\n+  }\n+\n   for (auto input : g->inputs()) {\n+    input_names.push_back(value_name(input));\n+    if (useful_names.find(value_name(input)) == useful_names.end()) {\n+      continue;", "path": "torch/csrc/jit/export.cpp", "position": null, "original_position": 24, "commit_id": "6f870f5c329e3e94c9f6b743a0ef40ed56e61b02", "original_commit_id": "72f71e0d599c428d043187b0491071756f0a020a", "user": {"login": "ezyang", "id": 13564, "node_id": "MDQ6VXNlcjEzNTY0", "avatar_url": "https://avatars0.githubusercontent.com/u/13564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ezyang", "html_url": "https://github.com/ezyang", "followers_url": "https://api.github.com/users/ezyang/followers", "following_url": "https://api.github.com/users/ezyang/following{/other_user}", "gists_url": "https://api.github.com/users/ezyang/gists{/gist_id}", "starred_url": "https://api.github.com/users/ezyang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ezyang/subscriptions", "organizations_url": "https://api.github.com/users/ezyang/orgs", "repos_url": "https://api.github.com/users/ezyang/repos", "events_url": "https://api.github.com/users/ezyang/events{/privacy}", "received_events_url": "https://api.github.com/users/ezyang/received_events", "type": "User", "site_admin": false}, "body": "@dzhulgakov I think this is an orthogonal issue.\r\n\r\nThe basic problem is, suppose you have a model (subclass `torch.autograd.Module`) in PyTorch. You know what the arity of the model is (e.g., it takes one input.) You run an ONNX export. Now you have a graph which takes 1 + some big pile of parameters which are not named in any way. How do you figure out what these parameters mean? Since we don't have names on them, you only know what they are if you can construct a correspondence between each PyTorch weight and the position in it. The way we implemented it previously was to use the ordering of `state_dict()` (which is an ordered dict) to do it.\r\n\r\nHere's another way to solve it: we could add \"external labels\" to inputs; these are meaningful strings that someone executing an ONNX graph can make use of. The key is to NOT have this label coincide with the internal name we refer to the input with. So, for example, instead of `graph %0, %1 { ... }` we have `graph (input: %0, weights: %1) { ... }` and you still refer to input as `%0` inside. That will solve the problem that torpedoed https://github.com/pytorch/pytorch/pull/2697", "created_at": "2018-02-06T22:39:37Z", "updated_at": "2018-11-23T15:39:16Z", "html_url": "https://github.com/pytorch/pytorch/pull/4626#discussion_r166465600", "pull_request_url": "https://api.github.com/repos/pytorch/pytorch/pulls/4626", "author_association": "CONTRIBUTOR", "_links": {"self": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/comments/166465600"}, "html": {"href": "https://github.com/pytorch/pytorch/pull/4626#discussion_r166465600"}, "pull_request": {"href": "https://api.github.com/repos/pytorch/pytorch/pulls/4626"}}, "body_html": "<p><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/hovercards?user_id=17890620\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/dzhulgakov\">@dzhulgakov</a> I think this is an orthogonal issue.</p>\n<p>The basic problem is, suppose you have a model (subclass <code>torch.autograd.Module</code>) in PyTorch. You know what the arity of the model is (e.g., it takes one input.) You run an ONNX export. Now you have a graph which takes 1 + some big pile of parameters which are not named in any way. How do you figure out what these parameters mean? Since we don't have names on them, you only know what they are if you can construct a correspondence between each PyTorch weight and the position in it. The way we implemented it previously was to use the ordering of <code>state_dict()</code> (which is an ordered dict) to do it.</p>\n<p>Here's another way to solve it: we could add \"external labels\" to inputs; these are meaningful strings that someone executing an ONNX graph can make use of. The key is to NOT have this label coincide with the internal name we refer to the input with. So, for example, instead of <code>graph %0, %1 { ... }</code> we have <code>graph (input: %0, weights: %1) { ... }</code> and you still refer to input as <code>%0</code> inside. That will solve the problem that torpedoed <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"256854210\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/pytorch/pytorch/issues/2697\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/pytorch/pytorch/pull/2697/hovercard\" href=\"https://github.com/pytorch/pytorch/pull/2697\">#2697</a></p>", "body_text": "@dzhulgakov I think this is an orthogonal issue.\nThe basic problem is, suppose you have a model (subclass torch.autograd.Module) in PyTorch. You know what the arity of the model is (e.g., it takes one input.) You run an ONNX export. Now you have a graph which takes 1 + some big pile of parameters which are not named in any way. How do you figure out what these parameters mean? Since we don't have names on them, you only know what they are if you can construct a correspondence between each PyTorch weight and the position in it. The way we implemented it previously was to use the ordering of state_dict() (which is an ordered dict) to do it.\nHere's another way to solve it: we could add \"external labels\" to inputs; these are meaningful strings that someone executing an ONNX graph can make use of. The key is to NOT have this label coincide with the internal name we refer to the input with. So, for example, instead of graph %0, %1 { ... } we have graph (input: %0, weights: %1) { ... } and you still refer to input as %0 inside. That will solve the problem that torpedoed #2697", "in_reply_to_id": 161825617}